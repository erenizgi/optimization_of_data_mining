{
    "author": "petebacondarwin",
    "message": "refactor(compiler-cli): make the output AST translator generic (#38775)\n\nThis commit refactors the `ExpressionTranslatorVisitor` so that it\nis not tied directly to the TypeScript AST. Instead it uses generic\n`TExpression` and `TStatement` types that are then converted\nto concrete types by the `TypeScriptAstFactory`.\n\nThis paves the way for a `BabelAstFactory` that can be used to\ngenerate Babel AST nodes instead of TypeScript, which will be\npart of the new linker tool.\n\nPR Close #38775",
    "sha": "297b123151efe59a80bde74e719999bcc7e1f077",
    "files": [
        {
            "sha": "962f94ad29dfbfee49ed7f737909b1fef7750511",
            "filename": "packages/compiler-cli/ngcc/src/rendering/commonjs_rendering_formatter.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fcommonjs_rendering_formatter.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fcommonjs_rendering_formatter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fcommonjs_rendering_formatter.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -55,7 +55,7 @@ export class CommonJsRenderingFormatter extends Esm5RenderingFormatter {\n       const namedImport = entryPointBasePath !== basePath ?\n           importManager.generateNamedImport(relativePath, e.identifier) :\n           {symbol: e.identifier, moduleImport: null};\n-      const importNamespace = namedImport.moduleImport ? `${namedImport.moduleImport}.` : '';\n+      const importNamespace = namedImport.moduleImport ? `${namedImport.moduleImport.text}.` : '';\n       const exportStr = `\\nexports.${e.identifier} = ${importNamespace}${namedImport.symbol};`;\n       output.append(exportStr);\n     });\n@@ -66,7 +66,7 @@ export class CommonJsRenderingFormatter extends Esm5RenderingFormatter {\n       file: ts.SourceFile): void {\n     for (const e of exports) {\n       const namedImport = importManager.generateNamedImport(e.fromModule, e.symbolName);\n-      const importNamespace = namedImport.moduleImport ? `${namedImport.moduleImport}.` : '';\n+      const importNamespace = namedImport.moduleImport ? `${namedImport.moduleImport.text}.` : '';\n       const exportStr = `\\nexports.${e.asAlias} = ${importNamespace}${namedImport.symbol};`;\n       output.append(exportStr);\n     }"
        },
        {
            "sha": "8cb3e68310e141662739f32c1da2a83bb175408c",
            "filename": "packages/compiler-cli/ngcc/src/rendering/esm5_rendering_formatter.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fesm5_rendering_formatter.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fesm5_rendering_formatter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fesm5_rendering_formatter.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -9,7 +9,6 @@ import {Statement} from '@angular/compiler';\n import MagicString from 'magic-string';\n import * as ts from 'typescript';\n \n-import {NOOP_DEFAULT_IMPORT_RECORDER} from '../../../src/ngtsc/imports';\n import {ImportManager, translateStatement} from '../../../src/ngtsc/translator';\n import {CompiledClass} from '../analysis/types';\n import {getContainingStatement} from '../host/esm2015_host';\n@@ -65,8 +64,9 @@ export class Esm5RenderingFormatter extends EsmRenderingFormatter {\n    * @return The JavaScript code corresponding to `stmt` (in the appropriate format).\n    */\n   printStatement(stmt: Statement, sourceFile: ts.SourceFile, importManager: ImportManager): string {\n-    const node =\n-        translateStatement(stmt, importManager, NOOP_DEFAULT_IMPORT_RECORDER, ts.ScriptTarget.ES5);\n+    const node = translateStatement(\n+        stmt, importManager,\n+        {downlevelLocalizedStrings: true, downlevelVariableDeclarations: true});\n     const code = this.printer.printNode(ts.EmitHint.Unspecified, node, sourceFile);\n \n     return code;"
        },
        {
            "sha": "28aeaec3b15606e249f60d14178fbf00424b8578",
            "filename": "packages/compiler-cli/ngcc/src/rendering/esm_rendering_formatter.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 6,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fesm_rendering_formatter.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fesm_rendering_formatter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fesm_rendering_formatter.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -10,7 +10,7 @@ import MagicString from 'magic-string';\n import * as ts from 'typescript';\n \n import {absoluteFromSourceFile, AbsoluteFsPath, dirname, relative, toRelativeImport} from '../../../src/ngtsc/file_system';\n-import {NOOP_DEFAULT_IMPORT_RECORDER, Reexport} from '../../../src/ngtsc/imports';\n+import {Reexport} from '../../../src/ngtsc/imports';\n import {Import, ImportManager, translateStatement} from '../../../src/ngtsc/translator';\n import {isDtsPath} from '../../../src/ngtsc/util/src/typescript';\n import {ModuleWithProvidersInfo} from '../analysis/module_with_providers_analyzer';\n@@ -247,8 +247,7 @@ export class EsmRenderingFormatter implements RenderingFormatter {\n    * @return The JavaScript code corresponding to `stmt` (in the appropriate format).\n    */\n   printStatement(stmt: Statement, sourceFile: ts.SourceFile, importManager: ImportManager): string {\n-    const node = translateStatement(\n-        stmt, importManager, NOOP_DEFAULT_IMPORT_RECORDER, ts.ScriptTarget.ES2015);\n+    const node = translateStatement(stmt, importManager);\n     const code = this.printer.printNode(ts.EmitHint.Unspecified, node, sourceFile);\n \n     return code;\n@@ -264,8 +263,6 @@ export class EsmRenderingFormatter implements RenderingFormatter {\n     return 0;\n   }\n \n-\n-\n   /**\n    * Check whether the given type is the core Angular `ModuleWithProviders` interface.\n    * @param typeName The type to check.\n@@ -292,7 +289,8 @@ function findStatement(node: ts.Node): ts.Statement|undefined {\n function generateImportString(\n     importManager: ImportManager, importPath: string|null, importName: string) {\n   const importAs = importPath ? importManager.generateNamedImport(importPath, importName) : null;\n-  return importAs ? `${importAs.moduleImport}.${importAs.symbol}` : `${importName}`;\n+  return importAs && importAs.moduleImport ? `${importAs.moduleImport.text}.${importAs.symbol}` :\n+                                             `${importName}`;\n }\n \n function getNextSiblingInArray<T extends ts.Node>(node: T, array: ts.NodeArray<T>): T|null {"
        },
        {
            "sha": "3fbf9755de0f4484114940a26da609b79727611f",
            "filename": "packages/compiler-cli/ngcc/src/rendering/umd_rendering_formatter.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fumd_rendering_formatter.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fumd_rendering_formatter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fumd_rendering_formatter.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -91,7 +91,7 @@ export class UmdRenderingFormatter extends Esm5RenderingFormatter {\n       const namedImport = entryPointBasePath !== basePath ?\n           importManager.generateNamedImport(relativePath, e.identifier) :\n           {symbol: e.identifier, moduleImport: null};\n-      const importNamespace = namedImport.moduleImport ? `${namedImport.moduleImport}.` : '';\n+      const importNamespace = namedImport.moduleImport ? `${namedImport.moduleImport.text}.` : '';\n       const exportStr = `\\nexports.${e.identifier} = ${importNamespace}${namedImport.symbol};`;\n       output.appendRight(insertionPoint, exportStr);\n     });\n@@ -111,7 +111,7 @@ export class UmdRenderingFormatter extends Esm5RenderingFormatter {\n         lastStatement ? lastStatement.getEnd() : factoryFunction.body.getEnd() - 1;\n     for (const e of exports) {\n       const namedImport = importManager.generateNamedImport(e.fromModule, e.symbolName);\n-      const importNamespace = namedImport.moduleImport ? `${namedImport.moduleImport}.` : '';\n+      const importNamespace = namedImport.moduleImport ? `${namedImport.moduleImport.text}.` : '';\n       const exportStr = `\\nexports.${e.asAlias} = ${importNamespace}${namedImport.symbol};`;\n       output.appendRight(insertionPoint, exportStr);\n     }"
        },
        {
            "sha": "78121b5dada58702c4b6a54c9d88c9f581f52051",
            "filename": "packages/compiler-cli/ngcc/test/rendering/renderer_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Frendering%2Frenderer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Frendering%2Frenderer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Frendering%2Frenderer_spec.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -13,7 +13,7 @@ import * as ts from 'typescript';\n \n import {absoluteFrom, getFileSystem} from '../../../src/ngtsc/file_system';\n import {runInEachFileSystem, TestFile} from '../../../src/ngtsc/file_system/testing';\n-import {NOOP_DEFAULT_IMPORT_RECORDER, Reexport} from '../../../src/ngtsc/imports';\n+import {Reexport} from '../../../src/ngtsc/imports';\n import {MockLogger} from '../../../src/ngtsc/logging/testing';\n import {Import, ImportManager, translateStatement} from '../../../src/ngtsc/translator';\n import {loadTestFiles} from '../../../test/helpers';\n@@ -65,8 +65,8 @@ class TestRenderingFormatter implements RenderingFormatter {\n   }\n   printStatement(stmt: Statement, sourceFile: ts.SourceFile, importManager: ImportManager): string {\n     const node = translateStatement(\n-        stmt, importManager, NOOP_DEFAULT_IMPORT_RECORDER,\n-        this.isEs5 ? ts.ScriptTarget.ES5 : ts.ScriptTarget.ES2015);\n+        stmt, importManager,\n+        {downlevelLocalizedStrings: this.isEs5, downlevelVariableDeclarations: this.isEs5});\n     const code = this.printer.printNode(ts.EmitHint.Unspecified, node, sourceFile);\n \n     return `// TRANSPILED\\n${code}`;"
        },
        {
            "sha": "9a09329bad1652cabbec2a01bf6f88a1e19fd759",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/metadata_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fmetadata_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fmetadata_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fmetadata_spec.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -133,8 +133,7 @@ runInEachFileSystem(() => {\n     }\n     const sf = getSourceFileOrError(program, _('/index.ts'));\n     const im = new ImportManager(new NoopImportRewriter(), 'i');\n-    const tsStatement =\n-        translateStatement(call, im, NOOP_DEFAULT_IMPORT_RECORDER, ts.ScriptTarget.ES2015);\n+    const tsStatement = translateStatement(call, im);\n     const res = ts.createPrinter().printNode(ts.EmitHint.Unspecified, tsStatement, sf);\n     return res.replace(/\\s+/g, ' ');\n   }"
        },
        {
            "sha": "96ea10d553d10e216574d81dbfffc264ae9f0104",
            "filename": "packages/compiler-cli/src/ngtsc/transform/src/transform.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 11,
            "changes": 36,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftransform.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftransform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftransform.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -11,7 +11,7 @@ import * as ts from 'typescript';\n \n import {DefaultImportRecorder, ImportRewriter} from '../../imports';\n import {Decorator, ReflectionHost} from '../../reflection';\n-import {ImportManager, translateExpression, translateStatement} from '../../translator';\n+import {ImportManager, RecordWrappedNodeExprFn, translateExpression, translateStatement} from '../../translator';\n import {visit, VisitListEntryResult, Visitor} from '../../util/src/visitor';\n \n import {CompileResult} from './api';\n@@ -35,11 +35,12 @@ export function ivyTransformFactory(\n     compilation: TraitCompiler, reflector: ReflectionHost, importRewriter: ImportRewriter,\n     defaultImportRecorder: DefaultImportRecorder, isCore: boolean,\n     isClosureCompilerEnabled: boolean): ts.TransformerFactory<ts.SourceFile> {\n+  const recordWrappedNodeExpr = createRecorderFn(defaultImportRecorder);\n   return (context: ts.TransformationContext): ts.Transformer<ts.SourceFile> => {\n     return (file: ts.SourceFile): ts.SourceFile => {\n       return transformIvySourceFile(\n           compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled,\n-          defaultImportRecorder);\n+          recordWrappedNodeExpr);\n     };\n   };\n }\n@@ -77,7 +78,7 @@ class IvyTransformationVisitor extends Visitor {\n       private compilation: TraitCompiler,\n       private classCompilationMap: Map<ts.ClassDeclaration, CompileResult[]>,\n       private reflector: ReflectionHost, private importManager: ImportManager,\n-      private defaultImportRecorder: DefaultImportRecorder,\n+      private recordWrappedNodeExpr: RecordWrappedNodeExprFn<ts.Expression>,\n       private isClosureCompilerEnabled: boolean, private isCore: boolean) {\n     super();\n   }\n@@ -97,8 +98,8 @@ class IvyTransformationVisitor extends Visitor {\n     for (const field of this.classCompilationMap.get(node)!) {\n       // Translate the initializer for the field into TS nodes.\n       const exprNode = translateExpression(\n-          field.initializer, this.importManager, this.defaultImportRecorder,\n-          ts.ScriptTarget.ES2015);\n+          field.initializer, this.importManager,\n+          {recordWrappedNodeExpr: this.recordWrappedNodeExpr});\n \n       // Create a static property declaration for the new field.\n       const property = ts.createProperty(\n@@ -118,7 +119,7 @@ class IvyTransformationVisitor extends Visitor {\n       field.statements\n           .map(\n               stmt => translateStatement(\n-                  stmt, this.importManager, this.defaultImportRecorder, ts.ScriptTarget.ES2015))\n+                  stmt, this.importManager, {recordWrappedNodeExpr: this.recordWrappedNodeExpr}))\n           .forEach(stmt => statements.push(stmt));\n \n       members.push(property);\n@@ -248,7 +249,7 @@ function transformIvySourceFile(\n     compilation: TraitCompiler, context: ts.TransformationContext, reflector: ReflectionHost,\n     importRewriter: ImportRewriter, file: ts.SourceFile, isCore: boolean,\n     isClosureCompilerEnabled: boolean,\n-    defaultImportRecorder: DefaultImportRecorder): ts.SourceFile {\n+    recordWrappedNodeExpr: RecordWrappedNodeExprFn<ts.Expression>): ts.SourceFile {\n   const constantPool = new ConstantPool(isClosureCompilerEnabled);\n   const importManager = new ImportManager(importRewriter);\n \n@@ -270,14 +271,18 @@ function transformIvySourceFile(\n   // results obtained at Step 1.\n   const transformationVisitor = new IvyTransformationVisitor(\n       compilation, compilationVisitor.classCompilationMap, reflector, importManager,\n-      defaultImportRecorder, isClosureCompilerEnabled, isCore);\n+      recordWrappedNodeExpr, isClosureCompilerEnabled, isCore);\n   let sf = visit(file, transformationVisitor, context);\n \n   // Generate the constant statements first, as they may involve adding additional imports\n   // to the ImportManager.\n-  const constants = constantPool.statements.map(\n-      stmt => translateStatement(\n-          stmt, importManager, defaultImportRecorder, getLocalizeCompileTarget(context)));\n+  const downlevelTranslatedCode = getLocalizeCompileTarget(context) < ts.ScriptTarget.ES2015;\n+  const constants =\n+      constantPool.statements.map(stmt => translateStatement(stmt, importManager, {\n+                                    recordWrappedNodeExpr,\n+                                    downlevelLocalizedStrings: downlevelTranslatedCode,\n+                                    downlevelVariableDeclarations: downlevelTranslatedCode,\n+                                  }));\n \n   // Preserve @fileoverview comments required by Closure, since the location might change as a\n   // result of adding extra imports and constant pool statements.\n@@ -360,3 +365,12 @@ function maybeFilterDecorator(\n function isFromAngularCore(decorator: Decorator): boolean {\n   return decorator.import !== null && decorator.import.from === '@angular/core';\n }\n+\n+function createRecorderFn(defaultImportRecorder: DefaultImportRecorder):\n+    RecordWrappedNodeExprFn<ts.Expression> {\n+  return expr => {\n+    if (ts.isIdentifier(expr)) {\n+      defaultImportRecorder.recordUsedIdentifier(expr);\n+    }\n+  };\n+}"
        },
        {
            "sha": "0df3249b78caf28632334e58b4f4638582a3d590",
            "filename": "packages/compiler-cli/src/ngtsc/translator/index.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Findex.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -6,6 +6,10 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-export {Import, ImportManager, NamedImport} from './src/import_manager';\n-export {attachComments, translateExpression, translateStatement} from './src/translator';\n-export {translateType} from './src/type_translator';\n\\ No newline at end of file\n+export {AstFactory, BinaryOperator, LeadingComment, ObjectLiteralProperty, SourceMapLocation, SourceMapRange, TemplateElement, TemplateLiteral, UnaryOperator} from './src/api/ast_factory';\n+export {Import, ImportGenerator, NamedImport} from './src/api/import_generator';\n+export {ImportManager} from './src/import_manager';\n+export {RecordWrappedNodeExprFn} from './src/translator';\n+export {translateType} from './src/type_translator';\n+export {attachComments, TypeScriptAstFactory} from './src/typescript_ast_factory';\n+export {translateExpression, translateStatement} from './src/typescript_translator';"
        },
        {
            "sha": "d8182f388590c123437a8178f734a77bbe2a0fa3",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/api/ast_factory.ts",
            "status": "added",
            "additions": 320,
            "deletions": 0,
            "changes": 320,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fapi%2Fast_factory.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fapi%2Fast_factory.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fapi%2Fast_factory.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -0,0 +1,320 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/**\n+ * Used to create transpiler specific AST nodes from Angular Output AST nodes in an abstract way.\n+ *\n+ * Note that the `AstFactory` makes no assumptions about the target language being generated.\n+ * It is up to the caller to do this - e.g. only call `createTaggedTemplate()` or pass `let`|`const`\n+ * to `createVariableDeclaration()` if the final JS will allow it.\n+ */\n+export interface AstFactory<TStatement, TExpression> {\n+  /**\n+   * Attach the `leadingComments` to the given `statement` node.\n+   *\n+   * @param statement the statement where the comment is to be attached.\n+   * @param leadingComments the comments to attach.\n+   * @returns the node passed in as `statement` with the comments attached.\n+   */\n+  attachComments(statement: TStatement, leadingComments?: LeadingComment[]): TStatement;\n+\n+  /**\n+   * Create a literal array expresion (e.g. `[expr1, expr2]`).\n+   *\n+   * @param elements a collection of the expressions to appear in each array slot.\n+   */\n+  createArrayLiteral(elements: TExpression[]): TExpression;\n+\n+  /**\n+   * Create an assignment expression (e.g. `lhsExpr = rhsExpr`).\n+   *\n+   * @param target an expression that evaluates to the left side of the assignment.\n+   * @param value an expression that evaluates to the right side of the assignment.\n+   */\n+  createAssignment(target: TExpression, value: TExpression): TExpression;\n+\n+  /**\n+   * Create a binary expression (e.g. `lhs && rhs`).\n+   *\n+   * @param leftOperand an expression that will appear on the left of the operator.\n+   * @param operator the binary operator that will be applied.\n+   * @param rightOperand an expression that will appear on the right of the operator.\n+   */\n+  createBinaryExpression(\n+      leftOperand: TExpression, operator: BinaryOperator, rightOperand: TExpression): TExpression;\n+\n+  /**\n+   * Create a block of statements (e.g. `{ stmt1; stmt2; }`).\n+   *\n+   * @param body an array of statements to be wrapped in a block.\n+   */\n+  createBlock(body: TStatement[]): TStatement;\n+\n+  /**\n+   * Create an expression that is calling the `callee` with the given `args`.\n+   *\n+   * @param callee an expression that evaluates to a function to be called.\n+   * @param args the arugments to be passed to the call.\n+   * @param pure whether to mark the call as pure (having no side-effects).\n+   */\n+  createCallExpression(callee: TExpression, args: TExpression[], pure: boolean): TExpression;\n+\n+  /**\n+   * Create a ternary expression (e.g. `testExpr ? trueExpr : falseExpr`).\n+   *\n+   * @param condition an expression that will be tested for truthiness.\n+   * @param thenExpression an expression that is executed if `condition` is truthy.\n+   * @param elseExpression an expression that is executed if `condition` is falsy.\n+   */\n+  createConditional(\n+      condition: TExpression, thenExpression: TExpression,\n+      elseExpression: TExpression): TExpression;\n+\n+  /**\n+   * Create an element access (e.g. `obj[expr]`).\n+   *\n+   * @param expression an expression that evaluates to the object to be accessed.\n+   * @param element an expression that evaluates to the element on the object.\n+   */\n+  createElementAccess(expression: TExpression, element: TExpression): TExpression;\n+\n+  /**\n+   * Create a statement that is simply executing the given `expression` (e.g. `x = 10;`).\n+   *\n+   * @param expression the expression to be converted to a statement.\n+   */\n+  createExpressionStatement(expression: TExpression): TStatement;\n+\n+  /**\n+   * Create a statement that declares a function (e.g. `function foo(param1, param2) { stmt; }`).\n+   *\n+   * @param functionName the name of the function.\n+   * @param parameters the names of the function's parameters.\n+   * @param body a statement (or a block of statements) that are the body of the function.\n+   */\n+  createFunctionDeclaration(functionName: string|null, parameters: string[], body: TStatement):\n+      TStatement;\n+\n+  /**\n+   * Create an expression that represents a function\n+   * (e.g. `function foo(param1, param2) { stmt; }`).\n+   *\n+   * @param functionName the name of the function.\n+   * @param parameters the names of the function's parameters.\n+   * @param body a statement (or a block of statements) that are the body of the function.\n+   */\n+  createFunctionExpression(functionName: string|null, parameters: string[], body: TStatement):\n+      TExpression;\n+\n+  /**\n+   * Create an identifier.\n+   *\n+   * @param name the name of the identifier.\n+   */\n+  createIdentifier(name: string): TExpression;\n+\n+  /**\n+   * Create an if statement (e.g. `if (testExpr) { trueStmt; } else { falseStmt; }`).\n+   *\n+   * @param condition an expression that will be tested for truthiness.\n+   * @param thenStatement a statement (or block of statements) that is executed if `condition` is\n+   *     truthy.\n+   * @param elseStatement a statement (or block of statements) that is executed if `condition` is\n+   *     falsy.\n+   */\n+  createIfStatement(\n+      condition: TExpression, thenStatement: TStatement,\n+      elseStatement: TStatement|null): TStatement;\n+\n+  /**\n+   * Create a simple literal (e.g. `\"string\"`, `123`, `false`, etc).\n+   *\n+   * @param value the value of the literal.\n+   */\n+  createLiteral(value: string|number|boolean|null|undefined): TExpression;\n+\n+  /**\n+   * Create an expression that is instantiating the `expression` as a class.\n+   *\n+   * @param expression an expression that evaluates to a constructor to be instantiated.\n+   * @param args the arguments to be passed to the constructor.\n+   */\n+  createNewExpression(expression: TExpression, args: TExpression[]): TExpression;\n+\n+  /**\n+   * Create a literal object expression (e.g. `{ prop1: expr1, prop2: expr2 }`).\n+   *\n+   * @param properties the properties (key and value) to appear in the object.\n+   */\n+  createObjectLiteral(properties: ObjectLiteralProperty<TExpression>[]): TExpression;\n+\n+  /**\n+   * Wrap an expression in parentheses.\n+   *\n+   * @param expression the expression to wrap in parentheses.\n+   */\n+  createParenthesizedExpression(expression: TExpression): TExpression;\n+\n+  /**\n+   * Create a property access (e.g. `obj.prop`).\n+   *\n+   * @param expression an expression that evaluates to the object to be accessed.\n+   * @param propertyName the name of the property to access.\n+   */\n+  createPropertyAccess(expression: TExpression, propertyName: string): TExpression;\n+\n+  /**\n+   * Create a return statement (e.g `return expr;`).\n+   *\n+   * @param expression the expression to be returned.\n+   */\n+  createReturnStatement(expression: TExpression|null): TStatement;\n+\n+  /**\n+   * Create a tagged template literal string. E.g.\n+   *\n+   * ```\n+   * tag`str1${expr1}str2${expr2}str3`\n+   * ```\n+   *\n+   * @param tag an expression that is applied as a tag handler for this template string.\n+   * @param template the collection of strings and expressions that constitute an interpolated\n+   *     template literal.\n+   */\n+  createTaggedTemplate(tag: TExpression, template: TemplateLiteral<TExpression>): TExpression;\n+\n+  /**\n+   * Create a throw statement (e.g. `throw expr;`).\n+   *\n+   * @param expression the expression to be thrown.\n+   */\n+  createThrowStatement(expression: TExpression): TStatement;\n+\n+  /**\n+   * Create an expression that extracts the type of an expression (e.g. `typeof expr`).\n+   *\n+   * @param expression the expression whose type we want.\n+   */\n+  createTypeOfExpression(expression: TExpression): TExpression;\n+\n+  /**\n+   * Prefix the `operand` with the given `operator` (e.g. `-expr`).\n+   *\n+   * @param operator the text of the operator to apply (e.g. `+`, `-` or `!`).\n+   * @param operand the expression that the operator applies to.\n+   */\n+  createUnaryExpression(operator: UnaryOperator, operand: TExpression): TExpression;\n+\n+  /**\n+   * Create an expression that declares a new variable, possibly initialized to `initializer`.\n+   *\n+   * @param variableName the name of the variable.\n+   * @param initializer if not `null` then this expression is assigned to the declared variable.\n+   * @param type whether this variable should be declared as `var`, `let` or `const`.\n+   */\n+  createVariableDeclaration(\n+      variableName: string, initializer: TExpression|null,\n+      type: VariableDeclarationType): TStatement;\n+\n+  /**\n+   * Attach a source map range to the given node.\n+   *\n+   * @param node the node to which the range should be attached.\n+   * @param sourceMapRange the range to attach to the node, or null if there is no range to attach.\n+   * @returns the `node` with the `sourceMapRange` attached.\n+   */\n+  setSourceMapRange<T extends TStatement|TExpression>(node: T, sourceMapRange: SourceMapRange|null):\n+      T;\n+}\n+\n+/**\n+ * The type of a variable declaration.\n+ */\n+export type VariableDeclarationType = 'const'|'let'|'var';\n+\n+/**\n+ * The unary operators supported by the `AstFactory`.\n+ */\n+export type UnaryOperator = '+'|'-'|'!';\n+\n+/**\n+ * The binary operators supported by the `AstFactory`.\n+ */\n+export type BinaryOperator =\n+    '&&'|'>'|'>='|'&'|'/'|'=='|'==='|'<'|'<='|'-'|'%'|'*'|'!='|'!=='|'||'|'+';\n+\n+/**\n+ * The original location of the start or end of a node created by the `AstFactory`.\n+ */\n+export interface SourceMapLocation {\n+  /** 0-based character position of the location in the original source file. */\n+  offset: number;\n+  /** 0-based line index of the location in the original source file. */\n+  line: number;\n+  /** 0-based column position of the location in the original source file. */\n+  column: number;\n+}\n+\n+/**\n+ * The original range of a node created by the `AstFactory`.\n+ */\n+export interface SourceMapRange {\n+  url: string;\n+  content: string;\n+  start: SourceMapLocation;\n+  end: SourceMapLocation;\n+}\n+\n+/**\n+ * Information used by the `AstFactory` to create a property on an object literal expression.\n+ */\n+export interface ObjectLiteralProperty<TExpression> {\n+  propertyName: string;\n+  value: TExpression;\n+  /**\n+   * Whether the `propertyName` should be enclosed in quotes.\n+   */\n+  quoted: boolean;\n+}\n+\n+/**\n+ * Information used by the `AstFactory` to create a template literal string (i.e. a back-ticked\n+ * string with interpolations).\n+ */\n+export interface TemplateLiteral<TExpression> {\n+  /**\n+   * A collection of the static string pieces of the interpolated template literal string.\n+   */\n+  elements: TemplateElement[];\n+  /**\n+   * A collection of the interpolated expressions that are interleaved between the elements.\n+   */\n+  expressions: TExpression[];\n+}\n+\n+/**\n+ * Information about a static string piece of an interpolated template literal string.\n+ */\n+export interface TemplateElement {\n+  /** The raw string as it was found in the original source code. */\n+  raw: string;\n+  /** The parsed string, with escape codes etc processed. */\n+  cooked: string;\n+  /** The original location of this piece of the template literal string. */\n+  range: SourceMapRange|null;\n+}\n+\n+/**\n+ * Information used by the `AstFactory` to prepend a comment to a statement that was created by the\n+ * `AstFactory`.\n+ */\n+export interface LeadingComment {\n+  toString(): string;\n+  multiline: boolean;\n+  trailingNewline: boolean;\n+}"
        },
        {
            "sha": "5e5fd3474de6c6118bb5f98a44945afecff0ed6f",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/api/import_generator.ts",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fapi%2Fimport_generator.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fapi%2Fimport_generator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fapi%2Fimport_generator.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -0,0 +1,39 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/**\n+ * Information about an import that has been added to a module.\n+ */\n+export interface Import {\n+  /** The name of the module that has been imported. */\n+  specifier: string;\n+  /** The alias of the imported module. */\n+  qualifier: string;\n+}\n+\n+/**\n+ * The symbol name and import namespace of an imported symbol,\n+ * which has been registered through the ImportGenerator.\n+ */\n+export interface NamedImport<TExpression> {\n+  /** The import namespace containing this imported symbol. */\n+  moduleImport: TExpression|null;\n+  /** The (possibly rewritten) name of the imported symbol. */\n+  symbol: string;\n+}\n+\n+/**\n+ * Generate import information based on the context of the code being generated.\n+ *\n+ * Implementations of these methods return a specific identifier that corresponds to the imported\n+ * module.\n+ */\n+export interface ImportGenerator<TExpression> {\n+  generateNamespaceImport(moduleName: string): TExpression;\n+  generateNamedImport(moduleName: string, originalSymbol: string): NamedImport<TExpression>;\n+}"
        },
        {
            "sha": "f5eeec0f4bdcce0a6f240f2bde3b49d9711953c1",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/import_manager.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 32,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fimport_manager.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fimport_manager.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Fimport_manager.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -5,37 +5,26 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {ImportRewriter, NoopImportRewriter} from '../../imports/src/core';\n+import * as ts from 'typescript';\n+import {ImportRewriter, NoopImportRewriter} from '../../imports';\n+import {Import, ImportGenerator, NamedImport} from './api/import_generator';\n \n-/**\n- * Information about an import that has been added to a module.\n- */\n-export interface Import {\n-  /** The name of the module that has been imported. */\n-  specifier: string;\n-  /** The alias of the imported module. */\n-  qualifier: string;\n-}\n-\n-/**\n- * The symbol name and import namespace of an imported symbol,\n- * which has been registered through the ImportManager.\n- */\n-export interface NamedImport {\n-  /** The import namespace containing this imported symbol. */\n-  moduleImport: string|null;\n-  /** The (possibly rewritten) name of the imported symbol. */\n-  symbol: string;\n-}\n-\n-export class ImportManager {\n-  private specifierToIdentifier = new Map<string, string>();\n+export class ImportManager implements ImportGenerator<ts.Identifier> {\n+  private specifierToIdentifier = new Map<string, ts.Identifier>();\n   private nextIndex = 0;\n \n   constructor(protected rewriter: ImportRewriter = new NoopImportRewriter(), private prefix = 'i') {\n   }\n \n-  generateNamedImport(moduleName: string, originalSymbol: string): NamedImport {\n+  generateNamespaceImport(moduleName: string): ts.Identifier {\n+    if (!this.specifierToIdentifier.has(moduleName)) {\n+      this.specifierToIdentifier.set(\n+          moduleName, ts.createIdentifier(`${this.prefix}${this.nextIndex++}`));\n+    }\n+    return this.specifierToIdentifier.get(moduleName)!;\n+  }\n+\n+  generateNamedImport(moduleName: string, originalSymbol: string): NamedImport<ts.Identifier> {\n     // First, rewrite the symbol name.\n     const symbol = this.rewriter.rewriteSymbol(originalSymbol, moduleName);\n \n@@ -46,12 +35,8 @@ export class ImportManager {\n       return {moduleImport: null, symbol};\n     }\n \n-    // If not, this symbol will be imported. Allocate a prefix for the imported module if needed.\n-\n-    if (!this.specifierToIdentifier.has(moduleName)) {\n-      this.specifierToIdentifier.set(moduleName, `${this.prefix}${this.nextIndex++}`);\n-    }\n-    const moduleImport = this.specifierToIdentifier.get(moduleName)!;\n+    // If not, this symbol will be imported using a generated namespace import.\n+    const moduleImport = this.generateNamespaceImport(moduleName);\n \n     return {moduleImport, symbol};\n   }\n@@ -60,7 +45,7 @@ export class ImportManager {\n     const imports: {specifier: string, qualifier: string}[] = [];\n     this.specifierToIdentifier.forEach((qualifier, specifier) => {\n       specifier = this.rewriter.rewriteSpecifier(specifier, contextPath);\n-      imports.push({specifier, qualifier});\n+      imports.push({specifier, qualifier: qualifier.text});\n     });\n     return imports;\n   }"
        },
        {
            "sha": "d644ec4cfcc792336dbd440dbf185b43049c3b24",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/translator.ts",
            "status": "modified",
            "additions": 267,
            "deletions": 364,
            "changes": 631,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftranslator.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -5,214 +5,249 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n+import * as o from '@angular/compiler';\n \n-import {AssertNotNull, BinaryOperator, BinaryOperatorExpr, CastExpr, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, Expression, ExpressionStatement, ExpressionVisitor, ExternalExpr, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, LeadingComment, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, NotExpr, ParseSourceSpan, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, ThrowStmt, TryCatchStmt, TypeofExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\n-import {LocalizedString, UnaryOperator, UnaryOperatorExpr} from '@angular/compiler/src/output/output_ast';\n-import * as ts from 'typescript';\n-\n-import {DefaultImportRecorder} from '../../imports';\n+import {AstFactory, BinaryOperator, ObjectLiteralProperty, SourceMapRange, TemplateElement, TemplateLiteral, UnaryOperator} from './api/ast_factory';\n+import {ImportGenerator} from './api/import_generator';\n import {Context} from './context';\n-import {ImportManager} from './import_manager';\n \n-const UNARY_OPERATORS = new Map<UnaryOperator, ts.PrefixUnaryOperator>([\n-  [UnaryOperator.Minus, ts.SyntaxKind.MinusToken],\n-  [UnaryOperator.Plus, ts.SyntaxKind.PlusToken],\n+const UNARY_OPERATORS = new Map<o.UnaryOperator, UnaryOperator>([\n+  [o.UnaryOperator.Minus, '-'],\n+  [o.UnaryOperator.Plus, '+'],\n ]);\n \n-const BINARY_OPERATORS = new Map<BinaryOperator, ts.BinaryOperator>([\n-  [BinaryOperator.And, ts.SyntaxKind.AmpersandAmpersandToken],\n-  [BinaryOperator.Bigger, ts.SyntaxKind.GreaterThanToken],\n-  [BinaryOperator.BiggerEquals, ts.SyntaxKind.GreaterThanEqualsToken],\n-  [BinaryOperator.BitwiseAnd, ts.SyntaxKind.AmpersandToken],\n-  [BinaryOperator.Divide, ts.SyntaxKind.SlashToken],\n-  [BinaryOperator.Equals, ts.SyntaxKind.EqualsEqualsToken],\n-  [BinaryOperator.Identical, ts.SyntaxKind.EqualsEqualsEqualsToken],\n-  [BinaryOperator.Lower, ts.SyntaxKind.LessThanToken],\n-  [BinaryOperator.LowerEquals, ts.SyntaxKind.LessThanEqualsToken],\n-  [BinaryOperator.Minus, ts.SyntaxKind.MinusToken],\n-  [BinaryOperator.Modulo, ts.SyntaxKind.PercentToken],\n-  [BinaryOperator.Multiply, ts.SyntaxKind.AsteriskToken],\n-  [BinaryOperator.NotEquals, ts.SyntaxKind.ExclamationEqualsToken],\n-  [BinaryOperator.NotIdentical, ts.SyntaxKind.ExclamationEqualsEqualsToken],\n-  [BinaryOperator.Or, ts.SyntaxKind.BarBarToken],\n-  [BinaryOperator.Plus, ts.SyntaxKind.PlusToken],\n+const BINARY_OPERATORS = new Map<o.BinaryOperator, BinaryOperator>([\n+  [o.BinaryOperator.And, '&&'],\n+  [o.BinaryOperator.Bigger, '>'],\n+  [o.BinaryOperator.BiggerEquals, '>='],\n+  [o.BinaryOperator.BitwiseAnd, '&'],\n+  [o.BinaryOperator.Divide, '/'],\n+  [o.BinaryOperator.Equals, '=='],\n+  [o.BinaryOperator.Identical, '==='],\n+  [o.BinaryOperator.Lower, '<'],\n+  [o.BinaryOperator.LowerEquals, '<='],\n+  [o.BinaryOperator.Minus, '-'],\n+  [o.BinaryOperator.Modulo, '%'],\n+  [o.BinaryOperator.Multiply, '*'],\n+  [o.BinaryOperator.NotEquals, '!='],\n+  [o.BinaryOperator.NotIdentical, '!=='],\n+  [o.BinaryOperator.Or, '||'],\n+  [o.BinaryOperator.Plus, '+'],\n ]);\n \n-export function translateExpression(\n-    expression: Expression, imports: ImportManager, defaultImportRecorder: DefaultImportRecorder,\n-    scriptTarget: Exclude<ts.ScriptTarget, ts.ScriptTarget.JSON>): ts.Expression {\n-  return expression.visitExpression(\n-      new ExpressionTranslatorVisitor(imports, defaultImportRecorder, scriptTarget),\n-      new Context(false));\n-}\n+export type RecordWrappedNodeExprFn<TExpression> = (expr: TExpression) => void;\n \n-export function translateStatement(\n-    statement: Statement, imports: ImportManager, defaultImportRecorder: DefaultImportRecorder,\n-    scriptTarget: Exclude<ts.ScriptTarget, ts.ScriptTarget.JSON>): ts.Statement {\n-  return statement.visitStatement(\n-      new ExpressionTranslatorVisitor(imports, defaultImportRecorder, scriptTarget),\n-      new Context(true));\n+export interface TranslatorOptions<TExpression> {\n+  downlevelLocalizedStrings?: boolean;\n+  downlevelVariableDeclarations?: boolean;\n+  recordWrappedNodeExpr?: RecordWrappedNodeExprFn<TExpression>;\n }\n \n+export class ExpressionTranslatorVisitor<TStatement, TExpression> implements o.ExpressionVisitor,\n+                                                                             o.StatementVisitor {\n+  private downlevelLocalizedStrings: boolean;\n+  private downlevelVariableDeclarations: boolean;\n+  private recordWrappedNodeExpr: RecordWrappedNodeExprFn<TExpression>;\n \n-class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor {\n-  private externalSourceFiles = new Map<string, ts.SourceMapSource>();\n   constructor(\n-      private imports: ImportManager, private defaultImportRecorder: DefaultImportRecorder,\n-      private scriptTarget: Exclude<ts.ScriptTarget, ts.ScriptTarget.JSON>) {}\n-\n-  visitDeclareVarStmt(stmt: DeclareVarStmt, context: Context): ts.VariableStatement {\n-    const varType = this.scriptTarget < ts.ScriptTarget.ES2015 ?\n-        ts.NodeFlags.None :\n-        stmt.hasModifier(StmtModifier.Final) ? ts.NodeFlags.Const : ts.NodeFlags.Let;\n-    const varDeclaration = ts.createVariableDeclaration(\n-        /* name */ stmt.name,\n-        /* type */ undefined,\n-        /* initializer */ stmt.value?.visitExpression(this, context.withExpressionMode));\n-    const declarationList = ts.createVariableDeclarationList(\n-        /* declarations */[varDeclaration],\n-        /* flags */ varType);\n-    const varStatement = ts.createVariableStatement(undefined, declarationList);\n-    return attachComments(varStatement, stmt.leadingComments);\n-  }\n-\n-  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: Context): ts.FunctionDeclaration {\n-    const fnDeclaration = ts.createFunctionDeclaration(\n-        /* decorators */ undefined,\n-        /* modifiers */ undefined,\n-        /* asterisk */ undefined,\n-        /* name */ stmt.name,\n-        /* typeParameters */ undefined,\n-        /* parameters */\n-        stmt.params.map(param => ts.createParameter(undefined, undefined, undefined, param.name)),\n-        /* type */ undefined,\n-        /* body */\n-        ts.createBlock(\n-            stmt.statements.map(child => child.visitStatement(this, context.withStatementMode))));\n-    return attachComments(fnDeclaration, stmt.leadingComments);\n-  }\n-\n-  visitExpressionStmt(stmt: ExpressionStatement, context: Context): ts.ExpressionStatement {\n-    return attachComments(\n-        ts.createStatement(stmt.expr.visitExpression(this, context.withStatementMode)),\n+      private factory: AstFactory<TStatement, TExpression>,\n+      private imports: ImportGenerator<TExpression>, options: TranslatorOptions<TExpression>) {\n+    this.downlevelLocalizedStrings = options.downlevelLocalizedStrings === true;\n+    this.downlevelVariableDeclarations = options.downlevelVariableDeclarations === true;\n+    this.recordWrappedNodeExpr = options.recordWrappedNodeExpr || (() => {});\n+  }\n+\n+  visitDeclareVarStmt(stmt: o.DeclareVarStmt, context: Context): TStatement {\n+    const varType = this.downlevelVariableDeclarations ?\n+        'var' :\n+        stmt.hasModifier(o.StmtModifier.Final) ? 'const' : 'let';\n+    return this.factory.attachComments(\n+        this.factory.createVariableDeclaration(\n+            stmt.name, stmt.value?.visitExpression(this, context.withExpressionMode), varType),\n         stmt.leadingComments);\n   }\n \n-  visitReturnStmt(stmt: ReturnStatement, context: Context): ts.ReturnStatement {\n-    return attachComments(\n-        ts.createReturn(stmt.value.visitExpression(this, context.withExpressionMode)),\n+  visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: Context): TStatement {\n+    return this.factory.attachComments(\n+        this.factory.createFunctionDeclaration(\n+            stmt.name, stmt.params.map(param => param.name),\n+            this.factory.createBlock(\n+                this.visitStatements(stmt.statements, context.withStatementMode))),\n         stmt.leadingComments);\n   }\n \n-  visitDeclareClassStmt(stmt: ClassStmt, context: Context) {\n-    if (this.scriptTarget < ts.ScriptTarget.ES2015) {\n-      throw new Error(\n-          `Unsupported mode: Visiting a \"declare class\" statement (class ${stmt.name}) while ` +\n-          `targeting ${ts.ScriptTarget[this.scriptTarget]}.`);\n-    }\n+  visitExpressionStmt(stmt: o.ExpressionStatement, context: Context): TStatement {\n+    return this.factory.attachComments(\n+        this.factory.createExpressionStatement(\n+            stmt.expr.visitExpression(this, context.withStatementMode)),\n+        stmt.leadingComments);\n+  }\n+\n+  visitReturnStmt(stmt: o.ReturnStatement, context: Context): TStatement {\n+    return this.factory.attachComments(\n+        this.factory.createReturnStatement(\n+            stmt.value.visitExpression(this, context.withExpressionMode)),\n+        stmt.leadingComments);\n+  }\n+\n+  visitDeclareClassStmt(_stmt: o.ClassStmt, _context: Context): never {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitIfStmt(stmt: IfStmt, context: Context): ts.IfStatement {\n-    const thenBlock = ts.createBlock(\n-        stmt.trueCase.map(child => child.visitStatement(this, context.withStatementMode)));\n-    const elseBlock = stmt.falseCase.length > 0 ?\n-        ts.createBlock(\n-            stmt.falseCase.map(child => child.visitStatement(this, context.withStatementMode))) :\n-        undefined;\n-    const ifStatement =\n-        ts.createIf(stmt.condition.visitExpression(this, context), thenBlock, elseBlock);\n-    return attachComments(ifStatement, stmt.leadingComments);\n+  visitIfStmt(stmt: o.IfStmt, context: Context): TStatement {\n+    return this.factory.attachComments(\n+        this.factory.createIfStatement(\n+            stmt.condition.visitExpression(this, context),\n+            this.factory.createBlock(\n+                this.visitStatements(stmt.trueCase, context.withStatementMode)),\n+            stmt.falseCase.length > 0 ? this.factory.createBlock(this.visitStatements(\n+                                            stmt.falseCase, context.withStatementMode)) :\n+                                        null),\n+        stmt.leadingComments);\n   }\n \n-  visitTryCatchStmt(stmt: TryCatchStmt, context: Context) {\n+  visitTryCatchStmt(_stmt: o.TryCatchStmt, _context: Context): never {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitThrowStmt(stmt: ThrowStmt, context: Context): ts.ThrowStatement {\n-    return attachComments(\n-        ts.createThrow(stmt.error.visitExpression(this, context.withExpressionMode)),\n+  visitThrowStmt(stmt: o.ThrowStmt, context: Context): TStatement {\n+    return this.factory.attachComments(\n+        this.factory.createThrowStatement(\n+            stmt.error.visitExpression(this, context.withExpressionMode)),\n         stmt.leadingComments);\n   }\n \n-  visitReadVarExpr(ast: ReadVarExpr, context: Context): ts.Identifier {\n-    const identifier = ts.createIdentifier(ast.name!);\n+  visitReadVarExpr(ast: o.ReadVarExpr, _context: Context): TExpression {\n+    const identifier = this.factory.createIdentifier(ast.name!);\n     this.setSourceMapRange(identifier, ast.sourceSpan);\n     return identifier;\n   }\n \n-  visitWriteVarExpr(expr: WriteVarExpr, context: Context): ts.Expression {\n-    const result: ts.Expression = ts.createBinary(\n-        ts.createIdentifier(expr.name), ts.SyntaxKind.EqualsToken,\n-        expr.value.visitExpression(this, context));\n-    return context.isStatement ? result : ts.createParen(result);\n+  visitWriteVarExpr(expr: o.WriteVarExpr, context: Context): TExpression {\n+    const assignment = this.factory.createAssignment(\n+        this.setSourceMapRange(this.factory.createIdentifier(expr.name), expr.sourceSpan),\n+        expr.value.visitExpression(this, context),\n+    );\n+    return context.isStatement ? assignment :\n+                                 this.factory.createParenthesizedExpression(assignment);\n   }\n \n-  visitWriteKeyExpr(expr: WriteKeyExpr, context: Context): ts.Expression {\n+  visitWriteKeyExpr(expr: o.WriteKeyExpr, context: Context): TExpression {\n     const exprContext = context.withExpressionMode;\n-    const lhs = ts.createElementAccess(\n+    const target = this.factory.createElementAccess(\n         expr.receiver.visitExpression(this, exprContext),\n-        expr.index.visitExpression(this, exprContext));\n-    const rhs = expr.value.visitExpression(this, exprContext);\n-    const result: ts.Expression = ts.createBinary(lhs, ts.SyntaxKind.EqualsToken, rhs);\n-    return context.isStatement ? result : ts.createParen(result);\n+        expr.index.visitExpression(this, exprContext),\n+    );\n+    const assignment =\n+        this.factory.createAssignment(target, expr.value.visitExpression(this, exprContext));\n+    return context.isStatement ? assignment :\n+                                 this.factory.createParenthesizedExpression(assignment);\n   }\n \n-  visitWritePropExpr(expr: WritePropExpr, context: Context): ts.BinaryExpression {\n-    return ts.createBinary(\n-        ts.createPropertyAccess(expr.receiver.visitExpression(this, context), expr.name),\n-        ts.SyntaxKind.EqualsToken, expr.value.visitExpression(this, context));\n+  visitWritePropExpr(expr: o.WritePropExpr, context: Context): TExpression {\n+    const target =\n+        this.factory.createPropertyAccess(expr.receiver.visitExpression(this, context), expr.name);\n+    return this.factory.createAssignment(target, expr.value.visitExpression(this, context));\n   }\n \n-  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: Context): ts.CallExpression {\n+  visitInvokeMethodExpr(ast: o.InvokeMethodExpr, context: Context): TExpression {\n     const target = ast.receiver.visitExpression(this, context);\n-    const call = ts.createCall(\n-        ast.name !== null ? ts.createPropertyAccess(target, ast.name) : target, undefined,\n-        ast.args.map(arg => arg.visitExpression(this, context)));\n-    this.setSourceMapRange(call, ast.sourceSpan);\n-    return call;\n+    return this.setSourceMapRange(\n+        this.factory.createCallExpression(\n+            ast.name !== null ? this.factory.createPropertyAccess(target, ast.name) : target,\n+            ast.args.map(arg => arg.visitExpression(this, context)),\n+            /* pure */ false),\n+        ast.sourceSpan);\n   }\n \n-  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: Context): ts.CallExpression {\n-    const expr = ts.createCall(\n-        ast.fn.visitExpression(this, context), undefined,\n-        ast.args.map(arg => arg.visitExpression(this, context)));\n-    if (ast.pure) {\n-      ts.addSyntheticLeadingComment(expr, ts.SyntaxKind.MultiLineCommentTrivia, '@__PURE__', false);\n-    }\n-    this.setSourceMapRange(expr, ast.sourceSpan);\n-    return expr;\n+  visitInvokeFunctionExpr(ast: o.InvokeFunctionExpr, context: Context): TExpression {\n+    return this.setSourceMapRange(\n+        this.factory.createCallExpression(\n+            ast.fn.visitExpression(this, context),\n+            ast.args.map(arg => arg.visitExpression(this, context)), ast.pure),\n+        ast.sourceSpan);\n   }\n \n-  visitInstantiateExpr(ast: InstantiateExpr, context: Context): ts.NewExpression {\n-    return ts.createNew(\n-        ast.classExpr.visitExpression(this, context), undefined,\n+  visitInstantiateExpr(ast: o.InstantiateExpr, context: Context): TExpression {\n+    return this.factory.createNewExpression(\n+        ast.classExpr.visitExpression(this, context),\n         ast.args.map(arg => arg.visitExpression(this, context)));\n   }\n \n-  visitLiteralExpr(ast: LiteralExpr, context: Context): ts.Expression {\n-    let expr: ts.Expression;\n-    if (ast.value === undefined) {\n-      expr = ts.createIdentifier('undefined');\n-    } else if (ast.value === null) {\n-      expr = ts.createNull();\n-    } else {\n-      expr = ts.createLiteral(ast.value);\n+  visitLiteralExpr(ast: o.LiteralExpr, _context: Context): TExpression {\n+    return this.setSourceMapRange(this.factory.createLiteral(ast.value), ast.sourceSpan);\n+  }\n+\n+  visitLocalizedString(ast: o.LocalizedString, context: Context): TExpression {\n+    // A `$localize` message consists of `messageParts` and `expressions`, which get interleaved\n+    // together. The interleaved pieces look like:\n+    // `[messagePart0, expression0, messagePart1, expression1, messagePart2]`\n+    //\n+    // Note that there is always a message part at the start and end, and so therefore\n+    // `messageParts.length === expressions.length + 1`.\n+    //\n+    // Each message part may be prefixed with \"metadata\", which is wrapped in colons (:) delimiters.\n+    // The metadata is attached to the first and subsequent message parts by calls to\n+    // `serializeI18nHead()` and `serializeI18nTemplatePart()` respectively.\n+    //\n+    // The first message part (i.e. `ast.messageParts[0]`) is used to initialize `messageParts`\n+    // array.\n+    const elements: TemplateElement[] = [createTemplateElement(ast.serializeI18nHead())];\n+    const expressions: TExpression[] = [];\n+    for (let i = 0; i < ast.expressions.length; i++) {\n+      const placeholder = this.setSourceMapRange(\n+          ast.expressions[i].visitExpression(this, context), ast.getPlaceholderSourceSpan(i));\n+      expressions.push(placeholder);\n+      elements.push(createTemplateElement(ast.serializeI18nTemplatePart(i + 1)));\n     }\n-    this.setSourceMapRange(expr, ast.sourceSpan);\n-    return expr;\n+\n+    const localizeTag = this.factory.createIdentifier('$localize');\n+\n+    // Now choose which implementation to use to actually create the necessary AST nodes.\n+    const localizeCall = this.downlevelLocalizedStrings ?\n+        this.createES5TaggedTemplateFunctionCall(localizeTag, {elements, expressions}) :\n+        this.factory.createTaggedTemplate(localizeTag, {elements, expressions});\n+\n+    return this.setSourceMapRange(localizeCall, ast.sourceSpan);\n   }\n \n-  visitLocalizedString(ast: LocalizedString, context: Context): ts.Expression {\n-    const localizedString = this.scriptTarget >= ts.ScriptTarget.ES2015 ?\n-        this.createLocalizedStringTaggedTemplate(ast, context) :\n-        this.createLocalizedStringFunctionCall(ast, context);\n-    this.setSourceMapRange(localizedString, ast.sourceSpan);\n-    return localizedString;\n+  /**\n+   * Translate the tagged template literal into a call that is compatible with ES5, using the\n+   * imported `__makeTemplateObject` helper for ES5 formatted output.\n+   */\n+  private createES5TaggedTemplateFunctionCall(\n+      tagHandler: TExpression, {elements, expressions}: TemplateLiteral<TExpression>): TExpression {\n+    // Ensure that the `__makeTemplateObject()` helper has been imported.\n+    const {moduleImport, symbol} =\n+        this.imports.generateNamedImport('tslib', '__makeTemplateObject');\n+    const __makeTemplateObjectHelper = (moduleImport === null) ?\n+        this.factory.createIdentifier(symbol) :\n+        this.factory.createPropertyAccess(moduleImport, symbol);\n+\n+    // Collect up the cooked and raw strings into two separate arrays.\n+    const cooked: TExpression[] = [];\n+    const raw: TExpression[] = [];\n+    for (const element of elements) {\n+      cooked.push(this.factory.setSourceMapRange(\n+          this.factory.createLiteral(element.cooked), element.range));\n+      raw.push(\n+          this.factory.setSourceMapRange(this.factory.createLiteral(element.raw), element.range));\n+    }\n+\n+    // Generate the helper call in the form: `__makeTemplateObject([cooked], [raw]);`\n+    const templateHelperCall = this.factory.createCallExpression(\n+        __makeTemplateObjectHelper,\n+        [this.factory.createArrayLiteral(cooked), this.factory.createArrayLiteral(raw)],\n+        /* pure */ false);\n+\n+    // Finally create the tagged handler call in the form:\n+    // `tag(__makeTemplateObject([cooked], [raw]), ...expressions);`\n+    return this.factory.createCallExpression(\n+        tagHandler, [templateHelperCall, ...expressions],\n+        /* pure */ false);\n   }\n \n-  visitExternalExpr(ast: ExternalExpr, context: Context): ts.PropertyAccessExpression\n-      |ts.Identifier {\n+  visitExternalExpr(ast: o.ExternalExpr, _context: Context): TExpression {\n     if (ast.value.name === null) {\n       throw new Error(`Import unknown module or symbol ${ast.value}`);\n     }\n@@ -224,19 +259,18 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n           this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n       if (moduleImport === null) {\n         // The symbol was ambient after all.\n-        return ts.createIdentifier(symbol);\n+        return this.factory.createIdentifier(symbol);\n       } else {\n-        return ts.createPropertyAccess(\n-            ts.createIdentifier(moduleImport), ts.createIdentifier(symbol));\n+        return this.factory.createPropertyAccess(moduleImport, symbol);\n       }\n     } else {\n       // The symbol is ambient, so just reference it.\n-      return ts.createIdentifier(ast.value.name);\n+      return this.factory.createIdentifier(ast.value.name);\n     }\n   }\n \n-  visitConditionalExpr(ast: ConditionalExpr, context: Context): ts.ConditionalExpression {\n-    let cond: ts.Expression = ast.condition.visitExpression(this, context);\n+  visitConditionalExpr(ast: o.ConditionalExpr, context: Context): TExpression {\n+    let cond: TExpression = ast.condition.visitExpression(this, context);\n \n     // Ordinarily the ternary operator is right-associative. The following are equivalent:\n     //   `a ? b : c ? d : e` => `a ? b : (c ? d : e)`\n@@ -258,259 +292,128 @@ class ExpressionTranslatorVisitor implements ExpressionVisitor, StatementVisitor\n     // conditional expression is directly used as the condition of another.\n     //\n     // TODO(alxhub): investigate better logic for precendence of conditional operators\n-    if (ast.condition instanceof ConditionalExpr) {\n+    if (ast.condition instanceof o.ConditionalExpr) {\n       // The condition of this ternary needs to be wrapped in parentheses to maintain\n       // left-associativity.\n-      cond = ts.createParen(cond);\n+      cond = this.factory.createParenthesizedExpression(cond);\n     }\n \n-    return ts.createConditional(\n+    return this.factory.createConditional(\n         cond, ast.trueCase.visitExpression(this, context),\n         ast.falseCase!.visitExpression(this, context));\n   }\n \n-  visitNotExpr(ast: NotExpr, context: Context): ts.PrefixUnaryExpression {\n-    return ts.createPrefix(\n-        ts.SyntaxKind.ExclamationToken, ast.condition.visitExpression(this, context));\n+  visitNotExpr(ast: o.NotExpr, context: Context): TExpression {\n+    return this.factory.createUnaryExpression('!', ast.condition.visitExpression(this, context));\n   }\n \n-  visitAssertNotNullExpr(ast: AssertNotNull, context: Context): ts.NonNullExpression {\n+  visitAssertNotNullExpr(ast: o.AssertNotNull, context: Context): TExpression {\n     return ast.condition.visitExpression(this, context);\n   }\n \n-  visitCastExpr(ast: CastExpr, context: Context): ts.Expression {\n+  visitCastExpr(ast: o.CastExpr, context: Context): TExpression {\n     return ast.value.visitExpression(this, context);\n   }\n \n-  visitFunctionExpr(ast: FunctionExpr, context: Context): ts.FunctionExpression {\n-    return ts.createFunctionExpression(\n-        undefined, undefined, ast.name || undefined, undefined,\n-        ast.params.map(\n-            param => ts.createParameter(\n-                undefined, undefined, undefined, param.name, undefined, undefined, undefined)),\n-        undefined, ts.createBlock(ast.statements.map(stmt => stmt.visitStatement(this, context))));\n+  visitFunctionExpr(ast: o.FunctionExpr, context: Context): TExpression {\n+    return this.factory.createFunctionExpression(\n+        ast.name ?? null, ast.params.map(param => param.name),\n+        this.factory.createBlock(this.visitStatements(ast.statements, context)));\n   }\n \n-  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: Context): ts.Expression {\n-    if (!UNARY_OPERATORS.has(ast.operator)) {\n-      throw new Error(`Unknown unary operator: ${UnaryOperator[ast.operator]}`);\n-    }\n-    return ts.createPrefix(\n-        UNARY_OPERATORS.get(ast.operator)!, ast.expr.visitExpression(this, context));\n-  }\n-\n-  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: Context): ts.Expression {\n+  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, context: Context): TExpression {\n     if (!BINARY_OPERATORS.has(ast.operator)) {\n-      throw new Error(`Unknown binary operator: ${BinaryOperator[ast.operator]}`);\n+      throw new Error(`Unknown binary operator: ${o.BinaryOperator[ast.operator]}`);\n     }\n-    return ts.createBinary(\n-        ast.lhs.visitExpression(this, context), BINARY_OPERATORS.get(ast.operator)!,\n-        ast.rhs.visitExpression(this, context));\n+    return this.factory.createBinaryExpression(\n+        ast.lhs.visitExpression(this, context),\n+        BINARY_OPERATORS.get(ast.operator)!,\n+        ast.rhs.visitExpression(this, context),\n+    );\n   }\n \n-  visitReadPropExpr(ast: ReadPropExpr, context: Context): ts.PropertyAccessExpression {\n-    return ts.createPropertyAccess(ast.receiver.visitExpression(this, context), ast.name);\n+  visitReadPropExpr(ast: o.ReadPropExpr, context: Context): TExpression {\n+    return this.factory.createPropertyAccess(ast.receiver.visitExpression(this, context), ast.name);\n   }\n \n-  visitReadKeyExpr(ast: ReadKeyExpr, context: Context): ts.ElementAccessExpression {\n-    return ts.createElementAccess(\n+  visitReadKeyExpr(ast: o.ReadKeyExpr, context: Context): TExpression {\n+    return this.factory.createElementAccess(\n         ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context));\n   }\n \n-  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: Context): ts.ArrayLiteralExpression {\n-    const expr =\n-        ts.createArrayLiteral(ast.entries.map(expr => expr.visitExpression(this, context)));\n-    this.setSourceMapRange(expr, ast.sourceSpan);\n-    return expr;\n+  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: Context): TExpression {\n+    return this.factory.createArrayLiteral(ast.entries.map(\n+        expr => this.setSourceMapRange(expr.visitExpression(this, context), ast.sourceSpan)));\n   }\n \n-  visitLiteralMapExpr(ast: LiteralMapExpr, context: Context): ts.ObjectLiteralExpression {\n-    const entries = ast.entries.map(\n-        entry => ts.createPropertyAssignment(\n-            entry.quoted ? ts.createLiteral(entry.key) : ts.createIdentifier(entry.key),\n-            entry.value.visitExpression(this, context)));\n-    const expr = ts.createObjectLiteral(entries);\n-    this.setSourceMapRange(expr, ast.sourceSpan);\n-    return expr;\n+  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: Context): TExpression {\n+    const properties: ObjectLiteralProperty<TExpression>[] = ast.entries.map(entry => {\n+      return {\n+        propertyName: entry.key,\n+        quoted: entry.quoted,\n+        value: entry.value.visitExpression(this, context)\n+      };\n+    });\n+    return this.setSourceMapRange(this.factory.createObjectLiteral(properties), ast.sourceSpan);\n   }\n \n-  visitCommaExpr(ast: CommaExpr, context: Context): never {\n+  visitCommaExpr(ast: o.CommaExpr, context: Context): never {\n     throw new Error('Method not implemented.');\n   }\n \n-  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: Context): any {\n-    if (ts.isIdentifier(ast.node)) {\n-      this.defaultImportRecorder.recordUsedIdentifier(ast.node);\n-    }\n+  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, _context: Context): any {\n+    this.recordWrappedNodeExpr(ast.node);\n     return ast.node;\n   }\n \n-  visitTypeofExpr(ast: TypeofExpr, context: Context): ts.TypeOfExpression {\n-    return ts.createTypeOf(ast.expr.visitExpression(this, context));\n+  visitTypeofExpr(ast: o.TypeofExpr, context: Context): TExpression {\n+    return this.factory.createTypeOfExpression(ast.expr.visitExpression(this, context));\n   }\n \n-  /**\n-   * Translate the `LocalizedString` node into a `TaggedTemplateExpression` for ES2015 formatted\n-   * output.\n-   */\n-  private createLocalizedStringTaggedTemplate(ast: LocalizedString, context: Context):\n-      ts.TaggedTemplateExpression {\n-    let template: ts.TemplateLiteral;\n-    const length = ast.messageParts.length;\n-    const metaBlock = ast.serializeI18nHead();\n-    if (length === 1) {\n-      template = ts.createNoSubstitutionTemplateLiteral(metaBlock.cooked, metaBlock.raw);\n-      this.setSourceMapRange(template, ast.getMessagePartSourceSpan(0));\n-    } else {\n-      // Create the head part\n-      const head = ts.createTemplateHead(metaBlock.cooked, metaBlock.raw);\n-      this.setSourceMapRange(head, ast.getMessagePartSourceSpan(0));\n-      const spans: ts.TemplateSpan[] = [];\n-      // Create the middle parts\n-      for (let i = 1; i < length - 1; i++) {\n-        const resolvedExpression = ast.expressions[i - 1].visitExpression(this, context);\n-        this.setSourceMapRange(resolvedExpression, ast.getPlaceholderSourceSpan(i - 1));\n-        const templatePart = ast.serializeI18nTemplatePart(i);\n-        const templateMiddle = createTemplateMiddle(templatePart.cooked, templatePart.raw);\n-        this.setSourceMapRange(templateMiddle, ast.getMessagePartSourceSpan(i));\n-        const templateSpan = ts.createTemplateSpan(resolvedExpression, templateMiddle);\n-        spans.push(templateSpan);\n-      }\n-      // Create the tail part\n-      const resolvedExpression = ast.expressions[length - 2].visitExpression(this, context);\n-      this.setSourceMapRange(resolvedExpression, ast.getPlaceholderSourceSpan(length - 2));\n-      const templatePart = ast.serializeI18nTemplatePart(length - 1);\n-      const templateTail = createTemplateTail(templatePart.cooked, templatePart.raw);\n-      this.setSourceMapRange(templateTail, ast.getMessagePartSourceSpan(length - 1));\n-      spans.push(ts.createTemplateSpan(resolvedExpression, templateTail));\n-      // Put it all together\n-      template = ts.createTemplateExpression(head, spans);\n+  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, context: Context): TExpression {\n+    if (!UNARY_OPERATORS.has(ast.operator)) {\n+      throw new Error(`Unknown unary operator: ${o.UnaryOperator[ast.operator]}`);\n     }\n-    const expression = ts.createTaggedTemplate(ts.createIdentifier('$localize'), template);\n-    this.setSourceMapRange(expression, ast.sourceSpan);\n-    return expression;\n+    return this.factory.createUnaryExpression(\n+        UNARY_OPERATORS.get(ast.operator)!, ast.expr.visitExpression(this, context));\n   }\n \n-  /**\n-   * Translate the `LocalizedString` node into a `$localize` call using the imported\n-   * `__makeTemplateObject` helper for ES5 formatted output.\n-   */\n-  private createLocalizedStringFunctionCall(ast: LocalizedString, context: Context) {\n-    // A `$localize` message consists `messageParts` and `expressions`, which get interleaved\n-    // together. The interleaved pieces look like:\n-    // `[messagePart0, expression0, messagePart1, expression1, messagePart2]`\n-    //\n-    // Note that there is always a message part at the start and end, and so therefore\n-    // `messageParts.length === expressions.length + 1`.\n-    //\n-    // Each message part may be prefixed with \"metadata\", which is wrapped in colons (:) delimiters.\n-    // The metadata is attached to the first and subsequent message parts by calls to\n-    // `serializeI18nHead()` and `serializeI18nTemplatePart()` respectively.\n-\n-    // The first message part (i.e. `ast.messageParts[0]`) is used to initialize `messageParts`\n-    // array.\n-    const messageParts = [ast.serializeI18nHead()];\n-    const expressions: any[] = [];\n-\n-    // The rest of the `ast.messageParts` and each of the expressions are `ast.expressions` pushed\n-    // into the arrays. Note that `ast.messagePart[i]` corresponds to `expressions[i-1]`\n-    for (let i = 1; i < ast.messageParts.length; i++) {\n-      expressions.push(ast.expressions[i - 1].visitExpression(this, context));\n-      messageParts.push(ast.serializeI18nTemplatePart(i));\n-    }\n-\n-    // The resulting downlevelled tagged template string uses a call to the `__makeTemplateObject()`\n-    // helper, so we must ensure it has been imported.\n-    const {moduleImport, symbol} =\n-        this.imports.generateNamedImport('tslib', '__makeTemplateObject');\n-    const __makeTemplateObjectHelper = (moduleImport === null) ?\n-        ts.createIdentifier(symbol) :\n-        ts.createPropertyAccess(ts.createIdentifier(moduleImport), ts.createIdentifier(symbol));\n-\n-    // Generate the call in the form:\n-    // `$localize(__makeTemplateObject(cookedMessageParts, rawMessageParts), ...expressions);`\n-    const cookedLiterals = messageParts.map(\n-        (messagePart, i) =>\n-            this.createLiteral(messagePart.cooked, ast.getMessagePartSourceSpan(i)));\n-    const rawLiterals = messageParts.map(\n-        (messagePart, i) => this.createLiteral(messagePart.raw, ast.getMessagePartSourceSpan(i)));\n-    return ts.createCall(\n-        /* expression */ ts.createIdentifier('$localize'),\n-        /* typeArguments */ undefined,\n-        /* argumentsArray */[\n-          ts.createCall(\n-              /* expression */ __makeTemplateObjectHelper,\n-              /* typeArguments */ undefined,\n-              /* argumentsArray */\n-              [\n-                ts.createArrayLiteral(cookedLiterals),\n-                ts.createArrayLiteral(rawLiterals),\n-              ]),\n-          ...expressions,\n-        ]);\n-  }\n-\n-\n-  private setSourceMapRange(expr: ts.Node, sourceSpan: ParseSourceSpan|null) {\n-    if (sourceSpan) {\n-      const {start, end} = sourceSpan;\n-      const {url, content} = start.file;\n-      if (url) {\n-        if (!this.externalSourceFiles.has(url)) {\n-          this.externalSourceFiles.set(url, ts.createSourceMapSource(url, content, pos => pos));\n-        }\n-        const source = this.externalSourceFiles.get(url);\n-        ts.setSourceMapRange(expr, {pos: start.offset, end: end.offset, source});\n-      }\n-    }\n+  private visitStatements(statements: o.Statement[], context: Context): TStatement[] {\n+    return statements.map(stmt => stmt.visitStatement(this, context))\n+        .filter(stmt => stmt !== undefined);\n   }\n \n-  private createLiteral(text: string, span: ParseSourceSpan|null) {\n-    const literal = ts.createStringLiteral(text);\n-    this.setSourceMapRange(literal, span);\n-    return literal;\n+  private setSourceMapRange<T extends TExpression|TStatement>(ast: T, span: o.ParseSourceSpan|null):\n+      T {\n+    return this.factory.setSourceMapRange(ast, createRange(span));\n   }\n }\n \n-// HACK: Use this in place of `ts.createTemplateMiddle()`.\n-// Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed\n-function createTemplateMiddle(cooked: string, raw: string): ts.TemplateMiddle {\n-  const node: ts.TemplateLiteralLikeNode = ts.createTemplateHead(cooked, raw);\n-  (node.kind as ts.SyntaxKind) = ts.SyntaxKind.TemplateMiddle;\n-  return node as ts.TemplateMiddle;\n-}\n-\n-// HACK: Use this in place of `ts.createTemplateTail()`.\n-// Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed\n-function createTemplateTail(cooked: string, raw: string): ts.TemplateTail {\n-  const node: ts.TemplateLiteralLikeNode = ts.createTemplateHead(cooked, raw);\n-  (node.kind as ts.SyntaxKind) = ts.SyntaxKind.TemplateTail;\n-  return node as ts.TemplateTail;\n+/**\n+ * Convert a cooked-raw string object into one that can be used by the AST factories.\n+ */\n+function createTemplateElement(\n+    {cooked, raw, range}: {cooked: string, raw: string, range: o.ParseSourceSpan|null}):\n+    TemplateElement {\n+  return {cooked, raw, range: createRange(range)};\n }\n \n /**\n- * Attach the given `leadingComments` to the `statement` node.\n- *\n- * @param statement The statement that will have comments attached.\n- * @param leadingComments The comments to attach to the statement.\n+ * Convert an OutputAST source-span into a range that can be used by the AST factories.\n  */\n-export function attachComments<T extends ts.Statement>(\n-    statement: T, leadingComments?: LeadingComment[]): T {\n-  if (leadingComments === undefined) {\n-    return statement;\n-  }\n-\n-  for (const comment of leadingComments) {\n-    const commentKind = comment.multiline ? ts.SyntaxKind.MultiLineCommentTrivia :\n-                                            ts.SyntaxKind.SingleLineCommentTrivia;\n-    if (comment.multiline) {\n-      ts.addSyntheticLeadingComment(\n-          statement, commentKind, comment.toString(), comment.trailingNewline);\n-    } else {\n-      for (const line of comment.text.split('\\n')) {\n-        ts.addSyntheticLeadingComment(statement, commentKind, line, comment.trailingNewline);\n-      }\n-    }\n-  }\n-  return statement;\n+function createRange(span: o.ParseSourceSpan|null): SourceMapRange|null {\n+  if (span === null) {\n+    return null;\n+  }\n+  const {start, end} = span;\n+  const {url, content} = start.file;\n+  if (!url) {\n+    return null;\n+  }\n+  return {\n+    url,\n+    content,\n+    start: {offset: start.offset, line: start.line, column: start.col},\n+    end: {offset: end.offset, line: end.line, column: end.col},\n+  };\n }"
        },
        {
            "sha": "06a86d7c5600a8bcced11bddcafb2f8aa6322e16",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/typescript_ast_factory.ts",
            "status": "added",
            "additions": 256,
            "deletions": 0,
            "changes": 256,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftypescript_ast_factory.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftypescript_ast_factory.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftypescript_ast_factory.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -0,0 +1,256 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import * as ts from 'typescript';\n+\n+import {AstFactory, BinaryOperator, LeadingComment, ObjectLiteralProperty, SourceMapRange, TemplateLiteral, UnaryOperator, VariableDeclarationType} from './api/ast_factory';\n+\n+const UNARY_OPERATORS: Record<UnaryOperator, ts.PrefixUnaryOperator> = {\n+  '+': ts.SyntaxKind.PlusToken,\n+  '-': ts.SyntaxKind.MinusToken,\n+  '!': ts.SyntaxKind.ExclamationToken,\n+};\n+\n+const BINARY_OPERATORS: Record<BinaryOperator, ts.BinaryOperator> = {\n+  '&&': ts.SyntaxKind.AmpersandAmpersandToken,\n+  '>': ts.SyntaxKind.GreaterThanToken,\n+  '>=': ts.SyntaxKind.GreaterThanEqualsToken,\n+  '&': ts.SyntaxKind.AmpersandToken,\n+  '/': ts.SyntaxKind.SlashToken,\n+  '==': ts.SyntaxKind.EqualsEqualsToken,\n+  '===': ts.SyntaxKind.EqualsEqualsEqualsToken,\n+  '<': ts.SyntaxKind.LessThanToken,\n+  '<=': ts.SyntaxKind.LessThanEqualsToken,\n+  '-': ts.SyntaxKind.MinusToken,\n+  '%': ts.SyntaxKind.PercentToken,\n+  '*': ts.SyntaxKind.AsteriskToken,\n+  '!=': ts.SyntaxKind.ExclamationEqualsToken,\n+  '!==': ts.SyntaxKind.ExclamationEqualsEqualsToken,\n+  '||': ts.SyntaxKind.BarBarToken,\n+  '+': ts.SyntaxKind.PlusToken,\n+};\n+\n+const VAR_TYPES: Record<VariableDeclarationType, ts.NodeFlags> = {\n+  'const': ts.NodeFlags.Const,\n+  'let': ts.NodeFlags.Let,\n+  'var': ts.NodeFlags.None,\n+};\n+\n+/**\n+ * A TypeScript flavoured implementation of the AstFactory.\n+ */\n+export class TypeScriptAstFactory implements AstFactory<ts.Statement, ts.Expression> {\n+  private externalSourceFiles = new Map<string, ts.SourceMapSource>();\n+\n+  attachComments = attachComments;\n+\n+  createArrayLiteral = ts.createArrayLiteral;\n+\n+  createAssignment(target: ts.Expression, value: ts.Expression): ts.Expression {\n+    return ts.createBinary(target, ts.SyntaxKind.EqualsToken, value);\n+  }\n+\n+  createBinaryExpression(\n+      leftOperand: ts.Expression, operator: BinaryOperator,\n+      rightOperand: ts.Expression): ts.Expression {\n+    return ts.createBinary(leftOperand, BINARY_OPERATORS[operator], rightOperand);\n+  }\n+\n+  createBlock(body: ts.Statement[]): ts.Statement {\n+    return ts.createBlock(body);\n+  }\n+\n+  createCallExpression(callee: ts.Expression, args: ts.Expression[], pure: boolean): ts.Expression {\n+    const call = ts.createCall(callee, undefined, args);\n+    if (pure) {\n+      ts.addSyntheticLeadingComment(\n+          call, ts.SyntaxKind.MultiLineCommentTrivia, '@__PURE__', /* trailing newline */ false);\n+    }\n+    return call;\n+  }\n+\n+  createConditional = ts.createConditional;\n+\n+  createElementAccess = ts.createElementAccess;\n+\n+  createExpressionStatement = ts.createExpressionStatement;\n+\n+  createFunctionDeclaration(functionName: string|null, parameters: string[], body: ts.Statement):\n+      ts.Statement {\n+    if (!ts.isBlock(body)) {\n+      throw new Error(`Invalid syntax, expected a block, but got ${ts.SyntaxKind[body.kind]}.`);\n+    }\n+    return ts.createFunctionDeclaration(\n+        undefined, undefined, undefined, functionName ?? undefined, undefined,\n+        parameters.map(param => ts.createParameter(undefined, undefined, undefined, param)),\n+        undefined, body);\n+  }\n+\n+  createFunctionExpression(functionName: string|null, parameters: string[], body: ts.Statement):\n+      ts.Expression {\n+    if (!ts.isBlock(body)) {\n+      throw new Error(`Invalid syntax, expected a block, but got ${ts.SyntaxKind[body.kind]}.`);\n+    }\n+    return ts.createFunctionExpression(\n+        undefined, undefined, functionName ?? undefined, undefined,\n+        parameters.map(param => ts.createParameter(undefined, undefined, undefined, param)),\n+        undefined, body);\n+  }\n+\n+  createIdentifier = ts.createIdentifier;\n+\n+  createIfStatement(\n+      condition: ts.Expression, thenStatement: ts.Statement,\n+      elseStatement: ts.Statement|null): ts.Statement {\n+    return ts.createIf(condition, thenStatement, elseStatement ?? undefined);\n+  }\n+\n+  createLiteral(value: string|number|boolean|null|undefined): ts.Expression {\n+    if (value === undefined) {\n+      return ts.createIdentifier('undefined');\n+    } else if (value === null) {\n+      return ts.createNull();\n+    } else {\n+      return ts.createLiteral(value);\n+    }\n+  }\n+\n+  createNewExpression(expression: ts.Expression, args: ts.Expression[]): ts.Expression {\n+    return ts.createNew(expression, undefined, args);\n+  }\n+\n+  createObjectLiteral(properties: ObjectLiteralProperty<ts.Expression>[]): ts.Expression {\n+    return ts.createObjectLiteral(properties.map(\n+        prop => ts.createPropertyAssignment(\n+            prop.quoted ? ts.createLiteral(prop.propertyName) :\n+                          ts.createIdentifier(prop.propertyName),\n+            prop.value)));\n+  }\n+\n+  createParenthesizedExpression = ts.createParen;\n+\n+  createPropertyAccess = ts.createPropertyAccess;\n+\n+  createReturnStatement(expression: ts.Expression|null): ts.Statement {\n+    return ts.createReturn(expression ?? undefined);\n+  }\n+\n+  createTaggedTemplate(tag: ts.Expression, template: TemplateLiteral<ts.Expression>):\n+      ts.Expression {\n+    let templateLiteral: ts.TemplateLiteral;\n+    const length = template.elements.length;\n+    const head = template.elements[0];\n+    if (length === 1) {\n+      templateLiteral = ts.createNoSubstitutionTemplateLiteral(head.cooked, head.raw);\n+    } else {\n+      const spans: ts.TemplateSpan[] = [];\n+      // Create the middle parts\n+      for (let i = 1; i < length - 1; i++) {\n+        const {cooked, raw, range} = template.elements[i];\n+        const middle = createTemplateMiddle(cooked, raw);\n+        if (range !== null) {\n+          this.setSourceMapRange(middle, range);\n+        }\n+        spans.push(ts.createTemplateSpan(template.expressions[i - 1], middle));\n+      }\n+      // Create the tail part\n+      const resolvedExpression = template.expressions[length - 2];\n+      const templatePart = template.elements[length - 1];\n+      const templateTail = createTemplateTail(templatePart.cooked, templatePart.raw);\n+      if (templatePart.range !== null) {\n+        this.setSourceMapRange(templateTail, templatePart.range);\n+      }\n+      spans.push(ts.createTemplateSpan(resolvedExpression, templateTail));\n+      // Put it all together\n+      templateLiteral =\n+          ts.createTemplateExpression(ts.createTemplateHead(head.cooked, head.raw), spans);\n+    }\n+    if (head.range !== null) {\n+      this.setSourceMapRange(templateLiteral, head.range);\n+    }\n+    return ts.createTaggedTemplate(tag, templateLiteral);\n+  }\n+\n+  createThrowStatement = ts.createThrow;\n+\n+  createTypeOfExpression = ts.createTypeOf;\n+\n+\n+  createUnaryExpression(operator: UnaryOperator, operand: ts.Expression): ts.Expression {\n+    return ts.createPrefix(UNARY_OPERATORS[operator], operand);\n+  }\n+\n+  createVariableDeclaration(\n+      variableName: string, initializer: ts.Expression|null,\n+      type: VariableDeclarationType): ts.Statement {\n+    return ts.createVariableStatement(\n+        undefined,\n+        ts.createVariableDeclarationList(\n+            [ts.createVariableDeclaration(variableName, undefined, initializer ?? undefined)],\n+            VAR_TYPES[type]),\n+    );\n+  }\n+\n+  setSourceMapRange<T extends ts.Node>(node: T, sourceMapRange: SourceMapRange|null): T {\n+    if (sourceMapRange === null) {\n+      return node;\n+    }\n+\n+    const url = sourceMapRange.url;\n+    if (!this.externalSourceFiles.has(url)) {\n+      this.externalSourceFiles.set(\n+          url, ts.createSourceMapSource(url, sourceMapRange.content, pos => pos));\n+    }\n+    const source = this.externalSourceFiles.get(url);\n+    ts.setSourceMapRange(\n+        node, {pos: sourceMapRange.start.offset, end: sourceMapRange.end.offset, source});\n+    return node;\n+  }\n+}\n+\n+// HACK: Use this in place of `ts.createTemplateMiddle()`.\n+// Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed.\n+export function createTemplateMiddle(cooked: string, raw: string): ts.TemplateMiddle {\n+  const node: ts.TemplateLiteralLikeNode = ts.createTemplateHead(cooked, raw);\n+  (node.kind as ts.SyntaxKind) = ts.SyntaxKind.TemplateMiddle;\n+  return node as ts.TemplateMiddle;\n+}\n+\n+// HACK: Use this in place of `ts.createTemplateTail()`.\n+// Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed.\n+export function createTemplateTail(cooked: string, raw: string): ts.TemplateTail {\n+  const node: ts.TemplateLiteralLikeNode = ts.createTemplateHead(cooked, raw);\n+  (node.kind as ts.SyntaxKind) = ts.SyntaxKind.TemplateTail;\n+  return node as ts.TemplateTail;\n+}\n+\n+/**\n+ * Attach the given `leadingComments` to the `statement` node.\n+ *\n+ * @param statement The statement that will have comments attached.\n+ * @param leadingComments The comments to attach to the statement.\n+ */\n+export function attachComments<T extends ts.Statement>(\n+    statement: T, leadingComments?: LeadingComment[]): T {\n+  if (leadingComments === undefined) {\n+    return statement;\n+  }\n+\n+  for (const comment of leadingComments) {\n+    const commentKind = comment.multiline ? ts.SyntaxKind.MultiLineCommentTrivia :\n+                                            ts.SyntaxKind.SingleLineCommentTrivia;\n+    if (comment.multiline) {\n+      ts.addSyntheticLeadingComment(\n+          statement, commentKind, comment.toString(), comment.trailingNewline);\n+    } else {\n+      for (const line of comment.toString().split('\\n')) {\n+        ts.addSyntheticLeadingComment(statement, commentKind, line, comment.trailingNewline);\n+      }\n+    }\n+  }\n+  return statement;\n+}"
        },
        {
            "sha": "5e71dd760f0f825a67e13e31207e0ce0423f0a97",
            "filename": "packages/compiler-cli/src/ngtsc/translator/src/typescript_translator.ts",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftypescript_translator.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftypescript_translator.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Fsrc%2Ftypescript_translator.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -0,0 +1,33 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as o from '@angular/compiler';\n+import * as ts from 'typescript';\n+\n+import {ImportGenerator} from './api/import_generator';\n+import {Context} from './context';\n+import {ExpressionTranslatorVisitor, TranslatorOptions} from './translator';\n+import {TypeScriptAstFactory} from './typescript_ast_factory';\n+\n+export function translateExpression(\n+    expression: o.Expression, imports: ImportGenerator<ts.Expression>,\n+    options: TranslatorOptions<ts.Expression> = {}): ts.Expression {\n+  return expression.visitExpression(\n+      new ExpressionTranslatorVisitor<ts.Statement, ts.Expression>(\n+          new TypeScriptAstFactory(), imports, options),\n+      new Context(false));\n+}\n+\n+export function translateStatement(\n+    statement: o.Statement, imports: ImportGenerator<ts.Expression>,\n+    options: TranslatorOptions<ts.Expression> = {}): ts.Statement {\n+  return statement.visitStatement(\n+      new ExpressionTranslatorVisitor<ts.Statement, ts.Expression>(\n+          new TypeScriptAstFactory(), imports, options),\n+      new Context(true));\n+}"
        },
        {
            "sha": "ab5851162f3c1e8c52f482203717f142ea4d9654",
            "filename": "packages/compiler-cli/src/ngtsc/translator/test/BUILD.bazel",
            "status": "added",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Ftest%2FBUILD.bazel?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -0,0 +1,25 @@\n+load(\"//tools:defaults.bzl\", \"jasmine_node_test\", \"ts_library\")\n+\n+package(default_visibility = [\"//visibility:public\"])\n+\n+ts_library(\n+    name = \"test_lib\",\n+    testonly = True,\n+    srcs = glob([\n+        \"**/*.ts\",\n+    ]),\n+    deps = [\n+        \"//packages:types\",\n+        \"//packages/compiler\",\n+        \"//packages/compiler-cli/src/ngtsc/translator\",\n+        \"@npm//typescript\",\n+    ],\n+)\n+\n+jasmine_node_test(\n+    name = \"test\",\n+    bootstrap = [\"//tools/testing:node_no_angular_es5\"],\n+    deps = [\n+        \":test_lib\",\n+    ],\n+)"
        },
        {
            "sha": "b128a58432b052d4e0f32ed163961af7bc2266f9",
            "filename": "packages/compiler-cli/src/ngtsc/translator/test/typescript_ast_factory_spec.ts",
            "status": "added",
            "additions": 389,
            "deletions": 0,
            "changes": 389,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Ftest%2Ftypescript_ast_factory_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Ftest%2Ftypescript_ast_factory_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftranslator%2Ftest%2Ftypescript_ast_factory_spec.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -0,0 +1,389 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+import {leadingComment} from '@angular/compiler';\n+import * as ts from 'typescript';\n+\n+import {TypeScriptAstFactory} from '../src/typescript_ast_factory';\n+\n+describe('TypeScriptAstFactory', () => {\n+  let factory: TypeScriptAstFactory;\n+  beforeEach(() => factory = new TypeScriptAstFactory());\n+\n+  describe('attachComments()', () => {\n+    it('should add the comments to the given statement', () => {\n+      const {items: [stmt], generate} = setupStatements('x = 10;');\n+      factory.attachComments(\n+          stmt, [leadingComment('comment 1', true), leadingComment('comment 2', false)]);\n+\n+      expect(generate(stmt)).toEqual([\n+        '/* comment 1 */',\n+        '//comment 2',\n+        'x = 10;',\n+      ].join('\\n'));\n+    });\n+  });\n+\n+  describe('createArrayLiteral()', () => {\n+    it('should create an array node containing the provided expressions', () => {\n+      const {items: [expr1, expr2], generate} = setupExpressions(`42`, '\"moo\"');\n+      const array = factory.createArrayLiteral([expr1, expr2]);\n+      expect(generate(array)).toEqual('[42, \"moo\"]');\n+    });\n+  });\n+\n+  describe('createAssignment()', () => {\n+    it('should create an assignment node using the target and value expressions', () => {\n+      const {items: [target, value], generate} = setupExpressions(`x`, `42`);\n+      const assignment = factory.createAssignment(target, value);\n+      expect(generate(assignment)).toEqual('x = 42');\n+    });\n+  });\n+\n+  describe('createBinaryExpression()', () => {\n+    it('should create a binary operation node using the left and right expressions', () => {\n+      const {items: [left, right], generate} = setupExpressions(`17`, `42`);\n+      const assignment = factory.createBinaryExpression(left, '+', right);\n+      expect(generate(assignment)).toEqual('17 + 42');\n+    });\n+  });\n+\n+  describe('createBlock()', () => {\n+    it('should create a block statement containing the given statements', () => {\n+      const {items: stmts, generate} = setupStatements('x = 10; y = 20;');\n+      const block = factory.createBlock(stmts);\n+      expect(generate(block)).toEqual([\n+        '{',\n+        '    x = 10;',\n+        '    y = 20;',\n+        '}',\n+      ].join('\\n'));\n+    });\n+  });\n+\n+  describe('createCallExpression()', () => {\n+    it('should create a call on the `callee` with the given `args`', () => {\n+      const {items: [callee, arg1, arg2], generate} = setupExpressions('foo', '42', '\"moo\"');\n+      const call = factory.createCallExpression(callee, [arg1, arg2], false);\n+      expect(generate(call)).toEqual('foo(42, \"moo\")');\n+    });\n+\n+    it('should create a call marked with a PURE comment if `pure` is true', () => {\n+      const {items: [callee, arg1, arg2], generate} = setupExpressions(`foo`, `42`, `\"moo\"`);\n+      const call = factory.createCallExpression(callee, [arg1, arg2], true);\n+      expect(generate(call)).toEqual('/*@__PURE__*/ foo(42, \"moo\")');\n+    });\n+  });\n+\n+  describe('createConditional()', () => {\n+    it('should create a condition expression', () => {\n+      const {items: [test, thenExpr, elseExpr], generate} =\n+          setupExpressions(`!test`, `42`, `\"moo\"`);\n+      const conditional = factory.createConditional(test, thenExpr, elseExpr);\n+      expect(generate(conditional)).toEqual('!test ? 42 : \"moo\"');\n+    });\n+  });\n+\n+  describe('createElementAccess()', () => {\n+    it('should create an expression accessing the element of an array/object', () => {\n+      const {items: [expr, element], generate} = setupExpressions(`obj`, `\"moo\"`);\n+      const access = factory.createElementAccess(expr, element);\n+      expect(generate(access)).toEqual('obj[\"moo\"]');\n+    });\n+  });\n+\n+  describe('createExpressionStatement()', () => {\n+    it('should create a statement node from the given expression', () => {\n+      const {items: [expr], generate} = setupExpressions(`x = 10`);\n+      const stmt = factory.createExpressionStatement(expr);\n+      expect(ts.isExpressionStatement(stmt)).toBe(true);\n+      expect(generate(stmt)).toEqual('x = 10;');\n+    });\n+  });\n+\n+  describe('createFunctionDeclaration()', () => {\n+    it('should create a function declaration node with the given name, parameters and body statements',\n+       () => {\n+         const {items: [body], generate} = setupStatements('{x = 10; y = 20;}');\n+         const fn = factory.createFunctionDeclaration('foo', ['arg1', 'arg2'], body);\n+         expect(generate(fn))\n+             .toEqual(\n+                 'function foo(arg1, arg2) { x = 10; y = 20; }',\n+             );\n+       });\n+  });\n+\n+  describe('createFunctionExpression()', () => {\n+    it('should create a function expression node with the given name, parameters and body statements',\n+       () => {\n+         const {items: [body], generate} = setupStatements('{x = 10; y = 20;}');\n+         const fn = factory.createFunctionExpression('foo', ['arg1', 'arg2'], body);\n+         expect(ts.isExpressionStatement(fn)).toBe(false);\n+         expect(generate(fn)).toEqual('function foo(arg1, arg2) { x = 10; y = 20; }');\n+       });\n+\n+    it('should create an anonymous function expression node if the name is null', () => {\n+      const {items: [body], generate} = setupStatements('{x = 10; y = 20;}');\n+      const fn = factory.createFunctionExpression(null, ['arg1', 'arg2'], body);\n+      expect(generate(fn)).toEqual('function (arg1, arg2) { x = 10; y = 20; }');\n+    });\n+  });\n+\n+  describe('createIdentifier()', () => {\n+    it('should create an identifier with the given name', () => {\n+      const id = factory.createIdentifier('someId') as ts.Identifier;\n+      expect(ts.isIdentifier(id)).toBe(true);\n+      expect(id.text).toEqual('someId');\n+    });\n+  });\n+\n+  describe('createIfStatement()', () => {\n+    it('should create an if-else statement', () => {\n+      const {items: [testStmt, thenStmt, elseStmt], generate} =\n+          setupStatements('!test;x = 10;x = 42;');\n+      const test = (testStmt as ts.ExpressionStatement).expression;\n+      const ifStmt = factory.createIfStatement(test, thenStmt, elseStmt);\n+      expect(generate(ifStmt)).toEqual([\n+        'if (!test)',\n+        '    x = 10;',\n+        'else',\n+        '    x = 42;',\n+      ].join('\\n'));\n+    });\n+\n+    it('should create an if statement if the else expression is null', () => {\n+      const {items: [testStmt, thenStmt], generate} = setupStatements('!test;x = 10;');\n+      const test = (testStmt as ts.ExpressionStatement).expression;\n+      const ifStmt = factory.createIfStatement(test, thenStmt, null);\n+      expect(generate(ifStmt)).toEqual([\n+        'if (!test)',\n+        '    x = 10;',\n+      ].join('\\n'));\n+    });\n+  });\n+\n+  describe('createLiteral()', () => {\n+    it('should create a string literal', () => {\n+      const {generate} = setupStatements();\n+      const literal = factory.createLiteral('moo');\n+      expect(ts.isStringLiteral(literal)).toBe(true);\n+      expect(generate(literal)).toEqual('\"moo\"');\n+    });\n+\n+    it('should create a number literal', () => {\n+      const {generate} = setupStatements();\n+      const literal = factory.createLiteral(42);\n+      expect(ts.isNumericLiteral(literal)).toBe(true);\n+      expect(generate(literal)).toEqual('42');\n+    });\n+\n+    it('should create a number literal for `NaN`', () => {\n+      const {generate} = setupStatements();\n+      const literal = factory.createLiteral(NaN);\n+      expect(ts.isNumericLiteral(literal)).toBe(true);\n+      expect(generate(literal)).toEqual('NaN');\n+    });\n+\n+    it('should create a boolean literal', () => {\n+      const {generate} = setupStatements();\n+      const literal = factory.createLiteral(true);\n+      expect(ts.isToken(literal)).toBe(true);\n+      expect(generate(literal)).toEqual('true');\n+    });\n+\n+    it('should create an `undefined` literal', () => {\n+      const {generate} = setupStatements();\n+      const literal = factory.createLiteral(undefined);\n+      expect(ts.isIdentifier(literal)).toBe(true);\n+      expect(generate(literal)).toEqual('undefined');\n+    });\n+\n+    it('should create a `null` literal', () => {\n+      const {generate} = setupStatements();\n+      const literal = factory.createLiteral(null);\n+      expect(ts.isToken(literal)).toBe(true);\n+      expect(generate(literal)).toEqual('null');\n+    });\n+  });\n+\n+  describe('createNewExpression()', () => {\n+    it('should create a `new` operation on the constructor `expression` with the given `args`',\n+       () => {\n+         const {items: [expr, arg1, arg2], generate} = setupExpressions('Foo', '42', '\"moo\"');\n+         const call = factory.createNewExpression(expr, [arg1, arg2]);\n+         expect(generate(call)).toEqual('new Foo(42, \"moo\")');\n+       });\n+  });\n+\n+  describe('createObjectLiteral()', () => {\n+    it('should create an object literal node, with the given properties', () => {\n+      const {items: [prop1, prop2], generate} = setupExpressions('42', '\"moo\"');\n+      const obj = factory.createObjectLiteral([\n+        {propertyName: 'prop1', value: prop1, quoted: false},\n+        {propertyName: 'prop2', value: prop2, quoted: true},\n+      ]);\n+      expect(generate(obj)).toEqual('{ prop1: 42, \"prop2\": \"moo\" }');\n+    });\n+  });\n+\n+  describe('createParenthesizedExpression()', () => {\n+    it('should add parentheses around the given expression', () => {\n+      const {items: [expr], generate} = setupExpressions(`a + b`);\n+      const paren = factory.createParenthesizedExpression(expr);\n+      expect(generate(paren)).toEqual('(a + b)');\n+    });\n+  });\n+\n+  describe('createPropertyAccess()', () => {\n+    it('should create a property access expression node', () => {\n+      const {items: [expr], generate} = setupExpressions(`obj`);\n+      const access = factory.createPropertyAccess(expr, 'moo');\n+      expect(generate(access)).toEqual('obj.moo');\n+    });\n+  });\n+\n+  describe('createReturnStatement()', () => {\n+    it('should create a return statement returning the given expression', () => {\n+      const {items: [expr], generate} = setupExpressions(`42`);\n+      const returnStmt = factory.createReturnStatement(expr);\n+      expect(generate(returnStmt)).toEqual('return 42;');\n+    });\n+\n+    it('should create a void return statement if the expression is null', () => {\n+      const {generate} = setupStatements();\n+      const returnStmt = factory.createReturnStatement(null);\n+      expect(generate(returnStmt)).toEqual('return;');\n+    });\n+  });\n+\n+  describe('createTaggedTemplate()', () => {\n+    it('should create a tagged template node from the tag, elements and expressions', () => {\n+      const elements = [\n+        {raw: 'raw\\\\n1', cooked: 'raw\\n1', range: null},\n+        {raw: 'raw\\\\n2', cooked: 'raw\\n2', range: null},\n+        {raw: 'raw\\\\n3', cooked: 'raw\\n3', range: null},\n+      ];\n+      const {items: [tag, ...expressions], generate} = setupExpressions('tagFn', '42', '\"moo\"');\n+      const template = factory.createTaggedTemplate(tag, {elements, expressions});\n+      expect(generate(template)).toEqual('tagFn `raw\\\\n1${42}raw\\\\n2${\"moo\"}raw\\\\n3`');\n+    });\n+  });\n+\n+  describe('createThrowStatement()', () => {\n+    it('should create a throw statement, throwing the given expression', () => {\n+      const {items: [expr], generate} = setupExpressions(`new Error(\"bad\")`);\n+      const throwStmt = factory.createThrowStatement(expr);\n+      expect(generate(throwStmt)).toEqual('throw new Error(\"bad\");');\n+    });\n+  });\n+\n+  describe('createTypeOfExpression()', () => {\n+    it('should create a typeof expression node', () => {\n+      const {items: [expr], generate} = setupExpressions(`42`);\n+      const typeofExpr = factory.createTypeOfExpression(expr);\n+      expect(generate(typeofExpr)).toEqual('typeof 42');\n+    });\n+  });\n+\n+  describe('createUnaryExpression()', () => {\n+    it('should create a unary expression with the operator and operand', () => {\n+      const {items: [expr], generate} = setupExpressions(`value`);\n+      const unaryExpr = factory.createUnaryExpression('!', expr);\n+      expect(generate(unaryExpr)).toEqual('!value');\n+    });\n+  });\n+\n+  describe('createVariableDeclaration()', () => {\n+    it('should create a variable declaration statement node for the given variable name and initializer',\n+       () => {\n+         const {items: [initializer], generate} = setupExpressions(`42`);\n+         const varDecl = factory.createVariableDeclaration('foo', initializer, 'let');\n+         expect(generate(varDecl)).toEqual('let foo = 42;');\n+       });\n+\n+    it('should create a constant declaration statement node for the given variable name and initializer',\n+       () => {\n+         const {items: [initializer], generate} = setupExpressions(`42`);\n+         const varDecl = factory.createVariableDeclaration('foo', initializer, 'const');\n+         expect(generate(varDecl)).toEqual('const foo = 42;');\n+       });\n+\n+    it('should create a downleveled declaration statement node for the given variable name and initializer',\n+       () => {\n+         const {items: [initializer], generate} = setupExpressions(`42`);\n+         const varDecl = factory.createVariableDeclaration('foo', initializer, 'var');\n+         expect(generate(varDecl)).toEqual('var foo = 42;');\n+       });\n+\n+    it('should create an uninitialized variable declaration statement node for the given variable name and a null initializer',\n+       () => {\n+         const {generate} = setupStatements();\n+         const varDecl = factory.createVariableDeclaration('foo', null, 'let');\n+         expect(generate(varDecl)).toEqual('let foo;');\n+       });\n+  });\n+\n+  describe('setSourceMapRange()', () => {\n+    it('should attach the `sourceMapRange` to the given `node`', () => {\n+      const {items: [expr]} = setupExpressions(`42`);\n+\n+      factory.setSourceMapRange(expr, {\n+        start: {line: 0, column: 1, offset: 1},\n+        end: {line: 2, column: 3, offset: 15},\n+        content: '-****\\n*****\\n****',\n+        url: 'original.ts'\n+      });\n+\n+      const range = ts.getSourceMapRange(expr);\n+      expect(range.pos).toEqual(1);\n+      expect(range.end).toEqual(15);\n+      expect(range.source?.getLineAndCharacterOfPosition(range.pos))\n+          .toEqual({line: 0, character: 1});\n+      expect(range.source?.getLineAndCharacterOfPosition(range.end))\n+          .toEqual({line: 2, character: 3});\n+    });\n+  });\n+});\n+\n+/**\n+ * Setup some statements to use in a test, along with a generate function to print the created nodes\n+ * out.\n+ *\n+ * The TypeScript printer requires access to the original source of non-synthesized nodes.\n+ * It uses the source content to output things like text between parts of nodes, which it doesn't\n+ * store in the AST node itself.\n+ *\n+ * So this helper (and its sister `setupExpressions()`) capture the original source file used to\n+ * provide the original statements/expressions that are used in the tests so that the printing will\n+ * work via the returned `generate()` function.\n+ */\n+function setupStatements(stmts: string = ''): SetupResult<ts.Statement> {\n+  const printer = ts.createPrinter();\n+  const sf = ts.createSourceFile('test.ts', stmts, ts.ScriptTarget.ES2015, true);\n+  return {\n+    items: Array.from(sf.statements),\n+    generate: (node: ts.Node) => printer.printNode(ts.EmitHint.Unspecified, node, sf),\n+  };\n+}\n+\n+/**\n+ * Setup some statements to use in a test, along with a generate function to print the created nodes\n+ * out.\n+ *\n+ * See `setupStatements()` for more information about this helper function.\n+ */\n+function setupExpressions(...exprs: string[]): SetupResult<ts.Expression> {\n+  const {items: [arrayStmt], generate} = setupStatements(`[${exprs.join(',')}];`);\n+  const expressions = Array.from(\n+      ((arrayStmt as ts.ExpressionStatement).expression as ts.ArrayLiteralExpression).elements);\n+  return {items: expressions, generate};\n+}\n+\n+interface SetupResult<TNode extends ts.Node> {\n+  items: TNode[];\n+  generate(node: ts.Node): string;\n+}"
        },
        {
            "sha": "d0c25504ba9538f5abb019dea3539b8236921d8f",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/environment.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "raw_url": "https://github.com/angular/angular/raw/297b123151efe59a80bde74e719999bcc7e1f077/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fenvironment.ts?ref=297b123151efe59a80bde74e719999bcc7e1f077",
            "patch": "@@ -9,7 +9,7 @@\n import {ExpressionType, ExternalExpr, Type, WrappedNodeExpr} from '@angular/compiler';\n import * as ts from 'typescript';\n \n-import {ImportFlags, NOOP_DEFAULT_IMPORT_RECORDER, Reference, ReferenceEmitter} from '../../imports';\n+import {ImportFlags, Reference, ReferenceEmitter} from '../../imports';\n import {ClassDeclaration, ReflectionHost} from '../../reflection';\n import {ImportManager, translateExpression, translateType} from '../../translator';\n import {TypeCheckableDirectiveMeta, TypeCheckingConfig, TypeCtorMetadata} from '../api';\n@@ -213,8 +213,7 @@ export class Environment {\n     const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing);\n \n     // Use `translateExpression` to convert the `Expression` into a `ts.Expression`.\n-    return translateExpression(\n-        ngExpr, this.importManager, NOOP_DEFAULT_IMPORT_RECORDER, ts.ScriptTarget.ES2015);\n+    return translateExpression(ngExpr, this.importManager);\n   }\n \n   /**"
        }
    ],
    "stats": {
        "total": 1826,
        "additions": 1395,
        "deletions": 431
    }
}