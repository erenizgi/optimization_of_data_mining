{
    "author": "atscott",
    "message": "fix(router): ensure duplicate popstate/hashchange events are handled correctly (#37674)\n\nThe current method of handling duplicate navigations caused by 'hashchange' and 'popstate' events for the same url change does not correctly handle cancelled navigations. Because `scheduleNavigation` is called in a `setTimeout` in the location change subscription, the duplicate navigations are not flushed at the same time. This means that if the initial navigation hits a guard that schedules a new navigation, the navigation for the duplicate event will not compare to the correct transition (because we inserted another navigation between the duplicates). See https://github.com/angular/angular/issues/16710#issuecomment-646919529\n\nFixes #16710\n\nPR Close #37674",
    "sha": "9185c6e9715ec2f03cc9c582b26f6ce73e59e52f",
    "files": [
        {
            "sha": "93c9f66230a601035ea06054728216d7a99a85b6",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/9185c6e9715ec2f03cc9c582b26f6ce73e59e52f/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/9185c6e9715ec2f03cc9c582b26f6ce73e59e52f/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=9185c6e9715ec2f03cc9c582b26f6ce73e59e52f",
            "patch": "@@ -39,7 +39,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2289,\n-        \"main-es2015\": 245488,\n+        \"main-es2015\": 246044,\n         \"polyfills-es2015\": 36938,\n         \"5-es2015\": 751\n       }\n@@ -49,7 +49,7 @@\n     \"master\": {\n       \"uncompressed\": {\n         \"runtime-es2015\": 2289,\n-        \"main-es2015\": 221268,\n+        \"main-es2015\": 221897,\n         \"polyfills-es2015\": 36938,\n         \"5-es2015\": 779\n       }"
        },
        {
            "sha": "5d7619e529f668857a65c5b7a941a464ad67cd78",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 69,
            "deletions": 30,
            "changes": 99,
            "blob_url": "https://github.com/angular/angular/blob/9185c6e9715ec2f03cc9c582b26f6ce73e59e52f/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/9185c6e9715ec2f03cc9c582b26f6ce73e59e52f/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=9185c6e9715ec2f03cc9c582b26f6ce73e59e52f",
            "patch": "@@ -6,9 +6,9 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {Location} from '@angular/common';\n+import {Location, PopStateEvent} from '@angular/common';\n import {Compiler, Injectable, Injector, isDevMode, NgModuleFactoryLoader, NgModuleRef, NgZone, Type, ÉµConsole as Console} from '@angular/core';\n-import {BehaviorSubject, EMPTY, Observable, of, Subject, Subscription} from 'rxjs';\n+import {BehaviorSubject, EMPTY, Observable, of, Subject, SubscriptionLike} from 'rxjs';\n import {catchError, filter, finalize, map, switchMap, tap} from 'rxjs/operators';\n \n import {QueryParamsHandling, Route, Routes, standardizeConfig, validateConfig} from './config';\n@@ -276,6 +276,16 @@ function defaultRouterHook(snapshot: RouterStateSnapshot, runExtras: {\n   return of(null) as any;\n }\n \n+/**\n+ * Information related to a location change, necessary for scheduling follow-up Router navigations.\n+ */\n+type LocationChangeInfo = {\n+  source: 'popstate'|'hashchange',\n+  urlTree: UrlTree,\n+  state: RestoredState|null,\n+  transitionId: number\n+};\n+\n /**\n  * @description\n  *\n@@ -298,8 +308,12 @@ export class Router {\n   private lastSuccessfulNavigation: Navigation|null = null;\n   private currentNavigation: Navigation|null = null;\n \n-  // TODO(issue/24571): remove '!'.\n-  private locationSubscription!: Subscription;\n+  private locationSubscription?: SubscriptionLike;\n+  /**\n+   * Tracks the previously seen location change from the location subscription so we can compare\n+   * the two latest to see if they are duplicates. See setUpLocationChangeListener.\n+   */\n+  private lastLocationChangeInfo: LocationChangeInfo|null = null;\n   private navigationId: number = 0;\n   private configLoader: RouterConfigLoader;\n   private ngModule: NgModuleRef<any>;\n@@ -851,26 +865,66 @@ export class Router {\n   }\n \n   /**\n-   * Sets up the location change listener.\n+   * Sets up the location change listener. This listener detects navigations triggered from outside\n+   * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\n+   * navigation so that the correct events, guards, etc. are triggered.\n    */\n   setUpLocationChangeListener(): void {\n     // Don't need to use Zone.wrap any more, because zone.js\n     // already patch onPopState, so location change callback will\n     // run into ngZone\n     if (!this.locationSubscription) {\n-      this.locationSubscription = <any>this.location.subscribe((change: any) => {\n-        let rawUrlTree = this.parseUrl(change['url']);\n-        const source: NavigationTrigger = change['type'] === 'popstate' ? 'popstate' : 'hashchange';\n-        // Navigations coming from Angular router have a navigationId state property. When this\n-        // exists, restore the state.\n-        const state = change.state && change.state.navigationId ? change.state : null;\n-        setTimeout(() => {\n-          this.scheduleNavigation(rawUrlTree, source, state, {replaceUrl: true});\n-        }, 0);\n+      this.locationSubscription = this.location.subscribe(event => {\n+        const currentChange = this.extractLocationChangeInfoFromEvent(event);\n+        if (this.shouldScheduleNavigation(this.lastLocationChangeInfo, currentChange)) {\n+          // The `setTimeout` was added in #12160 and is likely to support Angular/AngularJS\n+          // hybrid apps.\n+          setTimeout(() => {\n+            const {source, state, urlTree} = currentChange;\n+            this.scheduleNavigation(urlTree, source, state, {replaceUrl: true});\n+          }, 0);\n+        }\n+        this.lastLocationChangeInfo = currentChange;\n       });\n     }\n   }\n \n+  /** Extracts router-related information from a `PopStateEvent`. */\n+  private extractLocationChangeInfoFromEvent(change: PopStateEvent): LocationChangeInfo {\n+    return {\n+      source: change['type'] === 'popstate' ? 'popstate' : 'hashchange',\n+      urlTree: this.parseUrl(change['url']!),\n+      // Navigations coming from Angular router have a navigationId state\n+      // property. When this exists, restore the state.\n+      state: change.state?.navigationId ? change.state : null,\n+      transitionId: this.getTransition().id\n+    } as const;\n+  }\n+\n+  /**\n+   * Determines whether two events triggered by the Location subscription are due to the same\n+   * navigation. The location subscription can fire two events (popstate and hashchange) for a\n+   * single navigation. The second one should be ignored, that is, we should not schedule another\n+   * navigation in the Router.\n+   */\n+  private shouldScheduleNavigation(previous: LocationChangeInfo|null, current: LocationChangeInfo):\n+      boolean {\n+    if (!previous) return true;\n+\n+    const sameDestination = current.urlTree.toString() === previous.urlTree.toString();\n+    const eventsOccurredAtSameTime = current.transitionId === previous.transitionId;\n+    if (!eventsOccurredAtSameTime || !sameDestination) {\n+      return true;\n+    }\n+\n+    if ((current.source === 'hashchange' && previous.source === 'popstate') ||\n+        (current.source === 'popstate' && previous.source === 'hashchange')) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n   /** The current URL. */\n   get url(): string {\n     return this.serializeUrl(this.currentUrlTree);\n@@ -918,7 +972,7 @@ export class Router {\n   dispose(): void {\n     if (this.locationSubscription) {\n       this.locationSubscription.unsubscribe();\n-      this.locationSubscription = null!;\n+      this.locationSubscription = undefined;\n     }\n   }\n \n@@ -1151,21 +1205,6 @@ export class Router {\n       return Promise.resolve(true);  // return value is not used\n     }\n \n-    // Because of a bug in IE and Edge, the location class fires two events (popstate and\n-    // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n-    // flicker. Handles the case when a popstate was emitted first.\n-    if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&\n-        lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n-      return Promise.resolve(true);  // return value is not used\n-    }\n-    // Because of a bug in IE and Edge, the location class fires two events (popstate and\n-    // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n-    // flicker. Handles the case when a hashchange was emitted first.\n-    if (lastNavigation && source == 'popstate' && lastNavigation.source === 'hashchange' &&\n-        lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n-      return Promise.resolve(true);  // return value is not used\n-    }\n-\n     let resolve: any;\n     let reject: any;\n     let promise: Promise<boolean>;"
        },
        {
            "sha": "ce343becea8295c43d6032dd2164eadb63f813ad",
            "filename": "packages/router/test/integration.spec.ts",
            "status": "modified",
            "additions": 47,
            "deletions": 13,
            "changes": 60,
            "blob_url": "https://github.com/angular/angular/blob/9185c6e9715ec2f03cc9c582b26f6ce73e59e52f/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/9185c6e9715ec2f03cc9c582b26f6ce73e59e52f/packages%2Frouter%2Ftest%2Fintegration.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Ftest%2Fintegration.spec.ts?ref=9185c6e9715ec2f03cc9c582b26f6ce73e59e52f",
            "patch": "@@ -910,17 +910,29 @@ describe('Integration', () => {\n      })));\n \n   describe('duplicate in-flight navigations', () => {\n+    @Injectable()\n+    class RedirectingGuard {\n+      constructor(private router: Router) {}\n+      canActivate() {\n+        this.router.navigate(['/simple']);\n+        return false;\n+      }\n+    }\n+\n     beforeEach(() => {\n       TestBed.configureTestingModule({\n-        providers: [{\n-          provide: 'in1Second',\n-          useValue: (c: any, a: ActivatedRouteSnapshot, b: RouterStateSnapshot) => {\n-            let res: any = null;\n-            const p = new Promise(_ => res = _);\n-            setTimeout(() => res(true), 1000);\n-            return p;\n-          }\n-        }]\n+        providers: [\n+          {\n+            provide: 'in1Second',\n+            useValue: (c: any, a: ActivatedRouteSnapshot, b: RouterStateSnapshot) => {\n+              let res: any = null;\n+              const p = new Promise(_ => res = _);\n+              setTimeout(() => res(true), 1000);\n+              return p;\n+            }\n+          },\n+          RedirectingGuard\n+        ]\n       });\n     });\n \n@@ -966,6 +978,28 @@ describe('Integration', () => {\n \n          expect(location.path()).toEqual('/simple');\n        }));\n+\n+    it('should skip duplicate location events', fakeAsync(() => {\n+         const router = TestBed.inject(Router);\n+         const location = TestBed.inject(Location) as unknown as SpyLocation;\n+         const fixture = createRoot(router, RootCmp);\n+\n+         router.resetConfig([\n+           {path: 'blocked', component: SimpleCmp, canActivate: [RedirectingGuard]},\n+           {path: 'simple', component: SimpleCmp}\n+         ]);\n+         router.navigateByUrl('/simple');\n+         advance(fixture);\n+\n+         const recordedEvents = [] as Event[];\n+         router.events.forEach(e => onlyNavigationStartAndEnd(e) && recordedEvents.push(e));\n+\n+         location.simulateUrlPop('/blocked');\n+         location.simulateHashChange('/blocked');\n+\n+         advance(fixture);\n+         expectEvents(recordedEvents, [[NavigationStart, '/blocked']]);\n+       }));\n   });\n \n   it('should support secondary routes', fakeAsync(inject([Router], (router: Router) => {\n@@ -3878,8 +3912,8 @@ describe('Integration', () => {\n \n            expectEvents(recordedEvents, [\n              [NavigationStart, '/lazyFalse/loaded'],\n-             // No GuardCheck events as `canLoad` is a special guard that's not actually part of the\n-             // guard lifecycle.\n+             // No GuardCheck events as `canLoad` is a special guard that's not actually part of\n+             // the guard lifecycle.\n              [NavigationCancel, '/lazyFalse/loaded'],\n \n              [NavigationStart, '/blank'], [RoutesRecognized, '/blank'],\n@@ -4842,8 +4876,8 @@ describe('Integration', () => {\n         constructor(\n             lazy: LazyParentComponent,  // should be able to inject lazy/direct parent\n             lazyService: LazyLoadedServiceDefinedInModule,  // should be able to inject lazy service\n-            eager:\n-                EagerParentComponent  // should use the injector of the location to create a parent\n+            eager: EagerParentComponent  // should use the injector of the location to create a\n+                                         // parent\n         ) {}\n       }\n "
        }
    ],
    "stats": {
        "total": 163,
        "additions": 118,
        "deletions": 45
    }
}