{
    "author": "unknown",
    "message": "feat(core): support APP_INITIALIZER work with observable (#33222)\n\nThis commit adds support for Observables that now can be used as a part of APP_INITIALIZER. Previously, only\nPrimises were supported.\n\nCloses #15088.\n\nPR Close #33222",
    "sha": "ca17ac523cc2ed8046931c86a2c12d97fb6796ca",
    "files": [
        {
            "sha": "76707e8aa0b7aa72808f01d24097eca17fbb843f",
            "filename": "packages/core/src/application_init.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/ca17ac523cc2ed8046931c86a2c12d97fb6796ca/packages%2Fcore%2Fsrc%2Fapplication_init.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca17ac523cc2ed8046931c86a2c12d97fb6796ca/packages%2Fcore%2Fsrc%2Fapplication_init.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Fapplication_init.ts?ref=ca17ac523cc2ed8046931c86a2c12d97fb6796ca",
            "patch": "@@ -7,7 +7,7 @@\n  */\n \n import {Inject, Injectable, InjectionToken, Optional} from './di';\n-import {isPromise} from './util/lang';\n+import {isObservable, isPromise} from './util/lang';\n import {noop} from './util/noop';\n \n \n@@ -16,8 +16,8 @@ import {noop} from './util/noop';\n  * one or more initialization functions.\n  *\n  * The provided functions are injected at application startup and executed during\n- * app initialization. If any of these functions returns a Promise, initialization\n- * does not complete until the Promise is resolved.\n+ * app initialization. If any of these functions returns a Promise or an Observable, initialization\n+ * does not complete until the Promise is resolved or the Observable is completed.\n  *\n  * You can, for example, create a factory function that loads language data\n  * or an external configuration, and provide that function to the `APP_INITIALIZER` token.\n@@ -68,6 +68,11 @@ export class ApplicationInitStatus {\n         const initResult = this.appInits[i]();\n         if (isPromise(initResult)) {\n           asyncInitPromises.push(initResult);\n+        } else if (isObservable(initResult)) {\n+          const observableAsPromise = new Promise<void>((resolve, reject) => {\n+            initResult.subscribe({complete: resolve, error: reject});\n+          });\n+          asyncInitPromises.push(observableAsPromise);\n         }\n       }\n     }"
        },
        {
            "sha": "70dc0c84afac35993ce2a36c50ef195029fff845",
            "filename": "packages/core/test/application_init_spec.ts",
            "status": "modified",
            "additions": 123,
            "deletions": 21,
            "changes": 144,
            "blob_url": "https://github.com/angular/angular/blob/ca17ac523cc2ed8046931c86a2c12d97fb6796ca/packages%2Fcore%2Ftest%2Fapplication_init_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/ca17ac523cc2ed8046931c86a2c12d97fb6796ca/packages%2Fcore%2Ftest%2Fapplication_init_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fapplication_init_spec.ts?ref=ca17ac523cc2ed8046931c86a2c12d97fb6796ca",
            "patch": "@@ -5,8 +5,8 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {Injector} from '@angular/core';\n import {APP_INITIALIZER, ApplicationInitStatus} from '@angular/core/src/application_init';\n+import {Observable, Subscriber} from 'rxjs';\n \n import {inject, TestBed, waitForAsync} from '../testing';\n \n@@ -28,50 +28,152 @@ import {inject, TestBed, waitForAsync} from '../testing';\n          })));\n     });\n \n-    describe('with async initializers', () => {\n+    describe('with async promise initializers', () => {\n       let resolve: (result: any) => void;\n+      let reject: (reason?: any) => void;\n       let promise: Promise<any>;\n-      let completerResolver = false;\n+      let initFnInvoked = false;\n       beforeEach(() => {\n-        let initializerFactory = (injector: Injector) => {\n-          return () => {\n-            const initStatus = injector.get(ApplicationInitStatus);\n-            initStatus.donePromise.then(() => {\n-              expect(completerResolver).toBe(true);\n-            });\n-          };\n-        };\n-        promise = new Promise((res) => {\n+        promise = new Promise((res, rej) => {\n           resolve = res;\n+          reject = rej;\n         });\n         TestBed.configureTestingModule({\n           providers: [\n             {provide: APP_INITIALIZER, multi: true, useValue: () => promise},\n-            {\n-              provide: APP_INITIALIZER,\n-              multi: true,\n-              useFactory: initializerFactory,\n-              deps: [Injector]\n-            },\n           ]\n         });\n       });\n \n-      it('should update the status once all async initializers are done',\n+      it('should update the status once all async promise initializers are done',\n          waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n+           // Accessing internal `runInitializers` function of the `ApplicationInitStatus` class\n+           // instance for testing purposes to invoke initializer functions.\n            (status as any).runInitializers();\n \n            setTimeout(() => {\n-             completerResolver = true;\n+             initFnInvoked = true;\n              resolve(null);\n            });\n \n            expect(status.done).toBe(false);\n            status.donePromise.then(() => {\n              expect(status.done).toBe(true);\n-             expect(completerResolver).toBe(true);\n+             expect(initFnInvoked).toBe(true);\n            });\n          })));\n+\n+      it('should handle a case when promise is rejected',\n+         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n+           // Accessing internal `runInitializers` function of the `ApplicationInitStatus` class\n+           // instance for testing purposes to invoke initializer functions.\n+           (status as any).runInitializers();\n+\n+           setTimeout(() => {\n+             initFnInvoked = true;\n+             reject();\n+           });\n+\n+           expect(status.done).toBe(false);\n+           status.donePromise\n+               .then(\n+                   () => fail('`donePromise.then` should not be invoked when promise is rejected'))\n+               .catch(() => {\n+                 expect(status.done).toBe(false);\n+                 expect(initFnInvoked).toBe(true);\n+               });\n+         })));\n+    });\n+\n+    describe('with app initializers represented using observables', () => {\n+      let subscriber: Subscriber<any>;\n+      let observable: Observable<any>;\n+      let initFnInvoked = false;\n+      beforeEach(() => {\n+        observable = new Observable((res) => {\n+          subscriber = res;\n+        });\n+        TestBed.configureTestingModule({\n+          providers: [\n+            {provide: APP_INITIALIZER, multi: true, useValue: () => observable},\n+          ]\n+        });\n+      });\n+\n+      it('should update the status once all async observable initializers are completed',\n+         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n+           // Accessing internal `runInitializers` function of the `ApplicationInitStatus` class\n+           // instance for testing purposes to invoke initializer functions.\n+           (status as any).runInitializers();\n+\n+           setTimeout(() => {\n+             initFnInvoked = true;\n+             subscriber.complete();\n+           });\n+\n+           expect(status.done).toBe(false);\n+           status.donePromise.then(() => {\n+             expect(status.done).toBe(true);\n+             expect(initFnInvoked).toBe(true);\n+           });\n+         })));\n+\n+      it('should update the status once all async observable initializers nexted and completed',\n+         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n+           // Accessing internal `runInitializers` function of the `ApplicationInitStatus` class\n+           // instance for testing purposes to invoke initializer functions.\n+           (status as any).runInitializers();\n+\n+           subscriber.next('one');\n+           subscriber.next('two');\n+\n+           setTimeout(() => {\n+             initFnInvoked = true;\n+             subscriber.complete();\n+           });\n+\n+           expect(status.done).toBe(false);\n+           status.donePromise.then(() => {\n+             expect(status.done).toBe(true);\n+             expect(initFnInvoked).toBe(true);\n+           });\n+         })));\n+\n+      it('should update the status if all async observable initializers are completed before runInitializers',\n+         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n+           subscriber.complete();\n+           // Accessing internal `runInitializers` function of the `ApplicationInitStatus` class\n+           // instance for testing purposes to invoke initializer functions.\n+           (status as any).runInitializers();\n+\n+           expect(status.done).toBe(false);\n+\n+           status.donePromise.then(() => {\n+             expect(status.done).toBe(true);\n+           });\n+         })));\n+\n+      it('should handle a case when observable emits an error',\n+         waitForAsync(inject([ApplicationInitStatus], (status: ApplicationInitStatus) => {\n+           // Accessing internal `runInitializers` function of the `ApplicationInitStatus` class\n+           // instance for testing purposes to invoke initializer functions.\n+           (status as any).runInitializers();\n+\n+           setTimeout(() => {\n+             initFnInvoked = true;\n+             subscriber.error();\n+           });\n+\n+           expect(status.done).toBe(false);\n+           status.donePromise\n+               .then(\n+                   () => fail(\n+                       '`donePromise.then` should not be invoked when observable emits an error'))\n+               .catch(() => {\n+                 expect(status.done).toBe(false);\n+                 expect(initFnInvoked).toBe(true);\n+               });\n+         })));\n     });\n   });\n }"
        },
        {
            "sha": "e423dd727c10dcc79e42d3002133ae4f4ea07cd1",
            "filename": "packages/core/test/bundling/forms/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/ca17ac523cc2ed8046931c86a2c12d97fb6796ca/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/ca17ac523cc2ed8046931c86a2c12d97fb6796ca/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Fforms%2Fbundle.golden_symbols.json?ref=ca17ac523cc2ed8046931c86a2c12d97fb6796ca",
            "patch": "@@ -1253,6 +1253,9 @@\n   {\n     \"name\": \"isObject\"\n   },\n+  {\n+    \"name\": \"isObservable\"\n+  },\n   {\n     \"name\": \"isOptionsObj\"\n   },"
        },
        {
            "sha": "d79400f0c5bb452c84bea62685560d9fa025d3e5",
            "filename": "packages/core/test/bundling/router/bundle.golden_symbols.json",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/ca17ac523cc2ed8046931c86a2c12d97fb6796ca/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "raw_url": "https://github.com/angular/angular/raw/ca17ac523cc2ed8046931c86a2c12d97fb6796ca/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Fbundling%2Frouter%2Fbundle.golden_symbols.json?ref=ca17ac523cc2ed8046931c86a2c12d97fb6796ca",
            "patch": "@@ -1580,6 +1580,9 @@\n   {\n     \"name\": \"isObject\"\n   },\n+  {\n+    \"name\": \"isObservable\"\n+  },\n   {\n     \"name\": \"isPositive\"\n   },"
        }
    ],
    "stats": {
        "total": 161,
        "additions": 137,
        "deletions": 24
    }
}