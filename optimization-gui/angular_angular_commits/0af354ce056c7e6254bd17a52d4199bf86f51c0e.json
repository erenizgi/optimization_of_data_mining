{
    "author": "alxhub",
    "message": "refactor(bazel): extract function to patch fileNameToModuleName on host (#42974)\n\nThis commit extracts the patching operation that adds `fileNameToModuleName`\nto the Angular compiler's `ts.CompilerHost` into a separate function, so\nthat it can be invoked in other compilation flows besides the one outlined\nin `ngc-wrapped`. This is primarily needed for the xi18n operation in g3.\n\nPR Close #42974",
    "sha": "0af354ce056c7e6254bd17a52d4199bf86f51c0e",
    "files": [
        {
            "sha": "7d3c325ddc8d22c829b39493132ce03dbb58e54c",
            "filename": "packages/bazel/src/ngc-wrapped/index.ts",
            "status": "modified",
            "additions": 107,
            "deletions": 92,
            "changes": 199,
            "blob_url": "https://github.com/angular/angular/blob/0af354ce056c7e6254bd17a52d4199bf86f51c0e/packages%2Fbazel%2Fsrc%2Fngc-wrapped%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/0af354ce056c7e6254bd17a52d4199bf86f51c0e/packages%2Fbazel%2Fsrc%2Fngc-wrapped%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbazel%2Fsrc%2Fngc-wrapped%2Findex.ts?ref=0af354ce056c7e6254bd17a52d4199bf86f51c0e",
            "patch": "@@ -298,98 +298,8 @@ export function compile({\n   };\n \n   const ngHost = ng.createCompilerHost({options: compilerOpts, tsHost: bazelHost});\n-  const fileNameToModuleNameCache = new Map<string, string>();\n-  ngHost.fileNameToModuleName = (importedFilePath: string, containingFilePath?: string) => {\n-    const cacheKey = `${importedFilePath}:${containingFilePath}`;\n-    // Memoize this lookup to avoid expensive re-parses of the same file\n-    // When run as a worker, the actual ts.SourceFile is cached\n-    // but when we don't run as a worker, there is no cache.\n-    // For one example target in g3, we saw a cache hit rate of 7590/7695\n-    if (fileNameToModuleNameCache.has(cacheKey)) {\n-      return fileNameToModuleNameCache.get(cacheKey);\n-    }\n-    const result = doFileNameToModuleName(importedFilePath, containingFilePath);\n-    fileNameToModuleNameCache.set(cacheKey, result);\n-    return result;\n-  };\n-\n-  function doFileNameToModuleName(importedFilePath: string, containingFilePath?: string): string {\n-    const relativeTargetPath =\n-        relativeToRootDirs(importedFilePath, compilerOpts.rootDirs).replace(EXT, '');\n-    const manifestTargetPath = `${bazelOpts.workspaceName}/${relativeTargetPath}`;\n-    if (useManifestPathsAsModuleName === true) {\n-      return manifestTargetPath;\n-    }\n-\n-    // Unless manifest paths are explicitly enforced, we initially check if a module name is\n-    // set for the given source file. The compiler host from `@bazel/typescript` sets source\n-    // file module names if the compilation targets either UMD or AMD. To ensure that the AMD\n-    // module names match, we first consider those.\n-    try {\n-      const sourceFile = ngHost.getSourceFile(importedFilePath, ts.ScriptTarget.Latest);\n-      if (sourceFile && sourceFile.moduleName) {\n-        return sourceFile.moduleName;\n-      }\n-    } catch (err) {\n-      // File does not exist or parse error. Ignore this case and continue onto the\n-      // other methods of resolving the module below.\n-    }\n-\n-    // It can happen that the ViewEngine compiler needs to write an import in a factory file,\n-    // and is using an ngsummary file to get the symbols.\n-    // The ngsummary comes from an upstream ng_module rule.\n-    // The upstream rule based its imports on ngsummary file which was generated from a\n-    // metadata.json file that was published to npm in an Angular library.\n-    // However, the ngsummary doesn't propagate the 'importAs' from the original metadata.json\n-    // so we would normally not be able to supply the correct module name for it.\n-    // For example, if the rootDir-relative filePath is\n-    //  node_modules/@angular/material/toolbar/typings/index\n-    // we would supply a module name\n-    //  @angular/material/toolbar/typings/index\n-    // but there is no JavaScript file to load at this path.\n-    // This is a workaround for https://github.com/angular/angular/issues/29454\n-    if (importedFilePath.indexOf('node_modules') >= 0) {\n-      const maybeMetadataFile = importedFilePath.replace(EXT, '') + '.metadata.json';\n-      if (fs.existsSync(maybeMetadataFile)) {\n-        const moduleName = (JSON.parse(fs.readFileSync(maybeMetadataFile, {encoding: 'utf-8'})) as {\n-                             importAs: string\n-                           }).importAs;\n-        if (moduleName) {\n-          return moduleName;\n-        }\n-      }\n-    }\n-\n-    if ((compilerOpts.module === ts.ModuleKind.UMD || compilerOpts.module === ts.ModuleKind.AMD) &&\n-        ngHost.amdModuleName) {\n-      return ngHost.amdModuleName({fileName: importedFilePath} as ts.SourceFile);\n-    }\n-\n-    // If no AMD module name has been set for the source file by the `@bazel/typescript` compiler\n-    // host, and the target file is not part of a flat module node module package, we use the\n-    // following rules (in order):\n-    //    1. If target file is part of `node_modules/`, we use the package module name.\n-    //    2. If no containing file is specified, or the target file is part of a different\n-    //       compilation unit, we use a Bazel manifest path. Relative paths are not possible\n-    //       since we don't have a containing file, and the target file could be located in the\n-    //       output directory, or in an external Bazel repository.\n-    //    3. If both rules above didn't match, we compute a relative path between the source files\n-    //       since they are part of the same compilation unit.\n-    // Note that we don't want to always use (2) because it could mean that compilation outputs\n-    // are always leaking Bazel-specific paths, and the output is not self-contained. This could\n-    // break `esm2015` or `esm5` output for Angular package release output\n-    // Omit the `node_modules` prefix if the module name of an NPM package is requested.\n-    if (relativeTargetPath.startsWith(NODE_MODULES)) {\n-      return relativeTargetPath.substr(NODE_MODULES.length);\n-    } else if (\n-        containingFilePath == null || !bazelOpts.compilationTargetSrc.includes(importedFilePath)) {\n-      return manifestTargetPath;\n-    }\n-    const containingFileDir =\n-        path.dirname(relativeToRootDirs(containingFilePath, compilerOpts.rootDirs));\n-    const relativeImportPath = path.posix.relative(containingFileDir, relativeTargetPath);\n-    return relativeImportPath.startsWith('.') ? relativeImportPath : `./${relativeImportPath}`;\n-  }\n+  patchNgHostWithFileNameToModuleName(\n+      ngHost, compilerOpts, bazelOpts, useManifestPathsAsModuleName);\n \n   ngHost.toSummaryFileName = (fileName: string, referringSrcFileName: string) => path.posix.join(\n       bazelOpts.workspaceName,\n@@ -553,3 +463,108 @@ function gatherDiagnosticsForInputsOnly(\n if (require.main === module) {\n   process.exitCode = main(process.argv.slice(2));\n }\n+\n+/**\n+ * Adds support for the optional `fileNameToModuleName` operation to a given `ng.CompilerHost`.\n+ *\n+ * This is used within `ngc-wrapped` and the Bazel compilation flow, but is exported here to allow\n+ * for other consumers of the compiler to access this same logic. For example, the xi18n operation\n+ * in g3 configures its own `ng.CompilerHost` which also requires `fileNameToModuleName` to work\n+ * correctly.\n+ */\n+export function patchNgHostWithFileNameToModuleName(\n+    ngHost: ng.CompilerHost, compilerOpts: ng.CompilerOptions, bazelOpts: BazelOptions,\n+    useManifestPathsAsModuleName: boolean): void {\n+  const fileNameToModuleNameCache = new Map<string, string>();\n+  ngHost.fileNameToModuleName = (importedFilePath: string, containingFilePath?: string) => {\n+    const cacheKey = `${importedFilePath}:${containingFilePath}`;\n+    // Memoize this lookup to avoid expensive re-parses of the same file\n+    // When run as a worker, the actual ts.SourceFile is cached\n+    // but when we don't run as a worker, there is no cache.\n+    // For one example target in g3, we saw a cache hit rate of 7590/7695\n+    if (fileNameToModuleNameCache.has(cacheKey)) {\n+      return fileNameToModuleNameCache.get(cacheKey);\n+    }\n+    const result = doFileNameToModuleName(importedFilePath, containingFilePath);\n+    fileNameToModuleNameCache.set(cacheKey, result);\n+    return result;\n+  };\n+\n+  function doFileNameToModuleName(importedFilePath: string, containingFilePath?: string): string {\n+    const relativeTargetPath =\n+        relativeToRootDirs(importedFilePath, compilerOpts.rootDirs).replace(EXT, '');\n+    const manifestTargetPath = `${bazelOpts.workspaceName}/${relativeTargetPath}`;\n+    if (useManifestPathsAsModuleName === true) {\n+      return manifestTargetPath;\n+    }\n+\n+    // Unless manifest paths are explicitly enforced, we initially check if a module name is\n+    // set for the given source file. The compiler host from `@bazel/typescript` sets source\n+    // file module names if the compilation targets either UMD or AMD. To ensure that the AMD\n+    // module names match, we first consider those.\n+    try {\n+      const sourceFile = ngHost.getSourceFile(importedFilePath, ts.ScriptTarget.Latest);\n+      if (sourceFile && sourceFile.moduleName) {\n+        return sourceFile.moduleName;\n+      }\n+    } catch (err) {\n+      // File does not exist or parse error. Ignore this case and continue onto the\n+      // other methods of resolving the module below.\n+    }\n+\n+    // It can happen that the ViewEngine compiler needs to write an import in a factory file,\n+    // and is using an ngsummary file to get the symbols.\n+    // The ngsummary comes from an upstream ng_module rule.\n+    // The upstream rule based its imports on ngsummary file which was generated from a\n+    // metadata.json file that was published to npm in an Angular library.\n+    // However, the ngsummary doesn't propagate the 'importAs' from the original metadata.json\n+    // so we would normally not be able to supply the correct module name for it.\n+    // For example, if the rootDir-relative filePath is\n+    //  node_modules/@angular/material/toolbar/typings/index\n+    // we would supply a module name\n+    //  @angular/material/toolbar/typings/index\n+    // but there is no JavaScript file to load at this path.\n+    // This is a workaround for https://github.com/angular/angular/issues/29454\n+    if (importedFilePath.indexOf('node_modules') >= 0) {\n+      const maybeMetadataFile = importedFilePath.replace(EXT, '') + '.metadata.json';\n+      if (fs.existsSync(maybeMetadataFile)) {\n+        const moduleName = (JSON.parse(fs.readFileSync(maybeMetadataFile, {encoding: 'utf-8'})) as {\n+                             importAs: string\n+                           }).importAs;\n+        if (moduleName) {\n+          return moduleName;\n+        }\n+      }\n+    }\n+\n+    if ((compilerOpts.module === ts.ModuleKind.UMD || compilerOpts.module === ts.ModuleKind.AMD) &&\n+        ngHost.amdModuleName) {\n+      return ngHost.amdModuleName({fileName: importedFilePath} as ts.SourceFile);\n+    }\n+\n+    // If no AMD module name has been set for the source file by the `@bazel/typescript` compiler\n+    // host, and the target file is not part of a flat module node module package, we use the\n+    // following rules (in order):\n+    //    1. If target file is part of `node_modules/`, we use the package module name.\n+    //    2. If no containing file is specified, or the target file is part of a different\n+    //       compilation unit, we use a Bazel manifest path. Relative paths are not possible\n+    //       since we don't have a containing file, and the target file could be located in the\n+    //       output directory, or in an external Bazel repository.\n+    //    3. If both rules above didn't match, we compute a relative path between the source files\n+    //       since they are part of the same compilation unit.\n+    // Note that we don't want to always use (2) because it could mean that compilation outputs\n+    // are always leaking Bazel-specific paths, and the output is not self-contained. This could\n+    // break `esm2015` or `esm5` output for Angular package release output\n+    // Omit the `node_modules` prefix if the module name of an NPM package is requested.\n+    if (relativeTargetPath.startsWith(NODE_MODULES)) {\n+      return relativeTargetPath.substr(NODE_MODULES.length);\n+    } else if (\n+        containingFilePath == null || !bazelOpts.compilationTargetSrc.includes(importedFilePath)) {\n+      return manifestTargetPath;\n+    }\n+    const containingFileDir =\n+        path.dirname(relativeToRootDirs(containingFilePath, compilerOpts.rootDirs));\n+    const relativeImportPath = path.posix.relative(containingFileDir, relativeTargetPath);\n+    return relativeImportPath.startsWith('.') ? relativeImportPath : `./${relativeImportPath}`;\n+  }\n+}"
        }
    ],
    "stats": {
        "total": 199,
        "additions": 107,
        "deletions": 92
    }
}