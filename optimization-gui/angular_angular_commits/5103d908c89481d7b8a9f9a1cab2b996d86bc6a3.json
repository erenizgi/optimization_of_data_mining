{
    "author": "alxhub",
    "message": "perf(compiler-cli): fix regressions in incremental program reuse (#37641)\n\nCommit 4213e8d5 introduced shim reference tagging into the compiler, and\nchanged how the `TypeCheckProgramHost` worked under the hood during the\ncreation of a template type-checking program. This work enabled a more\nincremental flow for template type-checking, but unintentionally introduced\nseveral regressions in performance, caused by poor incrementality during\n`ts.Program` creation.\n\n1. The `TypeCheckProgramHost` was made to rely on the `ts.CompilerHost` to\n   retrieve instances of `ts.SourceFile`s from the original program. If the\n   host does not return the original instance of such files, but instead\n   creates new instances, this has two negative effects: it incurs\n   additional parsing time, and it interferes with TypeScript's ability to\n   reuse information about such files.\n\n2. During the incremental creation of a `ts.Program`, TypeScript compares\n   the `referencedFiles` of `ts.SourceFile` instances from the old program\n   with those in the new program. If these arrays differ, TypeScript cannot\n   fully reuse the old program. The implementation of reference tagging\n   introduced in 4213e8d5 restores the original `referencedFiles` array\n   after a `ts.Program` is created, which means that future incremental\n   operations involving that program will always fail this comparison,\n   effectively limiting the incrementality TypeScript can achieve.\n\nProblem 1 exacerbates problem 2: if a new `ts.SourceFile` is created by the\nhost after shim generation has been disabled, it will have an untagged\n`referencedFiles` array even if the original file's `referencedFiles` was\nnot restored, triggering problem 2 when creating the template type-checking\nprogram.\n\nTo fix these issues, `referencedFiles` arrays are now restored on the old\n`ts.Program` prior to the creation of a new incremental program. This allows\nTypeScript to get the most out of reusing the old program's data.\n\nAdditionally, the `TypeCheckProgramHost` now uses the original `ts.Program`\nto retrieve original instances of `ts.SourceFile`s where possible,\npreventing issues when a host would otherwise return fresh instances.\n\nTogether, these fixes ensure that program reuse is as incremental as\npossible, and tests have been added to verify this for certain scenarios.\n\nAn optimization was further added to prevent the creation of a type-checking\n`ts.Program` in the first place if no type-checking is necessary.\n\nPR Close #37641",
    "sha": "5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
    "files": [
        {
            "sha": "cb3c783dd78455945b9d70fd4013cedcd487ff55",
            "filename": "packages/compiler-cli/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2FBUILD.bazel?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -31,6 +31,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/indexer\",\n         \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n+        \"//packages/compiler-cli/src/ngtsc/shims\",\n         \"//packages/compiler-cli/src/ngtsc/typecheck\",\n         \"@npm//@bazel/typescript\",\n         \"@npm//@types/node\","
        },
        {
            "sha": "bf81c77638eaaf040f0b350474488a99af2dd764",
            "filename": "packages/compiler-cli/src/ngtsc/program.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 1,
            "changes": 20,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -17,6 +17,7 @@ import {NgCompilerOptions} from './core/api';\n import {TrackedIncrementalBuildStrategy} from './incremental';\n import {IndexedComponent} from './indexer';\n import {NOOP_PERF_RECORDER, PerfRecorder, PerfTracker} from './perf';\n+import {retagAllTsFiles, untagAllTsFiles} from './shims';\n import {ReusedProgramStrategy} from './typecheck';\n \n \n@@ -68,14 +69,26 @@ export class NgtscProgram implements api.Program {\n     }\n     this.closureCompilerEnabled = !!options.annotateForClosureCompiler;\n \n-    const reuseProgram = oldProgram && oldProgram.reuseTsProgram;\n+    const reuseProgram = oldProgram?.reuseTsProgram;\n     this.host = NgCompilerHost.wrap(delegateHost, rootNames, options, reuseProgram ?? null);\n \n+    if (reuseProgram !== undefined) {\n+      // Prior to reusing the old program, restore shim tagging for all its `ts.SourceFile`s.\n+      // TypeScript checks the `referencedFiles` of `ts.SourceFile`s for changes when evaluating\n+      // incremental reuse of data from the old program, so it's important that these match in order\n+      // to get the most benefit out of reuse.\n+      retagAllTsFiles(reuseProgram);\n+    }\n+\n     this.tsProgram = ts.createProgram(this.host.inputFiles, options, this.host, reuseProgram);\n     this.reuseTsProgram = this.tsProgram;\n \n     this.host.postProgramCreationCleanup();\n \n+    // Shim tagging has served its purpose, and tags can now be removed from all `ts.SourceFile`s in\n+    // the program.\n+    untagAllTsFiles(this.tsProgram);\n+\n     const reusedProgramStrategy = new ReusedProgramStrategy(\n         this.tsProgram, this.host, this.options, this.host.shimExtensionPrefixes);\n \n@@ -93,6 +106,10 @@ export class NgtscProgram implements api.Program {\n     return this.tsProgram;\n   }\n \n+  getReuseTsProgram(): ts.Program {\n+    return this.reuseTsProgram;\n+  }\n+\n   getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken|\n                          undefined): readonly ts.Diagnostic[] {\n     return this.tsProgram.getOptionsDiagnostics(cancellationToken);\n@@ -248,6 +265,7 @@ export class NgtscProgram implements api.Program {\n       }));\n       this.perfRecorder.stop(fileEmitSpan);\n     }\n+\n     this.perfRecorder.stop(emitSpan);\n \n     if (this.perfTracker !== null && this.options.tracePerformance !== undefined) {"
        },
        {
            "sha": "9cc388f5b77bdb87b75146b1b8916fe853f80031",
            "filename": "packages/compiler-cli/src/ngtsc/shims/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Findex.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -9,7 +9,7 @@\n /// <reference types=\"node\" />\n \n export {ShimAdapter} from './src/adapter';\n-export {copyFileShimData, isShim} from './src/expando';\n+export {copyFileShimData, isShim, retagAllTsFiles, retagTsFile, sfExtensionData, untagAllTsFiles, untagTsFile} from './src/expando';\n export {FactoryGenerator, generatedFactoryTransform} from './src/factory_generator';\n export {ShimReferenceTagger} from './src/reference_tagger';\n export {SummaryGenerator} from './src/summary_generator';"
        },
        {
            "sha": "ab4494568d054327c43516f133006a250416a78e",
            "filename": "packages/compiler-cli/src/ngtsc/shims/src/adapter.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Fsrc%2Fadapter.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Fsrc%2Fadapter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Fsrc%2Fadapter.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -12,7 +12,7 @@ import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '../../file_s\n import {isDtsPath} from '../../util/src/typescript';\n import {PerFileShimGenerator, TopLevelShimGenerator} from '../api';\n \n-import {isFileShimSourceFile, isShim, NgExtension, sfExtensionData} from './expando';\n+import {isFileShimSourceFile, isShim, sfExtensionData} from './expando';\n import {makeShimFileName} from './util';\n \n interface ShimGeneratorData {"
        },
        {
            "sha": "3d03ce42ba058f6a629d62a21b5d78d3e57c47ff",
            "filename": "packages/compiler-cli/src/ngtsc/shims/src/expando.ts",
            "status": "modified",
            "additions": 60,
            "deletions": 0,
            "changes": 60,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Fsrc%2Fexpando.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Fsrc%2Fexpando.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Fsrc%2Fexpando.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -21,7 +21,16 @@ export const NgExtension = Symbol('NgExtension');\n export interface NgExtensionData {\n   isTopLevelShim: boolean;\n   fileShim: NgFileShimData|null;\n+\n+  /**\n+   * The contents of the `referencedFiles` array, before modification by a `ShimReferenceTagger`.\n+   */\n   originalReferencedFiles: ReadonlyArray<ts.FileReference>|null;\n+\n+  /**\n+   * The contents of the `referencedFiles` array, after modification by a `ShimReferenceTagger`.\n+   */\n+  taggedReferenceFiles: ReadonlyArray<ts.FileReference>|null;\n }\n \n /**\n@@ -65,6 +74,7 @@ export function sfExtensionData(sf: ts.SourceFile): NgExtensionData {\n     isTopLevelShim: false,\n     fileShim: null,\n     originalReferencedFiles: null,\n+    taggedReferenceFiles: null,\n   };\n   extSf[NgExtension] = extension;\n   return extension;\n@@ -110,3 +120,53 @@ export function copyFileShimData(from: ts.SourceFile, to: ts.SourceFile): void {\n   }\n   sfExtensionData(to).fileShim = sfExtensionData(from).fileShim;\n }\n+\n+/**\n+ * For those `ts.SourceFile`s in the `program` which have previously been tagged by a\n+ * `ShimReferenceTagger`, restore the original `referencedFiles` array that does not have shim tags.\n+ */\n+export function untagAllTsFiles(program: ts.Program): void {\n+  for (const sf of program.getSourceFiles()) {\n+    untagTsFile(sf);\n+  }\n+}\n+\n+/**\n+ * For those `ts.SourceFile`s in the `program` which have previously been tagged by a\n+ * `ShimReferenceTagger`, re-apply the effects of tagging by updating the `referencedFiles` array to\n+ * the tagged version produced previously.\n+ */\n+export function retagAllTsFiles(program: ts.Program): void {\n+  for (const sf of program.getSourceFiles()) {\n+    retagTsFile(sf);\n+  }\n+}\n+\n+/**\n+ * Restore the original `referencedFiles` for the given `ts.SourceFile`.\n+ */\n+export function untagTsFile(sf: ts.SourceFile): void {\n+  if (sf.isDeclarationFile || !isExtended(sf)) {\n+    return;\n+  }\n+\n+  const ext = sfExtensionData(sf);\n+  if (ext.originalReferencedFiles !== null) {\n+    sf.referencedFiles = ext.originalReferencedFiles as Array<ts.FileReference>;\n+  }\n+}\n+\n+/**\n+ * Apply the previously tagged `referencedFiles` to the given `ts.SourceFile`, if it was previously\n+ * tagged.\n+ */\n+export function retagTsFile(sf: ts.SourceFile): void {\n+  if (sf.isDeclarationFile || !isExtended(sf)) {\n+    return;\n+  }\n+\n+  const ext = sfExtensionData(sf);\n+  if (ext.taggedReferenceFiles !== null) {\n+    sf.referencedFiles = ext.taggedReferenceFiles as Array<ts.FileReference>;\n+  }\n+}"
        },
        {
            "sha": "3e0a3fe428cadf6a7d9699a2e21780a0182b9862",
            "filename": "packages/compiler-cli/src/ngtsc/shims/src/reference_tagger.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 16,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Fsrc%2Freference_tagger.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Fsrc%2Freference_tagger.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Fsrc%2Freference_tagger.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -8,10 +8,10 @@\n \n import * as ts from 'typescript';\n \n-import {absoluteFrom, absoluteFromSourceFile} from '../../file_system';\n+import {absoluteFromSourceFile} from '../../file_system';\n import {isNonDeclarationTsPath} from '../../util/src/typescript';\n \n-import {isExtended as isExtendedSf, isShim, NgExtension, sfExtensionData} from './expando';\n+import {isShim, sfExtensionData} from './expando';\n import {makeShimFileName} from './util';\n \n /**\n@@ -48,8 +48,16 @@ export class ShimReferenceTagger {\n       return;\n     }\n \n-    sfExtensionData(sf).originalReferencedFiles = sf.referencedFiles;\n-    const referencedFiles = [...sf.referencedFiles];\n+    const ext = sfExtensionData(sf);\n+\n+    // If this file has never been tagged before, capture its `referencedFiles` in the extension\n+    // data.\n+    if (ext.originalReferencedFiles === null) {\n+      ext.originalReferencedFiles = sf.referencedFiles;\n+    }\n+\n+    const referencedFiles = [...ext.originalReferencedFiles];\n+\n \n     const sfPath = absoluteFromSourceFile(sf);\n     for (const suffix of this.suffixes) {\n@@ -60,26 +68,16 @@ export class ShimReferenceTagger {\n       });\n     }\n \n+    ext.taggedReferenceFiles = referencedFiles;\n     sf.referencedFiles = referencedFiles;\n     this.tagged.add(sf);\n   }\n \n   /**\n-   * Restore the original `referencedFiles` values of all tagged `ts.SourceFile`s and disable the\n-   * `ShimReferenceTagger`.\n+   * Disable the `ShimReferenceTagger` and free memory associated with tracking tagged files.\n    */\n   finalize(): void {\n     this.enabled = false;\n-    for (const sf of this.tagged) {\n-      if (!isExtendedSf(sf)) {\n-        continue;\n-      }\n-\n-      const extensionData = sfExtensionData(sf);\n-      if (extensionData.originalReferencedFiles !== null) {\n-        sf.referencedFiles = extensionData.originalReferencedFiles! as ts.FileReference[];\n-      }\n-    }\n     this.tagged.clear();\n   }\n }"
        },
        {
            "sha": "807d0996f9b2b8d223eae6500221a9bc3fae55b3",
            "filename": "packages/compiler-cli/src/ngtsc/shims/test/reference_tagger_spec.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 25,
            "changes": 67,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Ftest%2Freference_tagger_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Ftest%2Freference_tagger_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fshims%2Ftest%2Freference_tagger_spec.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -12,6 +12,7 @@ import {absoluteFrom as _, AbsoluteFsPath, getSourceFileOrError} from '../../fil\n import {runInEachFileSystem} from '../../file_system/testing';\n import {makeProgram} from '../../testing';\n import {ShimAdapter} from '../src/adapter';\n+import {retagTsFile, untagTsFile} from '../src/expando';\n import {ShimReferenceTagger} from '../src/reference_tagger';\n \n import {TestShimGenerator} from './util';\n@@ -67,49 +68,65 @@ runInEachFileSystem(() => {\n       expect(shimSf.referencedFiles).toEqual([]);\n     });\n \n-    it('should remove tags during finalization', () => {\n+    it('should not tag shims after finalization', () => {\n       const tagger = new ShimReferenceTagger(['test1', 'test2']);\n+      tagger.finalize();\n \n       const fileName = _('/file.ts');\n       const sf = makeArbitrarySf(fileName);\n \n-      expectReferencedFiles(sf, []);\n-\n       tagger.tag(sf);\n-      expectReferencedFiles(sf, ['/file.test1.ts', '/file.test2.ts']);\n-\n-      tagger.finalize();\n       expectReferencedFiles(sf, []);\n     });\n \n-    it('should not remove references it did not add during finalization', () => {\n-      const tagger = new ShimReferenceTagger(['test1', 'test2']);\n-      const fileName = _('/file.ts');\n-      const libFileName = _('/lib.d.ts');\n-\n-      const sf = makeSf(fileName, `\n-        /// <reference path=\"/lib.d.ts\" />\n-        export const UNIMPORTANT = true;\n-      `);\n+    it('should not overwrite original referencedFiles', () => {\n+      const tagger = new ShimReferenceTagger(['test']);\n \n-      expectReferencedFiles(sf, [libFileName]);\n+      const fileName = _('/file.ts');\n+      const sf = makeArbitrarySf(fileName);\n+      sf.referencedFiles = [{\n+        fileName: _('/other.ts'),\n+        pos: 0,\n+        end: 0,\n+      }];\n \n       tagger.tag(sf);\n-      expectReferencedFiles(sf, ['/file.test1.ts', '/file.test2.ts', libFileName]);\n-\n-      tagger.finalize();\n-      expectReferencedFiles(sf, [libFileName]);\n+      expectReferencedFiles(sf, ['/other.ts', '/file.test.ts']);\n     });\n \n-    it('should not tag shims after finalization', () => {\n-      const tagger = new ShimReferenceTagger(['test1', 'test2']);\n-      tagger.finalize();\n+    it('should always tag against the original referencedFiles', () => {\n+      const tagger1 = new ShimReferenceTagger(['test1']);\n+      const tagger2 = new ShimReferenceTagger(['test2']);\n \n       const fileName = _('/file.ts');\n       const sf = makeArbitrarySf(fileName);\n \n-      tagger.tag(sf);\n-      expectReferencedFiles(sf, []);\n+      tagger1.tag(sf);\n+      tagger2.tag(sf);\n+      expectReferencedFiles(sf, ['/file.test2.ts']);\n+    });\n+\n+    describe('tagging and untagging', () => {\n+      it('should be able to untag references and retag them later', () => {\n+        const tagger = new ShimReferenceTagger(['test']);\n+\n+        const fileName = _('/file.ts');\n+        const sf = makeArbitrarySf(fileName);\n+        sf.referencedFiles = [{\n+          fileName: _('/other.ts'),\n+          pos: 0,\n+          end: 0,\n+        }];\n+\n+        tagger.tag(sf);\n+        expectReferencedFiles(sf, ['/other.ts', '/file.test.ts']);\n+\n+        untagTsFile(sf);\n+        expectReferencedFiles(sf, ['/other.ts']);\n+\n+        retagTsFile(sf);\n+        expectReferencedFiles(sf, ['/other.ts', '/file.test.ts']);\n+      });\n     });\n   });\n });"
        },
        {
            "sha": "354d8a38768f8ff9b902747796fd0f10b32305e2",
            "filename": "packages/compiler-cli/src/ngtsc/testing/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftesting%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftesting%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftesting%2Findex.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -5,4 +5,4 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-export {getDeclaration, makeProgram} from './src/utils';\n+export {expectCompleteReuse, getDeclaration, makeProgram} from './src/utils';"
        },
        {
            "sha": "f2c84d263d2b96b86628ce724992371e733374a4",
            "filename": "packages/compiler-cli/src/ngtsc/testing/src/utils.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftesting%2Fsrc%2Futils.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftesting%2Fsrc%2Futils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftesting%2Fsrc%2Futils.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -97,6 +97,23 @@ export function walkForDeclaration(name: string, rootNode: ts.Node): ts.Declarat\n   return chosenDecl;\n }\n \n+const COMPLETE_REUSE_FAILURE_MESSAGE =\n+    'The original program was not reused completely, even though no changes should have been made to its structure';\n+\n+/**\n+ * Extracted from TypeScript's internal enum `StructureIsReused`.\n+ */\n+enum TsStructureIsReused {\n+  Not = 0,\n+  SafeModules = 1,\n+  Completely = 2,\n+}\n+\n+export function expectCompleteReuse(oldProgram: ts.Program): void {\n+  // Assert complete reuse using TypeScript's private API.\n+  expect((oldProgram as any).structureIsReused)\n+      .toBe(TsStructureIsReused.Completely, COMPLETE_REUSE_FAILURE_MESSAGE);\n+}\n \n function bindingNameEquals(node: ts.BindingName, name: string): boolean {\n   if (ts.isIdentifier(node)) {"
        },
        {
            "sha": "7c87be7f22faaa877521606876f152c492c1b525",
            "filename": "packages/compiler-cli/src/ngtsc/tsc_plugin.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftsc_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftsc_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftsc_plugin.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -13,6 +13,7 @@ import {NgCompilerOptions, UnifiedModulesHost} from './core/api';\n import {NodeJSFileSystem, setFileSystem} from './file_system';\n import {PatchedProgramIncrementalBuildStrategy} from './incremental';\n import {NOOP_PERF_RECORDER} from './perf';\n+import {untagAllTsFiles} from './shims';\n import {ReusedProgramStrategy} from './typecheck/src/augmented_program';\n \n // The following is needed to fix a the chicken-and-egg issue where the sync (into g3) script will\n@@ -80,6 +81,9 @@ export class NgTscPlugin implements TscPlugin {\n   wrapHost(\n       host: ts.CompilerHost&UnifiedModulesHost, inputFiles: readonly string[],\n       options: ts.CompilerOptions): PluginCompilerHost {\n+    // TODO(alxhub): Eventually the `wrapHost()` API will accept the old `ts.Program` (if one is\n+    // available). When it does, its `ts.SourceFile`s need to be re-tagged to enable proper\n+    // incremental compilation.\n     this.options = {...this.ngOptions, ...options} as NgCompilerOptions;\n     this.host = NgCompilerHost.wrap(host, inputFiles, this.options, /* oldProgram */ null);\n     return this.host;\n@@ -92,6 +96,8 @@ export class NgTscPlugin implements TscPlugin {\n     if (this.host === null || this.options === null) {\n       throw new Error('Lifecycle error: setupCompilation() before wrapHost().');\n     }\n+    this.host.postProgramCreationCleanup();\n+    untagAllTsFiles(program);\n     const typeCheckStrategy = new ReusedProgramStrategy(\n         program, this.host, this.options, this.host.shimExtensionPrefixes);\n     this._compiler = new NgCompiler("
        },
        {
            "sha": "c3c1f739872eceb26e9a3f7356721ff5aba24bb1",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/augmented_program.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 4,
            "changes": 33,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Faugmented_program.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Faugmented_program.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Faugmented_program.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -9,6 +9,7 @@\n import * as ts from 'typescript';\n \n import {AbsoluteFsPath} from '../../file_system';\n+import {retagAllTsFiles, untagAllTsFiles} from '../../shims';\n \n import {TypeCheckingProgramStrategy, UpdateMode} from './api';\n import {TypeCheckProgramHost} from './host';\n@@ -26,15 +27,28 @@ export class ReusedProgramStrategy implements TypeCheckingProgramStrategy {\n    */\n   private sfMap = new Map<string, ts.SourceFile>();\n \n+  private program: ts.Program = this.originalProgram;\n+\n   constructor(\n-      private program: ts.Program, private originalHost: ts.CompilerHost,\n+      private originalProgram: ts.Program, private originalHost: ts.CompilerHost,\n       private options: ts.CompilerOptions, private shimExtensionPrefixes: string[]) {}\n \n   getProgram(): ts.Program {\n     return this.program;\n   }\n \n   updateFiles(contents: Map<AbsoluteFsPath, string>, updateMode: UpdateMode): void {\n+    if (contents.size === 0) {\n+      // No changes have been requested. Is it safe to skip updating entirely?\n+      // If UpdateMode is Incremental, then yes. If UpdateMode is Complete, then it's safe to skip\n+      // only if there are no active changes already (that would be cleared by the update).\n+\n+      if (updateMode !== UpdateMode.Complete || this.sfMap.size === 0) {\n+        // No changes would be made to the `ts.Program` anyway, so it's safe to do nothing here.\n+        return;\n+      }\n+    }\n+\n     if (updateMode === UpdateMode.Complete) {\n       this.sfMap.clear();\n     }\n@@ -43,14 +57,25 @@ export class ReusedProgramStrategy implements TypeCheckingProgramStrategy {\n       this.sfMap.set(filePath, ts.createSourceFile(filePath, text, ts.ScriptTarget.Latest, true));\n     }\n \n-    const host =\n-        new TypeCheckProgramHost(this.sfMap, this.originalHost, this.shimExtensionPrefixes);\n+    const host = new TypeCheckProgramHost(\n+        this.sfMap, this.originalProgram, this.originalHost, this.shimExtensionPrefixes);\n+    const oldProgram = this.program;\n+\n+    // Retag the old program's `ts.SourceFile`s with shim tags, to allow TypeScript to reuse the\n+    // most data.\n+    retagAllTsFiles(oldProgram);\n+\n     this.program = ts.createProgram({\n       host,\n       rootNames: this.program.getRootFileNames(),\n       options: this.options,\n-      oldProgram: this.program,\n+      oldProgram,\n     });\n     host.postProgramCreationCleanup();\n+\n+    // And untag them afterwards. We explicitly untag both programs here, because the oldProgram\n+    // may still be used for emit and needs to not contain tags.\n+    untagAllTsFiles(this.program);\n+    untagAllTsFiles(oldProgram);\n   }\n }"
        },
        {
            "sha": "57a74db930c884b2d62e0ad5aa545598938f2aff",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/host.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 4,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fhost.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fhost.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fhost.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -35,8 +35,8 @@ export class TypeCheckProgramHost implements ts.CompilerHost {\n   readonly resolveModuleNames?: ts.CompilerHost['resolveModuleNames'];\n \n   constructor(\n-      sfMap: Map<string, ts.SourceFile>, private delegate: ts.CompilerHost,\n-      private shimExtensionPrefixes: string[]) {\n+      sfMap: Map<string, ts.SourceFile>, private originalProgram: ts.Program,\n+      private delegate: ts.CompilerHost, private shimExtensionPrefixes: string[]) {\n     this.sfMap = sfMap;\n \n     if (delegate.getDirectories !== undefined) {\n@@ -52,8 +52,15 @@ export class TypeCheckProgramHost implements ts.CompilerHost {\n       fileName: string, languageVersion: ts.ScriptTarget,\n       onError?: ((message: string) => void)|undefined,\n       shouldCreateNewSourceFile?: boolean|undefined): ts.SourceFile|undefined {\n-    const delegateSf =\n-        this.delegate.getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile)!;\n+    // Try to use the same `ts.SourceFile` as the original program, if possible. This guarantees\n+    // that program reuse will be as efficient as possible.\n+    let delegateSf: ts.SourceFile|undefined = this.originalProgram.getSourceFile(fileName);\n+    if (delegateSf === undefined) {\n+      // Something went wrong and a source file is being requested that's not in the original\n+      // program. Just in case, try to retrieve it from the delegate.\n+      delegateSf = this.delegate.getSourceFile(\n+          fileName, languageVersion, onError, shouldCreateNewSourceFile)!;\n+    }\n     if (delegateSf === undefined) {\n       return undefined;\n     }"
        },
        {
            "sha": "ce34bc6aa5a619f57ddf22c8a3b6c1495e91e54e",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2FBUILD.bazel?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -16,6 +16,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n         \"//packages/compiler-cli/src/ngtsc/incremental\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n+        \"//packages/compiler-cli/src/ngtsc/shims\",\n         \"//packages/compiler-cli/src/ngtsc/testing\",\n         \"//packages/compiler-cli/src/ngtsc/typecheck\",\n         \"//packages/compiler-cli/src/ngtsc/util\","
        },
        {
            "sha": "1d14e84ea6d0f469a2adc206b8d44d52dfde4065",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/program_spec.ts",
            "status": "added",
            "additions": 98,
            "deletions": 0,
            "changes": 98,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fprogram_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fprogram_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fprogram_spec.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -0,0 +1,98 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript';\n+\n+import {absoluteFrom, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\n+import {runInEachFileSystem} from '../../file_system/testing';\n+import {sfExtensionData, ShimReferenceTagger} from '../../shims';\n+import {expectCompleteReuse, makeProgram} from '../../testing';\n+import {UpdateMode} from '../src/api';\n+import {ReusedProgramStrategy} from '../src/augmented_program';\n+\n+import {createProgramWithNoTemplates} from './test_utils';\n+\n+runInEachFileSystem(() => {\n+  describe('template type-checking program', () => {\n+    it('should not be created if no components need to be checked', () => {\n+      const {program, templateTypeChecker, programStrategy} = createProgramWithNoTemplates();\n+      templateTypeChecker.refresh();\n+      // expect() here would create a really long error message, so this is checked manually.\n+      if (programStrategy.getProgram() !== program) {\n+        fail('Template type-checking created a new ts.Program even though it had no changes.');\n+      }\n+    });\n+\n+    it('should have complete reuse if no structural changes are made to shims', () => {\n+      const {program, host, options, typecheckPath} = makeSingleFileProgramWithTypecheckShim();\n+      const programStrategy = new ReusedProgramStrategy(program, host, options, ['ngtypecheck']);\n+\n+      // Update /main.ngtypecheck.ts without changing its shape. Verify that the old program was\n+      // reused completely.\n+      programStrategy.updateFiles(\n+          new Map([[typecheckPath, 'export const VERSION = 2;']]), UpdateMode.Complete);\n+\n+      expectCompleteReuse(program);\n+    });\n+\n+    it('should have complete reuse if no structural changes are made to input files', () => {\n+      const {program, host, options, mainPath} = makeSingleFileProgramWithTypecheckShim();\n+      const programStrategy = new ReusedProgramStrategy(program, host, options, ['ngtypecheck']);\n+\n+      // Update /main.ts without changing its shape. Verify that the old program was reused\n+      // completely.\n+      programStrategy.updateFiles(\n+          new Map([[mainPath, 'export const STILL_NOT_A_COMPONENT = true;']]), UpdateMode.Complete);\n+\n+      expectCompleteReuse(program);\n+    });\n+  });\n+});\n+\n+function makeSingleFileProgramWithTypecheckShim(): {\n+  program: ts.Program,\n+  host: ts.CompilerHost,\n+  options: ts.CompilerOptions,\n+  mainPath: AbsoluteFsPath,\n+  typecheckPath: AbsoluteFsPath,\n+} {\n+  const mainPath = absoluteFrom('/main.ts');\n+  const typecheckPath = absoluteFrom('/main.ngtypecheck.ts');\n+  const {program, host, options} = makeProgram([\n+    {\n+      name: mainPath,\n+      contents: 'export const NOT_A_COMPONENT = true;',\n+    },\n+    {\n+      name: typecheckPath,\n+      contents: 'export const VERSION = 1;',\n+    }\n+  ]);\n+\n+  const sf = getSourceFileOrError(program, mainPath);\n+  const typecheckSf = getSourceFileOrError(program, typecheckPath);\n+\n+  // To ensure this test is validating the correct behavior, the initial conditions of the\n+  // input program must be such that:\n+  //\n+  // 1) /main.ts was previously tagged with a reference to its ngtypecheck shim.\n+  // 2) /main.ngtypecheck.ts is marked as a shim itself.\n+\n+  // Condition 1:\n+  const tagger = new ShimReferenceTagger(['ngtypecheck']);\n+  tagger.tag(sf);\n+  tagger.finalize();\n+\n+  // Condition 2:\n+  sfExtensionData(typecheckSf).fileShim = {\n+    extension: 'ngtypecheck',\n+    generatedFrom: mainPath,\n+  };\n+\n+  return {program, host, options, mainPath, typecheckPath};\n+}"
        },
        {
            "sha": "cdc76566f0cf7875ce57e4cba015d9e71d19ba12",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/test_utils.ts",
            "status": "modified",
            "additions": 63,
            "deletions": 38,
            "changes": 101,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -235,10 +235,18 @@ export function tcb(\n   return res.replace(/\\s+/g, ' ');\n }\n \n-export function typecheck(\n-    template: string, source: string, declarations: TestDeclaration[] = [],\n-    additionalSources: {name: AbsoluteFsPath; contents: string}[] = [],\n-    config: Partial<TypeCheckingConfig> = {}, opts: ts.CompilerOptions = {}): ts.Diagnostic[] {\n+export interface TemplateTestEnvironment {\n+  sf: ts.SourceFile;\n+  program: ts.Program;\n+  templateTypeChecker: TemplateTypeChecker;\n+  programStrategy: ReusedProgramStrategy;\n+}\n+\n+function setupTemplateTypeChecking(\n+    source: string, additionalSources: {name: AbsoluteFsPath; contents: string}[],\n+    config: Partial<TypeCheckingConfig>, opts: ts.CompilerOptions,\n+    makeTypeCheckAdapterFn: (program: ts.Program, sf: ts.SourceFile) =>\n+        ProgramTypeCheckAdapter): TemplateTestEnvironment {\n   const typeCheckFilePath = absoluteFrom('/main.ngtypecheck.ts');\n   const files = [\n     typescriptLibDts(),\n@@ -266,48 +274,65 @@ export function typecheck(\n   ]);\n   const fullConfig = {...ALL_ENABLED_CONFIG, ...config};\n \n-  const templateUrl = 'synthetic.html';\n-  const templateFile = new ParseSourceFile(template, templateUrl);\n-  const {nodes, errors} = parseTemplate(template, templateUrl);\n-  if (errors !== undefined) {\n-    throw new Error('Template parse errors: \\n' + errors.join('\\n'));\n-  }\n-\n-  const {matcher, pipes} = prepareDeclarations(declarations, decl => {\n-    let declFile = sf;\n-    if (decl.file !== undefined) {\n-      declFile = program.getSourceFile(decl.file)!;\n-      if (declFile === undefined) {\n-        throw new Error(`Unable to locate ${decl.file} for ${decl.type} ${decl.name}`);\n-      }\n-    }\n-    return getClass(declFile, decl.name);\n-  });\n-  const binder = new R3TargetBinder(matcher);\n-  const boundTarget = binder.bind({template: nodes});\n-  const clazz = new Reference(getClass(sf, 'TestComponent'));\n-\n-  const sourceMapping: TemplateSourceMapping = {\n-    type: 'external',\n-    template,\n-    templateUrl,\n-    componentClass: clazz.node,\n-    // Use the class's name for error mappings.\n-    node: clazz.node.name,\n-  };\n-\n-  const checkAdapter = createTypeCheckAdapter((ctx: TypeCheckContext) => {\n-    ctx.addTemplate(clazz, boundTarget, pipes, [], sourceMapping, templateFile);\n-  });\n-\n+  const checkAdapter = makeTypeCheckAdapterFn(program, sf);\n   const programStrategy = new ReusedProgramStrategy(program, host, options, []);\n   const templateTypeChecker = new TemplateTypeChecker(\n       program, programStrategy, checkAdapter, fullConfig, emitter, reflectionHost, host,\n       NOOP_INCREMENTAL_BUILD);\n+\n+  return {program, sf, templateTypeChecker, programStrategy};\n+}\n+\n+export function typecheck(\n+    template: string, source: string, declarations: TestDeclaration[] = [],\n+    additionalSources: {name: AbsoluteFsPath; contents: string}[] = [],\n+    config: Partial<TypeCheckingConfig> = {}, opts: ts.CompilerOptions = {}): ts.Diagnostic[] {\n+  const {sf, templateTypeChecker} =\n+      setupTemplateTypeChecking(source, additionalSources, config, opts, (program, sf) => {\n+        const templateUrl = 'synthetic.html';\n+        const templateFile = new ParseSourceFile(template, templateUrl);\n+        const {nodes, errors} = parseTemplate(template, templateUrl);\n+        if (errors !== undefined) {\n+          throw new Error('Template parse errors: \\n' + errors.join('\\n'));\n+        }\n+\n+        const {matcher, pipes} = prepareDeclarations(declarations, decl => {\n+          let declFile = sf;\n+          if (decl.file !== undefined) {\n+            declFile = program.getSourceFile(decl.file)!;\n+            if (declFile === undefined) {\n+              throw new Error(`Unable to locate ${decl.file} for ${decl.type} ${decl.name}`);\n+            }\n+          }\n+          return getClass(declFile, decl.name);\n+        });\n+        const binder = new R3TargetBinder(matcher);\n+        const boundTarget = binder.bind({template: nodes});\n+        const clazz = new Reference(getClass(sf, 'TestComponent'));\n+\n+        const sourceMapping: TemplateSourceMapping = {\n+          type: 'external',\n+          template,\n+          templateUrl,\n+          componentClass: clazz.node,\n+          // Use the class's name for error mappings.\n+          node: clazz.node.name,\n+        };\n+\n+        return createTypeCheckAdapter((ctx: TypeCheckContext) => {\n+          ctx.addTemplate(clazz, boundTarget, pipes, [], sourceMapping, templateFile);\n+        });\n+      });\n+\n   templateTypeChecker.refresh();\n   return templateTypeChecker.getDiagnosticsForFile(sf);\n }\n \n+export function createProgramWithNoTemplates(): TemplateTestEnvironment {\n+  return setupTemplateTypeChecking(\n+      'export const NOT_A_COMPONENT = true;', [], {}, {}, () => createTypeCheckAdapter(() => {}));\n+}\n+\n function createTypeCheckAdapter(fn: (ctx: TypeCheckContext) => void): ProgramTypeCheckAdapter {\n   let called = false;\n   return {"
        },
        {
            "sha": "96e2a67c9e228cc9a3112dcbfdadbbac6687a42c",
            "filename": "packages/compiler-cli/test/ngtsc/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2FBUILD.bazel?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -12,6 +12,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/file_system/testing\",\n         \"//packages/compiler-cli/src/ngtsc/indexer\",\n         \"//packages/compiler-cli/src/ngtsc/routing\",\n+        \"//packages/compiler-cli/src/ngtsc/testing\",\n         \"//packages/compiler-cli/src/ngtsc/util\",\n         \"//packages/compiler-cli/test:test_utils\",\n         \"//packages/compiler-cli/test/helpers\","
        },
        {
            "sha": "281ec58a88d2e7c4a9edbc9ec51d0912e3dda0e1",
            "filename": "packages/compiler-cli/test/ngtsc/env.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fenv.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fenv.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fenv.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -128,6 +128,13 @@ export class NgtscTestEnvironment {\n     return this.oldProgram.getTsProgram();\n   }\n \n+  getReuseTsProgram(): ts.Program {\n+    if (this.oldProgram === null) {\n+      throw new Error('No ts.Program has been created yet.');\n+    }\n+    return (this.oldProgram as NgtscProgram).getReuseTsProgram();\n+  }\n+\n   /**\n    * Older versions of the CLI do not provide the `CompilerHost.getModifiedResourceFiles()` method.\n    * This results in the `changedResources` set being `null`."
        },
        {
            "sha": "6d084e5baaf72c6e7fb31a75e343b6981fb0cd0b",
            "filename": "packages/compiler-cli/test/ngtsc/template_typecheck_spec.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 10,
            "changes": 29,
            "blob_url": "https://github.com/angular/angular/blob/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Ftemplate_typecheck_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/5103d908c89481d7b8a9f9a1cab2b996d86bc6a3/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Ftemplate_typecheck_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Ftemplate_typecheck_spec.ts?ref=5103d908c89481d7b8a9f9a1cab2b996d86bc6a3",
            "patch": "@@ -9,8 +9,9 @@\n import * as ts from 'typescript';\n \n import {ErrorCode, ngErrorCode} from '../../src/ngtsc/diagnostics';\n-import {absoluteFrom as _, getFileSystem} from '../../src/ngtsc/file_system';\n+import {absoluteFrom as _, getFileSystem, getSourceFileOrError} from '../../src/ngtsc/file_system';\n import {runInEachFileSystem} from '../../src/ngtsc/file_system/testing';\n+import {expectCompleteReuse} from '../../src/ngtsc/testing';\n import {loadStandardTestFiles} from '../helpers/src/mock_file_loading';\n \n import {NgtscTestEnvironment} from './env';\n@@ -1862,18 +1863,26 @@ export declare class AnimationEvent {\n         expect(env.driveDiagnostics()).toEqual([]);\n       });\n \n-      it('should not leave references to shims after execution', () => {\n-        // This test verifies that proper cleanup is performed for the technique being used to\n-        // include shim files in the ts.Program, and that none are left in the referencedFiles of\n-        // any ts.SourceFile after compilation.\n+      it('should not leave referencedFiles in a tagged state', () => {\n         env.enableMultipleCompilations();\n \n         env.driveMain();\n-        for (const sf of env.getTsProgram().getSourceFiles()) {\n-          for (const ref of sf.referencedFiles) {\n-            expect(ref.fileName).not.toContain('.ngtypecheck.ts');\n-          }\n-        }\n+        const sf = getSourceFileOrError(env.getTsProgram(), _('/test.ts'));\n+        expect(sf.referencedFiles.map(ref => ref.fileName)).toEqual([]);\n+      });\n+\n+      it('should allow for complete program reuse during incremental compilations', () => {\n+        env.enableMultipleCompilations();\n+\n+        env.write('other.ts', `export const VERSION = 1;`);\n+\n+        env.driveMain();\n+        const firstProgram = env.getReuseTsProgram();\n+\n+        env.write('other.ts', `export const VERSION = 2;`);\n+        env.driveMain();\n+\n+        expectCompleteReuse(firstProgram);\n       });\n     });\n   });"
        }
    ],
    "stats": {
        "total": 492,
        "additions": 391,
        "deletions": 101
    }
}