{
    "author": "gkalpak",
    "message": "fix(elements): fire custom element output events during component initialization (#37570)\n\nPreviously, event listeners for component output events attached on an\nAngular custom element before inserting it into the DOM (i.e. before\ninstantiating the underlying component) didn't fire for events emitted\nduring initialization lifecycle hooks, such as `ngAfterContentInit`,\n`ngAfterViewInit`, `ngOnChanges` (initial call) and `ngOnInit`.\nThe reason was that `NgElementImpl` [subscribed to events][1] _after_\ncalling [ngElementStrategy#connect()][2], which is where the\n[initial change detection][3] takes place (running the initialization\nlifecycle hooks).\n\nThis commit fixes this by:\n1. Ensuring `ComponentNgElementStrategy#events` is defined and available\n   for subscribing to, even before instantiating the component.\n2. Changing `NgElementImpl` to subscribe to `NgElementStrategy#events`\n   (if available) before calling `NgElementStrategy#connect()` (which\n   initializes the component instance) if available.\n3. Falling back to the old behavior (subscribing to `events` after\n   calling `connect()` for strategies that do not initialize `events`\n   before their `connect()` is run).\n\nNOTE:\nBy falling back to the old behavior when `NgElementStrategy#events` is\nnot initialized before calling `NgElementStrategy#connect()`, we avoid\nbreaking existing custom `NgElementStrategy` implementations (with\n@remackgeek's [ElementZoneStrategy][4] being a commonly used example).\n\nJira issue: [FW-2010](https://angular-team.atlassian.net/browse/FW-2010)\n\n[1]: https://github.com/angular/angular/blob/c0143cb2abdd172de1b95fd1d2c4cfc738640e28/packages/elements/src/create-custom-element.ts#L167-L170\n[2]: https://github.com/angular/angular/blob/c0143cb2abdd172de1b95fd1d2c4cfc738640e28/packages/elements/src/create-custom-element.ts#L164\n[3]: https://github.com/angular/angular/blob/c0143cb2abdd172de1b95fd1d2c4cfc738640e28/packages/elements/src/component-factory-strategy.ts#L158\n[4]: https://github.com/remackgeek/elements-zone-strategy/blob/f1b6699495a8c0909dbbfbdca12770ecca843e15/projects/elements-zone-strategy/src/lib/element-zone-strategy.ts\n\nFixes #36141\n\nPR Close #37570",
    "sha": "eba9dd364e51a6e857a94fd5f8980fec4350c856",
    "files": [
        {
            "sha": "799cfba683c4d992d18d960386d0e1992f670a1c",
            "filename": "packages/elements/src/component-factory-strategy.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 9,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/eba9dd364e51a6e857a94fd5f8980fec4350c856/packages%2Felements%2Fsrc%2Fcomponent-factory-strategy.ts",
            "raw_url": "https://github.com/angular/angular/raw/eba9dd364e51a6e857a94fd5f8980fec4350c856/packages%2Felements%2Fsrc%2Fcomponent-factory-strategy.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Felements%2Fsrc%2Fcomponent-factory-strategy.ts?ref=eba9dd364e51a6e857a94fd5f8980fec4350c856",
            "patch": "@@ -7,8 +7,8 @@\n  */\n \n import {ApplicationRef, ComponentFactory, ComponentFactoryResolver, ComponentRef, EventEmitter, Injector, OnChanges, SimpleChange, SimpleChanges, Type} from '@angular/core';\n-import {merge, Observable} from 'rxjs';\n-import {map} from 'rxjs/operators';\n+import {merge, Observable, ReplaySubject} from 'rxjs';\n+import {map, switchMap} from 'rxjs/operators';\n \n import {NgElementStrategy, NgElementStrategyEvent, NgElementStrategyFactory} from './element-strategy';\n import {extractProjectableNodes} from './extract-projectable-nodes';\n@@ -43,9 +43,11 @@ export class ComponentNgElementStrategyFactory implements NgElementStrategyFacto\n  * @publicApi\n  */\n export class ComponentNgElementStrategy implements NgElementStrategy {\n+  // Subject of `NgElementStrategyEvent` observables corresponding to the component's outputs.\n+  private eventEmitters = new ReplaySubject<Observable<NgElementStrategyEvent>[]>(1);\n+\n   /** Merged stream of the component's output events. */\n-  // TODO(issue/24571): remove '!'.\n-  events!: Observable<NgElementStrategyEvent>;\n+  readonly events = this.eventEmitters.pipe(switchMap(emitters => merge(...emitters)));\n \n   /** Reference to the component that was created on connect. */\n   private componentRef: ComponentRef<any>|null = null;\n@@ -187,12 +189,13 @@ export class ComponentNgElementStrategy implements NgElementStrategy {\n \n   /** Sets up listeners for the component's outputs so that the events stream emits the events. */\n   protected initializeOutputs(componentRef: ComponentRef<any>): void {\n-    const eventEmitters = this.componentFactory.outputs.map(({propName, templateName}) => {\n-      const emitter: EventEmitter<any> = componentRef.instance[propName];\n-      return emitter.pipe(map(value => ({name: templateName, value})));\n-    });\n+    const eventEmitters: Observable<NgElementStrategyEvent>[] =\n+        this.componentFactory.outputs.map(({propName, templateName}) => {\n+          const emitter: EventEmitter<any> = componentRef.instance[propName];\n+          return emitter.pipe(map(value => ({name: templateName, value})));\n+        });\n \n-    this.events = merge(...eventEmitters);\n+    this.eventEmitters.next(eventEmitters);\n   }\n \n   /** Calls ngOnChanges with all the inputs that have changed since the last call. */"
        },
        {
            "sha": "5724018a9ac52265a0a64cb083cbc032ce757bf6",
            "filename": "packages/elements/src/create-custom-element.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 5,
            "changes": 35,
            "blob_url": "https://github.com/angular/angular/blob/eba9dd364e51a6e857a94fd5f8980fec4350c856/packages%2Felements%2Fsrc%2Fcreate-custom-element.ts",
            "raw_url": "https://github.com/angular/angular/raw/eba9dd364e51a6e857a94fd5f8980fec4350c856/packages%2Felements%2Fsrc%2Fcreate-custom-element.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Felements%2Fsrc%2Fcreate-custom-element.ts?ref=eba9dd364e51a6e857a94fd5f8980fec4350c856",
            "patch": "@@ -187,13 +187,30 @@ export function createCustomElement<P>(\n     }\n \n     connectedCallback(): void {\n+      // For historical reasons, some strategies may not have initialized the `events` property\n+      // until after `connect()` is run. Subscribe to `events` if it is available before running\n+      // `connect()` (in order to capture events emitted suring inittialization), otherwise\n+      // subscribe afterwards.\n+      //\n+      // TODO: Consider deprecating/removing the post-connect subscription in a future major version\n+      //       (e.g. v11).\n+\n+      let subscribedToEvents = false;\n+\n+      if (this.ngElementStrategy.events) {\n+        // `events` are already available: Subscribe to it asap.\n+        this.subscribeToEvents();\n+        subscribedToEvents = true;\n+      }\n+\n       this.ngElementStrategy.connect(this);\n \n-      // Listen for events from the strategy and dispatch them as custom events\n-      this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(e => {\n-        const customEvent = createCustomEvent(this.ownerDocument!, e.name, e.value);\n-        this.dispatchEvent(customEvent);\n-      });\n+      if (!subscribedToEvents) {\n+        // `events` were not initialized before running `connect()`: Subscribe to them now.\n+        // The events emitted during the component initialization have been missed, but at least\n+        // future events will be captured.\n+        this.subscribeToEvents();\n+      }\n     }\n \n     disconnectedCallback(): void {\n@@ -207,6 +224,14 @@ export function createCustomElement<P>(\n         this.ngElementEventsSubscription = null;\n       }\n     }\n+\n+    private subscribeToEvents(): void {\n+      // Listen for events from the strategy and dispatch them as custom events.\n+      this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe(e => {\n+        const customEvent = createCustomEvent(this.ownerDocument!, e.name, e.value);\n+        this.dispatchEvent(customEvent);\n+      });\n+    }\n   }\n \n   // TypeScript 3.9+ defines getters/setters as configurable but non-enumerable properties (in"
        },
        {
            "sha": "53c9fbd0fc150df05f5b7510e697b4fecb487de1",
            "filename": "packages/elements/test/component-factory-strategy_spec.ts",
            "status": "modified",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/angular/angular/blob/eba9dd364e51a6e857a94fd5f8980fec4350c856/packages%2Felements%2Ftest%2Fcomponent-factory-strategy_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/eba9dd364e51a6e857a94fd5f8980fec4350c856/packages%2Felements%2Ftest%2Fcomponent-factory-strategy_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Felements%2Ftest%2Fcomponent-factory-strategy_spec.ts?ref=eba9dd364e51a6e857a94fd5f8980fec4350c856",
            "patch": "@@ -41,6 +41,33 @@ describe('ComponentFactoryNgElementStrategy', () => {\n     expect(strategyFactory.create(injector)).toBeTruthy();\n   });\n \n+  describe('before connected', () => {\n+    it('should allow subscribing to output events', () => {\n+      const events: NgElementStrategyEvent[] = [];\n+      strategy.events.subscribe(e => events.push(e));\n+\n+      // No events before connecting (since `componentRef` is not even on the strategy yet).\n+      componentRef.instance.output1.next('output-1a');\n+      componentRef.instance.output1.next('output-1b');\n+      componentRef.instance.output2.next('output-2a');\n+      expect(events).toEqual([]);\n+\n+      // No events upon connecting (since events are not cached/played back).\n+      strategy.connect(document.createElement('div'));\n+      expect(events).toEqual([]);\n+\n+      // Events emitted once connected.\n+      componentRef.instance.output1.next('output-1c');\n+      componentRef.instance.output1.next('output-1d');\n+      componentRef.instance.output2.next('output-2b');\n+      expect(events).toEqual([\n+        {name: 'templateOutput1', value: 'output-1c'},\n+        {name: 'templateOutput1', value: 'output-1d'},\n+        {name: 'templateOutput2', value: 'output-2b'},\n+      ]);\n+    });\n+  });\n+\n   describe('after connected', () => {\n     beforeEach(() => {\n       // Set up an initial value to make sure it is passed to the component"
        },
        {
            "sha": "e4a3e0713d7a684cbbdb21d306ab9821f3acb46a",
            "filename": "packages/elements/test/create-custom-element_spec.ts",
            "status": "modified",
            "additions": 57,
            "deletions": 10,
            "changes": 67,
            "blob_url": "https://github.com/angular/angular/blob/eba9dd364e51a6e857a94fd5f8980fec4350c856/packages%2Felements%2Ftest%2Fcreate-custom-element_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/eba9dd364e51a6e857a94fd5f8980fec4350c856/packages%2Felements%2Ftest%2Fcreate-custom-element_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Felements%2Ftest%2Fcreate-custom-element_spec.ts?ref=eba9dd364e51a6e857a94fd5f8980fec4350c856",
            "patch": "@@ -40,12 +40,7 @@ if (browserDetection.supportsCustomElements) {\n             strategyFactory = new TestStrategyFactory();\n             strategy = strategyFactory.testStrategy;\n \n-            const {selector, ElementCtor} = createTestCustomElement();\n-            NgElementCtor = ElementCtor;\n-\n-            // The `@webcomponents/custom-elements/src/native-shim.js` polyfill allows us to create\n-            // new instances of the NgElement which extends HTMLElement, as long as we define it.\n-            customElements.define(selector, NgElementCtor);\n+            NgElementCtor = createAndRegisterTestCustomElement(strategyFactory);\n           })\n           .then(done, done.fail);\n     });\n@@ -117,6 +112,47 @@ if (browserDetection.supportsCustomElements) {\n       expect(eventValue).toEqual(null);\n     });\n \n+    it('should listen to output events during initialization', () => {\n+      const events: string[] = [];\n+\n+      const element = new NgElementCtor(injector);\n+      element.addEventListener('strategy-event', evt => events.push((evt as CustomEvent).detail));\n+      element.connectedCallback();\n+\n+      expect(events).toEqual(['connect']);\n+    });\n+\n+    it('should not break if `NgElementStrategy#events` is not available before calling `NgElementStrategy#connect()`',\n+       () => {\n+         class TestStrategyWithLateEvents extends TestStrategy {\n+           events: Subject<NgElementStrategyEvent> = undefined!;\n+\n+           connect(element: HTMLElement): void {\n+             this.connectedElement = element;\n+             this.events = new Subject<NgElementStrategyEvent>();\n+             this.events.next({name: 'strategy-event', value: 'connect'});\n+           }\n+         }\n+\n+         const strategyWithLateEvents = new TestStrategyWithLateEvents();\n+         const capturedEvents: string[] = [];\n+\n+         const NgElementCtorWithLateEventsStrategy =\n+             createAndRegisterTestCustomElement({create: () => strategyWithLateEvents});\n+\n+         const element = new NgElementCtorWithLateEventsStrategy(injector);\n+         element.addEventListener(\n+             'strategy-event', evt => capturedEvents.push((evt as CustomEvent).detail));\n+         element.connectedCallback();\n+\n+         // The \"connect\" event (emitted during initialization) was missed, but things didn't break.\n+         expect(capturedEvents).toEqual([]);\n+\n+         // Subsequent events are still captured.\n+         strategyWithLateEvents.events.next({name: 'strategy-event', value: 'after-connect'});\n+         expect(capturedEvents).toEqual(['after-connect']);\n+       });\n+\n     it('should properly set getters/setters on the element', () => {\n       const element = new NgElementCtor(injector);\n       element.fooFoo = 'foo-foo-value';\n@@ -144,7 +180,7 @@ if (browserDetection.supportsCustomElements) {\n \n     it('should capture properties set before upgrading the element', () => {\n       // Create a regular element and set properties on it.\n-      const {selector, ElementCtor} = createTestCustomElement();\n+      const {selector, ElementCtor} = createTestCustomElement(strategyFactory);\n       const element = Object.assign(document.createElement(selector), {\n         fooFoo: 'foo-prop-value',\n         barBar: 'bar-prop-value',\n@@ -165,7 +201,7 @@ if (browserDetection.supportsCustomElements) {\n     it('should capture properties set after upgrading the element but before inserting it into the DOM',\n        () => {\n          // Create a regular element and set properties on it.\n-         const {selector, ElementCtor} = createTestCustomElement();\n+         const {selector, ElementCtor} = createTestCustomElement(strategyFactory);\n          const element = Object.assign(document.createElement(selector), {\n            fooFoo: 'foo-prop-value',\n            barBar: 'bar-prop-value',\n@@ -193,7 +229,7 @@ if (browserDetection.supportsCustomElements) {\n     it('should allow overwriting properties with attributes after upgrading the element but before inserting it into the DOM',\n        () => {\n          // Create a regular element and set properties on it.\n-         const {selector, ElementCtor} = createTestCustomElement();\n+         const {selector, ElementCtor} = createTestCustomElement(strategyFactory);\n          const element = Object.assign(document.createElement(selector), {\n            fooFoo: 'foo-prop-value',\n            barBar: 'bar-prop-value',\n@@ -219,7 +255,17 @@ if (browserDetection.supportsCustomElements) {\n        });\n \n     // Helpers\n-    function createTestCustomElement() {\n+    function createAndRegisterTestCustomElement(strategyFactory: NgElementStrategyFactory) {\n+      const {selector, ElementCtor} = createTestCustomElement(strategyFactory);\n+\n+      // The `@webcomponents/custom-elements/src/native-shim.js` polyfill allows us to create\n+      // new instances of the NgElement which extends HTMLElement, as long as we define it.\n+      customElements.define(selector, ElementCtor);\n+\n+      return ElementCtor;\n+    }\n+\n+    function createTestCustomElement(strategyFactory: NgElementStrategyFactory) {\n       return {\n         selector: `test-element-${++selectorUid}`,\n         ElementCtor: createCustomElement<WithFooBar>(TestComponent, {injector, strategyFactory}),\n@@ -255,6 +301,7 @@ if (browserDetection.supportsCustomElements) {\n       events = new Subject<NgElementStrategyEvent>();\n \n       connect(element: HTMLElement): void {\n+        this.events.next({name: 'strategy-event', value: 'connect'});\n         this.connectedElement = element;\n       }\n "
        }
    ],
    "stats": {
        "total": 150,
        "additions": 126,
        "deletions": 24
    }
}