{
    "author": "atscott",
    "message": "refactor(compiler-cli): TemplateTypeChecker with checkTypeOfAttributes=false should still work (#39537)\n\nWhen the compiler option `checkTypeOfAttributes` is `false`, we should\nstill be able to produce type information from the\n`TemplateTypeChecker`. The current behavior ignores all attributes that\nmap to directive inputs. This commit includes those attribute bindings\nin the TCB but adds the \"ignore for diagnostics\" marker so they do not\nproduce errors. This way, consumers of the TTC (the Language Service)\ncan still get valid information about these attributes even when the\nuser has configured the compiler to not produce diagnostics/errors for them.\n\nPR Close #39537",
    "sha": "a694838c411f9a7124091d0306a484b7902c11dd",
    "files": [
        {
            "sha": "9ad75894a9fb38a8bb210a6040d27f26831c6787",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/a694838c411f9a7124091d0306a484b7902c11dd/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/a694838c411f9a7124091d0306a484b7902c11dd/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=a694838c411f9a7124091d0306a484b7902c11dd",
            "patch": "@@ -512,6 +512,11 @@ class TcbDirectiveCtorOp extends TcbOp {\n \n     const inputs = getBoundInputs(this.dir, this.node, this.tcb);\n     for (const input of inputs) {\n+      // Skip text attributes if configured to do so.\n+      if (!this.tcb.env.config.checkTypeOfAttributes &&\n+          input.attribute instanceof TmplAstTextAttribute) {\n+        continue;\n+      }\n       for (const fieldName of input.fieldNames) {\n         // Skip the field if an attribute has already been bound to it; we can't have a duplicate\n         // key in the type constructor call.\n@@ -654,6 +659,12 @@ class TcbDirectiveInputsOp extends TcbOp {\n       }\n \n       addParseSpanInfo(assignment, input.attribute.sourceSpan);\n+      // Ignore diagnostics for text attributes if configured to do so.\n+      if (!this.tcb.env.config.checkTypeOfAttributes &&\n+          input.attribute instanceof TmplAstTextAttribute) {\n+        markIgnoreDiagnostics(assignment);\n+      }\n+\n       this.scope.addStatement(ts.createExpressionStatement(assignment));\n     }\n \n@@ -1732,11 +1743,6 @@ function getBoundInputs(\n       return;\n     }\n \n-    // Skip text attributes if configured to do so.\n-    if (!tcb.env.config.checkTypeOfAttributes && attr instanceof TmplAstTextAttribute) {\n-      return;\n-    }\n-\n     // Skip the attribute if the directive does not have an input for it.\n     const inputs = directive.inputs.getByBindingPropertyName(attr.name);\n     if (inputs === null) {"
        },
        {
            "sha": "464282fae3ece472903d1d1d54ef26cc5d952191",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 55,
            "deletions": 38,
            "changes": 93,
            "blob_url": "https://github.com/angular/angular/blob/a694838c411f9a7124091d0306a484b7902c11dd/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a694838c411f9a7124091d0306a484b7902c11dd/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=a694838c411f9a7124091d0306a484b7902c11dd",
            "patch": "@@ -9,7 +9,7 @@\n import {ASTWithSource, Binary, BindingPipe, Conditional, Interpolation, PropertyRead, TmplAstBoundAttribute, TmplAstBoundText, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate} from '@angular/compiler';\n import * as ts from 'typescript';\n \n-import {absoluteFrom, getSourceFileOrError} from '../../file_system';\n+import {absoluteFrom, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n import {ClassDeclaration} from '../../reflection';\n import {DirectiveSymbol, DomBindingSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, ReferenceSymbol, Symbol, SymbolKind, TemplateSymbol, TemplateTypeChecker, TypeCheckingConfig, VariableSymbol} from '../api';\n@@ -66,44 +66,61 @@ runInEachFileSystem(() => {\n       expect(beforeSymbol).not.toBe(afterSymbol);\n     });\n \n-    it('should get a symbol for text attributes corresponding with a directive input', () => {\n-      const fileName = absoluteFrom('/main.ts');\n-      const dirFile = absoluteFrom('/dir.ts');\n-      const templateString = `<div name=\"helloWorld\"></div>`;\n-      const {templateTypeChecker, program} = setup(\n-          [\n-            {\n-              fileName,\n-              templates: {'Cmp': templateString},\n-              declarations: [{\n-                name: 'NameDiv',\n-                selector: 'div[name]',\n-                file: dirFile,\n-                type: 'directive',\n-                inputs: {name: 'name'},\n-              }]\n-            },\n-            {\n-              fileName: dirFile,\n-              source: `export class NameDiv {name!: string;}`,\n-              templates: {},\n-            }\n-          ],\n-      );\n-      const sf = getSourceFileOrError(program, fileName);\n-      const cmp = getClass(sf, 'Cmp');\n-      const {attributes} = getAstElements(templateTypeChecker, cmp)[0];\n+    describe('should get a symbol for text attributes corresponding with a directive input', () => {\n+      let fileName: AbsoluteFsPath;\n+      let targets: TypeCheckingTarget[];\n+      beforeEach(() => {\n+        fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const templateString = `<div name=\"helloWorld\"></div>`;\n+        targets = [\n+          {\n+            fileName,\n+            templates: {'Cmp': templateString} as {[key: string]: string},\n+            declarations: [{\n+              name: 'NameDiv',\n+              selector: 'div[name]',\n+              file: dirFile,\n+              type: 'directive' as const,\n+              inputs: {name: 'name'},\n+            }]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `export class NameDiv {name!: string;}`,\n+            templates: {},\n+          }\n+        ];\n+      });\n \n-      const symbol = templateTypeChecker.getSymbolOfNode(attributes[0], cmp)!;\n-      assertInputBindingSymbol(symbol);\n-      expect(\n-          (symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration).name.getText())\n-          .toEqual('name');\n-\n-      // Ensure we can go back to the original location using the shim location\n-      const mapping =\n-          templateTypeChecker.getTemplateMappingAtShimLocation(symbol.bindings[0].shimLocation)!;\n-      expect(mapping.span.toString()).toEqual('name');\n+      it('checkTypeOfAttributes = true', () => {\n+        const {templateTypeChecker, program} = setup(targets, {checkTypeOfAttributes: true});\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+        const {attributes} = getAstElements(templateTypeChecker, cmp)[0];\n+        const symbol = templateTypeChecker.getSymbolOfNode(attributes[0], cmp)!;\n+        assertInputBindingSymbol(symbol);\n+        expect(\n+            (symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration).name.getText())\n+            .toEqual('name');\n+\n+        // Ensure we can go back to the original location using the shim location\n+        const mapping =\n+            templateTypeChecker.getTemplateMappingAtShimLocation(symbol.bindings[0].shimLocation)!;\n+        expect(mapping.span.toString()).toEqual('name');\n+      });\n+\n+      it('checkTypeOfAttributes = false', () => {\n+        const {templateTypeChecker, program} = setup(targets, {checkTypeOfAttributes: false});\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+        const {attributes} = getAstElements(templateTypeChecker, cmp)[0];\n+        const symbol = templateTypeChecker.getSymbolOfNode(attributes[0], cmp)!;\n+        assertInputBindingSymbol(symbol);\n+        expect(\n+            (symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration).name.getText())\n+            .toEqual('name');\n+      });\n     });\n \n     describe('templates', () => {"
        },
        {
            "sha": "45bc6b3eda2bef6facfe1da2fa8bb496cc421a26",
            "filename": "packages/language-service/ivy/test/quick_info_spec.ts",
            "status": "modified",
            "additions": 283,
            "deletions": 267,
            "changes": 550,
            "blob_url": "https://github.com/angular/angular/blob/a694838c411f9a7124091d0306a484b7902c11dd/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a694838c411f9a7124091d0306a484b7902c11dd/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fquick_info_spec.ts?ref=a694838c411f9a7124091d0306a484b7902c11dd",
            "patch": "@@ -104,363 +104,379 @@ function quickInfoSkeleton(): TestFile[] {\n describe('quick info', () => {\n   let env: LanguageServiceTestEnvironment;\n \n-  beforeEach(() => {\n-    initMockFileSystem('Native');\n-    env = LanguageServiceTestEnvironment.setup(quickInfoSkeleton());\n-  });\n-\n-  describe('elements', () => {\n-    it('should work for native elements', () => {\n-      expectQuickInfo({\n-        templateOverride: `<butt¦on></button>`,\n-        expectedSpanText: '<button></button>',\n-        expectedDisplayString: '(element) button: HTMLButtonElement'\n-      });\n+  describe('strict templates (happy path)', () => {\n+    beforeEach(() => {\n+      initMockFileSystem('Native');\n+      env = LanguageServiceTestEnvironment.setup(quickInfoSkeleton());\n     });\n \n-    it('should work for directives which match native element tags', () => {\n-      expectQuickInfo({\n-        templateOverride: `<butt¦on compound custom-button></button>`,\n-        expectedSpanText: '<button compound custom-button></button>',\n-        expectedDisplayString: '(directive) AppModule.CompoundCustomButtonDirective'\n+    describe('elements', () => {\n+      it('should work for native elements', () => {\n+        expectQuickInfo({\n+          templateOverride: `<butt¦on></button>`,\n+          expectedSpanText: '<button></button>',\n+          expectedDisplayString: '(element) button: HTMLButtonElement'\n+        });\n       });\n-    });\n-  });\n \n-  describe('templates', () => {\n-    it('should return undefined for ng-templates', () => {\n-      const {documentation} = expectQuickInfo({\n-        templateOverride: `<ng-templ¦ate></ng-template>`,\n-        expectedSpanText: '<ng-template></ng-template>',\n-        expectedDisplayString: '(template) ng-template'\n+      it('should work for directives which match native element tags', () => {\n+        expectQuickInfo({\n+          templateOverride: `<butt¦on compound custom-button></button>`,\n+          expectedSpanText: '<button compound custom-button></button>',\n+          expectedDisplayString: '(directive) AppModule.CompoundCustomButtonDirective'\n+        });\n       });\n-      expect(toText(documentation))\n-          .toContain('The `<ng-template>` is an Angular element for rendering HTML.');\n     });\n-  });\n \n-  describe('directives', () => {\n-    it('should work for directives', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div string-model¦></div>`,\n-        expectedSpanText: 'string-model',\n-        expectedDisplayString: '(directive) AppModule.StringModel'\n+    describe('templates', () => {\n+      it('should return undefined for ng-templates', () => {\n+        const {documentation} = expectQuickInfo({\n+          templateOverride: `<ng-templ¦ate></ng-template>`,\n+          expectedSpanText: '<ng-template></ng-template>',\n+          expectedDisplayString: '(template) ng-template'\n+        });\n+        expect(toText(documentation))\n+            .toContain('The `<ng-template>` is an Angular element for rendering HTML.');\n       });\n     });\n \n-    it('should work for components', () => {\n-      const {documentation} = expectQuickInfo({\n-        templateOverride: `<t¦est-comp></test-comp>`,\n-        expectedSpanText: '<test-comp></test-comp>',\n-        expectedDisplayString: '(component) AppModule.TestComponent'\n+    describe('directives', () => {\n+      it('should work for directives', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div string-model¦></div>`,\n+          expectedSpanText: 'string-model',\n+          expectedDisplayString: '(directive) AppModule.StringModel'\n+        });\n       });\n-      expect(toText(documentation)).toBe('This Component provides the `test-comp` selector.');\n-    });\n \n-    it('should work for structural directives', () => {\n-      const {documentation} = expectQuickInfo({\n-        templateOverride: `<div *¦ngFor=\"let item of heroes\"></div>`,\n-        expectedSpanText: 'ngFor',\n-        expectedDisplayString: '(directive) NgForOf<Hero, Hero[]>'\n+      it('should work for components', () => {\n+        const {documentation} = expectQuickInfo({\n+          templateOverride: `<t¦est-comp></test-comp>`,\n+          expectedSpanText: '<test-comp></test-comp>',\n+          expectedDisplayString: '(component) AppModule.TestComponent'\n+        });\n+        expect(toText(documentation)).toBe('This Component provides the `test-comp` selector.');\n       });\n-      expect(toText(documentation)).toContain('A fake version of the NgFor directive.');\n-    });\n \n-    it('should work for directives with compound selectors, some of which are bindings', () => {\n-      expectQuickInfo({\n-        templateOverride: `<ng-template ngF¦or let-hero [ngForOf]=\"heroes\">{{hero}}</ng-template>`,\n-        expectedSpanText: 'ngFor',\n-        expectedDisplayString: '(directive) NgForOf<Hero, Hero[]>'\n+      it('should work for structural directives', () => {\n+        const {documentation} = expectQuickInfo({\n+          templateOverride: `<div *¦ngFor=\"let item of heroes\"></div>`,\n+          expectedSpanText: 'ngFor',\n+          expectedDisplayString: '(directive) NgForOf<Hero, Hero[]>'\n+        });\n+        expect(toText(documentation)).toContain('A fake version of the NgFor directive.');\n       });\n-    });\n \n-    it('should work for data-let- syntax', () => {\n-      expectQuickInfo({\n-        templateOverride:\n-            `<ng-template ngFor data-let-he¦ro [ngForOf]=\"heroes\">{{hero}}</ng-template>`,\n-        expectedSpanText: 'hero',\n-        expectedDisplayString: '(variable) hero: Hero'\n+      it('should work for directives with compound selectors, some of which are bindings', () => {\n+        expectQuickInfo({\n+          templateOverride:\n+              `<ng-template ngF¦or let-hero [ngForOf]=\"heroes\">{{hero}}</ng-template>`,\n+          expectedSpanText: 'ngFor',\n+          expectedDisplayString: '(directive) NgForOf<Hero, Hero[]>'\n+        });\n       });\n-    });\n-  });\n \n-  describe('bindings', () => {\n-    describe('inputs', () => {\n-      it('should work for input providers', () => {\n+      it('should work for data-let- syntax', () => {\n         expectQuickInfo({\n-          templateOverride: `<test-comp [tcN¦ame]=\"name\"></test-comp>`,\n-          expectedSpanText: 'tcName',\n-          expectedDisplayString: '(property) TestComponent.name: string'\n+          templateOverride:\n+              `<ng-template ngFor data-let-he¦ro [ngForOf]=\"heroes\">{{hero}}</ng-template>`,\n+          expectedSpanText: 'hero',\n+          expectedDisplayString: '(variable) hero: Hero'\n         });\n       });\n+    });\n \n-      it('should work for bind- syntax', () => {\n-        expectQuickInfo({\n-          templateOverride: `<test-comp bind-tcN¦ame=\"name\"></test-comp>`,\n-          expectedSpanText: 'tcName',\n-          expectedDisplayString: '(property) TestComponent.name: string'\n+    describe('bindings', () => {\n+      describe('inputs', () => {\n+        it('should work for input providers', () => {\n+          expectQuickInfo({\n+            templateOverride: `<test-comp [tcN¦ame]=\"name\"></test-comp>`,\n+            expectedSpanText: 'tcName',\n+            expectedDisplayString: '(property) TestComponent.name: string'\n+          });\n         });\n-        expectQuickInfo({\n-          templateOverride: `<test-comp data-bind-tcN¦ame=\"name\"></test-comp>`,\n-          expectedSpanText: 'tcName',\n-          expectedDisplayString: '(property) TestComponent.name: string'\n+\n+        it('should work for bind- syntax', () => {\n+          expectQuickInfo({\n+            templateOverride: `<test-comp bind-tcN¦ame=\"name\"></test-comp>`,\n+            expectedSpanText: 'tcName',\n+            expectedDisplayString: '(property) TestComponent.name: string'\n+          });\n+          expectQuickInfo({\n+            templateOverride: `<test-comp data-bind-tcN¦ame=\"name\"></test-comp>`,\n+            expectedSpanText: 'tcName',\n+            expectedDisplayString: '(property) TestComponent.name: string'\n+          });\n         });\n-      });\n \n-      it('should work for structural directive inputs ngForTrackBy', () => {\n-        expectQuickInfo({\n-          templateOverride: `<div *ngFor=\"let item of heroes; tr¦ackBy: trackByFn;\"></div>`,\n-          expectedSpanText: 'trackBy',\n-          expectedDisplayString:\n-              '(property) NgForOf<Hero, Hero[]>.ngForTrackBy: TrackByFunction<Hero>'\n+        it('should work for structural directive inputs ngForTrackBy', () => {\n+          expectQuickInfo({\n+            templateOverride: `<div *ngFor=\"let item of heroes; tr¦ackBy: trackByFn;\"></div>`,\n+            expectedSpanText: 'trackBy',\n+            expectedDisplayString:\n+                '(property) NgForOf<Hero, Hero[]>.ngForTrackBy: TrackByFunction<Hero>'\n+          });\n         });\n-      });\n \n-      it('should work for structural directive inputs ngForOf', () => {\n-        expectQuickInfo({\n-          templateOverride: `<div *ngFor=\"let item o¦f heroes; trackBy: trackByFn;\"></div>`,\n-          expectedSpanText: 'of',\n-          expectedDisplayString:\n-              '(property) NgForOf<Hero, Hero[]>.ngForOf: Hero[] | (Hero[] & Iterable<Hero>) | null | undefined'\n+        it('should work for structural directive inputs ngForOf', () => {\n+          expectQuickInfo({\n+            templateOverride: `<div *ngFor=\"let item o¦f heroes; trackBy: trackByFn;\"></div>`,\n+            expectedSpanText: 'of',\n+            expectedDisplayString:\n+                '(property) NgForOf<Hero, Hero[]>.ngForOf: Hero[] | (Hero[] & Iterable<Hero>) | null | undefined'\n+          });\n+        });\n+\n+        it('should work for two-way binding providers', () => {\n+          expectQuickInfo({\n+            templateOverride: `<test-comp string-model [(mo¦del)]=\"title\"></test-comp>`,\n+            expectedSpanText: 'model',\n+            expectedDisplayString: '(property) StringModel.model: string'\n+          });\n         });\n       });\n \n-      it('should work for two-way binding providers', () => {\n-        expectQuickInfo({\n-          templateOverride: `<test-comp string-model [(mo¦del)]=\"title\"></test-comp>`,\n-          expectedSpanText: 'model',\n-          expectedDisplayString: '(property) StringModel.model: string'\n+      describe('outputs', () => {\n+        it('should work for event providers', () => {\n+          expectQuickInfo({\n+            templateOverride: `<test-comp (te¦st)=\"myClick($event)\"></test-comp>`,\n+            expectedSpanText: 'test',\n+            expectedDisplayString: '(event) TestComponent.testEvent: EventEmitter<string>'\n+          });\n+        });\n+\n+        it('should work for on- syntax binding', () => {\n+          expectQuickInfo({\n+            templateOverride: `<test-comp on-te¦st=\"myClick($event)\"></test-comp>`,\n+            expectedSpanText: 'test',\n+            expectedDisplayString: '(event) TestComponent.testEvent: EventEmitter<string>'\n+          });\n+          expectQuickInfo({\n+            templateOverride: `<test-comp data-on-te¦st=\"myClick($event)\"></test-comp>`,\n+            expectedSpanText: 'test',\n+            expectedDisplayString: '(event) TestComponent.testEvent: EventEmitter<string>'\n+          });\n+        });\n+\n+        it('should work for $event from EventEmitter', () => {\n+          expectQuickInfo({\n+            templateOverride: `<div string-model (modelChange)=\"myClick($e¦vent)\"></div>`,\n+            expectedSpanText: '$event',\n+            expectedDisplayString: '(parameter) $event: string'\n+          });\n+        });\n+\n+        it('should work for $event from native element', () => {\n+          expectQuickInfo({\n+            templateOverride: `<div (click)=\"myClick($e¦vent)\"></div>`,\n+            expectedSpanText: '$event',\n+            expectedDisplayString: '(parameter) $event: MouseEvent'\n+          });\n         });\n       });\n     });\n \n-    describe('outputs', () => {\n-      it('should work for event providers', () => {\n-        expectQuickInfo({\n-          templateOverride: `<test-comp (te¦st)=\"myClick($event)\"></test-comp>`,\n-          expectedSpanText: 'test',\n-          expectedDisplayString: '(event) TestComponent.testEvent: EventEmitter<string>'\n+    describe('references', () => {\n+      it('should work for element reference declarations', () => {\n+        const {documentation} = expectQuickInfo({\n+          templateOverride: `<div #¦chart></div>`,\n+          expectedSpanText: 'chart',\n+          expectedDisplayString: '(reference) chart: HTMLDivElement'\n         });\n+        expect(toText(documentation))\n+            .toEqual(\n+                'Provides special properties (beyond the regular HTMLElement ' +\n+                'interface it also has available to it by inheritance) for manipulating <div> elements.');\n       });\n \n-      it('should work for on- syntax binding', () => {\n+      it('should work for directive references', () => {\n         expectQuickInfo({\n-          templateOverride: `<test-comp on-te¦st=\"myClick($event)\"></test-comp>`,\n-          expectedSpanText: 'test',\n-          expectedDisplayString: '(event) TestComponent.testEvent: EventEmitter<string>'\n-        });\n-        expectQuickInfo({\n-          templateOverride: `<test-comp data-on-te¦st=\"myClick($event)\"></test-comp>`,\n-          expectedSpanText: 'test',\n-          expectedDisplayString: '(event) TestComponent.testEvent: EventEmitter<string>'\n+          templateOverride: `<div string-model #dir¦Ref=\"stringModel\"></div>`,\n+          expectedSpanText: 'dirRef',\n+          expectedDisplayString: '(reference) dirRef: StringModel'\n         });\n       });\n \n-      it('should work for $event from EventEmitter', () => {\n+      it('should work for ref- syntax', () => {\n         expectQuickInfo({\n-          templateOverride: `<div string-model (modelChange)=\"myClick($e¦vent)\"></div>`,\n-          expectedSpanText: '$event',\n-          expectedDisplayString: '(parameter) $event: string'\n+          templateOverride: `<div ref-ch¦art></div>`,\n+          expectedSpanText: 'chart',\n+          expectedDisplayString: '(reference) chart: HTMLDivElement'\n         });\n-      });\n-\n-      it('should work for $event from native element', () => {\n         expectQuickInfo({\n-          templateOverride: `<div (click)=\"myClick($e¦vent)\"></div>`,\n-          expectedSpanText: '$event',\n-          expectedDisplayString: '(parameter) $event: MouseEvent'\n+          templateOverride: `<div data-ref-ch¦art></div>`,\n+          expectedSpanText: 'chart',\n+          expectedDisplayString: '(reference) chart: HTMLDivElement'\n         });\n       });\n     });\n-  });\n \n-  describe('references', () => {\n-    it('should work for element reference declarations', () => {\n-      const {documentation} = expectQuickInfo({\n-        templateOverride: `<div #¦chart></div>`,\n-        expectedSpanText: 'chart',\n-        expectedDisplayString: '(reference) chart: HTMLDivElement'\n-      });\n-      expect(toText(documentation))\n-          .toEqual(\n-              'Provides special properties (beyond the regular HTMLElement ' +\n-              'interface it also has available to it by inheritance) for manipulating <div> elements.');\n-    });\n-\n-    it('should work for directive references', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div string-model #dir¦Ref=\"stringModel\"></div>`,\n-        expectedSpanText: 'dirRef',\n-        expectedDisplayString: '(reference) dirRef: StringModel'\n+    describe('variables', () => {\n+      it('should work for array members', () => {\n+        const {documentation} = expectQuickInfo({\n+          templateOverride: `<div *ngFor=\"let hero of heroes\">{{her¦o}}</div>`,\n+          expectedSpanText: 'hero',\n+          expectedDisplayString: '(variable) hero: Hero'\n+        });\n+        expect(toText(documentation)).toEqual('The most heroic being.');\n       });\n-    });\n \n-    it('should work for ref- syntax', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div ref-ch¦art></div>`,\n-        expectedSpanText: 'chart',\n-        expectedDisplayString: '(reference) chart: HTMLDivElement'\n-      });\n-      expectQuickInfo({\n-        templateOverride: `<div data-ref-ch¦art></div>`,\n-        expectedSpanText: 'chart',\n-        expectedDisplayString: '(reference) chart: HTMLDivElement'\n+      it('should work for ReadonlyArray members (#36191)', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div *ngFor=\"let hero of readonlyHeroes\">{{her¦o}}</div>`,\n+          expectedSpanText: 'hero',\n+          expectedDisplayString: '(variable) hero: Readonly<Hero>'\n+        });\n       });\n-    });\n-  });\n \n-  describe('variables', () => {\n-    it('should work for array members', () => {\n-      const {documentation} = expectQuickInfo({\n-        templateOverride: `<div *ngFor=\"let hero of heroes\">{{her¦o}}</div>`,\n-        expectedSpanText: 'hero',\n-        expectedDisplayString: '(variable) hero: Hero'\n+      it('should work for const array members (#36191)', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div *ngFor=\"let name of constNames\">{{na¦me}}</div>`,\n+          expectedSpanText: 'name',\n+          expectedDisplayString: '(variable) name: { readonly name: \"name\"; }'\n+        });\n       });\n-      expect(toText(documentation)).toEqual('The most heroic being.');\n     });\n \n-    it('should work for ReadonlyArray members (#36191)', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div *ngFor=\"let hero of readonlyHeroes\">{{her¦o}}</div>`,\n-        expectedSpanText: 'hero',\n-        expectedDisplayString: '(variable) hero: Readonly<Hero>'\n+    describe('pipes', () => {\n+      it('should work for pipes', () => {\n+        const templateOverride = `<p>The hero's birthday is {{birthday | da¦te: \"MM/dd/yy\"}}</p>`;\n+        expectQuickInfo({\n+          templateOverride,\n+          expectedSpanText: 'date',\n+          expectedDisplayString:\n+              '(pipe) DatePipe.transform(value: string | number | Date, format?: string | undefined, timezone?: ' +\n+              'string | undefined, locale?: string | undefined): string | null (+2 overloads)'\n+        });\n       });\n     });\n \n-    it('should work for const array members (#36191)', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div *ngFor=\"let name of constNames\">{{na¦me}}</div>`,\n-        expectedSpanText: 'name',\n-        expectedDisplayString: '(variable) name: { readonly name: \"name\"; }'\n+    describe('expressions', () => {\n+      it('should find members in a text interpolation', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div>{{ tit¦le }}</div>`,\n+          expectedSpanText: 'title',\n+          expectedDisplayString: '(property) AppCmp.title: string'\n+        });\n       });\n-    });\n-  });\n \n-  describe('pipes', () => {\n-    it('should work for pipes', () => {\n-      const templateOverride = `<p>The hero's birthday is {{birthday | da¦te: \"MM/dd/yy\"}}</p>`;\n-      expectQuickInfo({\n-        templateOverride,\n-        expectedSpanText: 'date',\n-        expectedDisplayString:\n-            '(pipe) DatePipe.transform(value: string | number | Date, format?: string | undefined, timezone?: ' +\n-            'string | undefined, locale?: string | undefined): string | null (+2 overloads)'\n+      it('should work for accessed property reads', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div>{{title.len¦gth}}</div>`,\n+          expectedSpanText: 'length',\n+          expectedDisplayString: '(property) String.length: number'\n+        });\n       });\n-    });\n-  });\n \n-  describe('expressions', () => {\n-    it('should find members in a text interpolation', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div>{{ tit¦le }}</div>`,\n-        expectedSpanText: 'title',\n-        expectedDisplayString: '(property) AppCmp.title: string'\n+      it('should find members in an attribute interpolation', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div string-model model=\"{{tit¦le}}\"></div>`,\n+          expectedSpanText: 'title',\n+          expectedDisplayString: '(property) AppCmp.title: string'\n+        });\n       });\n-    });\n \n-    it('should work for accessed property reads', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div>{{title.len¦gth}}</div>`,\n-        expectedSpanText: 'length',\n-        expectedDisplayString: '(property) String.length: number'\n+      it('should find members of input binding', () => {\n+        expectQuickInfo({\n+          templateOverride: `<test-comp [tcName]=\"ti¦tle\"></test-comp>`,\n+          expectedSpanText: 'title',\n+          expectedDisplayString: '(property) AppCmp.title: string'\n+        });\n       });\n-    });\n \n-    it('should find members in an attribute interpolation', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div string-model model=\"{{tit¦le}}\"></div>`,\n-        expectedSpanText: 'title',\n-        expectedDisplayString: '(property) AppCmp.title: string'\n+      it('should find input binding on text attribute', () => {\n+        expectQuickInfo({\n+          templateOverride: `<test-comp tcN¦ame=\"title\"></test-comp>`,\n+          expectedSpanText: 'tcName',\n+          expectedDisplayString: '(property) TestComponent.name: string'\n+        });\n       });\n-    });\n \n-    it('should find members of input binding', () => {\n-      expectQuickInfo({\n-        templateOverride: `<test-comp [tcName]=\"ti¦tle\"></test-comp>`,\n-        expectedSpanText: 'title',\n-        expectedDisplayString: '(property) AppCmp.title: string'\n+      it('should find members of event binding', () => {\n+        expectQuickInfo({\n+          templateOverride: `<test-comp (test)=\"ti¦tle=$event\"></test-comp>`,\n+          expectedSpanText: 'title',\n+          expectedDisplayString: '(property) AppCmp.title: string'\n+        });\n       });\n-    });\n \n-    it('should find input binding on text attribute', () => {\n-      expectQuickInfo({\n-        templateOverride: `<test-comp tcN¦ame=\"title\"></test-comp>`,\n-        expectedSpanText: 'tcName',\n-        expectedDisplayString: '(property) TestComponent.name: string'\n+      it('should work for method calls', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div (click)=\"setT¦itle('title')\"></div>`,\n+          expectedSpanText: 'setTitle',\n+          expectedDisplayString: '(method) AppCmp.setTitle(newTitle: string): void'\n+        });\n       });\n-    });\n \n-    it('should find members of event binding', () => {\n-      expectQuickInfo({\n-        templateOverride: `<test-comp (test)=\"ti¦tle=$event\"></test-comp>`,\n-        expectedSpanText: 'title',\n-        expectedDisplayString: '(property) AppCmp.title: string'\n+      it('should work for accessed properties in writes', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div (click)=\"hero.i¦d = 2\"></div>`,\n+          expectedSpanText: 'id',\n+          expectedDisplayString: '(property) Hero.id: number'\n+        });\n       });\n-    });\n \n-    it('should work for method calls', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div (click)=\"setT¦itle('title')\"></div>`,\n-        expectedSpanText: 'setTitle',\n-        expectedDisplayString: '(method) AppCmp.setTitle(newTitle: string): void'\n+      it('should work for method call arguments', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div (click)=\"setTitle(hero.nam¦e)\"></div>`,\n+          expectedSpanText: 'name',\n+          expectedDisplayString: '(property) Hero.name: string'\n+        });\n       });\n-    });\n \n-    it('should work for accessed properties in writes', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div (click)=\"hero.i¦d = 2\"></div>`,\n-        expectedSpanText: 'id',\n-        expectedDisplayString: '(property) Hero.id: number'\n+      it('should find members of two-way binding', () => {\n+        expectQuickInfo({\n+          templateOverride: `<input string-model [(model)]=\"ti¦tle\" />`,\n+          expectedSpanText: 'title',\n+          expectedDisplayString: '(property) AppCmp.title: string'\n+        });\n       });\n-    });\n \n-    it('should work for method call arguments', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div (click)=\"setTitle(hero.nam¦e)\"></div>`,\n-        expectedSpanText: 'name',\n-        expectedDisplayString: '(property) Hero.name: string'\n+      it('should find members in a structural directive', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div *ngIf=\"anyV¦alue\"></div>`,\n+          expectedSpanText: 'anyValue',\n+          expectedDisplayString: '(property) AppCmp.anyValue: any'\n+        });\n       });\n-    });\n \n-    it('should find members of two-way binding', () => {\n-      expectQuickInfo({\n-        templateOverride: `<input string-model [(model)]=\"ti¦tle\" />`,\n-        expectedSpanText: 'title',\n-        expectedDisplayString: '(property) AppCmp.title: string'\n+      it('should work for members in structural directives', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div *ngFor=\"let item of her¦oes; trackBy: trackByFn;\"></div>`,\n+          expectedSpanText: 'heroes',\n+          expectedDisplayString: '(property) AppCmp.heroes: Hero[]'\n+        });\n       });\n-    });\n \n-    it('should find members in a structural directive', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div *ngIf=\"anyV¦alue\"></div>`,\n-        expectedSpanText: 'anyValue',\n-        expectedDisplayString: '(property) AppCmp.anyValue: any'\n+      it('should work for the $any() cast function', () => {\n+        expectQuickInfo({\n+          templateOverride: `<div>{{$an¦y(title)}}</div>`,\n+          expectedSpanText: '$any',\n+          expectedDisplayString: '(method) $any: any'\n+        });\n       });\n-    });\n \n-    it('should work for members in structural directives', () => {\n-      expectQuickInfo({\n-        templateOverride: `<div *ngFor=\"let item of her¦oes; trackBy: trackByFn;\"></div>`,\n-        expectedSpanText: 'heroes',\n-        expectedDisplayString: '(property) AppCmp.heroes: Hero[]'\n+      it('should provide documentation', () => {\n+        const {cursor} = env.overrideTemplateWithCursor(\n+            absoluteFrom('/app.ts'), 'AppCmp', `<div>{{¦title}}</div>`);\n+        const quickInfo = env.ngLS.getQuickInfoAtPosition(absoluteFrom('/app.html'), cursor);\n+        const documentation = toText(quickInfo!.documentation);\n+        expect(documentation).toBe('This is the title of the `AppCmp` Component.');\n       });\n     });\n+  });\n \n-    it('should work for the $any() cast function', () => {\n+  describe('non-strict compiler options', () => {\n+    it('should find input binding on text attribute when strictAttributeTypes is false', () => {\n+      initMockFileSystem('Native');\n+      env =\n+          LanguageServiceTestEnvironment.setup(quickInfoSkeleton(), {strictAttributeTypes: false});\n       expectQuickInfo({\n-        templateOverride: `<div>{{$an¦y(title)}}</div>`,\n-        expectedSpanText: '$any',\n-        expectedDisplayString: '(method) $any: any'\n+        templateOverride: `<test-comp tcN¦ame=\"title\"></test-comp>`,\n+        expectedSpanText: 'tcName',\n+        expectedDisplayString: '(property) TestComponent.name: string'\n       });\n     });\n-\n-    it('should provide documentation', () => {\n-      const {cursor} = env.overrideTemplateWithCursor(\n-          absoluteFrom('/app.ts'), 'AppCmp', `<div>{{¦title}}</div>`);\n-      const quickInfo = env.ngLS.getQuickInfoAtPosition(absoluteFrom('/app.html'), cursor);\n-      const documentation = toText(quickInfo!.documentation);\n-      expect(documentation).toBe('This is the title of the `AppCmp` Component.');\n-    });\n   });\n \n   function expectQuickInfo("
        }
    ],
    "stats": {
        "total": 659,
        "additions": 349,
        "deletions": 310
    }
}