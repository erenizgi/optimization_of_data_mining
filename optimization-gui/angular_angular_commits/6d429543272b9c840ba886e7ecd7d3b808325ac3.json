{
    "author": "alxhub",
    "message": "fix(compiler-cli): remove the concept of an errored trait (#39923)\n\nPreviously, if a trait's analysis step resulted in diagnostics, the trait\nwould be considered \"errored\" and no further operations, including register,\nwould be performed. Effectively, this meant that the compiler would pretend\nthe class in question was actually undecorated.\n\nHowever, this behavior is problematic for several reasons:\n\n1. It leads to inaccurate diagnostics being reported downstream.\n\nFor example, if a component is put into the error state, for example due to\na template error, the NgModule which declares the component would produce a\ndiagnostic claiming that the declaration is neither a directive nor a pipe.\nThis happened because the compiler wouldn't register() the component trait,\nso the component would not be recorded as actually being a directive.\n\n2. It can cause incorrect behavior on incremental builds.\n\nThis bug is more complex, but the general issue is that if the compiler\nfails to associate a component and its module, then incremental builds will\nnot correctly re-analyze the module when the component's template changes.\nFailing to register the component as such is one link in the larger chain of\nissues that result in these kinds of issues.\n\n3. It lumps together diagnostics produced during analysis and resolve steps.\n\nThis is not causing issues currently as the dependency graph ensures the\nright classes are re-analyzed when needed, instead of showing stale\ndiagnostics. However, the dependency graph was not intended to serve this\nrole, and could potentially be optimized in ways that would break this\nfunctionality.\n\nThis commit removes the concept of an \"errored\" trait entirely from the\ntrait system. Instead, analyzed and resolved traits have corresponding (and\nseparate) diagnostics, in addition to potentially `null` analysis results.\nAnalysis (but not resolution) diagnostics are carried forward during\nincremental build operations. Compilation (emit) is only performed when\na trait reaches the resolved state with no diagnostics.\n\nThis change is functionally different than before as the `register` step is\nnow performed even in the presence of analysis errors, as long as analysis\nresults are also produced. This fixes problem 1 above, and is part of the\nlarger solution to problem 2.\n\nPR Close #39923",
    "sha": "6d429543272b9c840ba886e7ecd7d3b808325ac3",
    "files": [
        {
            "sha": "60b6f89bd68c9cc195056f09dd0b49d99094fe51",
            "filename": "packages/compiler-cli/ngcc/src/analysis/migration_host.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fmigration_host.ts",
            "raw_url": "https://github.com/angular/angular/raw/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fmigration_host.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fmigration_host.ts?ref=6d429543272b9c840ba886e7ecd7d3b808325ac3",
            "patch": "@@ -32,9 +32,14 @@ export class DefaultMigrationHost implements MigrationHost {\n     const migratedTraits = this.compiler.injectSyntheticDecorator(clazz, decorator, flags);\n \n     for (const trait of migratedTraits) {\n-      if (trait.state === TraitState.ERRORED) {\n-        trait.diagnostics =\n-            trait.diagnostics.map(diag => createMigrationDiagnostic(diag, clazz, decorator));\n+      if ((trait.state === TraitState.Analyzed || trait.state === TraitState.Resolved) &&\n+          trait.analysisDiagnostics !== null) {\n+        trait.analysisDiagnostics = trait.analysisDiagnostics.map(\n+            diag => createMigrationDiagnostic(diag, clazz, decorator));\n+      }\n+      if (trait.state === TraitState.Resolved && trait.resolveDiagnostics !== null) {\n+        trait.resolveDiagnostics =\n+            trait.resolveDiagnostics.map(diag => createMigrationDiagnostic(diag, clazz, decorator));\n       }\n     }\n   }"
        },
        {
            "sha": "0b01063bd9003622f3525bd6b6636f14fa6c4748",
            "filename": "packages/compiler-cli/ngcc/test/analysis/decoration_analyzer_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fdecoration_analyzer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fdecoration_analyzer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fdecoration_analyzer_spec.ts?ref=6d429543272b9c840ba886e7ecd7d3b808325ac3",
            "patch": "@@ -79,7 +79,7 @@ runInEachFileSystem(() => {\n         handler.analyze.and.callFake((decl: DeclarationNode, dec: Decorator) => {\n           logs.push(`analyze: ${(decl as any).name.text}@${dec.name}`);\n           return {\n-            analysis: {decoratorName: dec.name},\n+            analysis: !options.analyzeErrorÂ ? {decoratorName: dec.name} : undefined,\n             diagnostics: options.analyzeError ? [makeDiagnostic(9999, decl, 'analyze diagnostic')] :\n                                                 undefined\n           };\n@@ -407,7 +407,7 @@ runInEachFileSystem(() => {\n                 `,\n                 },\n               ],\n-              {analyzeError: true, resolveError: true});\n+              {analyzeError: true, resolveError: false});\n           analyzer.analyzeProgram();\n           expect(diagnosticLogs.length).toEqual(1);\n           expect(diagnosticLogs[0]).toEqual(jasmine.objectContaining({code: -999999}));"
        },
        {
            "sha": "fff82af6bf5bbfa6936cc0a09b25212126bdeb94",
            "filename": "packages/compiler-cli/ngcc/test/analysis/migration_host_spec.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fmigration_host_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fmigration_host_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fmigration_host_spec.ts?ref=6d429543272b9c840ba886e7ecd7d3b808325ac3",
            "patch": "@@ -14,13 +14,14 @@ import {runInEachFileSystem} from '../../../src/ngtsc/file_system/testing';\n import {MockLogger} from '../../../src/ngtsc/logging/testing';\n import {ClassDeclaration, Decorator, isNamedClassDeclaration} from '../../../src/ngtsc/reflection';\n import {getDeclaration, loadTestFiles} from '../../../src/ngtsc/testing';\n-import {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence, TraitState} from '../../../src/ngtsc/transform';\n+import {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence} from '../../../src/ngtsc/transform';\n import {DefaultMigrationHost} from '../../src/analysis/migration_host';\n import {NgccTraitCompiler} from '../../src/analysis/ngcc_trait_compiler';\n import {Esm2015ReflectionHost} from '../../src/host/esm2015_host';\n import {createComponentDecorator} from '../../src/migrations/utils';\n import {EntryPointBundle} from '../../src/packages/entry_point_bundle';\n import {makeTestEntryPointBundle} from '../helpers/utils';\n+import {getTraitDiagnostics} from '../host/util';\n \n runInEachFileSystem(() => {\n   describe('DefaultMigrationHost', () => {\n@@ -78,12 +79,13 @@ runInEachFileSystem(() => {\n \n         const record = compiler.recordFor(mockClazz)!;\n         const migratedTrait = record.traits[0];\n-        if (migratedTrait.state !== TraitState.ERRORED) {\n+        const diagnostics = getTraitDiagnostics(migratedTrait);\n+        if (diagnostics === null) {\n           return fail('Expected migrated class trait to be in an error state');\n         }\n \n-        expect(migratedTrait.diagnostics.length).toBe(1);\n-        expect(ts.flattenDiagnosticMessageText(migratedTrait.diagnostics[0].messageText, '\\n'))\n+        expect(diagnostics.length).toBe(1);\n+        expect(ts.flattenDiagnosticMessageText(diagnostics[0].messageText, '\\n'))\n             .toEqual(\n                 `test diagnostic\\n` +\n                 `  Occurs for @Component decorator inserted by an automatic migration\\n` +"
        },
        {
            "sha": "71f9e10c1dc56d3c32736073bfd6ce85544c5258",
            "filename": "packages/compiler-cli/ngcc/test/analysis/ngcc_trait_compiler_spec.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fngcc_trait_compiler_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fngcc_trait_compiler_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fanalysis%2Fngcc_trait_compiler_spec.ts?ref=6d429543272b9c840ba886e7ecd7d3b808325ac3",
            "patch": "@@ -18,6 +18,7 @@ import {Esm2015ReflectionHost} from '../../src/host/esm2015_host';\n import {createComponentDecorator} from '../../src/migrations/utils';\n import {EntryPointBundle} from '../../src/packages/entry_point_bundle';\n import {makeTestEntryPointBundle} from '../helpers/utils';\n+import {getTraitDiagnostics} from '../host/util';\n \n runInEachFileSystem(() => {\n   describe('NgccTraitCompiler', () => {\n@@ -233,12 +234,13 @@ runInEachFileSystem(() => {\n \n         const record = compiler.recordFor(mockClazz)!;\n         const migratedTrait = record.traits[0];\n-        if (migratedTrait.state !== TraitState.ERRORED) {\n+        const diagnostics = getTraitDiagnostics(migratedTrait);\n+        if (diagnostics === null) {\n           return fail('Expected migrated class trait to be in an error state');\n         }\n \n-        expect(migratedTrait.diagnostics.length).toBe(1);\n-        expect(migratedTrait.diagnostics[0].messageText).toEqual(`test diagnostic`);\n+        expect(diagnostics.length).toBe(1);\n+        expect(diagnostics[0].messageText).toEqual(`test diagnostic`);\n       });\n     });\n "
        },
        {
            "sha": "dbec4d00d64c30f7ffaae46c7db00b71e45aa47d",
            "filename": "packages/compiler-cli/ngcc/test/host/util.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Ftest%2Fhost%2Futil.ts?ref=6d429543272b9c840ba886e7ecd7d3b808325ac3",
            "patch": "@@ -5,6 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n+import {Trait, TraitState} from '@angular/compiler-cli/src/ngtsc/transform';\n import * as ts from 'typescript';\n import {CtorParameter, TypeValueReferenceKind} from '../../../src/ngtsc/reflection';\n \n@@ -48,3 +49,17 @@ export function expectTypeValueReferencesForParameters(\n     }\n   });\n }\n+\n+export function getTraitDiagnostics(trait: Trait<unknown, unknown, unknown>): ts.Diagnostic[]|null {\n+  if (trait.state === TraitState.Analyzed) {\n+    return trait.analysisDiagnostics;\n+  } else if (trait.state === TraitState.Resolved) {\n+    const diags = [\n+      ...(trait.analysisDiagnostics ?? []),\n+      ...(trait.resolveDiagnostics ?? []),\n+    ];\n+    return diags.length > 0 ? diags : null;\n+  } else {\n+    return null;\n+  }\n+}"
        },
        {
            "sha": "a3fe99dfe68c4b8968de7b049fb059165bbbc006",
            "filename": "packages/compiler-cli/src/ngtsc/transform/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Findex.ts?ref=6d429543272b9c840ba886e7ecd7d3b808325ac3",
            "patch": "@@ -10,5 +10,5 @@ export * from './src/api';\n export {aliasTransformFactory} from './src/alias';\n export {ClassRecord, TraitCompiler} from './src/compilation';\n export {declarationTransformFactory, DtsTransformRegistry, IvyDeclarationDtsTransform, ReturnTypeTransform} from './src/declaration';\n-export {AnalyzedTrait, ErroredTrait, PendingTrait, ResolvedTrait, SkippedTrait, Trait, TraitState} from './src/trait';\n+export {AnalyzedTrait, PendingTrait, ResolvedTrait, SkippedTrait, Trait, TraitState} from './src/trait';\n export {ivyTransformFactory} from './src/transform';"
        },
        {
            "sha": "a3347323ef3a7be6964b07517ab01f3c5f14825d",
            "filename": "packages/compiler-cli/src/ngtsc/transform/src/compilation.ts",
            "status": "modified",
            "additions": 47,
            "deletions": 46,
            "changes": 93,
            "blob_url": "https://github.com/angular/angular/blob/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fcompilation.ts",
            "raw_url": "https://github.com/angular/angular/raw/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fcompilation.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fcompilation.ts?ref=6d429543272b9c840ba886e7ecd7d3b808325ac3",
            "patch": "@@ -181,15 +181,13 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n       const handler = this.handlersByName.get(priorTrait.handler.name)!;\n       let trait: Trait<unknown, unknown, unknown> = Trait.pending(handler, priorTrait.detected);\n \n-      if (priorTrait.state === TraitState.ANALYZED || priorTrait.state === TraitState.RESOLVED) {\n-        trait = trait.toAnalyzed(priorTrait.analysis);\n-        if (trait.handler.register !== undefined) {\n+      if (priorTrait.state === TraitState.Analyzed || priorTrait.state === TraitState.Resolved) {\n+        trait = trait.toAnalyzed(priorTrait.analysis, priorTrait.analysisDiagnostics);\n+        if (trait.analysis !== null && trait.handler.register !== undefined) {\n           trait.handler.register(record.node, trait.analysis);\n         }\n-      } else if (priorTrait.state === TraitState.SKIPPED) {\n+      } else if (priorTrait.state === TraitState.Skipped) {\n         trait = trait.toSkipped();\n-      } else if (priorTrait.state === TraitState.ERRORED) {\n-        trait = trait.toErrored(priorTrait.diagnostics);\n       }\n \n       record.traits.push(trait);\n@@ -314,7 +312,7 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n           preanalysis = trait.handler.preanalyze(clazz, trait.detected.metadata) || null;\n         } catch (err) {\n           if (err instanceof FatalDiagnosticError) {\n-            trait.toErrored([err.toDiagnostic()]);\n+            trait.toAnalyzed(null, [err.toDiagnostic()]);\n             return;\n           } else {\n             throw err;\n@@ -332,7 +330,7 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n   protected analyzeTrait(\n       clazz: ClassDeclaration, trait: Trait<unknown, unknown, unknown>,\n       flags?: HandlerFlags): void {\n-    if (trait.state !== TraitState.PENDING) {\n+    if (trait.state !== TraitState.Pending) {\n       throw new Error(`Attempt to analyze trait of ${clazz.name.text} in state ${\n           TraitState[trait.state]} (expected DETECTED)`);\n     }\n@@ -343,26 +341,18 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n       result = trait.handler.analyze(clazz, trait.detected.metadata, flags);\n     } catch (err) {\n       if (err instanceof FatalDiagnosticError) {\n-        trait = trait.toErrored([err.toDiagnostic()]);\n+        trait.toAnalyzed(null, [err.toDiagnostic()]);\n         return;\n       } else {\n         throw err;\n       }\n     }\n \n-    if (result.diagnostics !== undefined) {\n-      trait = trait.toErrored(result.diagnostics);\n-    } else if (result.analysis !== undefined) {\n-      // Analysis was successful. Trigger registration.\n-      if (trait.handler.register !== undefined) {\n-        trait.handler.register(clazz, result.analysis);\n-      }\n-\n-      // Successfully analyzed and registered.\n-      trait = trait.toAnalyzed(result.analysis);\n-    } else {\n-      trait = trait.toSkipped();\n+    if (result.analysis !== undefined && trait.handler.register !== undefined) {\n+      trait.handler.register(clazz, result.analysis);\n     }\n+\n+    trait = trait.toAnalyzed(result.analysis ?? null, result.diagnostics ?? null);\n   }\n \n   resolve(): void {\n@@ -372,19 +362,23 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n       for (let trait of record.traits) {\n         const handler = trait.handler;\n         switch (trait.state) {\n-          case TraitState.SKIPPED:\n-          case TraitState.ERRORED:\n+          case TraitState.Skipped:\n             continue;\n-          case TraitState.PENDING:\n+          case TraitState.Pending:\n             throw new Error(`Resolving a trait that hasn't been analyzed: ${clazz.name.text} / ${\n                 Object.getPrototypeOf(trait.handler).constructor.name}`);\n-          case TraitState.RESOLVED:\n+          case TraitState.Resolved:\n             throw new Error(`Resolving an already resolved trait`);\n         }\n \n+        if (trait.analysis === null) {\n+          // No analysis results, cannot further process this trait.\n+          continue;\n+        }\n+\n         if (handler.resolve === undefined) {\n           // No resolution of this trait needed - it's considered successful by default.\n-          trait = trait.toResolved(null);\n+          trait = trait.toResolved(null, null);\n           continue;\n         }\n \n@@ -393,22 +387,14 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n           result = handler.resolve(clazz, trait.analysis as Readonly<unknown>);\n         } catch (err) {\n           if (err instanceof FatalDiagnosticError) {\n-            trait = trait.toErrored([err.toDiagnostic()]);\n+            trait = trait.toResolved(null, [err.toDiagnostic()]);\n             continue;\n           } else {\n             throw err;\n           }\n         }\n \n-        if (result.diagnostics !== undefined && result.diagnostics.length > 0) {\n-          trait = trait.toErrored(result.diagnostics);\n-        } else {\n-          if (result.data !== undefined) {\n-            trait = trait.toResolved(result.data);\n-          } else {\n-            trait = trait.toResolved(null);\n-          }\n-        }\n+        trait = trait.toResolved(result.data ?? null, result.diagnostics ?? null);\n \n         if (result.reexports !== undefined) {\n           const fileName = clazz.getSourceFile().fileName;\n@@ -436,12 +422,14 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n     for (const clazz of this.fileToClasses.get(sf)!) {\n       const record = this.classes.get(clazz)!;\n       for (const trait of record.traits) {\n-        if (trait.state !== TraitState.RESOLVED) {\n+        if (trait.state !== TraitState.Resolved) {\n           continue;\n         } else if (trait.handler.typeCheck === undefined) {\n           continue;\n         }\n-        trait.handler.typeCheck(ctx, clazz, trait.analysis, trait.resolution);\n+        if (trait.resolution !== null) {\n+          trait.handler.typeCheck(ctx, clazz, trait.analysis, trait.resolution);\n+        }\n       }\n     }\n   }\n@@ -450,15 +438,17 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n     for (const clazz of this.classes.keys()) {\n       const record = this.classes.get(clazz)!;\n       for (const trait of record.traits) {\n-        if (trait.state !== TraitState.RESOLVED) {\n+        if (trait.state !== TraitState.Resolved) {\n           // Skip traits that haven't been resolved successfully.\n           continue;\n         } else if (trait.handler.index === undefined) {\n           // Skip traits that don't affect indexing.\n           continue;\n         }\n \n-        trait.handler.index(ctx, clazz, trait.analysis, trait.resolution);\n+        if (trait.resolution !== null) {\n+          trait.handler.index(ctx, clazz, trait.analysis, trait.resolution);\n+        }\n       }\n     }\n   }\n@@ -475,19 +465,26 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n     let res: CompileResult[] = [];\n \n     for (const trait of record.traits) {\n-      if (trait.state !== TraitState.RESOLVED) {\n+      if (trait.state !== TraitState.Resolved || trait.analysisDiagnostics !== null ||\n+          trait.resolveDiagnostics !== null) {\n+        // Cannot compile a trait that is not resolved, or had any errors in its declaration.\n         continue;\n       }\n \n       const compileSpan = this.perf.start('compileClass', original);\n \n+\n+      // `trait.resolution` is non-null asserted here because TypeScript does not recognize that\n+      // `Readonly<unknown>` is nullable (as `unknown` itself is nullable) due to the way that\n+      // `Readonly` works.\n+\n       let compileRes: CompileResult|CompileResult[];\n       if (this.compilationMode === CompilationMode.PARTIAL &&\n           trait.handler.compilePartial !== undefined) {\n-        compileRes = trait.handler.compilePartial(clazz, trait.analysis, trait.resolution);\n+        compileRes = trait.handler.compilePartial(clazz, trait.analysis, trait.resolution!);\n       } else {\n         compileRes =\n-            trait.handler.compileFull(clazz, trait.analysis, trait.resolution, constantPool);\n+            trait.handler.compileFull(clazz, trait.analysis, trait.resolution!, constantPool);\n       }\n \n       const compileMatchRes = compileRes;\n@@ -522,7 +519,7 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n     const decorators: ts.Decorator[] = [];\n \n     for (const trait of record.traits) {\n-      if (trait.state !== TraitState.RESOLVED) {\n+      if (trait.state !== TraitState.Resolved) {\n         continue;\n       }\n \n@@ -542,8 +539,12 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n         diagnostics.push(...record.metaDiagnostics);\n       }\n       for (const trait of record.traits) {\n-        if (trait.state === TraitState.ERRORED) {\n-          diagnostics.push(...trait.diagnostics);\n+        if ((trait.state === TraitState.Analyzed || trait.state === TraitState.Resolved) &&\n+            trait.analysisDiagnostics !== null) {\n+          diagnostics.push(...trait.analysisDiagnostics);\n+        }\n+        if (trait.state === TraitState.Resolved && trait.resolveDiagnostics !== null) {\n+          diagnostics.push(...trait.resolveDiagnostics);\n         }\n       }\n     }"
        },
        {
            "sha": "53cc026b15eab30e6317f53ee31e362dd59aa7b5",
            "filename": "packages/compiler-cli/src/ngtsc/transform/src/trait.ts",
            "status": "modified",
            "additions": 57,
            "deletions": 82,
            "changes": 139,
            "blob_url": "https://github.com/angular/angular/blob/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftrait.ts",
            "raw_url": "https://github.com/angular/angular/raw/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftrait.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftrait.ts?ref=6d429543272b9c840ba886e7ecd7d3b808325ac3",
            "patch": "@@ -13,28 +13,22 @@ export enum TraitState {\n   /**\n    * Pending traits are freshly created and have never been analyzed.\n    */\n-  PENDING = 0x01,\n+  Pending,\n \n   /**\n    * Analyzed traits have successfully been analyzed, but are pending resolution.\n    */\n-  ANALYZED = 0x02,\n+  Analyzed,\n \n   /**\n    * Resolved traits have successfully been analyzed and resolved and are ready for compilation.\n    */\n-  RESOLVED = 0x04,\n-\n-  /**\n-   * Errored traits have failed either analysis or resolution and as a result contain diagnostics\n-   * describing the failure(s).\n-   */\n-  ERRORED = 0x08,\n+  Resolved,\n \n   /**\n    * Skipped traits are no longer considered for compilation.\n    */\n-  SKIPPED = 0x10,\n+  Skipped,\n }\n \n /**\n@@ -50,8 +44,8 @@ export enum TraitState {\n  * This not only simplifies the implementation, but ensures traits are monomorphic objects as\n  * they're all just \"views\" in the type system of the same object (which never changes shape).\n  */\n-export type Trait<D, A, R> = PendingTrait<D, A, R>|SkippedTrait<D, A, R>|AnalyzedTrait<D, A, R>|\n-    ResolvedTrait<D, A, R>|ErroredTrait<D, A, R>;\n+export type Trait<D, A, R> =\n+    PendingTrait<D, A, R>|SkippedTrait<D, A, R>|AnalyzedTrait<D, A, R>|ResolvedTrait<D, A, R>;\n \n /**\n  * The value side of `Trait` exposes a helper to create a `Trait` in a pending state (by delegating\n@@ -93,19 +87,13 @@ export interface TraitBase<D, A, R> {\n  * Pending traits have yet to be analyzed in any way.\n  */\n export interface PendingTrait<D, A, R> extends TraitBase<D, A, R> {\n-  state: TraitState.PENDING;\n+  state: TraitState.Pending;\n \n   /**\n    * This pending trait has been successfully analyzed, and should transition to the \"analyzed\"\n    * state.\n    */\n-  toAnalyzed(analysis: A): AnalyzedTrait<D, A, R>;\n-\n-  /**\n-   * This trait failed analysis, and should transition to the \"errored\" state with the resulting\n-   * diagnostics.\n-   */\n-  toErrored(errors: ts.Diagnostic[]): ErroredTrait<D, A, R>;\n+  toAnalyzed(analysis: A|null, diagnostics: ts.Diagnostic[]|null): AnalyzedTrait<D, A, R>;\n \n   /**\n    * During analysis it was determined that this trait is not eligible for compilation after all,\n@@ -114,22 +102,6 @@ export interface PendingTrait<D, A, R> extends TraitBase<D, A, R> {\n   toSkipped(): SkippedTrait<D, A, R>;\n }\n \n-/**\n- * A trait in the \"errored\" state.\n- *\n- * Errored traits contain `ts.Diagnostic`s indicating any problem(s) with the class.\n- *\n- * This is a terminal state.\n- */\n-export interface ErroredTrait<D, A, R> extends TraitBase<D, A, R> {\n-  state: TraitState.ERRORED;\n-\n-  /**\n-   * Diagnostics which were produced while attempting to analyze the trait.\n-   */\n-  diagnostics: ts.Diagnostic[];\n-}\n-\n /**\n  * A trait in the \"skipped\" state.\n  *\n@@ -138,41 +110,33 @@ export interface ErroredTrait<D, A, R> extends TraitBase<D, A, R> {\n  * This is a terminal state.\n  */\n export interface SkippedTrait<D, A, R> extends TraitBase<D, A, R> {\n-  state: TraitState.SKIPPED;\n-}\n-\n-/**\n- * The part of the `Trait` interface for any trait which has been successfully analyzed.\n- *\n- * Mainly, this is used to share the comment on the `analysis` field.\n- */\n-export interface TraitWithAnalysis<A> {\n-  /**\n-   * The results returned by a successful analysis of the given class/`DecoratorHandler`\n-   * combination.\n-   */\n-  analysis: Readonly<A>;\n+  state: TraitState.Skipped;\n }\n \n /**\n  * A trait in the \"analyzed\" state.\n  *\n  * Analyzed traits have analysis results available, and are eligible for resolution.\n  */\n-export interface AnalyzedTrait<D, A, R> extends TraitBase<D, A, R>, TraitWithAnalysis<A> {\n-  state: TraitState.ANALYZED;\n+export interface AnalyzedTrait<D, A, R> extends TraitBase<D, A, R> {\n+  state: TraitState.Analyzed;\n \n   /**\n-   * This analyzed trait has been successfully resolved, and should be transitioned to the\n-   * \"resolved\" state.\n+   * Analysis results of the given trait (if able to be produced), or `null` if analysis failed\n+   * completely.\n    */\n-  toResolved(resolution: R): ResolvedTrait<D, A, R>;\n+  analysis: Readonly<A>|null;\n \n   /**\n-   * This trait failed resolution, and should transition to the \"errored\" state with the resulting\n-   * diagnostics.\n+   * Any diagnostics that resulted from analysis, or `null` if none.\n    */\n-  toErrored(errors: ts.Diagnostic[]): ErroredTrait<D, A, R>;\n+  analysisDiagnostics: ts.Diagnostic[]|null;\n+\n+  /**\n+   * This analyzed trait has been successfully resolved, and should be transitioned to the\n+   * \"resolved\" state.\n+   */\n+  toResolved(resolution: R|null, diagnostics: ts.Diagnostic[]|null): ResolvedTrait<D, A, R>;\n }\n \n /**\n@@ -183,63 +147,74 @@ export interface AnalyzedTrait<D, A, R> extends TraitBase<D, A, R>, TraitWithAna\n  *\n  * This is a terminal state.\n  */\n-export interface ResolvedTrait<D, A, R> extends TraitBase<D, A, R>, TraitWithAnalysis<A> {\n-  state: TraitState.RESOLVED;\n+export interface ResolvedTrait<D, A, R> extends TraitBase<D, A, R> {\n+  state: TraitState.Resolved;\n+\n+  /**\n+   * Resolved traits must have produced valid analysis results.\n+   */\n+  analysis: Readonly<A>;\n+\n+  /**\n+   * Analysis may have still resulted in diagnostics.\n+   */\n+  analysisDiagnostics: ts.Diagnostic[]|null;\n+\n+  /**\n+   * Diagnostics resulting from resolution are tracked separately from\n+   */\n+  resolveDiagnostics: ts.Diagnostic[]|null;\n \n   /**\n    * The results returned by a successful resolution of the given class/`DecoratorHandler`\n    * combination.\n    */\n-  resolution: Readonly<R>;\n+  resolution: Readonly<R>|null;\n }\n \n /**\n  * An implementation of the `Trait` type which transitions safely between the various\n  * `TraitState`s.\n  */\n class TraitImpl<D, A, R> {\n-  state: TraitState = TraitState.PENDING;\n+  state: TraitState = TraitState.Pending;\n   handler: DecoratorHandler<D, A, R>;\n   detected: DetectResult<D>;\n   analysis: Readonly<A>|null = null;\n   resolution: Readonly<R>|null = null;\n-  diagnostics: ts.Diagnostic[]|null = null;\n+  analysisDiagnostics: ts.Diagnostic[]|null = null;\n+  resolveDiagnostics: ts.Diagnostic[]|null = null;\n \n   constructor(handler: DecoratorHandler<D, A, R>, detected: DetectResult<D>) {\n     this.handler = handler;\n     this.detected = detected;\n   }\n \n-  toAnalyzed(analysis: A): AnalyzedTrait<D, A, R> {\n+  toAnalyzed(analysis: A|null, diagnostics: ts.Diagnostic[]|null): AnalyzedTrait<D, A, R> {\n     // Only pending traits can be analyzed.\n-    this.assertTransitionLegal(TraitState.PENDING, TraitState.ANALYZED);\n+    this.assertTransitionLegal(TraitState.Pending, TraitState.Analyzed);\n     this.analysis = analysis;\n-    this.state = TraitState.ANALYZED;\n+    this.analysisDiagnostics = diagnostics;\n+    this.state = TraitState.Analyzed;\n     return this as AnalyzedTrait<D, A, R>;\n   }\n \n-  toErrored(diagnostics: ts.Diagnostic[]): ErroredTrait<D, A, R> {\n-    // Pending traits (during analysis) or analyzed traits (during resolution) can produce\n-    // diagnostics and enter an errored state.\n-    this.assertTransitionLegal(TraitState.PENDING | TraitState.ANALYZED, TraitState.RESOLVED);\n-    this.diagnostics = diagnostics;\n-    this.analysis = null;\n-    this.state = TraitState.ERRORED;\n-    return this as ErroredTrait<D, A, R>;\n-  }\n-\n-  toResolved(resolution: R): ResolvedTrait<D, A, R> {\n+  toResolved(resolution: R|null, diagnostics: ts.Diagnostic[]|null): ResolvedTrait<D, A, R> {\n     // Only analyzed traits can be resolved.\n-    this.assertTransitionLegal(TraitState.ANALYZED, TraitState.RESOLVED);\n+    this.assertTransitionLegal(TraitState.Analyzed, TraitState.Resolved);\n+    if (this.analysis === null) {\n+      throw new Error(`Cannot transition an Analyzed trait with a null analysis to Resolved`);\n+    }\n     this.resolution = resolution;\n-    this.state = TraitState.RESOLVED;\n+    this.state = TraitState.Resolved;\n+    this.resolveDiagnostics = diagnostics;\n     return this as ResolvedTrait<D, A, R>;\n   }\n \n   toSkipped(): SkippedTrait<D, A, R> {\n     // Only pending traits can be skipped.\n-    this.assertTransitionLegal(TraitState.PENDING, TraitState.SKIPPED);\n-    this.state = TraitState.SKIPPED;\n+    this.assertTransitionLegal(TraitState.Pending, TraitState.Skipped);\n+    this.state = TraitState.Skipped;\n     return this as SkippedTrait<D, A, R>;\n   }\n \n@@ -252,7 +227,7 @@ class TraitImpl<D, A, R> {\n    * transitions to take place. Hence, this assertion provides a little extra runtime protection.\n    */\n   private assertTransitionLegal(allowedState: TraitState, transitionTo: TraitState): void {\n-    if (!(this.state & allowedState)) {\n+    if (!(this.state === allowedState)) {\n       throw new Error(`Assertion failure: cannot transition from ${TraitState[this.state]} to ${\n           TraitState[transitionTo]}.`);\n     }"
        },
        {
            "sha": "46bae12cc30f1fb0e41fe5cefaf9ce8f37e24cb9",
            "filename": "packages/compiler-cli/test/ngtsc/ngtsc_spec.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/angular/angular/blob/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6d429543272b9c840ba886e7ecd7d3b808325ac3/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts?ref=6d429543272b9c840ba886e7ecd7d3b808325ac3",
            "patch": "@@ -364,6 +364,30 @@ runInEachFileSystem(os => {\n       expect(jsContents).toContain('Hello World');\n     });\n \n+    it('should not report that broken components in modules are not components', () => {\n+      env.write('test.ts', `\n+        import {Component, NgModule} from '@angular/core';\n+\n+        @Component({\n+          selector: 'broken-cmp',\n+          template: '{{ broken = \"true\" }}', // assignment not legal in this context\n+        })\n+        export class BrokenCmp {}\n+\n+        @NgModule({\n+          declarations: [BrokenCmp],\n+        })\n+        export class Module {\n+          broken = \"false\";\n+        }\n+      `);\n+\n+      const diags = env.driveDiagnostics();\n+      if (diags.some(diag => diag.code === ngErrorCode(ErrorCode.NGMODULE_INVALID_DECLARATION))) {\n+        fail('Should not produce a diagnostic that BrokenCmp is not a component');\n+      }\n+    });\n+\n     // This test triggers the Tsickle compiler which asserts that the file-paths\n     // are valid for the real OS. When on non-Windows systems it doesn't like paths\n     // that start with `C:`."
        }
    ],
    "stats": {
        "total": 306,
        "additions": 165,
        "deletions": 141
    }
}