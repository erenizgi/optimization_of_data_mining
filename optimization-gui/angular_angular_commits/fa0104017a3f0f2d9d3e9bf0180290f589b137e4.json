{
    "author": "JoostK",
    "message": "refactor(compiler-cli): only use type constructors for directives with generic types (#38249)\n\nPrior to this change, the template type checker would always use a\ntype-constructor to instantiate a directive. This type-constructor call\nserves two purposes:\n\n1. Infer any generic types for the directive instance from the inputs\n   that are passed in.\n2. Type check the inputs that are passed into the directive's inputs.\n\nThe first purpose is only relevant when the directive actually has any\ngeneric types and using a type-constructor for these cases inhibits\na type-check performance penalty, as a type-constructor's signature is\nquite complex and needs to be generated for each directive.\n\nThis commit refactors the generated type-check blocks to only generate\na type-constructor call for directives that have generic types. Type\nchecking of inputs is achieved by generating individual statements for\nall inputs, using assignments into the directive's fields.\n\nEven if a type-constructor is used for type-inference of generic types\nwill the input checking also be achieved using the individual assignment\nstatements. This is done to support the rework of the language service,\nwhich will start to extract symbol information from the type-check\nblocks.\n\nAs a future optimization, it may be possible to reduce the number of\ninputs passed into a type-constructor to only those inputs that\ncontribute the the type-inference of the generics. As this is not a\nnecessity at the moment this is left as follow-up work.\n\nCloses #38185\n\nPR Close #38249",
    "sha": "fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
    "files": [
        {
            "sha": "5ea6aec53274e081e1506d47527b4584fbda1347",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -15,7 +15,7 @@ import {absoluteFrom, relative} from '../../file_system';\n import {DefaultImportRecorder, ModuleResolver, Reference, ReferenceEmitter} from '../../imports';\n import {DependencyTracker} from '../../incremental/api';\n import {IndexingContext} from '../../indexer';\n-import {DirectiveMeta, extractDirectiveGuards, InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\n+import {DirectiveMeta, DirectiveTypeCheckMeta, extractDirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\n import {flattenInheritedDirectiveMetadata} from '../../metadata/src/inheritance';\n import {EnumValue, PartialEvaluator} from '../../partial_evaluator';\n import {ClassDeclaration, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n@@ -51,7 +51,7 @@ export interface ComponentAnalysisData {\n    */\n   meta: Omit<R3ComponentMetadata, ComponentMetadataResolvedFields>;\n   baseClass: Reference<ClassDeclaration>|'dynamic'|null;\n-  guards: ReturnType<typeof extractDirectiveGuards>;\n+  typeCheckMeta: DirectiveTypeCheckMeta;\n   template: ParsedTemplateWithSource;\n   metadataStmt: Statement|null;\n \n@@ -327,7 +327,7 @@ export class ComponentDecoratorHandler implements\n           i18nUseExternalIds: this.i18nUseExternalIds,\n           relativeContextFilePath,\n         },\n-        guards: extractDirectiveGuards(node, this.reflector),\n+        typeCheckMeta: extractDirectiveTypeCheckMeta(node, metadata.inputs, this.reflector),\n         metadataStmt: generateSetClassMetadataCall(\n             node, this.reflector, this.defaultImportRecorder, this.isCore,\n             this.annotateForClosureCompiler),\n@@ -356,7 +356,7 @@ export class ComponentDecoratorHandler implements\n       queries: analysis.meta.queries.map(query => query.propertyName),\n       isComponent: true,\n       baseClass: analysis.baseClass,\n-      ...analysis.guards,\n+      ...analysis.typeCheckMeta,\n     });\n \n     this.injectableRegistry.registerInjectable(node);"
        },
        {
            "sha": "6bdd3398a76544a35553486f2f0c8a5b641e2bfc",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/directive.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -11,8 +11,8 @@ import * as ts from 'typescript';\n \n import {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\n import {DefaultImportRecorder, Reference} from '../../imports';\n-import {InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\n-import {extractDirectiveGuards} from '../../metadata/src/util';\n+import {DirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\n+import {extractDirectiveTypeCheckMeta} from '../../metadata/src/util';\n import {DynamicValue, EnumValue, PartialEvaluator} from '../../partial_evaluator';\n import {ClassDeclaration, ClassMember, ClassMemberKind, Decorator, filterToMembersWithDecorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n import {LocalModuleScopeRegistry} from '../../scope';\n@@ -35,7 +35,7 @@ const LIFECYCLE_HOOKS = new Set([\n \n export interface DirectiveHandlerData {\n   baseClass: Reference<ClassDeclaration>|'dynamic'|null;\n-  guards: ReturnType<typeof extractDirectiveGuards>;\n+  typeCheckMeta: DirectiveTypeCheckMeta;\n   meta: R3DirectiveMetadata;\n   metadataStmt: Statement|null;\n   providersRequiringFactory: Set<Reference<ClassDeclaration>>|null;\n@@ -102,7 +102,7 @@ export class DirectiveDecoratorHandler implements\n             node, this.reflector, this.defaultImportRecorder, this.isCore,\n             this.annotateForClosureCompiler),\n         baseClass: readBaseClass(node, this.reflector, this.evaluator),\n-        guards: extractDirectiveGuards(node, this.reflector),\n+        typeCheckMeta: extractDirectiveTypeCheckMeta(node, analysis.inputs, this.reflector),\n         providersRequiringFactory\n       }\n     };\n@@ -122,7 +122,7 @@ export class DirectiveDecoratorHandler implements\n       queries: analysis.meta.queries.map(query => query.propertyName),\n       isComponent: false,\n       baseClass: analysis.baseClass,\n-      ...analysis.guards,\n+      ...analysis.typeCheckMeta,\n     });\n \n     this.injectableRegistry.registerInjectable(node);"
        },
        {
            "sha": "ee3f910b1bb71ba44a9ca4937a9ced026bc5d7d3",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Findex.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -9,4 +9,4 @@\n export * from './src/api';\n export {DtsMetadataReader} from './src/dts';\n export {CompoundMetadataRegistry, LocalMetadataRegistry, InjectableClassRegistry} from './src/registry';\n-export {extractDirectiveGuards, CompoundMetadataReader} from './src/util';\n+export {extractDirectiveTypeCheckMeta, CompoundMetadataReader} from './src/util';"
        },
        {
            "sha": "a9d58de7c710821f712d69de42456cb53494b7d7",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/src/api.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 4,
            "changes": 44,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fapi.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -32,19 +32,55 @@ export interface NgModuleMeta {\n   rawDeclarations: ts.Expression|null;\n }\n \n+/**\n+ * Typing metadata collected for a directive within an NgModule's scope.\n+ */\n+export interface DirectiveTypeCheckMeta {\n+  /**\n+   * List of static `ngTemplateGuard_xx` members found on the Directive's class.\n+   * @see `TemplateGuardMeta`\n+   */\n+  ngTemplateGuards: TemplateGuardMeta[];\n+\n+  /**\n+   * Whether the Directive's class has a static ngTemplateContextGuard function.\n+   */\n+  hasNgTemplateContextGuard: boolean;\n+\n+  /**\n+   * The set of input fields which have a corresponding static `ngAcceptInputType_` on the\n+   * Directive's class. This allows inputs to accept a wider range of types and coerce the input to\n+   * a narrower type with a getter/setter. See https://angular.io/guide/template-typecheck.\n+   */\n+  coercedInputFields: Set<string>;\n+\n+  /**\n+   * The set of input fields which map to `readonly`, `private`, or `protected` members in the\n+   * Directive's class.\n+   */\n+  restrictedInputFields: Set<string>;\n+\n+  /**\n+   * The set of input fields which do not have corresponding members in the Directive's class.\n+   */\n+  undeclaredInputFields: Set<string>;\n+\n+  /**\n+   * Whether the Directive's class is generic, i.e. `class MyDir<T> {...}`.\n+   */\n+  isGeneric: boolean;\n+}\n+\n /**\n  * Metadata collected for a directive within an NgModule's scope.\n  */\n-export interface DirectiveMeta extends T2DirectiveMeta {\n+export interface DirectiveMeta extends T2DirectiveMeta, DirectiveTypeCheckMeta {\n   ref: Reference<ClassDeclaration>;\n   /**\n    * Unparsed selector of the directive, or null if the directive does not have a selector.\n    */\n   selector: string|null;\n   queries: string[];\n-  ngTemplateGuards: TemplateGuardMeta[];\n-  hasNgTemplateContextGuard: boolean;\n-  coercedInputFields: Set<string>;\n \n   /**\n    * A `Reference` to the base class for the directive, if one was detected."
        },
        {
            "sha": "faf588ab67d4fbdb26f1d4bcfa4c95bf02ddf092",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/src/dts.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fdts.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fdts.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Fdts.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -12,7 +12,7 @@ import {Reference} from '../../imports';\n import {ClassDeclaration, isNamedClassDeclaration, ReflectionHost} from '../../reflection';\n \n import {DirectiveMeta, MetadataReader, NgModuleMeta, PipeMeta} from './api';\n-import {extractDirectiveGuards, extractReferencesFromType, readStringArrayType, readStringMapType, readStringType} from './util';\n+import {extractDirectiveTypeCheckMeta, extractReferencesFromType, readStringArrayType, readStringMapType, readStringType} from './util';\n \n /**\n  * A `MetadataReader` that can read metadata from `.d.ts` files, which have static Ivy properties\n@@ -76,16 +76,17 @@ export class DtsMetadataReader implements MetadataReader {\n       return null;\n     }\n \n+    const inputs = readStringMapType(def.type.typeArguments[3]);\n     return {\n       ref,\n       name: clazz.name.text,\n       isComponent: def.name === 'Éµcmp',\n       selector: readStringType(def.type.typeArguments[1]),\n       exportAs: readStringArrayType(def.type.typeArguments[2]),\n-      inputs: readStringMapType(def.type.typeArguments[3]),\n+      inputs,\n       outputs: readStringMapType(def.type.typeArguments[4]),\n       queries: readStringArrayType(def.type.typeArguments[5]),\n-      ...extractDirectiveGuards(clazz, this.reflector),\n+      ...extractDirectiveTypeCheckMeta(clazz, inputs, this.reflector),\n       baseClass: readBaseClass(clazz, this.checker, this.reflector),\n     };\n   }"
        },
        {
            "sha": "ba775783e14a974c6303b176ce6cc5f8fde483a1",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/src/inheritance.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Finheritance.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Finheritance.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Finheritance.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -28,6 +28,8 @@ export function flattenInheritedDirectiveMetadata(\n   let inputs: {[key: string]: string|[string, string]} = {};\n   let outputs: {[key: string]: string} = {};\n   let coercedInputFields = new Set<string>();\n+  let undeclaredInputFields = new Set<string>();\n+  let restrictedInputFields = new Set<string>();\n   let isDynamic = false;\n \n   const addMetadata = (meta: DirectiveMeta): void => {\n@@ -48,6 +50,12 @@ export function flattenInheritedDirectiveMetadata(\n     for (const coercedInputField of meta.coercedInputFields) {\n       coercedInputFields.add(coercedInputField);\n     }\n+    for (const undeclaredInputField of meta.undeclaredInputFields) {\n+      undeclaredInputFields.add(undeclaredInputField);\n+    }\n+    for (const restrictedInputField of meta.restrictedInputFields) {\n+      restrictedInputFields.add(restrictedInputField);\n+    }\n   };\n \n   addMetadata(topMeta);\n@@ -57,6 +65,8 @@ export function flattenInheritedDirectiveMetadata(\n     inputs,\n     outputs,\n     coercedInputFields,\n+    undeclaredInputFields,\n+    restrictedInputFields,\n     baseClass: isDynamic ? 'dynamic' : null,\n   };\n }"
        },
        {
            "sha": "4cf0e5eabd64c3b49229599208b7633c7106a2d2",
            "filename": "packages/compiler-cli/src/ngtsc/metadata/src/util.ts",
            "status": "modified",
            "additions": 45,
            "deletions": 9,
            "changes": 54,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fmetadata%2Fsrc%2Futil.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -12,7 +12,7 @@ import {Reference} from '../../imports';\n import {ClassDeclaration, ClassMember, ClassMemberKind, isNamedClassDeclaration, ReflectionHost, reflectTypeEntityToDeclaration} from '../../reflection';\n import {nodeDebugInfo} from '../../util/src/typescript';\n \n-import {DirectiveMeta, MetadataReader, NgModuleMeta, PipeMeta, TemplateGuardMeta} from './api';\n+import {DirectiveMeta, DirectiveTypeCheckMeta, MetadataReader, NgModuleMeta, PipeMeta, TemplateGuardMeta} from './api';\n \n export function extractReferencesFromType(\n     checker: ts.TypeChecker, def: ts.TypeNode, ngModuleImportedFrom: string|null,\n@@ -78,13 +78,16 @@ export function readStringArrayType(type: ts.TypeNode): string[] {\n   return res;\n }\n \n-\n-export function extractDirectiveGuards(node: ClassDeclaration, reflector: ReflectionHost): {\n-  ngTemplateGuards: TemplateGuardMeta[],\n-  hasNgTemplateContextGuard: boolean,\n-  coercedInputFields: Set<string>,\n-} {\n-  const staticMembers = reflector.getMembersOfClass(node).filter(member => member.isStatic);\n+/**\n+ * Inspects the class' members and extracts the metadata that is used when type-checking templates\n+ * that use the directive. This metadata does not contain information from a base class, if any,\n+ * making this metadata invariant to changes of inherited classes.\n+ */\n+export function extractDirectiveTypeCheckMeta(\n+    node: ClassDeclaration, inputs: {[fieldName: string]: string|[string, string]},\n+    reflector: ReflectionHost): DirectiveTypeCheckMeta {\n+  const members = reflector.getMembersOfClass(node);\n+  const staticMembers = members.filter(member => member.isStatic);\n   const ngTemplateGuards = staticMembers.map(extractTemplateGuard)\n                                .filter((guard): guard is TemplateGuardMeta => guard !== null);\n   const hasNgTemplateContextGuard = staticMembers.some(\n@@ -93,7 +96,40 @@ export function extractDirectiveGuards(node: ClassDeclaration, reflector: Reflec\n   const coercedInputFields =\n       new Set(staticMembers.map(extractCoercedInput)\n                   .filter((inputName): inputName is string => inputName !== null));\n-  return {hasNgTemplateContextGuard, ngTemplateGuards, coercedInputFields};\n+\n+  const restrictedInputFields = new Set<string>();\n+  const undeclaredInputFields = new Set<string>();\n+\n+  for (const fieldName of Object.keys(inputs)) {\n+    const field = members.find(member => member.name === fieldName);\n+    if (field === undefined || field.node === null) {\n+      undeclaredInputFields.add(fieldName);\n+    } else if (isRestricted(field.node)) {\n+      restrictedInputFields.add(fieldName);\n+    }\n+  }\n+\n+  const arity = reflector.getGenericArityOfClass(node);\n+\n+  return {\n+    hasNgTemplateContextGuard,\n+    ngTemplateGuards,\n+    coercedInputFields,\n+    restrictedInputFields,\n+    undeclaredInputFields,\n+    isGeneric: arity !== null && arity > 0,\n+  };\n+}\n+\n+function isRestricted(node: ts.Node): boolean {\n+  if (node.modifiers === undefined) {\n+    return false;\n+  }\n+\n+  return node.modifiers.some(\n+      modifier => modifier.kind === ts.SyntaxKind.PrivateKeyword ||\n+          modifier.kind === ts.SyntaxKind.ProtectedKeyword ||\n+          modifier.kind === ts.SyntaxKind.ReadonlyKeyword);\n }\n \n function extractTemplateGuard(member: ClassMember): TemplateGuardMeta|null {"
        },
        {
            "sha": "60302988a1a423920e8ad6678d0030ed5177657c",
            "filename": "packages/compiler-cli/src/ngtsc/scope/test/local_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Ftest%2Flocal_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Ftest%2Flocal_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fscope%2Ftest%2Flocal_spec.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -243,6 +243,9 @@ function fakeDirective(ref: Reference<ClassDeclaration>): DirectiveMeta {\n     hasNgTemplateContextGuard: false,\n     ngTemplateGuards: [],\n     coercedInputFields: new Set<string>(),\n+    restrictedInputFields: new Set<string>(),\n+    undeclaredInputFields: new Set<string>(),\n+    isGeneric: false,\n     baseClass: null,\n   };\n }"
        },
        {
            "sha": "f0e241144a2d2aa241777826ce1b089ce2b098e6",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/api.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 5,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fapi.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -11,20 +11,17 @@ import * as ts from 'typescript';\n \n import {AbsoluteFsPath} from '../../file_system';\n import {Reference} from '../../imports';\n-import {TemplateGuardMeta} from '../../metadata';\n+import {DirectiveTypeCheckMeta} from '../../metadata';\n import {ClassDeclaration} from '../../reflection';\n \n \n /**\n  * Extension of `DirectiveMeta` that includes additional information required to type-check the\n  * usage of a particular directive.\n  */\n-export interface TypeCheckableDirectiveMeta extends DirectiveMeta {\n+export interface TypeCheckableDirectiveMeta extends DirectiveMeta, DirectiveTypeCheckMeta {\n   ref: Reference<ClassDeclaration>;\n   queries: string[];\n-  ngTemplateGuards: TemplateGuardMeta[];\n-  coercedInputFields: Set<string>;\n-  hasNgTemplateContextGuard: boolean;\n }\n \n export type TemplateId = string&{__brand: 'TemplateId'};"
        },
        {
            "sha": "748ee71d7478d7a2addf03a617338df498662c69",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/context.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -199,12 +199,12 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n     for (const dir of boundTarget.getUsedDirectives()) {\n       const dirRef = dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n       const dirNode = dirRef.node;\n-      if (requiresInlineTypeCtor(dirNode, this.reflector)) {\n+\n+      if (dir.isGeneric && requiresInlineTypeCtor(dirNode, this.reflector)) {\n         if (this.inlining === InliningMode.Error) {\n           missingInlines.push(dirNode);\n           continue;\n         }\n-\n         // Add a type constructor operation for the directive.\n         this.addInlineTypeCtor(fileData, dirNode.getSourceFile(), dirRef, {\n           fnName: 'ngTypeCtor',"
        },
        {
            "sha": "96ff8178a43f47721c955ad0005c869cbd74c208",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/ts_util.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fts_util.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fts_util.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fts_util.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -86,6 +86,21 @@ export function tsDeclareVariable(id: ts.Identifier, type: ts.TypeNode): ts.Vari\n       /* declarationList */[decl]);\n }\n \n+/**\n+ * Creates a `ts.TypeQueryNode` for a coerced input.\n+ *\n+ * For example: `typeof MatInput.ngAcceptInputType_value`, where MatInput is `typeName` and `value`\n+ * is the `coercedInputName`.\n+ *\n+ * @param typeName The `EntityName` of the Directive where the static coerced input is defined.\n+ * @param coercedInputName The field name of the coerced input.\n+ */\n+export function tsCreateTypeQueryForCoercedInput(\n+    typeName: ts.EntityName, coercedInputName: string): ts.TypeQueryNode {\n+  return ts.createTypeQueryNode(\n+      ts.createQualifiedName(typeName, `ngAcceptInputType_${coercedInputName}`));\n+}\n+\n /**\n  * Create a `ts.VariableStatement` that initializes a variable with a given expression.\n  *"
        },
        {
            "sha": "d2d56de68c2a46603ede7b49607e02c82c4a41fe",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 265,
            "deletions": 82,
            "changes": 347,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -19,7 +19,7 @@ import {Environment} from './environment';\n import {astToTypescript, NULL_AS_ANY} from './expression';\n import {OutOfBandDiagnosticRecorder} from './oob';\n import {ExpressionSemanticVisitor} from './template_semantics';\n-import {checkIfClassIsExported, checkIfGenericTypesAreUnbound, tsCallMethod, tsCastToAny, tsCreateElement, tsCreateVariable, tsDeclareVariable} from './ts_util';\n+import {checkIfClassIsExported, checkIfGenericTypesAreUnbound, tsCallMethod, tsCastToAny, tsCreateElement, tsCreateTypeQueryForCoercedInput, tsCreateVariable, tsDeclareVariable} from './ts_util';\n \n \n \n@@ -197,6 +197,7 @@ class TcbTemplateBodyOp extends TcbOp {\n   constructor(private tcb: Context, private scope: Scope, private template: TmplAstTemplate) {\n     super();\n   }\n+\n   execute(): null {\n     // An `if` will be constructed, within which the template's children will be type checked. The\n     // `if` is used for two reasons: it creates a new syntactic scope, isolating variables declared\n@@ -308,13 +309,15 @@ class TcbTextInterpolationOp extends TcbOp {\n }\n \n /**\n- * A `TcbOp` which constructs an instance of a directive with types inferred from its inputs, which\n- * also checks the bindings to the directive in the process.\n+ * A `TcbOp` which constructs an instance of a directive _without_ setting any of its inputs. Inputs\n+ * are later set in the `TcbDirectiveInputsOp`. Type checking was found to be faster when done in\n+ * this way as opposed to `TcbDirectiveCtorOp` which is only necessary when the directive is\n+ * generic.\n  *\n  * Executing this operation returns a reference to the directive instance variable with its inferred\n  * type.\n  */\n-class TcbDirectiveOp extends TcbOp {\n+class TcbDirectiveTypeOp extends TcbOp {\n   constructor(\n       private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n       private dir: TypeCheckableDirectiveMeta) {\n@@ -323,37 +326,190 @@ class TcbDirectiveOp extends TcbOp {\n \n   execute(): ts.Identifier {\n     const id = this.tcb.allocateId();\n-    // Process the directive and construct expressions for each of its bindings.\n-    const inputs = tcbGetDirectiveInputs(this.node, this.dir, this.tcb, this.scope);\n+\n+    const type = this.tcb.env.referenceType(this.dir.ref);\n+    this.scope.addStatement(tsDeclareVariable(id, type));\n+    return id;\n+  }\n+}\n+\n+/**\n+ * A `TcbOp` which constructs an instance of a directive with types inferred from its inputs. The\n+ * inputs themselves are not checked here; checking of inputs is achieved in `TcbDirectiveInputsOp`.\n+ * Any errors reported in this statement are ignored, as the type constructor call is only present\n+ * for type-inference.\n+ *\n+ * When a Directive is generic, it is required that the TCB generates the instance using this method\n+ * in order to infer the type information correctly.\n+ *\n+ * Executing this operation returns a reference to the directive instance variable with its inferred\n+ * type.\n+ */\n+class TcbDirectiveCtorOp extends TcbOp {\n+  constructor(\n+      private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n+      private dir: TypeCheckableDirectiveMeta) {\n+    super();\n+  }\n+\n+  execute(): ts.Identifier {\n+    const id = this.tcb.allocateId();\n+\n+    const genericInputs = new Map<string, TcbDirectiveInput>();\n+\n+    const inputs = getBoundInputs(this.dir, this.node, this.tcb);\n+    for (const input of inputs) {\n+      for (const fieldName of input.fieldNames) {\n+        // Skip the field if an attribute has already been bound to it; we can't have a duplicate\n+        // key in the type constructor call.\n+        if (genericInputs.has(fieldName)) {\n+          continue;\n+        }\n+\n+        const expression = translateInput(input.attribute, this.tcb, this.scope);\n+        genericInputs.set(fieldName, {\n+          type: 'binding',\n+          field: fieldName,\n+          expression,\n+          sourceSpan: input.attribute.sourceSpan\n+        });\n+      }\n+    }\n+\n+    // Add unset directive inputs for each of the remaining unset fields.\n+    for (const fieldName of Object.keys(this.dir.inputs)) {\n+      if (!genericInputs.has(fieldName)) {\n+        genericInputs.set(fieldName, {type: 'unset', field: fieldName});\n+      }\n+    }\n \n     // Call the type constructor of the directive to infer a type, and assign the directive\n     // instance.\n-    const typeCtor = tcbCallTypeCtor(this.dir, this.tcb, inputs);\n-    addParseSpanInfo(typeCtor, this.node.sourceSpan);\n+    const typeCtor = tcbCallTypeCtor(this.dir, this.tcb, Array.from(genericInputs.values()));\n+    ignoreDiagnostics(typeCtor);\n     this.scope.addStatement(tsCreateVariable(id, typeCtor));\n     return id;\n   }\n \n   circularFallback(): TcbOp {\n-    return new TcbDirectiveCircularFallbackOp(this.tcb, this.scope, this.node, this.dir);\n+    return new TcbDirectiveCtorCircularFallbackOp(this.tcb, this.scope, this.node, this.dir);\n+  }\n+}\n+\n+/**\n+ * A `TcbOp` which generates code to check input bindings on an element that correspond with the\n+ * members of a directive.\n+ *\n+ * Executing this operation returns nothing.\n+ */\n+class TcbDirectiveInputsOp extends TcbOp {\n+  constructor(\n+      private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n+      private dir: TypeCheckableDirectiveMeta) {\n+    super();\n+  }\n+\n+  execute(): null {\n+    const dirId = this.scope.resolve(this.node, this.dir);\n+\n+    // TODO(joost): report duplicate properties\n+\n+    const inputs = getBoundInputs(this.dir, this.node, this.tcb);\n+    for (const input of inputs) {\n+      // For bound inputs, the property is assigned the binding expression.\n+      let expr = translateInput(input.attribute, this.tcb, this.scope);\n+      if (!this.tcb.env.config.checkTypeOfInputBindings) {\n+        // If checking the type of bindings is disabled, cast the resulting expression to 'any'\n+        // before the assignment.\n+        expr = tsCastToAny(expr);\n+      } else if (!this.tcb.env.config.strictNullInputBindings) {\n+        // If strict null checks are disabled, erase `null` and `undefined` from the type by\n+        // wrapping the expression in a non-null assertion.\n+        expr = ts.createNonNullExpression(expr);\n+      }\n+\n+      let assignment: ts.Expression = wrapForDiagnostics(expr);\n+\n+      for (const fieldName of input.fieldNames) {\n+        let target: ts.LeftHandSideExpression;\n+        if (this.dir.coercedInputFields.has(fieldName)) {\n+          // The input has a coercion declaration which should be used instead of assigning the\n+          // expression into the input field directly. To achieve this, a variable is declared\n+          // with a type of `typeof Directive.ngAcceptInputType_fieldName` which is then used as\n+          // target of the assignment.\n+          const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n+          if (!ts.isTypeReferenceNode(dirTypeRef)) {\n+            throw new Error(\n+                `Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);\n+          }\n+\n+          const id = this.tcb.allocateId();\n+          const type = tsCreateTypeQueryForCoercedInput(dirTypeRef.typeName, fieldName);\n+          this.scope.addStatement(tsDeclareVariable(id, type));\n+\n+          target = id;\n+        } else if (this.dir.undeclaredInputFields.has(fieldName)) {\n+          // If no coercion declaration is present nor is the field declared (i.e. the input is\n+          // declared in a `@Directive` or `@Component` decorator's `inputs` property) there is no\n+          // assignment target available, so this field is skipped.\n+          continue;\n+        } else if (this.dir.restrictedInputFields.has(fieldName)) {\n+          // To ignore errors, assign to temp variable with type of the field\n+          const id = this.tcb.allocateId();\n+          const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n+          if (!ts.isTypeReferenceNode(dirTypeRef)) {\n+            throw new Error(\n+                `Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);\n+          }\n+          const type = ts.createIndexedAccessTypeNode(\n+              ts.createTypeQueryNode(dirId as ts.Identifier),\n+              ts.createLiteralTypeNode(ts.createStringLiteral(fieldName)));\n+          const temp = tsCreateVariable(id, ts.createNonNullExpression(ts.createNull()), type);\n+          addParseSpanInfo(temp, input.attribute.sourceSpan);\n+          this.scope.addStatement(temp);\n+          target = id;\n+\n+          // TODO: To get errors assign directly to the fields on the instance, using dot access\n+          // when possible\n+\n+        } else {\n+          // Otherwise, a declaration exists in which case the `dir[\"fieldName\"]` syntax is used\n+          // as assignment target. An element access is used instead of a property access to\n+          // support input names that are not valid JavaScript identifiers. Additionally, using\n+          // element access syntax does not produce\n+          // TS2341 \"Property $prop is private and only accessible within class $class.\" nor\n+          // TS2445 \"Property $prop is protected and only accessible within class $class and its\n+          //         subclasses.\"\n+          target = ts.createElementAccess(dirId, ts.createStringLiteral(fieldName));\n+        }\n+\n+        // Finally the assignment is extended by assigning it into the target expression.\n+        assignment = ts.createBinary(target, ts.SyntaxKind.EqualsToken, assignment);\n+      }\n+\n+      addParseSpanInfo(assignment, input.attribute.sourceSpan);\n+      this.scope.addStatement(ts.createExpressionStatement(assignment));\n+    }\n+\n+    return null;\n   }\n }\n \n /**\n  * A `TcbOp` which is used to generate a fallback expression if the inference of a directive type\n- * via `TcbDirectiveOp` requires a reference to its own type. This can happen using a template\n+ * via `TcbDirectiveCtorOp` requires a reference to its own type. This can happen using a template\n  * reference:\n  *\n  * ```html\n  * <some-cmp #ref [prop]=\"ref.foo\"></some-cmp>\n  * ```\n  *\n- * In this case, `TcbDirectiveCircularFallbackOp` will add a second inference of the directive type\n- * to the type-check block, this time calling the directive's type constructor without any input\n- * expressions. This infers the widest possible supertype for the directive, which is used to\n+ * In this case, `TcbDirectiveCtorCircularFallbackOp` will add a second inference of the directive\n+ * type to the type-check block, this time calling the directive's type constructor without any\n+ * input expressions. This infers the widest possible supertype for the directive, which is used to\n  * resolve any recursive references required to infer the real type.\n  */\n-class TcbDirectiveCircularFallbackOp extends TcbOp {\n+class TcbDirectiveCtorCircularFallbackOp extends TcbOp {\n   constructor(\n       private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n       private dir: TypeCheckableDirectiveMeta) {\n@@ -694,8 +850,8 @@ class Scope {\n    */\n   private elementOpMap = new Map<TmplAstElement, number>();\n   /**\n-   * A map of maps which tracks the index of `TcbDirectiveOp`s in the `opQueue` for each directive\n-   * on a `TmplAstElement` or `TmplAstTemplate` node.\n+   * A map of maps which tracks the index of `TcbDirectiveCtorOp`s in the `opQueue` for each\n+   * directive on a `TmplAstElement` or `TmplAstTemplate` node.\n    */\n   private directiveOpMap =\n       new Map<TmplAstElement|TmplAstTemplate, Map<TypeCheckableDirectiveMeta, number>>();\n@@ -957,8 +1113,12 @@ class Scope {\n \n     const dirMap = new Map<TypeCheckableDirectiveMeta, number>();\n     for (const dir of directives) {\n-      const dirIndex = this.opQueue.push(new TcbDirectiveOp(this.tcb, this, node, dir)) - 1;\n+      const directiveOp = dir.isGeneric ? new TcbDirectiveCtorOp(this.tcb, this, node, dir) :\n+                                          new TcbDirectiveTypeOp(this.tcb, this, node, dir);\n+      const dirIndex = this.opQueue.push(directiveOp) - 1;\n       dirMap.set(dir, dirIndex);\n+\n+      this.opQueue.push(new TcbDirectiveInputsOp(this.tcb, this, node, dir));\n     }\n     this.directiveOpMap.set(node, dirMap);\n \n@@ -1016,6 +1176,11 @@ class Scope {\n   }\n }\n \n+interface TcbBoundInput {\n+  attribute: TmplAstBoundAttribute|TmplAstTextAttribute;\n+  fieldNames: string[];\n+}\n+\n /**\n  * Create the `ctx` parameter to the top-level TCB function.\n  *\n@@ -1269,53 +1434,13 @@ function tcbCallTypeCtor(\n       /* argumentsArray */[ts.createObjectLiteral(members)]);\n }\n \n-type TcbDirectiveInput = {\n-  type: 'binding'; field: string; expression: ts.Expression; sourceSpan: ParseSourceSpan;\n-}|{\n-  type: 'unset';\n-  field: string;\n-};\n+function getBoundInputs(\n+    directive: TypeCheckableDirectiveMeta, node: TmplAstTemplate|TmplAstElement,\n+    tcb: Context): TcbBoundInput[] {\n+  const boundInputs: TcbBoundInput[] = [];\n \n-function tcbGetDirectiveInputs(\n-    el: TmplAstElement|TmplAstTemplate, dir: TypeCheckableDirectiveMeta, tcb: Context,\n-    scope: Scope): TcbDirectiveInput[] {\n-  // Only the first binding to a property is written.\n-  // TODO(alxhub): produce an error for duplicate bindings to the same property, independently of\n-  // this logic.\n-  const directiveInputs = new Map<string, TcbDirectiveInput>();\n-  // `dir.inputs` is an object map of field names on the directive class to property names.\n-  // This is backwards from what's needed to match bindings - a map of properties to field names\n-  // is desired. Invert `dir.inputs` into `propMatch` to create this map.\n-  const propMatch = new Map<string, string>();\n-  const inputs = dir.inputs;\n-  Object.keys(inputs).forEach(key => {\n-    Array.isArray(inputs[key]) ? propMatch.set(inputs[key][0], key) :\n-                                 propMatch.set(inputs[key] as string, key);\n-  });\n-\n-  el.inputs.forEach(processAttribute);\n-  el.attributes.forEach(processAttribute);\n-  if (el instanceof TmplAstTemplate) {\n-    el.templateAttrs.forEach(processAttribute);\n-  }\n-\n-  // Add unset directive inputs for each of the remaining unset fields.\n-  // Note: it's actually important here that `propMatch.values()` isn't used, as there can be\n-  // multiple fields which share the same property name and only one of them will be listed as a\n-  // value in `propMatch`.\n-  for (const field of Object.keys(inputs)) {\n-    if (!directiveInputs.has(field)) {\n-      directiveInputs.set(field, {type: 'unset', field});\n-    }\n-  }\n-\n-  return Array.from(directiveInputs.values());\n-\n-  /**\n-   * Add a binding expression to the map for each input/template attribute of the directive that has\n-   * a matching binding.\n-   */\n-  function processAttribute(attr: TmplAstBoundAttribute|TmplAstTextAttribute): void {\n+  const propertyToFieldNames = invertInputs(directive.inputs);\n+  const processAttribute = (attr: TmplAstBoundAttribute|TmplAstTextAttribute) => {\n     // Skip non-property bindings.\n     if (attr instanceof TmplAstBoundAttribute && attr.type !== BindingType.Property) {\n       return;\n@@ -1327,34 +1452,92 @@ function tcbGetDirectiveInputs(\n     }\n \n     // Skip the attribute if the directive does not have an input for it.\n-    if (!propMatch.has(attr.name)) {\n+    if (!propertyToFieldNames.has(attr.name)) {\n       return;\n     }\n-    const field = propMatch.get(attr.name)!;\n+    const fieldNames = propertyToFieldNames.get(attr.name)!;\n+    boundInputs.push({attribute: attr, fieldNames});\n+  };\n+\n+  node.inputs.forEach(processAttribute);\n+  node.attributes.forEach(processAttribute);\n+  if (node instanceof TmplAstTemplate) {\n+    node.templateAttrs.forEach(processAttribute);\n+  }\n \n-    // Skip the attribute if a previous binding also wrote to it.\n-    if (directiveInputs.has(field)) {\n-      return;\n-    }\n+  return boundInputs;\n+}\n+\n+/**\n+ * Translates the given attribute binding to a `ts.Expression`.\n+ */\n+function translateInput(\n+    attr: TmplAstBoundAttribute|TmplAstTextAttribute, tcb: Context, scope: Scope): ts.Expression {\n+  if (attr instanceof TmplAstBoundAttribute) {\n+    // Produce an expression representing the value of the binding.\n+    return tcbExpression(attr.value, tcb, scope);\n+  } else {\n+    // For regular attributes with a static string value, use the represented string literal.\n+    return ts.createStringLiteral(attr.value);\n+  }\n+}\n \n-    let expr: ts.Expression;\n-    if (attr instanceof TmplAstBoundAttribute) {\n-      // Produce an expression representing the value of the binding.\n-      expr = tcbExpression(attr.value, tcb, scope);\n+/**\n+ * Inverts the input-mapping from field-to-property name into property-to-field name, to be able\n+ * to match a property in a template with the corresponding field on a directive.\n+ */\n+function invertInputs(inputs: {[fieldName: string]: string|[string, string]}):\n+    Map<string, string[]> {\n+  const propertyToFieldNames = new Map<string, string[]>();\n+  for (const fieldName of Object.keys(inputs)) {\n+    const propertyNames = inputs[fieldName];\n+    const propertyName = Array.isArray(propertyNames) ? propertyNames[0] : propertyNames;\n+\n+    if (propertyToFieldNames.has(propertyName)) {\n+      propertyToFieldNames.get(propertyName)!.push(fieldName);\n     } else {\n-      // For regular attributes with a static string value, use the represented string literal.\n-      expr = ts.createStringLiteral(attr.value);\n+      propertyToFieldNames.set(propertyName, [fieldName]);\n     }\n-\n-    directiveInputs.set(field, {\n-      type: 'binding',\n-      field: field,\n-      expression: expr,\n-      sourceSpan: attr.sourceSpan,\n-    });\n   }\n+  return propertyToFieldNames;\n }\n \n+/**\n+ * An input binding that corresponds with a field of a directive.\n+ */\n+interface TcbDirectiveBoundInput {\n+  type: 'binding';\n+\n+  /**\n+   * The name of a field on the directive that is set.\n+   */\n+  field: string;\n+\n+  /**\n+   * The `ts.Expression` corresponding with the input binding expression.\n+   */\n+  expression: ts.Expression;\n+\n+  /**\n+   * The source span of the full attribute binding.\n+   */\n+  sourceSpan: ParseSourceSpan;\n+}\n+\n+/**\n+ * Indicates that a certain field of a directive does not have a corresponding input binding.\n+ */\n+interface TcbDirectiveUnsetInput {\n+  type: 'unset';\n+\n+  /**\n+   * The name of a field on the directive for which no input binding is present.\n+   */\n+  field: string;\n+}\n+\n+type TcbDirectiveInput = TcbDirectiveBoundInput|TcbDirectiveUnsetInput;\n+\n const EVENT_PARAMETER = '$event';\n \n const enum EventParamType {"
        },
        {
            "sha": "8cb2114ddffc345dddd058faba017d5daf8e314c",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_constructor.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_constructor.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_constructor.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_constructor.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -11,6 +11,7 @@ import * as ts from 'typescript';\n import {ClassDeclaration, ReflectionHost} from '../../reflection';\n import {TypeCtorMetadata} from '../api';\n \n+import {tsCreateTypeQueryForCoercedInput} from './ts_util';\n import {TypeParameterEmitter} from './type_parameter_emitter';\n \n export function generateTypeCtorDeclarationFn(\n@@ -150,9 +151,7 @@ function constructTypeCtorParameter(\n           /* modifiers */ undefined,\n           /* name */ key,\n           /* questionToken */ undefined,\n-          /* type */\n-          ts.createTypeQueryNode(\n-              ts.createQualifiedName(rawType.typeName, `ngAcceptInputType_${key}`)),\n+          /* type */ tsCreateTypeQueryForCoercedInput(rawType.typeName, key),\n           /* initializer */ undefined));\n     }\n   }"
        },
        {
            "sha": "2c278a3d6839702555a77089c3496b477e9fe294",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/diagnostics_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fdiagnostics_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fdiagnostics_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Fdiagnostics_spec.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -227,7 +227,8 @@ runInEachFileSystem(() => {\n             name: 'GuardDir',\n             selector: '[guard]',\n             inputs: {'guard': 'guard'},\n-            ngTemplateGuards: [{inputName: 'guard', type: 'binding'}]\n+            ngTemplateGuards: [{inputName: 'guard', type: 'binding'}],\n+            undeclaredInputFields: ['guard'],\n           }]);\n \n       expect(messages).toEqual(["
        },
        {
            "sha": "f1e285c25a189aa42ff3a39e593a4720bd4a07d1",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/test_utils.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 6,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -120,8 +120,9 @@ export function ngForDeclaration(): TestDeclaration {\n     file: absoluteFrom('/ngfor.d.ts'),\n     selector: '[ngForOf]',\n     name: 'NgForOf',\n-    inputs: {ngForOf: 'ngForOf'},\n+    inputs: {ngForOf: 'ngForOf', ngForTrackBy: 'ngForTrackBy', ngForTemplate: 'ngForTemplate'},\n     hasNgTemplateContextGuard: true,\n+    isGeneric: true,\n   };\n }\n \n@@ -175,11 +176,12 @@ export const ALL_ENABLED_CONFIG: TypeCheckingConfig = {\n // Remove 'ref' from TypeCheckableDirectiveMeta and add a 'selector' instead.\n export type TestDirective = Partial<Pick<\n     TypeCheckableDirectiveMeta,\n-    Exclude<keyof TypeCheckableDirectiveMeta, 'ref'|'coercedInputFields'>>>&{\n-  selector: string,\n-  name: string,\n-  file?: AbsoluteFsPath, type: 'directive',\n-  coercedInputFields?: string[],\n+    Exclude<\n+        keyof TypeCheckableDirectiveMeta,\n+        'ref'|'coercedInputFields'|'restrictedInputFields'|'undeclaredInputFields'>>>&{\n+  selector: string, name: string, file?: AbsoluteFsPath, type: 'directive',\n+      coercedInputFields?: string[], restrictedInputFields?: string[],\n+      undeclaredInputFields?: string[], isGeneric?: boolean;\n };\n export type TestPipe = {\n   name: string,\n@@ -417,6 +419,9 @@ function prepareDeclarations(\n       isComponent: decl.isComponent || false,\n       ngTemplateGuards: decl.ngTemplateGuards || [],\n       coercedInputFields: new Set<string>(decl.coercedInputFields || []),\n+      restrictedInputFields: new Set<string>(decl.restrictedInputFields || []),\n+      undeclaredInputFields: new Set<string>(decl.undeclaredInputFields || []),\n+      isGeneric: decl.isGeneric ?? false,\n       outputs: decl.outputs || {},\n       queries: decl.queries || [],\n     };"
        },
        {
            "sha": "d4a6b14a551ff5cb5cf24a88151a83c1e52fa80d",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_check_block_spec.ts",
            "status": "modified",
            "additions": 298,
            "deletions": 39,
            "changes": 337,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_check_block_spec.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -55,7 +55,7 @@ describe('type check blocks', () => {\n       selector: '[dir]',\n       inputs: {inputA: 'inputA'},\n     }];\n-    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('\"inputA\": (\"value\")');\n+    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('_t2: DirA = (null!); _t2[\"inputA\"] = (\"value\");');\n   });\n \n   it('should handle multiple bindings to the same property', () => {\n@@ -67,8 +67,8 @@ describe('type check blocks', () => {\n       inputs: {inputA: 'inputA'},\n     }];\n     const block = tcb(TEMPLATE, DIRECTIVES);\n-    expect(block).toContain('\"inputA\": (1)');\n-    expect(block).not.toContain('\"inputA\": (2)');\n+    expect(block).toContain('_t2[\"inputA\"] = (1);');\n+    expect(block).toContain('_t2[\"inputA\"] = (2);');\n   });\n \n   it('should handle empty bindings', () => {\n@@ -79,7 +79,7 @@ describe('type check blocks', () => {\n       selector: '[dir-a]',\n       inputs: {inputA: 'inputA'},\n     }];\n-    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('\"inputA\": (undefined)');\n+    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('_t2[\"inputA\"] = (undefined);');\n   });\n \n   it('should handle bindings without value', () => {\n@@ -90,7 +90,7 @@ describe('type check blocks', () => {\n       selector: '[dir-a]',\n       inputs: {inputA: 'inputA'},\n     }];\n-    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('\"inputA\": (undefined)');\n+    expect(tcb(TEMPLATE, DIRECTIVES)).toContain('_t2[\"inputA\"] = (undefined);');\n   });\n \n   it('should handle implicit vars on ng-template', () => {\n@@ -109,20 +109,148 @@ describe('type check blocks', () => {\n     expect(tcb(TEMPLATE)).toContain('var _t2 = _t1.$implicit;');\n   });\n \n-  it('should handle missing property bindings', () => {\n-    const TEMPLATE = `<div dir [inputA]=\"foo\"></div>`;\n-    const DIRECTIVES: TestDeclaration[] = [{\n-      type: 'directive',\n-      name: 'Dir',\n-      selector: '[dir]',\n-      inputs: {\n-        fieldA: 'inputA',\n-        fieldB: 'inputB',\n-      },\n-    }];\n-    expect(tcb(TEMPLATE, DIRECTIVES))\n-        .toContain(\n-            'var _t2 = Dir.ngTypeCtor({ \"fieldA\": (((ctx).foo)), \"fieldB\": (null as any) });');\n+  describe('type constructors', () => {\n+    it('should handle missing property bindings', () => {\n+      const TEMPLATE = `<div dir [inputA]=\"foo\"></div>`;\n+      const DIRECTIVES: TestDeclaration[] = [{\n+        type: 'directive',\n+        name: 'Dir',\n+        selector: '[dir]',\n+        inputs: {\n+          fieldA: 'inputA',\n+          fieldB: 'inputB',\n+        },\n+        isGeneric: true,\n+      }];\n+      expect(tcb(TEMPLATE, DIRECTIVES))\n+          .toContain(\n+              'var _t2 = Dir.ngTypeCtor({ \"fieldA\": (((ctx).foo)), \"fieldB\": (null as any) });');\n+    });\n+\n+    it('should handle multiple bindings to the same property', () => {\n+      const TEMPLATE = `<div dir [inputA]=\"1\" [inputA]=\"2\"></div>`;\n+      const DIRECTIVES: TestDeclaration[] = [{\n+        type: 'directive',\n+        name: 'Dir',\n+        selector: '[dir]',\n+        inputs: {\n+          fieldA: 'inputA',\n+        },\n+        isGeneric: true,\n+      }];\n+      const block = tcb(TEMPLATE, DIRECTIVES);\n+      expect(block).toContain('\"fieldA\": (1)');\n+      expect(block).not.toContain('\"fieldA\": (2)');\n+    });\n+\n+\n+    it('should only apply property bindings to directives', () => {\n+      const TEMPLATE = `\n+      <div dir [style.color]=\"'blue'\" [class.strong]=\"false\" [attr.enabled]=\"true\"></div>\n+    `;\n+      const DIRECTIVES: TestDeclaration[] = [{\n+        type: 'directive',\n+        name: 'Dir',\n+        selector: '[dir]',\n+        inputs: {'color': 'color', 'strong': 'strong', 'enabled': 'enabled'},\n+        isGeneric: true,\n+      }];\n+      const block = tcb(TEMPLATE, DIRECTIVES);\n+      expect(block).toContain(\n+          'var _t2 = Dir.ngTypeCtor({ \"color\": (null as any), \"strong\": (null as any), \"enabled\": (null as any) });');\n+      expect(block).toContain('\"blue\"; false; true;');\n+    });\n+\n+    it('should generate a circular directive reference correctly', () => {\n+      const TEMPLATE = `\n+      <div dir #d=\"dir\" [input]=\"d\"></div>\n+    `;\n+      const DIRECTIVES: TestDirective[] = [{\n+        type: 'directive',\n+        name: 'Dir',\n+        selector: '[dir]',\n+        exportAs: ['dir'],\n+        inputs: {input: 'input'},\n+        isGeneric: true,\n+      }];\n+      expect(tcb(TEMPLATE, DIRECTIVES))\n+          .toContain(\n+              'var _t3 = Dir.ngTypeCtor((null!)); ' +\n+              'var _t2 = Dir.ngTypeCtor({ \"input\": (_t3) });');\n+    });\n+\n+    it('should generate circular references between two directives correctly', () => {\n+      const TEMPLATE = `\n+    <div #a=\"dirA\" dir-a [inputA]=\"b\">A</div>\n+    <div #b=\"dirB\" dir-b [inputB]=\"a\">B</div>\n+`;\n+      const DIRECTIVES: TestDirective[] = [\n+        {\n+          type: 'directive',\n+          name: 'DirA',\n+          selector: '[dir-a]',\n+          exportAs: ['dirA'],\n+          inputs: {inputA: 'inputA'},\n+          isGeneric: true,\n+        },\n+        {\n+          type: 'directive',\n+          name: 'DirB',\n+          selector: '[dir-b]',\n+          exportAs: ['dirB'],\n+          inputs: {inputB: 'inputB'},\n+          isGeneric: true,\n+        }\n+      ];\n+      expect(tcb(TEMPLATE, DIRECTIVES))\n+          .toContain(\n+              'var _t4 = DirA.ngTypeCtor((null!)); ' +\n+              'var _t3 = DirB.ngTypeCtor({ \"inputB\": (_t4) }); ' +\n+              'var _t2 = DirA.ngTypeCtor({ \"inputA\": (_t3) });');\n+    });\n+\n+    it('should handle empty bindings', () => {\n+      const TEMPLATE = `<div dir-a [inputA]=\"\"></div>`;\n+      const DIRECTIVES: TestDeclaration[] = [{\n+        type: 'directive',\n+        name: 'DirA',\n+        selector: '[dir-a]',\n+        inputs: {inputA: 'inputA'},\n+        isGeneric: true,\n+      }];\n+      expect(tcb(TEMPLATE, DIRECTIVES)).toContain('\"inputA\": (undefined)');\n+    });\n+\n+    it('should handle bindings without value', () => {\n+      const TEMPLATE = `<div dir-a [inputA]></div>`;\n+      const DIRECTIVES: TestDeclaration[] = [{\n+        type: 'directive',\n+        name: 'DirA',\n+        selector: '[dir-a]',\n+        inputs: {inputA: 'inputA'},\n+        isGeneric: true,\n+      }];\n+      expect(tcb(TEMPLATE, DIRECTIVES)).toContain('\"inputA\": (undefined)');\n+    });\n+\n+    it('should use coercion types if declared', () => {\n+      const TEMPLATE = `<div dir [inputA]=\"foo\"></div>`;\n+      const DIRECTIVES: TestDeclaration[] = [{\n+        type: 'directive',\n+        name: 'Dir',\n+        selector: '[dir]',\n+        inputs: {\n+          fieldA: 'inputA',\n+        },\n+        isGeneric: true,\n+        coercedInputFields: ['fieldA'],\n+      }];\n+      expect(tcb(TEMPLATE, DIRECTIVES))\n+          .toContain(\n+              'var _t2 = Dir.ngTypeCtor({ \"fieldA\": (((ctx).foo)) }); ' +\n+              'var _t3: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n+              '_t3 = (((ctx).foo));');\n+    });\n   });\n \n   it('should generate a forward element reference correctly', () => {\n@@ -147,7 +275,7 @@ describe('type check blocks', () => {\n     }];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t1 = Dir.ngTypeCtor({}); \"\" + ((_t1).value); var _t2 = document.createElement(\"div\");');\n+            'var _t1: Dir = (null!); \"\" + ((_t1).value); var _t2 = document.createElement(\"div\");');\n   });\n \n   it('should handle style and class bindings specially', () => {\n@@ -173,8 +301,10 @@ describe('type check blocks', () => {\n       inputs: {'color': 'color', 'strong': 'strong', 'enabled': 'enabled'},\n     }];\n     const block = tcb(TEMPLATE, DIRECTIVES);\n-    expect(block).toContain(\n-        'var _t2 = Dir.ngTypeCtor({ \"color\": (null as any), \"strong\": (null as any), \"enabled\": (null as any) });');\n+    expect(block).toContain('var _t2: Dir = (null!);');\n+    expect(block).not.toContain('\"color\"');\n+    expect(block).not.toContain('\"strong\"');\n+    expect(block).not.toContain('\"enabled\"');\n     expect(block).toContain('\"blue\"; false; true;');\n   });\n \n@@ -191,8 +321,8 @@ describe('type check blocks', () => {\n     }];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t3 = Dir.ngTypeCtor((null!)); ' +\n-            'var _t2 = Dir.ngTypeCtor({ \"input\": (_t3) });');\n+            'var _t2: Dir = (null!); ' +\n+            '_t2[\"input\"] = (_t2);');\n   });\n \n   it('should generate circular references between two directives correctly', () => {\n@@ -218,9 +348,139 @@ describe('type check blocks', () => {\n     ];\n     expect(tcb(TEMPLATE, DIRECTIVES))\n         .toContain(\n-            'var _t4 = DirA.ngTypeCtor((null!)); ' +\n-            'var _t3 = DirB.ngTypeCtor({ \"inputA\": (_t4) }); ' +\n-            'var _t2 = DirA.ngTypeCtor({ \"inputA\": (_t3) });');\n+            'var _t2: DirA = (null!); ' +\n+            'var _t3: DirB = (null!); ' +\n+            '_t2[\"inputA\"] = (_t3); ' +\n+            'var _t4 = document.createElement(\"div\"); ' +\n+            '_t3[\"inputA\"] = (_t2);');\n+  });\n+\n+  it('should handle undeclared properties', () => {\n+    const TEMPLATE = `<div dir [inputA]=\"foo\"></div>`;\n+    const DIRECTIVES: TestDeclaration[] = [{\n+      type: 'directive',\n+      name: 'Dir',\n+      selector: '[dir]',\n+      inputs: {\n+        fieldA: 'inputA',\n+      },\n+      undeclaredInputFields: ['fieldA']\n+    }];\n+    expect(tcb(TEMPLATE, DIRECTIVES))\n+        .toContain(\n+            'var _t2: Dir = (null!); ' +\n+            '(((ctx).foo)); ');\n+  });\n+\n+  it('should handle restricted properties', () => {\n+    const TEMPLATE = `<div dir [inputA]=\"foo\"></div>`;\n+    const DIRECTIVES: TestDeclaration[] = [{\n+      type: 'directive',\n+      name: 'Dir',\n+      selector: '[dir]',\n+      inputs: {\n+        fieldA: 'inputA',\n+      },\n+      restrictedInputFields: ['fieldA']\n+    }];\n+    expect(tcb(TEMPLATE, DIRECTIVES))\n+        .toContain(\n+            'var _t2: Dir = (null!); ' +\n+            'var _t3: typeof _t2[\"fieldA\"] = (null!); ' +\n+            '_t3 = (((ctx).foo)); ');\n+  });\n+\n+  it('should handle a single property bound to multiple fields', () => {\n+    const TEMPLATE = `<div dir [inputA]=\"foo\"></div>`;\n+    const DIRECTIVES: TestDeclaration[] = [{\n+      type: 'directive',\n+      name: 'Dir',\n+      selector: '[dir]',\n+      inputs: {\n+        field1: 'inputA',\n+        field2: 'inputA',\n+      },\n+    }];\n+    expect(tcb(TEMPLATE, DIRECTIVES))\n+        .toContain(\n+            'var _t2: Dir = (null!); ' +\n+            '_t2[\"field2\"] = _t2[\"field1\"] = (((ctx).foo));');\n+  });\n+\n+  it('should handle a single property bound to multiple fields, where one of them is coerced',\n+     () => {\n+       const TEMPLATE = `<div dir [inputA]=\"foo\"></div>`;\n+       const DIRECTIVES: TestDeclaration[] = [{\n+         type: 'directive',\n+         name: 'Dir',\n+         selector: '[dir]',\n+         inputs: {\n+           field1: 'inputA',\n+           field2: 'inputA',\n+         },\n+         coercedInputFields: ['field1'],\n+       }];\n+       expect(tcb(TEMPLATE, DIRECTIVES))\n+           .toContain(\n+               'var _t2: Dir = (null!); ' +\n+               'var _t3: typeof Dir.ngAcceptInputType_field1 = (null!); ' +\n+               '_t2[\"field2\"] = _t3 = (((ctx).foo));');\n+     });\n+\n+  it('should handle a single property bound to multiple fields, where one of them is undeclared',\n+     () => {\n+       const TEMPLATE = `<div dir [inputA]=\"foo\"></div>`;\n+       const DIRECTIVES: TestDeclaration[] = [{\n+         type: 'directive',\n+         name: 'Dir',\n+         selector: '[dir]',\n+         inputs: {\n+           field1: 'inputA',\n+           field2: 'inputA',\n+         },\n+         undeclaredInputFields: ['field1'],\n+       }];\n+       expect(tcb(TEMPLATE, DIRECTIVES))\n+           .toContain(\n+               'var _t2: Dir = (null!); ' +\n+               '_t2[\"field2\"] = (((ctx).foo));');\n+     });\n+\n+  it('should use coercion types if declared', () => {\n+    const TEMPLATE = `<div dir [inputA]=\"foo\"></div>`;\n+    const DIRECTIVES: TestDeclaration[] = [{\n+      type: 'directive',\n+      name: 'Dir',\n+      selector: '[dir]',\n+      inputs: {\n+        fieldA: 'inputA',\n+      },\n+      coercedInputFields: ['fieldA'],\n+    }];\n+    expect(tcb(TEMPLATE, DIRECTIVES))\n+        .toContain(\n+            'var _t2: Dir = (null!); ' +\n+            'var _t3: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n+            '_t3 = (((ctx).foo));');\n+  });\n+\n+  it('should use coercion types if declared, even when backing field is not declared', () => {\n+    const TEMPLATE = `<div dir [inputA]=\"foo\"></div>`;\n+    const DIRECTIVES: TestDeclaration[] = [{\n+      type: 'directive',\n+      name: 'Dir',\n+      selector: '[dir]',\n+      inputs: {\n+        fieldA: 'inputA',\n+      },\n+      coercedInputFields: ['fieldA'],\n+      undeclaredInputFields: ['fieldA'],\n+    }];\n+    expect(tcb(TEMPLATE, DIRECTIVES))\n+        .toContain(\n+            'var _t2: Dir = (null!); ' +\n+            'var _t3: typeof Dir.ngAcceptInputType_fieldA = (null!); ' +\n+            '_t3 = (((ctx).foo));');\n   });\n \n   it('should handle $any casts', () => {\n@@ -379,14 +639,14 @@ describe('type check blocks', () => {\n \n       it('should include null and undefined when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('Dir.ngTypeCtor({ \"dirInput\": (((ctx).a)) })');\n+        expect(block).toContain('_t2[\"dirInput\"] = (((ctx).a));');\n         expect(block).toContain('((ctx).b);');\n       });\n       it('should use the non-null assertion operator when disabled', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, strictNullInputBindings: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('Dir.ngTypeCtor({ \"dirInput\": (((ctx).a)!) })');\n+        expect(block).toContain('_t2[\"dirInput\"] = (((ctx).a)!);');\n         expect(block).toContain('((ctx).b)!;');\n       });\n     });\n@@ -395,7 +655,7 @@ describe('type check blocks', () => {\n       it('should check types of bindings when enabled', () => {\n         const TEMPLATE = `<div dir [dirInput]=\"a\" [nonDirInput]=\"b\"></div>`;\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('Dir.ngTypeCtor({ \"dirInput\": (((ctx).a)) })');\n+        expect(block).toContain('_t2[\"dirInput\"] = (((ctx).a));');\n         expect(block).toContain('((ctx).b);');\n       });\n \n@@ -404,7 +664,7 @@ describe('type check blocks', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfInputBindings: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('Dir.ngTypeCtor({ \"dirInput\": ((((ctx).a) as any)) })');\n+        expect(block).toContain('_t2[\"dirInput\"] = ((((ctx).a) as any));');\n         expect(block).toContain('(((ctx).b) as any);');\n       });\n \n@@ -413,8 +673,7 @@ describe('type check blocks', () => {\n         const DISABLED_CONFIG:\n             TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfInputBindings: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain(\n-            'Dir.ngTypeCtor({ \"dirInput\": ((((((ctx).a)) === (((ctx).b))) as any)) })');\n+        expect(block).toContain('_t2[\"dirInput\"] = ((((((ctx).a)) === (((ctx).b))) as any));');\n       });\n     });\n \n@@ -534,17 +793,17 @@ describe('type check blocks', () => {\n \n       it('should assign string value to the input when enabled', () => {\n         const block = tcb(TEMPLATE, DIRECTIVES);\n-        expect(block).toContain('\"disabled\": (\"\")');\n-        expect(block).toContain('\"cols\": (\"3\")');\n-        expect(block).toContain('\"rows\": (2)');\n+        expect(block).toContain('_t2[\"disabled\"] = (\"\");');\n+        expect(block).toContain('_t2[\"cols\"] = (\"3\");');\n+        expect(block).toContain('_t2[\"rows\"] = (2);');\n       });\n \n       it('should use any for attributes but still check bound attributes when disabled', () => {\n         const DISABLED_CONFIG: TypeCheckingConfig = {...BASE_CONFIG, checkTypeOfAttributes: false};\n         const block = tcb(TEMPLATE, DIRECTIVES, DISABLED_CONFIG);\n-        expect(block).toContain('\"disabled\": (null as any)');\n-        expect(block).toContain('\"cols\": (null as any)');\n-        expect(block).toContain('\"rows\": (2)');\n+        expect(block).not.toContain('\"disabled\"');\n+        expect(block).not.toContain('\"cols\"');\n+        expect(block).toContain('_t2[\"rows\"] = (2);');\n       });\n     });\n "
        },
        {
            "sha": "0a075efbf30bfc0aaf00b790c8dfd3608bc6bd12",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker_spec.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker_spec.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -86,6 +86,7 @@ runInEachFileSystem(os => {\n         selector: '[dir]',\n         file: dirFile,\n         type: 'directive',\n+        isGeneric: true,\n       };\n       const {program, templateTypeChecker, programStrategy} = setup([\n         {\n@@ -104,7 +105,7 @@ runInEachFileSystem(os => {\n                 // A non-exported interface used as a type bound for a generic directive causes\n                 // an inline type constructor to be required.\n                 interface NotExported {}\n-                export class TestDir<T extends NotExported> {}`,\n+                export abstract class TestDir<T extends NotExported> {}`,\n           templates: {},\n         },\n       ]);\n@@ -161,7 +162,7 @@ runInEachFileSystem(os => {\n         const {program, templateTypeChecker} = setup(\n             [{\n               fileName,\n-              source: `class Cmp {} // not exported, so requires inline`,\n+              source: `abstract class Cmp {} // not exported, so requires inline`,\n               templates: {'Cmp': '<div></div>'}\n             }],\n             {inlining: false});\n@@ -188,6 +189,7 @@ runInEachFileSystem(os => {\n                     selector: '[dir]',\n                     file: dirFile,\n                     type: 'directive',\n+                    isGeneric: true,\n                   }]\n                 },\n                 {\n@@ -196,7 +198,7 @@ runInEachFileSystem(os => {\n                   // A non-exported interface used as a type bound for a generic directive causes\n                   // an inline type constructor to be required.\n                   interface NotExported {}\n-                  export class TestDir<T extends NotExported> {}`,\n+                  export abstract class TestDir<T extends NotExported> {}`,\n                   templates: {},\n                 }\n               ],"
        },
        {
            "sha": "5646850c2281d155bd2dd942e173f6be506fabf3",
            "filename": "packages/compiler-cli/test/ngtsc/template_typecheck_spec.ts",
            "status": "modified",
            "additions": 237,
            "deletions": 13,
            "changes": 250,
            "blob_url": "https://github.com/angular/angular/blob/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Ftemplate_typecheck_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/fa0104017a3f0f2d9d3e9bf0180290f589b137e4/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Ftemplate_typecheck_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Ftemplate_typecheck_spec.ts?ref=fa0104017a3f0f2d9d3e9bf0180290f589b137e4",
            "patch": "@@ -136,11 +136,42 @@ export declare class AnimationEvent {\n \n       const diags = env.driveDiagnostics();\n       expect(diags.length).toBe(1);\n-      expect(diags[0].messageText).toEqual(`Type 'string' is not assignable to type 'number'.`);\n+      expect(diags[0].messageText).toEqual(`Type '\"2\"' is not assignable to type 'number'.`);\n       // The reported error code should be in the TS error space, not a -99 \"NG\" code.\n       expect(diags[0].code).toBeGreaterThan(0);\n     });\n \n+    it('should produce diagnostics when mapping to multiple fields and bound types are incorrect',\n+       () => {\n+         env.tsconfig(\n+             {fullTemplateTypeCheck: true, strictInputTypes: true, strictAttributeTypes: true});\n+         env.write('test.ts', `\n+        import {Component, Directive, NgModule, Input} from '@angular/core';\n+\n+        @Component({\n+          selector: 'test',\n+          template: '<div dir foo=\"2\"></div>',\n+        })\n+        class TestCmp {}\n+\n+        @Directive({selector: '[dir]'})\n+        class TestDir {\n+          @Input('foo') foo1: number;\n+          @Input('foo') foo2: number;\n+        }\n+\n+        @NgModule({\n+          declarations: [TestCmp, TestDir],\n+        })\n+        class Module {}\n+      `);\n+\n+         const diags = env.driveDiagnostics();\n+         expect(diags.length).toBe(2);\n+         expect(diags[0].messageText).toEqual(`Type '\"2\"' is not assignable to type 'number'.`);\n+         expect(diags[1].messageText).toEqual(`Type '\"2\"' is not assignable to type 'number'.`);\n+       });\n+\n     it('should support inputs and outputs with names that are not JavaScript identifiers', () => {\n       env.tsconfig(\n           {fullTemplateTypeCheck: true, strictInputTypes: true, strictOutputEventTypes: true});\n@@ -173,7 +204,7 @@ export declare class AnimationEvent {\n \n       const diags = env.driveDiagnostics();\n       expect(diags.length).toBe(2);\n-      expect(diags[0].messageText).toEqual(`Type 'number' is not assignable to type 'string'.`);\n+      expect(diags[0].messageText).toEqual(`Type '2' is not assignable to type 'string'.`);\n       expect(diags[1].messageText)\n           .toEqual(`Argument of type 'string' is not assignable to parameter of type 'number'.`);\n     });\n@@ -349,7 +380,7 @@ export declare class AnimationEvent {\n \n         const diags = env.driveDiagnostics();\n         expect(diags.length).toBe(2);\n-        expect(diags[0].messageText).toEqual(`Type 'number' is not assignable to type 'string'.`);\n+        expect(diags[0].messageText).toEqual(`Type '1' is not assignable to type 'string'.`);\n         expect(diags[1].messageText)\n             .toEqual(`Property 'invalid' does not exist on type 'TestCmp'.`);\n       });\n@@ -359,7 +390,7 @@ export declare class AnimationEvent {\n \n         const diags = env.driveDiagnostics();\n         expect(diags.length).toBe(2);\n-        expect(diags[0].messageText).toEqual(`Type 'number' is not assignable to type 'string'.`);\n+        expect(diags[0].messageText).toEqual(`Type '1' is not assignable to type 'string'.`);\n         expect(diags[1].messageText)\n             .toEqual(`Property 'invalid' does not exist on type 'TestCmp'.`);\n       });\n@@ -685,17 +716,17 @@ export declare class AnimationEvent {\n \n         const diags = env.driveDiagnostics();\n         expect(diags.length).toBe(2);\n-        expect(diags[0].messageText).toEqual(`Type 'string' is not assignable to type 'boolean'.`);\n-        expect(diags[1].messageText).toEqual(`Type 'string' is not assignable to type 'number'.`);\n+        expect(diags[0].messageText).toEqual(`Type '\"\"' is not assignable to type 'boolean'.`);\n+        expect(diags[1].messageText).toEqual(`Type '\"3\"' is not assignable to type 'number'.`);\n       });\n \n       it('should produce an error for text attributes when overall strictness is enabled', () => {\n         env.tsconfig({strictTemplates: true});\n \n         const diags = env.driveDiagnostics();\n         expect(diags.length).toBe(2);\n-        expect(diags[0].messageText).toEqual(`Type 'string' is not assignable to type 'boolean'.`);\n-        expect(diags[1].messageText).toEqual(`Type 'string' is not assignable to type 'number'.`);\n+        expect(diags[0].messageText).toEqual(`Type '\"\"' is not assignable to type 'boolean'.`);\n+        expect(diags[1].messageText).toEqual(`Type '\"3\"' is not assignable to type 'number'.`);\n       });\n \n       it('should not produce an error for text attributes when not enabled', () => {\n@@ -1212,9 +1243,9 @@ export declare class AnimationEvent {\n       expect(diags.length).toBe(3);\n       expect(diags[0].messageText).toBe(`Type 'true' is not assignable to type 'number'.`);\n       expect(getSourceCodeForDiagnostic(diags[0])).toEqual('[fromAbstract]=\"true\"');\n-      expect(diags[1].messageText).toBe(`Type 'number' is not assignable to type 'string'.`);\n+      expect(diags[1].messageText).toBe(`Type '3' is not assignable to type 'string'.`);\n       expect(getSourceCodeForDiagnostic(diags[1])).toEqual('[fromBase]=\"3\"');\n-      expect(diags[2].messageText).toBe(`Type 'number' is not assignable to type 'boolean'.`);\n+      expect(diags[2].messageText).toBe(`Type '4' is not assignable to type 'boolean'.`);\n       expect(getSourceCodeForDiagnostic(diags[2])).toEqual('[fromChild]=\"4\"');\n     });\n \n@@ -1269,9 +1300,9 @@ export declare class AnimationEvent {\n       expect(diags.length).toBe(3);\n       expect(diags[0].messageText).toBe(`Type 'true' is not assignable to type 'number'.`);\n       expect(getSourceCodeForDiagnostic(diags[0])).toEqual('[fromAbstract]=\"true\"');\n-      expect(diags[1].messageText).toBe(`Type 'number' is not assignable to type 'string'.`);\n+      expect(diags[1].messageText).toBe(`Type '3' is not assignable to type 'string'.`);\n       expect(getSourceCodeForDiagnostic(diags[1])).toEqual('[fromBase]=\"3\"');\n-      expect(diags[2].messageText).toBe(`Type 'number' is not assignable to type 'boolean'.`);\n+      expect(diags[2].messageText).toBe(`Type '4' is not assignable to type 'boolean'.`);\n       expect(getSourceCodeForDiagnostic(diags[2])).toEqual('[fromChild]=\"4\"');\n     });\n \n@@ -1476,7 +1507,7 @@ export declare class AnimationEvent {\n       it('should give an error if the binding expression type is not accepted by the coercion function',\n          () => {\n            env.write('test.ts', `\n-            import {Component, NgModule} from '@angular/core';\n+            import {Component, NgModule, Input, Directive} from '@angular/core';\n             import {MatInputModule} from '@angular/material';\n \n             @Component({\n@@ -1533,6 +1564,199 @@ export declare class AnimationEvent {\n          });\n     });\n \n+    describe('restricted inputs', () => {\n+      const directiveDeclaration = `\n+            @Directive({selector: '[dir]'})\n+            export class TestDir {\n+              @Input()\n+              protected protectedField!: string;\n+              @Input()\n+              private privateField!: string;\n+              @Input()\n+              readonly readonlyField!: string;\n+            }\n+      `;\n+\n+      describe('with strict inputs', () => {\n+        beforeEach(() => {\n+          env.tsconfig({fullTemplateTypeCheck: true, strictInputTypes: true});\n+        });\n+\n+        it('should not produce diagnostics for correct inputs which assign to readonly, private, or protected fields',\n+           () => {\n+             env.write('test.ts', `\n+            import {Component, NgModule, Input, Directive} from '@angular/core';\n+\n+            @Component({\n+              selector: 'blah',\n+              template: '<div dir [readonlyField]=\"value\" [protectedField]=\"value\" [privateField]=\"value\"></div>',\n+            })\n+            export class FooCmp {\n+              value = \"value\";\n+            }\n+\n+            ${directiveDeclaration}\n+\n+            @NgModule({\n+              declarations: [FooCmp, TestDir],\n+            })\n+            export class FooModule {}\n+        `);\n+             const diags = env.driveDiagnostics();\n+             expect(diags.length).toBe(0);\n+           });\n+\n+        it('should not produce diagnostics for correct inputs which assign to readonly, private, or protected fields inherited from a base class',\n+           () => {\n+             env.write('test.ts', `\n+            import {Component, NgModule, Input, Directive} from '@angular/core';\n+\n+            @Component({\n+              selector: 'blah',\n+              template: '<div child-dir [readonlyField]=\"value\" [protectedField]=\"value\" [privateField]=\"value\"></div>',\n+            })\n+            export class FooCmp {\n+              value = \"value\";\n+            }\n+\n+            ${directiveDeclaration}\n+\n+            @Directive({selector: '[child-dir]'})\n+            export class ChildDir extends TestDir {\n+            }\n+\n+            @NgModule({\n+              declarations: [FooCmp, ChildDir],\n+            })\n+            export class FooModule {}\n+        `);\n+             const diags = env.driveDiagnostics();\n+             expect(diags.length).toBe(0);\n+           });\n+\n+        it('should produce diagnostics when assigning incorrect type to readonly, private, or protected fields',\n+           () => {\n+             env.write('test.ts', `\n+            import {Component, NgModule, Input, Directive} from '@angular/core';\n+\n+            @Component({\n+              selector: 'blah',\n+              template: '<div dir [readonlyField]=\"value\" [protectedField]=\"value\" [privateField]=\"value\"></div>',\n+            })\n+            export class FooCmp {\n+              value = 1;\n+            }\n+\n+            ${directiveDeclaration}\n+\n+            @NgModule({\n+              declarations: [FooCmp, TestDir],\n+            })\n+            export class FooModule {}\n+        `);\n+             const diags = env.driveDiagnostics();\n+             expect(diags.length).toBe(3);\n+             expect(diags[0].messageText)\n+                 .toEqual(`Type 'number' is not assignable to type 'string'.`);\n+             expect(diags[1].messageText)\n+                 .toEqual(`Type 'number' is not assignable to type 'string'.`);\n+             expect(diags[2].messageText)\n+                 .toEqual(`Type 'number' is not assignable to type 'string'.`);\n+           });\n+      });\n+    });\n+\n+    it('should not produce diagnostics for undeclared inputs', () => {\n+      env.tsconfig({fullTemplateTypeCheck: true, strictInputTypes: true});\n+      env.write('test.ts', `\n+            import {Component, NgModule, Input, Directive} from '@angular/core';\n+\n+            @Component({\n+              selector: 'blah',\n+              template: '<div dir [undeclared]=\"value\"></div>',\n+            })\n+            export class FooCmp {\n+              value = \"value\";\n+            }\n+\n+            @Directive({\n+              selector: '[dir]',\n+              inputs: ['undeclared'],\n+            })\n+            export class TestDir {\n+            }\n+\n+            @NgModule({\n+              declarations: [FooCmp, TestDir],\n+            })\n+            export class FooModule {}\n+        `);\n+      const diags = env.driveDiagnostics();\n+      expect(diags.length).toBe(0);\n+    });\n+\n+    it('should produce diagnostics for invalid expressions when assigned into an undeclared input',\n+       () => {\n+         env.tsconfig({fullTemplateTypeCheck: true, strictInputTypes: true});\n+         env.write('test.ts', `\n+            import {Component, NgModule, Input, Directive} from '@angular/core';\n+\n+            @Component({\n+              selector: 'blah',\n+              template: '<div dir [undeclared]=\"value\"></div>',\n+            })\n+            export class FooCmp {\n+            }\n+\n+            @Directive({\n+              selector: '[dir]',\n+              inputs: ['undeclared'],\n+            })\n+            export class TestDir {\n+            }\n+\n+            @NgModule({\n+              declarations: [FooCmp, TestDir],\n+            })\n+            export class FooModule {}\n+        `);\n+         const diags = env.driveDiagnostics();\n+         expect(diags.length).toBe(1);\n+         expect(diags[0].messageText).toBe(`Property 'value' does not exist on type 'FooCmp'.`);\n+       });\n+\n+    it('should not produce diagnostics for undeclared inputs inherited from a base class', () => {\n+      env.tsconfig({fullTemplateTypeCheck: true, strictInputTypes: true});\n+      env.write('test.ts', `\n+            import {Component, NgModule, Input, Directive} from '@angular/core';\n+\n+            @Component({\n+              selector: 'blah',\n+              template: '<div dir [undeclaredBase]=\"value\"></div>',\n+            })\n+            export class FooCmp {\n+              value = \"value\";\n+            }\n+\n+            @Directive({\n+              inputs: ['undeclaredBase'],\n+            })\n+            export class BaseDir {\n+            }\n+\n+            @Directive({selector: '[dir]'})\n+            export class TestDir extends BaseDir {\n+            }\n+\n+            @NgModule({\n+              declarations: [FooCmp, TestDir],\n+            })\n+            export class FooModule {}\n+        `);\n+      const diags = env.driveDiagnostics();\n+      expect(diags.length).toBe(0);\n+    });\n+\n     describe('legacy schema checking with the DOM schema', () => {\n       beforeEach(() => {\n         env.tsconfig({ivyTemplateTypeCheck: true, fullTemplateTypeCheck: false});"
        }
    ],
    "stats": {
        "total": 1131,
        "additions": 951,
        "deletions": 180
    }
}