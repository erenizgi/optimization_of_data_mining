{
    "author": "JiaLiPassion",
    "message": "fix(zone.js): only one listener should also re-throw an error correctly (#41868)\n\nClose #41867\n\nIn the previous commit https://github.com/angular/angular/pull/41562#issuecomment-822696973,\nthe error thrown in the event listener will be caught and re-thrown, but there is a bug\nin the commit, if there is only one listener for the specified event name, the error\nwill not be re-thrown, so this commit fixes the issue and make sure the error is re-thrown.\n\nPR Close #41868",
    "sha": "299f92c3b62a43c94cff4a204f9e41c46a159efc",
    "files": [
        {
            "sha": "7bd7d5bd9ff0f6d24bc70356c15307742a75ae06",
            "filename": "goldens/size-tracking/integration-payloads.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/299f92c3b62a43c94cff4a204f9e41c46a159efc/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "raw_url": "https://github.com/angular/angular/raw/299f92c3b62a43c94cff4a204f9e41c46a159efc/goldens%2Fsize-tracking%2Fintegration-payloads.json",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/goldens%2Fsize-tracking%2Fintegration-payloads.json?ref=299f92c3b62a43c94cff4a204f9e41c46a159efc",
            "patch": "@@ -13,7 +13,7 @@\n       \"uncompressed\": {\n         \"runtime-es2015\": 1205,\n         \"main-es2015\": 17597,\n-        \"polyfills-es2015\": 36709\n+        \"polyfills-es2015\": 37127\n       }\n     }\n   },"
        },
        {
            "sha": "186773e39c4653ef98dc0f5b70a6ef9421c91d42",
            "filename": "packages/zone.js/lib/common/events.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 3,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/299f92c3b62a43c94cff4a204f9e41c46a159efc/packages%2Fzone.js%2Flib%2Fcommon%2Fevents.ts",
            "raw_url": "https://github.com/angular/angular/raw/299f92c3b62a43c94cff4a204f9e41c46a159efc/packages%2Fzone.js%2Flib%2Fcommon%2Fevents.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Flib%2Fcommon%2Fevents.ts?ref=299f92c3b62a43c94cff4a204f9e41c46a159efc",
            "patch": "@@ -104,7 +104,7 @@ export function patchEventTarget(\n   const PREPEND_EVENT_LISTENER = 'prependListener';\n   const PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';\n \n-  const invokeTask = function(task: any, target: any, event: Event) {\n+  const invokeTask = function(task: any, target: any, event: Event): Error|undefined {\n     // for better performance, check isRemoved which is set\n     // by removeEventListener\n     if (task.isRemoved) {\n@@ -149,23 +149,30 @@ export function patchEventTarget(\n     const target: any = context || event.target || _global;\n     const tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];\n     if (tasks) {\n+      const errors = [];\n       // invoke all tasks which attached to current target with given event.type and capture = false\n       // for performance concern, if task.length === 1, just invoke\n       if (tasks.length === 1) {\n-        invokeTask(tasks[0], target, event);\n+        const err = invokeTask(tasks[0], target, event);\n+        err && errors.push(err);\n       } else {\n         // https://github.com/angular/zone.js/issues/836\n         // copy the tasks array before invoke, to avoid\n         // the callback will remove itself or other listener\n         const copyTasks = tasks.slice();\n-        const errors = [];\n         for (let i = 0; i < copyTasks.length; i++) {\n           if (event && (event as any)[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\n             break;\n           }\n           const err = invokeTask(copyTasks[i], target, event);\n           err && errors.push(err);\n         }\n+      }\n+      // Since there is only one error, we don't need to schedule microTask\n+      // to throw the error.\n+      if (errors.length === 1) {\n+        throw errors[0];\n+      } else {\n         for (let i = 0; i < errors.length; i++) {\n           const err = errors[i];\n           api.nativeScheduleMicroTask(() => {"
        },
        {
            "sha": "2c21c49f411d98b1e91b0f855926754ee0cc043b",
            "filename": "packages/zone.js/test/browser/XMLHttpRequest.spec.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/299f92c3b62a43c94cff4a204f9e41c46a159efc/packages%2Fzone.js%2Ftest%2Fbrowser%2FXMLHttpRequest.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/299f92c3b62a43c94cff4a204f9e41c46a159efc/packages%2Fzone.js%2Ftest%2Fbrowser%2FXMLHttpRequest.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Ftest%2Fbrowser%2FXMLHttpRequest.spec.ts?ref=299f92c3b62a43c94cff4a204f9e41c46a159efc",
            "patch": "@@ -132,9 +132,11 @@ describe('XMLHttpRequest', function() {\n \n   it('should invoke xhr task even onload listener throw error', function(done) {\n     const oriWindowError = window.onerror;\n-    window.onerror = function() {};\n+    const logs: string[] = [];\n+    window.onerror = function(err: any) {\n+      logs.push(err);\n+    };\n     try {\n-      const logs: string[] = [];\n       const xhrZone = Zone.current.fork({\n         name: 'xhr',\n         onInvokeTask: (delegate, curr, target, task, applyThis, applyArgs) => {\n@@ -156,7 +158,7 @@ describe('XMLHttpRequest', function() {\n           throw new Error('test');\n         };\n         const unhandledRejection = (e: PromiseRejectionEvent) => {\n-          logs.push(e.reason.message);\n+          fail('should not be here');\n         };\n         window.addEventListener('unhandledrejection', unhandledRejection);\n         req.addEventListener('load', () => {\n@@ -165,8 +167,7 @@ describe('XMLHttpRequest', function() {\n             expect(logs).toEqual([\n               'hasTask true', 'invokeTask XMLHttpRequest.addEventListener:load', 'onload',\n               'invokeTask XMLHttpRequest.addEventListener:load', 'onload1',\n-              'invokeTask XMLHttpRequest.send', 'hasTask false',\n-              'invokeTask Window.addEventListener:unhandledrejection', 'test'\n+              'invokeTask XMLHttpRequest.send', 'hasTask false', 'Uncaught Error: test'\n             ]);\n             window.removeEventListener('unhandledrejection', unhandledRejection);\n             window.onerror = oriWindowError;"
        },
        {
            "sha": "b73ddbf351b7ed8d3d7c7d171430929dad440bcd",
            "filename": "packages/zone.js/test/browser/browser.spec.ts",
            "status": "modified",
            "additions": 148,
            "deletions": 5,
            "changes": 153,
            "blob_url": "https://github.com/angular/angular/blob/299f92c3b62a43c94cff4a204f9e41c46a159efc/packages%2Fzone.js%2Ftest%2Fbrowser%2Fbrowser.spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/299f92c3b62a43c94cff4a204f9e41c46a159efc/packages%2Fzone.js%2Ftest%2Fbrowser%2Fbrowser.spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Ftest%2Fbrowser%2Fbrowser.spec.ts?ref=299f92c3b62a43c94cff4a204f9e41c46a159efc",
            "patch": "@@ -2491,6 +2491,85 @@ describe('Zone', function() {\n            expect(logs).toEqual([]);\n          }));\n \n+      it('should re-throw the error when the only listener throw error', function(done: DoneFn) {\n+        // override global.onerror to prevent jasmine report error\n+        let oriWindowOnError = window.onerror;\n+        let logs: string[] = [];\n+        window.onerror = function(err: any) {\n+          logs.push(err);\n+        };\n+        try {\n+          const listener1 = function() {\n+            throw new Error('test1');\n+          };\n+          button.addEventListener('click', listener1);\n+\n+          const mouseEvent = document.createEvent('MouseEvent');\n+          mouseEvent.initEvent('click', true, true);\n+\n+          const unhandledRejection = (e: PromiseRejectionEvent) => {\n+            fail('should not be here');\n+          };\n+          window.addEventListener('unhandledrejection', unhandledRejection);\n+\n+          button.dispatchEvent(mouseEvent);\n+          expect(logs).toEqual(['Uncaught Error: test1']);\n+\n+          setTimeout(() => {\n+            expect(logs).toEqual(['Uncaught Error: test1']);\n+            window.removeEventListener('unhandledrejection', unhandledRejection);\n+            window.onerror = oriWindowOnError;\n+            done()\n+          });\n+        } catch (e: any) {\n+          window.onerror = oriWindowOnError;\n+        }\n+      });\n+\n+      it('should not re-throw the error when zone onHandleError handled the error and the only listener throw error',\n+         function(done: DoneFn) {\n+           // override global.onerror to prevent jasmine report error\n+           let oriWindowOnError = window.onerror;\n+           window.onerror = function() {};\n+           try {\n+             let logs: string[] = [];\n+             const listener1 = function() {\n+               throw new Error('test1');\n+             };\n+             const zone = Zone.current.fork({\n+               name: 'error',\n+               onHandleError: (delegate, curr, target, error) => {\n+                 logs.push('zone handled ' + target.name + ' ' + error.message);\n+                 return false;\n+               }\n+             });\n+\n+             zone.runGuarded(() => {\n+               button.addEventListener('click', listener1);\n+             });\n+\n+             const mouseEvent = document.createEvent('MouseEvent');\n+             mouseEvent.initEvent('click', true, true);\n+\n+             const unhandledRejection = (e: PromiseRejectionEvent) => {\n+               logs.push(e.reason.message);\n+             };\n+             window.addEventListener('unhandledrejection', unhandledRejection);\n+\n+             button.dispatchEvent(mouseEvent);\n+             expect(logs).toEqual(['zone handled error test1']);\n+\n+             setTimeout(() => {\n+               expect(logs).toEqual(['zone handled error test1']);\n+               window.removeEventListener('unhandledrejection', unhandledRejection);\n+               window.onerror = oriWindowOnError;\n+               done();\n+             });\n+           } catch (e: any) {\n+             window.onerror = oriWindowOnError;\n+           }\n+         });\n+\n       it('should be able to continue to invoke remaining listeners even some listener throw error',\n          function(done: DoneFn) {\n            // override global.onerror to prevent jasmine report error\n@@ -2540,13 +2619,77 @@ describe('Zone', function() {\n            }\n          });\n \n-      it('should be able to continue to invoke remaining listeners even some listener throw error in the different zones',\n+      it('should be able to continue to invoke remaining listeners even some listener throw error with onHandleError zone',\n          function(done: DoneFn) {\n            // override global.onerror to prevent jasmine report error\n            let oriWindowOnError = window.onerror;\n            window.onerror = function() {};\n            try {\n+             const zone = Zone.current.fork({\n+               name: 'error',\n+               onHandleError: (delegate, curr, target, error) => {\n+                 logs.push('zone handled ' + target.name + ' ' + error.message);\n+                 return false;\n+               }\n+             });\n              let logs: string[] = [];\n+             const listener1 = function() {\n+               logs.push('listener1');\n+             };\n+             const listener2 = function() {\n+               throw new Error('test1');\n+             };\n+             const listener3 = function() {\n+               throw new Error('test2');\n+             };\n+             const listener4 = {\n+               handleEvent: function() {\n+                 logs.push('listener2');\n+               }\n+             };\n+\n+             zone.runGuarded(() => {\n+               button.addEventListener('click', listener1);\n+               button.addEventListener('click', listener2);\n+               button.addEventListener('click', listener3);\n+               button.addEventListener('click', listener4);\n+             });\n+\n+             const mouseEvent = document.createEvent('MouseEvent');\n+             mouseEvent.initEvent('click', true, true);\n+\n+             const unhandledRejection = (e: PromiseRejectionEvent) => {\n+               fail('should not be here');\n+             };\n+             window.addEventListener('unhandledrejection', unhandledRejection);\n+\n+             button.dispatchEvent(mouseEvent);\n+             expect(logs).toEqual([\n+               'listener1', 'zone handled error test1', 'zone handled error test2', 'listener2'\n+             ]);\n+\n+             setTimeout(() => {\n+               expect(logs).toEqual([\n+                 'listener1', 'zone handled error test1', 'zone handled error test2', 'listener2'\n+               ]);\n+               window.removeEventListener('unhandledrejection', unhandledRejection);\n+               window.onerror = oriWindowOnError;\n+               done();\n+             });\n+           } catch (e: any) {\n+             window.onerror = oriWindowOnError;\n+           }\n+         });\n+\n+      it('should be able to continue to invoke remaining listeners even some listener throw error in the different zones',\n+         function(done: DoneFn) {\n+           // override global.onerror to prevent jasmine report error\n+           let oriWindowOnError = window.onerror;\n+           let logs: string[] = [];\n+           window.onerror = function(err: any) {\n+             logs.push(err);\n+           };\n+           try {\n              const zone1 = Zone.current.fork({\n                name: 'zone1',\n                onHandleError: (delegate, curr, target, error) => {\n@@ -2580,18 +2723,18 @@ describe('Zone', function() {\n              mouseEvent.initEvent('click', true, true);\n \n              const unhandledRejection = (e: PromiseRejectionEvent) => {\n-               logs.push(e.reason.message);\n+               fail('should not be here');\n              };\n              window.addEventListener('unhandledrejection', unhandledRejection);\n \n              button.dispatchEvent(mouseEvent);\n-             expect(logs).toEqual(['listener1', 'test1', 'listener2']);\n+             expect(logs).toEqual(['listener1', 'test1', 'listener2', 'Uncaught Error: test2']);\n \n              setTimeout(() => {\n-               expect(logs).toEqual(['listener1', 'test1', 'listener2', 'test2']);\n+               expect(logs).toEqual(['listener1', 'test1', 'listener2', 'Uncaught Error: test2']);\n                window.removeEventListener('unhandledrejection', unhandledRejection);\n                window.onerror = oriWindowOnError;\n-               done()\n+               done();\n              });\n            } catch (e: any) {\n              window.onerror = oriWindowOnError;"
        }
    ],
    "stats": {
        "total": 179,
        "additions": 165,
        "deletions": 14
    }
}