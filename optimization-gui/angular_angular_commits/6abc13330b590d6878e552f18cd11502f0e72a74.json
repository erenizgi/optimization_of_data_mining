{
    "author": "crisbeto",
    "message": "fix(compiler): don't report parse error for interpolation inside string in property binding (#40267)\n\nCurrently we check whether a property binding contains an interpolation using a regex so\nthat we can throw an error. The problem is that the regex doesn't account for quotes\nwhich means that something like `[prop]=\"'{{ foo }}'\"` will be considered an error, even\nthough it's not actually an interpolation.\n\nThese changes build on top of the logic from #39826 to account for interpolation\ncharacters inside quotes.\n\nFixes #39601.\n\nPR Close #40267",
    "sha": "6abc13330b590d6878e552f18cd11502f0e72a74",
    "files": [
        {
            "sha": "fc386e7ebfc4b1e2dc0817187032120fede36394",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 45,
            "deletions": 48,
            "changes": 93,
            "blob_url": "https://github.com/angular/angular/blob/6abc13330b590d6878e552f18cd11502f0e72a74/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/6abc13330b590d6878e552f18cd11502f0e72a74/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=6abc13330b590d6878e552f18cd11502f0e72a74",
            "patch": "@@ -8,7 +8,6 @@\n \n import * as chars from '../chars';\n import {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\n-import {escapeRegExp} from '../util';\n \n import {AbsoluteSourceSpan, AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Chain, Conditional, EmptyExpr, ExpressionBinding, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, MethodCall, NonNullAssert, ParserError, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, Quote, RecursiveAstVisitor, SafeMethodCall, SafePropertyRead, TemplateBinding, TemplateBindingIdentifier, ThisReceiver, Unary, VariableBinding} from './ast';\n import {EOF, isIdentifier, isQuote, Lexer, Token, TokenType} from './lexer';\n@@ -30,20 +29,6 @@ export class TemplateBindingParseResult {\n       public errors: ParserError[]) {}\n }\n \n-const defaultInterpolateRegExp = _createInterpolateRegExp(DEFAULT_INTERPOLATION_CONFIG);\n-function _getInterpolateRegExp(config: InterpolationConfig): RegExp {\n-  if (config === DEFAULT_INTERPOLATION_CONFIG) {\n-    return defaultInterpolateRegExp;\n-  } else {\n-    return _createInterpolateRegExp(config);\n-  }\n-}\n-\n-function _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n-  const pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n-  return new RegExp(pattern, 'g');\n-}\n-\n export class Parser {\n   private errors: ParserError[] = [];\n \n@@ -247,7 +232,7 @@ export class Parser {\n         // parse from starting {{ to ending }} while ignoring content inside quotes.\n         const fullStart = i;\n         const exprStart = fullStart + interpStart.length;\n-        const exprEnd = this._getExpressiondEndIndex(input, interpEnd, exprStart);\n+        const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n         if (exprEnd === -1) {\n           // Could not find the end of the interpolation; do not parse an expression.\n           // Instead we should extend the content on the last raw string.\n@@ -315,59 +300,71 @@ export class Parser {\n     return null;\n   }\n \n-  private _checkNoInterpolation(\n-      input: string, location: string, interpolationConfig: InterpolationConfig): void {\n-    const regexp = _getInterpolateRegExp(interpolationConfig);\n-    const parts = input.split(regexp);\n-    if (parts.length > 1) {\n+  private _checkNoInterpolation(input: string, location: string, {start, end}: InterpolationConfig):\n+      void {\n+    let startIndex = -1;\n+    let endIndex = -1;\n+\n+    for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n+      if (startIndex === -1) {\n+        if (input.startsWith(start)) {\n+          startIndex = charIndex;\n+        }\n+      } else {\n+        endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n+        if (endIndex > -1) {\n+          break;\n+        }\n+      }\n+    }\n+\n+    if (startIndex > -1 && endIndex > -1) {\n       this._reportError(\n-          `Got interpolation (${interpolationConfig.start}${\n-              interpolationConfig.end}) where expression was expected`,\n-          input,\n-          `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n-          location);\n+          `Got interpolation (${start}${end}) where expression was expected`, input,\n+          `at column ${startIndex} in`, location);\n     }\n   }\n \n-  private _findInterpolationErrorColumn(\n-      parts: string[], partInErrIdx: number, interpolationConfig: InterpolationConfig): number {\n-    let errLocation = '';\n-    for (let j = 0; j < partInErrIdx; j++) {\n-      errLocation += j % 2 === 0 ?\n-          parts[j] :\n-          `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n+  /**\n+   * Finds the index of the end of an interpolation expression\n+   * while ignoring comments and quoted content.\n+   */\n+  private _getInterpolationEndIndex(input: string, expressionEnd: string, start: number): number {\n+    for (const charIndex of this._forEachUnquotedChar(input, start)) {\n+      if (input.startsWith(expressionEnd, charIndex)) {\n+        return charIndex;\n+      }\n+\n+      // Nothing else in the expression matters after we've\n+      // hit a comment so look directly for the end token.\n+      if (input.startsWith('//', charIndex)) {\n+        return input.indexOf(expressionEnd, charIndex);\n+      }\n     }\n \n-    return errLocation.length;\n+    return -1;\n   }\n \n   /**\n-   * Finds the index of the end of an interpolation expression\n-   * while ignoring comments and quoted content.\n+   * Generator used to iterate over the character indexes of a string that are outside of quotes.\n+   * @param input String to loop through.\n+   * @param start Index within the string at which to start.\n    */\n-  private _getExpressiondEndIndex(input: string, expressionEnd: string, start: number): number {\n+  private * _forEachUnquotedChar(input: string, start: number) {\n     let currentQuote: string|null = null;\n     let escapeCount = 0;\n     for (let i = start; i < input.length; i++) {\n       const char = input[i];\n-      // Skip the characters inside quotes. Note that we only care about the\n-      // outer-most quotes matching up and we need to account for escape characters.\n+      // Skip the characters inside quotes. Note that we only care about the outer-most\n+      // quotes matching up and we need to account for escape characters.\n       if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&\n           escapeCount % 2 === 0) {\n         currentQuote = currentQuote === null ? char : null;\n       } else if (currentQuote === null) {\n-        if (input.startsWith(expressionEnd, i)) {\n-          return i;\n-        }\n-        // Nothing else in the expression matters after we've\n-        // hit a comment so look directly for the end token.\n-        if (input.startsWith('//', i)) {\n-          return input.indexOf(expressionEnd, i);\n-        }\n+        yield i;\n       }\n       escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n     }\n-    return -1;\n   }\n }\n "
        },
        {
            "sha": "9b613b7274e2126833f4c0add79f4621b0ffaf40",
            "filename": "packages/compiler/test/expression_parser/parser_spec.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/6abc13330b590d6878e552f18cd11502f0e72a74/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6abc13330b590d6878e552f18cd11502f0e72a74/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts?ref=6abc13330b590d6878e552f18cd11502f0e72a74",
            "patch": "@@ -314,6 +314,13 @@ describe('parser', () => {\n     it('should report when encountering interpolation', () => {\n       expectActionError('{{a()}}', 'Got interpolation ({{}}) where expression was expected');\n     });\n+\n+    it('should not report interpolation inside a string', () => {\n+      expect(parseAction(`\"{{a()}}\"`).errors).toEqual([]);\n+      expect(parseAction(`'{{a()}}'`).errors).toEqual([]);\n+      expect(parseAction(`\"{{a('\\\\\"')}}\"`).errors).toEqual([]);\n+      expect(parseAction(`'{{a(\"\\\\'\")}}'`).errors).toEqual([]);\n+    });\n   });\n \n   describe('parse spans', () => {\n@@ -486,6 +493,13 @@ describe('parser', () => {\n       expectBindingError('{{a.b}}', 'Got interpolation ({{}}) where expression was expected');\n     });\n \n+    it('should not report interpolation inside a string', () => {\n+      expect(parseBinding(`\"{{exp}}\"`).errors).toEqual([]);\n+      expect(parseBinding(`'{{exp}}'`).errors).toEqual([]);\n+      expect(parseBinding(`'{{\\\\\"}}'`).errors).toEqual([]);\n+      expect(parseBinding(`'{{\\\\'}}'`).errors).toEqual([]);\n+    });\n+\n     it('should parse conditional expression', () => {\n       checkBinding('a < b ? a : b');\n     });\n@@ -952,6 +966,13 @@ describe('parser', () => {\n           'Got interpolation ({{}}) where expression was expected');\n     });\n \n+    it('should not report interpolation inside a string', () => {\n+      expect(parseSimpleBinding(`\"{{exp}}\"`).errors).toEqual([]);\n+      expect(parseSimpleBinding(`'{{exp}}'`).errors).toEqual([]);\n+      expect(parseSimpleBinding(`'{{\\\\\"}}'`).errors).toEqual([]);\n+      expect(parseSimpleBinding(`'{{\\\\'}}'`).errors).toEqual([]);\n+    });\n+\n     it('should report when encountering field write', () => {\n       expectError(validate(parseSimpleBinding('a = b')), 'Bindings cannot contain assignments');\n     });"
        },
        {
            "sha": "fdf7ca9a4b3fa606b58edd08f662eb915eb81d09",
            "filename": "packages/core/test/acceptance/property_binding_spec.ts",
            "status": "modified",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/angular/angular/blob/6abc13330b590d6878e552f18cd11502f0e72a74/packages%2Fcore%2Ftest%2Facceptance%2Fproperty_binding_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6abc13330b590d6878e552f18cd11502f0e72a74/packages%2Fcore%2Ftest%2Facceptance%2Fproperty_binding_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Ftest%2Facceptance%2Fproperty_binding_spec.ts?ref=6abc13330b590d6878e552f18cd11502f0e72a74",
            "patch": "@@ -623,4 +623,26 @@ describe('property bindings', () => {\n          fixture.detectChanges();\n        }).not.toThrow();\n      });\n+\n+  it('should allow quoted binding syntax inside property binding', () => {\n+    @Component({template: `<span [id]=\"'{{ id }}'\"></span>`})\n+    class Comp {\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [Comp]});\n+    const fixture = TestBed.createComponent(Comp);\n+    fixture.detectChanges();\n+    expect(fixture.nativeElement.querySelector('span').id).toBe('{{ id }}');\n+  });\n+\n+  it('should allow quoted binding syntax with escaped quotes inside property binding', () => {\n+    @Component({template: `<span [id]=\"'{{ \\\\' }}'\"></span>`})\n+    class Comp {\n+    }\n+\n+    TestBed.configureTestingModule({declarations: [Comp]});\n+    const fixture = TestBed.createComponent(Comp);\n+    fixture.detectChanges();\n+    expect(fixture.nativeElement.querySelector('span').id).toBe('{{ \\' }}');\n+  });\n });"
        }
    ],
    "stats": {
        "total": 136,
        "additions": 88,
        "deletions": 48
    }
}