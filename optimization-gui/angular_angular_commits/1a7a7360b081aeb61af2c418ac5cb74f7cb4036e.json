{
    "author": "JoostK",
    "message": "fix(compiler): properly associate source spans for implicitly closed elements (#38126)\n\nHTML is very lenient when it comes to closing elements, so Angular's parser has\nrules that specify which elements are implicitly closed when closing a tag.\nThe parser keeps track of the nesting of tag names using a stack and parsing\na closing tag will pop as many elements off the stack as possible, provided\nthat the elements can be implicitly closed.\n\nFor example, consider the following templates:\n\n- `<div><br></div>`, the `<br>` is implicitly closed when parsing `</div>`,\n  because `<br>` is a void element.\n- `<div><p></div>`, the `<p>` is implicitly closed when parsing `</div>`,\n  as `<p>` is allowed to be closed by the closing of its parent element.\n- `<ul><li>A <li>B</ul>`, the first `<li>` is implicitly closed when parsing\n  the second `<li>`, whereas the second `<li>` would be implicitly closed when\n  parsing the `</ul>`.\n\nIn all the cases above the parsed structure would be correct, however the source\nspan of the closing `</div>` would incorrectly be assigned to the element that\nis implicitly closed. The problem was that closing an element would associate\nthe source span with the element at the top of the stack, however this may not\nbe the element that is actually being closed if some elements would be\nimplicitly closed.\n\nThis commit fixes the issue by assigning the end source span with the element\non the stack that is actually being closed. Any implicitly closed elements that\nare popped off the stack will not be assigned an end source span, as the\nimplicit closing implies that no ending element is present.\n\nNote that there is a difference between self-closed elements such as `<input/>`\nand implicitly closed elements such as `<input>`. The former does have an end\nsource span (identical to its start source span) whereas the latter does not.\n\nFixes #36118\nResolves FW-2004\n\nPR Close #38126",
    "sha": "1a7a7360b081aeb61af2c418ac5cb74f7cb4036e",
    "files": [
        {
            "sha": "b31db0c25cfc0f2ad8d1c374494a838e5e3257f4",
            "filename": "packages/compiler/src/ml_parser/parser.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 8,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/1a7a7360b081aeb61af2c418ac5cb74f7cb4036e/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/1a7a7360b081aeb61af2c418ac5cb74f7cb4036e/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts?ref=1a7a7360b081aeb61af2c418ac5cb74f7cb4036e",
            "patch": "@@ -261,8 +261,9 @@ class _TreeBuilder {\n     const el = new html.Element(fullName, attrs, [], span, span, undefined);\n     this._pushElement(el);\n     if (selfClosing) {\n-      this._popElement(fullName);\n-      el.endSourceSpan = span;\n+      // Elements that are self-closed have their `endSourceSpan` set to the full span, as the\n+      // element start tag also represents the end tag.\n+      this._popElement(fullName, span);\n     }\n   }\n \n@@ -281,25 +282,26 @@ class _TreeBuilder {\n     const fullName = this._getElementFullName(\n         endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n \n-    if (this._getParentElement()) {\n-      this._getParentElement()!.endSourceSpan = endTagToken.sourceSpan;\n-    }\n-\n     if (this.getTagDefinition(fullName).isVoid) {\n       this.errors.push(TreeError.create(\n           fullName, endTagToken.sourceSpan,\n           `Void elements do not have end tags \"${endTagToken.parts[1]}\"`));\n-    } else if (!this._popElement(fullName)) {\n+    } else if (!this._popElement(fullName, endTagToken.sourceSpan)) {\n       const errMsg = `Unexpected closing tag \"${\n           fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n       this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n     }\n   }\n \n-  private _popElement(fullName: string): boolean {\n+  private _popElement(fullName: string, endSourceSpan: ParseSourceSpan): boolean {\n     for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n       const el = this._elementStack[stackIndex];\n       if (el.name == fullName) {\n+        // Record the parse span with the element that is being closed. Any elements that are\n+        // removed from the element stack at this point are closed implicitly, so they won't get\n+        // an end source span (as there is no explicit closing element).\n+        el.endSourceSpan = endSourceSpan;\n+\n         this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n         return true;\n       }"
        },
        {
            "sha": "10060905bb253c92c26cb3addfaffe24ded75696",
            "filename": "packages/compiler/test/ml_parser/ast_spec_utils.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/1a7a7360b081aeb61af2c418ac5cb74f7cb4036e/packages%2Fcompiler%2Ftest%2Fml_parser%2Fast_spec_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/1a7a7360b081aeb61af2c418ac5cb74f7cb4036e/packages%2Fcompiler%2Ftest%2Fml_parser%2Fast_spec_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fml_parser%2Fast_spec_utils.ts?ref=1a7a7360b081aeb61af2c418ac5cb74f7cb4036e",
            "patch": "@@ -41,6 +41,10 @@ class _Humanizer implements html.Visitor {\n \n   visitElement(element: html.Element, context: any): any {\n     const res = this._appendContext(element, [html.Element, element.name, this.elDepth++]);\n+    if (this.includeSourceSpan) {\n+      res.push(element.startSourceSpan?.toString() ?? null);\n+      res.push(element.endSourceSpan?.toString() ?? null);\n+    }\n     this.result.push(res);\n     html.visitAll(this, element.attrs);\n     html.visitAll(this, element.children);"
        },
        {
            "sha": "af167cba9410f053ad0f24fb9617542a6eaefcd4",
            "filename": "packages/compiler/test/ml_parser/html_parser_spec.ts",
            "status": "modified",
            "additions": 54,
            "deletions": 2,
            "changes": 56,
            "blob_url": "https://github.com/angular/angular/blob/1a7a7360b081aeb61af2c418ac5cb74f7cb4036e/packages%2Fcompiler%2Ftest%2Fml_parser%2Fhtml_parser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/1a7a7360b081aeb61af2c418ac5cb74f7cb4036e/packages%2Fcompiler%2Ftest%2Fml_parser%2Fhtml_parser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fml_parser%2Fhtml_parser_spec.ts?ref=1a7a7360b081aeb61af2c418ac5cb74f7cb4036e",
            "patch": "@@ -583,7 +583,10 @@ import {humanizeDom, humanizeDomSourceSpans, humanizeLineColumn} from './ast_spe\n           expect(humanizeDomSourceSpans(parser.parse(\n                      '<div [prop]=\"v1\" (e)=\"do()\" attr=\"v2\" noValue>\\na\\n</div>', 'TestComp')))\n               .toEqual([\n-                [html.Element, 'div', 0, '<div [prop]=\"v1\" (e)=\"do()\" attr=\"v2\" noValue>'],\n+                [\n+                  html.Element, 'div', 0, '<div [prop]=\"v1\" (e)=\"do()\" attr=\"v2\" noValue>',\n+                  '<div [prop]=\"v1\" (e)=\"do()\" attr=\"v2\" noValue>', '</div>'\n+                ],\n                 [html.Attribute, '[prop]', 'v1', '[prop]=\"v1\"'],\n                 [html.Attribute, '(e)', 'do()', '(e)=\"do()\"'],\n                 [html.Attribute, 'attr', 'v2', 'attr=\"v2\"'],\n@@ -602,12 +605,61 @@ import {humanizeDom, humanizeDomSourceSpans, humanizeLineColumn} from './ast_spe\n           expect(node.endSourceSpan!.end.offset).toEqual(12);\n         });\n \n+        it('should not set the end source span for void elements', () => {\n+          expect(humanizeDomSourceSpans(parser.parse('<div><br></div>', 'TestComp'))).toEqual([\n+            [html.Element, 'div', 0, '<div>', '<div>', '</div>'],\n+            [html.Element, 'br', 1, '<br>', '<br>', null],\n+          ]);\n+        });\n+\n+        it('should not set the end source span for multiple void elements', () => {\n+          expect(humanizeDomSourceSpans(parser.parse('<div><br><hr></div>', 'TestComp'))).toEqual([\n+            [html.Element, 'div', 0, '<div>', '<div>', '</div>'],\n+            [html.Element, 'br', 1, '<br>', '<br>', null],\n+            [html.Element, 'hr', 1, '<hr>', '<hr>', null],\n+          ]);\n+        });\n+\n+        it('should not set the end source span for standalone void elements', () => {\n+          expect(humanizeDomSourceSpans(parser.parse('<br>', 'TestComp'))).toEqual([\n+            [html.Element, 'br', 0, '<br>', '<br>', null],\n+          ]);\n+        });\n+\n+        it('should set the end source span for standalone self-closing elements', () => {\n+          expect(humanizeDomSourceSpans(parser.parse('<br/>', 'TestComp'))).toEqual([\n+            [html.Element, 'br', 0, '<br/>', '<br/>', '<br/>'],\n+          ]);\n+        });\n+\n+        it('should set the end source span for self-closing elements', () => {\n+          expect(humanizeDomSourceSpans(parser.parse('<div><br/></div>', 'TestComp'))).toEqual([\n+            [html.Element, 'div', 0, '<div>', '<div>', '</div>'],\n+            [html.Element, 'br', 1, '<br/>', '<br/>', '<br/>'],\n+          ]);\n+        });\n+\n+        it('should not set the end source span for elements that are implicitly closed', () => {\n+          expect(humanizeDomSourceSpans(parser.parse('<div><p></div>', 'TestComp'))).toEqual([\n+            [html.Element, 'div', 0, '<div>', '<div>', '</div>'],\n+            [html.Element, 'p', 1, '<p>', '<p>', null],\n+          ]);\n+          expect(humanizeDomSourceSpans(parser.parse('<div><li>A<li>B</div>', 'TestComp')))\n+              .toEqual([\n+                [html.Element, 'div', 0, '<div>', '<div>', '</div>'],\n+                [html.Element, 'li', 1, '<li>', '<li>', null],\n+                [html.Text, 'A', 2, 'A'],\n+                [html.Element, 'li', 1, '<li>', '<li>', null],\n+                [html.Text, 'B', 2, 'B'],\n+              ]);\n+        });\n+\n         it('should support expansion form', () => {\n           expect(humanizeDomSourceSpans(parser.parse(\n                      '<div>{count, plural, =0 {msg}}</div>', 'TestComp',\n                      {tokenizeExpansionForms: true})))\n               .toEqual([\n-                [html.Element, 'div', 0, '<div>'],\n+                [html.Element, 'div', 0, '<div>', '<div>', '</div>'],\n                 [html.Expansion, 'count', 'plural', 1, '{count, plural, =0 {msg}}'],\n                 [html.ExpansionCase, '=0', 2, '=0 {msg}'],\n               ]);"
        }
    ],
    "stats": {
        "total": 78,
        "additions": 68,
        "deletions": 10
    }
}