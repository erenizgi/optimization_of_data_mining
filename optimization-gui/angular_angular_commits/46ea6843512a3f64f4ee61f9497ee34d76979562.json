{
    "author": "atscott",
    "message": "refactor(compiler-cli): find symbol for output when there is a two way binding (#40185)\n\nThis commit fixes the Template Type Checker's `getSymbolOfNode` so that\nit is able to retrieve a symbol for the `BoundEvent` of a two-way\nbinding. Previously, the implementation would locate the node in the TCB\nfor the input because it appeared first and shares the same `keySpan` as\nthe event binding. To fix this, the TCB node search now verifies that\nthe located node matches the expected name for the output subscription:\neither `addEventListener` for a native listener  or the class member of the Angular `@Output`\nin the case of an Angular output, as would be the case for two-way\nbindings.\n\nPR Close #40185",
    "sha": "46ea6843512a3f64f4ee61f9497ee34d76979562",
    "files": [
        {
            "sha": "c509777c494e678b9f3d1c5f9cca3ea1c6a80735",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 35,
            "deletions": 10,
            "changes": 45,
            "blob_url": "https://github.com/angular/angular/blob/46ea6843512a3f64f4ee61f9497ee34d76979562/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/46ea6843512a3f64f4ee61f9497ee34d76979562/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=46ea6843512a3f64f4ee61f9497ee34d76979562",
            "patch": "@@ -168,24 +168,49 @@ export class SymbolBuilder {\n   }\n \n   private getSymbolOfBoundEvent(eventBinding: TmplAstBoundEvent): OutputBindingSymbol|null {\n+    const consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);\n+    if (consumer === null) {\n+      return null;\n+    }\n+\n     // Outputs in the TCB look like one of the two:\n     // * _outputHelper(_t1[\"outputField\"]).subscribe(handler);\n     // * _t1.addEventListener(handler);\n     // Even with strict null checks disabled, we still produce the access as a separate statement\n     // so that it can be found here.\n-    const outputFieldAccesses = findAllMatchingNodes(\n-        this.typeCheckBlock, {withSpan: eventBinding.keySpan, filter: isAccessExpression});\n+    let expectedAccess: string;\n+    if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n+      expectedAccess = 'addEventListener';\n+    } else {\n+      const bindingPropertyNames = consumer.outputs.getByBindingPropertyName(eventBinding.name);\n+      if (bindingPropertyNames === null || bindingPropertyNames.length === 0) {\n+        return null;\n+      }\n+      // Note that we only get the expectedAccess text from a single consumer of the binding. If\n+      // there are multiple consumers (not supported in the `boundTarget` API) and one of them has\n+      // an alias, it will not get matched here.\n+      expectedAccess = bindingPropertyNames[0].classPropertyName;\n+    }\n \n-    const bindings: BindingSymbol[] = [];\n-    for (const outputFieldAccess of outputFieldAccesses) {\n-      const consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);\n-      if (consumer === null) {\n-        continue;\n+    function filter(n: ts.Node): n is ts.PropertyAccessExpression|ts.ElementAccessExpression {\n+      if (!isAccessExpression(n)) {\n+        return false;\n       }\n \n+      if (ts.isPropertyAccessExpression(n)) {\n+        return n.name.getText() === expectedAccess;\n+      } else {\n+        return ts.isStringLiteral(n.argumentExpression) &&\n+            n.argumentExpression.text === expectedAccess;\n+      }\n+    }\n+    const outputFieldAccesses =\n+        findAllMatchingNodes(this.typeCheckBlock, {withSpan: eventBinding.keySpan, filter});\n+\n+    const bindings: BindingSymbol[] = [];\n+    for (const outputFieldAccess of outputFieldAccesses) {\n       if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n-        if (!ts.isPropertyAccessExpression(outputFieldAccess) ||\n-            outputFieldAccess.name.text !== 'addEventListener') {\n+        if (!ts.isPropertyAccessExpression(outputFieldAccess)) {\n           continue;\n         }\n \n@@ -233,10 +258,10 @@ export class SymbolBuilder {\n         });\n       }\n     }\n+\n     if (bindings.length === 0) {\n       return null;\n     }\n-\n     return {kind: SymbolKind.Output, bindings};\n   }\n "
        },
        {
            "sha": "a70c8bd09c169aa489baa7106217f65feccbc9e2",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 49,
            "deletions": 0,
            "changes": 49,
            "blob_url": "https://github.com/angular/angular/blob/46ea6843512a3f64f4ee61f9497ee34d76979562/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/46ea6843512a3f64f4ee61f9497ee34d76979562/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=46ea6843512a3f64f4ee61f9497ee34d76979562",
            "patch": "@@ -1348,6 +1348,55 @@ runInEachFileSystem(() => {\n                    .parent.name?.text)\n             .toEqual('TestDir');\n       });\n+\n+\n+      it('returns output symbol for two way binding', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const dirFile = absoluteFrom('/dir.ts');\n+        const {program, templateTypeChecker} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': `<div dir [(ngModel)]=\"value\"></div>`},\n+            source: `\n+                export class Cmp {\n+                  value = '';\n+                }`,\n+            declarations: [\n+              {\n+                name: 'TestDir',\n+                selector: '[dir]',\n+                file: dirFile,\n+                type: 'directive',\n+                inputs: {ngModel: 'ngModel'},\n+                outputs: {ngModelChange: 'ngModelChange'},\n+              },\n+            ]\n+          },\n+          {\n+            fileName: dirFile,\n+            source: `\n+                export class TestDir {\n+                  ngModel!: string;\n+                  ngModelChange!: EventEmitter<string>;\n+                }`,\n+            templates: {},\n+          }\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+\n+        const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+        const outputABinding = (nodes[0] as TmplAstElement).outputs[0];\n+        const symbol = templateTypeChecker.getSymbolOfNode(outputABinding, cmp)!;\n+        assertOutputBindingSymbol(symbol);\n+        expect(\n+            (symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration).name.getText())\n+            .toEqual('ngModelChange');\n+        expect((symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration)\n+                   .parent.name?.text)\n+            .toEqual('TestDir');\n+      });\n     });\n \n     describe('for elements', () => {"
        }
    ],
    "stats": {
        "total": 94,
        "additions": 84,
        "deletions": 10
    }
}