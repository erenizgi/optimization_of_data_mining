{
    "author": "atscott",
    "message": "refactor(language-service): Allow \"go to definition\" for directives in Ivy (#39228)\n\nFor directives/components, it would be generally more appropriate for\n\"go to type definition\" to be the function which navigates to the class\ndefinition. However, for a better user experience, we should do this\nfor \"go to definition\" as well.\n\nPR Close #39228",
    "sha": "437e5635072a7b3259b612055761955ab12d32af",
    "files": [
        {
            "sha": "7de4ecc63a9f6ee6a54a8008818fe16c0e51007a",
            "filename": "packages/language-service/ivy/definitions.ts",
            "status": "modified",
            "additions": 27,
            "deletions": 20,
            "changes": 47,
            "blob_url": "https://github.com/angular/angular/blob/437e5635072a7b3259b612055761955ab12d32af/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "raw_url": "https://github.com/angular/angular/raw/437e5635072a7b3259b612055761955ab12d32af/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fdefinitions.ts?ref=437e5635072a7b3259b612055761955ab12d32af",
            "patch": "@@ -8,7 +8,7 @@\n \n import {AST, TmplAstNode, TmplAstTextAttribute} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n-import {ShimLocation, Symbol, SymbolKind} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n+import {DirectiveSymbol, DomBindingSymbol, ElementSymbol, ShimLocation, Symbol, SymbolKind, TemplateSymbol} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript';\n \n import {findNodeAtPosition} from './hybrid_visitor';\n@@ -52,17 +52,12 @@ export class DefinitionBuilder {\n       case SymbolKind.Element:\n       case SymbolKind.Template:\n       case SymbolKind.DomBinding:\n-        // `Template` and `Element` types should not return anything because their \"definitions\" are\n-        // the template locations themselves. Instead, `getTypeDefinitionAtPosition` should return\n-        // the directive class / native element interface. `Directive` would have similar reasoning,\n-        // though the `TemplateTypeChecker` only returns it as a list on `DomBinding`, `Element`, or\n-        // `Template` so it's really only here for switch case completeness (it wouldn't ever appear\n-        // here).\n-        //\n-        // `DomBinding` also does not return anything because the value assignment is internal to\n-        // the TCB. Again, `getTypeDefinitionAtPosition` could return a possible directive the\n-        // attribute binds to or the property in the native interface.\n-        return [];\n+        // Though it is generally more appropriate for the above symbol definitions to be\n+        // associated with \"type definitions\" since the location in the template is the\n+        // actual definition location, the better user experience would be to allow\n+        // LS users to \"go to definition\" on an item in the template that maps to a class and be\n+        // taken to the directive or HTML class.\n+        return this.getTypeDefinitionsForTemplateInstance(symbol, node);\n       case SymbolKind.Input:\n       case SymbolKind.Output:\n         return this.getDefinitionsForSymbols(...symbol.bindings);\n@@ -110,14 +105,32 @@ export class DefinitionBuilder {\n     }\n \n     const {symbol, node} = definitionMeta;\n+    switch (symbol.kind) {\n+      case SymbolKind.Directive:\n+      case SymbolKind.DomBinding:\n+      case SymbolKind.Element:\n+      case SymbolKind.Template:\n+        return this.getTypeDefinitionsForTemplateInstance(symbol, node);\n+      case SymbolKind.Output:\n+      case SymbolKind.Input:\n+        return this.getTypeDefinitionsForSymbols(...symbol.bindings);\n+      case SymbolKind.Reference:\n+      case SymbolKind.Expression:\n+      case SymbolKind.Variable:\n+        return this.getTypeDefinitionsForSymbols(symbol);\n+    }\n+  }\n+\n+  private getTypeDefinitionsForTemplateInstance(\n+      symbol: TemplateSymbol|ElementSymbol|DomBindingSymbol|DirectiveSymbol,\n+      node: AST|TmplAstNode): ts.DefinitionInfo[] {\n     switch (symbol.kind) {\n       case SymbolKind.Template: {\n         const matches = getDirectiveMatchesForElementTag(symbol.templateNode, symbol.directives);\n         return this.getTypeDefinitionsForSymbols(...matches);\n       }\n       case SymbolKind.Element: {\n-        const matches = getDirectiveMatchesForAttribute(\n-            symbol.templateNode.name, symbol.templateNode, symbol.directives);\n+        const matches = getDirectiveMatchesForElementTag(symbol.templateNode, symbol.directives);\n         // If one of the directive matches is a component, we should not include the native element\n         // in the results because it is replaced by the component.\n         return Array.from(matches).some(dir => dir.isComponent) ?\n@@ -132,13 +145,7 @@ export class DefinitionBuilder {\n             node.name, symbol.host.templateNode, symbol.host.directives);\n         return this.getTypeDefinitionsForSymbols(...dirs);\n       }\n-      case SymbolKind.Output:\n-      case SymbolKind.Input:\n-        return this.getTypeDefinitionsForSymbols(...symbol.bindings);\n-      case SymbolKind.Reference:\n       case SymbolKind.Directive:\n-      case SymbolKind.Expression:\n-      case SymbolKind.Variable:\n         return this.getTypeDefinitionsForSymbols(symbol);\n     }\n   }"
        },
        {
            "sha": "99313d23281467618a2e943480a7a916a92315cc",
            "filename": "packages/language-service/ivy/test/definitions_spec.ts",
            "status": "modified",
            "additions": 41,
            "deletions": 21,
            "changes": 62,
            "blob_url": "https://github.com/angular/angular/blob/437e5635072a7b3259b612055761955ab12d32af/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/437e5635072a7b3259b612055761955ab12d32af/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fdefinitions_spec.ts?ref=437e5635072a7b3259b612055761955ab12d32af",
            "patch": "@@ -22,12 +22,15 @@ describe('definitions', () => {\n   });\n \n   describe('elements', () => {\n-    it('should return nothing for native elements', () => {\n-      const {position} = service.overwriteInlineTemplate(APP_COMPONENT, `<butt¦on></button>`);\n-      const definitionAndBoundSpan = ngLS.getDefinitionAndBoundSpan(APP_COMPONENT, position);\n-      // The \"definition\" is this location itself so we should return nothing.\n-      // getTypeDefinitionAtPosition would return the HTMLButtonElement interface.\n-      expect(definitionAndBoundSpan!.definitions).toEqual([]);\n+    it('should work for native elements', () => {\n+      const defs = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<butt¦on></button>`,\n+        expectedSpanText: `<button></button>`,\n+      });\n+      expect(defs.length).toEqual(2);\n+      expect(defs[0].fileName).toContain('lib.dom.d.ts');\n+      expect(defs[0].contextSpan).toContain('interface HTMLButtonElement extends HTMLElement');\n+      expect(defs[1].contextSpan).toContain('declare var HTMLButtonElement');\n     });\n   });\n \n@@ -42,11 +45,13 @@ describe('definitions', () => {\n \n   describe('directives', () => {\n     it('should work for directives', () => {\n-      const definitions = getDefinitionsAndAssertBoundSpan({\n+      const defs = getDefinitionsAndAssertBoundSpan({\n         templateOverride: `<div string-model¦></div>`,\n         expectedSpanText: 'string-model',\n       });\n-      expect(definitions).toEqual([]);\n+      expect(defs.length).toEqual(1);\n+      expect(defs[0].contextSpan).toContain('@Directive');\n+      expect(defs[0].contextSpan).toContain('export class StringModel');\n     });\n \n     it('should work for components', () => {\n@@ -58,17 +63,25 @@ describe('definitions', () => {\n         templateOverride,\n         expectedSpanText: templateOverride.replace('¦', '').trim(),\n       });\n-      expect(definitions).toEqual([]);\n+      expect(definitions.length).toEqual(1);\n+\n+      expect(definitions.length).toEqual(1);\n+      expect(definitions[0].textSpan).toEqual('TestComponent');\n+      expect(definitions[0].contextSpan).toContain('@Component');\n     });\n \n-    it('should not return anything for structural directives where the key does not map to a binding',\n-       () => {\n-         const definitions = getDefinitionsAndAssertBoundSpan({\n-           templateOverride: `<div *¦ngFor=\"let item of heroes\"></div>`,\n-           expectedSpanText: 'ngFor',\n-         });\n-         expect(definitions).toEqual([]);\n-       });\n+    it('should work for structural directives', () => {\n+      const definitions = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<div *¦ngFor=\"let item of heroes\"></div>`,\n+        expectedSpanText: 'ngFor',\n+      });\n+      expect(definitions.length).toEqual(1);\n+      expect(definitions[0].fileName).toContain('ng_for_of.d.ts');\n+      expect(definitions[0].textSpan).toEqual('NgForOf');\n+      expect(definitions[0].contextSpan)\n+          .toContain(\n+              'export declare class NgForOf<T, U extends NgIterable<T> = NgIterable<T>> implements DoCheck');\n+    });\n \n     it('should return binding for structural directive where key maps to a binding', () => {\n       const definitions = getDefinitionsAndAssertBoundSpan({\n@@ -83,11 +96,18 @@ describe('definitions', () => {\n     });\n \n     it('should work for directives with compound selectors', () => {\n-      const definitions = getDefinitionsAndAssertBoundSpan({\n-        templateOverride: `<ng-template ngF¦or let-item [ngForOf]=\"items\">{{item}}</ng-template>`,\n-        expectedSpanText: 'ngFor',\n+      let defs = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<button com¦pound custom-button></button>`,\n+        expectedSpanText: 'compound',\n       });\n-      expect(definitions).toEqual([]);\n+      expect(defs.length).toEqual(1);\n+      expect(defs[0].contextSpan).toContain('export class CompoundCustomButtonDirective');\n+      defs = getDefinitionsAndAssertBoundSpan({\n+        templateOverride: `<button compound cu¦stom-button></button>`,\n+        expectedSpanText: 'custom-button',\n+      });\n+      expect(defs.length).toEqual(1);\n+      expect(defs[0].contextSpan).toContain('export class CompoundCustomButtonDirective');\n     });\n   });\n "
        }
    ],
    "stats": {
        "total": 109,
        "additions": 68,
        "deletions": 41
    }
}