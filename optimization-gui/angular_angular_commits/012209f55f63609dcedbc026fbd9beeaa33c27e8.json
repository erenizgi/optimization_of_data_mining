{
    "author": "AndrewKushnir",
    "message": "Revert \"refactor(router): clean up unnecessary flag in `restoreHistory` function\" (#43409)\n\nThis reverts commit 061a456e39c80691b7fd374d2af33a9f6a753197.\n\nPR Close #43409",
    "sha": "012209f55f63609dcedbc026fbd9beeaa33c27e8",
    "files": [
        {
            "sha": "9704039f78bc189eae46ff9c70ec8f2caf990957",
            "filename": "packages/router/src/router.ts",
            "status": "modified",
            "additions": 22,
            "deletions": 8,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/012209f55f63609dcedbc026fbd9beeaa33c27e8/packages%2Frouter%2Fsrc%2Frouter.ts",
            "raw_url": "https://github.com/angular/angular/raw/012209f55f63609dcedbc026fbd9beeaa33c27e8/packages%2Frouter%2Fsrc%2Frouter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Frouter%2Fsrc%2Frouter.ts?ref=012209f55f63609dcedbc026fbd9beeaa33c27e8",
            "patch": "@@ -883,11 +883,19 @@ export class Router {\n                            // AngularJS sync code which looks for a value here in order to determine\n                            // whether or not to handle a given popstate event or to leave it to the\n                            // Angular router.\n-                           this.resetUrlToCurrentUrlTree();\n+                           this.restoreHistory(t);\n+                           this.cancelNavigationTransition(t, cancelationReason);\n+                         } else {\n+                           // We cannot trigger a `location.historyGo` if the\n+                           // cancellation was due to a new navigation before the previous could\n+                           // complete. This is because `location.historyGo` triggers a `popstate`\n+                           // which would also trigger another navigation. Instead, treat this as a\n+                           // redirect and do not reset the state.\n+                           this.cancelNavigationTransition(t, cancelationReason);\n+                           // TODO(atscott): The same problem happens here with a fresh page load\n+                           // and a new navigation before that completes where we won't set a page\n+                           // id.\n                          }\n-                         // Note: Other `canceledNavigationResolution` strategies will not support\n-                         // the AngularJS use-case that's mentioned above.\n-                         this.cancelNavigationTransition(t, cancelationReason);\n                        }\n                        // currentNavigation should always be reset to null here. If navigation was\n                        // successful, lastSuccessfulTransition will have already been set. Therefore\n@@ -918,7 +926,7 @@ export class Router {\n                            // This is only applicable with initial navigation, so setting\n                            // `navigated` only when not redirecting resolves this scenario.\n                            this.navigated = true;\n-                           this.restoreHistory(t);\n+                           this.restoreHistory(t, true);\n                          }\n                          const navCancel = new NavigationCancel(\n                              t.id, this.serializeUrl(t.extractedUrl), e.message);\n@@ -955,7 +963,7 @@ export class Router {\n                          /* All other errors should reset to the router's internal URL reference to\n                           * the pre-error state. */\n                        } else {\n-                         this.restoreHistory(t);\n+                         this.restoreHistory(t, true);\n                          const navError =\n                              new NavigationError(t.id, this.serializeUrl(t.extractedUrl), e);\n                          eventsSubject.next(navError);\n@@ -1431,7 +1439,7 @@ export class Router {\n    * Performs the necessary rollback action to restore the browser URL to the\n    * state before the transition.\n    */\n-  private restoreHistory(t: NavigationTransition) {\n+  private restoreHistory(t: NavigationTransition, restoringFromCaughtError = false) {\n     if (this.canceledNavigationResolution === 'computed') {\n       const targetPagePosition = this.currentPageId - t.targetPageId;\n       // The navigator change the location before triggered the browser event,\n@@ -1459,7 +1467,13 @@ export class Router {\n         // there's no restoration needed.\n       }\n     } else if (this.canceledNavigationResolution === 'replace') {\n-      this.resetState(t);\n+      // TODO(atscott): It seems like we should _always_ reset the state here. It would be a no-op\n+      // for `deferred` navigations that haven't change the internal state yet because guards\n+      // reject. For 'eager' navigations, it seems like we also really should reset the state\n+      // because the navigation was cancelled. Investigate if this can be done by running TGP.\n+      if (restoringFromCaughtError) {\n+        this.resetState(t);\n+      }\n       this.resetUrlToCurrentUrlTree();\n     }\n   }"
        }
    ],
    "stats": {
        "total": 30,
        "additions": 22,
        "deletions": 8
    }
}