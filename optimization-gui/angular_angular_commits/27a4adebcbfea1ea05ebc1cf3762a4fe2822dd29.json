{
    "author": "petebacondarwin",
    "message": "refactor(compiler-cli): support namespaced references (#39346)\n\nThe compiler uses a `Reference` abstraction to refer to TS nodes\nthat it needs to refer to from other parts of the source. Such\nreferences keep track of any identifiers that represent the referenced\nnode.\n\nPrior to this commit, the compiler (and specifically `ReferenceEmitter`\nclasses) assumed that the reference identifiers are always free standing.\nIn other words a reference identifier would be an expression like\n`FooDirective` in the expression `class FooDirective {}`.\n\nBut in UMD/CommonJS source, a reference can actually refer to an \"exports\"\ndeclaration of the form `exports.FooDirective = ...`.\nIn such cases the `FooDirective` identifier is not free-standing\nsince it is part of a property access, so the `ReferenceEmitter`\nshould take this into account when emitting an expression that\nrefers to such a `Reference`.\n\nThis commit changes the `LocalIdentifierStrategy` reference emitter\nso that if the `node` being referenced is not a declaration itself and\nis in the current file, then it should be used directly, rather than\ntrying to use one of its identifiers.\n\nPR Close #39346",
    "sha": "27a4adebcbfea1ea05ebc1cf3762a4fe2822dd29",
    "files": [
        {
            "sha": "aa77bb1884af3e7903f51d28591f73154d018386",
            "filename": "packages/compiler-cli/src/ngtsc/imports/src/emitter.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/27a4adebcbfea1ea05ebc1cf3762a4fe2822dd29/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Femitter.ts",
            "raw_url": "https://github.com/angular/angular/raw/27a4adebcbfea1ea05ebc1cf3762a4fe2822dd29/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Femitter.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fimports%2Fsrc%2Femitter.ts?ref=27a4adebcbfea1ea05ebc1cf3762a4fe2822dd29",
            "patch": "@@ -104,13 +104,23 @@ export class ReferenceEmitter {\n  */\n export class LocalIdentifierStrategy implements ReferenceEmitStrategy {\n   emit(ref: Reference<ts.Node>, context: ts.SourceFile, importFlags: ImportFlags): Expression|null {\n+    const refSf = getSourceFile(ref.node);\n+\n     // If the emitter has specified ForceNewImport, then LocalIdentifierStrategy should not use a\n     // local identifier at all, *except* in the source file where the node is actually declared.\n-    if (importFlags & ImportFlags.ForceNewImport &&\n-        getSourceFile(ref.node) !== getSourceFile(context)) {\n+    if (importFlags & ImportFlags.ForceNewImport && refSf !== context) {\n       return null;\n     }\n \n+    // If referenced node is not an actual TS declaration (e.g. `class Foo` or `function foo() {}`,\n+    // etc) and it is in the current file then just use it directly.\n+    // This is important because the reference could be a property access (e.g. `exports.foo`). In\n+    // such a case, the reference's `identities` property would be `[foo]`, which would result in an\n+    // invalid emission of a free-standing `foo` identifier, rather than `exports.foo`.\n+    if (!isDeclaration(ref.node) && refSf === context) {\n+      return new WrappedNodeExpr(ref.node);\n+    }\n+\n     // A Reference can have multiple identities in different files, so it may already have an\n     // Identifier in the requested context file.\n     const identifier = ref.getIdentityIn(context);"
        }
    ],
    "stats": {
        "total": 14,
        "additions": 12,
        "deletions": 2
    }
}