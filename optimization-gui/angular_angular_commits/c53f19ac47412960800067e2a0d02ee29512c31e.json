{
    "author": "JiaLiPassion",
    "message": "refactor(zone.js): rename several internal apis in fake async zone spec (#39127)\n\nIn `FakeAsyncZoneSpec`, there are several variables and APIs to identify\ndifferent times, and the names are confusing, in this commit, they are\nrenamed for more clear understandings.\n\n1. currentTickTime, the tick millis advanced.\n2. getFakeBaseSystemTime(), return the fake base system time.\n3. setFakeBaseSystemTime(), set the fake base system time.\n4. getRealSystemTime(), get the underlying native system time.\n\nPR Close #39127",
    "sha": "c53f19ac47412960800067e2a0d02ee29512c31e",
    "files": [
        {
            "sha": "ff76d4a9753121c8a2eac79b79e511d20366c0e8",
            "filename": "packages/zone.js/lib/jasmine/jasmine.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/c53f19ac47412960800067e2a0d02ee29512c31e/packages%2Fzone.js%2Flib%2Fjasmine%2Fjasmine.ts",
            "raw_url": "https://github.com/angular/angular/raw/c53f19ac47412960800067e2a0d02ee29512c31e/packages%2Fzone.js%2Flib%2Fjasmine%2Fjasmine.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Flib%2Fjasmine%2Fjasmine.ts?ref=c53f19ac47412960800067e2a0d02ee29512c31e",
            "patch": "@@ -127,7 +127,7 @@ Zone.__load_patch('jasmine', (global: any, Zone: ZoneType, api: _ZonePrivate) =>\n           const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n           if (fakeAsyncZoneSpec) {\n             const dateTime = arguments.length > 0 ? arguments[0] : new Date();\n-            return fakeAsyncZoneSpec.setCurrentRealTime.apply(\n+            return fakeAsyncZoneSpec.setFakeBaseSystemTime.apply(\n                 fakeAsyncZoneSpec,\n                 dateTime && typeof dateTime.getTime === 'function' ? [dateTime.getTime()] :\n                                                                      arguments);"
        },
        {
            "sha": "38fe1129d32f01819b1e3bfddd23fcd46ca6b359",
            "filename": "packages/zone.js/lib/jest/jest.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/c53f19ac47412960800067e2a0d02ee29512c31e/packages%2Fzone.js%2Flib%2Fjest%2Fjest.ts",
            "raw_url": "https://github.com/angular/angular/raw/c53f19ac47412960800067e2a0d02ee29512c31e/packages%2Fzone.js%2Flib%2Fjest%2Fjest.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Flib%2Fjest%2Fjest.ts?ref=c53f19ac47412960800067e2a0d02ee29512c31e",
            "patch": "@@ -188,7 +188,7 @@ Zone.__load_patch('jest', (context: any, Zone: ZoneType, api: _ZonePrivate) => {\n       return function(self: any, args: any[]) {\n         const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n         if (fakeAsyncZoneSpec && isPatchingFakeTimer()) {\n-          fakeAsyncZoneSpec.setCurrentRealTime(args[0]);\n+          fakeAsyncZoneSpec.setFakeBaseSystemTime(args[0]);\n         } else {\n           return delegate.apply(self, args);\n         }"
        },
        {
            "sha": "b7ef385c3076c7fe7653f0ee9d25bfcc5fa1e03a",
            "filename": "packages/zone.js/lib/zone-spec/fake-async-test.ts",
            "status": "modified",
            "additions": 38,
            "deletions": 39,
            "changes": 77,
            "blob_url": "https://github.com/angular/angular/blob/c53f19ac47412960800067e2a0d02ee29512c31e/packages%2Fzone.js%2Flib%2Fzone-spec%2Ffake-async-test.ts",
            "raw_url": "https://github.com/angular/angular/raw/c53f19ac47412960800067e2a0d02ee29512c31e/packages%2Fzone.js%2Flib%2Fzone-spec%2Ffake-async-test.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Flib%2Fzone-spec%2Ffake-async-test.ts?ref=c53f19ac47412960800067e2a0d02ee29512c31e",
            "patch": "@@ -45,16 +45,15 @@ function FakeDate() {\n   }\n }\n \n-FakeDate.now =\n-    function(this: unknown) {\n+FakeDate.now = function(this: unknown) {\n   const fakeAsyncTestZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n   if (fakeAsyncTestZoneSpec) {\n-    return fakeAsyncTestZoneSpec.getCurrentRealTime() + fakeAsyncTestZoneSpec.getCurrentTime();\n+    return fakeAsyncTestZoneSpec.getFakeSystemTime();\n   }\n   return OriginalDate.now.apply(this, arguments);\n-}\n+};\n \n-    FakeDate.UTC = OriginalDate.UTC;\n+FakeDate.UTC = OriginalDate.UTC;\n FakeDate.parse = OriginalDate.parse;\n \n // keep a reference for zone patched timer function\n@@ -72,24 +71,24 @@ class Scheduler {\n   // Scheduler queue with the tuple of end time and callback function - sorted by end time.\n   private _schedulerQueue: ScheduledFunction[] = [];\n   // Current simulated time in millis.\n-  private _currentTime: number = 0;\n-  // Current real time in millis.\n-  private _currentRealTime: number = OriginalDate.now();\n+  private _currentTickTime: number = 0;\n+  // Current fake system base time in millis.\n+  private _currentFakeBaseSystemTime: number = OriginalDate.now();\n   // track requeuePeriodicTimer\n   private _currentTickRequeuePeriodicEntries: any[] = [];\n \n   constructor() {}\n \n-  getCurrentTime() {\n-    return this._currentTime;\n+  getCurrentTickTime() {\n+    return this._currentTickTime;\n   }\n \n-  getCurrentRealTime() {\n-    return this._currentRealTime;\n+  getFakeSystemTime() {\n+    return this._currentFakeBaseSystemTime + this._currentTickTime;\n   }\n \n-  setCurrentRealTime(realTime: number) {\n-    this._currentRealTime = realTime;\n+  setFakeBaseSystemTime(fakeBaseSystemTime: number) {\n+    this._currentFakeBaseSystemTime = fakeBaseSystemTime;\n   }\n \n   getRealSystemTime() {\n@@ -114,7 +113,7 @@ class Scheduler {\n       ...options\n     };\n     let currentId = options.id! < 0 ? Scheduler.nextId++ : options.id!;\n-    let endTime = this._currentTime + delay;\n+    let endTime = this._currentTickTime + delay;\n \n     // Insert so that scheduler queue remains sorted by end time.\n     let newEntry: ScheduledFunction = {\n@@ -165,15 +164,15 @@ class Scheduler {\n     }\n     // Find the last task currently queued in the scheduler queue and tick\n     // till that time.\n-    const startTime = this._currentTime;\n+    const startTime = this._currentTickTime;\n     const targetTask = this._schedulerQueue[step - 1];\n     this.tick(targetTask.endTime - startTime, doTick, tickOptions);\n   }\n \n   tick(millis: number = 0, doTick?: (elapsed: number) => void, tickOptions?: {\n     processNewMacroTasksSynchronously: boolean\n   }): void {\n-    let finalTime = this._currentTime + millis;\n+    let finalTime = this._currentTickTime + millis;\n     let lastCurrentTime = 0;\n     tickOptions = Object.assign({processNewMacroTasksSynchronously: true}, tickOptions);\n     // we need to copy the schedulerQueue so nested timeout\n@@ -202,13 +201,13 @@ class Scheduler {\n             this._schedulerQueue.splice(idx, 1);\n           }\n         }\n-        lastCurrentTime = this._currentTime;\n-        this._currentTime = current.endTime;\n+        lastCurrentTime = this._currentTickTime;\n+        this._currentTickTime = current.endTime;\n         if (doTick) {\n-          doTick(this._currentTime - lastCurrentTime);\n+          doTick(this._currentTickTime - lastCurrentTime);\n         }\n         let retval = current.func.apply(\n-            global, current.isRequestAnimationFrame ? [this._currentTime] : current.args);\n+            global, current.isRequestAnimationFrame ? [this._currentTickTime] : current.args);\n         if (!retval) {\n           // Uncaught exception in the current scheduled function. Stop processing the queue.\n           break;\n@@ -230,10 +229,10 @@ class Scheduler {\n         }\n       }\n     }\n-    lastCurrentTime = this._currentTime;\n-    this._currentTime = finalTime;\n+    lastCurrentTime = this._currentTickTime;\n+    this._currentTickTime = finalTime;\n     if (doTick) {\n-      doTick(this._currentTime - lastCurrentTime);\n+      doTick(this._currentTickTime - lastCurrentTime);\n     }\n   }\n \n@@ -243,10 +242,10 @@ class Scheduler {\n     }\n     // Find the last task currently queued in the scheduler queue and tick\n     // till that time.\n-    const startTime = this._currentTime;\n+    const startTime = this._currentTickTime;\n     const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n     this.tick(lastTask.endTime - startTime, doTick, {processNewMacroTasksSynchronously: false});\n-    return this._currentTime - startTime;\n+    return this._currentTickTime - startTime;\n   }\n \n   flush(limit = 20, flushPeriodic = false, doTick?: (elapsed: number) => void): number {\n@@ -263,14 +262,14 @@ class Scheduler {\n     }\n     // Find the last task currently queued in the scheduler queue and tick\n     // till that time.\n-    const startTime = this._currentTime;\n+    const startTime = this._currentTickTime;\n     const lastTask = this._schedulerQueue[this._schedulerQueue.length - 1];\n     this.tick(lastTask.endTime - startTime, doTick);\n-    return this._currentTime - startTime;\n+    return this._currentTickTime - startTime;\n   }\n \n   private flushNonPeriodic(limit: number, doTick?: (elapsed: number) => void): number {\n-    const startTime = this._currentTime;\n+    const startTime = this._currentTickTime;\n     let lastCurrentTime = 0;\n     let count = 0;\n     while (this._schedulerQueue.length > 0) {\n@@ -289,19 +288,19 @@ class Scheduler {\n       }\n \n       const current = this._schedulerQueue.shift()!;\n-      lastCurrentTime = this._currentTime;\n-      this._currentTime = current.endTime;\n+      lastCurrentTime = this._currentTickTime;\n+      this._currentTickTime = current.endTime;\n       if (doTick) {\n         // Update any secondary schedulers like Jasmine mock Date.\n-        doTick(this._currentTime - lastCurrentTime);\n+        doTick(this._currentTickTime - lastCurrentTime);\n       }\n       const retval = current.func.apply(global, current.args);\n       if (!retval) {\n         // Uncaught exception in the current scheduled function. Stop processing the queue.\n         break;\n       }\n     }\n-    return this._currentTime - startTime;\n+    return this._currentTickTime - startTime;\n   }\n }\n \n@@ -426,16 +425,16 @@ class FakeAsyncTestZoneSpec implements ZoneSpec {\n     throw error;\n   }\n \n-  getCurrentTime() {\n-    return this._scheduler.getCurrentTime();\n+  getCurrentTickTime() {\n+    return this._scheduler.getCurrentTickTime();\n   }\n \n-  getCurrentRealTime() {\n-    return this._scheduler.getCurrentRealTime();\n+  getFakeSystemTime() {\n+    return this._scheduler.getFakeSystemTime();\n   }\n \n-  setCurrentRealTime(realTime: number) {\n-    this._scheduler.setCurrentRealTime(realTime);\n+  setFakeBaseSystemTime(realTime: number) {\n+    this._scheduler.setFakeBaseSystemTime(realTime);\n   }\n \n   getRealSystemTime() {"
        },
        {
            "sha": "77ebc6dbee4c35a1116d3a1b1ba120cbdb4f38a8",
            "filename": "packages/zone.js/test/jest/jest.spec.js",
            "status": "modified",
            "additions": 11,
            "deletions": 2,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/c53f19ac47412960800067e2a0d02ee29512c31e/packages%2Fzone.js%2Ftest%2Fjest%2Fjest.spec.js",
            "raw_url": "https://github.com/angular/angular/raw/c53f19ac47412960800067e2a0d02ee29512c31e/packages%2Fzone.js%2Ftest%2Fjest%2Fjest.spec.js",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fzone.js%2Ftest%2Fjest%2Fjest.spec.js?ref=c53f19ac47412960800067e2a0d02ee29512c31e",
            "patch": "@@ -125,14 +125,23 @@ describe('jest modern fakeTimers with zone.js fakeAsync', () => {\n     expect(typeof fakeAsyncZoneSpec.tick).toEqual('function');\n   });\n \n-  test('setSystemTime should set FakeDate.currentRealTime', () => {\n+  test('setSystemTime should set FakeDate.currentFakeTime', () => {\n     const fakeAsyncZoneSpec = Zone.current.get('FakeAsyncTestZoneSpec');\n-    const d = Date.now();\n+    let d = fakeAsyncZoneSpec.getRealSystemTime();\n     jest.setSystemTime(d);\n     expect(Date.now()).toEqual(d);\n     for (let i = 0; i < 100000; i++) {\n     }\n     expect(fakeAsyncZoneSpec.getRealSystemTime()).not.toEqual(d);\n+    d = fakeAsyncZoneSpec.getRealSystemTime();\n+    let timeoutTriggered = false;\n+    setTimeout(() => {\n+      timeoutTriggered = true;\n+    }, 100);\n+    jest.setSystemTime(d);\n+    tick(100);\n+    expect(timeoutTriggered).toBe(true);\n+    expect(Date.now()).toEqual(d + 100);\n   });\n \n   test('runAllTicks should run all microTasks', () => {"
        }
    ],
    "stats": {
        "total": 94,
        "additions": 51,
        "deletions": 43
    }
}