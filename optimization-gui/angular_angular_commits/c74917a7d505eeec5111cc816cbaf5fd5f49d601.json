{
    "author": "atscott",
    "message": "refactor(compiler-cli): update type checker symbols to include more information (#38844)\n\nThis commit updates the symbols in the TemplateTypeCheck API and methods\nfor retrieving them:\n\n* Include `isComponent` and `selector` for directives so callers can determine which\nattributes on an element map to the matched directives.\n* Add a new `TextAttributeSymbol` and return this when requesting a symbol for a `TextAttribute`.\n* When requesting a symbol for `PropertyWrite` and `MethodCall`, use the\n`nameSpan` to retrieve symbols.\n* Add fix to retrieve generic directives attached to elements/templates.\n\nPR Close #38844",
    "sha": "c74917a7d505eeec5111cc816cbaf5fd5f49d601",
    "files": [
        {
            "sha": "630980dc0df00373741dadc35d9a3f3a70036277",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/directive_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdirective_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdirective_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdirective_spec.ts?ref=c74917a7d505eeec5111cc816cbaf5fd5f49d601",
            "patch": "@@ -104,6 +104,7 @@ runInEachFileSystem(() => {\n         outputs: analysis.outputs,\n         isComponent: false,\n         name: 'Dir',\n+        selector: '[dir]',\n       };\n       matcher.addSelectables(CssSelector.parse('[dir]'), dirMeta);\n "
        },
        {
            "sha": "fd4fb7474903af2d14fab253acc22660864e5be0",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/api/symbols.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 1,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts",
            "raw_url": "https://github.com/angular/angular/raw/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fapi%2Fsymbols.ts?ref=c74917a7d505eeec5111cc816cbaf5fd5f49d601",
            "patch": "@@ -21,13 +21,14 @@ export enum SymbolKind {\n   Element,\n   Template,\n   Expression,\n+  DomBinding,\n }\n \n /**\n  * A representation of an entity in the `TemplateAst`.\n  */\n export type Symbol = InputBindingSymbol|OutputBindingSymbol|ElementSymbol|ReferenceSymbol|\n-    VariableSymbol|ExpressionSymbol|DirectiveSymbol|TemplateSymbol;\n+    VariableSymbol|ExpressionSymbol|DirectiveSymbol|TemplateSymbol|DomBindingSymbol;\n \n /** Information about where a `ts.Node` can be found in the type check block shim file. */\n export interface ShimLocation {\n@@ -227,4 +228,22 @@ export interface DirectiveSymbol {\n \n   /** The location in the shim file for the variable that holds the type of the directive. */\n   shimLocation: ShimLocation;\n+\n+  /** The selector for the `Directive` / `Component`. */\n+  selector: string|null;\n+\n+  /** `true` if this `DirectiveSymbol` is for a @Component. */\n+  isComponent: boolean;\n+}\n+\n+/**\n+ * A representation of an attribute on an element or template. These bindings aren't currently\n+ * type-checked (see `checkTypeOfDomBindings`) so they won't have a `ts.Type`, `ts.Symbol`, or shim\n+ * location.\n+ */\n+export interface DomBindingSymbol {\n+  kind: SymbolKind.DomBinding;\n+\n+  /** The symbol for the element or template of the text attribute. */\n+  host: ElementSymbol|TemplateSymbol;\n }"
        },
        {
            "sha": "6ce9b6ee8e8276222326d19d1ac72f9964f693df",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 91,
            "deletions": 49,
            "changes": 140,
            "blob_url": "https://github.com/angular/angular/blob/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=c74917a7d505eeec5111cc816cbaf5fd5f49d601",
            "patch": "@@ -6,18 +6,18 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AbsoluteSourceSpan, AST, ASTWithSource, BindingPipe, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\n+import {AST, ASTWithSource, BindingPipe, MethodCall, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {AbsoluteFsPath} from '../../file_system';\n import {isAssignment} from '../../util/src/typescript';\n-import {DirectiveSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, ReferenceSymbol, Symbol, SymbolKind, TemplateSymbol, TsNodeSymbolInfo, VariableSymbol} from '../api';\n+import {DirectiveSymbol, DomBindingSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, ReferenceSymbol, Symbol, SymbolKind, TemplateSymbol, TsNodeSymbolInfo, TypeCheckableDirectiveMeta, VariableSymbol} from '../api';\n \n import {ExpressionIdentifier, findAllMatchingNodes, findFirstMatchingNode, hasExpressionIdentifier} from './comments';\n import {TemplateData} from './context';\n+import {isAccessExpression} from './ts_util';\n import {TcbDirectiveOutputsOp} from './type_check_block';\n \n-\n /**\n  * A class which extracts information from a type check block.\n  * This class is essentially used as just a closure around the constructor parameters.\n@@ -31,7 +31,7 @@ export class SymbolBuilder {\n   getSymbol(node: TmplAstReference|TmplAstVariable): ReferenceSymbol|VariableSymbol|null;\n   getSymbol(node: AST|TmplAstNode): Symbol|null;\n   getSymbol(node: AST|TmplAstNode): Symbol|null {\n-    if (node instanceof TmplAstBoundAttribute) {\n+    if (node instanceof TmplAstBoundAttribute || node instanceof TmplAstTextAttribute) {\n       // TODO(atscott): input and output bindings only return the first directive match but should\n       // return a list of bindings for all of them.\n       return this.getSymbolOfInputBinding(node);\n@@ -85,24 +85,55 @@ export class SymbolBuilder {\n   private getDirectivesOfNode(element: TmplAstElement|TmplAstTemplate): DirectiveSymbol[] {\n     const elementSourceSpan = element.startSourceSpan ?? element.sourceSpan;\n     const tcbSourceFile = this.typeCheckBlock.getSourceFile();\n-    const isDirectiveDeclaration = (node: ts.Node): node is ts.TypeNode => ts.isTypeNode(node) &&\n+    // directives could be either:\n+    // - var _t1: TestDir /*T:D*/ = (null!);\n+    // - var _t1 /*T:D*/ = _ctor1({});\n+    const isDirectiveDeclaration = (node: ts.Node): node is ts.TypeNode|ts.Identifier =>\n+        (ts.isTypeNode(node) || ts.isIdentifier(node)) &&\n         hasExpressionIdentifier(tcbSourceFile, node, ExpressionIdentifier.DIRECTIVE);\n \n     const nodes = findAllMatchingNodes(\n         this.typeCheckBlock, {withSpan: elementSourceSpan, filter: isDirectiveDeclaration});\n     return nodes\n         .map(node => {\n-          const symbol = this.getSymbolOfTsNode(node);\n-          if (symbol === null || symbol.tsSymbol === null) {\n+          const symbol = (ts.isIdentifier(node) && ts.isVariableDeclaration(node.parent)) ?\n+              this.getSymbolOfVariableDeclaration(node.parent) :\n+              this.getSymbolOfTsNode(node);\n+          if (symbol === null || symbol.tsSymbol === null ||\n+              symbol.tsSymbol.declarations.length === 0) {\n+            return null;\n+          }\n+\n+          const meta = this.getDirectiveMeta(element, symbol.tsSymbol.declarations[0]);\n+          if (meta === null) {\n             return null;\n           }\n-          const directiveSymbol:\n-              DirectiveSymbol = {...symbol, tsSymbol: symbol.tsSymbol, kind: SymbolKind.Directive};\n+\n+          const selector = meta.selector ?? null;\n+          const isComponent = meta.isComponent ?? null;\n+          const directiveSymbol: DirectiveSymbol = {\n+            ...symbol,\n+            tsSymbol: symbol.tsSymbol,\n+            selector,\n+            isComponent,\n+            kind: SymbolKind.Directive\n+          };\n           return directiveSymbol;\n         })\n         .filter((d): d is DirectiveSymbol => d !== null);\n   }\n \n+  private getDirectiveMeta(\n+      host: TmplAstTemplate|TmplAstElement,\n+      directiveDeclaration: ts.Declaration): TypeCheckableDirectiveMeta|null {\n+    const directives = this.templateData.boundTarget.getDirectivesOfNode(host);\n+    if (directives === null) {\n+      return null;\n+    }\n+\n+    return directives.find(m => m.ref.node === directiveDeclaration) ?? null;\n+  }\n+\n   private getSymbolOfBoundEvent(eventBinding: TmplAstBoundEvent): OutputBindingSymbol|null {\n     // Outputs are a `ts.CallExpression` that look like one of the two:\n     // * _outputHelper(_t1[\"outputField\"]).subscribe(handler);\n@@ -114,7 +145,8 @@ export class SymbolBuilder {\n     }\n \n     const consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);\n-    if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n+    if (consumer === null || consumer instanceof TmplAstTemplate ||\n+        consumer instanceof TmplAstElement) {\n       // Bindings to element or template events produce `addEventListener` which\n       // we cannot get the field for.\n       return null;\n@@ -130,12 +162,12 @@ export class SymbolBuilder {\n     }\n \n \n-    const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess);\n+    const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess, consumer);\n     if (target === null) {\n       return null;\n     }\n \n-    const positionInShimFile = outputFieldAccess.argumentExpression.getStart();\n+    const positionInShimFile = this.getShimPositionForNode(outputFieldAccess);\n     const tsType = this.typeChecker.getTypeAtLocation(node);\n     return {\n       kind: SymbolKind.Output,\n@@ -149,58 +181,48 @@ export class SymbolBuilder {\n     };\n   }\n \n-  private getSymbolOfInputBinding(attributeBinding: TmplAstBoundAttribute): InputBindingSymbol\n-      |null {\n-    const node = findFirstMatchingNode(\n-        this.typeCheckBlock, {withSpan: attributeBinding.sourceSpan, filter: isAssignment});\n-    if (node === null) {\n+  private getSymbolOfInputBinding(binding: TmplAstBoundAttribute|\n+                                  TmplAstTextAttribute): InputBindingSymbol|DomBindingSymbol|null {\n+    const consumer = this.templateData.boundTarget.getConsumerOfBinding(binding);\n+    if (consumer === null) {\n       return null;\n     }\n \n-    let tsSymbol: ts.Symbol|undefined;\n-    let positionInShimFile: number|null = null;\n-    let tsType: ts.Type;\n-    if (ts.isElementAccessExpression(node.left)) {\n-      tsSymbol = this.typeChecker.getSymbolAtLocation(node.left.argumentExpression);\n-      positionInShimFile = node.left.argumentExpression.getStart();\n-      tsType = this.typeChecker.getTypeAtLocation(node.left.argumentExpression);\n-    } else if (ts.isPropertyAccessExpression(node.left)) {\n-      tsSymbol = this.typeChecker.getSymbolAtLocation(node.left.name);\n-      positionInShimFile = node.left.name.getStart();\n-      tsType = this.typeChecker.getTypeAtLocation(node.left.name);\n-    } else {\n-      return null;\n+    if (consumer instanceof TmplAstElement || consumer instanceof TmplAstTemplate) {\n+      const host = this.getSymbol(consumer);\n+      return host !== null ? {kind: SymbolKind.DomBinding, host} : null;\n     }\n-    if (tsSymbol === undefined || positionInShimFile === null) {\n+\n+    const node = findFirstMatchingNode(\n+        this.typeCheckBlock, {withSpan: binding.sourceSpan, filter: isAssignment});\n+    if (node === null || !isAccessExpression(node.left)) {\n       return null;\n     }\n \n-    const consumer = this.templateData.boundTarget.getConsumerOfBinding(attributeBinding);\n-    let target: ElementSymbol|TemplateSymbol|DirectiveSymbol|null;\n-    if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n-      target = this.getSymbol(consumer);\n-    } else {\n-      target = this.getDirectiveSymbolForAccessExpression(node.left);\n+    const symbolInfo = this.getSymbolOfTsNode(node.left);\n+    if (symbolInfo === null || symbolInfo.tsSymbol === null) {\n+      return null;\n     }\n \n+    const target = this.getDirectiveSymbolForAccessExpression(node.left, consumer);\n     if (target === null) {\n       return null;\n     }\n \n     return {\n       kind: SymbolKind.Input,\n       bindings: [{\n+        ...symbolInfo,\n+        tsSymbol: symbolInfo.tsSymbol,\n         kind: SymbolKind.Binding,\n-        tsSymbol,\n-        tsType,\n         target,\n-        shimLocation: {shimPath: this.shimPath, positionInShimFile},\n       }],\n     };\n   }\n \n-  private getDirectiveSymbolForAccessExpression(node: ts.ElementAccessExpression|\n-                                                ts.PropertyAccessExpression): DirectiveSymbol|null {\n+  private getDirectiveSymbolForAccessExpression(\n+      node: ts.ElementAccessExpression|ts.PropertyAccessExpression,\n+      {isComponent, selector}: TypeCheckableDirectiveMeta): DirectiveSymbol|null {\n     // In either case, `_t1[\"index\"]` or `_t1.index`, `node.expression` is _t1.\n     // The retrieved symbol for _t1 will be the variable declaration.\n     const tsSymbol = this.typeChecker.getSymbolAtLocation(node.expression);\n@@ -228,6 +250,8 @@ export class SymbolBuilder {\n       tsSymbol: symbol.tsSymbol,\n       tsType: symbol.tsType,\n       shimLocation: symbol.shimLocation,\n+      isComponent,\n+      selector,\n     };\n   }\n \n@@ -295,9 +319,14 @@ export class SymbolBuilder {\n       return this.getSymbol(expressionTarget);\n     }\n \n+    // The `name` part of a `PropertyWrite` and `MethodCall` does not have its own\n+    // AST so there is no way to retrieve a `Symbol` for just the `name` via a specific node.\n+    const withSpan = (expression instanceof PropertyWrite || expression instanceof MethodCall) ?\n+        expression.nameSpan :\n+        expression.sourceSpan;\n+\n     let node = findFirstMatchingNode(\n-        this.typeCheckBlock,\n-        {withSpan: expression.sourceSpan, filter: (n: ts.Node): n is ts.Node => true});\n+        this.typeCheckBlock, {withSpan, filter: (n: ts.Node): n is ts.Node => true});\n     if (node === null) {\n       return null;\n     }\n@@ -344,20 +373,20 @@ export class SymbolBuilder {\n     }\n \n     let tsSymbol: ts.Symbol|undefined;\n-    let positionInShimFile: number;\n     if (ts.isPropertyAccessExpression(node)) {\n       tsSymbol = this.typeChecker.getSymbolAtLocation(node.name);\n-      positionInShimFile = node.name.getStart();\n+    } else if (ts.isElementAccessExpression(node)) {\n+      tsSymbol = this.typeChecker.getSymbolAtLocation(node.argumentExpression);\n     } else {\n       tsSymbol = this.typeChecker.getSymbolAtLocation(node);\n-      positionInShimFile = node.getStart();\n     }\n \n+    const positionInShimFile = this.getShimPositionForNode(node);\n     const type = this.typeChecker.getTypeAtLocation(node);\n     return {\n       // If we could not find a symbol, fall back to the symbol on the type for the node.\n       // Some nodes won't have a \"symbol at location\" but will have a symbol for the type.\n-      // One example of this would be literals.\n+      // Examples of this would be literals and `document.createElement('div')`.\n       tsSymbol: tsSymbol ?? type.symbol ?? null,\n       tsType: type,\n       shimLocation: {shimPath: this.shimPath, positionInShimFile},\n@@ -381,7 +410,20 @@ export class SymbolBuilder {\n     if (symbol === null) {\n       return null;\n     }\n-\n     return symbol;\n   }\n+\n+  private getShimPositionForNode(node: ts.Node): number {\n+    if (ts.isTypeReferenceNode(node)) {\n+      return this.getShimPositionForNode(node.typeName);\n+    } else if (ts.isQualifiedName(node)) {\n+      return node.right.getStart();\n+    } else if (ts.isPropertyAccessExpression(node)) {\n+      return node.name.getStart();\n+    } else if (ts.isElementAccessExpression(node)) {\n+      return node.argumentExpression.getStart();\n+    } else {\n+      return node.getStart();\n+    }\n+  }\n }"
        },
        {
            "sha": "8356fbd1f18d95ab24561c75a360416dcee2ebde",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/ts_util.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fts_util.ts",
            "raw_url": "https://github.com/angular/angular/raw/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fts_util.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fts_util.ts?ref=c74917a7d505eeec5111cc816cbaf5fd5f49d601",
            "patch": "@@ -172,3 +172,8 @@ export function checkIfGenericTypesAreUnbound(node: ClassDeclaration<ts.ClassDec\n   }\n   return node.typeParameters.every(param => param.constraint === undefined);\n }\n+\n+export function isAccessExpression(node: ts.Node): node is ts.ElementAccessExpression|\n+    ts.PropertyAccessExpression {\n+  return ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node);\n+}"
        },
        {
            "sha": "217dd6024c246a5a58b16c63ed441a9df752ecd3",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/test_utils.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts?ref=c74917a7d505eeec5111cc816cbaf5fd5f49d601",
            "patch": "@@ -433,6 +433,7 @@ function prepareDeclarations(\n       name: decl.name,\n       ref: new Reference(resolveDeclaration(decl)),\n       exportAs: decl.exportAs || null,\n+      selector: decl.selector || null,\n       hasNgTemplateContextGuard: decl.hasNgTemplateContextGuard || false,\n       inputs: ClassPropertyMapping.fromMappedObject(decl.inputs || {}),\n       isComponent: decl.isComponent || false,"
        },
        {
            "sha": "d1b5d3fb7f9f45cd7c82f9cceef1fe90f262339e",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_checker__get_symbol_of_template_node_spec.ts",
            "status": "modified",
            "additions": 147,
            "deletions": 11,
            "changes": 158,
            "blob_url": "https://github.com/angular/angular/blob/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_checker__get_symbol_of_template_node_spec.ts?ref=c74917a7d505eeec5111cc816cbaf5fd5f49d601",
            "patch": "@@ -12,13 +12,13 @@ import * as ts from 'typescript';\n import {absoluteFrom, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n import {ClassDeclaration} from '../../reflection';\n-import {DirectiveSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, ReferenceSymbol, Symbol, SymbolKind, TemplateSymbol, TemplateTypeChecker, TypeCheckingConfig, VariableSymbol} from '../api';\n+import {DirectiveSymbol, DomBindingSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, ReferenceSymbol, Symbol, SymbolKind, TemplateSymbol, TemplateTypeChecker, TypeCheckingConfig, VariableSymbol} from '../api';\n \n import {getClass, ngForDeclaration, ngForTypeCheckTarget, setup as baseTestSetup, TypeCheckingTarget} from './test_utils';\n \n runInEachFileSystem(() => {\n   describe('TemplateTypeChecker.getSymbolOfNode', () => {\n-    it('should not get a symbol for regular attributes', () => {\n+    it('should get a symbol for regular attributes', () => {\n       const fileName = absoluteFrom('/main.ts');\n       const templateString = `<div id=\"helloWorld\"></div>`;\n       const {templateTypeChecker, program} = setup(\n@@ -34,8 +34,44 @@ runInEachFileSystem(() => {\n       const cmp = getClass(sf, 'Cmp');\n       const {attributes} = getAstElements(templateTypeChecker, cmp)[0];\n \n-      const symbol = templateTypeChecker.getSymbolOfNode(attributes[0], cmp);\n-      expect(symbol).toBeNull();\n+      const symbol = templateTypeChecker.getSymbolOfNode(attributes[0], cmp)!;\n+      assertDomBindingSymbol(symbol);\n+      assertElementSymbol(symbol.host);\n+    });\n+\n+    it('should get a symbol for text attributes corresponding with a directive input', () => {\n+      const fileName = absoluteFrom('/main.ts');\n+      const dirFile = absoluteFrom('/dir.ts');\n+      const templateString = `<div name=\"helloWorld\"></div>`;\n+      const {templateTypeChecker, program} = setup(\n+          [\n+            {\n+              fileName,\n+              templates: {'Cmp': templateString},\n+              declarations: [{\n+                name: 'NameDiv',\n+                selector: 'div[name]',\n+                file: dirFile,\n+                type: 'directive',\n+                inputs: {name: 'name'},\n+              }]\n+            },\n+            {\n+              fileName: dirFile,\n+              source: `export class NameDiv {name!: string;}`,\n+              templates: {},\n+            }\n+          ],\n+      );\n+      const sf = getSourceFileOrError(program, fileName);\n+      const cmp = getClass(sf, 'Cmp');\n+      const {attributes} = getAstElements(templateTypeChecker, cmp)[0];\n+\n+      const symbol = templateTypeChecker.getSymbolOfNode(attributes[0], cmp)!;\n+      assertInputBindingSymbol(symbol);\n+      expect(\n+          (symbol.bindings[0].tsSymbol!.declarations[0] as ts.PropertyDeclaration).name.getText())\n+          .toEqual('name');\n     });\n \n     describe('templates', () => {\n@@ -650,6 +686,54 @@ runInEachFileSystem(() => {\n           expect(program.getTypeChecker().typeToString(cSymbol.tsType)).toEqual('boolean');\n         });\n       });\n+\n+\n+      it('should get a symbol for PropertyWrite expressions', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const {templateTypeChecker, program} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': '<div (output)=\"lastEvent = $event\"></div>'},\n+            source: `export class Cmp { lastEvent: any; }`\n+          },\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+        const node = getAstElements(templateTypeChecker, cmp)[0];\n+        const writeSymbol = templateTypeChecker.getSymbolOfNode(node.outputs[0].handler, cmp)!;\n+        assertExpressionSymbol(writeSymbol);\n+        // Note that the symbol returned is for the RHS of the PropertyWrite. The AST\n+        // does not support specific designation for the RHS so we assume that's what\n+        // is wanted in this case. We don't support retrieving a symbol for the whole\n+        // expression and if you want to get a symbol for the '$event', you can\n+        // use the `value` AST of the `PropertyWrite`.\n+        expect(program.getTypeChecker().symbolToString(writeSymbol.tsSymbol!)).toEqual('lastEvent');\n+        expect(program.getTypeChecker().typeToString(writeSymbol.tsType)).toEqual('any');\n+      });\n+\n+      it('should get a symbol for MethodCall expressions', () => {\n+        const fileName = absoluteFrom('/main.ts');\n+        const {templateTypeChecker, program} = setup([\n+          {\n+            fileName,\n+            templates: {'Cmp': '<div [input]=\"toString(123)\"></div>'},\n+            source: `export class Cmp { toString(v: any): string { return String(v); } }`\n+          },\n+        ]);\n+        const sf = getSourceFileOrError(program, fileName);\n+        const cmp = getClass(sf, 'Cmp');\n+        const node = getAstElements(templateTypeChecker, cmp)[0];\n+        const callSymbol = templateTypeChecker.getSymbolOfNode(node.inputs[0].value, cmp)!;\n+        assertExpressionSymbol(callSymbol);\n+        // Note that the symbol returned is for the method name of the MethodCall. The AST\n+        // does not support specific designation for the name so we assume that's what\n+        // is wanted in this case. We don't support retrieving a symbol for the whole\n+        // call expression and if you want to get a symbol for the args, you can\n+        // use the AST of the args in the `MethodCall`.\n+        expect(program.getTypeChecker().symbolToString(callSymbol.tsSymbol!)).toEqual('toString');\n+        expect(program.getTypeChecker().typeToString(callSymbol.tsType))\n+            .toEqual('(v: any) => string');\n+      });\n     });\n \n     describe('input bindings', () => {\n@@ -750,9 +834,9 @@ runInEachFileSystem(() => {\n             .toEqual('ngForOf');\n       });\n \n-      it('returns empty list when there is no directive registered for the binding', () => {\n+      it('returns dom binding input binds only to the dom element', () => {\n         const fileName = absoluteFrom('/main.ts');\n-        const templateString = `<div dir [inputA]=\"'my input'\"></div>`;\n+        const templateString = `<div [name]=\"'my input'\"></div>`;\n         const {program, templateTypeChecker} = setup([\n           {fileName, templates: {'Cmp': templateString}, declarations: []},\n         ]);\n@@ -762,11 +846,12 @@ runInEachFileSystem(() => {\n         const nodes = templateTypeChecker.getTemplate(cmp)!;\n         const binding = (nodes[0] as TmplAstElement).inputs[0];\n \n-        const symbol = templateTypeChecker.getSymbolOfNode(binding, cmp);\n-        expect(symbol).toBeNull();\n+        const symbol = templateTypeChecker.getSymbolOfNode(binding, cmp)!;\n+        assertDomBindingSymbol(symbol);\n+        assertElementSymbol(symbol.host);\n       });\n \n-      it('returns empty list when directive members do not match the input', () => {\n+      it('returns dom binding when directive members do not match the input', () => {\n         const fileName = absoluteFrom('/main.ts');\n         const dirFile = absoluteFrom('/dir.ts');\n         const templateString = `<div dir [inputA]=\"'my input A'\"></div>`;\n@@ -794,8 +879,9 @@ runInEachFileSystem(() => {\n         const nodes = templateTypeChecker.getTemplate(cmp)!;\n \n         const inputAbinding = (nodes[0] as TmplAstElement).inputs[0];\n-        const symbol = templateTypeChecker.getSymbolOfNode(inputAbinding, cmp);\n-        expect(symbol).toBeNull();\n+        const symbol = templateTypeChecker.getSymbolOfNode(inputAbinding, cmp)!;\n+        assertDomBindingSymbol(symbol);\n+        assertElementSymbol(symbol.host);\n       });\n \n       it('can match binding when there are two directives', () => {\n@@ -1120,6 +1206,7 @@ runInEachFileSystem(() => {\n                   {\n                     name: 'ChildComponent',\n                     selector: 'child-component',\n+                    isComponent: true,\n                     file: dirFile,\n                     type: 'directive',\n                   },\n@@ -1145,6 +1232,7 @@ runInEachFileSystem(() => {\n         assertDirectiveSymbol(symbol.directives[0]);\n         expect(program.getTypeChecker().typeToString(symbol.directives[0].tsType))\n             .toEqual('ChildComponent');\n+        expect(symbol.directives[0].isComponent).toBe(true);\n       });\n \n       it('element with directive matches', () => {\n@@ -1199,8 +1287,52 @@ runInEachFileSystem(() => {\n         const actualDirectives =\n             symbol.directives.map(dir => program.getTypeChecker().typeToString(dir.tsType)).sort();\n         expect(actualDirectives).toEqual(expectedDirectives);\n+\n+        const expectedSelectors = ['[dir]', '[dir2]', 'div'].sort();\n+        const actualSelectors = symbol.directives.map(dir => dir.selector).sort();\n+        expect(actualSelectors).toEqual(expectedSelectors);\n       });\n     });\n+\n+    it('elements with generic directives', () => {\n+      const fileName = absoluteFrom('/main.ts');\n+      const dirFile = absoluteFrom('/dir.ts');\n+      const {program, templateTypeChecker} = setup(\n+          [\n+            {\n+              fileName,\n+              templates: {'Cmp': `<div genericDir></div>`},\n+              declarations: [\n+                {\n+                  name: 'GenericDir',\n+                  selector: '[genericDir]',\n+                  file: dirFile,\n+                  type: 'directive',\n+                  isGeneric: true\n+                },\n+              ]\n+            },\n+            {\n+              fileName: dirFile,\n+              source: `\n+              export class GenericDir<T>{}\n+            `,\n+              templates: {},\n+            }\n+          ],\n+      );\n+      const sf = getSourceFileOrError(program, fileName);\n+      const cmp = getClass(sf, 'Cmp');\n+\n+      const nodes = templateTypeChecker.getTemplate(cmp)!;\n+\n+      const symbol = templateTypeChecker.getSymbolOfNode(nodes[0] as TmplAstElement, cmp)!;\n+      assertElementSymbol(symbol);\n+      expect(symbol.directives.length).toBe(1);\n+      const actualDirectives =\n+          symbol.directives.map(dir => program.getTypeChecker().typeToString(dir.tsType)).sort();\n+      expect(actualDirectives).toEqual(['GenericDir<any>']);\n+    });\n   });\n });\n \n@@ -1254,6 +1386,10 @@ function assertElementSymbol(tSymbol: Symbol): asserts tSymbol is ElementSymbol\n   expect(tSymbol.kind).toEqual(SymbolKind.Element);\n }\n \n+function assertDomBindingSymbol(tSymbol: Symbol): asserts tSymbol is DomBindingSymbol {\n+  expect(tSymbol.kind).toEqual(SymbolKind.DomBinding);\n+}\n+\n export function setup(targets: TypeCheckingTarget[], config?: Partial<TypeCheckingConfig>) {\n   return baseTestSetup(\n       targets, {inlining: false, config: {...config, enableTemplateTypeChecker: true}});"
        },
        {
            "sha": "b8463d8f331ddf88fb0f5ab009b966d1f6a82210",
            "filename": "packages/compiler/src/render3/view/t2_api.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_api.ts",
            "raw_url": "https://github.com/angular/angular/raw/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_api.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ft2_api.ts?ref=c74917a7d505eeec5111cc816cbaf5fd5f49d601",
            "patch": "@@ -46,6 +46,9 @@ export interface DirectiveMeta {\n    */\n   name: string;\n \n+  /** The selector for the directive or `null` if there isn't one. */\n+  selector: string|null;\n+\n   /**\n    * Whether the directive is a component.\n    */"
        },
        {
            "sha": "5d792c338eb5af6a356f639c0e8b3bdee361822b",
            "filename": "packages/compiler/test/render3/view/binding_spec.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Fbinding_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/c74917a7d505eeec5111cc816cbaf5fd5f49d601/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Fbinding_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Frender3%2Fview%2Fbinding_spec.ts?ref=c74917a7d505eeec5111cc816cbaf5fd5f49d601",
            "patch": "@@ -38,27 +38,31 @@ function makeSelectorMatcher(): SelectorMatcher<DirectiveMeta> {\n     inputs: new IdentityInputMapping(['ngForOf']),\n     outputs: new IdentityInputMapping([]),\n     isComponent: false,\n+    selector: '[ngFor][ngForOf]',\n   });\n   matcher.addSelectables(CssSelector.parse('[dir]'), {\n     name: 'Dir',\n     exportAs: null,\n     inputs: new IdentityInputMapping([]),\n     outputs: new IdentityInputMapping([]),\n     isComponent: false,\n+    selector: '[dir]'\n   });\n   matcher.addSelectables(CssSelector.parse('[hasOutput]'), {\n     name: 'HasOutput',\n     exportAs: null,\n     inputs: new IdentityInputMapping([]),\n     outputs: new IdentityInputMapping(['outputBinding']),\n     isComponent: false,\n+    selector: '[hasOutput]'\n   });\n   matcher.addSelectables(CssSelector.parse('[hasInput]'), {\n     name: 'HasInput',\n     exportAs: null,\n     inputs: new IdentityInputMapping(['inputBinding']),\n     outputs: new IdentityInputMapping([]),\n     isComponent: false,\n+    selector: '[hasInput]'\n   });\n   return matcher;\n }\n@@ -103,6 +107,7 @@ describe('t2 binding', () => {\n       inputs: new IdentityInputMapping([]),\n       outputs: new IdentityInputMapping([]),\n       isComponent: false,\n+      selector: 'text[dir]'\n     });\n     const binder = new R3TargetBinder(matcher);\n     const res = binder.bind({template: template.nodes});"
        }
    ],
    "stats": {
        "total": 334,
        "additions": 273,
        "deletions": 61
    }
}