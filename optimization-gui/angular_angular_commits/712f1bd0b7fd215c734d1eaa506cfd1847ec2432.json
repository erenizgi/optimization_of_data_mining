{
    "author": "JoostK",
    "message": "feat(compiler-cli): explain why an expression cannot be used in AOT compilations (#37587)\n\nDuring AOT compilation, the value of some expressions need to be known at\ncompile time. The compiler has the ability to statically evaluate expressions\nthe best it can, but there can be occurrences when an expression cannot be\nevaluated statically. For instance, the evaluation could depend on a dynamic\nvalue or syntax is used that the compiler does not understand. Alternatively,\nit is possible that an expression could be statically evaluated but the\nresulting value would be of an incorrect type.\n\nIn these situations, it would be helpful if the compiler could explain why it\nis unable to evaluate an expression. To this extend, the static interpreter\nin Ivy keeps track of a trail of `DynamicValue`s which follow the path of nodes\nthat were considered all the way to the node that causes an expression to be\nconsidered dynamic. Up until this commit, this rich trail of information was\nnot surfaced to a developer so the compiler was of little help to explain\nwhy static evaluation failed, resulting in situations that are hard to debug\nand resolve.\n\nThis commit adds much more insight to the diagnostic that is produced for static\nevaluation errors. For dynamic values, the trail of `DynamicValue` instances\nis presented to the user in a meaningful way. If a value is available but not\nof the correct type, the type of the resolved value is shown.\n\nResolves FW-2155\n\nPR Close #37587",
    "sha": "712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
    "files": [
        {
            "sha": "abaf8d08263e55a8c62a3ddaed3c5e8fbbddb6b2",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 17,
            "changes": 31,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -26,7 +26,7 @@ import {tsSourceMapBug29300Fixed} from '../../util/src/ts_source_map_bug_29300';\n import {SubsetOfKeys} from '../../util/src/typescript';\n \n import {ResourceLoader} from './api';\n-import {getDirectiveDiagnostics, getProviderDiagnostics} from './diagnostics';\n+import {createValueHasWrongTypeError, getDirectiveDiagnostics, getProviderDiagnostics} from './diagnostics';\n import {extractDirectiveMetadata, parseFieldArrayValue} from './directive';\n import {compileNgFactoryDefField} from './factory';\n import {generateSetClassMetadataCall} from './metadata';\n@@ -243,8 +243,8 @@ export class ComponentDecoratorHandler implements\n         const templateUrlExpr = component.get('templateUrl')!;\n         const templateUrl = this.evaluator.evaluate(templateUrlExpr);\n         if (typeof templateUrl !== 'string') {\n-          throw new FatalDiagnosticError(\n-              ErrorCode.VALUE_HAS_WRONG_TYPE, templateUrlExpr, 'templateUrl must be a string');\n+          throw createValueHasWrongTypeError(\n+              templateUrlExpr, templateUrl, 'templateUrl must be a string');\n         }\n         const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n         template = this._extractExternalTemplate(node, component, templateUrlExpr, resourceUrl);\n@@ -617,9 +617,8 @@ export class ComponentDecoratorHandler implements\n       if (value instanceof EnumValue && isAngularCoreReference(value.enumRef, enumSymbolName)) {\n         resolved = value.resolved as number;\n       } else {\n-        throw new FatalDiagnosticError(\n-            ErrorCode.VALUE_HAS_WRONG_TYPE, expr,\n-            `${field} must be a member of ${enumSymbolName} enum from @angular/core`);\n+        throw createValueHasWrongTypeError(\n+            expr, value, `${field} must be a member of ${enumSymbolName} enum from @angular/core`);\n       }\n     }\n     return resolved;\n@@ -634,8 +633,8 @@ export class ComponentDecoratorHandler implements\n     const styleUrlsExpr = component.get('styleUrls')!;\n     const styleUrls = this.evaluator.evaluate(styleUrlsExpr);\n     if (!Array.isArray(styleUrls) || !styleUrls.every(url => typeof url === 'string')) {\n-      throw new FatalDiagnosticError(\n-          ErrorCode.VALUE_HAS_WRONG_TYPE, styleUrlsExpr, 'styleUrls must be an array of strings');\n+      throw createValueHasWrongTypeError(\n+          styleUrlsExpr, styleUrls, 'styleUrls must be an array of strings');\n     }\n     styleUrls.push(...extraUrls);\n     return styleUrls as string[];\n@@ -649,8 +648,8 @@ export class ComponentDecoratorHandler implements\n       const templateUrlExpr = component.get('templateUrl')!;\n       const templateUrl = this.evaluator.evaluate(templateUrlExpr);\n       if (typeof templateUrl !== 'string') {\n-        throw new FatalDiagnosticError(\n-            ErrorCode.VALUE_HAS_WRONG_TYPE, templateUrlExpr, 'templateUrl must be a string');\n+        throw createValueHasWrongTypeError(\n+            templateUrlExpr, templateUrl, 'templateUrl must be a string');\n       }\n       const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n       const templatePromise = this.resourceLoader.preload(resourceUrl);\n@@ -729,8 +728,8 @@ export class ComponentDecoratorHandler implements\n     } else {\n       const resolvedTemplate = this.evaluator.evaluate(templateExpr);\n       if (typeof resolvedTemplate !== 'string') {\n-        throw new FatalDiagnosticError(\n-            ErrorCode.VALUE_HAS_WRONG_TYPE, templateExpr, 'template must be a string');\n+        throw createValueHasWrongTypeError(\n+            templateExpr, resolvedTemplate, 'template must be a string');\n       }\n       templateStr = resolvedTemplate;\n       sourceMapping = {\n@@ -755,8 +754,7 @@ export class ComponentDecoratorHandler implements\n       const expr = component.get('preserveWhitespaces')!;\n       const value = this.evaluator.evaluate(expr);\n       if (typeof value !== 'boolean') {\n-        throw new FatalDiagnosticError(\n-            ErrorCode.VALUE_HAS_WRONG_TYPE, expr, 'preserveWhitespaces must be a boolean');\n+        throw createValueHasWrongTypeError(expr, value, 'preserveWhitespaces must be a boolean');\n       }\n       preserveWhitespaces = value;\n     }\n@@ -767,9 +765,8 @@ export class ComponentDecoratorHandler implements\n       const value = this.evaluator.evaluate(expr);\n       if (!Array.isArray(value) || value.length !== 2 ||\n           !value.every(element => typeof element === 'string')) {\n-        throw new FatalDiagnosticError(\n-            ErrorCode.VALUE_HAS_WRONG_TYPE, expr,\n-            'interpolation must be an array with 2 elements of string type');\n+        throw createValueHasWrongTypeError(\n+            expr, value, 'interpolation must be an array with 2 elements of string type');\n       }\n       interpolation = InterpolationConfig.fromArray(value as [string, string]);\n     }"
        },
        {
            "sha": "195254d627b7ce29cd75f70cdfddf92e93d6ea97",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/diagnostics.ts",
            "status": "modified",
            "additions": 44,
            "deletions": 2,
            "changes": 46,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdiagnostics.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdiagnostics.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdiagnostics.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -8,15 +8,57 @@\n \n import * as ts from 'typescript';\n \n-import {ErrorCode, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\n+import {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\n import {Reference} from '../../imports';\n import {InjectableClassRegistry, MetadataReader} from '../../metadata';\n-import {PartialEvaluator} from '../../partial_evaluator';\n+import {describeResolvedType, DynamicValue, PartialEvaluator, ResolvedValue, traceDynamicValue} from '../../partial_evaluator';\n import {ClassDeclaration, ReflectionHost} from '../../reflection';\n import {LocalModuleScopeRegistry} from '../../scope';\n+import {identifierOfNode} from '../../util/src/typescript';\n \n import {makeDuplicateDeclarationError, readBaseClass} from './util';\n \n+/**\n+ * Creates a `FatalDiagnosticError` for a node that did not evaluate to the expected type. The\n+ * diagnostic that is created will include details on why the value is incorrect, i.e. it includes\n+ * a representation of the actual type that was unsupported, or in the case of a dynamic value the\n+ * trace to the node where the dynamic value originated.\n+ *\n+ * @param node The node for which the diagnostic should be produced.\n+ * @param value The evaluated value that has the wrong type.\n+ * @param messageText The message text of the error.\n+ */\n+export function createValueHasWrongTypeError(\n+    node: ts.Node, value: ResolvedValue, messageText: string): FatalDiagnosticError {\n+  let chainedMessage: string;\n+  let relatedInformation: ts.DiagnosticRelatedInformation[]|undefined;\n+  if (value instanceof DynamicValue) {\n+    chainedMessage = 'Value could not be determined statically.';\n+    relatedInformation = traceDynamicValue(node, value);\n+  } else if (value instanceof Reference) {\n+    const target = value.debugName !== null ? `'${value.debugName}'` : 'an anonymous declaration';\n+    chainedMessage = `Value is a reference to ${target}.`;\n+\n+    const referenceNode = identifierOfNode(value.node) ?? value.node;\n+    relatedInformation = [makeRelatedInformation(referenceNode, 'Reference is declared here.')];\n+  } else {\n+    chainedMessage = `Value is of type '${describeResolvedType(value)}'.`;\n+  }\n+\n+  const chain: ts.DiagnosticMessageChain = {\n+    messageText,\n+    category: ts.DiagnosticCategory.Error,\n+    code: 0,\n+    next: [{\n+      messageText: chainedMessage,\n+      category: ts.DiagnosticCategory.Message,\n+      code: 0,\n+    }]\n+  };\n+\n+  return new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, node, chain, relatedInformation);\n+}\n+\n /**\n  * Gets the diagnostics for a set of provider classes.\n  * @param providerClasses Classes that should be checked."
        },
        {
            "sha": "04c6f3f2c426a091df6a8eb32a598118e350450f",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/directive.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 32,
            "changes": 58,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -18,7 +18,7 @@ import {ClassDeclaration, ClassMember, ClassMemberKind, Decorator, filterToMembe\n import {LocalModuleScopeRegistry} from '../../scope';\n import {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerFlags, HandlerPrecedence, ResolveResult} from '../../transform';\n \n-import {getDirectiveDiagnostics, getProviderDiagnostics, getUndecoratedClassWithAngularFeaturesDiagnostic} from './diagnostics';\n+import {createValueHasWrongTypeError, getDirectiveDiagnostics, getProviderDiagnostics, getUndecoratedClassWithAngularFeaturesDiagnostic} from './diagnostics';\n import {compileNgFactoryDefField} from './factory';\n import {generateSetClassMetadataCall} from './metadata';\n import {createSourceSpan, findAngularDecorator, getConstructorDependencies, isAngularDecorator, readBaseClass, resolveProvidersRequiringFactory, unwrapConstructorDependencies, unwrapExpression, unwrapForwardRef, validateConstructorDependencies, wrapFunctionExpressionsInParens, wrapTypeReference} from './util';\n@@ -278,8 +278,7 @@ export function extractDirectiveMetadata(\n     const expr = directive.get('selector')!;\n     const resolved = evaluator.evaluate(expr);\n     if (typeof resolved !== 'string') {\n-      throw new FatalDiagnosticError(\n-          ErrorCode.VALUE_HAS_WRONG_TYPE, expr, `selector must be a string`);\n+      throw createValueHasWrongTypeError(expr, resolved, `selector must be a string`);\n     }\n     // use default selector in case selector is an empty string\n     selector = resolved === '' ? defaultSelector : resolved;\n@@ -310,8 +309,7 @@ export function extractDirectiveMetadata(\n     const expr = directive.get('exportAs')!;\n     const resolved = evaluator.evaluate(expr);\n     if (typeof resolved !== 'string') {\n-      throw new FatalDiagnosticError(\n-          ErrorCode.VALUE_HAS_WRONG_TYPE, expr, `exportAs must be a string`);\n+      throw createValueHasWrongTypeError(expr, resolved, `exportAs must be a string`);\n     }\n     exportAs = resolved.split(',').map(part => part.trim());\n   }\n@@ -381,8 +379,7 @@ export function extractQueryMetadata(\n   } else if (isStringArrayOrDie(arg, `@${name} predicate`, node)) {\n     predicate = arg;\n   } else {\n-    throw new FatalDiagnosticError(\n-        ErrorCode.VALUE_HAS_WRONG_TYPE, node, `@${name} predicate cannot be interpreted`);\n+    throw createValueHasWrongTypeError(node, arg, `@${name} predicate cannot be interpreted`);\n   }\n \n   // Extract the read and descendants options.\n@@ -405,18 +402,17 @@ export function extractQueryMetadata(\n       const descendantsExpr = options.get('descendants')!;\n       const descendantsValue = evaluator.evaluate(descendantsExpr);\n       if (typeof descendantsValue !== 'boolean') {\n-        throw new FatalDiagnosticError(\n-            ErrorCode.VALUE_HAS_WRONG_TYPE, descendantsExpr,\n-            `@${name} options.descendants must be a boolean`);\n+        throw createValueHasWrongTypeError(\n+            descendantsExpr, descendantsValue, `@${name} options.descendants must be a boolean`);\n       }\n       descendants = descendantsValue;\n     }\n \n     if (options.has('static')) {\n       const staticValue = evaluator.evaluate(options.get('static')!);\n       if (typeof staticValue !== 'boolean') {\n-        throw new FatalDiagnosticError(\n-            ErrorCode.VALUE_HAS_WRONG_TYPE, node, `@${name} options.static must be a boolean`);\n+        throw createValueHasWrongTypeError(\n+            node, staticValue, `@${name} options.static must be a boolean`);\n       }\n       isStatic = staticValue;\n     }\n@@ -482,9 +478,8 @@ function isStringArrayOrDie(value: any, name: string, node: ts.Expression): valu\n \n   for (let i = 0; i < value.length; i++) {\n     if (typeof value[i] !== 'string') {\n-      throw new FatalDiagnosticError(\n-          ErrorCode.VALUE_HAS_WRONG_TYPE, node,\n-          `Failed to resolve ${name} at position ${i} to a string`);\n+      throw createValueHasWrongTypeError(\n+          node, value[i], `Failed to resolve ${name} at position ${i} to a string`);\n     }\n   }\n   return true;\n@@ -501,9 +496,8 @@ export function parseFieldArrayValue(\n   const expression = directive.get(field)!;\n   const value = evaluator.evaluate(expression);\n   if (!isStringArrayOrDie(value, field, expression)) {\n-    throw new FatalDiagnosticError(\n-        ErrorCode.VALUE_HAS_WRONG_TYPE, expression,\n-        `Failed to resolve @Directive.${field} to a string array`);\n+    throw createValueHasWrongTypeError(\n+        expression, value, `Failed to resolve @Directive.${field} to a string array`);\n   }\n \n   return value;\n@@ -548,8 +542,8 @@ function parseDecoratedFields(\n       } else if (decorator.args.length === 1) {\n         const property = evaluator.evaluate(decorator.args[0]);\n         if (typeof property !== 'string') {\n-          throw new FatalDiagnosticError(\n-              ErrorCode.VALUE_HAS_WRONG_TYPE, Decorator.nodeForError(decorator),\n+          throw createValueHasWrongTypeError(\n+              Decorator.nodeForError(decorator), property,\n               `@${decorator.name} decorator argument must resolve to a string`);\n         }\n         results[fieldName] = mapValueResolver(property, fieldName);\n@@ -613,8 +607,8 @@ function evaluateHostExpressionBindings(\n     hostExpr: ts.Expression, evaluator: PartialEvaluator): ParsedHostBindings {\n   const hostMetaMap = evaluator.evaluate(hostExpr);\n   if (!(hostMetaMap instanceof Map)) {\n-    throw new FatalDiagnosticError(\n-        ErrorCode.VALUE_HAS_WRONG_TYPE, hostExpr, `Decorator host metadata must be an object`);\n+    throw createValueHasWrongTypeError(\n+        hostExpr, hostMetaMap, `Decorator host metadata must be an object`);\n   }\n   const hostMetadata: StringMap<string|Expression> = {};\n   hostMetaMap.forEach((value, key) => {\n@@ -624,8 +618,8 @@ function evaluateHostExpressionBindings(\n     }\n \n     if (typeof key !== 'string') {\n-      throw new FatalDiagnosticError(\n-          ErrorCode.VALUE_HAS_WRONG_TYPE, hostExpr,\n+      throw createValueHasWrongTypeError(\n+          hostExpr, key,\n           `Decorator host metadata must be a string -> string object, but found unparseable key`);\n     }\n \n@@ -634,8 +628,8 @@ function evaluateHostExpressionBindings(\n     } else if (value instanceof DynamicValue) {\n       hostMetadata[key] = new WrappedNodeExpr(value.node as ts.Expression);\n     } else {\n-      throw new FatalDiagnosticError(\n-          ErrorCode.VALUE_HAS_WRONG_TYPE, hostExpr,\n+      throw createValueHasWrongTypeError(\n+          hostExpr, value,\n           `Decorator host metadata must be a string -> string object, but found unparseable value`);\n     }\n   });\n@@ -678,8 +672,8 @@ export function extractHostBindings(\n \n             const resolved = evaluator.evaluate(decorator.args[0]);\n             if (typeof resolved !== 'string') {\n-              throw new FatalDiagnosticError(\n-                  ErrorCode.VALUE_HAS_WRONG_TYPE, Decorator.nodeForError(decorator),\n+              throw createValueHasWrongTypeError(\n+                  Decorator.nodeForError(decorator), resolved,\n                   `@HostBinding's argument must be a string`);\n             }\n \n@@ -704,8 +698,8 @@ export function extractHostBindings(\n \n             const resolved = evaluator.evaluate(decorator.args[0]);\n             if (typeof resolved !== 'string') {\n-              throw new FatalDiagnosticError(\n-                  ErrorCode.VALUE_HAS_WRONG_TYPE, decorator.args[0],\n+              throw createValueHasWrongTypeError(\n+                  decorator.args[0], resolved,\n                   `@HostListener's event name argument must be a string`);\n             }\n \n@@ -715,8 +709,8 @@ export function extractHostBindings(\n               const expression = decorator.args[1];\n               const resolvedArgs = evaluator.evaluate(decorator.args[1]);\n               if (!isStringArrayOrDie(resolvedArgs, '@HostListener.args', expression)) {\n-                throw new FatalDiagnosticError(\n-                    ErrorCode.VALUE_HAS_WRONG_TYPE, decorator.args[1],\n+                throw createValueHasWrongTypeError(\n+                    decorator.args[1], resolvedArgs,\n                     `@HostListener's second argument must be a string array`);\n               }\n               args = resolvedArgs;"
        },
        {
            "sha": "950ae78b98946b1c3a208994834ef586055a9e30",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/ng_module.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 19,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -20,7 +20,7 @@ import {FactoryTracker} from '../../shims/api';\n import {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence, ResolveResult} from '../../transform';\n import {getSourceFile} from '../../util/src/typescript';\n \n-import {getProviderDiagnostics} from './diagnostics';\n+import {createValueHasWrongTypeError, getProviderDiagnostics} from './diagnostics';\n import {generateSetClassMetadataCall} from './metadata';\n import {ReferencesRegistry} from './references_registry';\n import {combineResolvers, findAngularDecorator, forwardRefResolver, getValidConstructorDependencies, isExpressionForwardReference, resolveProvidersRequiringFactory, toR3Reference, unwrapExpression, wrapFunctionExpressionsInParens, wrapTypeReference} from './util';\n@@ -170,21 +170,18 @@ export class NgModuleDecoratorHandler implements\n       const rawExpr = ngModule.get('schemas')!;\n       const result = this.evaluator.evaluate(rawExpr);\n       if (!Array.isArray(result)) {\n-        throw new FatalDiagnosticError(\n-            ErrorCode.VALUE_HAS_WRONG_TYPE, rawExpr, `NgModule.schemas must be an array`);\n+        throw createValueHasWrongTypeError(rawExpr, result, `NgModule.schemas must be an array`);\n       }\n \n       for (const schemaRef of result) {\n         if (!(schemaRef instanceof Reference)) {\n-          throw new FatalDiagnosticError(\n-              ErrorCode.VALUE_HAS_WRONG_TYPE, rawExpr,\n-              'NgModule.schemas must be an array of schemas');\n+          throw createValueHasWrongTypeError(\n+              rawExpr, result, 'NgModule.schemas must be an array of schemas');\n         }\n         const id = schemaRef.getIdentityIn(schemaRef.node.getSourceFile());\n         if (id === null || schemaRef.ownedByModuleGuess !== '@angular/core') {\n-          throw new FatalDiagnosticError(\n-              ErrorCode.VALUE_HAS_WRONG_TYPE, rawExpr,\n-              'NgModule.schemas must be an array of schemas');\n+          throw createValueHasWrongTypeError(\n+              rawExpr, result, 'NgModule.schemas must be an array of schemas');\n         }\n         // Since `id` is the `ts.Identifer` within the schema ref's declaration file, it's safe to\n         // use `id.text` here to figure out which schema is in use. Even if the actual reference was\n@@ -197,9 +194,8 @@ export class NgModuleDecoratorHandler implements\n             schemas.push(NO_ERRORS_SCHEMA);\n             break;\n           default:\n-            throw new FatalDiagnosticError(\n-                ErrorCode.VALUE_HAS_WRONG_TYPE, rawExpr,\n-                `'${schemaRef.debugName}' is not a valid NgModule schema`);\n+            throw createValueHasWrongTypeError(\n+                rawExpr, schemaRef, `'${schemaRef.debugName}' is not a valid NgModule schema`);\n         }\n       }\n     }\n@@ -554,8 +550,8 @@ export class NgModuleDecoratorHandler implements\n       arrayName: string): Reference<ClassDeclaration>[] {\n     const refList: Reference<ClassDeclaration>[] = [];\n     if (!Array.isArray(resolvedList)) {\n-      throw new FatalDiagnosticError(\n-          ErrorCode.VALUE_HAS_WRONG_TYPE, expr,\n+      throw createValueHasWrongTypeError(\n+          expr, resolvedList,\n           `Expected array when reading the NgModule.${arrayName} of ${className}`);\n     }\n \n@@ -571,18 +567,18 @@ export class NgModuleDecoratorHandler implements\n         refList.push(...this.resolveTypeList(expr, entry, className, arrayName));\n       } else if (isDeclarationReference(entry)) {\n         if (!this.isClassDeclarationReference(entry)) {\n-          throw new FatalDiagnosticError(\n-              ErrorCode.VALUE_HAS_WRONG_TYPE, entry.node,\n+          throw createValueHasWrongTypeError(\n+              entry.node, entry,\n               `Value at position ${idx} in the NgModule.${arrayName} of ${\n                   className} is not a class`);\n         }\n         refList.push(entry);\n       } else {\n         // TODO(alxhub): Produce a better diagnostic here - the array index may be an inner array.\n-        throw new FatalDiagnosticError(\n-            ErrorCode.VALUE_HAS_WRONG_TYPE, expr,\n+        throw createValueHasWrongTypeError(\n+            expr, entry,\n             `Value at position ${idx} in the NgModule.${arrayName} of ${\n-                className} is not a reference: ${entry}`);\n+                className} is not a reference`);\n       }\n     });\n "
        },
        {
            "sha": "f79d9ad07066d11c8f350c9f6ee91e2cf4c63fad",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/pipe.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fpipe.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fpipe.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fpipe.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -16,6 +16,7 @@ import {PartialEvaluator} from '../../partial_evaluator';\n import {ClassDeclaration, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n import {LocalModuleScopeRegistry} from '../../scope';\n import {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence, ResolveResult} from '../../transform';\n+import {createValueHasWrongTypeError} from './diagnostics';\n \n import {compileNgFactoryDefField} from './factory';\n import {generateSetClassMetadataCall} from './metadata';\n@@ -82,17 +83,15 @@ export class PipeDecoratorHandler implements DecoratorHandler<Decorator, PipeHan\n     const pipeNameExpr = pipe.get('name')!;\n     const pipeName = this.evaluator.evaluate(pipeNameExpr);\n     if (typeof pipeName !== 'string') {\n-      throw new FatalDiagnosticError(\n-          ErrorCode.VALUE_HAS_WRONG_TYPE, pipeNameExpr, `@Pipe.name must be a string`);\n+      throw createValueHasWrongTypeError(pipeNameExpr, pipeName, `@Pipe.name must be a string`);\n     }\n \n     let pure = true;\n     if (pipe.has('pure')) {\n       const expr = pipe.get('pure')!;\n       const pureValue = this.evaluator.evaluate(expr);\n       if (typeof pureValue !== 'boolean') {\n-        throw new FatalDiagnosticError(\n-            ErrorCode.VALUE_HAS_WRONG_TYPE, expr, `@Pipe.pure must be a boolean`);\n+        throw createValueHasWrongTypeError(expr, pureValue, `@Pipe.pure must be a boolean`);\n       }\n       pure = pureValue;\n     }"
        },
        {
            "sha": "a8f64ea6ce21ecc871ed7666acb96008840e9540",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/diagnostics_spec.ts",
            "status": "added",
            "additions": 117,
            "deletions": 0,
            "changes": 117,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdiagnostics_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdiagnostics_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdiagnostics_spec.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -0,0 +1,117 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript';\n+\n+import {FatalDiagnosticError} from '../../diagnostics';\n+import {absoluteFrom as _} from '../../file_system';\n+import {runInEachFileSystem, TestFile} from '../../file_system/testing';\n+import {PartialEvaluator} from '../../partial_evaluator';\n+import {TypeScriptReflectionHost} from '../../reflection';\n+import {getDeclaration, makeProgram} from '../../testing';\n+\n+import {createValueHasWrongTypeError} from '../src/diagnostics';\n+\n+runInEachFileSystem(() => {\n+  describe('ngtsc annotation diagnostics', () => {\n+    describe('createValueError()', () => {\n+      it('should include a trace for dynamic values', () => {\n+        const error = createError('', 'nonexistent', 'Error message');\n+\n+        if (typeof error.message === 'string') {\n+          return fail('Created error must have a message chain');\n+        }\n+        expect(error.message.messageText).toBe('Error message');\n+        expect(error.message.next!.length).toBe(1);\n+        expect(error.message.next![0].messageText)\n+            .toBe(`Value could not be determined statically.`);\n+\n+        expect(error.relatedInformation).toBeDefined();\n+        expect(error.relatedInformation!.length).toBe(1);\n+\n+        expect(error.relatedInformation![0].messageText).toBe('Unknown reference.');\n+        expect(error.relatedInformation![0].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(error.relatedInformation![0])).toBe('nonexistent');\n+      });\n+\n+      it('should include a pointer for a reference to a named declaration', () => {\n+        const error = createError(\n+            `import {Foo} from './foo';`, 'Foo', 'Error message',\n+            [{name: _('/foo.ts'), contents: 'export class Foo {}'}]);\n+\n+        if (typeof error.message === 'string') {\n+          return fail('Created error must have a message chain');\n+        }\n+        expect(error.message.messageText).toBe('Error message');\n+        expect(error.message.next!.length).toBe(1);\n+        expect(error.message.next![0].messageText).toBe(`Value is a reference to 'Foo'.`);\n+\n+        expect(error.relatedInformation).toBeDefined();\n+        expect(error.relatedInformation!.length).toBe(1);\n+        expect(error.relatedInformation![0].messageText).toBe('Reference is declared here.');\n+        expect(error.relatedInformation![0].file!.fileName).toBe(_('/foo.ts'));\n+        expect(getSourceCode(error.relatedInformation![0])).toBe('Foo');\n+      });\n+\n+      it('should include a pointer for a reference to an anonymous declaration', () => {\n+        const error = createError(\n+            `import Foo from './foo';`, 'Foo', 'Error message',\n+            [{name: _('/foo.ts'), contents: 'export default class {}'}]);\n+\n+        if (typeof error.message === 'string') {\n+          return fail('Created error must have a message chain');\n+        }\n+        expect(error.message.messageText).toBe('Error message');\n+        expect(error.message.next!.length).toBe(1);\n+        expect(error.message.next![0].messageText)\n+            .toBe(`Value is a reference to an anonymous declaration.`);\n+\n+        expect(error.relatedInformation).toBeDefined();\n+        expect(error.relatedInformation!.length).toBe(1);\n+        expect(error.relatedInformation![0].messageText).toBe('Reference is declared here.');\n+        expect(error.relatedInformation![0].file!.fileName).toBe(_('/foo.ts'));\n+        expect(getSourceCode(error.relatedInformation![0])).toBe('export default class {}');\n+      });\n+\n+      it('should include a representation of the value\\'s type', () => {\n+        const error = createError('', '{a: 2}', 'Error message');\n+\n+        if (typeof error.message === 'string') {\n+          return fail('Created error must have a message chain');\n+        }\n+        expect(error.message.messageText).toBe('Error message');\n+        expect(error.message.next!.length).toBe(1);\n+        expect(error.message.next![0].messageText).toBe(`Value is of type '{ a: number }'.`);\n+\n+        expect(error.relatedInformation).not.toBeDefined();\n+      });\n+    });\n+  });\n+});\n+\n+function getSourceCode(diag: ts.DiagnosticRelatedInformation): string {\n+  const text = diag.file!.text;\n+  return text.substr(diag.start!, diag.length!);\n+}\n+\n+function createError(\n+    code: string, expr: string, messageText: string,\n+    supportingFiles: TestFile[] = []): FatalDiagnosticError {\n+  const {program} = makeProgram(\n+      [{name: _('/entry.ts'), contents: `${code}; const target$ = ${expr}`}, ...supportingFiles],\n+      /* options */ undefined, /* host */ undefined, /* checkForErrors */ false);\n+  const checker = program.getTypeChecker();\n+  const decl = getDeclaration(program, _('/entry.ts'), 'target$', ts.isVariableDeclaration);\n+  const valueExpr = decl.initializer!;\n+\n+  const reflectionHost = new TypeScriptReflectionHost(checker);\n+  const evaluator = new PartialEvaluator(reflectionHost, checker, /* dependencyTracker */ null);\n+\n+  const value = evaluator.evaluate(valueExpr);\n+  return createValueHasWrongTypeError(valueExpr, value, messageText);\n+}"
        },
        {
            "sha": "0822840a9aa7a3d41bbd038203cf55e5479224b5",
            "filename": "packages/compiler-cli/src/ngtsc/diagnostics/src/error.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Fsrc%2Ferror.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Fsrc%2Ferror.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fdiagnostics%2Fsrc%2Ferror.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -8,28 +8,31 @@\n \n import * as ts from 'typescript';\n \n-import {ErrorCode} from './error_code';\n+import {ErrorCode, ngErrorCode} from './error_code';\n \n export class FatalDiagnosticError {\n-  constructor(readonly code: ErrorCode, readonly node: ts.Node, readonly message: string) {}\n+  constructor(\n+      readonly code: ErrorCode, readonly node: ts.Node,\n+      readonly message: string|ts.DiagnosticMessageChain,\n+      readonly relatedInformation?: ts.DiagnosticRelatedInformation[]) {}\n \n   /**\n    * @internal\n    */\n   _isFatalDiagnosticError = true;\n \n   toDiagnostic(): ts.DiagnosticWithLocation {\n-    return makeDiagnostic(this.code, this.node, this.message);\n+    return makeDiagnostic(this.code, this.node, this.message, this.relatedInformation);\n   }\n }\n \n export function makeDiagnostic(\n-    code: ErrorCode, node: ts.Node, messageText: string,\n+    code: ErrorCode, node: ts.Node, messageText: string|ts.DiagnosticMessageChain,\n     relatedInformation?: ts.DiagnosticRelatedInformation[]): ts.DiagnosticWithLocation {\n   node = ts.getOriginalNode(node);\n   return {\n     category: ts.DiagnosticCategory.Error,\n-    code: Number('-99' + code.valueOf()),\n+    code: ngErrorCode(code),\n     file: ts.getOriginalNode(node).getSourceFile(),\n     start: node.getStart(undefined, false),\n     length: node.getWidth(),"
        },
        {
            "sha": "48e6b1e71f2abeebb6140e7b6ac5e43a544f7d87",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2FBUILD.bazel?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -11,6 +11,7 @@ ts_library(\n     deps = [\n         \"//packages:types\",\n         \"//packages/compiler\",\n+        \"//packages/compiler-cli/src/ngtsc/diagnostics\",\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n         \"//packages/compiler-cli/src/ngtsc/incremental:api\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\","
        },
        {
            "sha": "7c3c566524ca71ed1d69c9ef8ea870cc53257124",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Findex.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -6,6 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n+export {describeResolvedType, traceDynamicValue} from './src/diagnostics';\n export {DynamicValue} from './src/dynamic';\n export {ForeignFunctionResolver, PartialEvaluator} from './src/interface';\n export {EnumValue, KnownFn, ResolvedValue, ResolvedValueArray, ResolvedValueMap} from './src/result';"
        },
        {
            "sha": "e6e2b48e9b51ad079be04ef309752266655c8d36",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/src/diagnostics.ts",
            "status": "added",
            "additions": 176,
            "deletions": 0,
            "changes": 176,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Fdiagnostics.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Fdiagnostics.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Fdiagnostics.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -0,0 +1,176 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript';\n+\n+import {makeRelatedInformation} from '../../diagnostics';\n+import {Reference} from '../../imports';\n+import {DynamicValue, DynamicValueVisitor} from './dynamic';\n+import {EnumValue, KnownFn, ResolvedModule, ResolvedValue} from './result';\n+\n+/**\n+ * Derives a type representation from a resolved value to be reported in a diagnostic.\n+ *\n+ * @param value The resolved value for which a type representation should be derived.\n+ * @param maxDepth The maximum nesting depth of objects and arrays, defaults to 1 level.\n+ */\n+export function describeResolvedType(value: ResolvedValue, maxDepth: number = 1): string {\n+  if (value === null) {\n+    return 'null';\n+  } else if (value === undefined) {\n+    return 'undefined';\n+  } else if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'string') {\n+    return typeof value;\n+  } else if (value instanceof Map) {\n+    if (maxDepth === 0) {\n+      return 'object';\n+    }\n+    const entries = Array.from(value.entries()).map(([key, v]) => {\n+      return `${quoteKey(key)}: ${describeResolvedType(v, maxDepth - 1)}`;\n+    });\n+    return entries.length > 0 ? `{ ${entries.join('; ')} }` : '{}';\n+  } else if (value instanceof ResolvedModule) {\n+    return '(module)';\n+  } else if (value instanceof EnumValue) {\n+    return value.enumRef.debugName ?? '(anonymous)';\n+  } else if (value instanceof Reference) {\n+    return value.debugName ?? '(anonymous)';\n+  } else if (Array.isArray(value)) {\n+    if (maxDepth === 0) {\n+      return 'Array';\n+    }\n+    return `[${value.map(v => describeResolvedType(v, maxDepth - 1)).join(', ')}]`;\n+  } else if (value instanceof DynamicValue) {\n+    return '(not statically analyzable)';\n+  } else if (value instanceof KnownFn) {\n+    return 'Function';\n+  } else {\n+    return 'unknown';\n+  }\n+}\n+\n+function quoteKey(key: string): string {\n+  if (/^[a-z0-9_]+$/i.test(key)) {\n+    return key;\n+  } else {\n+    return `'${key.replace(/'/g, '\\\\\\'')}'`;\n+  }\n+}\n+\n+/**\n+ * Creates an array of related information diagnostics for a `DynamicValue` that describe the trace\n+ * of why an expression was evaluated as dynamic.\n+ *\n+ * @param node The node for which a `ts.Diagnostic` is to be created with the trace.\n+ * @param value The dynamic value for which a trace should be created.\n+ */\n+export function traceDynamicValue(\n+    node: ts.Node, value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n+  return value.accept(new TraceDynamicValueVisitor(node));\n+}\n+\n+class TraceDynamicValueVisitor implements DynamicValueVisitor<ts.DiagnosticRelatedInformation[]> {\n+  private currentContainerNode: ts.Node|null = null;\n+\n+  constructor(private node: ts.Node) {}\n+\n+  visitDynamicInput(value: DynamicValue<DynamicValue>): ts.DiagnosticRelatedInformation[] {\n+    const trace = value.reason.accept(this);\n+    if (this.shouldTrace(value.node)) {\n+      const info =\n+          makeRelatedInformation(value.node, 'Unable to evaluate this expression statically.');\n+      trace.unshift(info);\n+    }\n+    return trace;\n+  }\n+\n+  visitDynamicString(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n+    return [makeRelatedInformation(\n+        value.node, 'A string value could not be determined statically.')];\n+  }\n+\n+  visitExternalReference(value: DynamicValue<Reference<ts.Declaration>>):\n+      ts.DiagnosticRelatedInformation[] {\n+    const name = value.reason.debugName;\n+    const description = name !== null ? `'${name}'` : 'an anonymous declaration';\n+    return [makeRelatedInformation(\n+        value.node,\n+        `A value for ${\n+            description} cannot be determined statically, as it is an external declaration.`)];\n+  }\n+\n+  visitInvalidExpressionType(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n+    return [makeRelatedInformation(value.node, 'Unable to evaluate an invalid expression.')];\n+  }\n+\n+  visitUnknown(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n+    return [makeRelatedInformation(value.node, 'Unable to evaluate statically.')];\n+  }\n+\n+  visitUnknownIdentifier(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n+    return [makeRelatedInformation(value.node, 'Unknown reference.')];\n+  }\n+\n+  visitUnsupportedSyntax(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n+    return [makeRelatedInformation(value.node, 'This syntax is not supported.')];\n+  }\n+\n+  /**\n+   * Determines whether the dynamic value reported for the node should be traced, i.e. if it is not\n+   * part of the container for which the most recent trace was created.\n+   */\n+  private shouldTrace(node: ts.Node): boolean {\n+    if (node === this.node) {\n+      // Do not include a dynamic value for the origin node, as the main diagnostic is already\n+      // reported on that node.\n+      return false;\n+    }\n+\n+    const container = getContainerNode(node);\n+    if (container === this.currentContainerNode) {\n+      // The node is part of the same container as the previous trace entry, so this dynamic value\n+      // should not become part of the trace.\n+      return false;\n+    }\n+\n+    this.currentContainerNode = container;\n+    return true;\n+  }\n+}\n+\n+/**\n+ * Determines the closest parent node that is to be considered as container, which is used to reduce\n+ * the granularity of tracing the dynamic values to a single entry per container. Currently, full\n+ * statements and destructuring patterns are considered as container.\n+ */\n+function getContainerNode(node: ts.Node): ts.Node {\n+  let currentNode: ts.Node|undefined = node;\n+  while (currentNode !== undefined) {\n+    switch (currentNode.kind) {\n+      case ts.SyntaxKind.ExpressionStatement:\n+      case ts.SyntaxKind.VariableStatement:\n+      case ts.SyntaxKind.ReturnStatement:\n+      case ts.SyntaxKind.IfStatement:\n+      case ts.SyntaxKind.SwitchStatement:\n+      case ts.SyntaxKind.DoStatement:\n+      case ts.SyntaxKind.WhileStatement:\n+      case ts.SyntaxKind.ForStatement:\n+      case ts.SyntaxKind.ForInStatement:\n+      case ts.SyntaxKind.ForOfStatement:\n+      case ts.SyntaxKind.ContinueStatement:\n+      case ts.SyntaxKind.BreakStatement:\n+      case ts.SyntaxKind.ThrowStatement:\n+      case ts.SyntaxKind.ObjectBindingPattern:\n+      case ts.SyntaxKind.ArrayBindingPattern:\n+        return currentNode;\n+    }\n+\n+    currentNode = currentNode.parent;\n+  }\n+  return node.getSourceFile();\n+}"
        },
        {
            "sha": "d5b0bb82cc71168c29068846c032291b235cdd1e",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/src/dynamic.ts",
            "status": "modified",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Fdynamic.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Fdynamic.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Fsrc%2Fdynamic.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -124,4 +124,34 @@ export class DynamicValue<R = unknown> {\n   isFromUnknown(this: DynamicValue<R>): this is DynamicValue {\n     return this.code === DynamicValueReason.UNKNOWN;\n   }\n+\n+  accept<R>(visitor: DynamicValueVisitor<R>): R {\n+    switch (this.code) {\n+      case DynamicValueReason.DYNAMIC_INPUT:\n+        return visitor.visitDynamicInput(this as unknown as DynamicValue<DynamicValue>);\n+      case DynamicValueReason.DYNAMIC_STRING:\n+        return visitor.visitDynamicString(this);\n+      case DynamicValueReason.EXTERNAL_REFERENCE:\n+        return visitor.visitExternalReference(\n+            this as unknown as DynamicValue<Reference<ts.Declaration>>);\n+      case DynamicValueReason.UNSUPPORTED_SYNTAX:\n+        return visitor.visitUnsupportedSyntax(this);\n+      case DynamicValueReason.UNKNOWN_IDENTIFIER:\n+        return visitor.visitUnknownIdentifier(this);\n+      case DynamicValueReason.INVALID_EXPRESSION_TYPE:\n+        return visitor.visitInvalidExpressionType(this);\n+      case DynamicValueReason.UNKNOWN:\n+        return visitor.visitUnknown(this);\n+    }\n+  }\n+}\n+\n+export interface DynamicValueVisitor<R> {\n+  visitDynamicInput(value: DynamicValue<DynamicValue>): R;\n+  visitDynamicString(value: DynamicValue): R;\n+  visitExternalReference(value: DynamicValue<Reference<ts.Declaration>>): R;\n+  visitUnsupportedSyntax(value: DynamicValue): R;\n+  visitUnknownIdentifier(value: DynamicValue): R;\n+  visitInvalidExpressionType(value: DynamicValue): R;\n+  visitUnknown(value: DynamicValue): R;\n }"
        },
        {
            "sha": "25cf1cbefe66d34291aa675c20d3b9cbd643416b",
            "filename": "packages/compiler-cli/src/ngtsc/partial_evaluator/test/diagnostics_spec.ts",
            "status": "added",
            "additions": 286,
            "deletions": 0,
            "changes": 286,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Fdiagnostics_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Fdiagnostics_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fpartial_evaluator%2Ftest%2Fdiagnostics_spec.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -0,0 +1,286 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+import * as ts from 'typescript';\n+\n+import {absoluteFrom as _} from '../../file_system';\n+import {runInEachFileSystem} from '../../file_system/testing';\n+import {Reference} from '../../imports';\n+import {TypeScriptReflectionHost} from '../../reflection';\n+import {getDeclaration, makeProgram} from '../../testing';\n+\n+import {ObjectAssignBuiltinFn} from '../src/builtin';\n+import {describeResolvedType, traceDynamicValue} from '../src/diagnostics';\n+import {DynamicValue} from '../src/dynamic';\n+import {PartialEvaluator} from '../src/interface';\n+import {EnumValue, ResolvedModule} from '../src/result';\n+\n+runInEachFileSystem(() => {\n+  describe('partial evaluator', () => {\n+    describe('describeResolvedType()', () => {\n+      it('should describe primitives', () => {\n+        expect(describeResolvedType(0)).toBe('number');\n+        expect(describeResolvedType(true)).toBe('boolean');\n+        expect(describeResolvedType(false)).toBe('boolean');\n+        expect(describeResolvedType(null)).toBe('null');\n+        expect(describeResolvedType(undefined)).toBe('undefined');\n+        expect(describeResolvedType('text')).toBe('string');\n+      });\n+\n+      it('should describe objects limited to a single level', () => {\n+        expect(describeResolvedType(new Map())).toBe('{}');\n+        expect(describeResolvedType(new Map<string, any>([['a', 0], ['b', true]])))\n+            .toBe('{ a: number; b: boolean }');\n+        expect(describeResolvedType(new Map([['a', new Map()]]))).toBe('{ a: object }');\n+        expect(describeResolvedType(new Map([['a', [1, 2, 3]]]))).toBe('{ a: Array }');\n+      });\n+\n+      it('should describe arrays limited to a single level', () => {\n+        expect(describeResolvedType([])).toBe('[]');\n+        expect(describeResolvedType([1, 2, 3])).toBe('[number, number, number]');\n+        expect(describeResolvedType([[1, 2], [3, 4]])).toBe('[Array, Array]');\n+        expect(describeResolvedType([new Map([['a', 0]])])).toBe('[object]');\n+      });\n+\n+      it('should describe references', () => {\n+        const namedFn = ts.createFunctionDeclaration(\n+            /* decorators */ undefined,\n+            /* modifiers */ undefined,\n+            /* asteriskToken */ undefined,\n+            /* name */ 'test',\n+            /* typeParameters */ undefined,\n+            /* parameters */[],\n+            /* type */ undefined,\n+            /* body */ undefined,\n+        );\n+        expect(describeResolvedType(new Reference(namedFn))).toBe('test');\n+\n+        const anonymousFn = ts.createFunctionDeclaration(\n+            /* decorators */ undefined,\n+            /* modifiers */ undefined,\n+            /* asteriskToken */ undefined,\n+            /* name */ undefined,\n+            /* typeParameters */ undefined,\n+            /* parameters */[],\n+            /* type */ undefined,\n+            /* body */ undefined,\n+        );\n+        expect(describeResolvedType(new Reference(anonymousFn))).toBe('(anonymous)');\n+      });\n+\n+      it('should describe enum values', () => {\n+        const decl = ts.createEnumDeclaration(\n+            /* decorators */ undefined,\n+            /* modifiers */ undefined,\n+            /* name */ 'MyEnum',\n+            /* members */[ts.createEnumMember('member', ts.createNumericLiteral('1'))],\n+        );\n+        const ref = new Reference(decl);\n+        expect(describeResolvedType(new EnumValue(ref, 'member', 1))).toBe('MyEnum');\n+      });\n+\n+      it('should describe dynamic values', () => {\n+        const node = ts.createObjectLiteral();\n+        expect(describeResolvedType(DynamicValue.fromUnsupportedSyntax(node)))\n+            .toBe('(not statically analyzable)');\n+      });\n+\n+      it('should describe known functions', () => {\n+        expect(describeResolvedType(new ObjectAssignBuiltinFn())).toBe('Function');\n+      });\n+\n+      it('should describe external modules', () => {\n+        expect(describeResolvedType(new ResolvedModule(new Map(), () => undefined)))\n+            .toBe('(module)');\n+      });\n+    });\n+\n+    describe('traceDynamicValue()', () => {\n+      it('should not include the origin node if points to a different dynamic node.', () => {\n+        // In the below expression, the read of \"value\" is evaluated to be dynamic, but it's also\n+        // the exact node for which the diagnostic is produced. Therefore, this node is not part\n+        // of the trace.\n+        const trace = traceExpression('const value = nonexistent;', 'value');\n+\n+        expect(trace.length).toBe(1);\n+        expect(trace[0].messageText).toBe(`Unknown reference.`);\n+        expect(trace[0].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[0])).toBe('nonexistent');\n+      });\n+\n+      it('should include the origin node if it is dynamic by itself', () => {\n+        const trace = traceExpression('', 'nonexistent;');\n+\n+        expect(trace.length).toBe(1);\n+        expect(trace[0].messageText).toBe(`Unknown reference.`);\n+        expect(trace[0].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[0])).toBe('nonexistent');\n+      });\n+\n+      it('should include a trace for a dynamic subexpression in the origin expression', () => {\n+        const trace = traceExpression('const value = nonexistent;', 'value.property');\n+\n+        expect(trace.length).toBe(2);\n+        expect(trace[0].messageText).toBe('Unable to evaluate this expression statically.');\n+        expect(trace[0].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[0])).toBe('value');\n+\n+        expect(trace[1].messageText).toBe('Unknown reference.');\n+        expect(trace[1].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[1])).toBe('nonexistent');\n+      });\n+\n+      it('should reduce the granularity to a single entry per statement', () => {\n+        // Dynamic values exist for each node that has been visited, but only the initial dynamic\n+        // value within a statement is included in the trace.\n+        const trace = traceExpression(\n+            `const firstChild = document.body.childNodes[0];\n+             const child = firstChild.firstChild;`,\n+            'child !== undefined');\n+\n+        expect(trace.length).toBe(4);\n+        expect(trace[0].messageText).toBe('Unable to evaluate this expression statically.');\n+        expect(trace[0].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[0])).toBe('child');\n+\n+        expect(trace[1].messageText).toBe('Unable to evaluate this expression statically.');\n+        expect(trace[1].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[1])).toBe('firstChild');\n+\n+        expect(trace[2].messageText).toBe('Unable to evaluate this expression statically.');\n+        expect(trace[2].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[2])).toBe('document.body');\n+\n+        expect(trace[3].messageText)\n+            .toBe(\n+                `A value for 'document' cannot be determined statically, as it is an external declaration.`);\n+        expect(trace[3].file!.fileName).toBe(_('/lib.d.ts'));\n+        expect(getSourceCode(trace[3])).toBe('document: any');\n+      });\n+\n+      it('should trace dynamic strings', () => {\n+        const trace = traceExpression('', '`${document}`');\n+\n+        expect(trace.length).toBe(1);\n+        expect(trace[0].messageText).toBe('A string value could not be determined statically.');\n+        expect(trace[0].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[0])).toBe('document');\n+      });\n+\n+      it('should trace invalid expression types', () => {\n+        const trace = traceExpression('', 'true()');\n+\n+        expect(trace.length).toBe(1);\n+        expect(trace[0].messageText).toBe('Unable to evaluate an invalid expression.');\n+        expect(trace[0].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[0])).toBe('true');\n+      });\n+\n+      it('should trace unknown syntax', () => {\n+        const trace = traceExpression('', `new String('test')`);\n+\n+        expect(trace.length).toBe(1);\n+        expect(trace[0].messageText).toBe('This syntax is not supported.');\n+        expect(trace[0].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[0])).toBe('new String(\\'test\\')');\n+      });\n+\n+      it('should trace complex function invocations', () => {\n+        const trace = traceExpression(\n+            `\n+          function complex() {\n+            console.log('test');\n+            return true;\n+          }`,\n+            'complex()');\n+\n+        expect(trace.length).toBe(1);\n+        expect(trace[0].messageText).toBe('Unable to evaluate statically.');\n+        expect(trace[0].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[0])).toBe('complex()');\n+      });\n+\n+      it('should trace object destructuring of external reference', () => {\n+        const trace = traceExpression('const {body: {firstChild}} = document;', 'firstChild');\n+\n+        expect(trace.length).toBe(2);\n+        expect(trace[0].messageText).toBe('Unable to evaluate this expression statically.');\n+        expect(trace[0].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[0])).toBe('body: {firstChild}');\n+\n+        expect(trace[1].messageText)\n+            .toBe(\n+                `A value for 'document' cannot be determined statically, as it is an external declaration.`);\n+        expect(trace[1].file!.fileName).toBe(_('/lib.d.ts'));\n+        expect(getSourceCode(trace[1])).toBe('document: any');\n+      });\n+\n+      it('should trace deep object destructuring of external reference', () => {\n+        const trace =\n+            traceExpression('const {doc: {body: {firstChild}}} = {doc: document};', 'firstChild');\n+\n+        expect(trace.length).toBe(2);\n+        expect(trace[0].messageText).toBe('Unable to evaluate this expression statically.');\n+        expect(trace[0].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[0])).toBe('body: {firstChild}');\n+\n+        expect(trace[1].messageText)\n+            .toBe(\n+                `A value for 'document' cannot be determined statically, as it is an external declaration.`);\n+        expect(trace[1].file!.fileName).toBe(_('/lib.d.ts'));\n+        expect(getSourceCode(trace[1])).toBe('document: any');\n+      });\n+\n+      it('should trace array destructuring of dynamic value', () => {\n+        const trace =\n+            traceExpression('const [firstChild] = document.body.childNodes;', 'firstChild');\n+\n+        expect(trace.length).toBe(3);\n+        expect(trace[0].messageText).toBe('Unable to evaluate this expression statically.');\n+        expect(trace[0].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[0])).toBe('firstChild');\n+\n+        expect(trace[1].messageText).toBe('Unable to evaluate this expression statically.');\n+        expect(trace[1].file!.fileName).toBe(_('/entry.ts'));\n+        expect(getSourceCode(trace[1])).toBe('document.body');\n+\n+        expect(trace[2].messageText)\n+            .toBe(\n+                `A value for 'document' cannot be determined statically, as it is an external declaration.`);\n+        expect(trace[2].file!.fileName).toBe(_('/lib.d.ts'));\n+        expect(getSourceCode(trace[2])).toBe('document: any');\n+      });\n+    });\n+  });\n+});\n+\n+function getSourceCode(diag: ts.DiagnosticRelatedInformation): string {\n+  const text = diag.file!.text;\n+  return text.substr(diag.start!, diag.length!);\n+}\n+\n+function traceExpression(code: string, expr: string): ts.DiagnosticRelatedInformation[] {\n+  const {program} = makeProgram(\n+      [\n+        {name: _('/entry.ts'), contents: `${code}; const target$ = ${expr};`},\n+        {name: _('/lib.d.ts'), contents: `declare const document: any;`},\n+      ],\n+      /* options */ undefined, /* host */ undefined, /* checkForErrors */ false);\n+  const checker = program.getTypeChecker();\n+  const decl = getDeclaration(program, _('/entry.ts'), 'target$', ts.isVariableDeclaration);\n+  const valueExpr = decl.initializer!;\n+\n+  const reflectionHost = new TypeScriptReflectionHost(checker);\n+  const evaluator = new PartialEvaluator(reflectionHost, checker, /* dependencyTracker */ null);\n+\n+  const value = evaluator.evaluate(valueExpr);\n+  if (!(value instanceof DynamicValue)) {\n+    throw new Error('Expected DynamicValue');\n+  }\n+  return traceDynamicValue(valueExpr, value);\n+}"
        },
        {
            "sha": "7e1ae0cde2f8283797b8046e2291a6d036214692",
            "filename": "packages/compiler-cli/test/ngtsc/ngtsc_spec.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 4,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fngtsc_spec.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -1622,7 +1622,8 @@ runInEachFileSystem(os => {\n         expect(errors.length).toBe(1);\n         const {code, messageText} = errors[0];\n         expect(code).toBe(ngErrorCode(errorCode));\n-        expect(trim(messageText as string)).toContain(errorMessage);\n+        const text = ts.flattenDiagnosticMessageText(messageText, '\\n');\n+        expect(trim(text)).toContain(errorMessage);\n       }\n \n       it('should throw if invalid arguments are provided in @NgModule', () => {\n@@ -3428,8 +3429,11 @@ runInEachFileSystem(os => {\n       class CompA {}\n     `);\n       const errors = env.driveDiagnostics();\n-      expect(errors[0].messageText)\n+      expect(errors.length).toBe(1);\n+      const messageText = ts.flattenDiagnosticMessageText(errors[0].messageText, '\\n');\n+      expect(messageText)\n           .toContain('encapsulation must be a member of ViewEncapsulation enum from @angular/core');\n+      expect(messageText).toContain('Value is of type \\'string\\'.');\n     });\n \n     it('should handle `changeDetection` field', () => {\n@@ -3459,9 +3463,12 @@ runInEachFileSystem(os => {\n       class CompA {}\n     `);\n       const errors = env.driveDiagnostics();\n-      expect(errors[0].messageText)\n+      expect(errors.length).toBe(1);\n+      const messageText = ts.flattenDiagnosticMessageText(errors[0].messageText, '\\n');\n+      expect(messageText)\n           .toContain(\n               'changeDetection must be a member of ChangeDetectionStrategy enum from @angular/core');\n+      expect(messageText).toContain('Value is of type \\'string\\'.');\n     });\n \n     it('should ignore empty bindings', () => {\n@@ -4700,7 +4707,10 @@ runInEachFileSystem(os => {\n           `);\n \n           const diags = await driveDiagnostics();\n-          expect(diags[0].messageText).toBe('styleUrls must be an array of strings');\n+          expect(diags.length).toBe(1);\n+          const messageText = ts.flattenDiagnosticMessageText(diags[0].messageText, '\\n');\n+          expect(messageText).toContain('styleUrls must be an array of strings');\n+          expect(messageText).toContain('Value is of type \\'string\\'.');\n           expect(diags[0].file!.fileName).toBe(absoluteFrom('/test.ts'));\n         });\n       });"
        },
        {
            "sha": "69a8b88947a00cd216f16bcc109965c031f5d41a",
            "filename": "packages/compiler-cli/test/ngtsc/scope_spec.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fscope_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/712f1bd0b7fd215c734d1eaa506cfd1847ec2432/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fscope_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngtsc%2Fscope_spec.ts?ref=712f1bd0b7fd215c734d1eaa506cfd1847ec2432",
            "patch": "@@ -205,8 +205,10 @@ runInEachFileSystem(() => {\n         `);\n           const [error] = env.driveDiagnostics();\n           expect(error).not.toBeUndefined();\n-          expect(error.messageText).toContain('IsAModule');\n-          expect(error.messageText).toContain('NgModule.imports');\n+          const messageText = ts.flattenDiagnosticMessageText(error.messageText, '\\n');\n+          expect(messageText)\n+              .toContain('Value at position 0 in the NgModule.imports of IsAModule is not a class');\n+          expect(messageText).toContain('Value is a reference to \\'NotAClass\\'.');\n           expect(error.code).toEqual(ngErrorCode(ErrorCode.VALUE_HAS_WRONG_TYPE));\n           expect(diagnosticToNode(error, ts.isIdentifier).text).toEqual('NotAClass');\n         });"
        }
    ],
    "stats": {
        "total": 824,
        "additions": 739,
        "deletions": 85
    }
}