{
    "author": "nreid260",
    "message": "fix(compiler-cli): Emit type annotations for synthesized decorator fields (#43021)\n\nPreviously, the decorator transformer was annotating the synthesized properties with TS type annotations. However, because it ran after the JSDoc transformer, the TS types were just dropped from the emitted JS. Attempting to move the decorator transformer before the JSDoc transformer causes tsickle crashes because synthetic AST fragments are not attached to a SourceFile node.\n\nPR Close #43021",
    "sha": "4341a5f4cb7969b5c06d46a6afbd95cbccab8d95",
    "files": [
        {
            "sha": "f9da5fa2f3e3e80ae8af2f407c2e8fede1449669",
            "filename": "packages/compiler-cli/src/transformers/downlevel_decorators_transform.ts",
            "status": "modified",
            "additions": 86,
            "deletions": 110,
            "changes": 196,
            "blob_url": "https://github.com/angular/angular/blob/4341a5f4cb7969b5c06d46a6afbd95cbccab8d95/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fdownlevel_decorators_transform.ts",
            "raw_url": "https://github.com/angular/angular/raw/4341a5f4cb7969b5c06d46a6afbd95cbccab8d95/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fdownlevel_decorators_transform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Ftransformers%2Fdownlevel_decorators_transform.ts?ref=4341a5f4cb7969b5c06d46a6afbd95cbccab8d95",
            "patch": "@@ -40,20 +40,7 @@ function isAngularDecorator(decorator: Decorator, isCore: boolean): boolean {\n  #####################################################################\n */\n \n-/**\n- * Creates the AST for the decorator field type annotation, which has the form\n- *     { type: Function, args?: any[] }[]\n- */\n-function createDecoratorInvocationType(): ts.TypeNode {\n-  const typeElements: ts.TypeElement[] = [];\n-  typeElements.push(ts.createPropertySignature(\n-      undefined, 'type', undefined,\n-      ts.createTypeReferenceNode(ts.createIdentifier('Function'), undefined), undefined));\n-  typeElements.push(ts.createPropertySignature(\n-      undefined, 'args', ts.createToken(ts.SyntaxKind.QuestionToken),\n-      ts.createArrayTypeNode(ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)), undefined));\n-  return ts.createArrayTypeNode(ts.createTypeLiteralNode(typeElements));\n-}\n+const DECORATOR_INVOCATION_JSDOC_TYPE = '!Array<{type: !Function, args: (undefined|!Array<?>)}>';\n \n /**\n  * Extracts the type of the decorator (the function or expression invoked), as well as all the\n@@ -100,68 +87,6 @@ function extractMetadataFromSingleDecorator(\n   return ts.createObjectLiteral(metadataProperties);\n }\n \n-/**\n- * Takes a list of decorator metadata object ASTs and produces an AST for a\n- * static class property of an array of those metadata objects.\n- */\n-function createDecoratorClassProperty(decoratorList: ts.ObjectLiteralExpression[]) {\n-  const modifier = ts.createToken(ts.SyntaxKind.StaticKeyword);\n-  const type = createDecoratorInvocationType();\n-  const initializer = ts.createArrayLiteral(decoratorList, true);\n-  // NB: the .decorators property does not get a @nocollapse property. There is\n-  // no good reason why - it means .decorators is not runtime accessible if you\n-  // compile with collapse properties, whereas propDecorators is, which doesn't\n-  // follow any stringent logic. However this has been the case previously, and\n-  // adding it back in leads to substantial code size increases as Closure fails\n-  // to tree shake these props without @nocollapse.\n-  return ts.createProperty(undefined, [modifier], 'decorators', undefined, type, initializer);\n-}\n-\n-/**\n- * Creates the AST for the 'ctorParameters' field type annotation:\n- *   () => ({ type: any, decorators?: {type: Function, args?: any[]}[] }|null)[]\n- */\n-function createCtorParametersClassPropertyType(): ts.TypeNode {\n-  // Sorry about this. Try reading just the string literals below.\n-  const typeElements: ts.TypeElement[] = [];\n-  typeElements.push(ts.createPropertySignature(\n-      undefined, 'type', undefined,\n-      ts.createTypeReferenceNode(ts.createIdentifier('any'), undefined), undefined));\n-  typeElements.push(ts.createPropertySignature(\n-      undefined, 'decorators', ts.createToken(ts.SyntaxKind.QuestionToken),\n-      ts.createArrayTypeNode(ts.createTypeLiteralNode([\n-        ts.createPropertySignature(\n-            undefined, 'type', undefined,\n-            ts.createTypeReferenceNode(ts.createIdentifier('Function'), undefined), undefined),\n-        ts.createPropertySignature(\n-            undefined, 'args', ts.createToken(ts.SyntaxKind.QuestionToken),\n-            ts.createArrayTypeNode(\n-                ts.createTypeReferenceNode(ts.createIdentifier('any'), undefined)),\n-            undefined),\n-      ])),\n-      undefined));\n-\n-  return ts.createFunctionTypeNode(undefined, [], ts.createArrayTypeNode(ts.createUnionTypeNode([\n-    ts.createTypeLiteralNode(typeElements),\n-    ts.createLiteralTypeNode(ts.createNull()),\n-  ])));\n-}\n-\n-/**\n- * Sets a Closure \\@nocollapse synthetic comment on the given node. This prevents Closure Compiler\n- * from collapsing the apparently static property, which would make it impossible to find for code\n- * trying to detect it at runtime.\n- */\n-function addNoCollapseComment(n: ts.Node) {\n-  ts.setSyntheticLeadingComments(n, [{\n-                                   kind: ts.SyntaxKind.MultiLineCommentTrivia,\n-                                   text: '* @nocollapse ',\n-                                   pos: -1,\n-                                   end: -1,\n-                                   hasTrailingNewLine: true\n-                                 }]);\n-}\n-\n /**\n  * createCtorParametersClassProperty creates a static 'ctorParameters' property containing\n  * downleveled decorator information.\n@@ -207,46 +132,31 @@ function createCtorParametersClassProperty(\n   const initializer = ts.createArrowFunction(\n       undefined, undefined, [], undefined, ts.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n       ts.createArrayLiteral(params, true));\n-  const type = createCtorParametersClassPropertyType();\n   const ctorProp = ts.createProperty(\n-      undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], 'ctorParameters', undefined, type,\n-      initializer);\n+      undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], 'ctorParameters', undefined,\n+      undefined, initializer);\n   if (isClosureCompilerEnabled) {\n-    addNoCollapseComment(ctorProp);\n+    ts.setSyntheticLeadingComments(ctorProp, [\n+      {\n+        kind: ts.SyntaxKind.MultiLineCommentTrivia,\n+        text: [\n+          `*`,\n+          ` * @type {function(): !Array<(null|{`,\n+          ` *   type: ?,`,\n+          ` *   decorators: (undefined|${DECORATOR_INVOCATION_JSDOC_TYPE}),`,\n+          ` * })>}`,\n+          ` * @nocollapse`,\n+          ` `,\n+        ].join('\\n'),\n+        pos: -1,\n+        end: -1,\n+        hasTrailingNewLine: true,\n+      },\n+    ]);\n   }\n   return ctorProp;\n }\n \n-/**\n- * createPropDecoratorsClassProperty creates a static 'propDecorators' property containing type\n- * information for every property that has a decorator applied.\n- *\n- *     static propDecorators: {[key: string]: {type: Function, args?: any[]}[]} = {\n- *       propA: [{type: MyDecorator, args: [1, 2]}, ...],\n- *       ...\n- *     };\n- */\n-function createPropDecoratorsClassProperty(\n-    diagnostics: ts.Diagnostic[], properties: Map<string, ts.Decorator[]>): ts.PropertyDeclaration {\n-  //  `static propDecorators: {[key: string]: ` + {type: Function, args?: any[]}[] + `} = {\\n`);\n-  const entries: ts.ObjectLiteralElementLike[] = [];\n-  for (const [name, decorators] of properties.entries()) {\n-    entries.push(ts.createPropertyAssignment(\n-        name,\n-        ts.createArrayLiteral(\n-            decorators.map(deco => extractMetadataFromSingleDecorator(deco, diagnostics)))));\n-  }\n-  const initializer = ts.createObjectLiteral(entries, true);\n-  const type = ts.createTypeLiteralNode([ts.createIndexSignature(\n-      undefined, undefined, [ts.createParameter(\n-                                undefined, undefined, undefined, 'key', undefined,\n-                                ts.createTypeReferenceNode('string', undefined), undefined)],\n-      createDecoratorInvocationType())]);\n-  return ts.createProperty(\n-      undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], 'propDecorators', undefined, type,\n-      initializer);\n-}\n-\n /**\n  * Returns an expression representing the (potentially) value part for the given node.\n  *\n@@ -346,6 +256,72 @@ export function getDownlevelDecoratorsTransform(\n     typeChecker: ts.TypeChecker, host: ReflectionHost, diagnostics: ts.Diagnostic[],\n     isCore: boolean, isClosureCompilerEnabled: boolean,\n     skipClassDecorators: boolean): ts.TransformerFactory<ts.SourceFile> {\n+  function addJSDocTypeAnnotation(node: ts.Node, jsdocType: string): void {\n+    if (!isClosureCompilerEnabled) {\n+      return;\n+    }\n+\n+    ts.setSyntheticLeadingComments(node, [\n+      {\n+        kind: ts.SyntaxKind.MultiLineCommentTrivia,\n+        text: `* @type {${jsdocType}} `,\n+        pos: -1,\n+        end: -1,\n+        hasTrailingNewLine: true,\n+      },\n+    ]);\n+  }\n+\n+  /**\n+   * Takes a list of decorator metadata object ASTs and produces an AST for a\n+   * static class property of an array of those metadata objects.\n+   */\n+  function createDecoratorClassProperty(decoratorList: ts.ObjectLiteralExpression[]) {\n+    const modifier = ts.createToken(ts.SyntaxKind.StaticKeyword);\n+    const initializer = ts.createArrayLiteral(decoratorList, true);\n+    // NB: the .decorators property does not get a @nocollapse property. There\n+    // is no good reason why - it means .decorators is not runtime accessible\n+    // if you compile with collapse properties, whereas propDecorators is,\n+    // which doesn't follow any stringent logic. However this has been the\n+    // case previously, and adding it back in leads to substantial code size\n+    // increases as Closure fails to tree shake these props\n+    // without @nocollapse.\n+    const prop =\n+        ts.createProperty(undefined, [modifier], 'decorators', undefined, undefined, initializer);\n+    addJSDocTypeAnnotation(prop, DECORATOR_INVOCATION_JSDOC_TYPE);\n+    return prop;\n+  }\n+\n+  /**\n+   * createPropDecoratorsClassProperty creates a static 'propDecorators'\n+   * property containing type information for every property that has a\n+   * decorator applied.\n+   *\n+   *     static propDecorators: {[key: string]: {type: Function, args?:\n+   * any[]}[]} = { propA: [{type: MyDecorator, args: [1, 2]}, ...],\n+   *       ...\n+   *     };\n+   */\n+  function createPropDecoratorsClassProperty(\n+      diagnostics: ts.Diagnostic[],\n+      properties: Map<string, ts.Decorator[]>): ts.PropertyDeclaration {\n+    //  `static propDecorators: {[key: string]: ` + {type: Function, args?:\n+    //  any[]}[] + `} = {\\n`);\n+    const entries: ts.ObjectLiteralElementLike[] = [];\n+    for (const [name, decorators] of properties.entries()) {\n+      entries.push(ts.createPropertyAssignment(\n+          name,\n+          ts.createArrayLiteral(\n+              decorators.map(deco => extractMetadataFromSingleDecorator(deco, diagnostics)))));\n+    }\n+    const initializer = ts.createObjectLiteral(entries, true);\n+    const prop = ts.createProperty(\n+        undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], 'propDecorators', undefined,\n+        undefined, initializer);\n+    addJSDocTypeAnnotation(prop, `!Object<string, ${DECORATOR_INVOCATION_JSDOC_TYPE}>`);\n+    return prop;\n+  }\n+\n   return (context: ts.TransformationContext) => {\n     // Ensure that referenced type symbols are not elided by TypeScript. Imports for\n     // such parameter type symbols previously could be type-only, but now might be also"
        },
        {
            "sha": "d7c7a0e8873e0e63a0543980285e0885a8b0c374",
            "filename": "packages/compiler-cli/test/ngc_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/4341a5f4cb7969b5c06d46a6afbd95cbccab8d95/packages%2Fcompiler-cli%2Ftest%2Fngc_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4341a5f4cb7969b5c06d46a6afbd95cbccab8d95/packages%2Fcompiler-cli%2Ftest%2Fngc_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Fngc_spec.ts?ref=4341a5f4cb7969b5c06d46a6afbd95cbccab8d95",
            "patch": "@@ -715,7 +715,7 @@ describe('ngc transformer command-line', () => {\n         const mymoduleSource = fs.readFileSync(mymodulejs, 'utf8');\n         expect(mymoduleSource).toContain('@fileoverview added by tsickle');\n         expect(mymoduleSource).toContain('@param {?} p');\n-        expect(mymoduleSource).toMatch(/\\/\\*\\* @nocollapse \\*\\/\\s+MyComp\\.ctorParameters = /);\n+        expect(mymoduleSource).toContain('@nocollapse');\n       });\n     });\n "
        },
        {
            "sha": "eaee4b84da1b352b4185abea38db77124768241b",
            "filename": "packages/compiler-cli/test/transformers/downlevel_decorators_transform_spec.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/4341a5f4cb7969b5c06d46a6afbd95cbccab8d95/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fdownlevel_decorators_transform_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/4341a5f4cb7969b5c06d46a6afbd95cbccab8d95/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fdownlevel_decorators_transform_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Ftest%2Ftransformers%2Fdownlevel_decorators_transform_spec.ts?ref=4341a5f4cb7969b5c06d46a6afbd95cbccab8d95",
            "patch": "@@ -424,11 +424,18 @@ describe('downlevel decorator transform', () => {\n \n     expect(diagnostics.length).toBe(0);\n     expect(output).toContain(dedent`\n+      /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */\n       MyDir.decorators = [\n         { type: core_1.Directive }\n       ];\n-      /** @nocollapse */\n-      MyDir.ctorParameters = () => [\n+      /**\n+       * @type {function(): !Array<(null|{\n+       *   type: ?,\n+       *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),\n+       * })>}\n+       * @nocollapse\n+       */\n+       MyDir.ctorParameters = () => [\n         { type: ClassInject }\n       ];\n     `);"
        }
    ],
    "stats": {
        "total": 209,
        "additions": 96,
        "deletions": 113
    }
}