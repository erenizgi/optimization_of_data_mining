{
    "author": "atscott",
    "message": "fix(compiler): always match close tag to the nearest open element (#42554)\n\nThis commit updates the parser logic to continue to try to match an end\ntag to an unclosed open tag on the stack. Previously, it would only\npush an error to the list and stop looking at unclosed elements.\n\nFor example, the invalid HTML of `<li><div></li>`, has an unclosed\nelement stack of [`li`, `div`] when it encounters the close `li` tag.\nWe compare against the previously unclosed tag `div` and see that this is\nunexpected. Instead of simply giving up here, we continue to move up the\nunclosed tags until we find a match (if there is one).\n\nPR Close #42554",
    "sha": "8c1e0e6ad0eba7ece827d899311cf7d25f64db1a",
    "files": [
        {
            "sha": "24465f8e972b0d355fa7c950c7c8d78c0a0fb7e8",
            "filename": "packages/compiler/src/ml_parser/parser.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/8c1e0e6ad0eba7ece827d899311cf7d25f64db1a/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/8c1e0e6ad0eba7ece827d899311cf7d25f64db1a/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fml_parser%2Fparser.ts?ref=8c1e0e6ad0eba7ece827d899311cf7d25f64db1a",
            "patch": "@@ -313,6 +313,7 @@ class _TreeBuilder {\n    * opening tag is recovered).\n    */\n   private _popElement(fullName: string, endSourceSpan: ParseSourceSpan|null): boolean {\n+    let unexpectedCloseTagDetected = false;\n     for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n       const el = this._elementStack[stackIndex];\n       if (el.name == fullName) {\n@@ -323,11 +324,14 @@ class _TreeBuilder {\n         el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;\n \n         this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n-        return true;\n+        return !unexpectedCloseTagDetected;\n       }\n \n       if (!this.getTagDefinition(el.name).closedByParent) {\n-        return false;\n+        // Note that we encountered an unexpected close tag but continue processing the element\n+        // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this\n+        // end tag in the stack.\n+        unexpectedCloseTagDetected = true;\n       }\n     }\n     return false;"
        },
        {
            "sha": "b971d9187a7249f362b619c35a7ccb58ad62f62c",
            "filename": "packages/compiler/test/ml_parser/html_parser_spec.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/angular/angular/blob/8c1e0e6ad0eba7ece827d899311cf7d25f64db1a/packages%2Fcompiler%2Ftest%2Fml_parser%2Fhtml_parser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/8c1e0e6ad0eba7ece827d899311cf7d25f64db1a/packages%2Fcompiler%2Ftest%2Fml_parser%2Fhtml_parser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fml_parser%2Fhtml_parser_spec.ts?ref=8c1e0e6ad0eba7ece827d899311cf7d25f64db1a",
            "patch": "@@ -857,6 +857,20 @@ import {humanizeDom, humanizeDomSourceSpans, humanizeLineColumn, humanizeNodes}\n           ]]);\n         });\n \n+        it('gets correct close tag for parent when a child is not closed', () => {\n+          const {errors, rootNodes} = parser.parse('<div><span></div>', 'TestComp');\n+          expect(errors.length).toEqual(1);\n+          expect(humanizeErrors(errors)).toEqual([[\n+            'div',\n+            'Unexpected closing tag \"div\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags',\n+            '0:11'\n+          ]]);\n+          expect(humanizeNodes(rootNodes, true)).toEqual([\n+            [html.Element, 'div', 0, '<div><span></div>', '<div>', '</div>'],\n+            [html.Element, 'span', 1, '<span>', '<span>', null],\n+          ]);\n+        });\n+\n         describe('incomplete element tag', () => {\n           it('should parse and report incomplete tags after the tag name', () => {\n             const {errors, rootNodes} = parser.parse('<div<span><div  </span>', 'TestComp');"
        }
    ],
    "stats": {
        "total": 22,
        "additions": 20,
        "deletions": 2
    }
}