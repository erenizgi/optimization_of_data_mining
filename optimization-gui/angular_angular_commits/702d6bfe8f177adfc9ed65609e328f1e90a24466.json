{
    "author": "atscott",
    "message": "refactor(compiler-cli): use keySpan for output event lookup (#39515)\n\nPR #39665 added the `keySpan` to the output field access so we no longer\nneed to get there from the call expression and can instead just find the\nnode we want directly.\n\nPR Close #39515",
    "sha": "702d6bfe8f177adfc9ed65609e328f1e90a24466",
    "files": [
        {
            "sha": "00a1b32988f2e65a75a154e3a356bdb450f0910b",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 11,
            "changes": 19,
            "blob_url": "https://github.com/angular/angular/blob/702d6bfe8f177adfc9ed65609e328f1e90a24466/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "raw_url": "https://github.com/angular/angular/raw/702d6bfe8f177adfc9ed65609e328f1e90a24466/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftemplate_symbol_builder.ts?ref=702d6bfe8f177adfc9ed65609e328f1e90a24466",
            "patch": "@@ -18,7 +18,6 @@ import {DirectiveSymbol, DomBindingSymbol, ElementSymbol, ExpressionSymbol, Inpu\n import {ExpressionIdentifier, findAllMatchingNodes, findFirstMatchingNode, hasExpressionIdentifier} from './comments';\n import {TemplateData} from './context';\n import {isAccessExpression} from './ts_util';\n-import {TcbDirectiveOutputsOp} from './type_check_block';\n \n /**\n  * Generates and caches `Symbol`s for various template structures for a given component.\n@@ -169,9 +168,9 @@ export class SymbolBuilder {\n     // Outputs are a `ts.CallExpression` that look like one of the two:\n     // * _outputHelper(_t1[\"outputField\"]).subscribe(handler);\n     // * _t1.addEventListener(handler);\n-    const node = findFirstMatchingNode(\n-        this.typeCheckBlock, {withSpan: eventBinding.sourceSpan, filter: ts.isCallExpression});\n-    if (node === null) {\n+    const outputFieldAccess = findFirstMatchingNode(\n+        this.typeCheckBlock, {withSpan: eventBinding.keySpan, filter: isAccessExpression});\n+    if (outputFieldAccess === null) {\n       return null;\n     }\n \n@@ -181,12 +180,12 @@ export class SymbolBuilder {\n     }\n \n     if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n-      if (!ts.isPropertyAccessExpression(node.expression) ||\n-          node.expression.name.text !== 'addEventListener') {\n+      if (!ts.isPropertyAccessExpression(outputFieldAccess) ||\n+          outputFieldAccess.name.text !== 'addEventListener') {\n         return null;\n       }\n \n-      const addEventListener = node.expression.name;\n+      const addEventListener = outputFieldAccess.name;\n       const tsSymbol = this.getTypeChecker().getSymbolAtLocation(addEventListener);\n       const tsType = this.getTypeChecker().getTypeAtLocation(addEventListener);\n       const positionInShimFile = this.getShimPositionForNode(addEventListener);\n@@ -207,11 +206,9 @@ export class SymbolBuilder {\n         }],\n       };\n     } else {\n-      const outputFieldAccess = TcbDirectiveOutputsOp.decodeOutputCallExpression(node);\n-      if (outputFieldAccess === null) {\n+      if (!ts.isElementAccessExpression(outputFieldAccess)) {\n         return null;\n       }\n-\n       const tsSymbol =\n           this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);\n       if (tsSymbol === undefined) {\n@@ -225,7 +222,7 @@ export class SymbolBuilder {\n       }\n \n       const positionInShimFile = this.getShimPositionForNode(outputFieldAccess);\n-      const tsType = this.getTypeChecker().getTypeAtLocation(node);\n+      const tsType = this.getTypeChecker().getTypeAtLocation(outputFieldAccess);\n       return {\n         kind: SymbolKind.Output,\n         bindings: [{"
        },
        {
            "sha": "55713439b9fd7f80453a333e18d09ff31ae5fa9d",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 34,
            "changes": 37,
            "blob_url": "https://github.com/angular/angular/blob/702d6bfe8f177adfc9ed65609e328f1e90a24466/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "raw_url": "https://github.com/angular/angular/raw/702d6bfe8f177adfc9ed65609e328f1e90a24466/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Ftype_check_block.ts?ref=702d6bfe8f177adfc9ed65609e328f1e90a24466",
            "patch": "@@ -902,39 +902,6 @@ export class TcbDirectiveOutputsOp extends TcbOp {\n \n     return null;\n   }\n-\n-  /**\n-   * Outputs are a `ts.CallExpression` that look like one of the two:\n-   *  - `_outputHelper(_t1[\"outputField\"]).subscribe(handler);`\n-   *  - `_t1.addEventListener(handler);`\n-   * This method reverses the operations to create a call expression for a directive output.\n-   * It unpacks the given call expression and returns the original element access (i.e.\n-   * `_t1[\"outputField\"]` in the example above). Returns `null` if the given call expression is not\n-   * the expected structure of an output binding\n-   */\n-  static decodeOutputCallExpression(node: ts.CallExpression): ts.ElementAccessExpression|null {\n-    // `node.expression` === `_outputHelper(_t1[\"outputField\"]).subscribe` or `_t1.addEventListener`\n-    if (!ts.isPropertyAccessExpression(node.expression) ||\n-        node.expression.name.text === 'addEventListener') {\n-      // `addEventListener` outputs do not have an `ElementAccessExpression` for the output field.\n-      return null;\n-    }\n-\n-    if (!ts.isCallExpression(node.expression.expression)) {\n-      return null;\n-    }\n-\n-    // `node.expression.expression` === `_outputHelper(_t1[\"outputField\"])`\n-    if (node.expression.expression.arguments.length === 0) {\n-      return null;\n-    }\n-\n-    const [outputFieldAccess] = node.expression.expression.arguments;\n-    if (!ts.isElementAccessExpression(outputFieldAccess)) {\n-      return null;\n-    }\n-    return outputFieldAccess;\n-  }\n }\n \n /**\n@@ -984,8 +951,10 @@ class TcbUnclaimedOutputsOp extends TcbOp {\n         if (elId === null) {\n           elId = this.scope.resolve(this.element);\n         }\n+        const propertyAccess = ts.createPropertyAccess(elId, 'addEventListener');\n+        addParseSpanInfo(propertyAccess, output.keySpan);\n         const call = ts.createCall(\n-            /* expression */ ts.createPropertyAccess(elId, 'addEventListener'),\n+            /* expression */ propertyAccess,\n             /* typeArguments */ undefined,\n             /* arguments */[ts.createStringLiteral(output.name), handler]);\n         addParseSpanInfo(call, output.sourceSpan);"
        }
    ],
    "stats": {
        "total": 56,
        "additions": 11,
        "deletions": 45
    }
}