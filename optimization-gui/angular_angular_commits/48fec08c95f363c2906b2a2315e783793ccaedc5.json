{
    "author": "alxhub",
    "message": "perf(compiler-cli): refactor the performance tracing infrastructure (#41125)\n\nngtsc has an internal performance tracing package, which previously has not\nreally seen much use. It used to track performance statistics on a very\ngranular basis (microseconds per actual class analysis, for example). This\nhad two problems:\n\n* it produced voluminous amounts of data, complicating the analysis of such\n  results and providing dubious value.\n* it added nontrivial overhead to compilation when used (which also affected\n  the very performance of the operations being measured).\n\nThis commit replaces the old system with a streamlined performance tracing\nsetup which is lightweight and designed to be always-on. The new system\ntracks 3 metrics:\n\n* time taken by various phases and operations within the compiler\n* events (counters) which measure the shape and size of the compilation\n* memory usage measured at various points of the compilation process\n\nIf the compiler option `tracePerformance` is set, the compiler will\nserialize these metrics to a JSON file at that location after compilation is\ncomplete.\n\nPR Close #41125",
    "sha": "48fec08c95f363c2906b2a2315e783793ccaedc5",
    "files": [
        {
            "sha": "198caa660462ab816825f5414215b28576c9bd32",
            "filename": "packages/bazel/src/ngc-wrapped/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fbazel%2Fsrc%2Fngc-wrapped%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fbazel%2Fsrc%2Fngc-wrapped%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbazel%2Fsrc%2Fngc-wrapped%2FBUILD.bazel?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -16,6 +16,7 @@ ts_library(\n     ],\n     deps = [\n         \"//packages/compiler-cli\",\n+        \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"@npm//@bazel/typescript\",\n         \"@npm//@types/node\",\n         \"@npm//tsickle\","
        },
        {
            "sha": "477a1a38d2bb5c79e9d5fd6834482639df91ba53",
            "filename": "packages/bazel/src/ngc-wrapped/index.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fbazel%2Fsrc%2Fngc-wrapped%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fbazel%2Fsrc%2Fngc-wrapped%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fbazel%2Fsrc%2Fngc-wrapped%2Findex.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -7,6 +7,7 @@\n  */\n \n import * as ng from '@angular/compiler-cli';\n+import {PerfPhase} from '@angular/compiler-cli/src/ngtsc/perf';\n import {BazelOptions, CachedFileLoader, CompilerHost, constructManifest, debug, FileCache, FileLoader, parseTsconfig, resolveNormalizedPath, runAsWorker, runWorkerLoop, UncachedFileLoader} from '@bazel/typescript';\n import * as fs from 'fs';\n import * as path from 'path';\n@@ -515,6 +516,12 @@ function gatherDiagnosticsForInputsOnly(\n     options: ng.CompilerOptions, bazelOpts: BazelOptions,\n     ngProgram: ng.Program): (ng.Diagnostic|ts.Diagnostic)[] {\n   const tsProgram = ngProgram.getTsProgram();\n+\n+  // For the Ivy compiler, track the amount of time spent fetching TypeScript diagnostics.\n+  let previousPhase = PerfPhase.Unaccounted;\n+  if (ngProgram instanceof ng.NgtscProgram) {\n+    previousPhase = ngProgram.compiler.perfRecorder.phase(PerfPhase.TypeScriptDiagnostics);\n+  }\n   const diagnostics: (ng.Diagnostic|ts.Diagnostic)[] = [];\n   // These checks mirror ts.getPreEmitDiagnostics, with the important\n   // exception of avoiding b/30708240, which is that if you call\n@@ -529,6 +536,11 @@ function gatherDiagnosticsForInputsOnly(\n     diagnostics.push(...tsProgram.getSyntacticDiagnostics(sf));\n     diagnostics.push(...tsProgram.getSemanticDiagnostics(sf));\n   }\n+\n+  if (ngProgram instanceof ng.NgtscProgram) {\n+    ngProgram.compiler.perfRecorder.phase(previousPhase);\n+  }\n+\n   if (!diagnostics.length) {\n     // only gather the angular diagnostics if we have no diagnostics\n     // in any other files."
        },
        {
            "sha": "1247ebc2f4c5c1cba82972adbb69713c8142268c",
            "filename": "packages/compiler-cli/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Findex.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -22,5 +22,6 @@ export {CompilerOptions as AngularCompilerOptions} from './src/transformers/api'\n \n export {ngToTsDiagnostic} from './src/transformers/util';\n export {NgTscPlugin} from './src/ngtsc/tsc_plugin';\n+export {NgtscProgram} from './src/ngtsc/program';\n \n setFileSystem(new NodeJSFileSystem());"
        },
        {
            "sha": "54f2b08dc4acbc8dc705c22a7437ea80f14693d2",
            "filename": "packages/compiler-cli/ngcc/src/analysis/decoration_analyzer.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 6,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fdecoration_analyzer.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fdecoration_analyzer.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Fanalysis%2Fdecoration_analyzer.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -6,6 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n import {ConstantPool} from '@angular/compiler';\n+import {NOOP_PERF_RECORDER} from '@angular/compiler-cli/src/ngtsc/perf';\n import * as ts from 'typescript';\n \n import {ParsedConfiguration} from '../../..';\n@@ -89,7 +90,7 @@ export class DecorationAnalyzer {\n   fullRegistry = new CompoundMetadataRegistry([this.metaRegistry, this.scopeRegistry]);\n   evaluator =\n       new PartialEvaluator(this.reflectionHost, this.typeChecker, /* dependencyTracker */ null);\n-  importGraph = new ImportGraph(this.typeChecker);\n+  importGraph = new ImportGraph(this.typeChecker, NOOP_PERF_RECORDER);\n   cycleAnalyzer = new CycleAnalyzer(this.importGraph);\n   injectableRegistry = new InjectableClassRegistry(this.reflectionHost);\n   typeCheckScopeRegistry = new TypeCheckScopeRegistry(this.scopeRegistry, this.fullMetaReader);\n@@ -104,7 +105,8 @@ export class DecorationAnalyzer {\n         /* i18nNormalizeLineEndingsInICUs */ false, this.moduleResolver, this.cycleAnalyzer,\n         CycleHandlingStrategy.UseRemoteScoping, this.refEmitter, NOOP_DEFAULT_IMPORT_RECORDER,\n         NOOP_DEPENDENCY_TRACKER, this.injectableRegistry,\n-        /* semanticDepGraphUpdater */ null, !!this.compilerOptions.annotateForClosureCompiler),\n+        /* semanticDepGraphUpdater */ null, !!this.compilerOptions.annotateForClosureCompiler,\n+        NOOP_PERF_RECORDER),\n \n     // See the note in ngtsc about why this cast is needed.\n     // clang-format off\n@@ -117,23 +119,26 @@ export class DecorationAnalyzer {\n         // version 10, undecorated classes that use Angular features are no longer handled\n         // in ngtsc, but we want to ensure compatibility in ngcc for outdated libraries that\n         // have not migrated to explicit decorators. See: https://hackmd.io/@alx/ryfYYuvzH.\n-        /* compileUndecoratedClassesWithAngularFeatures */ true\n+        /* compileUndecoratedClassesWithAngularFeatures */ true,\n+        NOOP_PERF_RECORDER\n     ) as DecoratorHandler<unknown, unknown, SemanticSymbol|null,unknown>,\n     // clang-format on\n     // Pipe handler must be before injectable handler in list so pipe factories are printed\n     // before injectable factories (so injectable factories can delegate to them)\n     new PipeDecoratorHandler(\n         this.reflectionHost, this.evaluator, this.metaRegistry, this.scopeRegistry,\n-        NOOP_DEFAULT_IMPORT_RECORDER, this.injectableRegistry, this.isCore),\n+        NOOP_DEFAULT_IMPORT_RECORDER, this.injectableRegistry, this.isCore, NOOP_PERF_RECORDER),\n     new InjectableDecoratorHandler(\n         this.reflectionHost, NOOP_DEFAULT_IMPORT_RECORDER, this.isCore,\n-        /* strictCtorDeps */ false, this.injectableRegistry, /* errorOnDuplicateProv */ false),\n+        /* strictCtorDeps */ false, this.injectableRegistry, NOOP_PERF_RECORDER,\n+        /* errorOnDuplicateProv */ false),\n     new NgModuleDecoratorHandler(\n         this.reflectionHost, this.evaluator, this.fullMetaReader, this.fullRegistry,\n         this.scopeRegistry, this.referencesRegistry, this.isCore, /* routeAnalyzer */ null,\n         this.refEmitter,\n         /* factoryTracker */ null, NOOP_DEFAULT_IMPORT_RECORDER,\n-        !!this.compilerOptions.annotateForClosureCompiler, this.injectableRegistry),\n+        !!this.compilerOptions.annotateForClosureCompiler, this.injectableRegistry,\n+        NOOP_PERF_RECORDER),\n   ];\n   compiler = new NgccTraitCompiler(this.handlers, this.reflectionHost);\n   migrations: Migration[] = ["
        },
        {
            "sha": "b10a14584e93fcb974fbbf8478d5fe23bffa72fc",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2FBUILD.bazel?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -18,6 +18,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/indexer\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n         \"//packages/compiler-cli/src/ngtsc/partial_evaluator\",\n+        \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"//packages/compiler-cli/src/ngtsc/routing\",\n         \"//packages/compiler-cli/src/ngtsc/scope\","
        },
        {
            "sha": "597d70d3d0c49a67aef53bead6c44a1b6fff6dfb",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/component.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fcomponent.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -18,6 +18,7 @@ import {extractSemanticTypeParameters, isArrayEqual, isReferenceEqual, SemanticD\n import {IndexingContext} from '../../indexer';\n import {ClassPropertyMapping, ComponentResources, DirectiveMeta, DirectiveTypeCheckMeta, extractDirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry, Resource, ResourceRegistry} from '../../metadata';\n import {EnumValue, PartialEvaluator, ResolvedValue} from '../../partial_evaluator';\n+import {PerfEvent, PerfRecorder} from '../../perf';\n import {ClassDeclaration, DeclarationNode, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n import {ComponentScopeReader, LocalModuleScopeRegistry, TypeCheckScopeRegistry} from '../../scope';\n import {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerFlags, HandlerPrecedence, ResolveResult} from '../../transform';\n@@ -208,7 +209,7 @@ export class ComponentDecoratorHandler implements\n       private depTracker: DependencyTracker|null,\n       private injectableRegistry: InjectableClassRegistry,\n       private semanticDepGraphUpdater: SemanticDepGraphUpdater|null,\n-      private annotateForClosureCompiler: boolean) {}\n+      private annotateForClosureCompiler: boolean, private perf: PerfRecorder) {}\n \n   private literalCache = new Map<Decorator, ts.ObjectLiteralExpression>();\n   private elementSchemaRegistry = new DomElementSchemaRegistry();\n@@ -309,6 +310,7 @@ export class ComponentDecoratorHandler implements\n   analyze(\n       node: ClassDeclaration, decorator: Readonly<Decorator>,\n       flags: HandlerFlags = HandlerFlags.NONE): AnalysisOutput<ComponentAnalysisData> {\n+    this.perf.eventCount(PerfEvent.AnalyzeComponent);\n     const containingFile = node.getSourceFile().fileName;\n     this.literalCache.delete(decorator);\n "
        },
        {
            "sha": "86cc55d0d3d4d0405278db3930cd2d6fbcadeabf",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/directive.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fdirective.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -16,6 +16,7 @@ import {areTypeParametersEqual, extractSemanticTypeParameters, isArrayEqual, isS\n import {BindingPropertyName, ClassPropertyMapping, ClassPropertyName, DirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry, TemplateGuardMeta} from '../../metadata';\n import {extractDirectiveTypeCheckMeta} from '../../metadata/src/util';\n import {DynamicValue, EnumValue, PartialEvaluator} from '../../partial_evaluator';\n+import {PerfEvent, PerfRecorder} from '../../perf';\n import {ClassDeclaration, ClassMember, ClassMemberKind, Decorator, filterToMembersWithDecorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n import {LocalModuleScopeRegistry} from '../../scope';\n import {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerFlags, HandlerPrecedence, ResolveResult} from '../../transform';\n@@ -180,7 +181,7 @@ export class DirectiveDecoratorHandler implements\n       private injectableRegistry: InjectableClassRegistry, private isCore: boolean,\n       private semanticDepGraphUpdater: SemanticDepGraphUpdater|null,\n       private annotateForClosureCompiler: boolean,\n-      private compileUndecoratedClassesWithAngularFeatures: boolean) {}\n+      private compileUndecoratedClassesWithAngularFeatures: boolean, private perf: PerfRecorder) {}\n \n   readonly precedence = HandlerPrecedence.PRIMARY;\n   readonly name = DirectiveDecoratorHandler.name;\n@@ -211,6 +212,8 @@ export class DirectiveDecoratorHandler implements\n       return {diagnostics: [getUndecoratedClassWithAngularFeaturesDiagnostic(node)]};\n     }\n \n+    this.perf.eventCount(PerfEvent.AnalyzeDirective);\n+\n     const directiveResult = extractDirectiveMetadata(\n         node, decorator, this.reflector, this.evaluator, this.defaultImportRecorder, this.isCore,\n         flags, this.annotateForClosureCompiler);"
        },
        {
            "sha": "0f420934e06923c64d8f4e4af12336a862d1a303",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Finjectable.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Finjectable.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Finjectable.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -12,6 +12,7 @@ import * as ts from 'typescript';\n import {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\n import {DefaultImportRecorder} from '../../imports';\n import {InjectableClassRegistry} from '../../metadata';\n+import {PerfEvent, PerfRecorder} from '../../perf';\n import {ClassDeclaration, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n import {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence} from '../../transform';\n \n@@ -34,7 +35,7 @@ export class InjectableDecoratorHandler implements\n   constructor(\n       private reflector: ReflectionHost, private defaultImportRecorder: DefaultImportRecorder,\n       private isCore: boolean, private strictCtorDeps: boolean,\n-      private injectableRegistry: InjectableClassRegistry,\n+      private injectableRegistry: InjectableClassRegistry, private perf: PerfRecorder,\n       /**\n        * What to do if the injectable already contains a ɵprov property.\n        *\n@@ -64,6 +65,8 @@ export class InjectableDecoratorHandler implements\n \n   analyze(node: ClassDeclaration, decorator: Readonly<Decorator>):\n       AnalysisOutput<InjectableHandlerData> {\n+    this.perf.eventCount(PerfEvent.AnalyzeInjectable);\n+\n     const meta = extractInjectableMetadata(node, decorator, this.reflector);\n     const decorators = this.reflector.getDecoratorsOfDeclaration(node);\n "
        },
        {
            "sha": "ac8f3562cc941bb4e6ef7919caf7123f339984ae",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/ng_module.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fng_module.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -14,6 +14,7 @@ import {DefaultImportRecorder, Reference, ReferenceEmitter} from '../../imports'\n import {isArrayEqual, isReferenceEqual, isSymbolEqual, SemanticReference, SemanticSymbol} from '../../incremental/semantic_graph';\n import {InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\n import {PartialEvaluator, ResolvedValue} from '../../partial_evaluator';\n+import {PerfEvent, PerfRecorder} from '../../perf';\n import {ClassDeclaration, Decorator, isNamedClassDeclaration, ReflectionHost, reflectObjectLiteral, typeNodeToValueExpr} from '../../reflection';\n import {NgModuleRouteAnalyzer} from '../../routing';\n import {LocalModuleScopeRegistry, ScopeData} from '../../scope';\n@@ -131,7 +132,8 @@ export class NgModuleDecoratorHandler implements\n       private factoryTracker: FactoryTracker|null,\n       private defaultImportRecorder: DefaultImportRecorder,\n       private annotateForClosureCompiler: boolean,\n-      private injectableRegistry: InjectableClassRegistry, private localeId?: string) {}\n+      private injectableRegistry: InjectableClassRegistry, private perf: PerfRecorder,\n+      private localeId?: string) {}\n \n   readonly precedence = HandlerPrecedence.PRIMARY;\n   readonly name = NgModuleDecoratorHandler.name;\n@@ -154,6 +156,8 @@ export class NgModuleDecoratorHandler implements\n \n   analyze(node: ClassDeclaration, decorator: Readonly<Decorator>):\n       AnalysisOutput<NgModuleAnalysis> {\n+    this.perf.eventCount(PerfEvent.AnalyzeNgModule);\n+\n     const name = node.name.text;\n     if (decorator.args === null || decorator.args.length > 1) {\n       throw new FatalDiagnosticError("
        },
        {
            "sha": "102aa1bd47486c40741ffc9d50bfee38f0625841",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/src/pipe.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fpipe.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fpipe.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Fsrc%2Fpipe.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -14,6 +14,7 @@ import {DefaultImportRecorder, Reference} from '../../imports';\n import {SemanticSymbol} from '../../incremental/semantic_graph';\n import {InjectableClassRegistry, MetadataRegistry} from '../../metadata';\n import {PartialEvaluator} from '../../partial_evaluator';\n+import {PerfEvent, PerfRecorder} from '../../perf';\n import {ClassDeclaration, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\n import {LocalModuleScopeRegistry} from '../../scope';\n import {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence, ResolveResult} from '../../transform';\n@@ -55,7 +56,8 @@ export class PipeDecoratorHandler implements\n       private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n       private metaRegistry: MetadataRegistry, private scopeRegistry: LocalModuleScopeRegistry,\n       private defaultImportRecorder: DefaultImportRecorder,\n-      private injectableRegistry: InjectableClassRegistry, private isCore: boolean) {}\n+      private injectableRegistry: InjectableClassRegistry, private isCore: boolean,\n+      private perf: PerfRecorder) {}\n \n   readonly precedence = HandlerPrecedence.PRIMARY;\n   readonly name = PipeDecoratorHandler.name;\n@@ -78,6 +80,8 @@ export class PipeDecoratorHandler implements\n \n   analyze(clazz: ClassDeclaration, decorator: Readonly<Decorator>):\n       AnalysisOutput<PipeHandlerData> {\n+    this.perf.eventCount(PerfEvent.AnalyzePipe);\n+\n     const name = clazz.name.text;\n     const type = wrapTypeReference(this.reflector, clazz);\n     const internalType = new WrappedNodeExpr(this.reflector.getInternalNameOfClass(clazz));"
        },
        {
            "sha": "88a4280c2e73263cd28fcc4b7329e973fd9ca9c3",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2FBUILD.bazel?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -20,6 +20,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/incremental:api\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n         \"//packages/compiler-cli/src/ngtsc/partial_evaluator\",\n+        \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"//packages/compiler-cli/src/ngtsc/scope\",\n         \"//packages/compiler-cli/src/ngtsc/testing\","
        },
        {
            "sha": "ccd010802a291301b116c0dc9dd54858d14efd9c",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/component_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fcomponent_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fcomponent_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fcomponent_spec.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -16,6 +16,7 @@ import {runInEachFileSystem} from '../../file_system/testing';\n import {ModuleResolver, NOOP_DEFAULT_IMPORT_RECORDER, ReferenceEmitter} from '../../imports';\n import {CompoundMetadataReader, DtsMetadataReader, InjectableClassRegistry, LocalMetadataRegistry, ResourceRegistry} from '../../metadata';\n import {PartialEvaluator} from '../../partial_evaluator';\n+import {NOOP_PERF_RECORDER} from '../../perf';\n import {isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n import {LocalModuleScopeRegistry, MetadataDtsModuleScopeResolver, TypeCheckScopeRegistry} from '../../scope';\n import {getDeclaration, makeProgram} from '../../testing';\n@@ -41,7 +42,7 @@ function setup(program: ts.Program, options: ts.CompilerOptions, host: ts.Compil\n   const evaluator = new PartialEvaluator(reflectionHost, checker, /* dependencyTracker */ null);\n   const moduleResolver =\n       new ModuleResolver(program, options, host, /* moduleResolutionCache */ null);\n-  const importGraph = new ImportGraph(checker);\n+  const importGraph = new ImportGraph(checker, NOOP_PERF_RECORDER);\n   const cycleAnalyzer = new CycleAnalyzer(importGraph);\n   const metaRegistry = new LocalMetadataRegistry();\n   const dtsReader = new DtsMetadataReader(checker, reflectionHost);\n@@ -80,6 +81,7 @@ function setup(program: ts.Program, options: ts.CompilerOptions, host: ts.Compil\n       injectableRegistry,\n       /* semanticDepGraphUpdater */ null,\n       /* annotateForClosureCompiler */ false,\n+      NOOP_PERF_RECORDER,\n   );\n   return {reflectionHost, handler};\n }"
        },
        {
            "sha": "898a0a28eb3f991c8a9a991d93d3593599a578d1",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/directive_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdirective_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdirective_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fdirective_spec.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -13,6 +13,7 @@ import {runInEachFileSystem} from '../../file_system/testing';\n import {NOOP_DEFAULT_IMPORT_RECORDER, ReferenceEmitter} from '../../imports';\n import {DtsMetadataReader, InjectableClassRegistry, LocalMetadataRegistry} from '../../metadata';\n import {PartialEvaluator} from '../../partial_evaluator';\n+import {NOOP_PERF_RECORDER} from '../../perf';\n import {ClassDeclaration, isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n import {LocalModuleScopeRegistry, MetadataDtsModuleScopeResolver} from '../../scope';\n import {getDeclaration, makeProgram} from '../../testing';\n@@ -171,7 +172,7 @@ runInEachFileSystem(() => {\n         NOOP_DEFAULT_IMPORT_RECORDER, injectableRegistry, /*isCore*/ false,\n         /*semanticDepGraphUpdater*/ null,\n         /*annotateForClosureCompiler*/ false,\n-        /*detectUndecoratedClassesWithAngularFeatures*/ false);\n+        /*detectUndecoratedClassesWithAngularFeatures*/ false, NOOP_PERF_RECORDER);\n \n     const DirNode = getDeclaration(program, _('/entry.ts'), dirName, isNamedClassDeclaration);\n "
        },
        {
            "sha": "293fd2553348cd5129fb133c6063e49e4945243a",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/injectable_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Finjectable_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Finjectable_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Finjectable_spec.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -10,6 +10,7 @@ import {absoluteFrom} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n import {NOOP_DEFAULT_IMPORT_RECORDER} from '../../imports';\n import {InjectableClassRegistry} from '../../metadata';\n+import {NOOP_PERF_RECORDER} from '../../perf';\n import {isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n import {getDeclaration, makeProgram} from '../../testing';\n import {InjectableDecoratorHandler} from '../src/injectable';\n@@ -70,7 +71,7 @@ function setupHandler(errorOnDuplicateProv: boolean) {\n   const injectableRegistry = new InjectableClassRegistry(reflectionHost);\n   const handler = new InjectableDecoratorHandler(\n       reflectionHost, NOOP_DEFAULT_IMPORT_RECORDER, /* isCore */ false,\n-      /* strictCtorDeps */ false, injectableRegistry, errorOnDuplicateProv);\n+      /* strictCtorDeps */ false, injectableRegistry, NOOP_PERF_RECORDER, errorOnDuplicateProv);\n   const TestClass = getDeclaration(program, ENTRY_FILE, 'TestClass', isNamedClassDeclaration);\n   const ɵprov = reflectionHost.getMembersOfClass(TestClass).find(member => member.name === 'ɵprov');\n   if (ɵprov === undefined) {"
        },
        {
            "sha": "5e0387b1dbd0ef024aaf682f98d08388d6aba83a",
            "filename": "packages/compiler-cli/src/ngtsc/annotations/test/ng_module_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fng_module_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fng_module_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fannotations%2Ftest%2Fng_module_spec.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -14,6 +14,7 @@ import {runInEachFileSystem} from '../../file_system/testing';\n import {LocalIdentifierStrategy, NOOP_DEFAULT_IMPORT_RECORDER, ReferenceEmitter} from '../../imports';\n import {CompoundMetadataReader, DtsMetadataReader, InjectableClassRegistry, LocalMetadataRegistry} from '../../metadata';\n import {PartialEvaluator} from '../../partial_evaluator';\n+import {NOOP_PERF_RECORDER} from '../../perf';\n import {isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n import {LocalModuleScopeRegistry, MetadataDtsModuleScopeResolver} from '../../scope';\n import {getDeclaration, makeProgram} from '../../testing';\n@@ -71,7 +72,8 @@ runInEachFileSystem(() => {\n       const handler = new NgModuleDecoratorHandler(\n           reflectionHost, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry,\n           /* isCore */ false, /* routeAnalyzer */ null, refEmitter, /* factoryTracker */ null,\n-          NOOP_DEFAULT_IMPORT_RECORDER, /* annotateForClosureCompiler */ false, injectableRegistry);\n+          NOOP_DEFAULT_IMPORT_RECORDER, /* annotateForClosureCompiler */ false, injectableRegistry,\n+          NOOP_PERF_RECORDER);\n       const TestModule =\n           getDeclaration(program, _('/entry.ts'), 'TestModule', isNamedClassDeclaration);\n       const detected ="
        },
        {
            "sha": "661221d87a32e59b40cd121362afefb5b51a3ceb",
            "filename": "packages/compiler-cli/src/ngtsc/core/api/src/options.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fapi%2Fsrc%2Foptions.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fapi%2Fsrc%2Foptions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fapi%2Fsrc%2Foptions.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -28,9 +28,8 @@ export interface TestOnlyOptions {\n   /**\n    * An option to enable ngtsc's internal performance tracing.\n    *\n-   * This should be a path to a JSON file where trace information will be written. An optional 'ts:'\n-   * prefix will cause the trace to be written via the TS host instead of directly to the filesystem\n-   * (not all hosts support this mode of operation).\n+   * This should be a path to a JSON file where trace information will be written. This is sensitive\n+   * to the compiler's working directory, and should likely be an absolute path.\n    *\n    * This is currently not exposed to users as the trace format is still unstable.\n    */"
        },
        {
            "sha": "f99ceb9ebb493d20d6e177c0884f52fe4b7bc07d",
            "filename": "packages/compiler-cli/src/ngtsc/core/src/compiler.ts",
            "status": "modified",
            "additions": 140,
            "deletions": 96,
            "changes": 236,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Fsrc%2Fcompiler.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -21,7 +21,9 @@ import {generateAnalysis, IndexedComponent, IndexingContext} from '../../indexer\n import {ComponentResources, CompoundMetadataReader, CompoundMetadataRegistry, DtsMetadataReader, InjectableClassRegistry, LocalMetadataRegistry, MetadataReader, ResourceRegistry} from '../../metadata';\n import {ModuleWithProvidersScanner} from '../../modulewithproviders';\n import {PartialEvaluator} from '../../partial_evaluator';\n-import {NOOP_PERF_RECORDER, PerfRecorder} from '../../perf';\n+import {ActivePerfRecorder} from '../../perf';\n+import {PerfCheckpoint, PerfEvent, PerfPhase} from '../../perf/src/api';\n+import {DelegatingPerfRecorder} from '../../perf/src/recorder';\n import {DeclarationNode, isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n import {AdapterResourceLoader} from '../../resource';\n import {entryPointKeyFor, NgModuleRouteAnalyzer} from '../../routing';\n@@ -80,6 +82,7 @@ export interface FreshCompilationTicket {\n   enableTemplateTypeChecker: boolean;\n   usePoisonedData: boolean;\n   tsProgram: ts.Program;\n+  perfRecorder: ActivePerfRecorder;\n }\n \n /**\n@@ -95,12 +98,14 @@ export interface IncrementalTypeScriptCompilationTicket {\n   newDriver: IncrementalDriver;\n   enableTemplateTypeChecker: boolean;\n   usePoisonedData: boolean;\n+  perfRecorder: ActivePerfRecorder;\n }\n \n export interface IncrementalResourceCompilationTicket {\n   kind: CompilationTicketKind.IncrementalResource;\n   compiler: NgCompiler;\n   modifiedResourceFiles: Set<string>;\n+  perfRecorder: ActivePerfRecorder;\n }\n \n /**\n@@ -119,8 +124,8 @@ export type CompilationTicket = FreshCompilationTicket|IncrementalTypeScriptComp\n export function freshCompilationTicket(\n     tsProgram: ts.Program, options: NgCompilerOptions,\n     incrementalBuildStrategy: IncrementalBuildStrategy,\n-    typeCheckingProgramStrategy: TypeCheckingProgramStrategy, enableTemplateTypeChecker: boolean,\n-    usePoisonedData: boolean): CompilationTicket {\n+    typeCheckingProgramStrategy: TypeCheckingProgramStrategy, perfRecorder: ActivePerfRecorder|null,\n+    enableTemplateTypeChecker: boolean, usePoisonedData: boolean): CompilationTicket {\n   return {\n     kind: CompilationTicketKind.Fresh,\n     tsProgram,\n@@ -129,6 +134,7 @@ export function freshCompilationTicket(\n     typeCheckingProgramStrategy,\n     enableTemplateTypeChecker,\n     usePoisonedData,\n+    perfRecorder: perfRecorder ?? ActivePerfRecorder.zeroedToNow(),\n   };\n }\n \n@@ -139,20 +145,24 @@ export function freshCompilationTicket(\n export function incrementalFromCompilerTicket(\n     oldCompiler: NgCompiler, newProgram: ts.Program,\n     incrementalBuildStrategy: IncrementalBuildStrategy,\n-    typeCheckingProgramStrategy: TypeCheckingProgramStrategy,\n-    modifiedResourceFiles: Set<string>): CompilationTicket {\n+    typeCheckingProgramStrategy: TypeCheckingProgramStrategy, modifiedResourceFiles: Set<string>,\n+    perfRecorder: ActivePerfRecorder|null): CompilationTicket {\n   const oldProgram = oldCompiler.getNextProgram();\n   const oldDriver = oldCompiler.incrementalStrategy.getIncrementalDriver(oldProgram);\n   if (oldDriver === null) {\n     // No incremental step is possible here, since no IncrementalDriver was found for the old\n     // program.\n     return freshCompilationTicket(\n         newProgram, oldCompiler.options, incrementalBuildStrategy, typeCheckingProgramStrategy,\n-        oldCompiler.enableTemplateTypeChecker, oldCompiler.usePoisonedData);\n+        perfRecorder, oldCompiler.enableTemplateTypeChecker, oldCompiler.usePoisonedData);\n   }\n \n-  const newDriver =\n-      IncrementalDriver.reconcile(oldProgram, oldDriver, newProgram, modifiedResourceFiles);\n+  if (perfRecorder === null) {\n+    perfRecorder = ActivePerfRecorder.zeroedToNow();\n+  }\n+\n+  const newDriver = IncrementalDriver.reconcile(\n+      oldProgram, oldDriver, newProgram, modifiedResourceFiles, perfRecorder);\n \n   return {\n     kind: CompilationTicketKind.IncrementalTypeScript,\n@@ -164,6 +174,7 @@ export function incrementalFromCompilerTicket(\n     newDriver,\n     oldProgram,\n     newProgram,\n+    perfRecorder,\n   };\n }\n \n@@ -175,9 +186,14 @@ export function incrementalFromDriverTicket(\n     oldProgram: ts.Program, oldDriver: IncrementalDriver, newProgram: ts.Program,\n     options: NgCompilerOptions, incrementalBuildStrategy: IncrementalBuildStrategy,\n     typeCheckingProgramStrategy: TypeCheckingProgramStrategy, modifiedResourceFiles: Set<string>,\n-    enableTemplateTypeChecker: boolean, usePoisonedData: boolean): CompilationTicket {\n-  const newDriver =\n-      IncrementalDriver.reconcile(oldProgram, oldDriver, newProgram, modifiedResourceFiles);\n+    perfRecorder: ActivePerfRecorder|null, enableTemplateTypeChecker: boolean,\n+    usePoisonedData: boolean): CompilationTicket {\n+  if (perfRecorder === null) {\n+    perfRecorder = ActivePerfRecorder.zeroedToNow();\n+  }\n+\n+  const newDriver = IncrementalDriver.reconcile(\n+      oldProgram, oldDriver, newProgram, modifiedResourceFiles, perfRecorder);\n   return {\n     kind: CompilationTicketKind.IncrementalTypeScript,\n     oldProgram,\n@@ -188,6 +204,7 @@ export function incrementalFromDriverTicket(\n     typeCheckingProgramStrategy,\n     enableTemplateTypeChecker,\n     usePoisonedData,\n+    perfRecorder,\n   };\n }\n \n@@ -197,6 +214,7 @@ export function resourceChangeTicket(compiler: NgCompiler, modifiedResourceFiles\n     kind: CompilationTicketKind.IncrementalResource,\n     compiler,\n     modifiedResourceFiles,\n+    perfRecorder: ActivePerfRecorder.zeroedToNow(),\n   };\n }\n \n@@ -245,16 +263,23 @@ export class NgCompiler {\n   readonly ignoreForDiagnostics: Set<ts.SourceFile>;\n   readonly ignoreForEmit: Set<ts.SourceFile>;\n \n+  /**\n+   * `NgCompiler` can be reused for multiple compilations (for resource-only changes), and each\n+   * new compilation uses a fresh `PerfRecorder`. Thus, classes created with a lifespan of the\n+   * `NgCompiler` use a `DelegatingPerfRecorder` so the `PerfRecorder` they write to can be updated\n+   * with each fresh compilation.\n+   */\n+  private delegatingPerfRecorder = new DelegatingPerfRecorder(this.perfRecorder);\n+\n   /**\n    * Convert a `CompilationTicket` into an `NgCompiler` instance for the requested compilation.\n    *\n    * Depending on the nature of the compilation request, the `NgCompiler` instance may be reused\n    * from a previous compilation and updated with any changes, it may be a new instance which\n-   * incrementally reuses state from a previous compilation, or it may represent a fresh compilation\n-   * entirely.\n+   * incrementally reuses state from a previous compilation, or it may represent a fresh\n+   * compilation entirely.\n    */\n-  static fromTicket(\n-      ticket: CompilationTicket, adapter: NgCompilerAdapter, perfRecorder?: PerfRecorder) {\n+  static fromTicket(ticket: CompilationTicket, adapter: NgCompilerAdapter) {\n     switch (ticket.kind) {\n       case CompilationTicketKind.Fresh:\n         return new NgCompiler(\n@@ -266,7 +291,7 @@ export class NgCompiler {\n             IncrementalDriver.fresh(ticket.tsProgram),\n             ticket.enableTemplateTypeChecker,\n             ticket.usePoisonedData,\n-            perfRecorder,\n+            ticket.perfRecorder,\n         );\n       case CompilationTicketKind.IncrementalTypeScript:\n         return new NgCompiler(\n@@ -278,11 +303,11 @@ export class NgCompiler {\n             ticket.newDriver,\n             ticket.enableTemplateTypeChecker,\n             ticket.usePoisonedData,\n-            perfRecorder,\n+            ticket.perfRecorder,\n         );\n       case CompilationTicketKind.IncrementalResource:\n         const compiler = ticket.compiler;\n-        compiler.updateWithChangedResources(ticket.modifiedResourceFiles);\n+        compiler.updateWithChangedResources(ticket.modifiedResourceFiles, ticket.perfRecorder);\n         return compiler;\n     }\n   }\n@@ -296,7 +321,7 @@ export class NgCompiler {\n       readonly incrementalDriver: IncrementalDriver,\n       readonly enableTemplateTypeChecker: boolean,\n       readonly usePoisonedData: boolean,\n-      private perfRecorder: PerfRecorder = NOOP_PERF_RECORDER,\n+      private livePerfRecorder: ActivePerfRecorder,\n   ) {\n     this.constructionDiagnostics.push(...this.adapter.constructionDiagnostics);\n     const incompatibleTypeCheckOptionsDiagnostic = verifyCompatibleTypeCheckOptions(this.options);\n@@ -312,52 +337,74 @@ export class NgCompiler {\n \n     const moduleResolutionCache = ts.createModuleResolutionCache(\n         this.adapter.getCurrentDirectory(),\n-        // Note: this used to be an arrow-function closure. However, JS engines like v8 have some\n-        // strange behaviors with retaining the lexical scope of the closure. Even if this function\n-        // doesn't retain a reference to `this`, if other closures in the constructor here reference\n+        // doen't retain a reference to `this`, if other closures in the constructor here reference\n         // `this` internally then a closure created here would retain them. This can cause major\n         // memory leak issues since the `moduleResolutionCache` is a long-lived object and finds its\n         // way into all kinds of places inside TS internal objects.\n         this.adapter.getCanonicalFileName.bind(this.adapter));\n     this.moduleResolver =\n         new ModuleResolver(tsProgram, this.options, this.adapter, moduleResolutionCache);\n     this.resourceManager = new AdapterResourceLoader(adapter, this.options);\n-    this.cycleAnalyzer = new CycleAnalyzer(new ImportGraph(tsProgram.getTypeChecker()));\n+    this.cycleAnalyzer =\n+        new CycleAnalyzer(new ImportGraph(tsProgram.getTypeChecker(), this.delegatingPerfRecorder));\n     this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, tsProgram);\n \n     this.ignoreForDiagnostics =\n         new Set(tsProgram.getSourceFiles().filter(sf => this.adapter.isShim(sf)));\n     this.ignoreForEmit = this.adapter.ignoreForEmit;\n-  }\n \n-  private updateWithChangedResources(changedResources: Set<string>): void {\n-    if (this.compilation === null) {\n-      // Analysis hasn't happened yet, so no update is necessary - any changes to resources will be\n-      // captured by the inital analysis pass itself.\n-      return;\n+    let dtsFileCount = 0;\n+    let nonDtsFileCount = 0;\n+    for (const sf of tsProgram.getSourceFiles()) {\n+      if (sf.isDeclarationFile) {\n+        dtsFileCount++;\n+      } else {\n+        nonDtsFileCount++;\n+      }\n     }\n \n-    this.resourceManager.invalidate();\n+    livePerfRecorder.eventCount(PerfEvent.InputDtsFile, dtsFileCount);\n+    livePerfRecorder.eventCount(PerfEvent.InputTsFile, nonDtsFileCount);\n+  }\n \n-    const classesToUpdate = new Set<DeclarationNode>();\n-    for (const resourceFile of changedResources) {\n-      for (const templateClass of this.getComponentsWithTemplateFile(resourceFile)) {\n-        classesToUpdate.add(templateClass);\n-      }\n+  get perfRecorder(): ActivePerfRecorder {\n+    return this.livePerfRecorder;\n+  }\n \n-      for (const styleClass of this.getComponentsWithStyleFile(resourceFile)) {\n-        classesToUpdate.add(styleClass);\n+  private updateWithChangedResources(\n+      changedResources: Set<string>, perfRecorder: ActivePerfRecorder): void {\n+    this.livePerfRecorder = perfRecorder;\n+    this.delegatingPerfRecorder.target = perfRecorder;\n+\n+    perfRecorder.inPhase(PerfPhase.ResourceUpdate, () => {\n+      if (this.compilation === null) {\n+        // Analysis hasn't happened yet, so no update is necessary - any changes to resources will\n+        // be captured by the inital analysis pass itself.\n+        return;\n       }\n-    }\n \n-    for (const clazz of classesToUpdate) {\n-      this.compilation.traitCompiler.updateResources(clazz);\n-      if (!ts.isClassDeclaration(clazz)) {\n-        continue;\n+      this.resourceManager.invalidate();\n+\n+      const classesToUpdate = new Set<DeclarationNode>();\n+      for (const resourceFile of changedResources) {\n+        for (const templateClass of this.getComponentsWithTemplateFile(resourceFile)) {\n+          classesToUpdate.add(templateClass);\n+        }\n+\n+        for (const styleClass of this.getComponentsWithStyleFile(resourceFile)) {\n+          classesToUpdate.add(styleClass);\n+        }\n       }\n \n-      this.compilation.templateTypeChecker.invalidateClass(clazz);\n-    }\n+      for (const clazz of classesToUpdate) {\n+        this.compilation.traitCompiler.updateResources(clazz);\n+        if (!ts.isClassDeclaration(clazz)) {\n+          continue;\n+        }\n+\n+        this.compilation.templateTypeChecker.invalidateClass(clazz);\n+      }\n+    });\n   }\n \n   /**\n@@ -481,33 +528,28 @@ export class NgCompiler {\n     if (this.compilation !== null) {\n       return;\n     }\n-    this.compilation = this.makeCompilation();\n \n-    const analyzeSpan = this.perfRecorder.start('analyze');\n-    const promises: Promise<void>[] = [];\n-    for (const sf of this.tsProgram.getSourceFiles()) {\n-      if (sf.isDeclarationFile) {\n-        continue;\n-      }\n+    await this.perfRecorder.inPhase(PerfPhase.Analysis, async () => {\n+      this.compilation = this.makeCompilation();\n \n-      const analyzeFileSpan = this.perfRecorder.start('analyzeFile', sf);\n-      let analysisPromise = this.compilation.traitCompiler.analyzeAsync(sf);\n-      this.scanForMwp(sf);\n-      if (analysisPromise === undefined) {\n-        this.perfRecorder.stop(analyzeFileSpan);\n-      } else if (this.perfRecorder.enabled) {\n-        analysisPromise = analysisPromise.then(() => this.perfRecorder.stop(analyzeFileSpan));\n-      }\n-      if (analysisPromise !== undefined) {\n-        promises.push(analysisPromise);\n-      }\n-    }\n+      const promises: Promise<void>[] = [];\n+      for (const sf of this.tsProgram.getSourceFiles()) {\n+        if (sf.isDeclarationFile) {\n+          continue;\n+        }\n \n-    await Promise.all(promises);\n+        let analysisPromise = this.compilation.traitCompiler.analyzeAsync(sf);\n+        this.scanForMwp(sf);\n+        if (analysisPromise !== undefined) {\n+          promises.push(analysisPromise);\n+        }\n+      }\n \n-    this.perfRecorder.stop(analyzeSpan);\n+      await Promise.all(promises);\n \n-    this.resolveCompilation(this.compilation.traitCompiler);\n+      this.perfRecorder.memory(PerfCheckpoint.Analysis);\n+      this.resolveCompilation(this.compilation.traitCompiler);\n+    });\n   }\n \n   /**\n@@ -517,9 +559,7 @@ export class NgCompiler {\n    */\n   listLazyRoutes(entryRoute?: string): LazyRoute[] {\n     if (entryRoute) {\n-      // Note:\n-      // This resolution step is here to match the implementation of the old `AotCompilerHost` (see\n-      // https://github.com/angular/angular/blob/50732e156/packages/compiler-cli/src/transformers/compiler_host.ts#L175-L188).\n+      // htts://github.com/angular/angular/blob/50732e156/packages/compiler-cli/src/transformers/compiler_host.ts#L175-L188).\n       //\n       // `@angular/cli` will always call this API with an absolute path, so the resolution step is\n       // not necessary, but keeping it backwards compatible in case someone else is using the API.\n@@ -573,7 +613,8 @@ export class NgCompiler {\n     const before = [\n       ivyTransformFactory(\n           compilation.traitCompiler, compilation.reflector, importRewriter,\n-          compilation.defaultImportTracker, compilation.isCore, this.closureCompilerEnabled),\n+          compilation.defaultImportTracker, this.delegatingPerfRecorder, compilation.isCore,\n+          this.closureCompilerEnabled),\n       aliasTransformFactory(compilation.traitCompiler.exportStatements),\n       compilation.defaultImportTracker.importPreservingTransformer(),\n     ];\n@@ -618,28 +659,32 @@ export class NgCompiler {\n   }\n \n   private analyzeSync(): void {\n-    const analyzeSpan = this.perfRecorder.start('analyze');\n-    this.compilation = this.makeCompilation();\n-    for (const sf of this.tsProgram.getSourceFiles()) {\n-      if (sf.isDeclarationFile) {\n-        continue;\n+    this.perfRecorder.inPhase(PerfPhase.Analysis, () => {\n+      this.compilation = this.makeCompilation();\n+      for (const sf of this.tsProgram.getSourceFiles()) {\n+        if (sf.isDeclarationFile) {\n+          continue;\n+        }\n+        this.compilation.traitCompiler.analyzeSync(sf);\n+        this.scanForMwp(sf);\n       }\n-      const analyzeFileSpan = this.perfRecorder.start('analyzeFile', sf);\n-      this.compilation.traitCompiler.analyzeSync(sf);\n-      this.scanForMwp(sf);\n-      this.perfRecorder.stop(analyzeFileSpan);\n-    }\n-    this.perfRecorder.stop(analyzeSpan);\n \n-    this.resolveCompilation(this.compilation.traitCompiler);\n+      this.perfRecorder.memory(PerfCheckpoint.Analysis);\n+\n+      this.resolveCompilation(this.compilation.traitCompiler);\n+    });\n   }\n \n   private resolveCompilation(traitCompiler: TraitCompiler): void {\n-    traitCompiler.resolve();\n+    this.perfRecorder.inPhase(PerfPhase.Resolve, () => {\n+      traitCompiler.resolve();\n \n-    // At this point, analysis is complete and the compiler can now calculate which files need to\n-    // be emitted, so do that.\n-    this.incrementalDriver.recordSuccessfulAnalysis(traitCompiler);\n+      // At this point, analysis is complete and the compiler can now calculate which files need to\n+      // be emitted, so do that.\n+      this.incrementalDriver.recordSuccessfulAnalysis(traitCompiler);\n+\n+      this.perfRecorder.memory(PerfCheckpoint.Resolve);\n+    });\n   }\n \n   private get fullTemplateTypeCheck(): boolean {\n@@ -770,7 +815,6 @@ export class NgCompiler {\n     const compilation = this.ensureAnalyzed();\n \n     // Get the diagnostics.\n-    const typeCheckSpan = this.perfRecorder.start('typeCheckDiagnostics');\n     const diagnostics: ts.Diagnostic[] = [];\n     for (const sf of this.tsProgram.getSourceFiles()) {\n       if (sf.isDeclarationFile || this.adapter.isShim(sf)) {\n@@ -782,7 +826,6 @@ export class NgCompiler {\n     }\n \n     const program = this.typeCheckingProgramStrategy.getProgram();\n-    this.perfRecorder.stop(typeCheckSpan);\n     this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, program);\n     this.nextProgram = program;\n \n@@ -794,14 +837,12 @@ export class NgCompiler {\n     const compilation = this.ensureAnalyzed();\n \n     // Get the diagnostics.\n-    const typeCheckSpan = this.perfRecorder.start('typeCheckDiagnostics');\n     const diagnostics: ts.Diagnostic[] = [];\n     if (!sf.isDeclarationFile && !this.adapter.isShim(sf)) {\n       diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf, optimizeFor));\n     }\n \n     const program = this.typeCheckingProgramStrategy.getProgram();\n-    this.perfRecorder.stop(typeCheckSpan);\n     this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, program);\n     this.nextProgram = program;\n \n@@ -950,7 +991,8 @@ export class NgCompiler {\n           this.options.enableI18nLegacyMessageIdFormat !== false, this.usePoisonedData,\n           this.options.i18nNormalizeLineEndingsInICUs, this.moduleResolver, this.cycleAnalyzer,\n           cycleHandlingStrategy, refEmitter, defaultImportTracker, this.incrementalDriver.depGraph,\n-          injectableRegistry, semanticDepGraphUpdater, this.closureCompilerEnabled),\n+          injectableRegistry, semanticDepGraphUpdater, this.closureCompilerEnabled,\n+          this.delegatingPerfRecorder),\n \n       // TODO(alxhub): understand why the cast here is necessary (something to do with `null`\n       // not being assignable to `unknown` when wrapped in `Readonly`).\n@@ -959,31 +1001,33 @@ export class NgCompiler {\n             reflector, evaluator, metaRegistry, scopeRegistry, metaReader,\n             defaultImportTracker, injectableRegistry, isCore, semanticDepGraphUpdater,\n           this.closureCompilerEnabled, compileUndecoratedClassesWithAngularFeatures,\n+          this.delegatingPerfRecorder,\n         ) as Readonly<DecoratorHandler<unknown, unknown, SemanticSymbol | null,unknown>>,\n       // clang-format on\n       // Pipe handler must be before injectable handler in list so pipe factories are printed\n       // before injectable factories (so injectable factories can delegate to them)\n       new PipeDecoratorHandler(\n           reflector, evaluator, metaRegistry, scopeRegistry, defaultImportTracker,\n-          injectableRegistry, isCore),\n+          injectableRegistry, isCore, this.delegatingPerfRecorder),\n       new InjectableDecoratorHandler(\n           reflector, defaultImportTracker, isCore, this.options.strictInjectionParameters || false,\n-          injectableRegistry),\n+          injectableRegistry, this.delegatingPerfRecorder),\n       new NgModuleDecoratorHandler(\n           reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, isCore,\n           routeAnalyzer, refEmitter, this.adapter.factoryTracker, defaultImportTracker,\n-          this.closureCompilerEnabled, injectableRegistry, this.options.i18nInLocale),\n+          this.closureCompilerEnabled, injectableRegistry, this.delegatingPerfRecorder,\n+          this.options.i18nInLocale),\n     ];\n \n     const traitCompiler = new TraitCompiler(\n-        handlers, reflector, this.perfRecorder, this.incrementalDriver,\n+        handlers, reflector, this.delegatingPerfRecorder, this.incrementalDriver,\n         this.options.compileNonExportedClasses !== false, compilationMode, dtsTransforms,\n         semanticDepGraphUpdater);\n \n     const templateTypeChecker = new TemplateTypeCheckerImpl(\n         this.tsProgram, this.typeCheckingProgramStrategy, traitCompiler,\n         this.getTypeCheckingConfig(), refEmitter, reflector, this.adapter, this.incrementalDriver,\n-        scopeRegistry, typeCheckScopeRegistry);\n+        scopeRegistry, typeCheckScopeRegistry, this.delegatingPerfRecorder);\n \n     return {\n       isCore,"
        },
        {
            "sha": "e7f59a2103582997799e8bf6eb74472ef2650a56",
            "filename": "packages/compiler-cli/src/ngtsc/core/test/compiler_test.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Ftest%2Fcompiler_test.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Ftest%2Fcompiler_test.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcore%2Ftest%2Fcompiler_test.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -25,8 +25,8 @@ function makeFreshCompiler(\n     programStrategy: TypeCheckingProgramStrategy, incrementalStrategy: IncrementalBuildStrategy,\n     enableTemplateTypeChecker: boolean, usePoisonedData: boolean): NgCompiler {\n   const ticket = freshCompilationTicket(\n-      program, options, incrementalStrategy, programStrategy, enableTemplateTypeChecker,\n-      usePoisonedData);\n+      program, options, incrementalStrategy, programStrategy, /* perfRecorder */ null,\n+      enableTemplateTypeChecker, usePoisonedData);\n   return NgCompiler.fromTicket(ticket, host);\n }\n "
        },
        {
            "sha": "b17665f899d43b99e4aba9ef048adb157cbe28bf",
            "filename": "packages/compiler-cli/src/ngtsc/cycles/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2FBUILD.bazel?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -9,6 +9,7 @@ ts_library(\n     ]),\n     module_name = \"@angular/compiler-cli/src/ngtsc/cycles\",\n     deps = [\n+        \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"@npm//typescript\",\n     ],\n )"
        },
        {
            "sha": "a04f044965379c7f9efdd7d88c13d5bb4a9387b8",
            "filename": "packages/compiler-cli/src/ngtsc/cycles/src/imports.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 19,
            "changes": 42,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Fsrc%2Fimports.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Fsrc%2Fimports.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Fsrc%2Fimports.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -8,6 +8,8 @@\n \n import * as ts from 'typescript';\n \n+import {PerfPhase, PerfRecorder} from '../../perf';\n+\n /**\n  * A cached graph of imports in the `ts.Program`.\n  *\n@@ -17,7 +19,7 @@ import * as ts from 'typescript';\n export class ImportGraph {\n   private map = new Map<ts.SourceFile, Set<ts.SourceFile>>();\n \n-  constructor(private checker: ts.TypeChecker) {}\n+  constructor(private checker: ts.TypeChecker, private perf: PerfRecorder) {}\n \n   /**\n    * List the direct (not transitive) imports of a given `ts.SourceFile`.\n@@ -99,26 +101,28 @@ export class ImportGraph {\n   }\n \n   private scanImports(sf: ts.SourceFile): Set<ts.SourceFile> {\n-    const imports = new Set<ts.SourceFile>();\n-    // Look through the source file for import and export statements.\n-    for (const stmt of sf.statements) {\n-      if ((!ts.isImportDeclaration(stmt) && !ts.isExportDeclaration(stmt)) ||\n-          stmt.moduleSpecifier === undefined) {\n-        continue;\n-      }\n+    return this.perf.inPhase(PerfPhase.CycleDetection, () => {\n+      const imports = new Set<ts.SourceFile>();\n+      // Look through the source file for import and export statements.\n+      for (const stmt of sf.statements) {\n+        if ((!ts.isImportDeclaration(stmt) && !ts.isExportDeclaration(stmt)) ||\n+            stmt.moduleSpecifier === undefined) {\n+          continue;\n+        }\n \n-      const symbol = this.checker.getSymbolAtLocation(stmt.moduleSpecifier);\n-      if (symbol === undefined || symbol.valueDeclaration === undefined) {\n-        // No symbol could be found to skip over this import/export.\n-        continue;\n-      }\n-      const moduleFile = symbol.valueDeclaration;\n-      if (ts.isSourceFile(moduleFile) && isLocalFile(moduleFile)) {\n-        // Record this local import.\n-        imports.add(moduleFile);\n+        const symbol = this.checker.getSymbolAtLocation(stmt.moduleSpecifier);\n+        if (symbol === undefined || symbol.valueDeclaration === undefined) {\n+          // No symbol could be found to skip over this import/export.\n+          continue;\n+        }\n+        const moduleFile = symbol.valueDeclaration;\n+        if (ts.isSourceFile(moduleFile) && isLocalFile(moduleFile)) {\n+          // Record this local import.\n+          imports.add(moduleFile);\n+        }\n       }\n-    }\n-    return imports;\n+      return imports;\n+    });\n   }\n }\n "
        },
        {
            "sha": "21b3aaae06917447b3664f187c2024faa1b3d581",
            "filename": "packages/compiler-cli/src/ngtsc/cycles/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2FBUILD.bazel?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -13,6 +13,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/cycles\",\n         \"//packages/compiler-cli/src/ngtsc/file_system\",\n         \"//packages/compiler-cli/src/ngtsc/file_system/testing\",\n+        \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"//packages/compiler-cli/src/ngtsc/testing\",\n         \"@npm//typescript\",\n     ],"
        },
        {
            "sha": "85b058dd8fcc6129b77d259b9d552524cb6c6393",
            "filename": "packages/compiler-cli/src/ngtsc/cycles/test/analyzer_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2Fanalyzer_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2Fanalyzer_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2Fanalyzer_spec.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -8,6 +8,7 @@\n import * as ts from 'typescript';\n import {absoluteFrom, getFileSystem, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n+import {NOOP_PERF_RECORDER} from '../../perf';\n import {Cycle, CycleAnalyzer} from '../src/analyzer';\n import {ImportGraph} from '../src/imports';\n import {importPath, makeProgramFromGraph} from './util';\n@@ -75,7 +76,7 @@ runInEachFileSystem(() => {\n     const {program} = makeProgramFromGraph(getFileSystem(), graph);\n     return {\n       program,\n-      analyzer: new CycleAnalyzer(new ImportGraph(program.getTypeChecker())),\n+      analyzer: new CycleAnalyzer(new ImportGraph(program.getTypeChecker(), NOOP_PERF_RECORDER)),\n     };\n   }\n });"
        },
        {
            "sha": "f88500643ddfad15e2930acbf14cd422b4ed221f",
            "filename": "packages/compiler-cli/src/ngtsc/cycles/test/imports_spec.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2Fimports_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2Fimports_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fcycles%2Ftest%2Fimports_spec.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -8,6 +8,7 @@\n import * as ts from 'typescript';\n import {absoluteFrom, getFileSystem, getSourceFileOrError} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n+import {NOOP_PERF_RECORDER} from '../../perf';\n import {ImportGraph} from '../src/imports';\n import {importPath, makeProgramFromGraph} from './util';\n \n@@ -86,7 +87,7 @@ runInEachFileSystem(() => {\n     const {program} = makeProgramFromGraph(getFileSystem(), graph);\n     return {\n       program,\n-      graph: new ImportGraph(program.getTypeChecker()),\n+      graph: new ImportGraph(program.getTypeChecker(), NOOP_PERF_RECORDER),\n     };\n   }\n "
        },
        {
            "sha": "0e89dfbed22121025e2793f9906fcae494f8779c",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2FBUILD.bazel?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -14,6 +14,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/incremental/semantic_graph\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n         \"//packages/compiler-cli/src/ngtsc/partial_evaluator\",\n+        \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"//packages/compiler-cli/src/ngtsc/scope\",\n         \"//packages/compiler-cli/src/ngtsc/transform\","
        },
        {
            "sha": "cd5f5fa431b25ff9dbc4d1497ca07e026997fe58",
            "filename": "packages/compiler-cli/src/ngtsc/incremental/src/state.ts",
            "status": "modified",
            "additions": 106,
            "deletions": 101,
            "changes": 207,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fstate.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fstate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fincremental%2Fsrc%2Fstate.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -9,6 +9,7 @@\n import * as ts from 'typescript';\n \n import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '../../file_system';\n+import {PerfEvent, PerfPhase, PerfRecorder} from '../../perf';\n import {ClassDeclaration} from '../../reflection';\n import {ClassRecord, TraitCompiler} from '../../transform';\n import {FileTypeCheckingData} from '../../typecheck/src/checker';\n@@ -43,118 +44,122 @@ export class IncrementalDriver implements IncrementalBuild<ClassRecord, FileType\n    */\n   static reconcile(\n       oldProgram: ts.Program, oldDriver: IncrementalDriver, newProgram: ts.Program,\n-      modifiedResourceFiles: Set<string>|null): IncrementalDriver {\n-    // Initialize the state of the current build based on the previous one.\n-    let state: PendingBuildState;\n-    if (oldDriver.state.kind === BuildStateKind.Pending) {\n-      // The previous build never made it past the pending state. Reuse it as the starting state for\n-      // this build.\n-      state = oldDriver.state;\n-    } else {\n-      let priorGraph: SemanticDepGraph|null = null;\n-      if (oldDriver.state.lastGood !== null) {\n-        priorGraph = oldDriver.state.lastGood.semanticDepGraph;\n-      }\n-\n-      // The previous build was successfully analyzed. `pendingEmit` is the only state carried\n-      // forward into this build.\n-      state = {\n-        kind: BuildStateKind.Pending,\n-        pendingEmit: oldDriver.state.pendingEmit,\n-        pendingTypeCheckEmit: oldDriver.state.pendingTypeCheckEmit,\n-        changedResourcePaths: new Set<AbsoluteFsPath>(),\n-        changedTsPaths: new Set<string>(),\n-        lastGood: oldDriver.state.lastGood,\n-        semanticDepGraphUpdater: new SemanticDepGraphUpdater(priorGraph),\n-      };\n-    }\n-\n-    // Merge the freshly modified resource files with any prior ones.\n-    if (modifiedResourceFiles !== null) {\n-      for (const resFile of modifiedResourceFiles) {\n-        state.changedResourcePaths.add(absoluteFrom(resFile));\n-      }\n-    }\n-\n-    // Next, process the files in the new program, with a couple of goals:\n-    // 1) Determine which TS files have changed, if any, and merge them into `changedTsFiles`.\n-    // 2) Produce a list of TS files which no longer exist in the program (they've been deleted\n-    //    since the previous compilation). These need to be removed from the state tracking to avoid\n-    //    leaking memory.\n-\n-    // All files in the old program, for easy detection of changes.\n-    const oldFiles = new Set<ts.SourceFile>(oldProgram.getSourceFiles());\n-\n-    // Assume all the old files were deleted to begin with. Only TS files are tracked.\n-    const deletedTsPaths = new Set<string>(tsOnlyFiles(oldProgram).map(sf => sf.fileName));\n-\n-    for (const newFile of newProgram.getSourceFiles()) {\n-      if (!newFile.isDeclarationFile) {\n-        // This file exists in the new program, so remove it from `deletedTsPaths`.\n-        deletedTsPaths.delete(newFile.fileName);\n+      modifiedResourceFiles: Set<string>|null, perf: PerfRecorder): IncrementalDriver {\n+    return perf.inPhase(PerfPhase.Reconciliation, () => {\n+      // Initialize the state of the current build based on the previous one.\n+      let state: PendingBuildState;\n+      if (oldDriver.state.kind === BuildStateKind.Pending) {\n+        // The previous build never made it past the pending state. Reuse it as the starting state\n+        // for this build.\n+        state = oldDriver.state;\n+      } else {\n+        let priorGraph: SemanticDepGraph|null = null;\n+        if (oldDriver.state.lastGood !== null) {\n+          priorGraph = oldDriver.state.lastGood.semanticDepGraph;\n+        }\n+\n+        // The previous build was successfully analyzed. `pendingEmit` is the only state carried\n+        // forward into this build.\n+        state = {\n+          kind: BuildStateKind.Pending,\n+          pendingEmit: oldDriver.state.pendingEmit,\n+          pendingTypeCheckEmit: oldDriver.state.pendingTypeCheckEmit,\n+          changedResourcePaths: new Set<AbsoluteFsPath>(),\n+          changedTsPaths: new Set<string>(),\n+          lastGood: oldDriver.state.lastGood,\n+          semanticDepGraphUpdater: new SemanticDepGraphUpdater(priorGraph),\n+        };\n       }\n \n-      if (oldFiles.has(newFile)) {\n-        // This file hasn't changed; no need to look at it further.\n-        continue;\n+      // Merge the freshly modified resource files with any prior ones.\n+      if (modifiedResourceFiles !== null) {\n+        for (const resFile of modifiedResourceFiles) {\n+          state.changedResourcePaths.add(absoluteFrom(resFile));\n+        }\n       }\n \n-      // The file has changed since the last successful build. The appropriate reaction depends on\n-      // what kind of file it is.\n-      if (!newFile.isDeclarationFile) {\n-        // It's a .ts file, so track it as a change.\n-        state.changedTsPaths.add(newFile.fileName);\n-      } else {\n-        // It's a .d.ts file. Currently the compiler does not do a great job of tracking\n-        // dependencies on .d.ts files, so bail out of incremental builds here and do a full build.\n-        // This usually only happens if something in node_modules changes.\n-        return IncrementalDriver.fresh(newProgram);\n+      // Next, process the files in the new program, with a couple of goals:\n+      // 1) Determine which TS files have changed, if any, and merge them into `changedTsFiles`.\n+      // 2) Produce a list of TS files which no longer exist in the program (they've been deleted\n+      //    since the previous compilation). These need to be removed from the state tracking to\n+      //    avoid leaking memory.\n+\n+      // All files in the old program, for easy detection of changes.\n+      const oldFiles = new Set<ts.SourceFile>(oldProgram.getSourceFiles());\n+\n+      // Assume all the old files were deleted to begin with. Only TS files are tracked.\n+      const deletedTsPaths = new Set<string>(tsOnlyFiles(oldProgram).map(sf => sf.fileName));\n+\n+      for (const newFile of newProgram.getSourceFiles()) {\n+        if (!newFile.isDeclarationFile) {\n+          // This file exists in the new program, so remove it from `deletedTsPaths`.\n+          deletedTsPaths.delete(newFile.fileName);\n+        }\n+\n+        if (oldFiles.has(newFile)) {\n+          // This file hasn't changed; no need to look at it further.\n+          continue;\n+        }\n+\n+        // The file has changed since the last successful build. The appropriate reaction depends on\n+        // what kind of file it is.\n+        if (!newFile.isDeclarationFile) {\n+          // It's a .ts file, so track it as a change.\n+          state.changedTsPaths.add(newFile.fileName);\n+        } else {\n+          // It's a .d.ts file. Currently the compiler does not do a great job of tracking\n+          // dependencies on .d.ts files, so bail out of incremental builds here and do a full\n+          // build. This usually only happens if something in node_modules changes.\n+          return IncrementalDriver.fresh(newProgram);\n+        }\n       }\n-    }\n \n-    // The next step is to remove any deleted files from the state.\n-    for (const filePath of deletedTsPaths) {\n-      state.pendingEmit.delete(filePath);\n-      state.pendingTypeCheckEmit.delete(filePath);\n+      // The next step is to remove any deleted files from the state.\n+      for (const filePath of deletedTsPaths) {\n+        state.pendingEmit.delete(filePath);\n+        state.pendingTypeCheckEmit.delete(filePath);\n \n-      // Even if the file doesn't exist in the current compilation, it still might have been changed\n-      // in a previous one, so delete it from the set of changed TS files, just in case.\n-      state.changedTsPaths.delete(filePath);\n-    }\n-\n-    // Now, changedTsPaths contains physically changed TS paths. Use the previous program's logical\n-    // dependency graph to determine logically changed files.\n-    const depGraph = new FileDependencyGraph();\n-\n-    // If a previous compilation exists, use its dependency graph to determine the set of logically\n-    // changed files.\n-    let logicalChanges: Set<string>|null = null;\n-    if (state.lastGood !== null) {\n-      // Extract the set of logically changed files. At the same time, this operation populates the\n-      // current (fresh) dependency graph with information about those files which have not\n-      // logically changed.\n-      logicalChanges = depGraph.updateWithPhysicalChanges(\n-          state.lastGood.depGraph, state.changedTsPaths, deletedTsPaths,\n-          state.changedResourcePaths);\n-      for (const fileName of state.changedTsPaths) {\n-        logicalChanges.add(fileName);\n+        // Even if the file doesn't exist in the current compilation, it still might have been\n+        // changed in a previous one, so delete it from the set of changed TS files, just in case.\n+        state.changedTsPaths.delete(filePath);\n       }\n \n-      // Any logically changed files need to be re-emitted. Most of the time this would happen\n-      // regardless because the new dependency graph would _also_ identify the file as stale.\n-      // However there are edge cases such as removing a component from an NgModule without adding\n-      // it to another one, where the previous graph identifies the file as logically changed, but\n-      // the new graph (which does not have that edge) fails to identify that the file should be\n-      // re-emitted.\n-      for (const change of logicalChanges) {\n-        state.pendingEmit.add(change);\n-        state.pendingTypeCheckEmit.add(change);\n+      perf.eventCount(PerfEvent.SourceFilePhysicalChange, state.changedTsPaths.size);\n+\n+      // Now, changedTsPaths contains physically changed TS paths. Use the previous program's\n+      // logical dependency graph to determine logically changed files.\n+      const depGraph = new FileDependencyGraph();\n+\n+      // If a previous compilation exists, use its dependency graph to determine the set of\n+      // logically changed files.\n+      let logicalChanges: Set<string>|null = null;\n+      if (state.lastGood !== null) {\n+        // Extract the set of logically changed files. At the same time, this operation populates\n+        // the current (fresh) dependency graph with information about those files which have not\n+        // logically changed.\n+        logicalChanges = depGraph.updateWithPhysicalChanges(\n+            state.lastGood.depGraph, state.changedTsPaths, deletedTsPaths,\n+            state.changedResourcePaths);\n+        perf.eventCount(PerfEvent.SourceFileLogicalChange, logicalChanges.size);\n+        for (const fileName of state.changedTsPaths) {\n+          logicalChanges.add(fileName);\n+        }\n+\n+        // Any logically changed files need to be re-emitted. Most of the time this would happen\n+        // regardless because the new dependency graph would _also_ identify the file as stale.\n+        // However there are edge cases such as removing a component from an NgModule without adding\n+        // it to another one, where the previous graph identifies the file as logically changed, but\n+        // the new graph (which does not have that edge) fails to identify that the file should be\n+        // re-emitted.\n+        for (const change of logicalChanges) {\n+          state.pendingEmit.add(change);\n+          state.pendingTypeCheckEmit.add(change);\n+        }\n       }\n-    }\n-\n-    // `state` now reflects the initial pending state of the current compilation.\n \n-    return new IncrementalDriver(state, depGraph, logicalChanges);\n+      // `state` now reflects the initial pending state of the current compilation.\n+      return new IncrementalDriver(state, depGraph, logicalChanges);\n+    });\n   }\n \n   static fresh(program: ts.Program): IncrementalDriver {"
        },
        {
            "sha": "53af9b1c4ff2429735b83088e208e473a9c8bc5f",
            "filename": "packages/compiler-cli/src/ngtsc/perf/BUILD.bazel",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2FBUILD.bazel?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -9,8 +9,6 @@ ts_library(\n     ]),\n     deps = [\n         \"//packages:types\",\n-        \"//packages/compiler-cli/src/ngtsc/file_system\",\n-        \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"@npm//@types/node\",\n         \"@npm//typescript\",\n     ],"
        },
        {
            "sha": "32b9762f9f18b2484533b49d6e38943c7a7c8b04",
            "filename": "packages/compiler-cli/src/ngtsc/perf/index.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Findex.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -6,6 +6,6 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-export {PerfRecorder} from './src/api';\n+export * from './src/api';\n export {NOOP_PERF_RECORDER} from './src/noop';\n-export {PerfTracker} from './src/tracking';\n+export {ActivePerfRecorder, DelegatingPerfRecorder} from './src/recorder';"
        },
        {
            "sha": "851ada1ba7b36a3f52fa76310c75d26830211554",
            "filename": "packages/compiler-cli/src/ngtsc/perf/src/api.ts",
            "status": "modified",
            "additions": 321,
            "deletions": 5,
            "changes": 326,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Fapi.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Fapi.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Fapi.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -6,12 +6,328 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {DeclarationNode} from '../../reflection';\n+/**\n+ * A phase of compilation for which time is tracked in a distinct bucket.\n+ */\n+export enum PerfPhase {\n+  /**\n+   * The \"default\" phase which tracks time not spent in any other phase.\n+   */\n+  Unaccounted,\n+\n+  /**\n+   * Time spent setting up the compiler, before a TypeScript program is created.\n+   *\n+   * This includes operations like configuring the `ts.CompilerHost` and any wrappers.\n+   */\n+  Setup,\n+\n+  /**\n+   * Time spent in `ts.createProgram`, including reading and parsing `ts.SourceFile`s in the\n+   * `ts.CompilerHost`.\n+   *\n+   * This might be an incremental program creation operation.\n+   */\n+  TypeScriptProgramCreate,\n+\n+  /**\n+   * Time spent reconciling the contents of an old `ts.Program` with the new incremental one.\n+   *\n+   * Only present in incremental compilations.\n+   */\n+  Reconciliation,\n+\n+  /**\n+   * Time spent updating an `NgCompiler` instance with a resource-only change.\n+   *\n+   * Only present in incremental compilations where the change was resource-only.\n+   */\n+  ResourceUpdate,\n+\n+  /**\n+   * Time spent calculating the plain TypeScript diagnostics (structural and semantic).\n+   */\n+  TypeScriptDiagnostics,\n+\n+  /**\n+   * Time spent in Angular analysis of individual classes in the program.\n+   */\n+  Analysis,\n+\n+  /**\n+   * Time spent in Angular global analysis (synthesis of analysis information into a complete\n+   * understanding of the program).\n+   */\n+  Resolve,\n+\n+  /**\n+   * Time spent building the import graph of the program in order to perform cycle detection.\n+   */\n+  CycleDetection,\n+\n+  /**\n+   * Time spent generating the text of Type Check Blocks in order to perform template type checking.\n+   */\n+  TcbGeneration,\n+\n+  /**\n+   * Time spent updating the `ts.Program` with new Type Check Block code.\n+   */\n+  TcbUpdateProgram,\n+\n+  /**\n+   * Time spent by TypeScript performing its emit operations, including downleveling and writing\n+   * output files.\n+   */\n+  TypeScriptEmit,\n+\n+  /**\n+   * Time spent by Angular performing code transformations of ASTs as they're about to be emitted.\n+   *\n+   * This includes the actual code generation step for templates, and occurs during the emit phase\n+   * (but is tracked separately from `TypeScriptEmit` time).\n+   */\n+  Compile,\n+\n+  /**\n+   * Time spent performing a `TemplateTypeChecker` autocompletion operation.\n+   */\n+  TtcAutocompletion,\n+\n+  /**\n+   * Time spent computing template type-checking diagnostics.\n+   */\n+  TtcDiagnostics,\n+\n+  /**\n+   * Time spent getting a `Symbol` from the `TemplateTypeChecker`.\n+   */\n+  TtcSymbol,\n+\n+  /**\n+   * Time spent by the Angular Language Service calculating a \"get references\" or a renaming\n+   * operation.\n+   */\n+  LsReferencesAndRenames,\n+\n+  /**\n+   * Tracks the number of `PerfPhase`s, and must appear at the end of the list.\n+   */\n+  LAST,\n+}\n+\n+/**\n+ * Represents some occurrence during compilation, and is tracked with a counter.\n+ */\n+export enum PerfEvent {\n+  /**\n+   * Counts the number of `.d.ts` files in the program.\n+   */\n+  InputDtsFile,\n+\n+  /**\n+   * Counts the number of non-`.d.ts` files in the program.\n+   */\n+  InputTsFile,\n+\n+  /**\n+   * An `@Component` class was analyzed.\n+   */\n+  AnalyzeComponent,\n+\n+  /**\n+   * An `@Directive` class was analyzed.\n+   */\n+  AnalyzeDirective,\n+\n+  /**\n+   * An `@Injectable` class was analyzed.\n+   */\n+  AnalyzeInjectable,\n+\n+  /**\n+   * An `@NgModule` class was analyzed.\n+   */\n+  AnalyzeNgModule,\n+\n+  /**\n+   * An `@Pipe` class was analyzed.\n+   */\n+  AnalyzePipe,\n+\n+  /**\n+   * A trait was analyzed.\n+   *\n+   * In theory, this should be the sum of the `Analyze` counters for each decorator type.\n+   */\n+  TraitAnalyze,\n \n+  /**\n+   * A trait had a prior analysis available from an incremental program, and did not need to be\n+   * re-analyzed.\n+   */\n+  TraitReuseAnalysis,\n+\n+  /**\n+   * A `ts.SourceFile` directly changed between the prior program and a new incremental compilation.\n+   */\n+  SourceFilePhysicalChange,\n+\n+  /**\n+   * A `ts.SourceFile` did not physically changed, but according to the file dependency graph, has\n+   * logically changed between the prior program and a new incremental compilation.\n+   */\n+  SourceFileLogicalChange,\n+\n+  /**\n+   * A `ts.SourceFile` has not logically changed and all of its analysis results were thus available\n+   * for reuse.\n+   */\n+  SourceFileReuseAnalysis,\n+\n+  /**\n+   * A Type Check Block (TCB) was generated.\n+   */\n+  GenerateTcb,\n+\n+  /**\n+   * A Type Check Block (TCB) could not be generated because inlining was disabled, and the block\n+   * would've required inlining.\n+   */\n+  SkipGenerateTcbNoInline,\n+\n+  /**\n+   * A `.ngtypecheck.ts` file could be reused from the previous program and did not need to be\n+   * regenerated.\n+   */\n+  ReuseTypeCheckFile,\n+\n+  /**\n+   * The template type-checking program required changes and had to be updated in an incremental\n+   * step.\n+   */\n+  UpdateTypeCheckProgram,\n+\n+  /**\n+   * The compiler was able to prove that a `ts.SourceFile` did not need to be re-emitted.\n+   */\n+  EmitSkipSourceFile,\n+\n+  /**\n+   * A `ts.SourceFile` was emitted.\n+   */\n+  EmitSourceFile,\n+\n+  /**\n+   * Tracks the number of `PrefEvent`s, and must appear at the end of the list.\n+   */\n+  LAST,\n+}\n+\n+/**\n+ * Represents a checkpoint during compilation at which the memory usage of the compiler should be\n+ * recorded.\n+ */\n+export enum PerfCheckpoint {\n+  /**\n+   * The point at which the `PerfRecorder` was created, and ideally tracks memory used before any\n+   * compilation structures are created.\n+   */\n+  Initial,\n+\n+  /**\n+   * The point just after the `ts.Program` has been created.\n+   */\n+  TypeScriptProgramCreate,\n+\n+  /**\n+   * The point just before Angular analysis starts.\n+   *\n+   * In the main usage pattern for the compiler, TypeScript diagnostics have been calculated at this\n+   * point, so the `ts.TypeChecker` has fully ingested the current program, all `ts.Type` structures\n+   * and `ts.Symbol`s have been created.\n+   */\n+  PreAnalysis,\n+\n+  /**\n+   * The point just after Angular analysis completes.\n+   */\n+  Analysis,\n+\n+  /**\n+   * The point just after Angular resolution is complete.\n+   */\n+  Resolve,\n+\n+  /**\n+   * The point just after Type Check Blocks (TCBs) have been generated.\n+   */\n+  TtcGeneration,\n+\n+  /**\n+   * The point just after the template type-checking program has been updated with any new TCBs.\n+   */\n+  TtcUpdateProgram,\n+\n+  /**\n+   * The point just before emit begins.\n+   *\n+   * In the main usage pattern for the compiler, all template type-checking diagnostics have been\n+   * requested at this point.\n+   */\n+  PreEmit,\n+\n+  /**\n+   * The point just after the program has been fully emitted.\n+   */\n+  Emit,\n+\n+  /**\n+   * Tracks the number of `PerfCheckpoint`s, and must appear at the end of the list.\n+   */\n+  LAST,\n+}\n+\n+/**\n+ * Records timing, memory, or counts at specific points in the compiler's operation.\n+ */\n export interface PerfRecorder {\n-  readonly enabled: boolean;\n+  /**\n+   * Set the current phase of compilation.\n+   *\n+   * Time spent in the previous phase will be accounted to that phase. The caller is responsible for\n+   * exiting the phase when work that should be tracked within it is completed, and either returning\n+   * to the previous phase or transitioning to the next one directly.\n+   *\n+   * In general, prefer using `inPhase()` to instrument a section of code, as it automatically\n+   * handles entering and exiting the phase. `phase()` should only be used when the former API\n+   * cannot be cleanly applied to a particular operation.\n+   *\n+   * @returns the previous phase\n+   */\n+  phase(phase: PerfPhase): PerfPhase;\n+\n+  /**\n+   * Run `fn` in the given `PerfPhase` and return the result.\n+   *\n+   * Enters `phase` before executing the given `fn`, then exits the phase and returns the result.\n+   * Prefer this API to `phase()` where possible.\n+   */\n+  inPhase<T>(phase: PerfPhase, fn: () => T): T;\n+\n+  /**\n+   * Record the memory usage of the compiler at the given checkpoint.\n+   */\n+  memory(after: PerfCheckpoint): void;\n+\n+  /**\n+   * Record that a specific event has occurred, possibly more than once.\n+   */\n+  eventCount(event: PerfEvent, incrementBy?: number): void;\n \n-  mark(name: string, node?: DeclarationNode, category?: string, detail?: string): void;\n-  start(name: string, node?: DeclarationNode, category?: string, detail?: string): number;\n-  stop(span: number): void;\n+  /**\n+   * Return the `PerfRecorder` to an empty state (clear all tracked statistics) and reset the zero\n+   * point to the current time.\n+   */\n+  reset(): void;\n }"
        },
        {
            "sha": "8d5c8e0a416ed3f4aa6ac037e3c0751dd35e1911",
            "filename": "packages/compiler-cli/src/ngtsc/perf/src/noop.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 10,
            "changes": 28,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Fnoop.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Fnoop.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Fnoop.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -5,15 +5,23 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-import {DeclarationNode} from '../../reflection';\n+import {PerfPhase, PerfRecorder} from './api';\n \n-import {PerfRecorder} from './api';\n+class NoopPerfRecorder implements PerfRecorder {\n+  eventCount(): void {}\n \n-export const NOOP_PERF_RECORDER: PerfRecorder = {\n-  enabled: false,\n-  mark: (name: string, node: DeclarationNode, category?: string, detail?: string): void => {},\n-  start: (name: string, node: DeclarationNode, category?: string, detail?: string): number => {\n-    return 0;\n-  },\n-  stop: (span: number|false): void => {},\n-};\n+  memory(): void {}\n+\n+  phase(): PerfPhase {\n+    return PerfPhase.Unaccounted;\n+  }\n+\n+  inPhase<T>(phase: PerfPhase, fn: () => T): T {\n+    return fn();\n+  }\n+\n+  reset(): void {}\n+}\n+\n+\n+export const NOOP_PERF_RECORDER: PerfRecorder = new NoopPerfRecorder();"
        },
        {
            "sha": "b35bf79ae00e2f581b3b3357ed0970ae21fc30a9",
            "filename": "packages/compiler-cli/src/ngtsc/perf/src/recorder.ts",
            "status": "added",
            "additions": 154,
            "deletions": 0,
            "changes": 154,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Frecorder.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Frecorder.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Frecorder.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -0,0 +1,154 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+/// <reference types=\"node\" />\n+\n+import {PerfCheckpoint, PerfEvent, PerfPhase, PerfRecorder} from './api';\n+import {HrTime, mark, timeSinceInMicros} from './clock';\n+\n+/**\n+ * Serializable performance data for the compilation, using string names.\n+ */\n+export interface PerfResults {\n+  events: Record<string, number>;\n+  phases: Record<string, number>;\n+  memory: Record<string, number>;\n+}\n+\n+/**\n+ * A `PerfRecorder` that actively tracks performance statistics.\n+ */\n+export class ActivePerfRecorder implements PerfRecorder {\n+  private counters: number[];\n+  private phaseTime: number[];\n+  private bytes: number[];\n+\n+  private currentPhase = PerfPhase.Unaccounted;\n+  private currentPhaseEntered = this.zeroTime;\n+\n+  /**\n+   * Creates an `ActivePerfRecoder` with its zero point set to the current time.\n+   */\n+  static zeroedToNow(): ActivePerfRecorder {\n+    return new ActivePerfRecorder(mark());\n+  }\n+\n+  private constructor(private zeroTime: HrTime) {\n+    this.counters = Array(PerfEvent.LAST).fill(0);\n+    this.phaseTime = Array(PerfPhase.LAST).fill(0);\n+    this.bytes = Array(PerfCheckpoint.LAST).fill(0);\n+\n+    // Take an initial memory snapshot before any other compilation work begins.\n+    this.memory(PerfCheckpoint.Initial);\n+  }\n+\n+  reset(): void {\n+    this.counters = Array(PerfEvent.LAST).fill(0);\n+    this.phaseTime = Array(PerfPhase.LAST).fill(0);\n+    this.bytes = Array(PerfCheckpoint.LAST).fill(0);\n+    this.zeroTime = mark();\n+    this.currentPhase = PerfPhase.Unaccounted;\n+    this.currentPhaseEntered = this.zeroTime;\n+  }\n+\n+  memory(after: PerfCheckpoint): void {\n+    this.bytes[after] = process.memoryUsage().heapUsed;\n+  }\n+\n+  phase(phase: PerfPhase): PerfPhase {\n+    const previous = this.currentPhase;\n+    this.phaseTime[this.currentPhase] += timeSinceInMicros(this.currentPhaseEntered);\n+    this.currentPhase = phase;\n+    this.currentPhaseEntered = mark();\n+    return previous;\n+  }\n+\n+  inPhase<T>(phase: PerfPhase, fn: () => T): T {\n+    const previousPhase = this.phase(phase);\n+    try {\n+      return fn();\n+    } finally {\n+      this.phase(previousPhase);\n+    }\n+  }\n+\n+  eventCount(counter: PerfEvent, incrementBy: number = 1): void {\n+    this.counters[counter] += incrementBy;\n+  }\n+\n+  /**\n+   * Return the current performance metrics as a serializable object.\n+   */\n+  finalize(): PerfResults {\n+    // Track the last segment of time spent in `this.currentPhase` in the time array.\n+    this.phase(PerfPhase.Unaccounted);\n+\n+    const results: PerfResults = {\n+      events: {},\n+      phases: {},\n+      memory: {},\n+    };\n+\n+    for (let i = 0; i < this.phaseTime.length; i++) {\n+      if (this.phaseTime[i] > 0) {\n+        results.phases[PerfPhase[i]] = this.phaseTime[i];\n+      }\n+    }\n+\n+    for (let i = 0; i < this.phaseTime.length; i++) {\n+      if (this.counters[i] > 0) {\n+        results.events[PerfEvent[i]] = this.counters[i];\n+      }\n+    }\n+\n+    for (let i = 0; i < this.bytes.length; i++) {\n+      if (this.bytes[i] > 0) {\n+        results.memory[PerfCheckpoint[i]] = this.bytes[i];\n+      }\n+    }\n+\n+    return results;\n+  }\n+}\n+\n+/**\n+ * A `PerfRecorder` that delegates to a target `PerfRecorder` which can be updated later.\n+ *\n+ * `DelegatingPerfRecorder` is useful when a compiler class that needs a `PerfRecorder` can outlive\n+ * the current compilation. This is true for most compiler classes as resource-only changes reuse\n+ * the same `NgCompiler` for a new compilation.\n+ */\n+export class DelegatingPerfRecorder implements PerfRecorder {\n+  constructor(public target: PerfRecorder) {}\n+\n+  eventCount(counter: PerfEvent, incrementBy?: number): void {\n+    this.target.eventCount(counter, incrementBy);\n+  }\n+\n+  phase(phase: PerfPhase): PerfPhase {\n+    return this.target.phase(phase);\n+  }\n+\n+  inPhase<T>(phase: PerfPhase, fn: () => T): T {\n+    // Note: this doesn't delegate to `this.target.inPhase` but instead is implemented manually here\n+    // to avoid adding an additional frame of noise to the stack when debugging.\n+    const previousPhase = this.target.phase(phase);\n+    try {\n+      return fn();\n+    } finally {\n+      this.target.phase(previousPhase);\n+    }\n+  }\n+\n+  memory(after: PerfCheckpoint): void {\n+    this.target.memory(after);\n+  }\n+\n+  reset(): void {\n+    this.target.reset();\n+  }\n+}"
        },
        {
            "sha": "732c8f03671e1bd1521de3d214b636c985ef3b23",
            "filename": "packages/compiler-cli/src/ngtsc/perf/src/tracking.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 110,
            "changes": 110,
            "blob_url": "https://github.com/angular/angular/blob/dd82c8e9f4d7107d8a9e9e1af451a3b7eb45bb5c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Ftracking.ts",
            "raw_url": "https://github.com/angular/angular/raw/dd82c8e9f4d7107d8a9e9e1af451a3b7eb45bb5c/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Ftracking.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fperf%2Fsrc%2Ftracking.ts?ref=dd82c8e9f4d7107d8a9e9e1af451a3b7eb45bb5c",
            "patch": "@@ -1,110 +0,0 @@\n-/**\n- * @license\n- * Copyright Google LLC All Rights Reserved.\n- *\n- * Use of this source code is governed by an MIT-style license that can be\n- * found in the LICENSE file at https://angular.io/license\n- */\n-/// <reference types=\"node\" />\n-import * as fs from 'fs';\n-import * as ts from 'typescript';\n-import {resolve} from '../../file_system';\n-import {DeclarationNode} from '../../reflection';\n-import {PerfRecorder} from './api';\n-import {HrTime, mark, timeSinceInMicros} from './clock';\n-\n-export class PerfTracker implements PerfRecorder {\n-  private nextSpanId = 1;\n-  private log: PerfLogEvent[] = [];\n-\n-  readonly enabled = true;\n-\n-  private constructor(private zeroTime: HrTime) {}\n-\n-  static zeroedToNow(): PerfTracker {\n-    return new PerfTracker(mark());\n-  }\n-\n-  mark(name: string, node?: DeclarationNode, category?: string, detail?: string): void {\n-    const msg = this.makeLogMessage(PerfLogEventType.MARK, name, node, category, detail, undefined);\n-    this.log.push(msg);\n-  }\n-\n-  start(name: string, node?: DeclarationNode, category?: string, detail?: string): number {\n-    const span = this.nextSpanId++;\n-    const msg = this.makeLogMessage(PerfLogEventType.SPAN_OPEN, name, node, category, detail, span);\n-    this.log.push(msg);\n-    return span;\n-  }\n-\n-  stop(span: number): void {\n-    this.log.push({\n-      type: PerfLogEventType.SPAN_CLOSE,\n-      span,\n-      stamp: timeSinceInMicros(this.zeroTime),\n-    });\n-  }\n-\n-  private makeLogMessage(\n-      type: PerfLogEventType, name: string, node: DeclarationNode|undefined,\n-      category: string|undefined, detail: string|undefined, span: number|undefined): PerfLogEvent {\n-    const msg: PerfLogEvent = {\n-      type,\n-      name,\n-      stamp: timeSinceInMicros(this.zeroTime),\n-    };\n-    if (category !== undefined) {\n-      msg.category = category;\n-    }\n-    if (detail !== undefined) {\n-      msg.detail = detail;\n-    }\n-    if (span !== undefined) {\n-      msg.span = span;\n-    }\n-    if (node !== undefined) {\n-      msg.file = node.getSourceFile().fileName;\n-      if (!ts.isSourceFile(node)) {\n-        const name = ts.getNameOfDeclaration(node);\n-        if (name !== undefined && ts.isIdentifier(name)) {\n-          msg.declaration = name.text;\n-        }\n-      }\n-    }\n-    return msg;\n-  }\n-\n-  asJson(): unknown {\n-    return this.log;\n-  }\n-\n-  serializeToFile(target: string, host: ts.CompilerHost): void {\n-    const json = JSON.stringify(this.log, null, 2);\n-\n-    if (target.startsWith('ts:')) {\n-      target = target.substr('ts:'.length);\n-      const outFile = resolve(host.getCurrentDirectory(), target);\n-      host.writeFile(outFile, json, false);\n-    } else {\n-      const outFile = resolve(host.getCurrentDirectory(), target);\n-      fs.writeFileSync(outFile, json);\n-    }\n-  }\n-}\n-\n-export interface PerfLogEvent {\n-  name?: string;\n-  span?: number;\n-  file?: string;\n-  declaration?: string;\n-  type: PerfLogEventType;\n-  category?: string;\n-  detail?: string;\n-  stamp: number;\n-}\n-\n-export enum PerfLogEventType {\n-  SPAN_OPEN,\n-  SPAN_CLOSE,\n-  MARK,\n-}"
        },
        {
            "sha": "1eb8ae18e7d161740af0ba66547f7ab46390085c",
            "filename": "packages/compiler-cli/src/ngtsc/program.ts",
            "status": "modified",
            "additions": 116,
            "deletions": 93,
            "changes": 209,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fprogram.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -14,10 +14,10 @@ import {verifySupportedTypeScriptVersion} from '../typescript_support';\n \n import {CompilationTicket, freshCompilationTicket, incrementalFromCompilerTicket, NgCompiler, NgCompilerHost} from './core';\n import {NgCompilerOptions} from './core/api';\n-import {absoluteFrom, AbsoluteFsPath} from './file_system';\n+import {absoluteFrom, AbsoluteFsPath, getFileSystem} from './file_system';\n import {TrackedIncrementalBuildStrategy} from './incremental';\n import {IndexedComponent} from './indexer';\n-import {NOOP_PERF_RECORDER, PerfRecorder, PerfTracker} from './perf';\n+import {ActivePerfRecorder, PerfCheckpoint as PerfCheckpoint, PerfEvent, PerfPhase} from './perf';\n import {DeclarationNode} from './reflection';\n import {retagAllTsFiles, untagAllTsFiles} from './shims';\n import {ReusedProgramStrategy} from './typecheck';\n@@ -54,22 +54,20 @@ export class NgtscProgram implements api.Program {\n   private reuseTsProgram: ts.Program;\n   private closureCompilerEnabled: boolean;\n   private host: NgCompilerHost;\n-  private perfRecorder: PerfRecorder = NOOP_PERF_RECORDER;\n-  private perfTracker: PerfTracker|null = null;\n   private incrementalStrategy: TrackedIncrementalBuildStrategy;\n \n   constructor(\n       rootNames: ReadonlyArray<string>, private options: NgCompilerOptions,\n       delegateHost: api.CompilerHost, oldProgram?: NgtscProgram) {\n+    const perfRecorder = ActivePerfRecorder.zeroedToNow();\n+\n+    perfRecorder.phase(PerfPhase.Setup);\n+\n     // First, check whether the current TS version is supported.\n     if (!options.disableTypeScriptVersionCheck) {\n       verifySupportedTypeScriptVersion();\n     }\n \n-    if (options.tracePerformance !== undefined) {\n-      this.perfTracker = PerfTracker.zeroedToNow();\n-      this.perfRecorder = this.perfTracker;\n-    }\n     this.closureCompilerEnabled = !!options.annotateForClosureCompiler;\n \n     const reuseProgram = oldProgram?.reuseTsProgram;\n@@ -83,9 +81,14 @@ export class NgtscProgram implements api.Program {\n       retagAllTsFiles(reuseProgram);\n     }\n \n-    this.tsProgram = ts.createProgram(this.host.inputFiles, options, this.host, reuseProgram);\n+    this.tsProgram = perfRecorder.inPhase(\n+        PerfPhase.TypeScriptProgramCreate,\n+        () => ts.createProgram(this.host.inputFiles, options, this.host, reuseProgram));\n     this.reuseTsProgram = this.tsProgram;\n \n+    perfRecorder.phase(PerfPhase.Unaccounted);\n+    perfRecorder.memory(PerfCheckpoint.TypeScriptProgramCreate);\n+\n     this.host.postProgramCreationCleanup();\n \n     // Shim tagging has served its purpose, and tags can now be removed from all `ts.SourceFile`s in\n@@ -111,7 +114,7 @@ export class NgtscProgram implements api.Program {\n     let ticket: CompilationTicket;\n     if (oldProgram === undefined) {\n       ticket = freshCompilationTicket(\n-          this.tsProgram, options, this.incrementalStrategy, reusedProgramStrategy,\n+          this.tsProgram, options, this.incrementalStrategy, reusedProgramStrategy, perfRecorder,\n           /* enableTemplateTypeChecker */ false, /* usePoisonedData */ false);\n     } else {\n       ticket = incrementalFromCompilerTicket(\n@@ -120,12 +123,13 @@ export class NgtscProgram implements api.Program {\n           this.incrementalStrategy,\n           reusedProgramStrategy,\n           modifiedResourceFiles,\n+          perfRecorder,\n       );\n     }\n \n \n     // Create the NgCompiler which will drive the rest of the compilation.\n-    this.compiler = NgCompiler.fromTicket(ticket, this.host, this.perfRecorder);\n+    this.compiler = NgCompiler.fromTicket(ticket, this.host);\n   }\n \n   getTsProgram(): ts.Program {\n@@ -138,49 +142,59 @@ export class NgtscProgram implements api.Program {\n \n   getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken|\n                          undefined): readonly ts.Diagnostic[] {\n-    return this.tsProgram.getOptionsDiagnostics(cancellationToken);\n+    return this.compiler.perfRecorder.inPhase(\n+        PerfPhase.TypeScriptDiagnostics,\n+        () => this.tsProgram.getOptionsDiagnostics(cancellationToken));\n   }\n \n   getTsSyntacticDiagnostics(\n       sourceFile?: ts.SourceFile|undefined,\n       cancellationToken?: ts.CancellationToken|undefined): readonly ts.Diagnostic[] {\n-    const ignoredFiles = this.compiler.ignoreForDiagnostics;\n-    if (sourceFile !== undefined) {\n-      if (ignoredFiles.has(sourceFile)) {\n-        return [];\n-      }\n+    return this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptDiagnostics, () => {\n+      const ignoredFiles = this.compiler.ignoreForDiagnostics;\n+      let res: readonly ts.Diagnostic[];\n+      if (sourceFile !== undefined) {\n+        if (ignoredFiles.has(sourceFile)) {\n+          return [];\n+        }\n \n-      return this.tsProgram.getSyntacticDiagnostics(sourceFile, cancellationToken);\n-    } else {\n-      const diagnostics: ts.Diagnostic[] = [];\n-      for (const sf of this.tsProgram.getSourceFiles()) {\n-        if (!ignoredFiles.has(sf)) {\n-          diagnostics.push(...this.tsProgram.getSyntacticDiagnostics(sf, cancellationToken));\n+        res = this.tsProgram.getSyntacticDiagnostics(sourceFile, cancellationToken);\n+      } else {\n+        const diagnostics: ts.Diagnostic[] = [];\n+        for (const sf of this.tsProgram.getSourceFiles()) {\n+          if (!ignoredFiles.has(sf)) {\n+            diagnostics.push(...this.tsProgram.getSyntacticDiagnostics(sf, cancellationToken));\n+          }\n         }\n+        res = diagnostics;\n       }\n-      return diagnostics;\n-    }\n+      return res;\n+    });\n   }\n \n   getTsSemanticDiagnostics(\n       sourceFile?: ts.SourceFile|undefined,\n       cancellationToken?: ts.CancellationToken|undefined): readonly ts.Diagnostic[] {\n-    const ignoredFiles = this.compiler.ignoreForDiagnostics;\n-    if (sourceFile !== undefined) {\n-      if (ignoredFiles.has(sourceFile)) {\n-        return [];\n-      }\n+    return this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptDiagnostics, () => {\n+      const ignoredFiles = this.compiler.ignoreForDiagnostics;\n+      let res: readonly ts.Diagnostic[];\n+      if (sourceFile !== undefined) {\n+        if (ignoredFiles.has(sourceFile)) {\n+          return [];\n+        }\n \n-      return this.tsProgram.getSemanticDiagnostics(sourceFile, cancellationToken);\n-    } else {\n-      const diagnostics: ts.Diagnostic[] = [];\n-      for (const sf of this.tsProgram.getSourceFiles()) {\n-        if (!ignoredFiles.has(sf)) {\n-          diagnostics.push(...this.tsProgram.getSemanticDiagnostics(sf, cancellationToken));\n+        res = this.tsProgram.getSemanticDiagnostics(sourceFile, cancellationToken);\n+      } else {\n+        const diagnostics: ts.Diagnostic[] = [];\n+        for (const sf of this.tsProgram.getSourceFiles()) {\n+          if (!ignoredFiles.has(sf)) {\n+            diagnostics.push(...this.tsProgram.getSemanticDiagnostics(sf, cancellationToken));\n+          }\n         }\n+        res = diagnostics;\n       }\n-      return diagnostics;\n-    }\n+      return res;\n+    });\n   }\n \n   getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken|\n@@ -235,73 +249,82 @@ export class NgtscProgram implements api.Program {\n     emitCallback?: api.TsEmitCallback | undefined;\n     mergeEmitResultsCallback?: api.TsMergeEmitResultsCallback | undefined;\n   }|undefined): ts.EmitResult {\n-    const {transformers} = this.compiler.prepareEmit();\n-    const ignoreFiles = this.compiler.ignoreForEmit;\n-    const emitCallback = opts && opts.emitCallback || defaultEmitCallback;\n-\n-    const writeFile: ts.WriteFileCallback =\n-        (fileName: string, data: string, writeByteOrderMark: boolean,\n-         onError: ((message: string) => void)|undefined,\n-         sourceFiles: ReadonlyArray<ts.SourceFile>|undefined) => {\n-          if (sourceFiles !== undefined) {\n-            // Record successful writes for any `ts.SourceFile` (that's not a declaration file)\n-            // that's an input to this write.\n-            for (const writtenSf of sourceFiles) {\n-              if (writtenSf.isDeclarationFile) {\n-                continue;\n+    this.compiler.perfRecorder.memory(PerfCheckpoint.PreEmit);\n+\n+    const res = this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptEmit, () => {\n+      const {transformers} = this.compiler.prepareEmit();\n+      const ignoreFiles = this.compiler.ignoreForEmit;\n+      const emitCallback = opts && opts.emitCallback || defaultEmitCallback;\n+\n+      const writeFile: ts.WriteFileCallback =\n+          (fileName: string, data: string, writeByteOrderMark: boolean,\n+           onError: ((message: string) => void)|undefined,\n+           sourceFiles: ReadonlyArray<ts.SourceFile>|undefined) => {\n+            if (sourceFiles !== undefined) {\n+              // Record successful writes for any `ts.SourceFile` (that's not a declaration file)\n+              // that's an input to this write.\n+              for (const writtenSf of sourceFiles) {\n+                if (writtenSf.isDeclarationFile) {\n+                  continue;\n+                }\n+\n+                this.compiler.incrementalDriver.recordSuccessfulEmit(writtenSf);\n               }\n-\n-              this.compiler.incrementalDriver.recordSuccessfulEmit(writtenSf);\n             }\n-          }\n-          this.host.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n-        };\n+            this.host.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n+          };\n \n-    const customTransforms = opts && opts.customTransformers;\n-    const beforeTransforms = transformers.before || [];\n-    const afterDeclarationsTransforms = transformers.afterDeclarations;\n+      const customTransforms = opts && opts.customTransformers;\n+      const beforeTransforms = transformers.before || [];\n+      const afterDeclarationsTransforms = transformers.afterDeclarations;\n \n-    if (customTransforms !== undefined && customTransforms.beforeTs !== undefined) {\n-      beforeTransforms.push(...customTransforms.beforeTs);\n-    }\n+      if (customTransforms !== undefined && customTransforms.beforeTs !== undefined) {\n+        beforeTransforms.push(...customTransforms.beforeTs);\n+      }\n \n-    const emitSpan = this.perfRecorder.start('emit');\n-    const emitResults: ts.EmitResult[] = [];\n+      const emitResults: ts.EmitResult[] = [];\n \n-    for (const targetSourceFile of this.tsProgram.getSourceFiles()) {\n-      if (targetSourceFile.isDeclarationFile || ignoreFiles.has(targetSourceFile)) {\n-        continue;\n-      }\n+      for (const targetSourceFile of this.tsProgram.getSourceFiles()) {\n+        if (targetSourceFile.isDeclarationFile || ignoreFiles.has(targetSourceFile)) {\n+          continue;\n+        }\n+\n+        if (this.compiler.incrementalDriver.safeToSkipEmit(targetSourceFile)) {\n+          this.compiler.perfRecorder.eventCount(PerfEvent.EmitSkipSourceFile);\n+          continue;\n+        }\n \n-      if (this.compiler.incrementalDriver.safeToSkipEmit(targetSourceFile)) {\n-        continue;\n+        this.compiler.perfRecorder.eventCount(PerfEvent.EmitSourceFile);\n+\n+        emitResults.push(emitCallback({\n+          targetSourceFile,\n+          program: this.tsProgram,\n+          host: this.host,\n+          options: this.options,\n+          emitOnlyDtsFiles: false,\n+          writeFile,\n+          customTransformers: {\n+            before: beforeTransforms,\n+            after: customTransforms && customTransforms.afterTs,\n+            afterDeclarations: afterDeclarationsTransforms,\n+          } as any,\n+        }));\n       }\n \n-      const fileEmitSpan = this.perfRecorder.start('emitFile', targetSourceFile);\n-      emitResults.push(emitCallback({\n-        targetSourceFile,\n-        program: this.tsProgram,\n-        host: this.host,\n-        options: this.options,\n-        emitOnlyDtsFiles: false,\n-        writeFile,\n-        customTransformers: {\n-          before: beforeTransforms,\n-          after: customTransforms && customTransforms.afterTs,\n-          afterDeclarations: afterDeclarationsTransforms,\n-        } as any,\n-      }));\n-      this.perfRecorder.stop(fileEmitSpan);\n-    }\n+      this.compiler.perfRecorder.memory(PerfCheckpoint.Emit);\n \n-    this.perfRecorder.stop(emitSpan);\n+      // Run the emit, including a custom transformer that will downlevel the Ivy decorators in\n+      // code.\n+      return ((opts && opts.mergeEmitResultsCallback) || mergeEmitResults)(emitResults);\n+    });\n \n-    if (this.perfTracker !== null && this.options.tracePerformance !== undefined) {\n-      this.perfTracker.serializeToFile(this.options.tracePerformance, this.host);\n+    // Record performance analysis information to disk if we've been asked to do so.\n+    if (this.options.tracePerformance !== undefined) {\n+      const perf = this.compiler.perfRecorder.finalize();\n+      getFileSystem().writeFile(\n+          getFileSystem().resolve(this.options.tracePerformance), JSON.stringify(perf, null, 2));\n     }\n-\n-    // Run the emit, including a custom transformer that will downlevel the Ivy decorators in code.\n-    return ((opts && opts.mergeEmitResultsCallback) || mergeEmitResults)(emitResults);\n+    return res;\n   }\n \n   getIndexedComponents(): Map<DeclarationNode, IndexedComponent> {"
        },
        {
            "sha": "d26059c9b61f7786486f3e902096e29c671c4a2f",
            "filename": "packages/compiler-cli/src/ngtsc/transform/src/compilation.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fcompilation.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fcompilation.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Fcompilation.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -13,7 +13,7 @@ import {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\n import {IncrementalBuild} from '../../incremental/api';\n import {SemanticDepGraphUpdater, SemanticSymbol} from '../../incremental/semantic_graph';\n import {IndexingContext} from '../../indexer';\n-import {PerfRecorder} from '../../perf';\n+import {PerfEvent, PerfRecorder} from '../../perf';\n import {ClassDeclaration, DeclarationNode, Decorator, ReflectionHost} from '../../reflection';\n import {ProgramTypeCheckAdapter, TypeCheckContext} from '../../typecheck/api';\n import {getSourceFile, isExported} from '../../util/src/typescript';\n@@ -124,6 +124,9 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n         this.adopt(priorRecord);\n       }\n \n+      this.perf.eventCount(PerfEvent.SourceFileReuseAnalysis);\n+      this.perf.eventCount(PerfEvent.TraitReuseAnalysis, priorWork.length);\n+\n       // Skip the rest of analysis, as this file's prior traits are being reused.\n       return;\n     }\n@@ -359,6 +362,8 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n           TraitState[trait.state]} (expected DETECTED)`);\n     }\n \n+    this.perf.eventCount(PerfEvent.TraitAnalyze);\n+\n     // Attempt analysis. This could fail with a `FatalDiagnosticError`; catch it if it does.\n     let result: AnalysisOutput<unknown>;\n     try {\n@@ -509,9 +514,6 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n         continue;\n       }\n \n-      const compileSpan = this.perf.start('compileClass', original);\n-\n-\n       // `trait.resolution` is non-null asserted here because TypeScript does not recognize that\n       // `Readonly<unknown>` is nullable (as `unknown` itself is nullable) due to the way that\n       // `Readonly` works.\n@@ -526,7 +528,6 @@ export class TraitCompiler implements ProgramTypeCheckAdapter {\n       }\n \n       const compileMatchRes = compileRes;\n-      this.perf.stop(compileSpan);\n       if (Array.isArray(compileMatchRes)) {\n         for (const result of compileMatchRes) {\n           if (!res.some(r => r.name === result.name)) {"
        },
        {
            "sha": "c9a0d7bd10cf2a01785f54285e3b4a9c43f9cd3a",
            "filename": "packages/compiler-cli/src/ngtsc/transform/src/transform.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftransform.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftransform.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftransform%2Fsrc%2Ftransform.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -10,6 +10,7 @@ import {ConstantPool} from '@angular/compiler';\n import * as ts from 'typescript';\n \n import {DefaultImportRecorder, ImportRewriter} from '../../imports';\n+import {PerfPhase, PerfRecorder} from '../../perf';\n import {Decorator, ReflectionHost} from '../../reflection';\n import {ImportManager, RecordWrappedNodeExprFn, translateExpression, translateStatement, TranslatorOptions} from '../../translator';\n import {visit, VisitListEntryResult, Visitor} from '../../util/src/visitor';\n@@ -33,14 +34,16 @@ interface FileOverviewMeta {\n \n export function ivyTransformFactory(\n     compilation: TraitCompiler, reflector: ReflectionHost, importRewriter: ImportRewriter,\n-    defaultImportRecorder: DefaultImportRecorder, isCore: boolean,\n+    defaultImportRecorder: DefaultImportRecorder, perf: PerfRecorder, isCore: boolean,\n     isClosureCompilerEnabled: boolean): ts.TransformerFactory<ts.SourceFile> {\n   const recordWrappedNodeExpr = createRecorderFn(defaultImportRecorder);\n   return (context: ts.TransformationContext): ts.Transformer<ts.SourceFile> => {\n     return (file: ts.SourceFile): ts.SourceFile => {\n-      return transformIvySourceFile(\n-          compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled,\n-          recordWrappedNodeExpr);\n+      return perf.inPhase(\n+          PerfPhase.Compile,\n+          () => transformIvySourceFile(\n+              compilation, context, reflector, importRewriter, file, isCore,\n+              isClosureCompilerEnabled, recordWrappedNodeExpr));\n     };\n   };\n }"
        },
        {
            "sha": "292c472a19e48fa04efcda667e5f317acec3d87a",
            "filename": "packages/compiler-cli/src/ngtsc/tsc_plugin.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 4,
            "changes": 18,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftsc_plugin.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftsc_plugin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftsc_plugin.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -12,7 +12,7 @@ import {CompilationTicket, freshCompilationTicket, incrementalFromDriverTicket,\n import {NgCompilerOptions, UnifiedModulesHost} from './core/api';\n import {NodeJSFileSystem, setFileSystem} from './file_system';\n import {PatchedProgramIncrementalBuildStrategy} from './incremental';\n-import {NOOP_PERF_RECORDER} from './perf';\n+import {ActivePerfRecorder, NOOP_PERF_RECORDER, PerfPhase} from './perf';\n import {untagAllTsFiles} from './shims';\n import {OptimizeFor} from './typecheck/api';\n import {ReusedProgramStrategy} from './typecheck/src/augmented_program';\n@@ -94,6 +94,13 @@ export class NgTscPlugin implements TscPlugin {\n     ignoreForDiagnostics: Set<ts.SourceFile>,\n     ignoreForEmit: Set<ts.SourceFile>,\n   } {\n+    // TODO(alxhub): we provide a `PerfRecorder` to the compiler, but because we're not driving the\n+    // compilation, the information captured within it is incomplete, and may not include timings\n+    // for phases such as emit.\n+    //\n+    // Additionally, nothing actually captures the perf results here, so recording stats at all is\n+    // somewhat moot for now :)\n+    const perfRecorder = ActivePerfRecorder.zeroedToNow();\n     if (this.host === null || this.options === null) {\n       throw new Error('Lifecycle error: setupCompilation() before wrapHost().');\n     }\n@@ -115,15 +122,15 @@ export class NgTscPlugin implements TscPlugin {\n \n     if (oldProgram === undefined || oldDriver === null) {\n       ticket = freshCompilationTicket(\n-          program, this.options, strategy, typeCheckStrategy,\n+          program, this.options, strategy, typeCheckStrategy, perfRecorder,\n           /* enableTemplateTypeChecker */ false, /* usePoisonedData */ false);\n     } else {\n       strategy.toNextBuildStrategy().getIncrementalDriver(oldProgram);\n       ticket = incrementalFromDriverTicket(\n           oldProgram, oldDriver, program, this.options, strategy, typeCheckStrategy,\n-          modifiedResourceFiles, false, false);\n+          modifiedResourceFiles, perfRecorder, false, false);\n     }\n-    this._compiler = NgCompiler.fromTicket(ticket, this.host, NOOP_PERF_RECORDER);\n+    this._compiler = NgCompiler.fromTicket(ticket, this.host);\n     return {\n       ignoreForDiagnostics: this._compiler.ignoreForDiagnostics,\n       ignoreForEmit: this._compiler.ignoreForEmit,\n@@ -146,6 +153,9 @@ export class NgTscPlugin implements TscPlugin {\n   }\n \n   createTransformers(): ts.CustomTransformers {\n+    // The plugin consumer doesn't know about our perf tracing system, so we consider the emit phase\n+    // as beginning now.\n+    this.compiler.perfRecorder.phase(PerfPhase.TypeScriptEmit);\n     return this.compiler.prepareEmit().transformers;\n   }\n }"
        },
        {
            "sha": "a258bcd9be1229e88d0d0671032ebf2e7f78e624",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2FBUILD.bazel?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -15,6 +15,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n         \"//packages/compiler-cli/src/ngtsc/incremental:api\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n+        \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"//packages/compiler-cli/src/ngtsc/scope\",\n         \"//packages/compiler-cli/src/ngtsc/shims\","
        },
        {
            "sha": "92ba82b43fde776f40b182c4fd07f9194ad94096",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts",
            "status": "modified",
            "additions": 100,
            "deletions": 80,
            "changes": 180,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fchecker.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -12,6 +12,7 @@ import * as ts from 'typescript';\n import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\n import {Reference, ReferenceEmitter} from '../../imports';\n import {IncrementalBuild} from '../../incremental/api';\n+import {PerfCheckpoint, PerfEvent, PerfPhase, PerfRecorder} from '../../perf';\n import {ClassDeclaration, isNamedClassDeclaration, ReflectionHost} from '../../reflection';\n import {ComponentScopeReader, TypeCheckScopeRegistry} from '../../scope';\n import {isShim} from '../../shims';\n@@ -82,7 +83,8 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n       private compilerHost: Pick<ts.CompilerHost, 'getCanonicalFileName'>,\n       private priorBuild: IncrementalBuild<unknown, FileTypeCheckingData>,\n       private readonly componentScopeReader: ComponentScopeReader,\n-      private readonly typeCheckScopeRegistry: TypeCheckScopeRegistry) {}\n+      private readonly typeCheckScopeRegistry: TypeCheckScopeRegistry,\n+      private readonly perf: PerfRecorder) {}\n \n   getTemplate(component: ts.ClassDeclaration): TmplAstNode[]|null {\n     const {data} = this.getLatestComponentState(component);\n@@ -181,69 +183,73 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n         break;\n     }\n \n-    const sfPath = absoluteFromSourceFile(sf);\n-    const fileRecord = this.state.get(sfPath)!;\n+    return this.perf.inPhase(PerfPhase.TtcDiagnostics, () => {\n+      const sfPath = absoluteFromSourceFile(sf);\n+      const fileRecord = this.state.get(sfPath)!;\n \n-    const typeCheckProgram = this.typeCheckingStrategy.getProgram();\n+      const typeCheckProgram = this.typeCheckingStrategy.getProgram();\n \n-    const diagnostics: (ts.Diagnostic|null)[] = [];\n-    if (fileRecord.hasInlines) {\n-      const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n-      diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(\n-          diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n-    }\n+      const diagnostics: (ts.Diagnostic|null)[] = [];\n+      if (fileRecord.hasInlines) {\n+        const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n+        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(\n+            diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n+      }\n \n-    for (const [shimPath, shimRecord] of fileRecord.shimData) {\n-      const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n-      diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(\n-          diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n-      diagnostics.push(...shimRecord.genesisDiagnostics);\n+      for (const [shimPath, shimRecord] of fileRecord.shimData) {\n+        const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n+        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(\n+            diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n+        diagnostics.push(...shimRecord.genesisDiagnostics);\n \n-      for (const templateData of shimRecord.templates.values()) {\n-        diagnostics.push(...templateData.templateDiagnostics);\n+        for (const templateData of shimRecord.templates.values()) {\n+          diagnostics.push(...templateData.templateDiagnostics);\n+        }\n       }\n-    }\n \n-    return diagnostics.filter((diag: ts.Diagnostic|null): diag is ts.Diagnostic => diag !== null);\n+      return diagnostics.filter((diag: ts.Diagnostic|null): diag is ts.Diagnostic => diag !== null);\n+    });\n   }\n \n   getDiagnosticsForComponent(component: ts.ClassDeclaration): ts.Diagnostic[] {\n     this.ensureShimForComponent(component);\n \n-    const sf = component.getSourceFile();\n-    const sfPath = absoluteFromSourceFile(sf);\n-    const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);\n+    return this.perf.inPhase(PerfPhase.TtcDiagnostics, () => {\n+      const sf = component.getSourceFile();\n+      const sfPath = absoluteFromSourceFile(sf);\n+      const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);\n \n-    const fileRecord = this.getFileData(sfPath);\n+      const fileRecord = this.getFileData(sfPath);\n \n-    if (!fileRecord.shimData.has(shimPath)) {\n-      return [];\n-    }\n+      if (!fileRecord.shimData.has(shimPath)) {\n+        return [];\n+      }\n \n-    const templateId = fileRecord.sourceManager.getTemplateId(component);\n-    const shimRecord = fileRecord.shimData.get(shimPath)!;\n+      const templateId = fileRecord.sourceManager.getTemplateId(component);\n+      const shimRecord = fileRecord.shimData.get(shimPath)!;\n \n-    const typeCheckProgram = this.typeCheckingStrategy.getProgram();\n+      const typeCheckProgram = this.typeCheckingStrategy.getProgram();\n \n-    const diagnostics: (TemplateDiagnostic|null)[] = [];\n-    if (shimRecord.hasInlines) {\n-      const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n-      diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(\n-          diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n-    }\n+      const diagnostics: (TemplateDiagnostic|null)[] = [];\n+      if (shimRecord.hasInlines) {\n+        const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n+        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(\n+            diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n+      }\n \n-    const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n-    diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(\n-        diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n-    diagnostics.push(...shimRecord.genesisDiagnostics);\n+      const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n+      diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(\n+          diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n+      diagnostics.push(...shimRecord.genesisDiagnostics);\n \n-    for (const templateData of shimRecord.templates.values()) {\n-      diagnostics.push(...templateData.templateDiagnostics);\n-    }\n+      for (const templateData of shimRecord.templates.values()) {\n+        diagnostics.push(...templateData.templateDiagnostics);\n+      }\n \n-    return diagnostics.filter(\n-        (diag: TemplateDiagnostic|null): diag is TemplateDiagnostic =>\n-            diag !== null && diag.templateId === templateId);\n+      return diagnostics.filter(\n+          (diag: TemplateDiagnostic|null): diag is TemplateDiagnostic =>\n+              diag !== null && diag.templateId === templateId);\n+    });\n   }\n \n   getTypeCheckBlock(component: ts.ClassDeclaration): ts.Node|null {\n@@ -256,7 +262,8 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     if (engine === null) {\n       return null;\n     }\n-    return engine.getGlobalCompletions(context);\n+    return this.perf.inPhase(\n+        PerfPhase.TtcAutocompletion, () => engine.getGlobalCompletions(context));\n   }\n \n   getExpressionCompletionLocation(\n@@ -266,7 +273,8 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     if (engine === null) {\n       return null;\n     }\n-    return engine.getExpressionCompletionLocation(ast);\n+    return this.perf.inPhase(\n+        PerfPhase.TtcAutocompletion, () => engine.getExpressionCompletionLocation(ast));\n   }\n \n   invalidateClass(clazz: ts.ClassDeclaration): void {\n@@ -318,6 +326,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n       return;\n     }\n \n+    this.perf.eventCount(PerfEvent.ReuseTypeCheckFile);\n     this.state.set(sfPath, previousResults);\n   }\n \n@@ -326,50 +335,55 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n       return;\n     }\n \n-    const host = new WholeProgramTypeCheckingHost(this);\n-    const ctx = this.newContext(host);\n+    this.perf.inPhase(PerfPhase.TcbGeneration, () => {\n+      const host = new WholeProgramTypeCheckingHost(this);\n+      const ctx = this.newContext(host);\n \n-    for (const sf of this.originalProgram.getSourceFiles()) {\n-      if (sf.isDeclarationFile || isShim(sf)) {\n-        continue;\n-      }\n+      for (const sf of this.originalProgram.getSourceFiles()) {\n+        if (sf.isDeclarationFile || isShim(sf)) {\n+          continue;\n+        }\n \n-      this.maybeAdoptPriorResultsForFile(sf);\n+        this.maybeAdoptPriorResultsForFile(sf);\n \n-      const sfPath = absoluteFromSourceFile(sf);\n-      const fileData = this.getFileData(sfPath);\n-      if (fileData.isComplete) {\n-        continue;\n-      }\n+        const sfPath = absoluteFromSourceFile(sf);\n+        const fileData = this.getFileData(sfPath);\n+        if (fileData.isComplete) {\n+          continue;\n+        }\n \n-      this.typeCheckAdapter.typeCheck(sf, ctx);\n+        this.typeCheckAdapter.typeCheck(sf, ctx);\n \n-      fileData.isComplete = true;\n-    }\n+        fileData.isComplete = true;\n+      }\n \n-    this.updateFromContext(ctx);\n-    this.isComplete = true;\n+      this.updateFromContext(ctx);\n+      this.isComplete = true;\n+    });\n   }\n \n   private ensureAllShimsForOneFile(sf: ts.SourceFile): void {\n-    this.maybeAdoptPriorResultsForFile(sf);\n+    this.perf.inPhase(PerfPhase.TcbGeneration, () => {\n+      this.maybeAdoptPriorResultsForFile(sf);\n \n-    const sfPath = absoluteFromSourceFile(sf);\n+      const sfPath = absoluteFromSourceFile(sf);\n \n-    const fileData = this.getFileData(sfPath);\n-    if (fileData.isComplete) {\n-      // All data for this file is present and accounted for already.\n-      return;\n-    }\n+      const fileData = this.getFileData(sfPath);\n+      if (fileData.isComplete) {\n+        // All data for this file is present and accounted for already.\n+        return;\n+      }\n \n-    const host = new SingleFileTypeCheckingHost(sfPath, fileData, this.typeCheckingStrategy, this);\n-    const ctx = this.newContext(host);\n+      const host =\n+          new SingleFileTypeCheckingHost(sfPath, fileData, this.typeCheckingStrategy, this);\n+      const ctx = this.newContext(host);\n \n-    this.typeCheckAdapter.typeCheck(sf, ctx);\n+      this.typeCheckAdapter.typeCheck(sf, ctx);\n \n-    fileData.isComplete = true;\n+      fileData.isComplete = true;\n \n-    this.updateFromContext(ctx);\n+      this.updateFromContext(ctx);\n+    });\n   }\n \n   private ensureShimForComponent(component: ts.ClassDeclaration): void {\n@@ -399,7 +413,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n                                                                           InliningMode.Error;\n     return new TypeCheckContextImpl(\n         this.config, this.compilerHost, this.typeCheckingStrategy, this.refEmitter, this.reflector,\n-        host, inlining);\n+        host, inlining, this.perf);\n   }\n \n   /**\n@@ -428,8 +442,14 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n \n   private updateFromContext(ctx: TypeCheckContextImpl): void {\n     const updates = ctx.finalize();\n-    this.typeCheckingStrategy.updateFiles(updates, UpdateMode.Incremental);\n-    this.priorBuild.recordSuccessfulTypeCheck(this.state);\n+    return this.perf.inPhase(PerfPhase.TcbUpdateProgram, () => {\n+      if (updates.size > 0) {\n+        this.perf.eventCount(PerfEvent.UpdateTypeCheckProgram);\n+      }\n+      this.typeCheckingStrategy.updateFiles(updates, UpdateMode.Incremental);\n+      this.priorBuild.recordSuccessfulTypeCheck(this.state);\n+      this.perf.memory(PerfCheckpoint.TtcUpdateProgram);\n+    });\n   }\n \n   getFileData(path: AbsoluteFsPath): FileTypeCheckingData {\n@@ -450,7 +470,7 @@ export class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n     if (builder === null) {\n       return null;\n     }\n-    return builder.getSymbol(node);\n+    return this.perf.inPhase(PerfPhase.TtcSymbol, () => builder.getSymbol(node));\n   }\n \n   private getOrCreateSymbolBuilder(component: ts.ClassDeclaration): SymbolBuilder|null {"
        },
        {
            "sha": "b06bdcfce35fabeb6bb94e3592f4f1ebe34658d7",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/src/context.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Fsrc%2Fcontext.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -12,6 +12,7 @@ import * as ts from 'typescript';\n \n import {absoluteFromSourceFile, AbsoluteFsPath} from '../../file_system';\n import {NoopImportRewriter, Reference, ReferenceEmitter} from '../../imports';\n+import {PerfEvent, PerfRecorder} from '../../perf';\n import {ClassDeclaration, ReflectionHost} from '../../reflection';\n import {ImportManager} from '../../translator';\n import {ComponentToShimMappingStrategy, TemplateId, TemplateSourceMapping, TypeCheckableDirectiveMeta, TypeCheckBlockMetadata, TypeCheckContext, TypeCheckingConfig, TypeCtorMetadata} from '../api';\n@@ -179,7 +180,7 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n       private compilerHost: Pick<ts.CompilerHost, 'getCanonicalFileName'>,\n       private componentMappingStrategy: ComponentToShimMappingStrategy,\n       private refEmitter: ReferenceEmitter, private reflector: ReflectionHost,\n-      private host: TypeCheckingHost, private inlining: InliningMode) {\n+      private host: TypeCheckingHost, private inlining: InliningMode, private perf: PerfRecorder) {\n     if (inlining === InliningMode.Error && config.useInlineTypeConstructors) {\n       // We cannot use inlining for type checking since this environment does not support it.\n       throw new Error(`AssertionError: invalid inlining configuration.`);\n@@ -273,6 +274,7 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n       shimData.oobRecorder.requiresInlineTcb(templateId, ref.node);\n \n       // Checking this template would be unsupported, so don't try.\n+      this.perf.eventCount(PerfEvent.SkipGenerateTcbNoInline);\n       return;\n     }\n \n@@ -282,6 +284,7 @@ export class TypeCheckContextImpl implements TypeCheckContext {\n       pipes,\n       schemas,\n     };\n+    this.perf.eventCount(PerfEvent.GenerateTcb);\n     if (tcbRequiresInline) {\n       // This class didn't meet the requirements for external type checking, so generate an inline\n       // TCB for the class."
        },
        {
            "sha": "853ecffa1ae5736aedaa3ca8e5c0c8bb011cdefe",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2FBUILD.bazel?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -17,6 +17,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n         \"//packages/compiler-cli/src/ngtsc/incremental\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n+        \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"//packages/compiler-cli/src/ngtsc/scope\",\n         \"//packages/compiler-cli/src/ngtsc/shims\","
        },
        {
            "sha": "71dc6a073e337a81d3d571173da7e5c740c5563d",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/test_utils.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftest_utils.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -14,6 +14,7 @@ import {TestFile} from '../../file_system/testing';\n import {AbsoluteModuleStrategy, LocalIdentifierStrategy, LogicalProjectStrategy, ModuleResolver, Reexport, Reference, ReferenceEmitter, RelativePathStrategy} from '../../imports';\n import {NOOP_INCREMENTAL_BUILD} from '../../incremental';\n import {ClassPropertyMapping, CompoundMetadataReader} from '../../metadata';\n+import {NOOP_PERF_RECORDER} from '../../perf';\n import {ClassDeclaration, isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n import {ComponentScopeReader, LocalModuleScope, ScopeData, TypeCheckScopeRegistry} from '../../scope';\n import {makeProgram} from '../../testing';\n@@ -515,7 +516,7 @@ export function setup(targets: TypeCheckingTarget[], overrides: {\n \n   const templateTypeChecker = new TemplateTypeCheckerImpl(\n       program, programStrategy, checkAdapter, fullConfig, emitter, reflectionHost, host,\n-      NOOP_INCREMENTAL_BUILD, fakeScopeReader, typeCheckScopeRegistry);\n+      NOOP_INCREMENTAL_BUILD, fakeScopeReader, typeCheckScopeRegistry, NOOP_PERF_RECORDER);\n   return {\n     templateTypeChecker,\n     program,"
        },
        {
            "sha": "6cd0410e34840676968333fba0fb17f3b505f85a",
            "filename": "packages/compiler-cli/src/ngtsc/typecheck/test/type_constructor_spec.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_constructor_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_constructor_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Ftypecheck%2Ftest%2Ftype_constructor_spec.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -10,6 +10,7 @@ import * as ts from 'typescript';\n import {absoluteFrom, AbsoluteFsPath, getFileSystem, getSourceFileOrError, LogicalFileSystem, NgtscCompilerHost} from '../../file_system';\n import {runInEachFileSystem, TestFile} from '../../file_system/testing';\n import {AbsoluteModuleStrategy, LocalIdentifierStrategy, LogicalProjectStrategy, ModuleResolver, Reference, ReferenceEmitter} from '../../imports';\n+import {NOOP_PERF_RECORDER} from '../../perf';\n import {isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\n import {getDeclaration, makeProgram} from '../../testing';\n import {getRootDirs} from '../../util/src/typescript';\n@@ -74,7 +75,7 @@ TestClass.ngTypeCtor({value: 'test'});\n         ]);\n         const ctx = new TypeCheckContextImpl(\n             ALL_ENABLED_CONFIG, host, new TestMappingStrategy(), emitter, reflectionHost,\n-            new TestTypeCheckingHost(), InliningMode.InlineOps);\n+            new TestTypeCheckingHost(), InliningMode.InlineOps, NOOP_PERF_RECORDER);\n         const TestClass =\n             getDeclaration(program, _('/main.ts'), 'TestClass', isNamedClassDeclaration);\n         const pendingFile = makePendingFile();\n@@ -113,7 +114,7 @@ TestClass.ngTypeCtor({value: 'test'});\n         const pendingFile = makePendingFile();\n         const ctx = new TypeCheckContextImpl(\n             ALL_ENABLED_CONFIG, host, new TestMappingStrategy(), emitter, reflectionHost,\n-            new TestTypeCheckingHost(), InliningMode.InlineOps);\n+            new TestTypeCheckingHost(), InliningMode.InlineOps, NOOP_PERF_RECORDER);\n         const TestClass =\n             getDeclaration(program, _('/main.ts'), 'TestClass', isNamedClassDeclaration);\n         ctx.addInlineTypeCtor(\n@@ -158,7 +159,7 @@ TestClass.ngTypeCtor({value: 'test'});\n         const pendingFile = makePendingFile();\n         const ctx = new TypeCheckContextImpl(\n             ALL_ENABLED_CONFIG, host, new TestMappingStrategy(), emitter, reflectionHost,\n-            new TestTypeCheckingHost(), InliningMode.InlineOps);\n+            new TestTypeCheckingHost(), InliningMode.InlineOps, NOOP_PERF_RECORDER);\n         const TestClass =\n             getDeclaration(program, _('/main.ts'), 'TestClass', isNamedClassDeclaration);\n         ctx.addInlineTypeCtor("
        },
        {
            "sha": "314728e998c87cedbd75f60e12d236804fb7e288",
            "filename": "packages/language-service/ivy/BUILD.bazel",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Flanguage-service%2Fivy%2FBUILD.bazel",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Flanguage-service%2Fivy%2FBUILD.bazel",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2FBUILD.bazel?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -15,6 +15,7 @@ ts_library(\n         \"//packages/compiler-cli/src/ngtsc/imports\",\n         \"//packages/compiler-cli/src/ngtsc/incremental\",\n         \"//packages/compiler-cli/src/ngtsc/metadata\",\n+        \"//packages/compiler-cli/src/ngtsc/perf\",\n         \"//packages/compiler-cli/src/ngtsc/reflection\",\n         \"//packages/compiler-cli/src/ngtsc/shims\",\n         \"//packages/compiler-cli/src/ngtsc/typecheck\","
        },
        {
            "sha": "2c634d1026fc60dc3304f876775ac6661bfb6119",
            "filename": "packages/language-service/ivy/compiler_factory.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Flanguage-service%2Fivy%2Fcompiler_factory.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Flanguage-service%2Fivy%2Fcompiler_factory.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompiler_factory.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -9,6 +9,7 @@\n import {CompilationTicket, freshCompilationTicket, incrementalFromCompilerTicket, NgCompiler, resourceChangeTicket} from '@angular/compiler-cli/src/ngtsc/core';\n import {NgCompilerOptions} from '@angular/compiler-cli/src/ngtsc/core/api';\n import {TrackedIncrementalBuildStrategy} from '@angular/compiler-cli/src/ngtsc/incremental';\n+import {ActivePerfRecorder} from '@angular/compiler-cli/src/ngtsc/perf';\n import {TypeCheckingProgramStrategy} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import * as ts from 'typescript/lib/tsserverlibrary';\n \n@@ -44,6 +45,10 @@ export class CompilerFactory {\n         // Only resource files have changed since the last NgCompiler was created.\n         const ticket = resourceChangeTicket(this.compiler, modifiedResourceFiles);\n         this.compiler = NgCompiler.fromTicket(ticket, this.adapter);\n+      } else {\n+        // The previous NgCompiler is being reused, but we still want to reset its performance\n+        // tracker to capture only the operations that are needed to service the current request.\n+        this.compiler.perfRecorder.reset();\n       }\n \n       return this.compiler;\n@@ -52,11 +57,12 @@ export class CompilerFactory {\n     let ticket: CompilationTicket;\n     if (this.compiler === null || this.lastKnownProgram === null) {\n       ticket = freshCompilationTicket(\n-          program, this.options, this.incrementalStrategy, this.programStrategy, true, true);\n+          program, this.options, this.incrementalStrategy, this.programStrategy,\n+          /* perfRecorder */ null, true, true);\n     } else {\n       ticket = incrementalFromCompilerTicket(\n           this.compiler, program, this.incrementalStrategy, this.programStrategy,\n-          modifiedResourceFiles);\n+          modifiedResourceFiles, /* perfRecorder */ null);\n     }\n     this.compiler = NgCompiler.fromTicket(ticket, this.adapter);\n     this.lastKnownProgram = program;"
        },
        {
            "sha": "5881da4cd58104624249c821eb7d2d76fa539efc",
            "filename": "packages/language-service/ivy/references.ts",
            "status": "modified",
            "additions": 86,
            "deletions": 73,
            "changes": 159,
            "blob_url": "https://github.com/angular/angular/blob/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Flanguage-service%2Fivy%2Freferences.ts",
            "raw_url": "https://github.com/angular/angular/raw/48fec08c95f363c2906b2a2315e783793ccaedc5/packages%2Flanguage-service%2Fivy%2Freferences.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Freferences.ts?ref=48fec08c95f363c2906b2a2315e783793ccaedc5",
            "patch": "@@ -8,6 +8,7 @@\n import {AbsoluteSourceSpan, AST, BindingPipe, LiteralPrimitive, MethodCall, ParseSourceSpan, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstNode, TmplAstReference, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\n import {NgCompiler} from '@angular/compiler-cli/src/ngtsc/core';\n import {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\n+import {PerfPhase} from '@angular/compiler-cli/src/ngtsc/perf';\n import {DirectiveSymbol, ShimLocation, SymbolKind, TemplateTypeChecker, TypeCheckingProgramStrategy} from '@angular/compiler-cli/src/ngtsc/typecheck/api';\n import {ExpressionIdentifier, hasExpressionIdentifier} from '@angular/compiler-cli/src/ngtsc/typecheck/src/comments';\n import * as ts from 'typescript';\n@@ -66,46 +67,53 @@ export class ReferencesAndRenameBuilder {\n \n   getRenameInfo(filePath: string, position: number):\n       Omit<ts.RenameInfoSuccess, 'kind'|'kindModifiers'>|ts.RenameInfoFailure {\n-    const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);\n-    // We could not get a template at position so we assume the request came from outside the\n-    // template.\n-    if (templateInfo === undefined) {\n-      return this.tsLS.getRenameInfo(filePath, position);\n-    }\n+    return this.compiler.perfRecorder.inPhase(PerfPhase.LsReferencesAndRenames, () => {\n+      const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);\n+      // We could not get a template at position so we assume the request came from outside the\n+      // template.\n+      if (templateInfo === undefined) {\n+        return this.tsLS.getRenameInfo(filePath, position);\n+      }\n \n-    const allTargetDetails = this.getTargetDetailsAtTemplatePosition(templateInfo, position);\n-    if (allTargetDetails === null) {\n-      return {canRename: false, localizedErrorMessage: 'Could not find template node at position.'};\n-    }\n-    const {templateTarget} = allTargetDetails[0];\n-    const templateTextAndSpan = getRenameTextAndSpanAtPosition(templateTarget, position);\n-    if (templateTextAndSpan === null) {\n-      return {canRename: false, localizedErrorMessage: 'Could not determine template node text.'};\n-    }\n-    const {text, span} = templateTextAndSpan;\n-    return {\n-      canRename: true,\n-      displayName: text,\n-      fullDisplayName: text,\n-      triggerSpan: span,\n-    };\n+      const allTargetDetails = this.getTargetDetailsAtTemplatePosition(templateInfo, position);\n+      if (allTargetDetails === null) {\n+        return {\n+          canRename: false,\n+          localizedErrorMessage: 'Could not find template node at position.',\n+        };\n+      }\n+      const {templateTarget} = allTargetDetails[0];\n+      const templateTextAndSpan = getRenameTextAndSpanAtPosition(templateTarget, position);\n+      if (templateTextAndSpan === null) {\n+        return {canRename: false, localizedErrorMessage: 'Could not determine template node text.'};\n+      }\n+      const {text, span} = templateTextAndSpan;\n+      return {\n+        canRename: true,\n+        displayName: text,\n+        fullDisplayName: text,\n+        triggerSpan: span,\n+      };\n+    });\n   }\n \n   findRenameLocations(filePath: string, position: number): readonly ts.RenameLocation[]|undefined {\n     this.ttc.generateAllTypeCheckBlocks();\n-    const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);\n-    // We could not get a template at position so we assume the request came from outside the\n-    // template.\n-    if (templateInfo === undefined) {\n-      const requestNode = this.getTsNodeAtPosition(filePath, position);\n-      if (requestNode === null) {\n-        return undefined;\n+    return this.compiler.perfRecorder.inPhase(PerfPhase.LsReferencesAndRenames, () => {\n+      const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);\n+      // We could not get a template at position so we assume the request came from outside the\n+      // template.\n+      if (templateInfo === undefined) {\n+        const requestNode = this.getTsNodeAtPosition(filePath, position);\n+        if (requestNode === null) {\n+          return undefined;\n+        }\n+        const requestOrigin: TypeScriptRequest = {kind: RequestKind.TypeScript, requestNode};\n+        return this.findRenameLocationsAtTypescriptPosition(filePath, position, requestOrigin);\n       }\n-      const requestOrigin: TypeScriptRequest = {kind: RequestKind.TypeScript, requestNode};\n-      return this.findRenameLocationsAtTypescriptPosition(filePath, position, requestOrigin);\n-    }\n \n-    return this.findRenameLocationsAtTemplatePosition(templateInfo, position);\n+      return this.findRenameLocationsAtTemplatePosition(templateInfo, position);\n+    });\n   }\n \n   private findRenameLocationsAtTemplatePosition(templateInfo: TemplateInfo, position: number):\n@@ -148,55 +156,60 @@ export class ReferencesAndRenameBuilder {\n   findRenameLocationsAtTypescriptPosition(\n       filePath: string, position: number,\n       requestOrigin: RequestOrigin): readonly ts.RenameLocation[]|undefined {\n-    let originalNodeText: string;\n-    if (requestOrigin.kind === RequestKind.TypeScript) {\n-      originalNodeText = requestOrigin.requestNode.getText();\n-    } else {\n-      const templateNodeText =\n-          getRenameTextAndSpanAtPosition(requestOrigin.requestNode, requestOrigin.position);\n-      if (templateNodeText === null) {\n-        return undefined;\n+    return this.compiler.perfRecorder.inPhase(PerfPhase.LsReferencesAndRenames, () => {\n+      let originalNodeText: string;\n+      if (requestOrigin.kind === RequestKind.TypeScript) {\n+        originalNodeText = requestOrigin.requestNode.getText();\n+      } else {\n+        const templateNodeText =\n+            getRenameTextAndSpanAtPosition(requestOrigin.requestNode, requestOrigin.position);\n+        if (templateNodeText === null) {\n+          return undefined;\n+        }\n+        originalNodeText = templateNodeText.text;\n       }\n-      originalNodeText = templateNodeText.text;\n-    }\n \n-    const locations = this.tsLS.findRenameLocations(\n-        filePath, position, /*findInStrings*/ false, /*findInComments*/ false);\n-    if (locations === undefined) {\n-      return undefined;\n-    }\n+      const locations = this.tsLS.findRenameLocations(\n+          filePath, position, /*findInStrings*/ false, /*findInComments*/ false);\n+      if (locations === undefined) {\n+        return undefined;\n+      }\n \n-    const entries: Map<string, ts.RenameLocation> = new Map();\n-    for (const location of locations) {\n-      // TODO(atscott): Determine if a file is a shim file in a more robust way and make the API\n-      // available in an appropriate location.\n-      if (this.ttc.isTrackedTypeCheckFile(absoluteFrom(location.fileName))) {\n-        const entry = this.convertToTemplateDocumentSpan(location, this.ttc, originalNodeText);\n-        // There is no template node whose text matches the original rename request. Bail on\n-        // renaming completely rather than providing incomplete results.\n-        if (entry === null) {\n-          return undefined;\n-        }\n-        entries.set(createLocationKey(entry), entry);\n-      } else {\n-        // Ensure we only allow renaming a TS result with matching text\n-        const refNode = this.getTsNodeAtPosition(location.fileName, location.textSpan.start);\n-        if (refNode === null || refNode.getText() !== originalNodeText) {\n-          return undefined;\n+      const entries: Map<string, ts.RenameLocation> = new Map();\n+      for (const location of locations) {\n+        // TODO(atscott): Determine if a file is a shim file in a more robust way and make the API\n+        // available in an appropriate location.\n+        if (this.ttc.isTrackedTypeCheckFile(absoluteFrom(location.fileName))) {\n+          const entry = this.convertToTemplateDocumentSpan(location, this.ttc, originalNodeText);\n+          // There is no template node whose text matches the original rename request. Bail on\n+          // renaming completely rather than providing incomplete results.\n+          if (entry === null) {\n+            return undefined;\n+          }\n+          entries.set(createLocationKey(entry), entry);\n+        } else {\n+          // Ensure we only allow renaming a TS result with matching text\n+          const refNode = this.getTsNodeAtPosition(location.fileName, location.textSpan.start);\n+          if (refNode === null || refNode.getText() !== originalNodeText) {\n+            return undefined;\n+          }\n+          entries.set(createLocationKey(location), location);\n         }\n-        entries.set(createLocationKey(location), location);\n       }\n-    }\n-    return Array.from(entries.values());\n+      return Array.from(entries.values());\n+    });\n   }\n \n   getReferencesAtPosition(filePath: string, position: number): ts.ReferenceEntry[]|undefined {\n     this.ttc.generateAllTypeCheckBlocks();\n-    const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);\n-    if (templateInfo === undefined) {\n-      return this.getReferencesAtTypescriptPosition(filePath, position);\n-    }\n-    return this.getReferencesAtTemplatePosition(templateInfo, position);\n+\n+    return this.compiler.perfRecorder.inPhase(PerfPhase.LsReferencesAndRenames, () => {\n+      const templateInfo = getTemplateInfoAtPosition(filePath, position, this.compiler);\n+      if (templateInfo === undefined) {\n+        return this.getReferencesAtTypescriptPosition(filePath, position);\n+      }\n+      return this.getReferencesAtTemplatePosition(templateInfo, position);\n+    });\n   }\n \n   private getReferencesAtTemplatePosition(templateInfo: TemplateInfo, position: number):"
        }
    ],
    "stats": {
        "total": 1816,
        "additions": 1183,
        "deletions": 633
    }
}