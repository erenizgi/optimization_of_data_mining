{
    "author": "crisbeto",
    "message": "refactor(compiler): clean up i18n attribute generation logic (#39498)\n\nThis is follow-up from [an earlier discussion](https://github.com/angular/angular/pull/39408#discussion_r511908358).\nAfter some testing, it looks like the type of `Element.attributes` was correct in specifying that it\nonly has `TextAttribute` instances. This means that the extra checks that filter out `BoundAttribute`\ninstances from the array isn't necessary. There is another loop a bit further down that actually\nextracts the bound i18n attributes.\n\nPR Close #39498",
    "sha": "fe343d8d96a727c7f48f7951a630ef008a9e0b9f",
    "files": [
        {
            "sha": "3c0360cffeb99641977ad16cfa2c45704797c34d",
            "filename": "packages/compiler/src/render3/view/i18n/util.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/fe343d8d96a727c7f48f7951a630ef008a9e0b9f/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Futil.ts",
            "raw_url": "https://github.com/angular/angular/raw/fe343d8d96a727c7f48f7951a630ef008a9e0b9f/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Futil.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Fi18n%2Futil.ts?ref=fe343d8d96a727c7f48f7951a630ef008a9e0b9f",
            "patch": "@@ -50,11 +50,6 @@ export function hasI18nMeta(node: t.Node&{i18n?: i18n.I18nMeta}): boolean {\n   return !!node.i18n;\n }\n \n-export function isBoundI18nAttribute(node: t.TextAttribute|\n-                                     t.BoundAttribute): node is t.BoundAttribute {\n-  return node.i18n !== undefined && node instanceof t.BoundAttribute;\n-}\n-\n export function hasI18nAttrs(element: html.Element): boolean {\n   return element.attrs.some((attr: html.Attribute) => isI18nAttribute(attr.name));\n }"
        },
        {
            "sha": "4fc8c24bb9b67263ff191237cd478fb16f7c5eee",
            "filename": "packages/compiler/src/render3/view/template.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 16,
            "changes": 24,
            "blob_url": "https://github.com/angular/angular/blob/fe343d8d96a727c7f48f7951a630ef008a9e0b9f/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "raw_url": "https://github.com/angular/angular/raw/fe343d8d96a727c7f48f7951a630ef008a9e0b9f/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Frender3%2Fview%2Ftemplate.ts?ref=fe343d8d96a727c7f48f7951a630ef008a9e0b9f",
            "patch": "@@ -36,7 +36,7 @@ import {I18nContext} from './i18n/context';\n import {createGoogleGetMsgStatements} from './i18n/get_msg_utils';\n import {createLocalizeStatements} from './i18n/localize_utils';\n import {I18nMetaVisitor} from './i18n/meta';\n-import {assembleBoundTextPlaceholders, assembleI18nBoundString, declareI18nVariable, getTranslationConstPrefix, hasI18nMeta, I18N_ICU_MAPPING_PREFIX, i18nFormatPlaceholderNames, icuFromI18nMessage, isBoundI18nAttribute, isI18nRootNode, isSingleI18nIcu, placeholdersToParams, TRANSLATION_VAR_PREFIX, wrapI18nPlaceholder} from './i18n/util';\n+import {assembleBoundTextPlaceholders, assembleI18nBoundString, declareI18nVariable, getTranslationConstPrefix, hasI18nMeta, I18N_ICU_MAPPING_PREFIX, i18nFormatPlaceholderNames, icuFromI18nMessage, isI18nRootNode, isSingleI18nIcu, placeholdersToParams, TRANSLATION_VAR_PREFIX, wrapI18nPlaceholder} from './i18n/util';\n import {StylingBuilder, StylingInstruction} from './styling_builder';\n import {asLiteral, chainedInstruction, CONTEXT_NAME, getAttrsForDirectiveMatching, getInterpolationArgsLength, IMPLICIT_REFERENCE, invalid, NON_BINDABLE_ATTR, REFERENCE_PREFIX, RENDER_FLAGS, trimTrailingNulls, unsupported} from './util';\n \n@@ -586,9 +586,7 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n     const isI18nRootElement: boolean =\n         isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);\n \n-    const boundI18nAttrs: t.BoundAttribute[] = [];\n     const outputAttrs: t.TextAttribute[] = [];\n-\n     const [namespaceKey, elementName] = splitNsName(element.name);\n     const isNgContainer = checkIsNgContainer(element.name);\n \n@@ -601,10 +599,6 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n         stylingBuilder.registerStyleAttr(value);\n       } else if (name === 'class') {\n         stylingBuilder.registerClassAttr(value);\n-      } else if (isBoundI18nAttribute(attr)) {\n-        // Note that we don't collect static i18n attributes here, because\n-        // they can be treated in the same way as regular attributes.\n-        boundI18nAttrs.push(attr);\n       } else {\n         outputAttrs.push(attr);\n       }\n@@ -621,8 +615,9 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n \n     // Add the attributes\n     const allOtherInputs: t.BoundAttribute[] = [];\n+    const boundI18nAttrs: t.BoundAttribute[] = [];\n \n-    element.inputs.forEach((input: t.BoundAttribute) => {\n+    element.inputs.forEach(input => {\n       const stylingInputWasSet = stylingBuilder.registerBoundInput(input);\n       if (!stylingInputWasSet) {\n         if (input.type === BindingType.Property && input.i18n) {\n@@ -720,7 +715,7 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n     const attributeBindings: ChainableBindingInstruction[] = [];\n \n     // Generate element input bindings\n-    allOtherInputs.forEach((input: t.BoundAttribute) => {\n+    allOtherInputs.forEach(input => {\n       const inputType = input.type;\n       if (inputType === BindingType.Animation) {\n         const value = input.value.visit(this._valueConverter);\n@@ -866,11 +861,9 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n     this.matchDirectives(NG_TEMPLATE_TAG_NAME, template);\n \n     // prepare attributes parameter (including attributes used for directive matching)\n-    const [boundI18nAttrs, attrs] = partitionArray<t.BoundAttribute, t.TextAttribute>(\n-        template.attributes, isBoundI18nAttribute);\n     const attrsExprs: o.Expression[] = this.getAttributeExpressions(\n-        NG_TEMPLATE_TAG_NAME, attrs, template.inputs, template.outputs, undefined /* styles */,\n-        template.templateAttrs, boundI18nAttrs);\n+        NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs,\n+        undefined /* styles */, template.templateAttrs);\n     parameters.push(this.addAttrsToConsts(attrsExprs));\n \n     // local refs (ex.: <ng-template #foo>)\n@@ -916,15 +909,14 @@ export class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver\n     if (template.tagName === NG_TEMPLATE_TAG_NAME) {\n       const [i18nInputs, inputs] =\n           partitionArray<t.BoundAttribute, t.BoundAttribute>(template.inputs, hasI18nMeta);\n-      const i18nAttrs = [...boundI18nAttrs, ...i18nInputs];\n \n       // Add i18n attributes that may act as inputs to directives. If such attributes are present,\n       // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>\n       // elements, in case of inline templates, corresponding instructions will be generated in the\n       // nested template function.\n-      if (i18nAttrs.length > 0) {\n+      if (i18nInputs.length > 0) {\n         this.i18nAttributesInstruction(\n-            templateIndex, i18nAttrs, template.startSourceSpan ?? template.sourceSpan);\n+            templateIndex, i18nInputs, template.startSourceSpan ?? template.sourceSpan);\n       }\n \n       // Add the input bindings"
        }
    ],
    "stats": {
        "total": 29,
        "additions": 8,
        "deletions": 21
    }
}