{
    "author": "mhevery",
    "message": "refactor(core): extract `icuSwitchCase`, `icuUpdateCase`, `removeNestedIcu` (#38154)\n\nExtract `icuSwitchCase`, `icuUpdateCase`, `removeNestedIcu` into\nseparate functions to align them with the `.debug` property text.\n\nPR Close #38154",
    "sha": "26be5b4994db2f561c8907a3719913891bd5996a",
    "files": [
        {
            "sha": "ab8e7b4dfc7e2f4677196ff587b96a51604d8237",
            "filename": "packages/core/src/render3/i18n.ts",
            "status": "modified",
            "additions": 73,
            "deletions": 55,
            "changes": 128,
            "blob_url": "https://github.com/angular/angular/blob/26be5b4994db2f561c8907a3719913891bd5996a/packages%2Fcore%2Fsrc%2Frender3%2Fi18n.ts",
            "raw_url": "https://github.com/angular/angular/raw/26be5b4994db2f561c8907a3719913891bd5996a/packages%2Fcore%2Fsrc%2Frender3%2Fi18n.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n.ts?ref=26be5b4994db2f561c8907a3719913891bd5996a",
            "patch": "@@ -758,6 +758,7 @@ function createDynamicNodeAtIndex(\n   const previousOrParentTNode = getPreviousOrParentTNode();\n   ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);\n   lView[index + HEADER_OFFSET] = native;\n+  // FIXME(misko): Why does this create A TNode??? I would not expect this to be here.\n   const tNode = getOrCreateTNode(tView, lView[T_HOST], index, type as any, name, null);\n \n   // We are creating a dynamic node, the previous tNode might not be pointing at this node.\n@@ -882,7 +883,7 @@ function readCreateOpCodes(\n \n function readUpdateOpCodes(\n     updateOpCodes: I18nUpdateOpCodes, icus: TIcu[]|null, bindingsStartIndex: number,\n-    changeMask: number, tView: TView, lView: LView, bypassCheckBit = false) {\n+    changeMask: number, tView: TView, lView: LView, bypassCheckBit: boolean) {\n   let caseCreated = false;\n   for (let i = 0; i < updateOpCodes.length; i++) {\n     // bit code to check if we should apply the next update\n@@ -898,12 +899,10 @@ function readUpdateOpCodes(\n           value += opCode;\n         } else if (typeof opCode == 'number') {\n           if (opCode < 0) {\n+            // Negative opCode represent `i18nExp` values offset.\n             value += renderStringify(lView[bindingsStartIndex - opCode]);\n           } else {\n             const nodeIndex = opCode >>> I18nUpdateOpCode.SHIFT_REF;\n-            let tIcuIndex: number;\n-            let tIcu: TIcu;\n-            let icuTNode: TIcuContainerNode;\n             switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n               case I18nUpdateOpCode.Attr:\n                 const propName = updateOpCodes[++j] as string;\n@@ -916,58 +915,13 @@ function readUpdateOpCodes(\n                 textBindingInternal(lView, nodeIndex, value);\n                 break;\n               case I18nUpdateOpCode.IcuSwitch:\n-                // FIXME(misko): Pull to a new function `icuSwitchCase`\n-                tIcuIndex = updateOpCodes[++j] as number;\n-                tIcu = icus![tIcuIndex];\n-                icuTNode = getTNode(tView, nodeIndex) as TIcuContainerNode;\n-                // If there is an active case, delete the old nodes\n-                if (icuTNode.activeCaseIndex !== null) {\n-                  const removeCodes = tIcu.remove[icuTNode.activeCaseIndex];\n-                  for (let k = 0; k < removeCodes.length; k++) {\n-                    const removeOpCode = removeCodes[k] as number;\n-                    switch (removeOpCode & I18nMutateOpCode.MASK_INSTRUCTION) {\n-                      case I18nMutateOpCode.Remove:\n-                        const nodeIndex = removeOpCode >>> I18nMutateOpCode.SHIFT_REF;\n-                        // Remove DOM element, but do *not* mark TNode as detached, since we are\n-                        // just switching ICU cases (while keeping the same TNode), so a DOM element\n-                        // representing a new ICU case will be re-created.\n-                        removeNode(tView, lView, nodeIndex, /* markAsDetached */ false);\n-                        break;\n-                      case I18nMutateOpCode.RemoveNestedIcu:\n-                        const nestedIcuNodeIndex =\n-                            removeCodes[k + 1] as number >>> I18nMutateOpCode.SHIFT_REF;\n-                        const nestedIcuTNode =\n-                            getTNode(tView, nestedIcuNodeIndex) as TIcuContainerNode;\n-                        const activeIndex = nestedIcuTNode.activeCaseIndex;\n-                        if (activeIndex !== null) {\n-                          const nestedIcuTIndex = removeOpCode >>> I18nMutateOpCode.SHIFT_REF;\n-                          const nestedTIcu = icus![nestedIcuTIndex];\n-                          addAllToArray(nestedTIcu.remove[activeIndex], removeCodes);\n-                        }\n-                        break;\n-                    }\n-                  }\n-                }\n-\n-                // Update the active caseIndex\n-                const caseIndex = getCaseIndex(tIcu, value);\n-                icuTNode.activeCaseIndex = caseIndex !== -1 ? caseIndex : null;\n-                if (caseIndex > -1) {\n-                  // Add the nodes for the new case\n-                  readCreateOpCodes(-1, tIcu.create[caseIndex], tView, lView);\n-                  caseCreated = true;\n-                }\n+                caseCreated = icuSwitchCase(\n+                    tView, updateOpCodes[++j] as number, nodeIndex, icus!, lView, value);\n                 break;\n               case I18nUpdateOpCode.IcuUpdate:\n-                // FIXME(misko): Pull to a new function `icuUpdateCase`\n-                tIcuIndex = updateOpCodes[++j] as number;\n-                tIcu = icus![tIcuIndex];\n-                icuTNode = getTNode(tView, nodeIndex) as TIcuContainerNode;\n-                if (icuTNode.activeCaseIndex !== null) {\n-                  readUpdateOpCodes(\n-                      tIcu.update[icuTNode.activeCaseIndex], icus, bindingsStartIndex, changeMask,\n-                      tView, lView, caseCreated);\n-                }\n+                icuUpdateCase(\n+                    tView, lView, updateOpCodes[++j] as number, nodeIndex, bindingsStartIndex,\n+                    icus!, caseCreated);\n                 break;\n             }\n           }\n@@ -978,6 +932,70 @@ function readUpdateOpCodes(\n   }\n }\n \n+function icuUpdateCase(\n+    tView: TView, lView: LView, tIcuIndex: number, nodeIndex: number, bindingsStartIndex: number,\n+    tIcus: TIcu[], caseCreated: boolean) {\n+  const tIcu = tIcus[tIcuIndex];\n+  const icuTNode = getTNode(tView, nodeIndex) as TIcuContainerNode;\n+  if (icuTNode.activeCaseIndex !== null) {\n+    readUpdateOpCodes(\n+        tIcu.update[icuTNode.activeCaseIndex], tIcus, bindingsStartIndex, changeMask, tView, lView,\n+        caseCreated);\n+  }\n+}\n+\n+function icuSwitchCase(\n+    tView: TView, tIcuIndex: number, nodeIndex: number, tIcus: TIcu[], lView: LView,\n+    value: string): boolean {\n+  const tIcu = tIcus[tIcuIndex];\n+  const icuTNode = getTNode(tView, nodeIndex) as TIcuContainerNode;\n+  let caseCreated = false;\n+  // If there is an active case, delete the old nodes\n+  if (icuTNode.activeCaseIndex !== null) {\n+    const removeCodes = tIcu.remove[icuTNode.activeCaseIndex];\n+    for (let k = 0; k < removeCodes.length; k++) {\n+      const removeOpCode = removeCodes[k] as number;\n+      const nodeOrIcuIndex = removeOpCode >>> I18nMutateOpCode.SHIFT_REF;\n+      switch (removeOpCode & I18nMutateOpCode.MASK_INSTRUCTION) {\n+        case I18nMutateOpCode.Remove:\n+          // Remove DOM element, but do *not* mark TNode as detached, since we are\n+          // just switching ICU cases (while keeping the same TNode), so a DOM element\n+          // representing a new ICU case will be re-created.\n+          removeNode(tView, lView, nodeOrIcuIndex, /* markAsDetached */ false);\n+          break;\n+        case I18nMutateOpCode.RemoveNestedIcu:\n+          removeNestedIcu(\n+              tView, tIcus, removeCodes, nodeOrIcuIndex,\n+              removeCodes[k + 1] as number >>> I18nMutateOpCode.SHIFT_REF);\n+          break;\n+      }\n+    }\n+  }\n+\n+  // Update the active caseIndex\n+  const caseIndex = getCaseIndex(tIcu, value);\n+  icuTNode.activeCaseIndex = caseIndex !== -1 ? caseIndex : null;\n+  if (caseIndex > -1) {\n+    // Add the nodes for the new case\n+    readCreateOpCodes(\n+        -1 /* -1 means we don't have parent node */, tIcu.create[caseIndex], tView, lView);\n+    caseCreated = true;\n+  }\n+  return caseCreated;\n+}\n+\n+function removeNestedIcu(\n+    tView: TView, tIcus: TIcu[], removeCodes: I18nMutateOpCodes, nodeIndex: number,\n+    nestedIcuNodeIndex: number) {\n+  const nestedIcuTNode = getTNode(tView, nestedIcuNodeIndex) as TIcuContainerNode;\n+  const activeIndex = nestedIcuTNode.activeCaseIndex;\n+  if (activeIndex !== null) {\n+    const nestedTIcu = tIcus[nodeIndex];\n+    // FIXME(misko): the fact that we are adding items to parent list looks very suspect!\n+    addAllToArray(nestedTIcu.remove[activeIndex], removeCodes);\n+  }\n+}\n+\n function removeNode(tView: TView, lView: LView, index: number, markAsDetached: boolean) {\n   const removedPhTNode = getTNode(tView, index);\n   const removedPhRNode = getNativeByIndex(index, lView);\n@@ -1146,7 +1164,7 @@ export function ɵɵi18nApply(index: number) {\n     }\n     const bindingsStartIndex = getBindingIndex() - shiftsCounter - 1;\n     const lView = getLView();\n-    readUpdateOpCodes(updateOpCodes, icus, bindingsStartIndex, changeMask, tView, lView);\n+    readUpdateOpCodes(updateOpCodes, icus, bindingsStartIndex, changeMask, tView, lView, false);\n \n     // Reset changeMask & maskBit to default for the next update cycle\n     changeMask = 0b0;"
        },
        {
            "sha": "930f810428fcce9c0c613050c8b7c1529b212fa1",
            "filename": "packages/core/src/render3/i18n_debug.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/angular/angular/blob/26be5b4994db2f561c8907a3719913891bd5996a/packages%2Fcore%2Fsrc%2Frender3%2Fi18n_debug.ts",
            "raw_url": "https://github.com/angular/angular/raw/26be5b4994db2f561c8907a3719913891bd5996a/packages%2Fcore%2Fsrc%2Frender3%2Fi18n_debug.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcore%2Fsrc%2Frender3%2Fi18n_debug.ts?ref=26be5b4994db2f561c8907a3719913891bd5996a",
            "patch": "@@ -102,7 +102,6 @@ export function i18nMutateOpCodesToString(\n       case I18nMutateOpCode.ElementEnd:\n         return `setPreviousOrParentTNode(tView.data[${ref}] as TNode)`;\n       case I18nMutateOpCode.RemoveNestedIcu:\n-        // FIXME(misko): refactor to have a real method in i18n.ts.\n         return `removeNestedICU(${ref})`;\n     }\n     throw new Error('Unexpected OpCode');"
        }
    ],
    "stats": {
        "total": 129,
        "additions": 73,
        "deletions": 56
    }
}