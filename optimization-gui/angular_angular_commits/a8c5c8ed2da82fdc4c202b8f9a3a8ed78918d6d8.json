{
    "author": "alxhub",
    "message": "fix(language-service): recognize incomplete pipe bindings with whitespace (#40346)\n\nThe Language Service uses the source span of AST nodes to recognize which\nnode a user has selected, given their cursor position in a template. This is\nused to trigger autocompletion.\n\nThe previous source span of BindingPipe nodes created a problem when:\n\n1) the pipe binding had no identifier (incomplete or in-progress expression)\n2) the user typed trailing whitespace after the pipe character ('|')\n\nFor example, the expression `{{foo | }}`. If the cursor preceded the '}' in\nthat expression, the Language Service was unable to detect that the user was\nautocompleting the BindingPipe expression, since the span of the BindingPipe\nended after the '|'.\n\nThis commit changes the expression parser to expand the span of BindingPipe\nexpressions with a missing identifier, to include any trailing whitespace.\nThis allows the Language Service to correctly recognize this case as\ntargeting the BindingPipe and complete it successfully. The `nameSpan` of\nthe BindingPipe is also moved to be right-aligned with the end of any\nwhitespace present in the pipe binding expression.\n\nThis change allows for the disabled test in the Language Service for pipe\ncompletion in this case to be re-enabled.\n\nPR Close #40346",
    "sha": "a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8",
    "files": [
        {
            "sha": "df6b60ec100c54fadf4729c6f4315a2b7ef49ff9",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 50,
            "deletions": 12,
            "changes": 62,
            "blob_url": "https://github.com/angular/angular/blob/a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8",
            "patch": "@@ -450,14 +450,27 @@ export class _ParseAST {\n     return this.absoluteOffset + this.inputIndex;\n   }\n \n-  span(start: number) {\n-    return new ParseSpan(start, this.currentEndIndex);\n+  /**\n+   * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\n+   * provided).\n+   *\n+   * @param start Position from which the `ParseSpan` will start.\n+   * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\n+   *     natural ending index)\n+   */\n+  span(start: number, artificialEndIndex?: number): ParseSpan {\n+    let endIndex = this.currentEndIndex;\n+    if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n+      endIndex = artificialEndIndex;\n+    }\n+    return new ParseSpan(start, endIndex);\n   }\n \n-  sourceSpan(start: number): AbsoluteSourceSpan {\n-    const serial = `${start}@${this.inputIndex}`;\n+  sourceSpan(start: number, artificialEndIndex?: number): AbsoluteSourceSpan {\n+    const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n     if (!this.sourceSpanCache.has(serial)) {\n-      this.sourceSpanCache.set(serial, this.span(start).toAbsolute(this.absoluteOffset));\n+      this.sourceSpanCache.set(\n+          serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n     }\n     return this.sourceSpanCache.get(serial)!;\n   }\n@@ -521,11 +534,11 @@ export class _ParseAST {\n     return tok === EOF ? 'end of input' : `token ${tok}`;\n   }\n \n-  expectIdentifierOrKeyword(): string {\n+  expectIdentifierOrKeyword(): string|null {\n     const n = this.next;\n     if (!n.isIdentifier() && !n.isKeyword()) {\n       this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n-      return '';\n+      return null;\n     }\n     this.advance();\n     return n.toString() as string;\n@@ -572,15 +585,40 @@ export class _ParseAST {\n \n       do {\n         const nameStart = this.inputIndex;\n-        const name = this.expectIdentifierOrKeyword();\n-        const nameSpan = this.sourceSpan(nameStart);\n+        let nameId = this.expectIdentifierOrKeyword();\n+        let nameSpan: AbsoluteSourceSpan;\n+        let fullSpanEnd: number|undefined = undefined;\n+        if (nameId !== null) {\n+          nameSpan = this.sourceSpan(nameStart);\n+        } else {\n+          // No valid identifier was found, so we'll assume an empty pipe name ('').\n+          nameId = '';\n+\n+          // However, there may have been whitespace present between the pipe character and the next\n+          // token in the sequence (or the end of input). We want to track this whitespace so that\n+          // the `BindingPipe` we produce covers not just the pipe character, but any trailing\n+          // whitespace beyond it. Another way of thinking about this is that the zero-length name\n+          // is assumed to be at the end of any whitespace beyond the pipe character.\n+          //\n+          // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n+          // beginning of the next token, or until the end of input if the next token is EOF.\n+          fullSpanEnd = this.next.index !== -1 ? this.next.index : this.inputLength + this.offset;\n+\n+          // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n+          // beyond the pipe character.\n+          nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n+        }\n+\n         const args: AST[] = [];\n         while (this.consumeOptionalCharacter(chars.$COLON)) {\n           args.push(this.parseExpression());\n+\n+          // If there are additional expressions beyond the name, then the artificial end for the\n+          // name is no longer relevant.\n         }\n         const {start} = result.span;\n-        result =\n-            new BindingPipe(this.span(start), this.sourceSpan(start), result, name, args, nameSpan);\n+        result = new BindingPipe(\n+            this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);\n       } while (this.consumeOptionalOperator('|'));\n     }\n \n@@ -881,7 +919,7 @@ export class _ParseAST {\n     const start = receiver.span.start;\n     const nameStart = this.inputIndex;\n     const id = this.withContext(ParseContextFlags.Writable, () => {\n-      const id = this.expectIdentifierOrKeyword();\n+      const id = this.expectIdentifierOrKeyword() ?? '';\n       if (id.length === 0) {\n         this.error(`Expected identifier for property access`, receiver.span.end);\n       }"
        },
        {
            "sha": "4130961cbc99fc049db5d2a23d2b4ad10ad73bc8",
            "filename": "packages/compiler/test/expression_parser/parser_spec.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 1,
            "changes": 17,
            "blob_url": "https://github.com/angular/angular/blob/a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts?ref=a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {ASTWithSource, BindingPipe, Interpolation, ParserError, TemplateBinding, VariableBinding} from '@angular/compiler/src/expression_parser/ast';\n+import {AbsoluteSourceSpan, ASTWithSource, BindingPipe, Interpolation, ParserError, TemplateBinding, VariableBinding} from '@angular/compiler/src/expression_parser/ast';\n import {Lexer} from '@angular/compiler/src/expression_parser/lexer';\n import {IvyParser, Parser, SplitInterpolation} from '@angular/compiler/src/expression_parser/parser';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n@@ -447,6 +447,17 @@ describe('parser', () => {\n             expectBindingError(input, err);\n           });\n         }\n+\n+        it('should parse an incomplete pipe with a source span that includes trailing whitespace',\n+           () => {\n+             const bindingText = 'foo | ';\n+             const binding = parseBinding(bindingText).ast as BindingPipe;\n+\n+             // The sourceSpan should include all characters of the input.\n+             expect(rawSpan(binding.sourceSpan)).toEqual([0, bindingText.length]);\n+             // The nameSpan should be positioned at the end of the input.\n+             expect(rawSpan(binding.nameSpan)).toEqual([bindingText.length, bindingText.length]);\n+           });\n       });\n \n       it('should only allow identifier or keyword as formatter names', () => {\n@@ -1180,3 +1191,7 @@ function checkActionWithError(text: string, expected: string, error: string) {\n   checkAction(text, expected);\n   expectActionError(text, error);\n }\n+\n+function rawSpan(span: AbsoluteSourceSpan): [number, number] {\n+  return [span.start, span.end];\n+}"
        },
        {
            "sha": "be61b17aef250a28f6c872df3050fdaae0b29563",
            "filename": "packages/language-service/ivy/test/completions_spec.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 8,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Fcompletions_spec.ts?ref=a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8",
            "patch": "@@ -569,18 +569,13 @@ describe('completions', () => {\n       expectReplacementText(completions, text, 'some');\n     });\n \n-    // TODO(alxhub): currently disabled as the template targeting system identifies the cursor\n-    // position as the entire Interpolation node, not the BindingPipe node. This happens because the\n-    // BindingPipe node's span ends at the '|' character. To make this case work, the targeting\n-    // system will need to artificially expand the BindingPipe's span to encompass any trailing\n-    // spaces, which will be done in a future PR.\n-    xit('should complete an empty pipe binding', () => {\n-      const {ngLS, fileName, cursor, text} = setup(`{{ foo | ¦ }}`, '', SOME_PIPE);\n+    it('should complete an empty pipe binding', () => {\n+      const {ngLS, fileName, cursor, text} = setup(`{{foo | ¦}}`, '', SOME_PIPE);\n       const completions = ngLS.getCompletionsAtPosition(fileName, cursor, /* options */ undefined);\n       expectContain(\n           completions, unsafeCastDisplayInfoKindToScriptElementKind(DisplayInfoKind.PIPE),\n           ['somePipe']);\n-      expectReplacementText(completions, text, 'some');\n+      expectReplacementText(completions, text, '');\n     });\n \n     it('should not return extraneous completions', () => {"
        },
        {
            "sha": "87eed427c18da7f8e0324c34200c2d0679fe5b38",
            "filename": "packages/language-service/ivy/test/legacy/template_target_spec.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/angular/angular/blob/a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Ftest%2Flegacy%2Ftemplate_target_spec.ts?ref=a8c5c8ed2da82fdc4c202b8f9a3a8ed78918d6d8",
            "patch": "@@ -497,8 +497,7 @@ describe('getTargetAtPosition for expression AST', () => {\n     const {context} = getTargetAtPosition(nodes, position)!;\n     const {node} = context as SingleNodeTarget;\n     expect(isExpressionNode(node!)).toBe(true);\n-    // TODO: We want this to be a BindingPipe.\n-    expect(node).toBeInstanceOf(e.Interpolation);\n+    expect(node).toBeInstanceOf(e.BindingPipe);\n   });\n \n   it('should locate binding pipe without identifier',"
        }
    ],
    "stats": {
        "total": 93,
        "additions": 70,
        "deletions": 23
    }
}