{
    "author": "petebacondarwin",
    "message": "fix(compiler-cli): handle pseudo cycles in inline source-maps (#40435)\n\nWhen a source-map has an inline source, any source-map linked from\nthat source should only be loaded if itself is also inline; it should not\nattempt to load a source-map from the file-system. Otherwise we can\nfind ourselves with inadvertent infinite cyclic dependencies.\n\nFor example, if a transpiler takes a file (e.g. index.js) and generates\na new file overwriting the original file - capturing the original\nsource inline in the new source-map (index.js.map) - the source\nfile loader might read the inline original file (also index.js) and\nthen try to load the `index.js.map` file from disk - ad infinitum.\n\nNote that the first call to `loadSourceFile()` is special, since you can\npass in the source-file and source-map contents directly as in-memory\nstrrngs. This is common if the transpiler has just generated these and has\nnot yet written them to disk.\nWhen the contents are passed into `loadSourceFile()` directly, they are\nnot treated as \"inline\" for the purposes described above since there is\nno chance of these \"in-memory\" source and source-map contents being caught\nup in a cyclic dependency.\n\nFixes #40408\n\nPR Close #40435",
    "sha": "dc06873c72dde8da2f8acacfb485e25e3fc84f31",
    "files": [
        {
            "sha": "5091ac5ae391bff0920e4dc70ca3d9bf06e939b9",
            "filename": "packages/compiler-cli/ngcc/src/rendering/source_maps.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 19,
            "changes": 38,
            "blob_url": "https://github.com/angular/angular/blob/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fsource_maps.ts",
            "raw_url": "https://github.com/angular/angular/raw/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fsource_maps.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fngcc%2Fsrc%2Frendering%2Fsource_maps.ts?ref=dc06873c72dde8da2f8acacfb485e25e3fc84f31",
            "patch": "@@ -11,7 +11,7 @@ import * as ts from 'typescript';\n \n import {absoluteFrom, absoluteFromSourceFile, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\n import {Logger} from '../../../src/ngtsc/logging';\n-import {RawSourceMap, SourceFileLoader} from '../../../src/ngtsc/sourcemaps';\n+import {ContentOrigin, RawSourceMap, SourceFileLoader} from '../../../src/ngtsc/sourcemaps';\n \n import {FileToWrite} from './utils';\n \n@@ -28,22 +28,22 @@ export interface SourceMapInfo {\n export function renderSourceAndMap(\n     logger: Logger, fs: ReadonlyFileSystem, sourceFile: ts.SourceFile,\n     generatedMagicString: MagicString): FileToWrite[] {\n-  const generatedPath = absoluteFromSourceFile(sourceFile);\n-  const generatedMapPath = absoluteFrom(`${generatedPath}.map`);\n+  const sourceFilePath = absoluteFromSourceFile(sourceFile);\n+  const sourceMapPath = absoluteFrom(`${sourceFilePath}.map`);\n   const generatedContent = generatedMagicString.toString();\n   const generatedMap: RawSourceMap = generatedMagicString.generateMap(\n-      {file: generatedPath, source: generatedPath, includeContent: true});\n+      {file: sourceFilePath, source: sourceFilePath, includeContent: true});\n \n   try {\n     const loader = new SourceFileLoader(fs, logger, {});\n     const generatedFile = loader.loadSourceFile(\n-        generatedPath, generatedContent, {map: generatedMap, mapPath: generatedMapPath});\n+        sourceFilePath, generatedContent, {map: generatedMap, mapPath: sourceMapPath});\n \n     const rawMergedMap: RawSourceMap = generatedFile.renderFlattenedSourceMap();\n     const mergedMap = fromObject(rawMergedMap);\n-    const firstSource = generatedFile.sources[0];\n-    if (firstSource && (firstSource.rawMap !== null || !sourceFile.isDeclarationFile) &&\n-        firstSource.inline) {\n+    const originalFile = loader.loadSourceFile(sourceFilePath, generatedMagicString.original);\n+    if (originalFile.rawMap === null && !sourceFile.isDeclarationFile ||\n+        originalFile.rawMap?.origin === ContentOrigin.Inline) {\n       // We render an inline source map if one of:\n       // * there was no input source map and this is not a typings file;\n       // * the input source map exists and was inline.\n@@ -52,21 +52,21 @@ export function renderSourceAndMap(\n       // the input file because these inline source maps can be very large and it impacts on the\n       // performance of IDEs that need to read them to provide intellisense etc.\n       return [\n-        {path: generatedPath, contents: `${generatedFile.contents}\\n${mergedMap.toComment()}`}\n-      ];\n-    } else {\n-      const sourceMapComment = generateMapFileComment(`${fs.basename(generatedPath)}.map`);\n-      return [\n-        {path: generatedPath, contents: `${generatedFile.contents}\\n${sourceMapComment}`},\n-        {path: generatedMapPath, contents: mergedMap.toJSON()}\n+        {path: sourceFilePath, contents: `${generatedFile.contents}\\n${mergedMap.toComment()}`}\n       ];\n     }\n+\n+    const sourceMapComment = generateMapFileComment(`${fs.basename(sourceFilePath)}.map`);\n+    return [\n+      {path: sourceFilePath, contents: `${generatedFile.contents}\\n${sourceMapComment}`},\n+      {path: sourceMapPath, contents: mergedMap.toJSON()}\n+    ];\n   } catch (e) {\n-    logger.error(`Error when flattening the source-map \"${generatedMapPath}\" for \"${\n-        generatedPath}\": ${e.toString()}`);\n+    logger.error(`Error when flattening the source-map \"${sourceMapPath}\" for \"${\n+        sourceFilePath}\": ${e.toString()}`);\n     return [\n-      {path: generatedPath, contents: generatedContent},\n-      {path: generatedMapPath, contents: fromObject(generatedMap).toJSON()},\n+      {path: sourceFilePath, contents: generatedContent},\n+      {path: sourceMapPath, contents: fromObject(generatedMap).toJSON()},\n     ];\n   }\n }"
        },
        {
            "sha": "210aeb457df1cb8443574ae0344d0da42285342f",
            "filename": "packages/compiler-cli/src/ngtsc/sourcemaps/index.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/angular/angular/blob/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Findex.ts",
            "raw_url": "https://github.com/angular/angular/raw/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Findex.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Findex.ts?ref=dc06873c72dde8da2f8acacfb485e25e3fc84f31",
            "patch": "@@ -5,6 +5,7 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n-export {RawSourceMap} from './src/raw_source_map';\n+export {ContentOrigin} from './src/content_origin';\n+export {MapAndPath, RawSourceMap} from './src/raw_source_map';\n export {Mapping, SourceFile} from './src/source_file';\n-export {MapAndPath, SourceFileLoader} from './src/source_file_loader';\n+export {SourceFileLoader} from './src/source_file_loader';"
        },
        {
            "sha": "09523f37a7c0870d81b44c6a24230e48b545fd64",
            "filename": "packages/compiler-cli/src/ngtsc/sourcemaps/src/content_origin.ts",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/angular/angular/blob/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fcontent_origin.ts",
            "raw_url": "https://github.com/angular/angular/raw/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fcontent_origin.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fcontent_origin.ts?ref=dc06873c72dde8da2f8acacfb485e25e3fc84f31",
            "patch": "@@ -0,0 +1,34 @@\n+/**\n+ * @license\n+ * Copyright Google LLC All Rights Reserved.\n+ *\n+ * Use of this source code is governed by an MIT-style license that can be\n+ * found in the LICENSE file at https://angular.io/license\n+ */\n+\n+/**\n+ * From where the content for a source file or source-map came.\n+ *\n+ * - Source files can be linked to source-maps by:\n+ *   - providing the content inline via a base64 encoded data comment,\n+ *   - providing a URL to the file path in a comment,\n+ *   - the loader inferring the source-map path from the source file path.\n+ * - Source-maps can link to source files by:\n+ *   - providing the content inline in the `sourcesContent` property\n+ *   - providing the path to the file in the `sources` property\n+ */\n+export enum ContentOrigin {\n+  /**\n+   * The contents were provided programmatically when calling `loadSourceFile()`.\n+   */\n+  Provided,\n+  /**\n+   * The contents were extracted directly form the contents of the referring file.\n+   */\n+  Inline,\n+  /**\n+   * The contents were loaded from the file-system, after being explicitly referenced or inferred\n+   * from the referring file.\n+   */\n+  FileSystem,\n+}"
        },
        {
            "sha": "c9ac934ac3b137030d4cf014f1f2ddf14ded173b",
            "filename": "packages/compiler-cli/src/ngtsc/sourcemaps/src/raw_source_map.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/angular/angular/blob/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fraw_source_map.ts",
            "raw_url": "https://github.com/angular/angular/raw/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fraw_source_map.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fraw_source_map.ts?ref=dc06873c72dde8da2f8acacfb485e25e3fc84f31",
            "patch": "@@ -5,6 +5,8 @@\n  * Use of this source code is governed by an MIT-style license that can be\n  * found in the LICENSE file at https://angular.io/license\n  */\n+import {AbsoluteFsPath} from '../../file_system';\n+import {ContentOrigin} from './content_origin';\n \n /**\n  * This interface is the basic structure of the JSON in a raw source map that one might load from\n@@ -19,3 +21,22 @@ export interface RawSourceMap {\n   sourcesContent?: (string|null)[];\n   mappings: string;\n }\n+\n+\n+/**\n+ * The path and content of a source-map.\n+ */\n+export interface MapAndPath {\n+  /** The path to the source map if it was external or `null` if it was inline. */\n+  mapPath: AbsoluteFsPath|null;\n+  /** The raw source map itself. */\n+  map: RawSourceMap;\n+}\n+\n+/**\n+ * Information about a loaded source-map.\n+ */\n+export interface SourceMapInfo extends MapAndPath {\n+  /** From where the content for this source-map came. */\n+  origin: ContentOrigin;\n+}"
        },
        {
            "sha": "5405756f605fff611f50640710c0bc69734f4fdc",
            "filename": "packages/compiler-cli/src/ngtsc/sourcemaps/src/source_file.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/angular/angular/blob/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fsource_file.ts",
            "raw_url": "https://github.com/angular/angular/raw/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fsource_file.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fsource_file.ts?ref=dc06873c72dde8da2f8acacfb485e25e3fc84f31",
            "patch": "@@ -10,7 +10,7 @@ import {decode, encode, SourceMapMappings, SourceMapSegment} from 'sourcemap-cod\n \n import {AbsoluteFsPath, PathManipulation} from '../../file_system';\n \n-import {RawSourceMap} from './raw_source_map';\n+import {RawSourceMap, SourceMapInfo} from './raw_source_map';\n import {compareSegments, offsetSegment, SegmentMarker} from './segment_marker';\n \n export function removeSourceMapComments(contents: string): string {\n@@ -33,10 +33,8 @@ export class SourceFile {\n       readonly sourcePath: AbsoluteFsPath,\n       /** The contents of this source file. */\n       readonly contents: string,\n-      /** The raw source map (if any) associated with this source file. */\n-      readonly rawMap: RawSourceMap|null,\n-      /** Whether this source file's source map was inline or external. */\n-      readonly inline: boolean,\n+      /** The raw source map (if any) referenced by this source file. */\n+      readonly rawMap: SourceMapInfo|null,\n       /** Any source files referenced by the raw source map associated with this source file. */\n       readonly sources: (SourceFile|null)[],\n       private fs: PathManipulation,\n@@ -141,7 +139,8 @@ export class SourceFile {\n    * source files with no transitive source maps.\n    */\n   private flattenMappings(): Mapping[] {\n-    const mappings = parseMappings(this.rawMap, this.sources, this.startOfLinePositions);\n+    const mappings =\n+        parseMappings(this.rawMap && this.rawMap.map, this.sources, this.startOfLinePositions);\n     ensureOriginalSegmentLinks(mappings);\n     const flattenedMappings: Mapping[] = [];\n     for (let mappingIndex = 0; mappingIndex < mappings.length; mappingIndex++) {"
        },
        {
            "sha": "2b1f84cb9c811ca1a8cfb563490d5f1ec09e6e5f",
            "filename": "packages/compiler-cli/src/ngtsc/sourcemaps/src/source_file_loader.ts",
            "status": "modified",
            "additions": 90,
            "deletions": 36,
            "changes": 126,
            "blob_url": "https://github.com/angular/angular/blob/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fsource_file_loader.ts",
            "raw_url": "https://github.com/angular/angular/raw/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fsource_file_loader.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Fsrc%2Fsource_file_loader.ts?ref=dc06873c72dde8da2f8acacfb485e25e3fc84f31",
            "patch": "@@ -10,7 +10,8 @@ import {commentRegex, fromComment, mapFileCommentRegex} from 'convert-source-map\n import {AbsoluteFsPath, ReadonlyFileSystem} from '../../file_system';\n import {Logger} from '../../logging';\n \n-import {RawSourceMap} from './raw_source_map';\n+import {ContentOrigin} from './content_origin';\n+import {MapAndPath, RawSourceMap, SourceMapInfo} from './raw_source_map';\n import {SourceFile} from './source_file';\n \n const SCHEME_MATCHER = /^([a-z][a-z0-9.-]*):\\/\\//i;\n@@ -33,32 +34,60 @@ export class SourceFileLoader {\n       private schemeMap: Record<string, AbsoluteFsPath>) {}\n \n   /**\n-   * Load a source file, compute its source map, and recursively load any referenced source files.\n+   * Load a source file from the provided content and source map, and recursively load any\n+   * referenced source files.\n    *\n    * @param sourcePath The path to the source file to load.\n    * @param contents The contents of the source file to load.\n    * @param mapAndPath The raw source-map and the path to the source-map file.\n    * @returns a SourceFile object created from the `contents` and provided source-map info.\n    */\n   loadSourceFile(sourcePath: AbsoluteFsPath, contents: string, mapAndPath: MapAndPath): SourceFile;\n+  /**\n+   * Load a source file from the provided content, compute its source map, and recursively load any\n+   * referenced source files.\n+   *\n+   * @param sourcePath The path to the source file to load.\n+   * @param contents The contents of the source file to load.\n+   * @returns a SourceFile object created from the `contents` and computed source-map info.\n+   */\n+  loadSourceFile(sourcePath: AbsoluteFsPath, contents: string): SourceFile;\n+  /**\n+   * Load a source file from the file-system, compute its source map, and recursively load any\n+   * referenced source files.\n+   *\n+   * @param sourcePath The path to the source file to load.\n+   * @returns a SourceFile object if its contents could be loaded from disk, or null otherwise.\n+   */\n+  loadSourceFile(sourcePath: AbsoluteFsPath): SourceFile|null;\n+  loadSourceFile(\n+      sourcePath: AbsoluteFsPath, contents: string|null = null,\n+      mapAndPath: MapAndPath|null = null): SourceFile|null {\n+    const contentsOrigin = contents !== null ? ContentOrigin.Provided : ContentOrigin.FileSystem;\n+    const sourceMapInfo: SourceMapInfo|null =\n+        mapAndPath && {origin: ContentOrigin.Provided, ...mapAndPath};\n+    return this.loadSourceFileInternal(sourcePath, contents, contentsOrigin, sourceMapInfo);\n+  }\n+\n   /**\n    * The overload used internally to load source files referenced in a source-map.\n    *\n    * In this case there is no guarantee that it will return a non-null SourceMap.\n    *\n    * @param sourcePath The path to the source file to load.\n-   * @param contents The contents of the source file to load, if provided inline.\n-   * If it is not known the contents will be read from the file at the `sourcePath`.\n-   * @param mapAndPath The raw source-map and the path to the source-map file.\n+   * @param contents The contents of the source file to load, if provided inline. If `null`,\n+   *     the contents will be read from the file at the `sourcePath`.\n+   * @param sourceOrigin Describes where the source content came from.\n+   * @param sourceMapInfo The raw contents and path of the source-map file. If `null` the\n+   *     source-map will be computed from the contents of the source file, either inline or loaded\n+   *     from the file-system.\n    *\n-   * @returns a SourceFile if the content for one was provided or able to be loaded from disk,\n+   * @returns a SourceFile if the content for one was provided or was able to be loaded from disk,\n    * `null` otherwise.\n    */\n-  loadSourceFile(sourcePath: AbsoluteFsPath, contents?: string|null, mapAndPath?: null): SourceFile\n-      |null;\n-  loadSourceFile(\n-      sourcePath: AbsoluteFsPath, contents: string|null = null,\n-      mapAndPath: MapAndPath|null = null): SourceFile|null {\n+  private loadSourceFileInternal(\n+      sourcePath: AbsoluteFsPath, contents: string|null, sourceOrigin: ContentOrigin,\n+      sourceMapInfo: SourceMapInfo|null): SourceFile|null {\n     const previousPaths = this.currentPaths.slice();\n     try {\n       if (contents === null) {\n@@ -69,21 +98,17 @@ export class SourceFileLoader {\n       }\n \n       // If not provided try to load the source map based on the source itself\n-      if (mapAndPath === null) {\n-        mapAndPath = this.loadSourceMap(sourcePath, contents);\n+      if (sourceMapInfo === null) {\n+        sourceMapInfo = this.loadSourceMap(sourcePath, contents, sourceOrigin);\n       }\n \n-      let map: RawSourceMap|null = null;\n-      let inline = true;\n       let sources: (SourceFile|null)[] = [];\n-      if (mapAndPath !== null) {\n-        const basePath = mapAndPath.mapPath || sourcePath;\n-        sources = this.processSources(basePath, mapAndPath.map);\n-        map = mapAndPath.map;\n-        inline = mapAndPath.mapPath === null;\n+      if (sourceMapInfo !== null) {\n+        const basePath = sourceMapInfo.mapPath || sourcePath;\n+        sources = this.processSources(basePath, sourceMapInfo);\n       }\n \n-      return new SourceFile(sourcePath, contents, map, inline, sources, this.fs);\n+      return new SourceFile(sourcePath, contents, sourceMapInfo, sources, this.fs);\n     } catch (e) {\n       this.logger.warn(\n           `Unable to fully load ${sourcePath} for source-map flattening: ${e.message}`);\n@@ -100,23 +125,46 @@ export class SourceFileLoader {\n    *\n    * Source maps can be inline, as part of a base64 encoded comment, or external as a separate file\n    * whose path is indicated in a comment or implied from the name of the source file itself.\n+   *\n+   * @param sourcePath the path to the source file.\n+   * @param sourceContents the contents of the source file.\n+   * @param sourceOrigin where the content of the source file came from.\n+   * @returns the parsed contents and path of the source-map, if loading was successful, null\n+   *     otherwise.\n    */\n-  private loadSourceMap(sourcePath: AbsoluteFsPath, contents: string): MapAndPath|null {\n+  private loadSourceMap(\n+      sourcePath: AbsoluteFsPath, sourceContents: string,\n+      sourceOrigin: ContentOrigin): SourceMapInfo|null {\n     // Only consider a source-map comment from the last non-empty line of the file, in case there\n     // are embedded source-map comments elsewhere in the file (as can be the case with bundlers like\n     // webpack).\n-    const lastLine = this.getLastNonEmptyLine(contents);\n+    const lastLine = this.getLastNonEmptyLine(sourceContents);\n     const inline = commentRegex.exec(lastLine);\n     if (inline !== null) {\n-      return {map: fromComment(inline.pop()!).sourcemap, mapPath: null};\n+      return {\n+        map: fromComment(inline.pop()!).sourcemap,\n+        mapPath: null,\n+        origin: ContentOrigin.Inline,\n+      };\n+    }\n+\n+    if (sourceOrigin === ContentOrigin.Inline) {\n+      // The source file was provided inline and its contents did not include an inline source-map.\n+      // So we don't try to load an external source-map from the file-system, since this can lead to\n+      // invalid circular dependencies.\n+      return null;\n     }\n \n     const external = mapFileCommentRegex.exec(lastLine);\n     if (external) {\n       try {\n         const fileName = external[1] || external[2];\n         const externalMapPath = this.fs.resolve(this.fs.dirname(sourcePath), fileName);\n-        return {map: this.readRawSourceMap(externalMapPath), mapPath: externalMapPath};\n+        return {\n+          map: this.readRawSourceMap(externalMapPath),\n+          mapPath: externalMapPath,\n+          origin: ContentOrigin.FileSystem,\n+        };\n       } catch (e) {\n         this.logger.warn(\n             `Unable to fully load ${sourcePath} for source-map flattening: ${e.message}`);\n@@ -126,7 +174,11 @@ export class SourceFileLoader {\n \n     const impliedMapPath = this.fs.resolve(sourcePath + '.map');\n     if (this.fs.exists(impliedMapPath)) {\n-      return {map: this.readRawSourceMap(impliedMapPath), mapPath: impliedMapPath};\n+      return {\n+        map: this.readRawSourceMap(impliedMapPath),\n+        mapPath: impliedMapPath,\n+        origin: ContentOrigin.FileSystem,\n+      };\n     }\n \n     return null;\n@@ -136,13 +188,23 @@ export class SourceFileLoader {\n    * Iterate over each of the \"sources\" for this source file's source map, recursively loading each\n    * source file and its associated source map.\n    */\n-  private processSources(basePath: AbsoluteFsPath, map: RawSourceMap): (SourceFile|null)[] {\n+  private processSources(basePath: AbsoluteFsPath, {map, origin: sourceMapOrigin}: SourceMapInfo):\n+      (SourceFile|null)[] {\n     const sourceRoot = this.fs.resolve(\n         this.fs.dirname(basePath), this.replaceSchemeWithPath(map.sourceRoot || ''));\n     return map.sources.map((source, index) => {\n       const path = this.fs.resolve(sourceRoot, this.replaceSchemeWithPath(source));\n       const content = map.sourcesContent && map.sourcesContent[index] || null;\n-      return this.loadSourceFile(path, content, null);\n+      // The origin of this source file is \"inline\" if we extracted it from the source-map's\n+      // `sourcesContent`, except when the source-map itself was \"provided\" in-memory.\n+      // An inline source file is treated as if it were from the file-system if the source-map that\n+      // contains it was provided in-memory. The first call to `loadSourceFile()` is special in that\n+      // if you \"provide\" the contents of the source-map in-memory then we don't want to block\n+      // loading sources from the file-system just because this source-map had an inline source.\n+      const sourceOrigin = content !== null && sourceMapOrigin !== ContentOrigin.Provided ?\n+          ContentOrigin.Inline :\n+          ContentOrigin.FileSystem;\n+      return this.loadSourceFileInternal(path, content, sourceOrigin, null);\n     });\n   }\n \n@@ -206,11 +268,3 @@ export class SourceFileLoader {\n         SCHEME_MATCHER, (_: string, scheme: string) => this.schemeMap[scheme.toLowerCase()] || '');\n   }\n }\n-\n-/** A small helper structure that is returned from `loadSourceMap()`. */\n-export interface MapAndPath {\n-  /** The path to the source map if it was external or `null` if it was inline. */\n-  mapPath: AbsoluteFsPath|null;\n-  /** The raw source map itself. */\n-  map: RawSourceMap;\n-}"
        },
        {
            "sha": "1e86114cf48e19d8b29d2a28a9340f1554967fec",
            "filename": "packages/compiler-cli/src/ngtsc/sourcemaps/test/source_file_loader_spec.ts",
            "status": "modified",
            "additions": 138,
            "deletions": 56,
            "changes": 194,
            "blob_url": "https://github.com/angular/angular/blob/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Ftest%2Fsource_file_loader_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Ftest%2Fsource_file_loader_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Ftest%2Fsource_file_loader_spec.ts?ref=dc06873c72dde8da2f8acacfb485e25e3fc84f31",
            "patch": "@@ -11,7 +11,7 @@ import {absoluteFrom, FileSystem, getFileSystem} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n import {MockLogger} from '../../logging/testing';\n import {RawSourceMap} from '../src/raw_source_map';\n-import {SourceFileLoader as SourceFileLoader} from '../src/source_file_loader';\n+import {SourceFileLoader} from '../src/source_file_loader';\n \n runInEachFileSystem(() => {\n   describe('SourceFileLoader', () => {\n@@ -34,7 +34,7 @@ runInEachFileSystem(() => {\n         }\n         expect(sourceFile.contents).toEqual('some inline content');\n         expect(sourceFile.sourcePath).toEqual(_('/foo/src/index.js'));\n-        expect(sourceFile.rawMap).toEqual(null);\n+        expect(sourceFile.rawMap).toBe(null);\n         expect(sourceFile.sources).toEqual([]);\n       });\n \n@@ -47,7 +47,7 @@ runInEachFileSystem(() => {\n         }\n         expect(sourceFile.contents).toEqual('some external content');\n         expect(sourceFile.sourcePath).toEqual(_('/foo/src/index.js'));\n-        expect(sourceFile.rawMap).toEqual(null);\n+        expect(sourceFile.rawMap).toBe(null);\n         expect(sourceFile.sources).toEqual([]);\n       });\n \n@@ -60,7 +60,10 @@ runInEachFileSystem(() => {\n         if (sourceFile === null) {\n           return fail('Expected source file to be defined');\n         }\n-        expect(sourceFile.rawMap).toEqual(sourceMap);\n+        if (sourceFile.rawMap === null) {\n+          return fail('Expected source map to be defined');\n+        }\n+        expect(sourceFile.rawMap.map).toEqual(sourceMap);\n       });\n \n       it('should only read source-map comments from the last line of a file', () => {\n@@ -76,7 +79,10 @@ runInEachFileSystem(() => {\n         if (sourceFile === null) {\n           return fail('Expected source file to be defined');\n         }\n-        expect(sourceFile.rawMap).toEqual(sourceMap);\n+        if (sourceFile.rawMap === null) {\n+          return fail('Expected source map to be defined');\n+        }\n+        expect(sourceFile.rawMap.map).toEqual(sourceMap);\n       });\n \n       for (const eolMarker of ['\\n', '\\r\\n']) {\n@@ -97,7 +103,10 @@ runInEachFileSystem(() => {\n              if (sourceFile === null) {\n                return fail('Expected source file to be defined');\n              }\n-             expect(sourceFile.rawMap).toEqual(sourceMap);\n+             if (sourceFile.rawMap === null) {\n+               return fail('Expected source map to be defined');\n+             }\n+             expect(sourceFile.rawMap.map).toEqual(sourceMap);\n            });\n       }\n \n@@ -121,7 +130,10 @@ runInEachFileSystem(() => {\n         if (sourceFile === null) {\n           return fail('Expected source file to be defined');\n         }\n-        expect(sourceFile.rawMap).toEqual(sourceMap);\n+        if (sourceFile.rawMap === null) {\n+          return fail('Expected source map to be defined');\n+        }\n+        expect(sourceFile.rawMap.map).toEqual(sourceMap);\n       });\n \n       it('should load a file with an implied source map', () => {\n@@ -132,7 +144,10 @@ runInEachFileSystem(() => {\n         if (sourceFile === null) {\n           return fail('Expected source file to be defined');\n         }\n-        expect(sourceFile.rawMap).toEqual(sourceMap);\n+        if (sourceFile.rawMap === null) {\n+          return fail('Expected source map to be defined');\n+        }\n+        expect(sourceFile.rawMap.map).toEqual(sourceMap);\n       });\n \n       it('should handle missing implied source-map file', () => {\n@@ -177,29 +192,32 @@ runInEachFileSystem(() => {\n \n            expect(sourceFile.contents).toEqual('index content');\n            expect(sourceFile.sourcePath).toEqual(_('/foo/src/index.js'));\n-           expect(sourceFile.rawMap).toEqual(indexSourceMap);\n+           if (sourceFile.rawMap === null) {\n+             return fail('Expected source map to be defined');\n+           }\n+           expect(sourceFile.rawMap.map).toEqual(indexSourceMap);\n \n            expect(sourceFile.sources.length).toEqual(3);\n \n            expect(sourceFile.sources[0]!.contents).toEqual('x content');\n            expect(sourceFile.sources[0]!.sourcePath).toEqual(_('/foo/src/x.js'));\n-           expect(sourceFile.sources[0]!.rawMap).toEqual(null);\n+           expect(sourceFile.sources[0]!.rawMap).toBe(null);\n            expect(sourceFile.sources[0]!.sources).toEqual([]);\n \n \n            expect(sourceFile.sources[1]!.contents).toEqual('y content');\n            expect(sourceFile.sources[1]!.sourcePath).toEqual(_('/foo/src/y.js'));\n-           expect(sourceFile.sources[1]!.rawMap).toEqual(ySourceMap);\n+           expect(sourceFile.sources[1]!.rawMap!.map).toEqual(ySourceMap);\n \n            expect(sourceFile.sources[1]!.sources.length).toEqual(1);\n            expect(sourceFile.sources[1]!.sources[0]!.contents).toEqual('a content');\n            expect(sourceFile.sources[1]!.sources[0]!.sourcePath).toEqual(_('/foo/src/a.js'));\n-           expect(sourceFile.sources[1]!.sources[0]!.rawMap).toEqual(null);\n+           expect(sourceFile.sources[1]!.sources[0]!.rawMap).toBe(null);\n            expect(sourceFile.sources[1]!.sources[0]!.sources).toEqual([]);\n \n            expect(sourceFile.sources[2]!.contents).toEqual('z content');\n            expect(sourceFile.sources[2]!.sourcePath).toEqual(_('/foo/src/z.js'));\n-           expect(sourceFile.sources[2]!.rawMap).toEqual(null);\n+           expect(sourceFile.sources[2]!.rawMap).toBe(null);\n            expect(sourceFile.sources[2]!.sources).toEqual([]);\n          });\n \n@@ -217,14 +235,21 @@ runInEachFileSystem(() => {\n \n         expect(sourceFile.contents).toEqual('index content');\n         expect(sourceFile.sourcePath).toEqual(_('/foo/src/index.js'));\n-        expect(sourceFile.rawMap).toEqual(indexSourceMap);\n+        if (sourceFile.rawMap === null) {\n+          return fail('Expected source map to be defined');\n+        }\n+        expect(sourceFile.rawMap.map).toEqual(indexSourceMap);\n         expect(sourceFile.sources.length).toEqual(1);\n         expect(sourceFile.sources[0]).toBe(null);\n       });\n     });\n \n     it('should log a warning if there is a cyclic dependency in source files loaded from disk',\n        () => {\n+         // a.js -> a.js.map -> b.js -> b.js.map -> c.js -> c.js.map -> (external) a.js\n+         //                                                             ^^^^^^^^^^^^^^^\n+         // c.js.map incorrectly links to a.js, creating a cycle\n+\n          fs.ensureDir(_('/foo/src'));\n \n          const aMap = createRawSourceMap({file: 'a.js', sources: ['b.js']});\n@@ -248,7 +273,10 @@ runInEachFileSystem(() => {\n          expect(sourceFile).not.toBe(null!);\n          expect(sourceFile.contents).toEqual('a content\\n');\n          expect(sourceFile.sourcePath).toEqual(_('/foo/src/a.js'));\n-         expect(sourceFile.rawMap).toEqual(aMap);\n+         if (sourceFile.rawMap === null) {\n+           return fail('Expected source map to be defined');\n+         }\n+         expect(sourceFile.rawMap.map).toEqual(aMap);\n          expect(sourceFile.sources.length).toEqual(1);\n \n          expect(logger.logs.warn[0][0])\n@@ -259,65 +287,119 @@ runInEachFileSystem(() => {\n \n     it('should log a warning if there is a cyclic dependency in source maps loaded from disk',\n        () => {\n+         // a.js -> a.js.map -> b.js -> a.js.map -> c.js\n+         //                             ^^^^^^^^\n+         // b.js incorrectly links to a.js.map, creating a cycle\n+\n          fs.ensureDir(_('/foo/src'));\n+         const aPath = _('/foo/src/a.js');\n+         fs.writeFile(aPath, 'a.js content\\n//# sourceMappingURL=a.js.map');\n \n-         // Create a self-referencing source-map\n-         const aMap = createRawSourceMap({\n-           file: 'a.js',\n-           sources: ['a.js'],\n-           sourcesContent: ['inline a.js content\\n//# sourceMappingURL=a.js.map']\n-         });\n+         const aMap = createRawSourceMap({file: 'a.js', sources: ['b.js']});\n          const aMapPath = _('/foo/src/a.js.map');\n          fs.writeFile(aMapPath, JSON.stringify(aMap));\n \n-         const aPath = _('/foo/src/a.js');\n-         fs.writeFile(aPath, 'a.js content\\n//# sourceMappingURL=a.js.map');\n+         const bPath = _('/foo/src/b.js');\n+         fs.writeFile(bPath, 'b.js content\\n//# sourceMappingURL=a.js.map');\n \n-         const sourceFile = registry.loadSourceFile(aPath)!;\n-         expect(sourceFile).not.toBe(null!);\n+         const sourceFile = registry.loadSourceFile(aPath);\n+         if (sourceFile === null) {\n+           return fail('Expected source file to be defined');\n+         }\n          expect(sourceFile.contents).toEqual('a.js content\\n');\n          expect(sourceFile.sourcePath).toEqual(_('/foo/src/a.js'));\n-         expect(sourceFile.rawMap).toEqual(aMap);\n+         if (sourceFile.rawMap === null) {\n+           return fail('Expected source map to be defined');\n+         }\n+         expect(sourceFile.rawMap.map).toEqual(aMap);\n          expect(sourceFile.sources.length).toEqual(1);\n \n          expect(logger.logs.warn[0][0])\n              .toContain(\n                  `Circular source file mapping dependency: ` +\n-                 `${aPath} -> ${aMapPath} -> ${aMapPath}`);\n-\n-         const innerSourceFile = sourceFile.sources[0]!;\n-         expect(innerSourceFile).not.toBe(null!);\n-         expect(innerSourceFile.contents).toEqual('inline a.js content\\n');\n-         expect(innerSourceFile.sourcePath).toEqual(_('/foo/src/a.js'));\n-         expect(innerSourceFile.rawMap).toEqual(null);\n+                 `${aPath} -> ${aMapPath} -> ${bPath} -> ${aMapPath}`);\n+         const innerSourceFile = sourceFile.sources[0];\n+         if (innerSourceFile === null) {\n+           return fail('Expected source file to be defined');\n+         }\n+         expect(innerSourceFile.contents).toEqual('b.js content\\n');\n+         expect(innerSourceFile.sourcePath).toEqual(_('/foo/src/b.js'));\n+         // The source-map from b.js was not loaded as it would have caused a cycle\n+         expect(innerSourceFile.rawMap).toBe(null);\n          expect(innerSourceFile.sources.length).toEqual(0);\n        });\n \n-    it('should not fail if there is a cyclic dependency in filenames of inline sources', () => {\n-      fs.ensureDir(_('/foo/src'));\n+    it('should not fail if the filename of an inline source looks like a cyclic dependency', () => {\n+      // a.js -> (inline) a.js.map -> (inline) a.js\n+      //                              ^^^^^^^^^^^^^\n+      // a.js loads despite same name as previous file because it is inline\n \n+      fs.ensureDir(_('/foo/src'));\n       const aPath = _('/foo/src/a.js');\n-      fs.writeFile(\n-          aPath,\n-          'a content\\n' +\n-              fromObject(createRawSourceMap({file: 'a.js', sources: ['b.js']})).toComment());\n-\n-      const bPath = _('/foo/src/b.js');\n-      fs.writeFile(bPath, 'b content');\n-      fs.writeFile(\n-          _('/foo/src/b.js.map'),\n-          JSON.stringify(createRawSourceMap({file: 'b.js', sources: ['c.js']})));\n-\n-      const cPath = _('/foo/src/c.js');\n-      fs.writeFile(cPath, 'c content');\n-      fs.writeFile(\n-          _('/foo/src/c.js.map'),\n-          JSON.stringify(createRawSourceMap(\n-              {file: 'c.js', sources: ['a.js'], sourcesContent: ['inline a.js content']})));\n-\n-      expect(() => registry.loadSourceFile(aPath)).not.toThrow();\n+      const aMap = createRawSourceMap(\n+          {file: 'a.js', sources: ['a.js'], sourcesContent: ['inline original a.js content']});\n+      fs.writeFile(aPath, 'a content\\n' + fromObject(aMap).toComment());\n+\n+      const sourceFile = registry.loadSourceFile(aPath);\n+      if (sourceFile === null) {\n+        return fail('Expected source file to be defined');\n+      }\n+      expect(sourceFile.sources.length).toEqual(1);\n+      expect(sourceFile.sources[0]!.contents).toEqual('inline original a.js content');\n+      expect(sourceFile.sources[0]!.sourcePath).toEqual(aPath);\n+      expect(sourceFile.sources[0]!.rawMap).toBe(null);\n+      expect(sourceFile.sources[0]!.sources).toEqual([]);\n+\n+      expect(logger.logs.warn.length).toEqual(0);\n     });\n \n+    it('should not load source-maps (after the initial map) from disk if the source file was inline',\n+       () => {\n+         // a.js -> (initial) a.js.map -> b.js -> b.js.map -> (inline) c.js -> c.js.map\n+         //                                                                    ^^^^^^^^\n+         // c.js.map is not loaded because the referencing source file (c.js) was inline\n+\n+         fs.ensureDir(_('/foo/src'));\n+\n+         const aPath = _('/foo/src/a.js');\n+         fs.writeFile(aPath, 'a.js content\\n//# sourceMappingURL=a.js.map');\n+         const aMapPath = _('/foo/src/a.js.map');\n+         const aMap = createRawSourceMap({file: 'a.js', sources: ['b.js']});\n+         fs.writeFile(aMapPath, JSON.stringify(aMap));\n+\n+         const bPath = _('/foo/src/b.js');\n+         fs.writeFile(bPath, 'b.js content\\n//# sourceMappingURL=b.js.map');\n+         const bMapPath = _('/foo/src/b.js.map');\n+         const bMap = createRawSourceMap({\n+           file: 'b.js',\n+           sources: ['c.js'],\n+           sourcesContent: ['c content\\n//# sourceMappingURL=c.js.map']\n+         });\n+         fs.writeFile(bMapPath, JSON.stringify(bMap));\n+\n+         const cMapPath = _('/foo/src/c.js.map');\n+         const cMap = createRawSourceMap({file: 'c.js', sources: ['d.js']});\n+         fs.writeFile(cMapPath, JSON.stringify(cMap));\n+\n+         const sourceFile = registry.loadSourceFile(aPath);\n+         if (sourceFile === null) {\n+           return fail('Expected source file to be defined');\n+         }\n+         const bSource = sourceFile.sources[0];\n+         if (!bSource) {\n+           return fail('Expected source file to be defined');\n+         }\n+         const cSource = bSource.sources[0];\n+         if (!cSource) {\n+           return fail('Expected source file to be defined');\n+         }\n+         // External c.js.map never gets loaded because c.js was inline source\n+         expect(cSource.rawMap).toBe(null);\n+         expect(cSource.sources).toEqual([]);\n+\n+         expect(logger.logs.warn.length).toEqual(0);\n+       });\n+\n     for (const {scheme, mappedPath} of\n              [{scheme: 'WEBPACK://', mappedPath: '/foo/src/index.ts'},\n               {scheme: 'webpack://', mappedPath: '/foo/src/index.ts'},\n@@ -342,7 +424,7 @@ runInEachFileSystem(() => {\n         }\n         expect(originalSource.contents).toEqual('original content');\n         expect(originalSource.sourcePath).toEqual(_(mappedPath));\n-        expect(originalSource.rawMap).toEqual(null);\n+        expect(originalSource.rawMap).toBe(null);\n         expect(originalSource.sources).toEqual([]);\n       });\n \n@@ -366,7 +448,7 @@ runInEachFileSystem(() => {\n         }\n         expect(originalSource.contents).toEqual('original content');\n         expect(originalSource.sourcePath).toEqual(_(mappedPath));\n-        expect(originalSource.rawMap).toEqual(null);\n+        expect(originalSource.rawMap).toBe(null);\n         expect(originalSource.sources).toEqual([]);\n       });\n     }"
        },
        {
            "sha": "9e4e079fbbe8b6b676942658e1c1b4d49d6696d4",
            "filename": "packages/compiler-cli/src/ngtsc/sourcemaps/test/source_file_spec.ts",
            "status": "modified",
            "additions": 204,
            "deletions": 152,
            "changes": 356,
            "blob_url": "https://github.com/angular/angular/blob/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Ftest%2Fsource_file_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/dc06873c72dde8da2f8acacfb485e25e3fc84f31/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Ftest%2Fsource_file_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler-cli%2Fsrc%2Fngtsc%2Fsourcemaps%2Ftest%2Fsource_file_spec.ts?ref=dc06873c72dde8da2f8acacfb485e25e3fc84f31",
            "patch": "@@ -9,7 +9,8 @@ import {encode} from 'sourcemap-codec';\n \n import {absoluteFrom, getFileSystem, PathManipulation} from '../../file_system';\n import {runInEachFileSystem} from '../../file_system/testing';\n-import {RawSourceMap} from '../src/raw_source_map';\n+import {ContentOrigin} from '../src/content_origin';\n+import {RawSourceMap, SourceMapInfo} from '../src/raw_source_map';\n import {SegmentMarker} from '../src/segment_marker';\n import {computeStartOfLinePositions, ensureOriginalSegmentLinks, extractOriginalSegments, findLastMappingIndexBefore, Mapping, parseMappings, SourceFile} from '../src/source_file';\n \n@@ -42,7 +43,7 @@ runInEachFileSystem(() => {\n           sources: ['a.js'],\n           version: 3\n         };\n-        const originalSource = new SourceFile(_('/foo/src/a.js'), 'abcdefg', null, false, [], fs);\n+        const originalSource = new SourceFile(_('/foo/src/a.js'), 'abcdefg', null, [], fs);\n         const mappings = parseMappings(rawSourceMap, [originalSource], [0, 8]);\n         expect(mappings).toEqual([\n           {\n@@ -73,8 +74,7 @@ runInEachFileSystem(() => {\n \n       it('should parse the segments in ascending order of original position from the raw source map',\n          () => {\n-           const originalSource =\n-               new SourceFile(_('/foo/src/a.js'), 'abcdefg', null, false, [], fs);\n+           const originalSource = new SourceFile(_('/foo/src/a.js'), 'abcdefg', null, [], fs);\n            const rawSourceMap: RawSourceMap = {\n              mappings: encode([[[0, 0, 0, 0], [2, 0, 0, 3], [4, 0, 0, 2]]]),\n              names: [],\n@@ -91,8 +91,8 @@ runInEachFileSystem(() => {\n          });\n \n       it('should create separate arrays for each original source file', () => {\n-        const sourceA = new SourceFile(_('/foo/src/a.js'), 'abcdefg', null, false, [], fs);\n-        const sourceB = new SourceFile(_('/foo/src/b.js'), '1234567', null, false, [], fs);\n+        const sourceA = new SourceFile(_('/foo/src/a.js'), 'abcdefg', null, [], fs);\n+        const sourceB = new SourceFile(_('/foo/src/b.js'), '1234567', null, [], fs);\n         const rawSourceMap: RawSourceMap = {\n           mappings:\n               encode([[[0, 0, 0, 0], [2, 1, 0, 3], [4, 0, 0, 2], [5, 1, 0, 5], [6, 1, 0, 2]]]),\n@@ -316,8 +316,8 @@ runInEachFileSystem(() => {\n     describe('ensureOriginalSegmentLinks', () => {\n       it('should add `next` properties to each segment that point to the next segment in the same source file',\n          () => {\n-           const sourceA = new SourceFile(_('/foo/src/a.js'), 'abcdefg', null, false, [], fs);\n-           const sourceB = new SourceFile(_('/foo/src/b.js'), '1234567', null, false, [], fs);\n+           const sourceA = new SourceFile(_('/foo/src/a.js'), 'abcdefg', null, [], fs);\n+           const sourceB = new SourceFile(_('/foo/src/b.js'), '1234567', null, [], fs);\n            const rawSourceMap: RawSourceMap = {\n              mappings:\n                  encode([[[0, 0, 0, 0], [2, 1, 0, 3], [4, 0, 0, 2], [5, 1, 0, 5], [6, 1, 0, 2]]]),\n@@ -338,55 +338,68 @@ runInEachFileSystem(() => {\n     describe('SourceFile', () => {\n       describe('flattenedMappings', () => {\n         it('should be an empty array for source files with no source map', () => {\n-          const sourceFile =\n-              new SourceFile(_('/foo/src/index.js'), 'index contents', null, false, [], fs);\n+          const sourceFile = new SourceFile(_('/foo/src/index.js'), 'index contents', null, [], fs);\n           expect(sourceFile.flattenedMappings).toEqual([]);\n         });\n \n         it('should be empty array for source files with no source map mappings', () => {\n-          const rawSourceMap: RawSourceMap = {mappings: '', names: [], sources: [], version: 3};\n+          const rawSourceMap: SourceMapInfo = {\n+            map: {mappings: '', names: [], sources: [], version: 3},\n+            mapPath: null,\n+            origin: ContentOrigin.Provided\n+          };\n           const sourceFile =\n-              new SourceFile(_('/foo/src/index.js'), 'index contents', rawSourceMap, false, [], fs);\n+              new SourceFile(_('/foo/src/index.js'), 'index contents', rawSourceMap, [], fs);\n           expect(sourceFile.flattenedMappings).toEqual([]);\n         });\n \n         it('should be the same as non-flat mappings if there is only one level of source map',\n            () => {\n-             const rawSourceMap: RawSourceMap = {\n-               mappings: encode([[[0, 0, 0, 0], [6, 0, 0, 3]]]),\n-               names: [],\n-               sources: ['a.js'],\n-               version: 3\n+             const rawSourceMap: SourceMapInfo = {\n+               mapPath: null,\n+               map: {\n+                 mappings: encode([[[0, 0, 0, 0], [6, 0, 0, 3]]]),\n+                 names: [],\n+                 sources: ['a.js'],\n+                 version: 3\n+               },\n+               origin: ContentOrigin.Provided,\n              };\n-             const originalSource =\n-                 new SourceFile(_('/foo/src/a.js'), 'abcdefg', null, false, [], fs);\n+             const originalSource = new SourceFile(_('/foo/src/a.js'), 'abcdefg', null, [], fs);\n              const sourceFile = new SourceFile(\n-                 _('/foo/src/index.js'), 'abc123defg', rawSourceMap, false, [originalSource], fs);\n+                 _('/foo/src/index.js'), 'abc123defg', rawSourceMap, [originalSource], fs);\n              expect(removeOriginalSegmentLinks(sourceFile.flattenedMappings))\n-                 .toEqual(parseMappings(rawSourceMap, [originalSource], [0, 11]));\n+                 .toEqual(parseMappings(rawSourceMap.map, [originalSource], [0, 11]));\n            });\n \n         it('should merge mappings from flattened original source files', () => {\n-          const cSource = new SourceFile(_('/foo/src/c.js'), 'bcd123', null, false, [], fs);\n-          const dSource = new SourceFile(_('/foo/src/d.js'), 'aef', null, false, [], fs);\n-\n-          const bSourceMap: RawSourceMap = {\n-            mappings: encode([[[0, 1, 0, 0], [1, 0, 0, 0], [4, 1, 0, 1]]]),\n-            names: [],\n-            sources: ['c.js', 'd.js'],\n-            version: 3\n+          const cSource = new SourceFile(_('/foo/src/c.js'), 'bcd123', null, [], fs);\n+          const dSource = new SourceFile(_('/foo/src/d.js'), 'aef', null, [], fs);\n+\n+          const bSourceMap: SourceMapInfo = {\n+            mapPath: null,\n+            map: {\n+              mappings: encode([[[0, 1, 0, 0], [1, 0, 0, 0], [4, 1, 0, 1]]]),\n+              names: [],\n+              sources: ['c.js', 'd.js'],\n+              version: 3\n+            },\n+            origin: ContentOrigin.Provided,\n           };\n-          const bSource = new SourceFile(\n-              _('/foo/src/b.js'), 'abcdef', bSourceMap, false, [cSource, dSource], fs);\n-\n-          const aSourceMap: RawSourceMap = {\n-            mappings: encode([[[0, 0, 0, 0], [2, 0, 0, 3], [4, 0, 0, 2], [5, 0, 0, 5]]]),\n-            names: [],\n-            sources: ['b.js'],\n-            version: 3\n+          const bSource =\n+              new SourceFile(_('/foo/src/b.js'), 'abcdef', bSourceMap, [cSource, dSource], fs);\n+\n+          const aSourceMap: SourceMapInfo = {\n+            mapPath: null,\n+            map: {\n+              mappings: encode([[[0, 0, 0, 0], [2, 0, 0, 3], [4, 0, 0, 2], [5, 0, 0, 5]]]),\n+              names: [],\n+              sources: ['b.js'],\n+              version: 3\n+            },\n+            origin: ContentOrigin.Provided,\n           };\n-          const aSource =\n-              new SourceFile(_('/foo/src/a.js'), 'abdecf', aSourceMap, false, [bSource], fs);\n+          const aSource = new SourceFile(_('/foo/src/a.js'), 'abdecf', aSourceMap, [bSource], fs);\n \n           expect(removeOriginalSegmentLinks(aSource.flattenedMappings)).toEqual([\n             {\n@@ -429,27 +442,34 @@ runInEachFileSystem(() => {\n         });\n \n         it('should ignore mappings to missing source files', () => {\n-          const bSourceMap: RawSourceMap = {\n-            mappings: encode([[[1, 0, 0, 0], [4, 0, 0, 3], [4, 0, 0, 6], [5, 0, 0, 7]]]),\n-            names: [],\n-            sources: ['c.js'],\n-            version: 3\n+          const bSourceMap: SourceMapInfo = {\n+            mapPath: null,\n+            map: {\n+              mappings: encode([[[1, 0, 0, 0], [4, 0, 0, 3], [4, 0, 0, 6], [5, 0, 0, 7]]]),\n+              names: [],\n+              sources: ['c.js'],\n+              version: 3\n+            },\n+            origin: ContentOrigin.Provided,\n           };\n-          const bSource =\n-              new SourceFile(_('/foo/src/b.js'), 'abcdef', bSourceMap, false, [null], fs);\n-          const aSourceMap: RawSourceMap = {\n-            mappings: encode([[[0, 0, 0, 0], [2, 0, 0, 3], [4, 0, 0, 2], [5, 0, 0, 5]]]),\n-            names: [],\n-            sources: ['b.js'],\n-            version: 3\n+          const bSource = new SourceFile(_('/foo/src/b.js'), 'abcdef', bSourceMap, [null], fs);\n+          const aSourceMap: SourceMapInfo = {\n+            mapPath: null,\n+            map: {\n+              mappings: encode([[[0, 0, 0, 0], [2, 0, 0, 3], [4, 0, 0, 2], [5, 0, 0, 5]]]),\n+              names: [],\n+              sources: ['b.js'],\n+              version: 3\n+            },\n+            origin: ContentOrigin.Provided,\n           };\n-          const aSource =\n-              new SourceFile(_('/foo/src/a.js'), 'abdecf', aSourceMap, false, [bSource], fs);\n+          const aSource = new SourceFile(_('/foo/src/a.js'), 'abdecf', aSourceMap, [bSource], fs);\n \n           // These flattened mappings are just the mappings from a to b.\n-          // (The mappings to c are dropped since there is no source file to map to.)\n+          // (The mappings to c are dropped since there is no source file to map\n+          // to.)\n           expect(removeOriginalSegmentLinks(aSource.flattenedMappings))\n-              .toEqual(parseMappings(aSourceMap, [bSource], [0, 7]));\n+              .toEqual(parseMappings(aSourceMap.map, [bSource], [0, 7]));\n         });\n \n         /**\n@@ -467,23 +487,31 @@ runInEachFileSystem(() => {\n \n       describe('renderFlattenedSourceMap()', () => {\n         it('should convert the flattenedMappings into a raw source-map object', () => {\n-          const cSource = new SourceFile(_('/foo/src/c.js'), 'bcd123e', null, false, [], fs);\n-          const bToCSourceMap: RawSourceMap = {\n-            mappings: encode([[[1, 0, 0, 0], [4, 0, 0, 3], [4, 0, 0, 6], [5, 0, 0, 7]]]),\n-            names: [],\n-            sources: ['c.js'],\n-            version: 3\n+          const cSource = new SourceFile(_('/foo/src/c.js'), 'bcd123e', null, [], fs);\n+          const bToCSourceMap: SourceMapInfo = {\n+            mapPath: null,\n+            map: {\n+              mappings: encode([[[1, 0, 0, 0], [4, 0, 0, 3], [4, 0, 0, 6], [5, 0, 0, 7]]]),\n+              names: [],\n+              sources: ['c.js'],\n+              version: 3\n+            },\n+            origin: ContentOrigin.Provided,\n           };\n           const bSource =\n-              new SourceFile(_('/foo/src/b.js'), 'abcdef', bToCSourceMap, false, [cSource], fs);\n-          const aToBSourceMap: RawSourceMap = {\n-            mappings: encode([[[0, 0, 0, 0], [2, 0, 0, 3], [4, 0, 0, 2], [5, 0, 0, 5]]]),\n-            names: [],\n-            sources: ['b.js'],\n-            version: 3\n+              new SourceFile(_('/foo/src/b.js'), 'abcdef', bToCSourceMap, [cSource], fs);\n+          const aToBSourceMap: SourceMapInfo = {\n+            mapPath: null,\n+            map: {\n+              mappings: encode([[[0, 0, 0, 0], [2, 0, 0, 3], [4, 0, 0, 2], [5, 0, 0, 5]]]),\n+              names: [],\n+              sources: ['b.js'],\n+              version: 3\n+            },\n+            origin: ContentOrigin.Provided,\n           };\n           const aSource =\n-              new SourceFile(_('/foo/src/a.js'), 'abdecf', aToBSourceMap, false, [bSource], fs);\n+              new SourceFile(_('/foo/src/a.js'), 'abdecf', aToBSourceMap, [bSource], fs);\n \n           const aTocSourceMap = aSource.renderFlattenedSourceMap();\n           expect(aTocSourceMap.version).toEqual(3);\n@@ -498,20 +526,24 @@ runInEachFileSystem(() => {\n         });\n \n         it('should handle mappings that map from lines outside of the actual content lines', () => {\n-          const bSource = new SourceFile(_('/foo/src/b.js'), 'abcdef', null, false, [], fs);\n-          const aToBSourceMap: RawSourceMap = {\n-            mappings: encode([\n-              [[0, 0, 0, 0], [2, 0, 0, 3], [4, 0, 0, 2], [5, 0, 0, 5]],\n-              [\n-                [0, 0, 0, 0],  // Extra mapping from a non-existent line\n-              ]\n-            ]),\n-            names: [],\n-            sources: ['b.js'],\n-            version: 3\n+          const bSource = new SourceFile(_('/foo/src/b.js'), 'abcdef', null, [], fs);\n+          const aToBSourceMap: SourceMapInfo = {\n+            mapPath: null,\n+            map: {\n+              mappings: encode([\n+                [[0, 0, 0, 0], [2, 0, 0, 3], [4, 0, 0, 2], [5, 0, 0, 5]],\n+                [\n+                  [0, 0, 0, 0],  // Extra mapping from a non-existent line\n+                ]\n+              ]),\n+              names: [],\n+              sources: ['b.js'],\n+              version: 3\n+            },\n+            origin: ContentOrigin.Provided,\n           };\n           const aSource =\n-              new SourceFile(_('/foo/src/a.js'), 'abdecf', aToBSourceMap, false, [bSource], fs);\n+              new SourceFile(_('/foo/src/a.js'), 'abdecf', aToBSourceMap, [bSource], fs);\n \n           const aTocSourceMap = aSource.renderFlattenedSourceMap();\n           expect(aTocSourceMap.version).toEqual(3);\n@@ -520,31 +552,39 @@ runInEachFileSystem(() => {\n           expect(aTocSourceMap.sourceRoot).toBeUndefined();\n           expect(aTocSourceMap.sources).toEqual(['b.js']);\n           expect(aTocSourceMap.sourcesContent).toEqual(['abcdef']);\n-          expect(aTocSourceMap.mappings).toEqual(aToBSourceMap.mappings);\n+          expect(aTocSourceMap.mappings).toEqual(aToBSourceMap.map.mappings);\n         });\n \n         it('should consolidate source-files with the same relative path', () => {\n-          const cSource1 = new SourceFile(_('/foo/src/lib/c.js'), 'bcd123e', null, false, [], fs);\n-          const cSource2 = new SourceFile(_('/foo/src/lib/c.js'), 'bcd123e', null, false, [], fs);\n-\n-          const bToCSourceMap: RawSourceMap = {\n-            mappings: encode([[[1, 0, 0, 0], [4, 0, 0, 3], [4, 0, 0, 6], [5, 0, 0, 7]]]),\n-            names: [],\n-            sources: ['c.js'],\n-            version: 3\n+          const cSource1 = new SourceFile(_('/foo/src/lib/c.js'), 'bcd123e', null, [], fs);\n+          const cSource2 = new SourceFile(_('/foo/src/lib/c.js'), 'bcd123e', null, [], fs);\n+\n+          const bToCSourceMap: SourceMapInfo = {\n+            mapPath: null,\n+            map: {\n+              mappings: encode([[[1, 0, 0, 0], [4, 0, 0, 3], [4, 0, 0, 6], [5, 0, 0, 7]]]),\n+              names: [],\n+              sources: ['c.js'],\n+              version: 3\n+            },\n+            origin: ContentOrigin.Provided,\n           };\n-          const bSource = new SourceFile(\n-              _('/foo/src/lib/b.js'), 'abcdef', bToCSourceMap, false, [cSource1], fs);\n-\n-          const aToBCSourceMap: RawSourceMap = {\n-            mappings:\n-                encode([[[0, 0, 0, 0], [2, 0, 0, 3], [4, 0, 0, 2], [5, 0, 0, 5], [6, 1, 0, 3]]]),\n-            names: [],\n-            sources: ['lib/b.js', 'lib/c.js'],\n-            version: 3\n+          const bSource =\n+              new SourceFile(_('/foo/src/lib/b.js'), 'abcdef', bToCSourceMap, [cSource1], fs);\n+\n+          const aToBCSourceMap: SourceMapInfo = {\n+            mapPath: null,\n+            map: {\n+              mappings:\n+                  encode([[[0, 0, 0, 0], [2, 0, 0, 3], [4, 0, 0, 2], [5, 0, 0, 5], [6, 1, 0, 3]]]),\n+              names: [],\n+              sources: ['lib/b.js', 'lib/c.js'],\n+              version: 3,\n+            },\n+            origin: ContentOrigin.Provided,\n           };\n           const aSource = new SourceFile(\n-              _('/foo/src/a.js'), 'abdecf123', aToBCSourceMap, false, [bSource, cSource2], fs);\n+              _('/foo/src/a.js'), 'abdecf123', aToBCSourceMap, [bSource, cSource2], fs);\n \n           const aTocSourceMap = aSource.renderFlattenedSourceMap();\n           expect(aTocSourceMap.version).toEqual(3);\n@@ -562,46 +602,54 @@ runInEachFileSystem(() => {\n \n       describe('getOriginalLocation()', () => {\n         it('should return null for source files with no flattened mappings', () => {\n-          const sourceFile =\n-              new SourceFile(_('/foo/src/index.js'), 'index contents', null, false, [], fs);\n+          const sourceFile = new SourceFile(_('/foo/src/index.js'), 'index contents', null, [], fs);\n           expect(sourceFile.getOriginalLocation(1, 1)).toEqual(null);\n         });\n \n         it('should return offset locations in multiple flattened original source files', () => {\n-          const cSource = new SourceFile(_('/foo/src/c.js'), 'bcd123', null, false, [], fs);\n-          const dSource = new SourceFile(_('/foo/src/d.js'), 'aef', null, false, [], fs);\n-\n-          const bSourceMap: RawSourceMap = {\n-            mappings: encode([\n-              [\n-                [0, 1, 0, 0],  // \"a\" is in d.js [source 1]\n-                [1, 0, 0, 0],  // \"bcd\" are in c.js [source 0]\n-                [4, 1, 0, 1],  // \"ef\" are in d.js [source 1]\n-              ],\n-            ]),\n-            names: [],\n-            sources: ['c.js', 'd.js'],\n-            version: 3\n+          const cSource = new SourceFile(_('/foo/src/c.js'), 'bcd123', null, [], fs);\n+          const dSource = new SourceFile(_('/foo/src/d.js'), 'aef', null, [], fs);\n+\n+          const bSourceMap: SourceMapInfo = {\n+            mapPath: null,\n+            map: {\n+              mappings: encode([\n+                [\n+                  [0, 1, 0, 0],  // \"a\" is in d.js [source 1]\n+                  [1, 0, 0, 0],  // \"bcd\" are in c.js [source 0]\n+                  [4, 1, 0, 1],  // \"ef\" are in d.js [source 1]\n+                ],\n+              ]),\n+              names: [],\n+              sources: ['c.js', 'd.js'],\n+              version: 3\n+            },\n+            origin: ContentOrigin.Provided,\n           };\n-          const bSource = new SourceFile(\n-              _('/foo/src/b.js'), 'abcdef', bSourceMap, false, [cSource, dSource], fs);\n-\n-          const aSourceMap: RawSourceMap = {\n-            mappings: encode([\n-              [\n-                [0, 0, 0, 0], [2, 0, 0, 3],  // \"c\" is missing from first line\n-              ],\n-              [\n-                [4, 0, 0, 2],  // second line has new indentation, and starts with \"c\"\n-                [5, 0, 0, 5],  // \"f\" is here\n-              ],\n-            ]),\n-            names: [],\n-            sources: ['b.js'],\n-            version: 3\n+          const bSource =\n+              new SourceFile(_('/foo/src/b.js'), 'abcdef', bSourceMap, [cSource, dSource], fs);\n+\n+          const aSourceMap: SourceMapInfo = {\n+            mapPath: null,\n+            map: {\n+              mappings: encode([\n+                [\n+                  [0, 0, 0, 0], [2, 0, 0, 3],  // \"c\" is missing from first line\n+                ],\n+                [\n+                  [4, 0, 0, 2],  // second line has new indentation, and starts\n+                                 // with \"c\"\n+                  [5, 0, 0, 5],  // \"f\" is here\n+                ],\n+              ]),\n+              names: [],\n+              sources: ['b.js'],\n+              version: 3\n+            },\n+            origin: ContentOrigin.Provided,\n           };\n           const aSource =\n-              new SourceFile(_('/foo/src/a.js'), 'abde\\n    cf', aSourceMap, false, [bSource], fs);\n+              new SourceFile(_('/foo/src/a.js'), 'abde\\n    cf', aSourceMap, [bSource], fs);\n \n           // Line 0\n           expect(aSource.getOriginalLocation(0, 0))  // a\n@@ -633,28 +681,32 @@ runInEachFileSystem(() => {\n         });\n \n         it('should return offset locations across multiple lines', () => {\n-          const originalSource = new SourceFile(\n-              _('/foo/src/original.js'), 'abcdef\\nghijk\\nlmnop', null, false, [], fs);\n-          const generatedSourceMap: RawSourceMap = {\n-            mappings: encode([\n-              [\n-                [0, 0, 0, 0],  // \"ABC\" [0,0] => [0,0]\n-              ],\n-              [\n-                [0, 0, 1, 0],  // \"GHIJ\" [1, 0] => [1,0]\n-                [4, 0, 0, 3],  // \"DEF\" [1, 4] => [0,3]\n-                [7, 0, 1, 4],  // \"K\" [1, 7] => [1,4]\n-              ],\n-              [\n-                [0, 0, 2, 0],  // \"LMNOP\" [2,0] => [2,0]\n-              ],\n-            ]),\n-            names: [],\n-            sources: ['original.js'],\n-            version: 3\n+          const originalSource =\n+              new SourceFile(_('/foo/src/original.js'), 'abcdef\\nghijk\\nlmnop', null, [], fs);\n+          const generatedSourceMap: SourceMapInfo = {\n+            mapPath: null,\n+            map: {\n+              mappings: encode([\n+                [\n+                  [0, 0, 0, 0],  // \"ABC\" [0,0] => [0,0]\n+                ],\n+                [\n+                  [0, 0, 1, 0],  // \"GHIJ\" [1, 0] => [1,0]\n+                  [4, 0, 0, 3],  // \"DEF\" [1, 4] => [0,3]\n+                  [7, 0, 1, 4],  // \"K\" [1, 7] => [1,4]\n+                ],\n+                [\n+                  [0, 0, 2, 0],  // \"LMNOP\" [2,0] => [2,0]\n+                ],\n+              ]),\n+              names: [],\n+              sources: ['original.js'],\n+              version: 3\n+            },\n+            origin: ContentOrigin.Provided,\n           };\n           const generatedSource = new SourceFile(\n-              _('/foo/src/generated.js'), 'ABC\\nGHIJDEFK\\nLMNOP', generatedSourceMap, false,\n+              _('/foo/src/generated.js'), 'ABC\\nGHIJDEFK\\nLMNOP', generatedSourceMap,\n               [originalSource], fs);\n \n           // Line 0"
        }
    ],
    "stats": {
        "total": 785,
        "additions": 514,
        "deletions": 271
    }
}