{
    "author": "atscott",
    "message": "fix(router): Router should focus element after scrolling (#40241)\n\nAccording to the [spec](https://html.spec.whatwg.org/#scroll-to-fragid),\nwe should attempt to set the browser focus after scrolling to a\nfragment. Note that this change does not exactly follow the robust steps\noutlined in the spec by finding a fallback target if the original is not\nfocusable. Instead, we simply attempt to focus the element by calling\n`focus` on it, which will do nothing if the element is not focusable.\n\nfixes #30067\n\nPR Close #40241",
    "sha": "4eac7e643687ec992fee323941064da79037f053",
    "files": [
        {
            "sha": "d74fdbe9d9d8bcfbc9caa6f03b55ee68d1435081",
            "filename": "packages/common/src/viewport_scroller.ts",
            "status": "modified",
            "additions": 48,
            "deletions": 11,
            "changes": 59,
            "blob_url": "https://github.com/angular/angular/blob/4eac7e643687ec992fee323941064da79037f053/packages%2Fcommon%2Fsrc%2Fviewport_scroller.ts",
            "raw_url": "https://github.com/angular/angular/raw/4eac7e643687ec992fee323941064da79037f053/packages%2Fcommon%2Fsrc%2Fviewport_scroller.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcommon%2Fsrc%2Fviewport_scroller.ts?ref=4eac7e643687ec992fee323941064da79037f053",
            "patch": "@@ -67,7 +67,7 @@ export abstract class ViewportScroller {\n export class BrowserViewportScroller implements ViewportScroller {\n   private offset: () => [number, number] = () => [0, 0];\n \n-  constructor(private document: any, private window: any) {}\n+  constructor(private document: Document, private window: Window) {}\n \n   /**\n    * Configures the top offset used when scrolling to an anchor.\n@@ -106,17 +106,33 @@ export class BrowserViewportScroller implements ViewportScroller {\n   }\n \n   /**\n-   * Scrolls to an anchor element.\n-   * @param anchor The ID of the anchor element.\n+   * Scrolls to an element and attempts to focus the element.\n+   *\n+   * Note that the function name here is misleading in that the target string may be an ID for a\n+   * non-anchor element.\n+   *\n+   * @param target The ID of an element or name of the anchor.\n+   *\n+   * @see https://html.spec.whatwg.org/#the-indicated-part-of-the-document\n+   * @see https://html.spec.whatwg.org/#scroll-to-fragid\n    */\n-  scrollToAnchor(anchor: string): void {\n-    if (this.supportsScrolling()) {\n-      const elSelected =\n-          this.document.getElementById(anchor) || this.document.getElementsByName(anchor)[0];\n-      if (elSelected) {\n-        this.scrollToElement(elSelected);\n-      }\n+  scrollToAnchor(target: string): void {\n+    if (!this.supportsScrolling()) {\n+      return;\n     }\n+    // TODO(atscott): The correct behavior for `getElementsByName` would be to also verify that the\n+    // element is an anchor. However, this could be considered a breaking change and should be\n+    // done in a major version.\n+    const elSelected: HTMLElement|undefined =\n+        this.document.getElementById(target) ?? this.document.getElementsByName(target)[0];\n+    if (elSelected === undefined) {\n+      return;\n+    }\n+\n+    this.scrollToElement(elSelected);\n+    // After scrolling to the element, the spec dictates that we follow the focus steps for the\n+    // target. Rather than following the robust steps, simply attempt focus.\n+    this.attemptFocus(elSelected);\n   }\n \n   /**\n@@ -131,14 +147,35 @@ export class BrowserViewportScroller implements ViewportScroller {\n     }\n   }\n \n-  private scrollToElement(el: any): void {\n+  /**\n+   * Scrolls to an element using the native offset and the specified offset set on this scroller.\n+   *\n+   * The offset can be used when we know that there is a floating header and scrolling naively to an\n+   * element (ex: `scrollIntoView`) leaves the element hidden behind the floating header.\n+   */\n+  private scrollToElement(el: HTMLElement): void {\n     const rect = el.getBoundingClientRect();\n     const left = rect.left + this.window.pageXOffset;\n     const top = rect.top + this.window.pageYOffset;\n     const offset = this.offset();\n     this.window.scrollTo(left - offset[0], top - offset[1]);\n   }\n \n+  /**\n+   * Calls `focus` on the `focusTarget` and returns `true` if the element was focused successfully.\n+   *\n+   * If `false`, further steps may be necessary to determine a valid substitute to be focused\n+   * instead.\n+   *\n+   * @see https://html.spec.whatwg.org/#get-the-focusable-area\n+   * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLOrForeignElement/focus\n+   * @see https://html.spec.whatwg.org/#focusable-area\n+   */\n+  private attemptFocus(focusTarget: HTMLElement): boolean {\n+    focusTarget.focus();\n+    return this.document.activeElement === focusTarget;\n+  }\n+\n   /**\n    * We only support scroll restoration when we can get a hold of window.\n    * This means that we do not support this behavior when running in a web worker."
        }
    ],
    "stats": {
        "total": 59,
        "additions": 48,
        "deletions": 11
    }
}