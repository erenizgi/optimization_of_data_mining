{
    "author": "atscott",
    "message": "fix(compiler): Don't set expression text to synthetic `$implicit` when empty (#40583)\n\nWhen parsing interpolations, if we encounter an empty interpolation\n(`{{}}`), the current code uses a \"pretend\" value of `$implicit` for the\nname as if the interplotion were really `{{$implicit}}`. This is\nproblematic because the spans are then incorrect downstream since they\nare based off of the `$implicit` text.\n\nThis commit changes the interpretation of empty interpolations so that\nthe text is simply an empty string.\n\nFixes https://github.com/angular/vscode-ng-language-service/issues/1077\nFixes https://github.com/angular/vscode-ng-language-service/issues/1078\n\nPR Close #40583",
    "sha": "6b4909c588213e689530bb14dc884000d06921ff",
    "files": [
        {
            "sha": "de8f485b8c33e948ff9cca0099ca9bb746d09e02",
            "filename": "packages/compiler/src/expression_parser/parser.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 5,
            "changes": 15,
            "blob_url": "https://github.com/angular/angular/blob/6b4909c588213e689530bb14dc884000d06921ff/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "raw_url": "https://github.com/angular/angular/raw/6b4909c588213e689530bb14dc884000d06921ff/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Fsrc%2Fexpression_parser%2Fparser.ts?ref=6b4909c588213e689530bb14dc884000d06921ff",
            "patch": "@@ -243,14 +243,12 @@ export class Parser {\n         const fullEnd = exprEnd + interpEnd.length;\n \n         const text = input.substring(exprStart, exprEnd);\n-        if (text.trim().length > 0) {\n-          expressions.push({text, start: fullStart, end: fullEnd});\n-        } else {\n+        if (text.trim().length === 0) {\n           this._reportError(\n               'Blank expressions are not allowed in interpolated strings', input,\n               `at column ${i} in`, location);\n-          expressions.push({text: '$implicit', start: fullStart, end: fullEnd});\n         }\n+        expressions.push({text, start: fullStart, end: fullEnd});\n         offsets.push(exprStart);\n \n         i = fullEnd;\n@@ -571,7 +569,14 @@ export class _ParseAST {\n         this.error(`Unexpected token '${this.next}'`);\n       }\n     }\n-    if (exprs.length == 0) return new EmptyExpr(this.span(start), this.sourceSpan(start));\n+    if (exprs.length == 0) {\n+      // We have no expressions so create an empty expression that spans the entire input length\n+      const artificialStart = this.offset;\n+      const artificialEnd = this.offset + this.inputLength;\n+      return new EmptyExpr(\n+          this.span(artificialStart, artificialEnd),\n+          this.sourceSpan(artificialStart, artificialEnd));\n+    }\n     if (exprs.length == 1) return exprs[0];\n     return new Chain(this.span(start), this.sourceSpan(start), exprs);\n   }"
        },
        {
            "sha": "5e5004f5b16487fe4678d456c714c3ece94dec9d",
            "filename": "packages/compiler/test/expression_parser/parser_spec.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/angular/angular/blob/6b4909c588213e689530bb14dc884000d06921ff/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "raw_url": "https://github.com/angular/angular/raw/6b4909c588213e689530bb14dc884000d06921ff/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Fcompiler%2Ftest%2Fexpression_parser%2Fparser_spec.ts?ref=6b4909c588213e689530bb14dc884000d06921ff",
            "patch": "@@ -6,7 +6,7 @@\n  * found in the LICENSE file at https://angular.io/license\n  */\n \n-import {AbsoluteSourceSpan, ASTWithSource, BindingPipe, Interpolation, ParserError, TemplateBinding, VariableBinding} from '@angular/compiler/src/expression_parser/ast';\n+import {AbsoluteSourceSpan, ASTWithSource, BindingPipe, EmptyExpr, Interpolation, ParserError, TemplateBinding, VariableBinding} from '@angular/compiler/src/expression_parser/ast';\n import {Lexer} from '@angular/compiler/src/expression_parser/lexer';\n import {IvyParser, Parser, SplitInterpolation} from '@angular/compiler/src/expression_parser/parser';\n import {expect} from '@angular/platform-browser/testing/src/matchers';\n@@ -910,6 +910,12 @@ describe('parser', () => {\n           'Parser Error: Blank expressions are not allowed in interpolated strings');\n     });\n \n+    it('should produce an empty expression ast for empty interpolations', () => {\n+      const parsed = parseInterpolation('{{}}')!.ast as Interpolation;\n+      expect(parsed.expressions.length).toBe(1);\n+      expect(parsed.expressions[0]).toBeAnInstanceOf(EmptyExpr);\n+    });\n+\n     it('should parse conditional expression', () => {\n       checkInterpolation('{{ a < b ? a : b }}');\n     });"
        },
        {
            "sha": "1005e7acbe62fd45ed3472a112a5446750c7ded8",
            "filename": "packages/language-service/ivy/completions.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 7,
            "changes": 16,
            "blob_url": "https://github.com/angular/angular/blob/6b4909c588213e689530bb14dc884000d06921ff/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "raw_url": "https://github.com/angular/angular/raw/6b4909c588213e689530bb14dc884000d06921ff/packages%2Flanguage-service%2Fivy%2Fcompletions.ts",
            "contents_url": "https://api.github.com/repos/angular/angular/contents/packages%2Flanguage-service%2Fivy%2Fcompletions.ts?ref=6b4909c588213e689530bb14dc884000d06921ff",
            "patch": "@@ -220,12 +220,7 @@ export class CompletionBuilder<N extends TmplAstNode|AST> {\n \n     const {componentContext, templateContext} = completions;\n \n-    let replacementSpan: ts.TextSpan|undefined = undefined;\n-    // Non-empty nodes get replaced with the completion.\n-    if (!(this.node instanceof EmptyExpr || this.node instanceof LiteralPrimitive ||\n-          this.node instanceof BoundEvent)) {\n-      replacementSpan = makeReplacementSpanFromAst(this.node);\n-    }\n+    const replacementSpan = makeReplacementSpanFromAst(this.node);\n \n     // Merge TS completion results with results from the template scope.\n     let entries: ts.CompletionEntry[] = [];\n@@ -631,7 +626,14 @@ function makeReplacementSpanFromParseSourceSpan(span: ParseSourceSpan): ts.TextS\n }\n \n function makeReplacementSpanFromAst(node: PropertyRead|PropertyWrite|MethodCall|SafePropertyRead|\n-                                    SafeMethodCall|BindingPipe): ts.TextSpan {\n+                                    SafeMethodCall|BindingPipe|EmptyExpr|LiteralPrimitive|\n+                                    BoundEvent): ts.TextSpan|undefined {\n+  if ((node instanceof EmptyExpr || node instanceof LiteralPrimitive ||\n+       node instanceof BoundEvent)) {\n+    // empty nodes do not replace any existing text\n+    return undefined;\n+  }\n+\n   return {\n     start: node.nameSpan.start,\n     length: node.nameSpan.end - node.nameSpan.start,"
        }
    ],
    "stats": {
        "total": 39,
        "additions": 26,
        "deletions": 13
    }
}