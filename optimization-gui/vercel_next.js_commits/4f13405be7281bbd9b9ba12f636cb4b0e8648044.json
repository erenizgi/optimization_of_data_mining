{
    "author": "ztanner",
    "message": "fix: otel error spans from streamed responses (#86955)\n\nWhen an error is thrown inside a Suspense boundary during streaming SSR,\nthe error was not being captured in the \"render route (app)\" span. This\nhappened because `getTracer().wrap()` ends the span as soon as the\nstream is created and returned, but errors inside Suspense boundaries\noccur asynchronously during stream consumption.\n\nThis PR changes the span management from using `wrap()` to manually\ncalling `startSpan()` and tracking the span lifecycle. The span now\nstays open until `allReady` resolves or rejects. A new `withSpan()`\nhelper was added to the tracer to properly activate the span context so\nchild spans are parented. Error handlers now accept an optional\n`spanToRecordOn` parameter to record exceptions on the correct span\nrather than relying solely on the active scope span.\n\nFixes #86517",
    "sha": "4f13405be7281bbd9b9ba12f636cb4b0e8648044",
    "files": [
        {
            "sha": "edaf4076bb7431ff5498596e237074f58927002c",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 515,
            "deletions": 455,
            "changes": 970,
            "blob_url": "https://github.com/vercel/next.js/blob/4f13405be7281bbd9b9ba12f636cb4b0e8648044/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/4f13405be7281bbd9b9ba12f636cb4b0e8648044/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=4f13405be7281bbd9b9ba12f636cb4b0e8648044",
            "patch": "@@ -70,7 +70,7 @@ import {\n import { isRedirectError } from '../../client/components/redirect-error'\n import { getImplicitTags, type ImplicitTags } from '../lib/implicit-tags'\n import { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\n-import { getTracer } from '../lib/trace/tracer'\n+import { getTracer, SpanStatusCode } from '../lib/trace/tracer'\n import { FlightRenderResult } from './flight-render-result'\n import {\n   createReactServerErrorHandler,\n@@ -2203,17 +2203,6 @@ async function renderToHTMLOrFlightImpl(\n       }\n     }\n \n-    const renderToStreamWithTracing = getTracer().wrap(\n-      AppRenderSpan.getBodyResult,\n-      {\n-        spanName: `render route (app) ${pagePath}`,\n-        attributes: {\n-          'next.route': pagePath,\n-        },\n-      },\n-      renderToStream\n-    )\n-\n     let didExecuteServerAction = false\n     let formState: null | any = null\n     if (isPossibleActionRequest) {\n@@ -2238,7 +2227,7 @@ async function renderToHTMLOrFlightImpl(\n           const notFoundLoaderTree = createNotFoundLoaderTree(loaderTree)\n           res.statusCode = 404\n           metadata.statusCode = 404\n-          const stream = await renderToStreamWithTracing(\n+          const stream = await renderToStream(\n             requestStore,\n             req,\n             res,\n@@ -2275,7 +2264,7 @@ async function renderToHTMLOrFlightImpl(\n       contentType: HTML_CONTENT_TYPE_HEADER,\n     }\n \n-    const stream = await renderToStreamWithTracing(\n+    const stream = await renderToStream(\n       // NOTE: in Cache Components (dev), if the render is restarted, it will use a different requestStore\n       // than the one that we're passing in here.\n       requestStore,\n@@ -2581,471 +2570,372 @@ async function renderToStream(\n       ? `self.__next_r=${JSON.stringify(requestId)}`\n       : undefined\n \n-  const { reactServerErrorsByDigest } = workStore\n-  function onHTMLRenderRSCError(err: DigestedError, silenceLog: boolean) {\n-    return onInstrumentationRequestError?.(\n-      err,\n-      req,\n-      createErrorContext(ctx, 'react-server-components'),\n-      silenceLog\n-    )\n-  }\n-  const serverComponentsErrorHandler = createReactServerErrorHandler(\n-    dev,\n-    nextExport,\n-    reactServerErrorsByDigest,\n-    onHTMLRenderRSCError\n+  // Create the \"render route (app)\" span manually so we can keep it open during streaming.\n+  // This is necessary because errors inside Suspense boundaries are reported asynchronously\n+  // during stream consumption, after a typical wrapped function would have ended the span.\n+  // Note: We pass the full span name as the first argument since startSpan uses it directly.\n+  const renderSpan = getTracer().startSpan(\n+    `render route (app) ${pagePath}` as any,\n+    {\n+      attributes: {\n+        'next.span_name': `render route (app) ${pagePath}`,\n+        'next.span_type': AppRenderSpan.getBodyResult,\n+        'next.route': pagePath,\n+      },\n+    }\n   )\n \n-  function onHTMLRenderSSRError(err: DigestedError) {\n-    // We don't need to silence logs here. onHTMLRenderSSRError won't be called\n-    // at all if the error was logged before in the RSC error handler.\n-    const silenceLog = false\n-    return onInstrumentationRequestError?.(\n-      err,\n-      req,\n-      createErrorContext(ctx, 'server-rendering'),\n-      silenceLog\n-    )\n+  // Helper to end the span with error status (used when throwing from catch blocks)\n+  const endSpanWithError = (err: unknown) => {\n+    if (!renderSpan.isRecording()) return\n+    if (err instanceof Error) {\n+      renderSpan.recordException(err)\n+      renderSpan.setAttribute('error.type', err.name)\n+    }\n+    renderSpan.setStatus({\n+      code: SpanStatusCode.ERROR,\n+      message: err instanceof Error ? err.message : undefined,\n+    })\n+    renderSpan.end()\n   }\n \n-  const allCapturedErrors: Array<unknown> = []\n-  const htmlRendererErrorHandler = createHTMLErrorHandler(\n-    dev,\n-    nextExport,\n-    reactServerErrorsByDigest,\n-    allCapturedErrors,\n-    onHTMLRenderSSRError\n-  )\n-\n-  let reactServerResult: null | ReactServerResult = null\n-  let reactDebugStream: ReadableStream<Uint8Array> | undefined\n-\n-  const setHeader = res.setHeader.bind(res)\n-  const appendHeader = res.appendHeader.bind(res)\n-  const { clientModules } = getClientReferenceManifest()\n+  // Run the rest of the function within the span's context so child spans\n+  // (like \"build component tree\", \"generateMetadata\") are properly parented.\n+  return getTracer().withSpan(renderSpan, async () => {\n+    const { reactServerErrorsByDigest } = workStore\n+    function onHTMLRenderRSCError(err: DigestedError, silenceLog: boolean) {\n+      return onInstrumentationRequestError?.(\n+        err,\n+        req,\n+        createErrorContext(ctx, 'react-server-components'),\n+        silenceLog\n+      )\n+    }\n+    const serverComponentsErrorHandler = createReactServerErrorHandler(\n+      dev,\n+      nextExport,\n+      reactServerErrorsByDigest,\n+      onHTMLRenderRSCError,\n+      renderSpan\n+    )\n \n-  try {\n-    if (\n-      // We only want this behavior when we have React's dev builds available\n-      process.env.NODE_ENV === 'development' &&\n-      // We only want this behavior when running `next dev`\n-      dev &&\n-      // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n-      process.env.NEXT_RUNTIME !== 'edge' &&\n-      // We only have a Prerender environment for projects opted into cacheComponents\n-      cacheComponents\n-    ) {\n-      let debugChannel: DebugChannelPair | undefined\n+    function onHTMLRenderSSRError(err: DigestedError) {\n+      // We don't need to silence logs here. onHTMLRenderSSRError won't be called\n+      // at all if the error was logged before in the RSC error handler.\n+      const silenceLog = false\n+      return onInstrumentationRequestError?.(\n+        err,\n+        req,\n+        createErrorContext(ctx, 'server-rendering'),\n+        silenceLog\n+      )\n+    }\n \n-      const getPayload = async (\n-        // eslint-disable-next-line @typescript-eslint/no-shadow\n-        requestStore: RequestStore\n-      ) => {\n-        const payload: InitialRSCPayload & RSCPayloadDevProperties =\n-          await workUnitAsyncStorage.run(\n-            requestStore,\n-            getRSCPayload,\n-            tree,\n-            ctx,\n-            res.statusCode === 404\n-          )\n+    const allCapturedErrors: Array<unknown> = []\n+    const htmlRendererErrorHandler = createHTMLErrorHandler(\n+      dev,\n+      nextExport,\n+      reactServerErrorsByDigest,\n+      allCapturedErrors,\n+      onHTMLRenderSSRError,\n+      renderSpan\n+    )\n \n-        if (isBypassingCachesInDev(renderOpts, requestStore)) {\n-          // Mark the RSC payload to indicate that caches were bypassed in dev.\n-          // This lets the client know not to cache anything based on this render.\n-          if (renderOpts.setCacheStatus) {\n-            // we know this is available  when cacheComponents is enabled, but typeguard to be safe\n-            renderOpts.setCacheStatus('bypass', htmlRequestId)\n-          }\n-          payload._bypassCachesInDev = createElement(WarnForBypassCachesInDev, {\n-            route: workStore.route,\n-          })\n-        }\n+    let reactServerResult: null | ReactServerResult = null\n+    let reactDebugStream: ReadableStream<Uint8Array> | undefined\n \n-        return payload\n-      }\n+    const setHeader = res.setHeader.bind(res)\n+    const appendHeader = res.appendHeader.bind(res)\n+    const { clientModules } = getClientReferenceManifest()\n \n+    try {\n       if (\n-        // We only do this flow if we can safely recreate the store from scratch\n-        // (which is not the case for renders after an action)\n-        createRequestStore &&\n-        // We only do this flow if we're not bypassing caches in dev using\n-        // \"disable cache\" in devtools or a hard refresh (cache-control: \"no-store\")\n-        !isBypassingCachesInDev(renderOpts, requestStore)\n+        // We only want this behavior when we have React's dev builds available\n+        process.env.NODE_ENV === 'development' &&\n+        // We only want this behavior when running `next dev`\n+        dev &&\n+        // Edge routes never prerender so we don't have a Prerender environment for anything in edge runtime\n+        process.env.NEXT_RUNTIME !== 'edge' &&\n+        // We only have a Prerender environment for projects opted into cacheComponents\n+        cacheComponents\n       ) {\n-        const {\n-          stream: serverStream,\n-          accumulatedChunksPromise,\n-          staticInterruptReason,\n-          runtimeInterruptReason,\n-          staticStageEndTime,\n-          runtimeStageEndTime,\n-          debugChannel: returnedDebugChannel,\n-          requestStore: finalRequestStore,\n-        } = await renderWithRestartOnCacheMissInDev(\n-          ctx,\n-          requestStore,\n-          createRequestStore,\n-          getPayload,\n-          serverComponentsErrorHandler\n-        )\n-\n-        let validationDebugChannelClient: Readable | undefined = undefined\n-        if (returnedDebugChannel) {\n-          const [t1, t2] = returnedDebugChannel.clientSide.readable.tee()\n-          returnedDebugChannel.clientSide.readable = t1\n-          validationDebugChannelClient = nodeStreamFromReadableStream(t2)\n-        }\n-\n-        consoleAsyncStorage.run(\n-          { dim: true },\n-          spawnStaticShellValidationInDev,\n-          accumulatedChunksPromise,\n-          staticInterruptReason,\n-          runtimeInterruptReason,\n-          staticStageEndTime,\n-          runtimeStageEndTime,\n-          ctx,\n-          finalRequestStore,\n-          devFallbackParams,\n-          validationDebugChannelClient\n-        )\n+        let debugChannel: DebugChannelPair | undefined\n+\n+        const getPayload = async (\n+          // eslint-disable-next-line @typescript-eslint/no-shadow\n+          requestStore: RequestStore\n+        ) => {\n+          const payload: InitialRSCPayload & RSCPayloadDevProperties =\n+            await workUnitAsyncStorage.run(\n+              requestStore,\n+              getRSCPayload,\n+              tree,\n+              ctx,\n+              res.statusCode === 404\n+            )\n \n-        reactServerResult = new ReactServerResult(serverStream)\n-        requestStore = finalRequestStore\n-        debugChannel = returnedDebugChannel\n-      } else {\n-        // We're either bypassing caches or we can't restart the render.\n-        // Do a dynamic render, but with (basic) environment labels.\n+          if (isBypassingCachesInDev(renderOpts, requestStore)) {\n+            // Mark the RSC payload to indicate that caches were bypassed in dev.\n+            // This lets the client know not to cache anything based on this render.\n+            if (renderOpts.setCacheStatus) {\n+              // we know this is available  when cacheComponents is enabled, but typeguard to be safe\n+              renderOpts.setCacheStatus('bypass', htmlRequestId)\n+            }\n+            payload._bypassCachesInDev = createElement(\n+              WarnForBypassCachesInDev,\n+              {\n+                route: workStore.route,\n+              }\n+            )\n+          }\n \n-        debugChannel = setReactDebugChannel && createDebugChannel()\n+          return payload\n+        }\n \n-        const serverStream =\n-          await stagedRenderToReadableStreamWithoutCachesInDev(\n+        if (\n+          // We only do this flow if we can safely recreate the store from scratch\n+          // (which is not the case for renders after an action)\n+          createRequestStore &&\n+          // We only do this flow if we're not bypassing caches in dev using\n+          // \"disable cache\" in devtools or a hard refresh (cache-control: \"no-store\")\n+          !isBypassingCachesInDev(renderOpts, requestStore)\n+        ) {\n+          const {\n+            stream: serverStream,\n+            accumulatedChunksPromise,\n+            staticInterruptReason,\n+            runtimeInterruptReason,\n+            staticStageEndTime,\n+            runtimeStageEndTime,\n+            debugChannel: returnedDebugChannel,\n+            requestStore: finalRequestStore,\n+          } = await renderWithRestartOnCacheMissInDev(\n             ctx,\n             requestStore,\n+            createRequestStore,\n             getPayload,\n-            {\n-              onError: serverComponentsErrorHandler,\n-              filterStackFrame,\n-              debugChannel: debugChannel?.serverSide,\n-            }\n+            serverComponentsErrorHandler\n           )\n-        reactServerResult = new ReactServerResult(serverStream)\n-      }\n-\n-      if (debugChannel && setReactDebugChannel) {\n-        const [readableSsr, readableBrowser] =\n-          debugChannel.clientSide.readable.tee()\n-\n-        reactDebugStream = readableSsr\n \n-        setReactDebugChannel(\n-          { readable: readableBrowser },\n-          htmlRequestId,\n-          requestId\n-        )\n-      }\n-    } else {\n-      // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n-      const RSCPayload: RSCPayload & RSCPayloadDevProperties =\n-        await workUnitAsyncStorage.run(\n-          requestStore,\n-          getRSCPayload,\n-          tree,\n-          ctx,\n-          res.statusCode === 404\n-        )\n-\n-      const debugChannel = setReactDebugChannel && createDebugChannel()\n-\n-      if (debugChannel) {\n-        const [readableSsr, readableBrowser] =\n-          debugChannel.clientSide.readable.tee()\n-\n-        reactDebugStream = readableSsr\n-\n-        setReactDebugChannel(\n-          { readable: readableBrowser },\n-          htmlRequestId,\n-          requestId\n-        )\n-      }\n-\n-      reactServerResult = new ReactServerResult(\n-        workUnitAsyncStorage.run(\n-          requestStore,\n-          serverRenderToReadableStream,\n-          RSCPayload,\n-          clientModules,\n-          {\n-            filterStackFrame,\n-            onError: serverComponentsErrorHandler,\n-            debugChannel: debugChannel?.serverSide,\n+          let validationDebugChannelClient: Readable | undefined = undefined\n+          if (returnedDebugChannel) {\n+            const [t1, t2] = returnedDebugChannel.clientSide.readable.tee()\n+            returnedDebugChannel.clientSide.readable = t1\n+            validationDebugChannelClient = nodeStreamFromReadableStream(t2)\n           }\n-        )\n-      )\n-    }\n \n-    // React doesn't start rendering synchronously but we want the RSC render to have a chance to start\n-    // before we begin SSR rendering because we want to capture any available preload headers so we tick\n-    // one task before continuing\n-    await waitAtLeastOneReactRenderTask()\n-\n-    // If provided, the postpone state should be parsed as JSON so it can be\n-    // provided to React.\n-    if (typeof renderOpts.postponed === 'string') {\n-      if (postponedState?.type === DynamicState.DATA) {\n-        // We have a complete HTML Document in the prerender but we need to\n-        // still include the new server component render because it was not included\n-        // in the static prelude.\n-        const inlinedReactServerDataStream = createInlinedDataReadableStream(\n-          reactServerResult.tee(),\n-          nonce,\n-          formState\n-        )\n+          consoleAsyncStorage.run(\n+            { dim: true },\n+            spawnStaticShellValidationInDev,\n+            accumulatedChunksPromise,\n+            staticInterruptReason,\n+            runtimeInterruptReason,\n+            staticStageEndTime,\n+            runtimeStageEndTime,\n+            ctx,\n+            finalRequestStore,\n+            devFallbackParams,\n+            validationDebugChannelClient\n+          )\n \n-        return chainStreams(\n-          inlinedReactServerDataStream,\n-          createDocumentClosingStream()\n-        )\n-      } else if (postponedState) {\n-        // We assume we have dynamic HTML requiring a resume render to complete\n-        const { postponed, preludeState } =\n-          getPostponedFromState(postponedState)\n-        const resume = (\n-          require('react-dom/server') as typeof import('react-dom/server')\n-        ).resume\n-\n-        const htmlStream = await workUnitAsyncStorage.run(\n-          requestStore,\n-          resume,\n-          <App\n-            reactServerStream={reactServerResult.tee()}\n-            reactDebugStream={reactDebugStream}\n-            debugEndTime={undefined}\n-            preinitScripts={preinitScripts}\n-            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n-            nonce={nonce}\n-            images={ctx.renderOpts.images}\n-          />,\n-          postponed,\n-          { onError: htmlRendererErrorHandler, nonce }\n-        )\n+          reactServerResult = new ReactServerResult(serverStream)\n+          requestStore = finalRequestStore\n+          debugChannel = returnedDebugChannel\n+        } else {\n+          // We're either bypassing caches or we can't restart the render.\n+          // Do a dynamic render, but with (basic) environment labels.\n \n-        const getServerInsertedHTML = makeGetServerInsertedHTML({\n-          polyfills,\n-          renderServerInsertedHTML,\n-          serverCapturedErrors: allCapturedErrors,\n-          basePath,\n-          tracingMetadata: tracingMetadata,\n-        })\n-        return await continueDynamicHTMLResume(htmlStream, {\n-          // If the prelude is empty (i.e. is no static shell), we should wait for initial HTML to be rendered\n-          // to avoid injecting RSC data too early.\n-          // If we have a non-empty-prelude (i.e. a static HTML shell), then it's already been sent separately,\n-          // so we shouldn't wait for any HTML to be emitted from the resume before sending RSC data.\n-          delayDataUntilFirstHtmlChunk:\n-            preludeState === DynamicHTMLPreludeState.Empty,\n-          inlinedDataStream: createInlinedDataReadableStream(\n-            reactServerResult.consume(),\n-            nonce,\n-            formState\n-          ),\n-          getServerInsertedHTML,\n-          getServerInsertedMetadata,\n-        })\n-      }\n-    }\n+          debugChannel = setReactDebugChannel && createDebugChannel()\n \n-    // This is a regular dynamic render\n-    const renderToReadableStream = (\n-      require('react-dom/server') as typeof import('react-dom/server')\n-    ).renderToReadableStream\n+          const serverStream =\n+            await stagedRenderToReadableStreamWithoutCachesInDev(\n+              ctx,\n+              requestStore,\n+              getPayload,\n+              {\n+                onError: serverComponentsErrorHandler,\n+                filterStackFrame,\n+                debugChannel: debugChannel?.serverSide,\n+              }\n+            )\n+          reactServerResult = new ReactServerResult(serverStream)\n+        }\n \n-    const htmlStream = await workUnitAsyncStorage.run(\n-      requestStore,\n-      renderToReadableStream,\n-      <App\n-        reactServerStream={reactServerResult.tee()}\n-        reactDebugStream={reactDebugStream}\n-        debugEndTime={undefined}\n-        preinitScripts={preinitScripts}\n-        ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n-        nonce={nonce}\n-        images={ctx.renderOpts.images}\n-      />,\n-      {\n-        onError: htmlRendererErrorHandler,\n-        nonce,\n-        onHeaders: (headers: Headers) => {\n-          headers.forEach((value, key) => {\n-            appendHeader(key, value)\n-          })\n-        },\n-        maxHeadersLength: reactMaxHeadersLength,\n-        bootstrapScriptContent,\n-        bootstrapScripts: [bootstrapScript],\n-        formState,\n-      }\n-    )\n+        if (debugChannel && setReactDebugChannel) {\n+          const [readableSsr, readableBrowser] =\n+            debugChannel.clientSide.readable.tee()\n \n-    const getServerInsertedHTML = makeGetServerInsertedHTML({\n-      polyfills,\n-      renderServerInsertedHTML,\n-      serverCapturedErrors: allCapturedErrors,\n-      basePath,\n-      tracingMetadata: tracingMetadata,\n-    })\n-    /**\n-     * Rules of Static & Dynamic HTML:\n-     *\n-     *    1.) We must generate static HTML unless the caller explicitly opts\n-     *        in to dynamic HTML support.\n-     *\n-     *    2.) If dynamic HTML support is requested, we must honor that request\n-     *        or throw an error. It is the sole responsibility of the caller to\n-     *        ensure they aren't e.g. requesting dynamic HTML for a static page.\n-     *\n-     *   3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n-     *       resolve all suspenses and generate a full HTML. e.g. when it's a\n-     *       html limited bot requests, we produce the full HTML content.\n-     *\n-     * These rules help ensure that other existing features like request caching,\n-     * coalescing, and ISR continue working as intended.\n-     */\n-    const generateStaticHTML =\n-      supportsDynamicResponse !== true || !!shouldWaitOnAllReady\n-\n-    return await continueFizzStream(htmlStream, {\n-      inlinedDataStream: createInlinedDataReadableStream(\n-        reactServerResult.consume(),\n-        nonce,\n-        formState\n-      ),\n-      isStaticGeneration: generateStaticHTML,\n-      isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === true,\n-      buildId: ctx.workStore.buildId,\n-      getServerInsertedHTML,\n-      getServerInsertedMetadata,\n-      validateRootLayout: dev,\n-    })\n-  } catch (err) {\n-    if (\n-      isStaticGenBailoutError(err) ||\n-      (typeof err === 'object' &&\n-        err !== null &&\n-        'message' in err &&\n-        typeof err.message === 'string' &&\n-        err.message.includes(\n-          'https://nextjs.org/docs/advanced-features/static-html-export'\n-        ))\n-    ) {\n-      // Ensure that \"next dev\" prints the red error overlay\n-      throw err\n-    }\n+          reactDebugStream = readableSsr\n \n-    // If a bailout made it to this point, it means it wasn't wrapped inside\n-    // a suspense boundary.\n-    const shouldBailoutToCSR = isBailoutToCSRError(err)\n-    if (shouldBailoutToCSR) {\n-      const stack = getStackWithoutErrorMessage(err)\n-      error(\n-        `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n-      )\n+          setReactDebugChannel(\n+            { readable: readableBrowser },\n+            htmlRequestId,\n+            requestId\n+          )\n+        }\n+      } else {\n+        // This is a dynamic render. We don't do dynamic tracking because we're not prerendering\n+        const RSCPayload: RSCPayload & RSCPayloadDevProperties =\n+          await workUnitAsyncStorage.run(\n+            requestStore,\n+            getRSCPayload,\n+            tree,\n+            ctx,\n+            res.statusCode === 404\n+          )\n \n-      throw err\n-    }\n+        const debugChannel = setReactDebugChannel && createDebugChannel()\n \n-    let errorType: MetadataErrorType | 'redirect' | undefined\n+        if (debugChannel) {\n+          const [readableSsr, readableBrowser] =\n+            debugChannel.clientSide.readable.tee()\n \n-    if (isHTTPAccessFallbackError(err)) {\n-      res.statusCode = getAccessFallbackHTTPStatus(err)\n-      metadata.statusCode = res.statusCode\n-      errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n-    } else if (isRedirectError(err)) {\n-      errorType = 'redirect'\n-      res.statusCode = getRedirectStatusCodeFromError(err)\n-      metadata.statusCode = res.statusCode\n+          reactDebugStream = readableSsr\n \n-      const redirectUrl = addPathPrefix(getURLFromRedirectError(err), basePath)\n+          setReactDebugChannel(\n+            { readable: readableBrowser },\n+            htmlRequestId,\n+            requestId\n+          )\n+        }\n \n-      // If there were mutable cookies set, we need to set them on the\n-      // response.\n-      const headers = new Headers()\n-      if (appendMutableCookies(headers, requestStore.mutableCookies)) {\n-        setHeader('set-cookie', Array.from(headers.values()))\n+        reactServerResult = new ReactServerResult(\n+          workUnitAsyncStorage.run(\n+            requestStore,\n+            serverRenderToReadableStream,\n+            RSCPayload,\n+            clientModules,\n+            {\n+              filterStackFrame,\n+              onError: serverComponentsErrorHandler,\n+              debugChannel: debugChannel?.serverSide,\n+            }\n+          )\n+        )\n       }\n \n-      setHeader('location', redirectUrl)\n-    } else if (!shouldBailoutToCSR) {\n-      res.statusCode = 500\n-      metadata.statusCode = res.statusCode\n-    }\n+      // React doesn't start rendering synchronously but we want the RSC render to have a chance to start\n+      // before we begin SSR rendering because we want to capture any available preload headers so we tick\n+      // one task before continuing\n+      await waitAtLeastOneReactRenderTask()\n+\n+      // If provided, the postpone state should be parsed as JSON so it can be\n+      // provided to React.\n+      if (typeof renderOpts.postponed === 'string') {\n+        if (postponedState?.type === DynamicState.DATA) {\n+          // We have a complete HTML Document in the prerender but we need to\n+          // still include the new server component render because it was not included\n+          // in the static prelude.\n+          const inlinedReactServerDataStream = createInlinedDataReadableStream(\n+            reactServerResult.tee(),\n+            nonce,\n+            formState\n+          )\n \n-    const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n-      buildManifest,\n-      assetPrefix,\n-      crossOrigin,\n-      subresourceIntegrityManifest,\n-      getAssetQueryString(ctx, false),\n-      nonce,\n-      '/_not-found/page'\n-    )\n+          // End the span since there's no async rendering in this path\n+          if (renderSpan.isRecording()) renderSpan.end()\n+          return chainStreams(\n+            inlinedReactServerDataStream,\n+            createDocumentClosingStream()\n+          )\n+        } else if (postponedState) {\n+          // We assume we have dynamic HTML requiring a resume render to complete\n+          const { postponed, preludeState } =\n+            getPostponedFromState(postponedState)\n+          const resume = (\n+            require('react-dom/server') as typeof import('react-dom/server')\n+          ).resume\n \n-    const errorRSCPayload = await workUnitAsyncStorage.run(\n-      requestStore,\n-      getErrorRSCPayload,\n-      tree,\n-      ctx,\n-      reactServerErrorsByDigest.has((err as any).digest) ? null : err,\n-      errorType\n-    )\n+          const htmlStream = await workUnitAsyncStorage.run(\n+            requestStore,\n+            resume,\n+            <App\n+              reactServerStream={reactServerResult.tee()}\n+              reactDebugStream={reactDebugStream}\n+              debugEndTime={undefined}\n+              preinitScripts={preinitScripts}\n+              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n+              nonce={nonce}\n+              images={ctx.renderOpts.images}\n+            />,\n+            postponed,\n+            { onError: htmlRendererErrorHandler, nonce }\n+          )\n \n-    const errorServerStream = workUnitAsyncStorage.run(\n-      requestStore,\n-      serverRenderToReadableStream,\n-      errorRSCPayload,\n-      clientModules,\n-      {\n-        filterStackFrame,\n-        onError: serverComponentsErrorHandler,\n+          // End the render span only after React completed rendering (including anything inside Suspense boundaries)\n+          htmlStream.allReady.finally(() => {\n+            if (renderSpan.isRecording()) renderSpan.end()\n+          })\n+\n+          const getServerInsertedHTML = makeGetServerInsertedHTML({\n+            polyfills,\n+            renderServerInsertedHTML,\n+            serverCapturedErrors: allCapturedErrors,\n+            basePath,\n+            tracingMetadata: tracingMetadata,\n+          })\n+          return await continueDynamicHTMLResume(htmlStream, {\n+            // If the prelude is empty (i.e. is no static shell), we should wait for initial HTML to be rendered\n+            // to avoid injecting RSC data too early.\n+            // If we have a non-empty-prelude (i.e. a static HTML shell), then it's already been sent separately,\n+            // so we shouldn't wait for any HTML to be emitted from the resume before sending RSC data.\n+            delayDataUntilFirstHtmlChunk:\n+              preludeState === DynamicHTMLPreludeState.Empty,\n+            inlinedDataStream: createInlinedDataReadableStream(\n+              reactServerResult.consume(),\n+              nonce,\n+              formState\n+            ),\n+            getServerInsertedHTML,\n+            getServerInsertedMetadata,\n+          })\n+        }\n       }\n-    )\n \n-    if (reactServerResult === null) {\n-      // We errored when we did not have an RSC stream to read from. This is not just a render\n-      // error, we need to throw early\n-      throw err\n-    }\n+      // This is a regular dynamic render\n+      const renderToReadableStream = (\n+        require('react-dom/server') as typeof import('react-dom/server')\n+      ).renderToReadableStream\n \n-    try {\n-      const fizzStream = await workUnitAsyncStorage.run(\n+      const htmlStream = await workUnitAsyncStorage.run(\n         requestStore,\n-        renderToInitialFizzStream,\n+        renderToReadableStream,\n+        <App\n+          reactServerStream={reactServerResult.tee()}\n+          reactDebugStream={reactDebugStream}\n+          debugEndTime={undefined}\n+          preinitScripts={preinitScripts}\n+          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n+          nonce={nonce}\n+          images={ctx.renderOpts.images}\n+        />,\n         {\n-          ReactDOMServer:\n-            require('react-dom/server') as typeof import('react-dom/server'),\n-          element: (\n-            <ErrorApp\n-              reactServerStream={errorServerStream}\n-              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n-              preinitScripts={errorPreinitScripts}\n-              nonce={nonce}\n-              images={ctx.renderOpts.images}\n-            />\n-          ),\n-          streamOptions: {\n-            nonce,\n-            bootstrapScriptContent,\n-            // Include hydration scripts in the HTML\n-            bootstrapScripts: [errorBootstrapScript],\n-            formState,\n+          onError: htmlRendererErrorHandler,\n+          nonce,\n+          onHeaders: (headers: Headers) => {\n+            headers.forEach((value, key) => {\n+              appendHeader(key, value)\n+            })\n           },\n+          maxHeadersLength: reactMaxHeadersLength,\n+          bootstrapScriptContent,\n+          bootstrapScripts: [bootstrapScript],\n+          formState,\n         }\n       )\n \n+      // End the render span only after React completed rendering (including anything inside Suspense boundaries)\n+      htmlStream.allReady.finally(() => {\n+        if (renderSpan.isRecording()) renderSpan.end()\n+      })\n+\n+      const getServerInsertedHTML = makeGetServerInsertedHTML({\n+        polyfills,\n+        renderServerInsertedHTML,\n+        serverCapturedErrors: allCapturedErrors,\n+        basePath,\n+        tracingMetadata: tracingMetadata,\n+      })\n       /**\n        * Rules of Static & Dynamic HTML:\n        *\n@@ -3055,49 +2945,219 @@ async function renderToStream(\n        *    2.) If dynamic HTML support is requested, we must honor that request\n        *        or throw an error. It is the sole responsibility of the caller to\n        *        ensure they aren't e.g. requesting dynamic HTML for a static page.\n-       *    3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n-       *        resolve all suspenses and generate a full HTML. e.g. when it's a\n-       *        html limited bot requests, we produce the full HTML content.\n+       *\n+       *   3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n+       *       resolve all suspenses and generate a full HTML. e.g. when it's a\n+       *       html limited bot requests, we produce the full HTML content.\n        *\n        * These rules help ensure that other existing features like request caching,\n        * coalescing, and ISR continue working as intended.\n        */\n       const generateStaticHTML =\n         supportsDynamicResponse !== true || !!shouldWaitOnAllReady\n-      return await continueFizzStream(fizzStream, {\n+\n+      return await continueFizzStream(htmlStream, {\n         inlinedDataStream: createInlinedDataReadableStream(\n-          // This is intentionally using the readable datastream from the\n-          // main render rather than the flight data from the error page\n-          // render\n           reactServerResult.consume(),\n           nonce,\n           formState\n         ),\n         isStaticGeneration: generateStaticHTML,\n         isBuildTimePrerendering: ctx.workStore.isBuildTimePrerendering === true,\n         buildId: ctx.workStore.buildId,\n-        getServerInsertedHTML: makeGetServerInsertedHTML({\n-          polyfills,\n-          renderServerInsertedHTML,\n-          serverCapturedErrors: [],\n-          basePath,\n-          tracingMetadata: tracingMetadata,\n-        }),\n+        getServerInsertedHTML,\n         getServerInsertedMetadata,\n         validateRootLayout: dev,\n       })\n-    } catch (finalErr: any) {\n+    } catch (err) {\n       if (\n-        process.env.NODE_ENV === 'development' &&\n-        isHTTPAccessFallbackError(finalErr)\n+        isStaticGenBailoutError(err) ||\n+        (typeof err === 'object' &&\n+          err !== null &&\n+          'message' in err &&\n+          typeof err.message === 'string' &&\n+          err.message.includes(\n+            'https://nextjs.org/docs/advanced-features/static-html-export'\n+          ))\n       ) {\n-        const { bailOnRootNotFound } =\n-          require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n-        bailOnRootNotFound()\n+        // Ensure that \"next dev\" prints the red error overlay\n+        endSpanWithError(err)\n+        throw err\n+      }\n+\n+      // If a bailout made it to this point, it means it wasn't wrapped inside\n+      // a suspense boundary.\n+      const shouldBailoutToCSR = isBailoutToCSRError(err)\n+      if (shouldBailoutToCSR) {\n+        const stack = getStackWithoutErrorMessage(err)\n+        error(\n+          `${err.reason} should be wrapped in a suspense boundary at page \"${pagePath}\". Read more: https://nextjs.org/docs/messages/missing-suspense-with-csr-bailout\\n${stack}`\n+        )\n+\n+        endSpanWithError(err)\n+        throw err\n+      }\n+\n+      let errorType: MetadataErrorType | 'redirect' | undefined\n+\n+      if (isHTTPAccessFallbackError(err)) {\n+        res.statusCode = getAccessFallbackHTTPStatus(err)\n+        metadata.statusCode = res.statusCode\n+        errorType = getAccessFallbackErrorTypeByStatus(res.statusCode)\n+      } else if (isRedirectError(err)) {\n+        errorType = 'redirect'\n+        res.statusCode = getRedirectStatusCodeFromError(err)\n+        metadata.statusCode = res.statusCode\n+\n+        const redirectUrl = addPathPrefix(\n+          getURLFromRedirectError(err),\n+          basePath\n+        )\n+\n+        // If there were mutable cookies set, we need to set them on the\n+        // response.\n+        const headers = new Headers()\n+        if (appendMutableCookies(headers, requestStore.mutableCookies)) {\n+          setHeader('set-cookie', Array.from(headers.values()))\n+        }\n+\n+        setHeader('location', redirectUrl)\n+      } else if (!shouldBailoutToCSR) {\n+        res.statusCode = 500\n+        metadata.statusCode = res.statusCode\n+      }\n+\n+      const [errorPreinitScripts, errorBootstrapScript] = getRequiredScripts(\n+        buildManifest,\n+        assetPrefix,\n+        crossOrigin,\n+        subresourceIntegrityManifest,\n+        getAssetQueryString(ctx, false),\n+        nonce,\n+        '/_not-found/page'\n+      )\n+\n+      let errorRSCPayload: InitialRSCPayload\n+      let errorServerStream: ReturnType<typeof serverRenderToReadableStream>\n+\n+      try {\n+        errorRSCPayload = await workUnitAsyncStorage.run(\n+          requestStore,\n+          getErrorRSCPayload,\n+          tree,\n+          ctx,\n+          reactServerErrorsByDigest.has((err as any).digest) ? null : err,\n+          errorType\n+        )\n+\n+        errorServerStream = workUnitAsyncStorage.run(\n+          requestStore,\n+          serverRenderToReadableStream,\n+          errorRSCPayload,\n+          clientModules,\n+          {\n+            filterStackFrame,\n+            onError: serverComponentsErrorHandler,\n+          }\n+        )\n+\n+        if (reactServerResult === null) {\n+          // We errored when we did not have an RSC stream to read from. This is not just a render\n+          // error, we need to throw early\n+          endSpanWithError(err)\n+          throw err\n+        }\n+      } catch (setupErr) {\n+        endSpanWithError(setupErr)\n+        throw setupErr\n+      }\n+\n+      try {\n+        const fizzStream = await workUnitAsyncStorage.run(\n+          requestStore,\n+          renderToInitialFizzStream,\n+          {\n+            ReactDOMServer:\n+              require('react-dom/server') as typeof import('react-dom/server'),\n+            element: (\n+              <ErrorApp\n+                reactServerStream={errorServerStream}\n+                ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n+                preinitScripts={errorPreinitScripts}\n+                nonce={nonce}\n+                images={ctx.renderOpts.images}\n+              />\n+            ),\n+            streamOptions: {\n+              nonce,\n+              bootstrapScriptContent,\n+              // Include hydration scripts in the HTML\n+              bootstrapScripts: [errorBootstrapScript],\n+              formState,\n+            },\n+          }\n+        )\n+\n+        // End the render span only after React completed rendering (including anything inside Suspense boundaries)\n+        fizzStream.allReady.finally(() => {\n+          if (renderSpan.isRecording()) renderSpan.end()\n+        })\n+\n+        /**\n+         * Rules of Static & Dynamic HTML:\n+         *\n+         *    1.) We must generate static HTML unless the caller explicitly opts\n+         *        in to dynamic HTML support.\n+         *\n+         *    2.) If dynamic HTML support is requested, we must honor that request\n+         *        or throw an error. It is the sole responsibility of the caller to\n+         *        ensure they aren't e.g. requesting dynamic HTML for a static page.\n+         *    3.) If `shouldWaitOnAllReady` is true, which indicates we need to\n+         *        resolve all suspenses and generate a full HTML. e.g. when it's a\n+         *        html limited bot requests, we produce the full HTML content.\n+         *\n+         * These rules help ensure that other existing features like request caching,\n+         * coalescing, and ISR continue working as intended.\n+         */\n+        const generateStaticHTML =\n+          supportsDynamicResponse !== true || !!shouldWaitOnAllReady\n+        return await continueFizzStream(fizzStream, {\n+          inlinedDataStream: createInlinedDataReadableStream(\n+            // This is intentionally using the readable datastream from the\n+            // main render rather than the flight data from the error page\n+            // render\n+            reactServerResult.consume(),\n+            nonce,\n+            formState\n+          ),\n+          isStaticGeneration: generateStaticHTML,\n+          isBuildTimePrerendering:\n+            ctx.workStore.isBuildTimePrerendering === true,\n+          buildId: ctx.workStore.buildId,\n+          getServerInsertedHTML: makeGetServerInsertedHTML({\n+            polyfills,\n+            renderServerInsertedHTML,\n+            serverCapturedErrors: [],\n+            basePath,\n+            tracingMetadata: tracingMetadata,\n+          }),\n+          getServerInsertedMetadata,\n+          validateRootLayout: dev,\n+        })\n+      } catch (finalErr: any) {\n+        if (\n+          process.env.NODE_ENV === 'development' &&\n+          isHTTPAccessFallbackError(finalErr)\n+        ) {\n+          const { bailOnRootNotFound } =\n+            require('../../client/components/dev-root-http-access-fallback-boundary') as typeof import('../../client/components/dev-root-http-access-fallback-boundary')\n+          bailOnRootNotFound()\n+        }\n+        endSpanWithError(finalErr)\n+        throw finalErr\n       }\n-      throw finalErr\n     }\n-  }\n+  })\n   /* eslint-enable @next/internal/no-ambiguous-jsx */\n }\n "
        },
        {
            "sha": "57f90bfa9077e52b8195db78a2c44dca7a4d3823",
            "filename": "packages/next/src/server/app-render/create-error-handler.tsx",
            "status": "modified",
            "additions": 19,
            "deletions": 16,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/4f13405be7281bbd9b9ba12f636cb4b0e8648044/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-error-handler.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/4f13405be7281bbd9b9ba12f636cb4b0e8648044/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-error-handler.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-error-handler.tsx?ref=4f13405be7281bbd9b9ba12f636cb4b0e8648044",
            "patch": "@@ -1,8 +1,9 @@\n import type { ErrorInfo } from 'react'\n-\n import stringHash from 'next/dist/compiled/string-hash'\n+\n import { formatServerError } from '../../lib/format-server-error'\n import { SpanStatusCode, getTracer } from '../lib/trace/tracer'\n+\n import { isAbortError } from '../pipe-readable'\n import { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\n import { isDynamicServerError } from '../../client/components/hooks-server-context'\n@@ -52,7 +53,8 @@ export function createReactServerErrorHandler(\n   shouldFormatError: boolean,\n   isNextExport: boolean,\n   reactServerErrors: Map<string, DigestedError>,\n-  onReactServerRenderError: (err: DigestedError, silenceLog: boolean) => void\n+  onReactServerRenderError: (err: DigestedError, silenceLog: boolean) => void,\n+  spanToRecordOn?: any\n ): RSCErrorHandler {\n   return (thrownValue: unknown) => {\n     if (typeof thrownValue === 'string') {\n@@ -125,8 +127,8 @@ export function createReactServerErrorHandler(\n         )\n       )\n     ) {\n-      // Record exception in an active span, if available.\n-      const span = getTracer().getActiveScopeSpan()\n+      // Record exception on the provided span if available, otherwise try active span.\n+      const span = spanToRecordOn ?? getTracer().getActiveScopeSpan()\n       if (span) {\n         span.recordException(err)\n         span.setAttribute('error.type', err.name)\n@@ -148,7 +150,8 @@ export function createHTMLErrorHandler(\n   isNextExport: boolean,\n   reactServerErrors: Map<string, DigestedError>,\n   allCapturedErrors: Array<unknown>,\n-  onHTMLRenderSSRError: (err: DigestedError, errorInfo?: ErrorInfo) => void\n+  onHTMLRenderSSRError: (err: DigestedError, errorInfo?: ErrorInfo) => void,\n+  spanToRecordOn?: any\n ): SSRErrorHandler {\n   return (thrownValue: unknown, errorInfo?: ErrorInfo) => {\n     if (isReactLargeShellError(thrownValue)) {\n@@ -207,19 +210,19 @@ export function createHTMLErrorHandler(\n         )\n       )\n     ) {\n-      // Record exception in an active span, if available.\n-      const span = getTracer().getActiveScopeSpan()\n-      if (span) {\n-        span.recordException(err)\n-        span.setAttribute('error.type', err.name)\n-        span.setStatus({\n-          code: SpanStatusCode.ERROR,\n-          message: err.message,\n-        })\n-      }\n-\n       // HTML errors contain RSC errors as well, filter them out before reporting\n       if (isSSRError) {\n+        // Record exception on the provided span if available, otherwise try active span.\n+        const span = spanToRecordOn ?? getTracer().getActiveScopeSpan()\n+        if (span) {\n+          span.recordException(err)\n+          span.setAttribute('error.type', err.name)\n+          span.setStatus({\n+            code: SpanStatusCode.ERROR,\n+            message: err.message,\n+          })\n+        }\n+\n         onHTMLRenderSSRError(err, errorInfo)\n       }\n     }"
        },
        {
            "sha": "e6e1ec933497e1ae7e7e76e4230b7b8ea7a9ca0b",
            "filename": "packages/next/src/server/lib/trace/tracer.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/4f13405be7281bbd9b9ba12f636cb4b0e8648044/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Ftrace%2Ftracer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4f13405be7281bbd9b9ba12f636cb4b0e8648044/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Ftrace%2Ftracer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Ftrace%2Ftracer.ts?ref=4f13405be7281bbd9b9ba12f636cb4b0e8648044",
            "patch": "@@ -157,6 +157,12 @@ interface NextTracer {\n    * through the OpenTelemetry propagator API.\n    */\n   getTracePropagationData(): ClientTraceDataEntry[]\n+\n+  /**\n+   * Executes a function with the given span set as the active span in the context.\n+   * This allows child spans created within the function to automatically parent to this span.\n+   */\n+  withSpan<T>(span: Span, fn: () => T): T\n }\n \n type NextAttributeNames =\n@@ -479,6 +485,11 @@ class NextTracerImpl implements NextTracer {\n       attributes.set(key, value)\n     }\n   }\n+\n+  public withSpan<T>(span: Span, fn: () => T): T {\n+    const spanContext = trace.setSpan(context.active(), span)\n+    return context.with(spanContext, fn)\n+  }\n }\n \n const getTracer = (() => {"
        },
        {
            "sha": "125de1ed70c8aac9a8b1c7e56ed4af84d48d1eab",
            "filename": "test/e2e/opentelemetry/instrumentation/app/app/[param]/loading/error/page.tsx",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/4f13405be7281bbd9b9ba12f636cb4b0e8648044/test%2Fe2e%2Fopentelemetry%2Finstrumentation%2Fapp%2Fapp%2F%5Bparam%5D%2Floading%2Ferror%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/4f13405be7281bbd9b9ba12f636cb4b0e8648044/test%2Fe2e%2Fopentelemetry%2Finstrumentation%2Fapp%2Fapp%2F%5Bparam%5D%2Floading%2Ferror%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fopentelemetry%2Finstrumentation%2Fapp%2Fapp%2F%5Bparam%5D%2Floading%2Ferror%2Fpage.tsx?ref=4f13405be7281bbd9b9ba12f636cb4b0e8648044",
            "patch": "@@ -0,0 +1,8 @@\n+import { connection } from 'next/server'\n+\n+export default async function Page() {\n+  await connection()\n+  // Simulate async work before throwing\n+  await new Promise((resolve) => setTimeout(resolve, 100))\n+  throw new Error('Error inside Suspense boundary')\n+}"
        },
        {
            "sha": "ba2554ace63d484c62f7d5cad28425de84011f91",
            "filename": "test/e2e/opentelemetry/instrumentation/opentelemetry.test.ts",
            "status": "modified",
            "additions": 123,
            "deletions": 0,
            "changes": 123,
            "blob_url": "https://github.com/vercel/next.js/blob/4f13405be7281bbd9b9ba12f636cb4b0e8648044/test%2Fe2e%2Fopentelemetry%2Finstrumentation%2Fopentelemetry.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4f13405be7281bbd9b9ba12f636cb4b0e8648044/test%2Fe2e%2Fopentelemetry%2Finstrumentation%2Fopentelemetry.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fopentelemetry%2Finstrumentation%2Fopentelemetry.test.ts?ref=4f13405be7281bbd9b9ba12f636cb4b0e8648044",
            "patch": "@@ -613,6 +613,129 @@ describe('opentelemetry', () => {\n               },\n             ])\n           })\n+\n+          it('should handle error inside Suspense boundary', async () => {\n+            await next.fetch('/app/param/loading/error', env.fetchInit)\n+\n+            await expectTrace(getCollector(), [\n+              {\n+                name: 'GET /app/[param]/loading/error',\n+                attributes: {\n+                  'http.method': 'GET',\n+                  'http.route': '/app/[param]/loading/error',\n+                  // The response starts streaming before the error,\n+                  // so HTTP status is 200 (unlike synchronous errors which get 500)\n+                  'http.status_code': 200,\n+                  'http.target': '/app/param/loading/error',\n+                  'next.route': '/app/[param]/loading/error',\n+                  'next.rsc': false,\n+                  'next.span_name': 'GET /app/[param]/loading/error',\n+                  'next.span_type': 'BaseServer.handleRequest',\n+                },\n+                kind: 1,\n+                status: { code: 0 },\n+                traceId: env.span.traceId,\n+                parentId: env.span.rootParentId,\n+                spans: [\n+                  {\n+                    name: 'render route (app) /app/[param]/loading/error',\n+                    attributes: {\n+                      'next.route': '/app/[param]/loading/error',\n+                      'next.span_name':\n+                        'render route (app) /app/[param]/loading/error',\n+                      'next.span_type': 'AppRender.getBodyResult',\n+                      'error.type': 'Error',\n+                    },\n+                    kind: 0,\n+                    // The render span should have error status because an error\n+                    // was thrown inside a Suspense boundary during streaming\n+                    status: {\n+                      code: 2,\n+                      message: 'Error inside Suspense boundary',\n+                    },\n+                    spans: [\n+                      {\n+                        name: 'build component tree',\n+                        attributes: {\n+                          'next.span_name': 'build component tree',\n+                          'next.span_type':\n+                            'NextNodeServer.createComponentTree',\n+                        },\n+                        kind: 0,\n+                        status: { code: 0 },\n+                        spans: [\n+                          {\n+                            name: 'resolve segment modules',\n+                            attributes: {\n+                              'next.segment': '__PAGE__',\n+                              'next.span_name': 'resolve segment modules',\n+                              'next.span_type':\n+                                'NextNodeServer.getLayoutOrPageModule',\n+                            },\n+                            kind: 0,\n+                            status: { code: 0 },\n+                          },\n+                          {\n+                            name: 'resolve segment modules',\n+                            attributes: {\n+                              'next.segment': '[param]',\n+                              'next.span_name': 'resolve segment modules',\n+                              'next.span_type':\n+                                'NextNodeServer.getLayoutOrPageModule',\n+                            },\n+                            kind: 0,\n+                            status: { code: 0 },\n+                          },\n+                        ],\n+                      },\n+                      {\n+                        name: 'generateMetadata /app/[param]/layout',\n+                        attributes: {\n+                          'next.page': '/app/[param]/layout',\n+                          'next.span_name':\n+                            'generateMetadata /app/[param]/layout',\n+                          'next.span_type': 'ResolveMetadata.generateMetadata',\n+                        },\n+                        kind: 0,\n+                        status: { code: 0 },\n+                      },\n+                      {\n+                        attributes: {\n+                          'next.clientComponentLoadCount': isNextDev ? 7 : 6,\n+                          'next.span_type':\n+                            'NextNodeServer.clientComponentLoading',\n+                        },\n+                        kind: 0,\n+                        name: 'NextNodeServer.clientComponentLoading',\n+                        status: {\n+                          code: 0,\n+                        },\n+                      },\n+                      {\n+                        name: 'start response',\n+                        attributes: {\n+                          'next.span_name': 'start response',\n+                          'next.span_type': 'NextNodeServer.startResponse',\n+                        },\n+                        kind: 0,\n+                        status: { code: 0 },\n+                      },\n+                    ],\n+                  },\n+                  {\n+                    name: 'resolve page components',\n+                    attributes: {\n+                      'next.route': '/app/[param]/loading/error',\n+                      'next.span_name': 'resolve page components',\n+                      'next.span_type': 'NextNodeServer.findPageComponents',\n+                    },\n+                    kind: 0,\n+                    status: { code: 0 },\n+                  },\n+                ],\n+              },\n+            ])\n+          })\n         })\n \n         describe('pages', () => {"
        }
    ],
    "stats": {
        "total": 1147,
        "additions": 676,
        "deletions": 471
    }
}