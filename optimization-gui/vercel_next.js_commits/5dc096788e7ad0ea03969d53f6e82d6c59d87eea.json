{
    "author": "sokra",
    "message": "Turbopack: avoid panic in module batches (#76757)\n\nBecause of eventual consistency",
    "sha": "5dc096788e7ad0ea03969d53f6e82d6c59d87eea",
    "files": [
        {
            "sha": "683f51634ad479d405494626c6754b9df4c589a8",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/module_batches.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/5dc096788e7ad0ea03969d53f6e82d6c59d87eea/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dc096788e7ad0ea03969d53f6e82d6c59d87eea/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs?ref=5dc096788e7ad0ea03969d53f6e82d6c59d87eea",
            "patch": "@@ -4,7 +4,7 @@ use std::{\n     mem::take,\n };\n \n-use anyhow::{bail, Result};\n+use anyhow::{bail, Context, Result};\n use either::Either;\n use petgraph::graph::{DiGraph, EdgeIndex, NodeIndex};\n use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n@@ -254,7 +254,7 @@ impl PreBatches {\n         let entry_chunk_groups = chunk_group_info\n             .module_chunk_groups\n             .get(&ResolvedVc::upcast(entry))\n-            .expect(\"all modules need to have chunk group info\");\n+            .context(\"all modules need to have chunk group info\")?;\n         let mut state = TraversalState {\n             items: Vec::new(),\n             this: self,\n@@ -279,7 +279,7 @@ impl PreBatches {\n                     let chunk_groups = chunk_group_info\n                         .module_chunk_groups\n                         .get(&node.module)\n-                        .expect(\"all modules need to have chunk group info\");\n+                        .context(\"all modules need to have chunk group info\")?;\n                     if chunk_groups != entry_chunk_groups {\n                         let idx = state.this.ensure_pre_batch_for_module(\n                             chunkable_module,\n@@ -340,7 +340,7 @@ pub async fn compute_module_batches(\n                     let chunk_groups = chunk_group_info\n                         .module_chunk_groups\n                         .get(&entry)\n-                        .expect(\"all modules need to have chunk group info\");\n+                        .context(\"all modules need to have chunk group info\")?;\n                     pre_batches.ensure_pre_batch_for_module(\n                         chunkable_module,\n                         chunk_groups,\n@@ -608,7 +608,7 @@ pub async fn compute_module_batches(\n             let chunk_groups = chunk_group_info\n                 .module_chunk_groups\n                 .get(&module)\n-                .expect(\"all modules need to have chunk group info\");\n+                .context(\"all modules need to have chunk group info\")?;\n             let key = BuildHasherDefault::<FxHasher>::default().prehash(chunk_groups.clone());\n             batch_groups\n                 .entry(key)"
        }
    ],
    "stats": {
        "total": 10,
        "additions": 5,
        "deletions": 5
    }
}