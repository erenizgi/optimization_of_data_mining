{
    "author": "sokra",
    "message": "Turbopack: fix graph chunk groups (#76383)\n\n### What?\n\n* Fix pages graph entrypoints\n* Fix chunk_group_info computation for merged\n* Fix client_shared_entries in graph\n* chunk_group_info: continue walking across graphs",
    "sha": "5d1ecedf6650f40ce5d18cbc6296fff5c9213f53",
    "files": [
        {
            "sha": "46cc5a6271ddd515151faa27485a7a6b010498f6",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 12,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/5d1ecedf6650f40ce5d18cbc6296fff5c9213f53/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5d1ecedf6650f40ce5d18cbc6296fff5c9213f53/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=5d1ecedf6650f40ce5d18cbc6296fff5c9213f53",
            "patch": "@@ -813,13 +813,14 @@ impl AppProject {\n         &self,\n         endpoint: Vc<AppEndpoint>,\n         rsc_entry: ResolvedVc<Box<dyn Module>>,\n-        extra_entries: Vc<EvaluatableAssets>,\n+        client_shared_entries: Vc<EvaluatableAssets>,\n         has_layout_segments: bool,\n     ) -> Result<Vc<ModuleGraphs>> {\n-        let extra_entries = extra_entries\n+        let client_shared_entries = client_shared_entries\n             .await?\n             .into_iter()\n-            .map(|m| ResolvedVc::upcast(*m));\n+            .map(|m| ResolvedVc::upcast(*m))\n+            .collect();\n \n         if *self.project.per_page_module_graph().await? {\n             // Implements layout segment optimization to compute a graph \"chain\" for each layout\n@@ -833,14 +834,17 @@ impl AppProject {\n                     } = &*find_server_entries(*rsc_entry).await?;\n \n                     let graph = SingleModuleGraph::new_with_entries_visited(\n-                        vec![(\n-                            server_utils\n-                                .iter()\n-                                .map(|m| ResolvedVc::upcast(*m))\n-                                .chain(extra_entries)\n-                                .collect(),\n-                            ChunkGroupType::Entry,\n-                        )],\n+                        vec![\n+                            (\n+                                server_utils\n+                                    .iter()\n+                                    .map(async |m| Ok(ResolvedVc::upcast(m.await?.module)))\n+                                    .try_join()\n+                                    .await?,\n+                                ChunkGroupType::Entry,\n+                            ),\n+                            (client_shared_entries, ChunkGroupType::Evaluated),\n+                        ],\n                         VisitedModules::empty(),\n                     );\n                     graphs.push(graph);\n@@ -869,7 +873,7 @@ impl AppProject {\n                     visited_modules\n                 } else {\n                     let graph = SingleModuleGraph::new_with_entries_visited(\n-                        vec![(extra_entries.collect(), ChunkGroupType::Entry)],\n+                        vec![(client_shared_entries, ChunkGroupType::Evaluated)],\n                         VisitedModules::empty(),\n                     );\n                     graphs.push(graph);"
        },
        {
            "sha": "bb8b89a2f0d2da5efd2106c70b82b73d3de6ffb7",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/5d1ecedf6650f40ce5d18cbc6296fff5c9213f53/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5d1ecedf6650f40ce5d18cbc6296fff5c9213f53/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=5d1ecedf6650f40ce5d18cbc6296fff5c9213f53",
            "patch": "@@ -1475,7 +1475,11 @@ impl Endpoint for PageEndpoint {\n \n         if let PageEndpointType::Html = this.ty {\n             modules.push((\n-                vec![self.client_module().to_resolved().await?],\n+                self.client_evaluatable_assets()\n+                    .await?\n+                    .iter()\n+                    .map(|m| ResolvedVc::upcast(*m))\n+                    .collect(),\n                 ChunkGroupType::Evaluated,\n             ));\n         }"
        },
        {
            "sha": "85265bbfd76720742a2fb1ec40612540e3f71668",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 18,
            "deletions": 15,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/5d1ecedf6650f40ce5d18cbc6296fff5c9213f53/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5d1ecedf6650f40ce5d18cbc6296fff5c9213f53/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=5d1ecedf6650f40ce5d18cbc6296fff5c9213f53",
            "patch": "@@ -22,8 +22,8 @@ use crate::{\n     chunk::{ChunkGroupType, ChunkingType},\n     module::Module,\n     module_graph::{\n-        get_node, GraphNodeIndex, GraphTraversalAction, ModuleGraph, SingleModuleGraphModuleNode,\n-        SingleModuleGraphNode,\n+        get_node, get_node_idx, GraphNodeIndex, GraphTraversalAction, ModuleGraph,\n+        SingleModuleGraphModuleNode, SingleModuleGraphNode,\n     },\n };\n \n@@ -152,14 +152,14 @@ enum ChunkGroupKey {\n     },\n     /// a module with an incoming async edge\n     Async(ResolvedVc<Box<dyn Module>>),\n-    /// a module with an incoming non-merged isolated edge\n+    /// a module with an incoming non-merging isolated edge\n     Isolated(ResolvedVc<Box<dyn Module>>),\n     /// a module with an incoming merging isolated edge\n     IsolatedMerged {\n         parent: ChunkGroupId,\n         merge_tag: RcStr,\n     },\n-    /// a module with an incoming merging shared edge\n+    /// a module with an incoming non-merging shared edge\n     Shared(ResolvedVc<Box<dyn Module>>),\n     /// a module with an incoming merging shared edge\n     SharedMerged {\n@@ -353,20 +353,23 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                         // Start of a new chunk group, don't inherit anything from parent\n                         let chunk_group_ids = chunk_groups.map(|chunk_group| {\n                             let len = chunk_groups_map.len();\n-                            let is_isolated_merged =\n-                                matches!(chunk_group, ChunkGroupKey::IsolatedMerged { .. });\n+                            let is_merged = matches!(\n+                                chunk_group,\n+                                ChunkGroupKey::IsolatedMerged { .. }\n+                                    | ChunkGroupKey::SharedMerged { .. }\n+                            );\n                             match chunk_groups_map.entry(chunk_group) {\n                                 Entry::Occupied(mut e) => {\n-                                    let (id, isolated_merged_entries) = e.get_mut();\n-                                    if is_isolated_merged {\n-                                        isolated_merged_entries.insert(node.module);\n+                                    let (id, merged_entries) = e.get_mut();\n+                                    if is_merged {\n+                                        merged_entries.insert(node.module);\n                                     }\n                                     **id\n                                 }\n                                 Entry::Vacant(e) => {\n                                     let chunk_group_id = len as u32;\n                                     let mut set = FxIndexSet::default();\n-                                    if is_isolated_merged {\n+                                    if is_merged {\n                                         set.insert(node.module);\n                                     }\n                                     e.insert((ChunkGroupId(chunk_group_id), set));\n@@ -443,8 +446,8 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n             }\n             while let Some(NodeWithPriority { node, .. }) = queue.pop() {\n                 queue_set.remove(&node);\n+                let (node_weight, node) = get_node_idx!(graphs, node)?;\n                 let graph = &graphs[node.graph_idx].graph;\n-                let node_weight = get_node!(graphs, node)?;\n                 let neighbors = iter_neighbors(graph, node.node_idx);\n \n                 visit_count += 1;\n@@ -454,7 +457,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                         graph_idx: node.graph_idx,\n                         node_idx: succ,\n                     };\n-                    let succ_weight = get_node!(graphs, succ)?;\n+                    let (succ_weight, succ) = get_node_idx!(graphs, succ)?;\n                     let edge_weight = graph.edge_weight(edge).unwrap();\n                     let action = visitor(\n                         Some((node_weight, edge_weight)),\n@@ -483,22 +486,22 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n             module_chunk_groups,\n             chunk_groups: chunk_groups_map\n                 .into_iter()\n-                .map(|(k, (_, isolated_merged_entries))| match k {\n+                .map(|(k, (_, merged_entries))| match k {\n                     ChunkGroupKey::Entry { entries, ty } => ChunkGroup::Entry { entries, ty },\n                     ChunkGroupKey::Async(module) => ChunkGroup::Async(module),\n                     ChunkGroupKey::Isolated(module) => ChunkGroup::Isolated(module),\n                     ChunkGroupKey::IsolatedMerged { parent, merge_tag } => {\n                         ChunkGroup::IsolatedMerged {\n                             parent: parent.0 as usize,\n                             merge_tag,\n-                            entries: isolated_merged_entries.into_iter().collect(),\n+                            entries: merged_entries.into_iter().collect(),\n                         }\n                     }\n                     ChunkGroupKey::Shared(module) => ChunkGroup::Shared(module),\n                     ChunkGroupKey::SharedMerged { parent, merge_tag } => ChunkGroup::SharedMerged {\n                         parent: parent.0 as usize,\n                         merge_tag,\n-                        entries: isolated_merged_entries.into_iter().collect(),\n+                        entries: merged_entries.into_iter().collect(),\n                     },\n                 })\n                 .collect(),"
        },
        {
            "sha": "f7fa7012c4ea5142a02b85a5bd11baa7421b8e93",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 1,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/5d1ecedf6650f40ce5d18cbc6296fff5c9213f53/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5d1ecedf6650f40ce5d18cbc6296fff5c9213f53/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=5d1ecedf6650f40ce5d18cbc6296fff5c9213f53",
            "patch": "@@ -692,7 +692,7 @@ macro_rules! get_node {\n             Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok(node),\n             Some(SingleModuleGraphNode::VisitedModule { idx, .. }) => {\n                 match $graphs[idx.graph_idx].graph.node_weight(idx.node_idx) {\n-                    Some(SingleModuleGraphNode::Module(node)) => anyhow::Ok(node),\n+                    Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok(node),\n                     Some(SingleModuleGraphNode::VisitedModule { .. }) => Err(::anyhow::anyhow!(\n                         \"Expected visited target node to be module\"\n                     )),\n@@ -704,6 +704,28 @@ macro_rules! get_node {\n     }};\n }\n pub(crate) use get_node;\n+macro_rules! get_node_idx {\n+    ($graphs:expr, $node:expr) => {{\n+        let node_idx = $node;\n+        match $graphs[node_idx.graph_idx]\n+            .graph\n+            .node_weight(node_idx.node_idx)\n+        {\n+            Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok((node, node_idx)),\n+            Some(SingleModuleGraphNode::VisitedModule { idx, .. }) => {\n+                match $graphs[idx.graph_idx].graph.node_weight(idx.node_idx) {\n+                    Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok((node, *idx)),\n+                    Some(SingleModuleGraphNode::VisitedModule { .. }) => Err(::anyhow::anyhow!(\n+                        \"Expected visited target node to be module\"\n+                    )),\n+                    None => Err(::anyhow::anyhow!(\"Expected visited target node\")),\n+                }\n+            }\n+            None => Err(::anyhow::anyhow!(\"Expected graph node\")),\n+        }\n+    }};\n+}\n+pub(crate) use get_node_idx;\n \n // pub struct AllNodesIterator {\n //     inner: Vec<ReadRef<SingleModuleGraph>>,"
        }
    ],
    "stats": {
        "total": 91,
        "additions": 62,
        "deletions": 29
    }
}