{
    "author": "ijjk",
    "message": "Add onBuildComplete adapter hook (#80446)\n\nThis implements the second hook `onBuildComplete` from the adapters RFC\nhttps://github.com/vercel/next.js/discussions/77740 which exposes\nstructured routing and build outputs information that can then be used\nto create finalized outputs depending on differing deployment targets.",
    "sha": "1f04759542ae24defecf72de0fd00fc560e48b68",
    "files": [
        {
            "sha": "17e21ee127ff704a1927cec2b7b939958aa453ee",
            "filename": "packages/next/src/build/adapter/build-complete.ts",
            "status": "added",
            "additions": 279,
            "deletions": 0,
            "changes": 279,
            "blob_url": "https://github.com/vercel/next.js/blob/1f04759542ae24defecf72de0fd00fc560e48b68/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1f04759542ae24defecf72de0fd00fc560e48b68/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts?ref=1f04759542ae24defecf72de0fd00fc560e48b68",
            "patch": "@@ -0,0 +1,279 @@\n+import path from 'path'\n+import fs from 'fs/promises'\n+import { promisify } from 'util'\n+import { pathToFileURL } from 'url'\n+import * as Log from '../output/log'\n+import globOriginal from 'next/dist/compiled/glob'\n+import { interopDefault } from '../../lib/interop-default'\n+import type { AdapterOutputs, NextAdapter } from '../../server/config-shared'\n+import {\n+  RouteType,\n+  type FunctionsConfigManifest,\n+  type PrerenderManifest,\n+  type RoutesManifest,\n+} from '..'\n+import type {\n+  EdgeFunctionDefinition,\n+  MiddlewareManifest,\n+} from '../webpack/plugins/middleware-plugin'\n+import { isMiddlewareFilename } from '../utils'\n+import { normalizePagePath } from '../../shared/lib/page-path/normalize-page-path'\n+import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n+\n+const glob = promisify(globOriginal)\n+\n+export async function handleBuildComplete({\n+  // dir,\n+  distDir,\n+  tracingRoot,\n+  adapterPath,\n+  pageKeys,\n+  appPageKeys,\n+  hasNodeMiddleware,\n+  hasInstrumentationHook,\n+  requiredServerFiles,\n+  routesManifest,\n+  // prerenderManifest,\n+  middlewareManifest,\n+}: {\n+  dir: string\n+  distDir: string\n+  adapterPath: string\n+  tracingRoot: string\n+  hasNodeMiddleware: boolean\n+  pageKeys: readonly string[]\n+  hasInstrumentationHook: boolean\n+  appPageKeys?: readonly string[] | undefined\n+  requiredServerFiles: string[]\n+  routesManifest: RoutesManifest\n+  prerenderManifest: PrerenderManifest\n+  middlewareManifest: MiddlewareManifest\n+  functionsConfigManifest: FunctionsConfigManifest\n+}) {\n+  const adapterMod = interopDefault(\n+    await import(pathToFileURL(require.resolve(adapterPath)).href)\n+  ) as NextAdapter\n+\n+  if (typeof adapterMod.onBuildComplete === 'function') {\n+    Log.info(`Running onBuildComplete from ${adapterMod.name}`)\n+\n+    try {\n+      const outputs: AdapterOutputs = []\n+\n+      const staticFiles = await glob('**/*', {\n+        cwd: path.join(distDir, 'static'),\n+      })\n+\n+      for (const file of staticFiles) {\n+        const pathname = path.posix.join('/_next/static', file)\n+        const filePath = path.join(distDir, 'static', file)\n+        outputs.push({\n+          type: RouteType.STATIC_FILE,\n+          id: path.join('static', file),\n+          pathname,\n+          filePath,\n+        })\n+      }\n+\n+      const sharedNodeAssets: Record<string, string> = {}\n+\n+      for (const file of requiredServerFiles) {\n+        // add to shared node assets\n+        const filePath = path.join(distDir, file)\n+        const fileOutputPath = path.relative(tracingRoot, filePath)\n+        sharedNodeAssets[fileOutputPath] = filePath\n+      }\n+\n+      if (hasInstrumentationHook) {\n+        const assets = await handleTraceFiles(\n+          path.join(distDir, 'server', 'instrumentation.js.nft.json')\n+        )\n+        const fileOutputPath = path.relative(\n+          tracingRoot,\n+          path.join(distDir, 'server', 'instrumentation.js')\n+        )\n+        sharedNodeAssets[fileOutputPath] = path.join(\n+          distDir,\n+          'server',\n+          'instrumentation.js'\n+        )\n+        Object.assign(sharedNodeAssets, assets)\n+      }\n+\n+      async function handleTraceFiles(\n+        traceFilePath: string\n+      ): Promise<Record<string, string>> {\n+        const assets: Record<string, string> = Object.assign(\n+          {},\n+          sharedNodeAssets\n+        )\n+        const traceData = JSON.parse(\n+          await fs.readFile(traceFilePath, 'utf8')\n+        ) as {\n+          files: string[]\n+        }\n+        const traceFileDir = path.dirname(traceFilePath)\n+\n+        for (const relativeFile of traceData.files) {\n+          const tracedFilePath = path.join(traceFileDir, relativeFile)\n+          const fileOutputPath = path.relative(tracingRoot, tracedFilePath)\n+          assets[fileOutputPath] = tracedFilePath\n+        }\n+        return assets\n+      }\n+\n+      async function handleEdgeFunction(\n+        page: EdgeFunctionDefinition,\n+        isMiddleware: boolean = false\n+      ) {\n+        let type = RouteType.PAGES\n+        const isAppPrefix = page.page.startsWith('app/')\n+        const isAppPage = isAppPrefix && page.page.endsWith('/page')\n+        const isAppRoute = isAppPrefix && page.page.endsWith('/route')\n+\n+        if (isMiddleware) {\n+          type = RouteType.MIDDLEWARE\n+        } else if (isAppPage) {\n+          type = RouteType.APP_PAGE\n+        } else if (isAppRoute) {\n+          type = RouteType.APP_ROUTE\n+        } else if (page.page.startsWith('/api')) {\n+          type = RouteType.PAGES_API\n+        }\n+\n+        const output: AdapterOutputs[0] = {\n+          id: page.name,\n+          runtime: 'edge',\n+          pathname: isAppPrefix ? normalizeAppPath(page.name) : page.name,\n+          filePath: path.join(\n+            distDir,\n+            'server',\n+            page.files.find(\n+              (item) =>\n+                item.startsWith('server/app') || item.startsWith('server/pages')\n+            ) || ''\n+          ),\n+          assets: {},\n+          type,\n+        }\n+\n+        function handleFile(file: string) {\n+          const originalPath = path.join(distDir, file)\n+          const fileOutputPath = path.join(\n+            path.relative(tracingRoot, distDir),\n+            file\n+          )\n+          if (!output.assets) {\n+            output.assets = {}\n+          }\n+          output.assets[fileOutputPath] = originalPath\n+        }\n+        for (const file of page.files) {\n+          handleFile(file)\n+        }\n+        for (const item of [...(page.wasm || []), ...(page.assets || [])]) {\n+          handleFile(item.filePath)\n+        }\n+        outputs.push(output)\n+      }\n+\n+      const edgeFunctionHandlers: Promise<any>[] = []\n+\n+      for (const middleware of Object.values(middlewareManifest.middleware)) {\n+        if (isMiddlewareFilename(middleware.name)) {\n+          edgeFunctionHandlers.push(handleEdgeFunction(middleware, true))\n+        }\n+      }\n+\n+      for (const page of Object.values(middlewareManifest.functions)) {\n+        edgeFunctionHandlers.push(handleEdgeFunction(page))\n+      }\n+\n+      for (const page of pageKeys) {\n+        if (middlewareManifest.functions.hasOwnProperty(page)) {\n+          continue\n+        }\n+        const route = normalizePagePath(page)\n+\n+        const pageFile = path.join(\n+          distDir,\n+          'server',\n+          'pages',\n+          `${normalizePagePath(page)}.js`\n+        )\n+        const pageTraceFile = `${pageFile}.nft.json`\n+        const assets = await handleTraceFiles(pageTraceFile).catch((err) => {\n+          if (err.code !== 'ENOENT' || (page !== '/404' && page !== '/500')) {\n+            Log.warn(`Failed to copy traced files for ${pageFile}`, err)\n+          }\n+          return {} as Record<string, string>\n+        })\n+\n+        outputs.push({\n+          id: route,\n+          type: page.startsWith('/api') ? RouteType.PAGES_API : RouteType.PAGES,\n+          filePath: pageTraceFile.replace(/\\.nft\\.json$/, ''),\n+          pathname: route,\n+          assets,\n+          runtime: 'nodejs',\n+        })\n+      }\n+\n+      if (hasNodeMiddleware) {\n+        const middlewareFile = path.join(distDir, 'server', 'middleware.js')\n+        const middlewareTrace = `${middlewareFile}.nft.json`\n+        const assets = await handleTraceFiles(middlewareTrace)\n+\n+        outputs.push({\n+          pathname: '/_middleware',\n+          id: '/_middleware',\n+          assets,\n+          type: RouteType.MIDDLEWARE,\n+          runtime: 'nodejs',\n+          filePath: middlewareFile,\n+        })\n+      }\n+\n+      if (appPageKeys) {\n+        for (const page of appPageKeys) {\n+          if (middlewareManifest.functions.hasOwnProperty(page)) {\n+            continue\n+          }\n+          const normalizedPage = normalizeAppPath(page)\n+          const pageFile = path.join(distDir, 'server', 'app', `${page}.js`)\n+          const pageTraceFile = `${pageFile}.nft.json`\n+          const assets = await handleTraceFiles(pageTraceFile).catch((err) => {\n+            Log.warn(`Failed to copy traced files for ${pageFile}`, err)\n+            return {} as Record<string, string>\n+          })\n+\n+          outputs.push({\n+            pathname: normalizedPage,\n+            id: normalizedPage,\n+            assets,\n+            type: page.endsWith('/route')\n+              ? RouteType.APP_ROUTE\n+              : RouteType.APP_PAGE,\n+            runtime: 'nodejs',\n+            filePath: pageFile,\n+          })\n+        }\n+      }\n+\n+      // TODO: prerender assets\n+\n+      await adapterMod.onBuildComplete({\n+        routes: {\n+          dynamicRoutes: routesManifest.dynamicRoutes,\n+          rewrites: routesManifest.rewrites,\n+          redirects: routesManifest.redirects,\n+          headers: routesManifest.headers,\n+        },\n+        outputs,\n+      })\n+    } catch (err) {\n+      Log.error(`Failed to run onBuildComplete from ${adapterMod.name}`)\n+      throw err\n+    }\n+  }\n+}"
        },
        {
            "sha": "95adb78da216f18cba7e7130ff25a1792d254296",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 53,
            "deletions": 1,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/1f04759542ae24defecf72de0fd00fc560e48b68/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1f04759542ae24defecf72de0fd00fc560e48b68/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=1f04759542ae24defecf72de0fd00fc560e48b68",
            "patch": "@@ -209,6 +209,7 @@ import { traceGlobals } from '../trace/shared'\n import { extractNextErrorCode } from '../lib/error-telemetry-utils'\n import { runAfterProductionCompile } from './after-production-compile'\n import { generatePreviewKeys } from './preview-key-utils'\n+import { handleBuildComplete } from './adapter/build-complete'\n \n type Fallback = null | boolean | string\n \n@@ -359,6 +360,39 @@ type ManifestBuiltRoute = {\n   regex: string\n }\n \n+export enum RouteType {\n+  /**\n+   * `PAGES` represents all the React pages that are under `pages/`.\n+   */\n+  PAGES = 'PAGES',\n+  /**\n+   * `PAGES_API` represents all the API routes under `pages/api/`.\n+   */\n+  PAGES_API = 'PAGES_API',\n+  /**\n+   * `APP_PAGE` represents all the React pages that are under `app/` with the\n+   * filename of `page.{j,t}s{,x}`.\n+   */\n+  APP_PAGE = 'APP_PAGE',\n+  /**\n+   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n+   * filename of `route.{j,t}s{,x}`.\n+   */\n+  APP_ROUTE = 'APP_ROUTE',\n+\n+  /**\n+   * `IMAGE` represents all the images that are generated by `next/image`.\n+   */\n+  // IMAGE = 'IMAGE',\n+\n+  /**\n+   * `STATIC_FILE` represents a static file (ie /_next/static)\n+   */\n+  STATIC_FILE = 'STATIC_FILE',\n+\n+  MIDDLEWARE = 'MIDDLEWARE',\n+}\n+\n export type ManifestRewriteRoute = ManifestBuiltRoute & Rewrite\n export type ManifestRedirectRoute = ManifestBuiltRoute & Redirect\n export type ManifestHeaderRoute = ManifestBuiltRoute & Header\n@@ -381,7 +415,7 @@ export type RoutesManifest = {\n   version: number\n   pages404: boolean\n   basePath: string\n-  redirects: Array<Redirect>\n+  redirects: Array<ManifestRedirectRoute>\n   rewrites: {\n     beforeFiles: Array<ManifestRewriteRoute>\n     afterFiles: Array<ManifestRewriteRoute>\n@@ -3709,6 +3743,24 @@ export default async function build(\n         )\n       }\n \n+      if (config.experimental.adapterPath) {\n+        await handleBuildComplete({\n+          dir,\n+          distDir,\n+          tracingRoot: outputFileTracingRoot,\n+          hasNodeMiddleware,\n+          hasInstrumentationHook,\n+          adapterPath: config.experimental.adapterPath,\n+          pageKeys: pageKeys.pages,\n+          appPageKeys: denormalizedAppPages,\n+          routesManifest,\n+          prerenderManifest,\n+          middlewareManifest,\n+          functionsConfigManifest,\n+          requiredServerFiles: requiredServerFilesManifest.files,\n+        })\n+      }\n+\n       if (config.output === 'standalone') {\n         await writeStandaloneDirectory(\n           nextBuildSpan,"
        },
        {
            "sha": "8f0ee277edbb089ee5c5995c181e325447f401cf",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/1f04759542ae24defecf72de0fd00fc560e48b68/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1f04759542ae24defecf72de0fd00fc560e48b68/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=1f04759542ae24defecf72de0fd00fc560e48b68",
            "patch": "@@ -13,6 +13,12 @@ import type { SizeLimit } from '../types'\n import type { SupportedTestRunners } from '../cli/next-test'\n import type { ExperimentalPPRConfig } from './lib/experimental/ppr'\n import { INFINITE_CACHE } from '../lib/constants'\n+import type {\n+  ManifestRewriteRoute,\n+  ManifestHeaderRoute,\n+  ManifestRedirectRoute,\n+  RouteType,\n+} from '../build'\n \n export type NextConfigComplete = Required<NextConfig> & {\n   images: Required<ImageConfigComplete>\n@@ -26,11 +32,40 @@ export type NextConfigComplete = Required<NextConfig> & {\n   experimental: Omit<ExperimentalConfig, 'turbo'>\n }\n \n+export type AdapterOutputs = Array<{\n+  id: string\n+  fallbackID?: string\n+  runtime?: 'nodejs' | 'edge'\n+  pathname: string\n+  allowQuery?: string[]\n+  config?: {\n+    maxDuration?: number\n+    expiration?: number\n+    revalidate?: number\n+  }\n+  assets?: Record<string, string>\n+  filePath: string\n+  type: RouteType\n+}>\n+\n export interface NextAdapter {\n   name: string\n   modifyConfig(\n     config: NextConfigComplete\n   ): Promise<NextConfigComplete> | NextConfigComplete\n+  onBuildComplete(ctx: {\n+    routes: {\n+      headers: Array<ManifestHeaderRoute>\n+      redirects: Array<ManifestRedirectRoute>\n+      rewrites: {\n+        beforeFiles: Array<ManifestRewriteRoute>\n+        afterFiles: Array<ManifestRewriteRoute>\n+        fallback: Array<ManifestRewriteRoute>\n+      }\n+      dynamicRoutes: Array<{}>\n+    }\n+    outputs: AdapterOutputs\n+  }): Promise<void> | void\n }\n \n export type I18NDomains = readonly DomainLocale[]"
        }
    ],
    "stats": {
        "total": 368,
        "additions": 367,
        "deletions": 1
    }
}