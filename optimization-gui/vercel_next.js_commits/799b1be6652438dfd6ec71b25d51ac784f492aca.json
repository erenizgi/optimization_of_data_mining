{
    "author": "Cy-Tek",
    "message": "cleanup(turbopack) Show users an error message when Webpack loaders have a glob in only the extension (#81084)\n\nThis PR adds validation for webpack loader rules in Next.js\nconfiguration to prevent a common issue where users define wildcard\nextensions without corresponding wildcard patterns in the `as` option.\nThis situation causes all modules to be transformed into the same name,\nresulting in duplicate module errors.\n\nThe changes:\n- Add a new `InvalidLoaderRuleError` issue type that provides clear\nerror messages when this misconfiguration is detected\n- Check if an extension contains a wildcard (`*`) but the `rename_as`\noption does not\n- Display helpful error messages with links to documentation when this\nissue is found\n- Update the `webpack_rules` function to accept the project path for\nerror reporting\n\nThis validation helps users avoid confusing duplicate module errors by\nproviding clear guidance on how to properly configure webpack loaders in\nNext.js.\n\n\n![image.png](https://graphite-user-uploaded-assets-prod.s3.amazonaws.com/IhNrutw2qOTgYcgE6MlR/6bae20b6-34b0-4643-9a5c-f580ba32c550.png)",
    "sha": "799b1be6652438dfd6ec71b25d51ac784f492aca",
    "files": [
        {
            "sha": "2c7f2789a2fb28f634cb484a5f53ec35016c762c",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 85,
            "deletions": 5,
            "changes": 90,
            "blob_url": "https://github.com/vercel/next.js/blob/799b1be6652438dfd6ec71b25d51ac784f492aca/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/799b1be6652438dfd6ec71b25d51ac784f492aca/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=799b1be6652438dfd6ec71b25d51ac784f492aca",
            "patch": "@@ -9,11 +9,15 @@ use turbo_tasks::{\n     trace::TraceRawVcs,\n };\n use turbo_tasks_env::EnvMap;\n+use turbo_tasks_fs::FileSystemPath;\n use turbopack::module_options::{\n     ConditionItem, ConditionPath, LoaderRuleItem, OptionWebpackRules,\n     module_options_context::{MdxTransformOptions, OptionWebpackConditions},\n };\n-use turbopack_core::resolve::ResolveAliasMap;\n+use turbopack_core::{\n+    issue::{Issue, IssueExt, IssueStage, OptionStyledString, StyledString},\n+    resolve::ResolveAliasMap,\n+};\n use turbopack_ecmascript::{OptionTreeShaking, TreeShakingMode};\n use turbopack_ecmascript_plugins::transform::{\n     emotion::EmotionTransformConfig, relay::RelayConfig,\n@@ -1112,6 +1116,62 @@ pub struct OptionServerActions(Option<ServerActions>);\n #[turbo_tasks::value(transparent)]\n pub struct OptionJsonValue(pub Option<serde_json::Value>);\n \n+#[turbo_tasks::value(shared)]\n+struct InvalidLoaderRuleError {\n+    ext: RcStr,\n+    rename_as: Option<RcStr>,\n+    config_file_path: FileSystemPath,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Issue for InvalidLoaderRuleError {\n+    #[turbo_tasks::function]\n+    async fn file_path(self: turbo_tasks::Vc<Self>) -> Result<Vc<FileSystemPath>> {\n+        Ok(self.await?.config_file_path.clone().cell())\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn stage(self: turbo_tasks::Vc<Self>) -> Vc<IssueStage> {\n+        IssueStage::Config.cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn title(self: turbo_tasks::Vc<Self>) -> Result<Vc<StyledString>> {\n+        Ok(StyledString::Text(\n+            format!(\n+                \"Invalid loader rule for extension: {}\",\n+                self.await?.ext.as_str()\n+            )\n+            .into(),\n+        )\n+        .cell())\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn description(self: turbo_tasks::Vc<Self>) -> Result<Vc<OptionStyledString>> {\n+        Ok(Vc::cell(Some(StyledString::Stack(vec![\n+            StyledString::Text(\n+                format!(\n+                    \"The extension {} contains a wildcard, but the `as` option does not: {}\",\n+                    self.await?.ext.as_str(),\n+                    self.await?\n+                        .rename_as\n+                        .as_ref()\n+                        .map(|r| r.as_str())\n+                        .unwrap_or(\"\")\n+                )\n+                .into(),\n+            ),\n+            StyledString::Text(\n+                \"Check out the documentation here for more information:\".into(),\n+            ),\n+            StyledString::Text(\n+                \"https://nextjs.org/docs/app/api-reference/config/next-config-js/turbopack#configuring-webpack-loaders\".into(),\n+            ),\n+        ]).resolved_cell())))\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl NextConfig {\n     #[turbo_tasks::function]\n@@ -1203,12 +1263,16 @@ impl NextConfig {\n     }\n \n     #[turbo_tasks::function]\n-    pub fn webpack_rules(&self, active_conditions: Vec<RcStr>) -> Vc<OptionWebpackRules> {\n+    pub async fn webpack_rules(\n+        &self,\n+        active_conditions: Vec<RcStr>,\n+        project_path: FileSystemPath,\n+    ) -> Result<Vc<OptionWebpackRules>> {\n         let Some(turbo_rules) = self.turbopack.as_ref().and_then(|t| t.rules.as_ref()) else {\n-            return Vc::cell(None);\n+            return Ok(Vc::cell(None));\n         };\n         if turbo_rules.is_empty() {\n-            return Vc::cell(None);\n+            return Ok(Vc::cell(None));\n         }\n         let active_conditions = active_conditions.into_iter().collect::<FxHashSet<_>>();\n         let mut rules = FxIndexMap::default();\n@@ -1271,6 +1335,22 @@ impl NextConfig {\n                     if let FindRuleResult::Found(RuleConfigItemOptions { loaders, rename_as }) =\n                         find_rule(rule, &active_conditions)\n                     {\n+                        // If the extension contains a wildcard, and the rename_as does not,\n+                        // emit an issue to prevent users from encountering duplicate module names.\n+                        if ext.contains(\"*\") && rename_as.as_ref().is_some_and(|r| !r.contains(\"*\"))\n+                        {\n+                            let config_file_path =\n+                                project_path.join(&format!(\"./{}\", self.config_file_name))?;\n+\n+                            InvalidLoaderRuleError {\n+                                ext: ext.clone(),\n+                                config_file_path,\n+                                rename_as: rename_as.clone(),\n+                            }\n+                            .resolved_cell()\n+                            .emit();\n+                        }\n+\n                         rules.insert(\n                             ext.clone(),\n                             LoaderRuleItem {\n@@ -1282,7 +1362,7 @@ impl NextConfig {\n                 }\n             }\n         }\n-        Vc::cell(Some(ResolvedVc::cell(rules)))\n+        Ok(Vc::cell(Some(ResolvedVc::cell(rules))))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "1d7f486dc916b820fb551a6a9030fcc15cb4fb2a",
            "filename": "crates/next-core/src/next_shared/webpack_rules/mod.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/799b1be6652438dfd6ec71b25d51ac784f492aca/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/799b1be6652438dfd6ec71b25d51ac784f492aca/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs?ref=799b1be6652438dfd6ec71b25d51ac784f492aca",
            "patch": "@@ -17,7 +17,9 @@ pub async fn webpack_loader_options(\n     foreign: bool,\n     condition_strs: Vec<RcStr>,\n ) -> Result<Option<ResolvedVc<WebpackLoadersOptions>>> {\n-    let rules = *next_config.webpack_rules(condition_strs).await?;\n+    let rules = *next_config\n+        .webpack_rules(condition_strs, project_path.clone())\n+        .await?;\n     let rules = *maybe_add_sass_loader(next_config.sass_config(), rules.map(|v| *v)).await?;\n     let rules = if foreign {\n         rules"
        }
    ],
    "stats": {
        "total": 94,
        "additions": 88,
        "deletions": 6
    }
}