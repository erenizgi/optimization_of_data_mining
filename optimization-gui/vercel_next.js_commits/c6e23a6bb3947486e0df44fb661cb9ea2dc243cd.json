{
    "author": "bgw",
    "message": "Turbopack: Use a factory factory (yes, really) to make hanging detection construction lazier (#81434)\n\nThis is an alternate attempt at solving #81424 without macros.\n\nThe extra laziness desired can be accomplished with an outer wrapping\n`FnOnce`. It's a bit confusing, but I think it causes less problems than\na macro does?\n\nChecked compilation and lints with:\n\n```\ncargo clippy --all-targets\ncargo clippy --all-targets --features turbo-tasks/hanging_detection\n```\n\n// TODO: Find somewhere else to insert a closure so that we can have a\nfactory factory factory!",
    "sha": "c6e23a6bb3947486e0df44fb661cb9ea2dc243cd",
    "files": [
        {
            "sha": "a8de4fda1b85ee014e3dc39d4bc3521bfad2dae0",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 32,
            "deletions": 25,
            "changes": 57,
            "blob_url": "https://github.com/vercel/next.js/blob/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=c6e23a6bb3947486e0df44fb661cb9ea2dc243cd",
            "patch": "@@ -256,9 +256,9 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             snapshot_completed: Condvar::new(),\n             last_snapshot: AtomicU64::new(0),\n             stopping: AtomicBool::new(false),\n-            stopping_event: Event::new(|| \"TurboTasksBackend::stopping_event\".to_string()),\n-            idle_start_event: Event::new(|| \"TurboTasksBackend::idle_start_event\".to_string()),\n-            idle_end_event: Event::new(|| \"TurboTasksBackend::idle_end_event\".to_string()),\n+            stopping_event: Event::new(|| || \"TurboTasksBackend::stopping_event\".to_string()),\n+            idle_start_event: Event::new(|| || \"TurboTasksBackend::idle_start_event\".to_string()),\n+            idle_end_event: Event::new(|| || \"TurboTasksBackend::idle_end_event\".to_string()),\n             #[cfg(feature = \"verify_aggregation_graph\")]\n             is_idle: AtomicBool::new(false),\n             task_statistics: TaskStatisticsApi::default(),\n@@ -453,12 +453,14 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             reader: Option<TaskId>,\n             done_event: &Event,\n         ) -> EventListener {\n-            let reader_desc = reader.map(|r| this.get_task_desc_fn(r));\n             done_event.listen_with_note(move || {\n-                if let Some(reader_desc) = reader_desc.as_ref() {\n-                    format!(\"try_read_task_output from {}\", reader_desc())\n-                } else {\n-                    \"try_read_task_output (untracked)\".to_string()\n+                let reader_desc = reader.map(|r| this.get_task_desc_fn(r));\n+                move || {\n+                    if let Some(reader_desc) = reader_desc.as_ref() {\n+                        format!(\"try_read_task_output from {}\", reader_desc())\n+                    } else {\n+                        \"try_read_task_output (untracked)\".to_string()\n+                    }\n                 }\n             })\n         }\n@@ -558,7 +560,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     get!(task, Activeness).unwrap()\n                 };\n                 let listener = activeness.all_clean_event.listen_with_note(move || {\n-                    format!(\"try_read_task_output (strongly consistent) from {reader:?}\")\n+                    move || format!(\"try_read_task_output (strongly consistent) from {reader:?}\")\n                 });\n                 drop(task);\n                 if !task_ids_to_schedule.is_empty() {\n@@ -612,19 +614,21 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             return result;\n         }\n \n-        let reader_desc = reader.map(|r| self.get_task_desc_fn(r));\n         let note = move || {\n-            if let Some(reader_desc) = reader_desc.as_ref() {\n-                format!(\"try_read_task_output (recompute) from {}\", reader_desc())\n-            } else {\n-                \"try_read_task_output (recompute, untracked)\".to_string()\n+            let reader_desc = reader.map(|r| self.get_task_desc_fn(r));\n+            move || {\n+                if let Some(reader_desc) = reader_desc.as_ref() {\n+                    format!(\"try_read_task_output (recompute) from {}\", (reader_desc)())\n+                } else {\n+                    \"try_read_task_output (recompute, untracked)\".to_string()\n+                }\n             }\n         };\n \n         // Output doesn't exist. We need to schedule the task to compute it.\n         let (item, listener) = CachedDataItem::new_scheduled_with_listener(\n             TaskExecutionReason::OutputNotAvailable,\n-            self.get_task_desc_fn(task_id),\n+            || self.get_task_desc_fn(task_id),\n             note,\n         );\n         // It's not possible that the task is InProgress at this point. If it is InProgress {\n@@ -756,7 +760,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         } else if !is_scheduled\n             && task.add(CachedDataItem::new_scheduled(\n                 TaskExecutionReason::CellNotAvailable,\n-                self.get_task_desc_fn(task_id),\n+                || self.get_task_desc_fn(task_id),\n             ))\n         {\n             turbo_tasks.schedule(task_id);\n@@ -772,12 +776,14 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         reader: Option<TaskId>,\n         cell: CellId,\n     ) -> (EventListener, bool) {\n-        let reader_desc = reader.map(|r| self.get_task_desc_fn(r));\n         let note = move || {\n-            if let Some(reader_desc) = reader_desc.as_ref() {\n-                format!(\"try_read_task_cell (in progress) from {}\", reader_desc())\n-            } else {\n-                \"try_read_task_cell (in progress, untracked)\".to_string()\n+            let reader_desc = reader.map(|r| self.get_task_desc_fn(r));\n+            move || {\n+                if let Some(reader_desc) = reader_desc.as_ref() {\n+                    format!(\"try_read_task_cell (in progress) from {}\", (reader_desc)())\n+                } else {\n+                    \"try_read_task_cell (in progress, untracked)\".to_string()\n+                }\n             }\n         };\n         if let Some(in_progress) = get!(task, InProgressCell { cell }) {\n@@ -812,7 +818,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         None\n     }\n \n-    // TODO feature flag that for hanging detection only\n     fn get_task_desc_fn(&self, task_id: TaskId) -> impl Fn() -> String + Send + Sync + 'static {\n         let task_type = self.lookup_task_type(task_id);\n         move || {\n@@ -2357,9 +2362,11 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             }\n             task.add(CachedDataItem::new_scheduled(\n                 TaskExecutionReason::Initial,\n-                move || match root_type {\n-                    RootType::RootTask => \"Root Task\".to_string(),\n-                    RootType::OnceTask => \"Once Task\".to_string(),\n+                move || {\n+                    move || match root_type {\n+                        RootType::RootTask => \"Root Task\".to_string(),\n+                        RootType::OnceTask => \"Once Task\".to_string(),\n+                    }\n                 },\n             ));\n         }"
        },
        {
            "sha": "f6ed53512d88cb932ee772ded696fb4f752421a3",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/aggregation_update.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs?ref=c6e23a6bb3947486e0df44fb661cb9ea2dc243cd",
            "patch": "@@ -1219,7 +1219,7 @@ impl AggregationUpdateQueue {\n             None\n         };\n         if let Some(reason) = should_schedule {\n-            let description = ctx.get_task_desc_fn(task_id);\n+            let description = || ctx.get_task_desc_fn(task_id);\n             if task.add(CachedDataItem::new_scheduled(reason, description)) {\n                 ctx.schedule(task_id);\n             }"
        },
        {
            "sha": "b93ae185bc50d9fffdbb335a5e5d83527e092570",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/connect_child.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs?ref=c6e23a6bb3947486e0df44fb661cb9ea2dc243cd",
            "patch": "@@ -27,10 +27,9 @@ impl ConnectChildOperation {\n         if !ctx.should_track_children() {\n             let mut task = ctx.task(child_task_id, TaskDataCategory::All);\n             if !task.has_key(&CachedDataItemKey::Output {}) {\n-                let description = ctx.get_task_desc_fn(child_task_id);\n                 let should_schedule = task.add(CachedDataItem::new_scheduled(\n                     TaskExecutionReason::Connect,\n-                    description,\n+                    || ctx.get_task_desc_fn(child_task_id),\n                 ));\n                 drop(task);\n                 if should_schedule {\n@@ -80,10 +79,9 @@ impl ConnectChildOperation {\n             let mut task = ctx.task(child_task_id, TaskDataCategory::All);\n \n             if !task.has_key(&CachedDataItemKey::Output {}) {\n-                let description = ctx.get_task_desc_fn(child_task_id);\n                 let should_schedule = task.add(CachedDataItem::new_scheduled(\n                     TaskExecutionReason::Connect,\n-                    description,\n+                    || ctx.get_task_desc_fn(child_task_id),\n                 ));\n                 drop(task);\n                 if should_schedule {"
        },
        {
            "sha": "ef8ac9a6e287785fc23550db4570a31be59ddb0d",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/invalidate.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs?ref=c6e23a6bb3947486e0df44fb661cb9ea2dc243cd",
            "patch": "@@ -296,7 +296,7 @@ pub fn make_task_dirty_internal(\n     };\n \n     if should_schedule {\n-        let description = ctx.get_task_desc_fn(task_id);\n+        let description = || ctx.get_task_desc_fn(task_id);\n         if task.add(CachedDataItem::new_scheduled(\n             TaskExecutionReason::Invalidated,\n             description,"
        },
        {
            "sha": "fd0cd7e55baabbb57370558e55db698cc0a6d9c7",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data.rs",
            "status": "modified",
            "additions": 29,
            "deletions": 14,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs?ref=c6e23a6bb3947486e0df44fb661cb9ea2dc243cd",
            "patch": "@@ -94,7 +94,9 @@ impl ActivenessState {\n             active_counter: 0,\n             root_ty: None,\n             active_until_clean: false,\n-            all_clean_event: Event::new(move || format!(\"ActivenessState::all_clean_event {id:?}\")),\n+            all_clean_event: Event::new(move || {\n+                move || format!(\"ActivenessState::all_clean_event {id:?}\")\n+            }),\n         }\n     }\n \n@@ -536,7 +538,9 @@ impl Eq for InProgressCellState {}\n impl InProgressCellState {\n     pub fn new(task_id: TaskId, cell: CellId) -> Self {\n         InProgressCellState {\n-            event: Event::new(move || format!(\"InProgressCellState::event ({task_id} {cell:?})\")),\n+            event: Event::new(move || {\n+                move || format!(\"InProgressCellState::event ({task_id} {cell:?})\")\n+            }),\n         }\n     }\n }\n@@ -723,24 +727,35 @@ impl CachedDataItem {\n         }\n     }\n \n-    pub fn new_scheduled(\n+    pub fn new_scheduled<InnerFnDescription>(\n         reason: TaskExecutionReason,\n-        description: impl Fn() -> String + Sync + Send + 'static,\n-    ) -> Self {\n+        description: impl FnOnce() -> InnerFnDescription,\n+    ) -> Self\n+    where\n+        InnerFnDescription: Fn() -> String + Sync + Send + 'static,\n+    {\n+        let done_event = Event::new(move || {\n+            let inner = description();\n+            move || format!(\"{} done_event\", inner())\n+        });\n         CachedDataItem::InProgress {\n-            value: InProgressState::Scheduled {\n-                done_event: Event::new(move || format!(\"{} done_event\", description())),\n-                reason,\n-            },\n+            value: InProgressState::Scheduled { done_event, reason },\n         }\n     }\n \n-    pub fn new_scheduled_with_listener(\n+    pub fn new_scheduled_with_listener<InnerFnDescription, InnerFnNote>(\n         reason: TaskExecutionReason,\n-        description: impl Fn() -> String + Sync + Send + 'static,\n-        note: impl Fn() -> String + Sync + Send + 'static,\n-    ) -> (Self, EventListener) {\n-        let done_event = Event::new(move || format!(\"{} done_event\", description()));\n+        description: impl FnOnce() -> InnerFnDescription,\n+        note: impl FnOnce() -> InnerFnNote,\n+    ) -> (Self, EventListener)\n+    where\n+        InnerFnDescription: Fn() -> String + Sync + Send + 'static,\n+        InnerFnNote: Fn() -> String + Sync + Send + 'static,\n+    {\n+        let done_event = Event::new(move || {\n+            let inner = description();\n+            move || format!(\"{} done_event\", inner())\n+        });\n         let listener = done_event.listen_with_note(note);\n         (\n             CachedDataItem::InProgress {"
        },
        {
            "sha": "1ab8a9293bbb47510ba1db3f26461cdf68a7c70e",
            "filename": "turbopack/crates/turbo-tasks-fs/benches/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fbenches%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fbenches%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fbenches%2Fmod.rs?ref=c6e23a6bb3947486e0df44fb661cb9ea2dc243cd",
            "patch": "@@ -32,7 +32,7 @@ fn bench_file_watching(c: &mut Criterion) {\n         BenchmarkId::new(\"bench_file_watching\", \"change file\"),\n         move |b| {\n             let (tx, rx) = channel();\n-            let event = Arc::new(Event::new(|| \"test event\".to_string()));\n+            let event = Arc::new(Event::new(|| || \"test event\".to_string()));\n \n             let mut watcher = RecommendedWatcher::new(tx, Config::default()).unwrap();\n             watcher.watch(temp_path, RecursiveMode::Recursive).unwrap();"
        },
        {
            "sha": "b12645a650ef5f8f6e1bb83ab78d54e90cceeb67",
            "filename": "turbopack/crates/turbo-tasks-fs/src/mutex_map.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fmutex_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fmutex_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fmutex_map.rs?ref=c6e23a6bb3947486e0df44fb661cb9ea2dc243cd",
            "patch": "@@ -30,7 +30,7 @@ impl<'a, K: Eq + Hash + Clone> MutexMap<K> {\n                             event.listen()\n                         }\n                         None => {\n-                            let event = Event::new(|| \"MutexMap\".to_string());\n+                            let event = Event::new(|| || \"MutexMap\".to_string());\n                             let listener = event.listen();\n                             *state = Some((event, 0));\n                             listener"
        },
        {
            "sha": "46a1f16140899a074820d2528fcc9872b5dde2ab",
            "filename": "turbopack/crates/turbo-tasks-testing/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs?ref=c6e23a6bb3947486e0df44fb661cb9ea2dc243cd",
            "patch": "@@ -52,7 +52,7 @@ impl VcStorage {\n             let mut tasks = self.tasks.lock().unwrap();\n             let i = tasks.len();\n             tasks.push(Task::Spawned(Event::new(move || {\n-                format!(\"Task({i})::event\")\n+                move || format!(\"Task({i})::event\")\n             })));\n             i\n         };"
        },
        {
            "sha": "0b893b2a128adce2f12f2ca9adceebb108951522",
            "filename": "turbopack/crates/turbo-tasks/src/effect.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Feffect.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Feffect.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Feffect.rs?ref=c6e23a6bb3947486e0df44fb661cb9ea2dc243cd",
            "patch": "@@ -85,7 +85,7 @@ impl EffectInstance {\n                     EffectState::NotStarted(_) => {\n                         let EffectState::NotStarted(inner) = std::mem::replace(\n                             &mut *guard,\n-                            EffectState::Started(Event::new(|| \"Effect\".to_string())),\n+                            EffectState::Started(Event::new(|| || \"Effect\".to_string())),\n                         ) else {\n                             unreachable!();\n                         };"
        },
        {
            "sha": "c36c50840b71ad940e9cb7601327f9c54de23853",
            "filename": "turbopack/crates/turbo-tasks/src/event.rs",
            "status": "modified",
            "additions": 114,
            "deletions": 66,
            "changes": 180,
            "blob_url": "https://github.com/vercel/next.js/blob/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fevent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fevent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fevent.rs?ref=c6e23a6bb3947486e0df44fb661cb9ea2dc243cd",
            "patch": "@@ -1,115 +1,121 @@\n-#[cfg(feature = \"hanging_detection\")]\n-use std::sync::Arc;\n-#[cfg(feature = \"hanging_detection\")]\n-use std::task::Poll;\n-#[cfg(feature = \"hanging_detection\")]\n-use std::task::ready;\n-#[cfg(feature = \"hanging_detection\")]\n-use std::time::Duration;\n use std::{\n     fmt::{Debug, Formatter},\n     future::Future,\n     mem::replace,\n     pin::Pin,\n };\n-\n #[cfg(feature = \"hanging_detection\")]\n-use tokio::time::Timeout;\n+use std::{\n+    sync::Arc,\n+    task::{Poll, ready},\n+    time::Duration,\n+};\n+\n #[cfg(feature = \"hanging_detection\")]\n-use tokio::time::timeout;\n+use tokio::time::{Timeout, timeout};\n \n pub struct Event {\n     #[cfg(feature = \"hanging_detection\")]\n     description: Arc<dyn Fn() -> String + Sync + Send>,\n     event: event_listener::Event,\n }\n \n-#[cfg(not(feature = \"hanging_detection\"))]\n impl Event {\n-    /// see [event_listener::Event]::new\n+    /// See [`event_listener::Event::new`]. May attach a description that may optionally be read\n+    /// later.\n+    ///\n+    /// This confusingly takes a closure ([`FnOnce`]) that returns a nested closure ([`Fn`]).\n+    ///\n+    /// When `hanging_detection` is disabled, `description` is never called.\n+    ///\n+    /// When `hanging_detection` is enabled, the outer closure is called immediately. The outer\n+    /// closure can have an ephemeral lifetime. The inner closure must be `'static`, but is called\n+    /// only when the `description` is actually read.\n+    ///\n+    /// The outer closure allows avoiding extra lookups (e.g. task type info) that may be needed to\n+    /// capture information needed for constructing (moving into) the inner closure.\n     #[inline(always)]\n-    pub fn new(_description: impl Fn() -> String + Sync + Send + 'static) -> Self {\n-        Self {\n+    pub fn new<InnerFn>(_description: impl FnOnce() -> InnerFn) -> Self\n+    where\n+        InnerFn: Fn() -> String + Sync + Send + 'static,\n+    {\n+        #[cfg(not(feature = \"hanging_detection\"))]\n+        return Self {\n             event: event_listener::Event::new(),\n-        }\n-    }\n-\n-    /// see [event_listener::Event]::listen\n-    pub fn listen(&self) -> EventListener {\n-        EventListener {\n-            listener: self.event.listen(),\n-        }\n-    }\n-\n-    /// see [event_listener::Event]::listen\n-    pub fn listen_with_note(\n-        &self,\n-        _note: impl Fn() -> String + Sync + Send + 'static,\n-    ) -> EventListener {\n-        EventListener {\n-            listener: self.event.listen(),\n-        }\n-    }\n-\n-    /// pulls out the event listener, leaving a new, empty event in its place.\n-    pub fn take(&mut self) -> Self {\n-        Self {\n-            event: replace(&mut self.event, event_listener::Event::new()),\n-        }\n-    }\n-}\n-\n-#[cfg(feature = \"hanging_detection\")]\n-impl Event {\n-    /// see [event_listener::Event]::new\n-    #[inline(always)]\n-    pub fn new(description: impl Fn() -> String + Sync + Send + 'static) -> Self {\n-        Self {\n-            description: Arc::new(description),\n+        };\n+        #[cfg(feature = \"hanging_detection\")]\n+        return Self {\n+            description: Arc::new((_description)()),\n             event: event_listener::Event::new(),\n-        }\n+        };\n     }\n \n-    /// see [event_listener::Event]::listen\n+    /// See [`event_listener::Event::listen`].\n     pub fn listen(&self) -> EventListener {\n-        EventListener {\n+        #[cfg(not(feature = \"hanging_detection\"))]\n+        return EventListener {\n+            listener: self.event.listen(),\n+        };\n+        #[cfg(feature = \"hanging_detection\")]\n+        return EventListener {\n             description: self.description.clone(),\n-            note: Arc::new(|| String::new()),\n+            note: Arc::new(String::new),\n             future: Some(Box::pin(timeout(\n                 Duration::from_secs(10),\n                 self.event.listen(),\n             ))),\n             duration: Duration::from_secs(10),\n-        }\n+        };\n     }\n \n-    /// see [event_listener::Event]::listen\n-    pub fn listen_with_note(\n-        &self,\n-        note: impl Fn() -> String + Sync + Send + 'static,\n-    ) -> EventListener {\n-        EventListener {\n+    /// See [`event_listener::Event::listen`]. May attach a note that may optionally be read later.\n+    ///\n+    /// This confusingly takes a closure ([`FnOnce`]) that returns a nested closure ([`Fn`]).\n+    ///\n+    /// When `hanging_detection` is disabled, `note` is never called.\n+    ///\n+    /// When `hanging_detection` is enabled, the outer closure is called immediately. The outer\n+    /// closure can have an ephemeral lifetime. The inner closer must be `'static`, but is called\n+    /// only when the `note` is actually read.\n+    ///\n+    /// The outer closure allow avoiding extra lookups (e.g. task type info) that may be needed to\n+    /// capture information needed for constructing (moving into) the inner closure.\n+    pub fn listen_with_note<InnerFn>(&self, _note: impl FnOnce() -> InnerFn) -> EventListener\n+    where\n+        InnerFn: Fn() -> String + Sync + Send + 'static,\n+    {\n+        #[cfg(not(feature = \"hanging_detection\"))]\n+        return EventListener {\n+            listener: self.event.listen(),\n+        };\n+        #[cfg(feature = \"hanging_detection\")]\n+        return EventListener {\n             description: self.description.clone(),\n-            note: Arc::new(note),\n+            note: Arc::new((_note)()),\n             future: Some(Box::pin(timeout(\n                 Duration::from_secs(10),\n                 self.event.listen(),\n             ))),\n             duration: Duration::from_secs(10),\n-        }\n+        };\n     }\n \n     /// pulls out the event listener, leaving a new, empty event in its place.\n     pub fn take(&mut self) -> Event {\n-        Self {\n+        #[cfg(not(feature = \"hanging_detection\"))]\n+        return Self {\n+            event: replace(&mut self.event, event_listener::Event::new()),\n+        };\n+        #[cfg(feature = \"hanging_detection\")]\n+        return Self {\n             description: self.description.clone(),\n             event: replace(&mut self.event, event_listener::Event::new()),\n-        }\n+        };\n     }\n }\n \n impl Event {\n-    /// see [event_listener::Event]::notify\n+    /// see [`event_listener::Event::notify`]\n     pub fn notify(&self, n: usize) {\n         self.event.notify(n);\n     }\n@@ -210,3 +216,45 @@ impl Future for EventListener {\n         Poll::Ready(())\n     }\n }\n+\n+#[cfg(all(test, not(feature = \"hanging_detection\")))]\n+mod tests {\n+    use std::hint::black_box;\n+\n+    use tokio::time::{Duration, timeout};\n+\n+    use super::*;\n+\n+    // The closures used for descriptions/notes should be eliminated. This may only happen at higher\n+    // optimization levels (that would be okay), but in practice it seems to work even for\n+    // opt-level=0.\n+    #[tokio::test]\n+    async fn ensure_dead_code_elimination() {\n+        fn dead_fn() {\n+            // This code triggers a build error when it's not removed.\n+            unsafe {\n+                unsafe extern \"C\" {\n+                    fn trigger_link_error() -> !;\n+                }\n+                trigger_link_error();\n+            }\n+        }\n+\n+        let event = black_box(Event::new(|| {\n+            dead_fn();\n+            || {\n+                dead_fn();\n+                String::new()\n+            }\n+        }));\n+        let listener = black_box(event.listen_with_note(|| {\n+            dead_fn();\n+            || {\n+                dead_fn();\n+                String::new()\n+            }\n+        }));\n+\n+        let _ = black_box(timeout(Duration::from_millis(10), listener)).await;\n+    }\n+}"
        },
        {
            "sha": "17dfb374473ab6264d369b4f333ab456628b635b",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 10,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c6e23a6bb3947486e0df44fb661cb9ea2dc243cd/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=c6e23a6bb3947486e0df44fb661cb9ea2dc243cd",
            "patch": "@@ -507,10 +507,10 @@ impl<B: Backend + 'static> TurboTasks<B> {\n             scheduled_tasks: AtomicUsize::new(0),\n             start: Default::default(),\n             aggregated_update: Default::default(),\n-            event: Event::new(|| \"TurboTasks::event\".to_string()),\n-            event_start: Event::new(|| \"TurboTasks::event_start\".to_string()),\n-            event_foreground: Event::new(|| \"TurboTasks::event_foreground\".to_string()),\n-            event_background: Event::new(|| \"TurboTasks::event_background\".to_string()),\n+            event: Event::new(|| || \"TurboTasks::event\".to_string()),\n+            event_start: Event::new(|| || \"TurboTasks::event_start\".to_string()),\n+            event_foreground: Event::new(|| || \"TurboTasks::event_foreground\".to_string()),\n+            event_background: Event::new(|| || \"TurboTasks::event_background\".to_string()),\n             program_start: Instant::now(),\n             compilation_events: CompilationEventQueue::default(),\n         });\n@@ -794,7 +794,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n             .with(|gts| {\n                 let mut gts_write = gts.write().unwrap();\n                 let local_task_id = gts_write.create_local_task(LocalTask::Scheduled {\n-                    done_event: Event::new({\n+                    done_event: Event::new(move || {\n                         move || format!(\"LocalTask({task_type})::done_event\")\n                     }),\n                 });\n@@ -985,7 +985,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n     ) -> Option<UpdateInfo> {\n         let listener = self\n             .event\n-            .listen_with_note(|| \"wait for update info\".to_string());\n+            .listen_with_note(|| || \"wait for update info\".to_string());\n         let wait_for_finish = {\n             let (update, reason_set) = &mut *self.aggregated_update.lock().unwrap();\n             if aggregation.is_zero() {\n@@ -1011,7 +1011,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                 // wait for start, then wait for finish or timeout\n                 let start_listener = self\n                     .event_start\n-                    .listen_with_note(|| \"wait for update info\".to_string());\n+                    .listen_with_note(|| || \"wait for update info\".to_string());\n                 if self.currently_scheduled_tasks.load(Ordering::Acquire) == 0 {\n                     start_listener.await;\n                 } else {\n@@ -1029,7 +1029,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                     () = tokio::time::sleep(aggregation) => {\n                         break;\n                     }\n-                    () = self.event.listen_with_note(|| \"wait for update info\".to_string()) => {\n+                    () = self.event.listen_with_note(|| || \"wait for update info\".to_string()) => {\n                         // Resets the sleep\n                     }\n                 }\n@@ -1063,7 +1063,9 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         self.backend.stopping(self);\n         self.stopped.store(true, Ordering::Release);\n         {\n-            let listener = self.event.listen_with_note(|| \"wait for stop\".to_string());\n+            let listener = self\n+                .event\n+                .listen_with_note(|| || \"wait for stop\".to_string());\n             if self.currently_scheduled_tasks.load(Ordering::Acquire) != 0 {\n                 listener.await;\n             }\n@@ -1097,7 +1099,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                 .scope(this.clone(), async move {\n                     while this.currently_scheduled_tasks.load(Ordering::Acquire) != 0 {\n                         let listener = this.event.listen_with_note(|| {\n-                            \"background job waiting for execution\".to_string()\n+                            || \"background job waiting for execution\".to_string()\n                         });\n                         if this.currently_scheduled_tasks.load(Ordering::Acquire) != 0 {\n                             listener.await;"
        }
    ],
    "stats": {
        "total": 320,
        "additions": 195,
        "deletions": 125
    }
}