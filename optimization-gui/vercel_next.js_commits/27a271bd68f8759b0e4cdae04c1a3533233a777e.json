{
    "author": "lukesandberg",
    "message": "[turbopack] Rename `traverse_edges_from_entries_topological` to `traverse_edges_from_entries_dfs` (#81481)\n\n## Rename `traverse_edges_from_entries_topological` to `traverse_edges_from_entries_dfs`\n\nThis PR renames the `traverse_edges_from_entries_topological` method to `traverse_edges_from_entries_dfs` to better reflect its actual behavior. The method performs a depth-first search traversal rather than a topological sort.\n\nThe PR also:\n- Updates the method documentation to clarify that it performs a DFS traversal\n- Makes `ClientReferenceMapType` derive `Copy` for better ergonomics\n- Removes unnecessary `ResolvedVc::upcast` call in client references mapping\n- Renames some variables for clarity (`actions` â†’ `client_references`)\n- Removes unused `module_graph_for_entries` function\n- Adds some tests for the traversal routine.  Not very interesting for this traversal but should make it easier to test future traversals.\n\nThese changes improve code clarity and correctness by ensuring the method name accurately describes its behavior.",
    "sha": "27a271bd68f8759b0e4cdae04c1a3533233a777e",
    "files": [
        {
            "sha": "d40e23ed8d1b73bf0564fab15638ead2e9fdc7ae",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/27a271bd68f8759b0e4cdae04c1a3533233a777e/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/27a271bd68f8759b0e4cdae04c1a3533233a777e/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=27a271bd68f8759b0e4cdae04c1a3533233a777e",
            "patch": "@@ -9639,10 +9639,12 @@ dependencies = [\n  \"turbo-prehash\",\n  \"turbo-rcstr\",\n  \"turbo-tasks\",\n+ \"turbo-tasks-backend\",\n  \"turbo-tasks-build\",\n  \"turbo-tasks-env\",\n  \"turbo-tasks-fs\",\n  \"turbo-tasks-hash\",\n+ \"turbo-tasks-testing\",\n  \"urlencoding\",\n ]\n "
        },
        {
            "sha": "fd192d3f79713fc3e62d219b0cae2383a8a00957",
            "filename": "crates/next-api/src/client_references.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/27a271bd68f8759b0e4cdae04c1a3533233a777e/crates%2Fnext-api%2Fsrc%2Fclient_references.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/27a271bd68f8759b0e4cdae04c1a3533233a777e/crates%2Fnext-api%2Fsrc%2Fclient_references.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fclient_references.rs?ref=27a271bd68f8759b0e4cdae04c1a3533233a777e",
            "patch": "@@ -13,7 +13,7 @@ use turbopack::css::chunk::CssChunkPlaceable;\n use turbopack_core::{module::Module, module_graph::SingleModuleGraph};\n \n #[derive(\n-    Clone, Serialize, Deserialize, Eq, PartialEq, TraceRawVcs, ValueDebugFormat, NonLocalValue,\n+    Copy, Clone, Serialize, Deserialize, Eq, PartialEq, TraceRawVcs, ValueDebugFormat, NonLocalValue,\n )]\n pub enum ClientReferenceMapType {\n     EcmascriptClientReference {\n@@ -31,7 +31,7 @@ pub struct ClientReferencesSet(FxHashMap<ResolvedVc<Box<dyn Module>>, ClientRefe\n pub async fn map_client_references(\n     graph: Vc<SingleModuleGraph>,\n ) -> Result<Vc<ClientReferencesSet>> {\n-    let actions = graph\n+    let client_references = graph\n         .await?\n         .iter_nodes()\n         .map(|node| async move {\n@@ -52,9 +52,9 @@ pub async fn map_client_references(\n             {\n                 Ok(Some((\n                     module,\n-                    ClientReferenceMapType::CssClientReference(ResolvedVc::upcast(\n+                    ClientReferenceMapType::CssClientReference(\n                         client_reference_module.await?.client_module,\n-                    )),\n+                    ),\n                 )))\n             } else if let Some(server_component) =\n                 ResolvedVc::try_downcast_type::<NextServerComponentModule>(module)\n@@ -69,5 +69,5 @@ pub async fn map_client_references(\n         })\n         .try_flat_join()\n         .await?;\n-    Ok(Vc::cell(actions.into_iter().collect()))\n+    Ok(Vc::cell(client_references.into_iter().collect()))\n }"
        },
        {
            "sha": "8f27dd663022a3aad3b0011d1949d0252f60439b",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/27a271bd68f8759b0e4cdae04c1a3533233a777e/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/27a271bd68f8759b0e4cdae04c1a3533233a777e/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=27a271bd68f8759b0e4cdae04c1a3533233a777e",
            "patch": "@@ -291,7 +291,7 @@ impl ClientReferencesGraph {\n             let mut client_references_by_server_component =\n                 FxIndexMap::from_iter([(None, Vec::new())]);\n \n-            graph.traverse_edges_from_entries_topological(\n+            graph.traverse_edges_from_entries_dfs(\n                 entries,\n                 // state_map is `module -> Option< the current so parent server component >`\n                 &mut FxHashMap::default(),"
        },
        {
            "sha": "b1347fd2ef67dc8751b6edc143b425f01491349a",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 12,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/27a271bd68f8759b0e4cdae04c1a3533233a777e/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/27a271bd68f8759b0e4cdae04c1a3533233a777e/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=27a271bd68f8759b0e4cdae04c1a3533233a777e",
            "patch": "@@ -960,18 +960,6 @@ impl Project {\n         })\n     }\n \n-    #[turbo_tasks::function]\n-    pub async fn module_graph_for_entries(\n-        self: Vc<Self>,\n-        entries: Vc<GraphEntries>,\n-    ) -> Result<Vc<ModuleGraph>> {\n-        Ok(if *self.per_page_module_graph().await? {\n-            ModuleGraph::from_modules(entries, self.next_mode().await?.is_production())\n-        } else {\n-            *self.whole_app_module_graphs().await?.full\n-        })\n-    }\n-\n     #[turbo_tasks::function]\n     pub async fn whole_app_module_graphs(self: ResolvedVc<Self>) -> Result<Vc<ModuleGraphs>> {\n         async move {"
        },
        {
            "sha": "3bda9c1f027e3ea946c33d31e5d0550afbf3ea80",
            "filename": "turbopack/crates/turbopack-core/Cargo.toml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2FCargo.toml?ref=27a271bd68f8759b0e4cdae04c1a3533233a777e",
            "patch": "@@ -50,6 +50,8 @@ turbo-tasks-build = { workspace = true }\n [dev-dependencies]\n rstest = { workspace = true }\n tokio = { workspace = true }\n+turbo-tasks-testing = { workspace = true }\n+turbo-tasks-backend = { workspace = true }\n \n [features]\n default = []"
        },
        {
            "sha": "bd6f804027f841b478e07a2dbb8bbc0baf5b9288",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunk_group.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs?ref=27a271bd68f8759b0e4cdae04c1a3533233a777e",
            "patch": "@@ -220,7 +220,7 @@ pub async fn chunk_group_content(\n         entries.push(module_batches_graph.get_entry_index(entry).await?);\n     }\n \n-    module_batches_graph.traverse_edges_from_entries_topological(\n+    module_batches_graph.traverse_edges_from_entries_dfs(\n         entries,\n         &mut state,\n         |parent_info, &node, state| {"
        },
        {
            "sha": "0d0429b91e8c3d20e4ae6a99d88ce4fc143df6f3",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/async_module_info.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs?ref=27a271bd68f8759b0e4cdae04c1a3533233a777e",
            "patch": "@@ -73,7 +73,7 @@ async fn compute_async_module_info_single(\n     // modules in the SCC is async.\n \n     let mut async_modules = self_async_modules;\n-    graph.traverse_edges_from_entries_topological(\n+    graph.traverse_edges_from_entries_dfs(\n         graph.entry_modules(),\n         &mut (),\n         |_, _, _| Ok(GraphTraversalAction::Continue),"
        },
        {
            "sha": "bb762ec4cc532851d302ad6081ee03ef2c5a4d52",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/merged_modules.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs?ref=27a271bd68f8759b0e4cdae04c1a3533233a777e",
            "patch": "@@ -251,7 +251,7 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             let mut visited = FxHashSet::default();\n \n             module_graph\n-                .traverse_edges_from_entries_topological(\n+                .traverse_edges_from_entries_dfs(\n                     chunk_group.entries(),\n                     &mut (),\n                     |parent_info, node, _| {\n@@ -332,7 +332,7 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             FxHashSet::with_capacity_and_hasher(module_merged_groups.len(), Default::default());\n \n         module_graph\n-            .traverse_edges_from_entries_topological(\n+            .traverse_edges_from_entries_dfs(\n                 entries,\n                 &mut (),\n                 |_, _, _| Ok(GraphTraversalAction::Continue),"
        },
        {
            "sha": "3f3676ca9040fc18692efded327aeec43d21e7eb",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 308,
            "deletions": 32,
            "changes": 340,
            "blob_url": "https://github.com/vercel/next.js/blob/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=27a271bd68f8759b0e4cdae04c1a3533233a777e",
            "patch": "@@ -563,15 +563,16 @@ impl SingleModuleGraph {\n         Ok(())\n     }\n \n-    /// Traverses all reachable edges in topological order. The preorder visitor can be used to\n-    /// forward state down the graph, and to skip subgraphs\n+    /// Traverses all reachable edges in dfs order. The preorder visitor can be used to\n+    /// forward state down the graph, and to skip subgraphs.\n     ///\n     /// Use this to collect modules in evaluation order.\n     ///\n-    /// Target nodes can be revisited (once per incoming edge).\n+    /// Target nodes can be revisited (once per incoming edge) in the preorder_visitor, in the post\n+    /// order visitor they are visited exactly once with the first edge they were discovered with.\n     /// Edges are traversed in normal order, so should correspond to reference order.\n     ///\n-    /// * `entry` - The entry module to start the traversal from\n+    /// * `entries` - The entry modules to start the traversal from\n     /// * `state` - The state to be passed to the visitors\n     /// * `visit_preorder` - Called before visiting the children of a node.\n     ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n@@ -580,7 +581,7 @@ impl SingleModuleGraph {\n     /// * `visit_postorder` - Called after visiting the children of a node. Return\n     ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode, state &S\n-    pub fn traverse_edges_from_entries_topological<'a, S>(\n+    pub fn traverse_edges_from_entries_dfs<'a, S>(\n         &'a self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         state: &mut S,\n@@ -598,15 +599,14 @@ impl SingleModuleGraph {\n         let graph = &self.graph;\n         let entries = entries.into_iter().map(|e| self.get_module(e).unwrap());\n \n-        enum TopologicalPass {\n+        enum Pass {\n             Visit,\n             ExpandAndVisit,\n         }\n \n         #[allow(clippy::type_complexity)] // This is a temporary internal structure\n-        let mut stack: Vec<(TopologicalPass, Option<(NodeIndex, EdgeIndex)>, NodeIndex)> = entries\n-            .map(|e| (TopologicalPass::ExpandAndVisit, None, e))\n-            .collect();\n+        let mut stack: Vec<(Pass, Option<(NodeIndex, EdgeIndex)>, NodeIndex)> =\n+            entries.map(|e| (Pass::ExpandAndVisit, None, e)).collect();\n         let mut expanded = FxHashSet::default();\n         while let Some((pass, parent, current)) = stack.pop() {\n             let parent_arg = parent.map(|parent| {\n@@ -621,24 +621,20 @@ impl SingleModuleGraph {\n                 )\n             });\n             match pass {\n-                TopologicalPass::Visit => {\n+                Pass::Visit => {\n                     visit_postorder(parent_arg, graph.node_weight(current).unwrap(), state)?;\n                 }\n-                TopologicalPass::ExpandAndVisit => match graph.node_weight(current).unwrap() {\n+                Pass::ExpandAndVisit => match graph.node_weight(current).unwrap() {\n                     current_node @ SingleModuleGraphNode::Module(_) => {\n                         let action = visit_preorder(parent_arg, current_node, state)?;\n                         if action == GraphTraversalAction::Exclude {\n                             continue;\n                         }\n-                        stack.push((TopologicalPass::Visit, parent, current));\n+                        stack.push((Pass::Visit, parent, current));\n                         if action == GraphTraversalAction::Continue && expanded.insert(current) {\n                             stack.extend(iter_neighbors_rev(graph, current).map(\n                                 |(edge, child)| {\n-                                    (\n-                                        TopologicalPass::ExpandAndVisit,\n-                                        Some((current, edge)),\n-                                        child,\n-                                    )\n+                                    (Pass::ExpandAndVisit, Some((current, edge)), child)\n                                 },\n                             ));\n                         }\n@@ -1304,15 +1300,16 @@ impl ModuleGraph {\n         Ok(())\n     }\n \n-    /// Traverses all reachable edges in topological order. The preorder visitor can be used to\n+    /// Traverses all reachable edges in dfs order. The preorder visitor can be used to\n     /// forward state down the graph, and to skip subgraphs\n     ///\n     /// Use this to collect modules in evaluation order.\n     ///\n-    /// Target nodes can be revisited (once per incoming edge).\n+    /// Target nodes can be revisited (once per incoming edge) in the preorder_visitor, in the post\n+    /// order visitor they are visited exactly once with the first edge they were discovered with.\n     /// Edges are traversed in normal order, so should correspond to reference order.\n     ///\n-    /// * `entry` - The entry module to start the traversal from\n+    /// * `entries` - The entry modules to start the traversal from\n     /// * `state` - The state to be passed to the visitors\n     /// * `visit_preorder` - Called before visiting the children of a node.\n     ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n@@ -1322,7 +1319,7 @@ impl ModuleGraph {\n     ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode, state &S\n     ///    - Can return [GraphTraversalAction]s to control the traversal\n-    pub async fn traverse_edges_from_entries_topological<S>(\n+    pub async fn traverse_edges_from_entries_dfs<S>(\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         state: &mut S,\n@@ -1341,19 +1338,16 @@ impl ModuleGraph {\n \n         let entries = entries.into_iter().collect::<Vec<_>>();\n \n-        enum TopologicalPass {\n+        enum Pass {\n             Visit,\n             ExpandAndVisit,\n         }\n         #[allow(clippy::type_complexity)] // This is a temporary internal structure\n-        let mut stack: Vec<(\n-            TopologicalPass,\n-            Option<(GraphNodeIndex, EdgeIndex)>,\n-            GraphNodeIndex,\n-        )> = Vec::with_capacity(entries.len());\n+        let mut stack: Vec<(Pass, Option<(GraphNodeIndex, EdgeIndex)>, GraphNodeIndex)> =\n+            Vec::with_capacity(entries.len());\n         for entry in entries.into_iter().rev() {\n             stack.push((\n-                TopologicalPass::ExpandAndVisit,\n+                Pass::ExpandAndVisit,\n                 None,\n                 ModuleGraph::get_entry(&graphs, entry).await?,\n             ));\n@@ -1372,15 +1366,15 @@ impl ModuleGraph {\n             };\n             let current_node = get_node!(graphs, current)?;\n             match pass {\n-                TopologicalPass::Visit => {\n+                Pass::Visit => {\n                     visit_postorder(parent_arg, current_node, state)?;\n                 }\n-                TopologicalPass::ExpandAndVisit => {\n+                Pass::ExpandAndVisit => {\n                     let action = visit_preorder(parent_arg, current_node, state)?;\n                     if action == GraphTraversalAction::Exclude {\n                         continue;\n                     }\n-                    stack.push((TopologicalPass::Visit, parent, current));\n+                    stack.push((Pass::Visit, parent, current));\n                     if action == GraphTraversalAction::Continue && expanded.insert(current) {\n                         let graph = &graphs[current.graph_idx()].graph;\n                         let (neighbors_rev, current) = match graph\n@@ -1398,7 +1392,7 @@ impl ModuleGraph {\n                         };\n                         stack.extend(neighbors_rev.map(|(edge, child)| {\n                             (\n-                                TopologicalPass::ExpandAndVisit,\n+                                Pass::ExpandAndVisit,\n                                 Some((current, edge)),\n                                 GraphNodeIndex {\n                                     graph_idx: current.graph_idx,\n@@ -1799,3 +1793,285 @@ impl Visit<(SingleModuleGraphBuilderNode, ExportUsage)> for SingleModuleGraphBui\n         }\n     }\n }\n+\n+#[cfg(test)]\n+pub mod tests {\n+    use anyhow::Result;\n+    use rustc_hash::FxHashMap;\n+    use turbo_rcstr::{RcStr, rcstr};\n+    use turbo_tasks::{ReadRef, ResolvedVc, TryJoinIterExt, Vc};\n+    use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n+    use turbo_tasks_fs::{FileSystem, FileSystemPath, VirtualFileSystem};\n+\n+    use crate::{\n+        asset::{Asset, AssetContent},\n+        ident::AssetIdent,\n+        module::Module,\n+        module_graph::{\n+            GraphEntries, GraphTraversalAction, SingleModuleGraph,\n+            chunk_group_info::ChunkGroupEntry,\n+        },\n+        reference::{ModuleReference, ModuleReferences, SingleChunkableModuleReference},\n+        resolve::ExportUsage,\n+    };\n+\n+    #[tokio::test]\n+    async fn traverse_dfs_from_entries_diamond() {\n+        run_graph_test(\n+            vec![rcstr!(\"a.js\")],\n+            {\n+                let mut deps = FxHashMap::default();\n+                // A classic diamond dependency on d\n+                deps.insert(rcstr!(\"a.js\"), vec![rcstr!(\"b.js\"), rcstr!(\"c.js\")]);\n+                deps.insert(rcstr!(\"b.js\"), vec![rcstr!(\"d.js\")]);\n+                deps.insert(rcstr!(\"c.js\"), vec![rcstr!(\"d.js\")]);\n+                deps\n+            },\n+            |graph, entry_modules, module_to_name| {\n+                let mut preorder_visits = Vec::new();\n+                let mut postorder_visits = Vec::new();\n+\n+                graph.traverse_edges_from_entries_dfs(\n+                    entry_modules,\n+                    &mut (),\n+                    |parent, target, _| {\n+                        preorder_visits.push((\n+                            parent\n+                                .map(|(node, _)| module_to_name.get(&node.module).unwrap().clone()),\n+                            module_to_name.get(&target.module()).unwrap().clone(),\n+                        ));\n+                        Ok(GraphTraversalAction::Continue)\n+                    },\n+                    |parent, target, _| {\n+                        postorder_visits.push((\n+                            parent\n+                                .map(|(node, _)| module_to_name.get(&node.module).unwrap().clone()),\n+                            module_to_name.get(&target.module()).unwrap().clone(),\n+                        ));\n+                        Ok(())\n+                    },\n+                )?;\n+                assert_eq!(\n+                    vec![\n+                        (None, rcstr!(\"a.js\")),\n+                        (Some(rcstr!(\"a.js\")), rcstr!(\"b.js\")),\n+                        (Some(rcstr!(\"b.js\")), rcstr!(\"d.js\")),\n+                        (Some(rcstr!(\"a.js\")), rcstr!(\"c.js\")),\n+                        (Some(rcstr!(\"c.js\")), rcstr!(\"d.js\"))\n+                    ],\n+                    preorder_visits\n+                );\n+                assert_eq!(\n+                    vec![\n+                        (Some(rcstr!(\"b.js\")), rcstr!(\"d.js\")),\n+                        (Some(rcstr!(\"a.js\")), rcstr!(\"b.js\")),\n+                        (Some(rcstr!(\"c.js\")), rcstr!(\"d.js\")),\n+                        (Some(rcstr!(\"a.js\")), rcstr!(\"c.js\")),\n+                        (None, rcstr!(\"a.js\"))\n+                    ],\n+                    postorder_visits\n+                );\n+                Ok(())\n+            },\n+        )\n+        .await;\n+    }\n+\n+    #[tokio::test]\n+    async fn traverse_dfs_from_entries_cycle() {\n+        run_graph_test(\n+            vec![rcstr!(\"a.js\")],\n+            {\n+                let mut deps = FxHashMap::default();\n+                // A cycle of length 3\n+                deps.insert(rcstr!(\"a.js\"), vec![rcstr!(\"b.js\")]);\n+                deps.insert(rcstr!(\"b.js\"), vec![rcstr!(\"c.js\")]);\n+                deps.insert(rcstr!(\"c.js\"), vec![rcstr!(\"a.js\")]);\n+                deps\n+            },\n+            |graph, entry_modules, module_to_name| {\n+                let mut preorder_visits = Vec::new();\n+                let mut postorder_visits = Vec::new();\n+\n+                graph.traverse_edges_from_entries_dfs(\n+                    entry_modules,\n+                    &mut (),\n+                    |parent, target, _| {\n+                        preorder_visits.push((\n+                            parent\n+                                .map(|(node, _)| module_to_name.get(&node.module).unwrap().clone()),\n+                            module_to_name.get(&target.module()).unwrap().clone(),\n+                        ));\n+                        Ok(GraphTraversalAction::Continue)\n+                    },\n+                    |parent, target, _| {\n+                        postorder_visits.push((\n+                            parent\n+                                .map(|(node, _)| module_to_name.get(&node.module).unwrap().clone()),\n+                            module_to_name.get(&target.module()).unwrap().clone(),\n+                        ));\n+                        Ok(())\n+                    },\n+                )?;\n+                assert_eq!(\n+                    vec![\n+                        (None, rcstr!(\"a.js\")),\n+                        (Some(rcstr!(\"a.js\")), rcstr!(\"b.js\")),\n+                        (Some(rcstr!(\"b.js\")), rcstr!(\"c.js\")),\n+                        (Some(rcstr!(\"c.js\")), rcstr!(\"a.js\")),\n+                    ],\n+                    preorder_visits\n+                );\n+                assert_eq!(\n+                    vec![\n+                        (Some(rcstr!(\"c.js\")), rcstr!(\"a.js\")),\n+                        (Some(rcstr!(\"b.js\")), rcstr!(\"c.js\")),\n+                        (Some(rcstr!(\"a.js\")), rcstr!(\"b.js\")),\n+                        (None, rcstr!(\"a.js\"))\n+                    ],\n+                    postorder_visits\n+                );\n+                Ok(())\n+            },\n+        )\n+        .await;\n+    }\n+\n+    #[turbo_tasks::value(shared)]\n+    struct TestRepo {\n+        repo: FxHashMap<FileSystemPath, Vec<FileSystemPath>>,\n+    }\n+    #[turbo_tasks::value]\n+    struct MockModule {\n+        path: FileSystemPath,\n+        repo: ResolvedVc<TestRepo>,\n+    }\n+    #[turbo_tasks::value_impl]\n+    impl MockModule {\n+        #[turbo_tasks::function]\n+        fn new(path: FileSystemPath, repo: ResolvedVc<TestRepo>) -> Vc<Self> {\n+            Self { path, repo }.cell()\n+        }\n+    }\n+\n+    #[turbo_tasks::value_impl]\n+    impl Asset for MockModule {\n+        #[turbo_tasks::function]\n+        fn content(&self) -> Vc<AssetContent> {\n+            todo!()\n+        }\n+    }\n+\n+    #[turbo_tasks::value_impl]\n+    impl Module for MockModule {\n+        #[turbo_tasks::function]\n+        fn ident(&self) -> Vc<AssetIdent> {\n+            AssetIdent::from_path(self.path.clone())\n+        }\n+\n+        #[turbo_tasks::function]\n+        async fn references(&self) -> Result<Vc<ModuleReferences>> {\n+            let repo = self.repo.await?;\n+            let references = match repo.repo.get(&self.path) {\n+                Some(deps) => {\n+                    deps.iter()\n+                        .map(|p| {\n+                            Vc::upcast::<Box<dyn ModuleReference>>(\n+                                SingleChunkableModuleReference::new(\n+                                    Vc::upcast(MockModule::new(p.clone(), *self.repo)),\n+                                    rcstr!(\"normal-dep\"),\n+                                    ExportUsage::all(),\n+                                ),\n+                            )\n+                            .to_resolved()\n+                        })\n+                        .try_join()\n+                        .await?\n+                }\n+                None => vec![],\n+            };\n+\n+            Ok(Vc::cell(references))\n+        }\n+    }\n+\n+    /// Constructs a graph based on the provided dependency adjacency lists and calls the given test\n+    /// function.\n+    ///\n+    /// # Parameters\n+    /// - `entries`: A vector of entry module names (as `RcStr`). These are the starting points for\n+    ///   the graph.\n+    /// - `graph`: A map from module name (`RcStr`) to a vector of its dependency module names\n+    ///   (`RcStr`). Represents the adjacency list of the graph.\n+    /// - `test_fn`: A function that is called with:\n+    ///     - `ReadRef<SingleModuleGraph>`: The constructed module graph.\n+    ///     - `Vec<ResolvedVc<Box<dyn Module>>>`: The resolved entry modules.\n+    ///     - `FxHashMap<ResolvedVc<Box<dyn Module>>, RcStr>`: A mapping from module to its name for\n+    ///       easier analysis in tests.\n+    async fn run_graph_test(\n+        entries: Vec<RcStr>,\n+        graph: FxHashMap<RcStr, Vec<RcStr>>,\n+        test_fn: impl FnOnce(\n+            ReadRef<SingleModuleGraph>,\n+            Vec<ResolvedVc<Box<dyn Module>>>,\n+            FxHashMap<ResolvedVc<Box<dyn Module>>, RcStr>,\n+        ) -> Result<()>\n+        + Send\n+        + 'static,\n+    ) {\n+        crate::register();\n+\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        tt.run_once(async move {\n+            let fs = VirtualFileSystem::new_with_name(rcstr!(\"test\"));\n+            let root = fs.root().await?;\n+\n+            let repo = TestRepo {\n+                repo: graph\n+                    .iter()\n+                    .map(|(k, v)| {\n+                        (\n+                            root.join(k).unwrap(),\n+                            v.iter().map(|f| root.join(f).unwrap()).collect(),\n+                        )\n+                    })\n+                    .collect(),\n+            }\n+            .cell();\n+            let entry_modules = entries\n+                .iter()\n+                .map(|e| {\n+                    Vc::upcast::<Box<dyn Module>>(MockModule::new(root.join(e).unwrap(), repo))\n+                        .to_resolved()\n+                })\n+                .try_join()\n+                .await?;\n+            let graph = SingleModuleGraph::new_with_entries(\n+                GraphEntries::cell(GraphEntries(vec![ChunkGroupEntry::Entry(\n+                    entry_modules.clone(),\n+                )])),\n+                false,\n+            )\n+            .await?;\n+\n+            // Create a simple name mapping to make analyzing the visitors easier.\n+            // Technically they could always pull this name off of the\n+            // `module.ident().await?.path.path` themselves but that `await` is trick in the\n+            // visitors so precomputing this helps.\n+            let module_to_name = graph\n+                .modules\n+                .keys()\n+                .map(|m| async move { Ok((*m, m.ident().await?.path.path.clone())) })\n+                .try_join()\n+                .await?\n+                .into_iter()\n+                .collect();\n+            test_fn(graph, entry_modules, module_to_name)\n+        })\n+        .await\n+        .unwrap();\n+    }\n+}"
        },
        {
            "sha": "4d9b2ee73a5812448262c8700999e7adb9d8a4cf",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/module_batches.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 19,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs?ref=27a271bd68f8759b0e4cdae04c1a3533233a777e",
            "patch": "@@ -123,15 +123,15 @@ impl ModuleBatchesGraph {\n \n     // Clippy complains but there's a type error without the bound\n     #[allow(clippy::implied_bounds_in_impls)]\n-    /// Traverses all reachable edges in topological order. The preorder visitor can be used to\n+    /// Traverses all reachable edges in dfs order. The preorder visitor can be used to\n     /// forward state down the graph, and to skip subgraphs\n     ///\n     /// Use this to collect batches/modules in evaluation order.\n     ///\n     /// Target nodes can be revisited (once per incoming edge).\n     /// Edges are traversed in normal order, so should correspond to reference order.\n     ///\n-    /// * `entry` - The entry module to start the traversal from\n+    /// * `entries` - The entry modules to start the traversal from\n     /// * `state` - The state to be passed to the visitors\n     /// * `visit_preorder` - Called before visiting the children of a node.\n     ///    - Receives: (originating &ModuleBatchesGraphNode, edge &ChunkingType), target\n@@ -140,7 +140,7 @@ impl ModuleBatchesGraph {\n     /// * `visit_postorder` - Called after visiting the children of a node. Return\n     ///    - Receives: (originating &ModuleBatchesGraphNode, edge &ChunkingType), target\n     ///      &ModuleBatchesGraphNode, state &S\n-    pub fn traverse_edges_from_entries_topological<'a, S>(\n+    pub fn traverse_edges_from_entries_dfs<'a, S>(\n         &'a self,\n         entries: impl IntoIterator<\n             Item = NodeIndex,\n@@ -160,20 +160,16 @@ impl ModuleBatchesGraph {\n     ) -> Result<()> {\n         let graph = &self.graph;\n \n-        enum ReverseTopologicalPass {\n+        enum ReverseDFSPass {\n             Visit,\n             ExpandAndVisit,\n         }\n \n         let entries = entries.into_iter();\n         #[allow(clippy::type_complexity)] // This is a temporary internal structure\n-        let mut stack: Vec<(\n-            ReverseTopologicalPass,\n-            Option<(NodeIndex, EdgeIndex)>,\n-            NodeIndex,\n-        )> = entries\n+        let mut stack: Vec<(ReverseDFSPass, Option<(NodeIndex, EdgeIndex)>, NodeIndex)> = entries\n             .rev()\n-            .map(|e| (ReverseTopologicalPass::ExpandAndVisit, None, e))\n+            .map(|e| (ReverseDFSPass::ExpandAndVisit, None, e))\n             .collect();\n         let mut expanded = FxHashSet::default();\n         while let Some((pass, parent, current)) = stack.pop() {\n@@ -184,24 +180,20 @@ impl ModuleBatchesGraph {\n                 )\n             });\n             match pass {\n-                ReverseTopologicalPass::Visit => {\n+                ReverseDFSPass::Visit => {\n                     let current_node = graph.node_weight(current).unwrap();\n                     visit_postorder(parent_arg, current_node, state);\n                 }\n-                ReverseTopologicalPass::ExpandAndVisit => {\n+                ReverseDFSPass::ExpandAndVisit => {\n                     let current_node = graph.node_weight(current).unwrap();\n                     let action = visit_preorder(parent_arg, current_node, state)?;\n                     if action == GraphTraversalAction::Exclude {\n                         continue;\n                     }\n-                    stack.push((ReverseTopologicalPass::Visit, parent, current));\n+                    stack.push((ReverseDFSPass::Visit, parent, current));\n                     if action == GraphTraversalAction::Continue && expanded.insert(current) {\n                         stack.extend(iter_neighbors_rev(graph, current).map(|(edge, child)| {\n-                            (\n-                                ReverseTopologicalPass::ExpandAndVisit,\n-                                Some((current, edge)),\n-                                child,\n-                            )\n+                            (ReverseDFSPass::ExpandAndVisit, Some((current, edge)), child)\n                         }));\n                     }\n                 }\n@@ -293,7 +285,7 @@ impl PreBatches {\n         };\n         let mut visited = FxHashSet::default();\n         module_graph\n-            .traverse_edges_from_entries_topological(\n+            .traverse_edges_from_entries_dfs(\n                 std::iter::once(ResolvedVc::upcast(entry)),\n                 &mut state,\n                 |parent_info, node, state| {"
        },
        {
            "sha": "068d75868cccf5737abc560aebc78c2fd445268e",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/style_groups.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fstyle_groups.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/27a271bd68f8759b0e4cdae04c1a3533233a777e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fstyle_groups.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fstyle_groups.rs?ref=27a271bd68f8759b0e4cdae04c1a3533233a777e",
            "patch": "@@ -93,7 +93,7 @@ pub async fn compute_style_groups(\n         }\n         let mut visited = FxHashSet::default();\n         let mut items_in_postorder = FxIndexSet::default();\n-        batches_graph.traverse_edges_from_entries_topological(\n+        batches_graph.traverse_edges_from_entries_dfs(\n             entries.iter().copied(),\n             &mut (),\n             |parent_info, module, _| {"
        }
    ],
    "stats": {
        "total": 408,
        "additions": 334,
        "deletions": 74
    }
}