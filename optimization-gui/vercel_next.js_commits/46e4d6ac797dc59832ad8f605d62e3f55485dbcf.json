{
    "author": "Cy-Tek",
    "message": "fix(Turbopack): Give intercept routes correct regex in generated manifest files (#83128)",
    "sha": "46e4d6ac797dc59832ad8f605d62e3f55485dbcf",
    "files": [
        {
            "sha": "35f4d608f1bed9b549ae7823bb7c863ca74fa50a",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/46e4d6ac797dc59832ad8f605d62e3f55485dbcf/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/46e4d6ac797dc59832ad8f605d62e3f55485dbcf/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=46e4d6ac797dc59832ad8f605d62e3f55485dbcf",
            "patch": "@@ -4347,6 +4347,7 @@ dependencies = [\n  \"qstring\",\n  \"react_remove_properties\",\n  \"regex\",\n+ \"regress\",\n  \"remove_console\",\n  \"rustc-hash 2.1.1\",\n  \"serde\",\n@@ -5832,9 +5833,9 @@ dependencies = [\n \n [[package]]\n name = \"regress\"\n-version = \"0.10.3\"\n+version = \"0.10.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"78ef7fa9ed0256d64a688a3747d0fef7a88851c18a5e1d57f115f38ec2e09366\"\n+checksum = \"145bb27393fe455dd64d6cbc8d059adfa392590a45eadf079c01b11857e7b010\"\n dependencies = [\n  \"hashbrown 0.15.4\",\n  \"memchr\","
        },
        {
            "sha": "4e1e253c45883226cfe2235337cb58921df028aa",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/46e4d6ac797dc59832ad8f605d62e3f55485dbcf/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/46e4d6ac797dc59832ad8f605d62e3f55485dbcf/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=46e4d6ac797dc59832ad8f605d62e3f55485dbcf",
            "patch": "@@ -406,7 +406,7 @@ quote = \"1.0.23\"\n rand = \"0.9.0\"\n rayon = \"1.10.0\"\n regex = \"1.10.6\"\n-regress = \"0.10.3\"\n+regress = \"0.10.4\"\n reqwest = { version = \"0.12.22\", default-features = false }\n ringmap = \"0.1.3\"\n roaring = \"0.10.10\""
        },
        {
            "sha": "82b2ea128c9b308e9ec14b8e80bf6a5208054bff",
            "filename": "crates/next-core/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/46e4d6ac797dc59832ad8f605d62e3f55485dbcf/crates%2Fnext-core%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/46e4d6ac797dc59832ad8f605d62e3f55485dbcf/crates%2Fnext-core%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2FCargo.toml?ref=46e4d6ac797dc59832ad8f605d62e3f55485dbcf",
            "patch": "@@ -28,6 +28,7 @@ allsorts = { workspace = true }\n futures = { workspace = true }\n thiserror = { workspace = true }\n tracing = { workspace = true }\n+regress = { workspace = true }\n rustc-hash = { workspace = true }\n react_remove_properties = { workspace = true }\n remove_console = { workspace = true }"
        },
        {
            "sha": "0e847f3409bbbdc1bd5bb843e53a42a237e314ea",
            "filename": "crates/next-core/src/next_edge/route_regex.rs",
            "status": "modified",
            "additions": 51,
            "deletions": 9,
            "changes": 60,
            "blob_url": "https://github.com/vercel/next.js/blob/46e4d6ac797dc59832ad8f605d62e3f55485dbcf/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Froute_regex.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/46e4d6ac797dc59832ad8f605d62e3f55485dbcf/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Froute_regex.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Froute_regex.rs?ref=46e4d6ac797dc59832ad8f605d62e3f55485dbcf",
            "patch": "@@ -3,6 +3,7 @@\n \n use once_cell::sync::Lazy;\n use regex::Regex;\n+use regress;\n use rustc_hash::FxHashMap;\n \n const INTERCEPTION_ROUTE_MARKERS: [&str; 4] = [\"(..)(..)\", \"(.)\", \"(..)\", \"(...)\"];\n@@ -64,7 +65,7 @@ fn parse_parameter(param: &str) -> ParsedParameter {\n }\n \n fn escape_string_regexp(segment: &str) -> String {\n-    regex::escape(segment)\n+    regress::escape(segment)\n }\n \n /// Removes the trailing slash for a given route or page path. Preserves the\n@@ -164,6 +165,7 @@ fn get_safe_key_from_segment(\n     segment: &str,\n     route_keys: &mut FxHashMap<String, String>,\n     key_prefix: Option<&'static str>,\n+    intercept_prefix: Option<&str>,\n ) -> String {\n     let ParsedParameter {\n         key,\n@@ -195,11 +197,13 @@ fn get_safe_key_from_segment(\n     } else {\n         route_keys.insert(cleaned_key.clone(), key);\n     }\n+\n+    let intercept_prefix = intercept_prefix.map_or_else(String::new, escape_string_regexp);\n     match (repeat, optional) {\n-        (true, true) => format!(r\"(?:/(?P<{cleaned_key}>.+?))?\"),\n-        (true, false) => format!(r\"/(?P<{cleaned_key}>.+?)\"),\n-        (false, true) => format!(r\"(?:/(?P<{cleaned_key}>[^/]+?))?\"),\n-        (false, false) => format!(r\"/(?P<{cleaned_key}>[^/]+?)\"),\n+        (true, true) => format!(r\"(?:/{intercept_prefix}(?P<{cleaned_key}>.+?))?\"),\n+        (true, false) => format!(r\"/{intercept_prefix}(?P<{cleaned_key}>.+?)\"),\n+        (false, true) => format!(r\"(?:/{intercept_prefix}(?P<{cleaned_key}>[^/]+?))?\"),\n+        (false, false) => format!(r\"/{intercept_prefix}(?P<{cleaned_key}>[^/]+?)\"),\n     }\n }\n \n@@ -213,11 +217,12 @@ fn get_named_parametrized_route(\n     let parameterized_route = segments\n         .iter()\n         .map(|segment| {\n+            let interception_marker = INTERCEPTION_ROUTE_MARKERS\n+                .iter()\n+                .find(|&m| segment.starts_with(m))\n+                .copied();\n             let key_prefix = if prefix_route_keys {\n-                let has_interception_marker = INTERCEPTION_ROUTE_MARKERS\n-                    .iter()\n-                    .any(|&m| segment.starts_with(m));\n-                if has_interception_marker {\n+                if interception_marker.is_some() {\n                     Some(NEXT_INTERCEPTION_MARKER_PREFIX)\n                 } else {\n                     Some(NEXT_QUERY_PARAM_PREFIX)\n@@ -233,6 +238,7 @@ fn get_named_parametrized_route(\n                     &matches[1],\n                     &mut route_keys,\n                     key_prefix,\n+                    interception_marker,\n                 );\n             }\n             format!(\"/{}\", escape_string_regexp(segment))\n@@ -265,3 +271,39 @@ pub fn get_named_middleware_regex(normalized_route: &str) -> String {\n     let (parameterized_route, _route_keys) = get_named_parametrized_route(normalized_route, true);\n     format!(\"^{parameterized_route}(?:/)?$\")\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::get_named_middleware_regex;\n+\n+    #[test]\n+    fn should_properly_handle_intercept_routes() {\n+        let tests = [\n+            (\n+                \"/[locale]/example/(...)[locale]/intercepted\",\n+                \"^/(?P<nxtPlocale>[^/]+?)/example/\\\\(\\\\.\\\\.\\\\.\\\\)(?P<nxtIlocale>[^/]+?)/\\\n+                 intercepted(?:/)?$\",\n+            ),\n+            (\n+                \"/[locale]/example/(..)[locale]/intercepted\",\n+                \"^/(?P<nxtPlocale>[^/]+?)/example/\\\\(\\\\.\\\\.\\\\)(?P<nxtIlocale>[^/]+?)/intercepted(?\\\n+                 :/)?$\",\n+            ),\n+            (\n+                \"/[locale]/example/(.)[locale]/intercepted\",\n+                \"^/(?P<nxtPlocale>[^/]+?)/example/\\\\(\\\\.\\\\)(?P<nxtIlocale>[^/]+?)/intercepted(?:/\\\n+                 )?$\",\n+            ),\n+            (\n+                \"/[locale]/example/(..)(..)[locale]/intercepted\",\n+                \"^/(?P<nxtPlocale>[^/]+?)/example/\\\\(\\\\.\\\\.\\\\)\\\\(\\\\.\\\\.\\\\)(?P<nxtIlocale>[^/]+?)/\\\n+                 intercepted(?:/)?$\",\n+            ),\n+        ];\n+\n+        for test in tests {\n+            let intercept_route = get_named_middleware_regex(test.0);\n+            assert_eq!(intercept_route, test.1);\n+        }\n+    }\n+}"
        }
    ],
    "stats": {
        "total": 68,
        "additions": 56,
        "deletions": 12
    }
}