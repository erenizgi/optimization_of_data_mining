{
    "author": "wyattjoh",
    "message": "Interception routes match from nested route navigation (#84898)\n\n### What?\n\nRefactors interception route regex generation to fix nested route\nnavigation and improve maintainability.\n\n### Why?\n\nInterception routes failed to trigger when navigating from nested\ndescendant routes. The previous implementation had overly complex,\nfragile regex patterns spread across multiple functions that were\ndifficult to maintain and didn't handle all navigation scenarios\ncorrectly.\n\nThe root cause was an overly restrictive header matching pattern\n(`/[^/]+` - single segment only) that prevented matching navigation from\ndeeper nested routes like `/groups/123/settings` → `/groups/123/new`.\n\n### How?\n\n**Simplified Architecture:**\n- Consolidated regex generation logic into `route-regex.ts` where it\nproperly belongs\n- Removed ~230 lines of complex, duplicated regex building code from\n`generate-interception-routes-rewrites.ts`\n- Leveraged existing `getNamedRouteRegex()` with a new `reference`\nparameter to handle parameter name mapping\n\n**Parameter Naming Fix:**\n- Introduced `nxtI` prefix for parameters adjacent to interception\nmarkers (e.g., `(.)[id]` → `nxtIid`)\n- Maintains `nxtP` prefix for regular parameters\n- Ensures consistent parameter naming across source, destination, and\nregex patterns\n\n**Regex Pattern Fix:**\n- Changed header matching from single-segment (`/[^/]+)?` to\nmulti-segment `(/.+)?` pattern\n- Now correctly matches navigation from any descendant route depth\n\n**Test Coverage:**\n- Added comprehensive e2e tests for nested navigation scenarios\n- Updated existing tests to reflect new parameter naming convention\n\nFixes #84813\n\nNAR-445",
    "sha": "dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
    "files": [
        {
            "sha": "cdb3377dc5b6bb06c37a060977f748b5c9766963",
            "filename": "packages/next/src/lib/generate-interception-routes-rewrites.test.ts",
            "status": "modified",
            "additions": 783,
            "deletions": 123,
            "changes": 906,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.test.ts?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -36,16 +36,48 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // - / (root)\n       // - /nested-link (any root-level route)\n       // - /foo (any other root-level route)\n-      // But NOT:\n-      // - /foo/bar (nested routes)\n+      // - /foo/bar (nested routes - any descendant of root)\n+      // Since the intercepting route is at root, it should match when navigating\n+      // FROM root or any of its descendants\n       const { headerRegex } = getRewriteMatchers(rewrite)\n-      expect(headerRegex.source).toMatchInlineSnapshot(`\"^(\\\\/[^/]+)?\\\\/?$\"`)\n+      expect(headerRegex.source).toMatchInlineSnapshot(`\"^\\\\/.*$\"`)\n \n       expect(headerRegex.test('/')).toBe(true)\n       expect(headerRegex.test('/nested-link')).toBe(true)\n       expect(headerRegex.test('/foo')).toBe(true)\n-      expect(headerRegex.test('/foo/bar')).toBe(false)\n-      expect(headerRegex.test('/a/b/c')).toBe(false)\n+      expect(headerRegex.test('/foo/bar')).toBe(true)\n+      expect(headerRegex.test('/a/b/c')).toBe(true)\n+    })\n+\n+    it('should generate rewrite for root-level slot intercepting nested route with dynamic segments', () => {\n+      const rewrites = generateInterceptionRoutesRewrites([\n+        '/@modal/(.)groups/[id]/new',\n+      ])\n+\n+      expect(rewrites).toHaveLength(1)\n+      const rewrite = rewrites[0]\n+\n+      // Source should be the intercepted route\n+      expect(rewrite.source).toBe('/groups/:nxtPid/new')\n+\n+      // Destination should be the intercepting route path\n+      expect(rewrite.destination).toBe('/@modal/(.)groups/:nxtPid/new')\n+\n+      // The Next-Url header should match routes at root level and all descendants\n+      // This is the bug fix: should match /groups/123 (nested route) in addition to / and /groups\n+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+      expect(headerRegex.source).toMatchInlineSnapshot(`\"^\\\\/.*$\"`)\n+\n+      // Source should match the target URL with dynamic parameter\n+      expect(sourceRegex.test('/groups/123/new')).toBe(true)\n+      expect(sourceRegex.test('/groups/abc/new')).toBe(true)\n+\n+      // Header should match when navigating FROM root or any descendant\n+      expect(headerRegex.test('/')).toBe(true) // From root\n+      expect(headerRegex.test('/groups')).toBe(true) // From /groups\n+      expect(headerRegex.test('/groups/123')).toBe(true) // From /groups/123 (THE BUG FIX!)\n+      expect(headerRegex.test('/groups/123/settings')).toBe(true) // From any nested route\n+      expect(headerRegex.test('/other/route/deep')).toBe(true) // From any other route\n     })\n \n     it('should generate rewrite for nested route intercepting sibling', () => {\n@@ -67,7 +99,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Verify the regex in the rewrite can match actual URLs\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/intercepting\\\\-routes\\\\/feed(\\\\/[^/]+)?\\\\/?$\"`\n+        `\"^\\\\/intercepting\\\\-routes\\\\/feed(?:\\\\/.*)?$\"`\n       )\n \n       expect(sourceRegex.test('/intercepting-routes/feed/photos/123')).toBe(\n@@ -78,15 +110,15 @@ describe('generateInterceptionRoutesRewrites', () => {\n       )\n \n       // The Next-Url header should match routes at /intercepting-routes/feed level\n-      // Should match routes at the same level\n+      // Should match routes at the same level and ALL descendants\n       expect(headerRegex.test('/intercepting-routes/feed')).toBe(true)\n       expect(headerRegex.test('/intercepting-routes/feed/nested')).toBe(true)\n-\n-      // Should NOT match parent or deeper nested routes\n-      expect(headerRegex.test('/intercepting-routes')).toBe(false)\n       expect(headerRegex.test('/intercepting-routes/feed/nested/deep')).toBe(\n-        false\n+        true\n       )\n+\n+      // Should NOT match parent routes\n+      expect(headerRegex.test('/intercepting-routes')).toBe(false)\n     })\n \n     it('should handle (.) with dynamic parameters in intercepting route', () => {\n@@ -97,24 +129,26 @@ describe('generateInterceptionRoutesRewrites', () => {\n       expect(rewrites).toHaveLength(1)\n       const rewrite = rewrites[0]\n \n-      // Source should have the [id] parameter with nxtP prefix (from intercepted route)\n+      // Source should have the [id] parameter with nxtI prefix (adjacent to interception marker)\n       // Destination uses the same prefix for parameter substitution\n-      expect(rewrite.source).toBe('/intercepting-siblings/:nxtPid')\n+      expect(rewrite.source).toBe('/intercepting-siblings/:nxtIid')\n       expect(rewrite.destination).toBe(\n-        '/intercepting-siblings/@modal/(.):nxtPid'\n+        '/intercepting-siblings/@modal/(.):nxtIid'\n       )\n \n       // Verify the source regex matches actual URLs\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/intercepting\\\\-siblings(\\\\/[^/]+)?\\\\/?$\"`\n+        `\"^\\\\/intercepting\\\\-siblings(?:\\\\/.*)?$\"`\n       )\n \n       expect(sourceRegex.test('/intercepting-siblings/123')).toBe(true)\n       expect(sourceRegex.test('/intercepting-siblings/user-abc')).toBe(true)\n \n-      // Should match routes at /intercepting-siblings level\n+      // Should match routes at /intercepting-siblings level and all descendants\n       expect(headerRegex.test('/intercepting-siblings')).toBe(true)\n+      expect(headerRegex.test('/intercepting-siblings/123')).toBe(true)\n+      expect(headerRegex.test('/intercepting-siblings/123/nested')).toBe(true)\n     })\n \n     it('should handle (.) with multiple dynamic parameters', () => {\n@@ -125,19 +159,19 @@ describe('generateInterceptionRoutesRewrites', () => {\n       expect(rewrites).toHaveLength(1)\n       const rewrite = rewrites[0]\n \n-      // Source should have both parameters with nxtP prefix (from intercepted route)\n+      // Source should have nxtI prefix for author (adjacent to marker), nxtP for id\n       // Both source and destination use the same prefixes for proper substitution\n       expect(rewrite.source).toBe(\n-        '/intercepting-routes-dynamic/photos/:nxtPauthor/:nxtPid'\n+        '/intercepting-routes-dynamic/photos/:nxtIauthor/:nxtPid'\n       )\n       expect(rewrite.destination).toBe(\n-        '/intercepting-routes-dynamic/photos/(.):nxtPauthor/:nxtPid'\n+        '/intercepting-routes-dynamic/photos/(.):nxtIauthor/:nxtPid'\n       )\n \n       // Verify the source regex matches actual URLs with both parameters\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/intercepting\\\\-routes\\\\-dynamic\\\\/photos(\\\\/[^/]+)?\\\\/?$\"`\n+        `\"^\\\\/intercepting\\\\-routes\\\\-dynamic\\\\/photos(?:\\\\/.*)?$\"`\n       )\n \n       expect(\n@@ -147,8 +181,14 @@ describe('generateInterceptionRoutesRewrites', () => {\n         sourceRegex.test('/intercepting-routes-dynamic/photos/jane/post-456')\n       ).toBe(true)\n \n-      // Should match the parent directory\n+      // Should match the parent directory and all descendants\n       expect(headerRegex.test('/intercepting-routes-dynamic/photos')).toBe(true)\n+      expect(headerRegex.test('/intercepting-routes-dynamic/photos/john')).toBe(\n+        true\n+      )\n+      expect(\n+        headerRegex.test('/intercepting-routes-dynamic/photos/john/123')\n+      ).toBe(true)\n     })\n \n     it('should handle (.) with optional catchall in intercepting route', () => {\n@@ -169,7 +209,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Verify source regex matches actual URLs with 0 or more catchall segments\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^(?:\\\\/(?<nxtPlocale>.+?))?(\\\\/[^/]+)?\\\\/?$\"`\n+        `\"^(?:\\\\/(?<nxtPlocale>.+?))?(?:\\\\/.*)?$\"`\n       )\n \n       expect(sourceRegex.test('/settings')).toBe(true)\n@@ -197,6 +237,74 @@ describe('generateInterceptionRoutesRewrites', () => {\n   })\n \n   describe('(..) one-level-up interception', () => {\n+    it('should handle (..) from exactly 2 levels deep', () => {\n+      // Boundary: /foo/bar with (..) goes to /foo (not root)\n+      const rewrites = generateInterceptionRoutesRewrites([\n+        '/foo/bar/(..)target',\n+      ])\n+\n+      expect(rewrites).toHaveLength(1)\n+      const rewrite = rewrites[0]\n+\n+      expect(rewrite.source).toBe('/foo/target')\n+      expect(rewrite.destination).toBe('/foo/bar/(..)target')\n+\n+      const { headerRegex } = getRewriteMatchers(rewrite)\n+\n+      // Should match at /foo/bar level\n+      expect(headerRegex.test('/foo/bar')).toBe(true)\n+      expect(headerRegex.test('/foo/bar/nested')).toBe(true)\n+\n+      // Should NOT match at /foo level (that's the parent)\n+      expect(headerRegex.test('/foo')).toBe(false)\n+    })\n+\n+    it('should handle (..) with dynamic segment at boundary (2 levels to 1)', () => {\n+      const rewrites = generateInterceptionRoutesRewrites([\n+        '/[locale]/dashboard/(..)settings',\n+      ])\n+\n+      expect(rewrites).toHaveLength(1)\n+      const rewrite = rewrites[0]\n+\n+      // (..) from /[locale]/dashboard goes to /[locale]\n+      expect(rewrite.source).toBe('/:nxtPlocale/settings')\n+      expect(rewrite.destination).toBe('/:nxtPlocale/dashboard/(..)settings')\n+\n+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+      expect(sourceRegex.test('/en/settings')).toBe(true)\n+      expect(sourceRegex.test('/fr/settings')).toBe(true)\n+\n+      // Header should match at /[locale]/dashboard level\n+      expect(headerRegex.test('/en/dashboard')).toBe(true)\n+      expect(headerRegex.test('/fr/dashboard')).toBe(true)\n+    })\n+\n+    it('should handle (..) with catchall at boundary', () => {\n+      // /[...all]/item with (..) removes one segment, leaving /[...all]\n+      const rewrites = generateInterceptionRoutesRewrites([\n+        '/[...all]/item/(..)target',\n+      ])\n+\n+      expect(rewrites).toHaveLength(1)\n+      const rewrite = rewrites[0]\n+\n+      // (..) from /[...all]/item removes one segment, leaving /[...all]\n+      expect(rewrite.source).toBe('/:nxtPall+/target')\n+      expect(rewrite.destination).toBe('/:nxtPall+/item/(..)target')\n+\n+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+      expect(sourceRegex.test('/a/target')).toBe(true)\n+      expect(sourceRegex.test('/a/b/target')).toBe(true)\n+\n+      // Header should match from /[...all]/item at any depth\n+      expect(headerRegex.test('/a/item')).toBe(true)\n+      expect(headerRegex.test('/a/b/item')).toBe(true)\n+      expect(headerRegex.test('/a/b/c/item')).toBe(true)\n+    })\n+\n     it('should generate header regex that matches child routes for (..) marker', () => {\n       // Test WITHOUT catchall sibling - should only match exact level\n       const rewritesWithoutCatchall = generateInterceptionRoutesRewrites([\n@@ -215,13 +323,13 @@ describe('generateInterceptionRoutesRewrites', () => {\n         rewriteWithoutCatchall\n       )\n       expect(headerWithoutCatchall.source).toMatchInlineSnapshot(\n-        `\"^\\\\/templates$\"`\n+        `\"^\\\\/templates(?:\\\\/.*)?$\"`\n       )\n \n-      // Without catchall sibling: should match exact level only\n+      // Now matches all descendants (consistent with other markers)\n       expect(headerWithoutCatchall.test('/templates')).toBe(true)\n-      expect(headerWithoutCatchall.test('/templates/multi')).toBe(false)\n-      expect(headerWithoutCatchall.test('/templates/multi/slug')).toBe(false)\n+      expect(headerWithoutCatchall.test('/templates/multi')).toBe(true)\n+      expect(headerWithoutCatchall.test('/templates/multi/slug')).toBe(true)\n \n       // Test WITH catchall sibling - should match exact level AND catchall paths\n       const rewritesWithCatchall = generateInterceptionRoutesRewrites([\n@@ -235,7 +343,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n       const { headerRegex: headerWithCatchall } =\n         getRewriteMatchers(rewriteWithCatchall)\n       expect(headerWithCatchall.source).toMatchInlineSnapshot(\n-        `\"^\\\\/templates(\\\\/.+)?$\"`\n+        `\"^\\\\/templates(?:\\\\/.*)?$\"`\n       )\n \n       // With catchall sibling: should match exact level AND catchall paths\n@@ -273,7 +381,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Verify source regex matches actual photo URLs\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/intercepting\\\\-parallel\\\\-modal\\\\/(?<nxtPusername>[^/]+?)$\"`\n+        `\"^\\\\/intercepting\\\\-parallel\\\\-modal\\\\/(?<nxtPusername>[^/]+?)(?:\\\\/.*)?$\"`\n       )\n \n       expect(sourceRegex.test('/intercepting-parallel-modal/photo/123')).toBe(\n@@ -283,18 +391,18 @@ describe('generateInterceptionRoutesRewrites', () => {\n         true\n       )\n \n-      // The (..) marker generates a pattern that matches the intercepting route level and its children\n+      // The (..) marker matches the intercepting route level and all descendants\n       // Should match the intercepting route itself with actual dynamic segment values\n       expect(headerRegex.test('/intercepting-parallel-modal/john')).toBe(true)\n       expect(headerRegex.test('/intercepting-parallel-modal/jane')).toBe(true)\n \n-      // Should not match child routes\n+      // Should also match all descendants\n       expect(headerRegex.test('/intercepting-parallel-modal/john/child')).toBe(\n-        false\n+        true\n       )\n       expect(\n         headerRegex.test('/intercepting-parallel-modal/jane/deep/nested')\n-      ).toBe(false)\n+      ).toBe(true)\n \n       // Should NOT match parent routes without the required parameter\n       expect(headerRegex.test('/intercepting-parallel-modal')).toBe(false)\n@@ -317,19 +425,18 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Verify source regex matches actual URLs\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/(?<nxtPlang>[^/]+?)\\\\/foo$\"`\n+        `\"^\\\\/(?<nxtPlang>[^/]+?)\\\\/foo(?:\\\\/.*)?$\"`\n       )\n \n       expect(sourceRegex.test('/en/photos')).toBe(true)\n       expect(sourceRegex.test('/es/photos')).toBe(true)\n       expect(sourceRegex.test('/fr/photos')).toBe(true)\n \n-      // Should match child routes of /[lang]/foo with actual parameter values\n-      // Since the route ends with a static segment (foo), children are required\n+      // Should match routes at /[lang]/foo level and all descendants\n       expect(headerRegex.test('/en/foo')).toBe(true)\n       expect(headerRegex.test('/es/foo')).toBe(true)\n-\n-      expect(headerRegex.test('/en/foo/bar')).toBe(false)\n+      expect(headerRegex.test('/en/foo/bar')).toBe(true)\n+      expect(headerRegex.test('/es/foo/nested/deep')).toBe(true)\n     })\n \n     it('should handle (..) with optional catchall in intercepting route', () => {\n@@ -349,7 +456,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Verify source regex matches actual URLs with 0 or more catchall segments\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/dashboard$\"`\n+        `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/dashboard(?:\\\\/.*)?$\"`\n       )\n \n       expect(sourceRegex.test('/settings')).toBe(true)\n@@ -378,7 +485,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n       const { headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/dashboard(\\\\/.+)?$\"`\n+        `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/dashboard(?:\\\\/.*)?$\"`\n       )\n \n       // With catchall sibling: should match exact level AND catchall paths\n@@ -409,7 +516,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/(?<nxtPuserId>[^/]+?)$\"`\n+        `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/(?<nxtPuserId>[^/]+?)(?:\\\\/.*)?$\"`\n       )\n \n       // Source should match with 0 or more locale segments\n@@ -445,19 +552,18 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Verify source regex matches actual URLs\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/(?<nxtPlocale>[^/]+?)\\\\/example(?:\\\\/)?$\"`\n+        `\"^\\\\/(?<nxtIlocale>[^/]+?)\\\\/example(?:\\\\/.*)?$\"`\n       )\n \n       expect(sourceRegex.test('/en/intercepted')).toBe(true)\n       expect(sourceRegex.test('/es/intercepted')).toBe(true)\n \n-      // Should match routes at the intercepting route level\n+      // Should match routes at the intercepting route level and all descendants\n       // The intercepting route is /[locale]/example\n       expect(headerRegex.test('/en/example')).toBe(true)\n       expect(headerRegex.test('/es/example')).toBe(true)\n-\n-      // Should NOT match deeper routes\n-      expect(headerRegex.test('/en/example/nested')).toBe(false)\n+      expect(headerRegex.test('/en/example/nested')).toBe(true)\n+      expect(headerRegex.test('/es/example/nested/deep')).toBe(true)\n     })\n \n     it('should generate rewrite for (...) in basepath context', () => {\n@@ -479,14 +585,15 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Verify source regex matches actual URLs\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/(?<nxtPfoo_id>[^/]+?)\\\\/(?<nxtPbar_id>[^/]+?)(?:\\\\/)?$\"`\n+        `\"^\\\\/(?<nxtPfoo_id>[^/]+?)\\\\/(?<nxtPbar_id>[^/]+?)(?:\\\\/.*)?$\"`\n       )\n \n       expect(sourceRegex.test('/baz_id/123')).toBe(true)\n       expect(sourceRegex.test('/baz_id/abc')).toBe(true)\n \n-      // Should match the intercepting route level\n+      // Should match the intercepting route level and all descendants\n       expect(headerRegex.test('/foo/bar')).toBe(true)\n+      expect(headerRegex.test('/foo/bar/nested')).toBe(true)\n     })\n \n     it('should handle (...) with optional catchall in intercepted route', () => {\n@@ -506,8 +613,11 @@ describe('generateInterceptionRoutesRewrites', () => {\n       )\n \n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+      expect(sourceRegex.source).toMatchInlineSnapshot(\n+        `\"^(?:\\\\/(?<nxtIlocale>.+?))?\\\\/intercepted(?:\\\\/)?$\"`\n+      )\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/dashboard(?:\\\\/)?$\"`\n+        `\"^(?:\\\\/(?<nxtIlocale>.+?))?\\\\/dashboard(?:\\\\/.*)?$\"`\n       )\n \n       // Source should match with 0 or more locale segments\n@@ -541,17 +651,18 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Verify source regex matches actual URLs\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/foo\\\\/bar(?:\\\\/)?$\"`\n+        `\"^\\\\/foo\\\\/bar(?:\\\\/.*)?$\"`\n       )\n \n       expect(sourceRegex.test('/hoge')).toBe(true)\n \n-      // Should match routes at /foo/bar level (two levels below root)\n+      // Should match routes at /foo/bar level and all descendants\n       expect(headerRegex.test('/foo/bar')).toBe(true)\n+      expect(headerRegex.test('/foo/bar/baz')).toBe(true)\n+      expect(headerRegex.test('/foo/bar/baz/deep')).toBe(true)\n \n-      // Should NOT match parent or deeper routes\n+      // Should NOT match parent routes\n       expect(headerRegex.test('/foo')).toBe(false)\n-      expect(headerRegex.test('/foo/bar/baz')).toBe(false)\n     })\n \n     it('should handle (..)(..) with optional catchall in intercepting route', () => {\n@@ -570,27 +681,115 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/foo\\\\/bar(?:\\\\/)?$\"`\n+        `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/foo\\\\/bar(?:\\\\/.*)?$\"`\n       )\n \n       // Source should match with 0 or more locale segments\n       expect(sourceRegex.test('/hoge')).toBe(true)\n       expect(sourceRegex.test('/en/hoge')).toBe(true)\n       expect(sourceRegex.test('/en/us/hoge')).toBe(true)\n \n-      // Header should match routes at /[[...locale]]/foo/bar level\n+      // Header should match routes at /[[...locale]]/foo/bar level and all descendants\n       expect(headerRegex.test('/foo/bar')).toBe(true)\n       expect(headerRegex.test('/en/foo/bar')).toBe(true)\n       expect(headerRegex.test('/en/us/foo/bar')).toBe(true)\n+      expect(headerRegex.test('/foo/bar/baz')).toBe(true)\n+      expect(headerRegex.test('/en/foo/bar/baz')).toBe(true)\n+      expect(headerRegex.test('/en/us/foo/bar/nested/deep')).toBe(true)\n \n-      // Should NOT match parent or deeper routes\n+      // Should NOT match parent routes\n       expect(headerRegex.test('/foo')).toBe(false)\n       expect(headerRegex.test('/en/foo')).toBe(false)\n-      expect(headerRegex.test('/foo/bar/baz')).toBe(false)\n     })\n   })\n \n   describe('catchall and optional catchall segments', () => {\n+    it('should handle interception from within a required catchall route', () => {\n+      // Blog pattern: /blog/[...category] can have many levels\n+      // User at /blog/tech/nextjs/latest intercepts /blog/post/123\n+      const rewrites = generateInterceptionRoutesRewrites([\n+        '/blog/[...category]/@modal/(.)post/[id]',\n+      ])\n+\n+      expect(rewrites).toHaveLength(1)\n+      const rewrite = rewrites[0]\n+\n+      // Source is the intercepted route\n+      expect(rewrite.source).toBe('/blog/:nxtPcategory+/post/:nxtPid')\n+\n+      // Destination includes the catchall from intercepting route\n+      expect(rewrite.destination).toBe(\n+        '/blog/:nxtPcategory+/@modal/(.)post/:nxtPid'\n+      )\n+\n+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+      // Source should match the target URL\n+      expect(sourceRegex.test('/blog/tech/post/123')).toBe(true)\n+      expect(sourceRegex.test('/blog/tech/nextjs/post/123')).toBe(true)\n+      expect(sourceRegex.test('/blog/tech/nextjs/latest/post/123')).toBe(true)\n+\n+      // Header should match from the catchall route at any depth\n+      expect(headerRegex.test('/blog/tech')).toBe(true)\n+      expect(headerRegex.test('/blog/tech/nextjs')).toBe(true)\n+      expect(headerRegex.test('/blog/tech/nextjs/latest')).toBe(true)\n+      expect(headerRegex.test('/blog/tech/nextjs/latest/nested')).toBe(true)\n+    })\n+\n+    it('should handle interception from optional catchall at deep nesting', () => {\n+      // i18n pattern: user at /en/US/dashboard intercepts /en/US/dashboard/settings\n+      const rewrites = generateInterceptionRoutesRewrites([\n+        '/[[...locale]]/dashboard/@modal/(.)settings',\n+      ])\n+\n+      expect(rewrites).toHaveLength(1)\n+      const rewrite = rewrites[0]\n+\n+      expect(rewrite.source).toBe('/:nxtPlocale*/dashboard/settings')\n+      expect(rewrite.destination).toBe(\n+        '/:nxtPlocale*/dashboard/@modal/(.)settings'\n+      )\n+\n+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+      // Source should match with various locale depths\n+      expect(sourceRegex.test('/dashboard/settings')).toBe(true)\n+      expect(sourceRegex.test('/en/dashboard/settings')).toBe(true)\n+      expect(sourceRegex.test('/en/US/dashboard/settings')).toBe(true)\n+      expect(sourceRegex.test('/en/US/CA/dashboard/settings')).toBe(true)\n+\n+      // Header should match from dashboard at any locale depth\n+      expect(headerRegex.test('/dashboard')).toBe(true)\n+      expect(headerRegex.test('/en/dashboard')).toBe(true)\n+      expect(headerRegex.test('/en/US/dashboard')).toBe(true)\n+      expect(headerRegex.test('/en/US/CA/dashboard')).toBe(true)\n+      expect(headerRegex.test('/en/US/dashboard/nested')).toBe(true)\n+    })\n+\n+    it('should handle (..) interception from within catchall with deep navigation', () => {\n+      // Docs site: user at /docs/api/reference/components navigates one level up\n+      const rewrites = generateInterceptionRoutesRewrites([\n+        '/docs/[...slug]/@modal/(..)related',\n+      ])\n+\n+      expect(rewrites).toHaveLength(1)\n+      const rewrite = rewrites[0]\n+\n+      // (..) goes one level up from /docs/[...slug], which is /docs\n+      expect(rewrite.source).toBe('/docs/related')\n+      expect(rewrite.destination).toBe('/docs/:nxtPslug+/@modal/(..)related')\n+\n+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+      expect(sourceRegex.test('/docs/related')).toBe(true)\n+\n+      // Header should match from any depth within the docs catchall\n+      expect(headerRegex.test('/docs/api')).toBe(true)\n+      expect(headerRegex.test('/docs/api/reference')).toBe(true)\n+      expect(headerRegex.test('/docs/api/reference/components')).toBe(true)\n+      expect(headerRegex.test('/docs/guide/getting-started/intro')).toBe(true)\n+    })\n+\n     it('should generate path-to-regexp format with + suffix for catchall parameters', () => {\n       const rewrites = generateInterceptionRoutesRewrites([\n         '/templates/(..)showcase/[...catchAll]',\n@@ -656,7 +855,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Verify source regex matches catchall URLs\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/intercepting\\\\-routes\\\\-dynamic\\\\-catchall\\\\/photos(\\\\/[^/]+)?\\\\/?$\"`\n+        `\"^\\\\/intercepting\\\\-routes\\\\-dynamic\\\\-catchall\\\\/photos(?:\\\\/.*)?$\"`\n       )\n \n       expect(\n@@ -675,10 +874,16 @@ describe('generateInterceptionRoutesRewrites', () => {\n         )\n       ).toBe(true)\n \n-      // Should match the parent level\n+      // Should match the parent level and all descendants\n       expect(\n         headerRegex.test('/intercepting-routes-dynamic-catchall/photos')\n       ).toBe(true)\n+      expect(\n+        headerRegex.test('/intercepting-routes-dynamic-catchall/photos/foo')\n+      ).toBe(true)\n+      expect(\n+        headerRegex.test('/intercepting-routes-dynamic-catchall/photos/foo/bar')\n+      ).toBe(true)\n     })\n \n     it('should handle (.) with optional catchall segments', () => {\n@@ -702,7 +907,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Verify source regex matches both with and without segments\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/intercepting\\\\-routes\\\\-dynamic\\\\-catchall\\\\/photos(\\\\/[^/]+)?\\\\/?$\"`\n+        `\"^\\\\/intercepting\\\\-routes\\\\-dynamic\\\\-catchall\\\\/photos(?:\\\\/.*)?$\"`\n       )\n \n       expect(\n@@ -721,10 +926,16 @@ describe('generateInterceptionRoutesRewrites', () => {\n         )\n       ).toBe(true)\n \n-      // Should match the parent level\n+      // Should match the parent level and all descendants\n       expect(\n         headerRegex.test('/intercepting-routes-dynamic-catchall/photos')\n       ).toBe(true)\n+      expect(\n+        headerRegex.test('/intercepting-routes-dynamic-catchall/photos/foo')\n+      ).toBe(true)\n+      expect(\n+        headerRegex.test('/intercepting-routes-dynamic-catchall/photos/foo/bar')\n+      ).toBe(true)\n     })\n   })\n \n@@ -741,7 +952,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Note: Router adds ^ and $ anchors automatically via matchHas()\n       const { headerRegex } = getRewriteMatchers(rewrites[0])\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/intercepting\\\\-parallel\\\\-modal\\\\/(?<nxtPusername>[^/]+?)$\"`\n+        `\"^\\\\/intercepting\\\\-parallel\\\\-modal\\\\/(?<nxtPusername>[^/]+?)(?:\\\\/.*)?$\"`\n       )\n \n       // With (..) marker, should match child routes.\n@@ -758,11 +969,12 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // So interceptingRoute should be / (root)\n       // Note: Router adds ^ and $ anchors automatically via matchHas()\n       const { headerRegex } = getRewriteMatchers(rewrites[0])\n-      expect(headerRegex.source).toMatchInlineSnapshot(`\"^(\\\\/[^/]+)?\\\\/?$\"`)\n+      expect(headerRegex.source).toMatchInlineSnapshot(`\"^\\\\/.*$\"`)\n \n-      // Should match root-level routes\n+      // Should match root-level routes and all descendants\n       expect(headerRegex.test('/')).toBe(true)\n       expect(headerRegex.test('/nested-link')).toBe(true)\n+      expect(headerRegex.test('/nested-link/deep')).toBe(true)\n     })\n \n     it('should handle parallel routes at nested levels', () => {\n@@ -775,11 +987,13 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Note: Router adds ^ and $ anchors automatically via matchHas()\n       const { headerRegex } = getRewriteMatchers(rewrites[0])\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/parallel\\\\-layout(\\\\/[^/]+)?\\\\/?$\"`\n+        `\"^\\\\/parallel\\\\-layout(?:\\\\/.*)?$\"`\n       )\n \n-      // Should match routes at /parallel-layout level\n+      // Should match routes at /parallel-layout level and all descendants\n       expect(headerRegex.test('/parallel-layout')).toBe(true)\n+      expect(headerRegex.test('/parallel-layout/nested')).toBe(true)\n+      expect(headerRegex.test('/parallel-layout/nested/deep')).toBe(true)\n     })\n \n     it('should handle optional catchall in route groups with (..) interception', () => {\n@@ -798,7 +1012,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n       const { headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/dashboard$\"`\n+        `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/dashboard(?:\\\\/.*)?$\"`\n       )\n \n       // Route group should be normalized, so header should match without it\n@@ -821,26 +1035,104 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n       const { headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^(?:\\\\/(?<nxtPlocale>.+?))?(\\\\/[^/]+)?\\\\/?$\"`\n+        `\"^(?:\\\\/(?<nxtPlocale>.+?))?(?:\\\\/.*)?$\"`\n       )\n \n       // @slot should be normalized away, so interceptingRoute is root\n-      // With optional catchall at root level\n+      // With optional catchall at root level, should match all descendants\n       expect(headerRegex.test('/')).toBe(true) // Zero locale segments (root level)\n       expect(headerRegex.test('/en')).toBe(true) // One locale segment\n       expect(headerRegex.test('/en/us')).toBe(true) // Multiple locale segments\n \n-      // Should match direct children at each level (same-level interception allows one child)\n-      expect(headerRegex.test('/other-page')).toBe(true) // Direct child at root\n-      expect(headerRegex.test('/en/settings')).toBe(true) // Direct child at /en level\n-      expect(headerRegex.test('/en/us/nested')).toBe(true) // Direct child at /en/us level\n+      // Should match all descendants at any depth\n+      expect(headerRegex.test('/other-page')).toBe(true)\n+      expect(headerRegex.test('/en/settings')).toBe(true)\n+      expect(headerRegex.test('/en/us/nested')).toBe(true)\n+      expect(headerRegex.test('/en/settings/deep')).toBe(true)\n+      expect(headerRegex.test('/en/us/nested/deeper')).toBe(true)\n+      expect(headerRegex.test('/a/b/c/d/e')).toBe(true)\n+    })\n \n-      // With optional catchall, any depth of catchall + one child is valid\n-      expect(headerRegex.test('/en/settings/deep')).toBe(true) // /en/settings level + child\n-      expect(headerRegex.test('/en/us/nested/deeper')).toBe(true) // /en/us/nested level + child\n+    it('should handle parallel route with its own dynamic segment', () => {\n+      // Pattern: /@modal/[modalId] for different modal types\n+      const rewrites = generateInterceptionRoutesRewrites([\n+        '/@modal/[modalId]/(.)photos/[id]',\n+      ])\n \n-      // Should NOT match when there's no valid \"catchall + child\" or \"just catchall\" interpretation\n-      expect(headerRegex.test('/a/b/c/d/e')).toBe(true) // Actually matches: /a/b/c/d as catchall + /e as child\n+      expect(rewrites).toHaveLength(1)\n+      const rewrite = rewrites[0]\n+\n+      // @modal is normalized away, but [modalId] remains\n+      expect(rewrite.source).toBe('/:nxtPmodalId/photos/:nxtPid')\n+      expect(rewrite.destination).toBe('/@modal/:nxtPmodalId/(.)photos/:nxtPid')\n+\n+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+      // Source should match with both parameters\n+      expect(sourceRegex.test('/gallery/photos/123')).toBe(true)\n+      expect(sourceRegex.test('/lightbox/photos/456')).toBe(true)\n+\n+      // Header should match the modal type level\n+      expect(headerRegex.test('/gallery')).toBe(true)\n+      expect(headerRegex.test('/lightbox')).toBe(true)\n+      expect(headerRegex.test('/gallery/nested')).toBe(true)\n+    })\n+\n+    it('should handle nested parallel route with dynamic segments in parent', () => {\n+      const rewrites = generateInterceptionRoutesRewrites([\n+        '/[org]/@sidebar/[section]/(..)profile',\n+      ])\n+\n+      expect(rewrites).toHaveLength(1)\n+      const rewrite = rewrites[0]\n+\n+      // (..) goes one level up from /[org]/@sidebar/[section], which is /[org]\n+      expect(rewrite.source).toBe('/:nxtPorg/profile')\n+      expect(rewrite.destination).toBe(\n+        '/:nxtPorg/@sidebar/:nxtPsection/(..)profile'\n+      )\n+\n+      const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+      expect(sourceRegex.test('/vercel/profile')).toBe(true)\n+      expect(sourceRegex.test('/acme/profile')).toBe(true)\n+\n+      // Header should match the sidebar section level\n+      expect(headerRegex.test('/vercel/settings')).toBe(true)\n+      expect(headerRegex.test('/acme/dashboard')).toBe(true)\n+      expect(headerRegex.test('/vercel/settings/nested')).toBe(true)\n+    })\n+\n+    it('should handle multiple parallel routes with their own dynamic segments', () => {\n+      const rewrites = generateInterceptionRoutesRewrites([\n+        '/[workspace]/@sidebar/[section]/@modal/[modalType]/(.)content/[id]',\n+      ])\n+\n+      expect(rewrites).toHaveLength(1)\n+      const rewrite = rewrites[0]\n+\n+      // Both parallel routes are normalized but their dynamic segments remain\n+      expect(rewrite.source).toBe(\n+        '/:nxtPworkspace/:nxtPsection/:nxtPmodalType/content/:nxtPid'\n+      )\n+      expect(rewrite.destination).toBe(\n+        '/:nxtPworkspace/@sidebar/:nxtPsection/@modal/:nxtPmodalType/(.)content/:nxtPid'\n+      )\n+\n+      const { sourceRegex } = getRewriteMatchers(rewrite)\n+\n+      // Should match with all dynamic parameters\n+      expect(sourceRegex.test('/acme/settings/gallery/content/photo123')).toBe(\n+        true\n+      )\n+\n+      const match = sourceRegex.exec('/acme/settings/gallery/content/photo123')\n+      expect(match?.groups).toEqual({\n+        nxtPworkspace: 'acme',\n+        nxtPsection: 'settings',\n+        nxtPmodalType: 'gallery',\n+        nxtPid: 'photo123',\n+      })\n     })\n   })\n \n@@ -860,21 +1152,19 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n       // Verify source regex includes basePath and matches actual URLs\n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n-      expect(headerRegex.source).toMatchInlineSnapshot(`\"^(\\\\/[^/]+)?\\\\/?$\"`)\n+      expect(headerRegex.source).toMatchInlineSnapshot(`\"^\\\\/.*$\"`)\n \n       expect(sourceRegex.test('/base/nested')).toBe(true)\n       expect(sourceRegex.test('/nested')).toBe(false) // Should NOT match without basePath\n \n       // But Next-Url header check should NOT include basePath\n       // (comment in code says \"The Next-Url header does not contain the base path\")\n \n-      // Should match root-level routes (without basePath in the check)\n+      // Should match root-level routes and all descendants (without basePath in the check)\n       expect(headerRegex.test('/')).toBe(true)\n       expect(headerRegex.test('/nested-link')).toBe(true)\n-      expect(headerRegex.test('/base')).toBe(true) // Matches because it's a root-level route\n-\n-      // Should NOT match deeply nested routes\n-      expect(headerRegex.test('/nested-link/deep')).toBe(false)\n+      expect(headerRegex.test('/base')).toBe(true)\n+      expect(headerRegex.test('/nested-link/deep')).toBe(true)\n     })\n \n     it('should handle optional catchall with basePath', () => {\n@@ -892,7 +1182,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n       const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^(?:\\\\/(?<nxtPlocale>.+?))?(\\\\/[^/]+)?\\\\/?$\"`\n+        `\"^(?:\\\\/(?<nxtPlocale>.+?))?(?:\\\\/.*)?$\"`\n       )\n \n       // Source regex should include basePath\n@@ -902,10 +1192,11 @@ describe('generateInterceptionRoutesRewrites', () => {\n       expect(sourceRegex.test('/settings')).toBe(false) // Without basePath\n \n       // Header check should NOT include basePath\n-      // The optional catchall allows zero or more segments at root level\n+      // The optional catchall allows zero or more segments at root level, matching all descendants\n       expect(headerRegex.test('/')).toBe(true) // Zero locale segments\n       expect(headerRegex.test('/en')).toBe(true) // One locale segment\n       expect(headerRegex.test('/en/us')).toBe(true) // Multiple locale segments\n+      expect(headerRegex.test('/en/us/deep')).toBe(true) // Deep nesting\n     })\n   })\n \n@@ -925,11 +1216,13 @@ describe('generateInterceptionRoutesRewrites', () => {\n       // Note: Router adds ^ and $ anchors automatically via matchHas()\n       const { headerRegex } = getRewriteMatchers(rewrites[0])\n       expect(headerRegex.source).toMatchInlineSnapshot(\n-        `\"^\\\\/(?<nxtPthisismyroute>[^/]+?)(\\\\/[^/]+)?\\\\/?$\"`\n+        `\"^\\\\/(?<nxtPthisismyroute>[^/]+?)(?:\\\\/.*)?$\"`\n       )\n \n-      // Should match routes at the parent level\n+      // Should match routes at the parent level and all descendants\n       expect(headerRegex.test('/foo')).toBe(true)\n+      expect(headerRegex.test('/foo/bar')).toBe(true)\n+      expect(headerRegex.test('/foo/bar/baz')).toBe(true)\n     })\n   })\n \n@@ -946,19 +1239,19 @@ describe('generateInterceptionRoutesRewrites', () => {\n       const sourceParams = rewrite.source\n         .match(/:(\\w+)/g)\n         ?.map((p) => p.slice(1))\n-      expect(sourceParams).toEqual(['nxtPauthor', 'nxtPid'])\n+      expect(sourceParams).toEqual(['nxtIauthor', 'nxtPid'])\n \n       // Extract parameter names from destination\n       const destParams = rewrite.destination\n         .match(/:(\\w+)/g)\n         ?.map((p) => p.slice(1))\n-      expect(destParams).toEqual(['nxtPauthor', 'nxtPid'])\n+      expect(destParams).toEqual(['nxtIauthor', 'nxtPid'])\n \n       // Extract capture group names from regex\n       const regexParams = Array.from(\n         rewrite.regex!.matchAll(/\\(\\?<(\\w+)>/g)\n       ).map((m) => m[1])\n-      expect(regexParams).toEqual(['nxtPauthor', 'nxtPid'])\n+      expect(regexParams).toEqual(['nxtIauthor', 'nxtPid'])\n \n       // All three should match exactly\n       expect(sourceParams).toEqual(destParams)\n@@ -1046,7 +1339,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n       expect(match).toBeTruthy()\n       expect(match!.groups).toEqual({\n-        nxtPcategory: 'electronics',\n+        nxtIcategory: 'electronics',\n         nxtPproductId: '12345',\n       })\n \n@@ -1070,9 +1363,9 @@ describe('generateInterceptionRoutesRewrites', () => {\n       expect(rewrites).toHaveLength(1)\n       const rewrite = rewrites[0]\n \n-      // Verify catchall parameters get * suffix in path-to-regexp format\n-      expect(rewrite.source).toBe('/docs/:nxtPslug+')\n-      expect(rewrite.destination).toBe('/docs/(.):nxtPslug+')\n+      // Verify catchall parameters get + suffix in path-to-regexp format\n+      expect(rewrite.source).toBe('/docs/:nxtIslug+')\n+      expect(rewrite.destination).toBe('/docs/(.):nxtIslug+')\n \n       const sourceParams = rewrite.source\n         .match(/:(\\w+)\\*?/g)\n@@ -1084,16 +1377,16 @@ describe('generateInterceptionRoutesRewrites', () => {\n         rewrite.regex!.matchAll(/\\(\\?<(\\w+)>/g)\n       ).map((m) => m[1])\n \n-      expect(sourceParams).toEqual(['nxtPslug'])\n-      expect(destParams).toEqual(['nxtPslug'])\n-      expect(regexParams).toEqual(['nxtPslug'])\n+      expect(sourceParams).toEqual(['nxtIslug'])\n+      expect(destParams).toEqual(['nxtIslug'])\n+      expect(regexParams).toEqual(['nxtIslug'])\n \n       // Test actual matching and substitution\n       const { sourceRegex } = getRewriteMatchers(rewrite)\n       const match = sourceRegex.exec('/docs/getting-started/installation')\n \n       expect(match).toBeTruthy()\n-      expect(match!.groups!.nxtPslug).toBe('getting-started/installation')\n+      expect(match!.groups!.nxtIslug).toBe('getting-started/installation')\n     })\n \n     it('should handle multiple parameters with mixed types consistently', () => {\n@@ -1104,12 +1397,12 @@ describe('generateInterceptionRoutesRewrites', () => {\n       expect(rewrites).toHaveLength(1)\n       const rewrite = rewrites[0]\n \n-      // Verify source and destination have correct format with * suffix for catchall\n+      // Verify source and destination have correct format with + suffix for catchall\n       expect(rewrite.source).toBe(\n-        '/blog/:nxtPyear/:nxtPmonth/:nxtPslug/comments/:nxtPcommentPath+'\n+        '/blog/:nxtPyear/:nxtPmonth/:nxtIslug/comments/:nxtPcommentPath+'\n       )\n       expect(rewrite.destination).toBe(\n-        '/blog/:nxtPyear/:nxtPmonth/(.):nxtPslug/comments/:nxtPcommentPath+'\n+        '/blog/:nxtPyear/:nxtPmonth/(.):nxtIslug/comments/:nxtPcommentPath+'\n       )\n \n       // All parameters should use nxtP prefix (no nxtI for intercepted route source)\n@@ -1127,19 +1420,19 @@ describe('generateInterceptionRoutesRewrites', () => {\n       expect(sourceParams).toEqual([\n         'nxtPyear',\n         'nxtPmonth',\n-        'nxtPslug',\n+        'nxtIslug',\n         'nxtPcommentPath',\n       ])\n       expect(destParams).toEqual([\n         'nxtPyear',\n         'nxtPmonth',\n-        'nxtPslug',\n+        'nxtIslug',\n         'nxtPcommentPath',\n       ])\n       expect(regexParams).toEqual([\n         'nxtPyear',\n         'nxtPmonth',\n-        'nxtPslug',\n+        'nxtIslug',\n         'nxtPcommentPath',\n       ])\n \n@@ -1157,23 +1450,23 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n       // This is the exact case that was failing\n       expect(rewrite.source).toBe(\n-        '/intercepting-routes-dynamic/photos/:nxtPauthor/:nxtPid'\n+        '/intercepting-routes-dynamic/photos/:nxtIauthor/:nxtPid'\n       )\n       expect(rewrite.destination).toBe(\n-        '/intercepting-routes-dynamic/photos/(.):nxtPauthor/:nxtPid'\n+        '/intercepting-routes-dynamic/photos/(.):nxtIauthor/:nxtPid'\n       )\n \n       // The bug was: regex had (?<nxtPauthor> but source had :nxtIauthor\n       // Now they should match:\n       const regexParams = Array.from(\n         rewrite.regex!.matchAll(/\\(\\?<(\\w+)>/g)\n       ).map((m) => m[1])\n-      expect(regexParams).toEqual(['nxtPauthor', 'nxtPid'])\n+      expect(regexParams).toEqual(['nxtIauthor', 'nxtPid'])\n \n       const sourceParams = rewrite.source\n         .match(/:(\\w+)/g)\n         ?.map((p) => p.slice(1))\n-      expect(sourceParams).toEqual(['nxtPauthor', 'nxtPid'])\n+      expect(sourceParams).toEqual(['nxtIauthor', 'nxtPid'])\n \n       // Verify actual URL matching and substitution works\n       const { sourceRegex } = getRewriteMatchers(rewrite)\n@@ -1183,7 +1476,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n       expect(match).toBeTruthy()\n       expect(match!.groups).toEqual({\n-        nxtPauthor: 'next',\n+        nxtIauthor: 'next',\n         nxtPid: '123',\n       })\n \n@@ -1213,13 +1506,13 @@ describe('generateInterceptionRoutesRewrites', () => {\n         expect(rewrite.source).toBe('/photos')\n         expect(rewrite.destination).toBe('/@slot1/@slot2/(.)photos')\n \n-        // Header should match root-level routes (both slots normalized away)\n+        // Header should match root-level routes and all descendants (both slots normalized away)\n         const { headerRegex } = getRewriteMatchers(rewrite)\n-        expect(headerRegex.source).toMatchInlineSnapshot(`\"^(\\\\/[^/]+)?\\\\/?$\"`)\n+        expect(headerRegex.source).toMatchInlineSnapshot(`\"^\\\\/.*$\"`)\n \n         expect(headerRegex.test('/')).toBe(true)\n         expect(headerRegex.test('/home')).toBe(true)\n-        expect(headerRegex.test('/home/nested')).toBe(false)\n+        expect(headerRegex.test('/home/nested')).toBe(true)\n       })\n     })\n \n@@ -1238,7 +1531,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n         const { headerRegex } = getRewriteMatchers(rewrite)\n         expect(headerRegex.source).toMatchInlineSnapshot(\n-          `\"^\\\\/templates(\\\\/.+)?$\"`\n+          `\"^\\\\/templates(?:\\\\/.*)?$\"`\n         )\n \n         // With optional catchall sibling, should match exact level AND nested paths\n@@ -1261,7 +1554,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n         const { headerRegex } = getRewriteMatchers(rewrite)\n         expect(headerRegex.source).toMatchInlineSnapshot(\n-          `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/dashboard(\\\\/.+)?$\"`\n+          `\"^(?:\\\\/(?<nxtPlocale>.+?))?\\\\/dashboard(?:\\\\/.*)?$\"`\n         )\n \n         // Should match dashboard with and without locale, plus nested paths\n@@ -1287,17 +1580,18 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n         const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n         expect(headerRegex.source).toMatchInlineSnapshot(\n-          `\"^\\\\/feed(\\\\/[^/]+)?\\\\/?$\"`\n+          `\"^\\\\/feed(?:\\\\/.*)?$\"`\n         )\n \n         // Source should match catchall paths\n         expect(sourceRegex.test('/feed/blog/post-1')).toBe(true)\n         expect(sourceRegex.test('/feed/blog/2024/post-1')).toBe(true)\n         expect(sourceRegex.test('/feed/blog/a/b/c')).toBe(true)\n \n-        // Header should match /feed level\n+        // Header should match /feed level and all descendants\n         expect(headerRegex.test('/feed')).toBe(true)\n         expect(headerRegex.test('/feed/home')).toBe(true)\n+        expect(headerRegex.test('/feed/home/nested')).toBe(true)\n       })\n \n       it('should intercept an optional catchall route with (..)', () => {\n@@ -1316,7 +1610,7 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n         const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n         expect(headerRegex.source).toMatchInlineSnapshot(\n-          `\"^\\\\/dashboard\\\\/settings$\"`\n+          `\"^\\\\/dashboard\\\\/settings(?:\\\\/.*)?$\"`\n         )\n \n         // Source should match with 0 or more path segments\n@@ -1326,8 +1620,9 @@ describe('generateInterceptionRoutesRewrites', () => {\n           true\n         )\n \n-        // Header should match intercepting route level\n+        // Header should match intercepting route level and all descendants\n         expect(headerRegex.test('/dashboard/settings')).toBe(true)\n+        expect(headerRegex.test('/dashboard/settings/nested')).toBe(true)\n       })\n \n       it('should handle (...) intercepting a catchall at root', () => {\n@@ -1348,15 +1643,17 @@ describe('generateInterceptionRoutesRewrites', () => {\n \n         const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n         expect(headerRegex.source).toMatchInlineSnapshot(\n-          `\"^\\\\/app\\\\/dashboard(?:\\\\/)?$\"`\n+          `\"^\\\\/app\\\\/dashboard(?:\\\\/.*)?$\"`\n         )\n \n         // Source should match catchall paths\n         expect(sourceRegex.test('/docs/getting-started')).toBe(true)\n         expect(sourceRegex.test('/docs/api/reference')).toBe(true)\n \n-        // Header should match intercepting route level\n+        // Header should match intercepting route level and all descendants\n         expect(headerRegex.test('/app/dashboard')).toBe(true)\n+        expect(headerRegex.test('/app/dashboard/nested')).toBe(true)\n+        expect(headerRegex.test('/app/dashboard/nested/deep')).toBe(true)\n       })\n     })\n \n@@ -1504,16 +1801,16 @@ describe('generateInterceptionRoutesRewrites', () => {\n         const rewrite = rewrites[0]\n \n         // Underscores should be preserved in parameter names\n-        expect(rewrite.source).toBe('/:nxtPuser_id123/:nxtPpost_id456')\n-        expect(rewrite.destination).toBe('/:nxtPuser_id123/(.):nxtPpost_id456')\n+        expect(rewrite.source).toBe('/:nxtPuser_id123/:nxtIpost_id456')\n+        expect(rewrite.destination).toBe('/:nxtPuser_id123/(.):nxtIpost_id456')\n \n         const { sourceRegex } = getRewriteMatchers(rewrite)\n         const match = sourceRegex.exec('/user123/post456')\n \n         expect(match).toBeTruthy()\n         expect(match!.groups).toEqual({\n           nxtPuser_id123: 'user123',\n-          nxtPpost_id456: 'post456',\n+          nxtIpost_id456: 'post456',\n         })\n       })\n \n@@ -1623,5 +1920,368 @@ describe('generateInterceptionRoutesRewrites', () => {\n         expect(headerRegex.test('/en/us/dashboard')).toBe(true)\n       })\n     })\n+\n+    describe('deep nesting with many dynamic segments', () => {\n+      it('should handle GitHub-style deeply nested route with interception', () => {\n+        // Pattern: /[org]/[repo]/tree/[branch]/@modal intercepts blob one level up\n+        // (..) from /[org]/[repo]/tree/[branch] goes to /[org]/[repo]/tree\n+        const rewrites = generateInterceptionRoutesRewrites([\n+          '/[org]/[repo]/tree/[branch]/@modal/(..)blob/[...filepath]',\n+        ])\n+\n+        expect(rewrites).toHaveLength(1)\n+        const rewrite = rewrites[0]\n+\n+        // (..) goes one level up from /[org]/[repo]/tree/[branch], which is /[org]/[repo]/tree\n+        expect(rewrite.source).toBe(\n+          '/:nxtPorg/:nxtPrepo/tree/blob/:nxtPfilepath+'\n+        )\n+\n+        // Destination includes all parameters from the intercepting route\n+        expect(rewrite.destination).toBe(\n+          '/:nxtPorg/:nxtPrepo/tree/:nxtPbranch/@modal/(..)blob/:nxtPfilepath+'\n+        )\n+\n+        const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+        // Source should match blob paths under tree\n+        expect(sourceRegex.test('/vercel/next.js/tree/blob/README.md')).toBe(\n+          true\n+        )\n+        expect(\n+          sourceRegex.test('/vercel/next.js/tree/blob/src/client/app.ts')\n+        ).toBe(true)\n+\n+        // Header should match tree view at specific branch level\n+        expect(headerRegex.test('/vercel/next.js/tree/canary')).toBe(true)\n+        expect(headerRegex.test('/vercel/next.js/tree/main')).toBe(true)\n+        expect(headerRegex.test('/vercel/next.js/tree/canary/nested')).toBe(\n+          true\n+        )\n+\n+        // Verify parameter extraction works correctly\n+        const match = sourceRegex.exec('/vercel/next.js/tree/blob/src/index.ts')\n+        expect(match?.groups).toEqual({\n+          nxtPorg: 'vercel',\n+          nxtPrepo: 'next.js',\n+          nxtPfilepath: 'src/index.ts',\n+        })\n+      })\n+\n+      it('should handle multi-tenant SaaS with 5+ segments', () => {\n+        // Pattern: /[workspace]/[project]/[env]/[service]/settings intercepts logs\n+        const rewrites = generateInterceptionRoutesRewrites([\n+          '/[workspace]/[project]/[env]/[service]/settings/@modal/(.)logs/[...path]',\n+        ])\n+\n+        expect(rewrites).toHaveLength(1)\n+        const rewrite = rewrites[0]\n+\n+        expect(rewrite.source).toBe(\n+          '/:nxtPworkspace/:nxtPproject/:nxtPenv/:nxtPservice/settings/logs/:nxtPpath+'\n+        )\n+        expect(rewrite.destination).toBe(\n+          '/:nxtPworkspace/:nxtPproject/:nxtPenv/:nxtPservice/settings/@modal/(.)logs/:nxtPpath+'\n+        )\n+\n+        const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+        // Source should match deeply nested log paths\n+        expect(\n+          sourceRegex.test('/acme/website/prod/api/settings/logs/errors.log')\n+        ).toBe(true)\n+        expect(\n+          sourceRegex.test(\n+            '/acme/website/staging/web/settings/logs/2024/01/app.log'\n+          )\n+        ).toBe(true)\n+\n+        // Header should match the settings level\n+        expect(headerRegex.test('/acme/website/prod/api/settings')).toBe(true)\n+        expect(headerRegex.test('/acme/website/staging/web/settings')).toBe(\n+          true\n+        )\n+\n+        // Verify all parameters are extracted\n+        const match = sourceRegex.exec(\n+          '/acme/website/prod/api/settings/logs/error.log'\n+        )\n+        expect(match?.groups).toEqual({\n+          nxtPworkspace: 'acme',\n+          nxtPproject: 'website',\n+          nxtPenv: 'prod',\n+          nxtPservice: 'api',\n+          nxtPpath: 'error.log',\n+        })\n+      })\n+\n+      it('should handle 6 consecutive dynamic segments with interception', () => {\n+        const rewrites = generateInterceptionRoutesRewrites([\n+          '/[a]/[b]/[c]/[d]/[e]/[f]/(.)target',\n+        ])\n+\n+        expect(rewrites).toHaveLength(1)\n+        const rewrite = rewrites[0]\n+\n+        expect(rewrite.source).toBe(\n+          '/:nxtPa/:nxtPb/:nxtPc/:nxtPd/:nxtPe/:nxtPf/target'\n+        )\n+        expect(rewrite.destination).toBe(\n+          '/:nxtPa/:nxtPb/:nxtPc/:nxtPd/:nxtPe/:nxtPf/(.)target'\n+        )\n+\n+        const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+        expect(sourceRegex.test('/1/2/3/4/5/6/target')).toBe(true)\n+\n+        // Header should match all 6 levels\n+        expect(headerRegex.test('/1/2/3/4/5/6')).toBe(true)\n+        expect(headerRegex.test('/a/b/c/d/e/f')).toBe(true)\n+\n+        // Verify all 6 parameters are captured\n+        const match = sourceRegex.exec('/1/2/3/4/5/6/target')\n+        expect(Object.keys(match?.groups || {}).length).toBe(6)\n+        expect(match?.groups).toMatchObject({\n+          nxtPa: '1',\n+          nxtPb: '2',\n+          nxtPc: '3',\n+          nxtPd: '4',\n+          nxtPe: '5',\n+          nxtPf: '6',\n+        })\n+      })\n+    })\n+\n+    describe('multiple conflicting interception routes', () => {\n+      it('should handle multiple routes intercepting the same target from different levels', () => {\n+        // Real scenario: multiple modals at different levels trying to intercept the same route\n+        const rewrites = generateInterceptionRoutesRewrites([\n+          '/dashboard/@modal/(.)settings',\n+          '/dashboard/profile/@modal/(..)settings',\n+          '/@global-modal/(...)settings',\n+        ])\n+\n+        // Should generate 3 rewrites, one for each interception route\n+        expect(rewrites).toHaveLength(3)\n+\n+        // First rewrite: from /dashboard level\n+        const dashboardRewrite = rewrites[0]\n+        expect(dashboardRewrite.source).toBe('/dashboard/settings')\n+        expect(dashboardRewrite.destination).toBe(\n+          '/dashboard/@modal/(.)settings'\n+        )\n+\n+        const { headerRegex: dashboardHeader } =\n+          getRewriteMatchers(dashboardRewrite)\n+        expect(dashboardHeader.test('/dashboard')).toBe(true)\n+        expect(dashboardHeader.test('/dashboard/profile')).toBe(true)\n+\n+        // Second rewrite: from /dashboard/profile level (one level up)\n+        const profileRewrite = rewrites[1]\n+        expect(profileRewrite.source).toBe('/dashboard/settings')\n+        expect(profileRewrite.destination).toBe(\n+          '/dashboard/profile/@modal/(..)settings'\n+        )\n+\n+        const { headerRegex: profileHeader } =\n+          getRewriteMatchers(profileRewrite)\n+        expect(profileHeader.test('/dashboard/profile')).toBe(true)\n+        expect(profileHeader.test('/dashboard/profile/nested')).toBe(true)\n+\n+        // Third rewrite: from root level (...)\n+        const rootRewrite = rewrites[2]\n+        expect(rootRewrite.source).toBe('/settings')\n+        expect(rootRewrite.destination).toBe('/@global-modal/(...)settings')\n+\n+        const { headerRegex: rootHeader } = getRewriteMatchers(rootRewrite)\n+        expect(rootHeader.test('/')).toBe(true)\n+        expect(rootHeader.test('/anything')).toBe(true)\n+      })\n+\n+      it('should handle parallel routes with same target from different positions', () => {\n+        const rewrites = generateInterceptionRoutesRewrites([\n+          '/dashboard/@sidebar/(.)user/[id]',\n+          '/dashboard/@modal/(.)user/[id]',\n+        ])\n+\n+        expect(rewrites).toHaveLength(2)\n+\n+        // Both should have the same source but different destinations\n+        expect(rewrites[0].source).toBe('/dashboard/user/:nxtPid')\n+        expect(rewrites[1].source).toBe('/dashboard/user/:nxtPid')\n+\n+        expect(rewrites[0].destination).toBe(\n+          '/dashboard/@sidebar/(.)user/:nxtPid'\n+        )\n+        expect(rewrites[1].destination).toBe(\n+          '/dashboard/@modal/(.)user/:nxtPid'\n+        )\n+\n+        // Both should match the same header pattern\n+        const { headerRegex: header1 } = getRewriteMatchers(rewrites[0])\n+        const { headerRegex: header2 } = getRewriteMatchers(rewrites[1])\n+\n+        expect(header1.source).toBe(header2.source)\n+        expect(header1.test('/dashboard')).toBe(true)\n+      })\n+    })\n+\n+    describe('complex real-world integration patterns', () => {\n+      it('should handle enterprise app with all features combined', () => {\n+        // i18n + multi-tenant + route groups + parallel routes + interception\n+        const rewrites = generateInterceptionRoutesRewrites([\n+          '/[[...locale]]/[workspace]/[project]/(dashboard)/[environment]/@modal/(..)settings/[section]/[...path]',\n+        ])\n+\n+        expect(rewrites).toHaveLength(1)\n+        const rewrite = rewrites[0]\n+\n+        // Source: intercepted route one level up from environment\n+        expect(rewrite.source).toBe(\n+          '/:nxtPlocale*/:nxtPworkspace/:nxtPproject/settings/:nxtPsection/:nxtPpath+'\n+        )\n+\n+        // Destination: full path with all segments\n+        expect(rewrite.destination).toBe(\n+          '/:nxtPlocale*/:nxtPworkspace/:nxtPproject/(dashboard)/:nxtPenvironment/@modal/(..)settings/:nxtPsection/:nxtPpath+'\n+        )\n+\n+        const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+        // Test various locale depths with full path\n+        expect(sourceRegex.test('/acme/myapp/settings/general/advanced')).toBe(\n+          true\n+        )\n+        expect(\n+          sourceRegex.test('/en/acme/myapp/settings/general/advanced')\n+        ).toBe(true)\n+        expect(\n+          sourceRegex.test('/en/US/acme/myapp/settings/general/advanced/nested')\n+        ).toBe(true)\n+\n+        // Header should match the environment level with optional locale\n+        expect(headerRegex.test('/acme/myapp/prod')).toBe(true)\n+        expect(headerRegex.test('/en/acme/myapp/staging')).toBe(true)\n+        expect(headerRegex.test('/en/US/acme/myapp/dev')).toBe(true)\n+\n+        // Verify all parameters are captured correctly\n+        const match = sourceRegex.exec(\n+          '/en/acme/myapp/settings/billing/invoices/2024'\n+        )\n+        expect(match?.groups).toEqual({\n+          nxtPlocale: 'en',\n+          nxtPworkspace: 'acme',\n+          nxtPproject: 'myapp',\n+          nxtPsection: 'billing',\n+          nxtPpath: 'invoices/2024',\n+        })\n+      })\n+\n+      it('should handle e-commerce with product categories and modals', () => {\n+        // (..) from /[[...locale]]/shop/[...category] goes to /[[...locale]]/shop\n+        const rewrites = generateInterceptionRoutesRewrites([\n+          '/[[...locale]]/shop/[...category]/@quickview/(..)product/[slug]',\n+        ])\n+\n+        expect(rewrites).toHaveLength(1)\n+        const rewrite = rewrites[0]\n+\n+        // (..) goes one level up from /[[...locale]]/shop/[...category], which is /[[...locale]]/shop\n+        expect(rewrite.source).toBe('/:nxtPlocale*/shop/product/:nxtPslug')\n+        expect(rewrite.destination).toBe(\n+          '/:nxtPlocale*/shop/:nxtPcategory+/@quickview/(..)product/:nxtPslug'\n+        )\n+\n+        const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+        // Should work with various locale depths\n+        expect(sourceRegex.test('/shop/product/laptop-1')).toBe(true)\n+        expect(sourceRegex.test('/en/shop/product/shirt-1')).toBe(true)\n+        expect(sourceRegex.test('/en/US/shop/product/blender-1')).toBe(true)\n+\n+        // Header should match from category pages at any depth\n+        expect(headerRegex.test('/shop/electronics')).toBe(true)\n+        expect(headerRegex.test('/en/shop/clothing/mens')).toBe(true)\n+        expect(headerRegex.test('/en/US/shop/home/kitchen/appliances')).toBe(\n+          true\n+        )\n+      })\n+\n+      it('should handle documentation site with versioning and modals', () => {\n+        // (..) from /[[...locale]]/docs/[version]/[...slug] goes to /[[...locale]]/docs/[version]\n+        const rewrites = generateInterceptionRoutesRewrites([\n+          '/[[...locale]]/docs/[version]/[...slug]/@modal/(..)api/[endpoint]',\n+        ])\n+\n+        expect(rewrites).toHaveLength(1)\n+        const rewrite = rewrites[0]\n+\n+        // (..) goes one level up from /[[...locale]]/docs/[version]/[...slug], which is /[[...locale]]/docs/[version]\n+        expect(rewrite.source).toBe(\n+          '/:nxtPlocale*/docs/:nxtPversion/api/:nxtPendpoint'\n+        )\n+        expect(rewrite.destination).toBe(\n+          '/:nxtPlocale*/docs/:nxtPversion/:nxtPslug+/@modal/(..)api/:nxtPendpoint'\n+        )\n+\n+        const { sourceRegex, headerRegex } = getRewriteMatchers(rewrite)\n+\n+        // Should handle different locales and versions\n+        expect(sourceRegex.test('/docs/v14/api/getStaticProps')).toBe(true)\n+        expect(sourceRegex.test('/en/docs/v15/api/generateStaticParams')).toBe(\n+          true\n+        )\n+\n+        // Header should match the doc page level (with slug catchall)\n+        expect(headerRegex.test('/docs/v14/getting-started')).toBe(true)\n+        expect(headerRegex.test('/en/docs/v15/guides/routing')).toBe(true)\n+\n+        const match = sourceRegex.exec('/en/docs/v15/api/generateStaticParams')\n+        expect(match?.groups).toEqual({\n+          nxtPlocale: 'en',\n+          nxtPversion: 'v15',\n+          nxtPendpoint: 'generateStaticParams',\n+        })\n+      })\n+\n+      it('should handle social media app with multiple modal types', () => {\n+        const rewrites = generateInterceptionRoutesRewrites([\n+          '/[username]/@post-modal/[postId]/@comments/(..)comment/[commentId]',\n+          '/[username]/@photo-modal/(.)photos/[photoId]',\n+        ])\n+\n+        expect(rewrites).toHaveLength(2)\n+\n+        // First rewrite: comment modal from within post modal\n+        // (..) from /[username]/[postId] (after normalizing @post-modal/@comments) goes to /[username]\n+        const commentRewrite = rewrites[0]\n+        expect(commentRewrite.source).toBe(\n+          '/:nxtPusername/comment/:nxtPcommentId'\n+        )\n+        expect(commentRewrite.destination).toBe(\n+          '/:nxtPusername/@post-modal/:nxtPpostId/@comments/(..)comment/:nxtPcommentId'\n+        )\n+\n+        // Second rewrite: photo modal from profile\n+        const photoRewrite = rewrites[1]\n+        expect(photoRewrite.source).toBe('/:nxtPusername/photos/:nxtPphotoId')\n+        expect(photoRewrite.destination).toBe(\n+          '/:nxtPusername/@photo-modal/(.)photos/:nxtPphotoId'\n+        )\n+\n+        const { sourceRegex: commentSource, headerRegex: commentHeader } =\n+          getRewriteMatchers(commentRewrite)\n+        const { sourceRegex: photoSource, headerRegex: photoHeader } =\n+          getRewriteMatchers(photoRewrite)\n+\n+        // Comment interception - goes one level up from postId, so no postId in source\n+        expect(commentSource.test('/john/comment/comment456')).toBe(true)\n+        expect(commentHeader.test('/john/post123')).toBe(true)\n+\n+        // Photo interception\n+        expect(photoSource.test('/john/photos/photo789')).toBe(true)\n+        expect(photoHeader.test('/john')).toBe(true)\n+      })\n+    })\n   })\n })"
        },
        {
            "sha": "c196b64dbf2fecf1f0e2fb5d2ba3fcfd433860b4",
            "filename": "packages/next/src/lib/generate-interception-routes-rewrites.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 252,
            "changes": 266,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.ts?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -2,233 +2,10 @@ import { NEXT_URL } from '../client/components/app-router-headers'\n import {\n   extractInterceptionRouteInformation,\n   isInterceptionRouteAppPath,\n-  INTERCEPTION_ROUTE_MARKERS,\n } from '../shared/lib/router/utils/interception-routes'\n import type { Rewrite } from './load-custom-routes'\n import type { DeepReadonly } from '../shared/lib/deep-readonly'\n import { getNamedRouteRegex } from '../shared/lib/router/utils/route-regex'\n-import {\n-  getSegmentParam,\n-  isCatchAll,\n-} from '../shared/lib/router/utils/get-segment-param'\n-import { InvariantError } from '../shared/lib/invariant-error'\n-import { escapeStringRegexp } from '../shared/lib/escape-regexp'\n-\n-/**\n- * Detects which interception marker is used in the app path\n- */\n-function getInterceptionMarker(\n-  appPath: string\n-): (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined {\n-  for (const segment of appPath.split('/')) {\n-    const marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n-    if (marker) {\n-      return marker\n-    }\n-  }\n-  return undefined\n-}\n-\n-/**\n- * Generates a regex pattern that matches routes at the same level as the intercepting route.\n- * For (.) same-level interception, we need to match:\n- * - The intercepting route itself\n- * - Any direct child of the intercepting route\n- * But NOT deeper nested routes\n- */\n-function generateSameLevelHeaderRegex(\n-  interceptingRoute: string,\n-  reference: Record<string, string>\n-): string {\n-  // Build the pattern for matching the intercepting route and its direct children\n-  const segments =\n-    interceptingRoute === '/'\n-      ? []\n-      : interceptingRoute.split('/').filter(Boolean)\n-\n-  const patterns: string[] = []\n-  const optionalIndices: number[] = []\n-\n-  for (let i = 0; i < segments.length; i++) {\n-    const segment = segments[i]\n-    const param = getSegmentParam(segment)\n-    if (param) {\n-      // Dynamic segment - use named capture group\n-      // Use the reference mapping which has the correct param -> prefixedKey mapping\n-      const prefixedKey = reference[param.param]\n-      if (!prefixedKey) {\n-        throw new InvariantError(\n-          `No reference found for param: ${param.param} in reference: ${JSON.stringify(reference)}`\n-        )\n-      }\n-\n-      // Check if this is a catchall (repeat) parameter\n-      if (isCatchAll(param.type)) {\n-        patterns.push(`(?<${prefixedKey}>.+?)`)\n-        // Track optional catchall segments so we can wrap them later\n-        if (param.type === 'optional-catchall') {\n-          optionalIndices.push(i)\n-        }\n-      } else {\n-        patterns.push(`(?<${prefixedKey}>[^/]+?)`)\n-      }\n-    } else {\n-      // Static segment\n-      patterns.push(escapeStringRegexp(segment))\n-    }\n-  }\n-\n-  // Build the header regex, wrapping optional catchall segments\n-  let pattern = ''\n-  for (let i = 0; i < patterns.length; i++) {\n-    if (optionalIndices.includes(i)) {\n-      // Optional catchall: wrap the segment with its leading / in an optional group\n-      pattern += `(?:/${patterns[i]})?`\n-    } else {\n-      pattern += `/${patterns[i]}`\n-    }\n-  }\n-\n-  // Match the pattern, optionally followed by a single segment, with optional trailing slash\n-  // Note: Don't add ^ and $ anchors here - matchHas() will add them automatically\n-  return `${pattern}(/[^/]+)?/?`\n-}\n-\n-/**\n- * Check if there's a catchall route sibling at the intercepting route level.\n- * For example, if interceptingRoute is '/templates', this checks for\n- * '/templates/[...catchAll]'.\n- */\n-function hasCatchallSiblingAtLevel(\n-  appPaths: string[],\n-  interceptingRoute: string\n-): boolean {\n-  const targetSegments =\n-    interceptingRoute === '/'\n-      ? []\n-      : interceptingRoute.split('/').filter(Boolean)\n-  const targetDepth = targetSegments.length\n-\n-  return appPaths.some((path) => {\n-    const segments = path.split('/').filter(Boolean)\n-\n-    // Check if this path is at the same depth + 1 (parent segments + the catchall segment)\n-    if (segments.length !== targetDepth + 1) {\n-      return false\n-    }\n-\n-    // Check if the first targetDepth segments match exactly\n-    for (let i = 0; i < targetDepth; i++) {\n-      // Skip interception routes\n-      if (\n-        INTERCEPTION_ROUTE_MARKERS.some((marker) =>\n-          segments[i].startsWith(marker)\n-        )\n-      ) {\n-        return false\n-      }\n-\n-      if (segments[i] !== targetSegments[i]) {\n-        return false\n-      }\n-    }\n-\n-    // Check if the last segment is a catchall parameter\n-    const lastSegment = segments[segments.length - 1]\n-    const param = getSegmentParam(lastSegment)\n-    return param !== null && isCatchAll(param.type)\n-  })\n-}\n-\n-/**\n- * Generates the appropriate header regex based on the interception marker type.\n- * @param marker The interception route marker (e.g., '(.)', '(..)'))\n- * @param interceptingRoute The route that intercepts (e.g., '/templates')\n- * @param headerReference The reference mapping from param names to prefixed keys\n- * @param appPaths All app paths (used for catchall sibling detection)\n- * @param defaultHeaderRegex The default regex to use if no marker-specific logic applies\n- * @returns The header regex pattern to match against the Next-URL header\n- */\n-function generateInterceptionHeaderRegex(\n-  marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,\n-  interceptingRoute: string,\n-  headerReference: Record<string, string>,\n-  appPaths: string[],\n-  defaultHeaderRegex: string\n-): string {\n-  // Generate the appropriate header regex based on the marker type\n-  let headerRegex: string\n-  if (marker === '(.)') {\n-    // For same-level interception, match routes at the same level as the intercepting route\n-    // Use header.reference which has the param -> prefixedKey mapping\n-    headerRegex = generateSameLevelHeaderRegex(\n-      interceptingRoute,\n-      headerReference\n-    )\n-  } else if (marker === '(..)') {\n-    // For parent-level interception, match routes at the intercepting route level\n-    // Check if there's a catchall sibling at the intercepting route level\n-    const hasCatchallSibling = hasCatchallSiblingAtLevel(\n-      appPaths,\n-      interceptingRoute\n-    )\n-\n-    // Build regex pattern that handles dynamic segments correctly\n-    const patterns: string[] = []\n-    const optionalIndices: number[] = []\n-\n-    const segments = interceptingRoute.split('/').filter(Boolean)\n-    for (let i = 0; i < segments.length; i++) {\n-      const segment = segments[i]\n-      const param = getSegmentParam(segment)\n-      if (param) {\n-        // Dynamic segment - use named capture group from header.reference\n-        const key = headerReference[param.param]\n-        if (!key) {\n-          throw new InvariantError(\n-            `No reference found for param: ${param.param} in reference: ${JSON.stringify(headerReference)}`\n-          )\n-        }\n-\n-        // Check if this is a catchall (repeat) parameter\n-        if (isCatchAll(param.type)) {\n-          patterns.push(`(?<${key}>.+?)`)\n-          // Track optional catchall segments so we can wrap them later\n-          if (param.type === 'optional-catchall') {\n-            optionalIndices.push(i)\n-          }\n-        } else {\n-          patterns.push(`(?<${key}>[^/]+?)`)\n-        }\n-      } else {\n-        // Static segment\n-        patterns.push(escapeStringRegexp(segment))\n-      }\n-    }\n-\n-    // Build the header regex, wrapping optional catchall segments\n-    let headerPattern = ''\n-    for (let i = 0; i < patterns.length; i++) {\n-      if (optionalIndices.includes(i)) {\n-        // Optional catchall: wrap the segment with its leading / in an optional group\n-        headerPattern += `(?:/${patterns[i]})?`\n-      } else {\n-        headerPattern += `/${patterns[i]}`\n-      }\n-    }\n-\n-    // Note: Don't add ^ and $ anchors - matchHas() will add them automatically\n-    // If there's a catchall sibling, match the level and its children (catchall paths)\n-    // Otherwise, only match the exact level\n-    headerRegex = `${headerPattern}${hasCatchallSibling ? '(/.+)?' : ''}`\n-  } else {\n-    // For other markers, use the default behavior (match exact intercepting route)\n-    // Strip ^ and $ anchors since matchHas() will add them automatically\n-    headerRegex = defaultHeaderRegex\n-  }\n-\n-  return headerRegex\n-}\n \n export function generateInterceptionRoutesRewrites(\n   appPaths: string[],\n@@ -241,44 +18,29 @@ export function generateInterceptionRoutesRewrites(\n       const { interceptingRoute, interceptedRoute } =\n         extractInterceptionRouteInformation(appPath)\n \n-      // Detect which marker is being used\n-      const marker = getInterceptionMarker(appPath)\n-\n-      // The Next-Url header does not contain the base path, so just use the\n-      // intercepting route. We don't handle duplicate keys here with the\n-      // backreferenceDuplicateKeys option because it's not a valid pathname\n-      // with them in this case.\n-      const header = getNamedRouteRegex(interceptingRoute, {\n+      const destination = getNamedRouteRegex(basePath + appPath, {\n         prefixRouteKeys: true,\n       })\n \n-      // The source is the intercepted route with the base path, it's matched by\n-      // the router. Generate this first to get the correct parameter prefixes.\n-      // We don't handle duplicate keys here with the backreferenceDuplicateKeys\n-      // option because it's not a valid pathname with them in this case.\n-      const source = getNamedRouteRegex(basePath + interceptedRoute, {\n+      const header = getNamedRouteRegex(interceptingRoute, {\n         prefixRouteKeys: true,\n+        reference: destination.reference,\n       })\n \n-      // The destination should use the same parameter reference as the source\n-      // so that parameter substitution works correctly. This ensures that when\n-      // the router extracts params from the source, they can be substituted\n-      // into the destination. We don't handle duplicate keys here with the\n-      // backreferenceDuplicateKeys option because we don't use the regexp\n-      // itself in this case, only the pathToRegexpPattern.\n-      const destination = getNamedRouteRegex(basePath + appPath, {\n+      const source = getNamedRouteRegex(basePath + interceptedRoute, {\n         prefixRouteKeys: true,\n-        reference: source.reference,\n+        reference: header.reference,\n       })\n \n-      // Generate the header regex based on the interception marker type\n-      const headerRegex = generateInterceptionHeaderRegex(\n-        marker,\n-        interceptingRoute,\n-        header.reference,\n-        appPaths,\n-        header.namedRegex.replace(/^\\^/, '').replace(/\\$$/, '')\n-      )\n+      const headerRegex = header.namedRegex\n+        // Strip ^ and $ anchors since matchHas() will add them automatically\n+        .replace(/^\\^/, '')\n+        .replace(/\\$$/, '')\n+        // Replace matching the `/` with matching any route segment.\n+        .replace(/^\\/\\(\\?:\\/\\)\\?$/, '/.*')\n+        // Replace the optional trailing with slash capture group with one that\n+        // will match any descendants.\n+        .replace(/\\(\\?:\\/\\)\\?$/, '(?:/.*)?')\n \n       rewrites.push({\n         source: source.pathToRegexpPattern,"
        },
        {
            "sha": "7d021741809c3988d924381f9a144782fd16aa18",
            "filename": "packages/next/src/shared/lib/router/utils/interception-routes.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 4,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Finterception-routes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Finterception-routes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Finterception-routes.ts?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -19,10 +19,27 @@ export function isInterceptionRouteAppPath(path: string): boolean {\n   )\n }\n \n-export function extractInterceptionRouteInformation(path: string) {\n-  let interceptingRoute: string | undefined,\n-    marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,\n-    interceptedRoute: string | undefined\n+type InterceptionRouteInformation = {\n+  /**\n+   * The intercepting route. This is the route that is being intercepted or the\n+   * route that the user was coming from. This is matched by the Next-Url\n+   * header.\n+   */\n+  interceptingRoute: string\n+\n+  /**\n+   * The intercepted route. This is the route that is being intercepted or the\n+   * route that the user is going to. This is matched by the request pathname.\n+   */\n+  interceptedRoute: string\n+}\n+\n+export function extractInterceptionRouteInformation(\n+  path: string\n+): InterceptionRouteInformation {\n+  let interceptingRoute: string | undefined\n+  let marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined\n+  let interceptedRoute: string | undefined\n \n   for (const segment of path.split('/')) {\n     marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))"
        },
        {
            "sha": "642518bca766f114b05fe06fe60ab3a9fe2d4b82",
            "filename": "packages/next/src/shared/lib/router/utils/route-regex.test.ts",
            "status": "modified",
            "additions": 89,
            "deletions": 31,
            "changes": 120,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-regex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-regex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-regex.test.ts?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -44,8 +44,13 @@ describe('getNamedRouteRegex', () => {\n        \"pathToRegexpPattern\": \"/photos/(.):nxtIauthor/:nxtPid\",\n        \"re\": /\\\\^\\\\\\\\/photos\\\\\\\\/\\\\\\\\\\\\(\\\\\\\\\\\\.\\\\\\\\\\\\)\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"author\": \"nxtIauthor\",\n-         \"id\": \"nxtPid\",\n+         \"intercepted\": {\n+           \"author\": \"(.)\",\n+         },\n+         \"names\": {\n+           \"author\": \"nxtIauthor\",\n+           \"id\": \"nxtPid\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtIauthor\": \"nxtIauthor\",\n@@ -86,8 +91,13 @@ describe('getNamedRouteRegex', () => {\n        \"pathToRegexpPattern\": \"/(.):nxtIauthor/:nxtPid\",\n        \"re\": /\\\\^\\\\\\\\/\\\\\\\\\\\\(\\\\\\\\\\\\.\\\\\\\\\\\\)\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"author\": \"nxtIauthor\",\n-         \"id\": \"nxtPid\",\n+         \"intercepted\": {\n+           \"author\": \"(.)\",\n+         },\n+         \"names\": {\n+           \"author\": \"nxtIauthor\",\n+           \"id\": \"nxtPid\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtIauthor\": \"nxtIauthor\",\n@@ -122,8 +132,13 @@ describe('getNamedRouteRegex', () => {\n        \"pathToRegexpPattern\": \"/(..)(..):nxtIauthor/:nxtPid\",\n        \"re\": /\\\\^\\\\\\\\/\\\\\\\\\\\\(\\\\\\\\\\\\.\\\\\\\\\\\\.\\\\\\\\\\\\)\\\\\\\\\\\\(\\\\\\\\\\\\.\\\\\\\\\\\\.\\\\\\\\\\\\)\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"author\": \"nxtIauthor\",\n-         \"id\": \"nxtPid\",\n+         \"intercepted\": {\n+           \"author\": \"(..)(..)\",\n+         },\n+         \"names\": {\n+           \"author\": \"nxtIauthor\",\n+           \"id\": \"nxtPid\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtIauthor\": \"nxtIauthor\",\n@@ -160,8 +175,13 @@ describe('getNamedRouteRegex', () => {\n        \"pathToRegexpPattern\": \"/photos/(..)(..):nxtIauthor/:nxtPid\",\n        \"re\": /\\\\^\\\\\\\\/photos\\\\\\\\/\\\\\\\\\\\\(\\\\\\\\\\\\.\\\\\\\\\\\\.\\\\\\\\\\\\)\\\\\\\\\\\\(\\\\\\\\\\\\.\\\\\\\\\\\\.\\\\\\\\\\\\)\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"author\": \"nxtIauthor\",\n-         \"id\": \"nxtPid\",\n+         \"intercepted\": {\n+           \"author\": \"(..)(..)\",\n+         },\n+         \"names\": {\n+           \"author\": \"nxtIauthor\",\n+           \"id\": \"nxtPid\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtIauthor\": \"nxtIauthor\",\n@@ -206,8 +226,11 @@ describe('getNamedRouteRegex', () => {\n        \"pathToRegexpPattern\": \"/:nxtPlocale/about.segments/:nxtPsegmentPath+.segment.rsc\",\n        \"re\": /\\\\^\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/about\\\\\\\\\\\\.segments\\\\\\\\/\\\\(\\\\.\\\\+\\\\?\\\\)\\\\\\\\\\\\.segment\\\\\\\\\\\\.rsc\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"locale\": \"nxtPlocale\",\n-         \"segmentPath\": \"nxtPsegmentPath\",\n+         \"intercepted\": {},\n+         \"names\": {\n+           \"locale\": \"nxtPlocale\",\n+           \"segmentPath\": \"nxtPsegmentPath\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtPlocale\": \"nxtPlocale\",\n@@ -245,8 +268,11 @@ describe('getNamedRouteRegex', () => {\n        \"pathToRegexpPattern\": \"/:nxtPlocale/about.segments/$dname$d/:nxtPname.segment.rsc\",\n        \"re\": /\\\\^\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/about\\\\\\\\\\\\.segments\\\\\\\\/\\\\\\\\\\\\$dname\\\\\\\\\\\\$d\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\\\\\.segment\\\\\\\\\\\\.rsc\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"locale\": \"nxtPlocale\",\n-         \"name\": \"nxtPname\",\n+         \"intercepted\": {},\n+         \"names\": {\n+           \"locale\": \"nxtPlocale\",\n+           \"name\": \"nxtPname\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtPlocale\": \"nxtPlocale\",\n@@ -283,7 +309,10 @@ describe('getNamedRouteRegex', () => {\n        \"pathToRegexpPattern\": \"/photos/(.)author/:nxtPid\",\n        \"re\": /\\\\^\\\\\\\\/photos\\\\\\\\/\\\\\\\\\\\\(\\\\\\\\\\\\.\\\\\\\\\\\\)author\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"id\": \"nxtPid\",\n+         \"intercepted\": {},\n+         \"names\": {\n+           \"id\": \"nxtPid\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtPid\": \"nxtPid\",\n@@ -317,7 +346,10 @@ describe('getNamedRouteRegex', () => {\n        \"pathToRegexpPattern\": \"/photos/:nxtPid\",\n        \"re\": /\\\\^\\\\\\\\/photos\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"id\": \"nxtPid\",\n+         \"intercepted\": {},\n+         \"names\": {\n+           \"id\": \"nxtPid\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtPid\": \"nxtPid\",\n@@ -354,7 +386,10 @@ describe('getNamedRouteRegex', () => {\n        \"pathToRegexpPattern\": \"/photos/:nxtPid*\",\n        \"re\": /\\\\^\\\\\\\\/photos\\\\(\\\\?:\\\\\\\\/\\\\(\\\\.\\\\+\\\\?\\\\)\\\\)\\\\?\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"id\": \"nxtPid\",\n+         \"intercepted\": {},\n+         \"names\": {\n+           \"id\": \"nxtPid\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtPid\": \"nxtPid\",\n@@ -402,7 +437,10 @@ describe('getNamedRouteRegex - Parameter Sanitization', () => {\n        \"pathToRegexpPattern\": \"/:nxtPfoobar/page\",\n        \"re\": /\\\\^\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/page\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"foo-bar\": \"nxtPfoobar\",\n+         \"intercepted\": {},\n+         \"names\": {\n+           \"foo-bar\": \"nxtPfoobar\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtPfoobar\": \"nxtPfoo-bar\",\n@@ -430,7 +468,10 @@ describe('getNamedRouteRegex - Parameter Sanitization', () => {\n        \"pathToRegexpPattern\": \"/:nxtPfoo_id/page\",\n        \"re\": /\\\\^\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/page\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"foo_id\": \"nxtPfoo_id\",\n+         \"intercepted\": {},\n+         \"names\": {\n+           \"foo_id\": \"nxtPfoo_id\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtPfoo_id\": \"nxtPfoo_id\",\n@@ -458,7 +499,10 @@ describe('getNamedRouteRegex - Parameter Sanitization', () => {\n        \"pathToRegexpPattern\": \"/:nxtPthisis_myroute/page\",\n        \"re\": /\\\\^\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/page\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"this-is_my-route\": \"nxtPthisis_myroute\",\n+         \"intercepted\": {},\n+         \"names\": {\n+           \"this-is_my-route\": \"nxtPthisis_myroute\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtPthisis_myroute\": \"nxtPthis-is_my-route\",\n@@ -508,11 +552,11 @@ describe('getNamedRouteRegex - Reference Mapping', () => {\n     })\n \n     // Both should use the same prefixed key for 'lang'\n-    expect(regex1.reference.lang).toBe(regex2.reference.lang)\n-    expect(regex2.reference.lang).toBe('nxtPlang')\n+    expect(regex1.reference.names.lang).toBe(regex2.reference.names.lang)\n+    expect(regex2.reference.names.lang).toBe('nxtPlang')\n \n     // New parameter should be added to the reference\n-    expect(regex2.reference.id).toBe('nxtPid')\n+    expect(regex2.reference.names.id).toBe('nxtPid')\n   })\n \n   it('should maintain reference consistency across multiple paths', () => {\n@@ -526,8 +570,10 @@ describe('getNamedRouteRegex - Reference Mapping', () => {\n     })\n \n     // Same parameter name should map to same prefixed key\n-    expect(baseRegex.reference.locale).toBe(interceptedRegex.reference.locale)\n-    expect(interceptedRegex.reference.locale).toBe('nxtPlocale')\n+    expect(baseRegex.reference.names.locale).toBe(\n+      interceptedRegex.reference.names.locale\n+    )\n+    expect(interceptedRegex.reference.names.locale).toBe('nxtPlocale')\n   })\n \n   it('should generate inverse pattern with correct parameter references', () => {\n@@ -566,7 +612,10 @@ describe('getNamedRouteRegex - Duplicate Keys', () => {\n        \"pathToRegexpPattern\": \"/:nxtPid/posts/:nxtPid\",\n        \"re\": /\\\\^\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/posts\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"id\": \"nxtPid\",\n+         \"intercepted\": {},\n+         \"names\": {\n+           \"id\": \"nxtPid\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtPid\": \"nxtPid\",\n@@ -595,7 +644,10 @@ describe('getNamedRouteRegex - Duplicate Keys', () => {\n        \"pathToRegexpPattern\": \"/:nxtPid/posts/:nxtPid\",\n        \"re\": /\\\\^\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/posts\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"id\": \"nxtPid\",\n+         \"intercepted\": {},\n+         \"names\": {\n+           \"id\": \"nxtPid\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtPid\": \"nxtPid\",\n@@ -639,10 +691,13 @@ describe('getNamedRouteRegex - Complex Paths', () => {\n        \"pathToRegexpPattern\": \"/:nxtPorg/:nxtPrepo/:nxtPbranch/:nxtPpath+\",\n        \"re\": /\\\\^\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\\\\\/\\\\(\\\\.\\\\+\\\\?\\\\)\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"branch\": \"nxtPbranch\",\n-         \"org\": \"nxtPorg\",\n-         \"path\": \"nxtPpath\",\n-         \"repo\": \"nxtPrepo\",\n+         \"intercepted\": {},\n+         \"names\": {\n+           \"branch\": \"nxtPbranch\",\n+           \"org\": \"nxtPorg\",\n+           \"path\": \"nxtPpath\",\n+           \"repo\": \"nxtPrepo\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtPbranch\": \"nxtPbranch\",\n@@ -689,7 +744,7 @@ describe('getNamedRouteRegex - Complex Paths', () => {\n         prefixRouteKeys: true,\n       })\n \n-      // Should use interception prefix\n+      // Should use consistent parameter prefix (interception marker adjacent to parameter uses nxtI)\n       expect(regex.routeKeys).toEqual({\n         nxtIid: 'nxtIid',\n       })\n@@ -721,7 +776,10 @@ describe('getNamedRouteRegex - Trailing Slash Behavior', () => {\n        \"pathToRegexpPattern\": \"/posts/:nxtPid\",\n        \"re\": /\\\\^\\\\\\\\/posts\\\\\\\\/\\\\(\\\\[\\\\^/\\\\]\\\\+\\\\?\\\\)\\\\(\\\\?:\\\\\\\\/\\\\)\\\\?\\\\$/,\n        \"reference\": {\n-         \"id\": \"nxtPid\",\n+         \"intercepted\": {},\n+         \"names\": {\n+           \"id\": \"nxtPid\",\n+         },\n        },\n        \"routeKeys\": {\n          \"nxtPid\": \"nxtPid\","
        },
        {
            "sha": "602ee38fc4a2ad46302360d2182c02bced7d5ca5",
            "filename": "packages/next/src/shared/lib/router/utils/route-regex.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 12,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-regex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-regex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-regex.ts?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -18,6 +18,11 @@ export interface RouteRegex {\n   re: RegExp\n }\n \n+export type RegexReference = {\n+  names: Record<string, string>\n+  intercepted: Record<string, string>\n+}\n+\n type GetNamedRouteRegexOptions = {\n   /**\n    * Whether to prefix the route keys with the NEXT_INTERCEPTION_MARKER_PREFIX\n@@ -58,7 +63,7 @@ type GetNamedRouteRegexOptions = {\n    * keys instead of generating them in context. This is currently only used for\n    * interception routes.\n    */\n-  reference?: Record<string, string>\n+  reference?: RegexReference\n }\n \n type GetRouteRegexOptions = {\n@@ -266,7 +271,7 @@ function getNamedParametrizedRoute(\n   includeSuffix: boolean,\n   includePrefix: boolean,\n   backreferenceDuplicateKeys: boolean,\n-  reference: Record<string, string> = {}\n+  reference: RegexReference = { names: {}, intercepted: {} }\n ) {\n   const getSafeRouteKey = buildGetSafeRouteKey()\n   const routeKeys: { [named: string]: string } = {}\n@@ -284,25 +289,37 @@ function getNamedParametrizedRoute(\n \n     const paramMatches = segment.match(PARAMETER_PATTERN) // Check for parameters\n \n-    if (hasInterceptionMarker && paramMatches && paramMatches[2]) {\n+    const interceptionMarker = hasInterceptionMarker\n+      ? paramMatches?.[1]\n+      : undefined\n+\n+    let keyPrefix: string | undefined\n+    if (interceptionMarker && paramMatches?.[2]) {\n+      keyPrefix = prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n+      reference.intercepted[paramMatches[2]] = interceptionMarker\n+    } else if (paramMatches?.[2] && reference.intercepted[paramMatches[2]]) {\n+      keyPrefix = prefixRouteKeys ? NEXT_INTERCEPTION_MARKER_PREFIX : undefined\n+    } else {\n+      keyPrefix = prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined\n+    }\n+\n+    if (interceptionMarker && paramMatches && paramMatches[2]) {\n       // If there's an interception marker, add it to the segments.\n       const { key, pattern, cleanedKey, repeat, optional } =\n         getSafeKeyFromSegment({\n           getSafeRouteKey,\n-          interceptionMarker: paramMatches[1],\n+          interceptionMarker,\n           segment: paramMatches[2],\n           routeKeys,\n-          keyPrefix: prefixRouteKeys\n-            ? NEXT_INTERCEPTION_MARKER_PREFIX\n-            : undefined,\n+          keyPrefix,\n           backreferenceDuplicateKeys,\n         })\n \n       segments.push(pattern)\n       inverseParts.push(\n-        `/${paramMatches[1]}:${reference[key] ?? cleanedKey}${repeat ? (optional ? '*' : '+') : ''}`\n+        `/${paramMatches[1]}:${reference.names[key] ?? cleanedKey}${repeat ? (optional ? '*' : '+') : ''}`\n       )\n-      reference[key] ??= cleanedKey\n+      reference.names[key] ??= cleanedKey\n     } else if (paramMatches && paramMatches[2]) {\n       // If there's a prefix, add it to the segments if it's enabled.\n       if (includePrefix && paramMatches[1]) {\n@@ -315,7 +332,7 @@ function getNamedParametrizedRoute(\n           getSafeRouteKey,\n           segment: paramMatches[2],\n           routeKeys,\n-          keyPrefix: prefixRouteKeys ? NEXT_QUERY_PARAM_PREFIX : undefined,\n+          keyPrefix,\n           backreferenceDuplicateKeys,\n         })\n \n@@ -327,9 +344,9 @@ function getNamedParametrizedRoute(\n \n       segments.push(s)\n       inverseParts.push(\n-        `/:${reference[key] ?? cleanedKey}${repeat ? (optional ? '*' : '+') : ''}`\n+        `/:${reference.names[key] ?? cleanedKey}${repeat ? (optional ? '*' : '+') : ''}`\n       )\n-      reference[key] ??= cleanedKey\n+      reference.names[key] ??= cleanedKey\n     } else {\n       segments.push(`/${escapeStringRegexp(segment)}`)\n       inverseParts.push(`/${segment}`)"
        },
        {
            "sha": "53e4dbdf4dc0a74f9022daec66537fee13c34f12",
            "filename": "test/e2e/app-dir/interception-dynamic-segment-middleware/interception-dynamic-segment-middleware.test.ts",
            "status": "modified",
            "additions": 54,
            "deletions": 4,
            "changes": 58,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-segment-middleware%2Finterception-dynamic-segment-middleware.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-segment-middleware%2Finterception-dynamic-segment-middleware.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-segment-middleware%2Finterception-dynamic-segment-middleware.test.ts?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -1,5 +1,5 @@\n import { nextTestSetup } from 'e2e-utils'\n-import { check } from 'next-test-utils'\n+import { retry } from 'next-test-utils'\n \n describe('interception-dynamic-segment-middleware', () => {\n   const { next } = nextTestSetup({\n@@ -10,9 +10,59 @@ describe('interception-dynamic-segment-middleware', () => {\n     const browser = await next.browser('/')\n \n     await browser.elementByCss('[href=\"/foo/p/1\"]').click()\n-    await check(() => browser.elementById('modal').text(), /intercepted/)\n+    await retry(async () => {\n+      expect(await browser.elementById('modal').text()).toMatch(/intercepted/)\n+    })\n     await browser.refresh()\n-    await check(() => browser.elementById('modal').text(), 'default')\n-    await check(() => browser.elementById('children').text(), /not intercepted/)\n+    await retry(async () => {\n+      expect(await browser.elementById('modal').text()).toBe('default')\n+    })\n+    await retry(async () => {\n+      expect(await browser.elementById('children').text()).toMatch(\n+        /not intercepted/\n+      )\n+    })\n+  })\n+\n+  it('should intercept with back/forward navigation with middleware', async () => {\n+    // Test that interception works correctly with middleware and browser navigation\n+    const browser = await next.browser('/')\n+\n+    // Navigate with interception\n+    await browser.elementByCss('[href=\"/foo/p/1\"]').click()\n+    await retry(async () => {\n+      expect(await browser.elementById('modal').text()).toMatch(/intercepted/)\n+    })\n+\n+    // Go back to root\n+    await browser.back()\n+    await retry(async () => {\n+      const url = await browser.url()\n+      expect(url).toContain('/')\n+    })\n+\n+    // Go forward - should show intercepted version\n+    await browser.forward()\n+    await retry(async () => {\n+      expect(await browser.elementById('modal').text()).toMatch(/intercepted/)\n+    })\n+  })\n+\n+  it('should intercept multiple times with middleware active', async () => {\n+    // Test that repeated interception works when middleware is involved\n+    const browser = await next.browser('/')\n+\n+    for (let i = 0; i < 2; i++) {\n+      await browser.elementByCss('[href=\"/foo/p/1\"]').click()\n+      await retry(async () => {\n+        expect(await browser.elementById('modal').text()).toMatch(/intercepted/)\n+      })\n+\n+      await browser.back()\n+      await retry(async () => {\n+        const url = await browser.url()\n+        expect(url).toMatch(/\\/$/)\n+      })\n+    }\n   })\n })"
        },
        {
            "sha": "7aa6932f118e73628dc0ffd272cb13f82d5ae5ad",
            "filename": "test/e2e/app-dir/interception-dynamic-segment/interception-dynamic-segment.test.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-segment%2Finterception-dynamic-segment.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-segment%2Finterception-dynamic-segment.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-segment%2Finterception-dynamic-segment.test.ts?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -24,6 +24,48 @@ describe('interception-dynamic-segment', () => {\n     })\n   })\n \n+  it('should intercept consistently with back/forward navigation', async () => {\n+    // Test that the fix works with browser back/forward navigation\n+    const browser = await next.browser('/')\n+\n+    // Navigate with interception\n+    await browser.elementByCss('[href=\"/foo/1\"]').click()\n+    await retry(async () => {\n+      expect(await browser.elementById('modal').text()).toEqual('intercepted')\n+    })\n+\n+    // Go back to root\n+    await browser.back()\n+    await retry(async () => {\n+      const url = await browser.url()\n+      expect(url).toContain('/')\n+    })\n+\n+    // Go forward - should show intercepted version\n+    await browser.forward()\n+    await retry(async () => {\n+      expect(await browser.elementById('modal').text()).toEqual('intercepted')\n+    })\n+  })\n+\n+  it('should intercept multiple times from root', async () => {\n+    // Test that repeated interception from root works\n+    const browser = await next.browser('/')\n+\n+    for (let i = 0; i < 2; i++) {\n+      await browser.elementByCss('[href=\"/foo/1\"]').click()\n+      await retry(async () => {\n+        expect(await browser.elementById('modal').text()).toEqual('intercepted')\n+      })\n+\n+      await browser.back()\n+      await retry(async () => {\n+        const url = await browser.url()\n+        expect(url).toMatch(/\\/$/)\n+      })\n+    }\n+  })\n+\n   if (isNextStart) {\n     it('should correctly prerender segments with generateStaticParams', async () => {\n       expect(next.cliOutput).toContain('/generate-static-params/a')"
        },
        {
            "sha": "e35a210508735d32e58ec60965de6a7bf5371aa6",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)[a]/[b]/[c]/item/page.tsx",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F(.)%5Ba%5D%2F%5Bb%5D%2F%5Bc%5D%2Fitem%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F(.)%5Ba%5D%2F%5Bb%5D%2F%5Bc%5D%2Fitem%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F(.)%5Ba%5D%2F%5Bb%5D%2F%5Bc%5D%2Fitem%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,10 @@\n+export default async function ItemModal(props: {\n+  params: Promise<{ a: string; b: string; c: string }>\n+}) {\n+  const params = await props.params\n+  return (\n+    <div id=\"item-modal\">\n+      Modal: Item for path {params.a}/{params.b}/{params.c}\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "6c0e3a0bd06440d5f91b797040486ce08779cae8",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)admin/dashboard/users/new/page.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F(.)admin%2Fdashboard%2Fusers%2Fnew%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F(.)admin%2Fdashboard%2Fusers%2Fnew%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F(.)admin%2Fdashboard%2Fusers%2Fnew%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,3 @@\n+export default function NewUserModal() {\n+  return <div id=\"new-user-modal\">Modal: New User Form</div>\n+}"
        },
        {
            "sha": "87f9da3a4e4de812d17cee9bedcdf61ffefb77d7",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)groups/[id]/new/page.tsx",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F(.)groups%2F%5Bid%5D%2Fnew%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F(.)groups%2F%5Bid%5D%2Fnew%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F(.)groups%2F%5Bid%5D%2Fnew%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,6 @@\n+export default async function NewItemModal(props: {\n+  params: Promise<{ id: string }>\n+}) {\n+  const params = await props.params\n+  return <div id=\"new-modal\">Modal: New item for group {params.id}</div>\n+}"
        },
        {
            "sha": "ce99d3eb2e4f3294519751a40a2a002001bb2c97",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/(.)org/[orgId]/team/[teamId]/settings/page.tsx",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F(.)org%2F%5BorgId%5D%2Fteam%2F%5BteamId%5D%2Fsettings%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F(.)org%2F%5BorgId%5D%2Fteam%2F%5BteamId%5D%2Fsettings%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F(.)org%2F%5BorgId%5D%2Fteam%2F%5BteamId%5D%2Fsettings%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,10 @@\n+export default async function TeamSettingsModal(props: {\n+  params: Promise<{ orgId: string; teamId: string }>\n+}) {\n+  const params = await props.params\n+  return (\n+    <div id=\"settings-modal\">\n+      Modal: Settings for Team {params.teamId} in Org {params.orgId}\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "cd6c2f1df26e48ce665fbf32cdb52d3177ed47aa",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/[a]/[b]/[c]/page.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F%5Ba%5D%2F%5Bb%5D%2F%5Bc%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F%5Ba%5D%2F%5Bb%5D%2F%5Bc%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2F%5Ba%5D%2F%5Bb%5D%2F%5Bc%5D%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,3 @@\n+export default function ConsecutiveDynamicModalDefault() {\n+  return null\n+}"
        },
        {
            "sha": "6b9b3fb3b79b3107eb1387600bc62705ba08a3d9",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/admin/dashboard/users/page.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2Fadmin%2Fdashboard%2Fusers%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2Fadmin%2Fdashboard%2Fusers%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2Fadmin%2Fdashboard%2Fusers%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,3 @@\n+export default function UsersModalDefault() {\n+  return null\n+}"
        },
        {
            "sha": "2c6e0672552c6788cf9e74960dd5225e6fb2fd70",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/default.tsx",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2Fdefault.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2Fdefault.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2Fdefault.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1 @@\n+export default () => 'default'"
        },
        {
            "sha": "9475665eebf21b0fe6e22526b988ff84781b4bc8",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/groups/[id]/page.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2Fgroups%2F%5Bid%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2Fgroups%2F%5Bid%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2Fgroups%2F%5Bid%5D%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,3 @@\n+export default function GroupModalDefault() {\n+  return null\n+}"
        },
        {
            "sha": "dbd550ca15dfcb0505c728deb8c8429d8d0fae07",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/@modal/org/[orgId]/team/[teamId]/page.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2Forg%2F%5BorgId%5D%2Fteam%2F%5BteamId%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2Forg%2F%5BorgId%5D%2Fteam%2F%5BteamId%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%40modal%2Forg%2F%5BorgId%5D%2Fteam%2F%5BteamId%5D%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,3 @@\n+export default function TeamModalDefault() {\n+  return null\n+}"
        },
        {
            "sha": "510e869333e3ce8db19859fc87fbb10d9714af47",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/[a]/[b]/[c]/item/page.tsx",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%5Ba%5D%2F%5Bb%5D%2F%5Bc%5D%2Fitem%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%5Ba%5D%2F%5Bb%5D%2F%5Bc%5D%2Fitem%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%5Ba%5D%2F%5Bb%5D%2F%5Bc%5D%2Fitem%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,10 @@\n+export default async function ItemPage(props: {\n+  params: Promise<{ a: string; b: string; c: string }>\n+}) {\n+  const params = await props.params\n+  return (\n+    <div id=\"item-page\">\n+      Item for path: {params.a}/{params.b}/{params.c}\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "0be8dcd37cc045341476ef8676a187ca5817dede",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/[a]/[b]/[c]/page.tsx",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%5Ba%5D%2F%5Bb%5D%2F%5Bc%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%5Ba%5D%2F%5Bb%5D%2F%5Bc%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2F%5Ba%5D%2F%5Bb%5D%2F%5Bc%5D%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,17 @@\n+import Link from 'next/link'\n+\n+export default async function ConsecutiveDynamicPage(props: {\n+  params: Promise<{ a: string; b: string; c: string }>\n+}) {\n+  const params = await props.params\n+  return (\n+    <div>\n+      <div id=\"consecutive-page\">\n+        Path: {params.a}/{params.b}/{params.c}\n+      </div>\n+      <Link href={`/${params.a}/${params.b}/${params.c}/item`} id=\"item-link\">\n+        View Item\n+      </Link>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "5e7d34ffbfe11347fc1824deb28cae393cf6fcd3",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/admin/dashboard/users/new/page.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fadmin%2Fdashboard%2Fusers%2Fnew%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fadmin%2Fdashboard%2Fusers%2Fnew%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fadmin%2Fdashboard%2Fusers%2Fnew%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,3 @@\n+export default function NewUserPage() {\n+  return <div id=\"new-user-page\">New User Form</div>\n+}"
        },
        {
            "sha": "459d9c90185e6547ec2d47375f0f764535ed59e3",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/admin/dashboard/users/page.tsx",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fadmin%2Fdashboard%2Fusers%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fadmin%2Fdashboard%2Fusers%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fadmin%2Fdashboard%2Fusers%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,12 @@\n+import Link from 'next/link'\n+\n+export default function UsersPage() {\n+  return (\n+    <div>\n+      <div id=\"users-page\">Admin Dashboard - Users</div>\n+      <Link href=\"/admin/dashboard/users/new\" id=\"new-user-link\">\n+        New User\n+      </Link>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "86b9e9a3881296c372d3f1de5b6988d1d31e3c9d",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/default.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fdefault.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fdefault.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fdefault.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,3 @@\n+export default function Default() {\n+  return null\n+}"
        },
        {
            "sha": "30e3867169a1e9bd249885842b7494da5a287bdb",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/groups/[id]/new/page.tsx",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fgroups%2F%5Bid%5D%2Fnew%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fgroups%2F%5Bid%5D%2Fnew%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fgroups%2F%5Bid%5D%2Fnew%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,6 @@\n+export default async function NewItemPage(props: {\n+  params: Promise<{ id: string }>\n+}) {\n+  const params = await props.params\n+  return <div id=\"new-page\">New item for group {params.id}</div>\n+}"
        },
        {
            "sha": "a4357329b58e78085ae8a087326b072d37840c2f",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/groups/[id]/page.tsx",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fgroups%2F%5Bid%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fgroups%2F%5Bid%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fgroups%2F%5Bid%5D%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,15 @@\n+import Link from 'next/link'\n+\n+export default async function GroupPage(props: {\n+  params: Promise<{ id: string }>\n+}) {\n+  const params = await props.params\n+  return (\n+    <div>\n+      <div id=\"group-page\">Group {params.id}</div>\n+      <Link href={`/groups/${params.id}/new`} id=\"new-link\">\n+        New Item\n+      </Link>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "5d9b38f583e2d021e26b52aa5f14989fd2692129",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/layout.tsx",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Flayout.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,17 @@\n+import { Suspense } from 'react'\n+\n+export default function Layout(props: {\n+  children: React.ReactNode\n+  modal: React.ReactNode\n+}) {\n+  return (\n+    <Suspense>\n+      <html>\n+        <body>\n+          <div id=\"children\">{props.children}</div>\n+          <div id=\"modal\">{props.modal}</div>\n+        </body>\n+      </html>\n+    </Suspense>\n+  )\n+}"
        },
        {
            "sha": "e31c5e47f1df592d07c39e9f0e0d9a7e1fcec1d8",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/org/[orgId]/team/[teamId]/page.tsx",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Forg%2F%5BorgId%5D%2Fteam%2F%5BteamId%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Forg%2F%5BorgId%5D%2Fteam%2F%5BteamId%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Forg%2F%5BorgId%5D%2Fteam%2F%5BteamId%5D%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,20 @@\n+import Link from 'next/link'\n+\n+export default async function TeamPage(props: {\n+  params: Promise<{ orgId: string; teamId: string }>\n+}) {\n+  const params = await props.params\n+  return (\n+    <div>\n+      <div id=\"team-page\">\n+        Team {params.teamId} in Org {params.orgId}\n+      </div>\n+      <Link\n+        href={`/org/${params.orgId}/team/${params.teamId}/settings`}\n+        id=\"settings-link\"\n+      >\n+        Settings\n+      </Link>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "111866d6086c35930324ecab63376951fbd7b5ef",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/org/[orgId]/team/[teamId]/settings/page.tsx",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Forg%2F%5BorgId%5D%2Fteam%2F%5BteamId%5D%2Fsettings%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Forg%2F%5BorgId%5D%2Fteam%2F%5BteamId%5D%2Fsettings%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Forg%2F%5BorgId%5D%2Fteam%2F%5BteamId%5D%2Fsettings%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,10 @@\n+export default async function TeamSettingsPage(props: {\n+  params: Promise<{ orgId: string; teamId: string }>\n+}) {\n+  const params = await props.params\n+  return (\n+    <div id=\"settings-page\">\n+      Settings for Team {params.teamId} in Org {params.orgId}\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "b358f7603e9745f6fd61887f98bd8e5b014869fe",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/app/page.tsx",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fapp%2Fpage.tsx?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,20 @@\n+import Link from 'next/link'\n+\n+export default function Page() {\n+  return (\n+    <div>\n+      <Link href=\"/groups/123\" id=\"groups-link\">\n+        Group 123\n+      </Link>{' '}\n+      <Link href=\"/org/acme/team/engineering\" id=\"team-link\">\n+        Team\n+      </Link>{' '}\n+      <Link href=\"/x/y/z\" id=\"consecutive-link\">\n+        Consecutive\n+      </Link>{' '}\n+      <Link href=\"/admin/dashboard/users\" id=\"admin-link\">\n+        Admin\n+      </Link>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "035a2379f1c3819778ecab49d38bed46a36d6e1d",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/interception-dynamic-single-segment.test.ts",
            "status": "added",
            "additions": 302,
            "deletions": 0,
            "changes": 302,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Finterception-dynamic-single-segment.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Finterception-dynamic-single-segment.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Finterception-dynamic-single-segment.test.ts?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,302 @@\n+import { nextTestSetup } from 'e2e-utils'\n+import { retry } from 'next-test-utils'\n+\n+describe('interception-dynamic-single-segment', () => {\n+  const { next } = nextTestSetup({\n+    files: __dirname,\n+  })\n+\n+  it('should intercept from nested route to deeper nested route with (.) modifier', async () => {\n+    // This test covers the bug fix for same-level (.) interception\n+    // where navigation from a nested route (e.g., /groups/123) to a deeper route\n+    // (e.g., /groups/123/new) should trigger the modal interception.\n+    //\n+    // The bug was that the regex pattern used [^/]+ which only matched single segments,\n+    // so interception failed when the source route had multiple segments like /groups/123\n+    const browser = await next.browser('/groups/123')\n+\n+    // Verify we're on the group page\n+    await retry(async () => {\n+      const text = await browser.elementByCss('body').text()\n+      expect(text).toContain('Group 123')\n+      expect(text).toContain('New Item')\n+    })\n+\n+    // Navigate from /groups/123 to /groups/123/new\n+    // This should trigger the modal interception\n+    await browser.elementById('new-link').click()\n+\n+    await retry(async () => {\n+      const modalText = await browser.elementById('modal').text()\n+      expect(modalText).toContain('Modal: New item for group 123')\n+    })\n+\n+    // The children should still show the group page\n+    await retry(async () => {\n+      const childrenText = await browser.elementById('children').text()\n+      expect(childrenText).toContain('Group 123')\n+    })\n+\n+    // Refresh to verify the full page renders (not intercepted)\n+    await browser.refresh()\n+    await retry(async () => {\n+      const childrenText = await browser.elementById('children').text()\n+      expect(childrenText).toContain('New item for group 123')\n+    })\n+  })\n+\n+  it('should intercept from deeply nested route (4 segments) with (.) modifier', async () => {\n+    // This test covers deeply nested routes with multiple dynamic segments\n+    // Source: /org/acme/team/engineering (4 segments, 2 dynamic)\n+    // Target: /org/acme/team/engineering/settings (5 segments)\n+    //\n+    // This ensures the regex fix (.+) handles very deep nesting correctly\n+    const browser = await next.browser('/org/acme/team/engineering')\n+\n+    // Verify we're on the team page\n+    await retry(async () => {\n+      const text = await browser.elementByCss('body').text()\n+      expect(text).toContain('Team engineering in Org acme')\n+      expect(text).toContain('Settings')\n+    })\n+\n+    // Navigate from /org/acme/team/engineering to /org/acme/team/engineering/settings\n+    // This should trigger the modal interception\n+    await browser.elementById('settings-link').click()\n+\n+    await retry(async () => {\n+      const modalText = await browser.elementById('modal').text()\n+      expect(modalText).toContain(\n+        'Modal: Settings for Team engineering in Org acme'\n+      )\n+    })\n+\n+    // The children should still show the team page\n+    await retry(async () => {\n+      const childrenText = await browser.elementById('children').text()\n+      expect(childrenText).toContain('Team engineering in Org acme')\n+    })\n+\n+    // Refresh to verify the full page renders (not intercepted)\n+    await browser.refresh()\n+    await retry(async () => {\n+      const childrenText = await browser.elementById('children').text()\n+      expect(childrenText).toContain(\n+        'Settings for Team engineering in Org acme'\n+      )\n+    })\n+  })\n+\n+  it('should intercept with programmatic navigation using router.push', async () => {\n+    // Test that interception works with programmatic navigation, not just Link clicks\n+    // This ensures the NEXT_URL header is set correctly in all navigation scenarios\n+    const browser = await next.browser('/groups/123')\n+\n+    // Verify we're on the group page\n+    await retry(async () => {\n+      const text = await browser.elementByCss('body').text()\n+      expect(text).toContain('Group 123')\n+    })\n+\n+    // Use router.push to navigate programmatically\n+    await browser.eval('window.next.router.push(\"/groups/123/new\")')\n+\n+    // Should trigger the modal interception\n+    await retry(async () => {\n+      const modalText = await browser.elementById('modal').text()\n+      expect(modalText).toContain('Modal: New item for group')\n+    })\n+\n+    // The children should still show the group page\n+    await retry(async () => {\n+      const childrenText = await browser.elementById('children').text()\n+      expect(childrenText).toContain('Group 123')\n+    })\n+  })\n+\n+  it('should intercept from nested route with query parameters', async () => {\n+    // Test that interception works when the source route has query parameters\n+    // The query params should not interfere with route matching\n+    const browser = await next.browser('/groups/123?tab=settings&view=grid')\n+\n+    // Verify we're on the group page with query params\n+    await retry(async () => {\n+      const text = await browser.elementByCss('body').text()\n+      expect(text).toContain('Group 123')\n+      expect(text).toContain('New Item')\n+    })\n+\n+    // Navigate to /groups/123/new (query params in source shouldn't affect interception)\n+    await browser.elementById('new-link').click()\n+\n+    await retry(async () => {\n+      const modalText = await browser.elementById('modal').text()\n+      expect(modalText).toContain('Modal: New item for group')\n+    })\n+\n+    // The children should still show the group page\n+    await retry(async () => {\n+      const childrenText = await browser.elementById('children').text()\n+      expect(childrenText).toContain('Group 123')\n+    })\n+  })\n+\n+  it('should intercept with consecutive dynamic segments', async () => {\n+    // Test that interception works with consecutive dynamic segments [a]/[b]/[c]\n+    // This is an edge case where there are no static segments between dynamics\n+    // Source: /x/y/z (3 consecutive dynamic segments)\n+    // Target: /x/y/z/item\n+    const browser = await next.browser('/x/y/z')\n+\n+    // Verify we're on the consecutive dynamic page\n+    await retry(async () => {\n+      const text = await browser.elementByCss('body').text()\n+      expect(text).toContain('Path: x/y/z')\n+      expect(text).toContain('View Item')\n+    })\n+\n+    // Navigate to /x/y/z/item\n+    await browser.elementById('item-link').click()\n+\n+    await retry(async () => {\n+      const modalText = await browser.elementById('modal').text()\n+      expect(modalText).toContain('Modal: Item for path x/y/z')\n+    })\n+\n+    // The children should still show the consecutive page\n+    await retry(async () => {\n+      const childrenText = await browser.elementById('children').text()\n+      expect(childrenText).toContain('Path: x/y/z')\n+    })\n+\n+    // Refresh to verify the full page renders (not intercepted)\n+    await browser.refresh()\n+    await retry(async () => {\n+      const childrenText = await browser.elementById('children').text()\n+      expect(childrenText).toContain('Item for path: x/y/z')\n+    })\n+  })\n+\n+  it('should intercept with purely static multi-segment paths', async () => {\n+    // Test that interception works with static (non-dynamic) multi-segment paths\n+    // This ensures the fix doesn't break static route interception\n+    // Source: /admin/dashboard/users (3 static segments)\n+    // Target: /admin/dashboard/users/new (4 static segments)\n+    const browser = await next.browser('/admin/dashboard/users')\n+\n+    // Verify we're on the users page\n+    await retry(async () => {\n+      const text = await browser.elementByCss('body').text()\n+      expect(text).toContain('Admin Dashboard - Users')\n+      expect(text).toContain('New User')\n+    })\n+\n+    // Navigate to /admin/dashboard/users/new\n+    await browser.elementById('new-user-link').click()\n+\n+    await retry(async () => {\n+      const modalText = await browser.elementById('modal').text()\n+      expect(modalText).toContain('Modal: New User Form')\n+    })\n+\n+    // The children should still show the users page\n+    await retry(async () => {\n+      const childrenText = await browser.elementById('children').text()\n+      expect(childrenText).toContain('Admin Dashboard - Users')\n+    })\n+\n+    // Refresh to verify the full page renders (not intercepted)\n+    await browser.refresh()\n+    await retry(async () => {\n+      const childrenText = await browser.elementById('children').text()\n+      expect(childrenText).toContain('New User Form')\n+    })\n+  })\n+\n+  describe('nested navigation - descendants of intercepting route', () => {\n+    // These tests verify the key bug fix: the regex pattern now matches\n+    // all descendants of the intercepting route level, not just the exact level.\n+    // Previously, navigation FROM a nested route (e.g., /groups/123/nested) would\n+    // fail to trigger interception. Now it should work from any depth.\n+    // NOTE: These are conceptual tests - actual nested pages would need to be created\n+    // in the app directory structure to fully test this behavior in a real app.\n+\n+    it('should intercept when navigating from a child route using back navigation', async () => {\n+      // Start at /groups/123, navigate to /groups/123/new (intercepted),\n+      // then navigate away and back\n+      const browser = await next.browser('/groups/123')\n+\n+      await retry(async () => {\n+        const text = await browser.elementByCss('body').text()\n+        expect(text).toContain('Group 123')\n+      })\n+\n+      // First navigation - should intercept\n+      await browser.elementById('new-link').click()\n+      await retry(async () => {\n+        const modalText = await browser.elementById('modal').text()\n+        expect(modalText).toContain('Modal: New item for group')\n+      })\n+\n+      // Navigate back\n+      await browser.back()\n+      await retry(async () => {\n+        const text = await browser.elementByCss('body').text()\n+        expect(text).toContain('Group 123')\n+      })\n+\n+      // Navigate forward again - should still intercept\n+      await browser.forward()\n+      await retry(async () => {\n+        const modalText = await browser.elementById('modal').text()\n+        expect(modalText).toContain('Modal: New item for group')\n+      })\n+    })\n+\n+    it('should intercept multiple times from the same route', async () => {\n+      // Test that interception works consistently on repeated navigation\n+      const browser = await next.browser('/groups/456')\n+\n+      for (let i = 0; i < 3; i++) {\n+        await browser.elementById('new-link').click()\n+        await retry(async () => {\n+          const modalText = await browser.elementById('modal').text()\n+          expect(modalText).toContain('Modal: New item for group 456')\n+        })\n+\n+        // Go back to test again\n+        await browser.back()\n+        await retry(async () => {\n+          const text = await browser.elementByCss('body').text()\n+          expect(text).toContain('Group 456')\n+        })\n+      }\n+    })\n+\n+    it('should intercept when navigating between different dynamic segments', async () => {\n+      // Test interception works across different dynamic route values\n+      // First group\n+      const browser1 = await next.browser('/groups/100')\n+\n+      await browser1.elementById('new-link').click()\n+      await retry(async () => {\n+        const modalText = await browser1.elementById('modal').text()\n+        expect(modalText).toContain('Modal: New item for group 100')\n+      })\n+\n+      // Second group - new browser instance to test fresh navigation\n+      const browser2 = await next.browser('/groups/200')\n+      await retry(async () => {\n+        const text = await browser2.elementByCss('body').text()\n+        expect(text).toContain('Group 200')\n+      })\n+\n+      // Intercept from second group - should still work\n+      await browser2.elementById('new-link').click()\n+      await retry(async () => {\n+        const modalText = await browser2.elementById('modal').text()\n+        expect(modalText).toContain('Modal: New item for group 200')\n+      })\n+    })\n+  })\n+})"
        },
        {
            "sha": "807126e4cf0bf5b1c8c917e6e0148a27331587d1",
            "filename": "test/e2e/app-dir/interception-dynamic-single-segment/next.config.js",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-dynamic-single-segment%2Fnext.config.js?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -0,0 +1,6 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "d1f9667005a8346f6b51ee574fd22bc5eb85d720",
            "filename": "test/e2e/app-dir/interception-segments-two-levels-above/interception-segments-two-levels-above.test.ts",
            "status": "modified",
            "additions": 60,
            "deletions": 2,
            "changes": 62,
            "blob_url": "https://github.com/vercel/next.js/blob/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-segments-two-levels-above%2Finterception-segments-two-levels-above.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/dc61d29e49ab328e9b36d3993f02b2762bc69f6c/test%2Fe2e%2Fapp-dir%2Finterception-segments-two-levels-above%2Finterception-segments-two-levels-above.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finterception-segments-two-levels-above%2Finterception-segments-two-levels-above.test.ts?ref=dc61d29e49ab328e9b36d3993f02b2762bc69f6c",
            "patch": "@@ -1,5 +1,5 @@\n import { nextTestSetup } from 'e2e-utils'\n-import { check } from 'next-test-utils'\n+import { retry } from 'next-test-utils'\n \n describe('interception-segments-two-levels-above', () => {\n   const { next } = nextTestSetup({\n@@ -10,6 +10,64 @@ describe('interception-segments-two-levels-above', () => {\n     const browser = await next.browser('/foo/bar')\n \n     await browser.elementByCss('[href=\"/hoge\"]').click()\n-    await check(() => browser.elementById('intercepted').text(), /intercepted/)\n+    await retry(async () => {\n+      expect(await browser.elementById('intercepted').text()).toMatch(\n+        /intercepted/\n+      )\n+    })\n+  })\n+\n+  it('should intercept consistently with back/forward navigation', async () => {\n+    // Test that interception works correctly with browser back/forward\n+    const browser = await next.browser('/foo/bar')\n+\n+    // Navigate with interception\n+    await browser.elementByCss('[href=\"/hoge\"]').click()\n+    await retry(async () => {\n+      expect(await browser.elementById('intercepted').text()).toMatch(\n+        /intercepted/\n+      )\n+    })\n+\n+    // Go back\n+    await browser.back()\n+    await retry(async () => {\n+      const url = await browser.url()\n+      expect(url).toContain('/foo/bar')\n+    })\n+\n+    // Go forward - should show the intercepted version again\n+    await browser.forward()\n+    await retry(async () => {\n+      expect(await browser.elementById('intercepted').text()).toMatch(\n+        /intercepted/\n+      )\n+    })\n+  })\n+\n+  it('should intercept multiple times from same route', async () => {\n+    // Test that repeated interception works\n+    const browser = await next.browser('/foo/bar')\n+\n+    for (let i = 0; i < 2; i++) {\n+      await retry(async () => {\n+        await browser.elementByCss('[href=\"/hoge\"]').click()\n+      })\n+\n+      await retry(async () => {\n+        expect(await browser.elementById('intercepted').text()).toMatch(\n+          /intercepted/\n+        )\n+      })\n+\n+      await browser.back()\n+\n+      await retry(async () => {\n+        const url = await browser.url()\n+        expect(url).toContain('/foo/bar')\n+\n+        await browser.elementByCss('[href=\"/hoge\"]')\n+      })\n+    }\n   })\n })"
        }
    ],
    "stats": {
        "total": 2003,
        "additions": 1575,
        "deletions": 428
    }
}