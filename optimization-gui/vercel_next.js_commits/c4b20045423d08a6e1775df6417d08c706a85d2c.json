{
    "author": "SukkaW",
    "message": "[Segment Cache] Detect third-party redirect + static export w/ HEAD request (#85910)\n\nThe PR superseds #85903.\n\n#81247 was introduced to:\n\n- Some CDN/server configuration that performs extra redirections (e.g.,\nNetlify's `_redirects`, Cloudflare Pages w/ `_redirects`/Page Rules,\nnginx conf on the origin server), we want Next.js can still be able to\nfetch the RSC payload after redirections.\n- But there are also cases where the target is not our Next.js app, for\nwhich we should not fetch the RSC payload. Thus, a build id check is\nimplemented to ensure the target is our Next.js app. This is done via a\nrange request to check the first 64 bytes of the HTML response, looking\nfor the injected build id.\n\nHowever, as mentioned in #85903, some popular static hosting providers\n(like Cloudflare Pages and `Render.com`) don't support range requests,\nand in the worst case, the entire HTML will be returned (which is\nwasteful).\n\n#85903 was an attempt to combat the waste, but it is not ideal:\n\n- The client might not save much bandwidth: with a somewhat good\nInternet connection, the extra HTML can still be returned in one chunk,\nand in the worst case, the entire HTML is still returned.\n- This doesn't ease the server loads\n\nThis PR changes the approach:\n\n- We now use the `HEAD` request to detect third-party redirections,\nwhich should ease the server loads\n- We add a check for `1xx`/`4xx`/`5xx` response (can be a WAF returning\n403 or a backend server returning 502), where we still bail out\n- We no longer enforce the \"redirection target belongs to our Next.js\napp\" check. We might be storming prefetch requests toward non-Next.js\napps. In the future, we might add an option to disable preflight\nprefetch to combat that.\n\nCo-authored-by: Niklas Mischkulnig <4586894+mischnic@users.noreply.github.com>\nCo-authored-by: Janka Uryga <lolzatu2@gmail.com>",
    "sha": "c4b20045423d08a6e1775df6417d08c706a85d2c",
    "files": [
        {
            "sha": "81e183d000f4e9e7a7715d12eb39501b03b7a9f1",
            "filename": "packages/next/src/client/components/segment-cache/cache.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 18,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/c4b20045423d08a6e1775df6417d08c706a85d2c/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c4b20045423d08a6e1775df6417d08c706a85d2c/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts?ref=c4b20045423d08a6e1775df6417d08c706a85d2c",
            "patch": "@@ -87,10 +87,6 @@ import {\n import { STATIC_STALETIME_MS } from '../router-reducer/reducers/navigate-reducer'\n import { pingVisibleLinks } from '../links'\n import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n-import {\n-  DOC_PREFETCH_RANGE_HEADER_VALUE,\n-  doesExportedHtmlMatchBuildId,\n-} from '../../../shared/lib/segment-cache/output-export-prefetch-encoding'\n import { FetchStrategy } from './types'\n import { createPromiseWithResolvers } from '../../../shared/lib/promise-with-resolvers'\n \n@@ -1337,30 +1333,40 @@ export async function fetchRouteOnCacheMiss(\n       // location, but we shouldn't assume or expect that they also redirect all\n       // the segment files, too.\n       //\n-      // To check whether the page is redirected, we perform a range request of\n-      // the first N bytes of the HTML document. The canonical URL is determined\n-      // from the response.\n+      // To check whether the page is redirected, previously we perform a range\n+      // request of 64 bytes of the HTML document to check if the target page\n+      // is part of this app (by checking if build id matches). Only if the target\n+      // page is part of this app do we determine the final canonical URL.\n+      //\n+      // However, as mentioned in https://github.com/vercel/next.js/pull/85903,\n+      // some popular static hosting providers (like Cloudflare Pages or Render.com)\n+      // do not support range requests, in the worst case, the entire HTML instead\n+      // of 64 bytes could be returned, which is wasteful.\n       //\n-      // Then we can use the canonical URL to request the route tree.\n+      // So instead, we drops the check for build id here, and simply perform\n+      // a HEAD request to rejects 1xx/4xx/5xx responses, and then determine the\n+      // final URL after redirects.\n       //\n       // NOTE: We could embed the route tree into the HTML document, to avoid\n       // a second request. We're not doing that currently because it would make\n       // the HTML document larger and affect normal page loads.\n-      const htmlResponse = await fetch(url, {\n-        headers: {\n-          Range: DOC_PREFETCH_RANGE_HEADER_VALUE,\n-        },\n+      const headResponse = await fetch(url, {\n+        method: 'HEAD',\n       })\n-      const partialHtml = await htmlResponse.text()\n-      if (!doesExportedHtmlMatchBuildId(partialHtml, getAppBuildId())) {\n-        // The target page is not part of this app, or it belongs to a\n-        // different build.\n+      if (headResponse.status < 200 || headResponse.status >= 400) {\n+        // The target page responded w/o a successful status code\n+        // Could be a WAF serving a 403, or a 5xx from a backend\n+        //\n+        // Note that we can't use headResponse.ok here, because\n+        // Response#ok returns `false` with 3xx responses.\n         rejectRouteCacheEntry(entry, Date.now() + 10 * 1000)\n         return null\n       }\n-      urlAfterRedirects = htmlResponse.redirected\n-        ? new URL(htmlResponse.url)\n+\n+      urlAfterRedirects = headResponse.redirected\n+        ? new URL(headResponse.url)\n         : url\n+\n       response = await fetchPrefetchResponse(\n         addSegmentPathToUrlInOutputExportMode(urlAfterRedirects, segmentPath),\n         headers"
        },
        {
            "sha": "e0389a602ce5cf8a74d287a6fe166e8bc1e99c99",
            "filename": "packages/next/src/shared/lib/segment-cache/output-export-prefetch-encoding.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/c4b20045423d08a6e1775df6417d08c706a85d2c/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment-cache%2Foutput-export-prefetch-encoding.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c4b20045423d08a6e1775df6417d08c706a85d2c/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment-cache%2Foutput-export-prefetch-encoding.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment-cache%2Foutput-export-prefetch-encoding.ts?ref=c4b20045423d08a6e1775df6417d08c706a85d2c",
            "patch": "@@ -16,9 +16,6 @@\n const DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes\n const MAX_BUILD_ID_LENGTH = 24\n \n-// Request the first 64 bytes. The Range header is inclusive of the end value.\n-export const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63'\n-\n function escapeBuildId(buildId: string) {\n   // If the build id is longer than the given limit, it's OK for our purposes\n   // to only match the beginning.\n@@ -49,13 +46,3 @@ export function insertBuildIdComment(originalHtml: string, buildId: string) {\n     DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n   )\n }\n-\n-export function doesExportedHtmlMatchBuildId(\n-  partialHtmlDocument: string,\n-  buildId: string\n-) {\n-  // Check whether the document starts with the expected buildId.\n-  return partialHtmlDocument.startsWith(\n-    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n-  )\n-}"
        }
    ],
    "stats": {
        "total": 55,
        "additions": 24,
        "deletions": 31
    }
}