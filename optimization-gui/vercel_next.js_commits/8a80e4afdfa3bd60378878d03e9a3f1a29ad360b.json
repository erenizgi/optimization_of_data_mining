{
    "author": "mischnic",
    "message": "Turbopack: filter NftJsonAsset entries earlier (#81446)\n\nImproves invalidation (and performance)\r\n\r\n1. filter out client asset while discovering client assets, so this filters out the whole subgraph already\r\n2. apply the user-defined excludes while discovering the assets, this is also what the JS implementation does:\r\nhttps://github.com/vercel/next.js/blob/b77eb3e127986b47cab9eced2253f00de12a5a14/packages/next/src/build/collect-build-traces.ts#L336-L343\r\n\r\nCloses PACK-5037",
    "sha": "8a80e4afdfa3bd60378878d03e9a3f1a29ad360b",
    "files": [
        {
            "sha": "655bc3653a7d1c7d30b34507579002bd13eba009",
            "filename": "crates/next-api/src/nft_json.rs",
            "status": "modified",
            "additions": 75,
            "deletions": 28,
            "changes": 103,
            "blob_url": "https://github.com/vercel/next.js/blob/8a80e4afdfa3bd60378878d03e9a3f1a29ad360b/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8a80e4afdfa3bd60378878d03e9a3f1a29ad360b/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fnft_json.rs?ref=8a80e4afdfa3bd60378878d03e9a3f1a29ad360b",
            "patch": "@@ -3,12 +3,14 @@ use std::collections::{BTreeSet, VecDeque};\n use anyhow::{Result, bail};\n use serde_json::json;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks::{\n+    ReadRef, ResolvedVc, TryFlatJoinIterExt, Vc,\n+    graph::{AdjacencyMap, GraphTraversal},\n+};\n use turbo_tasks_fs::{DirectoryEntry, File, FileSystem, FileSystemPath, glob::Glob};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n-    output::OutputAsset,\n-    reference::all_assets_from_entries,\n+    output::{OutputAsset, OutputAssets},\n };\n \n use crate::project::Project;\n@@ -19,7 +21,7 @@ use crate::project::Project;\n ///\n /// With this file, users can determine the minimum set of files that are needed alongside\n /// their bundle.\n-#[turbo_tasks::value(shared)]\n+#[turbo_tasks::value]\n pub struct NftJsonAsset {\n     project: ResolvedVc<Project>,\n     /// The chunk for which the asset is being generated\n@@ -75,7 +77,6 @@ fn get_output_specifier(\n     ident_folder_in_project_fs: &FileSystemPath,\n     output_root: &FileSystemPath,\n     project_root: &FileSystemPath,\n-    client_root: &FileSystemPath,\n ) -> Result<Option<RcStr>> {\n     // include assets in the outputs such as referenced chunks\n     if path_ref.is_inside_ref(output_root) {\n@@ -91,13 +92,8 @@ fn get_output_specifier(\n         ));\n     }\n \n-    if path_ref.is_inside_ref(client_root) {\n-        // Client assets are never needed on the server, they are served via a CDN\n-        return Ok(None);\n-    }\n-\n-    // Make this an error for now, this should effectively be unreachable\n-    bail!(\"NftJsonAsset: cannot handle filepath {}\", path_ref);\n+    // This should effectively be unreachable\n+    bail!(\"NftJsonAsset: cannot handle filepath {path_ref}\");\n }\n \n /// Apply outputFileTracingIncludes patterns to find additional files\n@@ -146,18 +142,17 @@ impl Asset for NftJsonAsset {\n         let project_root_ref = this.project.project_fs().root().await?;\n         let next_config = this.project.next_config();\n \n-        // Parse outputFileTracingIncludes and outputFileTracingExcludes from config\n         let output_file_tracing_includes = &*next_config.output_file_tracing_includes().await?;\n         let output_file_tracing_excludes = &*next_config.output_file_tracing_excludes().await?;\n \n         let client_root = this.project.client_fs().root();\n-        let client_root_ref = client_root.await?;\n-        let project_root_path = this.project.project_root_path().await?.clone_value(); // Example: [project]\n+        let client_root = client_root.owned().await?;\n \n-        // Example: [output]/apps/my-website/.next/server/app -- without the `.nft.json`\n+        // [project]/\n+        let project_root_path = this.project.project_root_path().owned().await?;\n+        // Example: [output]/apps/my-website/.next/server/app -- without the `page.js.nft.json`\n         let ident_folder = self.path().await?.parent();\n-        // Example: [project]/apps/my-website/.next/server/app -- without the `.nft.json`\n-        // apps/my-website/.next/server/app\n+        // Example: [project]/apps/my-website/.next/server/app -- without the `page.js.nft.json`\n         let ident_folder_in_project_fs = project_root_path.join(&ident_folder.path)?;\n \n         let chunk = this.chunk;\n@@ -200,8 +195,7 @@ impl Asset for NftJsonAsset {\n                             .join(\",\")\n                     )\n                     .into(),\n-                )\n-                .await?;\n+                );\n \n                 Some(glob)\n             } else {\n@@ -212,7 +206,9 @@ impl Asset for NftJsonAsset {\n         };\n \n         // Collect base assets first\n-        for referenced_chunk in all_assets_from_entries(Vc::cell(entries)).await? {\n+        for referenced_chunk in\n+            all_assets_from_entries_filtered(Vc::cell(entries), client_root, exclude_glob).await?\n+        {\n             if chunk.eq(referenced_chunk) {\n                 continue;\n             }\n@@ -222,19 +218,12 @@ impl Asset for NftJsonAsset {\n                 continue;\n             }\n \n-            if let Some(ref exclude_glob) = exclude_glob\n-                && exclude_glob.matches(referenced_chunk_path.path.as_str())\n-            {\n-                continue;\n-            }\n-\n             let Some(specifier) = get_output_specifier(\n                 &referenced_chunk_path,\n                 &ident_folder,\n                 &ident_folder_in_project_fs,\n                 &output_root_ref,\n                 &project_root_ref,\n-                &client_root_ref,\n             )?\n             else {\n                 continue;\n@@ -294,3 +283,61 @@ impl Asset for NftJsonAsset {\n         Ok(AssetContent::file(File::from(json.to_string()).into()))\n     }\n }\n+\n+/// Walks the asset graph from multiple assets and collect all referenced\n+/// assets, but filters out all client assets and glob matches.\n+#[turbo_tasks::function]\n+async fn all_assets_from_entries_filtered(\n+    entries: Vc<OutputAssets>,\n+    client_root: FileSystemPath,\n+    exclude_glob: Option<Vc<Glob>>,\n+) -> Result<Vc<OutputAssets>> {\n+    let exclude_glob = if let Some(exclude_glob) = exclude_glob {\n+        Some(exclude_glob.await?)\n+    } else {\n+        None\n+    };\n+    Ok(Vc::cell(\n+        AdjacencyMap::new()\n+            .skip_duplicates()\n+            .visit(\n+                entries.await?.iter().copied().map(ResolvedVc::upcast),\n+                |asset| get_referenced_server_assets(asset, &client_root, &exclude_glob),\n+            )\n+            .await\n+            .completed()?\n+            .into_inner()\n+            .into_postorder_topological()\n+            .collect(),\n+    ))\n+}\n+\n+/// Computes the list of all chunk children of a given chunk, but filters out all client assets and\n+/// glob matches.\n+async fn get_referenced_server_assets(\n+    asset: ResolvedVc<Box<dyn OutputAsset>>,\n+    client_root: &FileSystemPath,\n+    exclude_glob: &Option<ReadRef<Glob>>,\n+) -> Result<Vec<ResolvedVc<Box<dyn OutputAsset>>>> {\n+    asset\n+        .references()\n+        .await?\n+        .iter()\n+        .map(async |asset| {\n+            let asset_path = asset.path().await?;\n+            if asset_path.is_inside_ref(client_root) {\n+                return Ok(None);\n+            }\n+\n+            if exclude_glob\n+                .as_ref()\n+                .is_some_and(|g| g.matches(&asset_path.path))\n+            {\n+                return Ok(None);\n+            }\n+\n+            Ok(Some(*asset))\n+        })\n+        .try_flat_join()\n+        .await\n+}"
        }
    ],
    "stats": {
        "total": 103,
        "additions": 75,
        "deletions": 28
    }
}