{
    "author": "mischnic",
    "message": "Turbopack: less eager manifest generation (#83736)\n\nBefore:\r\n\r\n<img width=\"2560\" height=\"1224\" alt=\"Bildschirmfoto 2025-09-12 um 18 47 11\" src=\"https://github.com/user-attachments/assets/c40d2be6-f570-40b4-8a82-7b181f2de073\" />\r\n\r\n\r\nAfter:\r\n<img width=\"2560\" height=\"1323\" alt=\"Bildschirmfoto 2025-09-12 um 19 15 35\" src=\"https://github.com/user-attachments/assets/b58826c4-88f0-4efb-b70a-fd384785af21\" />\r\n\r\nNot that drastic of a difference, because this is still a problem:\r\n\r\n<img width=\"972\" height=\"826\" alt=\"Bildschirmfoto 2025-09-12 um 19 15 41\" src=\"https://github.com/user-attachments/assets/5bd63a13-27ba-468c-a0a4-e66639bc47a3\" />\r\n\r\n\r\nTechnically, when calling `::reference()`, there is no need to compute the path, but `ChunkData` does that on initialization.\r\n\r\n\r\n`NEXT_TURBOPACK_TRACING=turbo-tasks pnpm next build --turbo test/production/pages-dir/production/fixture`",
    "sha": "27515900b31bfad83c3ecc65ed2e5d020ec289a6",
    "files": [
        {
            "sha": "b625a1ebc3e14d26d0400de2ec2fbe344763c595",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 12,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/27515900b31bfad83c3ecc65ed2e5d020ec289a6/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/27515900b31bfad83c3ecc65ed2e5d020ec289a6/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=27515900b31bfad83c3ecc65ed2e5d020ec289a6",
            "patch": "@@ -1362,21 +1362,15 @@ impl AppEndpoint {\n             }\n \n             let build_manifest = BuildManifest {\n+                output_path: node_root.join(&format!(\n+                    \"server/app{manifest_path_prefix}/build-manifest.json\",\n+                ))?,\n+                client_relative_path: client_relative_path.clone(),\n+                pages: Default::default(),\n                 root_main_files: client_shared_chunks,\n                 polyfill_files: vec![polyfill_output_asset],\n-                ..Default::default()\n             };\n-            let build_manifest_output = build_manifest\n-                .build_output(\n-                    node_root.join(&format!(\n-                        \"server/app{manifest_path_prefix}/build-manifest.json\",\n-                    ))?,\n-                    client_relative_path.clone(),\n-                )\n-                .await?\n-                .to_resolved()\n-                .await?;\n-            server_assets.insert(build_manifest_output);\n+            server_assets.insert(ResolvedVc::upcast(build_manifest.resolved_cell()));\n         }\n \n         if runtime == NextRuntime::Edge {"
        },
        {
            "sha": "1f6217157d2dc39c3a61daa61560439153c62ac9",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 31,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/27515900b31bfad83c3ecc65ed2e5d020ec289a6/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/27515900b31bfad83c3ecc65ed2e5d020ec289a6/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=27515900b31bfad83c3ecc65ed2e5d020ec289a6",
            "patch": "@@ -12,8 +12,8 @@ use next_core::{\n     next_dynamic::NextDynamicTransition,\n     next_edge::route_regex::get_named_middleware_regex,\n     next_manifests::{\n-        BuildManifest, EdgeFunctionDefinition, MiddlewareMatcher, MiddlewaresManifestV2,\n-        PagesManifest, Regions,\n+        BuildManifest, ClientBuildManifest, EdgeFunctionDefinition, MiddlewareMatcher,\n+        MiddlewaresManifestV2, PagesManifest, Regions,\n     },\n     next_pages::create_page_ssr_entry_module,\n     next_server::{\n@@ -1235,51 +1235,50 @@ impl PageEndpoint {\n             fxindexmap![] // Empty pages when no user pages should be created\n         };\n \n+        let manifest_path_prefix = get_asset_prefix_from_pathname(&self.pathname);\n         let build_manifest = BuildManifest {\n+            output_path: node_root.join(&format!(\n+                \"server/pages{manifest_path_prefix}/build-manifest.json\",\n+            ))?,\n+            client_relative_path,\n             pages,\n-            ..Default::default()\n+            polyfill_files: Default::default(),\n+            root_main_files: Default::default(),\n         };\n-        let manifest_path_prefix = get_asset_prefix_from_pathname(&self.pathname);\n-        build_manifest\n-            .build_output(\n-                node_root.join(&format!(\n-                    \"server/pages{manifest_path_prefix}/build-manifest.json\",\n-                ))?,\n-                client_relative_path,\n-            )\n-            .await\n+        Ok(Vc::upcast(build_manifest.cell()))\n     }\n \n     #[turbo_tasks::function]\n     async fn client_build_manifest(\n-        self: Vc<Self>,\n+        &self,\n         page_loader: ResolvedVc<Box<dyn OutputAsset>>,\n     ) -> Result<Vc<Box<dyn OutputAsset>>> {\n-        let this = self.await?;\n-        let node_root = this.pages_project.project().node_root().await?;\n-        let client_relative_path = this.pages_project.project().client_relative_path().await?;\n+        let node_root = self.pages_project.project().node_root().await?;\n+        let client_relative_path = self\n+            .pages_project\n+            .project()\n+            .client_relative_path()\n+            .owned()\n+            .await?;\n \n         // Check if we should include pages in the manifest\n-        let pages_structure = this.pages_structure.await?;\n-        let client_build_manifest = if pages_structure.should_create_pages_entries {\n-            let page_loader_path = client_relative_path\n-                .get_relative_path_to(&*page_loader.path().await?)\n-                .context(\"failed to resolve client-relative path to page loader\")?;\n-            fxindexmap!(this.pathname.clone() => vec![page_loader_path])\n+        let pages_structure = self.pages_structure.await?;\n+        let pages = if pages_structure.should_create_pages_entries {\n+            fxindexmap!(self.pathname.clone() => page_loader)\n         } else {\n-            fxindexmap![] // Empty manifest when no user pages should be created\n+            fxindexmap![] // Empty pages when no user pages should be created\n         };\n \n-        let manifest_path_prefix = get_asset_prefix_from_pathname(&this.pathname);\n-        Ok(Vc::upcast(VirtualOutputAsset::new_with_references(\n-            node_root.join(&format!(\n+        let manifest_path_prefix = get_asset_prefix_from_pathname(&self.pathname);\n+        let client_build_manifest = ClientBuildManifest {\n+            output_path: node_root.join(&format!(\n                 \"server/pages{manifest_path_prefix}/client-build-manifest.json\",\n             ))?,\n-            AssetContent::file(\n-                File::from(serde_json::to_string_pretty(&client_build_manifest)?).into(),\n-            ),\n-            Vc::cell(vec![page_loader]),\n-        )))\n+            client_relative_path,\n+            pages,\n+        };\n+\n+        Ok(Vc::upcast(client_build_manifest.cell()))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "1c31e531647fc3d8bba711757130425d47bb2b35",
            "filename": "crates/next-core/src/next_manifests/mod.rs",
            "status": "modified",
            "additions": 116,
            "deletions": 81,
            "changes": 197,
            "blob_url": "https://github.com/vercel/next.js/blob/27515900b31bfad83c3ecc65ed2e5d020ec289a6/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/27515900b31bfad83c3ecc65ed2e5d020ec289a6/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fmod.rs?ref=27515900b31bfad83c3ecc65ed2e5d020ec289a6",
            "patch": "@@ -12,33 +12,56 @@ use turbo_tasks::{\n };\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n-    asset::AssetContent,\n+    asset::{Asset, AssetContent},\n     output::{OutputAsset, OutputAssets},\n-    virtual_output::VirtualOutputAsset,\n };\n \n-use crate::next_config::{CrossOriginConfig, Rewrites, RouteHas};\n+use crate::next_config::{CrossOriginConfig, RouteHas};\n \n #[derive(Serialize, Default, Debug)]\n pub struct PagesManifest {\n     #[serde(flatten)]\n     pub pages: FxIndexMap<RcStr, RcStr>,\n }\n \n-#[derive(Debug, Default)]\n+#[derive(Debug)]\n+#[turbo_tasks::value(shared)]\n pub struct BuildManifest {\n+    pub output_path: FileSystemPath,\n+    pub client_relative_path: FileSystemPath,\n+\n     pub polyfill_files: Vec<ResolvedVc<Box<dyn OutputAsset>>>,\n     pub root_main_files: Vec<ResolvedVc<Box<dyn OutputAsset>>>,\n     pub pages: FxIndexMap<RcStr, ResolvedVc<OutputAssets>>,\n }\n \n-impl BuildManifest {\n-    pub async fn build_output(\n-        self,\n-        output_path: FileSystemPath,\n-        client_relative_path: FileSystemPath,\n-    ) -> Result<Vc<Box<dyn OutputAsset>>> {\n-        let client_relative_path_ref = client_relative_path.clone();\n+#[turbo_tasks::value_impl]\n+impl OutputAsset for BuildManifest {\n+    #[turbo_tasks::function]\n+    async fn path(&self) -> Vc<FileSystemPath> {\n+        self.output_path.clone().cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn references(&self) -> Result<Vc<OutputAssets>> {\n+        let chunks: Vec<ReadRef<OutputAssets>> = self.pages.values().try_join().await?;\n+\n+        let references = chunks\n+            .into_iter()\n+            .flat_map(|c| c.into_iter().copied()) // once again, rustc struggles here\n+            .chain(self.root_main_files.iter().copied())\n+            .chain(self.polyfill_files.iter().copied())\n+            .collect();\n+\n+        Ok(Vc::cell(references))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Asset for BuildManifest {\n+    #[turbo_tasks::function]\n+    async fn content(&self) -> Result<Vc<AssetContent>> {\n+        let client_relative_path = &self.client_relative_path;\n \n         #[derive(Serialize, Default, Debug)]\n         #[serde(rename_all = \"camelCase\")]\n@@ -55,33 +78,23 @@ impl BuildManifest {\n         let pages: Vec<(RcStr, Vec<RcStr>)> = self\n             .pages\n             .iter()\n-            .map(|(k, chunks)| {\n-                let client_relative_path_ref = client_relative_path_ref.clone();\n-\n-                async move {\n-                    Ok((\n-                        k.clone(),\n-                        chunks\n-                            .await?\n-                            .iter()\n-                            .copied()\n-                            .map(|chunk| {\n-                                let client_relative_path_ref = client_relative_path_ref.clone();\n-                                async move {\n-                                    let chunk_path = chunk.path().await?;\n-                                    Ok(client_relative_path_ref\n-                                        .get_path_to(&chunk_path)\n-                                        .context(\n-                                            \"client chunk entry path must be inside the client \\\n-                                             root\",\n-                                        )?\n-                                        .into())\n-                                }\n-                            })\n-                            .try_join()\n-                            .await?,\n-                    ))\n-                }\n+            .map(|(k, chunks)| async move {\n+                Ok((\n+                    k.clone(),\n+                    chunks\n+                        .await?\n+                        .iter()\n+                        .copied()\n+                        .map(async |chunk| {\n+                            let chunk_path = chunk.path().await?;\n+                            Ok(client_relative_path\n+                                .get_path_to(&chunk_path)\n+                                .context(\"client chunk entry path must be inside the client root\")?\n+                                .into())\n+                        })\n+                        .try_join()\n+                        .await?,\n+                ))\n             })\n             .try_join()\n             .await?;\n@@ -90,16 +103,12 @@ impl BuildManifest {\n             .polyfill_files\n             .iter()\n             .copied()\n-            .map(|chunk| {\n-                let client_relative_path_ref = client_relative_path_ref.clone();\n-\n-                async move {\n-                    let chunk_path = chunk.path().await?;\n-                    Ok(client_relative_path_ref\n-                        .get_path_to(&chunk_path)\n-                        .context(\"failed to resolve client-relative path to polyfill\")?\n-                        .into())\n-                }\n+            .map(async |chunk| {\n+                let chunk_path = chunk.path().await?;\n+                Ok(client_relative_path\n+                    .get_path_to(&chunk_path)\n+                    .context(\"failed to resolve client-relative path to polyfill\")?\n+                    .into())\n             })\n             .try_join()\n             .await?;\n@@ -108,16 +117,12 @@ impl BuildManifest {\n             .root_main_files\n             .iter()\n             .copied()\n-            .map(|chunk| {\n-                let client_relative_path_ref = client_relative_path_ref.clone();\n-\n-                async move {\n-                    let chunk_path = chunk.path().await?;\n-                    Ok(client_relative_path_ref\n-                        .get_path_to(&chunk_path)\n-                        .context(\"failed to resolve client-relative path to root_main_file\")?\n-                        .into())\n-                }\n+            .map(async |chunk| {\n+                let chunk_path = chunk.path().await?;\n+                Ok(client_relative_path\n+                    .get_path_to(&chunk_path)\n+                    .context(\"failed to resolve client-relative path to root_main_file\")?\n+                    .into())\n             })\n             .try_join()\n             .await?;\n@@ -129,20 +134,63 @@ impl BuildManifest {\n             ..Default::default()\n         };\n \n-        let chunks: Vec<ReadRef<OutputAssets>> = self.pages.values().try_join().await?;\n+        Ok(AssetContent::file(\n+            File::from(serde_json::to_string_pretty(&manifest)?).into(),\n+        ))\n+    }\n+}\n \n-        let references = chunks\n+#[derive(Debug)]\n+#[turbo_tasks::value(shared)]\n+pub struct ClientBuildManifest {\n+    pub output_path: FileSystemPath,\n+    pub client_relative_path: FileSystemPath,\n+\n+    pub pages: FxIndexMap<RcStr, ResolvedVc<Box<dyn OutputAsset>>>,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl OutputAsset for ClientBuildManifest {\n+    #[turbo_tasks::function]\n+    async fn path(&self) -> Vc<FileSystemPath> {\n+        self.output_path.clone().cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn references(&self) -> Result<Vc<OutputAssets>> {\n+        let chunks: Vec<ResolvedVc<Box<dyn OutputAsset>>> = self.pages.values().copied().collect();\n+        Ok(Vc::cell(chunks))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Asset for ClientBuildManifest {\n+    #[turbo_tasks::function]\n+    async fn content(&self) -> Result<Vc<AssetContent>> {\n+        let client_relative_path = &self.client_relative_path;\n+\n+        let manifest: FxIndexMap<RcStr, Vec<RcStr>> = self\n+            .pages\n+            .iter()\n+            .map(async |(k, chunk)| {\n+                Ok((\n+                    k.clone(),\n+                    vec![\n+                        client_relative_path\n+                            .get_path_to(&*chunk.path().await?)\n+                            .context(\"client chunk entry path must be inside the client root\")?\n+                            .into(),\n+                    ],\n+                ))\n+            })\n+            .try_join()\n+            .await?\n             .into_iter()\n-            .flat_map(|c| c.into_iter().copied()) // once again, rustc struggles here\n-            .chain(self.root_main_files.iter().copied())\n-            .chain(self.polyfill_files.iter().copied())\n             .collect();\n \n-        Ok(Vc::upcast(VirtualOutputAsset::new_with_references(\n-            output_path,\n-            AssetContent::file(File::from(serde_json::to_string_pretty(&manifest)?).into()),\n-            Vc::cell(references),\n-        )))\n+        Ok(AssetContent::file(\n+            File::from(serde_json::to_string_pretty(&manifest)?).into(),\n+        ))\n     }\n }\n \n@@ -439,19 +487,6 @@ pub struct FontManifestEntry {\n     pub content: RcStr,\n }\n \n-// TODO(alexkirsz) Unify with the one for dev.\n-#[derive(Serialize, Debug)]\n-#[serde(rename_all = \"camelCase\")]\n-pub struct ClientBuildManifest<'a> {\n-    #[serde(rename = \"__rewrites\")]\n-    pub rewrites: &'a Rewrites,\n-\n-    pub sorted_pages: &'a [RcStr],\n-\n-    #[serde(flatten)]\n-    pub pages: FxIndexMap<RcStr, Vec<&'a str>>,\n-}\n-\n #[cfg(test)]\n mod tests {\n     use turbo_rcstr::rcstr;"
        }
    ],
    "stats": {
        "total": 276,
        "additions": 152,
        "deletions": 124
    }
}