{
    "author": "wyattjoh",
    "message": "docs: added `use cache: remote` docs (#85145)",
    "sha": "27a3fa71b6f4e53ae7b8944352c2e1a26e8dc602",
    "files": [
        {
            "sha": "eb758ad2fb2ddca00c74c85d5ac218ff889eec79",
            "filename": "docs/01-app/03-api-reference/01-directives/use-cache-remote.mdx",
            "status": "added",
            "additions": 560,
            "deletions": 0,
            "changes": 560,
            "blob_url": "https://github.com/vercel/next.js/blob/27a3fa71b6f4e53ae7b8944352c2e1a26e8dc602/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache-remote.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/27a3fa71b6f4e53ae7b8944352c2e1a26e8dc602/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache-remote.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache-remote.mdx?ref=27a3fa71b6f4e53ae7b8944352c2e1a26e8dc602",
            "patch": "@@ -0,0 +1,560 @@\n+---\n+title: 'use cache: remote'\n+description: 'Learn how to use the `\"use cache: remote\"` directive to enable caching in dynamic contexts in your Next.js application.'\n+version: canary\n+related:\n+  title: Related\n+  description: View related API references.\n+  links:\n+    - app/api-reference/directives/use-cache\n+    - app/api-reference/directives/use-cache-private\n+    - app/api-reference/config/next-config-js/cacheComponents\n+    - app/api-reference/functions/cacheLife\n+    - app/api-reference/functions/cacheTag\n+    - app/api-reference/functions/connection\n+---\n+\n+The `'use cache: remote'` directive enables caching of **shared data** in dynamic contexts where regular [`use cache`](/docs/app/api-reference/directives/use-cache) would not work, for example after calling [`await connection()`](/docs/app/api-reference/functions/connection), [`await cookies()`](/docs/app/api-reference/functions/cookies) or [`await headers()`](/docs/app/api-reference/functions/headers).\n+\n+> **Good to know:**\n+>\n+> - Results are stored in server-side cache handlers and shared across all users.\n+> - For **user-specific data** that depends on [`await cookies()`](/docs/app/api-reference/functions/cookies) or [`await headers()`](/docs/app/api-reference/functions/headers), use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead.\n+\n+## Usage\n+\n+To use `'use cache: remote'`, enable the [`cacheComponents`](/docs/app/api-reference/config/next-config-js/cacheComponents) flag in your `next.config.ts` file:\n+\n+```ts filename=\"next.config.ts\" switcher\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  cacheComponents: true,\n+}\n+\n+export default nextConfig\n+```\n+\n+```js filename=\"next.config.js\" switcher\n+/** @type {import('next').NextConfig} */\n+const nextConfig = {\n+  cacheComponents: true,\n+}\n+\n+export default nextConfig\n+```\n+\n+Then add `'use cache: remote'` to your function that needs to cache data in a dynamic context.\n+\n+### Basic example\n+\n+Cache product pricing that needs to be fetched at request time but can be shared across all users. Use [`cacheLife`](/docs/app/api-reference/functions/cacheLife#custom-cache-profiles) to set the cache lifetime of the price.\n+\n+```tsx filename=\"app/product/[id]/page.tsx\" switcher\n+import { Suspense } from 'react'\n+import { connection } from 'next/server'\n+import { cacheTag, cacheLife } from 'next/cache'\n+\n+export default async function ProductPage({\n+  params,\n+}: {\n+  params: Promise<{ id: string }>\n+}) {\n+  const { id } = await params\n+\n+  return (\n+    <div>\n+      <ProductDetails id={id} />\n+      <Suspense fallback={<div>Loading price...</div>}>\n+        <ProductPrice productId={id} />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+function ProductDetails({ id }: { id: string }) {\n+  return <div>Product: {id}</div>\n+}\n+\n+async function ProductPrice({ productId }: { productId: string }) {\n+  // Calling connection() makes this component dynamic, preventing\n+  // it from being included in the static shell. This ensures the price\n+  // is always fetched at request time.\n+  await connection()\n+\n+  // Now we can cache the price in a remote cache handler.\n+  // Regular 'use cache' would NOT work here because we're in a dynamic context.\n+  const price = await getProductPrice(productId)\n+\n+  return <div>Price: ${price}</div>\n+}\n+\n+async function getProductPrice(productId: string) {\n+  'use cache: remote'\n+  cacheTag(`product-price-${productId}`)\n+  cacheLife({ expire: 3600 }) // 1 hour\n+\n+  // This database query is cached and shared across all users\n+  return db.products.getPrice(productId)\n+}\n+```\n+\n+```jsx filename=\"app/product/[id]/page.js\" switcher\n+import { Suspense } from 'react'\n+import { connection } from 'next/server'\n+import { cacheTag, cacheLife } from 'next/cache'\n+\n+export default async function ProductPage({ params }) {\n+  const { id } = await params\n+\n+  return (\n+    <div>\n+      <ProductDetails id={id} />\n+      <Suspense fallback={<div>Loading price...</div>}>\n+        <ProductPrice productId={id} />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+function ProductDetails({ id }) {\n+  return <div>Product: {id}</div>\n+}\n+\n+async function ProductPrice({ productId }) {\n+  // Calling connection() makes this component dynamic, preventing\n+  // it from being included in the static shell. This ensures the price\n+  // is always fetched at request time.\n+  await connection()\n+\n+  // Now we can cache the price in a remote cache handler.\n+  // Regular 'use cache' would NOT work here because we're in a dynamic context.\n+  const price = await getProductPrice(productId)\n+\n+  return <div>Price: ${price}</div>\n+}\n+\n+async function getProductPrice(productId) {\n+  'use cache: remote'\n+  cacheTag(`product-price-${productId}`)\n+  cacheLife({ expire: 3600 }) // 1 hour\n+\n+  // This database query is cached and shared across all users\n+  return db.products.getPrice(productId)\n+}\n+```\n+\n+> **Note:** Regular [`use cache`](/docs/app/api-reference/directives/use-cache) will not cache anything when used in a dynamic context (after [`await connection()`](/docs/app/api-reference/functions/connection), [`await cookies()`](/docs/app/api-reference/functions/cookies), [`await headers()`](/docs/app/api-reference/functions/headers), etc.). Use `'use cache: remote'` to enable runtime caching in these scenarios.\n+\n+## How `use cache: remote` differs from `use cache` and `use cache: private`\n+\n+Next.js provides three caching directives, each designed for different use cases:\n+\n+| Feature                          | `use cache`                         | `'use cache: remote'`                                     | `'use cache: private'`              |\n+| -------------------------------- | ----------------------------------- | --------------------------------------------------------- | ----------------------------------- |\n+| **Works in dynamic context**     | No (requires static context)        | Yes (designed for dynamic contexts)                       | Yes                                 |\n+| **Access to `await cookies()`**  | No                                  | No                                                        | Yes                                 |\n+| **Access to `await headers()`**  | No                                  | No                                                        | Yes                                 |\n+| **After `await connection()`**   | No (won't cache)                    | No                                                        | No                                  |\n+| **Stored in cache handler**      | Yes (server-side)                   | Yes (server-side)                                         | No (client-side only)               |\n+| **Cache scope**                  | Global (shared)                     | Global (shared)                                           | Per-user (isolated)                 |\n+| **Supports runtime prefetching** | N/A (pre-rendered at build)         | No                                                        | Yes (when configured)               |\n+| **Use case**                     | Static, shared content (build-time) | Dynamic, shared content in runtime contexts (per-request) | Personalized, user-specific content |\n+\n+> **Note:** While you can't call `await cookies()` or `await headers()` inside `'use cache: remote'`, you can read the values before calling a function that is wrapped by `'use cache: remote'` and the arguments will be included in the cache key. Note that this is not recommended as it will dramatically increase the cache size and reduce the cache hit rate.\n+\n+### When to use each directive\n+\n+Choose the right caching directive based on your use case:\n+\n+**Use [`use cache`](/docs/app/api-reference/directives/use-cache) when:**\n+\n+- Content can be prerendered at build time\n+- Content is shared across all users\n+- Content doesn't depend on request-specific data\n+\n+**Use `'use cache: remote'` when:**\n+\n+- You need caching within dynamic context\n+- Content is shared across users but must be rendered per-request (after `await connection()`)\n+- You want to cache expensive operations in a server-side cache handler\n+\n+**Use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) when:**\n+\n+- Content is personalized per-user (depends on cookies, headers)\n+- You need [runtime prefetching](/docs/app/guides/prefetching) of user-specific content\n+- Content should never be shared between users\n+\n+## How it works\n+\n+The `'use cache: remote'` directive enables runtime caching of shared data in dynamic contexts by storing results in server-side cache handlers rather than prerendering at build time.\n+\n+### Dynamic context detection\n+\n+When Next.js encounters certain APIs like [`connection()`](/docs/app/api-reference/functions/connection), [`cookies()`](/docs/app/api-reference/functions/cookies), or [`headers()`](/docs/app/api-reference/functions/headers), the context becomes \"dynamic\". In a dynamic context:\n+\n+1. **Regular `use cache` stops working** - it won't cache anything\n+2. **`'use cache: remote'` continues to work** - it is cached by a remote cache handler.\n+3. **Results are stored server-side** in a key-value store configured for your deployment\n+4. **Cached data is shared across requests** - reducing database load and origin requests\n+\n+> **Good to know:** Without `'use cache: remote'`, functions in dynamic contexts would execute on every request, potentially creating performance bottlenecks. Remote caching eliminates this issue by storing results in server-side cache handlers.\n+\n+### Storage behavior\n+\n+Remote caches are **persisted using server-side cache handlers**, which may include:\n+\n+- **Distributed key-value stores** (in-memory or persistent storage solutions)\n+- **File system or in-memory storage** (often used in development or for custom deployments)\n+- **Environment-specific caches** (provided by your hosting infrastructure)\n+- **Custom or configured cache handlers** (depending on your application's setup)\n+\n+This means:\n+\n+1. Cached data is shared across all users and requests\n+2. Cache entries persist beyond a single session\n+3. Cache invalidation works via [`cacheTag`](/docs/app/api-reference/functions/cacheTag) and [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)\n+4. Cache expiration is controlled by [`cacheLife`](/docs/app/api-reference/functions/cacheLife) configuration\n+\n+### Dynamic context example\n+\n+```tsx\n+async function UserDashboard() {\n+  // Calling connection() makes the context dynamic\n+  await connection()\n+\n+  // Without any caching directive, this runs on every request\n+  const stats = await getStats()\n+\n+  // With 'use cache: remote', this is cached in the remote handler\n+  const analytics = await getAnalytics()\n+\n+  return (\n+    <div>\n+      <Stats data={stats} />\n+      <Analytics data={analytics} />\n+    </div>\n+  )\n+}\n+\n+async function getAnalytics() {\n+  'use cache: remote'\n+  cacheLife({ expire: 300 }) // 5 minutes\n+\n+  // This expensive operation is cached and shared across all requests\n+  return fetchAnalyticsData()\n+}\n+```\n+\n+## Request APIs and remote caches\n+\n+While `'use cache: remote'` technically allows access to request-specific data by calling API's like [`cookies()`](/docs/app/api-reference/functions/cookies) and [`headers()`](/docs/app/api-reference/functions/headers) before calling a function that is wrapped by `'use cache: remote'`, it's generally not recommended to use them together:\n+\n+| API                                                                                   | Allowed in `use cache` | Allowed in `'use cache: remote'` | Recommended                                                                                |\n+| ------------------------------------------------------------------------------------- | ---------------------- | -------------------------------- | ------------------------------------------------------------------------------------------ |\n+| [`cookies()`](/docs/app/api-reference/functions/cookies)                              | No                     | No                               | Use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead |\n+| [`headers()`](/docs/app/api-reference/functions/headers)                              | No                     | No                               | Use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead |\n+| [`connection()`](/docs/app/api-reference/functions/connection)                        | No                     | No                               | No - these cannot ever be cached                                                           |\n+| [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) | No                     | No                               | Use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead |\n+\n+> **Important:** If you need to cache based on cookies, headers, or search params, use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead. Remote caches are shared across all users, so caching user-specific data in them can lead to incorrect results being served to different users.\n+\n+## Nesting rules\n+\n+Remote caches have specific nesting rules:\n+\n+- Remote caches **can** be nested inside other remote caches (`'use cache: remote'`)\n+- Remote caches **can** be nested inside regular caches (`'use cache'`)\n+- Remote caches **cannot** be nested inside private caches (`'use cache: private'`)\n+- Private caches **cannot** be nested inside remote caches\n+\n+```tsx\n+// VALID: Remote inside remote\n+async function outerRemote() {\n+  'use cache: remote'\n+  const result = await innerRemote()\n+  return result\n+}\n+\n+async function innerRemote() {\n+  'use cache: remote'\n+  return getData()\n+}\n+\n+// VALID: Remote inside regular cache\n+async function outerCache() {\n+  'use cache'\n+  // If this is in a dynamic context, the inner remote cache will work\n+  const result = await innerRemote()\n+  return result\n+}\n+\n+async function innerRemote() {\n+  'use cache: remote'\n+  return getData()\n+}\n+\n+// INVALID: Remote inside private\n+async function outerPrivate() {\n+  'use cache: private'\n+  const result = await innerRemote() // Error!\n+  return result\n+}\n+\n+async function innerRemote() {\n+  'use cache: remote'\n+  return getData()\n+}\n+\n+// INVALID: Private inside remote\n+async function outerRemote() {\n+  'use cache: remote'\n+  const result = await innerPrivate() // Error!\n+  return result\n+}\n+\n+async function innerPrivate() {\n+  'use cache: private'\n+  return getData()\n+}\n+```\n+\n+## Examples\n+\n+The following examples demonstrate common patterns for using `'use cache: remote'`. For details about `cacheLife` parameters (`stale`, `revalidate`, `expire`), see the [`cacheLife` API reference](/docs/app/api-reference/functions/cacheLife).\n+\n+### Per-request database queries\n+\n+Cache expensive database queries that are accessed in dynamic contexts, reducing load on your database:\n+\n+```tsx filename=\"app/dashboard/page.tsx\"\n+import { connection } from 'next/server'\n+import { cacheLife, cacheTag } from 'next/cache'\n+\n+export default async function DashboardPage() {\n+  // Make context dynamic\n+  await connection()\n+\n+  const stats = await getGlobalStats()\n+\n+  return <StatsDisplay stats={stats} />\n+}\n+\n+async function getGlobalStats() {\n+  'use cache: remote'\n+  cacheTag('global-stats')\n+  cacheLife({ expire: 60 }) // 1 minute\n+\n+  // This expensive database query is cached and shared across all users,\n+  // reducing load on your database\n+  const stats = await db.analytics.aggregate({\n+    total_users: 'count',\n+    active_sessions: 'count',\n+    revenue: 'sum',\n+  })\n+\n+  return stats\n+}\n+```\n+\n+### API responses in streaming contexts\n+\n+Cache API responses that are fetched during streaming or after dynamic operations:\n+\n+```tsx filename=\"app/feed/page.tsx\"\n+import { Suspense } from 'react'\n+import { connection } from 'next/server'\n+import { cacheLife, cacheTag } from 'next/cache'\n+\n+export default async function FeedPage() {\n+  return (\n+    <div>\n+      <Suspense fallback={<Skeleton />}>\n+        <FeedItems />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+async function FeedItems() {\n+  // Dynamic context\n+  await connection()\n+\n+  const items = await getFeedItems()\n+\n+  return items.map((item) => <FeedItem key={item.id} item={item} />)\n+}\n+\n+async function getFeedItems() {\n+  'use cache: remote'\n+  cacheTag('feed-items')\n+  cacheLife({ expire: 120 }) // 2 minutes\n+\n+  // This API call is cached, reducing requests to your external service\n+  const response = await fetch('https://api.example.com/feed')\n+  return response.json()\n+}\n+```\n+\n+### Computed data after dynamic checks\n+\n+Cache expensive computations that occur after dynamic security or feature checks:\n+\n+```tsx filename=\"app/reports/page.tsx\"\n+import { connection } from 'next/server'\n+import { cacheLife } from 'next/cache'\n+\n+export default async function ReportsPage() {\n+  // Dynamic security check\n+  await connection()\n+\n+  const report = await generateReport()\n+\n+  return <ReportViewer report={report} />\n+}\n+\n+async function generateReport() {\n+  'use cache: remote'\n+  cacheLife({ expire: 3600 }) // 1 hour\n+\n+  // This expensive computation is cached and shared across all authorized users,\n+  // avoiding repeated calculations\n+  const data = await db.transactions.findMany()\n+\n+  return {\n+    totalRevenue: calculateRevenue(data),\n+    topProducts: analyzeProducts(data),\n+    trends: calculateTrends(data),\n+  }\n+}\n+```\n+\n+### Mixed caching strategies\n+\n+Combine static, remote, and private caching for optimal performance:\n+\n+```tsx filename=\"app/product/[id]/page.tsx\"\n+import { Suspense } from 'react'\n+import { connection } from 'next/server'\n+import { cookies } from 'next/headers'\n+import { cacheLife, cacheTag } from 'next/cache'\n+\n+// Static product data - prerendered at build time\n+async function getProduct(id: string) {\n+  'use cache'\n+  cacheTag(`product-${id}`)\n+\n+  // This is cached at build time and shared across all users\n+  return db.products.find({ where: { id } })\n+}\n+\n+// Shared pricing data - cached at runtime in remote handler\n+async function getProductPrice(id: string) {\n+  'use cache: remote'\n+  cacheTag(`product-price-${id}`)\n+  cacheLife({ expire: 300 }) // 5 minutes\n+\n+  // This is cached at runtime and shared across all users\n+  return db.products.getPrice({ where: { id } })\n+}\n+\n+// User-specific recommendations - private cache per user\n+async function getRecommendations(productId: string) {\n+  'use cache: private'\n+  cacheLife({ expire: 60 }) // 1 minute\n+\n+  const sessionId = (await cookies()).get('session-id')?.value\n+\n+  // This is cached per-user and never shared\n+  return db.recommendations.findMany({\n+    where: { productId, sessionId },\n+  })\n+}\n+\n+export default async function ProductPage({ params }) {\n+  const { id } = await params\n+\n+  // Static product data\n+  const product = await getProduct(id)\n+\n+  return (\n+    <div>\n+      <ProductDetails product={product} />\n+\n+      {/* Dynamic shared price */}\n+      <Suspense fallback={<PriceSkeleton />}>\n+        <ProductPriceComponent productId={id} />\n+      </Suspense>\n+\n+      {/* Dynamic personalized recommendations */}\n+      <Suspense fallback={<RecommendationsSkeleton />}>\n+        <ProductRecommendations productId={id} />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+function ProductDetails({ product }) {\n+  return (\n+    <div>\n+      <h1>{product.name}</h1>\n+      <p>{product.description}</p>\n+    </div>\n+  )\n+}\n+\n+async function ProductPriceComponent({ productId }) {\n+  // Make this component dynamic\n+  await connection()\n+\n+  const price = await getProductPrice(productId)\n+  return <div>Price: ${price}</div>\n+}\n+\n+async function ProductRecommendations({ productId }) {\n+  const recommendations = await getRecommendations(productId)\n+  return <RecommendationsList items={recommendations} />\n+}\n+\n+function PriceSkeleton() {\n+  return <div>Loading price...</div>\n+}\n+\n+function RecommendationsSkeleton() {\n+  return <div>Loading recommendations...</div>\n+}\n+\n+function RecommendationsList({ items }) {\n+  return (\n+    <ul>\n+      {items.map((item) => (\n+        <li key={item.id}>{item.name}</li>\n+      ))}\n+    </ul>\n+  )\n+}\n+```\n+\n+> **Good to know**:\n+>\n+> - Remote caches are stored in server-side cache handlers and shared across all users\n+> - Remote caches work in dynamic contexts where regular [`use cache`](/docs/app/api-reference/directives/use-cache) would fail\n+> - Use [`cacheTag()`](/docs/app/api-reference/functions/cacheTag) and [`revalidateTag()`](/docs/app/api-reference/functions/revalidateTag) to invalidate remote caches on-demand\n+> - Use [`cacheLife()`](/docs/app/api-reference/functions/cacheLife) to configure cache expiration\n+> - For user-specific data, use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead of `'use cache: remote'`\n+> - Remote caches reduce origin load by storing computed or fetched data server-side\n+\n+## Platform Support\n+\n+| Deployment Option                                                   | Supported |\n+| ------------------------------------------------------------------- | --------- |\n+| [Node.js server](/docs/app/getting-started/deploying#nodejs-server) | Yes       |\n+| [Docker container](/docs/app/getting-started/deploying#docker)      | Yes       |\n+| [Static export](/docs/app/getting-started/deploying#static-export)  | No        |\n+| [Adapters](/docs/app/getting-started/deploying#adapters)            | Yes       |\n+\n+## Version History\n+\n+| Version   | Changes                                                      |\n+| --------- | ------------------------------------------------------------ |\n+| `v16.0.0` | `'use cache: remote'` introduced as an experimental feature. |"
        }
    ],
    "stats": {
        "total": 560,
        "additions": 560,
        "deletions": 0
    }
}