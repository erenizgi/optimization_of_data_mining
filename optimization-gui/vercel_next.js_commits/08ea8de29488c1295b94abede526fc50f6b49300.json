{
    "author": "ijjk",
    "message": "Migrate app route to handler interface (#80008)\n\nContinuation of https://github.com/vercel/next.js/pull/78166 this\nimplements the handler interface for app router route handlers. This\ndoes still return the cache entry for ISR route handlers for the\nincremental cache to handle but response handling is moved into the\nhandler here.\n\nValidated against deploy tests\nhttps://github.com/vercel/vercel/pull/13413 and\nhttps://github.com/vercel/next.js/actions/runs/15359464126/job/43224461919",
    "sha": "08ea8de29488c1295b94abede526fc50f6b49300",
    "files": [
        {
            "sha": "34bece8cb33108ecbbd8a164e04164da0d15f55d",
            "filename": "packages/next/src/build/templates/app-route.ts",
            "status": "modified",
            "additions": 314,
            "deletions": 0,
            "changes": 314,
            "blob_url": "https://github.com/vercel/next.js/blob/08ea8de29488c1295b94abede526fc50f6b49300/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-route.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/08ea8de29488c1295b94abede526fc50f6b49300/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-route.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-route.ts?ref=08ea8de29488c1295b94abede526fc50f6b49300",
            "patch": "@@ -1,11 +1,35 @@\n import {\n   AppRouteRouteModule,\n+  type AppRouteRouteHandlerContext,\n   type AppRouteRouteModuleOptions,\n } from '../../server/route-modules/app-route/module.compiled'\n import { RouteKind } from '../../server/route-kind'\n import { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\n \n import * as userland from 'VAR_USERLAND'\n+import {\n+  RouterServerContextSymbol,\n+  routerServerGlobal,\n+} from '../../server/lib/router-utils/router-server-context'\n+import type { IncomingMessage, ServerResponse } from 'node:http'\n+import { getRequestMeta } from '../../server/request-meta'\n+import { getTracer, type Span, SpanKind } from '../../server/lib/trace/tracer'\n+import type { ServerOnInstrumentationRequestError } from '../../server/app-render/types'\n+import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n+import { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\n+import {\n+  NextRequestAdapter,\n+  signalFromNodeResponse,\n+} from '../../server/web/spec-extension/adapters/next-request'\n+import { BaseServerSpan } from '../../server/lib/trace/constants'\n+import { getRevalidateReason } from '../../server/instrumentation/utils'\n+import { sendResponse } from '../../server/send-response'\n+import { toNodeOutgoingHttpHeaders } from '../../server/web/utils'\n+import { INFINITE_CACHE, NEXT_CACHE_TAGS_HEADER } from '../../lib/constants'\n+import {\n+  CachedRouteKind,\n+  type ResponseCacheEntry,\n+} from '../../server/response-cache'\n \n // These are injected by the loader afterwards. This is injected as a variable\n // instead of a replacement because this could also be `undefined` instead of\n@@ -50,3 +74,293 @@ export {\n   serverHooks,\n   patchFetch,\n }\n+\n+export async function handler(\n+  req: IncomingMessage,\n+  res: ServerResponse,\n+  ctx: {\n+    waitUntil: (prom: Promise<void>) => void\n+  }\n+) {\n+  let srcPage = 'VAR_DEFINITION_PAGE'\n+\n+  // turbopack doesn't normalize `/index` in the page name\n+  // so we need to to process dynamic routes properly\n+  // TODO: fix turbopack providing differing value from webpack\n+  if (process.env.TURBOPACK) {\n+    srcPage = srcPage.replace(/\\/index$/, '') || '/'\n+  } else if (srcPage === '/index') {\n+    // we always normalize /index specifically\n+    srcPage = '/'\n+  }\n+  const multiZoneDraftMode = process.env\n+    .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n+\n+  const prepareResult = await routeModule.prepare(req, res, {\n+    srcPage,\n+    multiZoneDraftMode,\n+  })\n+\n+  if (!prepareResult) {\n+    res.statusCode = 400\n+    res.end('Bad Request')\n+    ctx.waitUntil?.(Promise.resolve())\n+    return null\n+  }\n+\n+  const {\n+    buildId,\n+    params,\n+    parsedUrl,\n+    serverFilesManifest,\n+    prerenderManifest,\n+    isOnDemandRevalidate,\n+  } = prepareResult\n+\n+  const routerServerContext =\n+    routerServerGlobal[RouterServerContextSymbol]?.[\n+      process.env.__NEXT_RELATIVE_PROJECT_DIR || ''\n+    ]\n+\n+  const onInstrumentationRequestError =\n+    routeModule.instrumentationOnRequestError.bind(routeModule)\n+\n+  const onError: ServerOnInstrumentationRequestError = (\n+    err,\n+    _,\n+    errorContext\n+  ) => {\n+    if (routerServerContext?.logErrorWithOriginalStack) {\n+      routerServerContext.logErrorWithOriginalStack(err, 'app-dir')\n+    } else {\n+      console.error(err)\n+    }\n+    return onInstrumentationRequestError(\n+      req,\n+      err,\n+      {\n+        path: req.url || '/',\n+        headers: req.headers,\n+        method: req.method || 'GET',\n+      },\n+      errorContext\n+    )\n+  }\n+\n+  const nextConfig =\n+    routerServerContext?.nextConfig || serverFilesManifest.config\n+\n+  const pathname = parsedUrl.pathname || '/'\n+  const normalizedSrcPage = normalizeAppPath(srcPage)\n+  let isIsr = Boolean(\n+    prerenderManifest.dynamicRoutes[normalizedSrcPage] ||\n+      prerenderManifest.routes[normalizedSrcPage] ||\n+      prerenderManifest.routes[pathname]\n+  )\n+\n+  const supportsDynamicResponse: boolean =\n+    // If we're in development, we always support dynamic HTML\n+    routeModule.isDev === true ||\n+    // If this is not SSG or does not have static paths, then it supports\n+    // dynamic HTML.\n+    !isIsr\n+\n+  // This is a revalidation request if the request is for a static\n+  // page and it is not being resumed from a postponed render and\n+  // it is not a dynamic RSC request then it is a revalidation\n+  // request.\n+  const isRevalidate = isIsr && !supportsDynamicResponse\n+\n+  const method = req.method || 'GET'\n+  const tracer = getTracer()\n+  const activeSpan = tracer.getActiveScopeSpan()\n+\n+  const context: AppRouteRouteHandlerContext = {\n+    params,\n+    prerenderManifest,\n+    renderOpts: {\n+      experimental: {\n+        dynamicIO: Boolean(nextConfig.experimental.dynamicIO),\n+        authInterrupts: Boolean(nextConfig.experimental.authInterrupts),\n+      },\n+      supportsDynamicResponse,\n+      incrementalCache: getRequestMeta(req, 'incrementalCache'),\n+      cacheLifeProfiles: nextConfig.experimental?.cacheLife,\n+      isRevalidate,\n+      waitUntil: ctx.waitUntil,\n+      onClose: (cb) => {\n+        res.on('close', cb)\n+      },\n+      onAfterTaskError: undefined,\n+      onInstrumentationRequestError: onError,\n+    },\n+    sharedContext: {\n+      buildId,\n+    },\n+  }\n+  const nodeNextReq = new NodeNextRequest(req)\n+  const nodeNextRes = new NodeNextResponse(res)\n+  const nextReq = NextRequestAdapter.fromNodeNextRequest(\n+    nodeNextReq,\n+    signalFromNodeResponse(res)\n+  )\n+\n+  try {\n+    const invokeRouteModule = async (span?: Span) => {\n+      return routeModule.handle(nextReq, context).finally(() => {\n+        if (!span) return\n+\n+        span.setAttributes({\n+          'http.status_code': res.statusCode,\n+          'next.rsc': false,\n+        })\n+\n+        const rootSpanAttributes = tracer.getRootSpanAttributes()\n+        // We were unable to get attributes, probably OTEL is not enabled\n+        if (!rootSpanAttributes) {\n+          return\n+        }\n+\n+        if (\n+          rootSpanAttributes.get('next.span_type') !==\n+          BaseServerSpan.handleRequest\n+        ) {\n+          console.warn(\n+            `Unexpected root span type '${rootSpanAttributes.get(\n+              'next.span_type'\n+            )}'. Please report this Next.js issue https://github.com/vercel/next.js`\n+          )\n+          return\n+        }\n+\n+        const route = rootSpanAttributes.get('next.route')\n+        if (route) {\n+          const name = `${method} ${route}`\n+\n+          span.setAttributes({\n+            'next.route': route,\n+            'http.route': route,\n+            'next.span_name': name,\n+          })\n+          span.updateName(name)\n+        } else {\n+          span.updateName(`${method} ${req.url}`)\n+        }\n+      })\n+    }\n+\n+    let response: Response\n+\n+    // TODO: activeSpan code path is for when wrapped by\n+    // next-server can be removed when this is no longer used\n+    if (activeSpan) {\n+      response = await invokeRouteModule(activeSpan)\n+    } else {\n+      response = await tracer.withPropagatedContext(req.headers, () =>\n+        tracer.trace(\n+          BaseServerSpan.handleRequest,\n+          {\n+            spanName: `${method} ${req.url}`,\n+            kind: SpanKind.SERVER,\n+            attributes: {\n+              'http.method': method,\n+              'http.target': req.url,\n+            },\n+          },\n+          invokeRouteModule\n+        )\n+      )\n+    }\n+\n+    ;(req as any).fetchMetrics = (context.renderOpts as any).fetchMetrics\n+\n+    const cacheTags = context.renderOpts.collectedTags\n+\n+    // If the request is for a static response, we can cache it so long\n+    // as it's not edge.\n+    if (isIsr) {\n+      const blob = await response.blob()\n+\n+      // Copy the headers from the response.\n+      const headers = toNodeOutgoingHttpHeaders(response.headers)\n+\n+      if (cacheTags) {\n+        headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n+      }\n+\n+      if (!headers['content-type'] && blob.type) {\n+        headers['content-type'] = blob.type\n+      }\n+\n+      const revalidate =\n+        typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n+        context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n+          ? false\n+          : context.renderOpts.collectedRevalidate\n+\n+      const expire =\n+        typeof context.renderOpts.collectedExpire === 'undefined' ||\n+        context.renderOpts.collectedExpire >= INFINITE_CACHE\n+          ? undefined\n+          : context.renderOpts.collectedExpire\n+\n+      // Create the cache entry for the response.\n+      const cacheEntry: ResponseCacheEntry = {\n+        value: {\n+          kind: CachedRouteKind.APP_ROUTE,\n+          status: response.status,\n+          body: Buffer.from(await blob.arrayBuffer()),\n+          headers,\n+        },\n+        cacheControl: { revalidate, expire },\n+      }\n+\n+      return cacheEntry\n+    }\n+    let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n+\n+    // Attempt using provided waitUntil if available\n+    // if it's not we fallback to sendResponse's handling\n+    if (pendingWaitUntil) {\n+      if (context.renderOpts.waitUntil) {\n+        context.renderOpts.waitUntil(pendingWaitUntil)\n+        pendingWaitUntil = undefined\n+      }\n+    }\n+\n+    // Send the response now that we have copied it into the cache.\n+    await sendResponse(\n+      nodeNextReq,\n+      nodeNextRes,\n+      response,\n+      context.renderOpts.pendingWaitUntil\n+    )\n+    return null\n+  } catch (err) {\n+    // if we aren't wrapped by base-server handle here\n+    if (!activeSpan) {\n+      await onError(err, req, {\n+        routerKind: 'App Router',\n+        routePath: normalizedSrcPage,\n+        routeType: 'route',\n+        revalidateReason: getRevalidateReason({\n+          isRevalidate,\n+          isOnDemandRevalidate,\n+        }),\n+      })\n+    }\n+\n+    // rethrow so that we can handle serving error page\n+\n+    // If this is during static generation, throw the error again.\n+    if (isIsr) throw err\n+\n+    // Otherwise, send a 500 response.\n+    await sendResponse(\n+      nodeNextReq,\n+      nodeNextRes,\n+      new Response(null, { status: 500 })\n+    )\n+    return null\n+  }\n+}"
        },
        {
            "sha": "6d29e665d6264fff9e0faec115ac265e63be6f1a",
            "filename": "packages/next/src/server/base-server.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 137,
            "changes": 150,
            "blob_url": "https://github.com/vercel/next.js/blob/08ea8de29488c1295b94abede526fc50f6b49300/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/08ea8de29488c1295b94abede526fc50f6b49300/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts?ref=08ea8de29488c1295b94abede526fc50f6b49300",
            "patch": "@@ -50,7 +50,6 @@ import type {\n   AppPageRouteModule,\n } from './route-modules/app-page/module'\n import type { PagesAPIRouteMatch } from './route-matches/pages-api-route-match'\n-import type { AppRouteRouteHandlerContext } from './route-modules/app-route/module'\n import type {\n   Server as HTTPServer,\n   IncomingMessage,\n@@ -125,20 +124,14 @@ import { sendResponse } from './send-response'\n import {\n   fromNodeOutgoingHttpHeaders,\n   normalizeNextQueryParam,\n-  toNodeOutgoingHttpHeaders,\n } from './web/utils'\n import {\n   CACHE_ONE_YEAR,\n-  INFINITE_CACHE,\n   MATCHED_PATH_HEADER,\n   NEXT_CACHE_TAGS_HEADER,\n   NEXT_RESUME_HEADER,\n } from '../lib/constants'\n import { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\n-import {\n-  NextRequestAdapter,\n-  signalFromNodeResponse,\n-} from './web/spec-extension/adapters/next-request'\n import { matchNextDataPathname } from './lib/match-next-data-pathname'\n import getRouteFromAssetPath from '../shared/lib/router/utils/get-route-from-asset-path'\n import { decodePathParams } from './lib/router-utils/decode-path-params'\n@@ -2641,140 +2634,17 @@ export default abstract class Server<\n       let result: RenderResult\n \n       if (routeModule) {\n-        if (isAppRouteRouteModule(routeModule)) {\n-          if (\n-            // The type check here ensures that `req` is correctly typed, and the\n-            // environment variable check provides dead code elimination.\n-            process.env.NEXT_RUNTIME === 'edge' ||\n-            !isNodeNextRequest(req) ||\n-            !isNodeNextResponse(res)\n-          ) {\n-            throw new Error(\n-              'Invariant: App Route Route Modules cannot be used in the edge runtime'\n-            )\n-          }\n-\n-          const context: AppRouteRouteHandlerContext = {\n-            params: opts.params,\n-            prerenderManifest,\n-            renderOpts: {\n-              experimental: {\n-                dynamicIO: renderOpts.experimental.dynamicIO,\n-                authInterrupts: renderOpts.experimental.authInterrupts,\n-              },\n-              supportsDynamicResponse,\n-              incrementalCache,\n-              cacheLifeProfiles: this.nextConfig.experimental?.cacheLife,\n-              isRevalidate: isSSG,\n-              waitUntil: this.getWaitUntil(),\n-              onClose: res.onClose.bind(res),\n-              onAfterTaskError: undefined,\n-              onInstrumentationRequestError:\n-                this.renderOpts.onInstrumentationRequestError,\n-            },\n-            sharedContext: {\n-              buildId: this.buildId,\n-            },\n-          }\n-\n-          try {\n-            const request = NextRequestAdapter.fromNodeNextRequest(\n-              req,\n-              signalFromNodeResponse(res.originalResponse)\n-            )\n-\n-            const response = await routeModule.handle(request, context)\n-\n-            ;(req as any).fetchMetrics = (\n-              context.renderOpts as any\n-            ).fetchMetrics\n-\n-            const cacheTags = context.renderOpts.collectedTags\n-\n-            // If the request is for a static response, we can cache it so long\n-            // as it's not edge.\n-            if (isSSG) {\n-              const blob = await response.blob()\n-\n-              // Copy the headers from the response.\n-              const headers = toNodeOutgoingHttpHeaders(response.headers)\n-\n-              if (cacheTags) {\n-                headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n-              }\n-\n-              if (!headers['content-type'] && blob.type) {\n-                headers['content-type'] = blob.type\n-              }\n-\n-              const revalidate =\n-                typeof context.renderOpts.collectedRevalidate === 'undefined' ||\n-                context.renderOpts.collectedRevalidate >= INFINITE_CACHE\n-                  ? false\n-                  : context.renderOpts.collectedRevalidate\n-\n-              const expire =\n-                typeof context.renderOpts.collectedExpire === 'undefined' ||\n-                context.renderOpts.collectedExpire >= INFINITE_CACHE\n-                  ? undefined\n-                  : context.renderOpts.collectedExpire\n-\n-              // Create the cache entry for the response.\n-              const cacheEntry: ResponseCacheEntry = {\n-                value: {\n-                  kind: CachedRouteKind.APP_ROUTE,\n-                  status: response.status,\n-                  body: Buffer.from(await blob.arrayBuffer()),\n-                  headers,\n-                },\n-                cacheControl: { revalidate, expire },\n-              }\n-\n-              return cacheEntry\n-            }\n-            let pendingWaitUntil = context.renderOpts.pendingWaitUntil\n-\n-            // Attempt using provided waitUntil if available\n-            // if it's not we fallback to sendResponse's handling\n-            if (pendingWaitUntil) {\n-              if (context.renderOpts.waitUntil) {\n-                context.renderOpts.waitUntil(pendingWaitUntil)\n-                pendingWaitUntil = undefined\n-              }\n-            }\n-\n-            // Send the response now that we have copied it into the cache.\n-            await sendResponse(\n-              req,\n-              res,\n-              response,\n-              context.renderOpts.pendingWaitUntil\n-            )\n-            return null\n-          } catch (err) {\n-            await this.instrumentationOnRequestError(err, req, {\n-              routerKind: 'App Router',\n-              routePath: pathname,\n-              routeType: 'route',\n-              revalidateReason: getRevalidateReason(renderOpts),\n-            })\n-\n-            // If this is during static generation, throw the error again.\n-            if (isSSG) throw err\n-\n-            Log.error(err)\n-\n-            // Otherwise, send a 500 response.\n-            await sendResponse(req, res, new Response(null, { status: 500 }))\n-\n-            return null\n-          }\n-        } else if (\n+        if (\n+          isAppRouteRouteModule(routeModule) ||\n           isPagesRouteModule(routeModule) ||\n           isAppPageRouteModule(routeModule)\n         ) {\n           // An OPTIONS request to a page handler is invalid.\n-          if (req.method === 'OPTIONS' && !is404Page) {\n+          if (\n+            req.method === 'OPTIONS' &&\n+            !is404Page &&\n+            !isAppRouteRouteModule(routeModule)\n+          ) {\n             await sendResponse(req, res, new Response(null, { status: 400 }))\n             return null\n           }\n@@ -2813,6 +2683,7 @@ export default abstract class Server<\n             if (renderOpts.err) {\n               addRequestMeta(request, 'invokeError', renderOpts.err)\n             }\n+\n             const handler: (\n               req: ServerRequest | IncomingMessage,\n               res: ServerResponse | HTTPServerResponse,\n@@ -2825,6 +2696,11 @@ export default abstract class Server<\n               waitUntil: this.getWaitUntil(),\n             })\n \n+            // this is handled fully in handler\n+            if (isAppRouteRouteModule(routeModule)) {\n+              return result as any as ResponseCacheEntry | null\n+            }\n+\n             if (!result) {\n               throw new Error(\n                 `Invariant: missing result from invoking ${pathname} handler`"
        }
    ],
    "stats": {
        "total": 464,
        "additions": 327,
        "deletions": 137
    }
}