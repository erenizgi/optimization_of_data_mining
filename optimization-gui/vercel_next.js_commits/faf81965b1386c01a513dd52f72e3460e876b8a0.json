{
    "author": "sokra",
    "message": "Turbopack: Symlink handling follow-up (#87637)\n\n### What?\n\n* Run symlink glob tests with windows too\n* make link content os specific before comparing it with the old value",
    "sha": "faf81965b1386c01a513dd52f72e3460e876b8a0",
    "files": [
        {
            "sha": "d365d5ef9409cab943f3d7ae7c55dc558b9cfbbe",
            "filename": "packages/next/src/build/utils.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/faf81965b1386c01a513dd52f72e3460e876b8a0/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/faf81965b1386c01a513dd52f72e3460e876b8a0/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts?ref=faf81965b1386c01a513dd52f72e3460e876b8a0",
            "patch": "@@ -1276,7 +1276,7 @@ export async function copyTracedFiles(\n               await fs.symlink(symlink, fileOutputPath)\n             } catch (err: any) {\n               // Windows doesn't support creating symlinks without elevated privileges, unless\n-              // \"Developer Mode\" is turned on. If we failed to crate a symlink due to EPERM, try\n+              // \"Developer Mode\" is turned on. If we failed to create a symlink due to EPERM, try\n               // creating a junction point instead.\n               //\n               // Ideally we'd just preserve the input file type (junction point or symlink), but"
        },
        {
            "sha": "e97a511025425f749664c568b87eeb2b85773092",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 58,
            "deletions": 39,
            "changes": 97,
            "blob_url": "https://github.com/vercel/next.js/blob/faf81965b1386c01a513dd52f72e3460e876b8a0/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/faf81965b1386c01a513dd52f72e3460e876b8a0/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=faf81965b1386c01a513dd52f72e3460e876b8a0",
            "patch": "@@ -1069,6 +1069,43 @@ impl FileSystem for DiskFileSystem {\n                 .transpose()?\n                 .unwrap_or_default();\n \n+            enum OsSpecificLinkContent {\n+                Link {\n+                    #[cfg(windows)]\n+                    is_directory: bool,\n+                    target: PathBuf,\n+                },\n+                NotFound,\n+                Invalid,\n+            }\n+\n+            let os_specific_link_content = match &*content {\n+                LinkContent::Link { target, link_type } => {\n+                    let is_directory = link_type.contains(LinkType::DIRECTORY);\n+                    let target_path = if link_type.contains(LinkType::ABSOLUTE) {\n+                        Path::new(&inner.root).join(unix_to_sys(target).as_ref())\n+                    } else {\n+                        let relative_target = PathBuf::from(unix_to_sys(target).as_ref());\n+                        if cfg!(windows) && is_directory {\n+                            // Windows junction points must always be stored as absolute\n+                            full_path\n+                                .parent()\n+                                .unwrap_or(&full_path)\n+                                .join(relative_target)\n+                        } else {\n+                            relative_target\n+                        }\n+                    };\n+                    OsSpecificLinkContent::Link {\n+                        #[cfg(windows)]\n+                        is_directory,\n+                        target: target_path,\n+                    }\n+                }\n+                LinkContent::Invalid => OsSpecificLinkContent::Invalid,\n+                LinkContent::NotFound => OsSpecificLinkContent::NotFound,\n+            };\n+\n             // TODO(sokra) perform a untracked read here, register an invalidator and get\n             // all existing invalidators\n             let old_content = match retry_blocking(full_path.clone().into_owned(), |path| {\n@@ -1084,21 +1121,12 @@ impl FileSystem for DiskFileSystem {\n                 Ok(res) => Some((res.is_absolute(), res)),\n                 Err(_) => None,\n             };\n-            let is_equal = match (&*content, &old_content) {\n-                // TODO(bgw): Is this logic correct? This might give us `is_equal = false` when it\n-                // shouldn't, and cause us to do extra work.\n-                // - `old_content` may have windows path separators, but `LinkContent` normalizes\n-                //   them.\n-                // - Windows junction points are always transformed to absolute before being stored.\n-                // - `LinkContent`'s target field stores absolute paths as relative to the project\n-                //   root, but `old_target` is relative to the real filesystem's root.\n-                // We should compute the final target `Path` first, and then it with that value, not\n-                // the normalized format stored in\n-                (LinkContent::Link { target, link_type }, Some((old_is_absolute, old_target))) => {\n-                    Path::new(target) == old_target\n-                        && link_type.contains(LinkType::ABSOLUTE) == *old_is_absolute\n-                }\n-                (LinkContent::NotFound, None) => true,\n+            let is_equal = match (&os_specific_link_content, &old_content) {\n+                (\n+                    OsSpecificLinkContent::Link { target, .. },\n+                    Some((old_is_absolute, old_target)),\n+                ) => target == old_target && target.is_absolute() == *old_is_absolute,\n+                (OsSpecificLinkContent::NotFound, None) => true,\n                 _ => false,\n             };\n             if is_equal {\n@@ -1114,23 +1142,13 @@ impl FileSystem for DiskFileSystem {\n                 return Ok(());\n             }\n \n-            match &*content {\n-                LinkContent::Link { target, link_type } => {\n-                    let is_directory = link_type.contains(LinkType::DIRECTORY);\n-                    let target_path = if link_type.contains(LinkType::ABSOLUTE) {\n-                        Path::new(&inner.root).join(unix_to_sys(target).as_ref())\n-                    } else {\n-                        let relative_target = PathBuf::from(unix_to_sys(target).as_ref());\n-                        if cfg!(windows) && is_directory {\n-                            // Windows junction points must always be stored as absolute\n-                            full_path\n-                                .parent()\n-                                .unwrap_or(&full_path)\n-                                .join(relative_target)\n-                        } else {\n-                            relative_target\n-                        }\n-                    };\n+            match os_specific_link_content {\n+                OsSpecificLinkContent::Link {\n+                    target,\n+                    #[cfg(windows)]\n+                    is_directory,\n+                    ..\n+                } => {\n                     let full_path = full_path.into_owned();\n \n                     let create_directory = old_content.is_none();\n@@ -1156,7 +1174,7 @@ impl FileSystem for DiskFileSystem {\n                             })?;\n                     }\n \n-                    retry_blocking(target_path, move |target_path| {\n+                    retry_blocking(target.clone(), move |target_path| {\n                         let _span = tracing::info_span!(\n                             \"write symlink\",\n                             name = display(target_path.display())\n@@ -1178,23 +1196,24 @@ impl FileSystem for DiskFileSystem {\n                     .await\n                     .with_context(|| {\n                         #[cfg(not(windows))]\n-                        let message = format!(\"failed to create symlink to {target}\");\n+                        let message = format!(\"failed to create symlink to {}\", target.display());\n                         #[cfg(windows)]\n                         let message = if is_directory {\n-                            format!(\"failed to create junction point to {target}\")\n+                            format!(\"failed to create junction point to {}\", target.display())\n                         } else {\n                             format!(\n-                                \"failed to create symlink to {target}\\n\\\n-                                (Note: creating file symlinks on Windows require developer mode or admin permissions: https://learn.microsoft.com/en-us/windows/advanced-settings/developer-mode)\"\n+                                \"failed to create symlink to {}\\n\\\n+                                (Note: creating file symlinks on Windows require developer mode or admin permissions: https://learn.microsoft.com/en-us/windows/advanced-settings/developer-mode)\",\n+                                target.display()\n                             )\n                         };\n                         message\n                     })?;\n                 }\n-                LinkContent::Invalid => {\n+                OsSpecificLinkContent::Invalid => {\n                     bail!(\"invalid symlink target: {}\", full_path.display())\n                 }\n-                LinkContent::NotFound => {\n+                OsSpecificLinkContent::NotFound => {\n                     remove_symbolic_link_dir_helper(&full_path)\n                         .concurrency_limited(&inner.write_semaphore)\n                         .await"
        },
        {
            "sha": "3220624949beaa203ff427133cb6536ec831379a",
            "filename": "turbopack/crates/turbo-tasks-fs/src/read_glob.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 17,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/faf81965b1386c01a513dd52f72e3460e876b8a0/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/faf81965b1386c01a513dd52f72e3460e876b8a0/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs?ref=faf81965b1386c01a513dd52f72e3460e876b8a0",
            "patch": "@@ -245,6 +245,29 @@ pub mod tests {\n         glob::{Glob, GlobOptions},\n     };\n \n+    fn symlink<P: AsRef<std::path::Path>, Q: AsRef<std::path::Path>>(\n+        target: Q,\n+        path: P,\n+    ) -> std::io::Result<()> {\n+        assert!(target.as_ref().is_absolute());\n+        let _ = std::fs::remove_dir(&path);\n+        let _ = std::fs::remove_file(&path);\n+\n+        #[cfg(unix)]\n+        {\n+            std::os::unix::fs::symlink(target, path)\n+        }\n+        #[cfg(windows)]\n+        {\n+            let metadata = std::fs::metadata(&target).ok();\n+            if metadata.is_none_or(|m| m.is_file()) {\n+                std::os::windows::fs::symlink_file(target, path)\n+            } else {\n+                std::os::windows::fs::junction_point(target, path)\n+            }\n+        }\n+    }\n+\n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n     async fn read_glob_basic() {\n         let scratch = tempfile::tempdir().unwrap();\n@@ -313,11 +336,8 @@ pub mod tests {\n         .unwrap();\n     }\n \n-    #[cfg(unix)]\n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n     async fn read_glob_symlinks() {\n-        use std::os::unix::fs::symlink;\n-\n         let scratch = tempfile::tempdir().unwrap();\n         {\n             // root.js\n@@ -420,10 +440,8 @@ pub mod tests {\n         path.track_glob(Glob::new(rcstr!(\"**\"), GlobOptions::default()), false)\n     }\n \n-    #[cfg(unix)]\n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n     async fn track_glob_invalidations() {\n-        use std::os::unix::fs::symlink;\n         let scratch = tempfile::tempdir().unwrap();\n \n         // Create a simple directory with 2 files, a subdirectory and a dotfile\n@@ -506,13 +524,10 @@ pub mod tests {\n         .unwrap();\n     }\n \n-    #[cfg(unix)]\n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n     async fn track_glob_symlinks_loop() {\n         let scratch = tempfile::tempdir().unwrap();\n         {\n-            use std::os::unix::fs::symlink;\n-\n             // Create a simple directory with 1 file and a symlink pointing at at a file in a\n             // subdirectory\n             let path = scratch.path();\n@@ -562,13 +577,10 @@ pub mod tests {\n     }\n \n     // Reproduces an issue where a dead symlink would cause a panic when tracking/reading a glob\n-    #[cfg(unix)]\n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n     async fn dead_symlinks() {\n         let scratch = tempfile::tempdir().unwrap();\n         {\n-            use std::os::unix::fs::symlink;\n-\n             // Create a simple directory with 1 file and a symlink pointing at a non-existent file\n             let path = scratch.path();\n             let sub = &path.join(\"sub\");\n@@ -625,13 +637,10 @@ pub mod tests {\n     }\n \n     // Reproduces an issue where a dead symlink would cause a panic when tracking/reading a glob\n-    #[cfg(unix)]\n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n     async fn symlink_escapes_fs_root() {\n         let scratch = tempfile::tempdir().unwrap();\n         {\n-            use std::os::unix::fs::symlink;\n-\n             // Create a simple directory with 1 file and a symlink pointing at a non-existent file\n             let path = scratch.path();\n             let sub = &path.join(\"sub\");\n@@ -657,13 +666,10 @@ pub mod tests {\n         .unwrap();\n     }\n \n-    #[cfg(unix)]\n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n     async fn read_glob_symlinks_loop() {\n         let scratch = tempfile::tempdir().unwrap();\n         {\n-            use std::os::unix::fs::symlink;\n-\n             // Create a simple directory with 1 file and a symlink pointing at at a file in a\n             // subdirectory\n             let path = scratch.path();"
        }
    ],
    "stats": {
        "total": 139,
        "additions": 82,
        "deletions": 57
    }
}