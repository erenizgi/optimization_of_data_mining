{
    "author": "mischnic",
    "message": "Turbopack: refactor codegen of module fragments (#78642)\n\nSo that every type of ecmascript chunk item uses `EcmascriptModuleContent::new`",
    "sha": "43a4c628f877df7c1867cc12c061d90487440790",
    "files": [
        {
            "sha": "fe9674b2a60cc5d99a06356ed884ece0d752e37c",
            "filename": "turbopack/crates/turbopack-ecmascript/src/code_gen.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fcode_gen.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fcode_gen.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fcode_gen.rs?ref=43a4c628f877df7c1867cc12c061d90487440790",
            "patch": "@@ -153,6 +153,14 @@ impl CodeGen {\n #[turbo_tasks::value(transparent)]\n pub struct CodeGens(Vec<CodeGen>);\n \n+#[turbo_tasks::value_impl]\n+impl CodeGens {\n+    #[turbo_tasks::function]\n+    pub fn empty() -> Vc<Self> {\n+        Vc::cell(Vec::new())\n+    }\n+}\n+\n pub trait IntoCodeGenReference {\n     fn into_code_gen_reference(\n         self,"
        },
        {
            "sha": "83a1c25717a71fe5c53de4d9cba3c507e806cbb4",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 45,
            "deletions": 22,
            "changes": 67,
            "blob_url": "https://github.com/vercel/next.js/blob/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=43a4c628f877df7c1867cc12c061d90487440790",
            "patch": "@@ -98,6 +98,7 @@ use crate::{\n     references::{\n         analyse_ecmascript_module, async_module::OptionAsyncModule, esm::base::EsmAssetReferences,\n     },\n+    side_effect_optimization::reference::EcmascriptModulePartReference,\n     transform::remove_shebang,\n };\n \n@@ -124,6 +125,7 @@ pub enum SpecifiedModuleType {\n     Deserialize,\n     TraceRawVcs,\n     NonLocalValue,\n+    TaskInput,\n )]\n #[serde(rename_all = \"kebab-case\")]\n pub enum TreeShakingMode {\n@@ -436,6 +438,7 @@ impl EcmascriptAnalyzable for EcmascriptModuleAsset {\n                 chunking_context,\n                 references: analyze.references().to_resolved().await?,\n                 esm_references: analyze_ref.esm_references,\n+                part_references: vec![],\n                 code_generation: analyze_ref.code_generation,\n                 async_module: analyze_ref.async_module,\n                 generate_source_map,\n@@ -747,30 +750,35 @@ impl EcmascriptChunkItem for ModuleChunkItem {\n         self: Vc<Self>,\n         async_module_info: Option<Vc<AsyncModuleInfo>>,\n     ) -> Result<Vc<EcmascriptChunkItemContent>> {\n-        let this = self.await?;\n-        let _span = tracing::info_span!(\n+        let span = tracing::info_span!(\n             \"code generation\",\n             module = self.asset_ident().to_string().await?.to_string()\n-        )\n-        .entered();\n-        let async_module_options = this\n-            .module\n-            .get_async_module()\n-            .module_options(async_module_info);\n-\n-        // TODO check if we need to pass async_module_info at all\n-        let content = this.module.module_content(\n-            *this.module_graph,\n-            *this.chunking_context,\n-            async_module_info,\n         );\n+        async {\n+            let this = self.await?;\n+            let async_module_options = this\n+                .module\n+                .get_async_module()\n+                .module_options(async_module_info);\n+\n+            // TODO check if we need to pass async_module_info at all\n+            let content = this.module.module_content(\n+                *this.module_graph,\n+                *this.chunking_context,\n+                async_module_info,\n+            );\n \n-        Ok(EcmascriptChunkItemContent::new(\n-            content,\n-            *this.chunking_context,\n-            this.module.options(),\n-            async_module_options,\n-        ))\n+            EcmascriptChunkItemContent::new(\n+                content,\n+                *this.chunking_context,\n+                this.module.options(),\n+                async_module_options,\n+            )\n+            .resolve()\n+            .await\n+        }\n+        .instrument(span)\n+        .await\n     }\n }\n \n@@ -792,6 +800,7 @@ pub struct EcmascriptModuleContentOptions {\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n     references: ResolvedVc<ModuleReferences>,\n     esm_references: ResolvedVc<EsmAssetReferences>,\n+    part_references: Vec<ResolvedVc<EcmascriptModulePartReference>>,\n     code_generation: ResolvedVc<CodeGens>,\n     async_module: ResolvedVc<OptionAsyncModule>,\n     generate_source_map: bool,\n@@ -813,6 +822,7 @@ impl EcmascriptModuleContent {\n             chunking_context,\n             references,\n             esm_references,\n+            part_references,\n             code_generation,\n             async_module,\n             generate_source_map,\n@@ -821,7 +831,7 @@ impl EcmascriptModuleContent {\n             async_module_info,\n         } = input;\n \n-        let (esm_code_gens, additional_code_gens, code_gens) = async {\n+        let (esm_code_gens, part_code_gens, additional_code_gens, code_gens) = async {\n             let additional_code_gens = [\n                 if let Some(async_module) = &*async_module.await? {\n                     Some(\n@@ -853,20 +863,33 @@ impl EcmascriptModuleContent {\n                 .map(|r| r.code_generation(*chunking_context))\n                 .try_join()\n                 .await?;\n+\n+            let part_code_gens = part_references\n+                .iter()\n+                .map(|r| r.code_generation(*chunking_context))\n+                .try_join()\n+                .await?;\n+\n             let code_gens = code_generation\n                 .await?\n                 .iter()\n                 .map(|c| c.code_generation(*module_graph, *chunking_context))\n                 .try_join()\n                 .await?;\n \n-            anyhow::Ok((esm_code_gens, additional_code_gens, code_gens))\n+            anyhow::Ok((\n+                esm_code_gens,\n+                part_code_gens,\n+                additional_code_gens,\n+                code_gens,\n+            ))\n         }\n         .instrument(tracing::info_span!(\"precompute code generation\"))\n         .await?;\n \n         let code_gens = esm_code_gens\n             .iter()\n+            .chain(part_code_gens.iter())\n             .chain(additional_code_gens.iter().flatten())\n             .chain(code_gens.iter());\n "
        },
        {
            "sha": "bf3e7779e4bcfdc939ede3cc07d2b23bf939be6d",
            "filename": "turbopack/crates/turbopack-ecmascript/src/parse.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 1,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs?ref=43a4c628f877df7c1867cc12c061d90487440790",
            "patch": "@@ -8,6 +8,7 @@ use swc_core::{\n         errors::{Handler, HANDLER},\n         input::StringInput,\n         source_map::SourceMapGenConfig,\n+        util::take::Take,\n         BytePos, FileName, Globals, LineCol, Mark, SyntaxContext, GLOBALS,\n     },\n     ecma::{\n@@ -38,7 +39,7 @@ use turbopack_swc_utils::emitter::IssueEmitter;\n \n use super::EcmascriptModuleAssetType;\n use crate::{\n-    analyzer::graph::EvalContext,\n+    analyzer::{graph::EvalContext, ImportMap},\n     swc_comments::ImmutableComments,\n     transform::{EcmascriptInputTransforms, TransformContext},\n     EcmascriptInputTransform,\n@@ -75,6 +76,28 @@ impl PartialEq for ParseResult {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl ParseResult {\n+    #[turbo_tasks::function]\n+    pub fn empty() -> Vc<ParseResult> {\n+        let globals = Globals::new();\n+        let eval_context = GLOBALS.set(&globals, || EvalContext {\n+            unresolved_mark: Mark::new(),\n+            top_level_mark: Mark::new(),\n+            imports: ImportMap::default(),\n+            force_free_values: Default::default(),\n+        });\n+        ParseResult::Ok {\n+            program: Program::Module(swc_core::ecma::ast::Module::dummy()),\n+            comments: Default::default(),\n+            eval_context,\n+            globals: Arc::new(globals),\n+            source_map: Default::default(),\n+        }\n+        .cell()\n+    }\n+}\n+\n pub fn generate_js_source_map(\n     files_map: Arc<swc_core::common::SourceMap>,\n     mappings: Vec<(BytePos, LineCol)>,"
        },
        {
            "sha": "bf8718d6aea6dc9c2c8d89733b7a0651ae82cc2f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/base.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs?ref=43a4c628f877df7c1867cc12c061d90487440790",
            "patch": "@@ -109,6 +109,14 @@ impl ReferencedAsset {\n #[turbo_tasks::value(transparent)]\n pub struct EsmAssetReferences(Vec<ResolvedVc<EsmAssetReference>>);\n \n+#[turbo_tasks::value_impl]\n+impl EsmAssetReferences {\n+    #[turbo_tasks::function]\n+    pub fn empty() -> Vc<Self> {\n+        Vc::cell(Vec::new())\n+    }\n+}\n+\n #[turbo_tasks::value(shared)]\n #[derive(Hash, Debug)]\n pub struct EsmAssetReference {"
        },
        {
            "sha": "a3486b8cf6faf4ee247593a3e2dc78ae8e11166f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/facade/chunk_item.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 75,
            "changes": 89,
            "blob_url": "https://github.com/vercel/next.js/blob/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs?ref=43a4c628f877df7c1867cc12c061d90487440790",
            "patch": "@@ -1,15 +1,5 @@\n-use std::sync::Arc;\n-\n-use anyhow::{bail, Result};\n-use swc_core::{\n-    common::{util::take::Take, Globals},\n-    ecma::{\n-        ast::Program,\n-        codegen::{text_writer::JsWriter, Emitter},\n-    },\n-};\n+use anyhow::Result;\n use turbo_tasks::{ResolvedVc, Vc};\n-use turbo_tasks_fs::rope::RopeBuilder;\n use turbopack_core::{\n     chunk::{AsyncModuleInfo, ChunkItem, ChunkType, ChunkingContext},\n     ident::AssetIdent,\n@@ -20,10 +10,10 @@ use turbopack_core::{\n use super::module::EcmascriptModuleFacadeModule;\n use crate::{\n     chunk::{\n-        EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkItemOptions,\n-        EcmascriptChunkPlaceable, EcmascriptChunkType, EcmascriptExports,\n+        EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkPlaceable,\n+        EcmascriptChunkType,\n     },\n-    process_content_with_code_gens,\n+    EcmascriptAnalyzable, EcmascriptOptions,\n };\n \n /// The chunk item for [EcmascriptModuleFacadeModule].\n@@ -47,74 +37,23 @@ impl EcmascriptChunkItem for EcmascriptModuleFacadeChunkItem {\n         async_module_info: Option<Vc<AsyncModuleInfo>>,\n     ) -> Result<Vc<EcmascriptChunkItemContent>> {\n         let chunking_context = self.chunking_context;\n-        let exports = self.module.get_exports();\n-        let EcmascriptExports::EsmExports(exports) = *exports.await? else {\n-            bail!(\"Expected EsmExports\");\n-        };\n+        let module_graph = self.module_graph;\n \n-        let externals = *chunking_context\n-            .environment()\n-            .supports_commonjs_externals()\n-            .await?;\n+        let content =\n+            self.module\n+                .module_content(*module_graph, *chunking_context, async_module_info);\n \n         let async_module_options = self\n             .module\n             .get_async_module()\n             .module_options(async_module_info);\n \n-        let async_module = async_module_options.owned().await?;\n-\n-        let mut code = RopeBuilder::default();\n-\n-        let esm_code_gens = self\n-            .module\n-            .code_generation(*self.module_graph, *chunking_context)\n-            .await?;\n-        let additional_code_gens = [\n-            self.module\n-                .async_module()\n-                .code_generation(\n-                    async_module_info,\n-                    self.module.references(),\n-                    *chunking_context,\n-                )\n-                .await?,\n-            exports\n-                .code_generation(*self.module_graph, *chunking_context, None)\n-                .await?,\n-        ];\n-        let code_gens = esm_code_gens.iter().chain(additional_code_gens.iter());\n-\n-        let mut program = Program::Module(swc_core::ecma::ast::Module::dummy());\n-        process_content_with_code_gens(&mut program, &Globals::new(), None, code_gens);\n-\n-        let mut bytes: Vec<u8> = vec![];\n-\n-        let source_map: Arc<swc_core::common::SourceMap> = Default::default();\n-\n-        let mut emitter = Emitter {\n-            cfg: swc_core::ecma::codegen::Config::default(),\n-            cm: source_map.clone(),\n-            comments: None,\n-            wr: JsWriter::new(source_map.clone(), \"\\n\", &mut bytes, None),\n-        };\n-\n-        emitter.emit_program(&program)?;\n-\n-        code.push_bytes(&bytes);\n-\n-        Ok(EcmascriptChunkItemContent {\n-            inner_code: code.build(),\n-            source_map: None,\n-            options: EcmascriptChunkItemOptions {\n-                strict: true,\n-                externals,\n-                async_module,\n-                ..Default::default()\n-            },\n-            ..Default::default()\n-        }\n-        .cell())\n+        Ok(EcmascriptChunkItemContent::new(\n+            content,\n+            *chunking_context,\n+            EcmascriptOptions::default().cell(),\n+            async_module_options,\n+        ))\n     }\n }\n "
        },
        {
            "sha": "54b8ba9ae341d805d86368401f856eb4a940d21f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/facade/module.rs",
            "status": "modified",
            "additions": 108,
            "deletions": 139,
            "changes": 247,
            "blob_url": "https://github.com/vercel/next.js/blob/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fmodule.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fmodule.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fmodule.rs?ref=43a4c628f877df7c1867cc12c061d90487440790",
            "patch": "@@ -1,28 +1,31 @@\n use std::collections::BTreeMap;\n \n use anyhow::{bail, Result};\n-use turbo_tasks::{ResolvedVc, TryJoinIterExt, Vc};\n+use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::{glob::Glob, File, FileContent};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n-    chunk::{ChunkableModule, ChunkingContext, EvaluatableAsset},\n+    chunk::{AsyncModuleInfo, ChunkableModule, ChunkingContext, EvaluatableAsset},\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n     reference::ModuleReferences,\n     resolve::ModulePart,\n+    source_map::OptionStringifiedSourceMap,\n };\n \n use super::chunk_item::EcmascriptModuleFacadeChunkItem;\n use crate::{\n     chunk::{EcmascriptChunkPlaceable, EcmascriptExports},\n-    code_gen::CodeGeneration,\n+    code_gen::CodeGens,\n+    parse::ParseResult,\n     references::{\n         async_module::{AsyncModule, OptionAsyncModule},\n-        esm::{EsmExport, EsmExports},\n+        esm::{base::EsmAssetReferences, EsmExport, EsmExports},\n     },\n     side_effect_optimization::reference::EcmascriptModulePartReference,\n-    EcmascriptAnalyzable,\n+    AnalyzeEcmascriptModuleResult, EcmascriptAnalyzable, EcmascriptModuleContent,\n+    EcmascriptModuleContentOptions, SpecifiedModuleType,\n };\n \n /// A module derived from an original ecmascript module that only contains all\n@@ -61,100 +64,13 @@ impl EcmascriptModuleFacadeModule {\n }\n \n impl EcmascriptModuleFacadeModule {\n-    pub async fn code_generation(\n-        self: Vc<Self>,\n-        module_graph: Vc<ModuleGraph>,\n-        chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    ) -> Result<Vec<CodeGeneration>> {\n-        let this = self.await?;\n-        Ok(match &this.ty {\n-            ModulePart::Evaluation => {\n-                let Some(module) =\n-                    ResolvedVc::try_sidecast::<Box<dyn EcmascriptAnalyzable>>(this.module)\n-                else {\n-                    bail!(\n-                        \"Expected EcmascriptModuleAsset for a EcmascriptModuleFacadeModule with \\\n-                         ModulePart::Evaluation\"\n-                    );\n-                };\n-                let result = module.analyze().await?;\n-                let mut code_gens = result\n-                    .esm_evaluation_references\n-                    .await?\n-                    .iter()\n-                    .map(|r| r.code_generation(chunking_context))\n-                    .try_join()\n-                    .await?;\n-                code_gens.push(\n-                    EcmascriptModulePartReference::new_part(*this.module, ModulePart::locals())\n-                        .code_generation(module_graph, chunking_context)\n-                        .await?,\n-                );\n-                code_gens\n-            }\n-            ModulePart::Exports => {\n-                let Some(module) =\n-                    ResolvedVc::try_sidecast::<Box<dyn EcmascriptAnalyzable>>(this.module)\n-                else {\n-                    bail!(\n-                        \"Expected EcmascriptModuleAsset for a EcmascriptModuleFacadeModule with \\\n-                         ModulePart::Exports\"\n-                    );\n-                };\n-                let result = module.analyze().await?;\n-                let mut code_gens = result\n-                    .esm_reexport_references\n-                    .await?\n-                    .iter()\n-                    .map(|r| r.code_generation(chunking_context))\n-                    .try_join()\n-                    .await?;\n-                code_gens.push(\n-                    EcmascriptModulePartReference::new_part(*this.module, ModulePart::locals())\n-                        .code_generation(module_graph, chunking_context)\n-                        .await?,\n-                );\n-                code_gens\n-            }\n-            ModulePart::Facade => {\n-                vec![\n-                    EcmascriptModulePartReference::new_part(*this.module, ModulePart::evaluation())\n-                        .code_generation(module_graph, chunking_context)\n-                        .await?,\n-                    EcmascriptModulePartReference::new_part(*this.module, ModulePart::exports())\n-                        .code_generation(module_graph, chunking_context)\n-                        .await?,\n-                ]\n-            }\n-            ModulePart::RenamedNamespace { .. } => vec![\n-                EcmascriptModulePartReference::new(*this.module)\n-                    .code_generation(module_graph, chunking_context)\n-                    .await?,\n-            ],\n-            ModulePart::RenamedExport { .. } => vec![\n-                EcmascriptModulePartReference::new(*this.module)\n-                    .code_generation(module_graph, chunking_context)\n-                    .await?,\n-            ],\n-            _ => {\n-                bail!(\"Unexpected ModulePart for EcmascriptModuleFacadeModule\");\n-            }\n-        })\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl Module for EcmascriptModuleFacadeModule {\n-    #[turbo_tasks::function]\n-    async fn ident(&self) -> Result<Vc<AssetIdent>> {\n-        let inner = self.module.ident();\n-\n-        Ok(inner.with_part(self.ty.clone()))\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn references(&self) -> Result<Vc<ModuleReferences>> {\n-        let references = match &self.ty {\n+    pub async fn specific_references(\n+        &self,\n+    ) -> Result<(\n+        ResolvedVc<EsmAssetReferences>,\n+        Vec<ResolvedVc<EcmascriptModulePartReference>>,\n+    )> {\n+        Ok(match &self.ty {\n             ModulePart::Evaluation => {\n                 let Some(module) =\n                     ResolvedVc::try_sidecast::<Box<dyn EcmascriptAnalyzable>>(self.module)\n@@ -165,17 +81,14 @@ impl Module for EcmascriptModuleFacadeModule {\n                     );\n                 };\n                 let result = module.analyze().await?;\n-                result\n-                    .esm_evaluation_references\n-                    .await?\n-                    .iter()\n-                    .map(|r| ResolvedVc::upcast(*r))\n-                    .chain(std::iter::once(ResolvedVc::upcast(\n+                (\n+                    result.esm_evaluation_references,\n+                    vec![\n                         EcmascriptModulePartReference::new_part(*self.module, ModulePart::locals())\n                             .to_resolved()\n                             .await?,\n-                    )))\n-                    .collect()\n+                    ],\n+                )\n             }\n             ModulePart::Exports => {\n                 let Some(module) =\n@@ -187,56 +100,67 @@ impl Module for EcmascriptModuleFacadeModule {\n                     );\n                 };\n                 let result = module.analyze().await?;\n-                result\n-                    .esm_reexport_references\n-                    .await?\n-                    .iter()\n-                    .map(|r| ResolvedVc::upcast(*r))\n-                    .chain(std::iter::once(ResolvedVc::upcast(\n+                (\n+                    result.esm_reexport_references,\n+                    vec![\n                         EcmascriptModulePartReference::new_part(*self.module, ModulePart::locals())\n                             .to_resolved()\n                             .await?,\n-                    )))\n-                    .collect()\n+                    ],\n+                )\n             }\n-            ModulePart::Facade => {\n+            ModulePart::Facade => (\n+                EsmAssetReferences::empty().to_resolved().await?,\n                 vec![\n-                    ResolvedVc::upcast(\n-                        EcmascriptModulePartReference::new_part(\n-                            *self.module,\n-                            ModulePart::evaluation(),\n-                        )\n+                    EcmascriptModulePartReference::new_part(*self.module, ModulePart::evaluation())\n                         .to_resolved()\n                         .await?,\n-                    ),\n-                    ResolvedVc::upcast(\n-                        EcmascriptModulePartReference::new_part(\n-                            *self.module,\n-                            ModulePart::exports(),\n-                        )\n+                    EcmascriptModulePartReference::new_part(*self.module, ModulePart::exports())\n                         .to_resolved()\n                         .await?,\n-                    ),\n-                ]\n-            }\n-            ModulePart::RenamedNamespace { .. } => {\n-                vec![ResolvedVc::upcast(\n+                ],\n+            ),\n+            ModulePart::RenamedNamespace { .. } => (\n+                EsmAssetReferences::empty().to_resolved().await?,\n+                vec![\n                     EcmascriptModulePartReference::new(*self.module)\n                         .to_resolved()\n                         .await?,\n-                )]\n-            }\n-            ModulePart::RenamedExport { .. } => {\n-                vec![ResolvedVc::upcast(\n+                ],\n+            ),\n+            ModulePart::RenamedExport { .. } => (\n+                EsmAssetReferences::empty().to_resolved().await?,\n+                vec![\n                     EcmascriptModulePartReference::new(*self.module)\n                         .to_resolved()\n                         .await?,\n-                )]\n-            }\n+                ],\n+            ),\n             _ => {\n                 bail!(\"Unexpected ModulePart for EcmascriptModuleFacadeModule\");\n             }\n-        };\n+        })\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Module for EcmascriptModuleFacadeModule {\n+    #[turbo_tasks::function]\n+    async fn ident(&self) -> Result<Vc<AssetIdent>> {\n+        let inner = self.module.ident();\n+\n+        Ok(inner.with_part(self.ty.clone()))\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn references(self: Vc<Self>) -> Result<Vc<ModuleReferences>> {\n+        let (esm_references, part_references) = self.await?.specific_references().await?;\n+        let references = esm_references\n+            .await?\n+            .iter()\n+            .map(|r| ResolvedVc::upcast(*r))\n+            .chain(part_references.iter().map(|r| ResolvedVc::upcast(*r)))\n+            .collect();\n         Ok(Vc::cell(references))\n     }\n \n@@ -264,6 +188,51 @@ impl Asset for EcmascriptModuleFacadeModule {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl EcmascriptAnalyzable for EcmascriptModuleFacadeModule {\n+    #[turbo_tasks::function]\n+    fn analyze(&self) -> Result<Vc<AnalyzeEcmascriptModuleResult>> {\n+        bail!(\"EcmascriptModuleFacadeModule::analyze shouldn't be called\");\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn module_content_without_analysis(\n+        &self,\n+        _generate_source_map: bool,\n+    ) -> Result<Vc<EcmascriptModuleContent>> {\n+        bail!(\"EcmascriptModuleFacadeModule::module_content_without_analysis shouldn't be called\");\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn module_content(\n+        self: Vc<Self>,\n+        module_graph: ResolvedVc<ModuleGraph>,\n+        chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+        async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n+    ) -> Result<Vc<EcmascriptModuleContent>> {\n+        let (esm_references, part_references) = self.await?.specific_references().await?;\n+\n+        Ok(EcmascriptModuleContent::new(\n+            EcmascriptModuleContentOptions {\n+                parsed: ParseResult::empty().to_resolved().await?,\n+                ident: self.ident().to_resolved().await?,\n+                specified_module_type: SpecifiedModuleType::EcmaScript,\n+                module_graph,\n+                chunking_context,\n+                references: self.references().to_resolved().await?,\n+                esm_references,\n+                part_references,\n+                code_generation: CodeGens::empty().to_resolved().await?,\n+                async_module: ResolvedVc::cell(Some(self.async_module().to_resolved().await?)),\n+                generate_source_map: false,\n+                original_source_map: OptionStringifiedSourceMap::none().to_resolved().await?,\n+                exports: self.get_exports().to_resolved().await?,\n+                async_module_info,\n+            },\n+        ))\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl EcmascriptChunkPlaceable for EcmascriptModuleFacadeModule {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "2c43d87307b415fcd297f7010a024733b3ddf09b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/locals/chunk_item.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 29,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs?ref=43a4c628f877df7c1867cc12c061d90487440790",
            "patch": "@@ -9,11 +9,8 @@ use turbopack_core::{\n \n use super::module::EcmascriptModuleLocalsModule;\n use crate::{\n-    chunk::{\n-        EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkPlaceable,\n-        EcmascriptChunkType,\n-    },\n-    EcmascriptModuleContent, EcmascriptModuleContentOptions,\n+    chunk::{EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkType},\n+    EcmascriptAnalyzable,\n };\n \n /// The chunk item for [EcmascriptModuleLocalsModule].\n@@ -34,41 +31,22 @@ impl EcmascriptChunkItem for EcmascriptModuleLocalsChunkItem {\n     #[turbo_tasks::function]\n     async fn content_with_async_module_info(\n         &self,\n-        async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n+        async_module_info: Option<Vc<AsyncModuleInfo>>,\n     ) -> Result<Vc<EcmascriptChunkItemContent>> {\n         let module = self.module.await?;\n         let chunking_context = self.chunking_context;\n         let module_graph = self.module_graph;\n-        let exports = self.module.get_exports().to_resolved().await?;\n         let original_module = module.module;\n-        let parsed = original_module.parse().to_resolved().await?;\n \n         let analyze = original_module.analyze();\n         let analyze_result = analyze.await?;\n         let async_module_options = analyze_result\n             .async_module\n-            .module_options(async_module_info.map(|info| *info));\n+            .module_options(async_module_info);\n \n-        let module_type_result = *original_module.determine_module_type().await?;\n-        let generate_source_map = *chunking_context\n-            .reference_module_source_maps(*ResolvedVc::upcast(self.module))\n-            .await?;\n-\n-        let content = EcmascriptModuleContent::new(EcmascriptModuleContentOptions {\n-            parsed,\n-            ident: self.module.ident().to_resolved().await?,\n-            specified_module_type: module_type_result.module_type,\n-            module_graph,\n-            chunking_context,\n-            references: analyze.local_references().to_resolved().await?,\n-            esm_references: analyze_result.esm_local_references,\n-            code_generation: analyze_result.code_generation,\n-            async_module: analyze_result.async_module,\n-            generate_source_map,\n-            original_source_map: analyze_result.source_map,\n-            exports,\n-            async_module_info,\n-        });\n+        let content =\n+            self.module\n+                .module_content(*module_graph, *chunking_context, async_module_info);\n \n         Ok(EcmascriptChunkItemContent::new(\n             content,"
        },
        {
            "sha": "ec0f7b7f00a615c3c8e772f61ce3d8e4fc187977",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/locals/module.rs",
            "status": "modified",
            "additions": 59,
            "deletions": 2,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fmodule.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fmodule.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fmodule.rs?ref=43a4c628f877df7c1867cc12c061d90487440790",
            "patch": "@@ -5,7 +5,7 @@ use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::glob::Glob;\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n-    chunk::{ChunkableModule, ChunkingContext},\n+    chunk::{AsyncModuleInfo, ChunkableModule, ChunkingContext},\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n@@ -20,7 +20,8 @@ use crate::{\n         async_module::OptionAsyncModule,\n         esm::{EsmExport, EsmExports},\n     },\n-    EcmascriptModuleAsset,\n+    AnalyzeEcmascriptModuleResult, EcmascriptAnalyzable, EcmascriptModuleAsset,\n+    EcmascriptModuleContent, EcmascriptModuleContentOptions,\n };\n \n /// A module derived from an original ecmascript module that only contains the\n@@ -74,6 +75,62 @@ impl Asset for EcmascriptModuleLocalsModule {\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl EcmascriptAnalyzable for EcmascriptModuleLocalsModule {\n+    #[turbo_tasks::function]\n+    fn analyze(&self) -> Vc<AnalyzeEcmascriptModuleResult> {\n+        self.module.analyze()\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn module_content_without_analysis(\n+        &self,\n+        generate_source_map: bool,\n+    ) -> Vc<EcmascriptModuleContent> {\n+        self.module\n+            .module_content_without_analysis(generate_source_map)\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn module_content(\n+        self: Vc<Self>,\n+        module_graph: ResolvedVc<ModuleGraph>,\n+        chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+        async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n+    ) -> Result<Vc<EcmascriptModuleContent>> {\n+        let exports = self.get_exports().to_resolved().await?;\n+        let original_module = self.await?.module;\n+        let parsed = original_module.parse().to_resolved().await?;\n+\n+        let analyze = original_module.analyze();\n+        let analyze_result = analyze.await?;\n+\n+        let module_type_result = *original_module.determine_module_type().await?;\n+        let generate_source_map = *chunking_context\n+            .reference_module_source_maps(Vc::upcast(self))\n+            .await?;\n+\n+        Ok(EcmascriptModuleContent::new(\n+            EcmascriptModuleContentOptions {\n+                parsed,\n+                ident: self.ident().to_resolved().await?,\n+                specified_module_type: module_type_result.module_type,\n+                module_graph,\n+                chunking_context,\n+                references: analyze.local_references().to_resolved().await?,\n+                esm_references: analyze_result.esm_local_references,\n+                part_references: vec![],\n+                code_generation: analyze_result.code_generation,\n+                async_module: analyze_result.async_module,\n+                generate_source_map,\n+                original_source_map: analyze_result.source_map,\n+                exports,\n+                async_module_info,\n+            },\n+        ))\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl EcmascriptChunkPlaceable for EcmascriptModuleLocalsModule {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "519f7d1dee87cbbc83d9465aea2f0a2ddf43f8de",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/reference.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Freference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Freference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Freference.rs?ref=43a4c628f877df7c1867cc12c061d90487440790",
            "patch": "@@ -8,7 +8,6 @@ use turbopack_core::{\n         ModuleChunkItemIdExt,\n     },\n     module::Module,\n-    module_graph::ModuleGraph,\n     reference::ModuleReference,\n     resolve::{ModulePart, ModuleResolveResult},\n };\n@@ -110,7 +109,6 @@ impl ChunkableModuleReference for EcmascriptModulePartReference {\n impl EcmascriptModulePartReference {\n     pub async fn code_generation(\n         self: Vc<Self>,\n-        _module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n     ) -> Result<CodeGeneration> {\n         let referenced_asset = ReferencedAsset::from_resolve_result(self.resolve_reference());"
        },
        {
            "sha": "8ab5461c9f30e633213f836a6e5c86b1c3cc2e2d",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/asset.rs",
            "status": "modified",
            "additions": 41,
            "deletions": 9,
            "changes": 50,
            "blob_url": "https://github.com/vercel/next.js/blob/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs?ref=43a4c628f877df7c1867cc12c061d90487440790",
            "patch": "@@ -26,7 +26,8 @@ use crate::{\n     side_effect_optimization::facade::module::EcmascriptModuleFacadeModule,\n     tree_shake::{side_effect_module::SideEffectsModule, Key},\n     AnalyzeEcmascriptModuleResult, EcmascriptAnalyzable, EcmascriptModuleAsset,\n-    EcmascriptModuleAssetType, EcmascriptModuleContent, EcmascriptParsable,\n+    EcmascriptModuleAssetType, EcmascriptModuleContent, EcmascriptModuleContentOptions,\n+    EcmascriptParsable,\n };\n \n /// A reference to part of an ES module.\n@@ -74,14 +75,45 @@ impl EcmascriptAnalyzable for EcmascriptModulePartAsset {\n     }\n \n     #[turbo_tasks::function]\n-    fn module_content(\n-        &self,\n-        module_graph: Vc<ModuleGraph>,\n-        chunking_context: Vc<Box<dyn ChunkingContext>>,\n-        async_module_info: Option<Vc<AsyncModuleInfo>>,\n-    ) -> Vc<EcmascriptModuleContent> {\n-        self.full_module\n-            .module_content(module_graph, chunking_context, async_module_info)\n+    async fn module_content(\n+        self: Vc<Self>,\n+        module_graph: ResolvedVc<ModuleGraph>,\n+        chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+        async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n+    ) -> Result<Vc<EcmascriptModuleContent>> {\n+        let module = self.await?;\n+\n+        let split_data = split_module(*module.full_module);\n+        let parsed = part_of_module(split_data, module.part.clone())\n+            .to_resolved()\n+            .await?;\n+\n+        let analyze = self.analyze();\n+        let analyze_ref = analyze.await?;\n+\n+        let module_type_result = *module.full_module.determine_module_type().await?;\n+        let generate_source_map = *chunking_context\n+            .reference_module_source_maps(Vc::upcast(self))\n+            .await?;\n+\n+        Ok(EcmascriptModuleContent::new(\n+            EcmascriptModuleContentOptions {\n+                parsed,\n+                ident: self.ident().to_resolved().await?,\n+                specified_module_type: module_type_result.module_type,\n+                module_graph,\n+                chunking_context,\n+                references: analyze.references().to_resolved().await?,\n+                esm_references: analyze_ref.esm_references,\n+                part_references: vec![],\n+                code_generation: analyze_ref.code_generation,\n+                async_module: analyze_ref.async_module,\n+                generate_source_map,\n+                original_source_map: analyze_ref.source_map,\n+                exports: analyze_ref.exports,\n+                async_module_info,\n+            },\n+        ))\n     }\n }\n "
        },
        {
            "sha": "c02f8b2b70c6f3ac20a90cfca738ca5ff487a012",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/chunk_item.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 35,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/43a4c628f877df7c1867cc12c061d90487440790/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs?ref=43a4c628f877df7c1867cc12c061d90487440790",
            "patch": "@@ -8,7 +8,7 @@ use turbopack_core::{\n     module_graph::ModuleGraph,\n };\n \n-use super::{asset::EcmascriptModulePartAsset, part_of_module, split_module};\n+use super::asset::EcmascriptModulePartAsset;\n use crate::{\n     chunk::{\n         EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkItemOptions,\n@@ -18,7 +18,7 @@ use crate::{\n     runtime_functions::{TURBOPACK_EXPORT_NAMESPACE, TURBOPACK_IMPORT},\n     tree_shake::side_effect_module::SideEffectsModule,\n     utils::StringifyModuleId,\n-    EcmascriptModuleContent, EcmascriptModuleContentOptions,\n+    EcmascriptAnalyzable,\n };\n \n /// This is an implementation of [ChunkItem] for\n@@ -42,47 +42,22 @@ impl EcmascriptChunkItem for EcmascriptModulePartChunkItem {\n     #[turbo_tasks::function]\n     async fn content_with_async_module_info(\n         &self,\n-        async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n+        async_module_info: Option<Vc<AsyncModuleInfo>>,\n     ) -> Result<Vc<EcmascriptChunkItemContent>> {\n-        let module = self.module.await?;\n-\n-        let split_data = split_module(*module.full_module);\n-        let parsed = part_of_module(split_data, module.part.clone())\n-            .to_resolved()\n-            .await?;\n-\n         let analyze = self.module.analyze();\n         let analyze_ref = analyze.await?;\n-        let async_module_options = analyze_ref\n-            .async_module\n-            .module_options(async_module_info.map(|info| *info));\n-\n-        let module_type_result = *module.full_module.determine_module_type().await?;\n-        let generate_source_map = *self\n-            .chunking_context\n-            .reference_module_source_maps(*ResolvedVc::upcast(self.module))\n-            .await?;\n-\n-        let content = EcmascriptModuleContent::new(EcmascriptModuleContentOptions {\n-            parsed,\n-            ident: self.module.ident().to_resolved().await?,\n-            specified_module_type: module_type_result.module_type,\n-            module_graph: self.module_graph,\n-            chunking_context: self.chunking_context,\n-            references: analyze.references().to_resolved().await?,\n-            esm_references: analyze_ref.esm_references,\n-            code_generation: analyze_ref.code_generation,\n-            async_module: analyze_ref.async_module,\n-            generate_source_map,\n-            original_source_map: analyze_ref.source_map,\n-            exports: analyze_ref.exports,\n+        let async_module_options = analyze_ref.async_module.module_options(async_module_info);\n+\n+        let content = self.module.module_content(\n+            *self.module_graph,\n+            *self.chunking_context,\n             async_module_info,\n-        });\n+        );\n \n         Ok(EcmascriptChunkItemContent::new(\n             content,\n             *self.chunking_context,\n-            *module.full_module.await?.options,\n+            *self.module.await?.full_module.await?.options,\n             async_module_options,\n         ))\n     }"
        }
    ],
    "stats": {
        "total": 638,
        "additions": 324,
        "deletions": 314
    }
}