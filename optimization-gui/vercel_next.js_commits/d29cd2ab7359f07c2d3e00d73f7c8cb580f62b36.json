{
    "author": "bgw",
    "message": "Turbopack: Replace heuristics for detecting manually-configured sass or babel loaders with less-fragile ones, configure rules as a vec and not a map (#83131)\n\n- There was very fragile logic in the sass and babel loaders for trying to detect existing configuration and extend them. I've replaced this with some more advanced heuristics and a warning. See also: https://vercel.slack.com/archives/C03EWR7LGEN/p1756320263002989\n  - The old logic would break if you used any globs other than the *exact* ones that the code expected.\n  - Some of this was probably motivated by the map data structure used, which didn't allow duplicate globs as keys.\n  - The new logic tries to look for a combination of globs and/or loader names, and is only used to control a warning, not to change any behavior.\n\n- Convert rules to a vec instead of a map. This lets us duplicate `glob` keys, which will make supporting the array syntax proposed in #82857 (not implemented there, will come later) easier. Eventually these get turned into an array anyways when `ModuleOptions::new()` is run.\n\n- Remove the `OptionWebpackRules` wrapper type. We can just use an empty `Vec` to represent the `None` state, as they're logically equivalent, and an empty `Vec` requires zero heap allocations. This simplifies the code and reduces the number of cells we need to create.\n\n- Add a couple experimental options for force-disabling the auto-configured babel and sass loaders, as an escape hatch. It seems pretty unlikely that many people will need this, so I'm not spending much time/effort on it. This at least seems better than the previous implicit check.\n  - This might be useful for somebody who wants to use a `babelrc` with webpack, but not with Turbopack.",
    "sha": "d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36",
    "files": [
        {
            "sha": "a3df5323034bdda4778d5bbc75347bcb9c363a0d",
            "filename": "crates/next-core/src/next_client/context.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs?ref=d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36",
            "patch": "@@ -248,11 +248,11 @@ pub async fn get_client_module_options_context(\n     let mut foreign_conditions = loader_conditions.clone();\n     foreign_conditions.insert(WebpackLoaderBuiltinCondition::Foreign);\n     let foreign_enable_webpack_loaders =\n-        webpack_loader_options(project_path.clone(), next_config, foreign_conditions).await?;\n+        *webpack_loader_options(project_path.clone(), next_config, foreign_conditions).await?;\n \n     // Now creates a webpack rules that applies to all code.\n     let enable_webpack_loaders =\n-        webpack_loader_options(project_path.clone(), next_config, loader_conditions).await?;\n+        *webpack_loader_options(project_path.clone(), next_config, loader_conditions).await?;\n \n     let tree_shaking_mode_for_user_code = *next_config\n         .tree_shaking_mode_for_user_code(next_mode.is_development())"
        },
        {
            "sha": "3f45a79727294d20e922326b49ba1ffad2355660",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 10,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36",
            "patch": "@@ -14,7 +14,7 @@ use turbo_tasks_env::{EnvMap, ProcessEnv};\n use turbo_tasks_fetch::FetchClient;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::module_options::{\n-    ConditionItem, ConditionPath, LoaderRuleItem, OptionWebpackRules,\n+    ConditionItem, ConditionPath, LoaderRuleItem, WebpackRules,\n     module_options_context::{MdxTransformOptions, OptionWebpackConditions},\n };\n use turbopack_core::{\n@@ -868,6 +868,13 @@ pub struct ExperimentalConfig {\n     turbopack_tree_shaking: Option<bool>,\n     turbopack_scope_hoisting: Option<bool>,\n     turbopack_use_system_tls_certs: Option<bool>,\n+    /// Disable automatic configuration of the sass loader.\n+    #[serde(default)]\n+    turbopack_use_builtin_sass: Option<bool>,\n+    /// Disable automatic configuration of the babel loader when a babel configuration file is\n+    /// present.\n+    #[serde(default)]\n+    turbopack_use_builtin_babel: Option<bool>,\n     // Whether to enable the global-not-found convention\n     global_not_found: Option<bool>,\n     /// Defaults to false in development mode, true in production mode.\n@@ -1377,14 +1384,14 @@ impl NextConfig {\n         &self,\n         active_conditions: BTreeSet<WebpackLoaderBuiltinCondition>,\n         project_path: FileSystemPath,\n-    ) -> Result<Vc<OptionWebpackRules>> {\n+    ) -> Result<Vc<WebpackRules>> {\n         let Some(turbo_rules) = self.turbopack.as_ref().and_then(|t| t.rules.as_ref()) else {\n-            return Ok(Vc::cell(None));\n+            return Ok(Vc::cell(Vec::new()));\n         };\n         if turbo_rules.is_empty() {\n-            return Ok(Vc::cell(None));\n+            return Ok(Vc::cell(Vec::new()));\n         }\n-        let mut rules = FxIndexMap::default();\n+        let mut rules = Vec::new();\n         for (glob, rule) in turbo_rules.iter() {\n             fn transform_loaders(loaders: &[LoaderItem]) -> ResolvedVc<WebpackLoaderItems> {\n                 ResolvedVc::cell(\n@@ -1440,14 +1447,14 @@ impl NextConfig {\n             let config_file_path = || project_path.join(&self.config_file_name);\n             match rule {\n                 RuleConfigItemOrShortcut::Loaders(loaders) => {\n-                    rules.insert(\n+                    rules.push((\n                         glob.clone(),\n                         LoaderRuleItem {\n                             loaders: transform_loaders(loaders),\n                             rename_as: None,\n                             condition: None,\n                         },\n-                    );\n+                    ));\n                 }\n                 RuleConfigItemOrShortcut::Advanced(rule) => {\n                     if let FindRuleResult::Found(RuleConfigItemOptions {\n@@ -1489,19 +1496,19 @@ impl NextConfig {\n                             None\n                         };\n \n-                        rules.insert(\n+                        rules.push((\n                             glob.clone(),\n                             LoaderRuleItem {\n                                 loaders: transform_loaders(loaders),\n                                 rename_as: rename_as.clone(),\n                                 condition,\n                             },\n-                        );\n+                        ));\n                     }\n                 }\n             }\n         }\n-        Ok(Vc::cell(Some(ResolvedVc::cell(rules))))\n+        Ok(Vc::cell(rules))\n     }\n \n     #[turbo_tasks::function]\n@@ -1638,6 +1645,16 @@ impl NextConfig {\n         })\n     }\n \n+    #[turbo_tasks::function]\n+    pub fn experimental_turbopack_use_builtin_babel(&self) -> Vc<Option<bool>> {\n+        Vc::cell(self.experimental.turbopack_use_builtin_babel)\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub fn experimental_turbopack_use_builtin_sass(&self) -> Vc<Option<bool>> {\n+        Vc::cell(self.experimental.turbopack_use_builtin_sass)\n+    }\n+\n     #[turbo_tasks::function]\n     pub fn react_compiler(&self) -> Vc<OptionalReactCompilerOptions> {\n         let options = &self.experimental.react_compiler;"
        },
        {
            "sha": "7b054f9b89ec8fce154f6255545f8b9d27ff50a3",
            "filename": "crates/next-core/src/next_server/context.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fcontext.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fcontext.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fcontext.rs?ref=d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36",
            "patch": "@@ -493,11 +493,11 @@ pub async fn get_server_module_options_context(\n     let mut foreign_conditions = loader_conditions.clone();\n     foreign_conditions.insert(WebpackLoaderBuiltinCondition::Foreign);\n     let foreign_enable_webpack_loaders =\n-        webpack_loader_options(project_path.clone(), next_config, foreign_conditions).await?;\n+        *webpack_loader_options(project_path.clone(), next_config, foreign_conditions).await?;\n \n     // Now creates a webpack rules that applies to all code.\n     let enable_webpack_loaders =\n-        webpack_loader_options(project_path.clone(), next_config, loader_conditions).await?;\n+        *webpack_loader_options(project_path.clone(), next_config, loader_conditions).await?;\n \n     let tree_shaking_mode_for_user_code = *next_config\n         .tree_shaking_mode_for_user_code(next_mode.is_development())"
        },
        {
            "sha": "bbf499fe8456d03ef0b8b2318b9e79fdd9b64487",
            "filename": "crates/next-core/src/next_shared/webpack_rules/babel.rs",
            "status": "modified",
            "additions": 66,
            "deletions": 84,
            "changes": 150,
            "blob_url": "https://github.com/vercel/next.js/blob/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fbabel.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fbabel.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fbabel.rs?ref=d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36",
            "patch": "@@ -1,15 +1,20 @@\n+use std::sync::LazyLock;\n+\n use anyhow::Result;\n-use turbo_rcstr::rcstr;\n+use regex::Regex;\n+use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::{self, FileSystemEntryType, FileSystemPath};\n-use turbopack::module_options::{LoaderRuleItem, OptionWebpackRules, WebpackRules};\n+use turbopack::module_options::LoaderRuleItem;\n use turbopack_core::{\n     issue::{Issue, IssueExt, IssueSeverity, IssueStage, OptionStyledString, StyledString},\n     reference_type::{CommonJsReferenceSubType, ReferenceType},\n     resolve::{node::node_cjs_resolve_options, parse::Request, pattern::Pattern, resolve},\n };\n use turbopack_node::transforms::webpack::WebpackLoaderItem;\n \n+// https://babeljs.io/docs/config-files\n+// TODO: Also support a `babel` key in a package.json file\n const BABEL_CONFIG_FILES: &[&str] = &[\n     \".babelrc\",\n     \".babelrc.json\",\n@@ -22,94 +27,71 @@ const BABEL_CONFIG_FILES: &[&str] = &[\n     \"babel.config.cjs\",\n ];\n \n-/// If the user has a babel configuration file (see list above) alongside their\n-/// `next.config.js` configuration, automatically add `babel-loader` as a\n-/// webpack loader for each eligible file type if it doesn't already exist.\n-#[turbo_tasks::function]\n-pub async fn maybe_add_babel_loader(\n-    project_root: FileSystemPath,\n-    webpack_rules: Option<ResolvedVc<WebpackRules>>,\n-) -> Result<Vc<OptionWebpackRules>> {\n-    let has_babel_config = {\n-        let mut has_babel_config = false;\n-        for &filename in BABEL_CONFIG_FILES {\n-            let filetype = *project_root.join(filename)?.get_type().await?;\n-            if matches!(filetype, FileSystemEntryType::File) {\n-                has_babel_config = true;\n-                break;\n-            }\n-        }\n-        has_babel_config\n-    };\n+static BABEL_LOADER_RE: LazyLock<Regex> =\n+    LazyLock::new(|| Regex::new(r\"(^|/)@?babel[-/]loader($|/|\\.)\").unwrap());\n \n-    if has_babel_config {\n-        let mut rules = if let Some(webpack_rules) = webpack_rules {\n-            webpack_rules.owned().await?\n-        } else {\n-            Default::default()\n-        };\n-        let mut has_emitted_babel_resolve_issue = false;\n-        let mut has_changed = false;\n-        for pattern in [\"*.js\", \"*.jsx\", \"*.ts\", \"*.tsx\", \"*.cjs\", \"*.mjs\"] {\n-            let rule = rules.get_mut(pattern);\n-            let has_babel_loader = if let Some(rule) = rule.as_ref() {\n-                rule.loaders\n-                    .await?\n-                    .iter()\n-                    .any(|c| c.loader == \"babel-loader\")\n-            } else {\n-                false\n-            };\n-\n-            if !has_babel_loader {\n-                if !has_emitted_babel_resolve_issue\n-                    && !*is_babel_loader_available(project_root.clone()).await?\n-                {\n-                    BabelIssue {\n-                        path: project_root.clone(),\n-                        title: StyledString::Text(rcstr!(\n-                            \"Unable to resolve babel-loader, but a babel config is present\"\n-                        ))\n-                        .resolved_cell(),\n-                        description: StyledString::Text(rcstr!(\n-                            \"Make sure babel-loader is installed via your package manager.\"\n-                        ))\n-                        .resolved_cell(),\n-                        severity: IssueSeverity::Fatal,\n-                    }\n-                    .resolved_cell()\n-                    .emit();\n-\n-                    has_emitted_babel_resolve_issue = true;\n-                }\n+pub async fn detect_likely_babel_loader(\n+    webpack_rules: &[(RcStr, LoaderRuleItem)],\n+) -> Result<Option<RcStr>> {\n+    for (glob, rule) in webpack_rules {\n+        if rule\n+            .loaders\n+            .await?\n+            .iter()\n+            .any(|item| BABEL_LOADER_RE.is_match(&item.loader))\n+        {\n+            return Ok(Some(glob.clone()));\n+        }\n+    }\n+    Ok(None)\n+}\n \n-                let loader = WebpackLoaderItem {\n-                    loader: rcstr!(\"babel-loader\"),\n-                    options: Default::default(),\n-                };\n-                if let Some(rule) = rule {\n-                    let mut loaders = rule.loaders.owned().await?;\n-                    loaders.push(loader);\n-                    rule.loaders = ResolvedVc::cell(loaders);\n-                } else {\n-                    rules.insert(\n-                        pattern.into(),\n-                        LoaderRuleItem {\n-                            loaders: ResolvedVc::cell(vec![loader]),\n-                            rename_as: Some(rcstr!(\"*\")),\n-                            condition: None,\n-                        },\n-                    );\n-                }\n-                has_changed = true;\n-            }\n+/// If the user has a babel configuration file (see list above) alongside their `next.config.js`\n+/// configuration, automatically add `babel-loader` as a webpack loader for each eligible file type\n+/// if it doesn't already exist.\n+pub async fn get_babel_loader_rules(\n+    project_root: FileSystemPath,\n+) -> Result<Vec<(RcStr, LoaderRuleItem)>> {\n+    let mut has_babel_config = false;\n+    for &filename in BABEL_CONFIG_FILES {\n+        let filetype = *project_root.join(filename)?.get_type().await?;\n+        if matches!(filetype, FileSystemEntryType::File) {\n+            has_babel_config = true;\n+            break;\n         }\n+    }\n+    if !has_babel_config {\n+        return Ok(Vec::new());\n+    }\n \n-        if has_changed {\n-            return Ok(Vc::cell(Some(ResolvedVc::cell(rules))));\n+    if !*is_babel_loader_available(project_root.clone()).await? {\n+        BabelIssue {\n+            path: project_root.clone(),\n+            title: StyledString::Text(rcstr!(\n+                \"Unable to resolve babel-loader, but a babel config is present\"\n+            ))\n+            .resolved_cell(),\n+            description: StyledString::Text(rcstr!(\n+                \"Make sure babel-loader is installed via your package manager.\"\n+            ))\n+            .resolved_cell(),\n+            severity: IssueSeverity::Fatal,\n         }\n+        .resolved_cell()\n+        .emit();\n     }\n-    Ok(Vc::cell(webpack_rules))\n+\n+    Ok(vec![(\n+        rcstr!(\"*.{js,jsx,ts,tsx,cjs,mjs,mts,cts}\"),\n+        LoaderRuleItem {\n+            loaders: ResolvedVc::cell(vec![WebpackLoaderItem {\n+                loader: rcstr!(\"babel-loader\"),\n+                options: Default::default(),\n+            }]),\n+            rename_as: Some(rcstr!(\"*\")),\n+            condition: None,\n+        },\n+    )])\n }\n \n #[turbo_tasks::function]"
        },
        {
            "sha": "979078db445c61b50d9e0fdf7fcbaa018190ce5b",
            "filename": "crates/next-core/src/next_shared/webpack_rules/mod.rs",
            "status": "modified",
            "additions": 146,
            "deletions": 24,
            "changes": 170,
            "blob_url": "https://github.com/vercel/next.js/blob/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs?ref=d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36",
            "patch": "@@ -2,16 +2,24 @@ use std::{collections::BTreeSet, str::FromStr};\n \n use anyhow::Result;\n use serde::{Deserialize, Serialize};\n-use turbo_rcstr::rcstr;\n+use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{NonLocalValue, OperationValue, ResolvedVc, TaskInput, Vc, trace::TraceRawVcs};\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::module_options::{\n     WebpackLoaderBuiltinConditionSet, WebpackLoaderBuiltinConditionSetMatch, WebpackLoadersOptions,\n };\n-use turbopack_core::resolve::{ExternalTraced, ExternalType, options::ImportMapping};\n+use turbopack_core::{\n+    issue::{Issue, IssueExt, IssueSeverity, IssueStage, OptionStyledString, StyledString},\n+    resolve::{ExternalTraced, ExternalType, options::ImportMapping},\n+};\n \n-use self::{babel::maybe_add_babel_loader, sass::maybe_add_sass_loader};\n-use crate::next_config::NextConfig;\n+use crate::{\n+    next_config::NextConfig,\n+    next_shared::webpack_rules::{\n+        babel::{detect_likely_babel_loader, get_babel_loader_rules},\n+        sass::{detect_likely_sass_loader, get_sass_loader_rules},\n+    },\n+};\n \n pub(crate) mod babel;\n pub(crate) mod sass;\n@@ -131,35 +139,89 @@ impl WebpackLoaderBuiltinConditionSet for NextWebpackLoaderBuiltinConditionSet {\n     }\n }\n \n+#[turbo_tasks::value(transparent)]\n+pub struct OptionWebpackLoadersOptions(Option<ResolvedVc<WebpackLoadersOptions>>);\n+\n+#[turbo_tasks::function]\n pub async fn webpack_loader_options(\n     project_path: FileSystemPath,\n     next_config: Vc<NextConfig>,\n     builtin_conditions: BTreeSet<WebpackLoaderBuiltinCondition>,\n-) -> Result<Option<ResolvedVc<WebpackLoadersOptions>>> {\n-    let mut rules = *next_config\n+) -> Result<Vc<OptionWebpackLoadersOptions>> {\n+    let mut rules = next_config\n         .webpack_rules(builtin_conditions.clone(), project_path.clone())\n+        .owned()\n         .await?;\n-    rules = *maybe_add_sass_loader(next_config.sass_config(), rules.map(|v| *v)).await?;\n-    if !builtin_conditions.contains(&WebpackLoaderBuiltinCondition::Foreign) {\n-        rules = *maybe_add_babel_loader(project_path.clone(), rules.map(|v| *v)).await?;\n+\n+    let config_file_path = async || project_path.join(&next_config.await?.config_file_name);\n+\n+    let use_builtin_sass = next_config\n+        .experimental_turbopack_use_builtin_sass()\n+        .await?;\n+    if use_builtin_sass.unwrap_or(true) {\n+        if use_builtin_sass.is_none()\n+            && let Some(glob) = detect_likely_sass_loader(&rules).await?\n+        {\n+            ManuallyConfiguredBuiltinLoaderIssue {\n+                glob,\n+                loader: rcstr!(\"sass-loader\"),\n+                config_key: rcstr!(\"experimental.turbopackUseBuiltinSass\"),\n+                config_file_path: config_file_path().await?,\n+            }\n+            .resolved_cell()\n+            .emit()\n+        }\n+        rules.append(&mut get_sass_loader_rules(next_config.sass_config()).await?);\n     }\n \n-    let conditions = next_config.webpack_conditions().to_resolved().await?;\n-    Ok(if let Some(rules) = rules {\n-        Some(\n-            WebpackLoadersOptions {\n-                rules,\n-                conditions,\n-                loader_runner_package: Some(loader_runner_package_mapping().to_resolved().await?),\n-                builtin_conditions: NextWebpackLoaderBuiltinConditionSet::new(builtin_conditions)\n-                    .to_resolved()\n-                    .await?,\n+    // TODO: Enable this warning after babel configuration is fixed\n+    // (https://github.com/vercel/next.js/pull/82676) and the react-compiler logic is moved into\n+    // here. React-compiler is currently configured in JS before it gets to us, which could trigger\n+    // false-positives.\n+    let use_builtin_babel = next_config\n+        .experimental_turbopack_use_builtin_babel()\n+        .await?;\n+    if !builtin_conditions.contains(&WebpackLoaderBuiltinCondition::Foreign)\n+        && use_builtin_babel.unwrap_or(true)\n+    {\n+        if use_builtin_babel.is_none()\n+            && let Some(glob) = detect_likely_babel_loader(&rules).await?\n+        {\n+            let _ = glob;\n+            // TODO: Enable this warning after babel configuration is fixed\n+            // (https://github.com/vercel/next.js/pull/82676) and the react-compiler logic is moved into\n+            // here. React-compiler is currently configured in JS before it gets to us, which could\n+            // trigger false-positives.\n+            /*\n+            ManuallyConfiguredBuiltinLoaderIssue {\n+                glob,\n+                loader: rcstr!(\"babel-loader\"),\n+                disable_builtin_config_key: rcstr!(\"experimental.turbopackUseBuiltinBabel\"),\n+                config_file_path: config_file_path().await?,\n             }\n-            .resolved_cell(),\n-        )\n-    } else {\n-        None\n-    })\n+            .resolved_cell()\n+            .emit()\n+            */\n+        }\n+        rules.append(&mut get_babel_loader_rules(project_path.clone()).await?);\n+    }\n+\n+    if rules.is_empty() {\n+        return Ok(Vc::cell(None));\n+    }\n+\n+    let conditions = next_config.webpack_conditions().to_resolved().await?;\n+    Ok(Vc::cell(Some(\n+        WebpackLoadersOptions {\n+            rules: ResolvedVc::cell(rules),\n+            conditions,\n+            loader_runner_package: Some(loader_runner_package_mapping().to_resolved().await?),\n+            builtin_conditions: NextWebpackLoaderBuiltinConditionSet::new(builtin_conditions)\n+                .to_resolved()\n+                .await?,\n+        }\n+        .resolved_cell(),\n+    )))\n }\n \n #[turbo_tasks::function]\n@@ -174,3 +236,63 @@ fn loader_runner_package_mapping() -> Result<Vc<ImportMapping>> {\n     ])\n     .cell())\n }\n+\n+#[turbo_tasks::value]\n+struct ManuallyConfiguredBuiltinLoaderIssue {\n+    glob: RcStr,\n+    loader: RcStr,\n+    config_key: RcStr,\n+    config_file_path: FileSystemPath,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Issue for ManuallyConfiguredBuiltinLoaderIssue {\n+    fn severity(&self) -> IssueSeverity {\n+        IssueSeverity::Warning\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn file_path(&self) -> Vc<FileSystemPath> {\n+        self.config_file_path.clone().cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn stage(&self) -> Vc<IssueStage> {\n+        IssueStage::Config.cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn title(&self) -> Vc<StyledString> {\n+        StyledString::Line(vec![\n+            StyledString::Text(rcstr!(\"Identified a likely manual configuration of \")),\n+            StyledString::Code(self.loader.clone()),\n+            StyledString::Text(rcstr!(\" for paths matching \")),\n+            StyledString::Code(self.glob.clone()),\n+        ])\n+        .cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn description(&self) -> Vc<OptionStyledString> {\n+        Vc::cell(Some(\n+            StyledString::Stack(vec![\n+                StyledString::Text(rcstr!(\n+                    \"Next.js includes a built-in version of this loader that is configured \\\n+                     automatically. You may not need to configure this.\"\n+                )),\n+                StyledString::Line(vec![\n+                    StyledString::Text(rcstr!(\"You can silence this warning by setting \")),\n+                    StyledString::Code(self.config_key.clone()),\n+                    StyledString::Text(rcstr!(\" in \")),\n+                    StyledString::Text(self.config_file_path.path.clone()),\n+                    StyledString::Text(rcstr!(\" to \")),\n+                    StyledString::Code(rcstr!(\"true\")),\n+                    StyledString::Text(rcstr!(\" (to silence this warning) or \")),\n+                    StyledString::Code(rcstr!(\"false\")),\n+                    StyledString::Text(rcstr!(\" (to disable the default built-in loader)\")),\n+                ]),\n+            ])\n+            .resolved_cell(),\n+        ))\n+    }\n+}"
        },
        {
            "sha": "55fd50d7a1b65d153bd6b2b70bbbee05034d96d6",
            "filename": "crates/next-core/src/next_shared/webpack_rules/sass.rs",
            "status": "modified",
            "additions": 120,
            "deletions": 71,
            "changes": 191,
            "blob_url": "https://github.com/vercel/next.js/blob/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fsass.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fsass.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fsass.rs?ref=d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36",
            "patch": "@@ -1,21 +1,47 @@\n-use std::mem::take;\n+use std::{mem::take, sync::LazyLock};\n \n use anyhow::{Result, bail};\n+use regex::Regex;\n use serde_json::Value as JsonValue;\n-use turbo_rcstr::rcstr;\n+use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, Vc};\n-use turbopack::module_options::{LoaderRuleItem, OptionWebpackRules, WebpackRules};\n+use turbopack::module_options::LoaderRuleItem;\n use turbopack_node::transforms::webpack::WebpackLoaderItem;\n \n-#[turbo_tasks::function]\n-pub async fn maybe_add_sass_loader(\n+// Try to match any reasonably-written glob pattern that might be intended to match `*.sass` or\n+// `*.scss` (e.g. isn't just a full wildcard match with no extension)\n+static SASS_GLOB_RE: LazyLock<Regex> = LazyLock::new(|| {\n+    Regex::new(r\"([\\.*\\}]|\\{([^\\}]*,)?)s([ac]|\\[[ac]{2}\\]|\\{[ac,]{3}\\})ss(,[^\\}]*\\}|\\})?$\").unwrap()\n+});\n+\n+static SASS_LOADER_RE: LazyLock<Regex> =\n+    LazyLock::new(|| Regex::new(r\"(^|/)@?sass[-/]loader($|/|\\.)\").unwrap());\n+\n+pub async fn detect_likely_sass_loader(\n+    webpack_rules: &[(RcStr, LoaderRuleItem)],\n+) -> Result<Option<RcStr>> {\n+    for (glob, rule) in webpack_rules {\n+        if SASS_GLOB_RE.is_match(glob)\n+            || rule\n+                .loaders\n+                .await?\n+                .iter()\n+                .any(|item| SASS_LOADER_RE.is_match(&item.loader))\n+        {\n+            return Ok(Some(glob.clone()));\n+        }\n+    }\n+    Ok(None)\n+}\n+\n+pub async fn get_sass_loader_rules(\n     sass_options: Vc<JsonValue>,\n-    webpack_rules: Option<Vc<WebpackRules>>,\n-) -> Result<Vc<OptionWebpackRules>> {\n+) -> Result<Vec<(RcStr, LoaderRuleItem)>> {\n     let sass_options = sass_options.await?;\n     let Some(mut sass_options) = sass_options.as_object().cloned() else {\n         bail!(\"sass_options must be an object\");\n     };\n+\n     // TODO: Remove this once we upgrade to sass-loader 16\n     let silence_deprecations = if let Some(v) = sass_options.get(\"silenceDeprecations\") {\n         v.clone()\n@@ -24,74 +50,97 @@ pub async fn maybe_add_sass_loader(\n     };\n \n     sass_options.insert(\"silenceDeprecations\".into(), silence_deprecations);\n-    let mut rules = if let Some(webpack_rules) = webpack_rules {\n-        webpack_rules.owned().await?\n-    } else {\n-        Default::default()\n+\n+    // additionalData is a loader option but Next.js has it under `sassOptions` in\n+    // `next.config.js`\n+    let additional_data = sass_options\n+        .get(\"prependData\")\n+        .or(sass_options.get(\"additionalData\"));\n+    let sass_loader = WebpackLoaderItem {\n+        loader: rcstr!(\"next/dist/compiled/sass-loader\"),\n+        options: take(\n+            serde_json::json!({\n+                \"implementation\": sass_options.get(\"implementation\"),\n+                \"sourceMap\": true,\n+                \"sassOptions\": sass_options,\n+                \"additionalData\": additional_data\n+            })\n+            .as_object_mut()\n+            .unwrap(),\n+        ),\n     };\n+    let resolve_url_loader = WebpackLoaderItem {\n+        loader: rcstr!(\"next/dist/build/webpack/loaders/resolve-url-loader/index\"),\n+        options: take(\n+            serde_json::json!({\n+                // https://github.com/vercel/turbo/blob/d527eb54be384a4658243304cecd547d09c05c6b/crates/turbopack-node/src/transforms/webpack.rs#L191\n+                \"sourceMap\": true\n+            })\n+            .as_object_mut()\n+            .unwrap(),\n+        ),\n+    };\n+\n+    let loaders = ResolvedVc::cell(vec![resolve_url_loader, sass_loader]);\n+\n+    let mut rules = Vec::new();\n+\n     for (pattern, rename) in [\n-        (\"*.module.scss\", \".module.css\"),\n-        (\"*.module.sass\", \".module.css\"),\n-        (\"*.scss\", \".css\"),\n-        (\"*.sass\", \".css\"),\n+        (rcstr!(\"*.module.s[ac]ss\"), rcstr!(\"*.module.css\")),\n+        (rcstr!(\"*.s[ac]ss\"), rcstr!(\"*.css\")),\n     ] {\n-        // additionalData is a loader option but Next.js has it under `sassOptions` in\n-        // `next.config.js`\n-        let additional_data = sass_options\n-            .get(\"prependData\")\n-            .or(sass_options.get(\"additionalData\"));\n-        let rule = rules.get_mut(pattern);\n-        let sass_loader = WebpackLoaderItem {\n-            loader: rcstr!(\"next/dist/compiled/sass-loader\"),\n-            options: take(\n-                serde_json::json!({\n-                    \"implementation\": sass_options.get(\"implementation\"),\n-                    \"sourceMap\": true,\n-                    \"sassOptions\": sass_options,\n-                    \"additionalData\": additional_data\n-                })\n-                .as_object_mut()\n-                .unwrap(),\n-            ),\n-        };\n-        let resolve_url_loader = WebpackLoaderItem {\n-            loader: rcstr!(\"next/dist/build/webpack/loaders/resolve-url-loader/index\"),\n-            options: take(\n-                serde_json::json!({\n-                    //https://github.com/vercel/turbo/blob/d527eb54be384a4658243304cecd547d09c05c6b/crates/turbopack-node/src/transforms/webpack.rs#L191\n-                    \"sourceMap\": true\n-                })\n-                .as_object_mut()\n-                .unwrap(),\n-            ),\n-        };\n-\n-        if let Some(rule) = rule {\n-            // Without `as`, loader result would be JS code, so we don't want to apply\n-            // sass-loader on that.\n-            let Some(rename_as) = rule.rename_as.as_ref() else {\n-                continue;\n-            };\n-            // Only when the result should run through the sass pipeline, we apply\n-            // sass-loader.\n-            if rename_as != \"*\" {\n-                continue;\n-            }\n-            let mut loaders = rule.loaders.owned().await?;\n-            loaders.push(resolve_url_loader);\n-            loaders.push(sass_loader);\n-            rule.loaders = ResolvedVc::cell(loaders);\n-        } else {\n-            rules.insert(\n-                pattern.into(),\n-                LoaderRuleItem {\n-                    loaders: ResolvedVc::cell(vec![resolve_url_loader, sass_loader]),\n-                    rename_as: Some(format!(\"*{rename}\").into()),\n-                    condition: None,\n-                },\n+        rules.push((\n+            pattern,\n+            LoaderRuleItem {\n+                loaders,\n+                rename_as: Some(rename),\n+                condition: None,\n+            },\n+        ));\n+    }\n+\n+    Ok(rules)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_sass_glob_regex() {\n+        let valid_patterns = vec![\n+            \"foobar.scss\",\n+            \"foobar.sass\",\n+            // Bracket expansion\n+            \"*.s[ac]ss\",\n+            \"*.s[ca]ss\",\n+            // Brace expansion\n+            \"*.{scss}\",\n+            \"*.{sass}\",\n+            \"*.{ext,scss}\",\n+            \"*.{sass,ext}\",\n+            // Brace expansion of a/c\n+            \"*.s{a,c}ss\",\n+            \"*.s{c,a}ss\",\n+            \"*.{css,s{c,a}ss}\",\n+            // Following a brace expansion\n+            \"{foo.,bar.}sass\",\n+        ];\n+\n+        let invalid_patterns = vec![\"*\", \"*.css\", \"*.scss.css\", \"endswithsass\", \"endswithscss\"];\n+\n+        for pattern in valid_patterns {\n+            assert!(\n+                SASS_GLOB_RE.is_match(pattern),\n+                \"VALID pattern should match: {pattern:?}\",\n             );\n         }\n-    }\n \n-    Ok(Vc::cell(Some(ResolvedVc::cell(rules))))\n+        for pattern in invalid_patterns {\n+            assert!(\n+                !SASS_GLOB_RE.is_match(pattern),\n+                \"INVALID pattern should NOT match: {pattern:?}\",\n+            );\n+        }\n+    }\n }"
        },
        {
            "sha": "890e5484fbbf8d7c1d35abb428d05dca6c19ab4d",
            "filename": "packages/next/src/server/config-schema.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 23,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts?ref=d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36",
            "patch": "@@ -479,30 +479,9 @@ export const configSchema: zod.ZodType<NextConfig> = z.lazy(() =>\n         turbopackTreeShaking: z.boolean().optional(),\n         turbopackRemoveUnusedExports: z.boolean().optional(),\n         turbopackScopeHoisting: z.boolean().optional(),\n-        /**\n-         * Use the system-provided CA roots instead of bundled CA roots for external HTTPS requests\n-         * made by Turbopack. Currently this is only used for fetching data from Google Fonts.\n-         *\n-         * This may be useful in cases where you or an employer are MITMing traffic.\n-         *\n-         * This option is experimental because:\n-         * - This may cause small performance problems, as it uses [`rustls-native-certs`](\n-         *   https://github.com/rustls/rustls-native-certs).\n-         * - In the future, this may become the default, and this option may be eliminated, once\n-         *   <https://github.com/seanmonstar/reqwest/issues/2159> is resolved.\n-         *\n-         * Users who need to configure this behavior system-wide can override the project\n-         * configuration using the `NEXT_TURBOPACK_EXPERIMENTAL_USE_SYSTEM_TLS_CERTS=1` environment\n-         * variable.\n-         *\n-         * This option is ignored on Windows on ARM, where the native TLS implementation is always\n-         * used.\n-         *\n-         * If you need to set a proxy, Turbopack [respects the common `HTTP_PROXY` and `HTTPS_PROXY`\n-         * environment variable convention](https://docs.rs/reqwest/latest/reqwest/#proxies). HTTP\n-         * proxies are supported, SOCKS proxies are not currently supported.\n-         */\n         turbopackUseSystemTlsCerts: z.boolean().optional(),\n+        turbopackUseBuiltinBabel: z.boolean().optional(),\n+        turbopackUseBuiltinSass: z.boolean().optional(),\n         optimizePackageImports: z.array(z.string()).optional(),\n         optimizeServerReact: z.boolean().optional(),\n         clientTraceMetadata: z.array(z.string()).optional(),"
        },
        {
            "sha": "72697402488507060f2d09a5a960143fd0cf7a2f",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36",
            "patch": "@@ -612,6 +612,43 @@ export interface ExperimentalConfig {\n    */\n   turbopackRemoveUnusedExports?: boolean\n \n+  /**\n+   * Use the system-provided CA roots instead of bundled CA roots for external HTTPS requests\n+   * made by Turbopack. Currently this is only used for fetching data from Google Fonts.\n+   *\n+   * This may be useful in cases where you or an employer are MITMing traffic.\n+   *\n+   * This option is experimental because:\n+   * - This may cause small performance problems, as it uses [`rustls-native-certs`](\n+   *   https://github.com/rustls/rustls-native-certs).\n+   * - In the future, this may become the default, and this option may be eliminated, once\n+   *   <https://github.com/seanmonstar/reqwest/issues/2159> is resolved.\n+   *\n+   * Users who need to configure this behavior system-wide can override the project\n+   * configuration using the `NEXT_TURBOPACK_EXPERIMENTAL_USE_SYSTEM_TLS_CERTS=1` environment\n+   * variable.\n+   *\n+   * This option is ignored on Windows on ARM, where the native TLS implementation is always\n+   * used.\n+   *\n+   * If you need to set a proxy, Turbopack [respects the common `HTTP_PROXY` and `HTTPS_PROXY`\n+   * environment variable convention](https://docs.rs/reqwest/latest/reqwest/#proxies). HTTP\n+   * proxies are supported, SOCKS proxies are not currently supported.\n+   */\n+  turbopackUseSystemTlsCerts?: boolean\n+\n+  /**\n+   * Set this to `false` to disable the automatic configuration of the babel loader when a babel\n+   * configuration file is present. The babel loader configuration is enabled by default.\n+   */\n+  turbopackUseBuiltinBabel?: boolean\n+\n+  /**\n+   * Set this to `false` to disable the automatic configuration of the sass loader. The sass loader\n+   * configuration is enabled by default.\n+   */\n+  turbopackUseBuiltinSass?: boolean\n+\n   /**\n    * For use with `@next/mdx`. Compile MDX files using the new Rust compiler.\n    * @see https://nextjs.org/docs/app/api-reference/next-config-js/mdxRs"
        },
        {
            "sha": "2718d1b43f35b77a6c1d57e3f20180f359fe1c64",
            "filename": "turbopack/crates/turbo-tasks/src/primitives.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fprimitives.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fprimitives.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fprimitives.rs?ref=d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36",
            "patch": "@@ -17,6 +17,7 @@ __turbo_tasks_internal_primitive!(Vec<RcStr>, manual_shrink_to_fit);\n __turbo_tasks_internal_primitive!(Option<u16>);\n __turbo_tasks_internal_primitive!(Option<u64>);\n __turbo_tasks_internal_primitive!(bool);\n+__turbo_tasks_internal_primitive!(Option<bool>);\n __turbo_tasks_internal_primitive!(u8);\n __turbo_tasks_internal_primitive!(u16);\n __turbo_tasks_internal_primitive!(u32);"
        },
        {
            "sha": "b3ede7fbdfec2e223b705070670e0a62f1dabd8d",
            "filename": "turbopack/crates/turbopack/src/module_options/module_options_context.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs?ref=d29cd2ab7359f07c2d3e00d73f7c8cb580f62b36",
            "patch": "@@ -26,13 +26,14 @@ pub struct LoaderRuleItem {\n     pub condition: Option<ConditionItem>,\n }\n \n+/// This is a list of instructions for the rule engine to process. The first element in each tuple\n+/// is a glob to match against, and the second is a rule to execute if that glob matches.\n+///\n+/// This is not a map, since multiple rules can be configured for the same glob, and since execution\n+/// order matters.\n #[derive(Default)]\n #[turbo_tasks::value(transparent)]\n-pub struct WebpackRules(FxIndexMap<RcStr, LoaderRuleItem>);\n-\n-#[derive(Default)]\n-#[turbo_tasks::value(transparent)]\n-pub struct OptionWebpackRules(Option<ResolvedVc<WebpackRules>>);\n+pub struct WebpackRules(Vec<(RcStr, LoaderRuleItem)>);\n \n #[derive(Default)]\n #[turbo_tasks::value(transparent)]"
        }
    ],
    "stats": {
        "total": 630,
        "additions": 409,
        "deletions": 221
    }
}