{
    "author": "mischnic",
    "message": "Turbopack: skip codegen effects when tracing (#83095)\n\nSkip these effects when in a tracing-only asset context, since we never codegen these modules and these effects cannot add any references (which is the only thing we are interested in this case):\n\n- `Effect::FreeVar`, `Effect::TypeOf`, `Effect::ImportMeta`, `Effect::Unreachable`, `Effect::Member`",
    "sha": "d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
    "files": [
        {
            "sha": "0e07fba0db871696c33442615aca1a7832dab46a",
            "filename": "turbopack/crates/turbopack-ecmascript/benches/analyzer.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fbenches%2Fanalyzer.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fbenches%2Fanalyzer.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fbenches%2Fanalyzer.rs?ref=d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
            "patch": "@@ -64,7 +64,7 @@ pub fn benchmark(c: &mut Criterion) {\n                     None,\n                     None,\n                 );\n-                let var_graph = create_graph(&program, &eval_context);\n+                let var_graph = create_graph(&program, &eval_context, false);\n \n                 let input = BenchInput {\n                     program,\n@@ -90,7 +90,7 @@ struct BenchInput {\n }\n \n fn bench_create_graph(b: &mut Bencher, input: &BenchInput) {\n-    b.iter(|| create_graph(&input.program, &input.eval_context));\n+    b.iter(|| create_graph(&input.program, &input.eval_context, false));\n }\n \n fn bench_link(b: &mut Bencher, input: &BenchInput) {"
        },
        {
            "sha": "a0b24dc147a33f01d98e42a801ff690d0885cd2d",
            "filename": "turbopack/crates/turbopack-ecmascript/benches/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fbenches%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fbenches%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fbenches%2Fmod.rs?ref=d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
            "patch": "@@ -3,8 +3,8 @@ extern crate turbo_tasks_malloc;\n use criterion::{criterion_group, criterion_main};\n \n mod analyzer;\n-mod full;\n+mod references;\n \n criterion_group!(analyzer_benches, analyzer::benchmark);\n-criterion_group!(full_benches, full::benchmark);\n+criterion_group!(full_benches, references::benchmark);\n criterion_main!(analyzer_benches, full_benches);"
        },
        {
            "sha": "63ac9aa0a0c839d894571989c86f4ef7fe25dfec",
            "filename": "turbopack/crates/turbopack-ecmascript/benches/references.rs",
            "status": "renamed",
            "additions": 12,
            "deletions": 9,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fbenches%2Freferences.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fbenches%2Freferences.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fbenches%2Freferences.rs?ref=d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
            "patch": "@@ -53,9 +53,11 @@ pub fn benchmark(c: &mut Criterion) {\n             .resolved_cell();\n \n             let mut cases = vec![];\n-            for file in [\n-                r#\"packages/next/dist/compiled/babel-packages/packages-bundle.js\"#,\n-                r#\"node_modules/.pnpm/react-dom@19.2.0-canary-03fda05d-20250820_react@19.2.0-canary-03fda05d-20250820/node_modules/react-dom/cjs/react-dom-client.development.js\"#,\n+            for (file, is_tracing) in [\n+                (r#\"packages/next/dist/compiled/babel-packages/packages-bundle.js\"#, false),\n+                (r#\"packages/next/dist/compiled/babel-packages/packages-bundle.js\"#, true),\n+                (r#\"node_modules/.pnpm/react-dom@19.2.0-canary-03fda05d-20250820_react@19.2.0-canary-03fda05d-20250820/node_modules/react-dom/cjs/react-dom-client.development.js\"#, false),\n+                (r#\"node_modules/.pnpm/react-dom@19.2.0-canary-03fda05d-20250820_react@19.2.0-canary-03fda05d-20250820/node_modules/react-dom/cjs/react-dom-client.development.js\"#, true),\n             ] {\n                 let module = EcmascriptModuleAsset::builder(\n                     ResolvedVc::upcast(\n@@ -67,6 +69,7 @@ pub fn benchmark(c: &mut Criterion) {\n                     EcmascriptInputTransforms::empty().to_resolved().await?,\n                     EcmascriptOptions {\n                         tree_shaking_mode: Some(TreeShakingMode::ReexportsOnly),\n+                        is_tracing,\n                         ..Default::default()\n                     }\n                     .resolved_cell(),\n@@ -76,21 +79,21 @@ pub fn benchmark(c: &mut Criterion) {\n                 .to_resolved()\n                 .await?;\n \n-                cases.push((file, module));\n+                cases.push((file.rsplit(\"/\").next().unwrap(), if is_tracing { \"tracing\" } else { \"full\" }, module));\n             }\n             anyhow::Ok(cases)\n         }))\n         .unwrap();\n \n-    let mut group = c.benchmark_group(\"full\");\n+    let mut group = c.benchmark_group(\"references\");\n     group.warm_up_time(Duration::from_secs(1));\n-    group.measurement_time(Duration::from_secs(20));\n+    group.measurement_time(Duration::from_secs(10));\n \n-    for case in cases {\n+    for (file, param, module) in cases {\n         group.bench_with_input(\n-            BenchmarkId::new(\"full\", case.0),\n+            BenchmarkId::new(file, param),\n             &BenchInput {\n-                module: case.1,\n+                module,\n                 storage: tt.clone(),\n             },\n             bench_full,",
            "previous_filename": "turbopack/crates/turbopack-ecmascript/benches/full.rs"
        },
        {
            "sha": "d480a1fc0bb0eb39825fcdb75f7639bafbfc3f15",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/graph.rs",
            "status": "modified",
            "additions": 31,
            "deletions": 14,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs?ref=d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
            "patch": "@@ -274,7 +274,7 @@ impl VarGraph {\n \n /// You should use same [Mark] for this function and\n /// [swc_ecma_transforms_base::resolver::resolver_with_mark]\n-pub fn create_graph(m: &Program, eval_context: &EvalContext) -> VarGraph {\n+pub fn create_graph(m: &Program, eval_context: &EvalContext, is_tracing: bool) -> VarGraph {\n     let mut graph = VarGraph {\n         values: Default::default(),\n         free_var_ids: Default::default(),\n@@ -283,6 +283,7 @@ pub fn create_graph(m: &Program, eval_context: &EvalContext) -> VarGraph {\n \n     m.visit_with_ast_path(\n         &mut Analyzer {\n+            is_tracing,\n             data: &mut graph,\n             state: analyzer_state::AnalyzerState::new(),\n             eval_context,\n@@ -788,6 +789,8 @@ pub fn as_parent_path_skip(\n }\n \n struct Analyzer<'a> {\n+    is_tracing: bool,\n+\n     data: &'a mut VarGraph,\n     state: analyzer_state::AnalyzerState,\n \n@@ -1274,6 +1277,10 @@ impl Analyzer<'_> {\n         member_expr: &'ast MemberExpr,\n         ast_path: &AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n+        if self.is_tracing {\n+            return;\n+        }\n+\n         let obj_value = Box::new(self.eval_context.eval(&member_expr.obj));\n         let prop_value = match &member_expr.prop {\n             // TODO avoid clone\n@@ -1315,7 +1322,9 @@ impl Analyzer<'_> {\n                     start_ast_path,\n                 } => {\n                     self.effects = prev_effects;\n-                    self.effects.push(Effect::Unreachable { start_ast_path });\n+                    if !self.is_tracing {\n+                        self.effects.push(Effect::Unreachable { start_ast_path });\n+                    }\n                     always_returns = true;\n                 }\n                 EarlyReturn::Conditional {\n@@ -2008,8 +2017,9 @@ impl VisitAstPath for Analyzer<'_> {\n         }\n \n         // If this variable is unresolved, track it as a free (unbound) variable\n-        if is_unresolved(ident, self.eval_context.unresolved_mark)\n-            || self.eval_context.force_free_values.contains(&ident.to_id())\n+        if !self.is_tracing\n+            && (is_unresolved(ident, self.eval_context.unresolved_mark)\n+                || self.eval_context.force_free_values.contains(&ident.to_id()))\n         {\n             self.add_effect(Effect::FreeVar {\n                 var: ident.sym.clone(),\n@@ -2043,21 +2053,24 @@ impl VisitAstPath for Analyzer<'_> {\n             // We are in some scope that will rebind this\n             return;\n         }\n-        // Otherwise 'this' is free\n-        self.add_effect(Effect::FreeVar {\n-            var: atom!(\"this\"),\n-            ast_path: as_parent_path(ast_path),\n-            span: node.span(),\n-            in_try: is_in_try(ast_path),\n-        })\n+\n+        if !self.is_tracing {\n+            // Otherwise 'this' is free\n+            self.add_effect(Effect::FreeVar {\n+                var: atom!(\"this\"),\n+                ast_path: as_parent_path(ast_path),\n+                span: node.span(),\n+                in_try: is_in_try(ast_path),\n+            })\n+        }\n     }\n \n     fn visit_meta_prop_expr<'ast: 'r, 'r>(\n         &mut self,\n         expr: &'ast MetaPropExpr,\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n-        if expr.kind == MetaPropKind::ImportMeta {\n+        if !self.is_tracing && expr.kind == MetaPropKind::ImportMeta {\n             // MetaPropExpr also covers `new.target`. Only consider `import.meta`\n             // an effect.\n             self.add_effect(Effect::ImportMeta {\n@@ -2292,8 +2305,9 @@ impl VisitAstPath for Analyzer<'_> {\n         n: &'ast UnaryExpr,\n         ast_path: &mut swc_core::ecma::visit::AstNodePath<'r>,\n     ) {\n-        if n.op == UnaryOp::TypeOf {\n+        if n.op == UnaryOp::TypeOf && !self.is_tracing {\n             let arg_value = Box::new(self.eval_context.eval(&n.arg));\n+\n             self.add_effect(Effect::TypeOf {\n                 arg: arg_value,\n                 ast_path: as_parent_path(ast_path),\n@@ -2414,7 +2428,10 @@ impl Analyzer<'_> {\n                     (Some(then), Some(r#else)) => ConditionalKind::IfElse { then, r#else },\n                     (Some(then), None) => ConditionalKind::If { then },\n                     (None, Some(r#else)) => ConditionalKind::Else { r#else },\n-                    (None, None) => unreachable!(),\n+                    (None, None) => {\n+                        // No effects, ignore\n+                        return;\n+                    }\n                 };\n                 self.add_effect(Effect::Conditional {\n                     condition,"
        },
        {
            "sha": "e56e5ec8163af8cd60eb26569ed2626f71cc430f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fmod.rs?ref=d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
            "patch": "@@ -3828,7 +3828,7 @@ mod tests {\n                     None,\n                 );\n \n-                let mut var_graph = create_graph(&m, &eval_context);\n+                let mut var_graph = create_graph(&m, &eval_context, false);\n                 let var_cache = Default::default();\n \n                 let mut named_values = var_graph"
        },
        {
            "sha": "0db8cc6ca8acd6e93d1c7afa9a61c4b9eacd1111",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
            "patch": "@@ -200,6 +200,9 @@ pub struct EcmascriptOptions {\n     /// parsing fails. This is useful to keep the module graph structure intact when syntax errors\n     /// are temporarily introduced.\n     pub keep_last_successful_parse: bool,\n+    /// Whether the modules in this context are never chunked/codegen-ed, but only used for\n+    /// tracing.\n+    pub is_tracing: bool,\n }\n \n #[turbo_tasks::value]"
        },
        {
            "sha": "dc9fd665032d7d034caa2a66c2c9ab3bd8f6cab1",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 60,
            "deletions": 26,
            "changes": 86,
            "blob_url": "https://github.com/vercel/next.js/blob/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
            "patch": "@@ -214,6 +214,8 @@ impl AnalyzeEcmascriptModuleResult {\n /// A temporary analysis result builder to pass around, to be turned into an\n /// `Vc<AnalyzeEcmascriptModuleResult>` eventually.\n pub struct AnalyzeEcmascriptModuleResultBuilder {\n+    is_tracing: bool,\n+\n     references: FxIndexSet<ResolvedVc<Box<dyn ModuleReference>>>,\n \n     esm_references: FxHashSet<usize>,\n@@ -234,8 +236,9 @@ pub struct AnalyzeEcmascriptModuleResultBuilder {\n }\n \n impl AnalyzeEcmascriptModuleResultBuilder {\n-    pub fn new() -> Self {\n+    pub fn new(is_tracing: bool) -> Self {\n         Self {\n+            is_tracing,\n             references: Default::default(),\n             esm_references: Default::default(),\n             esm_local_references: Default::default(),\n@@ -289,7 +292,9 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n     where\n         C: Into<CodeGen>,\n     {\n-        self.code_gens.push(code_gen.into())\n+        if !self.is_tracing {\n+            self.code_gens.push(code_gen.into())\n+        }\n     }\n \n     /// Sets the analysis result ES export.\n@@ -418,12 +423,6 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n     }\n }\n \n-impl Default for AnalyzeEcmascriptModuleResultBuilder {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n struct AnalysisState<'a> {\n     handler: &'a Handler,\n     source: ResolvedVc<Box<dyn Source>>,\n@@ -511,10 +510,11 @@ pub async fn analyse_ecmascript_module_internal(\n     let options = raw_module.options;\n     let options = options.await?;\n     let import_externals = options.import_externals;\n+    let is_tracing = options.is_tracing;\n \n     let origin = ResolvedVc::upcast::<Box<dyn ResolveOrigin>>(module);\n \n-    let mut analysis = AnalyzeEcmascriptModuleResultBuilder::new();\n+    let mut analysis = AnalyzeEcmascriptModuleResultBuilder::new(is_tracing);\n     let path = origin.origin_path().owned().await?;\n \n     // Is this a typescript file that requires analyzing type references?\n@@ -717,8 +717,10 @@ pub async fn analyse_ecmascript_module_internal(\n     let handler = Handler::with_emitter(true, false, Box::new(emitter));\n \n     let mut var_graph = {\n-        let _span = tracing::info_span!(\"analyze variable values\");\n-        set_handler_and_globals(&handler, globals, || create_graph(program, eval_context))\n+        let _span = tracing::info_span!(\"analyze variable values\").entered();\n+        set_handler_and_globals(&handler, globals, || {\n+            create_graph(program, eval_context, is_tracing)\n+        })\n     };\n \n     let span = tracing::info_span!(\"esm import references\");\n@@ -784,8 +786,12 @@ pub async fn analyse_ecmascript_module_internal(\n         let (webpack_runtime, webpack_entry, webpack_chunks, mut esm_exports) =\n             set_handler_and_globals(&handler, globals, || {\n                 // TODO migrate to effects\n-                let mut visitor =\n-                    ModuleReferencesVisitor::new(eval_context, &import_references, &mut analysis);\n+                let mut visitor = ModuleReferencesVisitor::new(\n+                    eval_context,\n+                    &import_references,\n+                    &mut analysis,\n+                    is_tracing,\n+                );\n                 // ModuleReferencesVisitor has already called analysis.add_esm_reexport_reference\n                 // for any references in esm_exports\n                 program.visit_with_ast_path(&mut visitor, &mut Default::default());\n@@ -1034,6 +1040,11 @@ pub async fn analyse_ecmascript_module_internal(\n \n             match effect {\n                 Effect::Unreachable { start_ast_path } => {\n+                    debug_assert!(\n+                        !is_tracing,\n+                        \"unexpected Effect::Unreachable in tracing mode\"\n+                    );\n+\n                     analysis\n                         .add_code_gen(Unreachable::new(AstPathRange::StartAfter(start_ast_path)));\n                 }\n@@ -1054,12 +1065,14 @@ pub async fn analyse_ecmascript_module_internal(\n \n                     macro_rules! inactive {\n                         ($block:ident) => {\n-                            analysis.add_code_gen(Unreachable::new($block.range.clone()));\n+                            if !is_tracing {\n+                                analysis.add_code_gen(Unreachable::new($block.range.clone()));\n+                            }\n                         };\n                     }\n                     macro_rules! condition {\n                         ($expr:expr) => {\n-                            if !condition_has_side_effects {\n+                            if !is_tracing && !condition_has_side_effects {\n                                 analysis.add_code_gen(ConstantConditionCodeGen::new(\n                                     $expr,\n                                     condition_ast_path.to_vec().into(),\n@@ -1308,6 +1321,8 @@ pub async fn analyse_ecmascript_module_internal(\n                     span,\n                     in_try: _,\n                 } => {\n+                    debug_assert!(!is_tracing, \"unexpected Effect::FreeVar in tracing mode\");\n+\n                     // FreeVar(\"require\") might be turbopackIgnore-d\n                     if !analysis_state\n                         .link_value(\n@@ -1335,6 +1350,8 @@ pub async fn analyse_ecmascript_module_internal(\n                     span,\n                     in_try: _,\n                 } => {\n+                    debug_assert!(!is_tracing, \"unexpected Effect::Member in tracing mode\");\n+\n                     // Intentionally not awaited because `handle_member` reads this only when needed\n                     let obj = analysis_state.link_value(*obj, ImportAttributes::empty_ref());\n \n@@ -1407,6 +1424,7 @@ pub async fn analyse_ecmascript_module_internal(\n                     ast_path,\n                     span,\n                 } => {\n+                    debug_assert!(!is_tracing, \"unexpected Effect::TypeOf in tracing mode\");\n                     let arg = analysis_state\n                         .link_value(*arg, ImportAttributes::empty_ref())\n                         .await?;\n@@ -1417,6 +1435,7 @@ pub async fn analyse_ecmascript_module_internal(\n                     span: _,\n                     in_try: _,\n                 } => {\n+                    debug_assert!(!is_tracing, \"unexpected Effect::ImportMeta in tracing mode\");\n                     if analysis_state.first_import_meta {\n                         analysis_state.first_import_meta = false;\n                         analysis.add_code_gen(ImportMetaBinding::new(\n@@ -3195,6 +3214,7 @@ impl StaticAnalyser {\n /// A visitor that walks the AST and collects information about the various\n /// references a module makes to other parts of the code.\n struct ModuleReferencesVisitor<'a> {\n+    is_tracing: bool,\n     eval_context: &'a EvalContext,\n     old_analyser: StaticAnalyser,\n     import_references: &'a [ResolvedVc<EsmAssetReference>],\n@@ -3210,8 +3230,10 @@ impl<'a> ModuleReferencesVisitor<'a> {\n         eval_context: &'a EvalContext,\n         import_references: &'a [ResolvedVc<EsmAssetReference>],\n         analysis: &'a mut AnalyzeEcmascriptModuleResultBuilder,\n+        is_tracing: bool,\n     ) -> Self {\n         Self {\n+            is_tracing,\n             eval_context,\n             old_analyser: StaticAnalyser::default(),\n             import_references,\n@@ -3269,8 +3291,10 @@ impl VisitAstPath for ModuleReferencesVisitor<'_> {\n         export: &'ast ExportAll,\n         ast_path: &mut AstNodePath<AstParentNodeRef<'r>>,\n     ) {\n-        self.analysis\n-            .add_code_gen(EsmModuleItem::new(as_parent_path(ast_path).into()));\n+        if !self.is_tracing {\n+            self.analysis\n+                .add_code_gen(EsmModuleItem::new(as_parent_path(ast_path).into()));\n+        }\n         export.visit_children_with_ast_path(self, ast_path);\n     }\n \n@@ -3344,8 +3368,10 @@ impl VisitAstPath for ModuleReferencesVisitor<'_> {\n             }\n         }\n \n-        self.analysis\n-            .add_code_gen(EsmModuleItem::new(as_parent_path(ast_path).into()));\n+        if !self.is_tracing {\n+            self.analysis\n+                .add_code_gen(EsmModuleItem::new(as_parent_path(ast_path).into()));\n+        }\n         export.visit_children_with_ast_path(self, ast_path);\n     }\n \n@@ -3393,8 +3419,10 @@ impl VisitAstPath for ModuleReferencesVisitor<'_> {\n                 }\n             }\n         };\n-        self.analysis\n-            .add_code_gen(EsmModuleItem::new(as_parent_path(ast_path).into()));\n+        if !self.is_tracing {\n+            self.analysis\n+                .add_code_gen(EsmModuleItem::new(as_parent_path(ast_path).into()));\n+        }\n         export.visit_children_with_ast_path(self, ast_path);\n     }\n \n@@ -3411,8 +3439,10 @@ impl VisitAstPath for ModuleReferencesVisitor<'_> {\n                 Liveness::Constant,\n             ),\n         );\n-        self.analysis\n-            .add_code_gen(EsmModuleItem::new(as_parent_path(ast_path).into()));\n+        if !self.is_tracing {\n+            self.analysis\n+                .add_code_gen(EsmModuleItem::new(as_parent_path(ast_path).into()));\n+        }\n         export.visit_children_with_ast_path(self, ast_path);\n     }\n \n@@ -3443,8 +3473,10 @@ impl VisitAstPath for ModuleReferencesVisitor<'_> {\n                 // ignore\n             }\n         }\n-        self.analysis\n-            .add_code_gen(EsmModuleItem::new(as_parent_path(ast_path).into()));\n+        if !self.is_tracing {\n+            self.analysis\n+                .add_code_gen(EsmModuleItem::new(as_parent_path(ast_path).into()));\n+        }\n         export.visit_children_with_ast_path(self, ast_path);\n     }\n \n@@ -3489,7 +3521,9 @@ impl VisitAstPath for ModuleReferencesVisitor<'_> {\n                 }\n             }\n         }\n-        self.analysis.add_code_gen(EsmModuleItem::new(path));\n+        if !self.is_tracing {\n+            self.analysis.add_code_gen(EsmModuleItem::new(path));\n+        }\n     }\n \n     fn visit_var_declarator<'ast: 'r, 'r>("
        },
        {
            "sha": "85debaa3ac68a6fb14954fa3434325f80848fca3",
            "filename": "turbopack/crates/turbopack-nft/src/nft.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-nft%2Fsrc%2Fnft.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack-nft%2Fsrc%2Fnft.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nft%2Fsrc%2Fnft.rs?ref=d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
            "patch": "@@ -89,6 +89,7 @@ async fn node_file_trace_operation(\n             // Environment is not passed in order to avoid downleveling JS / CSS for\n             // node-file-trace.\n             environment: None,\n+            is_tracing: true,\n             ..Default::default()\n         }\n         .cell(),"
        },
        {
            "sha": "11dd2d331b38c70e3c1f515e3c5f47f955759c8b",
            "filename": "turbopack/crates/turbopack/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs?ref=d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
            "patch": "@@ -709,6 +709,7 @@ async fn externals_tracing_module_context(\n             // Environment is not passed in order to avoid downleveling JS / CSS for\n             // node-file-trace.\n             environment: None,\n+            is_tracing: true,\n             ..Default::default()\n         }\n         .cell(),"
        },
        {
            "sha": "696f149ea54637ed5d7b916847be9f82d17bddde",
            "filename": "turbopack/crates/turbopack/src/module_options/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs?ref=d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
            "patch": "@@ -150,6 +150,7 @@ impl ModuleOptions {\n             execution_context,\n             tree_shaking_mode,\n             keep_last_successful_parse,\n+            is_tracing,\n             ..\n         } = *module_options_context.await?;\n \n@@ -203,6 +204,7 @@ impl ModuleOptions {\n             ignore_dynamic_requests,\n             extract_source_map: matches!(ecmascript_source_maps, SourceMapsType::Full),\n             keep_last_successful_parse,\n+            is_tracing,\n             ..Default::default()\n         };\n         let ecmascript_options_vc = ecmascript_options.resolved_cell();"
        },
        {
            "sha": "472a9b276cb5613f1826db6ac6167d1779e7925e",
            "filename": "turbopack/crates/turbopack/src/module_options/module_options_context.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs?ref=d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
            "patch": "@@ -174,6 +174,10 @@ pub struct ModuleOptionsContext {\n     /// context paths. The first matching is used.\n     pub rules: Vec<(ContextCondition, ResolvedVc<ModuleOptionsContext>)>,\n \n+    /// Whether the modules in this context are never chunked/codegen-ed, but only used for\n+    /// tracing.\n+    pub is_tracing: bool,\n+\n     pub placeholder_for_future_extensions: (),\n }\n "
        },
        {
            "sha": "7f5630da5d849d05fe30a21c0bf33211827d9fa1",
            "filename": "turbopack/crates/turbopack/tests/node-file-trace.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack%2Ftests%2Fnode-file-trace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d574c6a62c16f9747d57b4ca91b69ac69f8b88d4/turbopack%2Fcrates%2Fturbopack%2Ftests%2Fnode-file-trace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Ftests%2Fnode-file-trace.rs?ref=d574c6a62c16f9747d57b4ca91b69ac69f8b88d4",
            "patch": "@@ -368,6 +368,7 @@ async fn node_file_trace_operation(\n             // Environment is not passed in order to avoid downleveling JS / CSS for\n             // node-file-trace.\n             environment: None,\n+            is_tracing: true,\n             ..Default::default()\n         }\n         .cell(),"
        }
    ],
    "stats": {
        "total": 174,
        "additions": 120,
        "deletions": 54
    }
}