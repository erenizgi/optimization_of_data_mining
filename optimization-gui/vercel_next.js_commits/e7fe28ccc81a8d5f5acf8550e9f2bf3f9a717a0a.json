{
    "author": "sokra",
    "message": "Turbopack: fix hanging dev server and builds with fs cache (#85606)\n\n### What?\n\nFixes a deadlock due to concurrent task locks.\nAlso adds a debug check to prevent this in future.",
    "sha": "e7fe28ccc81a8d5f5acf8550e9f2bf3f9a717a0a",
    "files": [
        {
            "sha": "4f3598011a8d26bb9a1afa38c0914fbb6258c864",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 2,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/e7fe28ccc81a8d5f5acf8550e9f2bf3f9a717a0a/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e7fe28ccc81a8d5f5acf8550e9f2bf3f9a717a0a/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=e7fe28ccc81a8d5f5acf8550e9f2bf3f9a717a0a",
            "patch": "@@ -469,11 +469,17 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         self.assert_not_persistent_calling_transient(reader, task_id, /* cell_id */ None);\n \n         let mut ctx = self.execute_context(turbo_tasks);\n-        let (mut task, reader_task) = if self.should_track_dependencies()\n+        let need_reader_task = if self.should_track_dependencies()\n             && !matches!(options.tracking, ReadTracking::Untracked)\n+            && reader.is_some_and(|reader_id| reader_id != task_id)\n             && let Some(reader_id) = reader\n             && reader_id != task_id\n         {\n+            Some(reader_id)\n+        } else {\n+            None\n+        };\n+        let (mut task, mut reader_task) = if let Some(reader_id) = need_reader_task {\n             // Having a task_pair here is not optimal, but otherwise this would lead to a race\n             // condition. See below.\n             // TODO(sokra): solve that in a more performant way.\n@@ -534,6 +540,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     break;\n                 }\n                 drop(task);\n+                drop(reader_task);\n                 {\n                     let _span = tracing::trace_span!(\n                         \"make root node for strongly consistent read\",\n@@ -549,7 +556,13 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                         &mut ctx,\n                     );\n                 }\n-                task = ctx.task(task_id, TaskDataCategory::All);\n+                (task, reader_task) = if let Some(reader_id) = need_reader_task {\n+                    // TODO(sokra): see comment above\n+                    let (task, reader) = ctx.task_pair(task_id, reader_id, TaskDataCategory::All);\n+                    (task, Some(reader))\n+                } else {\n+                    (ctx.task(task_id, TaskDataCategory::All), None)\n+                }\n             }\n \n             let is_dirty =\n@@ -697,6 +710,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                         )\n                     }\n                 });\n+                drop(reader_task);\n                 drop(task);\n                 if !task_ids_to_schedule.is_empty() {\n                     let mut queue = AggregationUpdateQueue::new();\n@@ -893,6 +907,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 ctx.get_task_description(task_id)\n             );\n         }\n+        drop(reader_task);\n \n         // Cell should exist, but data was dropped or is not serializable. We need to recompute the\n         // task the get the cell content."
        },
        {
            "sha": "56bfa756d7c189c047595c76feab95f73c4b6496",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/e7fe28ccc81a8d5f5acf8550e9f2bf3f9a717a0a/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e7fe28ccc81a8d5f5acf8550e9f2bf3f9a717a0a/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=e7fe28ccc81a8d5f5acf8550e9f2bf3f9a717a0a",
            "patch": "@@ -85,6 +85,8 @@ where\n     turbo_tasks: &'e dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     _operation_guard: Option<OperationGuard<'e, B>>,\n     transaction: TransactionState<'e, 'tx, B>,\n+    #[cfg(debug_assertions)]\n+    active_task_locks: Arc<std::sync::atomic::AtomicU8>,\n }\n \n impl<'e, 'tx, B: BackingStorage> ExecuteContextImpl<'e, 'tx, B>\n@@ -100,6 +102,8 @@ where\n             turbo_tasks,\n             _operation_guard: Some(backend.start_operation()),\n             transaction: TransactionState::None,\n+            #[cfg(debug_assertions)]\n+            active_task_locks: Arc::new(std::sync::atomic::AtomicU8::new(0)),\n         }\n     }\n \n@@ -113,6 +117,8 @@ where\n             turbo_tasks,\n             _operation_guard: Some(backend.start_operation()),\n             transaction: TransactionState::Borrowed(transaction),\n+            #[cfg(debug_assertions)]\n+            active_task_locks: Arc::new(std::sync::atomic::AtomicU8::new(0)),\n         }\n     }\n \n@@ -180,6 +186,14 @@ where\n     }\n \n     fn task(&mut self, task_id: TaskId, category: TaskDataCategory) -> Self::TaskGuardImpl {\n+        #[cfg(debug_assertions)]\n+        if self.active_task_locks.fetch_add(1, Ordering::AcqRel) != 0 {\n+            panic!(\n+                \"Concurrent task lock acquisition detected. This is not allowed and indicates a \\\n+                 bug. It can lead to deadlocks.\"\n+            );\n+        }\n+\n         let mut task = self.backend.storage.access_mut(task_id);\n         if !task.state().is_restored(category) {\n             if task_id.is_transient() {\n@@ -208,6 +222,8 @@ where\n             backend: self.backend,\n             #[cfg(debug_assertions)]\n             category,\n+            #[cfg(debug_assertions)]\n+            active_task_locks: self.active_task_locks.clone(),\n         }\n     }\n \n@@ -228,6 +244,14 @@ where\n         task_id2: TaskId,\n         category: TaskDataCategory,\n     ) -> (Self::TaskGuardImpl, Self::TaskGuardImpl) {\n+        #[cfg(debug_assertions)]\n+        if self.active_task_locks.fetch_add(2, Ordering::AcqRel) != 0 {\n+            panic!(\n+                \"Concurrent task lock acquisition detected. This is not allowed and indicates a \\\n+                 bug. It can lead to deadlocks.\"\n+            );\n+        }\n+\n         let (mut task1, mut task2) = self.backend.storage.access_pair_mut(task_id1, task_id2);\n         let is_restored1 = task1.state().is_restored(category);\n         let is_restored2 = task2.state().is_restored(category);\n@@ -264,13 +288,17 @@ where\n                 backend: self.backend,\n                 #[cfg(debug_assertions)]\n                 category,\n+                #[cfg(debug_assertions)]\n+                active_task_locks: self.active_task_locks.clone(),\n             },\n             TaskGuardImpl {\n                 task: task2,\n                 task_id: task_id2,\n                 backend: self.backend,\n                 #[cfg(debug_assertions)]\n                 category,\n+                #[cfg(debug_assertions)]\n+                active_task_locks: self.active_task_locks.clone(),\n             },\n         )\n     }\n@@ -328,6 +356,8 @@ impl<'e, B: BackingStorage> ChildExecuteContext<'e> for ChildExecuteContextImpl<\n             turbo_tasks: self.turbo_tasks,\n             _operation_guard: None,\n             transaction: TransactionState::None,\n+            #[cfg(debug_assertions)]\n+            active_task_locks: Arc::new(std::sync::atomic::AtomicU8::new(0)),\n         }\n     }\n }\n@@ -376,6 +406,15 @@ pub struct TaskGuardImpl<'a, B: BackingStorage> {\n     backend: &'a TurboTasksBackendInner<B>,\n     #[cfg(debug_assertions)]\n     category: TaskDataCategory,\n+    #[cfg(debug_assertions)]\n+    active_task_locks: Arc<std::sync::atomic::AtomicU8>,\n+}\n+\n+#[cfg(debug_assertions)]\n+impl<B: BackingStorage> Drop for TaskGuardImpl<'_, B> {\n+    fn drop(&mut self) {\n+        self.active_task_locks.fetch_sub(1, Ordering::AcqRel);\n+    }\n }\n \n impl<B: BackingStorage> TaskGuardImpl<'_, B> {"
        }
    ],
    "stats": {
        "total": 58,
        "additions": 56,
        "deletions": 2
    }
}