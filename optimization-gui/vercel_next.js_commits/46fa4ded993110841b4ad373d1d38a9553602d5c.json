{
    "author": "huozhi",
    "message": "feat: capture logs into logging file during development (#84183)",
    "sha": "46fa4ded993110841b4ad373d1d38a9553602d5c",
    "files": [
        {
            "sha": "fd631c0631af07a6cf904de785147fd78e9f87e4",
            "filename": "packages/next/src/build/define-env.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fdefine-env.ts?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -316,6 +316,7 @@ export function getDefineEnv({\n     'process.env.__NEXT_BROWSER_DEBUG_INFO_IN_TERMINAL': JSON.stringify(\n       config.experimental.browserDebugInfoInTerminal || false\n     ),\n+    'process.env.__NEXT_MCP_SERVER': !!config.experimental.mcpServer,\n \n     // The devtools need to know whether or not to show an option to clear the\n     // bundler cache. This option may be removed later once Turbopack's"
        },
        {
            "sha": "8d170c4430f9d2148230c8d73a19feb58dd48e78",
            "filename": "packages/next/src/lib/is-error.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Flib%2Fis-error.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Flib%2Fis-error.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fis-error.ts?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -19,7 +19,10 @@ export default function isError(err: unknown): err is NextError {\n   )\n }\n \n-function safeStringify(obj: any) {\n+/**\n+ * This is a safe stringify function that handles circular references.\n+ */\n+export function safeStringify(obj: any) {\n   const seen = new WeakSet()\n \n   return JSON.stringify(obj, (_key, value) => {"
        },
        {
            "sha": "f3f4f6045fe3a8a98b1138480bacd093dcb95407",
            "filename": "packages/next/src/next-devtools/userspace/app/forward-logs.ts",
            "status": "modified",
            "additions": 202,
            "deletions": 21,
            "changes": 223,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fnext-devtools%2Fuserspace%2Fapp%2Fforward-logs.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fnext-devtools%2Fuserspace%2Fapp%2Fforward-logs.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fnext-devtools%2Fuserspace%2Fapp%2Fforward-logs.ts?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -13,6 +13,110 @@ import {\n   patchConsoleMethod,\n } from '../../shared/forward-logs-shared'\n import { preLogSerializationClone, logStringify } from './forward-logs-utils'\n+import { safeStringify } from '../../../lib/is-error'\n+\n+// Client-side file logger for browser logs\n+class ClientFileLogger {\n+  private logEntries: Array<{\n+    timestamp: string\n+    level: string // log level\n+    message: string // log message\n+  }> = []\n+\n+  private formatTimestamp(): string {\n+    const now = new Date()\n+    const hours = now.getHours().toString().padStart(2, '0')\n+    const minutes = now.getMinutes().toString().padStart(2, '0')\n+    const seconds = now.getSeconds().toString().padStart(2, '0')\n+    const milliseconds = now.getMilliseconds().toString().padStart(3, '0')\n+\n+    return `${hours}:${minutes}:${seconds}.${milliseconds}`\n+  }\n+\n+  log(level: string, args: any[]): void {\n+    if (isReactServerReplayedLog(args)) {\n+      return\n+    }\n+\n+    // Format the args into a message string\n+    const message = args\n+      .map((arg) => {\n+        if (typeof arg === 'string') return arg\n+        if (typeof arg === 'number' || typeof arg === 'boolean')\n+          return String(arg)\n+        if (arg === null) return 'null'\n+        if (arg === undefined) return 'undefined'\n+        return safeStringify(arg)\n+      })\n+      .join(' ')\n+\n+    const logEntry = {\n+      timestamp: this.formatTimestamp(),\n+      level: level.toUpperCase(),\n+      message,\n+    }\n+    this.logEntries.push(logEntry)\n+\n+    // Schedule flush when new log is added\n+    scheduleLogFlush()\n+  }\n+  getLogs(): Array<{ timestamp: string; level: string; message: string }> {\n+    return [...this.logEntries]\n+  }\n+\n+  clear(): void {\n+    this.logEntries = []\n+  }\n+}\n+\n+const clientFileLogger = new ClientFileLogger()\n+\n+// Set up flush-based sending of client file logs\n+let logFlushTimeout: NodeJS.Timeout | null = null\n+let heartbeatInterval: NodeJS.Timeout | null = null\n+\n+const scheduleLogFlush = () => {\n+  if (logFlushTimeout) {\n+    clearTimeout(logFlushTimeout)\n+  }\n+\n+  logFlushTimeout = setTimeout(() => {\n+    sendClientFileLogs()\n+    logFlushTimeout = null\n+  }, 100) // Send after 100ms (much faster with debouncing)\n+}\n+\n+const cancelLogFlush = () => {\n+  if (logFlushTimeout) {\n+    clearTimeout(logFlushTimeout)\n+    logFlushTimeout = null\n+  }\n+}\n+\n+const startHeartbeat = () => {\n+  if (heartbeatInterval) return\n+\n+  heartbeatInterval = setInterval(() => {\n+    if (logQueue.socket && logQueue.socket.readyState === WebSocket.OPEN) {\n+      try {\n+        // Send a ping to keep the connection alive\n+        logQueue.socket.send(JSON.stringify({ event: 'ping' }))\n+      } catch (error) {\n+        // Connection might be closed, stop heartbeat\n+        stopHeartbeat()\n+      }\n+    } else {\n+      stopHeartbeat()\n+    }\n+  }, 5000) // Send ping every 5 seconds\n+}\n+\n+const stopHeartbeat = () => {\n+  if (heartbeatInterval) {\n+    clearInterval(heartbeatInterval)\n+    heartbeatInterval = null\n+  }\n+}\n \n const isTerminalLoggingEnabled = getIsTerminalLoggingEnabled()\n \n@@ -67,6 +171,32 @@ const serializeEntries = (entries: Array<ClientLogEntry>) =>\n     }\n   })\n \n+// Function to send client file logs to server\n+const sendClientFileLogs = () => {\n+  if (!logQueue.socket || logQueue.socket.readyState !== WebSocket.OPEN) {\n+    return\n+  }\n+\n+  const logs = clientFileLogger.getLogs()\n+  if (logs.length === 0) {\n+    return\n+  }\n+\n+  try {\n+    const payload = JSON.stringify({\n+      event: 'client-file-logs',\n+      logs: logs,\n+    })\n+\n+    logQueue.socket.send(payload)\n+  } catch (error) {\n+    console.error(error)\n+  } finally {\n+    // Clear logs regardless of send success to prevent memory leaks\n+    clientFileLogger.clear()\n+  }\n+}\n+\n // Combined state and public API\n export const logQueue: {\n   entries: Array<ClientLogEntry>\n@@ -115,17 +245,21 @@ export const logQueue: {\n         socket.send(payload)\n         logQueue.entries = []\n         logQueue.sourceType = undefined\n+\n+        // Also send client file logs\n+        sendClientFileLogs()\n       } catch {\n         // error (make sure u don't infinite loop)\n         /* noop */\n       }\n     })\n   },\n   onSocketReady: (socket: WebSocket) => {\n-    if (!isTerminalLoggingEnabled) {\n+    // When MCP or terminal logging is enabled, we enable the socket connection,\n+    // otherwise it will not proceed.\n+    if (!isTerminalLoggingEnabled && !process.env.__NEXT_MCP_SERVER) {\n       return\n     }\n-\n     if (socket.readyState !== WebSocket.OPEN) {\n       // invariant\n       return\n@@ -134,20 +268,36 @@ export const logQueue: {\n     // incase an existing timeout was going to run with a stale socket\n     logQueue.cancelFlush?.()\n     logQueue.socket = socket\n-    try {\n-      const payload = JSON.stringify({\n-        event: 'browser-logs',\n-        entries: serializeEntries(logQueue.entries),\n-        router: logQueue.router,\n-        sourceType: logQueue.sourceType,\n-      })\n \n-      socket.send(payload)\n-      logQueue.entries = []\n-      logQueue.sourceType = undefined\n-    } catch {\n-      /** noop just incase */\n+    // Add socket event listeners to track connection state\n+    socket.addEventListener('close', () => {\n+      cancelLogFlush()\n+      stopHeartbeat()\n+    })\n+\n+    // Only send terminal logs if enabled\n+    if (isTerminalLoggingEnabled) {\n+      try {\n+        const payload = JSON.stringify({\n+          event: 'browser-logs',\n+          entries: serializeEntries(logQueue.entries),\n+          router: logQueue.router,\n+          sourceType: logQueue.sourceType,\n+        })\n+\n+        socket.send(payload)\n+        logQueue.entries = []\n+        logQueue.sourceType = undefined\n+      } catch {\n+        /** noop just incase */\n+      }\n     }\n+\n+    // Always send client file logs when socket is ready\n+    sendClientFileLogs()\n+\n+    // Start heartbeat to keep connection alive\n+    startHeartbeat()\n   },\n }\n \n@@ -180,6 +330,14 @@ const createErrorArg = (error: Error) => {\n }\n \n const createLogEntry = (level: LogMethod, args: any[]) => {\n+  // Always log to client file logger with args (formatting done inside log method)\n+  clientFileLogger.log(level, args)\n+\n+  // Only forward to terminal if enabled\n+  if (!isTerminalLoggingEnabled) {\n+    return\n+  }\n+\n   // do not abstract this, it implicitly relies on which functions call it. forcing the inlined implementation makes you think about callers\n   // error capture stack trace maybe\n   const stack = stackWithOwners(new Error())\n@@ -204,6 +362,9 @@ const createLogEntry = (level: LogMethod, args: any[]) => {\n }\n \n export const forwardErrorLog = (args: any[]) => {\n+  // Always log to client file logger with args (formatting done inside log method)\n+  clientFileLogger.log('error', args)\n+  // Only forward to terminal if enabled\n   if (!isTerminalLoggingEnabled) {\n     return\n   }\n@@ -267,6 +428,14 @@ const stackWithOwners = (error: Error) => {\n }\n \n export function logUnhandledRejection(reason: unknown) {\n+  // Always log to client file logger\n+  const message =\n+    reason instanceof Error\n+      ? `${reason.name}: ${reason.message}`\n+      : JSON.stringify(reason)\n+  clientFileLogger.log('error', [`unhandledRejection: ${message}`])\n+\n+  // Only forward to terminal if enabled\n   if (!isTerminalLoggingEnabled) {\n     return\n   }\n@@ -335,7 +504,10 @@ const isHMR = (args: any[]) => {\n   return false\n }\n \n-const isIgnoredLog = (args: any[]) => {\n+/**\n+ * Matches the format of logs arguments React replayed from the RSC.\n+ */\n+const isReactServerReplayedLog = (args: any[]) => {\n   if (args.length < 3) {\n     return false\n   }\n@@ -350,11 +522,16 @@ const isIgnoredLog = (args: any[]) => {\n     return false\n   }\n \n-  // kinda hacky, we should define a common format for these strings so we can safely ignore\n   return format.startsWith('%c%s%c') && styles.includes('background:')\n }\n \n export function forwardUnhandledError(error: Error) {\n+  // Always log to client file logger\n+  clientFileLogger.log('error', [\n+    `uncaughtError: ${error.name}: ${error.message}`,\n+  ])\n+\n+  // Only forward to terminal if enabled\n   if (!isTerminalLoggingEnabled) {\n     return\n   }\n@@ -364,10 +541,6 @@ export function forwardUnhandledError(error: Error) {\n \n // TODO: this router check is brittle, we need to update based on the current router the user is using\n export const initializeDebugLogForwarding = (router: 'app' | 'pages'): void => {\n-  if (!isTerminalLoggingEnabled) {\n-    return\n-  }\n-\n   // probably don't need this\n   if (isPatched) {\n     return\n@@ -384,7 +557,7 @@ export const initializeDebugLogForwarding = (router: 'app' | 'pages'): void => {\n         if (isHMR(args)) {\n           return\n         }\n-        if (isIgnoredLog(args)) {\n+        if (isReactServerReplayedLog(args)) {\n           return\n         }\n         createLogEntry(method, args)\n@@ -393,4 +566,12 @@ export const initializeDebugLogForwarding = (router: 'app' | 'pages'): void => {\n   } catch {}\n   logQueue.router = router\n   isPatched = true\n+\n+  // Cleanup on page unload\n+  window.addEventListener('beforeunload', () => {\n+    cancelLogFlush()\n+    stopHeartbeat()\n+    // Send any remaining logs before page unloads\n+    sendClientFileLogs()\n+  })\n }"
        },
        {
            "sha": "6142203428d74c68daa070d21cb1d5edefd252b6",
            "filename": "packages/next/src/server/dev/browser-logs/file-logger.test.ts",
            "status": "added",
            "additions": 250,
            "deletions": 0,
            "changes": 250,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fbrowser-logs%2Ffile-logger.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fbrowser-logs%2Ffile-logger.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fbrowser-logs%2Ffile-logger.test.ts?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -0,0 +1,250 @@\n+import fs from 'fs'\n+import path from 'path'\n+import os from 'os'\n+import { getFileLogger, test__resetFileLogger } from './file-logger'\n+\n+describe('FileLogger', () => {\n+  let tempDir: string\n+  let fileLogger: ReturnType<typeof getFileLogger>\n+\n+  beforeEach(() => {\n+    // Create a temporary directory for testing\n+    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'next-file-logger-test-'))\n+    test__resetFileLogger() // Reset singleton\n+    fileLogger = getFileLogger()\n+    fileLogger.initialize(tempDir, true) // Enable mcpServer for testing\n+  })\n+\n+  afterEach(() => {\n+    // Clean up temporary directory\n+    if (fs.existsSync(tempDir)) {\n+      fs.rmSync(tempDir, { recursive: true, force: true })\n+    }\n+  })\n+\n+  it('should create log file on first log', () => {\n+    // Log a message\n+    fileLogger.logBrowser('LOG', 'Test message')\n+\n+    // Force flush to ensure the log is written\n+    fileLogger.forceFlush()\n+\n+    // Check that a log file was created in the logs directory\n+    const logsDir = path.join(tempDir, 'logs')\n+    expect(fs.existsSync(logsDir)).toBe(true)\n+\n+    const logFiles = fs.readdirSync(logsDir)\n+    expect(logFiles.length).toBe(1)\n+    expect(logFiles[0]).toBe('next-development.log')\n+  })\n+\n+  it('should format log entries correctly', () => {\n+    fileLogger.logBrowser('LOG', 'Test message')\n+    fileLogger.logServer('ERROR', 'Server error')\n+\n+    // Force flush to ensure logs are written\n+    fileLogger.forceFlush()\n+\n+    // Get the log file path\n+    const logsDir = path.join(tempDir, 'logs')\n+    const logFilePath = path.join(logsDir, 'next-development.log')\n+\n+    const logContent = fs.readFileSync(logFilePath, 'utf-8')\n+    const lines = logContent.trim().split('\\n')\n+\n+    expect(lines).toHaveLength(2)\n+\n+    // Check format: [timestamp] source level message\n+    expect(lines[0]).toMatch(\n+      /^\\[\\d{2}:\\d{2}:\\d{2}\\.\\d{3}\\] Browser LOG {5}Test message$/\n+    )\n+    expect(lines[1]).toMatch(\n+      /^\\[\\d{2}:\\d{2}:\\d{2}\\.\\d{3}\\] Server {2}ERROR {3}Server error$/\n+    )\n+  })\n+\n+  it('should append multiple log entries', () => {\n+    fileLogger.logBrowser('LOG', 'First message')\n+    fileLogger.logBrowser('WARN', 'Second message')\n+    fileLogger.logServer('INFO', 'Third message')\n+\n+    // Force flush to ensure logs are written\n+    fileLogger.forceFlush()\n+\n+    // Get the log file path\n+    const logsDir = path.join(tempDir, 'logs')\n+    const logFilePath = path.join(logsDir, 'next-development.log')\n+\n+    const logContent = fs.readFileSync(logFilePath, 'utf-8')\n+    const lines = logContent.trim().split('\\n')\n+\n+    expect(lines).toHaveLength(3)\n+    expect(lines[0]).toContain('First message')\n+    expect(lines[1]).toContain('Second message')\n+    expect(lines[2]).toContain('Third message')\n+  })\n+\n+  it('should handle special characters in messages', () => {\n+    fileLogger.logBrowser('LOG', 'Message with \"quotes\" and \\n newlines')\n+\n+    // Force flush to ensure logs are written\n+    fileLogger.forceFlush()\n+\n+    // Get the log file path\n+    const logsDir = path.join(tempDir, 'logs')\n+    const logFilePath = path.join(logsDir, 'next-development.log')\n+\n+    const logContent = fs.readFileSync(logFilePath, 'utf-8')\n+    expect(logContent).toContain('Message with \"quotes\" and')\n+    expect(logContent).toContain('newlines')\n+  })\n+\n+  it('should pad log levels correctly', () => {\n+    fileLogger.logBrowser('LOG', 'Short level')\n+    fileLogger.logBrowser('WARN', 'Medium level')\n+    fileLogger.logBrowser('ERROR', 'Long level')\n+\n+    // Force flush to ensure logs are written\n+    fileLogger.forceFlush()\n+\n+    // Get the log file path\n+    const logsDir = path.join(tempDir, 'logs')\n+    const logFilePath = path.join(logsDir, 'next-development.log')\n+\n+    const logContent = fs.readFileSync(logFilePath, 'utf-8')\n+    const lines = logContent.trim().split('\\n')\n+\n+    // All levels should be padded to 7 characters\n+    expect(lines[0]).toMatch(/Browser LOG {5}Short level/)\n+    expect(lines[1]).toMatch(/Browser WARN {4}Medium level/)\n+    expect(lines[2]).toMatch(/Browser ERROR {3}Long level/)\n+  })\n+\n+  it('should not create log file when mcpServer is disabled', () => {\n+    // Check that logs directory doesn't exist before the test\n+    const logsDir = path.join(tempDir, 'logs')\n+    const logsDirExistedBefore = fs.existsSync(logsDir)\n+\n+    // Create a new file logger with mcpServer disabled\n+    const disabledLogger = getFileLogger()\n+    disabledLogger.initialize(tempDir, false)\n+\n+    // Log a message\n+    disabledLogger.logBrowser('LOG', 'This should not be logged')\n+    disabledLogger.logServer('ERROR', 'This should also not be logged')\n+\n+    // Force flush to ensure any queued logs are processed\n+    disabledLogger.forceFlush()\n+\n+    // Check that no new log file was created (directory should still be in same state)\n+    const logsDirExistsAfter = fs.existsSync(logsDir)\n+    expect(logsDirExistsAfter).toBe(logsDirExistedBefore)\n+  })\n+\n+  describe('batching behavior', () => {\n+    it('should batch multiple logs and flush them together', async () => {\n+      // Log multiple messages without forcing flush\n+      fileLogger.logBrowser('LOG', 'First batched message')\n+      fileLogger.logBrowser('WARN', 'Second batched message')\n+      fileLogger.logServer('INFO', 'Third batched message')\n+\n+      // Initially, the log file should be empty or not exist\n+      const logsDir = path.join(tempDir, 'logs')\n+      const logFilePath = path.join(logsDir, 'next-development.log')\n+\n+      if (fs.existsSync(logFilePath)) {\n+        const initialContent = fs.readFileSync(logFilePath, 'utf-8')\n+        expect(initialContent.trim()).toBe('')\n+      }\n+\n+      // Force flush to write all batched logs\n+      fileLogger.forceFlush()\n+\n+      const logContent = fs.readFileSync(logFilePath, 'utf-8')\n+      const lines = logContent.trim().split('\\n')\n+\n+      expect(lines).toHaveLength(3)\n+      expect(lines[0]).toContain('First batched message')\n+      expect(lines[1]).toContain('Second batched message')\n+      expect(lines[2]).toContain('Third batched message')\n+    })\n+\n+    it('should flush automatically after flush interval', async () => {\n+      // Log a message\n+      fileLogger.logBrowser('LOG', 'Auto-flush test message')\n+\n+      // Initially, the log file should be empty\n+      const logsDir = path.join(tempDir, 'logs')\n+      const logFilePath = path.join(logsDir, 'next-development.log')\n+\n+      if (fs.existsSync(logFilePath)) {\n+        const initialContent = fs.readFileSync(logFilePath, 'utf-8')\n+        expect(initialContent.trim()).toBe('')\n+      }\n+\n+      // Wait for the flush interval (1 second) plus a small buffer\n+      await new Promise((resolve) => setTimeout(resolve, 1100))\n+\n+      // Now the log should be written\n+      const logContent = fs.readFileSync(logFilePath, 'utf-8')\n+      const lines = logContent.trim().split('\\n')\n+\n+      expect(lines).toHaveLength(1)\n+      expect(lines[0]).toContain('Auto-flush test message')\n+    })\n+\n+    it('should flush immediately when queue reaches max size', () => {\n+      // Log many messages to test batching\n+      for (let i = 0; i < 100; i++) {\n+        fileLogger.logBrowser('LOG', `Message ${i}`)\n+      }\n+\n+      // Force flush to ensure all logs are written immediately\n+      fileLogger.forceFlush()\n+\n+      const logsDir = path.join(tempDir, 'logs')\n+      const logFilePath = path.join(logsDir, 'next-development.log')\n+\n+      const logContent = fs.readFileSync(logFilePath, 'utf-8')\n+      const lines = logContent.trim().split('\\n')\n+\n+      expect(lines).toHaveLength(100)\n+      expect(lines[0]).toContain('Message 0')\n+      expect(lines[99]).toContain('Message 99')\n+    })\n+\n+    it('should handle forceFlush correctly', () => {\n+      fileLogger.logBrowser('LOG', 'Before force flush')\n+      fileLogger.logServer('ERROR', 'Another before force flush')\n+\n+      // Force flush\n+      fileLogger.forceFlush()\n+\n+      const logsDir = path.join(tempDir, 'logs')\n+      const logFilePath = path.join(logsDir, 'next-development.log')\n+\n+      const logContent = fs.readFileSync(logFilePath, 'utf-8')\n+      const lines = logContent.trim().split('\\n')\n+\n+      expect(lines).toHaveLength(2)\n+      expect(lines[0]).toContain('Before force flush')\n+      expect(lines[1]).toContain('Another before force flush')\n+\n+      // Add more logs after force flush\n+      fileLogger.logBrowser('WARN', 'After force flush')\n+\n+      // These should not be written yet\n+      const logContentAfter = fs.readFileSync(logFilePath, 'utf-8')\n+      const linesAfter = logContentAfter.trim().split('\\n')\n+      expect(linesAfter).toHaveLength(2) // Still only 2 lines\n+\n+      // Force flush again\n+      fileLogger.forceFlush()\n+\n+      const logContentFinal = fs.readFileSync(logFilePath, 'utf-8')\n+      const linesFinal = logContentFinal.trim().split('\\n')\n+      expect(linesFinal).toHaveLength(3)\n+      expect(linesFinal[2]).toContain('After force flush')\n+    })\n+  })\n+})"
        },
        {
            "sha": "b532f0a36ab24aa4c9c5f40f92e9522e76b96d90",
            "filename": "packages/next/src/server/dev/browser-logs/file-logger.ts",
            "status": "added",
            "additions": 188,
            "deletions": 0,
            "changes": 188,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fbrowser-logs%2Ffile-logger.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fbrowser-logs%2Ffile-logger.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fbrowser-logs%2Ffile-logger.ts?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -0,0 +1,188 @@\n+import fs from 'fs'\n+import path from 'path'\n+\n+export interface LogEntry {\n+  timestamp: string\n+  source: 'Server' | 'Browser'\n+  level: string\n+  message: string\n+}\n+\n+export class FileLogger {\n+  private logFilePath: string = ''\n+  private isInitialized: boolean = false\n+  private logQueue: string[] = []\n+  private flushTimer: NodeJS.Timeout | null = null\n+  private mcpServerEnabled: boolean = false\n+\n+  public initialize(distDir: string, mcpServerEnabled: boolean): void {\n+    this.logFilePath = path.join(distDir, 'logs', `next-development.log`)\n+    this.mcpServerEnabled = mcpServerEnabled\n+\n+    if (this.isInitialized) {\n+      return\n+    }\n+\n+    // Only initialize if mcpServer is enabled\n+    if (!this.mcpServerEnabled) {\n+      return\n+    }\n+\n+    try {\n+      // Create the log file if it doesn't exist\n+      if (!fs.existsSync(this.logFilePath)) {\n+        // ensure the directory exists\n+        fs.mkdirSync(path.dirname(this.logFilePath), { recursive: true })\n+        fs.writeFileSync(this.logFilePath, '')\n+      }\n+      this.isInitialized = true\n+    } catch (error) {\n+      console.error(error)\n+    }\n+  }\n+\n+  private formatTimestamp(): string {\n+    // Use performance.now() instead of Date.now() for avoid sync IO of cache components\n+    const now = performance.now()\n+    const hours = Math.floor(now / 3600000)\n+      .toString()\n+      .padStart(2, '0')\n+    const minutes = Math.floor((now % 3600000) / 60000)\n+      .toString()\n+      .padStart(2, '0')\n+    const seconds = Math.floor((now % 60000) / 1000)\n+      .toString()\n+      .padStart(2, '0')\n+    const milliseconds = Math.floor(now % 1000)\n+      .toString()\n+      .padStart(3, '0')\n+    return `${hours}:${minutes}:${seconds}.${milliseconds}`\n+  }\n+\n+  private formatLogEntry(entry: LogEntry): string {\n+    const { timestamp, source, level, message } = entry\n+    const levelPadded = level.toUpperCase().padEnd(7, ' ') // Pad level to 7 characters for alignment\n+    const sourcePadded = source === 'Browser' ? source : 'Server '\n+    return `[${timestamp}] ${sourcePadded} ${levelPadded} ${message}\\n`\n+  }\n+\n+  private scheduleFlush(): void {\n+    // Debounce the flush\n+    if (this.flushTimer) {\n+      clearTimeout(this.flushTimer)\n+      this.flushTimer = null\n+    }\n+\n+    // Delay the log flush to ensure more logs can be batched together asynchronously\n+    this.flushTimer = setTimeout(() => {\n+      this.flush()\n+    }, 100)\n+  }\n+\n+  public getLogQueue(): string[] {\n+    return this.logQueue\n+  }\n+\n+  private flush(): void {\n+    if (this.logQueue.length === 0) {\n+      return\n+    }\n+\n+    // Only flush to disk if mcpServer is enabled\n+    if (!this.mcpServerEnabled) {\n+      this.logQueue = [] // Clear the queue without writing\n+      this.flushTimer = null\n+      return\n+    }\n+\n+    try {\n+      // Ensure the directory exists before writing\n+      const logDir = path.dirname(this.logFilePath)\n+      if (!fs.existsSync(logDir)) {\n+        fs.mkdirSync(logDir, { recursive: true })\n+      }\n+\n+      const logsToWrite = this.logQueue.join('')\n+      // Writing logs to files synchronously to ensure they're written before returning\n+      fs.appendFileSync(this.logFilePath, logsToWrite)\n+      this.logQueue = []\n+    } catch (error) {\n+      console.error('Failed to flush logs to file:', error)\n+    } finally {\n+      this.flushTimer = null\n+    }\n+  }\n+\n+  private enqueueLog(formattedEntry: string): void {\n+    this.logQueue.push(formattedEntry)\n+\n+    // Cancel existing timer and start a new one to ensure all logs are flushed together\n+    if (this.flushTimer) {\n+      clearTimeout(this.flushTimer)\n+      this.flushTimer = null\n+    }\n+\n+    this.scheduleFlush()\n+  }\n+\n+  log(source: 'Server' | 'Browser', level: string, message: string): void {\n+    // Don't log anything if mcpServer is disabled\n+    if (!this.mcpServerEnabled) {\n+      return\n+    }\n+\n+    if (!this.isInitialized) {\n+      return\n+    }\n+\n+    const logEntry: LogEntry = {\n+      timestamp: this.formatTimestamp(),\n+      source,\n+      level,\n+      message,\n+    }\n+\n+    const formattedEntry = this.formatLogEntry(logEntry)\n+    this.enqueueLog(formattedEntry)\n+  }\n+\n+  logServer(level: string, message: string): void {\n+    this.log('Server', level, message)\n+  }\n+\n+  logBrowser(level: string, message: string): void {\n+    this.log('Browser', level, message)\n+  }\n+\n+  // Force flush all queued logs immediately\n+  forceFlush(): void {\n+    if (this.flushTimer) {\n+      clearTimeout(this.flushTimer)\n+      this.flushTimer = null\n+    }\n+    this.flush()\n+  }\n+\n+  // Cleanup method to flush logs on process exit\n+  destroy(): void {\n+    this.forceFlush()\n+  }\n+}\n+\n+// Singleton instance\n+let fileLogger: FileLogger | null = null\n+\n+export function getFileLogger(): FileLogger {\n+  if (!fileLogger || process.env.NODE_ENV === 'test') {\n+    fileLogger = new FileLogger()\n+  }\n+  return fileLogger\n+}\n+\n+// Only used for testing\n+export function test__resetFileLogger(): void {\n+  if (fileLogger) {\n+    fileLogger.destroy()\n+  }\n+  fileLogger = null\n+}"
        },
        {
            "sha": "71e7d40c121a9c81f42776f87117087e929c3795",
            "filename": "packages/next/src/server/dev/browser-logs/receive-logs.ts",
            "status": "modified",
            "additions": 81,
            "deletions": 5,
            "changes": 86,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fbrowser-logs%2Freceive-logs.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fbrowser-logs%2Freceive-logs.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fbrowser-logs%2Freceive-logs.ts?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -13,6 +13,8 @@ import {\n   type ConsoleEntry,\n   UNDEFINED_MARKER,\n } from '../../../next-devtools/shared/forward-logs-shared'\n+import { formatConsoleArgs } from '../../../client/lib/console'\n+import { getFileLogger } from './file-logger'\n \n export function restoreUndefined(x: any): any {\n   if (x === UNDEFINED_MARKER) return undefined\n@@ -25,6 +27,23 @@ export function restoreUndefined(x: any): any {\n   return x\n }\n \n+function cleanConsoleArgsForFileLogging(args: any[]): string {\n+  /**\n+   * Use formatConsoleArgs to strip out background and color format specifiers\n+   * and keep only the original string content for file logging\n+   */\n+  try {\n+    return formatConsoleArgs(args)\n+  } catch {\n+    // Fallback to simple string conversion if formatting fails\n+    return args\n+      .map((arg) =>\n+        typeof arg === 'string' ? arg : util.inspect(arg, { depth: 2 })\n+      )\n+      .join(' ')\n+  }\n+}\n+\n const methods: Array<LogMethod> = [\n   'log',\n   'info',\n@@ -397,12 +416,13 @@ async function handleDefaultConsole(\n   browserPrefix: string,\n   ctx: MappingContext,\n   distDir: string,\n-  config: boolean | { logDepth?: number; showSourceLocation?: boolean }\n+  config: boolean | { logDepth?: number; showSourceLocation?: boolean },\n+  isServerLog: boolean\n ) {\n-  const loggableEntry = await prepareConsoleArgs(entry, ctx, distDir)\n+  const consoleArgs = await prepareConsoleArgs(entry, ctx, distDir)\n   const withStackEntry = await withLocation(\n     {\n-      original: loggableEntry,\n+      original: consoleArgs,\n       stack: (entry as any).consoleMethodStack || null,\n     },\n     ctx,\n@@ -411,6 +431,18 @@ async function handleDefaultConsole(\n   )\n   const consoleMethod = forwardConsole[entry.method] || forwardConsole.log\n   ;(consoleMethod as (...args: any[]) => void)(browserPrefix, ...withStackEntry)\n+\n+  // Process enqueued logs and write to file\n+  // Log to file with correct source based on context\n+  const fileLogger = getFileLogger()\n+\n+  // Use cleaned console args to strip out background and color format specifiers\n+  const message = cleanConsoleArgsForFileLogging(consoleArgs)\n+  if (isServerLog) {\n+    fileLogger.logServer(entry.method.toUpperCase(), message)\n+  } else {\n+    fileLogger.logBrowser(entry.method.toUpperCase(), message)\n+  }\n }\n \n export async function handleLog(\n@@ -419,7 +451,10 @@ export async function handleLog(\n   distDir: string,\n   config: boolean | { logDepth?: number; showSourceLocation?: boolean }\n ): Promise<void> {\n-  const browserPrefix = cyan('[browser]')\n+  // Determine the source based on the context\n+  const isServerLog = ctx.isServer || ctx.isEdgeServer\n+  const browserPrefix = isServerLog ? cyan('[server]') : cyan('[browser]')\n+  const fileLogger = getFileLogger()\n \n   for (const entry of entries) {\n     try {\n@@ -464,7 +499,8 @@ export async function handleLog(\n                 browserPrefix,\n                 ctx,\n                 distDir,\n-                config\n+                config,\n+                isServerLog\n               )\n               break\n             }\n@@ -478,6 +514,12 @@ export async function handleLog(\n         case 'any-logged-error': {\n           const consoleArgs = await prepareConsoleErrorArgs(entry, ctx, distDir)\n           forwardConsole.error(browserPrefix, ...consoleArgs)\n+\n+          // Process enqueued logs and write to file\n+          fileLogger.logBrowser(\n+            'ERROR',\n+            cleanConsoleArgsForFileLogging(consoleArgs)\n+          )\n           break\n         }\n         // formatted error is an explicit error event (rejections, uncaught errors)\n@@ -488,6 +530,12 @@ export async function handleLog(\n             distDir\n           )\n           forwardConsole.error(browserPrefix, ...formattedArgs)\n+\n+          // Process enqueued logs and write to file\n+          fileLogger.logBrowser(\n+            'ERROR',\n+            cleanConsoleArgsForFileLogging(formattedArgs)\n+          )\n           break\n         }\n         default: {\n@@ -498,6 +546,11 @@ export async function handleLog(\n         case 'any-logged-error': {\n           const consoleArgs = await prepareConsoleErrorArgs(entry, ctx, distDir)\n           forwardConsole.error(browserPrefix, ...consoleArgs)\n+          // Process enqueued logs and write to file\n+          fileLogger.logBrowser(\n+            'ERROR',\n+            cleanConsoleArgsForFileLogging(consoleArgs)\n+          )\n           break\n         }\n         case 'console': {\n@@ -508,10 +561,22 @@ export async function handleLog(\n             browserPrefix,\n             ...consoleArgs\n           )\n+\n+          // Process enqueued logs and write to file\n+          fileLogger.logBrowser(\n+            'ERROR',\n+            cleanConsoleArgsForFileLogging(consoleArgs)\n+          )\n           break\n         }\n         case 'formatted-error': {\n           forwardConsole.error(browserPrefix, `${entry.prefix}\\n`, entry.stack)\n+\n+          // Process enqueued logs and write to file\n+          fileLogger.logBrowser(\n+            'ERROR',\n+            cleanConsoleArgsForFileLogging([`${entry.prefix}\\n${entry.stack}`])\n+          )\n           break\n         }\n         default: {\n@@ -588,3 +653,14 @@ export async function receiveBrowserLogsTurbopack(opts: {\n \n   await handleLog(entries, ctx, distDir, opts.config)\n }\n+\n+// Handle client file logs (always logged regardless of terminal flag)\n+export async function handleClientFileLogs(\n+  logs: Array<{ timestamp: string; level: string; message: string }>\n+): Promise<void> {\n+  const fileLogger = getFileLogger()\n+\n+  for (const log of logs) {\n+    fileLogger.logBrowser(log.level, log.message)\n+  }\n+}"
        },
        {
            "sha": "65e61abbfa0add6f4dc6aa407e8913630e72064b",
            "filename": "packages/next/src/server/dev/hot-reloader-turbopack.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 1,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -97,7 +97,10 @@ import { getDisableDevIndicatorMiddleware } from '../../next-devtools/server/dev\n import { getRestartDevServerMiddleware } from '../../next-devtools/server/restart-dev-server-middleware'\n import { backgroundLogCompilationEvents } from '../../shared/lib/turbopack/compilation-events'\n import { getSupportedBrowsers } from '../../build/utils'\n-import { receiveBrowserLogsTurbopack } from './browser-logs/receive-logs'\n+import {\n+  receiveBrowserLogsTurbopack,\n+  handleClientFileLogs,\n+} from './browser-logs/receive-logs'\n import { normalizePath } from '../../lib/normalize-path'\n import {\n   devToolsConfigMiddleware,\n@@ -116,6 +119,7 @@ import { getMcpMiddleware } from '../mcp/get-mcp-middleware'\n import { handleErrorStateResponse } from '../mcp/tools/get-errors'\n import { handlePageMetadataResponse } from '../mcp/tools/get-page-metadata'\n import { setStackFrameResolver } from '../mcp/tools/utils/format-errors'\n+import { getFileLogger } from './browser-logs/file-logger'\n \n const wsServer = new ws.Server({ noServer: true })\n const isTestMode = !!(\n@@ -212,6 +216,12 @@ export async function createHotReloaderTurbopack(\n   // of the current `next dev` invocation.\n   hotReloaderSpan.stop()\n \n+  // Initialize log monitor for file logging\n+  // Enable logging by default in development mode\n+  const mcpServerEnabled = !!nextConfig.experimental.mcpServer\n+  const fileLogger = getFileLogger()\n+  fileLogger.initialize(distDir, mcpServerEnabled)\n+\n   const encryptionKey = await generateEncryptionKeyBase64({\n     isBuild: false,\n     distDir,\n@@ -939,6 +949,16 @@ export async function createHotReloaderTurbopack(\n               }\n               break\n             }\n+            case 'client-file-logs': {\n+              // Always log to file regardless of terminal flag\n+              await handleClientFileLogs(parsedData.logs)\n+              break\n+            }\n+            case 'ping': {\n+              // Handle ping events to keep WebSocket connections alive\n+              // No-op - just acknowledge the ping\n+              break\n+            }\n \n             case 'mcp-error-state-response': {\n               handleErrorStateResponse("
        },
        {
            "sha": "db43b662e856437877e219828b3a16571993155b",
            "filename": "packages/next/src/server/dev/hot-reloader-webpack.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 1,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-webpack.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-webpack.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-webpack.ts?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -89,7 +89,10 @@ import { getDisableDevIndicatorMiddleware } from '../../next-devtools/server/dev\n import getWebpackBundler from '../../shared/lib/get-webpack-bundler'\n import { getRestartDevServerMiddleware } from '../../next-devtools/server/restart-dev-server-middleware'\n import { checkPersistentCacheInvalidationAndCleanup } from '../../build/webpack/cache-invalidation'\n-import { receiveBrowserLogsWebpack } from './browser-logs/receive-logs'\n+import {\n+  receiveBrowserLogsWebpack,\n+  handleClientFileLogs,\n+} from './browser-logs/receive-logs'\n import {\n   devToolsConfigMiddleware,\n   getDevToolsConfig,\n@@ -107,6 +110,7 @@ import {\n } from './hot-reloader-shared-utils'\n import { getMcpMiddleware } from '../mcp/get-mcp-middleware'\n import { setStackFrameResolver } from '../mcp/tools/utils/format-errors'\n+import { getFileLogger } from './browser-logs/file-logger'\n \n const MILLISECONDS_IN_NANOSECOND = BigInt(1_000_000)\n \n@@ -313,6 +317,12 @@ export default class HotReloaderWebpack implements NextJsHotReloaderInterface {\n     // Ensure the hotReloaderSpan is flushed immediately as it's the parentSpan for all processing\n     // of the current `next dev` invocation.\n     this.hotReloaderSpan.stop()\n+\n+    // Initialize log monitor for file logging\n+    // Enable logging by default in development mode\n+    const mcpServerEnabled = !!config.experimental.mcpServer\n+    const fileLogger = getFileLogger()\n+    fileLogger.initialize(this.distDir, mcpServerEnabled)\n   }\n \n   public async run(\n@@ -578,6 +588,16 @@ export default class HotReloaderWebpack implements NextJsHotReloaderInterface {\n               }\n               break\n             }\n+            case 'client-file-logs': {\n+              // Always log to file regardless of terminal flag\n+              await handleClientFileLogs(payload.logs)\n+              break\n+            }\n+            case 'ping': {\n+              // Handle ping events to keep WebSocket connections alive\n+              // No-op - just acknowledge the ping\n+              break\n+            }\n             default: {\n               break\n             }"
        },
        {
            "sha": "fc46b5e5cb11cdc8ff58336dbad4f2487723b6b7",
            "filename": "packages/next/src/server/node-environment-extensions/console-dev.tsx",
            "status": "modified",
            "additions": 12,
            "deletions": 1,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-dev.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-dev.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-dev.tsx?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -1,5 +1,7 @@\n import { dim } from '../../lib/picocolors'\n import { devLogsAsyncStorage } from '../app-render/dev-logs-async-storage.external'\n+import { getFileLogger } from '../dev/browser-logs/file-logger'\n+import { formatConsoleArgs } from '../../client/lib/console'\n \n type InterceptableConsoleMethod =\n   | 'error'\n@@ -168,7 +170,16 @@ function patchConsoleMethodDEV(methodName: InterceptableConsoleMethod): void {\n       if (devLogsStore?.dim === true) {\n         return originalMethod.apply(this, dimConsoleCall(methodName, args))\n       } else {\n-        return originalMethod.apply(this, args)\n+        const ret = originalMethod.apply(this, args)\n+\n+        const fileLogger = getFileLogger()\n+        const message = formatConsoleArgs(args)\n+        // Strip ANSI escape codes for file logging\n+        // eslint-disable-next-line no-control-regex\n+        const ansiEscapeRegex = new RegExp('\\u001b\\\\[[0-9;]*m', 'g')\n+        const cleanMessage = message.replace(ansiEscapeRegex, '')\n+        fileLogger.logServer(methodName.toUpperCase(), cleanMessage)\n+        return ret\n       }\n     }\n     if (originalName) {"
        },
        {
            "sha": "ca3f2dbd5e047e55cc406d013cd54407d7a8c3ea",
            "filename": "test/e2e/app-dir/log-file/.gitignore",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2F.gitignore",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2F.gitignore",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Flog-file%2F.gitignore?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -0,0 +1 @@\n+!tsconfig.json"
        },
        {
            "sha": "ca2414d7b1bf974c4f6455906012b66ccbd86885",
            "filename": "test/e2e/app-dir/log-file/app/client/page.tsx",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Fapp%2Fclient%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Fapp%2Fclient%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Flog-file%2Fapp%2Fclient%2Fpage.tsx?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -0,0 +1,30 @@\n+'use client'\n+\n+import { useEffect } from 'react'\n+\n+export default function ClientPage() {\n+  useEffect(() => {\n+    // Logging in client component useEffect\n+    // Test complex partial circular object\n+    const circularObj: any = {\n+      name: 'test',\n+      data: {\n+        nested: {\n+          value: 42,\n+          items: [1, 2, 3],\n+        },\n+      },\n+      metadata: {\n+        name: 'safe stringify',\n+        version: '1.0.0',\n+      },\n+    }\n+    // Create partial circular reference\n+    circularObj.data.parent = circularObj\n+    console.log('Client: Complex circular object:', circularObj)\n+    console.error('Client: This is an error message from client component')\n+    console.warn('Client: This is a warning message from client component')\n+  }, [])\n+\n+  return <p>client page with logging</p>\n+}"
        },
        {
            "sha": "888614deda3ba5d744d1a7e5dac131038dba2b12",
            "filename": "test/e2e/app-dir/log-file/app/layout.tsx",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Flog-file%2Fapp%2Flayout.tsx?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -0,0 +1,8 @@\n+import { ReactNode } from 'react'\n+export default function Root({ children }: { children: ReactNode }) {\n+  return (\n+    <html>\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "38fb7f09cc11b3d8fdb7bf88f081381e1cdc3a53",
            "filename": "test/e2e/app-dir/log-file/app/server/page.tsx",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Fapp%2Fserver%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Fapp%2Fserver%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Flog-file%2Fapp%2Fserver%2Fpage.tsx?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -0,0 +1,8 @@\n+export default async function Page() {\n+  // Logging in RSC render\n+  console.log('RSC: This is a log message from server component')\n+  console.error('RSC: This is an error message from server component')\n+  console.warn('RSC: This is a warning message from server component')\n+\n+  return <p>hello world</p>\n+}"
        },
        {
            "sha": "d3e8a1ec1c72224e8898f5f16c0897e9b2afca29",
            "filename": "test/e2e/app-dir/log-file/log-file.test.ts",
            "status": "added",
            "additions": 155,
            "deletions": 0,
            "changes": 155,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Flog-file.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Flog-file.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Flog-file%2Flog-file.test.ts?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -0,0 +1,155 @@\n+import fs from 'fs'\n+import path from 'path'\n+import { nextTestSetup } from 'e2e-utils'\n+import { retry } from 'next-test-utils'\n+\n+describe('log-file', () => {\n+  const { next, isNextDev, skipped } = nextTestSetup({\n+    files: __dirname,\n+    skipDeployment: true,\n+  })\n+\n+  if (skipped) {\n+    return\n+  }\n+\n+  function getLogFilePath(): string {\n+    const logFilePath = path.join(\n+      next.testDir,\n+      next.distDir,\n+      'logs',\n+      'next-development.log'\n+    )\n+    return logFilePath\n+  }\n+\n+  function hasLogFile(): boolean {\n+    const logPath = getLogFilePath()\n+\n+    return fs.existsSync(logPath)\n+  }\n+\n+  function readLogFile(): string {\n+    const logPath = getLogFilePath()\n+    if (fs.existsSync(logPath)) {\n+      return fs.readFileSync(logPath, 'utf8')\n+    }\n+    return ''\n+  }\n+\n+  let previousLogContent = ''\n+\n+  function normalizeLogContent(content: string): string {\n+    return (\n+      content\n+        // Strip lines containing \"Download the React DevTools\"\n+        .split('\\n')\n+        .filter((line) => {\n+          // filter out the noise logs\n+          if (\n+            /Download the React DevTools|connected to ws at|received ws message|Next.js page already hydrated|Next.js hydrate callback fired|Compiling|Compiled|Ready in/.test(\n+              line\n+            )\n+          ) {\n+            return false\n+          }\n+          return true\n+        })\n+        .join('\\n')\n+        // Normalize timestamps to consistent format\n+        .replace(/\\[\\d{2}:\\d{2}:\\d{2}\\.\\d{3}\\]/g, '[xx:xx:xx.xxx]')\n+    )\n+  }\n+\n+  function getNewLogContent(): string {\n+    const currentContent = readLogFile()\n+    const newContent = currentContent.slice(previousLogContent.length)\n+    return normalizeLogContent(newContent)\n+  }\n+\n+  beforeEach(() => {\n+    // Reset log tracking at the start of each test to only capture new logs\n+    previousLogContent = readLogFile()\n+  })\n+\n+  it('should capture RSC logging in log file', async () => {\n+    // Request to RSC page and wait for hydration\n+    await next.browser('/server')\n+    // Wait for logs to be written (increased timeout for batched logging)\n+    await new Promise((resolve) => setTimeout(resolve, 2000))\n+\n+    if (isNextDev) {\n+      await retry(async () => {\n+        const newLogContent = getNewLogContent()\n+        expect(newLogContent).toMatchInlineSnapshot(`\n+         \"[xx:xx:xx.xxx] Server  LOG     RSC: This is a log message from server component\n+         [xx:xx:xx.xxx] Server  ERROR   RSC: This is an error message from server component\n+         [xx:xx:xx.xxx] Server  WARN    RSC: This is a warning message from server component\n+         \"\n+        `)\n+      })\n+    } else {\n+      expect(hasLogFile()).toBe(false)\n+    }\n+  })\n+\n+  it('should capture client logging in log file', async () => {\n+    // Make request to client page and wait for hydration\n+    const browser = await next.browser('/client')\n+    // Wait for console.log to be logged in browser\n+    await retry(async () => {\n+      const logs = await browser.log()\n+      expect(logs).toContainEqual(\n+        expect.objectContaining({\n+          message: expect.stringContaining('Client: Complex circular object'),\n+          source: 'log',\n+        })\n+      )\n+      expect(logs).toContainEqual(\n+        expect.objectContaining({\n+          message: 'Client: This is an error message from client component',\n+          source: 'error',\n+        })\n+      )\n+    })\n+    // Wait for logs to be written (reduced timeout with faster flush)\n+    await new Promise((resolve) => setTimeout(resolve, 2000))\n+\n+    if (isNextDev) {\n+      await retry(async () => {\n+        const newLogContent = getNewLogContent()\n+        expect(newLogContent).toMatchInlineSnapshot(`\n+         \"[xx:xx:xx.xxx] Browser LOG     Client: Complex circular object: {\"name\":\"test\",\"data\":{\"nested\":{\"value\":42,\"items\":[1,2,3]},\"parent\":\"[Circular]\"},\"metadata\":{\"name\":\"safe stringify\",\"version\":\"1.0.0\"}}\n+         [xx:xx:xx.xxx] Browser ERROR   Client: This is an error message from client component\n+         [xx:xx:xx.xxx] Browser WARN    Client: This is a warning message from client component\n+         \"\n+        `)\n+      })\n+    } else {\n+      expect(hasLogFile()).toBe(false)\n+    }\n+  })\n+\n+  it('should capture logging in pages router', async () => {\n+    // Make request to page with getServerSideProps\n+    await next.browser('/pages-router-page')\n+    // Wait for logs to be written (increased timeout for batched logging)\n+    await new Promise((resolve) => setTimeout(resolve, 2000))\n+\n+    if (isNextDev) {\n+      await retry(async () => {\n+        const newLogContent = getNewLogContent()\n+        expect(newLogContent).toMatchInlineSnapshot(`\n+         \"[xx:xx:xx.xxx] Server  LOG     Pages Router SSR: This is a log message from getServerSideProps\n+         [xx:xx:xx.xxx] Server  ERROR   Pages Router SSR: This is an error message from getServerSideProps\n+         [xx:xx:xx.xxx] Server  WARN    Pages Router SSR: This is a warning message from getServerSideProps\n+         [xx:xx:xx.xxx] Server  LOG     Pages Router isomorphic: This is a log message from render\n+         [xx:xx:xx.xxx] Browser LOG     Pages Router isomorphic: This is a log message from render\n+         \"\n+        `)\n+      })\n+    } else {\n+      expect(hasLogFile()).toBe(false)\n+    }\n+  })\n+})"
        },
        {
            "sha": "6c3d49f3b48679325b7d6379936d4ad2c6375e21",
            "filename": "test/e2e/app-dir/log-file/next.config.js",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Flog-file%2Fnext.config.js?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -0,0 +1,10 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  experimental: {\n+    mcpServer: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "465c59aa8197fab3b32e56c09ff6a152b5457578",
            "filename": "test/e2e/app-dir/log-file/pages/pages-router-page.tsx",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Fpages%2Fpages-router-page.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Fpages%2Fpages-router-page.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Flog-file%2Fpages%2Fpages-router-page.tsx?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -0,0 +1,31 @@\n+import { GetServerSideProps } from 'next'\n+\n+interface Props {\n+  message: string\n+}\n+\n+export default function Page({ message }: Props) {\n+  console.log('Pages Router isomorphic: This is a log message from render')\n+  return (\n+    <div>\n+      <h1>Pages Router Server-Side Props Test</h1>\n+      <p>{message}</p>\n+    </div>\n+  )\n+}\n+\n+export const getServerSideProps: GetServerSideProps<Props> = async () => {\n+  console.log('Pages Router SSR: This is a log message from getServerSideProps')\n+  console.error(\n+    'Pages Router SSR: This is an error message from getServerSideProps'\n+  )\n+  console.warn(\n+    'Pages Router SSR: This is a warning message from getServerSideProps'\n+  )\n+\n+  return {\n+    props: {\n+      message: 'Server-side props executed successfully',\n+    },\n+  }\n+}"
        },
        {
            "sha": "03599f888d539f051033a8e21f9e47f7e96f31b1",
            "filename": "test/e2e/app-dir/log-file/tsconfig.json",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Ftsconfig.json",
            "raw_url": "https://github.com/vercel/next.js/raw/46fa4ded993110841b4ad373d1d38a9553602d5c/test%2Fe2e%2Fapp-dir%2Flog-file%2Ftsconfig.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Flog-file%2Ftsconfig.json?ref=46fa4ded993110841b4ad373d1d38a9553602d5c",
            "patch": "@@ -0,0 +1,33 @@\n+{\n+  \"compilerOptions\": {\n+    \"target\": \"ES2017\",\n+    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n+    \"allowJs\": true,\n+    \"skipLibCheck\": true,\n+    \"strict\": true,\n+    \"noEmit\": true,\n+    \"esModuleInterop\": true,\n+    \"module\": \"esnext\",\n+    \"moduleResolution\": \"bundler\",\n+    \"resolveJsonModule\": true,\n+    \"isolatedModules\": true,\n+    \"jsx\": \"react-jsx\",\n+    \"incremental\": true,\n+    \"plugins\": [\n+      {\n+        \"name\": \"next\"\n+      }\n+    ],\n+    \"paths\": {\n+      \"@/*\": [\"./*\"]\n+    }\n+  },\n+  \"include\": [\n+    \"next-env.d.ts\",\n+    \"**/*.ts\",\n+    \"**/*.tsx\",\n+    \".next/types/**/*.ts\",\n+    \"**/*.mts\"\n+  ],\n+  \"exclude\": [\"node_modules\", \"**/*.test.ts\", \"**/*.test.tsx\"]\n+}"
        }
    ],
    "stats": {
        "total": 1086,
        "additions": 1056,
        "deletions": 30
    }
}