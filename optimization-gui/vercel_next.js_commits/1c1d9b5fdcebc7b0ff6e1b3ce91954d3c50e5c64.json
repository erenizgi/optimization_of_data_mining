{
    "author": "unstubbable",
    "message": "Use and enforce exhaustive switch statements for work unit store (#81577)\n\nThis allows us to introduce more work unit store types with confidence.\r\n\r\ncloses NAR-203",
    "sha": "1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
    "files": [
        {
            "sha": "789a45e2a731a09b9dd012c236da62c603a15a08",
            "filename": ".eslintrc.json",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/.eslintrc.json",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/.eslintrc.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.eslintrc.json?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -316,6 +316,16 @@\n       {\n         \"message\": \"substr() is deprecated, use slice() or substring() instead\",\n         \"selector\": \"MemberExpression > Identifier[name='substr']\"\n+      },\n+      // ban plain workUnitStore.type if statements and ternaries\n+      {\n+        \"selector\": \"BinaryExpression[left.object.name='workUnitStore'][left.property.name='type'][operator=/^(?:===|!==)$/]\",\n+        \"message\": \"Use an exhaustive switch on `workUnitStore.type` (with a `never`-based default) instead of using if statements or ternaries.\"\n+      },\n+      // ban optional-chained workUnitStore?.type if statements and ternaries\n+      {\n+        \"selector\": \"BinaryExpression[left.type='ChainExpression'][left.expression.object.name='workUnitStore'][left.expression.property.name='type'][operator=/^(?:===|!==)$/]\",\n+        \"message\": \"Use an exhaustive switch on `workUnitStore.type` (with a `never`-based default) instead of using if statements or ternaries.\"\n       }\n     ],\n     \"no-script-url\": \"error\","
        },
        {
            "sha": "ebf44dece99c8077c408ae54e1b2448f653d7b9f",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -717,5 +717,6 @@\n   \"716\": \"NEXT_DEVTOOLS_SIMULATED_ERROR\",\n   \"717\": \"Unsupported environment condition \\\"%s\\\" and react condition \\\"%s\\\". This is a bug in Next.js.\",\n   \"718\": \"Invariant: projectDir is required for node runtime\",\n-  \"719\": \"Failed to get source map for '%s'. This is a bug in Next.js\"\n+  \"719\": \"Failed to get source map for '%s'. This is a bug in Next.js\",\n+  \"720\": \"A client prerender store should not be used for a route handler.\"\n }"
        },
        {
            "sha": "18379777d2cc85a21dea9da35f6b60a2a91fb502",
            "filename": "packages/next/src/client/components/bailout-to-client-rendering.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fbailout-to-client-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fbailout-to-client-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fbailout-to-client-rendering.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -16,7 +16,12 @@ export function bailoutToClientRendering(reason: string): void | never {\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n         throw new BailoutToCSRError(reason)\n+      case 'request':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n       default:\n+        workUnitStore satisfies never\n     }\n   }\n }"
        },
        {
            "sha": "a022ee454122f1d48c37eabe5ac1c999cae92145",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 18,
            "deletions": 6,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -1233,12 +1233,24 @@ async function renderToHTMLOrFlightImpl(\n         return true\n       }\n       const workUnitStore = workUnitAsyncStorage.getStore()\n-      return !!(\n-        workUnitStore &&\n-        (workUnitStore.type === 'prerender' ||\n-          workUnitStore.type === 'prerender-client' ||\n-          workUnitStore.type === 'cache')\n-      )\n+\n+      if (!workUnitStore) {\n+        return false\n+      }\n+\n+      switch (workUnitStore.type) {\n+        case 'prerender':\n+        case 'prerender-client':\n+        case 'cache':\n+          return true\n+        case 'prerender-ppr':\n+        case 'prerender-legacy':\n+        case 'request':\n+        case 'unstable-cache':\n+          return false\n+        default:\n+          workUnitStore satisfies never\n+      }\n     }\n \n     const __next_require__: typeof instrumented.require = (...args) => {"
        },
        {
            "sha": "e9be3e4934e28e8525b5eb7f65bfd7c776234746",
            "filename": "packages/next/src/server/app-render/create-component-tree.tsx",
            "status": "modified",
            "additions": 15,
            "deletions": 9,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -293,15 +293,21 @@ async function createComponentTreeInternal({\n     const workUnitStore = workUnitAsyncStorage.getStore()\n \n     if (workUnitStore) {\n-      if (\n-        workUnitStore.type === 'prerender' ||\n-        workUnitStore.type === 'prerender-legacy' ||\n-        workUnitStore.type === 'prerender-ppr' ||\n-        workUnitStore.type === 'cache'\n-      ) {\n-        if (workUnitStore.revalidate > defaultRevalidate) {\n-          workUnitStore.revalidate = defaultRevalidate\n-        }\n+      switch (workUnitStore.type) {\n+        case 'prerender':\n+        case 'prerender-legacy':\n+        case 'prerender-ppr':\n+        case 'cache':\n+          if (workUnitStore.revalidate > defaultRevalidate) {\n+            workUnitStore.revalidate = defaultRevalidate\n+          }\n+          break\n+        case 'prerender-client':\n+        case 'request':\n+        case 'unstable-cache':\n+          break\n+        default:\n+          workUnitStore satisfies never\n       }\n     }\n "
        },
        {
            "sha": "3f9203655612d36e6d6dfb153bf0cfd035acd99b",
            "filename": "packages/next/src/server/app-render/dynamic-rendering.ts",
            "status": "modified",
            "additions": 116,
            "deletions": 108,
            "changes": 224,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -122,14 +122,20 @@ export function markCurrentScopeAsDynamic(\n   expression: string\n ): void {\n   if (workUnitStore) {\n-    if (\n-      workUnitStore.type === 'cache' ||\n-      workUnitStore.type === 'unstable-cache'\n-    ) {\n-      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n-      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n-      // forbidden inside a cache scope.\n-      return\n+    switch (workUnitStore.type) {\n+      case 'cache':\n+      case 'unstable-cache':\n+        // Inside cache scopes, marking a scope as dynamic has no effect,\n+        // because the outer cache scope creates a cache boundary. This is\n+        // subtly different from reading a dynamic data source, which is\n+        // forbidden inside a cache scope.\n+        return\n+      case 'prerender-legacy':\n+      case 'prerender-ppr':\n+      case 'request':\n+        break\n+      default:\n+        workUnitStore satisfies never\n     }\n   }\n \n@@ -145,51 +151,36 @@ export function markCurrentScopeAsDynamic(\n   }\n \n   if (workUnitStore) {\n-    if (workUnitStore.type === 'prerender-ppr') {\n-      postponeWithTracking(\n-        store.route,\n-        expression,\n-        workUnitStore.dynamicTracking\n-      )\n-    } else if (workUnitStore.type === 'prerender-legacy') {\n-      workUnitStore.revalidate = 0\n+    switch (workUnitStore.type) {\n+      case 'prerender-ppr':\n+        return postponeWithTracking(\n+          store.route,\n+          expression,\n+          workUnitStore.dynamicTracking\n+        )\n+      case 'prerender-legacy':\n+        workUnitStore.revalidate = 0\n \n-      // We aren't prerendering but we are generating a static page. We need to bail out of static generation\n-      const err = new DynamicServerError(\n-        `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n-      )\n-      store.dynamicUsageDescription = expression\n-      store.dynamicUsageStack = err.stack\n-\n-      throw err\n-    } else if (\n-      process.env.NODE_ENV === 'development' &&\n-      workUnitStore &&\n-      workUnitStore.type === 'request'\n-    ) {\n-      workUnitStore.usedDynamic = true\n+        // We aren't prerendering, but we are generating a static page. We need\n+        // to bail out of static generation.\n+        const err = new DynamicServerError(\n+          `Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n+        )\n+        store.dynamicUsageDescription = expression\n+        store.dynamicUsageStack = err.stack\n+\n+        throw err\n+      case 'request':\n+        if (process.env.NODE_ENV !== 'production') {\n+          workUnitStore.usedDynamic = true\n+        }\n+        break\n+      default:\n+        workUnitStore satisfies never\n     }\n   }\n }\n \n-/**\n- * This function communicates that some dynamic path parameter was read. This\n- * differs from the more general `trackDynamicDataAccessed` in that it is will\n- * not error when `dynamic = \"error\"` is set.\n- *\n- * @param store The static generation store\n- * @param expression The expression that was accessed dynamically\n- */\n-export function trackFallbackParamAccessed(\n-  store: WorkStore,\n-  expression: string\n-): void {\n-  const prerenderStore = workUnitAsyncStorage.getStore()\n-  if (!prerenderStore || prerenderStore.type !== 'prerender-ppr') return\n-\n-  postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking)\n-}\n-\n /**\n  * This function is meant to be used when prerendering without dynamicIO or PPR.\n  * When called during a build it will cause Next.js to consider the route as dynamic.\n@@ -221,34 +212,27 @@ export function throwToInterruptStaticGeneration(\n  *\n  * @internal\n  */\n-export function trackDynamicDataInDynamicRender(\n-  _store: WorkStore,\n-  workUnitStore: void | WorkUnitStore\n-) {\n-  if (workUnitStore) {\n-    if (\n-      workUnitStore.type === 'cache' ||\n-      workUnitStore.type === 'unstable-cache'\n-    ) {\n-      // inside cache scopes marking a scope as dynamic has no effect because the outer cache scope\n-      // creates a cache boundary. This is subtly different from reading a dynamic data source which is\n+export function trackDynamicDataInDynamicRender(workUnitStore: WorkUnitStore) {\n+  switch (workUnitStore.type) {\n+    case 'cache':\n+    case 'unstable-cache':\n+      // Inside cache scopes, marking a scope as dynamic has no effect,\n+      // because the outer cache scope creates a cache boundary. This is\n+      // subtly different from reading a dynamic data source, which is\n       // forbidden inside a cache scope.\n       return\n-    }\n-    // TODO: it makes no sense to have these work unit store types during a dev render.\n-    if (\n-      workUnitStore.type === 'prerender' ||\n-      workUnitStore.type === 'prerender-client' ||\n-      workUnitStore.type === 'prerender-legacy'\n-    ) {\n-      workUnitStore.revalidate = 0\n-    }\n-    if (\n-      process.env.NODE_ENV === 'development' &&\n-      workUnitStore.type === 'request'\n-    ) {\n-      workUnitStore.usedDynamic = true\n-    }\n+    case 'prerender':\n+    case 'prerender-legacy':\n+    case 'prerender-ppr':\n+    case 'prerender-client':\n+      break\n+    case 'request':\n+      if (process.env.NODE_ENV !== 'production') {\n+        workUnitStore.usedDynamic = true\n+      }\n+      break\n+    default:\n+      workUnitStore satisfies never\n   }\n }\n \n@@ -529,27 +513,40 @@ export function createPostponedAbortSignal(reason: string): AbortSignal {\n  * case we need to abort the encoding of arguments since they'll never complete.\n  */\n export function createHangingInputAbortSignal(\n-  workUnitStore: PrerenderStoreModern\n-): AbortSignal {\n-  const controller = new AbortController()\n+  workUnitStore: WorkUnitStore\n+): AbortSignal | undefined {\n+  switch (workUnitStore.type) {\n+    case 'prerender':\n+      const controller = new AbortController()\n+\n+      if (workUnitStore.cacheSignal) {\n+        // If we have a cacheSignal it means we're in a prospective render. If\n+        // the input we're waiting on is coming from another cache, we do want\n+        // to wait for it so that we can resolve this cache entry too.\n+        workUnitStore.cacheSignal.inputReady().then(() => {\n+          controller.abort()\n+        })\n+      } else {\n+        // Otherwise we're in the final render and we should already have all\n+        // our caches filled. We might still be waiting on some microtasks so we\n+        // wait one tick before giving up. When we give up, we still want to\n+        // render the content of this cache as deeply as we can so that we can\n+        // suspend as deeply as possible in the tree or not at all if we don't\n+        // end up waiting for the input.\n+        scheduleOnNextTick(() => controller.abort())\n+      }\n \n-  if (workUnitStore.cacheSignal) {\n-    // If we have a cacheSignal it means we're in a prospective render. If the input\n-    // we're waiting on is coming from another cache, we do want to wait for it so that\n-    // we can resolve this cache entry too.\n-    workUnitStore.cacheSignal.inputReady().then(() => {\n-      controller.abort()\n-    })\n-  } else {\n-    // Otherwise we're in the final render and we should already have all our caches\n-    // filled. We might still be waiting on some microtasks so we wait one tick before\n-    // giving up. When we give up, we still want to render the content of this cache\n-    // as deeply as we can so that we can suspend as deeply as possible in the tree\n-    // or not at all if we don't end up waiting for the input.\n-    scheduleOnNextTick(() => controller.abort())\n+      return controller.signal\n+    case 'prerender-client':\n+    case 'prerender-ppr':\n+    case 'prerender-legacy':\n+    case 'request':\n+    case 'cache':\n+    case 'unstable-cache':\n+      return undefined\n+    default:\n+      workUnitStore satisfies never\n   }\n-\n-  return controller.signal\n }\n \n export function annotateDynamicAccess(\n@@ -580,21 +577,32 @@ export function useDynamicRouteParams(expression: string) {\n     // accesses.\n     const workUnitStore = workUnitAsyncStorage.getStore()\n     if (workUnitStore) {\n-      // We're prerendering with dynamicIO or PPR or both\n-      if (workUnitStore.type === 'prerender-client') {\n-        // We are in a prerender with dynamicIO semantics\n-        // We are going to hang here and never resolve. This will cause the currently\n-        // rendering component to effectively be a dynamic hole\n-        React.use(makeHangingPromise(workUnitStore.renderSignal, expression))\n-      } else if (workUnitStore.type === 'prerender-ppr') {\n-        // We're prerendering with PPR\n-        postponeWithTracking(\n-          workStore.route,\n-          expression,\n-          workUnitStore.dynamicTracking\n-        )\n-      } else if (workUnitStore.type === 'prerender-legacy') {\n-        throwToInterruptStaticGeneration(expression, workStore, workUnitStore)\n+      switch (workUnitStore.type) {\n+        case 'prerender-client':\n+          // We are in a prerender with dynamicIO semantics. We are going to\n+          // hang here and never resolve. This will cause the currently\n+          // rendering component to effectively be a dynamic hole.\n+          React.use(makeHangingPromise(workUnitStore.renderSignal, expression))\n+          break\n+        case 'prerender':\n+        case 'prerender-ppr':\n+          return postponeWithTracking(\n+            workStore.route,\n+            expression,\n+            workUnitStore.dynamicTracking\n+          )\n+        case 'prerender-legacy':\n+          return throwToInterruptStaticGeneration(\n+            expression,\n+            workStore,\n+            workUnitStore\n+          )\n+        case 'request':\n+        case 'cache':\n+        case 'unstable-cache':\n+          break\n+        default:\n+          workUnitStore satisfies never\n       }\n     }\n   }"
        },
        {
            "sha": "a9027e3cb235e228b0c788995799ce0d8115c9ec",
            "filename": "packages/next/src/server/app-render/encryption.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 25,
            "changes": 57,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fencryption.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fencryption.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fencryption.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -17,6 +17,7 @@ import {\n   stringToUint8Array,\n } from './encryption-utils'\n import {\n+  getCacheSignal,\n   getPrerenderResumeDataCache,\n   getRenderResumeDataCache,\n   workUnitAsyncStorage,\n@@ -95,10 +96,9 @@ enum ReadStatus {\n export const encryptActionBoundArgs = React.cache(\n   async function encryptActionBoundArgs(actionId: string, ...args: any[]) {\n     const workUnitStore = workUnitAsyncStorage.getStore()\n-    const cacheSignal =\n-      workUnitStore?.type === 'prerender'\n-        ? workUnitStore.cacheSignal\n-        : undefined\n+    const cacheSignal = workUnitStore\n+      ? getCacheSignal(workUnitStore)\n+      : undefined\n \n     const { clientModules } = getClientReferenceManifestForRsc()\n \n@@ -109,10 +109,9 @@ export const encryptActionBoundArgs = React.cache(\n \n     let didCatchError = false\n \n-    const hangingInputAbortSignal =\n-      workUnitStore?.type === 'prerender'\n-        ? createHangingInputAbortSignal(workUnitStore)\n-        : undefined\n+    const hangingInputAbortSignal = workUnitStore\n+      ? createHangingInputAbortSignal(workUnitStore)\n+      : undefined\n \n     let readStatus = ReadStatus.Ready\n     function startReadOnce() {\n@@ -227,9 +226,7 @@ export async function decryptActionBoundArgs(\n   let decrypted: string | undefined\n \n   if (workUnitStore) {\n-    const cacheSignal =\n-      workUnitStore.type === 'prerender' ? workUnitStore.cacheSignal : undefined\n-\n+    const cacheSignal = getCacheSignal(workUnitStore)\n     const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n     const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n \n@@ -256,20 +253,30 @@ export async function decryptActionBoundArgs(\n       start(controller) {\n         controller.enqueue(textEncoder.encode(decrypted))\n \n-        if (workUnitStore?.type === 'prerender') {\n-          // Explicitly don't close the stream here (until prerendering is\n-          // complete) so that hanging promises are not rejected.\n-          if (workUnitStore.renderSignal.aborted) {\n-            controller.close()\n-          } else {\n-            workUnitStore.renderSignal.addEventListener(\n-              'abort',\n-              () => controller.close(),\n-              { once: true }\n-            )\n-          }\n-        } else {\n-          controller.close()\n+        switch (workUnitStore?.type) {\n+          case 'prerender':\n+            // Explicitly don't close the stream here (until prerendering is\n+            // complete) so that hanging promises are not rejected.\n+            if (workUnitStore.renderSignal.aborted) {\n+              controller.close()\n+            } else {\n+              workUnitStore.renderSignal.addEventListener(\n+                'abort',\n+                () => controller.close(),\n+                { once: true }\n+              )\n+            }\n+            break\n+          case 'prerender-client':\n+          case 'prerender-ppr':\n+          case 'prerender-legacy':\n+          case 'request':\n+          case 'cache':\n+          case 'unstable-cache':\n+          case undefined:\n+            return controller.close()\n+          default:\n+            workUnitStore satisfies never\n         }\n       },\n     }),"
        },
        {
            "sha": "88b6b844ab42a9102c9bee4b23ca6e02b1108b7b",
            "filename": "packages/next/src/server/app-render/use-flight-response.tsx",
            "status": "modified",
            "additions": 17,
            "deletions": 7,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fuse-flight-response.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fuse-flight-response.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fuse-flight-response.tsx?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -51,17 +51,27 @@ export function useFlightStream<T>(\n   // that requires the nextTick behavior. This is why it is safe to access a node only API here\n   if (process.env.NEXT_RUNTIME !== 'edge') {\n     const workUnitStore = workUnitAsyncStorage.getStore()\n+\n     if (!workUnitStore) {\n       throw new InvariantError('Expected workUnitAsyncStorage to have a store.')\n     }\n-    if (workUnitStore.type === 'prerender-client') {\n-      const responseOnNextTick = new Promise<T>((r) => {\n-        process.nextTick(() => {\n-          r(newResponse)\n+\n+    switch (workUnitStore.type) {\n+      case 'prerender-client':\n+        const responseOnNextTick = new Promise<T>((resolve) => {\n+          process.nextTick(() => resolve(newResponse))\n         })\n-      })\n-      flightResponses.set(flightStream, responseOnNextTick)\n-      return responseOnNextTick\n+        flightResponses.set(flightStream, responseOnNextTick)\n+        return responseOnNextTick\n+      case 'prerender':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'request':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n     }\n   }\n "
        },
        {
            "sha": "98baaefdcf70a87ef132fe75363da20f34d51ac0",
            "filename": "packages/next/src/server/app-render/work-unit-async-storage.external.ts",
            "status": "modified",
            "additions": 61,
            "deletions": 20,
            "changes": 81,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -264,8 +264,7 @@ export function getExpectedRequestStore(\n       )\n \n     default:\n-      const _exhaustiveCheck: never = workUnitStore\n-      return _exhaustiveCheck\n+      return workUnitStore satisfies never\n   }\n }\n \n@@ -278,16 +277,22 @@ export function throwForMissingRequestStore(callingExpression: string): never {\n export function getPrerenderResumeDataCache(\n   workUnitStore: WorkUnitStore\n ): PrerenderResumeDataCache | null {\n-  if (\n-    workUnitStore.type === 'prerender' ||\n-    // TODO eliminate fetch caching in client scope and stop exposing this data cache during SSR\n-    workUnitStore.type === 'prerender-client' ||\n-    workUnitStore.type === 'prerender-ppr'\n-  ) {\n-    return workUnitStore.prerenderResumeDataCache\n+  switch (workUnitStore.type) {\n+    case 'prerender':\n+    case 'prerender-ppr':\n+      return workUnitStore.prerenderResumeDataCache\n+    case 'prerender-client':\n+      // TODO eliminate fetch caching in client scope and stop exposing this data\n+      // cache during SSR.\n+      return workUnitStore.prerenderResumeDataCache\n+    case 'prerender-legacy':\n+    case 'request':\n+    case 'cache':\n+    case 'unstable-cache':\n+      return null\n+    default:\n+      return workUnitStore satisfies never\n   }\n-\n-  return null\n }\n \n export function getRenderResumeDataCache(\n@@ -308,24 +313,37 @@ export function getRenderResumeDataCache(\n       // Otherwise we return the mutable resume data cache here as an immutable\n       // version of the cache as it can also be used for reading.\n       return workUnitStore.prerenderResumeDataCache\n-    default:\n+    case 'cache':\n+    case 'unstable-cache':\n+    case 'prerender-legacy':\n       return null\n+    default:\n+      return workUnitStore satisfies never\n   }\n }\n \n export function getHmrRefreshHash(\n   workStore: WorkStore,\n   workUnitStore: WorkUnitStore\n ): string | undefined {\n-  if (!workStore.dev) {\n-    return undefined\n+  if (workStore.dev) {\n+    switch (workUnitStore.type) {\n+      case 'cache':\n+      case 'prerender':\n+        return workUnitStore.hmrRefreshHash\n+      case 'request':\n+        return workUnitStore.cookies.get(NEXT_HMR_REFRESH_HASH_COOKIE)?.value\n+      case 'prerender-client':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n+    }\n   }\n \n-  return workUnitStore.type === 'cache' || workUnitStore.type === 'prerender'\n-    ? workUnitStore.hmrRefreshHash\n-    : workUnitStore.type === 'request'\n-      ? workUnitStore.cookies.get(NEXT_HMR_REFRESH_HASH_COOKIE)?.value\n-      : undefined\n+  return undefined\n }\n \n /**\n@@ -341,10 +359,33 @@ export function getDraftModeProviderForCacheScope(\n       case 'unstable-cache':\n       case 'request':\n         return workUnitStore.draftMode\n+      case 'prerender':\n+      case 'prerender-client':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+        break\n       default:\n-        return undefined\n+        workUnitStore satisfies never\n     }\n   }\n \n   return undefined\n }\n+\n+export function getCacheSignal(\n+  workUnitStore: WorkUnitStore\n+): CacheSignal | null {\n+  switch (workUnitStore.type) {\n+    case 'prerender':\n+    case 'prerender-client':\n+      return workUnitStore.cacheSignal\n+    case 'prerender-ppr':\n+    case 'prerender-legacy':\n+    case 'request':\n+    case 'cache':\n+    case 'unstable-cache':\n+      return null\n+    default:\n+      return workUnitStore satisfies never\n+  }\n+}"
        },
        {
            "sha": "a109e5513aec6d07b207030fa2296e798545e1d6",
            "filename": "packages/next/src/server/lib/patch-fetch.ts",
            "status": "modified",
            "additions": 283,
            "deletions": 175,
            "changes": 458,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -15,14 +15,21 @@ import { markCurrentScopeAsDynamic } from '../app-render/dynamic-rendering'\n import { makeHangingPromise } from '../dynamic-rendering-utils'\n import type { FetchMetric } from '../base-http'\n import { createDedupeFetch } from './dedupe-fetch'\n-import type { WorkUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n+import {\n+  getCacheSignal,\n+  type WorkUnitAsyncStorage,\n+  type WorkUnitStore,\n+} from '../app-render/work-unit-async-storage.external'\n import {\n   CachedRouteKind,\n   IncrementalCacheKind,\n   type CachedFetchData,\n+  type ServerComponentsHmrCache,\n+  type SetIncrementalFetchCacheContext,\n } from '../response-cache'\n import { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\n import { cloneResponse } from './clone-response'\n+import type { IncrementalCache } from './incremental-cache'\n \n const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n \n@@ -142,6 +149,115 @@ function trackFetchMetric(\n   })\n }\n \n+async function createCachedPrerenderResponse(\n+  res: Response,\n+  cacheKey: string,\n+  incrementalCacheContext: SetIncrementalFetchCacheContext | undefined,\n+  incrementalCache: IncrementalCache,\n+  revalidate: number,\n+  handleUnlock: () => Promise<void> | void\n+): Promise<Response> {\n+  // We are prerendering at build time or revalidate time with dynamicIO so we\n+  // need to buffer the response so we can guarantee it can be read in a\n+  // microtask.\n+  const bodyBuffer = await res.arrayBuffer()\n+\n+  const fetchedData = {\n+    headers: Object.fromEntries(res.headers.entries()),\n+    body: Buffer.from(bodyBuffer).toString('base64'),\n+    status: res.status,\n+    url: res.url,\n+  }\n+\n+  // We can skip setting the serverComponentsHmrCache because we aren't in dev\n+  // mode.\n+\n+  if (incrementalCacheContext) {\n+    await incrementalCache.set(\n+      cacheKey,\n+      { kind: CachedRouteKind.FETCH, data: fetchedData, revalidate },\n+      incrementalCacheContext\n+    )\n+  }\n+\n+  await handleUnlock()\n+\n+  // We return a new Response to the caller.\n+  return new Response(bodyBuffer, {\n+    headers: res.headers,\n+    status: res.status,\n+    statusText: res.statusText,\n+  })\n+}\n+\n+async function createCachedDynamicResponse(\n+  workStore: WorkStore,\n+  res: Response,\n+  cacheKey: string,\n+  incrementalCacheContext: SetIncrementalFetchCacheContext | undefined,\n+  incrementalCache: IncrementalCache,\n+  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n+  revalidate: number,\n+  input: RequestInfo | URL,\n+  handleUnlock: () => Promise<void> | void\n+): Promise<Response> {\n+  // We're cloning the response using this utility because there exists a bug in\n+  // the undici library around response cloning. See the following pull request\n+  // for more details: https://github.com/vercel/next.js/pull/73274\n+  const [cloned1, cloned2] = cloneResponse(res)\n+\n+  // We are dynamically rendering including dev mode. We want to return the\n+  // response to the caller as soon as possible because it might stream over a\n+  // very long time.\n+  const cacheSetPromise = cloned1\n+    .arrayBuffer()\n+    .then(async (arrayBuffer) => {\n+      const bodyBuffer = Buffer.from(arrayBuffer)\n+\n+      const fetchedData = {\n+        headers: Object.fromEntries(cloned1.headers.entries()),\n+        body: bodyBuffer.toString('base64'),\n+        status: cloned1.status,\n+        url: cloned1.url,\n+      }\n+\n+      serverComponentsHmrCache?.set(cacheKey, fetchedData)\n+\n+      if (incrementalCacheContext) {\n+        await incrementalCache.set(\n+          cacheKey,\n+          { kind: CachedRouteKind.FETCH, data: fetchedData, revalidate },\n+          incrementalCacheContext\n+        )\n+      }\n+    })\n+    .catch((error) => console.warn(`Failed to set fetch cache`, input, error))\n+    .finally(handleUnlock)\n+\n+  const pendingRevalidateKey = `cache-set-${cacheKey}`\n+  workStore.pendingRevalidates ??= {}\n+\n+  if (pendingRevalidateKey in workStore.pendingRevalidates) {\n+    // there is already a pending revalidate entry that we need to await to\n+    // avoid race conditions\n+    await workStore.pendingRevalidates[pendingRevalidateKey]\n+  }\n+\n+  workStore.pendingRevalidates[pendingRevalidateKey] = cacheSetPromise.finally(\n+    () => {\n+      // If the pending revalidate is not present in the store, then we have\n+      // nothing to delete.\n+      if (!workStore.pendingRevalidates?.[pendingRevalidateKey]) {\n+        return\n+      }\n+\n+      delete workStore.pendingRevalidates[pendingRevalidateKey]\n+    }\n+  )\n+\n+  return cloned2\n+}\n+\n interface PatchableModule {\n   workAsyncStorage: WorkAsyncStorage\n   workUnitAsyncStorage: WorkUnitAsyncStorage\n@@ -184,10 +300,7 @@ export function createPatchedFetcher(\n     const workUnitStore = workUnitAsyncStorage.getStore()\n \n     // During static generation we track cache reads so we can reason about when they fill\n-    let cacheSignal =\n-      workUnitStore && workUnitStore.type === 'prerender'\n-        ? workUnitStore.cacheSignal\n-        : null\n+    let cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n     if (cacheSignal) {\n       cacheSignal.beginRead()\n     }\n@@ -252,16 +365,25 @@ export function createPatchedFetcher(\n           `fetch ${input.toString()}`\n         )\n \n-        const revalidateStore =\n-          workUnitStore &&\n-          (workUnitStore.type === 'cache' ||\n-            workUnitStore.type === 'prerender' ||\n-            // TODO: stop accumulating tags in client prerender\n-            workUnitStore.type === 'prerender-client' ||\n-            workUnitStore.type === 'prerender-ppr' ||\n-            workUnitStore.type === 'prerender-legacy')\n-            ? workUnitStore\n-            : undefined\n+        let revalidateStore: Extract<WorkUnitStore, { tags: any }> | undefined\n+\n+        if (workUnitStore) {\n+          switch (workUnitStore.type) {\n+            case 'prerender':\n+            // TODO: Stop accumulating tags in client prerender. (fallthrough)\n+            case 'prerender-client':\n+            case 'prerender-ppr':\n+            case 'prerender-legacy':\n+            case 'cache':\n+              revalidateStore = workUnitStore\n+              break\n+            case 'request':\n+            case 'unstable-cache':\n+              break\n+            default:\n+              workUnitStore satisfies never\n+          }\n+        }\n \n         if (revalidateStore) {\n           if (Array.isArray(tags)) {\n@@ -278,12 +400,26 @@ export function createPatchedFetcher(\n \n         const implicitTags = workUnitStore?.implicitTags\n \n-        // Inside unstable-cache we treat it the same as force-no-store on the\n-        // page.\n-        const pageFetchCacheMode =\n-          workUnitStore && workUnitStore.type === 'unstable-cache'\n-            ? 'force-no-store'\n-            : workStore.fetchCache\n+        let pageFetchCacheMode = workStore.fetchCache\n+\n+        if (workUnitStore) {\n+          switch (workUnitStore.type) {\n+            case 'unstable-cache':\n+              // Inside unstable-cache we treat it the same as force-no-store on\n+              // the page.\n+              pageFetchCacheMode = 'force-no-store'\n+              break\n+            case 'prerender':\n+            case 'prerender-client':\n+            case 'prerender-ppr':\n+            case 'prerender-legacy':\n+            case 'request':\n+            case 'cache':\n+              break\n+            default:\n+              workUnitStore satisfies never\n+          }\n+        }\n \n         const isUsingNoStore = !!workStore.isUnstableNoStore\n \n@@ -409,25 +545,33 @@ export function createPatchedFetcher(\n           }\n         }\n \n-        if (\n-          hasNoExplicitCacheConfig &&\n-          workUnitStore !== undefined &&\n-          (workUnitStore.type === 'prerender' ||\n-            // While we don't want to do caching in the client scope\n-            // we know the fetch will be dynamic for dynamicIO so we\n-            // may as well avoid the call here\n-            workUnitStore.type === 'prerender-client')\n-        ) {\n-          // If we have no cache config, and we're in Dynamic I/O prerendering, it'll be a dynamic call.\n-          // We don't have to issue that dynamic call.\n-          if (cacheSignal) {\n-            cacheSignal.endRead()\n-            cacheSignal = null\n+        // If we have no cache config, and we're in Dynamic I/O prerendering,\n+        // it'll be a dynamic call. We don't have to issue that dynamic call.\n+        if (hasNoExplicitCacheConfig && workUnitStore !== undefined) {\n+          switch (workUnitStore.type) {\n+            case 'prerender':\n+            // While we don't want to do caching in the client scope we know the\n+            // fetch will be dynamic for dynamicIO so we may as well avoid the\n+            // call here. (fallthrough)\n+            case 'prerender-client':\n+              if (cacheSignal) {\n+                cacheSignal.endRead()\n+                cacheSignal = null\n+              }\n+\n+              return makeHangingPromise<Response>(\n+                workUnitStore.renderSignal,\n+                'fetch()'\n+              )\n+            case 'prerender-ppr':\n+            case 'prerender-legacy':\n+            case 'request':\n+            case 'cache':\n+            case 'unstable-cache':\n+              break\n+            default:\n+              workUnitStore satisfies never\n           }\n-          return makeHangingPromise<Response>(\n-            workUnitStore.renderSignal,\n-            'fetch()'\n-          )\n         }\n \n         switch (pageFetchCacheMode) {\n@@ -523,8 +667,14 @@ export function createPatchedFetcher(\n                     workUnitStore.renderSignal,\n                     'fetch()'\n                   )\n+                case 'prerender-ppr':\n+                case 'prerender-legacy':\n+                case 'request':\n+                case 'cache':\n+                case 'unstable-cache':\n+                  break\n                 default:\n-                // fallthrough\n+                  workUnitStore satisfies never\n               }\n             }\n \n@@ -548,16 +698,30 @@ export function createPatchedFetcher(\n \n         let cacheKey: string | undefined\n         const { incrementalCache } = workStore\n-\n-        const useCacheOrRequestStore =\n-          workUnitStore?.type === 'request' || workUnitStore?.type === 'cache'\n-            ? workUnitStore\n-            : undefined\n+        let isHmrRefresh = false\n+        let serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n+\n+        if (workUnitStore) {\n+          switch (workUnitStore.type) {\n+            case 'request':\n+            case 'cache':\n+              isHmrRefresh = workUnitStore.isHmrRefresh ?? false\n+              serverComponentsHmrCache = workUnitStore.serverComponentsHmrCache\n+              break\n+            case 'prerender':\n+            case 'prerender-client':\n+            case 'prerender-ppr':\n+            case 'prerender-legacy':\n+            case 'unstable-cache':\n+              break\n+            default:\n+              workUnitStore satisfies never\n+          }\n+        }\n \n         if (\n           incrementalCache &&\n-          (isCacheableRevalidate ||\n-            useCacheOrRequestStore?.serverComponentsHmrCache)\n+          (isCacheableRevalidate || serverComponentsHmrCache)\n         ) {\n           try {\n             cacheKey = await incrementalCache.generateCacheKey(\n@@ -643,128 +807,55 @@ export function createPatchedFetcher(\n                 res.status === 200 &&\n                 incrementalCache &&\n                 cacheKey &&\n-                (isCacheableRevalidate ||\n-                  useCacheOrRequestStore?.serverComponentsHmrCache)\n+                (isCacheableRevalidate || serverComponentsHmrCache)\n               ) {\n                 const normalizedRevalidate =\n                   finalRevalidate >= INFINITE_CACHE\n                     ? CACHE_ONE_YEAR\n                     : finalRevalidate\n \n-                if (\n-                  workUnitStore &&\n-                  (workUnitStore.type === 'prerender' ||\n-                    workUnitStore.type === 'prerender-client')\n-                ) {\n-                  // We are prerendering at build time or revalidate time with dynamicIO so we need to\n-                  // buffer the response so we can guarantee it can be read in a microtask\n-                  const bodyBuffer = await res.arrayBuffer()\n-\n-                  const fetchedData = {\n-                    headers: Object.fromEntries(res.headers.entries()),\n-                    body: Buffer.from(bodyBuffer).toString('base64'),\n-                    status: res.status,\n-                    url: res.url,\n-                  }\n-\n-                  // We can skip checking the serverComponentsHmrCache because we aren't in\n-                  // dev mode.\n-\n-                  await incrementalCache.set(\n-                    cacheKey,\n-                    {\n-                      kind: CachedRouteKind.FETCH,\n-                      data: fetchedData,\n-                      revalidate: normalizedRevalidate,\n-                    },\n-                    {\n+                const incrementalCacheConfig:\n+                  | SetIncrementalFetchCacheContext\n+                  | undefined = isCacheableRevalidate\n+                  ? {\n                       fetchCache: true,\n                       fetchUrl,\n                       fetchIdx,\n                       tags,\n                       isImplicitBuildTimeCache,\n                     }\n-                  )\n-                  await handleUnlock()\n-\n-                  // We return a new Response to the caller.\n-                  return new Response(bodyBuffer, {\n-                    headers: res.headers,\n-                    status: res.status,\n-                    statusText: res.statusText,\n-                  })\n-                } else {\n-                  // We're cloning the response using this utility because there\n-                  // exists a bug in the undici library around response cloning.\n-                  // See the following pull request for more details:\n-                  // https://github.com/vercel/next.js/pull/73274\n-\n-                  const [cloned1, cloned2] = cloneResponse(res)\n-\n-                  // We are dynamically rendering including dev mode. We want to return\n-                  // the response to the caller as soon as possible because it might stream\n-                  // over a very long time.\n-                  const cacheSetPromise = cloned1\n-                    .arrayBuffer()\n-                    .then(async (arrayBuffer) => {\n-                      const bodyBuffer = Buffer.from(arrayBuffer)\n-\n-                      const fetchedData = {\n-                        headers: Object.fromEntries(cloned1.headers.entries()),\n-                        body: bodyBuffer.toString('base64'),\n-                        status: cloned1.status,\n-                        url: cloned1.url,\n-                      }\n-\n-                      useCacheOrRequestStore?.serverComponentsHmrCache?.set(\n-                        cacheKey,\n-                        fetchedData\n-                      )\n-\n-                      if (isCacheableRevalidate) {\n-                        await incrementalCache.set(\n-                          cacheKey,\n-                          {\n-                            kind: CachedRouteKind.FETCH,\n-                            data: fetchedData,\n-                            revalidate: normalizedRevalidate,\n-                          },\n-                          {\n-                            fetchCache: true,\n-                            fetchUrl,\n-                            fetchIdx,\n-                            tags,\n-                            isImplicitBuildTimeCache,\n-                          }\n-                        )\n-                      }\n-                    })\n-                    .catch((error) =>\n-                      console.warn(`Failed to set fetch cache`, input, error)\n-                    )\n-                    .finally(handleUnlock)\n+                  : undefined\n \n-                  const pendingRevalidateKey = `cache-set-${cacheKey}`\n-                  workStore.pendingRevalidates ??= {}\n-                  if (pendingRevalidateKey in workStore.pendingRevalidates) {\n-                    // there is already a pending revalidate entry that\n-                    // we need to await to avoid race conditions\n-                    await workStore.pendingRevalidates[pendingRevalidateKey]\n-                  }\n-                  workStore.pendingRevalidates[pendingRevalidateKey] =\n-                    cacheSetPromise.finally(() => {\n-                      // If the pending revalidate is not present in the store, then\n-                      // we have nothing to delete.\n-                      if (\n-                        !workStore.pendingRevalidates?.[pendingRevalidateKey]\n-                      ) {\n-                        return\n-                      }\n-\n-                      delete workStore.pendingRevalidates[pendingRevalidateKey]\n-                    })\n-\n-                  return cloned2\n+                switch (workUnitStore?.type) {\n+                  case 'prerender':\n+                  case 'prerender-client':\n+                    return createCachedPrerenderResponse(\n+                      res,\n+                      cacheKey,\n+                      incrementalCacheConfig,\n+                      incrementalCache,\n+                      normalizedRevalidate,\n+                      handleUnlock\n+                    )\n+                  case 'prerender-ppr':\n+                  case 'prerender-legacy':\n+                  case 'request':\n+                  case 'cache':\n+                  case 'unstable-cache':\n+                  case undefined:\n+                    return createCachedDynamicResponse(\n+                      workStore,\n+                      res,\n+                      cacheKey,\n+                      incrementalCacheConfig,\n+                      incrementalCache,\n+                      serverComponentsHmrCache,\n+                      normalizedRevalidate,\n+                      input,\n+                      handleUnlock\n+                    )\n+                  default:\n+                    workUnitStore satisfies never\n                 }\n               }\n \n@@ -787,13 +878,8 @@ export function createPatchedFetcher(\n         if (cacheKey && incrementalCache) {\n           let cachedFetchData: CachedFetchData | undefined\n \n-          if (\n-            useCacheOrRequestStore?.isHmrRefresh &&\n-            useCacheOrRequestStore.serverComponentsHmrCache\n-          ) {\n-            cachedFetchData =\n-              useCacheOrRequestStore.serverComponentsHmrCache.get(cacheKey)\n-\n+          if (isHmrRefresh && serverComponentsHmrCache) {\n+            cachedFetchData = serverComponentsHmrCache.get(cacheKey)\n             isHmrRefreshCache = true\n           }\n \n@@ -810,16 +896,25 @@ export function createPatchedFetcher(\n                   softTags: implicitTags?.tags,\n                 })\n \n-            if (hasNoExplicitCacheConfig) {\n-              // We sometimes use the cache to dedupe fetches that do not specify a cache configuration\n-              // In these cases we want to make sure we still exclude them from prerenders if dynamicIO is on\n-              // so we introduce an artificial Task boundary here.\n-              if (\n-                workUnitStore &&\n-                (workUnitStore.type === 'prerender' ||\n-                  workUnitStore.type === 'prerender-client')\n-              ) {\n-                await waitAtLeastOneReactRenderTask()\n+            if (hasNoExplicitCacheConfig && workUnitStore) {\n+              switch (workUnitStore.type) {\n+                case 'prerender':\n+                case 'prerender-client':\n+                  // We sometimes use the cache to dedupe fetches that do not\n+                  // specify a cache configuration. In these cases we want to\n+                  // make sure we still exclude them from prerenders if\n+                  // dynamicIO is on so we introduce an artificial task boundary\n+                  // here.\n+                  await waitAtLeastOneReactRenderTask()\n+                  break\n+                case 'prerender-ppr':\n+                case 'prerender-legacy':\n+                case 'request':\n+                case 'cache':\n+                case 'unstable-cache':\n+                  break\n+                default:\n+                  workUnitStore satisfies never\n               }\n             }\n \n@@ -913,8 +1008,14 @@ export function createPatchedFetcher(\n                     workUnitStore.renderSignal,\n                     'fetch()'\n                   )\n+                case 'prerender-ppr':\n+                case 'prerender-legacy':\n+                case 'request':\n+                case 'cache':\n+                case 'unstable-cache':\n+                  break\n                 default:\n-                // fallthrough\n+                  workUnitStore satisfies never\n               }\n             }\n             markCurrentScopeAsDynamic(\n@@ -941,8 +1042,14 @@ export function createPatchedFetcher(\n                       workUnitStore.renderSignal,\n                       'fetch()'\n                     )\n+                  case 'request':\n+                  case 'cache':\n+                  case 'unstable-cache':\n+                  case 'prerender-legacy':\n+                  case 'prerender-ppr':\n+                    break\n                   default:\n-                  // fallthrough\n+                    workUnitStore satisfies never\n                 }\n               }\n               markCurrentScopeAsDynamic(\n@@ -1057,6 +1164,7 @@ export function createPatchedFetcher(\n \n   return patched\n }\n+\n // we patch fetch to collect cache information used for\n // determining if a page is static or not\n export function patchFetch(options: PatchableModule) {"
        },
        {
            "sha": "5f628e05af831700b9cd2c5b01f1ea78cc3f729f",
            "filename": "packages/next/src/server/node-environment-extensions/console-dev.tsx",
            "status": "modified",
            "additions": 16,
            "deletions": 9,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-dev.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-dev.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Fconsole-dev.tsx?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -128,15 +128,22 @@ function patchConsoleMethodDEV(methodName: InterceptableConsoleMethod): void {\n     const originalName = Object.getOwnPropertyDescriptor(originalMethod, 'name')\n     const wrapperMethod = function (this: typeof console, ...args: any[]) {\n       const workUnitStore = workUnitAsyncStorage.getStore()\n-      const isPrerenderValidation =\n-        workUnitStore !== undefined &&\n-        (workUnitStore.type === 'prerender-client' ||\n-          workUnitStore.type === 'prerender')\n-\n-      if (isPrerenderValidation) {\n-        originalMethod.apply(this, dimConsoleCall(methodName, args))\n-      } else {\n-        originalMethod.apply(this, args)\n+\n+      switch (workUnitStore?.type) {\n+        case 'prerender':\n+        case 'prerender-client':\n+          originalMethod.apply(this, dimConsoleCall(methodName, args))\n+          break\n+        case 'prerender-ppr':\n+        case 'prerender-legacy':\n+        case 'request':\n+        case 'cache':\n+        case 'unstable-cache':\n+        case undefined:\n+          originalMethod.apply(this, args)\n+          break\n+        default:\n+          workUnitStore satisfies never\n       }\n     }\n     if (originalName) {"
        },
        {
            "sha": "ebbb3ec96eec19b7444a83b16aeab2af2ed10775",
            "filename": "packages/next/src/server/node-environment-extensions/utils.tsx",
            "status": "modified",
            "additions": 106,
            "deletions": 73,
            "changes": 179,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -1,5 +1,8 @@\n import { workAsyncStorage } from '../app-render/work-async-storage.external'\n-import { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n+import {\n+  workUnitAsyncStorage,\n+  type PrerenderStoreModern,\n+} from '../app-render/work-unit-async-storage.external'\n import {\n   abortOnSynchronousPlatformIOAccess,\n   trackSynchronousPlatformIOAccessInDev,\n@@ -10,93 +13,123 @@ type ApiType = 'time' | 'random' | 'crypto'\n \n export function io(expression: string, type: ApiType) {\n   const workUnitStore = workUnitAsyncStorage.getStore()\n-  if (workUnitStore) {\n-    let isClient = false\n-    if (\n-      workUnitStore.type === 'prerender' ||\n-      (isClient = workUnitStore.type === 'prerender-client')\n-    ) {\n+  const workStore = workAsyncStorage.getStore()\n+\n+  if (!workUnitStore || !workStore) {\n+    return\n+  }\n+\n+  switch (workUnitStore.type) {\n+    case 'prerender': {\n       const prerenderSignal = workUnitStore.controller.signal\n+\n       if (prerenderSignal.aborted === false) {\n-        // If the prerender signal is already aborted we don't need to construct any stacks\n-        // because something else actually terminated the prerender.\n-        const workStore = workAsyncStorage.getStore()\n-        if (workStore) {\n-          let message: string\n-          switch (type) {\n-            case 'time':\n-              message = isClient\n-                ? `Route \"${workStore.route}\" used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time-client`\n-                : `Route \"${workStore.route}\" used ${expression} instead of using \\`performance\\` or without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time`\n-              break\n-            case 'random':\n-              message = isClient\n-                ? `Route \"${workStore.route}\" used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-random-client`\n-                : `Route \"${workStore.route}\" used ${expression} outside of \\`\"use cache\"\\` and without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-random`\n-              break\n-            case 'crypto':\n-              message = isClient\n-                ? `Route \"${workStore.route}\" used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto-client`\n-                : `Route \"${workStore.route}\" used ${expression} outside of \\`\"use cache\"\\` and without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto`\n-              break\n-            default:\n-              throw new InvariantError(\n-                'Unknown expression type in abortOnSynchronousPlatformIOAccess.'\n-              )\n-          }\n+        // If the prerender signal is already aborted we don't need to construct\n+        // any stacks because something else actually terminated the prerender.\n+        let message: string\n+        switch (type) {\n+          case 'time':\n+            message = `Route \"${workStore.route}\" used ${expression} instead of using \\`performance\\` or without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time`\n+            break\n+          case 'random':\n+            message = `Route \"${workStore.route}\" used ${expression} outside of \\`\"use cache\"\\` and without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-random`\n+            break\n+          case 'crypto':\n+            message = `Route \"${workStore.route}\" used ${expression} outside of \\`\"use cache\"\\` and without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto`\n+            break\n+          default:\n+            throw new InvariantError(\n+              'Unknown expression type in abortOnSynchronousPlatformIOAccess.'\n+            )\n+        }\n \n-          const errorWithStack = new Error(message)\n-\n-          if (\n-            process.env.NODE_ENV !== 'production' &&\n-            workUnitStore.captureOwnerStack\n-          ) {\n-            const ownerStack = workUnitStore.captureOwnerStack()\n-\n-            if (ownerStack) {\n-              // TODO: Instead of stitching the stacks here, we should log the\n-              // original error as-is when it occurs (i.e. here), and let\n-              // `patchErrorInspect` handle adding the owner stack, instead of\n-              // logging it deferred in the `LogSafely` component via\n-              // `throwIfDisallowedDynamic`.\n-              applyOwnerStack(errorWithStack, ownerStack)\n-            }\n-          }\n+        abortOnSynchronousPlatformIOAccess(\n+          workStore.route,\n+          expression,\n+          applyOwnerStack(new Error(message), workUnitStore),\n+          workUnitStore\n+        )\n+      }\n+      break\n+    }\n+    case 'prerender-client': {\n+      const prerenderSignal = workUnitStore.controller.signal\n \n-          abortOnSynchronousPlatformIOAccess(\n-            workStore.route,\n-            expression,\n-            errorWithStack,\n-            workUnitStore\n-          )\n+      if (prerenderSignal.aborted === false) {\n+        // If the prerender signal is already aborted we don't need to construct\n+        // any stacks because something else actually terminated the prerender.\n+        let message: string\n+        switch (type) {\n+          case 'time':\n+            message = `Route \"${workStore.route}\" used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time-client`\n+            break\n+          case 'random':\n+            message = `Route \"${workStore.route}\" used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-random-client`\n+            break\n+          case 'crypto':\n+            message = `Route \"${workStore.route}\" used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto-client`\n+            break\n+          default:\n+            throw new InvariantError(\n+              'Unknown expression type in abortOnSynchronousPlatformIOAccess.'\n+            )\n         }\n+\n+        abortOnSynchronousPlatformIOAccess(\n+          workStore.route,\n+          expression,\n+          applyOwnerStack(new Error(message), workUnitStore),\n+          workUnitStore\n+        )\n       }\n-    } else if (\n-      workUnitStore.type === 'request' &&\n-      workUnitStore.prerenderPhase === true\n-    ) {\n-      const requestStore = workUnitStore\n-      trackSynchronousPlatformIOAccessInDev(requestStore)\n+      break\n     }\n+    case 'request':\n+      if (workUnitStore.prerenderPhase === true) {\n+        trackSynchronousPlatformIOAccessInDev(workUnitStore)\n+      }\n+      break\n+    case 'prerender-ppr':\n+    case 'prerender-legacy':\n+    case 'cache':\n+    case 'unstable-cache':\n+      break\n+    default:\n+      workUnitStore satisfies never\n   }\n }\n \n-function applyOwnerStack(error: Error, ownerStack: string) {\n-  let stack = ownerStack\n+function applyOwnerStack(error: Error, workUnitStore: PrerenderStoreModern) {\n+  // TODO: Instead of stitching the stacks here, we should log the original\n+  // error as-is when it occurs, and let `patchErrorInspect` handle adding the\n+  // owner stack, instead of logging it deferred in the `LogSafely` component\n+  // via `throwIfDisallowedDynamic`.\n+  if (\n+    process.env.NODE_ENV !== 'production' &&\n+    workUnitStore.captureOwnerStack\n+  ) {\n+    const ownerStack = workUnitStore.captureOwnerStack()\n+\n+    if (ownerStack) {\n+      let stack = ownerStack\n \n-  if (error.stack) {\n-    const frames: string[] = []\n+      if (error.stack) {\n+        const frames: string[] = []\n \n-    for (const frame of error.stack.split('\\n').slice(1)) {\n-      if (frame.includes('react_stack_bottom_frame')) {\n-        break\n+        for (const frame of error.stack.split('\\n').slice(1)) {\n+          if (frame.includes('react_stack_bottom_frame')) {\n+            break\n+          }\n+\n+          frames.push(frame)\n+        }\n+\n+        stack = '\\n' + frames.join('\\n') + stack\n       }\n \n-      frames.push(frame)\n+      error.stack = error.name + ': ' + error.message + stack\n     }\n-\n-    stack = '\\n' + frames.join('\\n') + stack\n   }\n \n-  error.stack = error.name + ': ' + error.message + stack\n+  return error\n }"
        },
        {
            "sha": "d3fbe4f2f89573e020fcd44752e19a95415fd23c",
            "filename": "packages/next/src/server/request/connection.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 35,
            "changes": 75,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -30,53 +30,58 @@ export function connection(): Promise<void> {\n     }\n \n     if (workStore.forceStatic) {\n-      // When using forceStatic we override all other logic and always just return an empty\n-      // headers object without tracking\n+      // When using forceStatic, we override all other logic and always just\n+      // return a resolving promise without tracking.\n       return Promise.resolve(undefined)\n     }\n \n-    if (workUnitStore) {\n-      if (workUnitStore.type === 'cache') {\n-        throw new Error(\n-          `Route ${workStore.route} used \"connection\" inside \"use cache\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n-        )\n-      } else if (workUnitStore.type === 'unstable-cache') {\n-        throw new Error(\n-          `Route ${workStore.route} used \"connection\" inside a function cached with \"unstable_cache(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n-        )\n-      }\n-    }\n     if (workStore.dynamicShouldError) {\n       throw new StaticGenBailoutError(\n         `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`connection\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n       )\n     }\n \n     if (workUnitStore) {\n-      if (\n-        workUnitStore.type === 'prerender' ||\n-        workUnitStore.type === 'prerender-client'\n-      ) {\n-        // dynamicIO Prerender\n-        // We return a promise that never resolves to allow the prender to stall at this point\n-        return makeHangingPromise(workUnitStore.renderSignal, '`connection()`')\n-      } else if (workUnitStore.type === 'prerender-ppr') {\n-        // PPR Prerender (no dynamicIO)\n-        // We use React's postpone API to interrupt rendering here to create a dynamic hole\n-        postponeWithTracking(\n-          workStore.route,\n-          'connection',\n-          workUnitStore.dynamicTracking\n-        )\n-      } else if (workUnitStore.type === 'prerender-legacy') {\n-        // Legacy Prerender\n-        // We throw an error here to interrupt prerendering to mark the route as dynamic\n-        throwToInterruptStaticGeneration('connection', workStore, workUnitStore)\n+      switch (workUnitStore.type) {\n+        case 'cache':\n+          throw new Error(\n+            `Route ${workStore.route} used \"connection\" inside \"use cache\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+          )\n+        case 'unstable-cache':\n+          throw new Error(\n+            `Route ${workStore.route} used \"connection\" inside a function cached with \"unstable_cache(...)\". The \\`connection()\\` function is used to indicate the subsequent code must only run when there is an actual Request, but caches must be able to be produced before a Request so this function is not allowed in this scope. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n+          )\n+        case 'prerender':\n+        case 'prerender-client':\n+          // We return a promise that never resolves to allow the prerender to\n+          // stall at this point.\n+          return makeHangingPromise(\n+            workUnitStore.renderSignal,\n+            '`connection()`'\n+          )\n+        case 'prerender-ppr':\n+          // We use React's postpone API to interrupt rendering here to create a\n+          // dynamic hole\n+          return postponeWithTracking(\n+            workStore.route,\n+            'connection',\n+            workUnitStore.dynamicTracking\n+          )\n+        case 'prerender-legacy':\n+          // We throw an error here to interrupt prerendering to mark the route\n+          // as dynamic\n+          return throwToInterruptStaticGeneration(\n+            'connection',\n+            workStore,\n+            workUnitStore\n+          )\n+        case 'request':\n+          trackDynamicDataInDynamicRender(workUnitStore)\n+          break\n+        default:\n+          workUnitStore satisfies never\n       }\n     }\n-    // We fall through to the dynamic context below but we still track dynamic access\n-    // because in dev we can still error for things like using headers inside a cache context\n-    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n   }\n \n   return Promise.resolve(undefined)"
        },
        {
            "sha": "472219f50be5499bb1b88388918ad007905f0b7d",
            "filename": "packages/next/src/server/request/cookies.ts",
            "status": "modified",
            "additions": 38,
            "deletions": 33,
            "changes": 71,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -72,17 +72,6 @@ export function cookies(): Promise<ReadonlyRequestCookies> {\n       return makeUntrackedExoticCookies(underlyingCookies)\n     }\n \n-    if (workUnitStore) {\n-      if (workUnitStore.type === 'cache') {\n-        throw new Error(\n-          `Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n-        )\n-      } else if (workUnitStore.type === 'unstable-cache') {\n-        throw new Error(\n-          `Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n-        )\n-      }\n-    }\n     if (workStore.dynamicShouldError) {\n       throw new StaticGenBailoutError(\n         `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`cookies\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n@@ -91,6 +80,14 @@ export function cookies(): Promise<ReadonlyRequestCookies> {\n \n     if (workUnitStore) {\n       switch (workUnitStore.type) {\n+        case 'cache':\n+          throw new Error(\n+            `Route ${workStore.route} used \"cookies\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+          )\n+        case 'unstable-cache':\n+          throw new Error(\n+            `Route ${workStore.route} used \"cookies\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"cookies\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n+          )\n         case 'prerender':\n           return makeHangingCookies(workUnitStore)\n         case 'prerender-client':\n@@ -99,32 +96,28 @@ export function cookies(): Promise<ReadonlyRequestCookies> {\n             `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n           )\n         case 'prerender-ppr':\n-          // PPR Prerender (no dynamicIO)\n-          // We are prerendering with PPR. We need track dynamic access here eagerly\n-          // to keep continuity with how cookies has worked in PPR without dynamicIO.\n-          postponeWithTracking(\n+          // We need track dynamic access here eagerly to keep continuity with\n+          // how cookies has worked in PPR without dynamicIO.\n+          return postponeWithTracking(\n             workStore.route,\n             callingExpression,\n             workUnitStore.dynamicTracking\n           )\n-          break\n         case 'prerender-legacy':\n-          // Legacy Prerender\n-          // We track dynamic access here so we don't need to wrap the cookies in\n-          // individual property access tracking.\n-          throwToInterruptStaticGeneration(\n+          // We track dynamic access here so we don't need to wrap the cookies\n+          // in individual property access tracking.\n+          return throwToInterruptStaticGeneration(\n             callingExpression,\n             workStore,\n             workUnitStore\n           )\n+        case 'request':\n+          trackDynamicDataInDynamicRender(workUnitStore)\n           break\n         default:\n-        // fallthrough\n+          workUnitStore satisfies never\n       }\n     }\n-    // We fall through to the dynamic context below but we still track dynamic access\n-    // because in dev we can still error for things like using cookies inside a cache context\n-    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n   }\n \n   // cookies is being called in a dynamic context\n@@ -459,16 +452,28 @@ function describeNameArg(arg: unknown) {\n \n function syncIODev(route: string | undefined, expression: string) {\n   const workUnitStore = workUnitAsyncStorage.getStore()\n-  if (\n-    workUnitStore &&\n-    workUnitStore.type === 'request' &&\n-    workUnitStore.prerenderPhase === true\n-  ) {\n-    // When we're rendering dynamically in dev we need to advance out of the\n-    // Prerender environment when we read Request data synchronously\n-    const requestStore = workUnitStore\n-    trackSynchronousRequestDataAccessInDev(requestStore)\n+\n+  if (workUnitStore) {\n+    switch (workUnitStore.type) {\n+      case 'request':\n+        if (workUnitStore.prerenderPhase === true) {\n+          // When we're rendering dynamically in dev, we need to advance out of\n+          // the Prerender environment when we read Request data synchronously.\n+          trackSynchronousRequestDataAccessInDev(workUnitStore)\n+        }\n+        break\n+      case 'prerender':\n+      case 'prerender-client':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n+    }\n   }\n+\n   // In all cases we warn normally\n   warnForSyncAccess(route, expression)\n }"
        },
        {
            "sha": "d1a6aa9ba3980cc2fc8c92b784f8fe1600312c69",
            "filename": "packages/next/src/server/request/draft-mode.ts",
            "status": "modified",
            "additions": 39,
            "deletions": 36,
            "changes": 75,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fdraft-mode.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fdraft-mode.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fdraft-mode.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -13,6 +13,7 @@ import { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.exte\n import {\n   abortAndThrowOnSynchronousRequestDataAccess,\n   postponeWithTracking,\n+  trackDynamicDataInDynamicRender,\n   trackSynchronousRequestDataAccessInDev,\n } from '../app-render/dynamic-rendering'\n import { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\n@@ -81,8 +82,7 @@ export function draftMode(): Promise<DraftMode> {\n       return createOrGetCachedDraftMode(null, workStore)\n \n     default:\n-      const _exhaustiveCheck: never = workUnitStore\n-      return _exhaustiveCheck\n+      return workUnitStore satisfies never\n   }\n }\n \n@@ -244,16 +244,28 @@ class DraftMode {\n \n function syncIODev(route: string | undefined, expression: string) {\n   const workUnitStore = workUnitAsyncStorage.getStore()\n-  if (\n-    workUnitStore &&\n-    workUnitStore.type === 'request' &&\n-    workUnitStore.prerenderPhase === true\n-  ) {\n-    // When we're rendering dynamically in dev we need to advance out of the\n-    // Prerender environment when we read Request data synchronously\n-    const requestStore = workUnitStore\n-    trackSynchronousRequestDataAccessInDev(requestStore)\n+\n+  if (workUnitStore) {\n+    switch (workUnitStore.type) {\n+      case 'request':\n+        if (workUnitStore.prerenderPhase === true) {\n+          // When we're rendering dynamically in dev, we need to advance out of\n+          // the Prerender environment when we read Request data synchronously.\n+          trackSynchronousRequestDataAccessInDev(workUnitStore)\n+        }\n+        break\n+      case 'prerender':\n+      case 'prerender-client':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n+    }\n   }\n+\n   // In all cases we warn normally\n   warnForSyncAccess(route, expression)\n }\n@@ -280,20 +292,10 @@ function trackDynamicDraftMode(expression: string) {\n   if (store) {\n     // We have a store we want to track dynamic data access to ensure we\n     // don't statically generate routes that manipulate draft mode.\n-    if (workUnitStore) {\n-      if (workUnitStore.type === 'cache') {\n-        throw new Error(\n-          `Route ${store.route} used \"${expression}\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n-        )\n-      } else if (workUnitStore.type === 'unstable-cache') {\n-        throw new Error(\n-          `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n-        )\n-      } else if (workUnitStore.phase === 'after') {\n-        throw new Error(\n-          `Route ${store.route} used \"${expression}\" inside \\`after\\`. The enabled status of draftMode can be read inside \\`after\\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n-        )\n-      }\n+    if (workUnitStore?.phase === 'after') {\n+      throw new Error(\n+        `Route ${store.route} used \"${expression}\" inside \\`after\\`. The enabled status of draftMode can be read inside \\`after\\` but you cannot enable or disable draftMode. See more info here: https://nextjs.org/docs/app/api-reference/functions/after`\n+      )\n     }\n \n     if (store.dynamicShouldError) {\n@@ -304,33 +306,36 @@ function trackDynamicDraftMode(expression: string) {\n \n     if (workUnitStore) {\n       switch (workUnitStore.type) {\n+        case 'cache':\n+          throw new Error(\n+            `Route ${store.route} used \"${expression}\" inside \"use cache\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+          )\n+        case 'unstable-cache':\n+          throw new Error(\n+            `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". The enabled status of draftMode can be read in caches but you must not enable or disable draftMode inside a cache. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n+          )\n         case 'prerender':\n-          // dynamicIO Prerender\n           const error = new Error(\n             `Route ${store.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-headers`\n           )\n-          abortAndThrowOnSynchronousRequestDataAccess(\n+          return abortAndThrowOnSynchronousRequestDataAccess(\n             store.route,\n             expression,\n             error,\n             workUnitStore\n           )\n-          break\n         case 'prerender-client':\n           const exportName = '`draftMode`'\n           throw new InvariantError(\n             `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n           )\n         case 'prerender-ppr':\n-          // PPR Prerender\n-          postponeWithTracking(\n+          return postponeWithTracking(\n             store.route,\n             expression,\n             workUnitStore.dynamicTracking\n           )\n-          break\n         case 'prerender-legacy':\n-          // legacy Prerender\n           workUnitStore.revalidate = 0\n \n           const err = new DynamicServerError(\n@@ -341,12 +346,10 @@ function trackDynamicDraftMode(expression: string) {\n \n           throw err\n         case 'request':\n-          if (process.env.NODE_ENV === 'development') {\n-            workUnitStore.usedDynamic = true\n-          }\n+          trackDynamicDataInDynamicRender(workUnitStore)\n           break\n         default:\n-        // fallthrough\n+          workUnitStore satisfies never\n       }\n     }\n   }"
        },
        {
            "sha": "d1fe9412544be39b946864d2e3712ab6707dec46",
            "filename": "packages/next/src/server/request/headers.ts",
            "status": "modified",
            "additions": 48,
            "deletions": 24,
            "changes": 72,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -77,16 +77,26 @@ export function headers(): Promise<ReadonlyHeaders> {\n     }\n \n     if (workUnitStore) {\n-      if (workUnitStore.type === 'cache') {\n-        throw new Error(\n-          `Route ${workStore.route} used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n-        )\n-      } else if (workUnitStore.type === 'unstable-cache') {\n-        throw new Error(\n-          `Route ${workStore.route} used \"headers\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n-        )\n+      switch (workUnitStore.type) {\n+        case 'cache':\n+          throw new Error(\n+            `Route ${workStore.route} used \"headers\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+          )\n+        case 'unstable-cache':\n+          throw new Error(\n+            `Route ${workStore.route} used \"headers\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"headers\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n+          )\n+        case 'prerender':\n+        case 'prerender-client':\n+        case 'prerender-ppr':\n+        case 'prerender-legacy':\n+        case 'request':\n+          break\n+        default:\n+          workUnitStore satisfies never\n       }\n     }\n+\n     if (workStore.dynamicShouldError) {\n       throw new StaticGenBailoutError(\n         `Route ${workStore.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`headers\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n@@ -107,26 +117,28 @@ export function headers(): Promise<ReadonlyHeaders> {\n           // We are prerendering with PPR. We need track dynamic access here eagerly\n           // to keep continuity with how headers has worked in PPR without dynamicIO.\n           // TODO consider switching the semantic to throw on property access instead\n-          postponeWithTracking(\n+          return postponeWithTracking(\n             workStore.route,\n             'headers',\n             workUnitStore.dynamicTracking\n           )\n-          break\n         case 'prerender-legacy':\n           // Legacy Prerender\n           // We are in a legacy static generation mode while prerendering\n           // We track dynamic access here so we don't need to wrap the headers in\n           // individual property access tracking.\n-          throwToInterruptStaticGeneration('headers', workStore, workUnitStore)\n+          return throwToInterruptStaticGeneration(\n+            'headers',\n+            workStore,\n+            workUnitStore\n+          )\n+        case 'request':\n+          trackDynamicDataInDynamicRender(workUnitStore)\n           break\n         default:\n-        // fallthrough\n+          workUnitStore satisfies never\n       }\n     }\n-    // We fall through to the dynamic context below but we still track dynamic access\n-    // because in dev we can still error for things like using headers inside a cache context\n-    trackDynamicDataInDynamicRender(workStore, workUnitStore)\n   }\n \n   const requestStore = getExpectedRequestStore('headers')\n@@ -391,16 +403,28 @@ function describeNameArg(arg: unknown) {\n \n function syncIODev(route: string | undefined, expression: string) {\n   const workUnitStore = workUnitAsyncStorage.getStore()\n-  if (\n-    workUnitStore &&\n-    workUnitStore.type === 'request' &&\n-    workUnitStore.prerenderPhase === true\n-  ) {\n-    // When we're rendering dynamically in dev we need to advance out of the\n-    // Prerender environment when we read Request data synchronously\n-    const requestStore = workUnitStore\n-    trackSynchronousRequestDataAccessInDev(requestStore)\n+\n+  if (workUnitStore) {\n+    switch (workUnitStore.type) {\n+      case 'request':\n+        if (workUnitStore.prerenderPhase === true) {\n+          // When we're rendering dynamically in dev, we need to advance out of\n+          // the Prerender environment when we read Request data synchronously.\n+          trackSynchronousRequestDataAccessInDev(workUnitStore)\n+        }\n+        break\n+      case 'prerender':\n+      case 'prerender-client':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n+    }\n   }\n+\n   // In all cases we warn normally\n   warnForSyncAccess(route, expression)\n }"
        },
        {
            "sha": "6c644cd0748958af37698478c213b2ff494c7cd2",
            "filename": "packages/next/src/server/request/params.ts",
            "status": "modified",
            "additions": 63,
            "deletions": 28,
            "changes": 91,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -68,8 +68,12 @@ export function createParamsFromClient(\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n         return createPrerenderParams(underlyingParams, workStore, workUnitStore)\n+      case 'request':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n       default:\n-      // fallthrough\n+        workUnitStore satisfies never\n     }\n   }\n   return createRenderParams(underlyingParams, workStore)\n@@ -92,8 +96,12 @@ export function createServerParamsForRoute(\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n         return createPrerenderParams(underlyingParams, workStore, workUnitStore)\n+      case 'request':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n       default:\n-      // fallthrough\n+        workUnitStore satisfies never\n     }\n   }\n   return createRenderParams(underlyingParams, workStore)\n@@ -111,8 +119,12 @@ export function createServerParamsForServerSegment(\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n         return createPrerenderParams(underlyingParams, workStore, workUnitStore)\n+      case 'request':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n       default:\n-      // fallthrough\n+        workUnitStore satisfies never\n     }\n   }\n   return createRenderParams(underlyingParams, workStore)\n@@ -122,22 +134,32 @@ export function createPrerenderParamsForClientSegment(\n   underlyingParams: Params,\n   workStore: WorkStore\n ): Promise<Params> {\n-  const prerenderStore = workUnitAsyncStorage.getStore()\n-  if (\n-    prerenderStore &&\n-    (prerenderStore.type === 'prerender' ||\n-      prerenderStore.type === 'prerender-client')\n-  ) {\n-    const fallbackParams = workStore.fallbackRouteParams\n-    if (fallbackParams) {\n-      for (let key in underlyingParams) {\n-        if (fallbackParams.has(key)) {\n-          // This params object has one of more fallback params so we need to consider\n-          // the awaiting of this params object \"dynamic\". Since we are in dynamicIO mode\n-          // we encode this as a promise that never resolves\n-          return makeHangingPromise(prerenderStore.renderSignal, '`params`')\n+  const workUnitStore = workUnitAsyncStorage.getStore()\n+  if (workUnitStore) {\n+    switch (workUnitStore.type) {\n+      case 'prerender':\n+      case 'prerender-client':\n+        const fallbackParams = workStore.fallbackRouteParams\n+        if (fallbackParams) {\n+          for (let key in underlyingParams) {\n+            if (fallbackParams.has(key)) {\n+              // This params object has one or more fallback params, so we need\n+              // to consider the awaiting of this params object \"dynamic\". Since\n+              // we are in dynamicIO mode we encode this as a promise that never\n+              // resolves.\n+              return makeHangingPromise(workUnitStore.renderSignal, '`params`')\n+            }\n+          }\n         }\n-      }\n+        break\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'request':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n     }\n   }\n   // We're prerendering in a mode that does not abort. We resolve the promise without\n@@ -168,13 +190,16 @@ function createPrerenderParams(\n         case 'prerender-client':\n           // We are in a dynamicIO prerender\n           return makeHangingParams(underlyingParams, prerenderStore)\n-        default:\n+        case 'prerender-ppr':\n+        case 'prerender-legacy':\n           return makeErroringExoticParams(\n             underlyingParams,\n             fallbackParams,\n             workStore,\n             prerenderStore\n           )\n+        default:\n+          prerenderStore satisfies never\n       }\n     }\n   }\n@@ -516,15 +541,25 @@ function syncIODev(\n   missingProperties?: Array<string>\n ) {\n   const workUnitStore = workUnitAsyncStorage.getStore()\n-  if (\n-    workUnitStore &&\n-    workUnitStore.type === 'request' &&\n-    workUnitStore.prerenderPhase === true\n-  ) {\n-    // When we're rendering dynamically in dev we need to advance out of the\n-    // Prerender environment when we read Request data synchronously\n-    const requestStore = workUnitStore\n-    trackSynchronousRequestDataAccessInDev(requestStore)\n+  if (workUnitStore) {\n+    switch (workUnitStore.type) {\n+      case 'request':\n+        if (workUnitStore.prerenderPhase === true) {\n+          // When we're rendering dynamically in dev, we need to advance out of\n+          // the Prerender environment when we read Request data synchronously.\n+          trackSynchronousRequestDataAccessInDev(workUnitStore)\n+        }\n+        break\n+      case 'prerender':\n+      case 'prerender-client':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n+    }\n   }\n   // In all cases we warn normally\n   if (missingProperties && missingProperties.length > 0) {"
        },
        {
            "sha": "462e15df38ad6b7c4ffb3946a5c65366c68844a1",
            "filename": "packages/next/src/server/request/pathname.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fpathname.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fpathname.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fpathname.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -29,8 +29,12 @@ export function createServerPathnameForMetadata(\n           workUnitStore\n         )\n       }\n+      case 'request':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n       default:\n-      // fallthrough\n+        workUnitStore satisfies never\n     }\n   }\n   return createRenderPathname(underlyingPathname)\n@@ -55,9 +59,10 @@ function createPrerenderPathname(\n         )\n       case 'prerender-ppr':\n         return makeErroringPathname(workStore, prerenderStore.dynamicTracking)\n-        break\n-      default:\n+      case 'prerender-legacy':\n         return makeErroringPathname(workStore, null)\n+      default:\n+        prerenderStore satisfies never\n     }\n   }\n "
        },
        {
            "sha": "32c53a050b2a32aa32cd6e49c03c3eebf0eba2fc",
            "filename": "packages/next/src/server/request/root-params.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Froot-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Froot-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Froot-params.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -54,8 +54,10 @@ export async function unstable_rootParams(): Promise<Params> {\n         workStore,\n         workUnitStore\n       )\n-    default:\n+    case 'request':\n       return Promise.resolve(workUnitStore.rootParams)\n+    default:\n+      return workUnitStore satisfies never\n   }\n }\n \n@@ -96,8 +98,8 @@ function createPrerenderRootParams(\n           throw new InvariantError(\n             `${exportName} must not be used within a client component. Next.js should be preventing ${exportName} from being included in client components statically, but did not in this case.`\n           )\n-        default:\n-          // remaining cases are prerender-ppr and prerender-legacy\n+        case 'prerender-ppr':\n+        case 'prerender-legacy':\n           // We aren't in a dynamicIO prerender but we do have fallback params at this\n           // level so we need to make an erroring params object which will postpone\n           // if you access the fallback params\n@@ -107,6 +109,8 @@ function createPrerenderRootParams(\n             workStore,\n             prerenderStore\n           )\n+        default:\n+          prerenderStore satisfies never\n       }\n     }\n   }"
        },
        {
            "sha": "a8dfa840dbe00db3ecd6258abc0dad3cc4c9da2c",
            "filename": "packages/next/src/server/request/search-params.ts",
            "status": "modified",
            "additions": 63,
            "deletions": 33,
            "changes": 96,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -72,8 +72,12 @@ export function createSearchParamsFromClient(\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n         return createPrerenderSearchParams(workStore, workUnitStore)\n+      case 'request':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n       default:\n-      // fallthrough\n+        workUnitStore satisfies never\n     }\n   }\n   return createRenderSearchParams(underlyingSearchParams, workStore)\n@@ -95,8 +99,12 @@ export function createServerSearchParamsForServerPage(\n       case 'prerender-ppr':\n       case 'prerender-legacy':\n         return createPrerenderSearchParams(workStore, workUnitStore)\n+      case 'request':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n       default:\n-      // fallthrough\n+        workUnitStore satisfies never\n     }\n   }\n   return createRenderSearchParams(underlyingSearchParams, workStore)\n@@ -111,20 +119,27 @@ export function createPrerenderSearchParamsForClientPage(\n     return Promise.resolve({})\n   }\n \n-  const prerenderStore = workUnitAsyncStorage.getStore()\n-  if (\n-    prerenderStore &&\n-    (prerenderStore.type === 'prerender' ||\n-      prerenderStore.type === 'prerender-client')\n-  ) {\n-    // dynamicIO Prerender\n-    // We're prerendering in a mode that aborts (dynamicIO) and should stall\n-    // the promise to ensure the RSC side is considered dynamic\n-    return makeHangingPromise(prerenderStore.renderSignal, '`searchParams`')\n+  const workUnitStore = workUnitAsyncStorage.getStore()\n+  if (workUnitStore) {\n+    switch (workUnitStore.type) {\n+      case 'prerender':\n+      case 'prerender-client':\n+        // We're prerendering in a mode that aborts (dynamicIO) and should stall\n+        // the promise to ensure the RSC side is considered dynamic\n+        return makeHangingPromise(workUnitStore.renderSignal, '`searchParams`')\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'request':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n+    }\n   }\n-  // We're prerendering in a mode that does not aborts. We resolve the promise without\n-  // any tracking because we're just transporting a value from server to client where the tracking\n-  // will be applied.\n+  // We're prerendering in a mode that does not abort. We resolve the promise\n+  // without any tracking because we're just transporting a value from server to\n+  // client where the tracking will be applied.\n   return Promise.resolve({})\n }\n \n@@ -143,11 +158,13 @@ function createPrerenderSearchParams(\n     case 'prerender-client':\n       // We are in a dynamicIO (PPR or otherwise) prerender\n       return makeHangingSearchParams(prerenderStore)\n-    default:\n-      // The remaining cases are prerender-ppr and prerender-legacy\n-      // We are in a legacy static generation and need to interrupt the prerender\n-      // when search params are accessed.\n+    case 'prerender-ppr':\n+    case 'prerender-legacy':\n+      // We are in a legacy static generation and need to interrupt the\n+      // prerender when search params are accessed.\n       return makeErroringExoticSearchParams(workStore, prerenderStore)\n+    default:\n+      return prerenderStore satisfies never\n   }\n }\n \n@@ -180,7 +197,7 @@ function createRenderSearchParams(\n         return makeUntrackedSearchParams(underlyingSearchParams)\n       }\n \n-      return makeUntrackedExoticSearchParams(underlyingSearchParams, workStore)\n+      return makeUntrackedExoticSearchParams(underlyingSearchParams)\n     }\n   }\n }\n@@ -464,8 +481,7 @@ export function makeErroringExoticSearchParamsForUseCache(\n }\n \n function makeUntrackedExoticSearchParams(\n-  underlyingSearchParams: SearchParams,\n-  store: WorkStore\n+  underlyingSearchParams: SearchParams\n ): Promise<SearchParams> {\n   const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n   if (cachedSearchParams) {\n@@ -483,7 +499,9 @@ function makeUntrackedExoticSearchParams(\n       Object.defineProperty(promise, prop, {\n         get() {\n           const workUnitStore = workUnitAsyncStorage.getStore()\n-          trackDynamicDataInDynamicRender(store, workUnitStore)\n+          if (workUnitStore) {\n+            trackDynamicDataInDynamicRender(workUnitStore)\n+          }\n           return underlyingSearchParams[prop]\n         },\n         set(value) {\n@@ -546,7 +564,9 @@ function makeDynamicallyTrackedExoticSearchParamsWithDevWarnings(\n           )\n         }\n         const workUnitStore = workUnitAsyncStorage.getStore()\n-        trackDynamicDataInDynamicRender(store, workUnitStore)\n+        if (workUnitStore) {\n+          trackDynamicDataInDynamicRender(workUnitStore)\n+        }\n       }\n       return ReflectAdapter.get(target, prop, receiver)\n     },\n@@ -760,15 +780,25 @@ function syncIODev(\n   }\n \n   const workUnitStore = workUnitAsyncStorage.getStore()\n-  if (\n-    workUnitStore &&\n-    workUnitStore.type === 'request' &&\n-    workUnitStore.prerenderPhase === true\n-  ) {\n-    // When we're rendering dynamically in dev we need to advance out of the\n-    // Prerender environment when we read Request data synchronously\n-    const requestStore = workUnitStore\n-    trackSynchronousRequestDataAccessInDev(requestStore)\n+  if (workUnitStore) {\n+    switch (workUnitStore.type) {\n+      case 'request':\n+        if (workUnitStore.prerenderPhase === true) {\n+          // When we're rendering dynamically in dev, we need to advance out of\n+          // the Prerender environment when we read Request data synchronously.\n+          trackSynchronousRequestDataAccessInDev(workUnitStore)\n+        }\n+        break\n+      case 'prerender':\n+      case 'prerender-client':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'cache':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n+    }\n   }\n }\n "
        },
        {
            "sha": "91342a8fc9ffee08d7b4fe7f53c5e040b2bcadac",
            "filename": "packages/next/src/server/route-modules/app-route/module.ts",
            "status": "modified",
            "additions": 50,
            "deletions": 53,
            "changes": 103,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -84,6 +84,7 @@ import { RedirectStatusCode } from '../../../client/components/redirect-status-c\n import { INFINITE_CACHE } from '../../../lib/constants'\n import { executeRevalidates } from '../../revalidation-utils'\n import { trackPendingModules } from '../../app-render/module-loading/track-module-loading.external'\n+import { InvariantError } from '../../../shared/lib/invariant-error'\n \n export class WrappedNextRouterError {\n   constructor(\n@@ -601,9 +602,7 @@ export class AppRouteRouteModule extends RouteModule<\n         // cookie API.\n         // TODO leaving the gate here b/c it indicates that we might not actually want to do this\n         // on every `do` call. During prerender there should be no mutableCookies because\n-        if (requestStore.type === 'request') {\n-          appendMutableCookies(headers, requestStore.mutableCookies)\n-        }\n+        appendMutableCookies(headers, requestStore.mutableCookies)\n \n         resolvePendingRevalidations()\n \n@@ -647,10 +646,7 @@ export class AppRouteRouteModule extends RouteModule<\n     // to merge the modified cookies and the returned response\n     // here.\n     const headers = new Headers(res.headers)\n-    if (\n-      requestStore.type === 'request' &&\n-      appendMutableCookies(headers, requestStore.mutableCookies)\n-    ) {\n+    if (appendMutableCookies(headers, requestStore.mutableCookies)) {\n       return new Response(res.body, {\n         status: res.status,\n         statusText: res.statusText,\n@@ -1154,60 +1150,61 @@ function trackDynamic(\n   workUnitStore: undefined | WorkUnitStore,\n   expression: string\n ): void {\n-  if (workUnitStore) {\n-    if (workUnitStore.type === 'cache') {\n-      throw new Error(\n-        `Route ${store.route} used \"${expression}\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"${expression}\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n-      )\n-    } else if (workUnitStore.type === 'unstable-cache') {\n-      throw new Error(\n-        `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"${expression}\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n-      )\n-    }\n-  }\n-\n   if (store.dynamicShouldError) {\n     throw new StaticGenBailoutError(\n       `Route ${store.route} with \\`dynamic = \"error\"\\` couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n     )\n   }\n \n   if (workUnitStore) {\n-    if (workUnitStore.type === 'prerender') {\n-      // dynamicIO Prerender\n-      const error = new Error(\n-        `Route ${store.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-request`\n-      )\n-      abortAndThrowOnSynchronousRequestDataAccess(\n-        store.route,\n-        expression,\n-        error,\n-        workUnitStore\n-      )\n-    } else if (workUnitStore.type === 'prerender-ppr') {\n-      // PPR Prerender\n-      postponeWithTracking(\n-        store.route,\n-        expression,\n-        workUnitStore.dynamicTracking\n-      )\n-    } else if (workUnitStore.type === 'prerender-legacy') {\n-      // legacy Prerender\n-      workUnitStore.revalidate = 0\n-\n-      const err = new DynamicServerError(\n-        `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n-      )\n-      store.dynamicUsageDescription = expression\n-      store.dynamicUsageStack = err.stack\n+    switch (workUnitStore.type) {\n+      case 'cache':\n+        throw new Error(\n+          `Route ${store.route} used \"${expression}\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"${expression}\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+        )\n+      case 'unstable-cache':\n+        throw new Error(\n+          `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"${expression}\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n+        )\n+      case 'prerender':\n+        const error = new Error(\n+          `Route ${store.route} used ${expression} without first calling \\`await connection()\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-sync-request`\n+        )\n+        return abortAndThrowOnSynchronousRequestDataAccess(\n+          store.route,\n+          expression,\n+          error,\n+          workUnitStore\n+        )\n+      case 'prerender-client':\n+        throw new InvariantError(\n+          'A client prerender store should not be used for a route handler.'\n+        )\n+      case 'prerender-ppr':\n+        return postponeWithTracking(\n+          store.route,\n+          expression,\n+          workUnitStore.dynamicTracking\n+        )\n+      case 'prerender-legacy':\n+        workUnitStore.revalidate = 0\n \n-      throw err\n-    } else if (\n-      process.env.NODE_ENV === 'development' &&\n-      workUnitStore &&\n-      workUnitStore.type === 'request'\n-    ) {\n-      workUnitStore.usedDynamic = true\n+        const err = new DynamicServerError(\n+          `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n+        )\n+        store.dynamicUsageDescription = expression\n+        store.dynamicUsageStack = err.stack\n+\n+        throw err\n+      case 'request':\n+        if (process.env.NODE_ENV !== 'production') {\n+          // TODO: This is currently not really needed for route handlers, as it\n+          // only controls the ISR status that's shown for pages.\n+          workUnitStore.usedDynamic = true\n+        }\n+        break\n+      default:\n+        workUnitStore satisfies never\n     }\n   }\n }"
        },
        {
            "sha": "c322a3477f41595dda99ba3c036a9ec8da94df26",
            "filename": "packages/next/src/server/use-cache/cache-life.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 4,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fcache-life.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fcache-life.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fcache-life.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -92,10 +92,22 @@ export function cacheLife(profile: CacheLifeProfiles | CacheLife): void {\n   }\n \n   const workUnitStore = workUnitAsyncStorage.getStore()\n-  if (!workUnitStore || workUnitStore.type !== 'cache') {\n-    throw new Error(\n-      'cacheLife() can only be called inside a \"use cache\" function.'\n-    )\n+\n+  switch (workUnitStore?.type) {\n+    case 'prerender':\n+    case 'prerender-client':\n+    case 'prerender-ppr':\n+    case 'prerender-legacy':\n+    case 'request':\n+    case 'unstable-cache':\n+    case undefined:\n+      throw new Error(\n+        'cacheLife() can only be called inside a \"use cache\" function.'\n+      )\n+    case 'cache':\n+      break\n+    default:\n+      workUnitStore satisfies never\n   }\n \n   if (typeof profile === 'string') {"
        },
        {
            "sha": "9e99b558993715bac0600a571cc1b4e4f649bab5",
            "filename": "packages/next/src/server/use-cache/cache-tag.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 4,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fcache-tag.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fcache-tag.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fcache-tag.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -9,10 +9,22 @@ export function cacheTag(...tags: string[]): void {\n   }\n \n   const workUnitStore = workUnitAsyncStorage.getStore()\n-  if (!workUnitStore || workUnitStore.type !== 'cache') {\n-    throw new Error(\n-      'cacheTag() can only be called inside a \"use cache\" function.'\n-    )\n+\n+  switch (workUnitStore?.type) {\n+    case 'prerender':\n+    case 'prerender-client':\n+    case 'prerender-ppr':\n+    case 'prerender-legacy':\n+    case 'request':\n+    case 'unstable-cache':\n+    case undefined:\n+      throw new Error(\n+        'cacheTag() can only be called inside a \"use cache\" function.'\n+      )\n+    case 'cache':\n+      break\n+    default:\n+      workUnitStore satisfies never\n   }\n \n   const validTags = validateTags(tags, 'cacheTag()')"
        },
        {
            "sha": "59126c1d3004eb38f4ec3cbbc4f605e0cbe2f2e6",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 309,
            "deletions": 210,
            "changes": 519,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -17,6 +17,7 @@ import { unstable_prerender as prerender } from 'react-server-dom-webpack/static\n import type { WorkStore } from '../app-render/work-async-storage.external'\n import { workAsyncStorage } from '../app-render/work-async-storage.external'\n import type {\n+  RequestStore,\n   UseCacheStore,\n   WorkUnitStore,\n } from '../app-render/work-unit-async-storage.external'\n@@ -26,6 +27,7 @@ import {\n   getPrerenderResumeDataCache,\n   workUnitAsyncStorage,\n   getDraftModeProviderForCacheScope,\n+  getCacheSignal,\n } from '../app-render/work-unit-async-storage.external'\n \n import { makeHangingPromise } from '../dynamic-rendering-utils'\n@@ -162,11 +164,24 @@ function generateCacheEntryWithCacheContext(\n     )\n   }\n \n-  const useCacheOrRequestStore =\n-    outerWorkUnitStore?.type === 'request' ||\n-    outerWorkUnitStore?.type === 'cache'\n-      ? outerWorkUnitStore\n-      : undefined\n+  let useCacheOrRequestStore: RequestStore | UseCacheStore | undefined\n+\n+  if (outerWorkUnitStore) {\n+    switch (outerWorkUnitStore?.type) {\n+      case 'cache':\n+      case 'request':\n+        useCacheOrRequestStore = outerWorkUnitStore\n+        break\n+      case 'prerender':\n+      case 'prerender-client':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        outerWorkUnitStore satisfies never\n+    }\n+  }\n \n   // Initialize the Store for this Cache entry.\n   const cacheStore: UseCacheStore = {\n@@ -209,30 +224,37 @@ function propagateCacheLifeAndTags(\n   workUnitStore: WorkUnitStore | undefined,\n   entry: CacheEntry\n ): void {\n-  if (\n-    workUnitStore &&\n-    (workUnitStore.type === 'cache' ||\n-      workUnitStore.type === 'prerender' ||\n-      workUnitStore.type === 'prerender-ppr' ||\n-      workUnitStore.type === 'prerender-legacy')\n-  ) {\n-    // Propagate tags and revalidate upwards\n-    const outerTags = workUnitStore.tags ?? (workUnitStore.tags = [])\n-    const entryTags = entry.tags\n-    for (let i = 0; i < entryTags.length; i++) {\n-      const tag = entryTags[i]\n-      if (!outerTags.includes(tag)) {\n-        outerTags.push(tag)\n-      }\n-    }\n-    if (workUnitStore.stale > entry.stale) {\n-      workUnitStore.stale = entry.stale\n-    }\n-    if (workUnitStore.revalidate > entry.revalidate) {\n-      workUnitStore.revalidate = entry.revalidate\n-    }\n-    if (workUnitStore.expire > entry.expire) {\n-      workUnitStore.expire = entry.expire\n+  if (workUnitStore) {\n+    switch (workUnitStore.type) {\n+      case 'cache':\n+      case 'prerender':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+        // Propagate tags and revalidate upwards\n+        const outerTags = workUnitStore.tags ?? (workUnitStore.tags = [])\n+        const entryTags = entry.tags\n+        for (let i = 0; i < entryTags.length; i++) {\n+          const tag = entryTags[i]\n+          if (!outerTags.includes(tag)) {\n+            outerTags.push(tag)\n+          }\n+        }\n+        if (workUnitStore.stale > entry.stale) {\n+          workUnitStore.stale = entry.stale\n+        }\n+        if (workUnitStore.revalidate > entry.revalidate) {\n+          workUnitStore.revalidate = entry.revalidate\n+        }\n+        if (workUnitStore.expire > entry.expire) {\n+          workUnitStore.expire = entry.expire\n+        }\n+        break\n+      case 'prerender-client':\n+      case 'request':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n     }\n   }\n }\n@@ -314,10 +336,9 @@ async function collectResult(\n   // Propagate tags/revalidate to the parent context.\n   propagateCacheLifeAndTags(outerWorkUnitStore, entry)\n \n-  const cacheSignal =\n-    outerWorkUnitStore && outerWorkUnitStore.type === 'prerender'\n-      ? outerWorkUnitStore.cacheSignal\n-      : null\n+  const cacheSignal = outerWorkUnitStore\n+    ? getCacheSignal(outerWorkUnitStore)\n+    : null\n \n   if (cacheSignal) {\n     cacheSignal.endRead()\n@@ -362,22 +383,36 @@ async function generateCacheEntryImpl(\n                 yield entry\n               }\n \n-              // The encoded arguments might contain hanging promises. In this\n-              // case we don't want to reject with \"Error: Connection closed.\",\n-              // so we intentionally keep the iterable alive. This is similar to\n-              // the halting trick that we do while rendering.\n-              if (outerWorkUnitStore?.type === 'prerender') {\n-                await new Promise<void>((resolve) => {\n-                  if (outerWorkUnitStore.renderSignal.aborted) {\n-                    resolve()\n-                  } else {\n-                    outerWorkUnitStore.renderSignal.addEventListener(\n-                      'abort',\n-                      () => resolve(),\n-                      { once: true }\n-                    )\n-                  }\n-                })\n+              if (outerWorkUnitStore) {\n+                switch (outerWorkUnitStore.type) {\n+                  case 'prerender':\n+                    // The encoded arguments might contain hanging promises. In\n+                    // this case we don't want to reject with \"Error: Connection\n+                    // closed.\", so we intentionally keep the iterable alive.\n+                    // This is similar to the halting trick that we do while\n+                    // rendering.\n+                    await new Promise<void>((resolve) => {\n+                      if (outerWorkUnitStore.renderSignal.aborted) {\n+                        resolve()\n+                      } else {\n+                        outerWorkUnitStore.renderSignal.addEventListener(\n+                          'abort',\n+                          () => resolve(),\n+                          { once: true }\n+                        )\n+                      }\n+                    })\n+                    break\n+                  case 'prerender-client':\n+                  case 'prerender-ppr':\n+                  case 'prerender-legacy':\n+                  case 'request':\n+                  case 'cache':\n+                  case 'unstable-cache':\n+                    break\n+                  default:\n+                    outerWorkUnitStore satisfies never\n+                }\n               }\n             },\n           },\n@@ -425,88 +460,99 @@ async function generateCacheEntryImpl(\n \n   let stream: ReadableStream<Uint8Array>\n \n-  if (outerWorkUnitStore?.type === 'prerender') {\n-    const timeoutAbortController = new AbortController()\n-\n-    // If we're prerendering, we give you 50 seconds to fill a cache entry.\n-    // Otherwise we assume you stalled on hanging input and de-opt. This needs\n-    // to be lower than just the general timeout of 60 seconds.\n-    const timer = setTimeout(() => {\n-      workStore.invalidDynamicUsageError = timeoutError\n-      timeoutAbortController.abort(timeoutError)\n-    }, 50000)\n+  switch (outerWorkUnitStore?.type) {\n+    case 'prerender':\n+      const timeoutAbortController = new AbortController()\n+\n+      // If we're prerendering, we give you 50 seconds to fill a cache entry.\n+      // Otherwise we assume you stalled on hanging input and de-opt. This needs\n+      // to be lower than just the general timeout of 60 seconds.\n+      const timer = setTimeout(() => {\n+        workStore.invalidDynamicUsageError = timeoutError\n+        timeoutAbortController.abort(timeoutError)\n+      }, 50000)\n+\n+      const dynamicAccessAbortSignal =\n+        dynamicAccessAsyncStorage.getStore()?.abortController.signal\n+\n+      const abortSignal = dynamicAccessAbortSignal\n+        ? AbortSignal.any([\n+            dynamicAccessAbortSignal,\n+            outerWorkUnitStore.renderSignal,\n+            timeoutAbortController.signal,\n+          ])\n+        : timeoutAbortController.signal\n+\n+      const { prelude } = await prerender(\n+        resultPromise,\n+        clientReferenceManifest.clientModules,\n+        {\n+          environmentName: 'Cache',\n+          filterStackFrame,\n+          signal: abortSignal,\n+          temporaryReferences,\n+          onError(error) {\n+            if (abortSignal.aborted && abortSignal.reason === error) {\n+              return undefined\n+            }\n \n-    const dynamicAccessAbortSignal =\n-      dynamicAccessAsyncStorage.getStore()?.abortController.signal\n+            return handleError(error)\n+          },\n+        }\n+      )\n \n-    const abortSignal = dynamicAccessAbortSignal\n-      ? AbortSignal.any([\n-          dynamicAccessAbortSignal,\n+      clearTimeout(timer)\n+\n+      if (timeoutAbortController.signal.aborted) {\n+        // When the timeout is reached we always error the stream. Even for\n+        // fallback shell prerenders we don't want to return a hanging promise,\n+        // which would allow the function to become a dynamic hole. Because that\n+        // would mean that a non-empty shell could be generated which would be\n+        // subject to revalidation, and we don't want to create long\n+        // revalidation times.\n+        stream = new ReadableStream({\n+          start(controller) {\n+            controller.error(timeoutError)\n+          },\n+        })\n+      } else if (dynamicAccessAbortSignal?.aborted) {\n+        // If the prerender is aborted because of dynamic access (e.g. reading\n+        // fallback params), we return a hanging promise. This essentially makes\n+        // the \"use cache\" function dynamic.\n+        const hangingPromise = makeHangingPromise<never>(\n           outerWorkUnitStore.renderSignal,\n-          timeoutAbortController.signal,\n-        ])\n-      : timeoutAbortController.signal\n-\n-    const { prelude } = await prerender(\n-      resultPromise,\n-      clientReferenceManifest.clientModules,\n-      {\n-        environmentName: 'Cache',\n-        filterStackFrame,\n-        signal: abortSignal,\n-        temporaryReferences,\n-        onError(error) {\n-          if (abortSignal.aborted && abortSignal.reason === error) {\n-            return undefined\n-          }\n-\n-          return handleError(error)\n-        },\n-      }\n-    )\n-\n-    clearTimeout(timer)\n-\n-    if (timeoutAbortController.signal.aborted) {\n-      // When the timeout is reached we always error the stream. Even for\n-      // fallback shell prerenders we don't want to return a hanging promise,\n-      // which would allow the function to become a dynamic hole. Because that\n-      // would mean that a non-empty shell could be generated which would be\n-      // subject to revalidation, and we don't want to create long revalidation\n-      // times.\n-      stream = new ReadableStream({\n-        start(controller) {\n-          controller.error(timeoutError)\n-        },\n-      })\n-    } else if (dynamicAccessAbortSignal?.aborted) {\n-      // If the prerender is aborted because of dynamic access (e.g. reading\n-      // fallback params), we return a hanging promise. This essentially makes\n-      // the \"use cache\" function dynamic.\n-      const hangingPromise = makeHangingPromise<never>(\n-        outerWorkUnitStore.renderSignal,\n-        abortSignal.reason\n-      )\n+          abortSignal.reason\n+        )\n \n-      if (outerWorkUnitStore?.type === 'prerender') {\n-        outerWorkUnitStore.cacheSignal?.endRead()\n-      }\n+        if (outerWorkUnitStore.cacheSignal) {\n+          outerWorkUnitStore.cacheSignal.endRead()\n+        }\n \n-      return { type: 'prerender-dynamic', hangingPromise }\n-    } else {\n-      stream = prelude\n-    }\n-  } else {\n-    stream = renderToReadableStream(\n-      resultPromise,\n-      clientReferenceManifest.clientModules,\n-      {\n-        environmentName: 'Cache',\n-        filterStackFrame,\n-        temporaryReferences,\n-        onError: handleError,\n+        return { type: 'prerender-dynamic', hangingPromise }\n+      } else {\n+        stream = prelude\n       }\n-    )\n+      break\n+    case 'prerender-client':\n+    case 'prerender-ppr':\n+    case 'prerender-legacy':\n+    case 'request':\n+    case 'cache':\n+    case 'unstable-cache':\n+    case undefined:\n+      stream = renderToReadableStream(\n+        resultPromise,\n+        clientReferenceManifest.clientModules,\n+        {\n+          environmentName: 'Cache',\n+          filterStackFrame,\n+          temporaryReferences,\n+          onError: handleError,\n+        }\n+      )\n+      break\n+    default:\n+      return outerWorkUnitStore satisfies never\n   }\n \n   const [returnStream, savedStream] = stream.tee()\n@@ -657,10 +703,9 @@ export function cache(\n       const hmrRefreshHash =\n         workUnitStore && getHmrRefreshHash(workStore, workUnitStore)\n \n-      const hangingInputAbortSignal =\n-        workUnitStore?.type === 'prerender'\n-          ? createHangingInputAbortSignal(workUnitStore)\n-          : undefined\n+      const hangingInputAbortSignal = workUnitStore\n+        ? createHangingInputAbortSignal(workUnitStore)\n+        : undefined\n \n       let isPageOrLayout = false\n \n@@ -758,29 +803,43 @@ export function cache(\n \n       let encodedCacheKeyParts: FormData | string\n \n-      if (workUnitStore?.type === 'prerender' && !isPageOrLayout) {\n-        // If the \"use cache\" function is not a page or a layout, we need to\n-        // track dynamic access already when encoding the arguments. If params\n-        // are passed explicitly into a \"use cache\" function (as opposed to\n-        // receiving them automatically in a page or layout), we assume that the\n-        // params are also accessed. This allows us to abort early, and treat\n-        // the function as dynamic, instead of waiting for the timeout to be\n-        // reached.\n-        const dynamicAccessAbortController = new AbortController()\n-\n-        encodedCacheKeyParts = await dynamicAccessAsyncStorage.run(\n-          { abortController: dynamicAccessAbortController },\n-          encodeCacheKeyParts\n-        )\n+      switch (workUnitStore?.type) {\n+        case 'prerender':\n+          if (!isPageOrLayout) {\n+            // If the \"use cache\" function is not a page or a layout, we need to\n+            // track dynamic access already when encoding the arguments. If\n+            // params are passed explicitly into a \"use cache\" function (as\n+            // opposed to receiving them automatically in a page or layout), we\n+            // assume that the params are also accessed. This allows us to abort\n+            // early, and treat the function as dynamic, instead of waiting for\n+            // the timeout to be reached.\n+            const dynamicAccessAbortController = new AbortController()\n+\n+            encodedCacheKeyParts = await dynamicAccessAsyncStorage.run(\n+              { abortController: dynamicAccessAbortController },\n+              encodeCacheKeyParts\n+            )\n \n-        if (dynamicAccessAbortController.signal.aborted) {\n-          return makeHangingPromise(\n-            workUnitStore.renderSignal,\n-            dynamicAccessAbortController.signal.reason.message\n-          )\n-        }\n-      } else {\n-        encodedCacheKeyParts = await encodeCacheKeyParts()\n+            if (dynamicAccessAbortController.signal.aborted) {\n+              return makeHangingPromise(\n+                workUnitStore.renderSignal,\n+                dynamicAccessAbortController.signal.reason.message\n+              )\n+            }\n+            break\n+          }\n+        // fallthrough\n+        case 'prerender-client':\n+        case 'prerender-ppr':\n+        case 'prerender-legacy':\n+        case 'request':\n+        case 'cache':\n+        case 'unstable-cache':\n+        case undefined:\n+          encodedCacheKeyParts = await encodeCacheKeyParts()\n+          break\n+        default:\n+          return workUnitStore satisfies never\n       }\n \n       const serializedCacheKey =\n@@ -801,10 +860,7 @@ export function cache(\n         : null\n \n       if (renderResumeDataCache) {\n-        const cacheSignal =\n-          workUnitStore && workUnitStore.type === 'prerender'\n-            ? workUnitStore.cacheSignal\n-            : null\n+        const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n \n         if (cacheSignal) {\n           cacheSignal.beginRead()\n@@ -815,22 +871,35 @@ export function cache(\n           propagateCacheLifeAndTags(workUnitStore, existingEntry)\n           if (\n             workUnitStore !== undefined &&\n-            workUnitStore.type === 'prerender' &&\n             existingEntry !== undefined &&\n             (existingEntry.revalidate === 0 ||\n               existingEntry.expire < DYNAMIC_EXPIRE)\n           ) {\n-            // In a Dynamic I/O prerender, if the cache entry has revalidate: 0 or if the\n-            // expire time is under 5 minutes, then we consider this cache entry dynamic\n-            // as it's not worth generating static pages for such data. It's better to leave\n-            // a PPR hole that can be filled in dynamically with a potentially cached entry.\n-            if (cacheSignal) {\n-              cacheSignal.endRead()\n+            switch (workUnitStore.type) {\n+              case 'prerender':\n+                // In a Dynamic I/O prerender, if the cache entry has\n+                // revalidate: 0 or if the expire time is under 5 minutes, then\n+                // we consider this cache entry dynamic as it's not worth\n+                // generating static pages for such data. It's better to leave a\n+                // PPR hole that can be filled in dynamically with a potentially\n+                // cached entry.\n+                if (cacheSignal) {\n+                  cacheSignal.endRead()\n+                }\n+                return makeHangingPromise(\n+                  workUnitStore.renderSignal,\n+                  'dynamic \"use cache\"'\n+                )\n+              case 'prerender-client':\n+              case 'prerender-ppr':\n+              case 'prerender-legacy':\n+              case 'request':\n+              case 'cache':\n+              case 'unstable-cache':\n+                break\n+              default:\n+                workUnitStore satisfies never\n             }\n-            return makeHangingPromise(\n-              workUnitStore.renderSignal,\n-              'dynamic \"use cache\"'\n-            )\n           }\n           const [streamA, streamB] = existingEntry.value.tee()\n           existingEntry.value = streamB\n@@ -847,37 +916,47 @@ export function cache(\n             cacheSignal.endRead()\n           }\n \n-          // If `allowEmptyStaticShell` is true, and a prefilled resume data\n-          // cache was provided, then a cache miss means that params were part\n-          // of the cache key. In this case, we can make this cache function a\n-          // dynamic hole in the shell (or produce an empty shell if there's no\n-          // parent suspense boundary). Currently, this also includes layouts\n-          // and pages that don't read params, which will be improved when we\n-          // implement NAR-136. Otherwise, we assume that if params are passed\n-          // explicitly into a \"use cache\" function, that the params are also\n-          // accessed. This allows us to abort early, and treat the function as\n-          // dynamic, instead of waiting for the timeout to be reached. Compared\n-          // to the instrumentation-based params bailout we do here, this also\n-          // covers the case where params are transformed with an async\n-          // function, before being passed into the \"use cache\" function, which\n-          // escapes the instrumentation.\n-          if (\n-            workUnitStore?.type === 'prerender' &&\n-            workUnitStore.allowEmptyStaticShell\n-          ) {\n-            return makeHangingPromise(\n-              workUnitStore.renderSignal,\n-              'dynamic \"use cache\"'\n-            )\n+          if (workUnitStore) {\n+            switch (workUnitStore.type) {\n+              case 'prerender':\n+                // If `allowEmptyStaticShell` is true, and thus a prefilled\n+                // resume data cache was provided, then a cache miss means that\n+                // params were part of the cache key. In this case, we can make\n+                // this cache function a dynamic hole in the shell (or produce\n+                // an empty shell if there's no parent suspense boundary).\n+                // Currently, this also includes layouts and pages that don't\n+                // read params, which will be improved when we implement\n+                // NAR-136. Otherwise, we assume that if params are passed\n+                // explicitly into a \"use cache\" function, that the params are\n+                // also accessed. This allows us to abort early, and treat the\n+                // function as dynamic, instead of waiting for the timeout to be\n+                // reached. Compared to the instrumentation-based params bailout\n+                // we do here, this also covers the case where params are\n+                // transformed with an async function, before being passed into\n+                // the \"use cache\" function, which escapes the instrumentation.\n+                if (workUnitStore.allowEmptyStaticShell) {\n+                  return makeHangingPromise(\n+                    workUnitStore.renderSignal,\n+                    'dynamic \"use cache\"'\n+                  )\n+                }\n+                break\n+              case 'prerender-client':\n+              case 'prerender-ppr':\n+              case 'prerender-legacy':\n+              case 'request':\n+              case 'cache':\n+              case 'unstable-cache':\n+                break\n+              default:\n+                workUnitStore satisfies never\n+            }\n           }\n         }\n       }\n \n       if (stream === undefined) {\n-        const cacheSignal =\n-          workUnitStore && workUnitStore.type === 'prerender'\n-            ? workUnitStore.cacheSignal\n-            : null\n+        const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n         if (cacheSignal) {\n           // Either the cache handler or the generation can be using I/O at this point.\n           // We need to track when they start and when they complete.\n@@ -937,23 +1016,36 @@ export function cache(\n         const currentTime = performance.timeOrigin + performance.now()\n         if (\n           workUnitStore !== undefined &&\n-          workUnitStore.type === 'prerender' &&\n           entry !== undefined &&\n           (entry.revalidate === 0 || entry.expire < DYNAMIC_EXPIRE)\n         ) {\n-          // In a Dynamic I/O prerender, if the cache entry has revalidate: 0 or if the\n-          // expire time is under 5 minutes, then we consider this cache entry dynamic\n-          // as it's not worth generating static pages for such data. It's better to leave\n-          // a PPR hole that can be filled in dynamically with a potentially cached entry.\n-          if (cacheSignal) {\n-            cacheSignal.endRead()\n+          switch (workUnitStore.type) {\n+            case 'prerender':\n+              // In a Dynamic I/O prerender, if the cache entry has revalidate:\n+              // 0 or if the expire time is under 5 minutes, then we consider\n+              // this cache entry dynamic as it's not worth generating static\n+              // pages for such data. It's better to leave a PPR hole that can\n+              // be filled in dynamically with a potentially cached entry.\n+              if (cacheSignal) {\n+                cacheSignal.endRead()\n+              }\n+              return makeHangingPromise(\n+                workUnitStore.renderSignal,\n+                'dynamic \"use cache\"'\n+              )\n+            case 'prerender-client':\n+            case 'prerender-ppr':\n+            case 'prerender-legacy':\n+            case 'request':\n+            case 'cache':\n+            case 'unstable-cache':\n+              break\n+            default:\n+              workUnitStore satisfies never\n           }\n+        }\n \n-          return makeHangingPromise(\n-            workUnitStore.renderSignal,\n-            'dynamic \"use cache\"'\n-          )\n-        } else if (\n+        if (\n           entry === undefined ||\n           currentTime > entry.timestamp + entry.expire * 1000 ||\n           (workStore.isStaticGeneration &&\n@@ -1170,12 +1262,19 @@ function shouldForceRevalidate(\n   }\n \n   if (workStore.dev && workUnitStore) {\n-    if (workUnitStore.type === 'request') {\n-      return workUnitStore.headers.get('cache-control') === 'no-cache'\n-    }\n-\n-    if (workUnitStore.type === 'cache') {\n-      return workUnitStore.forceRevalidate\n+    switch (workUnitStore.type) {\n+      case 'request':\n+        return workUnitStore.headers.get('cache-control') === 'no-cache'\n+      case 'cache':\n+        return workUnitStore.forceRevalidate\n+      case 'prerender':\n+      case 'prerender-client':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy':\n+      case 'unstable-cache':\n+        break\n+      default:\n+        workUnitStore satisfies never\n     }\n   }\n "
        },
        {
            "sha": "d2750804e889cf8ecf22f4324a179d88d8753845",
            "filename": "packages/next/src/server/web/spec-extension/revalidate.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 18,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Frevalidate.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Frevalidate.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Frevalidate.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -93,48 +93,42 @@ function revalidate(tags: string[], expression: string) {\n \n   const workUnitStore = workUnitAsyncStorage.getStore()\n   if (workUnitStore) {\n-    if (workUnitStore.type === 'cache') {\n-      throw new Error(\n-        `Route ${store.route} used \"${expression}\" inside a \"use cache\" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n-      )\n-    } else if (workUnitStore.type === 'unstable-cache') {\n-      throw new Error(\n-        `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n-      )\n-    }\n     if (workUnitStore.phase === 'render') {\n       throw new Error(\n         `Route ${store.route} used \"${expression}\" during render which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n       )\n     }\n \n     switch (workUnitStore.type) {\n+      case 'cache':\n+        throw new Error(\n+          `Route ${store.route} used \"${expression}\" inside a \"use cache\" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n+        )\n+      case 'unstable-cache':\n+        throw new Error(\n+          `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n+        )\n       case 'prerender':\n-        // dynamicIO Prerender\n         const error = new Error(\n           `Route ${store.route} used ${expression} without first calling \\`await connection()\\`.`\n         )\n-        abortAndThrowOnSynchronousRequestDataAccess(\n+        return abortAndThrowOnSynchronousRequestDataAccess(\n           store.route,\n           expression,\n           error,\n           workUnitStore\n         )\n-        break\n       case 'prerender-client':\n         throw new InvariantError(\n           `${expression} must not be used within a client component. Next.js should be preventing ${expression} from being included in client components statically, but did not in this case.`\n         )\n       case 'prerender-ppr':\n-        // PPR Prerender\n-        postponeWithTracking(\n+        return postponeWithTracking(\n           store.route,\n           expression,\n           workUnitStore.dynamicTracking\n         )\n-        break\n       case 'prerender-legacy':\n-        // legacy Prerender\n         workUnitStore.revalidate = 0\n \n         const err = new DynamicServerError(\n@@ -145,12 +139,15 @@ function revalidate(tags: string[], expression: string) {\n \n         throw err\n       case 'request':\n-        if (process.env.NODE_ENV === 'development') {\n+        if (process.env.NODE_ENV !== 'production') {\n+          // TODO: This is most likely incorrect. It would lead to the ISR\n+          // status being flipped when revalidating a static page with a server\n+          // action.\n           workUnitStore.usedDynamic = true\n         }\n         break\n       default:\n-      // fallthrough\n+        workUnitStore satisfies never\n     }\n   }\n "
        },
        {
            "sha": "db357242fd29eba9019689a0bc67cad2f3ffdca7",
            "filename": "packages/next/src/server/web/spec-extension/unstable-cache.ts",
            "status": "modified",
            "additions": 82,
            "deletions": 51,
            "changes": 133,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-cache.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -2,8 +2,12 @@ import type { IncrementalCache } from '../../lib/incremental-cache'\n \n import { CACHE_ONE_YEAR } from '../../../lib/constants'\n import { validateRevalidate, validateTags } from '../../lib/patch-fetch'\n-import { workAsyncStorage } from '../../app-render/work-async-storage.external'\n import {\n+  workAsyncStorage,\n+  type WorkStore,\n+} from '../../app-render/work-async-storage.external'\n+import {\n+  getCacheSignal,\n   getDraftModeProviderForCacheScope,\n   workUnitAsyncStorage,\n } from '../../app-render/work-unit-async-storage.external'\n@@ -12,7 +16,10 @@ import {\n   IncrementalCacheKind,\n   type CachedFetchData,\n } from '../../response-cache'\n-import type { UnstableCacheStore } from '../../app-render/work-unit-async-storage.external'\n+import type {\n+  UnstableCacheStore,\n+  WorkUnitStore,\n+} from '../../app-render/work-unit-async-storage.external'\n \n type Callback = (...args: any[]) => Promise<any>\n \n@@ -106,39 +113,27 @@ export function unstable_cache<T extends Callback>(\n     }\n     const incrementalCache = maybeIncrementalCache\n \n-    const cacheSignal =\n-      workUnitStore && workUnitStore.type === 'prerender'\n-        ? workUnitStore.cacheSignal\n-        : null\n+    const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n     if (cacheSignal) {\n       cacheSignal.beginRead()\n     }\n     try {\n-      // If there's no request store, we aren't in a request (or we're not in app\n-      // router)  and if there's no static generation store, we aren't in app\n+      // If there's no request store, we aren't in a request (or we're not in\n+      // app router) and if there's no static generation store, we aren't in app\n       // router. Default to an empty pathname and search params when there's no\n       // request store or static generation store available.\n-      const requestStore =\n-        workUnitStore && workUnitStore.type === 'request'\n-          ? workUnitStore\n-          : undefined\n-      const pathname = requestStore?.url.pathname ?? workStore?.route ?? ''\n-      const searchParams = new URLSearchParams(requestStore?.url.search ?? '')\n-\n-      const sortedSearchKeys = [...searchParams.keys()].sort((a, b) => {\n-        return a.localeCompare(b)\n-      })\n-      const sortedSearch = sortedSearchKeys\n-        .map((key) => `${key}=${searchParams.get(key)}`)\n-        .join('&')\n+      const fetchUrlPrefix =\n+        workStore && workUnitStore\n+          ? getFetchUrlPrefix(workStore, workUnitStore)\n+          : ''\n \n       // Construct the complete cache key for this function invocation\n       // @TODO stringify is likely not safe here. We will coerce undefined to null which will make\n       // the keyspace smaller than the execution space\n       const invocationKey = `${fixedKey}-${JSON.stringify(args)}`\n       const cacheKey = await incrementalCache.generateCacheKey(invocationKey)\n       // $urlWithPath,$sortedQueryStringKeys,$hashOfEveryThingElse\n-      const fetchUrl = `unstable_cache ${pathname}${sortedSearch.length ? '?' : ''}${sortedSearch} ${cb.name ? ` ${cb.name}` : cacheKey}`\n+      const fetchUrl = `unstable_cache ${fetchUrlPrefix} ${cb.name ? ` ${cb.name}` : cacheKey}`\n       const fetchIdx =\n         (workStore ? workStore.nextFetchId : noStoreFetchIdx) ?? 1\n \n@@ -161,40 +156,49 @@ export function unstable_cache<T extends Callback>(\n         // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n         // the background. If the entry is missing or invalid we generate a new entry and return it.\n \n-        // We update the store's revalidate property if the option.revalidate is a higher precedence\n-        if (\n-          workUnitStore &&\n-          (workUnitStore.type === 'cache' ||\n-            workUnitStore.type === 'prerender' ||\n-            workUnitStore.type === 'prerender-ppr' ||\n-            workUnitStore.type === 'prerender-legacy')\n-        ) {\n-          // options.revalidate === undefined doesn't affect timing.\n-          // options.revalidate === false doesn't shrink timing. it stays at the maximum.\n-          if (typeof options.revalidate === 'number') {\n-            if (workUnitStore.revalidate < options.revalidate) {\n-              // The store is already revalidating on a shorter time interval, leave it alone\n-            } else {\n-              workUnitStore.revalidate = options.revalidate\n-            }\n-          }\n+        let isNestedUnstableCache = false\n+\n+        if (workUnitStore) {\n+          switch (workUnitStore.type) {\n+            case 'cache':\n+            case 'prerender':\n+            case 'prerender-ppr':\n+            case 'prerender-legacy':\n+              // We update the store's revalidate property if the option.revalidate is a higher precedence\n+              // options.revalidate === undefined doesn't affect timing.\n+              // options.revalidate === false doesn't shrink timing. it stays at the maximum.\n+              if (typeof options.revalidate === 'number') {\n+                if (workUnitStore.revalidate < options.revalidate) {\n+                  // The store is already revalidating on a shorter time interval, leave it alone\n+                } else {\n+                  workUnitStore.revalidate = options.revalidate\n+                }\n+              }\n \n-          // We need to accumulate the tags for this invocation within the store\n-          const collectedTags = workUnitStore.tags\n-          if (collectedTags === null) {\n-            workUnitStore.tags = tags.slice()\n-          } else {\n-            for (const tag of tags) {\n-              // @TODO refactor tags to be a set to avoid this O(n) lookup\n-              if (!collectedTags.includes(tag)) {\n-                collectedTags.push(tag)\n+              // We need to accumulate the tags for this invocation within the store\n+              const collectedTags = workUnitStore.tags\n+              if (collectedTags === null) {\n+                workUnitStore.tags = tags.slice()\n+              } else {\n+                for (const tag of tags) {\n+                  // @TODO refactor tags to be a set to avoid this O(n) lookup\n+                  if (!collectedTags.includes(tag)) {\n+                    collectedTags.push(tag)\n+                  }\n+                }\n               }\n-            }\n+              break\n+            case 'unstable-cache':\n+              isNestedUnstableCache = true\n+              break\n+            case 'prerender-client':\n+            case 'request':\n+              break\n+            default:\n+              workUnitStore satisfies never\n           }\n         }\n \n-        const isNestedUnstableCache =\n-          workUnitStore && workUnitStore.type === 'unstable-cache'\n         if (\n           // when we are nested inside of other unstable_cache's\n           // we should bypass cache similar to fetches\n@@ -361,3 +365,30 @@ export function unstable_cache<T extends Callback>(\n   // TODO: once AsyncLocalStorage.run() returns the correct types this override will no longer be necessary\n   return cachedCb as unknown as T\n }\n+\n+function getFetchUrlPrefix(\n+  workStore: WorkStore,\n+  workUnitStore: WorkUnitStore\n+): string {\n+  switch (workUnitStore.type) {\n+    case 'request':\n+      const pathname = workUnitStore.url.pathname\n+      const searchParams = new URLSearchParams(workUnitStore.url.search)\n+\n+      const sortedSearch = [...searchParams.keys()]\n+        .sort((a, b) => a.localeCompare(b))\n+        .map((key) => `${key}=${searchParams.get(key)}`)\n+        .join('&')\n+\n+      return `${pathname}${sortedSearch.length ? '?' : ''}${sortedSearch}`\n+    case 'prerender':\n+    case 'prerender-client':\n+    case 'prerender-ppr':\n+    case 'prerender-legacy':\n+    case 'cache':\n+    case 'unstable-cache':\n+      return workStore.route\n+    default:\n+      return workUnitStore satisfies never\n+  }\n+}"
        },
        {
            "sha": "c199935369284b0447fe5241e3087ab5ebf931ae",
            "filename": "packages/next/src/server/web/spec-extension/unstable-no-store.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-no-store.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-no-store.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-no-store.ts?ref=1c1d9b5fdcebc7b0ff6e1b3ce91954d3c50e5c64",
            "patch": "@@ -36,8 +36,14 @@ export function unstable_noStore() {\n         case 'prerender-client':\n           // unstable_noStore() is a noop in Dynamic I/O.\n           return\n+        case 'prerender-ppr':\n+        case 'prerender-legacy':\n+        case 'request':\n+        case 'cache':\n+        case 'unstable-cache':\n+          break\n         default:\n-        // fallthrough\n+          workUnitStore satisfies never\n       }\n     }\n     markCurrentScopeAsDynamic(store, workUnitStore, callingExpression)"
        }
    ],
    "stats": {
        "total": 2451,
        "additions": 1482,
        "deletions": 969
    }
}