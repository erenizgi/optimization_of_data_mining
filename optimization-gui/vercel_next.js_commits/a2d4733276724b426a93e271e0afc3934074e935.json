{
    "author": "mischnic",
    "message": "Turbopack: leave `chunks` in `rscModuleMapping` empty (#79511)\n\nPreviously, `clientReferenceManifest.rscModuleMapping.*.chunks` would list the RSC entry, such as `server/app/encryption/page.js` which contains\n```js\nconst CHUNK_PUBLIC_PATH = \"server/app/encryption/page.js\";\nconst runtime = require(\"../../chunks/ssr/[turbopack]_runtime.js\");\nruntime.loadChunk(\"server/chunks/ssr/[root-of-the-server]__a810eacb._.js\");\nruntime.loadChunk(\"server/chunks/ssr/_7a4bd82c._.js\");\nruntime.loadChunk(\"server/chunks/ssr/test_e2e_app-dir_actions_app_not-found_b8caa540.js\");\nruntime.loadChunk(\"server/chunks/ssr/packages_next_dist_client_components_1d957a03._.js\");\nruntime.loadChunk(\"server/chunks/ssr/packages_next_dist_client_components_unauthorized-error_4ad694c5.js\");\nruntime.loadChunk(\"server/chunks/ssr/_0aa93936._.js\");\nruntime.getOrInstantiateRuntimeModule(\"[project]/test/e2e/app-dir/actions/.next-internal/server/app/encryption/page/actions.js { ACTIONS_MODULE0 => \\\"[project]/test/e2e/app-dir/actions/app/encryption/page.js [app-rsc] (ecmascript)\\\" } [app-rsc] (server actions loader, ecmascript)\", CHUNK_PUBLIC_PATH);\nruntime.getOrInstantiateRuntimeModule(\"[project]/packages/next/dist/esm/build/templates/app-page.js??page=/encryption/page { MODULE_0 => \\\"[project]/test/e2e/app-dir/actions/app/layout.js [app-rsc] (ecmascript, Next.js Server Component)\\\", MODULE_1 => \\\"[project]/test/e2e/app-dir/actions/app/not-found.js [app-rsc] (ecmascript, Next.js Server Component)\\\", MODULE_2 => \\\"[project]/packages/next/dist/client/components/forbidden-error.js [app-rsc] (ecmascript, Next.js Server Component)\\\", MODULE_3 => \\\"[project]/packages/next/dist/client/components/unauthorized-error.js [app-rsc] (ecmascript, Next.js Server Component)\\\", MODULE_4 => \\\"[project]/test/e2e/app-dir/actions/app/encryption/page.js [app-rsc] (ecmascript, Next.js Server Component)\\\" } [app-rsc] (ecmascript)\", CHUNK_PUBLIC_PATH);\nmodule.exports = runtime.getOrInstantiateRuntimeModule(\"[project]/packages/next/dist/esm/build/templates/app-page.js??page=/encryption/page { MODULE_0 => \\\"[project]/test/e2e/app-dir/actions/app/layout.js [app-rsc] (ecmascript, Next.js Server Component)\\\", MODULE_1 => \\\"[project]/test/e2e/app-dir/actions/app/not-found.js [app-rsc] (ecmascript, Next.js Server Component)\\\", MODULE_2 => \\\"[project]/packages/next/dist/client/components/forbidden-error.js [app-rsc] (ecmascript, Next.js Server Component)\\\", MODULE_3 => \\\"[project]/packages/next/dist/client/components/unauthorized-error.js [app-rsc] (ecmascript, Next.js Server Component)\\\", MODULE_4 => \\\"[project]/test/e2e/app-dir/actions/app/encryption/page.js [app-rsc] (ecmascript, Next.js Server Component)\\\" } [app-rsc] (ecmascript)\", CHUNK_PUBLIC_PATH).exports;\n```\n\nThe problem is that this chunk (Turbopack calls them \"entry chunk\") exports some entry point, as opposed to the usual chunk which does `module.exports = {19285: function(){}, ...}` to export the module factories (called an \"evaluated chunk\")\n\nIf you use `__turbopack_load__` to load an entry chunk, stuff breaks because you end up with the entry module's exports in the module factory map.\n\n\nHendrik confirmed that Webpack also doesn't specify any chunks in here, they are already loaded anyway. Then this case of `__turbopack_load__`ing an entry chunk never occurs.",
    "sha": "a2d4733276724b426a93e271e0afc3934074e935",
    "files": [
        {
            "sha": "438527a5a2cced13007edc5af46dfac5d5526f74",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/a2d4733276724b426a93e271e0afc3934074e935/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a2d4733276724b426a93e271e0afc3934074e935/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=a2d4733276724b426a93e271e0afc3934074e935",
            "patch": "@@ -1459,7 +1459,6 @@ impl AppEndpoint {\n                     entry_name: app_entry.original_name.clone(),\n                     client_references,\n                     client_references_chunks,\n-                    rsc_app_entry_chunks: app_entry_chunks,\n                     client_chunking_context,\n                     ssr_chunking_context,\n                     async_module_info: module_graphs.full.async_module_info().to_resolved().await?,"
        },
        {
            "sha": "ea684e83af780aeb9443487958d4e04837652c3f",
            "filename": "crates/next-core/src/next_manifests/client_reference_manifest.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 34,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/a2d4733276724b426a93e271e0afc3934074e935/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a2d4733276724b426a93e271e0afc3934074e935/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs?ref=a2d4733276724b426a93e271e0afc3934074e935",
            "patch": "@@ -15,7 +15,7 @@ use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::{ChunkingContext, ModuleChunkItemIdExt, ModuleId as TurbopackModuleId},\n     module_graph::async_module_info::AsyncModulesInfo,\n-    output::{OutputAsset, OutputAssets},\n+    output::OutputAsset,\n     virtual_output::VirtualOutputAsset,\n };\n use turbopack_ecmascript::utils::StringifyJs;\n@@ -37,7 +37,6 @@ pub struct ClientReferenceManifestOptions {\n     pub entry_name: RcStr,\n     pub client_references: ResolvedVc<ClientReferenceGraphResult>,\n     pub client_references_chunks: ResolvedVc<ClientReferencesChunks>,\n-    pub rsc_app_entry_chunks: ResolvedVc<OutputAssets>,\n     pub client_chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n     pub ssr_chunking_context: Option<ResolvedVc<Box<dyn ChunkingContext>>>,\n     pub async_module_info: ResolvedVc<AsyncModulesInfo>,\n@@ -58,7 +57,6 @@ impl ClientReferenceManifest {\n             entry_name,\n             client_references,\n             client_references_chunks,\n-            rsc_app_entry_chunks,\n             client_chunking_context,\n             ssr_chunking_context,\n             async_module_info,\n@@ -100,7 +98,6 @@ impl ClientReferenceManifest {\n             } = &*client_references_chunks.await?;\n             let client_relative_path = &*client_relative_path.await?;\n             let node_root_ref = &*node_root.await?;\n-            let rsc_app_entry_chunks = &*rsc_app_entry_chunks.await?;\n \n             let client_references_ecmascript = client_references\n                 .await?\n@@ -167,10 +164,6 @@ impl ClientReferenceManifest {\n                 ResolvedVc<Box<dyn OutputAsset>>,\n                 ReadRef<FileSystemPath>,\n             > = FxHashMap::default();\n-            let mut rsc_chunk_path_cache: FxHashMap<\n-                ResolvedVc<Box<dyn OutputAsset>>,\n-                ReadRef<FileSystemPath>,\n-            > = FxHashMap::default();\n \n             for (client_reference_module, client_reference_module_ref) in\n                 client_references_ecmascript\n@@ -266,32 +259,10 @@ impl ClientReferenceManifest {\n                         (Vec::new(), false)\n                     };\n \n-                    let (rsc_chunks_paths, rsc_is_async) = if runtime == NextRuntime::Edge {\n-                        // the chunks get added to the middleware-manifest.json instead\n-                        // of this file because the\n-                        // edge runtime doesn't support dynamically\n-                        // loading chunks.\n-                        (Vec::new(), false)\n+                    let rsc_is_async = if runtime == NextRuntime::Edge {\n+                        false\n                     } else {\n-                        let rsc_chunks_paths = cached_chunk_paths(\n-                            &mut rsc_chunk_path_cache,\n-                            rsc_app_entry_chunks.iter().copied(),\n-                        )\n-                        .await?;\n-\n-                        let chunk_paths = rsc_chunks_paths\n-                            .filter_map(|(_, chunk_path)| {\n-                                node_root_ref\n-                                    .get_path_to(&chunk_path)\n-                                    .map(ToString::to_string)\n-                            })\n-                            .map(RcStr::from)\n-                            .collect::<Vec<_>>();\n-\n-                        let is_async =\n-                            async_modules.contains(&ResolvedVc::upcast(client_reference_module));\n-\n-                        (chunk_paths, is_async)\n+                        async_modules.contains(&ResolvedVc::upcast(client_reference_module))\n                     };\n \n                     entry_manifest.client_modules.module_exports.insert(\n@@ -326,7 +297,7 @@ impl ClientReferenceManifest {\n                         ManifestNodeEntry {\n                             name: \"*\".into(),\n                             id: (&*rsc_chunk_item_id).into(),\n-                            chunks: rsc_chunks_paths,\n+                            chunks: vec![],\n                             r#async: rsc_is_async,\n                         },\n                     );"
        }
    ],
    "stats": {
        "total": 40,
        "additions": 5,
        "deletions": 35
    }
}