{
    "author": "mischnic",
    "message": "Turbopack: validate CSS without computing all paths (#83810)\n\nDon't compute all paths of all modules beforehand (and store them in a vector) for every single endpoint\n\nInstead, compute the list of all potentially problematic modules on demand.\n\nCloses PACK-5455",
    "sha": "fd9f0d1460427c8f13f437fbacb75ba025303a54",
    "files": [
        {
            "sha": "d6b521108bcc1c4f7d8eba0c81a68cb52999204c",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 54,
            "deletions": 70,
            "changes": 124,
            "blob_url": "https://github.com/vercel/next.js/blob/fd9f0d1460427c8f13f437fbacb75ba025303a54/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fd9f0d1460427c8f13f437fbacb75ba025303a54/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=fd9f0d1460427c8f13f437fbacb75ba025303a54",
            "patch": "@@ -16,8 +16,7 @@ use rustc_hash::FxHashMap;\n use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n-    CollectiblesSource, FxIndexMap, FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt,\n-    ValueToString, Vc,\n+    CollectiblesSource, FxIndexMap, FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Vc,\n };\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::css::{CssModuleAsset, ModuleCssAsset};\n@@ -429,8 +428,8 @@ impl ClientReferencesGraph {\n \n #[turbo_tasks::value(shared)]\n struct CssGlobalImportIssue {\n-    parent_module: ResolvedVc<Box<dyn Module>>,\n-    module: ResolvedVc<Box<dyn Module>>,\n+    pub parent_module: ResolvedVc<Box<dyn Module>>,\n+    pub module: ResolvedVc<Box<dyn Module>>,\n }\n \n impl CssGlobalImportIssue {\n@@ -512,17 +511,16 @@ type FxModuleNameMap = FxIndexMap<ResolvedVc<Box<dyn Module>>, RcStr>;\n #[turbo_tasks::value(transparent)]\n struct ModuleNameMap(pub FxModuleNameMap);\n \n+#[tracing::instrument(level = tracing::Level::INFO, name = \"validate pages css imports\", skip_all)]\n #[turbo_tasks::function]\n async fn validate_pages_css_imports(\n     graph: Vc<SingleModuleGraph>,\n     is_single_page: bool,\n     entry: Vc<Box<dyn Module>>,\n     app_module: ResolvedVc<Box<dyn Module>>,\n-    module_name_map: ResolvedVc<ModuleNameMap>,\n ) -> Result<()> {\n     let graph = &*graph.await?;\n     let entry = entry.to_resolved().await?;\n-    let module_name_map = module_name_map.await?;\n \n     let entries = if !is_single_page {\n         if !graph.has_entry_module(entry) {\n@@ -534,33 +532,31 @@ async fn validate_pages_css_imports(\n         Either::Right(graph.entry_modules())\n     };\n \n+    let mut candidates = vec![];\n+\n     graph.traverse_edges_from_entries(entries, |parent_info, node| {\n         let module = node.module;\n \n-        // If the module being imported isn't a global css module, there is nothing to validate.\n-        let module_is_global_css =\n-            ResolvedVc::try_downcast_type::<CssModuleAsset>(module).is_some();\n+        // If we're at a root node, there is nothing importing this module and we can skip\n+        // any further validations.\n+        let Some((parent_node, _)) = parent_info else {\n+            return GraphTraversalAction::Continue;\n+        };\n+        let parent_module = parent_node.module;\n \n-        if !module_is_global_css {\n+        // Importing CSS from _app.js is always allowed.\n+        if parent_module == app_module {\n             return GraphTraversalAction::Continue;\n         }\n \n-        // We allow imports of global CSS files which are inside of `node_modules`.\n-        let module_name_contains_node_modules = module_name_map\n-            .get(&module)\n-            .is_some_and(|s| s.contains(\"node_modules\"));\n+        // If the module being imported isn't a global css module, there is nothing to validate.\n+        let module_is_global_css =\n+            ResolvedVc::try_downcast_type::<CssModuleAsset>(module).is_some();\n \n-        if module_name_contains_node_modules {\n+        if !module_is_global_css {\n             return GraphTraversalAction::Continue;\n         }\n \n-        // If we're at a root node, there is nothing importing this module and we can skip\n-        // any further validations.\n-        let Some((parent_node, _)) = parent_info else {\n-            return GraphTraversalAction::Continue;\n-        };\n-\n-        let parent_module = parent_node.module;\n         let parent_is_css_module = ResolvedVc::try_downcast_type::<ModuleCssAsset>(parent_module)\n             .is_some()\n             || ResolvedVc::try_downcast_type::<CssModuleAsset>(parent_module).is_some();\n@@ -574,14 +570,38 @@ async fn validate_pages_css_imports(\n         // the same as the app module. If it isn't we know it isn't a valid place to import global\n         // css.\n         if parent_module != app_module {\n-            CssGlobalImportIssue::new(parent_module, module)\n-                .resolved_cell()\n-                .emit();\n+            candidates.push(CssGlobalImportIssue::new(parent_module, module))\n         }\n \n         GraphTraversalAction::Continue\n     })?;\n \n+    candidates\n+        .into_iter()\n+        .map(async |issue| {\n+            // We allow imports of global CSS files which are inside of `node_modules`.\n+            Ok(\n+                if !issue\n+                    .module\n+                    .ident()\n+                    .path()\n+                    .await?\n+                    .path\n+                    .contains(\"/node_modules/\")\n+                {\n+                    Some(issue)\n+                } else {\n+                    None\n+                },\n+            )\n+        })\n+        .try_flat_join()\n+        .await?\n+        .into_iter()\n+        .for_each(|issue| {\n+            issue.resolved_cell().emit();\n+        });\n+\n     Ok(())\n }\n \n@@ -785,54 +805,18 @@ impl GlobalBuildInformation {\n         entry: Vc<Box<dyn Module>>,\n         app_module: Vc<Box<dyn Module>>,\n     ) -> Result<()> {\n-        let span = tracing::info_span!(\"validate pages css imports\");\n-        async move {\n-            let graphs = &self.bare_graphs.await?.graphs;\n-\n-            // We need to collect the module names here to pass into the\n-            // `validate_pages_css_imports` function. This is because the function is\n-            // called for each graph, and we need to know the module names of the parent\n-            // modules to determine if the import is valid. We can't do this in the\n-            // called function because it's within a closure that can't resolve turbo tasks.\n-            let graph_to_module_ident_tuples = async |graph: &ResolvedVc<SingleModuleGraph>| {\n-                graph\n-                    .await?\n-                    .graph\n-                    .node_weights()\n-                    .map(async |n| Ok((n.module(), n.module().ident().to_string().owned().await?)))\n-                    .try_join()\n-                    .await\n-            };\n-\n-            let identifier_map = graphs\n-                .iter()\n-                .map(graph_to_module_ident_tuples)\n-                .try_join()\n-                .await?\n-                .into_iter()\n-                .flatten()\n-                .collect::<FxIndexMap<_, _>>();\n-            let identifier_map = ModuleNameMap(identifier_map).cell();\n+        let graphs = &self.bare_graphs.await?.graphs;\n \n-            graphs\n-                .iter()\n-                .map(|graph| {\n-                    validate_pages_css_imports(\n-                        **graph,\n-                        self.is_single_page,\n-                        entry,\n-                        app_module,\n-                        identifier_map,\n-                    )\n+        graphs\n+            .iter()\n+            .map(|graph| {\n+                validate_pages_css_imports(**graph, self.is_single_page, entry, app_module)\n                     .as_side_effect()\n-                })\n-                .try_join()\n-                .await?;\n+            })\n+            .try_join()\n+            .await?;\n \n-            Ok(())\n-        }\n-        .instrument(span)\n-        .await\n+        Ok(())\n     }\n }\n "
        }
    ],
    "stats": {
        "total": 124,
        "additions": 54,
        "deletions": 70
    }
}