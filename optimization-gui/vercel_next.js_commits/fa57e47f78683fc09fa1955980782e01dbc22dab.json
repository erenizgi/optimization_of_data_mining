{
    "author": "sokra",
    "message": "[Turbopack] avoid attaching referenced output assets to chunks (#75933)\n\n### What?\r\n\r\n`referenced_output_assets` are different for every chunk group. Attaching them as references to a random chunk in the group causes a different Chunk instance which not only causes duplicate work, but also multiple writes to the same file.\r\n\r\nThis fixes that by refactoring that and attaching the `referenced_output_assets`  higher. Actually it simplifies it.\r\n\r\nCloses PACK-4322\r\nCloses PACK-4392",
    "sha": "fa57e47f78683fc09fa1955980782e01dbc22dab",
    "files": [
        {
            "sha": "dd805183d2387aac66aa3b045ea25dc8f72e5135",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 114,
            "deletions": 57,
            "changes": 171,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -39,8 +39,8 @@ use serde::{Deserialize, Serialize};\n use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n-    Completion, FxIndexSet, NonLocalValue, ResolvedVc, TryJoinIterExt, ValueToString, Vc,\n-    fxindexset, trace::TraceRawVcs,\n+    Completion, NonLocalValue, ResolvedVc, TryJoinIterExt, ValueToString, Vc, fxindexset,\n+    trace::TraceRawVcs,\n };\n use turbo_tasks_env::{CustomProcessEnv, ProcessEnv};\n use turbo_tasks_fs::{File, FileContent, FileSystemPath};\n@@ -63,7 +63,7 @@ use turbopack_core::{\n         GraphEntries, ModuleGraph, SingleModuleGraph, VisitedModules,\n         chunk_group_info::{ChunkGroup, ChunkGroupEntry},\n     },\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n     raw_output::RawOutput,\n     reference_type::{CommonJsReferenceSubType, CssReferenceSubType, ReferenceType},\n     resolve::{origin::PlainResolveOrigin, parse::Request, pattern::Pattern},\n@@ -1240,14 +1240,17 @@ impl AppEndpoint {\n             .await?;\n \n             let mut client_shared_chunks = vec![];\n-            for chunk in client_shared_chunk_group.assets.await?.iter().copied() {\n+            for &chunk in client_shared_chunk_group.assets.await? {\n                 client_assets.insert(chunk);\n \n                 let chunk_path = chunk.path().await?;\n                 if chunk_path.has_extension(\".js\") {\n                     client_shared_chunks.push(chunk);\n                 }\n             }\n+            for &chunk in client_shared_chunk_group.referenced_assets.await? {\n+                client_assets.insert(chunk);\n+            }\n \n             (\n                 client_shared_chunk_group.availability_info,\n@@ -1285,31 +1288,40 @@ impl AppEndpoint {\n         .await?;\n         let client_references_chunks_ref = client_references_chunks.await?;\n \n-        let mut entry_client_chunks = FxIndexSet::default();\n-        // TODO(alexkirsz) In which manifest does this go?\n-        let mut entry_ssr_chunks = FxIndexSet::default();\n-        for chunks in client_references_chunks_ref\n+        for OutputAssetsWithReferenced {\n+            assets,\n+            referenced_assets,\n+        } in client_references_chunks_ref\n             .layout_segment_client_chunks\n             .values()\n         {\n-            entry_client_chunks.extend(chunks.await?.iter().copied());\n+            client_assets.extend(assets.await?.iter().copied());\n+            client_assets.extend(referenced_assets.await?.iter().copied());\n         }\n-        for (chunks, _) in client_references_chunks_ref\n+        for ChunkGroupResult {\n+            assets,\n+            referenced_assets,\n+            availability_info: _,\n+        } in client_references_chunks_ref\n             .client_component_client_chunks\n             .values()\n         {\n-            client_assets.extend(chunks.await?.iter().copied());\n+            client_assets.extend(assets.await?.iter().copied());\n+            client_assets.extend(referenced_assets.await?.iter().copied());\n         }\n-        for (chunks, _) in client_references_chunks_ref\n+        for ChunkGroupResult {\n+            assets,\n+            referenced_assets,\n+            availability_info: _,\n+        } in client_references_chunks_ref\n             .client_component_ssr_chunks\n             .values()\n         {\n-            entry_ssr_chunks.extend(chunks.await?.iter().copied());\n+            // TODO(alexkirsz) In which manifest does this go?\n+            server_assets.extend(assets.await?.iter().copied());\n+            server_assets.extend(referenced_assets.await?.iter().copied());\n         }\n \n-        client_assets.extend(entry_client_chunks.iter().copied());\n-        server_assets.extend(entry_ssr_chunks.iter().copied());\n-\n         let manifest_path_prefix = &app_entry.original_name;\n \n         // polyfill-nomodule.js is a pre-compiled asset distributed as part of next,\n@@ -1377,12 +1389,16 @@ impl AppEndpoint {\n             // initialization\n             let client_references_chunks = &*client_references_chunks.await?;\n \n-            for (ssr_chunks, _) in client_references_chunks\n+            for ChunkGroupResult {\n+                assets,\n+                referenced_assets,\n+                availability_info: _,\n+            } in client_references_chunks\n                 .client_component_ssr_chunks\n                 .values()\n             {\n-                let ssr_chunks = ssr_chunks.await?;\n-                middleware_assets.extend(ssr_chunks);\n+                middleware_assets.extend(assets.await?);\n+                middleware_assets.extend(referenced_assets.await?);\n             }\n         }\n \n@@ -1426,8 +1442,17 @@ impl AppEndpoint {\n             )\n             .to_resolved()\n             .await?;\n+        let app_entry_chunk_group_ref = app_entry_chunks.await?;\n+        let app_entry_chunks = app_entry_chunk_group_ref.assets;\n         let app_entry_chunks_ref = app_entry_chunks.await?;\n         server_assets.extend(app_entry_chunks_ref.iter().copied());\n+        server_assets.extend(\n+            app_entry_chunk_group_ref\n+                .referenced_assets\n+                .await?\n+                .iter()\n+                .copied(),\n+        );\n \n         let client_assets = OutputAssets::new(client_assets.iter().map(|asset| **asset).collect())\n             .to_resolved()\n@@ -1701,7 +1726,7 @@ impl AppEndpoint {\n         server_path: FileSystemPath,\n         process_client_assets: bool,\n         module_graph: Vc<ModuleGraph>,\n-    ) -> Result<Vc<OutputAssets>> {\n+    ) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let this = self.await?;\n         let project = this.app_project.project();\n         let app_entry = self.app_endpoint_entry().await?;\n@@ -1713,6 +1738,7 @@ impl AppEndpoint {\n             NextRuntime::Edge => {\n                 let ChunkGroupResult {\n                     assets,\n+                    referenced_assets,\n                     availability_info,\n                 } = *chunking_context\n                     .chunk_group(\n@@ -1727,17 +1753,25 @@ impl AppEndpoint {\n                     )\n                     .await?;\n \n-                assets.concatenate(\n-                    chunking_context\n-                        .evaluated_chunk_group_assets(\n-                            app_entry.rsc_entry.ident(),\n-                            ChunkGroup::Entry(vec![app_entry.rsc_entry]),\n-                            module_graph,\n-                            availability_info,\n-                        )\n-                        .resolve()\n+                let chunk_group = chunking_context\n+                    .evaluated_chunk_group_assets(\n+                        app_entry.rsc_entry.ident(),\n+                        ChunkGroup::Entry(vec![app_entry.rsc_entry]),\n+                        module_graph,\n+                        availability_info,\n+                    )\n+                    .await?;\n+                OutputAssetsWithReferenced {\n+                    assets: assets\n+                        .concatenate(*chunk_group.assets)\n+                        .to_resolved()\n                         .await?,\n-                )\n+                    referenced_assets: referenced_assets\n+                        .concatenate(*chunk_group.referenced_assets)\n+                        .to_resolved()\n+                        .await?,\n+                }\n+                .cell()\n             }\n             NextRuntime::NodeJs => {\n                 let Some(rsc_entry) = ResolvedVc::try_downcast(app_entry.rsc_entry) else {\n@@ -1748,6 +1782,7 @@ impl AppEndpoint {\n \n                 async {\n                     let mut current_chunks = OutputAssets::empty();\n+                    let mut current_referenced_assets = OutputAssets::empty();\n                     let mut current_availability_info = AvailabilityInfo::Root;\n \n                     let client_references = client_references.await?;\n@@ -1759,7 +1794,11 @@ impl AppEndpoint {\n                             .map(async |m| Ok(ResolvedVc::upcast(m.await?.module)))\n                             .try_join()\n                             .await?;\n-                        let chunk_group = chunking_context\n+                        let ChunkGroupResult {\n+                            assets,\n+                            referenced_assets,\n+                            availability_info,\n+                        } = *chunking_context\n                             .chunk_group(\n                                 AssetIdent::from_path(\n                                     this.app_project.project().project_path().owned().await?,\n@@ -1772,11 +1811,12 @@ impl AppEndpoint {\n                             )\n                             .await?;\n \n-                        current_chunks = current_chunks\n-                            .concatenate(*chunk_group.assets)\n+                        current_chunks = current_chunks.concatenate(*assets).resolve().await?;\n+                        current_referenced_assets = current_referenced_assets\n+                            .concatenate(*referenced_assets)\n                             .resolve()\n                             .await?;\n-                        current_availability_info = chunk_group.availability_info;\n+                        current_availability_info = availability_info;\n \n                         anyhow::Ok(())\n                     }\n@@ -1798,7 +1838,11 @@ impl AppEndpoint {\n                             name = server_component.ident().to_string().await?.as_str()\n                         );\n                         async {\n-                            let chunk_group = chunking_context\n+                            let ChunkGroupResult {\n+                                assets,\n+                                referenced_assets,\n+                                availability_info,\n+                            } = *chunking_context\n                                 .chunk_group(\n                                     server_component.ident(),\n                                     // TODO this should be ChunkGroup::Shared\n@@ -1810,11 +1854,12 @@ impl AppEndpoint {\n                                 )\n                                 .await?;\n \n-                            current_chunks = current_chunks\n-                                .concatenate(*chunk_group.assets)\n+                            current_chunks = current_chunks.concatenate(*assets).resolve().await?;\n+                            current_referenced_assets = current_referenced_assets\n+                                .concatenate(*referenced_assets)\n                                 .resolve()\n                                 .await?;\n-                            current_availability_info = chunk_group.availability_info;\n+                            current_availability_info = availability_info;\n \n                             anyhow::Ok(())\n                         }\n@@ -1823,7 +1868,11 @@ impl AppEndpoint {\n                     }\n \n                     {\n-                        let chunk_group = chunking_context\n+                        let ChunkGroupResult {\n+                            assets,\n+                            referenced_assets,\n+                            availability_info,\n+                        } = *chunking_context\n                             .chunk_group(\n                                 server_action_manifest_loader.ident(),\n                                 ChunkGroup::Entry(vec![ResolvedVc::upcast(\n@@ -1834,28 +1883,36 @@ impl AppEndpoint {\n                             )\n                             .await?;\n \n-                        current_chunks = current_chunks\n-                            .concatenate(*chunk_group.assets)\n+                        current_chunks = current_chunks.concatenate(*assets).resolve().await?;\n+                        current_referenced_assets = current_referenced_assets\n+                            .concatenate(*referenced_assets)\n                             .resolve()\n                             .await?;\n-                        current_availability_info = chunk_group.availability_info;\n+                        current_availability_info = availability_info;\n                     }\n \n-                    anyhow::Ok(Vc::cell(vec![\n-                        chunking_context\n-                            .entry_chunk_group_asset(\n-                                server_path.join(&format!(\n-                                    \"app{original_name}.js\",\n-                                    original_name = app_entry.original_name\n-                                ))?,\n-                                evaluatable_assets,\n-                                module_graph,\n-                                current_chunks,\n-                                current_availability_info,\n-                            )\n-                            .to_resolved()\n-                            .await?,\n-                    ]))\n+                    anyhow::Ok(\n+                        OutputAssetsWithReferenced {\n+                            assets: ResolvedVc::cell(vec![\n+                                chunking_context\n+                                    .entry_chunk_group_asset(\n+                                        server_path.join(&format!(\n+                                            \"app{original_name}.js\",\n+                                            original_name = app_entry.original_name\n+                                        ))?,\n+                                        evaluatable_assets,\n+                                        module_graph,\n+                                        current_chunks,\n+                                        current_referenced_assets,\n+                                        current_availability_info,\n+                                    )\n+                                    .to_resolved()\n+                                    .await?,\n+                            ]),\n+                            referenced_assets: ResolvedVc::cell(vec![]),\n+                        }\n+                        .cell(),\n+                    )\n                 }\n                 .instrument(tracing::trace_span!(\"server node entrypoint\"))\n                 .await?"
        },
        {
            "sha": "78bf12f41088c32f4b3a5425c568b90552f257f4",
            "filename": "crates/next-api/src/dynamic_imports.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -68,7 +68,7 @@ pub(crate) async fn collect_next_dynamic_chunks(\n                         .client_component_client_chunks\n                         .get(&parent_client_reference.unwrap())\n                         .unwrap()\n-                        .1\n+                        .availability_info\n                 }\n                 NextDynamicChunkAvailability::AvailabilityInfo(availability_info) => {\n                     *availability_info"
        },
        {
            "sha": "51c07c7d3e91950e22710427d5d721bc6df00eaf",
            "filename": "crates/next-api/src/instrumentation.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Finstrumentation.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -20,7 +20,7 @@ use turbopack_core::{\n         GraphEntries,\n         chunk_group_info::{ChunkGroup, ChunkGroupEntry},\n     },\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     source::Source,\n     virtual_output::VirtualOutputAsset,\n@@ -97,21 +97,19 @@ impl InstrumentationEndpoint {\n     }\n \n     #[turbo_tasks::function]\n-    async fn edge_files(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n+    async fn edge_chunk_group(self: Vc<Self>) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let this = self.await?;\n         let module = self.core_modules().await?.edge_entry_module;\n \n         let module_graph = this.project.module_graph(*module);\n \n         let edge_chunking_context = this.project.edge_chunking_context(false);\n-        let edge_files: Vc<OutputAssets> = edge_chunking_context.evaluated_chunk_group_assets(\n+        Ok(edge_chunking_context.evaluated_chunk_group_assets(\n             module.ident(),\n             ChunkGroup::Entry(vec![module]),\n             module_graph,\n             AvailabilityInfo::Root,\n-        );\n-\n-        Ok(edge_files)\n+        ))\n     }\n \n     #[turbo_tasks::function]\n@@ -136,6 +134,7 @@ impl InstrumentationEndpoint {\n                 Vc::cell(vec![module]),\n                 module_graph,\n                 OutputAssets::empty(),\n+                OutputAssets::empty(),\n                 AvailabilityInfo::Root,\n             )\n             .await?;\n@@ -147,19 +146,20 @@ impl InstrumentationEndpoint {\n         let this = self.await?;\n \n         if this.is_edge {\n-            let edge_files = self.edge_files();\n-            let mut output_assets = edge_files.owned().await?;\n+            let edge_chunk_group = self.edge_chunk_group();\n+            let edge_all_assets = edge_chunk_group.all_assets();\n \n             let node_root = this.project.node_root().owned().await?;\n             let node_root_value = node_root.clone();\n \n             let file_paths_from_root =\n-                get_js_paths_from_root(&node_root_value, &output_assets).await?;\n+                get_js_paths_from_root(&node_root_value, &edge_chunk_group.await?.assets.await?)\n+                    .await?;\n \n-            let all_output_assets = all_assets_from_entries(edge_files).await?;\n+            let mut output_assets = all_assets_from_entries(edge_all_assets).owned().await?;\n \n             let wasm_paths_from_root =\n-                get_wasm_paths_from_root(&node_root_value, &all_output_assets).await?;\n+                get_wasm_paths_from_root(&node_root_value, &output_assets).await?;\n \n             let instrumentation_definition = InstrumentationDefinition {\n                 files: file_paths_from_root,"
        },
        {
            "sha": "d5e75f30caf9648e3ab0ddf7399ef2fbd660a07a",
            "filename": "crates/next-api/src/middleware.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 11,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmiddleware.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -26,7 +26,7 @@ use turbopack_core::{\n         GraphEntries,\n         chunk_group_info::{ChunkGroup, ChunkGroupEntry},\n     },\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     source::Source,\n     virtual_output::VirtualOutputAsset,\n@@ -104,20 +104,20 @@ impl MiddlewareEndpoint {\n     }\n \n     #[turbo_tasks::function]\n-    async fn edge_files(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n+    async fn edge_chunk_group(self: Vc<Self>) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let this = self.await?;\n         let module = self.entry_module().to_resolved().await?;\n \n         let module_graph = this.project.module_graph(*module);\n \n         let edge_chunking_context = this.project.edge_chunking_context(false);\n-        let edge_files = edge_chunking_context.evaluated_chunk_group_assets(\n+        let edge_chunk_grou = edge_chunking_context.evaluated_chunk_group_assets(\n             module.ident(),\n             ChunkGroup::Entry(vec![module]),\n             module_graph,\n             AvailabilityInfo::Root,\n         );\n-        Ok(edge_files)\n+        Ok(edge_chunk_grou)\n     }\n \n     #[turbo_tasks::function]\n@@ -142,6 +142,7 @@ impl MiddlewareEndpoint {\n                 Vc::cell(vec![module]),\n                 module_graph,\n                 OutputAssets::empty(),\n+                OutputAssets::empty(),\n                 AvailabilityInfo::Root,\n             )\n             .await?;\n@@ -254,22 +255,22 @@ impl MiddlewareEndpoint {\n \n             Ok(Vc::cell(output_assets))\n         } else {\n-            let edge_files = self.edge_files();\n-            let mut output_assets = edge_files.owned().await?;\n+            let edge_chunk_group = self.edge_chunk_group();\n+            let edge_all_assets = edge_chunk_group.all_assets();\n \n             let node_root = this.project.node_root().owned().await?;\n             let node_root_value = node_root.clone();\n \n             let file_paths_from_root =\n-                get_js_paths_from_root(&node_root_value, &output_assets).await?;\n+                get_js_paths_from_root(&node_root_value, &edge_chunk_group.await?.assets.await?)\n+                    .await?;\n \n-            let all_output_assets = all_assets_from_entries(edge_files).await?;\n+            let mut output_assets = all_assets_from_entries(edge_all_assets).owned().await?;\n \n             let wasm_paths_from_root =\n-                get_wasm_paths_from_root(&node_root_value, &all_output_assets).await?;\n+                get_wasm_paths_from_root(&node_root_value, &output_assets).await?;\n \n-            let all_assets =\n-                get_asset_paths_from_root(&node_root_value, &all_output_assets).await?;\n+            let all_assets = get_asset_paths_from_root(&node_root_value, &output_assets).await?;\n \n             let regions = if let Some(regions) = config.preferred_region.as_ref() {\n                 if regions.len() == 1 {"
        },
        {
            "sha": "2b8051c7f2de1c7cf26ce7d98d3f6a5ff0a647df",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 57,
            "deletions": 23,
            "changes": 80,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -56,7 +56,7 @@ use turbopack_core::{\n         GraphEntries, ModuleGraph, SingleModuleGraph, VisitedModules,\n         chunk_group_info::{ChunkGroup, ChunkGroupEntry},\n     },\n-    output::{OptionOutputAsset, OutputAsset, OutputAssets},\n+    output::{OptionOutputAsset, OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n     reference_type::{EcmaScriptModulesReferenceSubType, EntryReferenceSubType, ReferenceType},\n     resolve::{origin::PlainResolveOrigin, parse::Request, pattern::Pattern},\n     source::Source,\n@@ -756,7 +756,7 @@ impl PageEndpoint {\n     }\n \n     #[turbo_tasks::function]\n-    async fn client_chunks(self: Vc<Self>) -> Result<Vc<ChunkGroupResult>> {\n+    async fn client_chunk_group(self: Vc<Self>) -> Result<Vc<ChunkGroupResult>> {\n         async move {\n             let this = self.await?;\n \n@@ -933,7 +933,7 @@ impl PageEndpoint {\n             let ssr_module_graph = self.ssr_module_graph();\n \n             let next_dynamic_imports = if let PageEndpointType::Html = this.ty {\n-                let client_availability_info = self.client_chunks().await?.availability_info;\n+                let client_availability_info = self.client_chunk_group().await?.availability_info;\n \n                 let client_module_graph = self.client_module_graph();\n \n@@ -998,14 +998,19 @@ impl PageEndpoint {\n             };\n \n             let mut current_chunks = OutputAssets::empty();\n+            let mut current_referenced_assets = OutputAssets::empty();\n             let mut current_availability_info = AvailabilityInfo::Root;\n             for layout in [document_module, app_module].iter().flatten().copied() {\n                 let span = tracing::trace_span!(\n                     \"layout segment\",\n                     name = display(layout.ident().to_string().await?)\n                 );\n                 async {\n-                    let chunk_group = chunking_context\n+                    let ChunkGroupResult {\n+                        assets,\n+                        referenced_assets,\n+                        availability_info,\n+                    } = *chunking_context\n                         .chunk_group(\n                             layout.ident(),\n                             ChunkGroup::Shared(layout),\n@@ -1014,11 +1019,12 @@ impl PageEndpoint {\n                         )\n                         .await?;\n \n-                    current_chunks = current_chunks\n-                        .concatenate(*chunk_group.assets)\n+                    current_chunks = current_chunks.concatenate(*assets).resolve().await?;\n+                    current_referenced_assets = current_referenced_assets\n+                        .concatenate(*referenced_assets)\n                         .resolve()\n                         .await?;\n-                    current_availability_info = chunk_group.availability_info;\n+                    current_availability_info = availability_info;\n \n                     anyhow::Ok(())\n                 }\n@@ -1030,15 +1036,27 @@ impl PageEndpoint {\n                 .context(\"could not process page loader entry module\")?;\n             let is_edge = matches!(runtime, NextRuntime::Edge);\n             if is_edge {\n-                let edge_files = edge_chunking_context.evaluated_chunk_group_assets(\n-                    ssr_module.ident(),\n-                    ChunkGroup::Entry(vec![ResolvedVc::upcast(ssr_module_evaluatable)]),\n-                    ssr_module_graph,\n-                    current_availability_info,\n-                );\n+                let OutputAssetsWithReferenced {\n+                    assets: edge_assets,\n+                    referenced_assets: edge_referenced_assets,\n+                } = *edge_chunking_context\n+                    .evaluated_chunk_group_assets(\n+                        ssr_module.ident(),\n+                        ChunkGroup::Entry(vec![ResolvedVc::upcast(ssr_module_evaluatable)]),\n+                        ssr_module_graph,\n+                        current_availability_info,\n+                    )\n+                    .await?;\n \n                 Ok(SsrChunk::Edge {\n-                    files: current_chunks.concatenate(edge_files).to_resolved().await?,\n+                    assets: current_chunks\n+                        .concatenate(*edge_assets)\n+                        .to_resolved()\n+                        .await?,\n+                    referenced_assets: current_referenced_assets\n+                        .concatenate(*edge_referenced_assets)\n+                        .to_resolved()\n+                        .await?,\n                     dynamic_import_entries,\n                     regions: regions.clone(),\n                 }\n@@ -1056,6 +1074,7 @@ impl PageEndpoint {\n                         EvaluatableAssets::empty().with_entry(*ssr_module_evaluatable),\n                         ssr_module_graph,\n                         current_chunks,\n+                        current_referenced_assets,\n                         current_availability_info,\n                     )\n                     .to_resolved()\n@@ -1296,8 +1315,16 @@ impl PageEndpoint {\n \n         let ssr_chunk = match this.ty {\n             PageEndpointType::Html => {\n-                let client_chunks = *self.client_chunks().await?.assets;\n+                let client_chunk_group = self.client_chunk_group().await?;\n+                let client_chunks = *client_chunk_group.assets;\n                 client_assets.extend(client_chunks.await?.iter().map(|asset| **asset));\n+                client_assets.extend(\n+                    client_chunk_group\n+                        .referenced_assets\n+                        .await?\n+                        .iter()\n+                        .map(|asset| **asset),\n+                );\n \n                 let build_manifest = self.build_manifest(client_chunks).to_resolved().await?;\n                 let page_loader = self.page_loader(client_chunks);\n@@ -1394,7 +1421,8 @@ impl PageEndpoint {\n                 }\n             }\n             SsrChunk::Edge {\n-                files,\n+                assets,\n+                referenced_assets,\n                 dynamic_import_entries,\n                 ref regions,\n             } => {\n@@ -1414,19 +1442,24 @@ impl PageEndpoint {\n                         fxindexset![]\n                     };\n \n-                    let files_value = files.await?;\n+                    let all_assets = assets.concatenate(*referenced_assets);\n+                    let assets_ref = assets.await?;\n+\n+                    server_assets.extend(referenced_assets.await?.iter().copied());\n \n-                    if let Some(&file) = files_value.first() {\n+                    // TODO(sokra): accessing the 1st asset is a bit hacky, we should find a better\n+                    // way to get the main entry asset\n+                    if let Some(&file) = assets_ref.first() {\n                         let pages_manifest = self.pages_manifest(*file).to_resolved().await?;\n                         server_assets.push(pages_manifest);\n                     }\n \n                     // Only include the actual edge files if pages should be created\n                     let pages_structure = this.pages_structure.await?;\n                     if pages_structure.should_create_pages_entries {\n-                        server_assets.extend(files_value.iter().copied());\n+                        server_assets.extend(assets_ref.iter().copied());\n                         file_paths_from_root\n-                            .extend(get_js_paths_from_root(&node_root, &files_value).await?);\n+                            .extend(get_js_paths_from_root(&node_root, &assets_ref).await?);\n                     }\n \n                     if emit_manifests == EmitManifests::Full {\n@@ -1444,7 +1477,7 @@ impl PageEndpoint {\n \n                     let (wasm_paths_from_root, all_assets) =\n                         if pages_structure.should_create_pages_entries {\n-                            let all_output_assets = all_assets_from_entries(*files).await?;\n+                            let all_output_assets = all_assets_from_entries(all_assets).await?;\n \n                             let mut wasm_paths_from_root = fxindexset![];\n                             wasm_paths_from_root.extend(\n@@ -1512,7 +1545,7 @@ impl PageEndpoint {\n                 }\n \n                 PageEndpointOutput::Edge {\n-                    files,\n+                    files: assets,\n                     server_assets: ResolvedVc::cell(server_assets),\n                     client_assets,\n                 }\n@@ -1745,7 +1778,8 @@ pub enum SsrChunk {\n         server_asset_trace_file: ResolvedVc<OptionOutputAsset>,\n     },\n     Edge {\n-        files: ResolvedVc<OutputAssets>,\n+        assets: ResolvedVc<OutputAssets>,\n+        referenced_assets: ResolvedVc<OutputAssets>,\n         dynamic_import_entries: ResolvedVc<DynamicImportedChunks>,\n         regions: Option<Vec<RcStr>>,\n     },"
        },
        {
            "sha": "5c23861ad5a8824f6a266c5025eb6abb2f94304b",
            "filename": "crates/next-core/src/next_app/app_client_references_chunks.rs",
            "status": "modified",
            "additions": 48,
            "deletions": 17,
            "changes": 65,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_references_chunks.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_references_chunks.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_references_chunks.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -3,10 +3,10 @@ use tracing::Instrument;\n use turbo_rcstr::rcstr;\n use turbo_tasks::{FxIndexMap, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Vc};\n use turbopack_core::{\n-    chunk::{ChunkingContext, availability_info::AvailabilityInfo},\n+    chunk::{ChunkGroupResult, ChunkingContext, availability_info::AvailabilityInfo},\n     module::Module,\n     module_graph::{ModuleGraph, chunk_group_info::ChunkGroup},\n-    output::OutputAssets,\n+    output::{OutputAssets, OutputAssetsWithReferenced},\n };\n \n use crate::{\n@@ -22,12 +22,10 @@ use crate::{\n \n #[turbo_tasks::value]\n pub struct ClientReferencesChunks {\n-    pub client_component_client_chunks:\n-        FxIndexMap<ClientReferenceType, (ResolvedVc<OutputAssets>, AvailabilityInfo)>,\n-    pub client_component_ssr_chunks:\n-        FxIndexMap<ClientReferenceType, (ResolvedVc<OutputAssets>, AvailabilityInfo)>,\n+    pub client_component_client_chunks: FxIndexMap<ClientReferenceType, ChunkGroupResult>,\n+    pub client_component_ssr_chunks: FxIndexMap<ClientReferenceType, ChunkGroupResult>,\n     pub layout_segment_client_chunks:\n-        FxIndexMap<ResolvedVc<NextServerComponentModule>, ResolvedVc<OutputAssets>>,\n+        FxIndexMap<ResolvedVc<NextServerComponentModule>, OutputAssetsWithReferenced>,\n }\n \n /// Computes all client references chunks.\n@@ -161,8 +159,10 @@ pub async fn get_app_client_references_chunks(\n \n             let mut current_client_availability_info = client_availability_info;\n             let mut current_client_chunks = OutputAssets::empty().to_resolved().await?;\n+            let mut current_client_referenced_assets = OutputAssets::empty().to_resolved().await?;\n             let mut current_ssr_availability_info = AvailabilityInfo::Root;\n             let mut current_ssr_chunks = OutputAssets::empty().to_resolved().await?;\n+            let mut current_ssr_referenced_assets = OutputAssets::empty().to_resolved().await?;\n \n             let mut layout_segment_client_chunks = FxIndexMap::default();\n             let mut client_component_ssr_chunks = FxIndexMap::default();\n@@ -264,26 +264,46 @@ pub async fn get_app_client_references_chunks(\n                 };\n \n                 if let Some(client_chunk_group) = client_chunk_group {\n-                    let client_chunk_group = client_chunk_group.await?;\n+                    let ChunkGroupResult {\n+                        assets,\n+                        referenced_assets,\n+                        availability_info,\n+                    } = *client_chunk_group.await?;\n \n-                    let client_chunks =\n-                        current_client_chunks.concatenate(*client_chunk_group.assets);\n-                    let client_chunks = client_chunks.to_resolved().await?;\n+                    let client_chunks = current_client_chunks\n+                        .concatenate(*assets)\n+                        .to_resolved()\n+                        .await?;\n+                    let client_referenced_assets = current_client_referenced_assets\n+                        .concatenate(*referenced_assets)\n+                        .to_resolved()\n+                        .await?;\n \n                     if is_layout {\n-                        current_client_availability_info = client_chunk_group.availability_info;\n+                        current_client_availability_info = availability_info;\n                         current_client_chunks = client_chunks;\n+                        current_client_referenced_assets = client_referenced_assets;\n                     }\n \n-                    layout_segment_client_chunks.insert(server_component, client_chunks);\n+                    layout_segment_client_chunks.insert(\n+                        server_component,\n+                        OutputAssetsWithReferenced {\n+                            assets: client_chunks,\n+                            referenced_assets: client_referenced_assets,\n+                        },\n+                    );\n \n                     for &client_reference_ty in client_reference_types.iter() {\n                         if let ClientReferenceType::EcmascriptClientReference(_) =\n                             client_reference_ty\n                         {\n                             client_component_client_chunks.insert(\n                                 client_reference_ty,\n-                                (client_chunks, client_chunk_group.availability_info),\n+                                ChunkGroupResult {\n+                                    assets: client_chunks,\n+                                    referenced_assets: client_referenced_assets,\n+                                    availability_info,\n+                                },\n                             );\n                         }\n                     }\n@@ -292,12 +312,19 @@ pub async fn get_app_client_references_chunks(\n                 if let Some(ssr_chunk_group) = ssr_chunk_group {\n                     let ssr_chunk_group = ssr_chunk_group.await?;\n \n-                    let ssr_chunks = current_ssr_chunks.concatenate(*ssr_chunk_group.assets);\n-                    let ssr_chunks = ssr_chunks.to_resolved().await?;\n+                    let ssr_chunks = current_ssr_chunks\n+                        .concatenate(*ssr_chunk_group.assets)\n+                        .to_resolved()\n+                        .await?;\n+                    let ssr_referenced_assets = current_ssr_referenced_assets\n+                        .concatenate(*ssr_chunk_group.referenced_assets)\n+                        .to_resolved()\n+                        .await?;\n \n                     if is_layout {\n                         current_ssr_availability_info = ssr_chunk_group.availability_info;\n                         current_ssr_chunks = ssr_chunks;\n+                        current_ssr_referenced_assets = ssr_referenced_assets;\n                     }\n \n                     for &client_reference_ty in client_reference_types.iter() {\n@@ -306,7 +333,11 @@ pub async fn get_app_client_references_chunks(\n                         {\n                             client_component_ssr_chunks.insert(\n                                 client_reference_ty,\n-                                (ssr_chunks, ssr_chunk_group.availability_info),\n+                                ChunkGroupResult {\n+                                    assets: ssr_chunks,\n+                                    referenced_assets: ssr_referenced_assets,\n+                                    availability_info: ssr_chunk_group.availability_info,\n+                                },\n                             );\n                         }\n                     }"
        },
        {
            "sha": "fee949cd962860bfeefaa827ab5e527cbd0fe284",
            "filename": "crates/next-core/src/next_app/app_client_shared_chunks.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_shared_chunks.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_shared_chunks.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fapp_client_shared_chunks.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -20,6 +20,7 @@ pub async fn get_app_client_shared_chunk_group(\n     if app_client_runtime_entries.await?.is_empty() {\n         return Ok(ChunkGroupResult {\n             assets: OutputAssets::empty().to_resolved().await?,\n+            referenced_assets: OutputAssets::empty().to_resolved().await?,\n             availability_info: AvailabilityInfo::Root,\n         }\n         .cell());"
        },
        {
            "sha": "cd69c5f3f20e33d9792042b0278fec91976389f2",
            "filename": "crates/next-core/src/next_manifests/client_reference_manifest.rs",
            "status": "modified",
            "additions": 60,
            "deletions": 40,
            "changes": 100,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -13,9 +13,11 @@ use turbo_tasks::{\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n-    chunk::{ChunkingContext, ModuleChunkItemIdExt, ModuleId as TurbopackModuleId},\n+    chunk::{\n+        ChunkGroupResult, ChunkingContext, ModuleChunkItemIdExt, ModuleId as TurbopackModuleId,\n+    },\n     module_graph::async_module_info::AsyncModulesInfo,\n-    output::OutputAsset,\n+    output::{OutputAsset, OutputAssetsWithReferenced},\n     virtual_output::VirtualOutputAsset,\n };\n use turbopack_ecmascript::utils::StringifyJs;\n@@ -172,44 +174,50 @@ impl ClientReferenceManifest {\n                     .chunk_item_id(*client_chunking_context)\n                     .await?;\n \n-                let (client_chunks_paths, client_is_async) =\n-                    if let Some((client_chunks, _client_availability_info)) =\n-                        client_component_client_chunks.get(&app_client_reference_ty)\n-                    {\n-                        let client_chunks = client_chunks.await?;\n-                        references.extend(client_chunks.iter());\n-                        let client_chunks_paths = cached_chunk_paths(\n-                            &mut client_chunk_path_cache,\n-                            client_chunks.iter().copied(),\n-                        )\n-                        .await?;\n+                let (client_chunks_paths, client_is_async) = if let Some(ChunkGroupResult {\n+                    assets: client_chunks,\n+                    referenced_assets: client_referenced_assets,\n+                    availability_info: _,\n+                }) =\n+                    client_component_client_chunks.get(&app_client_reference_ty)\n+                {\n+                    let client_chunks = client_chunks.await?;\n+                    let client_referenced_assets = client_referenced_assets.await?;\n+                    references.extend(client_chunks.iter());\n+                    references.extend(client_referenced_assets.iter());\n+\n+                    let client_chunks_paths = cached_chunk_paths(\n+                        &mut client_chunk_path_cache,\n+                        client_chunks.iter().copied(),\n+                    )\n+                    .await?;\n \n-                        let chunk_paths = client_chunks_paths\n-                            .filter_map(|(_, chunk_path)| {\n-                                client_relative_path\n-                                    .get_path_to(&chunk_path)\n-                                    .map(ToString::to_string)\n-                            })\n-                            // It's possible that a chunk also emits CSS files, that will\n-                            // be handled separately.\n-                            .filter(|path| path.ends_with(\".js\"))\n-                            .map(|path| {\n-                                format!(\n-                                    \"{}{}{}\",\n-                                    prefix_path,\n-                                    path.split('/').map(encode_uri_component).format(\"/\"),\n-                                    suffix_path\n-                                )\n-                            })\n-                            .map(RcStr::from)\n-                            .collect::<Vec<_>>();\n+                    let chunk_paths = client_chunks_paths\n+                        .filter_map(|(_, chunk_path)| {\n+                            client_relative_path\n+                                .get_path_to(&chunk_path)\n+                                .map(ToString::to_string)\n+                        })\n+                        // It's possible that a chunk also emits CSS files, that will\n+                        // be handled separately.\n+                        .filter(|path| path.ends_with(\".js\"))\n+                        .map(|path| {\n+                            format!(\n+                                \"{}{}{}\",\n+                                prefix_path,\n+                                path.split('/').map(encode_uri_component).format(\"/\"),\n+                                suffix_path\n+                            )\n+                        })\n+                        .map(RcStr::from)\n+                        .collect::<Vec<_>>();\n \n-                        let is_async = async_modules.contains(&ResolvedVc::upcast(client_module));\n+                    let is_async = async_modules.contains(&ResolvedVc::upcast(client_module));\n \n-                        (chunk_paths, is_async)\n-                    } else {\n-                        (Vec::new(), false)\n-                    };\n+                    (chunk_paths, is_async)\n+                } else {\n+                    (Vec::new(), false)\n+                };\n \n                 if let Some(ssr_chunking_context) = ssr_chunking_context {\n                     let ssr_module = client_reference_module_ref.ssr_module;\n@@ -225,11 +233,16 @@ impl ClientReferenceManifest {\n                         // edge runtime doesn't support dynamically\n                         // loading chunks.\n                         (Vec::new(), false)\n-                    } else if let Some((ssr_chunks, _ssr_availability_info)) =\n-                        client_component_ssr_chunks.get(&app_client_reference_ty)\n+                    } else if let Some(ChunkGroupResult {\n+                        assets: ssr_chunks,\n+                        referenced_assets: ssr_referenced_assets,\n+                        availability_info: _,\n+                    }) = client_component_ssr_chunks.get(&app_client_reference_ty)\n                     {\n                         let ssr_chunks = ssr_chunks.await?;\n+                        let ssr_referenced_assets = ssr_referenced_assets.await?;\n                         references.extend(ssr_chunks.iter());\n+                        references.extend(ssr_referenced_assets.iter());\n \n                         let ssr_chunks_paths = cached_chunk_paths(\n                             &mut ssr_chunk_path_cache,\n@@ -317,7 +330,14 @@ impl ClientReferenceManifest {\n             }\n \n             // per layout segment chunks need to be emitted into the manifest too\n-            for (server_component, client_chunks) in layout_segment_client_chunks.iter() {\n+            for (\n+                server_component,\n+                OutputAssetsWithReferenced {\n+                    assets: client_chunks,\n+                    referenced_assets: _,\n+                },\n+            ) in layout_segment_client_chunks.iter()\n+            {\n                 let server_component_name = server_component\n                     .server_path()\n                     .await?"
        },
        {
            "sha": "186c72285b57e5f3262a3cfe6f107d09a6e3c6c6",
            "filename": "test/production/deployment-id-handling/app/tsconfig.json",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/test%2Fproduction%2Fdeployment-id-handling%2Fapp%2Ftsconfig.json",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/test%2Fproduction%2Fdeployment-id-handling%2Fapp%2Ftsconfig.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fdeployment-id-handling%2Fapp%2Ftsconfig.json?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -12,7 +12,7 @@\n     \"moduleResolution\": \"bundler\",\n     \"resolveJsonModule\": true,\n     \"isolatedModules\": true,\n-    \"jsx\": \"preserve\",\n+    \"jsx\": \"react-jsx\",\n     \"plugins\": [\n       {\n         \"name\": \"next\"\n@@ -21,6 +21,12 @@\n     \"strictNullChecks\": true,\n     \"target\": \"ES2017\"\n   },\n-  \"include\": [\"next-env.d.ts\", \".next/types/**/*.ts\", \"**/*.ts\", \"**/*.tsx\"],\n-  \"exclude\": [\"node_modules\"]\n+  \"include\": [\n+    \"**/*.ts\",\n+    \"**/*.tsx\",\n+    \".next/types/**/*.ts\",\n+    \"next-env.d.ts\",\n+    \"**/*.mts\"\n+  ],\n+  \"exclude\": [\"node_modules\", \"**/*.test.ts\", \"**/*.test.tsx\"]\n }"
        },
        {
            "sha": "f1bb0e2468b1c50fccf8f30ff9626382d10bf31f",
            "filename": "test/production/deployment-id-handling/deployment-id-cookie-handling.test.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 5,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/test%2Fproduction%2Fdeployment-id-handling%2Fdeployment-id-cookie-handling.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/test%2Fproduction%2Fdeployment-id-handling%2Fdeployment-id-cookie-handling.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fdeployment-id-handling%2Fdeployment-id-cookie-handling.test.ts?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -1,5 +1,5 @@\n import { nextTestSetup } from 'e2e-utils'\n-import { check } from 'next-test-utils'\n+import { retry } from 'next-test-utils'\n import { join } from 'node:path'\n \n describe('deployment-id-handling disabled', () => {\n@@ -62,10 +62,7 @@ describe('deployment-id-handling disabled', () => {\n \n       await browser.elementByCss('#dynamic-import').click()\n \n-      await check(\n-        () => (requests.length > 0 ? 'success' : JSON.stringify(requests)),\n-        'success'\n-      )\n+      await retry(() => expect(requests).not.toBeEmpty())\n \n       try {\n         expect("
        },
        {
            "sha": "7388b6c9764f717b1cb4a706cfb0bac3dad08e6c",
            "filename": "test/production/deployment-id-handling/deployment-id-handling.test.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 9,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/test%2Fproduction%2Fdeployment-id-handling%2Fdeployment-id-handling.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/test%2Fproduction%2Fdeployment-id-handling%2Fdeployment-id-handling.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fdeployment-id-handling%2Fdeployment-id-handling.test.ts?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -1,5 +1,5 @@\n import { nextTestSetup } from 'e2e-utils'\n-import { check, retry } from 'next-test-utils'\n+import { retry } from 'next-test-utils'\n import { join } from 'node:path'\n \n describe.each(['NEXT_DEPLOYMENT_ID', 'CUSTOM_DEPLOYMENT_ID'])(\n@@ -58,10 +58,7 @@ describe.each(['NEXT_DEPLOYMENT_ID', 'CUSTOM_DEPLOYMENT_ID'])(\n \n         await browser.elementByCss('#dynamic-import').click()\n \n-        await check(\n-          () => (requests.length > 0 ? 'success' : JSON.stringify(requests)),\n-          'success'\n-        )\n+        await retry(() => expect(requests).not.toBeEmpty())\n \n         try {\n           expect(\n@@ -190,10 +187,7 @@ describe('deployment-id-handling disabled', () => {\n \n       await browser.elementByCss('#dynamic-import').click()\n \n-      await check(\n-        () => (requests.length > 0 ? 'success' : JSON.stringify(requests)),\n-        'success'\n-      )\n+      await retry(() => expect(requests).not.toBeEmpty())\n \n       try {\n         expect("
        },
        {
            "sha": "36694cce5c6e8c6b2f5b0b4658524327e9239d28",
            "filename": "turbopack/crates/turbopack-browser/src/chunking_context.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -577,6 +577,7 @@ impl ChunkingContext for BrowserChunkingContext {\n             let input_availability_info = availability_info;\n             let MakeChunkGroupResult {\n                 chunks,\n+                referenced_output_assets,\n                 availability_info,\n             } = make_chunk_group(\n                 entries,\n@@ -619,6 +620,7 @@ impl ChunkingContext for BrowserChunkingContext {\n \n             Ok(ChunkGroupResult {\n                 assets: ResolvedVc::cell(assets),\n+                referenced_assets: ResolvedVc::cell(referenced_output_assets),\n                 availability_info,\n             }\n             .cell())\n@@ -644,6 +646,7 @@ impl ChunkingContext for BrowserChunkingContext {\n             let entries = chunk_group.entries();\n             let MakeChunkGroupResult {\n                 chunks,\n+                referenced_output_assets,\n                 availability_info,\n             } = make_chunk_group(\n                 entries,\n@@ -703,6 +706,7 @@ impl ChunkingContext for BrowserChunkingContext {\n \n             Ok(ChunkGroupResult {\n                 assets: ResolvedVc::cell(assets),\n+                referenced_assets: ResolvedVc::cell(referenced_output_assets),\n                 availability_info,\n             }\n             .cell())\n@@ -718,6 +722,7 @@ impl ChunkingContext for BrowserChunkingContext {\n         _evaluatable_assets: Vc<EvaluatableAssets>,\n         _module_graph: Vc<ModuleGraph>,\n         _extra_chunks: Vc<OutputAssets>,\n+        _extra_referenced_assets: Vc<OutputAssets>,\n         _availability_info: AvailabilityInfo,\n     ) -> Result<Vc<EntryChunkGroupResult>> {\n         bail!(\"Browser chunking context does not support entry chunk groups\")"
        },
        {
            "sha": "bd2c71c6793037017d6f1b5f6e622391caf64548",
            "filename": "turbopack/crates/turbopack-cli/src/build/mod.rs",
            "status": "modified",
            "additions": 49,
            "deletions": 35,
            "changes": 84,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -23,8 +23,8 @@ use turbopack_cli_utils::issue::{ConsoleUi, LogOptions};\n use turbopack_core::{\n     asset::Asset,\n     chunk::{\n-        ChunkingConfig, ChunkingContext, EvaluatableAsset, EvaluatableAssets, MangleType,\n-        MinifyType, SourceMapsType, availability_info::AvailabilityInfo,\n+        ChunkingConfig, ChunkingContext, ChunkingContextExt, EvaluatableAsset, EvaluatableAssets,\n+        MangleType, MinifyType, SourceMapsType, availability_info::AvailabilityInfo,\n     },\n     environment::{BrowserEnvironment, Environment, ExecutionEnvironment, NodeJsEnvironment},\n     ident::AssetIdent,\n@@ -35,7 +35,7 @@ use turbopack_core::{\n         chunk_group_info::{ChunkGroup, ChunkGroupEntry},\n         export_usage::compute_export_usage_info,\n     },\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n     reference::all_assets_from_entries,\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     resolve::{\n@@ -428,8 +428,8 @@ async fn build_internal(\n                     {\n                         match target {\n                             Target::Browser => {\n-                                chunking_context\n-                                    .evaluated_chunk_group(\n+                                *chunking_context\n+                                    .evaluated_chunk_group_assets(\n                                         AssetIdent::from_path(\n                                             build_output_root\n                                                 .join(\n@@ -449,29 +449,32 @@ async fn build_internal(\n                                         AvailabilityInfo::Root,\n                                     )\n                                     .await?\n-                                    .assets\n                             }\n-                            Target::Node => ResolvedVc::cell(vec![\n-                                chunking_context\n-                                    .entry_chunk_group(\n-                                        build_output_root\n-                                            .join(\n-                                                ecmascript\n-                                                    .ident()\n-                                                    .path()\n-                                                    .await?\n-                                                    .file_stem()\n-                                                    .unwrap(),\n-                                            )?\n-                                            .with_extension(\"entry.js\"),\n-                                        EvaluatableAssets::one(*ecmascript),\n-                                        module_graph,\n-                                        OutputAssets::empty(),\n-                                        AvailabilityInfo::Root,\n-                                    )\n-                                    .await?\n-                                    .asset,\n-                            ]),\n+                            Target::Node => OutputAssetsWithReferenced {\n+                                assets: ResolvedVc::cell(vec![\n+                                    chunking_context\n+                                        .entry_chunk_group(\n+                                            build_output_root\n+                                                .join(\n+                                                    ecmascript\n+                                                        .ident()\n+                                                        .path()\n+                                                        .await?\n+                                                        .file_stem()\n+                                                        .unwrap(),\n+                                                )?\n+                                                .with_extension(\"entry.js\"),\n+                                            EvaluatableAssets::one(*ecmascript),\n+                                            module_graph,\n+                                            OutputAssets::empty(),\n+                                            OutputAssets::empty(),\n+                                            AvailabilityInfo::Root,\n+                                        )\n+                                        .await?\n+                                        .asset,\n+                                ]),\n+                                referenced_assets: ResolvedVc::cell(vec![]),\n+                            },\n                         }\n                     } else {\n                         bail!(\n@@ -485,16 +488,27 @@ async fn build_internal(\n         .try_join()\n         .await?;\n \n-    let mut chunks: FxHashSet<ResolvedVc<Box<dyn OutputAsset>>> = FxHashSet::default();\n-    for chunk_group in entry_chunk_groups {\n-        chunks.extend(\n-            &*async move { all_assets_from_entries(*chunk_group).await }\n-                .instrument(tracing::info_span!(\"list chunks\"))\n-                .await?,\n-        );\n+    let all_assets = async move {\n+        let mut all_assets: FxHashSet<ResolvedVc<Box<dyn OutputAsset>>> = FxHashSet::default();\n+        for OutputAssetsWithReferenced {\n+            assets,\n+            referenced_assets,\n+        } in entry_chunk_groups\n+        {\n+            all_assets.extend(all_assets_from_entries(*assets).await?.into_iter().copied());\n+            all_assets.extend(\n+                all_assets_from_entries(*referenced_assets)\n+                    .await?\n+                    .into_iter()\n+                    .copied(),\n+            );\n+        }\n+        anyhow::Ok(all_assets)\n     }\n+    .instrument(tracing::info_span!(\"list chunks\"))\n+    .await?;\n \n-    chunks\n+    all_assets\n         .iter()\n         .map(|c| async move { c.content().write(c.path().owned().await?).await })\n         .try_join()"
        },
        {
            "sha": "bc26d79da7e2e0de3aa7ffad5050e59a63e2a45f",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunk_group.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunk_group.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -25,13 +25,14 @@ use crate::{\n         },\n         module_batches::{BatchingConfig, ModuleBatchesGraphEdge},\n     },\n-    output::OutputAssets,\n+    output::{OutputAsset, OutputAssets},\n     reference::ModuleReference,\n     traced_asset::TracedAsset,\n };\n \n pub struct MakeChunkGroupResult {\n     pub chunks: Vec<ResolvedVc<Box<dyn Chunk>>>,\n+    pub referenced_output_assets: Vec<ResolvedVc<Box<dyn OutputAsset>>>,\n     pub availability_info: AvailabilityInfo,\n }\n \n@@ -155,12 +156,12 @@ pub async fn make_chunk_group(\n         chunk_items,\n         chunk_item_batch_groups,\n         rcstr!(\"\"),\n-        ResolvedVc::cell(referenced_output_assets),\n     )\n     .await?;\n \n     Ok(MakeChunkGroupResult {\n         chunks,\n+        referenced_output_assets,\n         availability_info,\n     })\n }"
        },
        {
            "sha": "a11397cb79489d3503fae391733a0620c1c305e1",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunking/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 13,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking%2Fmod.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -1,4 +1,4 @@\n-use std::{future::IntoFuture, mem::replace};\n+use std::future::IntoFuture;\n \n use anyhow::Result;\n use rustc_hash::FxHashMap;\n@@ -26,7 +26,6 @@ use crate::{\n         },\n     },\n     module_graph::ModuleGraph,\n-    output::OutputAssets,\n };\n \n mod dev;\n@@ -283,15 +282,13 @@ async fn batch_chunk_items_with_info_with_type(\n     Ok(Vc::cell(map))\n }\n \n-/// Creates chunks based on heuristics for the passed `chunk_items`. Also\n-/// attaches `referenced_output_assets` to the first chunk.\n+/// Creates chunks based on heuristics for the passed `chunk_items`.\n pub async fn make_chunks(\n     module_graph: Vc<ModuleGraph>,\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n     chunk_items_or_batches: Vec<ChunkItemOrBatchWithAsyncModuleInfo>,\n     batch_groups: Vec<ResolvedVc<ChunkItemBatchGroup>>,\n     key_prefix: RcStr,\n-    mut referenced_output_assets: ResolvedVc<OutputAssets>,\n ) -> Result<Vec<ResolvedVc<Box<dyn Chunk>>>> {\n     let chunking_configs = &*chunking_context.chunking_configs().await?;\n \n@@ -330,8 +327,6 @@ pub async fn make_chunks(\n                 ty,\n                 chunking_context,\n                 chunks: &mut chunks,\n-                referenced_output_assets: &mut referenced_output_assets,\n-                empty_referenced_output_assets: OutputAssets::empty().to_resolved().await?,\n             };\n \n             if let Some(chunking_config) = chunking_configs.get(&ty) {\n@@ -400,8 +395,6 @@ struct SplitContext<'a> {\n     // resolution of `chunks` is deferred so it can be done with `try_join` at the end, letting as\n     // much work happen in parallel as possible.\n     chunks: &'a mut Vec<Vc<Box<dyn Chunk>>>,\n-    referenced_output_assets: &'a mut ResolvedVc<OutputAssets>,\n-    empty_referenced_output_assets: ResolvedVc<OutputAssets>,\n }\n \n /// Creates a chunk with the given `chunk_items. `key` should be unique.\n@@ -427,10 +420,6 @@ async fn make_chunk<'l>(\n                 })\n                 .collect(),\n             ResolvedVc::deref_vec(batch_groups),\n-            *replace(\n-                split_context.referenced_output_assets,\n-                split_context.empty_referenced_output_assets,\n-            ),\n         ),\n     );\n     Ok(())"
        },
        {
            "sha": "6818a12fce9e1a7dc50ad589fd83155bb094bc86",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunking_context.rs",
            "status": "modified",
            "additions": 45,
            "deletions": 19,
            "changes": 64,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking_context.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -17,7 +17,7 @@ use crate::{\n         ModuleGraph, chunk_group_info::ChunkGroup, export_usage::ModuleExportUsage,\n         module_batches::BatchingConfig,\n     },\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n };\n \n #[derive(\n@@ -87,8 +87,10 @@ pub enum ChunkGroupType {\n }\n \n #[turbo_tasks::value(shared)]\n+#[derive(Clone, Copy)]\n pub struct ChunkGroupResult {\n     pub assets: ResolvedVc<OutputAssets>,\n+    pub referenced_assets: ResolvedVc<OutputAssets>,\n     pub availability_info: AvailabilityInfo,\n }\n \n@@ -273,6 +275,7 @@ pub trait ChunkingContext {\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n+        extra_referenced_assets: Vc<OutputAssets>,\n         availability_info: AvailabilityInfo,\n     ) -> Result<Vc<EntryChunkGroupResult>>;\n \n@@ -313,7 +316,7 @@ pub trait ChunkingContextExt {\n         ident: Vc<AssetIdent>,\n         chunk_group: ChunkGroup,\n         module_graph: Vc<ModuleGraph>,\n-    ) -> Vc<OutputAssets>\n+    ) -> Vc<OutputAssetsWithReferenced>\n     where\n         Self: Send;\n \n@@ -323,7 +326,7 @@ pub trait ChunkingContextExt {\n         chunk_group: ChunkGroup,\n         module_graph: Vc<ModuleGraph>,\n         availability_info: AvailabilityInfo,\n-    ) -> Vc<OutputAssets>\n+    ) -> Vc<OutputAssetsWithReferenced>\n     where\n         Self: Send;\n \n@@ -333,6 +336,7 @@ pub trait ChunkingContextExt {\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n+        extra_referenced_assets: Vc<OutputAssets>,\n         availability_info: AvailabilityInfo,\n     ) -> Vc<Box<dyn OutputAsset>>\n     where\n@@ -344,6 +348,7 @@ pub trait ChunkingContextExt {\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n+        extra_referenced_assets: Vc<OutputAssets>,\n     ) -> Vc<EntryChunkGroupResult>\n     where\n         Self: Send;\n@@ -354,6 +359,7 @@ pub trait ChunkingContextExt {\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n+        extra_referenced_assets: Vc<OutputAssets>,\n     ) -> Vc<Box<dyn OutputAsset>>\n     where\n         Self: Send;\n@@ -364,7 +370,7 @@ pub trait ChunkingContextExt {\n         chunk_group: ChunkGroup,\n         module_graph: Vc<ModuleGraph>,\n         availability_info: AvailabilityInfo,\n-    ) -> Vc<OutputAssets>\n+    ) -> Vc<OutputAssetsWithReferenced>\n     where\n         Self: Send;\n }\n@@ -384,7 +390,7 @@ impl<T: ChunkingContext + Send + Upcast<Box<dyn ChunkingContext>>> ChunkingConte\n         ident: Vc<AssetIdent>,\n         chunk_group: ChunkGroup,\n         module_graph: Vc<ModuleGraph>,\n-    ) -> Vc<OutputAssets> {\n+    ) -> Vc<OutputAssetsWithReferenced> {\n         root_chunk_group_assets(\n             Vc::upcast_non_strict(self),\n             ident,\n@@ -399,7 +405,7 @@ impl<T: ChunkingContext + Send + Upcast<Box<dyn ChunkingContext>>> ChunkingConte\n         chunk_group: ChunkGroup,\n         module_graph: Vc<ModuleGraph>,\n         availability_info: AvailabilityInfo,\n-    ) -> Vc<OutputAssets> {\n+    ) -> Vc<OutputAssetsWithReferenced> {\n         evaluated_chunk_group_assets(\n             Vc::upcast_non_strict(self),\n             ident,\n@@ -415,6 +421,7 @@ impl<T: ChunkingContext + Send + Upcast<Box<dyn ChunkingContext>>> ChunkingConte\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n+        extra_referenced_assets: Vc<OutputAssets>,\n         availability_info: AvailabilityInfo,\n     ) -> Vc<Box<dyn OutputAsset>> {\n         entry_chunk_group_asset(\n@@ -423,6 +430,7 @@ impl<T: ChunkingContext + Send + Upcast<Box<dyn ChunkingContext>>> ChunkingConte\n             evaluatable_assets,\n             module_graph,\n             extra_chunks,\n+            extra_referenced_assets,\n             availability_info,\n         )\n     }\n@@ -433,12 +441,14 @@ impl<T: ChunkingContext + Send + Upcast<Box<dyn ChunkingContext>>> ChunkingConte\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n+        extra_referenced_assets: Vc<OutputAssets>,\n     ) -> Vc<EntryChunkGroupResult> {\n         self.entry_chunk_group(\n             path,\n             evaluatable_assets,\n             module_graph,\n             extra_chunks,\n+            extra_referenced_assets,\n             AvailabilityInfo::Root,\n         )\n     }\n@@ -449,13 +459,15 @@ impl<T: ChunkingContext + Send + Upcast<Box<dyn ChunkingContext>>> ChunkingConte\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n+        extra_referenced_assets: Vc<OutputAssets>,\n     ) -> Vc<Box<dyn OutputAsset>> {\n         entry_chunk_group_asset(\n             Vc::upcast_non_strict(self),\n             path,\n             evaluatable_assets,\n             module_graph,\n             extra_chunks,\n+            extra_referenced_assets,\n             AvailabilityInfo::Root,\n         )\n     }\n@@ -466,7 +478,7 @@ impl<T: ChunkingContext + Send + Upcast<Box<dyn ChunkingContext>>> ChunkingConte\n         chunk_group: ChunkGroup,\n         module_graph: Vc<ModuleGraph>,\n         availability_info: AvailabilityInfo,\n-    ) -> Vc<OutputAssets> {\n+    ) -> Vc<OutputAssetsWithReferenced> {\n         chunk_group_assets(\n             Vc::upcast_non_strict(self),\n             ident,\n@@ -483,11 +495,15 @@ async fn root_chunk_group_assets(\n     ident: Vc<AssetIdent>,\n     chunk_group: ChunkGroup,\n     module_graph: Vc<ModuleGraph>,\n-) -> Result<Vc<OutputAssets>> {\n-    Ok(*chunking_context\n+) -> Result<Vc<OutputAssetsWithReferenced>> {\n+    let root_chunk_group = chunking_context\n         .root_chunk_group(ident, chunk_group, module_graph)\n-        .await?\n-        .assets)\n+        .await?;\n+    Ok(OutputAssetsWithReferenced {\n+        assets: root_chunk_group.assets,\n+        referenced_assets: root_chunk_group.referenced_assets,\n+    }\n+    .cell())\n }\n \n #[turbo_tasks::function]\n@@ -497,11 +513,15 @@ async fn evaluated_chunk_group_assets(\n     chunk_group: ChunkGroup,\n     module_graph: Vc<ModuleGraph>,\n     availability_info: AvailabilityInfo,\n-) -> Result<Vc<OutputAssets>> {\n-    Ok(*chunking_context\n+) -> Result<Vc<OutputAssetsWithReferenced>> {\n+    let evaluated_chunk_group = chunking_context\n         .evaluated_chunk_group(ident, chunk_group, module_graph, availability_info)\n-        .await?\n-        .assets)\n+        .await?;\n+    Ok(OutputAssetsWithReferenced {\n+        assets: evaluated_chunk_group.assets,\n+        referenced_assets: evaluated_chunk_group.referenced_assets,\n+    }\n+    .cell())\n }\n \n #[turbo_tasks::function]\n@@ -511,6 +531,7 @@ async fn entry_chunk_group_asset(\n     evaluatable_assets: Vc<EvaluatableAssets>,\n     module_graph: Vc<ModuleGraph>,\n     extra_chunks: Vc<OutputAssets>,\n+    extra_referenced_assets: Vc<OutputAssets>,\n     availability_info: AvailabilityInfo,\n ) -> Result<Vc<Box<dyn OutputAsset>>> {\n     Ok(*chunking_context\n@@ -519,6 +540,7 @@ async fn entry_chunk_group_asset(\n             evaluatable_assets,\n             module_graph,\n             extra_chunks,\n+            extra_referenced_assets,\n             availability_info,\n         )\n         .await?\n@@ -532,9 +554,13 @@ async fn chunk_group_assets(\n     chunk_group: ChunkGroup,\n     module_graph: Vc<ModuleGraph>,\n     availability_info: AvailabilityInfo,\n-) -> Result<Vc<OutputAssets>> {\n-    Ok(*chunking_context\n+) -> Result<Vc<OutputAssetsWithReferenced>> {\n+    let chunk_group = chunking_context\n         .chunk_group(ident, chunk_group, module_graph, availability_info)\n-        .await?\n-        .assets)\n+        .await?;\n+    Ok(OutputAssetsWithReferenced {\n+        assets: chunk_group.assets,\n+        referenced_assets: chunk_group.referenced_assets,\n+    }\n+    .cell())\n }"
        },
        {
            "sha": "cc10ba4c5312a7919d065d44c8c591b7676f0d4a",
            "filename": "turbopack/crates/turbopack-core/src/chunk/mod.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -481,7 +481,6 @@ pub trait ChunkType: ValueToString {\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n         chunk_items: Vec<ChunkItemOrBatchWithAsyncModuleInfo>,\n         batch_groups: Vec<ResolvedVc<ChunkItemBatchGroup>>,\n-        referenced_output_assets: Vc<OutputAssets>,\n     ) -> Vc<Box<dyn Chunk>>;\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "540795c8ed95d6d54a17dadd8a5687a4ae385226",
            "filename": "turbopack/crates/turbopack-core/src/output.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Foutput.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Foutput.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Foutput.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -59,3 +59,18 @@ impl OutputAssets {\n /// A set of [OutputAsset]s\n #[turbo_tasks::value(transparent)]\n pub struct OutputAssetsSet(FxIndexSet<ResolvedVc<Box<dyn OutputAsset>>>);\n+\n+#[turbo_tasks::value(shared)]\n+#[derive(Clone, Copy)]\n+pub struct OutputAssetsWithReferenced {\n+    pub assets: ResolvedVc<OutputAssets>,\n+    pub referenced_assets: ResolvedVc<OutputAssets>,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl OutputAssetsWithReferenced {\n+    #[turbo_tasks::function]\n+    pub fn all_assets(&self) -> Vc<OutputAssets> {\n+        self.assets.concatenate(*self.referenced_assets)\n+    }\n+}"
        },
        {
            "sha": "ad8341fa78f4debfb7978743f6e0c2b7e4b57bc4",
            "filename": "turbopack/crates/turbopack-css/src/chunk/mod.rs",
            "status": "modified",
            "additions": 18,
            "deletions": 24,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -236,7 +236,6 @@ pub async fn write_import_context(\n #[turbo_tasks::value]\n pub struct CssChunkContent {\n     pub chunk_items: Vec<ResolvedVc<Box<dyn CssChunkItem>>>,\n-    pub referenced_output_assets: ResolvedVc<OutputAssets>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -337,33 +336,30 @@ impl OutputAsset for CssChunk {\n     async fn references(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n         let this = self.await?;\n         let content = this.content.await?;\n-        let mut references = content.referenced_output_assets.owned().await?;\n         let should_generate_single_item_chunks = content.chunk_items.len() > 1\n             && *this\n                 .chunking_context\n                 .is_dynamic_chunk_content_loading_enabled()\n                 .await?;\n-        references.extend(\n-            content\n-                .chunk_items\n-                .iter()\n-                .map(|item| async {\n-                    let references = item.references().await?.into_iter().copied();\n-                    Ok(if should_generate_single_item_chunks {\n-                        Either::Left(\n-                            references.chain(std::iter::once(ResolvedVc::upcast(\n-                                SingleItemCssChunk::new(*this.chunking_context, **item)\n-                                    .to_resolved()\n-                                    .await?,\n-                            ))),\n-                        )\n-                    } else {\n-                        Either::Right(references)\n-                    })\n+        let mut references = content\n+            .chunk_items\n+            .iter()\n+            .map(|item| async {\n+                let references = item.references().await?.into_iter().copied();\n+                Ok(if should_generate_single_item_chunks {\n+                    Either::Left(\n+                        references.chain(std::iter::once(ResolvedVc::upcast(\n+                            SingleItemCssChunk::new(*this.chunking_context, **item)\n+                                .to_resolved()\n+                                .await?,\n+                        ))),\n+                    )\n+                } else {\n+                    Either::Right(references)\n                 })\n-                .try_flat_join()\n-                .await?,\n-        );\n+            })\n+            .try_flat_join()\n+            .await?;\n         if *this\n             .chunking_context\n             .reference_chunk_source_maps(Vc::upcast(self))\n@@ -501,7 +497,6 @@ impl ChunkType for CssChunkType {\n         chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n         chunk_items_or_batches: Vec<ChunkItemOrBatchWithAsyncModuleInfo>,\n         _batch_groups: Vec<ResolvedVc<ChunkItemBatchGroup>>,\n-        referenced_output_assets: ResolvedVc<OutputAssets>,\n     ) -> Result<Vc<Box<dyn Chunk>>> {\n         let mut chunk_items = Vec::new();\n         // TODO operate with batches\n@@ -530,7 +525,6 @@ impl ChunkType for CssChunkType {\n                 })\n                 .try_join()\n                 .await?,\n-            referenced_output_assets,\n         }\n         .cell();\n         Ok(Vc::upcast(CssChunk::new(*chunking_context, content)))"
        },
        {
            "sha": "13c6e49d5d642021bcfb47603088b08a42a90fce",
            "filename": "turbopack/crates/turbopack-dev-server/src/html.rs",
            "status": "modified",
            "additions": 44,
            "deletions": 30,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fhtml.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fhtml.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fhtml.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -15,7 +15,7 @@ use turbopack_core::{\n     },\n     module::Module,\n     module_graph::{ModuleGraph, chunk_group_info::ChunkGroup},\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n     version::{Version, VersionedContent},\n };\n \n@@ -49,7 +49,7 @@ impl OutputAsset for DevHtmlAsset {\n \n     #[turbo_tasks::function]\n     fn references(self: Vc<Self>) -> Vc<OutputAssets> {\n-        self.chunks()\n+        self.chunk_group().all_assets()\n     }\n }\n \n@@ -116,7 +116,7 @@ impl DevHtmlAsset {\n         let this = self.await?;\n         let context_path = this.path.parent();\n         let mut chunk_paths = vec![];\n-        for chunk in &*self.chunks().await? {\n+        for chunk in &*self.chunk_group().await?.assets.await? {\n             let chunk_path = &*chunk.path().await?;\n             if let Some(relative_path) = context_path.get_path_to(chunk_path) {\n                 chunk_paths.push(format!(\"/{relative_path}\").into());\n@@ -127,8 +127,8 @@ impl DevHtmlAsset {\n     }\n \n     #[turbo_tasks::function]\n-    async fn chunks(&self) -> Result<Vc<OutputAssets>> {\n-        let all_assets = self\n+    async fn chunk_group(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        let all_chunk_groups = self\n             .entries\n             .iter()\n             .map(|entry| async move {\n@@ -139,7 +139,7 @@ impl DevHtmlAsset {\n                     runtime_entries,\n                 } = entry;\n \n-                let assets = if let Some(runtime_entries) = runtime_entries {\n+                let asset_with_referenced = if let Some(runtime_entries) = runtime_entries {\n                     let runtime_entries =\n                         if let Some(evaluatable) = ResolvedVc::try_downcast(chunkable_module) {\n                             runtime_entries\n@@ -149,36 +149,50 @@ impl DevHtmlAsset {\n                         } else {\n                             runtime_entries\n                         };\n-                    chunking_context.evaluated_chunk_group_assets(\n-                        chunkable_module.ident(),\n-                        ChunkGroup::Entry(\n-                            runtime_entries\n-                                .await?\n-                                .iter()\n-                                .map(|v| ResolvedVc::upcast(*v))\n-                                .collect(),\n-                        ),\n-                        *module_graph,\n-                        AvailabilityInfo::Root,\n-                    )\n+                    chunking_context\n+                        .evaluated_chunk_group_assets(\n+                            chunkable_module.ident(),\n+                            ChunkGroup::Entry(\n+                                runtime_entries\n+                                    .await?\n+                                    .iter()\n+                                    .map(|v| ResolvedVc::upcast(*v))\n+                                    .collect(),\n+                            ),\n+                            *module_graph,\n+                            AvailabilityInfo::Root,\n+                        )\n+                        .await?\n                 } else {\n-                    chunking_context.root_chunk_group_assets(\n-                        chunkable_module.ident(),\n-                        ChunkGroup::Entry(vec![ResolvedVc::upcast(chunkable_module)]),\n-                        *module_graph,\n-                    )\n+                    chunking_context\n+                        .root_chunk_group_assets(\n+                            chunkable_module.ident(),\n+                            ChunkGroup::Entry(vec![ResolvedVc::upcast(chunkable_module)]),\n+                            *module_graph,\n+                        )\n+                        .await?\n                 };\n \n-                assets.await\n+                Ok((\n+                    asset_with_referenced.assets.await?,\n+                    asset_with_referenced.referenced_assets.await?,\n+                ))\n             })\n             .try_join()\n-            .await?\n-            .iter()\n-            .flatten()\n-            .copied()\n-            .collect();\n+            .await?;\n \n-        Ok(Vc::cell(all_assets))\n+        let mut all_assets = Vec::new();\n+        let mut all_referenced_assets = Vec::new();\n+        for (asset, referenced_asset) in all_chunk_groups {\n+            all_assets.extend(asset);\n+            all_referenced_assets.extend(referenced_asset);\n+        }\n+\n+        Ok(OutputAssetsWithReferenced {\n+            assets: ResolvedVc::cell(all_assets),\n+            referenced_assets: ResolvedVc::cell(all_referenced_assets),\n+        }\n+        .cell())\n     }\n }\n "
        },
        {
            "sha": "da54f0b82302e2235a42fed5fb66befda120fc02",
            "filename": "turbopack/crates/turbopack-ecmascript/src/async_chunk/chunk_item.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 5,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fasync_chunk%2Fchunk_item.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -11,7 +11,7 @@ use turbopack_core::{\n     module_graph::{\n         ModuleGraph, chunk_group_info::ChunkGroup, module_batch::ChunkableModuleOrBatch,\n     },\n-    output::OutputAssets,\n+    output::{OutputAssets, OutputAssetsWithReferenced},\n };\n \n use crate::{\n@@ -34,7 +34,7 @@ pub struct AsyncLoaderChunkItem {\n #[turbo_tasks::value_impl]\n impl AsyncLoaderChunkItem {\n     #[turbo_tasks::function]\n-    pub(super) async fn chunks(&self) -> Result<Vc<OutputAssets>> {\n+    pub(super) async fn chunk_group(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let module = self.module.await?;\n         if let Some(chunk_items) = module.availability_info.available_modules() {\n             let inner_module = ResolvedVc::upcast(module.inner);\n@@ -47,7 +47,11 @@ impl AsyncLoaderChunkItem {\n                 ChunkableModuleOrBatch::from_module_or_batch(module_or_batch)\n                 && *chunk_items.get(chunkable_module_or_batch).await?\n             {\n-                return Ok(Vc::cell(vec![]));\n+                return Ok(OutputAssetsWithReferenced {\n+                    assets: ResolvedVc::cell(vec![]),\n+                    referenced_assets: ResolvedVc::cell(vec![]),\n+                }\n+                .cell());\n             }\n         }\n         Ok(self.chunking_context.chunk_group_assets(\n@@ -63,7 +67,7 @@ impl AsyncLoaderChunkItem {\n         let this = self.await?;\n         Ok(ChunkData::from_assets(\n             this.chunking_context.output_root().owned().await?,\n-            self.chunks(),\n+            *self.chunk_group().await?.assets,\n         ))\n     }\n }\n@@ -162,7 +166,7 @@ impl ChunkItem for AsyncLoaderChunkItem {\n \n     #[turbo_tasks::function]\n     fn references(self: Vc<Self>) -> Vc<OutputAssets> {\n-        self.chunks()\n+        self.chunk_group().all_assets()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "423ce56bf5c460de1b4b5c70b7a8cec4b7329909",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/chunk_type.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 8,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fchunk_type.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fchunk_type.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fchunk_type.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -1,12 +1,9 @@\n use anyhow::{Result, bail};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, TryJoinIterExt, ValueDefault, ValueToString, Vc};\n-use turbopack_core::{\n-    chunk::{\n-        AsyncModuleInfo, Chunk, ChunkItem, ChunkItemBatchGroup,\n-        ChunkItemOrBatchWithAsyncModuleInfo, ChunkType, ChunkingContext, round_chunk_item_size,\n-    },\n-    output::OutputAssets,\n+use turbopack_core::chunk::{\n+    AsyncModuleInfo, Chunk, ChunkItem, ChunkItemBatchGroup, ChunkItemOrBatchWithAsyncModuleInfo,\n+    ChunkType, ChunkingContext, round_chunk_item_size,\n };\n \n use super::{EcmascriptChunk, EcmascriptChunkContent, EcmascriptChunkItem};\n@@ -37,7 +34,6 @@ impl ChunkType for EcmascriptChunkType {\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n         chunk_items: Vec<ChunkItemOrBatchWithAsyncModuleInfo>,\n         batch_groups: Vec<ResolvedVc<ChunkItemBatchGroup>>,\n-        referenced_output_assets: Vc<OutputAssets>,\n     ) -> Result<Vc<Box<dyn Chunk>>> {\n         let content = EcmascriptChunkContent {\n             chunk_items: chunk_items\n@@ -53,7 +49,6 @@ impl ChunkType for EcmascriptChunkType {\n                 })\n                 .try_join()\n                 .await?,\n-            referenced_output_assets: referenced_output_assets.owned().await?,\n         }\n         .cell();\n         Ok(Vc::upcast(EcmascriptChunk::new(chunking_context, content)))"
        },
        {
            "sha": "5c61ef72b13a0964f160e62712c03b43da031da2",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/content.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 5,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fcontent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fcontent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fcontent.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -3,10 +3,7 @@ use std::future::IntoFuture;\n use anyhow::Result;\n use either::Either;\n use turbo_tasks::{ReadRef, ResolvedVc, TryJoinIterExt, Vc};\n-use turbopack_core::{\n-    chunk::{ChunkItem, ChunkItems, batch_info},\n-    output::OutputAsset,\n-};\n+use turbopack_core::chunk::{ChunkItem, ChunkItems, batch_info};\n \n use crate::chunk::{\n     CodeAndIds,\n@@ -18,7 +15,6 @@ use crate::chunk::{\n pub struct EcmascriptChunkContent {\n     pub chunk_items: Vec<EcmascriptChunkItemOrBatchWithAsyncInfo>,\n     pub batch_groups: Vec<ResolvedVc<EcmascriptChunkItemBatchGroup>>,\n-    pub referenced_output_assets: Vec<ResolvedVc<Box<dyn OutputAsset>>>,\n }\n \n #[turbo_tasks::value_impl]"
        },
        {
            "sha": "f0bcc62a0f928a2a89e003884534be3e825a5fa1",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fmod.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -19,7 +19,7 @@ use turbopack_core::{\n         Introspectable, IntrospectableChildren, module::IntrospectableModule,\n         utils::children_from_output_assets,\n     },\n-    output::{OutputAsset, OutputAssets},\n+    output::OutputAssets,\n     server_fs::ServerFileSystem,\n };\n \n@@ -130,13 +130,12 @@ impl Chunk for EcmascriptChunk {\n     #[turbo_tasks::function]\n     async fn references(&self) -> Result<Vc<OutputAssets>> {\n         let content = self.content.await?;\n-        let mut referenced_output_assets: Vec<ResolvedVc<Box<dyn OutputAsset>>> = content\n+        let referenced_output_assets = content\n             .chunk_items\n             .iter()\n             .map(async |with_info| Ok(with_info.references().await?.into_iter().copied()))\n             .try_flat_join()\n             .await?;\n-        referenced_output_assets.extend(content.referenced_output_assets.iter().copied());\n         Ok(Vc::cell(referenced_output_assets))\n     }\n "
        },
        {
            "sha": "2a135a6deb05179244aaffd31b14339f9328b3b0",
            "filename": "turbopack/crates/turbopack-ecmascript/src/manifest/chunk_asset.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 8,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_asset.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -11,7 +11,7 @@ use turbopack_core::{\n     module_graph::{\n         ModuleGraph, chunk_group_info::ChunkGroup, module_batch::ChunkableModuleOrBatch,\n     },\n-    output::OutputAssets,\n+    output::OutputAssetsWithReferenced,\n     reference::{ModuleReferences, SingleOutputAssetReference},\n };\n \n@@ -55,7 +55,7 @@ impl ManifestAsyncModule {\n     }\n \n     #[turbo_tasks::function]\n-    pub(super) fn chunks(&self) -> Vc<OutputAssets> {\n+    pub(super) fn chunk_group(&self) -> Vc<OutputAssetsWithReferenced> {\n         self.chunking_context.chunk_group_assets(\n             self.inner.ident(),\n             ChunkGroup::Async(ResolvedVc::upcast(self.inner)),\n@@ -65,7 +65,9 @@ impl ManifestAsyncModule {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn manifest_chunks(self: ResolvedVc<Self>) -> Result<Vc<OutputAssets>> {\n+    pub async fn manifest_chunk_group(\n+        self: ResolvedVc<Self>,\n+    ) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let this = self.await?;\n         if let Some(chunk_items) = this.availability_info.available_modules() {\n             let inner_module = ResolvedVc::upcast(this.inner);\n@@ -78,7 +80,11 @@ impl ManifestAsyncModule {\n                 ChunkableModuleOrBatch::from_module_or_batch(module_or_batch)\n                 && *chunk_items.get(chunkable_module_or_batch).await?\n             {\n-                return Ok(Vc::cell(vec![]));\n+                return Ok(OutputAssetsWithReferenced {\n+                    assets: ResolvedVc::cell(vec![]),\n+                    referenced_assets: ResolvedVc::cell(vec![]),\n+                }\n+                .cell());\n             }\n         }\n         Ok(this.chunking_context.chunk_group_assets(\n@@ -119,12 +125,11 @@ impl Module for ManifestAsyncModule {\n \n     #[turbo_tasks::function]\n     async fn references(self: Vc<Self>) -> Result<Vc<ModuleReferences>> {\n-        let chunks = self.chunks();\n+        let assets = self.chunk_group().all_assets().await?;\n \n         Ok(Vc::cell(\n-            chunks\n-                .await?\n-                .iter()\n+            assets\n+                .into_iter()\n                 .copied()\n                 .map(|chunk| async move {\n                     Ok(ResolvedVc::upcast("
        },
        {
            "sha": "1452f1c2c04dbba2dbf9d296165f572a7bd8b303",
            "filename": "turbopack/crates/turbopack-ecmascript/src/manifest/chunk_item.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Fchunk_item.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -33,7 +33,7 @@ impl ManifestChunkItem {\n     async fn chunks_data(&self) -> Result<Vc<ChunksData>> {\n         Ok(ChunkData::from_assets(\n             self.chunking_context.output_root().owned().await?,\n-            self.manifest.chunks(),\n+            *self.manifest.chunk_group().await?.assets,\n         ))\n     }\n }\n@@ -77,8 +77,8 @@ impl ChunkItem for ManifestChunkItem {\n     }\n \n     #[turbo_tasks::function]\n-    async fn references(&self) -> Result<Vc<OutputAssets>> {\n-        Ok(self.manifest.chunks())\n+    fn references(&self) -> Vc<OutputAssets> {\n+        self.manifest.chunk_group().all_assets()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "1911bffb88c2a67d7b409346eeb20b9e48c516e0",
            "filename": "turbopack/crates/turbopack-ecmascript/src/manifest/loader_item.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Floader_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Floader_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fmanifest%2Floader_item.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -67,10 +67,10 @@ impl ManifestLoaderChunkItem {\n \n     #[turbo_tasks::function]\n     pub async fn chunks_data(&self) -> Result<Vc<ChunksData>> {\n-        let chunks = self.manifest.manifest_chunks();\n+        let chunks = self.manifest.manifest_chunk_group().await?.assets;\n         Ok(ChunkData::from_assets(\n             self.chunking_context.output_root().owned().await?,\n-            chunks,\n+            *chunks,\n         ))\n     }\n \n@@ -93,8 +93,8 @@ impl ChunkItem for ManifestLoaderChunkItem {\n     }\n \n     #[turbo_tasks::function]\n-    async fn references(&self) -> Result<Vc<OutputAssets>> {\n-        Ok(self.manifest.manifest_chunks())\n+    fn references(&self) -> Vc<OutputAssets> {\n+        self.manifest.manifest_chunk_group().all_assets()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "919e1e336e46d0695dfe6f4ecb4249cc812e0931",
            "filename": "turbopack/crates/turbopack-ecmascript/src/worker_chunk/chunk_item.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fworker_chunk%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fworker_chunk%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fworker_chunk%2Fchunk_item.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -10,7 +10,7 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::{ModuleGraph, chunk_group_info::ChunkGroup},\n-    output::OutputAssets,\n+    output::{OutputAssets, OutputAssetsWithReferenced},\n };\n \n use super::module::WorkerLoaderModule;\n@@ -33,7 +33,7 @@ pub struct WorkerLoaderChunkItem {\n #[turbo_tasks::value_impl]\n impl WorkerLoaderChunkItem {\n     #[turbo_tasks::function]\n-    async fn chunks(&self) -> Result<Vc<OutputAssets>> {\n+    async fn chunk_group(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n         let module = self.module.await?;\n \n         Ok(self.chunking_context.evaluated_chunk_group_assets(\n@@ -49,7 +49,7 @@ impl WorkerLoaderChunkItem {\n         let this = self.await?;\n         Ok(ChunkData::from_assets(\n             this.chunking_context.output_root().owned().await?,\n-            self.chunks(),\n+            *self.chunk_group().await?.assets,\n         ))\n     }\n }\n@@ -94,7 +94,7 @@ impl ChunkItem for WorkerLoaderChunkItem {\n \n     #[turbo_tasks::function]\n     fn references(self: Vc<Self>) -> Vc<OutputAssets> {\n-        self.chunks()\n+        self.chunk_group().all_assets()\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "f1493dca007c3ed6077d255571dc1d6cea92e34d",
            "filename": "turbopack/crates/turbopack-node/src/evaluate.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -177,6 +177,7 @@ async fn emit_evaluate_pool_assets_operation(\n             .with_entry(*ResolvedVc::try_downcast(entry_module).unwrap()),\n         module_graph,\n         OutputAssets::empty(),\n+        OutputAssets::empty(),\n     );\n \n     let output_root = chunking_context.output_root().owned().await?;"
        },
        {
            "sha": "a60998b22eada505e4b14e23a0e7c271040063ad",
            "filename": "turbopack/crates/turbopack-node/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -280,6 +280,7 @@ pub async fn get_intermediate_asset(\n             false,\n         ),\n         OutputAssets::empty(),\n+        OutputAssets::empty(),\n     ))\n }\n "
        },
        {
            "sha": "fb00a295025901fd2dd0e27f45b8059329225f54",
            "filename": "turbopack/crates/turbopack-nodejs/src/chunking_context.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 10,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fchunking_context.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -388,6 +388,7 @@ impl ChunkingContext for NodeJsChunkingContext {\n             let modules = chunk_group.entries();\n             let MakeChunkGroupResult {\n                 chunks,\n+                referenced_output_assets,\n                 availability_info,\n             } = make_chunk_group(\n                 modules,\n@@ -405,6 +406,7 @@ impl ChunkingContext for NodeJsChunkingContext {\n \n             Ok(ChunkGroupResult {\n                 assets: ResolvedVc::cell(assets),\n+                referenced_assets: ResolvedVc::cell(referenced_output_assets),\n                 availability_info,\n             }\n             .cell())\n@@ -420,6 +422,7 @@ impl ChunkingContext for NodeJsChunkingContext {\n         evaluatable_assets: Vc<EvaluatableAssets>,\n         module_graph: Vc<ModuleGraph>,\n         extra_chunks: Vc<OutputAssets>,\n+        extra_referenced_assets: Vc<OutputAssets>,\n         availability_info: AvailabilityInfo,\n     ) -> Result<Vc<EntryChunkGroupResult>> {\n         let evaluatable_assets_ref = evaluatable_assets.await?;\n@@ -429,6 +432,7 @@ impl ChunkingContext for NodeJsChunkingContext {\n \n         let MakeChunkGroupResult {\n             chunks,\n+            mut referenced_output_assets,\n             availability_info,\n         } = make_chunk_group(\n             entries,\n@@ -439,17 +443,14 @@ impl ChunkingContext for NodeJsChunkingContext {\n         .await?;\n \n         let extra_chunks = extra_chunks.await?;\n-        let other_chunks: Vec<_> = extra_chunks\n+        let mut other_chunks = chunks\n             .iter()\n-            .copied()\n-            .chain(\n-                chunks\n-                    .iter()\n-                    .map(|chunk| self.generate_chunk(**chunk).to_resolved())\n-                    .try_join()\n-                    .await?,\n-            )\n-            .collect();\n+            .map(|chunk| self.generate_chunk(**chunk).to_resolved())\n+            .try_join()\n+            .await?;\n+        other_chunks.extend(extra_chunks.iter().copied());\n+\n+        referenced_output_assets.extend(extra_referenced_assets.await?.iter().copied());\n \n         let Some(module) = ResolvedVc::try_sidecast(*evaluatable_assets_ref.last().unwrap()) else {\n             bail!(\"module must be placeable in an ecmascript chunk\");\n@@ -461,6 +462,7 @@ impl ChunkingContext for NodeJsChunkingContext {\n                 Vc::cell(other_chunks),\n                 evaluatable_assets,\n                 *module,\n+                Vc::cell(referenced_output_assets),\n                 module_graph,\n                 *self,\n             )"
        },
        {
            "sha": "3252c37509aaac427e55bba7be8c58bec755f5ae",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/entry/chunk.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -26,6 +26,7 @@ pub(crate) struct EcmascriptBuildNodeEntryChunk {\n     other_chunks: ResolvedVc<OutputAssets>,\n     evaluatable_assets: ResolvedVc<EvaluatableAssets>,\n     exported_module: ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>,\n+    referenced_output_assets: ResolvedVc<OutputAssets>,\n     module_graph: ResolvedVc<ModuleGraph>,\n     chunking_context: ResolvedVc<NodeJsChunkingContext>,\n }\n@@ -39,6 +40,7 @@ impl EcmascriptBuildNodeEntryChunk {\n         other_chunks: ResolvedVc<OutputAssets>,\n         evaluatable_assets: ResolvedVc<EvaluatableAssets>,\n         exported_module: ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>,\n+        referenced_output_assets: ResolvedVc<OutputAssets>,\n         module_graph: ResolvedVc<ModuleGraph>,\n         chunking_context: ResolvedVc<NodeJsChunkingContext>,\n     ) -> Vc<Self> {\n@@ -47,6 +49,7 @@ impl EcmascriptBuildNodeEntryChunk {\n             other_chunks,\n             evaluatable_assets,\n             exported_module,\n+            referenced_output_assets,\n             module_graph,\n             chunking_context,\n         }\n@@ -191,6 +194,11 @@ impl OutputAsset for EcmascriptBuildNodeEntryChunk {\n         let other_chunks = this.other_chunks.await?;\n         references.extend(other_chunks.iter().copied());\n \n+        let referenced_output_assets = this.referenced_output_assets.await?;\n+        for &referenced_output_asset in &*referenced_output_assets {\n+            references.push(referenced_output_asset);\n+        }\n+\n         Ok(Vc::cell(references))\n     }\n }"
        },
        {
            "sha": "69192bb569813686c5e9960b5ed5b9123d2652c3",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 19,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa57e47f78683fc09fa1955980782e01dbc22dab/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs?ref=fa57e47f78683fc09fa1955980782e01dbc22dab",
            "patch": "@@ -50,7 +50,7 @@ use turbopack_core::{\n         chunk_group_info::{ChunkGroup, ChunkGroupEntry},\n         export_usage::compute_export_usage_info,\n     },\n-    output::{OutputAsset, OutputAssets},\n+    output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n     reference_type::{EntryReferenceSubType, ReferenceType},\n     source::Source,\n };\n@@ -511,28 +511,33 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n             AvailabilityInfo::Root,\n         ),\n         Runtime::NodeJs => {\n-            Vc::cell(vec![\n-                Vc::try_resolve_downcast_type::<NodeJsChunkingContext>(chunking_context)\n-                    .await?\n-                    .unwrap()\n-                    .entry_chunk_group(\n-                        // `expected` expects a completely flat output directory.\n-                        chunk_root_path\n-                            .join(entry_module.ident().path().await?.file_stem().unwrap())?\n-                            .with_extension(\"entry.js\"),\n-                        evaluatable_assets,\n-                        module_graph,\n-                        OutputAssets::empty(),\n-                        AvailabilityInfo::Root,\n-                    )\n-                    .await?\n-                    .asset,\n-            ])\n+            OutputAssetsWithReferenced {\n+                assets: ResolvedVc::cell(vec![\n+                    Vc::try_resolve_downcast_type::<NodeJsChunkingContext>(chunking_context)\n+                        .await?\n+                        .unwrap()\n+                        .entry_chunk_group(\n+                            // `expected` expects a completely flat output directory.\n+                            chunk_root_path\n+                                .join(entry_module.ident().path().await?.file_stem().unwrap())?\n+                                .with_extension(\"entry.js\"),\n+                            evaluatable_assets,\n+                            module_graph,\n+                            OutputAssets::empty(),\n+                            OutputAssets::empty(),\n+                            AvailabilityInfo::Root,\n+                        )\n+                        .await?\n+                        .asset,\n+                ]),\n+                referenced_assets: ResolvedVc::cell(vec![]),\n+            }\n+            .cell()\n         }\n     };\n \n     let mut seen = FxHashSet::default();\n-    let mut queue: VecDeque<_> = chunks.await?.iter().copied().collect();\n+    let mut queue: VecDeque<_> = chunks.all_assets().await?.iter().copied().collect();\n \n     let output_path = project_path.clone();\n     while let Some(asset) = queue.pop_front() {"
        }
    ],
    "stats": {
        "total": 954,
        "additions": 584,
        "deletions": 370
    }
}