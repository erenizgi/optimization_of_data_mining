{
    "author": "sokra",
    "message": "Turbopack: process task result as part of the task completion (#84638)\n\n### What?\n\n* Set the task output when finishing the task\n* Remove setting task as initial dirty in the normal execution\n* Fix race condition when setting output and invalidating dependents",
    "sha": "9864120483fcf26555b7c408cf1aad0ba7b9d1ec",
    "files": [
        {
            "sha": "ab823703f720f0464160354e0ceac3b027b98392",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 153,
            "deletions": 39,
            "changes": 192,
            "blob_url": "https://github.com/vercel/next.js/blob/9864120483fcf26555b7c408cf1aad0ba7b9d1ec/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9864120483fcf26555b7c408cf1aad0ba7b9d1ec/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=9864120483fcf26555b7c408cf1aad0ba7b9d1ec",
            "patch": "@@ -52,7 +52,7 @@ use crate::{\n             AggregatedDataUpdate, AggregationUpdateJob, AggregationUpdateQueue,\n             CleanupOldEdgesOperation, ConnectChildOperation, ExecuteContext, ExecuteContextImpl,\n             Operation, OutdatedEdge, TaskGuard, connect_children, get_aggregation_number,\n-            get_uppers, is_root_node, prepare_new_children,\n+            get_uppers, is_root_node, make_task_dirty_internal, prepare_new_children,\n         },\n         storage::{\n             InnerStorageSnapshot, Storage, count, get, get_many, get_mut, get_mut_or_insert_with,\n@@ -420,6 +420,8 @@ struct TaskExecutionCompletePrepareResult {\n     pub new_children: FxHashSet<TaskId>,\n     pub removed_data: Vec<CachedDataItem>,\n     pub is_now_immutable: bool,\n+    pub new_output: Option<OutputValue>,\n+    pub output_dependent_tasks: SmallVec<[TaskId; 4]>,\n }\n \n // Operations\n@@ -493,16 +495,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     Some(Ok(Err(listen_to_done_event(this, reader, done_event))))\n                 }\n                 Some(InProgressState::InProgress(box InProgressStateInner {\n-                    done,\n-                    done_event,\n-                    ..\n-                })) => {\n-                    if !*done {\n-                        Some(Ok(Err(listen_to_done_event(this, reader, done_event))))\n-                    } else {\n-                        None\n-                    }\n-                }\n+                    done_event, ..\n+                })) => Some(Ok(Err(listen_to_done_event(this, reader, done_event)))),\n                 Some(InProgressState::Canceled) => Some(Err(anyhow::anyhow!(\n                     \"{} was canceled\",\n                     ctx.get_task_description(task.id())\n@@ -1596,7 +1590,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     done_event,\n                     session_dependent: false,\n                     marked_as_completed: false,\n-                    done: false,\n                     new_children: Default::default(),\n                 })),\n             });\n@@ -1695,20 +1688,12 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         Some(TaskExecutionSpec { future, span })\n     }\n \n-    fn task_execution_result(\n-        &self,\n-        task_id: TaskId,\n-        result: Result<RawVc, TurboTasksExecutionError>,\n-        turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n-    ) {\n-        operation::UpdateOutputOperation::run(task_id, result, self.execute_context(turbo_tasks));\n-    }\n-\n     fn task_execution_completed(\n         &self,\n         task_id: TaskId,\n         duration: Duration,\n         _memory_usage: usize,\n+        result: Result<RawVc, TurboTasksExecutionError>,\n         cell_counters: &AutoMap<ValueTypeId, u32, BuildHasherDefault<FxHasher>, 8>,\n         stateful: bool,\n         has_invalidator: bool,\n@@ -1737,10 +1722,13 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             new_children,\n             mut removed_data,\n             is_now_immutable,\n+            new_output,\n+            output_dependent_tasks,\n         }) = self.task_execution_completed_prepare(\n             &mut ctx,\n             &span,\n             task_id,\n+            result,\n             cell_counters,\n             stateful,\n             has_invalidator,\n@@ -1754,7 +1742,20 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         // suspend in `CleanupOldEdgesOperation`), but that's ok as the task is still dirty and\n         // would be executed again.\n \n+        if !output_dependent_tasks.is_empty() {\n+            self.task_execution_completed_invalidate_output_dependent(\n+                &mut ctx,\n+                task_id,\n+                output_dependent_tasks,\n+            );\n+        }\n+\n         let has_new_children = !new_children.is_empty();\n+\n+        if has_new_children {\n+            self.task_execution_completed_unfinished_children_dirty(&mut ctx, &new_children)\n+        }\n+\n         if has_new_children\n             && self.task_execution_completed_connect(&mut ctx, task_id, new_children)\n         {\n@@ -1765,6 +1766,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         if self.task_execution_completed_finish(\n             &mut ctx,\n             task_id,\n+            new_output,\n             &mut removed_data,\n             is_now_immutable,\n         ) {\n@@ -1784,6 +1786,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         ctx: &mut impl ExecuteContext<'_>,\n         span: &Span,\n         task_id: TaskId,\n+        result: Result<RawVc, TurboTasksExecutionError>,\n         cell_counters: &AutoMap<ValueTypeId, u32, BuildHasherDefault<FxHasher>, 8>,\n         stateful: bool,\n         has_invalidator: bool,\n@@ -1797,12 +1800,12 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 new_children: Default::default(),\n                 removed_data: Default::default(),\n                 is_now_immutable: false,\n+                new_output: None,\n+                output_dependent_tasks: Default::default(),\n             });\n         }\n         let &mut InProgressState::InProgress(box InProgressStateInner {\n             stale,\n-            ref mut done,\n-            ref done_event,\n             ref mut new_children,\n             session_dependent,\n             ..\n@@ -1846,12 +1849,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             return None;\n         }\n \n-        if cfg!(not(feature = \"no_fast_stale\")) || !stale {\n-            // mark the task as completed, so dependent tasks can continue working\n-            *done = true;\n-            done_event.notify(usize::MAX);\n-        }\n-\n         // take the children from the task to process them\n         let mut new_children = take(new_children);\n \n@@ -1979,6 +1976,53 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             );\n         }\n \n+        // Check if output need to be updated\n+        let current_output = get!(task, Output);\n+        let new_output = match result {\n+            Ok(RawVc::TaskOutput(output_task_id)) => {\n+                if let Some(OutputValue::Output(current_task_id)) = current_output\n+                    && *current_task_id == output_task_id\n+                {\n+                    None\n+                } else {\n+                    Some(OutputValue::Output(output_task_id))\n+                }\n+            }\n+            Ok(RawVc::TaskCell(output_task_id, cell)) => {\n+                if let Some(OutputValue::Cell(CellRef {\n+                    task: current_task_id,\n+                    cell: current_cell,\n+                })) = current_output\n+                    && *current_task_id == output_task_id\n+                    && *current_cell == cell\n+                {\n+                    None\n+                } else {\n+                    Some(OutputValue::Cell(CellRef {\n+                        task: output_task_id,\n+                        cell,\n+                    }))\n+                }\n+            }\n+            Ok(RawVc::LocalOutput(..)) => {\n+                panic!(\"Non-local tasks must not return a local Vc\");\n+            }\n+            Err(err) => {\n+                if let Some(OutputValue::Error(old_error)) = current_output\n+                    && old_error == &err\n+                {\n+                    None\n+                } else {\n+                    Some(OutputValue::Error(err))\n+                }\n+            }\n+        };\n+        let mut output_dependent_tasks = SmallVec::<[_; 4]>::new();\n+        // When output has changed, grab the dependent tasks\n+        if new_output.is_some() && ctx.should_track_dependencies() {\n+            output_dependent_tasks = get_many!(task, OutputDependent { task } => task);\n+        }\n+\n         drop(task);\n \n         // Check if the task can be marked as immutable\n@@ -2005,9 +2049,76 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             new_children,\n             removed_data,\n             is_now_immutable,\n+            new_output,\n+            output_dependent_tasks,\n         })\n     }\n \n+    fn task_execution_completed_invalidate_output_dependent(\n+        &self,\n+        ctx: &mut impl ExecuteContext<'_>,\n+        task_id: TaskId,\n+        output_dependent_tasks: SmallVec<[TaskId; 4]>,\n+    ) {\n+        debug_assert!(!output_dependent_tasks.is_empty());\n+\n+        let mut queue = AggregationUpdateQueue::new();\n+        for dependent_task_id in output_dependent_tasks {\n+            if ctx.is_once_task(dependent_task_id) {\n+                // once tasks are never invalidated\n+                continue;\n+            }\n+            let dependent = ctx.task(dependent_task_id, TaskDataCategory::All);\n+            if dependent.has_key(&CachedDataItemKey::OutdatedOutputDependency { target: task_id }) {\n+                // output dependency is outdated, so it hasn't read the output yet\n+                // and doesn't need to be invalidated\n+                continue;\n+            }\n+            if !dependent.has_key(&CachedDataItemKey::OutputDependency { target: task_id }) {\n+                // output dependency has been removed, so the task doesn't depend on the\n+                // output anymore and doesn't need to be invalidated\n+                continue;\n+            }\n+            make_task_dirty_internal(\n+                dependent,\n+                dependent_task_id,\n+                true,\n+                #[cfg(feature = \"trace_task_dirty\")]\n+                TaskDirtyCause::OutputChange { task_id },\n+                &mut queue,\n+                ctx,\n+            );\n+        }\n+\n+        queue.execute(ctx);\n+    }\n+\n+    fn task_execution_completed_unfinished_children_dirty(\n+        &self,\n+        ctx: &mut impl ExecuteContext<'_>,\n+        new_children: &FxHashSet<TaskId>,\n+    ) {\n+        debug_assert!(!new_children.is_empty());\n+\n+        let mut queue = AggregationUpdateQueue::new();\n+        for &child_id in new_children {\n+            let child_task = ctx.task(child_id, TaskDataCategory::Meta);\n+            if !child_task.has_key(&CachedDataItemKey::Output {}) {\n+                make_task_dirty_internal(\n+                    child_task,\n+                    child_id,\n+                    false,\n+                    #[cfg(feature = \"trace_task_dirty\")]\n+                    TaskDirtyCause::InitialDirty,\n+                    &mut queue,\n+                    ctx,\n+                );\n+            }\n+        }\n+\n+        queue.execute(ctx);\n+    }\n+\n     fn task_execution_completed_connect(\n         &self,\n         ctx: &mut impl ExecuteContext<'_>,\n@@ -2078,6 +2189,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         &self,\n         ctx: &mut impl ExecuteContext<'_>,\n         task_id: TaskId,\n+        new_output: Option<OutputValue>,\n         removed_data: &mut Vec<CachedDataItem>,\n         is_now_immutable: bool,\n     ) -> bool {\n@@ -2094,7 +2206,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             once_task: _,\n             stale,\n             session_dependent,\n-            done: _,\n             marked_as_completed: _,\n             new_children,\n         }) = in_progress\n@@ -2114,6 +2225,12 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             return true;\n         }\n \n+        // Set the output if it has changed\n+        let mut old_content = None;\n+        if let Some(value) = new_output {\n+            old_content = task.insert(CachedDataItem::Output { value });\n+        }\n+\n         // If the task is not stateful and has no mutable children, it does not have a way to be\n         // invalidated and we can mark it as immutable.\n         if is_now_immutable {\n@@ -2194,6 +2311,10 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         };\n \n         drop(task);\n+        drop(old_content);\n+\n+        // Notify dependent tasks that are waiting for this task to finish\n+        done_event.notify(usize::MAX);\n \n         if let Some(data_update) = data_update {\n             AggregationUpdateQueue::run(data_update, ctx);\n@@ -2981,20 +3102,12 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n         self.0.try_start_task_execution(task_id, turbo_tasks)\n     }\n \n-    fn task_execution_result(\n-        &self,\n-        task_id: TaskId,\n-        result: Result<RawVc, TurboTasksExecutionError>,\n-        turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n-    ) {\n-        self.0.task_execution_result(task_id, result, turbo_tasks);\n-    }\n-\n     fn task_execution_completed(\n         &self,\n         task_id: TaskId,\n         _duration: Duration,\n         _memory_usage: usize,\n+        result: Result<RawVc, TurboTasksExecutionError>,\n         cell_counters: &AutoMap<ValueTypeId, u32, BuildHasherDefault<FxHasher>, 8>,\n         stateful: bool,\n         has_invalidator: bool,\n@@ -3004,6 +3117,7 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n             task_id,\n             _duration,\n             _memory_usage,\n+            result,\n             cell_counters,\n             stateful,\n             has_invalidator,"
        },
        {
            "sha": "135553d0fc61772b89621f0320e48dd909a64d90",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 4,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/9864120483fcf26555b7c408cf1aad0ba7b9d1ec/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9864120483fcf26555b7c408cf1aad0ba7b9d1ec/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=9864120483fcf26555b7c408cf1aad0ba7b9d1ec",
            "patch": "@@ -6,7 +6,6 @@ mod invalidate;\n mod prepare_new_children;\n mod update_cell;\n mod update_collectible;\n-mod update_output;\n \n use std::{\n     fmt::{Debug, Formatter},\n@@ -600,7 +599,6 @@ macro_rules! impl_operation {\n pub enum AnyOperation {\n     ConnectChild(connect_child::ConnectChildOperation),\n     Invalidate(invalidate::InvalidateOperation),\n-    UpdateOutput(update_output::UpdateOutputOperation),\n     UpdateCell(update_cell::UpdateCellOperation),\n     CleanupOldEdges(cleanup_old_edges::CleanupOldEdgesOperation),\n     AggregationUpdate(aggregation_update::AggregationUpdateQueue),\n@@ -612,7 +610,6 @@ impl AnyOperation {\n         match self {\n             AnyOperation::ConnectChild(op) => op.execute(ctx),\n             AnyOperation::Invalidate(op) => op.execute(ctx),\n-            AnyOperation::UpdateOutput(op) => op.execute(ctx),\n             AnyOperation::UpdateCell(op) => op.execute(ctx),\n             AnyOperation::CleanupOldEdges(op) => op.execute(ctx),\n             AnyOperation::AggregationUpdate(op) => op.execute(ctx),\n@@ -627,7 +624,6 @@ impl AnyOperation {\n \n impl_operation!(ConnectChild connect_child::ConnectChildOperation);\n impl_operation!(Invalidate invalidate::InvalidateOperation);\n-impl_operation!(UpdateOutput update_output::UpdateOutputOperation);\n impl_operation!(UpdateCell update_cell::UpdateCellOperation);\n impl_operation!(CleanupOldEdges cleanup_old_edges::CleanupOldEdgesOperation);\n impl_operation!(AggregationUpdate aggregation_update::AggregationUpdateQueue);\n@@ -641,6 +637,7 @@ pub use self::{\n     },\n     cleanup_old_edges::OutdatedEdge,\n     connect_children::connect_children,\n+    invalidate::make_task_dirty_internal,\n     prepare_new_children::prepare_new_children,\n     update_collectible::UpdateCollectibleOperation,\n };"
        },
        {
            "sha": "9aea8f099fc25c99e30a0f6756160b4d0e039c5c",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_output.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 224,
            "changes": 224,
            "blob_url": "https://github.com/vercel/next.js/blob/4ee2f4ad8711401c51e51d0f941b1aeb803b537e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4ee2f4ad8711401c51e51d0f941b1aeb803b537e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs?ref=4ee2f4ad8711401c51e51d0f941b1aeb803b537e",
            "patch": "@@ -1,224 +0,0 @@\n-use std::mem::take;\n-\n-use anyhow::Result;\n-use serde::{Deserialize, Serialize};\n-use smallvec::SmallVec;\n-use turbo_tasks::{RawVc, TaskId, backend::TurboTasksExecutionError};\n-\n-#[cfg(feature = \"trace_task_dirty\")]\n-use crate::backend::operation::invalidate::TaskDirtyCause;\n-use crate::{\n-    backend::{\n-        TaskDataCategory,\n-        operation::{\n-            AggregationUpdateQueue, ExecuteContext, Operation, TaskGuard,\n-            invalidate::make_task_dirty_internal,\n-        },\n-        storage::{get, get_many},\n-    },\n-    data::{\n-        CachedDataItem, CachedDataItemKey, CellRef, InProgressState, InProgressStateInner,\n-        OutputValue,\n-    },\n-};\n-\n-#[derive(Serialize, Deserialize, Clone, Default)]\n-pub enum UpdateOutputOperation {\n-    MakeDependentTasksDirty {\n-        task_id: TaskId,\n-        dependent_tasks: SmallVec<[TaskId; 4]>,\n-        children: SmallVec<[TaskId; 4]>,\n-        queue: AggregationUpdateQueue,\n-    },\n-    EnsureUnfinishedChildrenDirty {\n-        children: SmallVec<[TaskId; 4]>,\n-        queue: AggregationUpdateQueue,\n-    },\n-    AggregationUpdate {\n-        queue: AggregationUpdateQueue,\n-    },\n-    #[default]\n-    Done,\n-}\n-\n-impl UpdateOutputOperation {\n-    pub fn run(\n-        task_id: TaskId,\n-        output: Result<RawVc, TurboTasksExecutionError>,\n-        mut ctx: impl ExecuteContext<'_>,\n-    ) {\n-        let mut dependent_tasks = Default::default();\n-        let mut children = Default::default();\n-        let mut queue = AggregationUpdateQueue::new();\n-\n-        'output: {\n-            let mut task = ctx.task(task_id, TaskDataCategory::All);\n-            let in_progress_state = get!(task, InProgress);\n-            if matches!(in_progress_state, Some(InProgressState::Canceled)) {\n-                // Skip updating the output when the task was canceled\n-                break 'output;\n-            }\n-            let Some(InProgressState::InProgress(box InProgressStateInner {\n-                stale,\n-                new_children,\n-                ..\n-            })) = in_progress_state\n-            else {\n-                panic!(\"Task is not in progress while updating the output\");\n-            };\n-            if *stale {\n-                // Skip updating the output when the task is stale\n-                break 'output;\n-            }\n-            children = new_children.iter().copied().collect();\n-\n-            let current_output = get!(task, Output);\n-            let output_value = match output {\n-                Ok(RawVc::TaskOutput(output_task_id)) => {\n-                    if let Some(OutputValue::Output(current_task_id)) = current_output\n-                        && *current_task_id == output_task_id\n-                    {\n-                        break 'output;\n-                    }\n-                    OutputValue::Output(output_task_id)\n-                }\n-                Ok(RawVc::TaskCell(output_task_id, cell)) => {\n-                    if let Some(OutputValue::Cell(CellRef {\n-                        task: current_task_id,\n-                        cell: current_cell,\n-                    })) = current_output\n-                        && *current_task_id == output_task_id\n-                        && *current_cell == cell\n-                    {\n-                        break 'output;\n-                    }\n-                    OutputValue::Cell(CellRef {\n-                        task: output_task_id,\n-                        cell,\n-                    })\n-                }\n-                Ok(RawVc::LocalOutput(..)) => {\n-                    panic!(\"Non-local tasks must not return a local Vc\");\n-                }\n-                Err(err) => {\n-                    if let Some(OutputValue::Error(old_error)) = current_output\n-                        && old_error == &err\n-                    {\n-                        break 'output;\n-                    }\n-                    OutputValue::Error(err)\n-                }\n-            };\n-            let old_content = task.insert(CachedDataItem::Output {\n-                value: output_value,\n-            });\n-\n-            if ctx.should_track_dependencies() {\n-                dependent_tasks = get_many!(task, OutputDependent { task } => task);\n-            }\n-\n-            make_task_dirty_internal(\n-                task,\n-                task_id,\n-                false,\n-                #[cfg(feature = \"trace_task_dirty\")]\n-                TaskDirtyCause::InitialDirty,\n-                &mut queue,\n-                &mut ctx,\n-            );\n-\n-            drop(old_content);\n-        }\n-\n-        UpdateOutputOperation::MakeDependentTasksDirty {\n-            task_id,\n-            dependent_tasks,\n-            children,\n-            queue,\n-        }\n-        .execute(&mut ctx);\n-    }\n-}\n-\n-impl Operation for UpdateOutputOperation {\n-    fn execute(mut self, ctx: &mut impl ExecuteContext) {\n-        loop {\n-            ctx.operation_suspend_point(&self);\n-            match self {\n-                UpdateOutputOperation::MakeDependentTasksDirty {\n-                    task_id,\n-                    ref mut dependent_tasks,\n-                    ref mut children,\n-                    ref mut queue,\n-                } => {\n-                    if let Some(dependent_task_id) = dependent_tasks.pop() {\n-                        if ctx.is_once_task(dependent_task_id) {\n-                            // once tasks are never invalidated\n-                            continue;\n-                        }\n-                        let dependent = ctx.task(dependent_task_id, TaskDataCategory::All);\n-                        if dependent.has_key(&CachedDataItemKey::OutdatedOutputDependency {\n-                            target: task_id,\n-                        }) {\n-                            // output dependency is outdated, so it hasn't read the output yet\n-                            // and doesn't need to be invalidated\n-                            continue;\n-                        }\n-                        if !dependent\n-                            .has_key(&CachedDataItemKey::OutputDependency { target: task_id })\n-                        {\n-                            // output dependency has been removed, so the task doesn't depend on the\n-                            // output anymore and doesn't need to be invalidated\n-                            continue;\n-                        }\n-                        make_task_dirty_internal(\n-                            dependent,\n-                            dependent_task_id,\n-                            true,\n-                            #[cfg(feature = \"trace_task_dirty\")]\n-                            TaskDirtyCause::OutputChange { task_id },\n-                            queue,\n-                            ctx,\n-                        );\n-                    }\n-                    if dependent_tasks.is_empty() {\n-                        self = UpdateOutputOperation::EnsureUnfinishedChildrenDirty {\n-                            children: take(children),\n-                            queue: take(queue),\n-                        };\n-                    }\n-                }\n-                UpdateOutputOperation::EnsureUnfinishedChildrenDirty {\n-                    ref mut children,\n-                    ref mut queue,\n-                } => {\n-                    if let Some(child_id) = children.pop() {\n-                        let child_task = ctx.task(child_id, TaskDataCategory::Meta);\n-                        if !child_task.has_key(&CachedDataItemKey::Output {}) {\n-                            make_task_dirty_internal(\n-                                child_task,\n-                                child_id,\n-                                false,\n-                                #[cfg(feature = \"trace_task_dirty\")]\n-                                TaskDirtyCause::InitialDirty,\n-                                queue,\n-                                ctx,\n-                            );\n-                        }\n-                    }\n-                    if children.is_empty() {\n-                        self = UpdateOutputOperation::AggregationUpdate { queue: take(queue) };\n-                    }\n-                }\n-                UpdateOutputOperation::AggregationUpdate { ref mut queue } => {\n-                    if queue.process(ctx) {\n-                        self = UpdateOutputOperation::Done;\n-                    }\n-                }\n-                UpdateOutputOperation::Done => {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-}"
        },
        {
            "sha": "2afaab53df28006b609ea4b8b7ca2420f908a562",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/9864120483fcf26555b7c408cf1aad0ba7b9d1ec/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9864120483fcf26555b7c408cf1aad0ba7b9d1ec/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs?ref=9864120483fcf26555b7c408cf1aad0ba7b9d1ec",
            "patch": "@@ -499,8 +499,6 @@ pub struct InProgressStateInner {\n     /// Early marking as completed. This is set before the output is available and will ignore full\n     /// task completion of the task for strongly consistent reads.\n     pub marked_as_completed: bool,\n-    /// Task execution has completed and the output is available.\n-    pub done: bool,\n     /// Event that is triggered when the task output is available (completed flag set).\n     /// This is used to wait for completion when reading the task output before it's available.\n     pub done_event: Event,"
        },
        {
            "sha": "018fc1c579b90688510d9d145b09b69b5acadc70",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 7,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/9864120483fcf26555b7c408cf1aad0ba7b9d1ec/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9864120483fcf26555b7c408cf1aad0ba7b9d1ec/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=9864120483fcf26555b7c408cf1aad0ba7b9d1ec",
            "patch": "@@ -538,18 +538,12 @@ pub trait Backend: Sync + Send {\n \n     fn task_execution_canceled(&self, task: TaskId, turbo_tasks: &dyn TurboTasksBackendApi<Self>);\n \n-    fn task_execution_result(\n-        &self,\n-        task_id: TaskId,\n-        result: Result<RawVc, TurboTasksExecutionError>,\n-        turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n-    );\n-\n     fn task_execution_completed(\n         &self,\n         task: TaskId,\n         duration: Duration,\n         memory_usage: usize,\n+        result: Result<RawVc, TurboTasksExecutionError>,\n         cell_counters: &AutoMap<ValueTypeId, u32, BuildHasherDefault<FxHasher>, 8>,\n         stateful: bool,\n         has_invalidator: bool,"
        },
        {
            "sha": "9ac93282ccc616f9a78d7c66542468b30768ecc6",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/9864120483fcf26555b7c408cf1aad0ba7b9d1ec/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9864120483fcf26555b7c408cf1aad0ba7b9d1ec/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=9864120483fcf26555b7c408cf1aad0ba7b9d1ec",
            "patch": "@@ -722,7 +722,6 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                             Err(err) => Err(TurboTasksExecutionError::Panic(Arc::new(err))),\n                         };\n \n-                        this.backend.task_execution_result(task_id, result, &*this);\n                         let FinishedTaskState {\n                             stateful,\n                             has_invalidator,\n@@ -733,6 +732,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                             task_id,\n                             duration,\n                             alloc_info.memory_usage(),\n+                            result,\n                             &cell_counters,\n                             stateful,\n                             has_invalidator,"
        }
    ],
    "stats": {
        "total": 433,
        "additions": 156,
        "deletions": 277
    }
}