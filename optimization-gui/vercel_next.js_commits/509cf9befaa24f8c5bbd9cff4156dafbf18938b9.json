{
    "author": "Cy-Tek",
    "message": "feat(turbopack): Add basic compilation event support (#78785)\n\n## Implement Compilation Events System for Turbopack\n\nThis PR adds a compilation events system to Turbopack that allows sending and subscribing to events during compilation. The system enables better communication of important information to users, such as filesystem performance warnings.\n\n### What?\n\n- Added a `CompilationEvent` trait in Turbo Tasks to standardize event messaging\n- Implemented a broadcast-based event queue for distributing events to subscribers\n- Created specific event types for diagnostics and slow filesystem detection\n- Added JavaScript bindings to expose events to the Next.js frontend\n\n### How?\n\n- Created a new `message_queue.rs` module in turbo-tasks to handle event broadcasting\n- Added methods to the TurboTasks manager to send and subscribe to compilation events\n- Enhanced the filesystem benchmark to send detailed performance warnings through the new event system",
    "sha": "509cf9befaa24f8c5bbd9cff4156dafbf18938b9",
    "files": [
        {
            "sha": "a72b1715f4df1d548f3446764b00f60ab95f0824",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 92,
            "deletions": 6,
            "changes": 98,
            "blob_url": "https://github.com/vercel/next.js/blob/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=509cf9befaa24f8c5bbd9cff4156dafbf18938b9",
            "patch": "@@ -31,6 +31,7 @@ use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     Completion, Effects, FxIndexSet, OperationVc, ReadRef, ResolvedVc, TransientInstance,\n     TryJoinIterExt, UpdateInfo, Vc, get_effects,\n+    message_queue::{CompilationEvent, DiagnosticEvent, Severity},\n };\n use turbo_tasks_fs::{\n     DiskFileSystem, FileContent, FileSystem, FileSystemPath, get_relative_path_to,\n@@ -402,6 +403,12 @@ pub async fn project_new(\n         memory_limit,\n         dependency_tracking,\n     )?;\n+\n+    turbo_tasks.send_compilation_event(Arc::new(DiagnosticEvent::new(\n+        \"Starting the compilation events server...\".to_owned(),\n+        Severity::Trace,\n+    )));\n+\n     let stats_path = std::env::var_os(\"NEXT_TURBOPACK_TASK_STATISTICS\");\n     if let Some(stats_path) = stats_path {\n         let task_stats = turbo_tasks.task_statistics().enable().clone();\n@@ -429,8 +436,9 @@ pub async fn project_new(\n         .await\n         .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e).to_string()))?;\n \n+    let tasks_ref = turbo_tasks.clone();\n     turbo_tasks.spawn_once_task(async move {\n-        benchmark_file_io(container.project().node_root())\n+        benchmark_file_io(tasks_ref, container.project().node_root())\n             .await\n             .inspect_err(|err| tracing::warn!(%err, \"failed to benchmark file IO\"))\n     });\n@@ -444,15 +452,47 @@ pub async fn project_new(\n     ))\n }\n \n+#[derive(Debug, Clone, serde::Serialize)]\n+struct SlowFilesystemEvent {\n+    directory: String,\n+    duration_ms: u128,\n+}\n+\n+impl CompilationEvent for SlowFilesystemEvent {\n+    fn type_name(&self) -> &'static str {\n+        \"SlowFilesystemEvent\"\n+    }\n+\n+    fn severity(&self) -> Severity {\n+        Severity::Warning\n+    }\n+\n+    fn message(&self) -> String {\n+        format!(\n+            \"Slow filesystem detected. The benchmark took {}ms. If {} is a network drive, \\\n+             consider moving it to a local folder. If you have an antivirus enabled, consider \\\n+             excluding your project directory.\",\n+            self.duration_ms, self.directory\n+        )\n+    }\n+\n+    fn to_json(&self) -> String {\n+        serde_json::to_string(self).unwrap()\n+    }\n+}\n+\n /// A very simple and low-overhead, but potentially noisy benchmark to detect\n /// very slow disk IO. Warns the user (via `println!`) if the benchmark takes\n /// more than `SLOW_FILESYSTEM_THRESHOLD`.\n ///\n /// This idea is copied from Bun:\n /// - https://x.com/jarredsumner/status/1637549427677364224\n /// - https://github.com/oven-sh/bun/blob/06a9aa80c38b08b3148bfeabe560/src/install/install.zig#L3038\n-#[tracing::instrument]\n-async fn benchmark_file_io(directory: Vc<FileSystemPath>) -> Result<Vc<Completion>> {\n+#[tracing::instrument(skip(turbo_tasks))]\n+async fn benchmark_file_io(\n+    turbo_tasks: NextTurboTasks,\n+    directory: Vc<FileSystemPath>,\n+) -> Result<Vc<Completion>> {\n     // try to get the real file path on disk so that we can use it with tokio\n     let fs = Vc::try_resolve_downcast_type::<DiskFileSystem>(directory.fs())\n         .await?\n@@ -490,12 +530,20 @@ async fn benchmark_file_io(directory: Vc<FileSystemPath>) -> Result<Vc<Completio\n     .instrument(tracing::info_span!(\"benchmark file IO (measurement)\"))\n     .await?;\n \n-    if Instant::now().duration_since(start) > SLOW_FILESYSTEM_THRESHOLD {\n+    let duration = Instant::now().duration_since(start);\n+    if duration > SLOW_FILESYSTEM_THRESHOLD {\n         println!(\n-            \"Slow filesystem detected. If {} is a network drive, consider moving it to a local \\\n-             folder. If you have an antivirus enabled, consider excluding your project directory.\",\n+            \"Slow filesystem detected. The benchmark took {}ms. If {} is a network drive, \\\n+             consider moving it to a local folder. If you have an antivirus enabled, consider \\\n+             excluding your project directory.\",\n+            duration.as_millis(),\n             directory.to_string_lossy(),\n         );\n+\n+        turbo_tasks.send_compilation_event(Arc::new(SlowFilesystemEvent {\n+            directory: directory.to_string_lossy().into(),\n+            duration_ms: duration.as_millis(),\n+        }));\n     }\n \n     Ok(Completion::new())\n@@ -1221,6 +1269,44 @@ pub fn project_update_info_subscribe(\n     Ok(())\n }\n \n+/// Subscribes to all compilation events that are not cached like timing and progress information.\n+#[napi]\n+pub fn project_compilation_events_subscribe(\n+    #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n+    func: JsFunction,\n+    event_types: Option<Vec<String>>,\n+) -> napi::Result<()> {\n+    let turbo_tasks = project.turbo_tasks.clone();\n+    let tsfn: ThreadsafeFunction<Arc<dyn CompilationEvent>> =\n+        func.create_threadsafe_function(0, |ctx| {\n+            let event: Arc<dyn CompilationEvent> = ctx.value;\n+\n+            let env = ctx.env;\n+            let mut obj = env.create_object()?;\n+            obj.set_named_property(\"typeName\", event.type_name())?;\n+            obj.set_named_property(\"severity\", event.severity().to_string())?;\n+            obj.set_named_property(\"message\", event.message())?;\n+\n+            let external = env.create_external(event, None);\n+            obj.set_named_property(\"eventData\", external)?;\n+\n+            Ok(vec![obj])\n+        })?;\n+\n+    tokio::spawn(async move {\n+        let mut receiver = turbo_tasks.get_compilation_events_stream(event_types);\n+        while let Some(msg) = receiver.recv().await {\n+            let status = tsfn.call(Ok(msg), ThreadsafeFunctionCallMode::Blocking);\n+\n+            if status != Status::Ok {\n+                break;\n+            }\n+        }\n+    });\n+\n+    Ok(())\n+}\n+\n #[turbo_tasks::value]\n #[derive(Debug)]\n #[napi(object)]"
        },
        {
            "sha": "ee3021fdb676e753f9bf36df511087fb8aeb248d",
            "filename": "crates/napi/src/next_api/utils.rs",
            "status": "modified",
            "additions": 26,
            "deletions": 1,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Futils.rs?ref=509cf9befaa24f8c5bbd9cff4156dafbf18938b9",
            "patch": "@@ -8,9 +8,11 @@ use napi::{\n };\n use rustc_hash::FxHashMap;\n use serde::Serialize;\n+use tokio::sync::mpsc::Receiver;\n use turbo_tasks::{\n     Effects, OperationVc, ReadRef, TaskId, TryJoinIterExt, TurboTasks, TurboTasksApi, UpdateInfo,\n-    Vc, VcValueType, get_effects, task_statistics::TaskStatisticsApi, trace::TraceRawVcs,\n+    Vc, VcValueType, get_effects, message_queue::CompilationEvent,\n+    task_statistics::TaskStatisticsApi, trace::TraceRawVcs,\n };\n use turbo_tasks_backend::{\n     DefaultBackingStorage, GitVersionInfo, NoopBackingStorage, default_backing_storage,\n@@ -124,6 +126,29 @@ impl NextTurboTasks {\n             NextTurboTasks::PersistentCaching(turbo_tasks) => turbo_tasks.task_statistics(),\n         }\n     }\n+\n+    pub fn get_compilation_events_stream(\n+        &self,\n+        event_types: Option<Vec<String>>,\n+    ) -> Receiver<Arc<dyn CompilationEvent>> {\n+        match self {\n+            NextTurboTasks::Memory(turbo_tasks) => {\n+                turbo_tasks.subscribe_to_compilation_events(event_types)\n+            }\n+            NextTurboTasks::PersistentCaching(turbo_tasks) => {\n+                turbo_tasks.subscribe_to_compilation_events(event_types)\n+            }\n+        }\n+    }\n+\n+    pub fn send_compilation_event(&self, event: Arc<dyn CompilationEvent>) {\n+        match self {\n+            NextTurboTasks::Memory(turbo_tasks) => turbo_tasks.send_compilation_event(event),\n+            NextTurboTasks::PersistentCaching(turbo_tasks) => {\n+                turbo_tasks.send_compilation_event(event)\n+            }\n+        }\n+    }\n }\n \n pub fn create_turbo_tasks("
        },
        {
            "sha": "772bc7433a9a0a93de14781610ac8de6a2b907c5",
            "filename": "packages/next/src/build/swc/generated-native.d.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts?ref=509cf9befaa24f8c5bbd9cff4156dafbf18938b9",
            "patch": "@@ -300,6 +300,12 @@ export declare function projectUpdateInfoSubscribe(\n   aggregationMs: number,\n   func: (...args: any[]) => any\n ): void\n+/** Subscribes to all compilation events that are not cached like timing and progress information. */\n+export declare function projectCompilationEventsSubscribe(\n+  project: { __napiType: 'Project' },\n+  func: (...args: any[]) => any,\n+  eventTypes?: Array<string> | undefined | null\n+): void\n export interface StackFrame {\n   isServer: boolean\n   isInternal?: boolean"
        },
        {
            "sha": "2662b247058ee8c6cfccc821cfaf076c64dea678",
            "filename": "packages/next/src/build/swc/index.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts?ref=509cf9befaa24f8c5bbd9cff4156dafbf18938b9",
            "patch": "@@ -27,6 +27,7 @@ import type {\n } from './generated-native'\n import type {\n   Binding,\n+  CompilationEvent,\n   DefineEnv,\n   Endpoint,\n   HmrIdentifiers,\n@@ -712,6 +713,18 @@ function bindingToApi(\n       )\n     }\n \n+    compilationEventsSubscribe() {\n+      return subscribe<TurbopackResult<CompilationEvent>>(\n+        true,\n+        async (callback) => {\n+          binding.projectCompilationEventsSubscribe(\n+            this._nativeProject,\n+            callback\n+          )\n+        }\n+      )\n+    }\n+\n     shutdown(): Promise<void> {\n       return binding.projectShutdown(this._nativeProject)\n     }"
        },
        {
            "sha": "65233a7aecbdc90d1088959f6328e19fbbef552f",
            "filename": "packages/next/src/build/swc/types.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Ftypes.ts?ref=509cf9befaa24f8c5bbd9cff4156dafbf18938b9",
            "patch": "@@ -182,6 +182,13 @@ export type UpdateMessage =\n       value: UpdateInfo\n     }\n \n+export type CompilationEvent = {\n+  typeName: string\n+  message: string\n+  severity: string\n+  eventData: any\n+}\n+\n export interface UpdateInfo {\n   duration: number\n   tasks: number\n@@ -216,6 +223,10 @@ export interface Project {\n     aggregationMs: number\n   ): AsyncIterableIterator<TurbopackResult<UpdateMessage>>\n \n+  compilationEventsSubscribe(): AsyncIterableIterator<\n+    TurbopackResult<CompilationEvent>\n+  >\n+\n   shutdown(): Promise<void>\n \n   onExit(): Promise<void>"
        },
        {
            "sha": "f6c8cee73a0aaa6de0c5140794eb6eab59c6948f",
            "filename": "turbopack/crates/turbo-tasks-testing/src/lib.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs?ref=509cf9befaa24f8c5bbd9cff4156dafbf18938b9",
            "patch": "@@ -14,11 +14,13 @@ use std::{\n use anyhow::{Result, anyhow};\n use futures::FutureExt;\n use rustc_hash::FxHashMap;\n+use tokio::sync::mpsc::Receiver;\n use turbo_tasks::{\n     CellId, ExecutionId, InvalidationReason, LocalTaskId, MagicAny, RawVc, ReadCellOptions,\n     ReadConsistency, TaskId, TaskPersistence, TraitTypeId, TurboTasksApi, TurboTasksCallApi,\n     backend::{CellContent, TaskCollectiblesMap, TypedCellContent},\n     event::{Event, EventListener},\n+    message_queue::CompilationEvent,\n     registry,\n     test_helpers::with_turbo_tasks_for_testing,\n     util::{SharedError, StaticOrArc},\n@@ -314,6 +316,21 @@ impl TurboTasksApi for VcStorage {\n     fn stop_and_wait(&self) -> std::pin::Pin<Box<dyn Future<Output = ()> + Send + 'static>> {\n         Box::pin(async {})\n     }\n+\n+    /// Should not be called on the testing VcStorage. These methods are only implemented for\n+    /// structs with access to a `MessageQueue` like `TurboTasks`.\n+    fn subscribe_to_compilation_events(\n+        &self,\n+        _event_types: Option<Vec<String>>,\n+    ) -> Receiver<Arc<dyn CompilationEvent>> {\n+        unimplemented!()\n+    }\n+\n+    /// Should not be called on the testing VcStorage. These methods are only implemented for\n+    /// structs with access to a `MessageQueue` like `TurboTasks`.\n+    fn send_compilation_event(&self, _event: Arc<dyn CompilationEvent>) {\n+        unimplemented!()\n+    }\n }\n \n impl VcStorage {"
        },
        {
            "sha": "da58de2473216add2df9f5b8c11aa14505f9f086",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=509cf9befaa24f8c5bbd9cff4156dafbf18938b9",
            "patch": "@@ -59,6 +59,7 @@ pub mod macro_helpers;\n mod magic_any;\n mod manager;\n mod marker_trait;\n+pub mod message_queue;\n mod native_function;\n mod no_move_vec;\n mod once_map;"
        },
        {
            "sha": "8fbb3e33a576d5de52c4fa2baef1cf5f14daa435",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 1,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=509cf9befaa24f8c5bbd9cff4156dafbf18938b9",
            "patch": "@@ -17,7 +17,7 @@ use anyhow::{Result, anyhow};\n use auto_hash_map::AutoMap;\n use rustc_hash::FxHasher;\n use serde::{Deserialize, Serialize};\n-use tokio::{runtime::Handle, select, task_local};\n+use tokio::{runtime::Handle, select, sync::mpsc::Receiver, task_local};\n use tokio_util::task::TaskTracker;\n use tracing::{Instrument, Level, Span, info_span, instrument, trace_span};\n use turbo_tasks_malloc::TurboMalloc;\n@@ -35,6 +35,7 @@ use crate::{\n     id::{BackendJobId, ExecutionId, FunctionId, LocalTaskId, TRANSIENT_TASK_BIT, TraitTypeId},\n     id_factory::IdFactoryWithReuse,\n     magic_any::MagicAny,\n+    message_queue::{CompilationEvent, CompilationEventQueue},\n     raw_vc::{CellId, RawVc},\n     registry,\n     serialization_invalidation::SerializationInvalidator,\n@@ -200,6 +201,12 @@ pub trait TurboTasksApi: TurboTasksCallApi + Sync + Send {\n     fn task_statistics(&self) -> &TaskStatisticsApi;\n \n     fn stop_and_wait(&self) -> Pin<Box<dyn Future<Output = ()> + Send>>;\n+\n+    fn subscribe_to_compilation_events(\n+        &self,\n+        event_types: Option<Vec<String>>,\n+    ) -> Receiver<Arc<dyn CompilationEvent>>;\n+    fn send_compilation_event(&self, event: Arc<dyn CompilationEvent>);\n }\n \n /// A wrapper around a value that is unused.\n@@ -378,6 +385,7 @@ pub struct TurboTasks<B: Backend + 'static> {\n     event_foreground: Event,\n     event_background: Event,\n     program_start: Instant,\n+    compilation_events: CompilationEventQueue,\n }\n \n /// Information about a non-local task. A non-local task can contain multiple \"local\" tasks, which\n@@ -503,6 +511,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n             event_foreground: Event::new(|| \"TurboTasks::event_foreground\".to_string()),\n             event_background: Event::new(|| \"TurboTasks::event_background\".to_string()),\n             program_start: Instant::now(),\n+            compilation_events: CompilationEventQueue::default(),\n         });\n         this.backend.startup(&*this);\n         this\n@@ -1449,6 +1458,19 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n             this.stop_and_wait().await;\n         })\n     }\n+\n+    fn subscribe_to_compilation_events(\n+        &self,\n+        event_types: Option<Vec<String>>,\n+    ) -> Receiver<Arc<dyn CompilationEvent>> {\n+        self.compilation_events.subscribe(event_types)\n+    }\n+\n+    fn send_compilation_event(&self, event: Arc<dyn CompilationEvent>) {\n+        if let Err(e) = self.compilation_events.send(event) {\n+            tracing::warn!(\"Failed to send compilation event: {e}\");\n+        }\n+    }\n }\n \n impl<B: Backend + 'static> TurboTasksBackendApi<B> for TurboTasks<B> {"
        },
        {
            "sha": "6f2d414c2889a642c2cc8f518513022d5f5be489",
            "filename": "turbopack/crates/turbo-tasks/src/message_queue.rs",
            "status": "added",
            "additions": 170,
            "deletions": 0,
            "changes": 170,
            "blob_url": "https://github.com/vercel/next.js/blob/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmessage_queue.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmessage_queue.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmessage_queue.rs?ref=509cf9befaa24f8c5bbd9cff4156dafbf18938b9",
            "patch": "@@ -0,0 +1,170 @@\n+use std::{any::Any, collections::VecDeque, fmt::Display, sync::Arc};\n+\n+use dashmap::DashMap;\n+use tokio::sync::{Mutex, mpsc};\n+\n+pub trait CompilationEvent: Sync + Send + Any {\n+    fn type_name(&self) -> &'static str;\n+    fn severity(&self) -> Severity;\n+    fn message(&self) -> String;\n+    fn to_json(&self) -> String;\n+}\n+\n+const MAX_QUEUE_SIZE: usize = 256;\n+\n+type ArcMx<T> = Arc<Mutex<T>>;\n+type CompilationEventChannel = mpsc::Sender<Arc<dyn CompilationEvent>>;\n+\n+pub struct CompilationEventQueue {\n+    event_history: ArcMx<VecDeque<Arc<dyn CompilationEvent>>>,\n+    subscribers: DashMap<String, Vec<CompilationEventChannel>>,\n+}\n+\n+impl Default for CompilationEventQueue {\n+    fn default() -> Self {\n+        let subscribers = DashMap::new();\n+        subscribers.insert(\"*\".to_owned(), Vec::<CompilationEventChannel>::new());\n+\n+        Self {\n+            event_history: Arc::new(Mutex::new(VecDeque::with_capacity(MAX_QUEUE_SIZE))),\n+            subscribers,\n+        }\n+    }\n+}\n+\n+impl CompilationEventQueue {\n+    pub fn send(\n+        &self,\n+        message: Arc<dyn CompilationEvent>,\n+    ) -> Result<(), mpsc::error::SendError<Arc<dyn CompilationEvent>>> {\n+        let event_history = self.event_history.clone();\n+        let subscribers = self.subscribers.clone();\n+        let message_clone = message.clone();\n+\n+        // Spawn a task to handle the async operations\n+        tokio::spawn(async move {\n+            // Store the message in history\n+            let mut history = event_history.lock().await;\n+            if history.len() >= MAX_QUEUE_SIZE {\n+                history.pop_front();\n+            }\n+            history.push_back(message_clone.clone());\n+\n+            // Send to all active receivers of the same message type\n+            if let Some(mut type_subscribers) = subscribers.get_mut(message_clone.type_name()) {\n+                let mut removal_indices = Vec::new();\n+                for (ix, sender) in type_subscribers.iter().enumerate() {\n+                    if sender.send(message_clone.clone()).await.is_err() {\n+                        removal_indices.push(ix);\n+                    }\n+                }\n+\n+                for ix in removal_indices.iter().rev() {\n+                    type_subscribers.remove(*ix);\n+                }\n+            }\n+\n+            // Send to all global message subscribers\n+            let mut all_channel = subscribers.get_mut(\"*\").unwrap();\n+            let mut removal_indices = Vec::new();\n+            for (ix, sender) in all_channel.iter_mut().enumerate() {\n+                if sender.send(message_clone.clone()).await.is_err() {\n+                    removal_indices.push(ix);\n+                }\n+            }\n+\n+            for ix in removal_indices.iter().rev() {\n+                all_channel.remove(*ix);\n+            }\n+        });\n+\n+        Ok(())\n+    }\n+\n+    pub fn subscribe(\n+        &self,\n+        event_types: Option<Vec<String>>,\n+    ) -> mpsc::Receiver<Arc<dyn CompilationEvent>> {\n+        let (tx, rx) = mpsc::channel(MAX_QUEUE_SIZE);\n+        let subscribers = self.subscribers.clone();\n+        let event_history = self.event_history.clone();\n+        let tx_clone = tx.clone();\n+\n+        // Spawn a task to handle the async operations\n+        tokio::spawn(async move {\n+            // Store the sender\n+            if let Some(event_types) = event_types {\n+                for event_type in event_types.iter() {\n+                    let mut type_subscribers = subscribers.entry(event_type.clone()).or_default();\n+                    type_subscribers.push(tx_clone.clone());\n+                }\n+\n+                for event in event_history.lock().await.iter() {\n+                    if event_types.contains(&event.type_name().to_string()) {\n+                        let _ = tx_clone.send(event.clone()).await;\n+                    }\n+                }\n+            } else {\n+                let mut global_subscribers = subscribers.entry(\"*\".to_string()).or_default();\n+                global_subscribers.push(tx_clone.clone());\n+\n+                for event in event_history.lock().await.iter() {\n+                    let _ = tx_clone.send(event.clone()).await;\n+                }\n+            }\n+        });\n+\n+        rx\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash, serde::Serialize, serde::Deserialize)]\n+pub enum Severity {\n+    Info,\n+    Trace,\n+    Warning,\n+    Error,\n+    Fatal,\n+}\n+\n+impl Display for Severity {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            Severity::Info => write!(f, \"INFO\"),\n+            Severity::Trace => write!(f, \"TRACE\"),\n+            Severity::Warning => write!(f, \"WARNING\"),\n+            Severity::Error => write!(f, \"ERROR\"),\n+            Severity::Fatal => write!(f, \"FATAL\"),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\n+pub struct DiagnosticEvent {\n+    pub message: String,\n+    pub severity: Severity,\n+}\n+\n+impl DiagnosticEvent {\n+    pub fn new(message: String, severity: Severity) -> Self {\n+        Self { message, severity }\n+    }\n+}\n+\n+impl CompilationEvent for DiagnosticEvent {\n+    fn type_name(&self) -> &'static str {\n+        \"DiagnosticEvent\"\n+    }\n+\n+    fn severity(&self) -> Severity {\n+        self.severity\n+    }\n+\n+    fn message(&self) -> String {\n+        self.message.clone()\n+    }\n+\n+    fn to_json(&self) -> String {\n+        serde_json::to_string(self).unwrap()\n+    }\n+}"
        },
        {
            "sha": "36f1894576f16fe4f45f188694aa3fb688a69249",
            "filename": "turbopack/crates/turbopack-ecmascript/src/parse.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/509cf9befaa24f8c5bbd9cff4156dafbf18938b9/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs?ref=509cf9befaa24f8c5bbd9cff4156dafbf18938b9",
            "patch": "@@ -174,6 +174,7 @@ pub async fn parse(\n ) -> Result<Vc<ParseResult>> {\n     let name = source.ident().to_string().await?.to_string();\n     let span = tracing::info_span!(\"parse ecmascript\", name = name, ty = display(&*ty));\n+\n     match parse_internal(source, ty, transforms)\n         .instrument(span)\n         .await\n@@ -428,8 +429,8 @@ async fn parse_file_content(\n                 }\n                 anyhow::Ok(())\n             }\n-            .instrument(span)\n-            .await?;\n+                .instrument(span)\n+                .await?;\n \n             if parser_handler.has_errors() {\n                 let messages = if let Some(error) = collector_parse.last_emitted_issue() {\n@@ -476,7 +477,7 @@ async fn parse_file_content(\n             })\n         },\n     )\n-    .await?;\n+        .await?;\n     if let ParseResult::Ok {\n         globals: ref mut g, ..\n     } = result"
        }
    ],
    "stats": {
        "total": 374,
        "additions": 363,
        "deletions": 11
    }
}