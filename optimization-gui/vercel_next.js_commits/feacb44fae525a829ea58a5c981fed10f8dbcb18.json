{
    "author": "unstubbable",
    "message": "Add debug logging to default cache handler and `\"use cache\"` wrapper (#77827)\n\nWhen the env variable `NEXT_PRIVATE_DEBUG_CACHE` is defined (see https://nextjs.org/docs/app/building-your-application/data-fetching/incremental-static-regeneration#verifying-correct-production-behavior), the default cache handler and the `\"use cache\"` wrapper will now emit debug logs.\r\n\r\nNote: This variable can already be used for `\"use cache\"` debug logging when deploying to Vercel.",
    "sha": "feacb44fae525a829ea58a5c981fed10f8dbcb18",
    "files": [
        {
            "sha": "5e6044207071e035e6b8e7bc4e319d818fa4ae7e",
            "filename": "packages/next/src/server/lib/cache-handlers/default.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 3,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/feacb44fae525a829ea58a5c981fed10f8dbcb18/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fcache-handlers%2Fdefault.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/feacb44fae525a829ea58a5c981fed10f8dbcb18/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fcache-handlers%2Fdefault.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fcache-handlers%2Fdefault.ts?ref=feacb44fae525a829ea58a5c981fed10f8dbcb18",
            "patch": "@@ -41,13 +41,23 @@ const memoryCache = new LRUCache<PrivateCacheEntry>(\n )\n const pendingSets = new Map<string, Promise<void>>()\n \n+const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n+  ? console.debug.bind(console, 'DefaultCacheHandler:')\n+  : undefined\n+\n const DefaultCacheHandler: CacheHandlerV2 = {\n   async get(cacheKey) {\n-    await pendingSets.get(cacheKey)\n+    const pendingPromise = pendingSets.get(cacheKey)\n+\n+    if (pendingPromise) {\n+      debug?.('get', cacheKey, 'pending')\n+      await pendingPromise\n+    }\n \n     const privateEntry = memoryCache.get(cacheKey)\n \n     if (!privateEntry) {\n+      debug?.('get', cacheKey, 'not found')\n       return undefined\n     }\n \n@@ -59,22 +69,35 @@ const DefaultCacheHandler: CacheHandlerV2 = {\n       // In-memory caches should expire after revalidate time because it is\n       // unlikely that a new entry will be able to be used before it is dropped\n       // from the cache.\n+      debug?.('get', cacheKey, 'expired')\n+\n       return undefined\n     }\n \n     if (isStale(entry.tags, entry.timestamp)) {\n+      debug?.('get', cacheKey, 'had stale tag')\n+\n       return undefined\n     }\n     const [returnStream, newSaved] = entry.value.tee()\n     entry.value = newSaved\n \n+    debug?.('get', cacheKey, 'found', {\n+      tags: entry.tags,\n+      timestamp: entry.timestamp,\n+      revalidate: entry.revalidate,\n+      expire: entry.expire,\n+    })\n+\n     return {\n       ...entry,\n       value: returnStream,\n     }\n   },\n \n   async set(cacheKey, pendingEntry) {\n+    debug?.('set', cacheKey, 'start')\n+\n     let resolvePending: () => void = () => {}\n     const pendingPromise = new Promise<void>((resolve) => {\n       resolvePending = resolve\n@@ -100,8 +123,11 @@ const DefaultCacheHandler: CacheHandlerV2 = {\n         errorRetryCount: 0,\n         size,\n       })\n-    } catch {\n+\n+      debug?.('set', cacheKey, 'done')\n+    } catch (err) {\n       // TODO: store partial buffer with error after we retry 3 times\n+      debug?.('set', cacheKey, 'failed', err)\n     } finally {\n       resolvePending()\n       pendingSets.delete(cacheKey)\n@@ -113,11 +139,18 @@ const DefaultCacheHandler: CacheHandlerV2 = {\n   },\n \n   async getExpiration(...tags) {\n-    return Math.max(...tags.map((tag) => tagsManifest.get(tag) ?? 0))\n+    const expiration = Math.max(\n+      ...tags.map((tag) => tagsManifest.get(tag) ?? 0)\n+    )\n+\n+    debug?.('getExpiration', { tags, expiration })\n+\n+    return expiration\n   },\n \n   async expireTags(...tags) {\n     const timestamp = Math.round(performance.timeOrigin + performance.now())\n+    debug?.('expireTags', { tags, timestamp })\n \n     for (const tag of tags) {\n       // TODO: update file-system-cache?"
        },
        {
            "sha": "8423a66b97b2f3551d739c0f84354b9f370abfe4",
            "filename": "packages/next/src/server/use-cache/handlers.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/feacb44fae525a829ea58a5c981fed10f8dbcb18/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fhandlers.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/feacb44fae525a829ea58a5c981fed10f8dbcb18/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fhandlers.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fhandlers.ts?ref=feacb44fae525a829ea58a5c981fed10f8dbcb18",
            "patch": "@@ -5,7 +5,7 @@ const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n   ? (message: string, ...args: any[]) => {\n       console.log(`use-cache: ${message}`, ...args)\n     }\n-  : () => {}\n+  : undefined\n \n const handlersSymbol = Symbol.for('@next/cache-handlers')\n const handlersMapSymbol = Symbol.for('@next/cache-handlers-map')\n@@ -32,40 +32,40 @@ const reference: typeof globalThis & {\n export function initializeCacheHandlers(): boolean {\n   // If the cache handlers have already been initialized, don't do it again.\n   if (reference[handlersMapSymbol]) {\n-    debug('cache handlers already initialized')\n+    debug?.('cache handlers already initialized')\n     return false\n   }\n \n-  debug('initializing cache handlers')\n+  debug?.('initializing cache handlers')\n   reference[handlersMapSymbol] = new Map<string, CacheHandlerCompat>()\n \n   // Initialize the cache from the symbol contents first.\n   if (reference[handlersSymbol]) {\n     let fallback: CacheHandlerCompat\n     if (reference[handlersSymbol].DefaultCache) {\n-      debug('setting \"default\" cache handler from symbol')\n+      debug?.('setting \"default\" cache handler from symbol')\n       fallback = reference[handlersSymbol].DefaultCache\n     } else {\n-      debug('setting \"default\" cache handler from default')\n+      debug?.('setting \"default\" cache handler from default')\n       fallback = DefaultCacheHandler\n     }\n \n     reference[handlersMapSymbol].set('default', fallback)\n \n     if (reference[handlersSymbol].RemoteCache) {\n-      debug('setting \"remote\" cache handler from symbol')\n+      debug?.('setting \"remote\" cache handler from symbol')\n       reference[handlersMapSymbol].set(\n         'remote',\n         reference[handlersSymbol].RemoteCache\n       )\n     } else {\n-      debug('setting \"remote\" cache handler from default')\n+      debug?.('setting \"remote\" cache handler from default')\n       reference[handlersMapSymbol].set('remote', fallback)\n     }\n   } else {\n-    debug('setting \"default\" cache handler from default')\n+    debug?.('setting \"default\" cache handler from default')\n     reference[handlersMapSymbol].set('default', DefaultCacheHandler)\n-    debug('setting \"remote\" cache handler from default')\n+    debug?.('setting \"remote\" cache handler from default')\n     reference[handlersMapSymbol].set('remote', DefaultCacheHandler)\n   }\n \n@@ -135,7 +135,7 @@ export function setCacheHandler(\n     throw new Error('Cache handlers not initialized')\n   }\n \n-  debug('setting cache handler for \"%s\"', kind)\n+  debug?.('setting cache handler for \"%s\"', kind)\n   reference[handlersMapSymbol].set(kind, cacheHandler)\n   reference[handlersSetSymbol].add(cacheHandler)\n }"
        },
        {
            "sha": "0fdacf44c55adc44d4eb7d97fe9546ae1104ad10",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/feacb44fae525a829ea58a5c981fed10f8dbcb18/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/feacb44fae525a829ea58a5c981fed10f8dbcb18/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=feacb44fae525a829ea58a5c981fed10f8dbcb18",
            "patch": "@@ -66,6 +66,10 @@ export interface UseCachePageComponentProps {\n \n const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n \n+const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n+  ? console.debug.bind(console, 'use-cache:')\n+  : undefined\n+\n function generateCacheEntry(\n   workStore: WorkStore,\n   outerWorkUnitStore: WorkUnitStore | undefined,\n@@ -716,6 +720,7 @@ export function cache(\n           entry &&\n           (await shouldDiscardCacheEntry(entry, workStore, implicitTags))\n         ) {\n+          debug?.('discarding stale entry', serializedCacheKey)\n           entry = undefined\n         }\n \n@@ -756,6 +761,19 @@ export function cache(\n           // Note: It is important that we await at least once before this because it lets us\n           // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n \n+          if (entry) {\n+            if (currentTime > entry.timestamp + entry.expire * 1000) {\n+              debug?.('entry is expired', serializedCacheKey)\n+            }\n+\n+            if (\n+              workStore.isStaticGeneration &&\n+              currentTime > entry.timestamp + entry.revalidate * 1000\n+            ) {\n+              debug?.('static generation, entry is stale', serializedCacheKey)\n+            }\n+          }\n+\n           const [newStream, pendingCacheEntry] = await generateCacheEntry(\n             workStore,\n             workUnitStore,\n@@ -942,6 +960,13 @@ async function shouldDiscardCacheEntry(\n     // If the cache entry was created before any of the implicit tags were\n     // revalidated last, we also need to discard it.\n     if (entry.timestamp <= (await implicitTags.expiration)) {\n+      debug?.(\n+        'entry was created at',\n+        entry.timestamp,\n+        'before implicit tags were revalidated at',\n+        implicitTags.expiration\n+      )\n+\n       return true\n     }\n \n@@ -962,13 +987,17 @@ function isRecentlyRevalidatedTag(tag: string, workStore: WorkStore): boolean {\n \n   // Was the tag previously revalidated (e.g. by a redirecting server action)?\n   if (previouslyRevalidatedTags.includes(tag)) {\n+    debug?.('tag', tag, 'was previously revalidated')\n+\n     return true\n   }\n \n   // It could also have been revalidated by the currently running server action.\n   // In this case the revalidation might not have been propagated to the cache\n   // handler yet, so we read it from the pending tags in the work store.\n   if (pendingRevalidatedTags?.includes(tag)) {\n+    debug?.('tag', tag, 'was just revalidated')\n+\n     return true\n   }\n "
        }
    ],
    "stats": {
        "total": 88,
        "additions": 75,
        "deletions": 13
    }
}