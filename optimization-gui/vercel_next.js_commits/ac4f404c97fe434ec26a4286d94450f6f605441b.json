{
    "author": "icyJoseph",
    "message": "docs: generateMetadata and generateViewport w/ CC (#87218)\n\nCo-authored-by: Rich Haines <hello@richardhaines.dev>",
    "sha": "ac4f404c97fe434ec26a4286d94450f6f605441b",
    "files": [
        {
            "sha": "0df4aea79fdf82be70c13c50feae3e84c0996cf0",
            "filename": "docs/01-app/01-getting-started/06-cache-components.mdx",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/ac4f404c97fe434ec26a4286d94450f6f605441b/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/ac4f404c97fe434ec26a4286d94450f6f605441b/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx?ref=ac4f404c97fe434ec26a4286d94450f6f605441b",
            "patch": "@@ -504,6 +504,12 @@ During prerendering the header (static) and the blog posts fetched from the API\n \n When a user visits the page, they instantly see this prerendered shell with the header and blog posts. Only the personalized preferences need to stream in at request time since they depend on the user's cookies. This ensures fast initial page loads while still providing personalized content.\n \n+## Metadata and Viewport\n+\n+`generateMetadata` and `generateViewport` are part of rendering your page or layout. During prerendering, their access to runtime data or uncached dynamic data is tracked separately from the rest of the page.\n+\n+If a page or layout is prerenderable but only metadata or viewport accesses uncached dynamic data or runtime data, Next.js requires an explicit choice: cache the data if possible, or signal that deferred rendering is intentional. See [Metadata with Cache Components](/docs/app/api-reference/functions/generate-metadata#with-cache-components) and [Viewport with Cache Components](/docs/app/api-reference/functions/generate-viewport#with-cache-components) for how to handle this.\n+\n ## Enabling Cache Components\n \n You can enable Cache Components (which includes PPR) by adding the [`cacheComponents`](/docs/app/api-reference/config/next-config-js/cacheComponents) option to your Next config file:"
        },
        {
            "sha": "df6da90cc396e5a0272c0706240f37ea44c7c4c9",
            "filename": "docs/01-app/03-api-reference/03-file-conventions/layout.mdx",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/ac4f404c97fe434ec26a4286d94450f6f605441b/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Flayout.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/ac4f404c97fe434ec26a4286d94450f6f605441b/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Flayout.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Flayout.mdx?ref=ac4f404c97fe434ec26a4286d94450f6f605441b",
            "patch": "@@ -137,8 +137,10 @@ export default function RootLayout({ children }) {\n \n - The root layout **must** define `<html>` and `<body>` tags.\n   - You should **not** manually add `<head>` tags such as `<title>` and `<meta>` to root layouts. Instead, you should use the [Metadata API](/docs/app/getting-started/metadata-and-og-images) which automatically handles advanced requirements such as streaming and de-duplicating `<head>` elements.\n-- You can use [route groups](/docs/app/api-reference/file-conventions/route-groups) to create **multiple root layouts**.\n-  - Navigating **across multiple root layouts** will cause a **full page load** (as opposed to a client-side navigation). For example, navigating from `/cart` that uses `app/(shop)/layout.js` to `/blog` that uses `app/(marketing)/layout.js` will cause a full page load. This **only** applies to multiple root layouts.\n+- You can create **multiple root layouts**. Any layout without a `layout.js` above it is a root layout. Two common approaches:\n+  - Using [route groups](/docs/app/api-reference/file-conventions/route-groups) like `app/(shop)/layout.js` and `app/(marketing)/layout.js`\n+  - Omitting `app/layout.js` so layouts in subdirectories like `app/dashboard/layout.js` and `app/blog/layout.js` each become root layouts for their respective directories.\n+  - Navigating **across multiple root layouts** will cause a **full page load** (as opposed to a client-side navigation).\n - The root layout can be under a **dynamic segment**, for example when implementing [internationalization](/docs/app/guides/internationalization) with `app/[lang]/layout.js`.\n \n ## Caveats"
        },
        {
            "sha": "7720541df9ed0427245ad48c3ac63c8567c214f6",
            "filename": "docs/01-app/03-api-reference/04-functions/generate-metadata.mdx",
            "status": "modified",
            "additions": 65,
            "deletions": 0,
            "changes": 65,
            "blob_url": "https://github.com/vercel/next.js/blob/ac4f404c97fe434ec26a4286d94450f6f605441b/docs%2F01-app%2F03-api-reference%2F04-functions%2Fgenerate-metadata.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/ac4f404c97fe434ec26a4286d94450f6f605441b/docs%2F01-app%2F03-api-reference%2F04-functions%2Fgenerate-metadata.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2Fgenerate-metadata.mdx?ref=ac4f404c97fe434ec26a4286d94450f6f605441b",
            "patch": "@@ -7,6 +7,8 @@ related:\n   links:\n     - app/api-reference/file-conventions/metadata\n     - app/api-reference/functions/generate-viewport\n+    - app/getting-started/cache-components\n+    - app/api-reference/config/next-config-js/cacheComponents\n ---\n \n You can use the `metadata` object or the `generateMetadata` function to define metadata.\n@@ -1202,6 +1204,69 @@ Streaming metadata improves perceived performance by reducing [TTFB](https://dev\n \n Overriding `htmlLimitedBots` could lead to longer response times. Streaming metadata is an advanced feature, and the default should be sufficient for most cases.\n \n+### With Cache Components\n+\n+When [Cache Components](/docs/app/getting-started/cache-components) is enabled, `generateMetadata` follows the same rules as other components. If metadata accesses runtime data (`cookies()`, `headers()`, `params`, `searchParams`) or performs uncached data fetching, it defers to request time.\n+\n+How Next.js handles this depends on the rest of your page:\n+\n+- **If other parts also defer to request time**: Prerendering generates a static shell, and metadata streams in with other deferred content.\n+- **If the page or layout is otherwise fully prerenderable**: Next.js requires an explicit choice: cache the data if possible, or signal that deferred rendering is intentional.\n+\n+Streaming metadata at runtime while the rest of the page is fully prerenderable is not common. To ensure this behavior is intentional, an error is raised indicating which page or layout needs to be handled.\n+\n+To resolve this, you have two options. If metadata depends on external data but not runtime data, use `use cache`:\n+\n+```tsx filename=\"app/blog/[slug]/page.tsx\" highlight={2}\n+export async function generateMetadata({ params }) {\n+  'use cache'\n+  const { slug } = await params\n+  const post = await db.getPost(slug)\n+  return { title: post.title }\n+}\n+```\n+\n+If metadata genuinely requires runtime data, add a dynamic marker component to your page:\n+\n+```tsx filename=\"app/page.tsx\" highlight={11-14,19,28}\n+import { Suspense } from 'react'\n+import { cookies } from 'next/headers'\n+import { connection } from 'next/server'\n+\n+export async function generateMetadata() {\n+  const token = (await cookies()).get('token')?.value\n+  // ... use token to fetch personalized metadata\n+  return { title: 'Personalized Title' }\n+}\n+\n+const Connection = async () => {\n+  await connection()\n+  return null\n+}\n+\n+async function DynamicMarker() {\n+  return (\n+    <Suspense>\n+      <Connection />\n+    </Suspense>\n+  )\n+}\n+\n+export default function Page() {\n+  // DO NOT place await connection() here\n+  // doing so prevents the article tag content from\n+  // being included in the static shell\n+  return (\n+    <>\n+      <article>Static content</article>\n+      <DynamicMarker />\n+    </>\n+  )\n+}\n+```\n+\n+The `DynamicMarker` component renders nothing but tells Next.js the page has intentional dynamic content. By wrapping it in Suspense, the static content still prerenders normally.\n+\n ### Ordering\n \n Metadata is evaluated in order, starting from the root segment down to the segment closest to the final `page.js` segment. For example:"
        },
        {
            "sha": "f777a07a4f0850c23195fe1836bdc00d580f2da5",
            "filename": "docs/01-app/03-api-reference/04-functions/generate-viewport.mdx",
            "status": "modified",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/vercel/next.js/blob/ac4f404c97fe434ec26a4286d94450f6f605441b/docs%2F01-app%2F03-api-reference%2F04-functions%2Fgenerate-viewport.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/ac4f404c97fe434ec26a4286d94450f6f605441b/docs%2F01-app%2F03-api-reference%2F04-functions%2Fgenerate-viewport.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2Fgenerate-viewport.mdx?ref=ac4f404c97fe434ec26a4286d94450f6f605441b",
            "patch": "@@ -6,6 +6,8 @@ related:\n   description: View all the Metadata API options.\n   links:\n     - app/api-reference/file-conventions/metadata\n+    - app/getting-started/cache-components\n+    - app/api-reference/config/next-config-js/cacheComponents\n ---\n \n You can customize the initial viewport of the page with the static `viewport` object or the dynamic `generateViewport` function.\n@@ -174,6 +176,52 @@ export const viewport = {\n <meta name=\"color-scheme\" content=\"dark\" />\n ```\n \n+## With Cache Components\n+\n+When [Cache Components](/docs/app/getting-started/cache-components) is enabled, `generateViewport` follows the same rules as other components. If viewport accesses runtime data (`cookies()`, `headers()`, `params`, `searchParams`) or performs uncached data fetching, it defers to request time.\n+\n+Unlike metadata, viewport cannot be streamed because it affects initial page load UI. If `generateViewport` defers to request time, the page would need to block until resolved.\n+\n+To ensure, that having a deferred viewport on an otherwise fully prerenderable page or layout is intentional, an error is raised. To resolve this error, you have two options.\n+\n+If viewport depends on external data but not runtime data, use `use cache`:\n+\n+```tsx filename=\"app/layout.tsx\" highlight={2}\n+export async function generateViewport() {\n+  'use cache'\n+  const { width, initialScale } = await db.query('viewport-size')\n+  return { width, initialScale }\n+}\n+```\n+\n+If viewport genuinely requires runtime data, wrap the document `<body>` in a Suspense boundary to signal that the entire route should be dynamic:\n+\n+```tsx filename=\"app/layout.tsx\" highlight={1,11-15}\n+import { Suspense } from 'react'\n+import { cookies } from 'next/headers'\n+\n+export async function generateViewport() {\n+  const cookieJar = await cookies()\n+  return {\n+    themeColor: cookieJar.get('theme-color')?.value,\n+  }\n+}\n+\n+export default function RootLayout({ children }) {\n+  return (\n+    <Suspense>\n+      <html>\n+        <body>{children}</body>\n+      </html>\n+    </Suspense>\n+  )\n+}\n+```\n+\n+Caching is preferred because it allows static shell generation. Wrapping the document `body` in Suspense means there is no static shell or content to immediately send when a request arrives, making the entire route block until ready on every request.\n+\n+> **Good to know**: Use [multiple root layouts](/docs/app/api-reference/file-conventions/layout#root-layout) to isolate fully dynamic viewport to specific routes, while still letting other routes in your application generate a static shell.\n+\n ## Types\n \n You can add type safety to your viewport object by using the `Viewport` type. If you are using the [built-in TypeScript plugin](/docs/app/api-reference/config/typescript) in your IDE, you do not need to manually add the type, but you can still explicitly add it if you want."
        },
        {
            "sha": "c2c7fbb700aa3ce3a97b53ce58b9f36877af2132",
            "filename": "errors/next-prerender-dynamic-metadata.mdx",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/ac4f404c97fe434ec26a4286d94450f6f605441b/errors%2Fnext-prerender-dynamic-metadata.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/ac4f404c97fe434ec26a4286d94450f6f605441b/errors%2Fnext-prerender-dynamic-metadata.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fnext-prerender-dynamic-metadata.mdx?ref=ac4f404c97fe434ec26a4286d94450f6f605441b",
            "patch": "@@ -8,9 +8,9 @@ When `cacheComponents` is enabled, Next.js requires that Document Metadata not d\n \n Next.js determines if a page is entirely static or partially static by looking at whether any part of the page cannot be prerendered.\n \n-Typically you control the which parts of a page can be prerendered by adding `\"use cache\"` to Components or data functions and by avoiding Runtime data like `cookies()` or `searchParams`. However, Metadata can be defined in functions (`generateMetadata()`) defined far from your Page content. Additionally Metadata can implicitly depend on Runtime data when using file-based Metadata such as an icon inside a route with a dynamic param. It would be easy for Metadata to accidentally make an otherwise entirely static page have a dynamic component.\n+You control which parts of a page can be prerendered by adding `\"use cache\"` to components or data functions and by avoiding Runtime data like `cookies()` or `searchParams`. Metadata, though, can be defined in functions (`generateMetadata()`) far from your Page content. It can also implicitly depend on Runtime data when using file-based Metadata such as an icon inside a route with a dynamic param. This makes it easy for Metadata to accidentally make an otherwise entirely static page partially dynamic.\n \n-To prevent anwanted partially dynamic pages, Next.js expects pages that are otherwise entirely prerenderable to also have prerenderable Metadata.\n+To prevent unwanted partially dynamic pages, Next.js expects pages that are otherwise entirely prerenderable to also have prerenderable Metadata.\n \n ## Possible Ways to Fix It\n \n@@ -80,7 +80,7 @@ export default async function Page() {\n \n ### If you must access Request Data or your external data is uncacheable\n \n-If your metadata requires Request data or depends on external data which is not cacheable then Next.js will need to render this page dynamically on every request. However if you got this error, the rest of your page is able to be completely static. This is generally pretty rare, but if this is your actual constraint, you can indicate to Next.js that the page should be allowed to be dynamic by rendering any other component that is dynamic. Since your route doesn't have any genuine need for Request data, you can indicate an intentional dependency on a Request with `await connection()`. This is like telling Next.js that this component is never prerenderable and must be rendered on every user request.\n+If your metadata requires Request data or depends on external data that is not cacheable, Next.js will need to render this page dynamically on every request. That said, if you got this error, the rest of your page is able to be completely static. This is generally pretty rare, but if this is your actual constraint, you can indicate to Next.js that the page should be allowed to be dynamic by rendering any other component that is dynamic. Since your route doesn't have any genuine need for Request data, you can indicate an intentional dependency on a Request with `await connection()`. This is like telling Next.js that this component is never prerenderable and must be rendered on every user request.\n \n Before:\n \n@@ -91,7 +91,7 @@ import { getPersonalizedTitle } from './my-api'\n export async function generateMetadata() {\n   // In this example, we are assuming we must fetch our title\n   // from a protected external API. While the response is potentially\n-  // cacheable, the it still requires accessing a token from the Request cookies.\n+  // cacheable, it still requires accessing a token from the Request cookies.\n   const token = (await cookies()).get('token')\n   const response = await getPersonalizedTitle(token)\n   return {"
        },
        {
            "sha": "2766eeead9d40dd7eecb33f35bc83f7147033a82",
            "filename": "errors/next-prerender-dynamic-viewport.mdx",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/ac4f404c97fe434ec26a4286d94450f6f605441b/errors%2Fnext-prerender-dynamic-viewport.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/ac4f404c97fe434ec26a4286d94450f6f605441b/errors%2Fnext-prerender-dynamic-viewport.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fnext-prerender-dynamic-viewport.mdx?ref=ac4f404c97fe434ec26a4286d94450f6f605441b",
            "patch": "@@ -10,11 +10,11 @@ When `cacheComponents` is enabled, Next.js requires that `generateViewport()` no\n \n To fix this issue, you must first determine your goal for the affected route.\n \n-Normally, Next.js ensures every page can produce an initial UI that allows the page to start loading even before uncached data and Runtime data is available. This is accomplished by defining prerenderable UI with Suspense. However viewport metadata is not able to be deferred until after the page loads because it affects initial page load UI.\n+Next.js ensures every page can produce an initial UI before uncached data and Runtime data is available. This is accomplished by defining prerenderable UI with Suspense. Viewport metadata, though, cannot be deferred because it affects initial page load UI.\n \n Ideally, you update `generateViewport` so it does not depend on any uncached data or Runtime data. This allows navigations to appear instant.\n \n-However if this is not possibl you can instruct Next.js to allow all navigations to be potentially blocking by wrapping your document `<body>` in a Suspense boundary.\n+If this is not possible, you can instruct Next.js to allow all navigations to be potentially blocking by wrapping your document `<body>` in a Suspense boundary.\n \n ### Caching External Data\n \n@@ -69,7 +69,7 @@ import { cookies } from 'next/headers'\n export async function generateViewport() {\n   const cookieJar = await cookies()\n   return {\n-    themeColor: cookieJar.get('theme-color'),\n+    themeColor: cookieJar.get('theme-color')?.value,\n   }\n }\n \n@@ -91,7 +91,7 @@ import { cookies } from 'next/headers'\n export async function generateViewport() {\n   const cookieJar = await cookies()\n   return {\n-    themeColor: cookieJar.get('theme-color'),\n+    themeColor: cookieJar.get('theme-color')?.value,\n   }\n }\n "
        }
    ],
    "stats": {
        "total": 141,
        "additions": 131,
        "deletions": 10
    }
}