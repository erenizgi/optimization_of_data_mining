{
    "author": "sokra",
    "message": "Turbopack: use a source content regexp for the react compiler (#82631)\n\n### What?\n\nDepending on compilation mode of the react compiler, check the source code if matches a certain regex\n\nThis also adds `content` as condition for webpack loaders\n\nCloses PACK-5252",
    "sha": "6016558bbc485f61a93e35b03854c97c0d0da769",
    "files": [
        {
            "sha": "e63efb2af24ea9d4b6a1fc6d74b94a1814c1a6da",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 5,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/6016558bbc485f61a93e35b03854c97c0d0da769/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6016558bbc485f61a93e35b03854c97c0d0da769/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=6016558bbc485f61a93e35b03854c97c0d0da769",
            "patch": "@@ -577,24 +577,32 @@ impl TryInto<ConditionPath> for ConfigConditionPath {\n     fn try_into(self) -> Result<ConditionPath> {\n         Ok(match self {\n             ConfigConditionPath::Glob(path) => ConditionPath::Glob(path),\n-            ConfigConditionPath::Regex(path) => {\n-                ConditionPath::Regex(EsRegex::new(&path.source, &path.flags)?.resolved_cell())\n-            }\n+            ConfigConditionPath::Regex(path) => ConditionPath::Regex(path.try_into()?),\n         })\n     }\n \n     type Error = anyhow::Error;\n }\n \n+impl TryInto<ResolvedVc<EsRegex>> for RegexComponents {\n+    fn try_into(self) -> Result<ResolvedVc<EsRegex>> {\n+        Ok(EsRegex::new(&self.source, &self.flags)?.resolved_cell())\n+    }\n+\n+    type Error = anyhow::Error;\n+}\n+\n #[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]\n pub struct ConfigConditionItem {\n-    pub path: ConfigConditionPath,\n+    pub path: Option<ConfigConditionPath>,\n+    pub content: Option<RegexComponents>,\n }\n \n impl TryInto<ConditionItem> for ConfigConditionItem {\n     fn try_into(self) -> Result<ConditionItem> {\n         Ok(ConditionItem {\n-            path: self.path.try_into()?,\n+            path: self.path.map(|p| p.try_into()).transpose()?,\n+            content: self.content.map(|r| r.try_into()).transpose()?,\n         })\n     }\n "
        },
        {
            "sha": "af6b9d4f6b6ed8f5f70460c511b0558f1e140166",
            "filename": "packages/next/src/build/swc/index.ts",
            "status": "modified",
            "additions": 35,
            "deletions": 7,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/6016558bbc485f61a93e35b03854c97c0d0da769/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6016558bbc485f61a93e35b03854c97c0d0da769/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts?ref=6016558bbc485f61a93e35b03854c97c0d0da769",
            "patch": "@@ -10,6 +10,7 @@ import { patchIncorrectLockfile } from '../../lib/patch-incorrect-lockfile'\n import { downloadNativeNextSwc, downloadWasmSwc } from '../../lib/download-swc'\n import type {\n   NextConfigComplete,\n+  ReactCompilerOptions,\n   TurbopackLoaderItem,\n   TurbopackRuleConfigItem,\n   TurbopackRuleConfigItemOptions,\n@@ -805,13 +806,15 @@ function bindingToApi(\n     originalNextConfig: NextConfigComplete,\n     projectPath: string\n   ): Record<string, any> {\n-    let nextConfig = { ...(originalNextConfig as any) }\n+    let nextConfig = { ...(originalNextConfig as NextConfigComplete) }\n \n     const reactCompilerOptions = nextConfig.experimental?.reactCompiler\n \n     // It is not easy to set the rules inside of rust as resolving, and passing the context identical to the webpack\n     // config is bit hard, also we can reuse same codes between webpack config in here.\n     if (reactCompilerOptions) {\n+      const options: ReactCompilerOptions =\n+        typeof reactCompilerOptions === 'object' ? reactCompilerOptions : {}\n       const ruleKeys = ['*.ts', '*.js', '*.jsx', '*.tsx']\n       if (\n         Object.keys(nextConfig?.turbopack?.rules ?? {}).some((key) =>\n@@ -826,15 +829,27 @@ function bindingToApi(\n         )\n       } else {\n         nextConfig.turbopack ??= {}\n+        nextConfig.turbopack.conditions ??= {}\n         nextConfig.turbopack.rules ??= {}\n \n         for (const key of ruleKeys) {\n-          nextConfig.turbopack.rules[key] = {\n+          nextConfig.turbopack.conditions[`#reactCompiler/${key}`] = {\n+            path: key,\n+            content:\n+              options.compilationMode === 'annotation'\n+                ? /['\"]use memo['\"]/\n+                : !options.compilationMode ||\n+                    options.compilationMode === 'infer'\n+                  ? // Matches declaration or useXXX or </ (closing jsx) or /> (self closing jsx)\n+                    /['\"]use memo['\"]|\\Wuse[A-Z]|<\\/|\\/>/\n+                  : undefined,\n+          }\n+          nextConfig.turbopack.rules[`#reactCompiler/${key}`] = {\n             browser: {\n               foreign: false,\n               loaders: [\n                 getReactCompilerLoader(\n-                  originalNextConfig.experimental.reactCompiler,\n+                  reactCompilerOptions,\n                   projectPath,\n                   nextConfig.dev,\n                   /* isServer */ false,\n@@ -905,23 +920,36 @@ function bindingToApi(\n     if (conditions) {\n       type SerializedConditions = {\n         [key: string]: {\n-          path:\n+          path?:\n             | { type: 'regex'; value: { source: string; flags: string } }\n             | { type: 'glob'; value: string }\n+          content?: { source: string; flags: string }\n+        }\n+      }\n+\n+      function regexComponents(regex: RegExp): {\n+        source: string\n+        flags: string\n+      } {\n+        return {\n+          source: regex.source,\n+          flags: regex.flags,\n         }\n       }\n \n       const serializedConditions: SerializedConditions = {}\n       for (const [key, value] of Object.entries(conditions)) {\n         serializedConditions[key] = {\n           ...value,\n-          path:\n-            value.path instanceof RegExp\n+          path: !value.path\n+            ? undefined\n+            : value.path instanceof RegExp\n               ? {\n                   type: 'regex',\n-                  value: { source: value.path.source, flags: value.path.flags },\n+                  value: regexComponents(value.path),\n                 }\n               : { type: 'glob', value: value.path },\n+          content: !value.content ? undefined : regexComponents(value.content),\n         }\n       }\n       nextConfigSerializable.turbopack.conditions = serializedConditions"
        },
        {
            "sha": "300e9d9b5e36f417b1345e44db6007c5dc3a4f8e",
            "filename": "packages/next/src/server/config-schema.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/6016558bbc485f61a93e35b03854c97c0d0da769/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6016558bbc485f61a93e35b03854c97c0d0da769/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts?ref=6016558bbc485f61a93e35b03854c97c0d0da769",
            "patch": "@@ -129,7 +129,8 @@ const zTurboRuleConfigItemOrShortcut: zod.ZodType<TurbopackRuleConfigItemOrShort\n   z.union([z.array(zTurboLoaderItem), zTurboRuleConfigItem])\n \n const zTurboCondition: zod.ZodType<TurbopackRuleCondition> = z.object({\n-  path: z.union([z.string(), z.instanceof(RegExp)]),\n+  path: z.union([z.string(), z.instanceof(RegExp)]).optional(),\n+  content: z.instanceof(RegExp).optional(),\n })\n \n const zTurbopackConfig: zod.ZodType<TurbopackOptions> = z.strictObject({"
        },
        {
            "sha": "e9a30f20b0f8ac0bc8a2bf919e06337feec1224c",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/6016558bbc485f61a93e35b03854c97c0d0da769/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6016558bbc485f61a93e35b03854c97c0d0da769/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=6016558bbc485f61a93e35b03854c97c0d0da769",
            "patch": "@@ -262,7 +262,8 @@ export type TurbopackLoaderItem =\n     }\n \n export type TurbopackRuleCondition = {\n-  path: string | RegExp\n+  path?: string | RegExp\n+  content?: RegExp\n }\n \n export type TurbopackRuleConfigItemOrShortcut ="
        },
        {
            "sha": "dc19eb01dd38b0e9bc2b7db1543ffaa29f1ca3e3",
            "filename": "turbopack/crates/turbopack/src/module_options/mod.rs",
            "status": "modified",
            "additions": 49,
            "deletions": 34,
            "changes": 83,
            "blob_url": "https://github.com/vercel/next.js/blob/6016558bbc485f61a93e35b03854c97c0d0da769/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6016558bbc485f61a93e35b03854c97c0d0da769/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs?ref=6016558bbc485f61a93e35b03854c97c0d0da769",
            "patch": "@@ -489,43 +489,58 @@ impl ModuleOptions {\n                 )\n             };\n             for (key, rule) in webpack_loaders_options.rules.await?.iter() {\n-                rules.push(ModuleRule::new(\n-                    RuleCondition::All(vec![\n-                        if key.starts_with(\"#\") {\n-                            // This is a custom marker requiring a corresponding condition entry\n-                            let conditions = (*webpack_loaders_options.conditions.await?)\n-                                .context(\n-                                    \"Expected a condition entry for the webpack loader rule \\\n-                                     matching {key}. Create a `conditions` mapping in your \\\n-                                     next.config.js\",\n-                                )?\n-                                .await?;\n-\n-                            let condition = conditions.get(key).context(\n-                                \"Expected a condition entry for the webpack loader rule matching \\\n-                                 {key}.\",\n-                            )?;\n-\n-                            match &condition.path {\n-                                ConditionPath::Glob(glob) => RuleCondition::ResourcePathGlob {\n+                let mut rule_conditions = Vec::new();\n+                if key.starts_with(\"#\") {\n+                    // This is a custom marker requiring a corresponding condition entry\n+                    let conditions = (*webpack_loaders_options.conditions.await?)\n+                        .context(\n+                            \"Expected a condition entry for the webpack loader rule matching \\\n+                             {key}. Create a `conditions` mapping in your next.config.js\",\n+                        )?\n+                        .await?;\n+\n+                    let condition = conditions.get(key).context(\n+                        \"Expected a condition entry for the webpack loader rule matching {key}.\",\n+                    )?;\n+\n+                    let ConditionItem { path, content } = &condition;\n+\n+                    match &path {\n+                        Some(ConditionPath::Glob(glob)) => {\n+                            if glob.contains('/') {\n+                                rule_conditions.push(RuleCondition::ResourcePathGlob {\n                                     base: execution_context.project_path().owned().await?,\n                                     glob: Glob::new(glob.clone()).await?,\n-                                },\n-                                ConditionPath::Regex(regex) => {\n-                                    RuleCondition::ResourcePathEsRegex(regex.await?)\n-                                }\n-                            }\n-                        } else if key.contains('/') {\n-                            RuleCondition::ResourcePathGlob {\n-                                base: execution_context.project_path().owned().await?,\n-                                glob: Glob::new(key.clone()).await?,\n+                                });\n+                            } else {\n+                                rule_conditions.push(RuleCondition::ResourceBasePathGlob(\n+                                    Glob::new(glob.clone()).await?,\n+                                ));\n                             }\n-                        } else {\n-                            RuleCondition::ResourceBasePathGlob(Glob::new(key.clone()).await?)\n-                        },\n-                        RuleCondition::not(RuleCondition::ResourceIsVirtualSource),\n-                        module_css_external_transform_conditions.clone(),\n-                    ]),\n+                        }\n+                        Some(ConditionPath::Regex(regex)) => {\n+                            rule_conditions.push(RuleCondition::ResourcePathEsRegex(regex.await?));\n+                        }\n+                        None => {}\n+                    }\n+                    if let Some(content) = content {\n+                        rule_conditions.push(RuleCondition::ResourceContentEsRegex(content.await?));\n+                    }\n+                } else if key.contains('/') {\n+                    rule_conditions.push(RuleCondition::ResourcePathGlob {\n+                        base: execution_context.project_path().owned().await?,\n+                        glob: Glob::new(key.clone()).await?,\n+                    });\n+                } else {\n+                    rule_conditions.push(RuleCondition::ResourceBasePathGlob(\n+                        Glob::new(key.clone()).await?,\n+                    ));\n+                };\n+                rule_conditions.push(RuleCondition::not(RuleCondition::ResourceIsVirtualSource));\n+                rule_conditions.push(module_css_external_transform_conditions.clone());\n+\n+                rules.push(ModuleRule::new(\n+                    RuleCondition::All(rule_conditions),\n                     vec![ModuleRuleEffect::SourceTransforms(ResolvedVc::cell(vec![\n                         ResolvedVc::upcast(\n                             WebpackLoaders::new("
        },
        {
            "sha": "1cdc0c918577370723145bad2600235e201704cf",
            "filename": "turbopack/crates/turbopack/src/module_options/module_options_context.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/6016558bbc485f61a93e35b03854c97c0d0da769/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6016558bbc485f61a93e35b03854c97c0d0da769/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs?ref=6016558bbc485f61a93e35b03854c97c0d0da769",
            "patch": "@@ -50,7 +50,8 @@ pub enum ConditionPath {\n #[turbo_tasks::value(shared)]\n #[derive(Clone, Debug)]\n pub struct ConditionItem {\n-    pub path: ConditionPath,\n+    pub path: Option<ConditionPath>,\n+    pub content: Option<ResolvedVc<EsRegex>>,\n }\n \n #[turbo_tasks::value(shared)]"
        },
        {
            "sha": "820c5c36ba807d10ff4f8c8880ec763f75928696",
            "filename": "turbopack/crates/turbopack/src/module_options/rule_condition.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/6016558bbc485f61a93e35b03854c97c0d0da769/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6016558bbc485f61a93e35b03854c97c0d0da769/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs?ref=6016558bbc485f61a93e35b03854c97c0d0da769",
            "patch": "@@ -3,9 +3,9 @@ use serde::{Deserialize, Serialize};\n use smallvec::SmallVec;\n use turbo_esregex::EsRegex;\n use turbo_tasks::{NonLocalValue, ReadRef, ResolvedVc, primitives::Regex, trace::TraceRawVcs};\n-use turbo_tasks_fs::{FileSystemPath, glob::Glob};\n+use turbo_tasks_fs::{FileContent, FileSystemPath, glob::Glob};\n use turbopack_core::{\n-    reference_type::ReferenceType, source::Source, virtual_source::VirtualSource,\n+    asset::Asset, reference_type::ReferenceType, source::Source, virtual_source::VirtualSource,\n };\n \n #[derive(Debug, Clone, Serialize, Deserialize, TraceRawVcs, PartialEq, Eq, NonLocalValue)]\n@@ -24,6 +24,7 @@ pub enum RuleCondition {\n     ContentTypeEmpty,\n     ResourcePathRegex(#[turbo_tasks(trace_ignore)] Regex),\n     ResourcePathEsRegex(#[turbo_tasks(trace_ignore)] ReadRef<EsRegex>),\n+    ResourceContentEsRegex(#[turbo_tasks(trace_ignore)] ReadRef<EsRegex>),\n     /// For paths that are within the same filesystem as the `base`, it need to\n     /// match the relative path from base to resource. This includes `./` or\n     /// `../` prefix. For paths in a different filesystem, it need to match\n@@ -166,6 +167,15 @@ impl RuleCondition {\n                     RuleCondition::ResourcePathEsRegex(regex) => {\n                         return Ok(regex.is_match(&path.path));\n                     }\n+                    RuleCondition::ResourceContentEsRegex(regex) => {\n+                        let content = source.content().file_content().await?;\n+                        match &*content {\n+                            FileContent::Content(file_content) => {\n+                                return Ok(regex.is_match(&file_content.content().to_str()?));\n+                            }\n+                            FileContent::NotFound => return Ok(false),\n+                        }\n+                    }\n                 }\n             }\n         }"
        }
    ],
    "stats": {
        "total": 166,
        "additions": 115,
        "deletions": 51
    }
}