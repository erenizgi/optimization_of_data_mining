{
    "author": "wyattjoh",
    "message": "feat(build): add client param parsing support for PPR routes (#82621)\n\n### What?\n\nThis PR introduces comprehensive type-aware parameter tracking and\nfallback handling for dynamic routes in PPR scenarios, with enhanced\nclient-side parameter resolution capabilities.\n\n### Why?\n\nWhen using client segment cache with dynamic routes, Next.js faced\nseveral critical issues that prevented reliable client-side navigation:\n\n**1. Parameter Resolution Inconsistencies**: The previous system had\ninconsistent behavior when handling parallel route parameters, causing\nunpredictable parameter resolution across different route segments. This\nled to client-side navigation failures when encountering dynamic route\nsegments that weren't statically generated.\n\n**2. Limited Parameter Type Awareness**: The routing system lacked\nsemantic understanding of different parameter types (dynamic, catchall,\noptional catchall), making it impossible to implement advanced parameter\nhandling features or provide proper fallback behavior for different\nparameter scenarios.\n\n**3. Incomplete Fallback Parameter Collection**: The original\n`getFallbackRouteParams()` used simple string-based tracking that\ncouldn't capture the full complexity of parameter relationships,\nespecially in parallel route scenarios where parameters might be defined\nat different levels of the route tree.\n\n**4. Client-Side Parameter Extraction Gaps**: The `getDynamicParam`\nfunction had limitations in handling fallback route parameters and\nlacked proper encoding/decoding mechanisms, leading to potential\nclient-side errors during route resolution.\n\n**5. Configuration Validation Missing**: There was no validation to\nensure `clientParamParsing` was only enabled when `clientSegmentCache`\nwas also enabled, leading to potential misconfigurations in production.\n\nThese issues became critical blockers for implementing reliable\nclient-side parameter parsing in PPR scenarios, particularly for the\nVercel platform integration\n(https://github.com/vercel/vercel/pull/13740).\n\n### How?\n\n- Introduces `DynamicParamTypes` and `OpaqueFallbackRouteParams` for\nstructured, type-aware parameter tracking\n- Refactors `getFallbackRouteParams()` to use route modules for\ncomprehensive parameter collection across the routing tree\n- Adds `resolveParallelRouteParams` function to eliminate parallel route\nparameter inconsistencies\n- Enhances `getDynamicParam` with proper fallback parameter handling,\nencoding, and comprehensive catchall support\n- Implements configuration validation in `assignDefaultsAndValidate()`\nto prevent misconfigurations\n- Adds clientParamParsing boolean to the routes manifest configuration\n(needed for https://github.com/vercel/vercel/pull/13740)\n- Updates build pipeline to properly handle enhanced fallback parameters\nacross static generation, export, and rendering phases\n\nNAR-305\n\n---------\n\nCo-authored-by: vercel[bot] <35613825+vercel[bot]@users.noreply.github.com>",
    "sha": "badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
    "files": [
        {
            "sha": "91560102b2336abc7c1c989bfcdd1e41d92203d7",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -784,5 +784,12 @@\n   \"783\": \"Expected document.currentScript to be a <script> element. Received %s instead.\",\n   \"784\": \"Expected document.currentScript src to contain '/_next/'. Received %s instead.\",\n   \"785\": \"Expected webSocket to be defined in dev mode.\",\n-  \"786\": \"Expected staticIndicatorState to be defined in dev mode.\"\n+  \"786\": \"Expected staticIndicatorState to be defined in dev mode.\",\n+  \"787\": \"\\\\`experimental.clientParamParsing\\\\` can not be \\\\`true\\\\` when \\\\`experimental.clientSegmentCache\\\\` is \\\\`false\\\\`. Client param parsing is only relevant when client segment cache is enabled.\",\n+  \"788\": \"Unexpected dynamic param type: %s\",\n+  \"789\": \"Expected RSC response, got %s\",\n+  \"790\": \"Invariant: Expected RSC response, got %s\",\n+  \"791\": \"Unexpected match for a pathname \\\"%s\\\" with a param \\\"%s\\\" of type \\\"%s\\\"\",\n+  \"792\": \"Unexpected empty path segments match for a pathname \\\"%s\\\" with param \\\"%s\\\" of type \\\"%s\\\"\",\n+  \"793\": \"No value found for segment key: \\\"%s\\\"\"\n }"
        },
        {
            "sha": "cef9801ff87c966b17950fe817bac85717ac4d9c",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 65,
            "deletions": 11,
            "changes": 76,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -143,7 +143,7 @@ import {\n   collectMeta,\n } from './utils'\n import type { PageInfo, PageInfos } from './utils'\n-import type { PrerenderedRoute } from './static-paths/types'\n+import type { FallbackRouteParam, PrerenderedRoute } from './static-paths/types'\n import type { AppSegmentConfig } from './segment-config/app/app-segment-config'\n import { writeBuildId } from './write-build-id'\n import { normalizeLocalePath } from '../shared/lib/i18n/normalize-locale-path'\n@@ -323,6 +323,12 @@ export interface DynamicPrerenderManifestRoute {\n    */\n   fallbackRootParams: readonly string[] | undefined\n \n+  /**\n+   * The fallback route params for this route that were parsed from the loader\n+   * tree.\n+   */\n+  fallbackRouteParams: readonly FallbackRouteParam[] | undefined\n+\n   /**\n    * The source route that this fallback route is based on. This is a reference\n    * so that we can associate this dynamic route with the correct source.\n@@ -461,6 +467,12 @@ export type RoutesManifest = {\n     prefetchSegmentHeader: typeof NEXT_ROUTER_SEGMENT_PREFETCH_HEADER\n     prefetchSegmentDirSuffix: typeof RSC_SEGMENTS_DIR_SUFFIX\n     prefetchSegmentSuffix: typeof RSC_SEGMENT_SUFFIX\n+\n+    /**\n+     * Whether the client param parsing is enabled. This is only relevant for\n+     * app pages when PPR is enabled.\n+     */\n+    clientParamParsing: boolean\n   }\n   rewriteHeaders: {\n     pathHeader: typeof NEXT_REWRITTEN_PATH_HEADER\n@@ -1541,6 +1553,10 @@ export default async function build(\n               prefetchSegmentHeader: NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n               prefetchSegmentSuffix: RSC_SEGMENT_SUFFIX,\n               prefetchSegmentDirSuffix: RSC_SEGMENTS_DIR_SUFFIX,\n+              clientParamParsing:\n+                // NOTE: once this is the default for `clientSegmentCache`, this\n+                // should exclusively be based on the `clientSegmentCache` flag.\n+                config.experimental.clientParamParsing ?? false,\n             },\n             rewriteHeaders: {\n               pathHeader: NEXT_REWRITTEN_PATH_HEADER,\n@@ -2886,9 +2902,19 @@ export default async function build(\n                   // If the route has any dynamic root segments, we need to skip\n                   // rendering the route. This is because we don't support\n                   // revalidating the shells without the parameters present.\n+                  // Note that we only have fallback root params if we also have\n+                  // PPR enabled for this route/app already.\n                   if (\n                     route.fallbackRootParams &&\n-                    route.fallbackRootParams.length > 0\n+                    route.fallbackRootParams.length > 0 &&\n+                    // We don't skip rendering the route if we have the\n+                    // following enabled. This is because the flight data now\n+                    // does not contain any of the route params and is instead\n+                    // completely static.\n+                    !(\n+                      config.experimental.clientSegmentCache &&\n+                      config.experimental.clientParamParsing\n+                    )\n                   ) {\n                     return\n                   }\n@@ -3186,12 +3212,25 @@ export default async function build(\n                   dataRoute = path.posix.join(`${normalizedRoute}${RSC_SUFFIX}`)\n                 }\n \n-                let prefetchDataRoute: string | null | undefined\n+                let prefetchDataRoute: string | null = null\n                 // While we may only write the `.rsc` when the route does not\n                 // have PPR enabled, we still want to generate the route when\n                 // deployed so it doesn't 404. If the app has PPR enabled, we\n                 // should add this key.\n-                if (!isAppRouteHandler && isAppPPREnabled) {\n+                if (\n+                  !isAppRouteHandler &&\n+                  isAppPPREnabled &&\n+                  // Don't add a prefetch data route if we have both\n+                  // clientSegmentCache and clientParamParsing enabled. This is\n+                  // because we don't actually use the prefetch data route in\n+                  // this case. This only applies if we have PPR enabled for\n+                  // this route.\n+                  !(\n+                    config.experimental.clientSegmentCache &&\n+                    config.experimental.clientParamParsing &&\n+                    isRoutePPREnabled\n+                  )\n+                ) {\n                   prefetchDataRoute = path.posix.join(\n                     `${normalizedRoute}${RSC_PREFETCH_SUFFIX}`\n                   )\n@@ -3264,14 +3303,25 @@ export default async function build(\n                   dataRoute = path.posix.join(`${normalizedRoute}${RSC_SUFFIX}`)\n                 }\n \n-                let prefetchDataRoute: string | undefined\n+                let prefetchDataRoute: string | null = null\n                 let dynamicRoute = routesManifest.dynamicRoutes.find(\n                   (r) => r.page === route.pathname\n                 )\n                 if (!isAppRouteHandler && isAppPPREnabled) {\n-                  prefetchDataRoute = path.posix.join(\n-                    `${normalizedRoute}${RSC_PREFETCH_SUFFIX}`\n-                  )\n+                  if (\n+                    // Don't add a prefetch data route if we have both\n+                    // clientSegmentCache and clientParamParsing enabled. This is\n+                    // because we don't actually use the prefetch data route in\n+                    // this case. This only applies if we have PPR enabled for\n+                    // this route.\n+                    !config.experimental.clientSegmentCache ||\n+                    !config.experimental.clientParamParsing ||\n+                    !isRoutePPREnabled\n+                  ) {\n+                    prefetchDataRoute = path.posix.join(\n+                      `${normalizedRoute}${RSC_PREFETCH_SUFFIX}`\n+                    )\n+                  }\n \n                   // If the dynamic route wasn't found, then we need to create\n                   // it. This ensures that for each fallback shell there's an\n@@ -3416,9 +3466,12 @@ export default async function build(\n                   fallbackRootParams: fallback\n                     ? route.fallbackRootParams\n                     : undefined,\n-                  fallbackSourceRoute: route.fallbackRouteParams?.length\n-                    ? page\n-                    : undefined,\n+                  fallbackSourceRoute:\n+                    route.fallbackRouteParams &&\n+                    route.fallbackRouteParams.length > 0\n+                      ? page\n+                      : undefined,\n+                  fallbackRouteParams: route.fallbackRouteParams,\n                   dataRouteRegex: !dataRoute\n                     ? null\n                     : normalizeRouteRegex(\n@@ -3945,6 +3998,7 @@ export default async function build(\n             fallbackExpire: undefined,\n             fallbackSourceRoute: undefined,\n             fallbackRootParams: undefined,\n+            fallbackRouteParams: undefined,\n             dataRouteRegex: normalizeRouteRegex(\n               getNamedRouteRegex(dataRoute, {\n                 prefixRouteKeys: true,"
        },
        {
            "sha": "4403d156b33e4a466afda3f6a2a46028b8702498",
            "filename": "packages/next/src/build/segment-config/app/app-segments.ts",
            "status": "modified",
            "additions": 91,
            "deletions": 16,
            "changes": 107,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Fsegment-config%2Fapp%2Fapp-segments.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Fsegment-config%2Fapp%2Fapp-segments.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fsegment-config%2Fapp%2Fapp-segments.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -18,7 +18,9 @@ import {\n   type LoaderTree,\n } from '../../../server/lib/app-dir-module'\n import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n-import type { RouteModule } from '../../../server/route-modules/route-module'\n+import type { FallbackRouteParam } from '../../static-paths/types'\n+import { createFallbackRouteParam } from '../../static-paths/utils'\n+import type { DynamicParamTypes } from '../../../shared/lib/app-router-types'\n \n type GenerateStaticParams = (options: { params?: Params }) => Promise<Params[]>\n \n@@ -57,11 +59,18 @@ function attach(segment: AppSegment, userland: unknown, route: string) {\n \n export type AppSegment = {\n   name: string\n-  param: string | undefined\n+  paramName: string | undefined\n+  paramType: DynamicParamTypes | undefined\n   filePath: string | undefined\n   config: AppSegmentConfig | undefined\n   isDynamicSegment: boolean\n   generateStaticParams: GenerateStaticParams | undefined\n+\n+  /**\n+   * Whether this segment is a parallel route segment or descends from a\n+   * parallel route segment.\n+   */\n+  isParallelRouteSegment: boolean | undefined\n }\n \n /**\n@@ -75,27 +84,33 @@ async function collectAppPageSegments(routeModule: AppPageRouteModule) {\n   // to see the same segment multiple times.\n   const uniqueSegments = new Map<string, AppSegment>()\n \n-  // Queue will store tuples of [loaderTree, currentSegments]\n-  type QueueItem = [LoaderTree, AppSegment[]]\n-  const queue: QueueItem[] = [[routeModule.userland.loaderTree, []]]\n+  // Queue will store tuples of [loaderTree, currentSegments, isParallelRouteSegment]\n+  type QueueItem = [\n+    loaderTree: LoaderTree,\n+    currentSegments: AppSegment[],\n+    isParallelRouteSegment: boolean,\n+  ]\n+  const queue: QueueItem[] = [[routeModule.userland.loaderTree, [], false]]\n \n   while (queue.length > 0) {\n-    const [loaderTree, currentSegments] = queue.shift()!\n+    const [loaderTree, currentSegments, isParallelRouteSegment] = queue.shift()!\n     const [name, parallelRoutes] = loaderTree\n \n     // Process current node\n     const { mod: userland, filePath } = await getLayoutOrPageModule(loaderTree)\n     const isClientComponent = userland && isClientReference(userland)\n \n-    const param = getSegmentParam(name)?.param\n+    const { param: paramName, type: paramType } = getSegmentParam(name) ?? {}\n \n     const segment: AppSegment = {\n       name,\n-      param,\n+      paramName,\n+      paramType,\n       filePath,\n       config: undefined,\n-      isDynamicSegment: !!param,\n+      isDynamicSegment: !!paramName,\n       generateStaticParams: undefined,\n+      isParallelRouteSegment,\n     }\n \n     // Only server components can have app segment configurations\n@@ -123,15 +138,21 @@ async function collectAppPageSegments(routeModule: AppPageRouteModule) {\n     // Add all parallel routes to the queue\n     for (const parallelRouteKey in parallelRoutes) {\n       const parallelRoute = parallelRoutes[parallelRouteKey]\n-      queue.push([parallelRoute, updatedSegments])\n+      queue.push([\n+        parallelRoute,\n+        updatedSegments,\n+        // A parallel route segment is one that descends from a segment that is\n+        // not children or descends from a parallel route segment.\n+        isParallelRouteSegment || parallelRouteKey !== 'children',\n+      ])\n     }\n   }\n \n   return Array.from(uniqueSegments.values())\n }\n \n function getSegmentKey(segment: AppSegment) {\n-  return `${segment.name}-${segment.filePath ?? ''}-${segment.param ?? ''}`\n+  return `${segment.name}-${segment.filePath ?? ''}-${segment.paramName ?? ''}`\n }\n \n /**\n@@ -151,16 +172,18 @@ function collectAppRouteSegments(\n \n   // Generate all the segments.\n   const segments: AppSegment[] = parts.map((name) => {\n-    const param = getSegmentParam(name)?.param\n+    const { param: paramName, type: paramType } = getSegmentParam(name) ?? {}\n \n     return {\n       name,\n-      param,\n+      paramName,\n+      paramType,\n       filePath: undefined,\n-      isDynamicSegment: !!param,\n+      isDynamicSegment: !!paramName,\n       config: undefined,\n       generateStaticParams: undefined,\n-    }\n+      isParallelRouteSegment: undefined,\n+    } satisfies AppSegment\n   })\n \n   // We know we have at least one, we verified this above. We should get the\n@@ -182,7 +205,7 @@ function collectAppRouteSegments(\n  * @returns the segments for the route module\n  */\n export function collectSegments(\n-  routeModule: RouteModule\n+  routeModule: AppRouteRouteModule | AppPageRouteModule\n ): Promise<AppSegment[]> | AppSegment[] {\n   if (isAppRouteRouteModule(routeModule)) {\n     return collectAppRouteSegments(routeModule)\n@@ -196,3 +219,55 @@ export function collectSegments(\n     'Expected a route module to be one of app route or page'\n   )\n }\n+\n+/**\n+ * Collects the fallback route params for a given app page route module. This is\n+ * a variant of the `collectSegments` function that only collects the fallback\n+ * route params without importing anything.\n+ *\n+ * @param routeModule the app page route module\n+ * @returns the fallback route params for the app page route module\n+ */\n+export function collectFallbackRouteParams(\n+  routeModule: AppPageRouteModule\n+): readonly FallbackRouteParam[] {\n+  const uniqueSegments = new Map<string, FallbackRouteParam>()\n+\n+  // Queue will store tuples of [loaderTree, isParallelRouteSegment]\n+  type QueueItem = [loaderTree: LoaderTree, isParallelRouteSegment: boolean]\n+  const queue: QueueItem[] = [[routeModule.userland.loaderTree, false]]\n+\n+  while (queue.length > 0) {\n+    const [loaderTree, isParallelRouteSegment] = queue.shift()!\n+    const [name, parallelRoutes] = loaderTree\n+\n+    // Handle this segment (if it's a dynamic segment param).\n+    const segmentParam = getSegmentParam(name)\n+    if (segmentParam) {\n+      const key = `${name}-${segmentParam.param}`\n+      if (!uniqueSegments.has(key)) {\n+        uniqueSegments.set(\n+          key,\n+          createFallbackRouteParam(\n+            segmentParam.param,\n+            segmentParam.type,\n+            isParallelRouteSegment\n+          )\n+        )\n+      }\n+    }\n+\n+    // Add all of this segment's parallel routes to the queue.\n+    for (const parallelRouteKey in parallelRoutes) {\n+      const parallelRoute = parallelRoutes[parallelRouteKey]\n+      queue.push([\n+        parallelRoute,\n+        // A parallel route segment is one that descends from a segment that is\n+        // not children or descends from a parallel route segment.\n+        isParallelRouteSegment || parallelRouteKey !== 'children',\n+      ])\n+    }\n+  }\n+\n+  return Array.from(uniqueSegments.values())\n+}"
        },
        {
            "sha": "44d7f4482f3cbc707b31dea93089ac00add1df8c",
            "filename": "packages/next/src/build/static-paths/app.test.ts",
            "status": "modified",
            "additions": 478,
            "deletions": 39,
            "changes": 517,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -6,10 +6,12 @@ import {\n   calculateFallbackMode,\n   filterUniqueParams,\n   generateRouteStaticParams,\n+  resolveParallelRouteParams,\n } from './app'\n-import type { PrerenderedRoute } from './types'\n+import type { PrerenderedRoute, FallbackRouteParam } from './types'\n import type { WorkStore } from '../../server/app-render/work-async-storage.external'\n import type { AppSegment } from '../segment-config/app/app-segments'\n+import type { DynamicParamTypes } from '../../shared/lib/app-router-types'\n \n describe('assignErrorIfEmpty', () => {\n   it('should assign throwOnEmptyStaticShell true for a static route with no children', () => {\n@@ -36,7 +38,13 @@ describe('assignErrorIfEmpty', () => {\n         params: {},\n         pathname: '/[id]',\n         encodedPathname: '/[id]',\n-        fallbackRouteParams: ['id'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'id',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n@@ -52,7 +60,7 @@ describe('assignErrorIfEmpty', () => {\n       },\n     ]\n \n-    assignErrorIfEmpty(prerenderedRoutes, ['id'])\n+    assignErrorIfEmpty(prerenderedRoutes, [{ paramName: 'id' }])\n \n     expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false)\n     expect(prerenderedRoutes[1].throwOnEmptyStaticShell).toBe(true)\n@@ -64,7 +72,18 @@ describe('assignErrorIfEmpty', () => {\n         params: {},\n         pathname: '/[id]/[name]',\n         encodedPathname: '/[id]/[name]',\n-        fallbackRouteParams: ['id', 'name'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'id',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+          {\n+            paramName: 'name',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n@@ -73,7 +92,13 @@ describe('assignErrorIfEmpty', () => {\n         params: { id: '1' },\n         pathname: '/1/[name]',\n         encodedPathname: '/1/[name]',\n-        fallbackRouteParams: ['name'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'name',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n@@ -100,14 +125,23 @@ describe('assignErrorIfEmpty', () => {\n         params: { id: '2' },\n         pathname: '/2/[name]',\n         encodedPathname: '/2/[name]',\n-        fallbackRouteParams: ['name'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'name',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n       },\n     ]\n \n-    assignErrorIfEmpty(prerenderedRoutes, ['id', 'name'])\n+    assignErrorIfEmpty(prerenderedRoutes, [\n+      { paramName: 'id' },\n+      { paramName: 'name' },\n+    ])\n \n     expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false)\n     expect(prerenderedRoutes[1].throwOnEmptyStaticShell).toBe(false)\n@@ -122,7 +156,13 @@ describe('assignErrorIfEmpty', () => {\n         params: { id: '1' },\n         pathname: '/1/[name]',\n         encodedPathname: '/1/[name]',\n-        fallbackRouteParams: ['name'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'name',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n@@ -131,7 +171,18 @@ describe('assignErrorIfEmpty', () => {\n         params: { id: '1' },\n         pathname: '/1/[name]/[extra]',\n         encodedPathname: '/1/[name]/[extra]',\n-        fallbackRouteParams: ['name', 'extra'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'name',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+          {\n+            paramName: 'extra',\n+            paramType: 'catchall',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n@@ -147,7 +198,11 @@ describe('assignErrorIfEmpty', () => {\n       },\n     ]\n \n-    assignErrorIfEmpty(prerenderedRoutes, ['id', 'name', 'extra'])\n+    assignErrorIfEmpty(prerenderedRoutes, [\n+      { paramName: 'id' },\n+      { paramName: 'name' },\n+      { paramName: 'extra' },\n+    ])\n \n     expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false)\n     expect(prerenderedRoutes[1].throwOnEmptyStaticShell).toBe(false)\n@@ -166,7 +221,13 @@ describe('assignErrorIfEmpty', () => {\n         params: {},\n         pathname: '/blog/[slug]',\n         encodedPathname: '/blog/[slug]',\n-        fallbackRouteParams: ['slug'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'slug',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n@@ -191,7 +252,7 @@ describe('assignErrorIfEmpty', () => {\n       },\n     ]\n \n-    assignErrorIfEmpty(prerenderedRoutes, ['slug'])\n+    assignErrorIfEmpty(prerenderedRoutes, [{ paramName: 'slug' }])\n \n     expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false) // Should not throw - has concrete children\n     expect(prerenderedRoutes[1].throwOnEmptyStaticShell).toBe(true) // Should throw - concrete route\n@@ -204,7 +265,18 @@ describe('assignErrorIfEmpty', () => {\n         params: {},\n         pathname: '/[id]/[...slug]',\n         encodedPathname: '/[id]/[...slug]',\n-        fallbackRouteParams: ['id', 'slug'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'id',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+          {\n+            paramName: 'slug',\n+            paramType: 'catchall',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n@@ -213,7 +285,13 @@ describe('assignErrorIfEmpty', () => {\n         params: { id: '1234' },\n         pathname: '/1234/[...slug]',\n         encodedPathname: '/1234/[...slug]',\n-        fallbackRouteParams: ['slug'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'slug',\n+            paramType: 'catchall',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n@@ -229,7 +307,10 @@ describe('assignErrorIfEmpty', () => {\n       },\n     ]\n \n-    assignErrorIfEmpty(prerenderedRoutes, ['id', 'slug'])\n+    assignErrorIfEmpty(prerenderedRoutes, [\n+      { paramName: 'id' },\n+      { paramName: 'slug' },\n+    ])\n \n     expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false) // Should not throw - has children\n     expect(prerenderedRoutes[1].throwOnEmptyStaticShell).toBe(false) // Should not throw - has children\n@@ -242,7 +323,23 @@ describe('assignErrorIfEmpty', () => {\n         params: {},\n         pathname: '/[category]/[subcategory]/[item]',\n         encodedPathname: '/[category]/[subcategory]/[item]',\n-        fallbackRouteParams: ['category', 'subcategory', 'item'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'category',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+          {\n+            paramName: 'subcategory',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+          {\n+            paramName: 'item',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n@@ -251,7 +348,18 @@ describe('assignErrorIfEmpty', () => {\n         params: { category: 'electronics' },\n         pathname: '/electronics/[subcategory]/[item]',\n         encodedPathname: '/electronics/[subcategory]/[item]',\n-        fallbackRouteParams: ['subcategory', 'item'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'subcategory',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+          {\n+            paramName: 'item',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n@@ -260,7 +368,13 @@ describe('assignErrorIfEmpty', () => {\n         params: { category: 'electronics', subcategory: 'phones' },\n         pathname: '/electronics/phones/[item]',\n         encodedPathname: '/electronics/phones/[item]',\n-        fallbackRouteParams: ['item'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'item',\n+            paramType: 'dynamic',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n@@ -280,7 +394,11 @@ describe('assignErrorIfEmpty', () => {\n       },\n     ]\n \n-    assignErrorIfEmpty(prerenderedRoutes, ['category', 'subcategory', 'item'])\n+    assignErrorIfEmpty(prerenderedRoutes, [\n+      { paramName: 'category' },\n+      { paramName: 'subcategory' },\n+      { paramName: 'item' },\n+    ])\n \n     // All except the last one should not throw on empty static shell\n     expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false)\n@@ -295,7 +413,13 @@ describe('assignErrorIfEmpty', () => {\n         params: { locale: 'en' },\n         pathname: '/en/[...segments]',\n         encodedPathname: '/en/[...segments]',\n-        fallbackRouteParams: ['segments'],\n+        fallbackRouteParams: [\n+          {\n+            paramName: 'segments',\n+            paramType: 'catchall',\n+            isParallelRouteParam: false,\n+          },\n+        ],\n         fallbackMode: FallbackMode.NOT_FOUND,\n         fallbackRootParams: [],\n         throwOnEmptyStaticShell: true,\n@@ -311,7 +435,10 @@ describe('assignErrorIfEmpty', () => {\n       },\n     ]\n \n-    assignErrorIfEmpty(prerenderedRoutes, ['locale', 'segments'])\n+    assignErrorIfEmpty(prerenderedRoutes, [\n+      { paramName: 'locale' },\n+      { paramName: 'segments' },\n+    ])\n \n     // The route with more fallback params should not throw on empty static shell\n     expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false)\n@@ -327,7 +454,10 @@ describe('filterUniqueParams', () => {\n       { id: '2' },\n     ]\n \n-    const unique = filterUniqueParams(['id', 'name'], params)\n+    const unique = filterUniqueParams(\n+      [{ paramName: 'id' }, { paramName: 'name' }],\n+      params\n+    )\n \n     expect(unique).toEqual([{ id: '1', name: 'test' }, { id: '2' }])\n   })\n@@ -339,7 +469,10 @@ describe('filterUniqueParams', () => {\n       { id: '2', name: 'test', age: '10' },\n     ]\n \n-    const unique = filterUniqueParams(['id', 'name', 'age'], params)\n+    const unique = filterUniqueParams(\n+      [{ paramName: 'id' }, { paramName: 'name' }, { paramName: 'age' }],\n+      params\n+    )\n \n     expect(unique).toEqual([\n       { id: '1', name: 'test', age: '10' },\n@@ -357,7 +490,11 @@ describe('generateParamPrefixCombinations', () => {\n       { id: '2', name: 'test' },\n     ]\n \n-    const unique = generateAllParamCombinations(['id'], params, [])\n+    const unique = generateAllParamCombinations(\n+      [{ paramName: 'id' }],\n+      params,\n+      []\n+    )\n \n     expect(unique).toEqual([{ id: '1' }, { id: '2' }])\n   })\n@@ -370,7 +507,11 @@ describe('generateParamPrefixCombinations', () => {\n       { lang: 'fr', region: 'CA', page: 'about' },\n     ]\n \n-    const unique = generateAllParamCombinations(['lang', 'region'], params, [])\n+    const unique = generateAllParamCombinations(\n+      [{ paramName: 'lang' }, { paramName: 'region' }],\n+      params,\n+      []\n+    )\n \n     expect(unique).toEqual([\n       { lang: 'en' },\n@@ -383,7 +524,11 @@ describe('generateParamPrefixCombinations', () => {\n   it('should handle parameter value collisions', () => {\n     const params = [{ slug: ['foo', 'bar'] }, { slug: 'foo,bar' }]\n \n-    const unique = generateAllParamCombinations(['slug'], params, [])\n+    const unique = generateAllParamCombinations(\n+      [{ paramName: 'slug' }],\n+      params,\n+      []\n+    )\n \n     expect(unique).toEqual([{ slug: ['foo', 'bar'] }, { slug: 'foo,bar' }])\n   })\n@@ -393,7 +538,9 @@ describe('generateParamPrefixCombinations', () => {\n     expect(generateAllParamCombinations([], [{ id: '1' }], [])).toEqual([])\n \n     // Empty routeParams\n-    expect(generateAllParamCombinations(['id'], [], [])).toEqual([])\n+    expect(generateAllParamCombinations([{ paramName: 'id' }], [], [])).toEqual(\n+      []\n+    )\n \n     // Both empty\n     expect(generateAllParamCombinations([], [], [])).toEqual([])\n@@ -406,7 +553,11 @@ describe('generateParamPrefixCombinations', () => {\n       { id: '3' }, // missing name key\n     ]\n \n-    const unique = generateAllParamCombinations(['id', 'name'], params, [])\n+    const unique = generateAllParamCombinations(\n+      [{ paramName: 'id' }, { paramName: 'name' }],\n+      params,\n+      []\n+    )\n \n     expect(unique).toEqual([\n       { id: '1' },\n@@ -424,7 +575,11 @@ describe('generateParamPrefixCombinations', () => {\n     ]\n \n     const unique = generateAllParamCombinations(\n-      ['lang', 'region', 'category'],\n+      [\n+        { paramName: 'lang' },\n+        { paramName: 'region' },\n+        { paramName: 'category' },\n+      ],\n       params,\n       []\n     )\n@@ -447,7 +602,11 @@ describe('generateParamPrefixCombinations', () => {\n       { slug: 'U:undefined' }, // String that looks like undefined prefix\n     ]\n \n-    const unique = generateAllParamCombinations(['slug'], params, [])\n+    const unique = generateAllParamCombinations(\n+      [{ paramName: 'slug' }],\n+      params,\n+      []\n+    )\n \n     expect(unique).toEqual([\n       { slug: ['foo', 'bar'] },\n@@ -465,7 +624,11 @@ describe('generateParamPrefixCombinations', () => {\n       { slug: ['foo', 'bar|baz'] }, // Array with pipe in element\n     ]\n \n-    const unique = generateAllParamCombinations(['slug'], params, [])\n+    const unique = generateAllParamCombinations(\n+      [{ paramName: 'slug' }],\n+      params,\n+      []\n+    )\n \n     expect(unique).toEqual([{ slug: 'foo|bar' }, { slug: ['foo', 'bar|baz'] }])\n   })\n@@ -478,7 +641,13 @@ describe('generateParamPrefixCombinations', () => {\n     ]\n \n     const unique = generateAllParamCombinations(\n-      ['a', 'b', 'c', 'd', 'e'],\n+      [\n+        { paramName: 'a' },\n+        { paramName: 'b' },\n+        { paramName: 'c' },\n+        { paramName: 'd' },\n+        { paramName: 'e' },\n+      ],\n       params,\n       []\n     )\n@@ -503,7 +672,7 @@ describe('generateParamPrefixCombinations', () => {\n     ]\n \n     const unique = generateAllParamCombinations(\n-      ['lang', 'region', 'slug'],\n+      [{ paramName: 'lang' }, { paramName: 'region' }, { paramName: 'slug' }],\n       params,\n       ['lang', 'region'] // Root params\n     )\n@@ -527,7 +696,7 @@ describe('generateParamPrefixCombinations', () => {\n     ]\n \n     const unique = generateAllParamCombinations(\n-      ['category', 'slug'],\n+      [{ paramName: 'category' }, { paramName: 'slug' }],\n       params,\n       [] // No root params\n     )\n@@ -550,7 +719,7 @@ describe('generateParamPrefixCombinations', () => {\n     ]\n \n     const unique = generateAllParamCombinations(\n-      ['lang', 'page'],\n+      [{ paramName: 'lang' }, { paramName: 'page' }],\n       params,\n       ['lang'] // Single root param\n     )\n@@ -573,7 +742,7 @@ describe('generateParamPrefixCombinations', () => {\n     ]\n \n     const unique = generateAllParamCombinations(\n-      ['lang', 'page'],\n+      [{ paramName: 'lang' }, { paramName: 'page' }],\n       params,\n       ['lang'] // Root param\n     )\n@@ -594,7 +763,7 @@ describe('generateParamPrefixCombinations', () => {\n     ]\n \n     const unique = generateAllParamCombinations(\n-      ['category', 'slug'],\n+      [{ paramName: 'category' }, { paramName: 'slug' }],\n       params,\n       ['lang', 'region'] // Root params not in route params\n     )\n@@ -618,7 +787,7 @@ describe('generateParamPrefixCombinations', () => {\n     ]\n \n     const unique = generateAllParamCombinations(\n-      ['lang', 'locale', 'slug'], // All route params\n+      [{ paramName: 'lang' }, { paramName: 'locale' }, { paramName: 'slug' }], // All route params\n       params,\n       ['lang', 'locale'] // Root params\n     )\n@@ -635,7 +804,7 @@ describe('generateParamPrefixCombinations', () => {\n     const params: Params[] = [] // No generateStaticParams results\n \n     const unique = generateAllParamCombinations(\n-      ['lang', 'locale', 'slug'], // All route params\n+      [{ paramName: 'lang' }, { paramName: 'locale' }, { paramName: 'slug' }], // All route params\n       params,\n       ['lang', 'locale'] // Root params\n     )\n@@ -1094,3 +1263,273 @@ describe('calculateFallbackMode', () => {\n     expect(result).toBe(FallbackMode.BLOCKING_STATIC_RENDER)\n   })\n })\n+\n+describe('resolveParallelRouteParams', () => {\n+  function createParallelRouteSegment(\n+    paramName: string,\n+    paramType: DynamicParamTypes\n+  ): {\n+    name: string\n+    paramName: string\n+    paramType: DynamicParamTypes\n+  } {\n+    return {\n+      name: `@${paramName}`,\n+      paramName,\n+      paramType,\n+    }\n+  }\n+\n+  function createFallbackParam(\n+    paramName: string,\n+    isParallelRouteParam: boolean,\n+    paramType: DynamicParamTypes = 'dynamic'\n+  ): FallbackRouteParam {\n+    return { paramName, paramType, isParallelRouteParam }\n+  }\n+\n+  describe('direct match case', () => {\n+    it('should skip processing when param already exists in params object', () => {\n+      const parallelRouteSegments = [\n+        createParallelRouteSegment('existingParam', 'dynamic'),\n+      ]\n+      const params: Params = { existingParam: 'value' }\n+      const pathname = '/some/path'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        parallelRouteSegments,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.existingParam).toBe('value')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should skip processing for multiple existing params', () => {\n+      const parallelRouteSegments = [\n+        createParallelRouteSegment('param1', 'dynamic'),\n+        createParallelRouteSegment('param2', 'catchall'),\n+      ]\n+      const params: Params = { param1: 'value1', param2: ['a', 'b'] }\n+      const pathname = '/some/path'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        parallelRouteSegments,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.param1).toBe('value1')\n+      expect(params.param2).toEqual(['a', 'b'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('catchall with non-parallel fallback params', () => {\n+    it('should add to fallbackRouteParams when non-parallel fallback params exist', () => {\n+      const parallelRouteSegments = [\n+        createParallelRouteSegment('catchallParam', 'catchall'),\n+      ]\n+      const params: Params = {}\n+      const pathname = '/some/path/segments'\n+      const fallbackRouteParams: FallbackRouteParam[] = [\n+        createFallbackParam('regularParam', false), // Non-parallel fallback param\n+      ]\n+\n+      resolveParallelRouteParams(\n+        parallelRouteSegments,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.catchallParam).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(2)\n+      expect(fallbackRouteParams[1]).toEqual({\n+        paramName: 'catchallParam',\n+        paramType: 'catchall',\n+        isParallelRouteParam: true,\n+      })\n+    })\n+  })\n+\n+  describe('optional-catchall with non-parallel fallback params', () => {\n+    it('should add to fallbackRouteParams when non-parallel fallback params exist', () => {\n+      const parallelRouteSegments = [\n+        createParallelRouteSegment('optionalCatchall', 'optional-catchall'),\n+      ]\n+      const params: Params = {}\n+      const pathname = '/some/path'\n+      const fallbackRouteParams: FallbackRouteParam[] = [\n+        createFallbackParam('regularParam', false), // Non-parallel fallback param\n+      ]\n+\n+      resolveParallelRouteParams(\n+        parallelRouteSegments,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.optionalCatchall).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(2)\n+      expect(fallbackRouteParams[1]).toEqual({\n+        paramName: 'optionalCatchall',\n+        paramType: 'optional-catchall',\n+        isParallelRouteParam: true,\n+      })\n+    })\n+  })\n+\n+  describe('catchall deriving from pathname', () => {\n+    it('should populate params with path segments when no non-parallel fallback params', () => {\n+      const parallelRouteSegments = [\n+        createParallelRouteSegment('catchallParam', 'catchall'),\n+      ]\n+      const params: Params = {}\n+      const pathname = '/blog/2023/posts/my-article'\n+      const fallbackRouteParams: FallbackRouteParam[] = [\n+        createFallbackParam('parallelParam', true), // Only parallel fallback params\n+      ]\n+\n+      resolveParallelRouteParams(\n+        parallelRouteSegments,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.catchallParam).toEqual([\n+        'blog',\n+        '2023',\n+        'posts',\n+        'my-article',\n+      ])\n+      expect(fallbackRouteParams).toHaveLength(1) // No new fallback params added\n+    })\n+\n+    it('should handle single path segment', () => {\n+      const parallelRouteSegments = [\n+        createParallelRouteSegment('catchallParam', 'catchall'),\n+      ]\n+      const params: Params = {}\n+      const pathname = '/single'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        parallelRouteSegments,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.catchallParam).toEqual(['single'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('optional-catchall with empty pathname', () => {\n+    it('should set params to empty array when pathname has no segments', () => {\n+      const parallelRouteSegments = [\n+        createParallelRouteSegment('optionalCatchall', 'optional-catchall'),\n+      ]\n+      const params: Params = {}\n+      const pathname = '/'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        parallelRouteSegments,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.optionalCatchall).toEqual([])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should set params to empty array when pathname is empty string', () => {\n+      const parallelRouteSegments = [\n+        createParallelRouteSegment('optionalCatchall', 'optional-catchall'),\n+      ]\n+      const params: Params = {}\n+      const pathname = '/'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        parallelRouteSegments,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.optionalCatchall).toEqual([])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('optional-catchall with non-empty pathname', () => {\n+    it('should populate params with path segments', () => {\n+      const parallelRouteSegments = [\n+        createParallelRouteSegment('optionalCatchall', 'optional-catchall'),\n+      ]\n+      const params: Params = {}\n+      const pathname = '/api/v1/users'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        parallelRouteSegments,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.optionalCatchall).toEqual(['api', 'v1', 'users'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  it('should throw error for catchall with empty pathname', () => {\n+    const parallelRouteSegments = [\n+      createParallelRouteSegment('catchallParam', 'catchall'),\n+    ]\n+    const params: Params = {}\n+    const pathname = '/'\n+    const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+    expect(() =>\n+      resolveParallelRouteParams(\n+        parallelRouteSegments,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+    ).toThrow()\n+  })\n+\n+  describe('edge cases', () => {\n+    it('should throw error for catchall with empty path segments', () => {\n+      const parallelRouteSegments = [\n+        createParallelRouteSegment('catchall', 'catchall'),\n+        createParallelRouteSegment('optional', 'optional-catchall'),\n+      ]\n+      const params: Params = {}\n+      const pathname = '///'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      expect(() =>\n+        resolveParallelRouteParams(\n+          parallelRouteSegments,\n+          params,\n+          pathname,\n+          fallbackRouteParams\n+        )\n+      ).toThrow()\n+    })\n+  })\n+})"
        },
        {
            "sha": "4abb7951e1cd3b82bd73469894aee572c98a5030",
            "filename": "packages/next/src/build/static-paths/app.ts",
            "status": "modified",
            "additions": 217,
            "deletions": 45,
            "changes": 262,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -1,34 +1,43 @@\n import type { Params } from '../../server/request/params'\n import type { AppPageModule } from '../../server/route-modules/app-page/module'\n import type { AppSegment } from '../segment-config/app/app-segments'\n-import type { PrerenderedRoute, StaticPathsResult } from './types'\n+import type {\n+  FallbackRouteParam,\n+  PrerenderedRoute,\n+  StaticPathsResult,\n+} from './types'\n \n import path from 'node:path'\n import { AfterRunner } from '../../server/after/run-with-after'\n import { createWorkStore } from '../../server/async-storage/work-store'\n import { FallbackMode } from '../../lib/fallback'\n-import { getRouteMatcher } from '../../shared/lib/router/utils/route-matcher'\n import {\n   getRouteRegex,\n   type RouteRegex,\n } from '../../shared/lib/router/utils/route-regex'\n import type { IncrementalCache } from '../../server/lib/incremental-cache'\n-import { normalizePathname, encodeParam } from './utils'\n+import {\n+  normalizePathname,\n+  encodeParam,\n+  createFallbackRouteParam,\n+} from './utils'\n import escapePathDelimiters from '../../shared/lib/router/utils/escape-path-delimiters'\n import { createIncrementalCache } from '../../export/helpers/create-incremental-cache'\n import type { NextConfigComplete } from '../../server/config-shared'\n import type { WorkStore } from '../../server/app-render/work-async-storage.external'\n+import type { DynamicParamTypes } from '../../shared/lib/app-router-types'\n+import { InvariantError } from '../../shared/lib/invariant-error'\n \n /**\n  * Filters out duplicate parameters from a list of parameters.\n  * This function uses a Map to efficiently store and retrieve unique parameter combinations.\n  *\n- * @param routeParamKeys - The keys of the parameters. These should be sorted to ensure consistent key generation.\n+ * @param childrenRouteParams - The keys of the parameters. These should be sorted to ensure consistent key generation.\n  * @param routeParams - The list of parameter objects to filter.\n  * @returns A new array containing only the unique parameter combinations.\n  */\n export function filterUniqueParams(\n-  routeParamKeys: readonly string[],\n+  childrenRouteParams: readonly { paramName: string }[],\n   routeParams: readonly Params[]\n ): Params[] {\n   // A Map is used to store unique parameter combinations. The key of the Map\n@@ -43,7 +52,7 @@ export function filterUniqueParams(\n     // Iterate through the `routeParamKeys` (which are assumed to be sorted).\n     // This consistent order is crucial for generating a stable and unique key\n     // for each parameter combination.\n-    for (const paramKey of routeParamKeys) {\n+    for (const { paramName: paramKey } of childrenRouteParams) {\n       const value = params[paramKey]\n \n       // Construct a part of the key using the parameter key and its value.\n@@ -112,15 +121,17 @@ export function filterUniqueParams(\n  * For routes without Root Parameters (e.g., `/[slug]`), all sub-combinations are generated\n  * as before.\n  *\n- * @param routeParamKeys - The keys of the Route Parameters. These should be sorted\n+ * @param childrenRouteParams - The children route params. These should be sorted\n  *   to ensure consistent key generation for the internal Map.\n  * @param routeParams - The list of Static Parameters to filter.\n  * @param rootParamKeys - The keys of the Root Parameters. When provided, ensures Static Shells\n  *   include all Root Parameters.\n  * @returns A new array containing all unique sub-combinations of Route Parameters.\n  */\n export function generateAllParamCombinations(\n-  routeParamKeys: readonly string[],\n+  childrenRouteParams: ReadonlyArray<{\n+    readonly paramName: string\n+  }>,\n   routeParams: readonly Params[],\n   rootParamKeys: readonly string[]\n ): Params[] {\n@@ -143,7 +154,9 @@ export function generateAllParamCombinations(\n     // Find the index of the last Root Parameter in routeParamKeys.\n     // This tells us the minimum combination length needed to include all Root Parameters.\n     for (const rootParamKey of rootParamKeys) {\n-      const index = routeParamKeys.indexOf(rootParamKey)\n+      const index = childrenRouteParams.findIndex(\n+        (param) => param.paramName === rootParamKey\n+      )\n       if (index === -1) {\n         // Root Parameter not found in Route Parameters - this shouldn't happen in normal cases\n         // but we handle it gracefully by treating it as if there are no Root Parameters.\n@@ -171,7 +184,7 @@ export function generateAllParamCombinations(\n     //\n     // The iteration order is crucial for generating stable and unique keys\n     // for each Route Parameter combination.\n-    for (let i = 0; i < routeParamKeys.length; i++) {\n+    for (let i = 0; i < childrenRouteParams.length; i++) {\n       // Skip generating combinations that don't include all Root Parameters.\n       // This prevents creating invalid Static Shells that are missing required Root Parameters.\n       //\n@@ -198,7 +211,7 @@ export function generateAllParamCombinations(\n       // - j=1: Add 'region' parameter\n       // Result: { lang: 'en', region: 'US' }\n       for (let j = 0; j <= i; j++) {\n-        const routeKey = routeParamKeys[j]\n+        const { paramName: routeKey } = childrenRouteParams[j]\n \n         // Check if the parameter exists in the original params object and has a defined value.\n         // This handles cases where generateStaticParams doesn't provide all possible parameters,\n@@ -288,7 +301,7 @@ export function calculateFallbackMode(\n  * @param page - The page to validate.\n  * @param regex - The route regex.\n  * @param isRoutePPREnabled - Whether the route has partial prerendering enabled.\n- * @param routeParamKeys - The keys of the parameters.\n+ * @param childrenRouteParams - The keys of the parameters.\n  * @param rootParamKeys - The keys of the root params.\n  * @param routeParams - The list of parameters to validate.\n  * @returns The list of validated parameters.\n@@ -297,7 +310,9 @@ function validateParams(\n   page: string,\n   regex: RouteRegex,\n   isRoutePPREnabled: boolean,\n-  routeParamKeys: readonly string[],\n+  childrenRouteParams: ReadonlyArray<{\n+    readonly paramName: string\n+  }>,\n   rootParamKeys: readonly string[],\n   routeParams: readonly Params[]\n ): Params[] {\n@@ -327,7 +342,7 @@ function validateParams(\n   for (const params of routeParams) {\n     const item: Params = {}\n \n-    for (const key of routeParamKeys) {\n+    for (const { paramName: key } of childrenRouteParams) {\n       const { repeat, optional } = regex.groups[key]\n \n       let paramValue = params[key]\n@@ -399,11 +414,13 @@ interface TrieNode {\n  * `/blog/[slug]` should not throw because `/blog/first-post` is a more specific concrete route.\n  *\n  * @param prerenderedRoutes - The prerendered routes.\n- * @param routeParamKeys - The keys of the route parameters.\n+ * @param childrenRouteParams - The keys of the route parameters.\n  */\n export function assignErrorIfEmpty(\n   prerenderedRoutes: readonly PrerenderedRoute[],\n-  routeParamKeys: readonly string[]\n+  childrenRouteParams: ReadonlyArray<{\n+    readonly paramName: string\n+  }>\n ): void {\n   // If there are no routes to process, exit early.\n   if (prerenderedRoutes.length === 0) {\n@@ -424,7 +441,7 @@ export function assignErrorIfEmpty(\n     // for ensuring that routes with the same concrete parameters follow the\n     // same path in the Trie, regardless of the original order of properties\n     // in the `params` object.\n-    for (const key of routeParamKeys) {\n+    for (const { paramName: key } of childrenRouteParams) {\n       // Check if the current route actually has a concrete value for this parameter.\n       // If a dynamic segment is not filled (i.e., it's a fallback), it won't have\n       // this property, and we stop building the path for this route at this point.\n@@ -492,7 +509,7 @@ export function assignErrorIfEmpty(\n         // might be `undefined` or `null`, treating them as 0 length.\n         minFallbacks = Math.min(\n           minFallbacks,\n-          r.fallbackRouteParams?.length ?? 0\n+          r.fallbackRouteParams ? r.fallbackRouteParams.length : 0\n         )\n       }\n \n@@ -530,6 +547,83 @@ export function assignErrorIfEmpty(\n   }\n }\n \n+/**\n+ * Resolves parallel route parameters from regular route parameters. This function\n+ * handles the complex logic of determining how to populate parallel route params\n+ * based on their type (catchall, optional-catchall, or regular) and the current\n+ * state of fallback parameters.\n+ *\n+ * @param parallelRouteSegments - Array of parallel route segments with their types and param names\n+ * @param params - The current route parameters object (will be mutated)\n+ * @param pathname - The current pathname being processed\n+ * @param fallbackRouteParams - Array of fallback route parameters (will be mutated)\n+ */\n+export function resolveParallelRouteParams(\n+  parallelRouteSegments: ReadonlyArray<{\n+    readonly paramName: string\n+    readonly paramType: DynamicParamTypes\n+  }>,\n+  params: Params,\n+  pathname: string,\n+  fallbackRouteParams: FallbackRouteParam[]\n+): void {\n+  // Resolve parallel route params from the regular route params\n+  for (const { paramType, paramName } of parallelRouteSegments) {\n+    // Check if we can resolve this from existing params\n+    if (params[paramName]) {\n+      // Direct match - the param name exists in regular params\n+      continue\n+    }\n+\n+    if (paramType === 'catchall' || paramType === 'optional-catchall') {\n+      // If there are any fallback route segments then we can't use the\n+      // pathname to derive the value because it's not complete. We can\n+      // make this assumption because the routes are always resolved left\n+      // to right and the catchall is always the last segment, so any\n+      // route parameters that are unknown will always contribute to the\n+      // pathname and therefore the catchall param too.\n+      if (fallbackRouteParams.some((param) => !param.isParallelRouteParam)) {\n+        fallbackRouteParams.push(\n+          createFallbackRouteParam(paramName, paramType, true)\n+        )\n+        continue\n+      }\n+\n+      // For catchall routes in parallel segments, derive from pathname\n+      // Similar to getDynamicParam's pagePath parsing logic\n+      const pathSegments = pathname.split('/').filter(Boolean)\n+\n+      // For catchall parallel routes, we use the full path segments\n+      // This mimics the behavior in getDynamicParam where the pagePath\n+      // is split and used to populate catchall values\n+      if (pathSegments.length > 0) {\n+        // FIXME: (NAR-335) this should handle prefixed segments\n+        params[paramName] = pathSegments\n+      } else if (paramType === 'optional-catchall') {\n+        params[paramName] = []\n+      } else {\n+        // We shouldn't be able to match a catchall segment without any path\n+        // segments if it's not an optional catchall.\n+        throw new InvariantError(\n+          `Unexpected empty path segments match for a pathname \"${pathname}\" with param \"${paramName}\" of type \"${paramType}\"`\n+        )\n+      }\n+    } else if (paramType === 'dynamic') {\n+      // We can't resolve dynamic param values at build time because they're\n+      // inferred from the request pathname.\n+      fallbackRouteParams.push(\n+        createFallbackRouteParam(paramName, paramType, true)\n+      )\n+    } else {\n+      // This is some other type of route param that shouldn't get resolved\n+      // statically.\n+      throw new InvariantError(\n+        `Unexpected match for a pathname \"${pathname}\" with a param \"${paramName}\" of type \"${paramType}\"`\n+      )\n+    }\n+  }\n+}\n+\n /**\n  * Processes app directory segments to build route parameters from generateStaticParams functions.\n  * This function walks through the segments array and calls generateStaticParams for each segment that has it,\n@@ -541,7 +635,9 @@ export function assignErrorIfEmpty(\n  * @returns Promise that resolves to an array of all parameter combinations\n  */\n export async function generateRouteStaticParams(\n-  segments: Pick<AppSegment, 'config' | 'generateStaticParams'>[],\n+  segments: ReadonlyArray<\n+    Readonly<Pick<AppSegment, 'config' | 'generateStaticParams'>>\n+  >,\n   store: Pick<WorkStore, 'fetchCache'>\n ): Promise<Params[]> {\n   // Early return if no segments to process\n@@ -641,7 +737,7 @@ export async function buildAppStaticPaths({\n   page: string\n   cacheComponents: boolean\n   authInterrupts: boolean\n-  segments: AppSegment[]\n+  segments: readonly Readonly<AppSegment>[]\n   distDir: string\n   isrFlushToDisk?: boolean\n   fetchCacheKeyPrefix?: string\n@@ -681,7 +777,48 @@ export async function buildAppStaticPaths({\n   })\n \n   const regex = getRouteRegex(page)\n-  const routeParamKeys = Object.keys(getRouteMatcher(regex)(page) || {})\n+\n+  const childrenRouteParamSegments: Array<{\n+    readonly name: string\n+    readonly paramName: string\n+    readonly paramType: DynamicParamTypes\n+  }> = []\n+  const parallelRouteSegments: Array<{\n+    readonly name: string\n+    readonly paramName: string\n+    readonly paramType: DynamicParamTypes\n+  }> = []\n+\n+  // These are all the parallel fallback route params that will be included when\n+  // we're emitting the route for the base route.\n+  const parallelFallbackRouteParams: FallbackRouteParam[] = []\n+\n+  for (const segment of segments) {\n+    // If this segment doesn't have a param name then it's not param that we\n+    // need to resolve.\n+    if (!segment.paramName || !segment.paramType) continue\n+\n+    if (segment.isParallelRouteSegment) {\n+      // Collect all the parallel route segments that have dynamic params for\n+      // second-pass resolution.\n+      parallelRouteSegments.push({\n+        name: segment.name,\n+        paramName: segment.paramName,\n+        paramType: segment.paramType,\n+      })\n+      parallelFallbackRouteParams.push(\n+        createFallbackRouteParam(segment.paramName, segment.paramType, true)\n+      )\n+    } else {\n+      // Collect all the route param keys that are not parallel route params.\n+      // These are the ones that will be included in the request pathname.\n+      childrenRouteParamSegments.push({\n+        name: segment.name,\n+        paramName: segment.paramName,\n+        paramType: segment.paramType,\n+      })\n+    }\n+  }\n \n   const afterRunner = new AfterRunner()\n \n@@ -715,19 +852,19 @@ export async function buildAppStaticPaths({\n     // Check to see if there are any missing params for segments that have\n     // dynamicParams set to false.\n     if (\n-      segment.param &&\n+      segment.paramName &&\n       segment.isDynamicSegment &&\n       segment.config?.dynamicParams === false\n     ) {\n       for (const params of routeParams) {\n-        if (segment.param in params) continue\n+        if (segment.paramName in params) continue\n \n         const relative = segment.filePath\n           ? path.relative(dir, segment.filePath)\n           : undefined\n \n         throw new Error(\n-          `Segment \"${relative}\" exports \"dynamicParams: false\" but the param \"${segment.param}\" is missing from the generated route params.`\n+          `Segment \"${relative}\" exports \"dynamicParams: false\" but the param \"${segment.paramName}\" is missing from the generated route params.`\n         )\n       }\n     }\n@@ -744,11 +881,11 @@ export async function buildAppStaticPaths({\n \n   // Determine if all the segments have had their parameters provided.\n   const hadAllParamsGenerated =\n-    routeParamKeys.length === 0 ||\n+    childrenRouteParamSegments.length === 0 ||\n     (routeParams.length > 0 &&\n       routeParams.every((params) => {\n-        for (const key of routeParamKeys) {\n-          if (key in params) continue\n+        for (const { paramName } of childrenRouteParamSegments) {\n+          if (paramName in params) continue\n           return false\n         }\n         return true\n@@ -776,13 +913,13 @@ export async function buildAppStaticPaths({\n \n   // Precompile the regex patterns for the route params.\n   const paramPatterns = new Map<string, string>()\n-  for (const key of routeParamKeys) {\n-    const { repeat, optional } = regex.groups[key]\n-    let pattern = `[${repeat ? '...' : ''}${key}]`\n+  for (const { paramName } of childrenRouteParamSegments) {\n+    const { repeat, optional } = regex.groups[paramName]\n+    let pattern = `[${repeat ? '...' : ''}${paramName}]`\n     if (optional) {\n       pattern = `[${pattern}]`\n     }\n-    paramPatterns.set(key, pattern)\n+    paramPatterns.set(paramName, pattern)\n   }\n \n   // Convert rootParamKeys to Set for O(1) lookup.\n@@ -796,18 +933,27 @@ export async function buildAppStaticPaths({\n       // routes that won't throw on empty static shell for each of them if\n       // they're available.\n       paramsToProcess = generateAllParamCombinations(\n-        routeParamKeys,\n+        childrenRouteParamSegments,\n         routeParams,\n         rootParamKeys\n       )\n \n+      // The fallback route params for this route is a combination of the\n+      // parallel route params and the non-parallel route params.\n+      const fallbackRouteParams: readonly FallbackRouteParam[] = [\n+        ...childrenRouteParamSegments.map(({ paramName, paramType: type }) =>\n+          createFallbackRouteParam(paramName, type, false)\n+        ),\n+        ...parallelFallbackRouteParams,\n+      ]\n+\n       // Add the base route, this is the route with all the placeholders as it's\n       // derived from the `page` string.\n       prerenderedRoutesByPathname.set(page, {\n         params: {},\n         pathname: page,\n         encodedPathname: page,\n-        fallbackRouteParams: routeParamKeys,\n+        fallbackRouteParams,\n         fallbackMode: calculateFallbackMode(\n           dynamicParams,\n           rootParamKeys,\n@@ -819,34 +965,46 @@ export async function buildAppStaticPaths({\n     }\n \n     filterUniqueParams(\n-      routeParamKeys,\n+      childrenRouteParamSegments,\n       validateParams(\n         page,\n         regex,\n         isRoutePPREnabled,\n-        routeParamKeys,\n+        childrenRouteParamSegments,\n         rootParamKeys,\n         paramsToProcess\n       )\n     ).forEach((params) => {\n       let pathname = page\n       let encodedPathname = page\n \n-      const fallbackRouteParams: string[] = []\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n \n-      for (const key of routeParamKeys) {\n+      for (const {\n+        paramName: key,\n+        paramType: type,\n+      } of childrenRouteParamSegments) {\n         const paramValue = params[key]\n \n         if (!paramValue) {\n           if (isRoutePPREnabled) {\n             // Mark remaining params as fallback params.\n-            fallbackRouteParams.push(key)\n+            fallbackRouteParams.push(createFallbackRouteParam(key, type, false))\n             for (\n-              let i = routeParamKeys.indexOf(key) + 1;\n-              i < routeParamKeys.length;\n+              let i =\n+                childrenRouteParamSegments.findIndex(\n+                  (param) => param.paramName === key\n+                ) + 1;\n+              i < childrenRouteParamSegments.length;\n               i++\n             ) {\n-              fallbackRouteParams.push(routeParamKeys[i])\n+              fallbackRouteParams.push(\n+                createFallbackRouteParam(\n+                  childrenRouteParamSegments[i].paramName,\n+                  childrenRouteParamSegments[i].paramType,\n+                  false\n+                )\n+              )\n             }\n             break\n           } else {\n@@ -868,10 +1026,24 @@ export async function buildAppStaticPaths({\n         )\n       }\n \n+      // Resolve parallel route params from the regular route params\n+      resolveParallelRouteParams(\n+        parallelRouteSegments,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n       const fallbackRootParams: string[] = []\n-      for (const param of fallbackRouteParams) {\n-        if (rootParamSet.has(param)) {\n-          fallbackRootParams.push(param)\n+      for (const { paramName, isParallelRouteParam } of fallbackRouteParams) {\n+        // Only add the param to the fallback root params if it's not a\n+        // parallel route param. They won't contribute to the request pathname.\n+        if (isParallelRouteParam) continue\n+\n+        // If the param is a root param then we can add it to the fallback\n+        // root params.\n+        if (rootParamSet.has(paramName)) {\n+          fallbackRootParams.push(paramName)\n         }\n       }\n \n@@ -901,7 +1073,7 @@ export async function buildAppStaticPaths({\n \n   // Now we have to set the throwOnEmptyStaticShell for each of the routes.\n   if (prerenderedRoutes && cacheComponents) {\n-    assignErrorIfEmpty(prerenderedRoutes, routeParamKeys)\n+    assignErrorIfEmpty(prerenderedRoutes, childrenRouteParamSegments)\n   }\n \n   return { fallbackMode, prerenderedRoutes }"
        },
        {
            "sha": "0b9a8f63ee84a22c1899f95c5abac37835372587",
            "filename": "packages/next/src/build/static-paths/types.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 1,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Ftypes.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -1,5 +1,6 @@\n import type { FallbackMode } from '../../lib/fallback'\n import type { Params } from '../../server/request/params'\n+import type { DynamicParamTypes } from '../../shared/lib/app-router-types'\n \n type StaticPrerenderedRoute = {\n   readonly params: Params\n@@ -16,11 +17,34 @@ type StaticPrerenderedRoute = {\n   throwOnEmptyStaticShell: undefined\n }\n \n+export type FallbackRouteParam = {\n+  /**\n+   * The name of the param.\n+   */\n+  readonly paramName: string\n+\n+  /**\n+   * The type of the param.\n+   */\n+  readonly paramType: DynamicParamTypes\n+\n+  /**\n+   * Whether this is a parallel route param or descends from a parallel route\n+   * param.\n+   */\n+  readonly isParallelRouteParam: boolean\n+}\n+\n type FallbackPrerenderedRoute = {\n   readonly params: Params\n   readonly pathname: string\n   readonly encodedPathname: string\n-  readonly fallbackRouteParams: readonly string[]\n+\n+  /**\n+   * The fallback route params for the route. This includes both the parallel\n+   * route params and the non-parallel route params.\n+   */\n+  readonly fallbackRouteParams: readonly FallbackRouteParam[]\n   readonly fallbackMode: FallbackMode | undefined\n   readonly fallbackRootParams: readonly string[]\n "
        },
        {
            "sha": "efb26ecd285d6e1720173c6e228d42b70649e321",
            "filename": "packages/next/src/build/static-paths/utils.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Futils.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -1,3 +1,6 @@\n+import type { DynamicParamTypes } from '../../shared/lib/app-router-types'\n+import type { FallbackRouteParam } from './types'\n+\n /**\n  * Encodes a parameter value using the provided encoder.\n  *\n@@ -28,3 +31,19 @@ export function encodeParam(\n export function normalizePathname(pathname: string) {\n   return pathname.replace(/\\\\/g, '/').replace(/(?!^)\\/$/, '')\n }\n+\n+/**\n+ * Creates a fallback route param.\n+ *\n+ * @param paramName - The name of the param.\n+ * @param isParallelRouteParam - Whether this is a parallel route param or\n+ * descends from a parallel route param.\n+ * @returns The fallback route param.\n+ */\n+export function createFallbackRouteParam(\n+  paramName: string,\n+  paramType: DynamicParamTypes,\n+  isParallelRouteParam: boolean\n+): FallbackRouteParam {\n+  return { paramName, paramType, isParallelRouteParam }\n+}"
        },
        {
            "sha": "61542efa5e6d8303d28aca180e68b3b1f6a491a7",
            "filename": "packages/next/src/build/templates/app-page.ts",
            "status": "modified",
            "additions": 67,
            "deletions": 27,
            "changes": 94,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -18,7 +18,8 @@ import { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\n import { checkIsAppPPREnabled } from '../../server/lib/experimental/ppr'\n import {\n   getFallbackRouteParams,\n-  type FallbackRouteParams,\n+  createOpaqueFallbackRouteParams,\n+  type OpaqueFallbackRouteParams,\n } from '../../server/request/fallback-params'\n import { setReferenceManifestsSingleton } from '../../server/app-render/encryption-utils'\n import {\n@@ -89,6 +90,7 @@ export const __next_app__ = {\n \n import * as entryBase from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\n import { RedirectStatusCode } from '../../client/components/redirect-status-code'\n+import { InvariantError } from '../../shared/lib/invariant-error'\n \n export * from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\n \n@@ -447,7 +449,7 @@ export async function handler(\n       /**\n        * The unknown route params for this render.\n        */\n-      fallbackRouteParams: FallbackRouteParams | null\n+      fallbackRouteParams: OpaqueFallbackRouteParams | null\n     }): Promise<ResponseCacheEntry> => {\n       const context: AppPageRouteHandlerContext = {\n         query,\n@@ -515,7 +517,9 @@ export async function handler(\n           basePath: nextConfig.basePath,\n           serverActions: nextConfig.experimental.serverActions,\n \n-          ...(isDebugStaticShell || isDebugDynamicAccesses\n+          ...(isDebugStaticShell ||\n+          isDebugDynamicAccesses ||\n+          isDebugFallbackShell\n             ? {\n                 nextExport: true,\n                 supportsDynamicResponse: false,\n@@ -697,19 +701,38 @@ export async function handler(\n           throw new NoFallbackError()\n         }\n \n-        let fallbackResponse: ResponseCacheEntry | null | undefined\n-\n-        if (isRoutePPREnabled && !isRSCRequest) {\n+        // When client param parsing is enabled, we can use the fallback\n+        // response if the request is not a dynamic RSC request because the\n+        // RSC data when this feature flag is enabled does not contain any\n+        // param references. Without this feature flag enabled, the RSC data\n+        // contains param references, and therefore we can't use the fallback.\n+        if (\n+          isRoutePPREnabled &&\n+          (nextConfig.experimental.clientParamParsing\n+            ? !isDynamicRSCRequest\n+            : !isRSCRequest)\n+        ) {\n           const cacheKey =\n-            typeof prerenderInfo?.fallback === 'string'\n+            isProduction && typeof prerenderInfo?.fallback === 'string'\n               ? prerenderInfo.fallback\n-              : isProduction\n-                ? normalizedSrcPage\n+              : normalizedSrcPage\n+\n+          const fallbackRouteParams =\n+            // If we're in production and we have fallback route params, then we\n+            // can use the manifest fallback route params.\n+            isProduction && prerenderInfo?.fallbackRouteParams\n+              ? createOpaqueFallbackRouteParams(\n+                  prerenderInfo.fallbackRouteParams\n+                )\n+              : // Otherwise, if we're debugging the fallback shell, then we\n+                // have to manually generate the fallback route params.\n+                isDebugFallbackShell\n+                ? getFallbackRouteParams(normalizedSrcPage, routeModule)\n                 : null\n \n           // We use the response cache here to handle the revalidation and\n           // management of the fallback shell.\n-          fallbackResponse = await routeModule.handleResponse({\n+          const fallbackResponse = await routeModule.handleResponse({\n             cacheKey,\n             req,\n             nextConfig,\n@@ -723,13 +746,7 @@ export async function handler(\n                 // We pass `undefined` as rendering a fallback isn't resumed\n                 // here.\n                 postponed: undefined,\n-                fallbackRouteParams:\n-                  // If we're in production or we're debugging the fallback\n-                  // shell then we should postpone when dynamic params are\n-                  // accessed.\n-                  isProduction || isDebugFallbackShell\n-                    ? getFallbackRouteParams(normalizedSrcPage)\n-                    : null,\n+                fallbackRouteParams,\n               }),\n             waitUntil: ctx.waitUntil,\n           })\n@@ -747,6 +764,7 @@ export async function handler(\n           }\n         }\n       }\n+\n       // Only requests that aren't revalidating can be resumed. If we have the\n       // minimal postponed data, then we should resume the render with it.\n       const postponed =\n@@ -772,15 +790,19 @@ export async function handler(\n         }\n       }\n \n-      // If this is a dynamic route with PPR enabled and the default route\n-      // matches were set, then we should pass the fallback route params to\n-      // the renderer as this is a fallback revalidation request.\n       const fallbackRouteParams =\n-        pageIsDynamic &&\n-        isRoutePPREnabled &&\n-        (getRequestMeta(req, 'renderFallbackShell') || isDebugFallbackShell)\n-          ? getFallbackRouteParams(pathname)\n-          : null\n+        // If we're in production and we have fallback route params, then we\n+        // can use the manifest fallback route params if we need to render the\n+        // fallback shell.\n+        isProduction &&\n+        prerenderInfo?.fallbackRouteParams &&\n+        getRequestMeta(req, 'renderFallbackShell')\n+          ? createOpaqueFallbackRouteParams(prerenderInfo.fallbackRouteParams)\n+          : // Otherwise, if we're debugging the fallback shell, then we have to\n+            // manually generate the fallback route params.\n+            isDebugFallbackShell\n+            ? getFallbackRouteParams(normalizedSrcPage, routeModule)\n+            : null\n \n       // Perform the render.\n       return doRender({\n@@ -1071,8 +1093,26 @@ export async function handler(\n       if (isRSCRequest && !isDraftMode) {\n         // If this is a dynamic RSC request, then stream the response.\n         if (typeof cachedData.rscData === 'undefined') {\n-          if (cachedData.postponed) {\n-            throw new Error('Invariant: Expected postponed to be undefined')\n+          // If the response is not an RSC response, then we can't serve it.\n+          if (cachedData.html.contentType !== RSC_CONTENT_TYPE_HEADER) {\n+            if (nextConfig.experimental.clientParamParsing) {\n+              // If client param parsing is enabled, then we can return a 404.\n+              // This was likely an old prefetch request.\n+              res.statusCode = 404\n+              return sendRenderResult({\n+                req,\n+                res,\n+                generateEtags: nextConfig.generateEtags,\n+                poweredByHeader: nextConfig.poweredByHeader,\n+                result: RenderResult.EMPTY,\n+                cacheControl: cacheEntry.cacheControl,\n+              })\n+            } else {\n+              // Otherwise this case is not expected.\n+              throw new InvariantError(\n+                `Expected RSC response, got ${cachedData.html.contentType}`\n+              )\n+            }\n           }\n \n           return sendRenderResult({"
        },
        {
            "sha": "f5408c385907539af67b712b386b1bf67ff73fa1",
            "filename": "packages/next/src/build/utils.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -15,7 +15,10 @@ import type {\n   MiddlewareManifest,\n } from './webpack/plugins/middleware-plugin'\n import type { WebpackLayerName } from '../lib/constants'\n-import type { AppPageModule } from '../server/route-modules/app-page/module'\n+import type {\n+  AppPageModule,\n+  AppPageRouteModule,\n+} from '../server/route-modules/app-page/module'\n import type { NextComponentType } from '../shared/lib/utils'\n \n import '../server/require-hook'\n@@ -83,6 +86,7 @@ import { buildPagesStaticPaths } from './static-paths/pages'\n import type { PrerenderedRoute } from './static-paths/types'\n import type { CacheControl } from '../server/lib/cache-control'\n import { formatExpire, formatRevalidate } from './output/format'\n+import type { AppRouteRouteModule } from '../server/route-modules/app-route/module'\n \n export type ROUTER_TYPE = 'pages' | 'app'\n \n@@ -1174,9 +1178,13 @@ export async function isPageStatic({\n \n         isClientComponent = isClientReference(componentsResult.ComponentMod)\n \n-        let segments\n+        let segments: AppSegment[]\n         try {\n-          segments = await collectSegments(routeModule)\n+          segments = await collectSegments(\n+            // We know this is an app page or app route module because we\n+            // checked above that the page type is 'app'.\n+            routeModule as AppPageRouteModule | AppRouteRouteModule\n+          )\n         } catch (err) {\n           throw new Error(`Failed to collect configuration for ${page}`, {\n             cause: err,"
        },
        {
            "sha": "58455849b37b667b56644edefcdbb3248f666428",
            "filename": "packages/next/src/client/components/navigation-untracked.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fnavigation-untracked.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fnavigation-untracked.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fnavigation-untracked.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -2,8 +2,9 @@ import { useContext } from 'react'\n import { PathnameContext } from '../../shared/lib/hooks-client-context.shared-runtime'\n \n /**\n- * This checks to see if the current render has any unknown route parameters.\n- * It's used to trigger a different render path in the error boundary.\n+ * This checks to see if the current render has any unknown route parameters that\n+ * would cause the pathname to be dynamic. It's used to trigger a different\n+ * render path in the error boundary.\n  *\n  * @returns true if there are any unknown route parameters, false otherwise\n  */"
        },
        {
            "sha": "470758c4cb559a3ff467bbaf24a1b880470271ac",
            "filename": "packages/next/src/export/routes/app-page.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 10,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fexport%2Froutes%2Fapp-page.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fexport%2Froutes%2Fapp-page.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fexport%2Froutes%2Fapp-page.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -24,7 +24,7 @@ import { NodeNextRequest, NodeNextResponse } from '../../server/base-http/node'\n import { NEXT_IS_PRERENDER_HEADER } from '../../client/components/app-router-headers'\n import type { FetchMetrics } from '../../server/base-http'\n import type { WorkStore } from '../../server/app-render/work-async-storage.external'\n-import type { FallbackRouteParams } from '../../server/request/fallback-params'\n+import type { OpaqueFallbackRouteParams } from '../../server/request/fallback-params'\n import { AfterRunner } from '../../server/after/run-with-after'\n import type { RequestLifecycleOpts } from '../../server/base-server'\n import type { AppSharedContext } from '../../server/app-render/app-render'\n@@ -45,7 +45,7 @@ export async function exportAppPage(\n   path: string,\n   pathname: string,\n   query: NextParsedUrlQuery,\n-  fallbackRouteParams: FallbackRouteParams | null,\n+  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n   partialRenderOpts: Omit<RenderOpts, keyof RequestLifecycleOpts>,\n   htmlFilepath: string,\n   debugOutput: boolean,\n@@ -132,14 +132,19 @@ export async function exportAppPage(\n     // If page data isn't available, it means that the page couldn't be rendered\n     // properly so long as we don't have unknown route params. When a route doesn't\n     // have unknown route params, there will not be any flight data.\n-    if (\n-      !flightData &&\n-      (!fallbackRouteParams || fallbackRouteParams.size === 0)\n-    ) {\n-      throw new Error(`Invariant: failed to get page data for ${path}`)\n-    }\n-\n-    if (flightData) {\n+    if (!flightData) {\n+      // Unless the user has clientParamParsing enabled, we expect that routes\n+      // that don't have fallback route params would have flight data. This is\n+      // because when clientParamParsing is enabled, the absence of flight data\n+      // means that the route has unknown route params.\n+      if (\n+        !fallbackRouteParams ||\n+        fallbackRouteParams.size === 0 ||\n+        renderOpts.experimental.clientParamParsing\n+      ) {\n+        throw new Error(`Invariant: failed to get page data for ${path}`)\n+      }\n+    } else {\n       // If PPR is enabled, we want to emit a prefetch rsc file for the page\n       // instead of the standard rsc. This is because the standard rsc will\n       // contain the dynamic data. We do this if any routes have PPR enabled so"
        },
        {
            "sha": "e542fc47d541da631c83313e528526d392102e59",
            "filename": "packages/next/src/export/worker.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fexport%2Fworker.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fexport%2Fworker.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fexport%2Fworker.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -40,8 +40,8 @@ import {\n } from '../build/turborepo-access-trace'\n import type { Params } from '../server/request/params'\n import {\n-  getFallbackRouteParams,\n-  type FallbackRouteParams,\n+  createOpaqueFallbackRouteParams,\n+  type OpaqueFallbackRouteParams,\n } from '../server/request/fallback-params'\n import { needsExperimentalReact } from '../lib/needs-experimental-react'\n import type { AppRouteRouteModule } from '../server/route-modules/app-route/module.compiled'\n@@ -119,8 +119,8 @@ async function exportPageImpl(\n     query: originalQuery = {},\n   } = exportPath\n \n-  const fallbackRouteParams: FallbackRouteParams | null =\n-    getFallbackRouteParams(_fallbackRouteParams)\n+  const fallbackRouteParams: OpaqueFallbackRouteParams | null =\n+    createOpaqueFallbackRouteParams(_fallbackRouteParams)\n \n   let query = { ...originalQuery }\n   const pathname = normalizeAppPath(page)"
        },
        {
            "sha": "290f64918aedd91a8a4632ce20342dab8507a0c0",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 8,
            "deletions": 7,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -153,7 +153,7 @@ import { createInitialRouterState } from '../../client/components/router-reducer\n import { createMutableActionQueue } from '../../client/components/app-router-instance'\n import { getRevalidateReason } from '../instrumentation/utils'\n import { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\n-import type { FallbackRouteParams } from '../request/fallback-params'\n+import type { OpaqueFallbackRouteParams } from '../request/fallback-params'\n import {\n   prerenderAndAbortInSequentialTasksWithStages,\n   processPrelude,\n@@ -365,7 +365,7 @@ function createNotFoundLoaderTree(loaderTree: LoaderTree): LoaderTree {\n function makeGetDynamicParamFromSegment(\n   params: { [key: string]: any },\n   pagePath: string,\n-  fallbackRouteParams: FallbackRouteParams | null\n+  fallbackRouteParams: OpaqueFallbackRouteParams | null\n ): GetDynamicParamFromSegment {\n   return function getDynamicParamFromSegment(\n     // [slug] / [[slug]] / [...slug]\n@@ -1444,7 +1444,7 @@ async function renderToHTMLOrFlightImpl(\n   postponedState: PostponedState | null,\n   serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n   sharedContext: AppSharedContext,\n-  fallbackRouteParams: FallbackRouteParams | null\n+  fallbackRouteParams: OpaqueFallbackRouteParams | null\n ) {\n   const isNotFoundPath = pagePath === '/404'\n   if (isNotFoundPath) {\n@@ -1927,7 +1927,7 @@ export type AppPageRender = (\n   res: BaseNextResponse,\n   pagePath: string,\n   query: NextParsedUrlQuery,\n-  fallbackRouteParams: FallbackRouteParams | null,\n+  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n   renderOpts: RenderOpts,\n   serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n   isDevWarmup: boolean,\n@@ -1974,6 +1974,7 @@ export const renderToHTMLOrFlight: AppPageRender = (\n \n     postponedState = parsePostponedState(\n       renderOpts.postponed,\n+      pagePath,\n       renderOpts.params\n     )\n   }\n@@ -2072,7 +2073,7 @@ async function renderToStream(\n   formState: any,\n   postponedState: PostponedState | null,\n   metadata: AppPageRenderResultMetadata,\n-  devValidatingFallbackParams: FallbackRouteParams | null\n+  devValidatingFallbackParams: OpaqueFallbackRouteParams | null\n ): Promise<ReadableStream<Uint8Array>> {\n   const { assetPrefix, nonce, pagePath, renderOpts } = ctx\n \n@@ -2581,7 +2582,7 @@ async function spawnDynamicValidationInDev(\n   isNotFound: boolean,\n   clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>,\n   requestStore: RequestStore,\n-  fallbackRouteParams: FallbackRouteParams | null\n+  fallbackRouteParams: OpaqueFallbackRouteParams | null\n ): Promise<void> {\n   const {\n     componentMod: ComponentMod,\n@@ -3193,7 +3194,7 @@ async function prerenderToStream(\n   ctx: AppRenderContext,\n   metadata: AppPageRenderResultMetadata,\n   tree: LoaderTree,\n-  fallbackRouteParams: FallbackRouteParams | null\n+  fallbackRouteParams: OpaqueFallbackRouteParams | null\n ): Promise<PrerenderToStreamResult> {\n   // When prerendering formState is always null. We still include it\n   // because some shared APIs expect a formState value and this is slightly"
        },
        {
            "sha": "97facd83ba585ca3476c9c613205373824bd5fb5",
            "filename": "packages/next/src/server/app-render/dynamic-rendering.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -595,6 +595,7 @@ export function useDynamicRouteParams(expression: string) {\n       case 'prerender-client':\n       case 'prerender': {\n         const fallbackParams = workUnitStore.fallbackRouteParams\n+\n         if (fallbackParams && fallbackParams.size > 0) {\n           // We are in a prerender with cacheComponents semantics. We are going to\n           // hang here and never resolve. This will cause the currently"
        },
        {
            "sha": "0c484211515eec436323487bc844e8899f57b10f",
            "filename": "packages/next/src/server/app-render/get-short-dynamic-param-type.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 13,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fget-short-dynamic-param-type.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fget-short-dynamic-param-type.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fget-short-dynamic-param-type.tsx?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -13,16 +13,3 @@ export const dynamicParamTypes: Record<\n   dynamic: 'd',\n   'dynamic-intercepted': 'di',\n }\n-\n-/**\n- * Shorten the dynamic param in order to make it smaller when transmitted to the browser.\n- */\n-export function getShortDynamicParamType(\n-  type: DynamicParamTypes\n-): DynamicParamTypesShort {\n-  const short = dynamicParamTypes[type]\n-  if (!short) {\n-    throw new Error('Unknown dynamic param type')\n-  }\n-  return short\n-}"
        },
        {
            "sha": "8b0ed182b612d6e8063579467d75f66b5e1133a3",
            "filename": "packages/next/src/server/app-render/postponed-state.test.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 7,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.test.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -10,11 +10,23 @@ import {\n   parsePostponedState,\n   DynamicHTMLPreludeState,\n } from './postponed-state'\n+import type {\n+  OpaqueFallbackRouteParams,\n+  OpaqueFallbackRouteParamValue,\n+} from '../request/fallback-params'\n+\n+export function createMockOpaqueFallbackRouteParams(\n+  params: Record<string, OpaqueFallbackRouteParamValue>\n+): OpaqueFallbackRouteParams {\n+  return new Map(Object.entries(params))\n+}\n \n describe('getDynamicHTMLPostponedState', () => {\n   it('serializes a HTML postponed state with fallback params', async () => {\n     const key = '%%drp:slug:e9615126684e5%%'\n-    const fallbackRouteParams = new Map([['slug', key]])\n+    const fallbackRouteParams = createMockOpaqueFallbackRouteParams({\n+      slug: [key, 'd'],\n+    })\n     const prerenderResumeDataCache = createPrerenderResumeDataCache()\n \n     prerenderResumeDataCache.cache.set(\n@@ -36,7 +48,7 @@ describe('getDynamicHTMLPostponedState', () => {\n       prerenderResumeDataCache\n     )\n \n-    const parsed = parsePostponedState(state, { slug: '123' })\n+    const parsed = parsePostponedState(state, '/blog/[slug]', { slug: '123' })\n     expect(parsed).toMatchInlineSnapshot(`\n      {\n        \"data\": [\n@@ -79,7 +91,9 @@ describe('getDynamicHTMLPostponedState', () => {\n \n   it('can serialize and deserialize a HTML postponed state with fallback params', async () => {\n     const key = '%%drp:slug:e9615126684e5%%'\n-    const fallbackRouteParams = new Map([['slug', key]])\n+    const fallbackRouteParams = createMockOpaqueFallbackRouteParams({\n+      slug: [key, 'd'],\n+    })\n     const state = await getDynamicHTMLPostponedState(\n       { [key]: key },\n       DynamicHTMLPreludeState.Full,\n@@ -89,7 +103,7 @@ describe('getDynamicHTMLPostponedState', () => {\n \n     const value = 'hello'\n     const params = { slug: value }\n-    const parsed = parsePostponedState(state, params)\n+    const parsed = parsePostponedState(state, '/blog/[slug]', params)\n     expect(parsed).toEqual({\n       type: DynamicState.HTML,\n       data: [1, { [value]: value }],\n@@ -116,7 +130,7 @@ describe('parsePostponedState', () => {\n     const params = {\n       slug: Math.random().toString(16).slice(3),\n     }\n-    const parsed = parsePostponedState(state, params)\n+    const parsed = parsePostponedState(state, '/blog/[slug]', params)\n \n     // Ensure that it parsed it correctly.\n     expect(parsed).toEqual({\n@@ -132,7 +146,7 @@ describe('parsePostponedState', () => {\n   it('parses a HTML postponed state without fallback params', () => {\n     const state = `2:{}null`\n     const params = {}\n-    const parsed = parsePostponedState(state, params)\n+    const parsed = parsePostponedState(state, '/blog', params)\n \n     // Ensure that it parsed it correctly.\n     expect(parsed).toEqual({\n@@ -144,7 +158,7 @@ describe('parsePostponedState', () => {\n \n   it('parses a data postponed state', () => {\n     const state = '4:nullnull'\n-    const parsed = parsePostponedState(state, undefined)\n+    const parsed = parsePostponedState(state, '/blog', undefined)\n \n     // Ensure that it parsed it correctly.\n     expect(parsed).toEqual({"
        },
        {
            "sha": "4ab1e15a2a4b700858183723a7e4aaabcaf07e44",
            "filename": "packages/next/src/server/app-render/postponed-state.ts",
            "status": "modified",
            "additions": 31,
            "deletions": 8,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -1,4 +1,8 @@\n-import type { FallbackRouteParams } from '../../server/request/fallback-params'\n+import type {\n+  OpaqueFallbackRouteParamEntries,\n+  OpaqueFallbackRouteParams,\n+} from '../../server/request/fallback-params'\n+import { getDynamicParam } from '../../shared/lib/router/utils/get-dynamic-param'\n import type { Params } from '../request/params'\n import {\n   createPrerenderResumeDataCache,\n@@ -74,20 +78,24 @@ export type PostponedState =\n export async function getDynamicHTMLPostponedState(\n   postponed: ReactPostponed,\n   preludeState: DynamicHTMLPreludeState,\n-  fallbackRouteParams: FallbackRouteParams | null,\n+  fallbackRouteParams: OpaqueFallbackRouteParams | null,\n   resumeDataCache: PrerenderResumeDataCache | RenderResumeDataCache\n ): Promise<string> {\n   const data: DynamicHTMLPostponedState['data'] = [preludeState, postponed]\n   const dataString = JSON.stringify(data)\n \n+  // If there are no fallback route params, we can just serialize the postponed\n+  // state as is.\n   if (!fallbackRouteParams || fallbackRouteParams.size === 0) {\n     // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n     return `${dataString.length}:${dataString}${await stringifyResumeDataCache(\n       createRenderResumeDataCache(resumeDataCache)\n     )}`\n   }\n \n-  const replacements: Array<[string, string]> = Array.from(fallbackRouteParams)\n+  const replacements: OpaqueFallbackRouteParamEntries = Array.from(\n+    fallbackRouteParams.entries()\n+  )\n   const replacementsString = JSON.stringify(replacements)\n \n   // Serialized as `<replacements.length><replacements><data>`\n@@ -105,6 +113,7 @@ export async function getDynamicDataPostponedState(\n \n export function parsePostponedState(\n   state: string,\n+  pagePath: string,\n   params: Params | undefined\n ): PostponedState {\n   try {\n@@ -147,13 +156,27 @@ export function parsePostponedState(\n             // We then go to the end of the string.\n             match.length + length\n           )\n-        ) as ReadonlyArray<[string, string]>\n+        ) as OpaqueFallbackRouteParamEntries\n \n         let postponed = postponedString.slice(match.length + length)\n-        for (const [key, searchValue] of replacements) {\n-          const value = params?.[key] ?? ''\n-          const replaceValue = Array.isArray(value) ? value.join('/') : value\n-          postponed = postponed.replaceAll(searchValue, replaceValue)\n+        for (const [key, [searchValue, dynamicParamType]] of replacements) {\n+          const {\n+            treeSegment: [\n+              ,\n+              // This is the same value that'll be used in the postponed state\n+              // as it's part of the tree data. That's why we use it as the\n+              // replacement value.\n+              value,\n+            ],\n+          } = getDynamicParam(\n+            params ?? {},\n+            key,\n+            dynamicParamType,\n+            pagePath,\n+            null\n+          )\n+\n+          postponed = postponed.replaceAll(searchValue, value)\n         }\n \n         return {"
        },
        {
            "sha": "a963d0d8255fc9d4c82317357bc1bd65f7d8c9bf",
            "filename": "packages/next/src/server/app-render/work-unit-async-storage.external.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -5,7 +5,7 @@ import type { ReadonlyHeaders } from '../web/spec-extension/adapters/headers'\n import type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\n import type { CacheSignal } from './cache-signal'\n import type { DynamicTrackingState } from './dynamic-rendering'\n-import type { FallbackRouteParams } from '../request/fallback-params'\n+import type { OpaqueFallbackRouteParams } from '../request/fallback-params'\n \n // Share the instance module in the next-shared layer\n import { workUnitAsyncStorageInstance } from './work-unit-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\n@@ -68,7 +68,7 @@ export interface RequestStore extends CommonWorkUnitStore {\n   // DEV-only\n   usedDynamic?: boolean\n   prerenderPhase?: boolean\n-  devFallbackParams?: FallbackRouteParams | null\n+  devFallbackParams?: OpaqueFallbackRouteParams | null\n }\n \n /**\n@@ -203,7 +203,7 @@ interface StaticPrerenderStoreCommon {\n    * The set of unknown route parameters. Accessing these will be tracked as\n    * a dynamic access.\n    */\n-  readonly fallbackRouteParams: FallbackRouteParams | null\n+  readonly fallbackRouteParams: OpaqueFallbackRouteParams | null\n \n   /**\n    * When true, the page is prerendered as a fallback shell, while allowing any\n@@ -225,7 +225,7 @@ export interface PrerenderStorePPR\n    * The set of unknown route parameters. Accessing these will be tracked as\n    * a dynamic access.\n    */\n-  readonly fallbackRouteParams: FallbackRouteParams | null\n+  readonly fallbackRouteParams: OpaqueFallbackRouteParams | null\n \n   /**\n    * The resume data cache for this prerender."
        },
        {
            "sha": "7e236933d26da72512f7808589657e1038cef0cc",
            "filename": "packages/next/src/server/async-storage/request-store.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -24,7 +24,7 @@ import type { ServerComponentsHmrCache } from '../response-cache'\n import type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\n import type { Params } from '../request/params'\n import type { ImplicitTags } from '../lib/implicit-tags'\n-import type { FallbackRouteParams } from '../request/fallback-params'\n+import type { OpaqueFallbackRouteParams } from '../request/fallback-params'\n \n function getHeaders(headers: Headers | IncomingHttpHeaders): ReadonlyHeaders {\n   const cleaned = HeadersAdapter.from(headers)\n@@ -116,7 +116,7 @@ export function createRequestStoreForRender(\n   isHmrRefresh: RequestContext['isHmrRefresh'],\n   serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],\n   renderResumeDataCache: RenderResumeDataCache | undefined,\n-  devFallbackParams: FallbackRouteParams | null\n+  devFallbackParams: OpaqueFallbackRouteParams | null\n ): RequestStore {\n   return createRequestStoreImpl(\n     // Pages start in render phase by default\n@@ -171,7 +171,7 @@ function createRequestStoreImpl(\n   previewProps: WrapperRenderOpts['previewProps'],\n   isHmrRefresh: RequestContext['isHmrRefresh'],\n   serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],\n-  devFallbackParams: FallbackRouteParams | null | undefined\n+  devFallbackParams: OpaqueFallbackRouteParams | null | undefined\n ): RequestStore {\n   function defaultOnUpdateCookies(cookies: string[]) {\n     if (res) {"
        },
        {
            "sha": "ae8f338b7748adb56482392432aa0e1a51b54706",
            "filename": "packages/next/src/server/base-server.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -147,6 +147,7 @@ import { computeCacheBustingSearchParam } from '../shared/lib/router/utils/cache\n import { setCacheBustingSearchParamWithHash } from '../client/components/router-reducer/set-cache-busting-search-param'\n import type { CacheControl } from './lib/cache-control'\n import type { PrerenderedRoute } from '../build/static-paths/types'\n+import { createOpaqueFallbackRouteParams } from './request/fallback-params'\n \n export type FindComponentsResult = {\n   components: LoadComponentsReturnType\n@@ -2319,13 +2320,10 @@ export default abstract class Server<\n             }\n           }\n           if (smallestFallbackRouteParams) {\n-            const devValidatingFallbackParams = new Map<string, string>(\n-              smallestFallbackRouteParams.map((v) => [v, ''])\n-            )\n             addRequestMeta(\n               req,\n               'devValidatingFallbackParams',\n-              devValidatingFallbackParams\n+              createOpaqueFallbackRouteParams(smallestFallbackRouteParams)!\n             )\n           }\n         }"
        },
        {
            "sha": "15178a96a4eb6cdfcd4edb92831064a4a5380f41",
            "filename": "packages/next/src/server/config-schema.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -37,8 +37,9 @@ const zExportMap: zod.ZodType<ExportPathMap> = z.record(\n   z.object({\n     page: z.string(),\n     query: z.any(), // NextParsedUrlQuery\n+\n     // private optional properties\n-    _fallbackRouteParams: z.array(z.string()).optional(),\n+    _fallbackRouteParams: z.array(z.any()).optional(),\n     _isAppDir: z.boolean().optional(),\n     _isDynamicError: z.boolean().optional(),\n     _isRoutePPREnabled: z.boolean().optional(),"
        },
        {
            "sha": "7279c56dfc59ac24ab0e8f14c1cf88c4dc8f103c",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -29,6 +29,7 @@ import type { RenderingMode } from '../build/rendering-mode'\n import type { Revalidate } from './lib/cache-control'\n import type { AdapterOutputType } from '../shared/lib/constants'\n import type { MiddlewareMatcher } from '../build/analysis/get-page-static-info'\n+import type { FallbackRouteParam } from '../build/static-paths/types'\n \n export type NextConfigComplete = Required<NextConfig> & {\n   images: Required<ImageConfigComplete>\n@@ -940,7 +941,7 @@ export type ExportPathMap = {\n      *\n      * @internal\n      */\n-    _fallbackRouteParams?: readonly string[]\n+    _fallbackRouteParams?: readonly FallbackRouteParam[]\n \n     /**\n      * @internal"
        },
        {
            "sha": "87c2ef92f43af9440619b38ba0d1362c6b176596",
            "filename": "packages/next/src/server/config.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 4,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -224,7 +224,15 @@ function warnCustomizedOption(\n   }\n }\n \n-function assignDefaults(\n+/**\n+ * Assigns defaults to the user config and validates the config.\n+ *\n+ * @param dir - The directory of the project.\n+ * @param userConfig - The user config.\n+ * @param silent - Whether to suppress warnings.\n+ * @returns The complete config.\n+ */\n+function assignDefaultsAndValidate(\n   dir: string,\n   userConfig: NextConfig & { configFileName: string },\n   silent: boolean\n@@ -1173,6 +1181,18 @@ function assignDefaults(\n     result.experimental.ppr = true\n   }\n \n+  // We require clientSegmentCache to be enabled if clientParamParsing is\n+  // enabled. This is because clientParamParsing is only relevant when\n+  // clientSegmentCache is enabled.\n+  if (\n+    result.experimental.clientParamParsing &&\n+    !result.experimental.clientSegmentCache\n+  ) {\n+    throw new Error(\n+      `\\`experimental.clientParamParsing\\` can not be \\`true\\` when \\`experimental.clientSegmentCache\\` is \\`false\\`. Client param parsing is only relevant when client segment cache is enabled.`\n+    )\n+  }\n+\n   return result as NextConfigComplete\n }\n \n@@ -1329,7 +1349,7 @@ export default async function loadConfig(\n     checkDeprecations(customConfig as NextConfig, configFileName, silent, dir)\n \n     const config = await applyModifyConfig(\n-      assignDefaults(\n+      assignDefaultsAndValidate(\n         dir,\n         {\n           configOrigin: 'server',\n@@ -1534,7 +1554,7 @@ export default async function loadConfig(\n       phase,\n     })\n \n-    const completeConfig = assignDefaults(\n+    const completeConfig = assignDefaultsAndValidate(\n       dir,\n       {\n         configOrigin: relative(dir, path),\n@@ -1592,7 +1612,7 @@ export default async function loadConfig(\n \n   // always call assignDefaults to ensure settings like\n   // reactRoot can be updated correctly even with no next.config.js\n-  const completeConfig = assignDefaults(\n+  const completeConfig = assignDefaultsAndValidate(\n     dir,\n     { ...clonedDefaultConfig, configFileName },\n     silent"
        },
        {
            "sha": "df7f323082e5c11ab3fb111fa6eb7c6c21894638",
            "filename": "packages/next/src/server/dev/next-dev-server.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fnext-dev-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fnext-dev-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fnext-dev-server.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -901,8 +901,7 @@ export default class DevServer extends Server {\n \n         if (\n           res.value?.fallbackMode !== undefined &&\n-          // This matches the hasGenerateStaticParams logic\n-          // we do during build\n+          // This matches the hasGenerateStaticParams logic we do during build.\n           (!isAppPath || (prerenderedRoutes && prerenderedRoutes.length > 0))\n         ) {\n           // we write the static paths to partial manifest for\n@@ -916,6 +915,7 @@ export default class DevServer extends Server {\n           for (const staticPath of value.staticPaths || []) {\n             existingManifest.routes[staticPath] = {} as any\n           }\n+\n           existingManifest.dynamicRoutes[pathname] = {\n             dataRoute: null,\n             dataRouteRegex: null,\n@@ -925,6 +925,7 @@ export default class DevServer extends Server {\n             fallbackHeaders: undefined,\n             fallbackStatus: undefined,\n             fallbackRootParams: undefined,\n+            fallbackRouteParams: undefined,\n             fallbackSourceRoute: pathname,\n             prefetchDataRoute: undefined,\n             prefetchDataRouteRegex: undefined,"
        },
        {
            "sha": "c831dd2f3cb7985cc71ab4d5c41b2afac4e53ac4",
            "filename": "packages/next/src/server/dev/static-paths-worker.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fstatic-paths-worker.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fstatic-paths-worker.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fstatic-paths-worker.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -19,6 +19,8 @@ import { collectRootParamKeys } from '../../build/segment-config/app/collect-roo\n import { buildAppStaticPaths } from '../../build/static-paths/app'\n import { buildPagesStaticPaths } from '../../build/static-paths/pages'\n import { createIncrementalCache } from '../../export/helpers/create-incremental-cache'\n+import type { AppPageRouteModule } from '../route-modules/app-page/module'\n+import type { AppRouteRouteModule } from '../route-modules/app-route/module'\n \n type RuntimeConfig = {\n   pprConfig: ExperimentalPPRConfig | undefined\n@@ -108,7 +110,11 @@ export async function loadStaticPaths({\n \n   if (isAppPath) {\n     const routeModule = components.routeModule\n-    const segments = await collectSegments(routeModule)\n+    const segments = await collectSegments(\n+      // We know this is an app page or app route module because we checked\n+      // above that the page type is 'app'.\n+      routeModule as AppPageRouteModule | AppRouteRouteModule\n+    )\n \n     const isRoutePPREnabled =\n       isAppPageRouteModule(routeModule) &&"
        },
        {
            "sha": "08d5592ac888ff7fdf7d864c0dc2a6d9477e53b2",
            "filename": "packages/next/src/server/lib/implicit-tags.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fimplicit-tags.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fimplicit-tags.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fimplicit-tags.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -1,5 +1,5 @@\n import { NEXT_CACHE_IMPLICIT_TAG_ID } from '../../lib/constants'\n-import type { FallbackRouteParams } from '../request/fallback-params'\n+import type { OpaqueFallbackRouteParams } from '../request/fallback-params'\n import { getCacheHandlerEntries } from '../use-cache/handlers'\n import { createLazyResult, type LazyResult } from './lazy-result'\n \n@@ -77,11 +77,9 @@ export async function getImplicitTags(\n     pathname: string\n     search?: string\n   },\n-  fallbackRouteParams: null | FallbackRouteParams\n+  fallbackRouteParams: null | OpaqueFallbackRouteParams\n ): Promise<ImplicitTags> {\n   const tags: string[] = []\n-  const hasFallbackRouteParams =\n-    fallbackRouteParams && fallbackRouteParams.size > 0\n \n   // Add the derived tags from the page.\n   const derivedTags = getDerivedTags(page)\n@@ -92,7 +90,10 @@ export async function getImplicitTags(\n \n   // Add the tags from the pathname. If the route has unknown params, we don't\n   // want to add the pathname as a tag, as it will be invalid.\n-  if (url.pathname && !hasFallbackRouteParams) {\n+  if (\n+    url.pathname &&\n+    (!fallbackRouteParams || fallbackRouteParams.size === 0)\n+  ) {\n     const tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${url.pathname}`\n     tags.push(tag)\n   }"
        },
        {
            "sha": "0705fc34cf86eee70f6b3b244ec5753b8fc0ad77",
            "filename": "packages/next/src/server/lib/incremental-cache/shared-cache-controls.external.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Fshared-cache-controls.external.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Fshared-cache-controls.external.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Fshared-cache-controls.external.test.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -40,6 +40,7 @@ describe('SharedCacheControls', () => {\n           fallback: true,\n           fallbackRootParams: undefined,\n           fallbackSourceRoute: undefined,\n+          fallbackRouteParams: undefined,\n           dataRoute: null,\n           dataRouteRegex: null,\n           prefetchDataRoute: null,"
        },
        {
            "sha": "041f84377ac0eff01d3592e9806c0dcb6dae3827",
            "filename": "packages/next/src/server/request-meta.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -8,6 +8,7 @@ import type { RouteMatch } from './route-matches/route-match'\n import type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\n import type { ServerComponentsHmrCache } from './response-cache'\n import type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'\n+import type { OpaqueFallbackRouteParams } from './request/fallback-params'\n \n // FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules\n export const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')\n@@ -235,7 +236,7 @@ export interface RequestMeta {\n   /**\n    * DEV only: The fallback params that should be used when validating prerenders during dev\n    */\n-  devValidatingFallbackParams?: Map<string, string>\n+  devValidatingFallbackParams?: OpaqueFallbackRouteParams\n }\n \n /**"
        },
        {
            "sha": "5844ae79423f0600519e01f9e1256cbfc041bd41",
            "filename": "packages/next/src/server/request/fallback-params.test.ts",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Ffallback-params.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Ffallback-params.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Ffallback-params.test.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -0,0 +1,40 @@\n+import { createOpaqueFallbackRouteParams } from './fallback-params'\n+import type { FallbackRouteParam } from '../../build/static-paths/types'\n+\n+describe('createOpaqueFallbackRouteParams', () => {\n+  describe('opaque object interface', () => {\n+    const fallbackParams: readonly FallbackRouteParam[] = [\n+      { paramName: 'slug', paramType: 'dynamic', isParallelRouteParam: false },\n+      { paramName: 'modal', paramType: 'dynamic', isParallelRouteParam: true },\n+    ]\n+\n+    it('has method works correctly', () => {\n+      const result = createOpaqueFallbackRouteParams(fallbackParams)!\n+\n+      expect(result.has('slug')).toBe(true)\n+      expect(result.has('modal')).toBe(true)\n+      expect(result.has('nonexistent')).toBe(false)\n+      expect(result.has('')).toBe(false)\n+    })\n+\n+    it('get method works correctly', () => {\n+      const result = createOpaqueFallbackRouteParams(fallbackParams)!\n+\n+      expect(result.get('slug')?.[0]).toMatch(/^%%drp:slug:[a-f0-9]+%%$/)\n+      expect(result.get('modal')?.[0]).toMatch(/^%%drp:modal:[a-f0-9]+%%$/)\n+      expect(result.get('nonexistent')).toBeUndefined()\n+      expect(result.get('')).toBeUndefined()\n+    })\n+\n+    it('iterator yields correct entries', () => {\n+      const result = createOpaqueFallbackRouteParams(fallbackParams)!\n+\n+      const entries = Array.from(result.entries())\n+      expect(entries).toHaveLength(2)\n+\n+      const [name, [value]] = entries[0]\n+      expect(name).toBe('slug')\n+      expect(value).toMatch(/^%%drp:slug:[a-f0-9]+%%$/)\n+    })\n+  })\n+})"
        },
        {
            "sha": "7f584dd8150b8c7d39e0b367594684f44fc182ca",
            "filename": "packages/next/src/server/request/fallback-params.ts",
            "status": "modified",
            "additions": 151,
            "deletions": 17,
            "changes": 168,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Ffallback-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Ffallback-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Ffallback-params.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -1,7 +1,11 @@\n+import { collectFallbackRouteParams } from '../../build/segment-config/app/app-segments'\n+import type { FallbackRouteParam } from '../../build/static-paths/types'\n+import type { DynamicParamTypesShort } from '../../shared/lib/app-router-types'\n+import { InvariantError } from '../../shared/lib/invariant-error'\n import { getRouteMatcher } from '../../shared/lib/router/utils/route-matcher'\n import { getRouteRegex } from '../../shared/lib/router/utils/route-regex'\n-\n-export type FallbackRouteParams = ReadonlyMap<string, string>\n+import { dynamicParamTypes } from '../app-render/get-short-dynamic-param-type'\n+import type AppPageRouteModule from '../route-modules/app-page/module'\n \n function getParamKeys(page: string) {\n   const pattern = getRouteRegex(page)\n@@ -11,29 +15,159 @@ function getParamKeys(page: string) {\n   return Object.keys(matcher(page))\n }\n \n-export function getFallbackRouteParams(\n-  pageOrKeys: string | readonly string[]\n-): FallbackRouteParams | null {\n-  let keys: readonly string[]\n-  if (typeof pageOrKeys === 'string') {\n-    keys = getParamKeys(pageOrKeys)\n-  } else {\n-    keys = pageOrKeys\n-  }\n+export type OpaqueFallbackRouteParamValue = [\n+  /**\n+   * The search value of the fallback route param. This is the opaque key\n+   * that will be used to replace the dynamic param in the postponed state.\n+   */\n+  searchValue: string,\n+\n+  /**\n+   * The dynamic param type of the fallback route param. This is the type of\n+   * the dynamic param that will be used to replace the dynamic param in the\n+   * postponed state.\n+   */\n+  dynamicParamType: DynamicParamTypesShort,\n+]\n+\n+/**\n+ * An opaque fallback route params object. This is used to store the fallback\n+ * route params in a way that is not easily accessible to the client.\n+ */\n+export type OpaqueFallbackRouteParams = ReadonlyMap<\n+  string,\n+  OpaqueFallbackRouteParamValue\n+>\n \n-  // If there are no keys, we can return early.\n-  if (keys.length === 0) return null\n+/**\n+ * The entries of the opaque fallback route params object.\n+ *\n+ * @param key the key of the fallback route param\n+ * @param value the value of the fallback route param\n+ */\n+export type OpaqueFallbackRouteParamEntries =\n+  ReturnType<OpaqueFallbackRouteParams['entries']> extends MapIterator<\n+    [infer K, infer V]\n+  >\n+    ? ReadonlyArray<[K, V]>\n+    : never\n \n-  const params = new Map<string, string>()\n+/**\n+ * Creates an opaque fallback route params object from the fallback route params.\n+ *\n+ * @param fallbackRouteParams the fallback route params\n+ * @returns the opaque fallback route params\n+ */\n+export function createOpaqueFallbackRouteParams(\n+  fallbackRouteParams: readonly FallbackRouteParam[]\n+): OpaqueFallbackRouteParams | null {\n+  // If there are no fallback route params, we can return early.\n+  if (fallbackRouteParams.length === 0) return null\n \n   // As we're creating unique keys for each of the dynamic route params, we only\n   // need to generate a unique ID once per request because each of the keys will\n   // be also be unique.\n   const uniqueID = Math.random().toString(16).slice(2)\n \n-  for (const key of keys) {\n-    params.set(key, `%%drp:${key}:${uniqueID}%%`)\n+  const keys = new Map<string, OpaqueFallbackRouteParamValue>()\n+\n+  // Generate a unique key for the fallback route param, if this key is found\n+  // in the static output, it represents a bug in cache components.\n+  for (const { paramName, paramType } of fallbackRouteParams) {\n+    keys.set(paramName, [\n+      `%%drp:${paramName}:${uniqueID}%%`,\n+      dynamicParamTypes[paramType],\n+    ])\n+  }\n+\n+  return keys\n+}\n+\n+/**\n+ * Gets the fallback route params for a given page. This is an expensive\n+ * operation because it requires parsing the loader tree to extract the fallback\n+ * route params.\n+ *\n+ * @param page the page\n+ * @param routeModule the route module\n+ * @returns the opaque fallback route params\n+ */\n+export function getFallbackRouteParams(\n+  page: string,\n+  routeModule: AppPageRouteModule\n+) {\n+  // First, get the fallback route params based on the provided page.\n+  const unknownParamKeys = new Set(getParamKeys(page))\n+\n+  // Needed when processing fallback route params for catchall routes in\n+  // parallel segments, derive from pathname. This is similar to\n+  // getDynamicParam's pagePath parsing logic.\n+  const pathSegments = page.split('/').filter(Boolean)\n+\n+  const collected = collectFallbackRouteParams(routeModule)\n+\n+  // Then, we have to get the fallback route params from the segments that are\n+  // associated with parallel route segments.\n+  const fallbackRouteParams: FallbackRouteParam[] = []\n+  for (const fallbackRouteParam of collected) {\n+    if (fallbackRouteParam.isParallelRouteParam) {\n+      // Try to see if we can resolve this parameter from the page that was\n+      // passed in.\n+      if (unknownParamKeys.has(fallbackRouteParam.paramName)) {\n+        // The parameter is known, we can skip adding it to the fallback route\n+        // params.\n+        continue\n+      }\n+\n+      if (\n+        fallbackRouteParam.paramType === 'optional-catchall' ||\n+        fallbackRouteParam.paramType === 'catchall'\n+      ) {\n+        // If there are any fallback route segments then we can't use the\n+        // pathname to derive the value because it's not complete. We can\n+        // make this assumption because the routes are always resolved left\n+        // to right and the catchall is always the last segment, so any\n+        // route parameters that are unknown will always contribute to the\n+        // pathname and therefore the catchall param too.\n+        if (\n+          collected.some(\n+            (param) =>\n+              !param.isParallelRouteParam &&\n+              unknownParamKeys.has(param.paramName)\n+          )\n+        ) {\n+          fallbackRouteParams.push(fallbackRouteParam)\n+          continue\n+        }\n+\n+        if (\n+          pathSegments.length === 0 &&\n+          fallbackRouteParam.paramType !== 'optional-catchall'\n+        ) {\n+          // We shouldn't be able to match a catchall segment without any path\n+          // segments if it's not an optional catchall.\n+          throw new InvariantError(\n+            `Unexpected empty path segments match for a pathname \"${page}\" with param \"${fallbackRouteParam.paramName}\" of type \"${fallbackRouteParam.paramType}\"`\n+          )\n+        }\n+\n+        // The path segments are not empty, and the segments didn't contain any\n+        // unknown params, so we know that this particular fallback route param\n+        // route param is not actually unknown, and is known. We can skip adding\n+        // it to the fallback route params.\n+      } else {\n+        // This is some other type of route param that shouldn't get resolved\n+        // statically.\n+        throw new InvariantError(\n+          `Unexpected match for a pathname \"${page}\" with a param \"${fallbackRouteParam.paramName}\" of type \"${fallbackRouteParam.paramType}\"`\n+        )\n+      }\n+    } else if (unknownParamKeys.has(fallbackRouteParam.paramName)) {\n+      // As this is a non-parallel route segment, and it exists in the unknown\n+      // param keys, we know it's a fallback route param.\n+      fallbackRouteParams.push(fallbackRouteParam)\n+    }\n   }\n \n-  return params\n+  return createOpaqueFallbackRouteParams(fallbackRouteParams)\n }"
        },
        {
            "sha": "2f0724c06762c129409d24adf4e7ee21d8c8a99f",
            "filename": "packages/next/src/server/request/params.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -2,7 +2,7 @@ import {\n   workAsyncStorage,\n   type WorkStore,\n } from '../app-render/work-async-storage.external'\n-import type { FallbackRouteParams } from './fallback-params'\n+import type { OpaqueFallbackRouteParams } from './fallback-params'\n \n import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n import {\n@@ -336,7 +336,7 @@ function createRenderParamsInProd(underlyingParams: Params): Promise<Params> {\n \n function createRenderParamsInDev(\n   underlyingParams: Params,\n-  devFallbackParams: FallbackRouteParams | null | undefined,\n+  devFallbackParams: OpaqueFallbackRouteParams | null | undefined,\n   workStore: WorkStore\n ): Promise<Params> {\n   let hasFallbackParams = false\n@@ -419,7 +419,7 @@ function makeHangingParams(\n \n function makeErroringExoticParams(\n   underlyingParams: Params,\n-  fallbackParams: FallbackRouteParams,\n+  fallbackParams: OpaqueFallbackRouteParams,\n   workStore: WorkStore,\n   prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n ): Promise<Params> {"
        },
        {
            "sha": "559299dda5174da92380e220dd87a23411241675",
            "filename": "packages/next/src/server/request/root-params.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Froot-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Froot-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Froot-params.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -14,7 +14,7 @@ import {\n   type StaticPrerenderStore,\n } from '../app-render/work-unit-async-storage.external'\n import { makeHangingPromise } from '../dynamic-rendering-utils'\n-import type { FallbackRouteParams } from './fallback-params'\n+import type { OpaqueFallbackRouteParams } from './fallback-params'\n import type { Params, ParamValue } from './params'\n import {\n   describeStringPropertyAccess,\n@@ -136,7 +136,7 @@ function createPrerenderRootParams(\n \n function makeErroringRootParams(\n   underlyingParams: Params,\n-  fallbackParams: FallbackRouteParams,\n+  fallbackParams: OpaqueFallbackRouteParams,\n   workStore: WorkStore,\n   prerenderStore: PrerenderStorePPR | PrerenderStoreLegacy\n ): Promise<Params> {"
        },
        {
            "sha": "92a1849d625f8334962db38903493f47f1251ec3",
            "filename": "packages/next/src/server/route-modules/app-page/helpers/prerender-manifest-matcher.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fhelpers%2Fprerender-manifest-matcher.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fhelpers%2Fprerender-manifest-matcher.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fhelpers%2Fprerender-manifest-matcher.test.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -34,6 +34,7 @@ function createMockDynamicRoute(\n     fallbackExpire: undefined,\n     fallbackHeaders: undefined,\n     fallbackStatus: undefined,\n+    fallbackRouteParams: undefined,\n     fallbackRootParams: undefined,\n     fallbackSourceRoute: undefined,\n     prefetchDataRoute: undefined,"
        },
        {
            "sha": "147e0a6039a25278237d2859f5e94384a7d7b4bf",
            "filename": "packages/next/src/server/route-modules/app-page/module.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fmodule.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fmodule.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-page%2Fmodule.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -17,7 +17,7 @@ import {\n import * as vendoredContexts from './vendored/contexts/entrypoints'\n import type { BaseNextRequest, BaseNextResponse } from '../../base-http'\n import type { ServerComponentsHmrCache } from '../../response-cache'\n-import type { FallbackRouteParams } from '../../request/fallback-params'\n+import type { OpaqueFallbackRouteParams } from '../../request/fallback-params'\n import { PrerenderManifestMatcher } from './helpers/prerender-manifest-matcher'\n import type { DeepReadonly } from '../../../shared/lib/deep-readonly'\n import {\n@@ -56,7 +56,7 @@ type AppPageUserlandModule = {\n export interface AppPageRouteHandlerContext extends RouteModuleHandleContext {\n   page: string\n   query: NextParsedUrlQuery\n-  fallbackRouteParams: FallbackRouteParams | null\n+  fallbackRouteParams: OpaqueFallbackRouteParams | null\n   renderOpts: RenderOpts\n   serverComponentsHmrCache?: ServerComponentsHmrCache\n   sharedContext: AppSharedContext"
        },
        {
            "sha": "b6837c555c444191aa42cc823e5368819f4f5ac6",
            "filename": "packages/next/src/shared/lib/app-router-types.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-types.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-types.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-types.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -125,16 +125,16 @@ export type Segment =\n   | string\n   | [\n       // Param name\n-      string,\n+      paramName: string,\n       // Param cache key (almost the same as the value, but arrays are\n       // concatenated into strings)\n       // TODO: We should change this to just be the value. Currently we convert\n       // it back to a value when passing to useParams. It only needs to be\n       // a string when converted to a a cache key, but that doesn't mean we\n       // need to store it as that representation.\n-      string,\n+      paramCacheKey: string,\n       // Dynamic param type\n-      DynamicParamTypesShort,\n+      dynamicParamType: DynamicParamTypesShort,\n     ]\n \n /**"
        },
        {
            "sha": "2a1d09c229c3f0de5c617b72991b247c11823b49",
            "filename": "packages/next/src/shared/lib/router/utils/get-dynamic-param.test.ts",
            "status": "added",
            "additions": 732,
            "deletions": 0,
            "changes": 732,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.test.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -0,0 +1,732 @@\n+import {\n+  getDynamicParam,\n+  parseParameter,\n+  parseMatchedParameter,\n+} from './get-dynamic-param'\n+import type { Params } from '../../../../server/request/params'\n+import { InvariantError } from '../../invariant-error'\n+import { createMockOpaqueFallbackRouteParams } from '../../../../server/app-render/postponed-state.test'\n+\n+describe('getDynamicParam', () => {\n+  describe('basic dynamic parameters (d, di)', () => {\n+    it('should handle simple string parameter', () => {\n+      const params: Params = { slug: 'hello-world' }\n+      const result = getDynamicParam(params, 'slug', 'd', '/blog/[slug]', null)\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: 'hello-world',\n+        type: 'd',\n+        treeSegment: ['slug', 'hello-world', 'd'],\n+      })\n+    })\n+\n+    it('should encode special characters in string parameters', () => {\n+      const params: Params = { slug: 'hello world & stuff' }\n+      const result = getDynamicParam(params, 'slug', 'd', '/blog/[slug]', null)\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: 'hello%20world%20%26%20stuff',\n+        type: 'd',\n+        treeSegment: ['slug', 'hello%20world%20%26%20stuff', 'd'],\n+      })\n+    })\n+\n+    it('should handle unicode characters', () => {\n+      const params: Params = { slug: 'caf-nave' }\n+      const result = getDynamicParam(params, 'slug', 'd', '/blog/[slug]', null)\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: 'caf%EF%BF%BD-na%EF%BF%BDve',\n+        type: 'd',\n+        treeSegment: ['slug', 'caf%EF%BF%BD-na%EF%BF%BDve', 'd'],\n+      })\n+    })\n+\n+    it('should throw InvariantError for missing dynamic parameter', () => {\n+      const params: Params = {}\n+\n+      expect(() => {\n+        getDynamicParam(params, 'slug', 'd', '/blog/[slug]', null)\n+      }).toThrow(InvariantError)\n+      expect(() => {\n+        getDynamicParam(params, 'slug', 'd', '/blog/[slug]', null)\n+      }).toThrow('Unexpected dynamic param type: d')\n+    })\n+\n+    it('should throw InvariantError for dynamic intercepted parameter without value', () => {\n+      const params: Params = {}\n+\n+      expect(() => {\n+        getDynamicParam(params, 'slug', 'di', '/blog/[slug]', null)\n+      }).toThrow(InvariantError)\n+      expect(() => {\n+        getDynamicParam(params, 'slug', 'di', '/blog/[slug]', null)\n+      }).toThrow('Unexpected dynamic param type: di')\n+    })\n+  })\n+\n+  describe('catchall parameters (c, ci)', () => {\n+    it('should handle array of values for catchall', () => {\n+      const params: Params = { slug: ['docs', 'getting-started'] }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/docs/[...slug]',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: ['docs', 'getting-started'],\n+        type: 'c',\n+        treeSegment: ['slug', 'docs/getting-started', 'c'],\n+      })\n+    })\n+\n+    it('should encode array values for catchall', () => {\n+      const params: Params = { slug: ['docs & guides', 'getting started'] }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/docs/[...slug]',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: ['docs%20%26%20guides', 'getting%20started'],\n+        type: 'c',\n+        treeSegment: ['slug', 'docs%20%26%20guides/getting%20started', 'c'],\n+      })\n+    })\n+\n+    it('should handle single string value for catchall', () => {\n+      const params: Params = { slug: 'single-page' }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/docs/[...slug]',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: 'single-page',\n+        type: 'c',\n+        treeSegment: ['slug', 'single-page', 'c'],\n+      })\n+    })\n+\n+    it('should use pagePath fallback when catchall has no value', () => {\n+      const params: Params = {}\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/dashboard/analytics/reports',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: ['dashboard', 'analytics', 'reports'],\n+        type: 'c',\n+        treeSegment: ['slug', 'dashboard/analytics/reports', 'c'],\n+      })\n+    })\n+\n+    it('should handle catchall intercepted (ci) with array values', () => {\n+      const params: Params = { path: ['photo', '123'] }\n+      const result = getDynamicParam(\n+        params,\n+        'path',\n+        'ci',\n+        '/(.)photo/[...path]',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'path',\n+        value: ['photo', '123'],\n+        type: 'ci',\n+        treeSegment: ['path', 'photo/123', 'ci'],\n+      })\n+    })\n+\n+    it('should parse pagePath with dynamic segments for catchall fallback', () => {\n+      const params: Params = { category: 'electronics' }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/shop/[category]/products',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: ['shop', 'electronics', 'products'],\n+        type: 'c',\n+        treeSegment: ['slug', 'shop/electronics/products', 'c'],\n+      })\n+    })\n+\n+    it('should handle pagePath with parallel routes for catchall', () => {\n+      const params: Params = { category: 'books' }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/shop/[category]/@modal/product-details',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: ['shop', 'books', '@modal', 'product-details'],\n+        type: 'c',\n+        treeSegment: ['slug', 'shop/books/@modal/product-details', 'c'],\n+      })\n+    })\n+\n+    it('should handle pagePath with multiple parallel routes for catchall', () => {\n+      const params: Params = {\n+        category: 'electronics',\n+        brand: 'apple',\n+      }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/shop/[category]/[brand]/@sidebar/@modal/details',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: [\n+          'shop',\n+          'electronics',\n+          'apple',\n+          '@sidebar',\n+          '@modal',\n+          'details',\n+        ],\n+        type: 'c',\n+        treeSegment: [\n+          'slug',\n+          'shop/electronics/apple/@sidebar/@modal/details',\n+          'c',\n+        ],\n+      })\n+    })\n+\n+    it('should handle pagePath with parallel routes and static segments for optional catchall when param missing', () => {\n+      const params: Params = { userId: '123' }\n+      const result = getDynamicParam(\n+        params,\n+        'path',\n+        'oc',\n+        '/dashboard/[userId]/@analytics/reports/monthly',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'path',\n+        value: null,\n+        type: 'oc',\n+        treeSegment: ['path', '', 'oc'],\n+      })\n+    })\n+\n+    it('should handle parallel routes with fallback params for catchall', () => {\n+      const params: Params = { category: 'electronics' }\n+      const fallbackParams = createMockOpaqueFallbackRouteParams({\n+        slug: ['%%drp:slug:parallel123%%', 'd'],\n+      })\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'd',\n+        '/shop/[category]/@modal/@sidebar/product',\n+        fallbackParams\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: '%%drp:slug:parallel123%%',\n+        type: 'd',\n+        treeSegment: ['slug', '%%drp:slug:parallel123%%', 'd'],\n+      })\n+    })\n+\n+    it('should handle parallel routes with catchall parameters in the parallel segment', () => {\n+      const params: Params = {\n+        category: 'books',\n+        modalPath: ['details', 'reviews', 'summary'],\n+      }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/shop/[category]/@modal/[...modalPath]/content',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: [\n+          'shop',\n+          'books',\n+          '@modal',\n+          'details',\n+          'reviews',\n+          'summary',\n+          'content',\n+        ],\n+        type: 'c',\n+        treeSegment: [\n+          'slug',\n+          'shop/books/@modal/details/reviews/summary/content',\n+          'c',\n+        ],\n+      })\n+    })\n+\n+    it('should handle parallel routes with optional catchall in parallel segment', () => {\n+      const params: Params = {\n+        userId: '456',\n+        tabPath: ['settings', 'profile'],\n+      }\n+      const result = getDynamicParam(\n+        params,\n+        'content',\n+        'c',\n+        '/dashboard/[userId]/@tabs/[[...tabPath]]/layout',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'content',\n+        value: ['dashboard', '456', '@tabs', 'settings', 'profile', 'layout'],\n+        type: 'c',\n+        treeSegment: [\n+          'content',\n+          'dashboard/456/@tabs/settings/profile/layout',\n+          'c',\n+        ],\n+      })\n+    })\n+\n+    it('should handle multiple parallel routes each with catchall segments', () => {\n+      const params: Params = {\n+        category: 'electronics',\n+        modalPath: ['photo', 'gallery'],\n+        sidebarPath: ['filters', 'brands'],\n+      }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/shop/[category]/@modal/[...modalPath]/@sidebar/[...sidebarPath]/page',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: [\n+          'shop',\n+          'electronics',\n+          '@modal',\n+          'photo',\n+          'gallery',\n+          '@sidebar',\n+          'filters',\n+          'brands',\n+          'page',\n+        ],\n+        type: 'c',\n+        treeSegment: [\n+          'slug',\n+          'shop/electronics/@modal/photo/gallery/@sidebar/filters/brands/page',\n+          'c',\n+        ],\n+      })\n+    })\n+\n+    it('should handle parallel routes with missing catchall in parallel segment', () => {\n+      const params: Params = {\n+        category: 'electronics',\n+        // modalPath is missing\n+      }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/shop/[category]/@modal/[...modalPath]/content',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: ['shop', 'electronics', '@modal', 'modalPath', 'content'],\n+        type: 'c',\n+        treeSegment: ['slug', 'shop/electronics/@modal/modalPath/content', 'c'],\n+      })\n+    })\n+  })\n+\n+  describe('optional catchall parameters (oc)', () => {\n+    it('should handle array of values for optional catchall', () => {\n+      const params: Params = { slug: ['api', 'users', 'create'] }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'oc',\n+        '/api/[[...slug]]',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: ['api', 'users', 'create'],\n+        type: 'oc',\n+        treeSegment: ['slug', 'api/users/create', 'oc'],\n+      })\n+    })\n+\n+    it('should return null value for optional catchall without value', () => {\n+      const params: Params = {}\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'oc',\n+        '/api/[[...slug]]',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: null,\n+        type: 'oc',\n+        treeSegment: ['slug', '', 'oc'],\n+      })\n+    })\n+\n+    it('should encode array values for optional catchall', () => {\n+      const params: Params = { slug: ['hello world', 'caf'] }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'oc',\n+        '/api/[[...slug]]',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: ['hello%20world', 'caf%EF%BF%BD'],\n+        type: 'oc',\n+        treeSegment: ['slug', 'hello%20world/caf%EF%BF%BD', 'oc'],\n+      })\n+    })\n+\n+    it('should handle single string value for optional catchall', () => {\n+      const params: Params = { slug: 'documentation' }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'oc',\n+        '/docs/[[...slug]]',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: 'documentation',\n+        type: 'oc',\n+        treeSegment: ['slug', 'documentation', 'oc'],\n+      })\n+    })\n+  })\n+\n+  describe('fallback route parameters', () => {\n+    it('should use fallback param value when available', () => {\n+      const params: Params = { slug: 'original-value' }\n+      const fallbackParams = createMockOpaqueFallbackRouteParams({\n+        slug: ['%%drp:slug:abc123%%', 'd'],\n+      })\n+\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'd',\n+        '/blog/[slug]',\n+        fallbackParams\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: '%%drp:slug:abc123%%',\n+        type: 'd',\n+        treeSegment: ['slug', '%%drp:slug:abc123%%', 'd'],\n+      })\n+    })\n+\n+    it('should not encode fallback param values', () => {\n+      const params: Params = { slug: 'hello world' }\n+      const fallbackParams = createMockOpaqueFallbackRouteParams({\n+        slug: ['%%drp:slug:xyz789%%', 'd'],\n+      })\n+\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'd',\n+        '/blog/[slug]',\n+        fallbackParams\n+      )\n+\n+      expect(result.value).toBe('%%drp:slug:xyz789%%')\n+    })\n+\n+    it('should use fallback params with catchall routes', () => {\n+      const params: Params = { slug: ['docs', 'api'] }\n+      const fallbackParams = createMockOpaqueFallbackRouteParams({\n+        slug: ['%%drp:slug:def456%%', 'c'],\n+      })\n+\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/docs/[...slug]',\n+        fallbackParams\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: '%%drp:slug:def456%%',\n+        type: 'c',\n+        treeSegment: ['slug', '%%drp:slug:def456%%', 'c'],\n+      })\n+    })\n+\n+    it('should use fallback params with optional catchall routes', () => {\n+      const params: Params = {}\n+      const fallbackParams = createMockOpaqueFallbackRouteParams({\n+        slug: ['%%drp:slug:ghi789%%', 'oc'],\n+      })\n+\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'oc',\n+        '/api/[[...slug]]',\n+        fallbackParams\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: '%%drp:slug:ghi789%%',\n+        type: 'oc',\n+        treeSegment: ['slug', '%%drp:slug:ghi789%%', 'oc'],\n+      })\n+    })\n+\n+    it('should fall back to regular encoding when param not in fallback', () => {\n+      const params: Params = { slug: 'hello world' }\n+      const fallbackParams = createMockOpaqueFallbackRouteParams({\n+        other: ['%%drp:other:abc123%%', 'd'],\n+      })\n+\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'd',\n+        '/blog/[slug]',\n+        fallbackParams\n+      )\n+\n+      expect(result.value).toBe('hello%20world')\n+    })\n+  })\n+\n+  describe('edge cases', () => {\n+    it('should throw InvariantError for empty string values', () => {\n+      const params: Params = { slug: '' }\n+\n+      expect(() => {\n+        getDynamicParam(params, 'slug', 'd', '/blog/[slug]', null)\n+      }).toThrow(InvariantError)\n+      expect(() => {\n+        getDynamicParam(params, 'slug', 'd', '/blog/[slug]', null)\n+      }).toThrow('Unexpected dynamic param type: d')\n+    })\n+\n+    it('should handle empty array for catchall', () => {\n+      const params: Params = { slug: [] }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/docs/guide/tutorial',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: [],\n+        type: 'c',\n+        treeSegment: ['slug', '', 'c'],\n+      })\n+    })\n+\n+    it('should handle complex pagePath parsing for catchall', () => {\n+      const params: Params = {\n+        category: 'electronics',\n+        brand: 'apple',\n+      }\n+      const result = getDynamicParam(\n+        params,\n+        'slug',\n+        'c',\n+        '/shop/[category]/[brand]/products/featured',\n+        null\n+      )\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: ['shop', 'electronics', 'apple', 'products', 'featured'],\n+        type: 'c',\n+        treeSegment: ['slug', 'shop/electronics/apple/products/featured', 'c'],\n+      })\n+    })\n+\n+    it('should handle root path for catchall without value', () => {\n+      const params: Params = {}\n+      const result = getDynamicParam(params, 'slug', 'c', '/', null)\n+\n+      expect(result).toEqual({\n+        param: 'slug',\n+        value: [''],\n+        type: 'c',\n+        treeSegment: ['slug', '', 'c'],\n+      })\n+    })\n+\n+    it('should handle undefined param values', () => {\n+      const params: Params = { slug: undefined }\n+\n+      expect(() => {\n+        getDynamicParam(params, 'slug', 'd', '/blog/[slug]', null)\n+      }).toThrow(InvariantError)\n+    })\n+  })\n+})\n+\n+describe('parseParameter', () => {\n+  it('should parse simple dynamic parameter', () => {\n+    expect(parseParameter('[slug]')).toEqual({\n+      key: 'slug',\n+      repeat: false,\n+      optional: false,\n+    })\n+  })\n+\n+  it('should parse optional parameter', () => {\n+    expect(parseParameter('[[slug]]')).toEqual({\n+      key: 'slug',\n+      repeat: false,\n+      optional: true,\n+    })\n+  })\n+\n+  it('should parse catchall parameter', () => {\n+    expect(parseParameter('[...slug]')).toEqual({\n+      key: 'slug',\n+      repeat: true,\n+      optional: false,\n+    })\n+  })\n+\n+  it('should parse optional catchall parameter', () => {\n+    expect(parseParameter('[[...slug]]')).toEqual({\n+      key: 'slug',\n+      repeat: true,\n+      optional: true,\n+    })\n+  })\n+\n+  it('should parse static segment as non-optional, non-repeat', () => {\n+    expect(parseParameter('static-page')).toEqual({\n+      key: 'static-page',\n+      repeat: false,\n+      optional: false,\n+    })\n+  })\n+\n+  it('should handle complex parameter names', () => {\n+    expect(parseParameter('[product-id]')).toEqual({\n+      key: 'product-id',\n+      repeat: false,\n+      optional: false,\n+    })\n+  })\n+\n+  it('should parse parameter with prefix/suffix', () => {\n+    expect(parseParameter('prefix[slug]suffix')).toEqual({\n+      key: 'slug',\n+      repeat: false,\n+      optional: false,\n+    })\n+  })\n+})\n+\n+describe('parseMatchedParameter', () => {\n+  it('should parse matched simple parameter', () => {\n+    expect(parseMatchedParameter('slug')).toEqual({\n+      key: 'slug',\n+      repeat: false,\n+      optional: false,\n+    })\n+  })\n+\n+  it('should parse matched optional parameter', () => {\n+    expect(parseMatchedParameter('[slug]')).toEqual({\n+      key: 'slug',\n+      repeat: false,\n+      optional: true,\n+    })\n+  })\n+\n+  it('should parse matched catchall parameter', () => {\n+    expect(parseMatchedParameter('...slug')).toEqual({\n+      key: 'slug',\n+      repeat: true,\n+      optional: false,\n+    })\n+  })\n+\n+  it('should parse matched optional catchall parameter', () => {\n+    expect(parseMatchedParameter('[...slug]')).toEqual({\n+      key: 'slug',\n+      repeat: true,\n+      optional: true,\n+    })\n+  })\n+\n+  it('should handle parameter names with special characters', () => {\n+    expect(parseMatchedParameter('[product_id-123]')).toEqual({\n+      key: 'product_id-123',\n+      repeat: false,\n+      optional: true,\n+    })\n+  })\n+})"
        },
        {
            "sha": "92fef4293f56b2594c1e371fa5c8c67d757d9faf",
            "filename": "packages/next/src/shared/lib/router/utils/get-dynamic-param.ts",
            "status": "modified",
            "additions": 57,
            "deletions": 14,
            "changes": 71,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -1,6 +1,39 @@\n import type { DynamicParam } from '../../../../server/app-render/app-render'\n+import type { OpaqueFallbackRouteParams } from '../../../../server/request/fallback-params'\n+import type { Params } from '../../../../server/request/params'\n import type { DynamicParamTypesShort } from '../../app-router-types'\n-import type { FallbackRouteParams } from '../../../../server/request/fallback-params'\n+import { InvariantError } from '../../invariant-error'\n+\n+/**\n+ * Gets the value of a param from the params object. This correctly handles the\n+ * case where the param is a fallback route param and encodes the resulting\n+ * value.\n+ *\n+ * @param params - The params object.\n+ * @param segmentKey - The key of the segment.\n+ * @param fallbackRouteParams - The fallback route params.\n+ * @returns The value of the param.\n+ */\n+function getParamValue(\n+  params: Params,\n+  segmentKey: string,\n+  fallbackRouteParams: OpaqueFallbackRouteParams | null\n+) {\n+  let value = params[segmentKey]\n+\n+  if (fallbackRouteParams && fallbackRouteParams.has(segmentKey)) {\n+    // We know that the fallback route params has the segment key because we\n+    // checked that above.\n+    const [searchValue] = fallbackRouteParams.get(segmentKey)!\n+    value = searchValue\n+  } else if (Array.isArray(value)) {\n+    value = value.map((i) => encodeURIComponent(i))\n+  } else if (typeof value === 'string') {\n+    value = encodeURIComponent(value)\n+  }\n+\n+  return value\n+}\n \n /**\n  *\n@@ -14,21 +47,17 @@ import type { FallbackRouteParams } from '../../../../server/request/fallback-pa\n  * and optional is, alas, unfortunate.\n  */\n export function getDynamicParam(\n-  params: { [key: string]: any },\n+  params: Params,\n   segmentKey: string,\n   dynamicParamType: DynamicParamTypesShort,\n   pagePath: string,\n-  fallbackRouteParams: FallbackRouteParams | null\n+  fallbackRouteParams: OpaqueFallbackRouteParams | null\n ): DynamicParam {\n-  let value = params[segmentKey]\n-\n-  if (fallbackRouteParams && fallbackRouteParams.has(segmentKey)) {\n-    value = fallbackRouteParams.get(segmentKey)\n-  } else if (Array.isArray(value)) {\n-    value = value.map((i) => encodeURIComponent(i))\n-  } else if (typeof value === 'string') {\n-    value = encodeURIComponent(value)\n-  }\n+  let value: string | string[] | undefined = getParamValue(\n+    params,\n+    segmentKey,\n+    fallbackRouteParams\n+  )\n \n   if (!value) {\n     const isCatchall = dynamicParamType === 'c'\n@@ -48,32 +77,46 @@ export function getDynamicParam(\n \n       // handle the case where a catchall or optional catchall does not have a value,\n       // e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched\n+      // FIXME: (NAR-335) this should handle prefixed segments\n       value = pagePath\n         .split('/')\n         // remove the first empty string\n         .slice(1)\n         // replace any dynamic params with the actual values\n         .flatMap((pathSegment) => {\n           const param = parseParameter(pathSegment)\n+\n           // if the segment matches a param, return the param value\n           // otherwise, it's a static segment, so just return that\n-          return params[param.key] ?? param.key\n+          return (\n+            getParamValue(params, param.key, fallbackRouteParams) ?? param.key\n+          )\n         })\n \n+      if (!value) {\n+        throw new InvariantError(\n+          `No value found for segment key: \"${segmentKey}\"`\n+        )\n+      }\n+\n       return {\n         param: segmentKey,\n         value,\n         type: dynamicParamType,\n         // This value always has to be a string.\n         treeSegment: [segmentKey, value.join('/'), dynamicParamType],\n       }\n+    } else {\n+      throw new InvariantError(\n+        `Unexpected dynamic param type: ${dynamicParamType}`\n+      )\n     }\n   }\n \n   return {\n     param: segmentKey,\n     // The value that is passed to user code.\n-    value: value,\n+    value,\n     // The value that is rendered in the router tree.\n     treeSegment: [\n       segmentKey,"
        },
        {
            "sha": "469c0edffb385af6031c178ad2fa5573f55d897c",
            "filename": "test/cache-components-tests-manifest.json",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/test%2Fcache-components-tests-manifest.json",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/test%2Fcache-components-tests-manifest.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fcache-components-tests-manifest.json?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -222,7 +222,6 @@\n       \"test/e2e/app-dir/parallel-routes-and-interception-from-root/parallel-routes-and-interception-from-root.test.ts\",\n       \"test/e2e/app-dir/parallel-routes-and-interception-nested-dynamic-routes/parallel-routes-and-interception-nested-dynamic-routes.test.ts\",\n       \"test/e2e/app-dir/parallel-routes-and-interception/parallel-routes-and-interception.test.ts\",\n-      \"test/e2e/app-dir/parallel-routes-breadcrumbs/parallel-routes-breadcrumbs.test.ts\",\n       \"test/e2e/app-dir/parallel-routes-catchall-specificity/parallel-routes-catchall-specificity.test.ts\",\n       \"test/e2e/app-dir/parallel-routes-generate-static-params/parallel-routes-generate-static-params.test.ts\",\n       \"test/e2e/app-dir/parallel-routes-revalidation/parallel-routes-revalidation.test.ts\","
        },
        {
            "sha": "4679c6844b88ff13408f62f07956370248e7f7bb",
            "filename": "test/e2e/app-dir/app-static/app-static.test.ts",
            "status": "modified",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/test%2Fe2e%2Fapp-dir%2Fapp-static%2Fapp-static.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/test%2Fe2e%2Fapp-dir%2Fapp-static%2Fapp-static.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-static%2Fapp-static.test.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -985,6 +985,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/\",\n          },\n          \"/_not-found\": {\n@@ -1010,6 +1011,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialRevalidateSeconds\": false,\n            \"initialStatus\": 404,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/_not-found\",\n          },\n          \"/api/large-data\": {\n@@ -1038,6 +1040,7 @@ describe('app-dir static/dynamic handling', () => {\n              \"x-next-cache-tags\": \"_N_T_/layout,_N_T_/api/layout,_N_T_/api/large-data/layout,_N_T_/api/large-data/route,_N_T_/api/large-data\",\n            },\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/api/large-data\",\n          },\n          \"/articles/works\": {\n@@ -1063,6 +1066,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 1,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/articles/[slug]\",\n          },\n          \"/blog/seb\": {\n@@ -1088,6 +1092,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 10,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/blog/[author]\",\n          },\n          \"/blog/seb/second-post\": {\n@@ -1112,6 +1117,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/blog/[author]/[slug]\",\n          },\n          \"/blog/styfle\": {\n@@ -1137,6 +1143,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 10,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/blog/[author]\",\n          },\n          \"/blog/styfle/first-post\": {\n@@ -1161,6 +1168,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/blog/[author]/[slug]\",\n          },\n          \"/blog/styfle/second-post\": {\n@@ -1185,6 +1193,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/blog/[author]/[slug]\",\n          },\n          \"/blog/tim\": {\n@@ -1210,6 +1219,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 10,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/blog/[author]\",\n          },\n          \"/blog/tim/first-post\": {\n@@ -1234,6 +1244,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/blog/[author]/[slug]\",\n          },\n          \"/default-config-fetch\": {\n@@ -1258,6 +1269,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/default-config-fetch\",\n          },\n          \"/force-cache\": {\n@@ -1283,6 +1295,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 3,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/force-cache\",\n          },\n          \"/force-static-fetch-no-store\": {\n@@ -1307,6 +1320,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/force-static-fetch-no-store\",\n          },\n          \"/force-static/first\": {\n@@ -1331,6 +1345,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/force-static/[slug]\",\n          },\n          \"/force-static/second\": {\n@@ -1355,6 +1370,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/force-static/[slug]\",\n          },\n          \"/gen-params-catch-all-unique/foo/bar\": {\n@@ -1379,6 +1395,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/gen-params-catch-all-unique/[...slug]\",\n          },\n          \"/gen-params-catch-all-unique/foo/foo\": {\n@@ -1403,6 +1420,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/gen-params-catch-all-unique/[...slug]\",\n          },\n          \"/gen-params-dynamic-revalidate/one\": {\n@@ -1428,6 +1446,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 3,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/gen-params-dynamic-revalidate/[slug]\",\n          },\n          \"/hooks/use-pathname/slug\": {\n@@ -1452,6 +1471,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/hooks/use-pathname/[slug]\",\n          },\n          \"/hooks/use-search-params/force-static\": {\n@@ -1476,6 +1496,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/hooks/use-search-params/force-static\",\n          },\n          \"/hooks/use-search-params/with-suspense\": {\n@@ -1500,6 +1521,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/hooks/use-search-params/with-suspense\",\n          },\n          \"/isr-error-handling\": {\n@@ -1525,6 +1547,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 3,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/isr-error-handling\",\n          },\n          \"/no-config-fetch\": {\n@@ -1549,6 +1572,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/no-config-fetch\",\n          },\n          \"/no-store/static\": {\n@@ -1573,6 +1597,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/no-store/static\",\n          },\n          \"/partial-gen-params-no-additional-lang/en/RAND\": {\n@@ -1597,6 +1622,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-gen-params-no-additional-lang/[lang]/[slug]\",\n          },\n          \"/partial-gen-params-no-additional-lang/en/first\": {\n@@ -1621,6 +1647,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-gen-params-no-additional-lang/[lang]/[slug]\",\n          },\n          \"/partial-gen-params-no-additional-lang/en/second\": {\n@@ -1645,6 +1672,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-gen-params-no-additional-lang/[lang]/[slug]\",\n          },\n          \"/partial-gen-params-no-additional-lang/fr/RAND\": {\n@@ -1669,6 +1697,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-gen-params-no-additional-lang/[lang]/[slug]\",\n          },\n          \"/partial-gen-params-no-additional-lang/fr/first\": {\n@@ -1693,6 +1722,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-gen-params-no-additional-lang/[lang]/[slug]\",\n          },\n          \"/partial-gen-params-no-additional-lang/fr/second\": {\n@@ -1717,6 +1747,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-gen-params-no-additional-lang/[lang]/[slug]\",\n          },\n          \"/partial-gen-params-no-additional-slug/en/RAND\": {\n@@ -1741,6 +1772,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-gen-params-no-additional-slug/[lang]/[slug]\",\n          },\n          \"/partial-gen-params-no-additional-slug/en/first\": {\n@@ -1765,6 +1797,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-gen-params-no-additional-slug/[lang]/[slug]\",\n          },\n          \"/partial-gen-params-no-additional-slug/en/second\": {\n@@ -1789,6 +1822,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-gen-params-no-additional-slug/[lang]/[slug]\",\n          },\n          \"/partial-gen-params-no-additional-slug/fr/RAND\": {\n@@ -1813,6 +1847,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-gen-params-no-additional-slug/[lang]/[slug]\",\n          },\n          \"/partial-gen-params-no-additional-slug/fr/first\": {\n@@ -1837,6 +1872,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-gen-params-no-additional-slug/[lang]/[slug]\",\n          },\n          \"/partial-gen-params-no-additional-slug/fr/second\": {\n@@ -1861,6 +1897,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-gen-params-no-additional-slug/[lang]/[slug]\",\n          },\n          \"/partial-params-false/en/static\": {\n@@ -1885,6 +1922,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-params-false/[locale]/static\",\n          },\n          \"/partial-params-false/fr/static\": {\n@@ -1909,6 +1947,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/partial-params-false/[locale]/static\",\n          },\n          \"/prerendered-not-found/first\": {\n@@ -1933,6 +1972,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/prerendered-not-found/[slug]\",\n          },\n          \"/prerendered-not-found/second\": {\n@@ -1957,6 +1997,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/prerendered-not-found/[slug]\",\n          },\n          \"/prerendered-not-found/segment-revalidate\": {\n@@ -1982,6 +2023,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 3,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/prerendered-not-found/segment-revalidate\",\n          },\n          \"/route-handler/no-store-force-static\": {\n@@ -2011,6 +2053,7 @@ describe('app-dir static/dynamic handling', () => {\n              \"x-next-cache-tags\": \"_N_T_/layout,_N_T_/route-handler/layout,_N_T_/route-handler/no-store-force-static/layout,_N_T_/route-handler/no-store-force-static/route,_N_T_/route-handler/no-store-force-static\",\n            },\n            \"initialRevalidateSeconds\": 3,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/route-handler/no-store-force-static\",\n          },\n          \"/route-handler/revalidate-360-isr\": {\n@@ -2040,6 +2083,7 @@ describe('app-dir static/dynamic handling', () => {\n              \"x-next-cache-tags\": \"_N_T_/layout,_N_T_/route-handler/layout,_N_T_/route-handler/revalidate-360-isr/layout,_N_T_/route-handler/revalidate-360-isr/route,_N_T_/route-handler/revalidate-360-isr,thankyounext\",\n            },\n            \"initialRevalidateSeconds\": 10,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/route-handler/revalidate-360-isr\",\n          },\n          \"/route-handler/static-cookies\": {\n@@ -2068,6 +2112,7 @@ describe('app-dir static/dynamic handling', () => {\n              \"x-next-cache-tags\": \"_N_T_/layout,_N_T_/route-handler/layout,_N_T_/route-handler/static-cookies/layout,_N_T_/route-handler/static-cookies/route,_N_T_/route-handler/static-cookies\",\n            },\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/route-handler/static-cookies\",\n          },\n          \"/ssg-draft-mode\": {\n@@ -2092,6 +2137,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/ssg-draft-mode/[[...route]]\",\n          },\n          \"/ssg-draft-mode/test\": {\n@@ -2116,6 +2162,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/ssg-draft-mode/[[...route]]\",\n          },\n          \"/ssg-draft-mode/test-2\": {\n@@ -2140,6 +2187,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/ssg-draft-mode/[[...route]]\",\n          },\n          \"/strip-w3c-trace-context-headers\": {\n@@ -2165,6 +2213,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 50,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/strip-w3c-trace-context-headers\",\n          },\n          \"/unstable-cache/fetch/no-cache\": {\n@@ -2189,6 +2238,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/unstable-cache/fetch/no-cache\",\n          },\n          \"/unstable-cache/fetch/no-store\": {\n@@ -2213,6 +2263,7 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"initialRevalidateSeconds\": false,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/unstable-cache/fetch/no-store\",\n          },\n          \"/variable-config-revalidate/revalidate-3\": {\n@@ -2238,6 +2289,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 3,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/variable-config-revalidate/revalidate-3\",\n          },\n          \"/variable-revalidate-stable/revalidate-3\": {\n@@ -2263,6 +2315,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 3,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/variable-revalidate-stable/revalidate-3\",\n          },\n          \"/variable-revalidate/authorization\": {\n@@ -2288,6 +2341,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 10,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/variable-revalidate/authorization\",\n          },\n          \"/variable-revalidate/cookie\": {\n@@ -2313,6 +2367,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 3,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/variable-revalidate/cookie\",\n          },\n          \"/variable-revalidate/encoding\": {\n@@ -2338,6 +2393,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 3,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/variable-revalidate/encoding\",\n          },\n          \"/variable-revalidate/headers-instance\": {\n@@ -2363,6 +2419,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 10,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/variable-revalidate/headers-instance\",\n          },\n          \"/variable-revalidate/revalidate-3\": {\n@@ -2388,6 +2445,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 3,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/variable-revalidate/revalidate-3\",\n          },\n          \"/variable-revalidate/revalidate-360-isr\": {\n@@ -2413,6 +2471,7 @@ describe('app-dir static/dynamic handling', () => {\n            ],\n            \"initialExpireSeconds\": 31536000,\n            \"initialRevalidateSeconds\": 10,\n+           \"prefetchDataRoute\": null,\n            \"srcRoute\": \"/variable-revalidate/revalidate-360-isr\",\n          },\n        }\n@@ -2442,6 +2501,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": null,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/articles\\\\/([^\\\\/]+?)(?:\\\\/)?$\",\n          },\n          \"/blog/[author]\": {\n@@ -2467,6 +2528,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": false,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/blog\\\\/([^\\\\/]+?)(?:\\\\/)?$\",\n          },\n          \"/blog/[author]/[slug]\": {\n@@ -2492,6 +2555,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": null,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/blog\\\\/([^\\\\/]+?)\\\\/([^\\\\/]+?)(?:\\\\/)?$\",\n          },\n          \"/dynamic-error/[id]\": {\n@@ -2517,6 +2582,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": null,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/dynamic\\\\-error\\\\/([^\\\\/]+?)(?:\\\\/)?$\",\n          },\n          \"/force-static/[slug]\": {\n@@ -2542,6 +2609,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": null,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/force\\\\-static\\\\/([^\\\\/]+?)(?:\\\\/)?$\",\n          },\n          \"/gen-params-catch-all-unique/[...slug]\": {\n@@ -2567,6 +2636,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": false,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/gen\\\\-params\\\\-catch\\\\-all\\\\-unique\\\\/(.+?)(?:\\\\/)?$\",\n          },\n          \"/gen-params-dynamic-revalidate/[slug]\": {\n@@ -2592,6 +2663,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": null,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/gen\\\\-params\\\\-dynamic\\\\-revalidate\\\\/([^\\\\/]+?)(?:\\\\/)?$\",\n          },\n          \"/hooks/use-pathname/[slug]\": {\n@@ -2617,6 +2690,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": null,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/hooks\\\\/use\\\\-pathname\\\\/([^\\\\/]+?)(?:\\\\/)?$\",\n          },\n          \"/partial-gen-params-no-additional-lang/[lang]/[slug]\": {\n@@ -2642,6 +2717,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": false,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/partial\\\\-gen\\\\-params\\\\-no\\\\-additional\\\\-lang\\\\/([^\\\\/]+?)\\\\/([^\\\\/]+?)(?:\\\\/)?$\",\n          },\n          \"/partial-gen-params-no-additional-slug/[lang]/[slug]\": {\n@@ -2667,6 +2744,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": false,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/partial\\\\-gen\\\\-params\\\\-no\\\\-additional\\\\-slug\\\\/([^\\\\/]+?)\\\\/([^\\\\/]+?)(?:\\\\/)?$\",\n          },\n          \"/partial-params-false/[locale]/static\": {\n@@ -2692,6 +2771,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": false,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/partial\\\\-params\\\\-false\\\\/([^\\\\/]+?)\\\\/static(?:\\\\/)?$\",\n          },\n          \"/prerendered-not-found/[slug]\": {\n@@ -2717,6 +2798,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": null,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/prerendered\\\\-not\\\\-found\\\\/([^\\\\/]+?)(?:\\\\/)?$\",\n          },\n          \"/ssg-draft-mode/[[...route]]\": {\n@@ -2742,6 +2825,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": null,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/ssg\\\\-draft\\\\-mode(?:\\\\/(.+?))?(?:\\\\/)?$\",\n          },\n          \"/static-to-dynamic-error-forced/[id]\": {\n@@ -2767,6 +2852,8 @@ describe('app-dir static/dynamic handling', () => {\n              },\n            ],\n            \"fallback\": null,\n+           \"fallbackRouteParams\": [],\n+           \"prefetchDataRoute\": null,\n            \"routeRegex\": \"^\\\\/static\\\\-to\\\\-dynamic\\\\-error\\\\-forced\\\\/([^\\\\/]+?)(?:\\\\/)?$\",\n          },\n        }"
        },
        {
            "sha": "9619891541a2a412a1760574509aaf991b684962",
            "filename": "test/e2e/app-dir/parallel-routes-breadcrumbs/app/layout.tsx",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/test%2Fe2e%2Fapp-dir%2Fparallel-routes-breadcrumbs%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/test%2Fe2e%2Fapp-dir%2Fparallel-routes-breadcrumbs%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fparallel-routes-breadcrumbs%2Fapp%2Flayout.tsx?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -1,4 +1,4 @@\n-import React from 'react'\n+import React, { Suspense } from 'react'\n \n export default function Root({\n   children,\n@@ -10,8 +10,12 @@ export default function Root({\n   return (\n     <html>\n       <body>\n-        <div id=\"slot\">{slot}</div>\n-        <div id=\"children\">{children}</div>\n+        <Suspense>\n+          <div id=\"slot\">{slot}</div>\n+        </Suspense>\n+        <Suspense>\n+          <div id=\"children\">{children}</div>\n+        </Suspense>\n       </body>\n     </html>\n   )"
        },
        {
            "sha": "05e3fa49ba2b714bcf271463b30ced4687e52946",
            "filename": "test/e2e/app-dir/rewrite-headers/rewrite-headers.test.ts",
            "status": "modified",
            "additions": 57,
            "deletions": 3,
            "changes": 60,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/test%2Fe2e%2Fapp-dir%2Frewrite-headers%2Frewrite-headers.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/test%2Fe2e%2Fapp-dir%2Frewrite-headers%2Frewrite-headers.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Frewrite-headers%2Frewrite-headers.test.ts?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -10,7 +10,11 @@ const cases: {\n   pathname: string\n   only?: boolean\n   debug?: true\n-  headers?: Record<string, string>\n+  headers?: {\n+    rsc?: '1'\n+    'next-router-prefetch'?: '0' | '1' | '2'\n+    'next-router-segment-prefetch'?: string\n+  }\n   expected: Record<Target, string | null>\n }[] = [\n   {\n@@ -38,6 +42,11 @@ const cases: {\n     headers: {\n       rsc: '1',\n       'next-router-prefetch': '1',\n+      ...(process.env.__NEXT_EXPERIMENTAL_PPR === 'true'\n+        ? {\n+            'next-router-segment-prefetch': '/_tree',\n+          }\n+        : {}),\n     },\n     expected: {\n       'x-nextjs-rewritten-path': null,\n@@ -69,6 +78,11 @@ const cases: {\n     headers: {\n       rsc: '1',\n       'next-router-prefetch': '1',\n+      ...(process.env.__NEXT_EXPERIMENTAL_PPR === 'true'\n+        ? {\n+            'next-router-segment-prefetch': '/_tree',\n+          }\n+        : {}),\n     },\n     expected: {\n       'x-nextjs-rewritten-path': null,\n@@ -100,6 +114,11 @@ const cases: {\n     headers: {\n       rsc: '1',\n       'next-router-prefetch': '1',\n+      ...(process.env.__NEXT_EXPERIMENTAL_PPR === 'true'\n+        ? {\n+            'next-router-segment-prefetch': '/_tree',\n+          }\n+        : {}),\n     },\n     // only: true,\n     expected: {\n@@ -132,6 +151,11 @@ const cases: {\n     headers: {\n       rsc: '1',\n       'next-router-prefetch': '1',\n+      ...(process.env.__NEXT_EXPERIMENTAL_PPR === 'true'\n+        ? {\n+            'next-router-segment-prefetch': '/_tree',\n+          }\n+        : {}),\n     },\n     expected: {\n       'x-nextjs-rewritten-path': '/hello/bobby',\n@@ -163,6 +187,11 @@ const cases: {\n     headers: {\n       rsc: '1',\n       'next-router-prefetch': '1',\n+      ...(process.env.__NEXT_EXPERIMENTAL_PPR === 'true'\n+        ? {\n+            'next-router-segment-prefetch': '/_tree',\n+          }\n+        : {}),\n     },\n     expected: {\n       'x-nextjs-rewritten-path': null,\n@@ -194,6 +223,11 @@ const cases: {\n     headers: {\n       rsc: '1',\n       'next-router-prefetch': '1',\n+      ...(process.env.__NEXT_EXPERIMENTAL_PPR === 'true'\n+        ? {\n+            'next-router-segment-prefetch': '/_tree',\n+          }\n+        : {}),\n     },\n     expected: {\n       'x-nextjs-rewritten-path': null,\n@@ -225,6 +259,11 @@ const cases: {\n     headers: {\n       rsc: '1',\n       'next-router-prefetch': '1',\n+      ...(process.env.__NEXT_EXPERIMENTAL_PPR === 'true'\n+        ? {\n+            'next-router-segment-prefetch': '/_tree',\n+          }\n+        : {}),\n     },\n     expected: {\n       'x-nextjs-rewritten-path': '/hello/samantha',\n@@ -256,6 +295,11 @@ const cases: {\n     headers: {\n       rsc: '1',\n       'next-router-prefetch': '1',\n+      ...(process.env.__NEXT_EXPERIMENTAL_PPR === 'true'\n+        ? {\n+            'next-router-segment-prefetch': '/_tree',\n+          }\n+        : {}),\n     },\n     expected: {\n       'x-nextjs-rewritten-path': '/other',\n@@ -295,6 +339,11 @@ const cases: {\n     headers: {\n       rsc: '1',\n       'next-router-prefetch': '1',\n+      ...(process.env.__NEXT_EXPERIMENTAL_PPR === 'true'\n+        ? {\n+            'next-router-segment-prefetch': '/_tree',\n+          }\n+        : {}),\n     },\n     expected: {\n       'x-nextjs-rewritten-path': null,\n@@ -393,6 +442,11 @@ const cases: {\n     headers: {\n       rsc: '1',\n       'next-router-prefetch': '1',\n+      ...(process.env.__NEXT_EXPERIMENTAL_PPR === 'true'\n+        ? {\n+            'next-router-segment-prefetch': '/_tree',\n+          }\n+        : {}),\n     },\n     expected: {\n       'x-nextjs-rewritten-path': '/other',\n@@ -418,9 +472,9 @@ describe('rewrite-headers', () => {\n         // Add cache busting param for RSC requests\n         if (headers.rsc === '1') {\n           const cacheBustingParam = computeCacheBustingSearchParam(\n-            headers['next-router-prefetch'] ? '1' : '0',\n+            headers['next-router-prefetch'],\n+            headers['next-router-segment-prefetch'],\n             undefined,\n-            headers['next-router-state-tree'],\n             undefined\n           )\n           if (cacheBustingParam) {"
        },
        {
            "sha": "6020bbbe8c2ef3079fc2711b7c20f1f3ccc6f71e",
            "filename": "test/integration/custom-routes/test/index.test.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -2428,6 +2428,7 @@ const runTests = (isDev = false) => {\n            \"fallback\": [],\n          },\n          \"rsc\": {\n+           \"clientParamParsing\": false,\n            \"contentTypeHeader\": \"text/x-component\",\n            \"didPostponeHeader\": \"x-nextjs-postponed\",\n            \"header\": \"rsc\","
        },
        {
            "sha": "dffba3a15df4b908fbaad219aefbb110388bd32c",
            "filename": "test/integration/dynamic-routing/test/index.test.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/badf4b6c17255ecfe8f0ff16f8108c7254dd83ac/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js?ref=badf4b6c17255ecfe8f0ff16f8108c7254dd83ac",
            "patch": "@@ -1471,6 +1471,7 @@ function runTests({ dev }) {\n            \"fallback\": [],\n          },\n          \"rsc\": {\n+           \"clientParamParsing\": false,\n            \"contentTypeHeader\": \"text/x-component\",\n            \"didPostponeHeader\": \"x-nextjs-postponed\",\n            \"header\": \"rsc\","
        }
    ],
    "stats": {
        "total": 2532,
        "additions": 2264,
        "deletions": 268
    }
}