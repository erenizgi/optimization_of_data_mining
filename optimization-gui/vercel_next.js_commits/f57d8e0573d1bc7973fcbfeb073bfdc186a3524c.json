{
    "author": "mischnic",
    "message": "Turbopack: resolve `sourceMap.file` (#80625)\n\nThis information is needed in #79459 to match up the right input source maps.",
    "sha": "f57d8e0573d1bc7973fcbfeb073bfdc186a3524c",
    "files": [
        {
            "sha": "2c763a7f67e0033a9a52c24ad9c577289bc4e71f",
            "filename": "turbopack/crates/turbopack-core/src/source_map/utils.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 5,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/f57d8e0573d1bc7973fcbfeb073bfdc186a3524c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f57d8e0573d1bc7973fcbfeb073bfdc186a3524c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Futils.rs?ref=f57d8e0573d1bc7973fcbfeb073bfdc186a3524c",
            "patch": "@@ -69,15 +69,15 @@ struct SourceMapJson {\n     sections: Option<Vec<SourceMapSectionItemJson>>,\n }\n \n-/// Replace the origin prefix in the `sources` with `turbopack:///` and read the the\n+/// Replace the origin prefix in the `file` and `sources` with `turbopack:///` and read the the\n /// `sourceContent`s from disk.\n pub async fn resolve_source_map_sources(\n     map: Option<&Rope>,\n     origin: Vc<FileSystemPath>,\n ) -> Result<Option<Rope>> {\n     async fn resolve_source(\n         original_source: &mut String,\n-        original_content: &mut Option<String>,\n+        original_content: Option<&mut Option<String>>,\n         origin: Vc<FileSystemPath>,\n     ) -> Result<()> {\n         if let Some(path) = *origin\n@@ -89,7 +89,9 @@ pub async fn resolve_source_map_sources(\n             let source = format!(\"{SOURCE_URL_PROTOCOL}///{path_str}\");\n             *original_source = source;\n \n-            if original_content.is_none() {\n+            if let Some(original_content) = original_content\n+                && original_content.is_none()\n+            {\n                 if let FileContent::Content(file) = &*path.read().await? {\n                     let text = file.content().to_str()?;\n                     *original_content = Some(text.to_string())\n@@ -105,7 +107,9 @@ pub async fn resolve_source_map_sources(\n                 s[0].replace('.', \"_\")\n             });\n             *original_source = format!(\"{SOURCE_URL_PROTOCOL}///{origin_str}/{source}\");\n-            if original_content.is_none() {\n+            if let Some(original_content) = original_content\n+                && original_content.is_none()\n+            {\n                 *original_content = Some(format!(\n                     \"unable to access {original_source} in {origin_str} (it's leaving the \\\n                      filesystem root)\"\n@@ -126,7 +130,7 @@ pub async fn resolve_source_map_sources(\n \n             for (source, content) in sources.iter_mut().zip(contents.iter_mut()) {\n                 if let Some(source) = source {\n-                    resolve_source(source, content, origin).await?;\n+                    resolve_source(source, Some(content), origin).await?;\n                 }\n             }\n \n@@ -144,6 +148,10 @@ pub async fn resolve_source_map_sources(\n         return Ok(None);\n     };\n \n+    if let Some(file) = &mut map.file {\n+        resolve_source(file, None, origin).await?;\n+    }\n+\n     resolve_map(&mut map, origin).await?;\n     for section in map.sections.iter_mut().flatten() {\n         resolve_map(&mut section.map, origin).await?;"
        }
    ],
    "stats": {
        "total": 18,
        "additions": 13,
        "deletions": 5
    }
}