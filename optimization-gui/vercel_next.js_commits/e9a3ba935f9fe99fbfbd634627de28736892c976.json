{
    "author": "sokra",
    "message": "Turbopack: fix import chain by determining depth locally per route (#86350)\n\n### What?\n\nfix the import chain showing only modules relevant to the current route\n\nfix module graph being merged by path. It's keyed by identifier now.\n\nalso add more info to import chain, e. g. layer info. and more details in tooltip.",
    "sha": "e9a3ba935f9fe99fbfbd634627de28736892c976",
    "files": [
        {
            "sha": "99fca28a7b92960dfddc58efd2b65259e4751999",
            "filename": "apps/bundle-analyzer/app/page.tsx",
            "status": "modified",
            "additions": 15,
            "deletions": 3,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/apps%2Fbundle-analyzer%2Fapp%2Fpage.tsx?ref=e9a3ba935f9fe99fbfbd634627de28736892c976",
            "patch": "@@ -15,6 +15,7 @@ import { Input } from '@/components/ui/input'\n import { Skeleton, TreemapSkeleton } from '@/components/ui/skeleton'\n import { ToggleGroup, ToggleGroupItem } from '@/components/ui/toggle-group'\n import { AnalyzeData, ModulesData } from '@/lib/analyze-data'\n+import { computeActiveEntries, computeModuleDepthMap } from '@/lib/module-graph'\n import { SpecialModule } from '@/lib/types'\n import { getSpecialModuleType, fetchStrict } from '@/lib/utils'\n \n@@ -29,7 +30,9 @@ function formatBytes(bytes: number): string {\n \n export default function Home() {\n   const [selectedRoute, setSelectedRoute] = useState<string | null>(null)\n-  const [environmentFilter, setEnvironmentFilter] = useState<string>('client')\n+  const [environmentFilter, setEnvironmentFilter] = useState<\n+    'client' | 'server'\n+  >('client')\n   const [typeFilter, setTypeFilter] = useState<string[]>(['js', 'css', 'json'])\n   const [selectedSourceIndex, setSelectedSourceIndex] = useState<number | null>(\n     null\n@@ -100,6 +103,14 @@ export default function Home() {\n     return () => window.removeEventListener('keydown', handleKeyDown)\n   }, [])\n \n+  // Compute module depth map from active entries\n+  const moduleDepthMap = useMemo(() => {\n+    if (!modulesData || !analyzeData) return new Map()\n+\n+    const activeEntries = computeActiveEntries(modulesData, analyzeData)\n+    return computeModuleDepthMap(modulesData, activeEntries)\n+  }, [modulesData, analyzeData])\n+\n   const filterSource = useMemo(() => {\n     if (!analyzeData) return undefined\n \n@@ -172,7 +183,7 @@ export default function Home() {\n                 className=\"mr-4\"\n                 value={environmentFilter}\n                 onValueChange={(value) => {\n-                  if (value) setEnvironmentFilter(value)\n+                  if (value) setEnvironmentFilter(value as 'client' | 'server')\n                 }}\n                 size=\"sm\"\n               >\n@@ -332,7 +343,8 @@ export default function Home() {\n                           startFileId={selectedSourceIndex}\n                           analyzeData={analyzeData}\n                           modulesData={modulesData}\n-                          filterSource={filterSource}\n+                          depthMap={moduleDepthMap}\n+                          environmentFilter={environmentFilter}\n                         />\n                       )}\n                       {(() => {"
        },
        {
            "sha": "7a7d820265776e52e1494685f7bc0aae2a342458",
            "filename": "apps/bundle-analyzer/components/import-chain.tsx",
            "status": "modified",
            "additions": 317,
            "deletions": 167,
            "changes": 484,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Fcomponents%2Fimport-chain.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Fcomponents%2Fimport-chain.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/apps%2Fbundle-analyzer%2Fcomponents%2Fimport-chain.tsx?ref=e9a3ba935f9fe99fbfbd634627de28736892c976",
            "patch": "@@ -4,104 +4,141 @@ import {\n   ArrowUp,\n   ChevronLeft,\n   ChevronRight,\n-  Monitor,\n-  Route,\n+  Box,\n+  File,\n+  PanelTop,\n+  SquareFunction,\n   Server,\n+  Globe,\n+  MessageCircleQuestion,\n } from 'lucide-react'\n import { useMemo, useState } from 'react'\n-import type { AnalyzeData, ModulesData } from '@/lib/analyze-data'\n+import type {\n+  AnalyzeData,\n+  ModuleIndex,\n+  ModulesData,\n+  SourceIndex,\n+} from '@/lib/analyze-data'\n+import { splitIdent } from '@/lib/utils'\n+import clsx from 'clsx'\n \n interface ImportChainProps {\n   startFileId: number\n   analyzeData: AnalyzeData\n   modulesData: ModulesData\n-  filterSource?: (sourceIndex: number) => boolean\n+  depthMap: Map<ModuleIndex, number>\n+  environmentFilter: 'client' | 'server'\n }\n \n interface ChainLevel {\n-  fileId: number\n-  filePath: string\n-  fileDepth: number\n+  moduleIndex: ModuleIndex\n+  sourceIndex: SourceIndex | undefined\n+  path: string\n+  depth: number\n+  fullPath?: string\n+  templateArgs?: string\n+  layer?: string\n+  moduleType?: string\n+  treeShaking?: string\n   selectedIndex: number\n   totalCount: number\n   // Info about this level's relationship to parent (undefined for root)\n   info?: DependentInfo\n-  // All available dependents at this level\n-  allDependents?: DependentInfo[]\n }\n \n interface DependentInfo {\n   moduleIndex: number\n   sourceIndex: number | undefined\n+  ident: string\n   isAsync: boolean\n   depth: number\n-  flags:\n-    | {\n-        client: boolean\n-        server: boolean\n-        traced: boolean\n-        js: boolean\n-        css: boolean\n-        json: boolean\n-        asset: boolean\n-      }\n-    | undefined\n }\n \n-function getPathDifference(currentPath: string, previousPath: string | null) {\n-  if (!previousPath) {\n-    return { common: '', different: currentPath }\n-  }\n+type PathPart = {\n+  segment: string\n+  isCommon: boolean\n+  isLastCommon: boolean\n+  isPackageName: boolean\n+  isInfrastructure: boolean\n+}\n \n-  const currentSegments = currentPath.split('/')\n-  const previousSegments = previousPath.split('/')\n+function spitPathSegments(path: string): string[] {\n+  return Array.from(path.matchAll(/(.+?(?:\\/|$))/g)).map(([i]) => i)\n+}\n+\n+function getPathParts(\n+  currentPath: string,\n+  previousPath: string | null\n+): PathPart[] {\n+  const currentSegments = spitPathSegments(currentPath)\n \n   let commonCount = 0\n-  const minLength = Math.min(currentSegments.length, previousSegments.length)\n+  if (previousPath) {\n+    const previousSegments = spitPathSegments(previousPath)\n \n-  for (let i = 0; i < minLength; i++) {\n-    if (currentSegments[i] === previousSegments[i]) {\n-      commonCount++\n-    } else {\n-      break\n+    const minLength = Math.min(currentSegments.length, previousSegments.length)\n+\n+    for (let i = 0; i < minLength; i++) {\n+      if (currentSegments[i] === previousSegments[i]) {\n+        commonCount++\n+      } else {\n+        break\n+      }\n     }\n   }\n \n-  const commonSegments = currentSegments.slice(0, commonCount)\n-  const differentSegments = currentSegments.slice(commonCount)\n-\n-  return {\n-    common: commonSegments.length > 0 ? `${commonSegments.join('/')}/` : '',\n-    different: differentSegments.join('/'),\n+  let infrastructureCount = 0\n+  let packageNameCount = 0\n+  let nodeModulesIndex = currentSegments.lastIndexOf('node_modules/')\n+  if (nodeModulesIndex === -1) {\n+    nodeModulesIndex = currentSegments.length\n+  } else {\n+    infrastructureCount = nodeModulesIndex + 1\n+    if (currentSegments[nodeModulesIndex + 1]?.startsWith('@')) {\n+      packageNameCount = 2\n+    } else {\n+      packageNameCount = 1\n+    }\n   }\n+\n+  return currentSegments.map((segment, i) => ({\n+    segment,\n+    isCommon: i < commonCount,\n+    isLastCommon: i === commonCount - 1,\n+    isInfrastructure: i < infrastructureCount,\n+    isPackageName:\n+      i >= infrastructureCount && i < infrastructureCount + packageNameCount,\n+  }))\n }\n \n-const insertLineBreaks = (path: string) => {\n-  const segments = path.split('/')\n-  return segments.map((segment, i) => (\n-    <span\n-      key={`${segment}-${i}`}\n-      className={segment.length > 20 ? 'break-all' : ''}\n-    >\n-      {segment}\n-      {i < segments.length - 1 && '/'}\n-      <wbr />\n-    </span>\n-  ))\n+function getTitle(level: ChainLevel) {\n+  const parts = []\n+  if (level.fullPath) parts.push(`Full Path: ${level.fullPath}`)\n+  else parts.push(`Path: ${level.path}`)\n+  if (level.layer) parts.push(`Layer: ${level.layer}`)\n+  if (level.moduleType) parts.push(`Module Type: ${level.moduleType}`)\n+  if (level.treeShaking) parts.push(`Tree Shaking: ${level.treeShaking}`)\n+  if (level.templateArgs) parts.push(`Template Args: ${level.templateArgs}`)\n+  return parts.join('\\n')\n }\n \n export function ImportChain({\n   startFileId,\n   analyzeData,\n   modulesData,\n+  depthMap,\n+  environmentFilter,\n }: ImportChainProps) {\n+  // Filter to include only the current route\n+  const [showAll, setShowAll] = useState(false)\n+\n   // Track which dependent is selected at each level\n   const [selectedIndices, setSelectedIndices] = useState<number[]>([])\n \n-  // Helper function to get module index from source path\n-  const getModuleIndexFromSourceIndex = (sourceIndex: number) => {\n+  // Helper function to get module indices from source path\n+  const getModuleIndicesFromSourceIndex = (sourceIndex: number) => {\n     const path = analyzeData.getFullSourcePath(sourceIndex)\n-    return modulesData.getModuleIndexFromPath(path)\n+    return modulesData.getModuleIndiciesFromPath(path)\n   }\n \n   // Helper function to get source index from module path\n@@ -127,38 +164,75 @@ export function ImportChain({\n     const startPath = analyzeData.getFullSourcePath(startFileId)\n     if (!startPath) return result\n \n-    // Get the module index for the starting source\n-    const startModuleIndex = getModuleIndexFromSourceIndex(startFileId)\n-    if (startModuleIndex === undefined) return result\n+    // Get all module indices for the starting source\n+    const startModuleIndices = getModuleIndicesFromSourceIndex(\n+      startFileId\n+    ).filter((moduleIndex) => {\n+      if (!showAll && !depthMap.has(moduleIndex)) {\n+        return false\n+      }\n+      let module = modulesData.module(moduleIndex)\n+      let layer = splitIdent(module?.ident || '').layer\n+      if (layer) {\n+        if (environmentFilter === 'client' && /ssr|rsc|route|api/.test(layer)) {\n+          return false\n+        }\n+        if (environmentFilter === 'server' && /client/.test(layer)) {\n+          return false\n+        }\n+      }\n+      return true\n+    })\n+    if (startModuleIndices.length === 0) return result\n+\n+    // Get the selected index for the start modules (default to 0)\n+    const selectedStartIdx = selectedIndices[0] ?? 0\n+    const actualStartIdx = Math.min(\n+      selectedStartIdx,\n+      startModuleIndices.length - 1\n+    )\n+    const startModuleIndex = startModuleIndices[actualStartIdx]\n+    const startIdent = modulesData.module(startModuleIndex)?.ident ?? ''\n \n     result.push({\n-      fileId: startFileId,\n-      filePath: startPath,\n-      fileDepth: modulesData.module(startModuleIndex)?.depth ?? Infinity,\n-      selectedIndex: 0,\n-      totalCount: 1,\n+      moduleIndex: startModuleIndex,\n+      sourceIndex: startFileId,\n+      path: startPath,\n+      ...splitIdent(startIdent),\n+      depth: depthMap.get(startModuleIndex) ?? Infinity,\n+      selectedIndex: actualStartIdx,\n+      totalCount: startModuleIndices.length,\n     })\n \n     visitedModules.add(startModuleIndex)\n \n     // Build chain by following selected dependents\n-    let levelIndex = 0\n+    let levelIndex = 1\n     let currentModuleIndex = startModuleIndex\n \n     while (true) {\n       // Get dependents at the module level (sync and async)\n       const dependentModuleIndices = [\n         ...modulesData\n           .moduleDependents(currentModuleIndex)\n-          .map((index: number) => ({ index, async: false })),\n+          .map((index: number) => ({\n+            index,\n+            async: false,\n+            depth: depthMap.get(index) ?? Infinity,\n+          })),\n         ...modulesData\n           .asyncModuleDependents(currentModuleIndex)\n-          .map((index: number) => ({ index, async: true })),\n+          .map((index: number) => ({\n+            index,\n+            async: true,\n+            depth: depthMap.get(index) ?? Infinity,\n+          })),\n       ]\n \n       // Filter out dependents that would create a cycle\n       const validDependents = dependentModuleIndices.filter(\n-        ({ index }) => !visitedModules.has(index)\n+        ({ index, depth }) =>\n+          !visitedModules.has(index) && (isFinite(depth) || showAll)\n       )\n \n       if (validDependents.length === 0) {\n@@ -168,39 +242,31 @@ export function ImportChain({\n \n       // Build info for each dependent\n       const dependentsInfo: DependentInfo[] = validDependents.map(\n-        ({ index: moduleIndex, async: isAsync }) => {\n-          const module = modulesData.module(moduleIndex)\n+        ({ index: moduleIndex, async: isAsync, depth }) => {\n           const sourceIndex = getSourceIndexFromModuleIndex(moduleIndex)\n-          const flags =\n-            sourceIndex !== undefined\n-              ? analyzeData.getSourceFlags(sourceIndex)\n-              : undefined\n+          let ident = modulesData.module(moduleIndex)?.ident || ''\n           return {\n             moduleIndex,\n             sourceIndex,\n+            ident,\n             isAsync,\n-            depth: module?.depth ?? Infinity,\n-            flags,\n+            depth,\n           }\n         }\n       )\n \n       // Sort: sync first, async second, then by source presence, then by depth\n       dependentsInfo.sort((a, b) => {\n-        // First sort by async state (sync before async)\n-        if (a.isAsync !== b.isAsync) {\n-          return a.isAsync ? 1 : -1\n+        // Sort by depth (smallest first)\n+        if (a.depth !== b.depth) {\n+          return a.depth - b.depth\n         }\n-\n-        // Then sort by source presence (with source before without)\n-        const aHasSource = a.sourceIndex !== undefined\n-        const bHasSource = b.sourceIndex !== undefined\n-        if (aHasSource !== bHasSource) {\n-          return aHasSource ? -1 : 1\n+        // Sort by ident length (shortest first)\n+        if (a.ident.length !== b.ident.length) {\n+          return a.ident.length - b.ident.length\n         }\n-\n-        // Finally sort by depth (smallest first)\n-        return a.depth - b.depth\n+        // Sort by ident\n+        return a.ident.localeCompare(b.ident)\n       })\n \n       // Get the selected index for this level (default to 0)\n@@ -213,13 +279,14 @@ export function ImportChain({\n       if (!selectedDepModule) break\n \n       result.push({\n-        fileId: selectedDepInfo.moduleIndex,\n-        filePath: selectedDepModule.path,\n-        fileDepth: selectedDepModule.depth,\n+        moduleIndex: selectedDepInfo.moduleIndex,\n+        sourceIndex: selectedDepInfo.sourceIndex,\n+        path: selectedDepModule.path,\n+        depth: depthMap.get(selectedDepInfo.moduleIndex) ?? Infinity,\n+        ...splitIdent(selectedDepModule.ident),\n         selectedIndex: actualIdx,\n         totalCount: dependentsInfo.length,\n         info: selectedDepInfo,\n-        allDependents: dependentsInfo,\n       })\n \n       visitedModules.add(selectedDepInfo.moduleIndex)\n@@ -232,13 +299,21 @@ export function ImportChain({\n \n     return result\n     // eslint-disable-next-line react-hooks/exhaustive-deps\n-  }, [startFileId, analyzeData, modulesData, selectedIndices])\n+  }, [\n+    startFileId,\n+    analyzeData,\n+    modulesData,\n+    selectedIndices,\n+    showAll,\n+    depthMap,\n+    environmentFilter,\n+  ])\n \n   const handlePrevious = (levelIndex: number) => {\n     setSelectedIndices((prev) => {\n       const newIndices = [...prev]\n       const currentIdx = newIndices[levelIndex] ?? 0\n-      const level = chain[levelIndex + 1] // Fixed: use levelIndex + 1 to get the correct level\n+      const level = chain[levelIndex]\n       newIndices[levelIndex] =\n         currentIdx > 0 ? currentIdx - 1 : level.totalCount - 1\n       return newIndices.slice(0, levelIndex + 1)\n@@ -249,7 +324,7 @@ export function ImportChain({\n     setSelectedIndices((prev) => {\n       const newIndices = [...prev]\n       const currentIdx = newIndices[levelIndex] ?? 0\n-      const level = chain[levelIndex + 1] // Fixed: use levelIndex + 1 to get the correct level\n+      const level = chain[levelIndex]\n       newIndices[levelIndex] =\n         currentIdx < level.totalCount - 1 ? currentIdx + 1 : 0\n       return newIndices.slice(0, levelIndex + 1)\n@@ -264,103 +339,165 @@ export function ImportChain({\n       <h3 className=\"text-xs font-semibold text-foreground\">Import chain</h3>\n       <div className=\"space-y-0\">\n         {chain.map((level, index) => {\n-          const previousPath = index > 0 ? chain[index - 1].filePath : null\n-          const { common, different } = getPathDifference(\n-            level.filePath,\n-            previousPath\n-          )\n+          const previousPath = index > 0 ? chain[index - 1].path : null\n+          const parts = getPathParts(level.path, previousPath)\n+\n+          const flags =\n+            level.sourceIndex !== undefined\n+              ? analyzeData.getSourceFlags(level.sourceIndex)\n+              : undefined\n \n           // Get the current item's info from the level itself\n           const currentItemInfo = level.info\n \n           return (\n-            <div key={`${level.filePath}-${index}`}>\n+            <div key={`${level.path}-${index}`}>\n+              {currentItemInfo?.isAsync && <div className=\"h-8\" />}\n+              <div className=\"flex items-center justify-center gap-2 py-1\">\n+                {currentItemInfo?.isAsync && (\n+                  <span className=\"text-xs text-muted-foreground italic\">\n+                    (async)\n+                  </span>\n+                )}\n+                {index > 0 ? (\n+                  <ArrowUp className=\"w-4 h-4 text-muted-foreground\" />\n+                ) : undefined}\n+                {level.totalCount > 1 && (\n+                  <div className=\"flex items-center gap-1 flex-none\">\n+                    <button\n+                      type=\"button\"\n+                      onClick={() => handlePrevious(index)}\n+                      className=\"p-0.5 hover:bg-accent rounded transition-colors cursor-pointer\"\n+                      title=\"Previous dependent\"\n+                    >\n+                      <ChevronLeft className=\"w-3 h-3\" />\n+                    </button>\n+                    <span className=\"text-muted-foreground text-xs min-w-[3ch] text-center\">\n+                      {level.selectedIndex + 1}/{level.totalCount}\n+                    </span>\n+                    <button\n+                      type=\"button\"\n+                      onClick={() => handleNext(index)}\n+                      className=\"p-0.5 hover:bg-accent rounded transition-colors cursor-pointer\"\n+                      title=\"Next dependent\"\n+                    >\n+                      <ChevronRight className=\"w-3 h-3\" />\n+                    </button>\n+                  </div>\n+                )}\n+              </div>\n+              {currentItemInfo?.isAsync && <div className=\"h-8\" />}\n               <div className=\"flex items-center gap-2\">\n+                <div className=\"flex flex-col gap-1 items-center\">\n+                  {!level.layer ? (\n+                    <div title=\"Unknown\">\n+                      <MessageCircleQuestion className=\"w-3 h-3 text-gray-500\" />\n+                    </div>\n+                  ) : /app/.test(level.layer || '') ? (\n+                    <div title=\"App Router\">\n+                      <Box className=\"w-3 h-3 text-green-500\" />\n+                    </div>\n+                  ) : (\n+                    <div title=\"Pages Router\">\n+                      <File className=\"w-3 h-3 text-purple-500\" />\n+                    </div>\n+                  )}\n+                </div>\n+\n                 <div className=\"flex-1 border border-border rounded px-2 py-1 bg-background\">\n                   <span\n                     className=\"font-mono text-xs text-foreground text-center block break-words\"\n-                    title={level.filePath}\n+                    title={getTitle(level)}\n                   >\n-                    {index === 0 ? (\n-                      <span className=\"font-normal\">\n-                        {insertLineBreaks(level.filePath)}\n-                      </span>\n-                    ) : (\n-                      <>\n-                        {common && (\n-                          <span className=\"font-normal text-muted-foreground/60\">\n-                            {insertLineBreaks(common)}\n-                          </span>\n-                        )}\n-                        <span className=\"font-bold\">\n-                          {insertLineBreaks(different)}\n+                    {parts.map(\n+                      (\n+                        {\n+                          segment,\n+                          isCommon,\n+                          isLastCommon,\n+                          isInfrastructure,\n+                          isPackageName,\n+                        },\n+                        i\n+                      ) => (\n+                        <span\n+                          key={i}\n+                          className={clsx(\n+                            segment.length > 20 && 'break-all',\n+                            isCommon &&\n+                              !isLastCommon &&\n+                              !isPackageName &&\n+                              !isInfrastructure &&\n+                              'text-muted-foreground/80',\n+                            !isCommon && !isInfrastructure && 'font-bold',\n+                            isInfrastructure && 'text-muted-foreground/50',\n+                            isPackageName && 'text-orange-500'\n+                          )}\n+                        >\n+                          {segment}\n+                          <wbr />\n                         </span>\n-                      </>\n+                      )\n                     )}\n                   </span>\n                 </div>\n \n                 {/* Show icons for current item if we have flag info or no source */}\n-                {currentItemInfo && (\n-                  <div className=\"flex flex-col gap-1 items-center\">\n-                    {currentItemInfo.sourceIndex === undefined && (\n-                      <div title=\"Used only on different route\">\n-                        <Route className=\"w-3 h-3 text-amber-500\" />\n+                <div className=\"flex flex-col gap-1 items-center\">\n+                  {/client/.test(level.layer || '') &&\n+                    (flags?.client ? (\n+                      <div title=\"Included on client-side of this route\">\n+                        <PanelTop className=\"w-3 h-3 text-green-500\" />\n                       </div>\n-                    )}\n-                    {currentItemInfo.flags?.client ? (\n-                      <div title=\"Client Component\">\n-                        <Monitor className=\"w-3 h-3 text-green-500\" />\n+                    ) : (\n+                      <div title=\"On client layer, but not included on client-side of this route (might be optimized away)\">\n+                        <PanelTop className=\"w-3 h-3 text-gray-500\" />\n                       </div>\n-                    ) : currentItemInfo.flags?.server ? (\n-                      <div title=\"Server Component\">\n-                        <Server className=\"w-3 h-3 text-blue-500\" />\n+                    ))}\n+                  {/ssr/.test(level.layer || '') &&\n+                    (flags?.server ? (\n+                      <div title=\"Included on server-side of this route for server-side rendering\">\n+                        <Globe className=\"w-3 h-3 text-blue-500\" />\n                       </div>\n-                    ) : null}\n+                    ) : (\n+                      <div title=\"On server-side rendering layer, but not included on server-side of this route (might be optimized away)\">\n+                        <Globe className=\"w-3 h-3 text-gray-500\" />\n+                      </div>\n+                    ))}\n+                  {/rsc/.test(level.layer || '') &&\n+                    (flags?.server ? (\n+                      <div title=\"Included on server-side of this route as Server Component\">\n+                        <Server className=\"w-3 h-3 text-orange-500\" />\n+                      </div>\n+                    ) : (\n+                      <div title=\"On Server Component layer, but not included on server-side of this route (might be optimized away)\">\n+                        <Server className=\"w-3 h-3 text-gray-500\" />\n+                      </div>\n+                    ))}\n+                  {/route|api/.test(level.layer || '') &&\n+                    (flags?.server ? (\n+                      <div title=\"Included on server-side of this route for API routes\">\n+                        <SquareFunction className=\"w-3 h-3 text-red-500\" />\n+                      </div>\n+                    ) : (\n+                      <div title=\"On API route layer, but not included on server-side of this route (might be optimized away)\">\n+                        <SquareFunction className=\"w-3 h-3 text-gray-500\" />\n+                      </div>\n+                    ))}\n+                </div>\n+              </div>\n+\n+              <div className=\"block text-center\">\n+                {level.treeShaking && (\n+                  <div className=\"text-xs text-foreground text-center\">\n+                    {level.treeShaking === 'locals'\n+                      ? '(local declarations only)'\n+                      : level.treeShaking === 'module evaluation'\n+                        ? '(only the module evaluation part of the module)'\n+                        : `(${level.treeShaking})`}\n                   </div>\n                 )}\n               </div>\n-\n-              {index < chain.length - 1 &&\n-                (() => {\n-                  // Get the info for the next item (the one the arrow points to)\n-                  const nextItemInfo = chain[index + 1].info\n-\n-                  return (\n-                    <div className=\"flex items-center justify-center gap-2 py-1\">\n-                      <ArrowUp\n-                        className=\"w-4 h-4 text-muted-foreground\"\n-                        strokeDasharray={\n-                          nextItemInfo?.isAsync ? '4,4' : undefined\n-                        }\n-                      />\n-                      {chain[index + 1].totalCount > 1 && (\n-                        <div className=\"flex items-center gap-1 flex-none\">\n-                          <button\n-                            type=\"button\"\n-                            onClick={() => handlePrevious(index)}\n-                            className=\"p-0.5 hover:bg-accent rounded transition-colors cursor-pointer\"\n-                            title=\"Previous dependent\"\n-                          >\n-                            <ChevronLeft className=\"w-3 h-3\" />\n-                          </button>\n-                          <span className=\"text-muted-foreground text-xs min-w-[3ch] text-center\">\n-                            {chain[index + 1].selectedIndex + 1}/\n-                            {chain[index + 1].totalCount}\n-                          </span>\n-                          <button\n-                            type=\"button\"\n-                            onClick={() => handleNext(index)}\n-                            className=\"p-0.5 hover:bg-accent rounded transition-colors cursor-pointer\"\n-                            title=\"Next dependent\"\n-                          >\n-                            <ChevronRight className=\"w-3 h-3\" />\n-                          </button>\n-                        </div>\n-                      )}\n-                    </div>\n-                  )\n-                })()}\n             </div>\n           )\n         })}\n@@ -370,6 +507,19 @@ export function ImportChain({\n           </p>\n         )}\n       </div>\n+      <div className=\"pt-2\">\n+        <label className=\"inline-flex items-center space-x-2 text-sm cursor-pointer\">\n+          <input\n+            type=\"checkbox\"\n+            className=\"form-checkbox h-4 w-4 text-primary\"\n+            checked={showAll}\n+            onChange={() => setShowAll((prev) => !prev)}\n+          />\n+          <span>\n+            Show all dependents (including those outside current route)\n+          </span>\n+        </label>\n+      </div>\n     </div>\n   )\n }"
        },
        {
            "sha": "a780cc86bfcb9e184ef3ec8da0d9a402461ca039",
            "filename": "apps/bundle-analyzer/lib/analyze-data.ts",
            "status": "modified",
            "additions": 45,
            "deletions": 24,
            "changes": 69,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Flib%2Fanalyze-data.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Flib%2Fanalyze-data.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/apps%2Fbundle-analyzer%2Flib%2Fanalyze-data.ts?ref=e9a3ba935f9fe99fbfbd634627de28736892c976",
            "patch": "@@ -1,8 +1,12 @@\n // Type definitions matching the Rust structures from analyze.rs\n \n+// Type aliases for better readability\n+export type ModuleIndex = number\n+export type SourceIndex = number\n+\n export interface AnalyzeModule {\n+  ident: string\n   path: string\n-  depth: number\n }\n \n export interface AnalyzeSource {\n@@ -53,7 +57,7 @@ interface ModulesDataHeader {\n export class ModulesData {\n   private modulesHeader: ModulesDataHeader\n   private modulesBinaryData: DataView\n-  private pathToModuleIndex: Map<string, number>\n+  private pathToModuleIndex: Map<string, ModuleIndex[]>\n \n   constructor(modulesArrayBuffer: ArrayBuffer) {\n     // Parse modules.data\n@@ -76,27 +80,32 @@ export class ModulesData {\n     this.pathToModuleIndex = new Map()\n     for (let i = 0; i < this.modulesHeader.modules.length; i++) {\n       const module = this.modulesHeader.modules[i]\n-      this.pathToModuleIndex.set(module.path, i)\n+      const existing = this.pathToModuleIndex.get(module.path)\n+      if (existing) {\n+        existing.push(i)\n+      } else {\n+        this.pathToModuleIndex.set(module.path, [i])\n+      }\n     }\n   }\n \n-  module(index: number): AnalyzeModule | undefined {\n+  module(index: ModuleIndex): AnalyzeModule | undefined {\n     return this.modulesHeader.modules[index]\n   }\n \n   moduleCount(): number {\n     return this.modulesHeader.modules.length\n   }\n \n-  getModuleIndexFromPath(path: string): number | undefined {\n-    return this.pathToModuleIndex.get(path)\n+  getModuleIndiciesFromPath(path: string): ModuleIndex[] {\n+    return this.pathToModuleIndex.get(path) ?? []\n   }\n \n   // Read edges data for a specific index only\n   private readEdgesDataAtIndex(\n     reference: EdgesDataReference,\n-    index: number\n-  ): number[] {\n+    index: ModuleIndex\n+  ): ModuleIndex[] {\n     const { offset, length } = reference\n \n     if (length === 0) {\n@@ -143,28 +152,28 @@ export class ModulesData {\n     return edges\n   }\n \n-  moduleDependents(index: number): number[] {\n+  moduleDependents(index: ModuleIndex): ModuleIndex[] {\n     return this.readEdgesDataAtIndex(\n       this.modulesHeader.module_dependents,\n       index\n     )\n   }\n \n-  asyncModuleDependents(index: number): number[] {\n+  asyncModuleDependents(index: ModuleIndex): ModuleIndex[] {\n     return this.readEdgesDataAtIndex(\n       this.modulesHeader.async_module_dependents,\n       index\n     )\n   }\n \n-  moduleDependencies(index: number): number[] {\n+  moduleDependencies(index: ModuleIndex): ModuleIndex[] {\n     return this.readEdgesDataAtIndex(\n       this.modulesHeader.module_dependencies,\n       index\n     )\n   }\n \n-  asyncModuleDependencies(index: number): number[] {\n+  asyncModuleDependencies(index: ModuleIndex): ModuleIndex[] {\n     return this.readEdgesDataAtIndex(\n       this.modulesHeader.async_module_dependencies,\n       index\n@@ -182,6 +191,7 @@ export class ModulesData {\n export class AnalyzeData {\n   private analyzeHeader: AnalyzeDataHeader\n   private analyzeBinaryData: DataView\n+  private pathToSourceIndex: Map<string, SourceIndex>\n \n   constructor(analyzeArrayBuffer: ArrayBuffer) {\n     // Parse analyze.data\n@@ -199,18 +209,29 @@ export class AnalyzeData {\n       analyzeArrayBuffer,\n       analyzeBinaryOffset\n     )\n+\n+    // Build pathToSourceIndex map\n+    this.pathToSourceIndex = new Map()\n+    for (let i = 0; i < this.analyzeHeader.sources.length; i++) {\n+      const fullPath = this.getFullSourcePath(i)\n+      this.pathToSourceIndex.set(fullPath, i)\n+    }\n   }\n \n   // Accessor methods for header data\n \n-  source(index: number): AnalyzeSource | undefined {\n+  source(index: SourceIndex): AnalyzeSource | undefined {\n     return this.analyzeHeader.sources[index]\n   }\n \n   sourceCount(): number {\n     return this.analyzeHeader.sources.length\n   }\n \n+  getSourceIndexFromPath(path: string): SourceIndex | undefined {\n+    return this.pathToSourceIndex.get(path)\n+  }\n+\n   chunkPart(index: number): AnalyzeChunkPart | undefined {\n     return this.analyzeHeader.chunk_parts[index]\n   }\n@@ -227,7 +248,7 @@ export class AnalyzeData {\n     return this.analyzeHeader.output_files.length\n   }\n \n-  sourceRoots(): number[] {\n+  sourceRoots(): SourceIndex[] {\n     return this.analyzeHeader.source_roots\n   }\n \n@@ -236,8 +257,8 @@ export class AnalyzeData {\n   // Read edges data for a specific index only\n   private readEdgesDataAtIndex(\n     reference: EdgesDataReference,\n-    index: number\n-  ): number[] {\n+    index: SourceIndex\n+  ): SourceIndex[] {\n     const { offset, length } = reference\n \n     if (length === 0) {\n@@ -291,19 +312,19 @@ export class AnalyzeData {\n     )\n   }\n \n-  sourceChunkParts(index: number): number[] {\n+  sourceChunkParts(index: SourceIndex): number[] {\n     return this.readEdgesDataAtIndex(\n       this.analyzeHeader.source_chunk_parts,\n       index\n     )\n   }\n \n-  sourceChildren(index: number): number[] {\n+  sourceChildren(index: SourceIndex): SourceIndex[] {\n     return this.readEdgesDataAtIndex(this.analyzeHeader.source_children, index)\n   }\n \n   // Utility method to get the full path of a source by walking up the parent chain\n-  getFullSourcePath(index: number): string {\n+  getFullSourcePath(index: SourceIndex): string {\n     const source = this.source(index)\n     if (!source) return ''\n \n@@ -315,7 +336,7 @@ export class AnalyzeData {\n     return parentPath + source.path\n   }\n \n-  getSourceOutputSize(index: number): number {\n+  getSourceOutputSize(index: SourceIndex): number {\n     const chunkParts = this.sourceChunkParts(index)\n     let totalSize = 0\n     for (const chunkPartIndex of chunkParts) {\n@@ -327,7 +348,7 @@ export class AnalyzeData {\n     return totalSize\n   }\n \n-  sourceChunks(index: number): string[] {\n+  sourceChunks(index: SourceIndex): string[] {\n     const chunkParts = this.sourceChunkParts(index)\n     const uniqueChunks = new Set<string>()\n \n@@ -344,7 +365,7 @@ export class AnalyzeData {\n     return Array.from(uniqueChunks).sort()\n   }\n \n-  getSourceFlags(index: number): {\n+  getSourceFlags(index: SourceIndex): {\n     client: boolean\n     server: boolean\n     traced: boolean\n@@ -388,14 +409,14 @@ export class AnalyzeData {\n     return { client, server, traced, js, css, json, asset }\n   }\n \n-  isPolyfillModule(index: number): boolean {\n+  isPolyfillModule(index: SourceIndex): boolean {\n     const fullSourcePath = this.getFullSourcePath(index)\n     return fullSourcePath.endsWith(\n       'node_modules/next/dist/build/polyfills/polyfill-module.js'\n     )\n   }\n \n-  isPolyfillNoModule(index: number): boolean {\n+  isPolyfillNoModule(index: SourceIndex): boolean {\n     const fullSourcePath = this.getFullSourcePath(index)\n     return fullSourcePath.endsWith(\n       'node_modules/next/dist/build/polyfills/polyfill-nomodule.js'"
        },
        {
            "sha": "02c4652d4a901f91e6b546ad335138ed32b7e4d0",
            "filename": "apps/bundle-analyzer/lib/module-graph.ts",
            "status": "added",
            "additions": 143,
            "deletions": 0,
            "changes": 143,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Flib%2Fmodule-graph.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Flib%2Fmodule-graph.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/apps%2Fbundle-analyzer%2Flib%2Fmodule-graph.ts?ref=e9a3ba935f9fe99fbfbd634627de28736892c976",
            "patch": "@@ -0,0 +1,143 @@\n+import type { AnalyzeData, ModuleIndex, ModulesData } from './analyze-data'\n+\n+/**\n+ * Compute active entries from the current route's sources.\n+ *\n+ * It's a heuristic approach that looks for known entry module idents\n+ * and traces their dependencies to find active modules.\n+ *\n+ * I don't like it as it has too much assumptions about next.js internals.\n+ * It would be better if the source map contains idents instead of only paths.\n+ */\n+export function computeActiveEntries(\n+  modulesData: ModulesData,\n+  analyzeData: AnalyzeData\n+): ModuleIndex[] {\n+  const potentialEntryDependents = [\n+    'next/dist/esm/build/templates/pages.js',\n+    'next/dist/esm/build/templates/pages-api.js',\n+    'next/dist/esm/build/templates/pages-edge-api.js',\n+    'next/dist/esm/build/templates/edge-ssr.js',\n+    'next/dist/esm/build/templates/app-route.js',\n+    'next/dist/esm/build/templates/edge-app-route.js',\n+    'next/dist/esm/build/templates/app-page.js',\n+    'next/dist/esm/build/templates/edge-ssr-app.js',\n+    'next/dist/esm/build/templates/middleware.js',\n+    '[next]/entry/page-loader.ts',\n+  ]\n+  const potentialEntries = [\n+    'next/dist/client/app-next-turbopack.js',\n+    'next/dist/client/next-turbopack.js',\n+  ]\n+\n+  const activeEntries = new Set<ModuleIndex>()\n+\n+  for (\n+    let moduleIndex = 0;\n+    moduleIndex < modulesData.moduleCount();\n+    moduleIndex++\n+  ) {\n+    const ident = modulesData.module(moduleIndex)!.ident\n+\n+    if (\n+      potentialEntryDependents.some((entryIdent) => ident.includes(entryIdent))\n+    ) {\n+      const dependencies = modulesData.moduleDependencies(moduleIndex)\n+      for (const dep of dependencies) {\n+        const path = modulesData.module(dep)!.path\n+        if (path.includes('next/dist/')) {\n+          continue\n+        }\n+        const source = analyzeData.getSourceIndexFromPath(path)\n+        if (source !== undefined) {\n+          activeEntries.add(dep)\n+        }\n+      }\n+    }\n+    if (potentialEntries.some((entryIdent) => ident.includes(entryIdent))) {\n+      activeEntries.add(moduleIndex)\n+    }\n+  }\n+\n+  return Array.from(activeEntries)\n+}\n+\n+/**\n+ * Compute module depth from active entries using BFS\n+ * Returns a Map from ModuleIndex to depth\n+ * Unreachable modules will not have an entry in the map\n+ */\n+export function computeModuleDepthMap(\n+  modulesData: ModulesData,\n+  activeEntries: ModuleIndex[]\n+): Map<ModuleIndex, number> {\n+  const depthMap = new Map<ModuleIndex, number>()\n+  const delayedModules = new Array<{ depth: number; queue: ModuleIndex[] }>()\n+\n+  // Initialize queue with active entries\n+  for (const moduleIndex of activeEntries) {\n+    depthMap.set(moduleIndex, 0)\n+  }\n+\n+  // BFS to compute depth\n+  // We need to insert new entries into the depth map in monotonic increasing order of depth\n+  // so that we always process shallower modules before deeper ones\n+  // This is important to avoid visiting modules multiple times and needing to decrease their depth\n+  let i = 0\n+  for (const [moduleIndex, depth] of depthMap) {\n+    const newDepth = depth + 1\n+    // Process regular dependencies\n+    const dependencies = modulesData.moduleDependencies(moduleIndex)\n+    for (const depIndex of dependencies) {\n+      if (!depthMap.has(depIndex)) {\n+        depthMap.set(depIndex, newDepth)\n+      }\n+    }\n+\n+    // Process async dependencies with higher depth penalty\n+    const asyncDependencies = modulesData.asyncModuleDependencies(moduleIndex)\n+    for (const depIndex of asyncDependencies) {\n+      if (!depthMap.has(depIndex)) {\n+        const newDepth = depth + 1000\n+        // We can't directly insert async dependencies into the depth map\n+        // because they might be processed before their parent module\n+        // leading to incorrect depth assignment.\n+        // Instead, we queue them to be processed later.\n+        let delayedQueue = delayedModules.find((dq) => dq.depth === newDepth)\n+        if (!delayedQueue) {\n+          delayedQueue = { depth: newDepth, queue: [] }\n+          delayedModules.push(delayedQueue)\n+          // Keep delayed queues sorted by depth descending\n+          delayedModules.sort((a, b) => b.depth - a.depth)\n+        }\n+        delayedQueue.queue.push(depIndex)\n+      }\n+    }\n+\n+    i++\n+\n+    // Check if we need to process the next delayed queue to insert its items into the depth map\n+    // This happens when we reach the end of the current queue\n+    // or the next delayed queue has the same depth so its items need to be processed now\n+    while (\n+      delayedModules.length > 0 &&\n+      (i === depthMap.size ||\n+        newDepth === delayedModules[delayedModules.length - 1].depth)\n+    ) {\n+      const { depth, queue } = delayedModules.pop()!\n+      for (const depIndex of queue) {\n+        if (!depthMap.has(depIndex)) {\n+          depthMap.set(depIndex, depth)\n+        }\n+      }\n+    }\n+  }\n+\n+  if (delayedModules.length > 0) {\n+    throw new Error(\n+      'Internal error: delayed modules remain after BFS processing'\n+    )\n+  }\n+\n+  return depthMap\n+}"
        },
        {
            "sha": "48cd93f65ed90bb2f5de353396484a3904142ea8",
            "filename": "apps/bundle-analyzer/lib/treemap-layout.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Flib%2Ftreemap-layout.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Flib%2Ftreemap-layout.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/apps%2Fbundle-analyzer%2Flib%2Ftreemap-layout.ts?ref=e9a3ba935f9fe99fbfbd634627de28736892c976",
            "patch": "@@ -1,4 +1,4 @@\n-import type { AnalyzeData } from './analyze-data'\n+import type { AnalyzeData, SourceIndex } from './analyze-data'\n import { layoutTreemap } from './layout-treemap'\n import { SpecialModule } from './types'\n import { getSpecialModuleType } from './utils'\n@@ -29,7 +29,7 @@ export interface LayoutNode extends LayoutNodeInfo {\n   css?: boolean\n   json?: boolean\n   asset?: boolean\n-  sourceIndex?: number // Track which source this node represents\n+  sourceIndex?: SourceIndex // Track which source this node represents\n }\n \n interface SourceMetadata {\n@@ -39,7 +39,7 @@ interface SourceMetadata {\n \n function precomputeSourceMetadata(\n   analyzeData: AnalyzeData,\n-  filterSource?: (sourceIndex: number) => boolean\n+  filterSource?: (sourceIndex: SourceIndex) => boolean\n ): SourceMetadata[] {\n   const sourceCount = analyzeData.sourceCount()\n   const metadata: SourceMetadata[] = new Array(sourceCount)\n@@ -65,7 +65,7 @@ function precomputeSourceMetadata(\n   }\n \n   // Top-down pass: aggregate child sizes and filtered status for directories\n-  function processDirectory(idx: number) {\n+  function processDirectory(idx: SourceIndex) {\n     const children = analyzeData.sourceChildren(idx)\n     if (children.length === 0) return // Already processed as leaf\n \n@@ -97,11 +97,11 @@ function precomputeSourceMetadata(\n // Internal function that uses precomputed metadata\n function computeTreemapLayoutFromAnalyzeInternal(\n   analyzeData: AnalyzeData,\n-  sourceIndex: number,\n+  sourceIndex: SourceIndex,\n   foldedPath: string,\n   rect: LayoutRect,\n   metadata: SourceMetadata[],\n-  filterSource?: (sourceIndex: number) => boolean\n+  filterSource?: (sourceIndex: SourceIndex) => boolean\n ): LayoutNode {\n   const source = analyzeData.source(sourceIndex)\n   if (!source) {\n@@ -164,7 +164,7 @@ function computeTreemapLayoutFromAnalyzeInternal(\n \n   if (isCollapsed) {\n     // Count all descendant files\n-    function countDescendants(idx: number): number {\n+    function countDescendants(idx: SourceIndex): number {\n       const children = analyzeData.sourceChildren(idx)\n       if (children.length === 0) return 1\n       return children.reduce(\n@@ -253,9 +253,9 @@ function computeTreemapLayoutFromAnalyzeInternal(\n // Public function that precomputes metadata and calls internal function\n export function computeTreemapLayoutFromAnalyze(\n   analyzeData: AnalyzeData,\n-  sourceIndex: number,\n+  sourceIndex: SourceIndex,\n   rect: LayoutRect,\n-  filterSource?: (sourceIndex: number) => boolean\n+  filterSource?: (sourceIndex: SourceIndex) => boolean\n ): LayoutNode {\n   // Precompute metadata once for entire tree\n   const metadata = precomputeSourceMetadata(analyzeData, filterSource)"
        },
        {
            "sha": "13e04bd5b8fa6944e4bc41438be751e60a371deb",
            "filename": "apps/bundle-analyzer/lib/utils.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 2,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Flib%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Flib%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/apps%2Fbundle-analyzer%2Flib%2Futils.ts?ref=e9a3ba935f9fe99fbfbd634627de28736892c976",
            "patch": "@@ -2,7 +2,7 @@ import { type ClassValue, clsx } from 'clsx'\n import { twMerge } from 'tailwind-merge'\n import { SpecialModule } from './types'\n import { NetworkError } from './errors'\n-import { AnalyzeData } from './analyze-data'\n+import { AnalyzeData, SourceIndex } from './analyze-data'\n \n export function cn(...inputs: ClassValue[]) {\n   return twMerge(clsx(inputs))\n@@ -29,7 +29,7 @@ export async function jsonFetcher<T>(url: string): Promise<T> {\n \n export function getSpecialModuleType(\n   analyzeData: AnalyzeData | undefined,\n-  sourceIndex: number | null\n+  sourceIndex: SourceIndex | null\n ): SpecialModule | null {\n   if (!analyzeData || sourceIndex == null) return null\n \n@@ -42,3 +42,19 @@ export function getSpecialModuleType(\n \n   return null\n }\n+\n+let IDENT_ATTRIBUTES_REGEXP =\n+  /^(.+?)(?: \\{(.*)\\})?(?: \\[(.*)\\])?(?: \\((.*?)\\))?(?: <(.*?)>)?$/\n+\n+export function splitIdent(ident: string): {\n+  fullPath: string\n+  templateArgs: string\n+  layer: string\n+  moduleType: string\n+  treeShaking: string\n+} {\n+  let [match, fullPath, templateArgs, layer, moduleType, treeShaking] =\n+    IDENT_ATTRIBUTES_REGEXP.exec(ident) || ['']\n+  ident = ident.substring(0, ident.length - match.length)\n+  return { fullPath, templateArgs, layer, moduleType, treeShaking }\n+}"
        },
        {
            "sha": "192de1686397a3825595cf6b10fb49b7feb3b454",
            "filename": "apps/bundle-analyzer/package.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a3ba935f9fe99fbfbd634627de28736892c976/apps%2Fbundle-analyzer%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/apps%2Fbundle-analyzer%2Fpackage.json?ref=e9a3ba935f9fe99fbfbd634627de28736892c976",
            "patch": "@@ -17,7 +17,7 @@\n     \"class-variance-authority\": \"^0.7.1\",\n     \"clsx\": \"^2.1.1\",\n     \"cmdk\": \"1.0.4\",\n-    \"lucide-react\": \"^0.454.0\",\n+    \"lucide-react\": \"^0.554.0\",\n     \"next\": \"16.0.1\",\n     \"next-themes\": \"^0.4.6\",\n     \"polished\": \"^4.3.1\","
        },
        {
            "sha": "fffba1fd785d1fbcd475387f8e9558e5ae689266",
            "filename": "crates/next-api/src/analyze.rs",
            "status": "modified",
            "additions": 41,
            "deletions": 68,
            "changes": 109,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a3ba935f9fe99fbfbd634627de28736892c976/crates%2Fnext-api%2Fsrc%2Fanalyze.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a3ba935f9fe99fbfbd634627de28736892c976/crates%2Fnext-api%2Fsrc%2Fanalyze.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fanalyze.rs?ref=e9a3ba935f9fe99fbfbd634627de28736892c976",
            "patch": "@@ -6,7 +6,7 @@ use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    FxIndexSet, NonLocalValue, ResolvedVc, TryFlatJoinIterExt, ValueToString, Vc,\n+    FxIndexSet, NonLocalValue, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n     trace::TraceRawVcs,\n };\n use turbo_tasks_fs::{\n@@ -72,8 +72,8 @@ pub struct AnalyzeSource {\n \n #[derive(Serialize)]\n pub struct AnalyzeModule {\n+    pub ident: RcStr,\n     pub path: RcStr,\n-    pub depth: u32,\n }\n \n #[derive(Serialize)]\n@@ -283,18 +283,23 @@ impl ModulesDataBuilder {\n         }\n     }\n \n-    fn ensure_module(&mut self, path: &str) -> (&mut AnalyzeModuleBuilder, u32) {\n-        if let Some(&index) = self.module_index_map.get(path) {\n+    fn get_module(&mut self, ident: &str) -> (&mut AnalyzeModuleBuilder, u32) {\n+        if let Some(&index) = self.module_index_map.get(ident) {\n+            return (&mut self.modules[index as usize], index);\n+        }\n+        panic!(\"Module with ident `{}` not found\", ident);\n+    }\n+\n+    fn ensure_module(&mut self, ident: &str, path: &str) -> (&mut AnalyzeModuleBuilder, u32) {\n+        if let Some(&index) = self.module_index_map.get(ident) {\n             return (&mut self.modules[index as usize], index);\n         }\n         let index = self.modules.len() as u32;\n+        let ident = RcStr::from(ident);\n         let path = RcStr::from(path);\n-        self.module_index_map.insert(path.clone(), index);\n+        self.module_index_map.insert(ident.clone(), index);\n         self.modules.push(AnalyzeModuleBuilder {\n-            module: AnalyzeModule {\n-                path,\n-                depth: u32::MAX,\n-            },\n+            module: AnalyzeModule { ident, path },\n             dependencies: FxIndexSet::default(),\n             async_dependencies: FxIndexSet::default(),\n             dependents: FxIndexSet::default(),\n@@ -420,11 +425,14 @@ pub async fn analyze_output_assets(output_assets: Vc<OutputAssets>) -> Result<Vc\n pub async fn analyze_module_graphs(module_graphs: Vc<ModuleGraphs>) -> Result<Vc<FileContent>> {\n     let mut builder = ModulesDataBuilder::new();\n \n+    let mut all_modules = FxIndexSet::default();\n     let mut all_edges = FxIndexSet::default();\n     let mut all_async_edges = FxIndexSet::default();\n     for &module_graph in module_graphs.await? {\n         let module_graph = module_graph.read_graphs().await?;\n         module_graph.traverse_all_edges_unordered(|(parent_node, reference), node| {\n+            all_modules.insert(parent_node);\n+            all_modules.insert(node);\n             match reference.chunking_type {\n                 ChunkingType::Async => {\n                     all_async_edges.insert((parent_node, node));\n@@ -442,9 +450,24 @@ pub async fn analyze_module_graphs(module_graphs: Vc<ModuleGraphs>) -> Result<Vc\n         if from == to {\n             return Ok(None);\n         }\n-        let from_path = from.ident().path().to_string().owned().await?;\n-        let to_path = to.ident().path().to_string().owned().await?;\n-        Ok(Some((from_path, to_path)))\n+        let from_ident = from.ident().to_string().owned().await?;\n+        let to_ident = to.ident().to_string().owned().await?;\n+        Ok(Some((from_ident, to_ident)))\n+    }\n+\n+    let all_modules = all_modules\n+        .iter()\n+        .copied()\n+        .map(async |module| {\n+            let ident = module.ident().to_string().owned().await?;\n+            let path = module.ident().path().to_string().owned().await?;\n+            Ok((ident, path))\n+        })\n+        .try_join()\n+        .await?;\n+\n+    for (ident, path) in all_modules {\n+        builder.ensure_module(&ident, &path);\n     }\n \n     let all_edges = all_edges\n@@ -459,9 +482,9 @@ pub async fn analyze_module_graphs(module_graphs: Vc<ModuleGraphs>) -> Result<Vc\n         .map(mapper)\n         .try_flat_join()\n         .await?;\n-    for (from_path, to_path) in all_edges {\n-        let from_index = builder.ensure_module(&from_path).1;\n-        let to_index = builder.ensure_module(&to_path).1;\n+    for (from_ident, to_ident) in all_edges {\n+        let from_index = builder.get_module(&from_ident).1;\n+        let to_index = builder.get_module(&to_ident).1;\n         if from_index == to_index {\n             continue;\n         }\n@@ -472,9 +495,9 @@ pub async fn analyze_module_graphs(module_graphs: Vc<ModuleGraphs>) -> Result<Vc\n             .dependents\n             .insert(from_index);\n     }\n-    for (from_path, to_path) in all_async_edges {\n-        let from_index = builder.ensure_module(&from_path).1;\n-        let to_index = builder.ensure_module(&to_path).1;\n+    for (from_ident, to_ident) in all_async_edges {\n+        let from_index = builder.get_module(&from_ident).1;\n+        let to_index = builder.get_module(&to_ident).1;\n         if from_index == to_index {\n             continue;\n         }\n@@ -486,56 +509,6 @@ pub async fn analyze_module_graphs(module_graphs: Vc<ModuleGraphs>) -> Result<Vc\n             .insert(from_index);\n     }\n \n-    // Compute depth using BFS from modules without incoming edges\n-    let mut queue = std::collections::VecDeque::new();\n-\n-    // Find modules without incoming edges and set their depth to 0\n-    for (index, module) in builder.modules.iter_mut().enumerate() {\n-        if module.dependents.is_empty() && module.async_dependents.is_empty() {\n-            module.module.depth = 0;\n-            queue.push_back(index as u32);\n-        }\n-    }\n-\n-    // Process queue and propagate depth\n-    while let Some(current_index) = queue.pop_front() {\n-        let current_depth = builder.modules[current_index as usize].module.depth;\n-\n-        // Collect dependencies to avoid borrow conflicts\n-        let dependencies: Vec<u32> = builder.modules[current_index as usize]\n-            .dependencies\n-            .iter()\n-            .copied()\n-            .collect();\n-\n-        // Update dependencies\n-        let new_depth = current_depth + 1;\n-        for &dep_index in &dependencies {\n-            let dep_module = &mut builder.modules[dep_index as usize];\n-            if new_depth < dep_module.module.depth {\n-                dep_module.module.depth = new_depth;\n-                queue.push_back(dep_index);\n-            }\n-        }\n-\n-        // Collect async dependencies to avoid borrow conflicts\n-        let async_dependencies: Vec<u32> = builder.modules[current_index as usize]\n-            .async_dependencies\n-            .iter()\n-            .copied()\n-            .collect();\n-\n-        // Update async dependencies\n-        let new_depth = current_depth + 1000;\n-        for &dep_index in &async_dependencies {\n-            let dep_module = &mut builder.modules[dep_index as usize];\n-            if new_depth < dep_module.module.depth {\n-                dep_module.module.depth = new_depth;\n-                queue.push_back(dep_index);\n-            }\n-        }\n-    }\n-\n     let rope = builder.build();\n     Ok(FileContent::Content(File::from(rope)).cell())\n }"
        },
        {
            "sha": "64455633d9a0d70197bcbf6839e26d954218274a",
            "filename": "pnpm-lock.yaml",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/e9a3ba935f9fe99fbfbd634627de28736892c976/pnpm-lock.yaml",
            "raw_url": "https://github.com/vercel/next.js/raw/e9a3ba935f9fe99fbfbd634627de28736892c976/pnpm-lock.yaml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/pnpm-lock.yaml?ref=e9a3ba935f9fe99fbfbd634627de28736892c976",
            "patch": "@@ -643,8 +643,8 @@ importers:\n         specifier: 1.0.4\n         version: 1.0.4(@types/react-dom@19.2.1(@types/react@19.2.2))(@types/react@19.2.2)(react-dom@19.3.0-canary-8ac5f4eb-20251119(react@19.3.0-canary-8ac5f4eb-20251119))(react@19.3.0-canary-8ac5f4eb-20251119)\n       lucide-react:\n-        specifier: ^0.454.0\n-        version: 0.454.0(react@19.3.0-canary-8ac5f4eb-20251119)\n+        specifier: ^0.554.0\n+        version: 0.554.0(react@19.3.0-canary-8ac5f4eb-20251119)\n       next:\n         specifier: 16.0.1\n         version: 16.0.1(@babel/core@7.26.10)(@opentelemetry/api@1.6.0)(@playwright/test@1.51.1)(babel-plugin-macros@3.1.0)(babel-plugin-react-compiler@0.0.0-experimental-3fde738-20250918)(react-dom@19.3.0-canary-8ac5f4eb-20251119(react@19.3.0-canary-8ac5f4eb-20251119))(react@19.3.0-canary-8ac5f4eb-20251119)(sass@1.77.8)\n@@ -12820,8 +12820,8 @@ packages:\n     peerDependencies:\n       react: 19.3.0-canary-8ac5f4eb-20251119\n \n-  lucide-react@0.454.0:\n-    resolution: {integrity: sha512-hw7zMDwykCLnEzgncEEjHeA6+45aeEzRYuKHuyRSOPkhko+J3ySGjGIzu+mmMfDFG1vazHepMaYFYHbTFAZAAQ==}\n+  lucide-react@0.554.0:\n+    resolution: {integrity: sha512-St+z29uthEJVx0Is7ellNkgTEhaeSoA42I7JjOCBCrc5X6LYMGSv0P/2uS5HDLTExP5tpiqRD2PyUEOS6s9UXA==}\n     peerDependencies:\n       react: 19.3.0-canary-8ac5f4eb-20251119\n \n@@ -31817,7 +31817,7 @@ snapshots:\n     dependencies:\n       react: 19.3.0-canary-fb2177c1-20251114\n \n-  lucide-react@0.454.0(react@19.3.0-canary-8ac5f4eb-20251119):\n+  lucide-react@0.554.0(react@19.3.0-canary-8ac5f4eb-20251119):\n     dependencies:\n       react: 19.3.0-canary-8ac5f4eb-20251119\n "
        }
    ],
    "stats": {
        "total": 873,
        "additions": 594,
        "deletions": 279
    }
}