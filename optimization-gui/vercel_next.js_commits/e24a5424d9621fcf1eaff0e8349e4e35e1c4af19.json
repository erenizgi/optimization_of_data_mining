{
    "author": "mischnic",
    "message": "Turbopack: parallelize scope hoisting computation (#83904)\n\nParallellize the `for chunk_group {` loop",
    "sha": "e24a5424d9621fcf1eaff0e8349e4e35e1c4af19",
    "files": [
        {
            "sha": "22808f9cad101d27be916d7854588ab28ab8310e",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/merged_modules.rs",
            "status": "modified",
            "additions": 165,
            "deletions": 89,
            "changes": 254,
            "blob_url": "https://github.com/vercel/next.js/blob/e24a5424d9621fcf1eaff0e8349e4e35e1c4af19/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e24a5424d9621fcf1eaff0e8349e4e35e1c4af19/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs?ref=e24a5424d9621fcf1eaff0e8349e4e35e1c4af19",
            "patch": "@@ -243,17 +243,24 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             // index.\n             entry: usize,\n             list: usize,\n+            chunk_group: usize,\n         }\n \n         // A list of all different execution traces (orderings) of all modules, initially a union of\n         // the partition of each chunk's modules (one for each ESM subtree in each chunks), but\n         // further split up later on.\n-        let mut lists = vec![];\n+        // This is a list (one per chunk group, initially) of lists (one per ESM subtree) of modules\n+        let mut lists;\n         let mut lists_reverse_indices: FxIndexMap<\n             ResolvedVc<Box<dyn MergeableModule>>,\n             FxIndexSet<ListOccurrence>,\n         > = FxIndexMap::default();\n \n+        // Once we do the reconciliation below, we need to insert new lists, but the lists are per\n+        // chunk group, so we put them into this one.\n+        #[allow(non_snake_case)]\n+        let LISTS_COMMON_IDX: usize;\n+\n         // A map of all references between modules with the same bitmap. These are all references,\n         // including reexecution edges and cycles. Used to expose additional modules if the\n         // bitmap-groups are split up further.\n@@ -270,85 +277,147 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             FxIndexSet<ResolvedVc<Box<dyn Module>>>,\n         > = FxIndexMap::default();\n \n-        // TODO try to parallelize this loop somehow\n-        for chunk_group in &chunk_group_info.chunk_groups {\n-            // A partition of all modules in the chunk into several execution traces (orderings),\n-            // stored in the top-level lists and referenced here by index.\n-            let mut chunk_lists: FxHashMap<&RoaringBitmapWrapper, usize> =\n-                FxHashMap::with_capacity_and_hasher(\n-                    module_merged_groups.len() / chunk_group_info.chunk_groups.len(),\n-                    Default::default(),\n-                );\n-\n-            // This is necessary to have the correct order with cycles: a `a -> b -> a` graph would\n-            // otherwise be visited as `b->a`, `a->b`, leading to the list `a, b` which is not\n-            // execution order.\n-            let mut visited = FxHashSet::default();\n-\n-            module_graph.traverse_edges_from_entries_dfs(\n-                chunk_group.entries(),\n-                &mut (),\n-                |parent_info, node, _| {\n-                    if parent_info.is_none_or(|(_, r)| r.chunking_type.is_parallel())\n-                        && visited.insert(node.module)\n-                    {\n-                        Ok(GraphTraversalAction::Continue)\n-                    } else {\n-                        Ok(GraphTraversalAction::Exclude)\n-                    }\n-                },\n-                |parent_info, node, _| {\n-                    let module = node.module;\n-                    let bitmap = module_merged_groups\n-                        .get(&module)\n-                        .context(\"every module should have a bitmap at this point\")?;\n-\n-                    if mergeable.contains(&module) {\n-                        let mergeable_module =\n-                            ResolvedVc::try_downcast::<Box<dyn MergeableModule>>(module).unwrap();\n-                        match chunk_lists.entry(bitmap) {\n-                            Entry::Vacant(e) => {\n-                                // New list, insert the module\n-                                let idx = lists.len();\n-                                e.insert(idx);\n-                                lists.push(vec![mergeable_module]);\n-                                lists_reverse_indices\n-                                    .entry(mergeable_module)\n-                                    .or_default()\n-                                    .insert(ListOccurrence {\n-                                        list: idx,\n-                                        entry: 0,\n-                                    });\n+        {\n+            struct ChunkGroupResult {\n+                chunk_group_idx: usize,\n+                lists: Vec<Vec<ResolvedVc<Box<dyn MergeableModule>>>>,\n+                lists_reverse_indices:\n+                    FxIndexMap<ResolvedVc<Box<dyn MergeableModule>>, FxIndexSet<ListOccurrence>>,\n+                #[allow(clippy::type_complexity)]\n+                intra_group_references_rev: FxIndexMap<\n+                    ResolvedVc<Box<dyn Module>>,\n+                    FxIndexSet<ResolvedVc<Box<dyn Module>>>,\n+                >,\n+            }\n+\n+            let result = turbo_tasks::parallel::map_collect_owned::<_, _, Result<Vec<_>>>(\n+                // TODO without collect\n+                chunk_group_info.chunk_groups.iter().enumerate().collect(),\n+                |(chunk_group_idx, chunk_group)| {\n+                    // A partition of all modules in the chunk into several execution traces\n+                    // (orderings), stored in the top-level lists and referenced here by\n+                    // index.\n+                    let mut chunk_lists: FxHashMap<&RoaringBitmapWrapper, usize> =\n+                        FxHashMap::with_capacity_and_hasher(\n+                            module_merged_groups.len() / chunk_group_info.chunk_groups.len(),\n+                            Default::default(),\n+                        );\n+\n+                    // This is necessary to have the correct order with cycles: a `a -> b -> a`\n+                    // graph would otherwise be visited as `b->a`, `a->b`,\n+                    // leading to the list `a, b` which is not execution order.\n+                    let mut visited = FxHashSet::default();\n+\n+                    let mut lists = vec![];\n+                    let mut lists_reverse_indices: FxIndexMap<\n+                        ResolvedVc<Box<dyn MergeableModule>>,\n+                        FxIndexSet<ListOccurrence>,\n+                    > = FxIndexMap::default();\n+                    #[allow(clippy::type_complexity)]\n+                    let mut intra_group_references_rev: FxIndexMap<\n+                        ResolvedVc<Box<dyn Module>>,\n+                        FxIndexSet<ResolvedVc<Box<dyn Module>>>,\n+                    > = FxIndexMap::default();\n+\n+                    module_graph.traverse_edges_from_entries_dfs(\n+                        chunk_group.entries(),\n+                        &mut (),\n+                        |parent_info, node, _| {\n+                            if parent_info.is_none_or(|(_, r)| r.chunking_type.is_parallel())\n+                                && visited.insert(node.module)\n+                            {\n+                                Ok(GraphTraversalAction::Continue)\n+                            } else {\n+                                Ok(GraphTraversalAction::Exclude)\n                             }\n-                            Entry::Occupied(e) => {\n-                                let list_idx = *e.get();\n-                                let list = &mut lists[list_idx];\n-                                list.push(mergeable_module);\n-                                lists_reverse_indices\n-                                    .entry(mergeable_module)\n-                                    .or_default()\n-                                    .insert(ListOccurrence {\n-                                        list: list_idx,\n-                                        entry: list.len() - 1,\n-                                    });\n+                        },\n+                        |parent_info, node, _| {\n+                            let module = node.module;\n+                            let bitmap = module_merged_groups\n+                                .get(&module)\n+                                .context(\"every module should have a bitmap at this point\")?;\n+\n+                            if mergeable.contains(&module) {\n+                                let mergeable_module =\n+                                    ResolvedVc::try_downcast::<Box<dyn MergeableModule>>(module)\n+                                        .unwrap();\n+                                match chunk_lists.entry(bitmap) {\n+                                    Entry::Vacant(e) => {\n+                                        // New list, insert the module\n+                                        let idx = lists.len();\n+                                        e.insert(idx);\n+                                        lists.push(vec![mergeable_module]);\n+                                        lists_reverse_indices\n+                                            .entry(mergeable_module)\n+                                            .or_default()\n+                                            .insert(ListOccurrence {\n+                                                chunk_group: chunk_group_idx,\n+                                                list: idx,\n+                                                entry: 0,\n+                                            });\n+                                    }\n+                                    Entry::Occupied(e) => {\n+                                        let list_idx = *e.get();\n+                                        let list = &mut lists[list_idx];\n+                                        list.push(mergeable_module);\n+                                        lists_reverse_indices\n+                                            .entry(mergeable_module)\n+                                            .or_default()\n+                                            .insert(ListOccurrence {\n+                                                chunk_group: chunk_group_idx,\n+                                                list: list_idx,\n+                                                entry: list.len() - 1,\n+                                            });\n+                                    }\n+                                }\n                             }\n-                        }\n-                    }\n \n-                    if let Some((parent, _)) = parent_info {\n-                        let same_bitmap = module_merged_groups.get(&parent.module).unwrap()\n-                            == module_merged_groups.get(&module).unwrap();\n+                            if let Some((parent, _)) = parent_info {\n+                                let same_bitmap = module_merged_groups.get(&parent.module).unwrap()\n+                                    == module_merged_groups.get(&module).unwrap();\n \n-                        if same_bitmap {\n-                            intra_group_references_rev\n-                                .entry(module)\n-                                .or_default()\n-                                .insert(parent.module);\n-                        }\n-                    }\n-                    Ok(())\n+                                if same_bitmap {\n+                                    intra_group_references_rev\n+                                        .entry(module)\n+                                        .or_default()\n+                                        .insert(parent.module);\n+                                }\n+                            }\n+                            Ok(())\n+                        },\n+                    )?;\n+                    Ok(ChunkGroupResult {\n+                        chunk_group_idx,\n+                        lists,\n+                        lists_reverse_indices,\n+                        intra_group_references_rev,\n+                    })\n                 },\n             )?;\n+\n+            lists = vec![Default::default(); result.len() + 1];\n+            LISTS_COMMON_IDX = result.len();\n+            for ChunkGroupResult {\n+                chunk_group_idx,\n+                lists: result_lists,\n+                lists_reverse_indices: result_lists_reverse_indices,\n+                intra_group_references_rev: result_intra_group_references_rev,\n+            } in result\n+            {\n+                lists[chunk_group_idx] = result_lists;\n+                for (module, occurrences) in result_lists_reverse_indices {\n+                    lists_reverse_indices\n+                        .entry(module)\n+                        .or_default()\n+                        .extend(occurrences);\n+                }\n+                for (module, occurrences) in result_intra_group_references_rev {\n+                    intra_group_references_rev\n+                        .entry(module)\n+                        .or_default()\n+                        .extend(occurrences);\n+                }\n+            }\n         }\n \n         drop(inner_span);\n@@ -419,15 +488,18 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             // Find the longest common sequence in the lists, starting from the given module.\n             let mut common_length = 2;\n             loop {\n-                let m =\n-                    lists[first_occurrence.list].get(first_occurrence.entry + common_length - 1);\n+                let m = lists[first_occurrence.chunk_group][first_occurrence.list]\n+                    .get(first_occurrence.entry + common_length - 1);\n                 if m.is_some()\n-                    && common_occurrences\n-                        .iter()\n-                        .skip(1)\n-                        .all(|ListOccurrence { list, entry }| {\n-                            lists[*list].get(*entry + common_length - 1) == m\n-                        })\n+                    && common_occurrences.iter().skip(1).all(\n+                        |ListOccurrence {\n+                             chunk_group,\n+                             list,\n+                             entry,\n+                         }| {\n+                            lists[*chunk_group][*list].get(*entry + common_length - 1) == m\n+                        },\n+                    )\n                 {\n                     common_length += 1;\n                     continue;\n@@ -442,32 +514,34 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             // - \"common\" [occurrence.entry .. occurrence.entry + common_length) -- same for all\n             // - \"before\" [0 .. occurrence.entry)\n             // - \"after\"  [occurrence.entry + common_length .. ]\n-            let common_list = lists[first_occurrence.list]\n+            let common_list = lists[first_occurrence.chunk_group][first_occurrence.list]\n                 [first_occurrence.entry..first_occurrence.entry + common_length]\n                 .to_vec();\n \n-            let common_list_index = lists.len();\n-            lists.push(common_list.clone());\n+            let common_list_index = lists[LISTS_COMMON_IDX].len();\n+            lists[LISTS_COMMON_IDX].push(common_list.clone());\n \n             // Insert occurrences for the \"common\" list, skip the first because that is now\n             // guaranteed to exist only once\n             for (i, &m) in common_list.iter().enumerate().skip(1) {\n                 let occurrences = lists_reverse_indices.get_mut(&m).unwrap();\n                 for common_occurrence in &common_occurrences {\n                     let removed = occurrences.swap_remove(&ListOccurrence {\n+                        chunk_group: common_occurrence.chunk_group,\n                         list: common_occurrence.list,\n                         entry: common_occurrence.entry + i,\n                     });\n                     debug_assert!(removed);\n                 }\n                 occurrences.insert(ListOccurrence {\n+                    chunk_group: LISTS_COMMON_IDX,\n                     list: common_list_index,\n                     entry: i,\n                 });\n             }\n \n             for common_occurrence in &common_occurrences {\n-                let list = &mut lists[common_occurrence.list];\n+                let list = &mut lists[common_occurrence.chunk_group][common_occurrence.list];\n                 let after_list = list.split_off(common_occurrence.entry + common_length);\n                 list.truncate(common_occurrence.entry);\n                 let before_list = &*list;\n@@ -524,20 +598,22 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                 // The occurrences for the \"before\" list (`list`) are still valid, need to update\n                 // the occurrences for the \"after\" list\n                 if !after_list.is_empty() {\n-                    let after_index = lists.len();\n-                    lists.push(after_list.clone());\n+                    let after_index = lists[LISTS_COMMON_IDX].len();\n+                    lists[LISTS_COMMON_IDX].push(after_list.clone());\n                     for (i, &m) in after_list.iter().enumerate() {\n                         let Some(occurrences) = lists_reverse_indices.get_mut(&m) else {\n                             bail!(\"Couldn't find module in reverse list\");\n                         };\n \n                         let removed = occurrences.swap_remove(&ListOccurrence {\n+                            chunk_group: common_occurrence.chunk_group,\n                             list: common_occurrence.list,\n                             entry: common_occurrence.entry + common_length + i,\n                         });\n                         debug_assert!(removed);\n \n                         occurrences.insert(ListOccurrence {\n+                            chunk_group: LISTS_COMMON_IDX,\n                             list: after_index,\n                             entry: i,\n                         });\n@@ -547,7 +623,7 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n         }\n \n         // Dedupe the lists\n-        let lists = lists.into_iter().collect::<FxHashSet<_>>();\n+        let lists = lists.into_iter().flatten().collect::<FxHashSet<_>>();\n \n         drop(inner_span);\n         let inner_span = tracing::info_span!(\"merging\");"
        }
    ],
    "stats": {
        "total": 254,
        "additions": 165,
        "deletions": 89
    }
}