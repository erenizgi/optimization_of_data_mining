{
    "author": "gnoff",
    "message": "[Cache Components] Reset PrerenderStore after generating RSC payload (#82286)\n\nThe RSC payload ideally would be constructed during the prerender.\nHowever it is not currently sync and RSC doesn't provide a top level way\nto produce an object child from a function at the root so we generate\nthe component tree before starting the render.\n\nHowever we use the workUnitStore type to govern certain behaviors within\nthe RSC payload generation for instance preparing things like\nsearchParams and params props for layouts and pages.\n\nSo at the moment we scope the RSC generation inside the same\nworkUnitStore instance that will also scope the prerender. This is fine\nexcept there are certain things that apply in the prerender context that\ndo not apply in the component tree generation. Namely we do not want to\ntrack Sync IO as need to abort the prerender. This would lead to the\nentire prerender being aborted before it even begins.\n\nThere are a few options. We could create a new workUnitStore type. This\nisn't great b/c we have so many places where we need to exhaustively\ncheck this.\n\nWe could use a new phase to similarly track whether we're before render\nor not however this has the same problem of all places where phase is\nconsidered needing to be aware of this additional possible phase.\n\nInstead I think we ought to leave the logic of the code that determines\nwhat to do simple and continue to track the sync IO but we just reset\nthe dynamic tracking and abort controllers so that the render starts\nafresh with these.",
    "sha": "d49f449f94f4df81635c2dffd767018df10e97bd",
    "files": [
        {
            "sha": "a2aa7203de36cf656ad738f686ba844c86523cbe",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 136,
            "deletions": 23,
            "changes": 159,
            "blob_url": "https://github.com/vercel/next.js/blob/d49f449f94f4df81635c2dffd767018df10e97bd/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d49f449f94f4df81635c2dffd767018df10e97bd/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=d49f449f94f4df81635c2dffd767018df10e97bd",
            "patch": "@@ -2660,14 +2660,19 @@ async function spawnDynamicValidationInDev(\n   // prerendering of an already prerendered page, we should use the passed\n   // resume data cache instead.\n   const prerenderResumeDataCache = createPrerenderResumeDataCache()\n-  const initialServerPrerenderStore: PrerenderStore = {\n+  const initialServerPayloadPrerenderStore: PrerenderStore = {\n     type: 'prerender',\n     phase: 'render',\n     rootParams,\n     fallbackRouteParams,\n     implicitTags,\n+    // While this render signal isn't going to be used to abort a React render while getting the RSC payload\n+    // various request data APIs bind to this controller to reject after completion.\n     renderSignal: initialServerRenderController.signal,\n-    controller: initialServerPrerenderController,\n+    // When we generate the RSC payload we might abort this controller due to sync IO\n+    // but we don't actually care about sync IO in this phase so we use a throw away controller\n+    // that isn't connected to anything\n+    controller: new AbortController(),\n     // During the initial prerender we need to track all cache reads to ensure\n     // we render long enough to fill every cache it is possible to visit during\n     // the final prerender.\n@@ -2687,13 +2692,37 @@ async function spawnDynamicValidationInDev(\n   // We're not going to use the result of this render because the only time it could be used\n   // is if it completes in a microtask and that's likely very rare for any non-trivial app\n   const initialServerPayload = await workUnitAsyncStorage.run(\n-    initialServerPrerenderStore,\n+    initialServerPayloadPrerenderStore,\n     getRSCPayload,\n     tree,\n     ctx,\n     isNotFound\n   )\n \n+  const initialServerPrerenderStore: PrerenderStore = {\n+    type: 'prerender',\n+    phase: 'render',\n+    rootParams,\n+    fallbackRouteParams,\n+    implicitTags,\n+    renderSignal: initialServerRenderController.signal,\n+    controller: initialServerPrerenderController,\n+    // During the initial prerender we need to track all cache reads to ensure\n+    // we render long enough to fill every cache it is possible to visit during\n+    // the final prerender.\n+    cacheSignal,\n+    dynamicTracking: null,\n+    allowEmptyStaticShell,\n+    revalidate: INFINITE_CACHE,\n+    expire: INFINITE_CACHE,\n+    stale: INFINITE_CACHE,\n+    tags: [...implicitTags.tags],\n+    prerenderResumeDataCache,\n+    renderResumeDataCache: null,\n+    hmrRefreshHash,\n+    captureOwnerStack: captureOwnerStackServer,\n+  }\n+\n   const pendingInitialServerResult = workUnitAsyncStorage.run(\n     initialServerPrerenderStore,\n     ComponentMod.prerender,\n@@ -2897,21 +2926,22 @@ async function spawnDynamicValidationInDev(\n   const finalServerReactController = new AbortController()\n   const finalServerRenderController = new AbortController()\n \n-  const serverDynamicTracking = createDynamicTrackingState(\n-    false // isDebugDynamicAccesses\n-  )\n-\n-  const finalServerPrerenderStore: PrerenderStore = {\n+  const finalServerPayloadPrerenderStore: PrerenderStore = {\n     type: 'prerender',\n     phase: 'render',\n     rootParams,\n     fallbackRouteParams,\n     implicitTags,\n+    // While this render signal isn't going to be used to abort a React render while getting the RSC payload\n+    // various request data APIs bind to this controller to reject after completion.\n     renderSignal: finalServerRenderController.signal,\n-    controller: finalServerReactController,\n+    // When we generate the RSC payload we might abort this controller due to sync IO\n+    // but we don't actually care about sync IO in this phase so we use a throw away controller\n+    // that isn't connected to anything\n+    controller: new AbortController(),\n     // All caches we could read must already be filled so no tracking is necessary\n     cacheSignal: null,\n-    dynamicTracking: serverDynamicTracking,\n+    dynamicTracking: null,\n     allowEmptyStaticShell,\n     revalidate: INFINITE_CACHE,\n     expire: INFINITE_CACHE,\n@@ -2924,13 +2954,39 @@ async function spawnDynamicValidationInDev(\n   }\n \n   const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n-    finalServerPrerenderStore,\n+    finalServerPayloadPrerenderStore,\n     getRSCPayload,\n     tree,\n     ctx,\n     isNotFound\n   )\n \n+  const serverDynamicTracking = createDynamicTrackingState(\n+    false // isDebugDynamicAccesses\n+  )\n+\n+  const finalServerPrerenderStore: PrerenderStore = {\n+    type: 'prerender',\n+    phase: 'render',\n+    rootParams,\n+    fallbackRouteParams,\n+    implicitTags,\n+    renderSignal: finalServerRenderController.signal,\n+    controller: finalServerReactController,\n+    // All caches we could read must already be filled so no tracking is necessary\n+    cacheSignal: null,\n+    dynamicTracking: serverDynamicTracking,\n+    allowEmptyStaticShell,\n+    revalidate: INFINITE_CACHE,\n+    expire: INFINITE_CACHE,\n+    stale: INFINITE_CACHE,\n+    tags: [...implicitTags.tags],\n+    prerenderResumeDataCache,\n+    renderResumeDataCache: null,\n+    hmrRefreshHash,\n+    captureOwnerStack: captureOwnerStackServer,\n+  }\n+\n   const reactServerResult = await createReactServerPrerenderResult(\n     prerenderAndAbortInSequentialTasks(\n       async () => {\n@@ -3354,14 +3410,19 @@ async function prerenderToStream(\n           createPrerenderResumeDataCache()\n       }\n \n-      const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n+      const initialServerPayloadPrerenderStore: PrerenderStore = {\n         type: 'prerender',\n         phase: 'render',\n         rootParams,\n         fallbackRouteParams,\n         implicitTags,\n+        // While this render signal isn't going to be used to abort a React render while getting the RSC payload\n+        // various request data APIs bind to this controller to reject after completion.\n         renderSignal: initialServerRenderController.signal,\n-        controller: initialServerPrerenderController,\n+        // When we generate the RSC payload we might abort this controller due to sync IO\n+        // but we don't actually care about sync IO in this phase so we use a throw away controller\n+        // that isn't connected to anything\n+        controller: new AbortController(),\n         // During the initial prerender we need to track all cache reads to ensure\n         // we render long enough to fill every cache it is possible to visit during\n         // the final prerender.\n@@ -3376,18 +3437,42 @@ async function prerenderToStream(\n         renderResumeDataCache,\n         hmrRefreshHash: undefined,\n         captureOwnerStack: undefined, // Not available in production.\n-      })\n+      }\n \n       // We're not going to use the result of this render because the only time it could be used\n       // is if it completes in a microtask and that's likely very rare for any non-trivial app\n       const initialServerPayload = await workUnitAsyncStorage.run(\n-        initialServerPrerenderStore,\n+        initialServerPayloadPrerenderStore,\n         getRSCPayload,\n         tree,\n         ctx,\n         res.statusCode === 404\n       )\n \n+      const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n+        type: 'prerender',\n+        phase: 'render',\n+        rootParams,\n+        fallbackRouteParams,\n+        implicitTags,\n+        renderSignal: initialServerRenderController.signal,\n+        controller: initialServerPrerenderController,\n+        // During the initial prerender we need to track all cache reads to ensure\n+        // we render long enough to fill every cache it is possible to visit during\n+        // the final prerender.\n+        cacheSignal,\n+        dynamicTracking: null,\n+        allowEmptyStaticShell,\n+        revalidate: INFINITE_CACHE,\n+        expire: INFINITE_CACHE,\n+        stale: INFINITE_CACHE,\n+        tags: [...implicitTags.tags],\n+        prerenderResumeDataCache,\n+        renderResumeDataCache,\n+        hmrRefreshHash: undefined,\n+        captureOwnerStack: undefined, // Not available in production.\n+      })\n+\n       const pendingInitialServerResult = workUnitAsyncStorage.run(\n         initialServerPrerenderStore,\n         ComponentMod.prerender,\n@@ -3580,13 +3665,48 @@ async function prerenderToStream(\n         initialClientReactController.abort()\n       }\n \n-      let serverIsDynamic = false\n       const finalServerReactController = new AbortController()\n       const finalServerRenderController = new AbortController()\n \n+      const finalServerPayloadPrerenderStore: PrerenderStore = {\n+        type: 'prerender',\n+        phase: 'render',\n+        rootParams,\n+        fallbackRouteParams,\n+        implicitTags,\n+        // While this render signal isn't going to be used to abort a React render while getting the RSC payload\n+        // various request data APIs bind to this controller to reject after completion.\n+        renderSignal: finalServerRenderController.signal,\n+        // When we generate the RSC payload we might abort this controller due to sync IO\n+        // but we don't actually care about sync IO in this phase so we use a throw away controller\n+        // that isn't connected to anything\n+        controller: new AbortController(),\n+        // All caches we could read must already be filled so no tracking is necessary\n+        cacheSignal: null,\n+        dynamicTracking: null,\n+        allowEmptyStaticShell,\n+        revalidate: INFINITE_CACHE,\n+        expire: INFINITE_CACHE,\n+        stale: INFINITE_CACHE,\n+        tags: [...implicitTags.tags],\n+        prerenderResumeDataCache,\n+        renderResumeDataCache,\n+        hmrRefreshHash: undefined,\n+        captureOwnerStack: undefined, // Not available in production.\n+      }\n+\n+      const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n+        finalServerPayloadPrerenderStore,\n+        getRSCPayload,\n+        tree,\n+        ctx,\n+        res.statusCode === 404\n+      )\n+\n       const serverDynamicTracking = createDynamicTrackingState(\n         isDebugDynamicAccesses\n       )\n+      let serverIsDynamic = false\n \n       const finalServerPrerenderStore: PrerenderStore = (prerenderStore = {\n         type: 'prerender',\n@@ -3610,13 +3730,6 @@ async function prerenderToStream(\n         captureOwnerStack: undefined, // Not available in production.\n       })\n \n-      const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n-        finalServerPrerenderStore,\n-        getRSCPayload,\n-        tree,\n-        ctx,\n-        res.statusCode === 404\n-      )\n       let prerenderIsPending = true\n       const reactServerResult = (reactServerPrerenderResult =\n         await createReactServerPrerenderResult("
        },
        {
            "sha": "4965832f2c9b0605eaa189b7c7fb11124d24e48a",
            "filename": "test/e2e/app-dir/cache-components-create-component-tree/app/favicon.ico",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/d49f449f94f4df81635c2dffd767018df10e97bd/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fapp%2Ffavicon.ico",
            "raw_url": "https://github.com/vercel/next.js/raw/d49f449f94f4df81635c2dffd767018df10e97bd/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fapp%2Ffavicon.ico",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fapp%2Ffavicon.ico?ref=d49f449f94f4df81635c2dffd767018df10e97bd"
        },
        {
            "sha": "7be34446efd2da5ce3bcd9290009c2a049c5a9e2",
            "filename": "test/e2e/app-dir/cache-components-create-component-tree/app/layout.tsx",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/d49f449f94f4df81635c2dffd767018df10e97bd/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d49f449f94f4df81635c2dffd767018df10e97bd/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fapp%2Flayout.tsx?ref=d49f449f94f4df81635c2dffd767018df10e97bd",
            "patch": "@@ -0,0 +1,38 @@\n+/**\n+ * This is a rather contrived test. The trick is to construct a scenario where\n+ * Math.random is called during the create-component-tree phase but not during the render.\n+ * To do this we patch Symbol.for. When the `react.client.reference` symbol is checked\n+ * we know that this is happening in the create-component-tree function. Given the simple\n+ * setup of the test page this symbol is not checked during the actual prerender itself.\n+ *\n+ * This test may flake in the future. It should be replaced ideally with a test that uses\n+ * our OTel implementation to ensure that the built-in trace in create-component-tree does not\n+ * early abort the prerender. The problem is that we are about to make these functions avoid the\n+ * workUnitStore scope so it will not express the regression for other reasons.\n+ */\n+function patchSymbolFor() {\n+  const isPatched = globalThis[Symbol.for('__SYMBOL_FOR_PATCHED__')]\n+  if (!isPatched) {\n+    console.log('patching')\n+    globalThis[Symbol.for('__SYMBOL_FOR_PATCHED__')] = true\n+\n+    const originalSymbolFor = Symbol.for\n+\n+    Symbol.for = (...args) => {\n+      if (args[0] === 'react.client.reference') {\n+        Math.random()\n+      }\n+      return originalSymbolFor.apply(Symbol, args)\n+    }\n+  }\n+}\n+\n+patchSymbolFor()\n+\n+export default function Root({ children }: { children: React.ReactNode }) {\n+  return (\n+    <html>\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "209f60c9ae435f02dd7371575e14a220fffd4717",
            "filename": "test/e2e/app-dir/cache-components-create-component-tree/app/page.tsx",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/d49f449f94f4df81635c2dffd767018df10e97bd/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d49f449f94f4df81635c2dffd767018df10e97bd/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fapp%2Fpage.tsx?ref=d49f449f94f4df81635c2dffd767018df10e97bd",
            "patch": "@@ -0,0 +1,20 @@\n+export default function Page() {\n+  return (\n+    <>\n+      <p>\n+        This test does some hacky stuff to cause a `Math.random()` call to\n+        happen during the component tree creation which happens before the RSC\n+        render. Before the fix that this test accompanied landed this kind of\n+        sync IO was reported as a problem in Dev and in runtime during start. In\n+        practice this would be because of an OTEL span generation during\n+        create-component-tree. With this fix in place the create-component-tree\n+        function will not leak any sync IO results into the final prerender.\n+      </p>\n+      <p>\n+        In the long run we ought to move create-component-tree into the render\n+        itself and ensure the tree structure comports with CacheComponent rules.\n+        This test can be deleted at that time.\n+      </p>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "3daac670ff197c87167a6576d58dfad3e0abfc3d",
            "filename": "test/e2e/app-dir/cache-components-create-component-tree/cache-components-create-component-tree.test.ts",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/d49f449f94f4df81635c2dffd767018df10e97bd/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fcache-components-create-component-tree.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d49f449f94f4df81635c2dffd767018df10e97bd/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fcache-components-create-component-tree.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fcache-components-create-component-tree.test.ts?ref=d49f449f94f4df81635c2dffd767018df10e97bd",
            "patch": "@@ -0,0 +1,31 @@\n+import { isNextDev, nextTestSetup } from 'e2e-utils'\n+import { assertNoRedbox } from 'next-test-utils'\n+\n+describe('hello-world', () => {\n+  const { next } = nextTestSetup({\n+    files: __dirname,\n+    skipStart: !isNextDev,\n+    skipDeployment: true,\n+  })\n+\n+  if (isNextDev) {\n+    it('should not indicate there is an error when incidental math.random calls occur during component tree generation during dev', async () => {\n+      const browser = await next.browser('/')\n+      await assertNoRedbox(browser)\n+\n+      // The redbox assertion is currently unreliable in this test and so this is an additional check to ensure the CLI didn't print anything with `Math.random()` in it.\n+      expect(next.cliOutput).not.toContain('Math.random()')\n+    })\n+  } else {\n+    it('should not indicate there is an error when incidental math.random calls occur during component tree generation during build', async () => {\n+      try {\n+        await next.build()\n+      } catch (e) {\n+        console.error('Expected build to Succeed, but it failed.')\n+        throw e\n+      }\n+\n+      expect(next.cliOutput).not.toContain('Math.random()')\n+    })\n+  }\n+})"
        },
        {
            "sha": "30a826fdacc568ffb8cd6641fe15330a3c9d618d",
            "filename": "test/e2e/app-dir/cache-components-create-component-tree/next.config.js",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/d49f449f94f4df81635c2dffd767018df10e97bd/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/d49f449f94f4df81635c2dffd767018df10e97bd/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-create-component-tree%2Fnext.config.js?ref=d49f449f94f4df81635c2dffd767018df10e97bd",
            "patch": "@@ -0,0 +1,10 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  experimental: {\n+    cacheComponents: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        }
    ],
    "stats": {
        "total": 258,
        "additions": 235,
        "deletions": 23
    }
}