{
    "author": "bgw",
    "message": "Turbopack: Rework watcher data structures, store watched list and watcher behind the same RwLock (#82258)\n\nReworks the data structures used for the watcher to achieve a few goals:\n\n- I want to avoid multiple locks, as I don't think we actually need two different locks, and multiple locks leaves more room for bugs (e.g. lock inversion).\n- The information about if we're in non-recursive mode or recursive mode needs to be available outside of the lock for performance reasons.\n- The `watching`/`watched` set needs to be ordered. We don't have a convenient concurrent BTreeSet or Trie/Radix Tree pulled in, and I'd like to avoid adding more dependencies. We end up locking `notify_watcher` anywhere we'd need a write lock anyways, so it might block a few reads, but otherwise it's not that bad.\n\nFixes in this PR:\n\n- Fixes an issue where multiple concurrent calls to `ensure_watching` for the same directory could cause one of those calls to exit early. This may cause a file in that directory to be read before the filesystem watcher is set up, potentially missing events.\n- Improves the time complexity of `restore_if_watching` using an ordered set to avoid iterating over all of `watched` to find child directories. See `OrderedPathSetExt`. This time complexity problem is introduced in the previous PR, #82130.\n\nOther changes:\n\n- It turns out that we don't need to explicitly set up any watchers during `start_watching` except for the `root_dir`. If paths have already been read, they'll set up watchers before re-reading the file when we invalidate it! This simplifies things, and means there's less stuff we need to track if you never start the watcher (i.e. `next build`).\n- Added a `--start-watching-late` option to the fuzzer to test calling `start_watching` after all the initial reads happen, to help validate the safety of the claim in the previous bullet point.\n\nMinor (aesthetic) changes:\n\n- Use past tense: `watching` is now `watched` and `ensure_watching` is now `ensure_watched`, as the `watched` list includes both currently active paths *and* previously watched but deleted paths.\n- Shorten the names of non-public types, because we have a lot more of them, and the names would get long otherwise\n\n## Benchmarking\n\nThis replaces a `DashSet<_>` with (essentially) a `RwLock<BTreeSet<_>>`. There's some risk of increased contention, particularly in the read-only fast-path for `ensure_watched`/`ensure_watching`.\n\nUnder the assumption that the most heavily lock-contended use-case for this code is after restoring from persistent cache on a large repository:\n\n1. Check out `vercel-site` in `front`.\n2. Hack the new tracing span onto the canary version.\n3. Build a release version with `pnpm pack-next --project ~/front/apps/vercel-site --no-js-build -- --release`\n4. `rm -rf .next`\n5. `NEXT_TURBOPACK_TRACING='turbo_tasks_fs' TURBO_ENGINE_IGNORE_DIRTY=1 pnpm next dev --turbopack`\n6. Load `http://localhost:3000/vercel`. Wait for it to fully finish loading. Stop the server with `ctrl+c`.\n7. Restart the server, wait for it to finish initializing, and then exit.\n8. Start the trace viewer: `pnpm next internal trace .next/trace-turbopack`, and look at the aggregated times of `ensure_watched`/`ensure_watching`.\n\nResults:\n\nbefore (canary): 313ms ensure_watching (2235x spans)\nafter (this pr): 279ms ensure_watched (2235x spans)\n\nSo no significant difference.",
    "sha": "0ad13118dda40eb1275ef00e0d3aabcf906eb2e7",
    "files": [
        {
            "sha": "65bbcd3672a02a7ec87b21b559074960bff8b9d0",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 13,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/0ad13118dda40eb1275ef00e0d3aabcf906eb2e7/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0ad13118dda40eb1275ef00e0d3aabcf906eb2e7/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=0ad13118dda40eb1275ef00e0d3aabcf906eb2e7",
            "patch": "@@ -261,11 +261,7 @@ impl DiskFileSystemInner {\n         let invalidator = turbo_tasks::get_invalidator();\n         self.invalidator_map\n             .insert(path.to_owned(), invalidator, None);\n-        if let Some(non_recursive) = &self.watcher.non_recursive_state\n-            && let Some(dir) = path.parent()\n-        {\n-            non_recursive.ensure_watching(&self.watcher, dir, self.root_path())?;\n-        }\n+        self.watcher.ensure_watched_file(path, self.root_path())?;\n         Ok(())\n     }\n \n@@ -291,11 +287,7 @@ impl DiskFileSystemInner {\n             .collect::<Vec<_>>();\n         invalidators.insert(invalidator, Some(write_content));\n         drop(invalidator_map);\n-        if let Some(non_recursive) = &self.watcher.non_recursive_state\n-            && let Some(dir) = path.parent()\n-        {\n-            non_recursive.ensure_watching(&self.watcher, dir, self.root_path())?;\n-        }\n+        self.watcher.ensure_watched_file(path, self.root_path())?;\n         Ok(old_invalidators)\n     }\n \n@@ -305,9 +297,7 @@ impl DiskFileSystemInner {\n         let invalidator = turbo_tasks::get_invalidator();\n         self.dir_invalidator_map\n             .insert(path.to_owned(), invalidator, None);\n-        if let Some(non_recursive) = &self.watcher.non_recursive_state {\n-            non_recursive.ensure_watching(&self.watcher, path, self.root_path())?;\n-        }\n+        self.watcher.ensure_watched_dir(path, self.root_path())?;\n         Ok(())\n     }\n "
        },
        {
            "sha": "647a20056b4e6fd3d7a6ff5d4785292413954286",
            "filename": "turbopack/crates/turbo-tasks-fs/src/path_map.rs",
            "status": "modified",
            "additions": 86,
            "deletions": 14,
            "changes": 100,
            "blob_url": "https://github.com/vercel/next.js/blob/0ad13118dda40eb1275ef00e0d3aabcf906eb2e7/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fpath_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0ad13118dda40eb1275ef00e0d3aabcf906eb2e7/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fpath_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fpath_map.rs?ref=0ad13118dda40eb1275ef00e0d3aabcf906eb2e7",
            "patch": "@@ -1,5 +1,5 @@\n use std::{\n-    collections::{BTreeMap, btree_map::CursorMut},\n+    collections::{BTreeMap, BTreeSet, btree_map, btree_set},\n     ops::Bound,\n     path::{Path, PathBuf},\n };\n@@ -9,24 +9,31 @@ use std::{\n ///\n /// In the future, this may use a more efficient representation, like a radix tree or trie.\n pub trait OrderedPathMapExt<V> {\n-    fn extract_path_with_children<'a>(&'a mut self, path: &'a Path) -> ExtractWithChildren<'a, V>;\n+    fn extract_path_with_children<'a>(\n+        &'a mut self,\n+        path: &'a Path,\n+    ) -> PathMapExtractPathWithChildren<'a, V>;\n }\n \n impl<V> OrderedPathMapExt<V> for BTreeMap<PathBuf, V> {\n-    fn extract_path_with_children<'a>(&'a mut self, path: &'a Path) -> ExtractWithChildren<'a, V> {\n-        ExtractWithChildren {\n+    /// Iterates over and removes `path` and all of its children.\n+    fn extract_path_with_children<'a>(\n+        &'a mut self,\n+        path: &'a Path,\n+    ) -> PathMapExtractPathWithChildren<'a, V> {\n+        PathMapExtractPathWithChildren {\n             cursor: self.lower_bound_mut(Bound::Included(path)),\n             parent_path: path,\n         }\n     }\n }\n \n-pub struct ExtractWithChildren<'a, V> {\n-    cursor: CursorMut<'a, PathBuf, V>,\n+pub struct PathMapExtractPathWithChildren<'a, V> {\n+    cursor: btree_map::CursorMut<'a, PathBuf, V>,\n     parent_path: &'a Path,\n }\n \n-impl<V> Iterator for ExtractWithChildren<'_, V> {\n+impl<V> Iterator for PathMapExtractPathWithChildren<'_, V> {\n     type Item = (PathBuf, V);\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -44,20 +51,61 @@ impl<V> Iterator for ExtractWithChildren<'_, V> {\n     }\n }\n \n+/// A thin wrapper around [`BTreeSet<PathBuf>`] that provides efficient iteration of child paths.\n+///\n+/// In the future, this may use a more efficient representation, like a radix tree or trie.\n+pub trait OrderedPathSetExt {\n+    /// Iterates over the children of `path`, excluding `path` itself.\n+    fn iter_path_children<'a>(&'a mut self, path: &'a Path) -> PathSetIterPathChildren<'a>;\n+}\n+\n+impl OrderedPathSetExt for BTreeSet<PathBuf> {\n+    fn iter_path_children<'a>(&'a mut self, path: &'a Path) -> PathSetIterPathChildren<'a> {\n+        PathSetIterPathChildren {\n+            // this is range written weirdly due to type inference limitations:\n+            // https://stackoverflow.com/a/66130898\n+            range: self.range::<Path, _>((Bound::Excluded(path), Bound::Unbounded)),\n+            parent_path: path,\n+        }\n+    }\n+}\n+\n+pub struct PathSetIterPathChildren<'a> {\n+    // we don't need the nightly cursors API for this, the `Range` type is sufficient.\n+    range: btree_set::Range<'a, PathBuf>,\n+    parent_path: &'a Path,\n+}\n+\n+impl<'a> Iterator for PathSetIterPathChildren<'a> {\n+    type Item = &'a Path;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        // this simple implementation works because `Path` implements `Ord` (and `starts_with`)\n+        // using path component comparision, rather than raw byte comparisions. The parent path is\n+        // always guaranteed to be placed immediately before its children (pre-order traversal).\n+        let current_path = self.range.next()?;\n+        if !current_path.starts_with(self.parent_path) {\n+            return None;\n+        }\n+        Some(&**current_path)\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n \n     #[test]\n-    fn test_extract_with_children() {\n+    fn test_map_extract_path_with_children() {\n         let mut map = BTreeMap::default();\n         map.insert(PathBuf::from(\"a\"), 1);\n         map.insert(PathBuf::from(\"a/b\"), 2);\n         map.insert(PathBuf::from(\"a/b/c\"), 3);\n         map.insert(PathBuf::from(\"a/b/d\"), 4);\n-        map.insert(PathBuf::from(\"a/c\"), 5);\n-        map.insert(PathBuf::from(\"x/y/z\"), 6);\n-        map.insert(PathBuf::from(\"z/a/b\"), 7);\n+        map.insert(PathBuf::from(\"a/b/d/e\"), 5);\n+        map.insert(PathBuf::from(\"a/c\"), 6);\n+        map.insert(PathBuf::from(\"x/y/z\"), 7);\n+        map.insert(PathBuf::from(\"z/a/b\"), 8);\n \n         let parent_path = PathBuf::from(\"a/b\");\n         let extracted: Vec<_> = map.extract_path_with_children(&parent_path).collect();\n@@ -66,15 +114,39 @@ mod tests {\n             (PathBuf::from(\"a/b\"), 2),\n             (PathBuf::from(\"a/b/c\"), 3),\n             (PathBuf::from(\"a/b/d\"), 4),\n+            (PathBuf::from(\"a/b/d/e\"), 5),\n         ];\n         assert_eq!(extracted, expected_extracted);\n \n         let mut expected_remaining = BTreeMap::new();\n         expected_remaining.insert(PathBuf::from(\"a\"), 1);\n-        expected_remaining.insert(PathBuf::from(\"a/c\"), 5);\n-        expected_remaining.insert(PathBuf::from(\"x/y/z\"), 6);\n-        expected_remaining.insert(PathBuf::from(\"z/a/b\"), 7);\n+        expected_remaining.insert(PathBuf::from(\"a/c\"), 6);\n+        expected_remaining.insert(PathBuf::from(\"x/y/z\"), 7);\n+        expected_remaining.insert(PathBuf::from(\"z/a/b\"), 8);\n \n         assert_eq!(map, expected_remaining);\n     }\n+\n+    #[test]\n+    fn test_set_iter_path_children() {\n+        let mut set = BTreeSet::default();\n+        set.insert(PathBuf::from(\"a\"));\n+        set.insert(PathBuf::from(\"a/b\"));\n+        set.insert(PathBuf::from(\"a/b/c\"));\n+        set.insert(PathBuf::from(\"a/b/d\"));\n+        set.insert(PathBuf::from(\"a/b/d/e\"));\n+        set.insert(PathBuf::from(\"a/c\"));\n+        set.insert(PathBuf::from(\"x/y/z\"));\n+        set.insert(PathBuf::from(\"z/a/b\"));\n+\n+        let parent_path = PathBuf::from(\"a/b\");\n+        let iterated: Vec<_> = set.iter_path_children(&parent_path).collect();\n+\n+        let expected_iterated = vec![\n+            PathBuf::from(\"a/b/c\"),\n+            PathBuf::from(\"a/b/d\"),\n+            PathBuf::from(\"a/b/d/e\"),\n+        ];\n+        assert_eq!(iterated, expected_iterated);\n+    }\n }"
        },
        {
            "sha": "d9031814905b21978c33db179fc6d5fa2f7c093d",
            "filename": "turbopack/crates/turbo-tasks-fs/src/watcher.rs",
            "status": "modified",
            "additions": 244,
            "deletions": 121,
            "changes": 365,
            "blob_url": "https://github.com/vercel/next.js/blob/0ad13118dda40eb1275ef00e0d3aabcf906eb2e7/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0ad13118dda40eb1275ef00e0d3aabcf906eb2e7/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs?ref=0ad13118dda40eb1275ef00e0d3aabcf906eb2e7",
            "patch": "@@ -1,17 +1,17 @@\n use std::{\n     any::Any,\n+    collections::BTreeSet,\n     env, fmt,\n     mem::take,\n     path::{Path, PathBuf},\n     sync::{\n-        Arc, LazyLock, Mutex,\n+        Arc, LazyLock, RwLock, RwLockWriteGuard,\n         mpsc::{Receiver, TryRecvError, channel},\n     },\n     time::Duration,\n };\n \n use anyhow::{Context, Result};\n-use dashmap::DashSet;\n use notify::{\n     Config, EventKind, PollWatcher, RecommendedWatcher, RecursiveMode, Watcher,\n     event::{MetadataKind, ModifyKind, RenameMode},\n@@ -61,145 +61,207 @@ static WATCH_RECURSIVE_MODE: LazyLock<RecursiveMode> = LazyLock::new(|| {\n     }\n });\n \n-/// A thin wrapper around [`RecommendedWatcher`] and [`PollWatcher`].\n-enum DiskWatcherInternal {\n-    Recommended(RecommendedWatcher),\n-    Polling(PollWatcher),\n+#[derive(Serialize, Deserialize)]\n+pub(crate) struct DiskWatcher {\n+    #[serde(skip, default = \"State::new_stopped\")]\n+    state: State,\n }\n \n-impl DiskWatcherInternal {\n-    fn watch(&mut self, path: &Path, recursive_mode: RecursiveMode) -> notify::Result<()> {\n+enum State {\n+    // Note: Information about if we're a recursive or non-recursive watcher must live outside the\n+    // `RwLock` to allow us to quickly bail out on calls to `ensure_watched`.\n+    Recursive(RwLock<RecursiveState>),\n+    NonRecursive(RwLock<NonRecursiveState>),\n+}\n+\n+enum StateWriteGuard<'a> {\n+    Recursive(RwLockWriteGuard<'a, RecursiveState>),\n+    NonRecursive(RwLockWriteGuard<'a, NonRecursiveState>),\n+}\n+\n+impl State {\n+    fn new_stopped() -> Self {\n+        match *WATCH_RECURSIVE_MODE {\n+            RecursiveMode::Recursive => Self::Recursive(RwLock::new(RecursiveState::Stopped)),\n+            RecursiveMode::NonRecursive => {\n+                Self::NonRecursive(RwLock::new(NonRecursiveState::Stopped))\n+            }\n+        }\n+    }\n+\n+    fn write(&self) -> StateWriteGuard<'_> {\n         match self {\n-            DiskWatcherInternal::Recommended(watcher) => watcher.watch(path, recursive_mode),\n-            DiskWatcherInternal::Polling(watcher) => watcher.watch(path, recursive_mode),\n+            Self::Recursive(state) => StateWriteGuard::Recursive(state.write().unwrap()),\n+            Self::NonRecursive(state) => StateWriteGuard::NonRecursive(state.write().unwrap()),\n         }\n     }\n }\n \n-#[derive(Serialize, Deserialize)]\n-pub(crate) struct DiskWatcher {\n-    /// This value is [`None`] when the watcher has been stopped (see\n-    /// [`DiskWatcher::stop_watching`]).\n-    #[serde(skip)]\n-    internal: Mutex<Option<DiskWatcherInternal>>,\n-\n-    #[serde(skip, default = \"NonRecursiveDiskWatcherState::try_new\")]\n-    pub(crate) non_recursive_state: Option<NonRecursiveDiskWatcherState>,\n+/// Used by when [`WATCH_RECURSIVE_MODE`] is [`RecursiveMode::Recursive`] (default on macOS and\n+/// Windows).\n+enum RecursiveState {\n+    /// Used when [`DiskWatcher::start_watching`] hasn't been called yet or after\n+    /// [`DiskWatcher::stop_watching`] is called.\n+    Stopped,\n+    Watching {\n+        /// Hold onto the watcher: When this is dropped, it will cause the channel to disconnect\n+        _notify_watcher: NotifyWatcher,\n+    },\n }\n \n-impl Default for DiskWatcher {\n-    fn default() -> Self {\n-        Self {\n-            internal: Mutex::new(None),\n-            non_recursive_state: NonRecursiveDiskWatcherState::try_new(),\n-        }\n-    }\n+/// Used by when [`WATCH_RECURSIVE_MODE`] is [`RecursiveMode::NonRecursive`] (default on Linux).\n+enum NonRecursiveState {\n+    /// Used when [`DiskWatcher::start_watching`] hasn't been called yet or after\n+    /// [`DiskWatcher::stop_watching`] is called.\n+    Stopped,\n+    Watching(NonRecursiveWatchingState),\n }\n \n-/// Extra state used by [`DiskWatcher`] when [`WATCH_RECURSIVE_MODE`] is\n-/// [`RecursiveMode::NonRecursive`] (default on Linux).\n-pub(crate) struct NonRecursiveDiskWatcherState {\n-    /// Keeps track of which directories are currently (or were previously) watched.\n+// split out from the `NonRecursiveState` enum because we want to pass this value around\n+struct NonRecursiveWatchingState {\n+    notify_watcher: NotifyWatcher,\n+    /// Keeps track of which directories are currently or were previously watched by\n+    /// [`Self::notify_watcher`].\n     ///\n     /// Invariants:\n     /// - Never contains `root_path`. A watcher for `root_path` is implicitly set up during\n     ///   [`DiskWatcher::start_watching`].\n     /// - Contains all parent directories up to `root_path` for every entry.\n-    watching: DashSet<PathBuf>,\n+    watched: BTreeSet<PathBuf>,\n }\n \n-impl NonRecursiveDiskWatcherState {\n-    fn try_new() -> Option<NonRecursiveDiskWatcherState> {\n-        match *WATCH_RECURSIVE_MODE {\n-            RecursiveMode::Recursive => None,\n-            RecursiveMode::NonRecursive => Some(NonRecursiveDiskWatcherState {\n-                watching: DashSet::new(),\n-            }),\n+/// A thin wrapper around [`RecommendedWatcher`] and [`PollWatcher`].\n+enum NotifyWatcher {\n+    Recommended(RecommendedWatcher),\n+    Polling(PollWatcher),\n+}\n+\n+impl NotifyWatcher {\n+    fn watch(&mut self, path: &Path, recursive_mode: RecursiveMode) -> notify::Result<()> {\n+        match self {\n+            Self::Recommended(watcher) => watcher.watch(path, recursive_mode),\n+            Self::Polling(watcher) => watcher.watch(path, recursive_mode),\n         }\n     }\n+}\n+\n+mod non_recursive_helpers {\n+    use super::*;\n+    use crate::path_map::OrderedPathSetExt;\n \n     /// Called after a rescan in case a previously watched-but-deleted directory was recreated.\n-    pub(crate) fn restore_all_watching(&self, watcher: &DiskWatcher, root_path: &Path) {\n-        let mut internal_guard = watcher.internal.lock().unwrap();\n-        let Some(internal) = &mut *internal_guard else {\n+    #[instrument(skip_all, level = \"trace\")]\n+    pub fn restore_all_watched_ignore_errors(state: &RwLock<NonRecursiveState>, root_path: &Path) {\n+        let mut guard = state.write().unwrap();\n+        let NonRecursiveState::Watching(watching_state) = &mut *guard else {\n             return;\n         };\n-        for dir_path in self.watching.iter() {\n+        for dir_path in watching_state.watched.iter() {\n             // TODO: Report diagnostics if this error happens\n             //\n-            // Don't watch the parents, because those are already included in `self.watching` (so\n+            // Don't watch the parents, because those are already included in `self.watched` (so\n             // it'd be redundant), but also because this could deadlock, since we'd try to modify\n-            // `self.watching` while iterating over it (write lock overlapping with a read lock).\n-            let _ = self.start_watching_dir(internal, &dir_path, root_path);\n+            // `self.watched` while iterating over it (write lock overlapping with a read lock).\n+            let _ = start_watching_dir(&mut watching_state.notify_watcher, dir_path, root_path);\n         }\n     }\n \n     /// Called when a new directory is found in a parent directory we're watching. Restores the\n     /// watcher if we were previously watching it.\n-    pub(crate) fn restore_if_watching(\n-        &self,\n-        watcher: &DiskWatcher,\n+    #[instrument(skip_all, level = \"trace\")]\n+    pub fn restore_if_watched(\n+        state: &RwLock<NonRecursiveState>,\n         dir_path: &Path,\n         root_path: &Path,\n     ) -> Result<()> {\n-        if dir_path == root_path || !self.watching.contains(dir_path) {\n+        // fast path: The root directory is always implicitly watched during\n+        // `DiskWatcher::start_watching`, we assume it is never deleted and never needs to be\n+        // restored.\n+        if dir_path == root_path {\n             return Ok(());\n         }\n-        let mut internal_guard = watcher.internal.lock().unwrap();\n-        let Some(internal) = &mut *internal_guard else {\n+\n+        // fast path: the directory isn't in `watched`, only take a read lock and bail out early\n+        {\n+            let guard = state.read().unwrap();\n+            let NonRecursiveState::Watching(watching_state) = &*guard else {\n+                return Ok(());\n+            };\n+            if !watching_state.watched.contains(dir_path) {\n+                return Ok(());\n+            }\n+        }\n+\n+        // slow path: re-watch the path\n+        let mut guard = state.write().unwrap();\n+        let NonRecursiveState::Watching(watching_state) = &mut *guard else {\n             return Ok(());\n         };\n \n         // watch the new directory\n-        self.start_watching_dir(internal, dir_path, root_path)?;\n+        start_watching_dir(&mut watching_state.notify_watcher, dir_path, root_path)?;\n \n         // Also try to restore any watchers for children of this directory\n-        for child_path in self\n-            .watching\n-            .iter()\n-            .filter(|p| p.key().starts_with(dir_path) && **p != dir_path)\n-        {\n-            // Don't watch the parents -- see the comment on `restore_all_watching`\n-            self.start_watching_dir(internal, child_path.key(), root_path)?;\n+        for child_path in watching_state.watched.iter_path_children(dir_path) {\n+            // Don't watch the parents -- see the comment on `restore_all_watched`\n+            start_watching_dir(&mut watching_state.notify_watcher, child_path, root_path)?;\n         }\n         Ok(())\n     }\n \n     /// Called when a file in `dir_path` or `dir_path` itself is read or written. Adds a new watcher\n     /// if we're not already watching the directory.\n-    pub(crate) fn ensure_watching(\n-        &self,\n-        watcher: &DiskWatcher,\n+    ///\n+    /// This should be called *before* reading a file to avoid a race condition.\n+    #[instrument(skip_all, level = \"trace\")]\n+    pub fn ensure_watched(\n+        state: &RwLock<NonRecursiveState>,\n         dir_path: &Path,\n         root_path: &Path,\n     ) -> Result<()> {\n-        if dir_path == root_path || self.watching.contains(dir_path) {\n+        // fast path: The root directory is always implicitly watched during\n+        // `DiskWatcher::start_watching`.\n+        if dir_path == root_path {\n             return Ok(());\n         }\n-        let mut internal_guard = watcher.internal.lock().unwrap();\n-        let Some(internal) = &mut *internal_guard else {\n+\n+        // fast path: the directory is already in `watched`, only take a read lock and bail out\n+        // early\n+        {\n+            let guard = state.read().unwrap();\n+            let NonRecursiveState::Watching(watching_state) = &*guard else {\n+                return Ok(());\n+            };\n+            if watching_state.watched.contains(dir_path) {\n+                return Ok(());\n+            }\n+        }\n+\n+        // slow path: watch the path\n+        let mut guard = state.write().unwrap();\n+        let NonRecursiveState::Watching(watching_state) = &mut *guard else {\n             return Ok(());\n         };\n-        if self.watching.insert(dir_path.to_path_buf()) {\n-            self.start_watching_dir_and_parents(internal, dir_path, root_path)?;\n+        if watching_state.watched.insert(dir_path.to_path_buf()) {\n+            start_watching_dir_and_parents(watching_state, dir_path, root_path)?;\n         }\n         Ok(())\n     }\n \n-    /// Private helper, assumes that `dir_path` has already been added to `self.watching`.\n+    /// Private helper, assumes that `dir_path` has already been added to\n+    /// [`NonRecursiveWatchingState::watched`].\n     ///\n     /// This does not watch any of the parent directories. For that, use\n     /// [`start_watching_dir_and_parents`]. Use this method when iterating over previously-watched\n     /// values in `self.watching`.\n     fn start_watching_dir(\n-        &self,\n-        watcher_internal: &mut DiskWatcherInternal,\n+        notify_watcher: &mut NotifyWatcher,\n         dir_path: &Path,\n         root_path: &Path,\n     ) -> Result<()> {\n         debug_assert_ne!(dir_path, root_path);\n \n-        match watcher_internal.watch(dir_path, RecursiveMode::NonRecursive) {\n+        match notify_watcher.watch(dir_path, RecursiveMode::NonRecursive) {\n             Ok(())\n             | Err(notify::Error {\n                 // The path was probably deleted before we could process the event, but the parent\n@@ -214,20 +276,20 @@ impl NonRecursiveDiskWatcherState {\n         }\n     }\n \n-    /// Private helper, assumes that `dir_path` has already been added to `self.watching`.\n+    /// Private helper, assumes that `dir_path` has already been added to\n+    /// [`NonRecursiveWatchingState::watched`].\n     ///\n     /// Watches the given `dir_path` and every parent up to `root_path`. Parents must be recursively\n     /// watched in case any of them change:\n     /// https://docs.rs/notify/latest/notify/#parent-folder-deletion\n     fn start_watching_dir_and_parents(\n-        &self,\n-        watcher_internal: &mut DiskWatcherInternal,\n+        state: &mut NonRecursiveWatchingState,\n         dir_path: &Path,\n         root_path: &Path,\n     ) -> Result<()> {\n         let mut cur_path = dir_path;\n         loop {\n-            self.start_watching_dir(watcher_internal, cur_path, root_path)?;\n+            start_watching_dir(&mut state.notify_watcher, cur_path, root_path)?;\n \n             let Some(parent_path) = cur_path.parent() else {\n                 // this should never happen as we break before we reach the root path\n@@ -237,7 +299,7 @@ impl NonRecursiveDiskWatcherState {\n                 );\n             };\n \n-            if parent_path == root_path || !self.watching.insert(parent_path.to_path_buf()) {\n+            if parent_path == root_path || !state.watched.insert(parent_path.to_path_buf()) {\n                 break;\n             }\n \n@@ -249,8 +311,10 @@ impl NonRecursiveDiskWatcherState {\n }\n \n impl DiskWatcher {\n-    pub(crate) fn new() -> Self {\n-        Default::default()\n+    pub fn new() -> Self {\n+        Self {\n+            state: State::new_stopped(),\n+        }\n     }\n \n     /// Create a watcher and start watching by creating `debounced` watcher\n@@ -268,14 +332,22 @@ impl DiskWatcher {\n     /// - Emits only one Remove event when deleting a directory (inotify)\n     /// - Doesn't emit duplicate create events\n     /// - Doesn't emit Modify events after a Create event\n-    pub(crate) fn start_watching(\n+    pub fn start_watching(\n         &self,\n         fs_inner: Arc<DiskFileSystemInner>,\n         report_invalidation_reason: bool,\n         poll_interval: Option<Duration>,\n     ) -> Result<()> {\n-        let mut internal_guard = self.internal.lock().unwrap();\n-        if internal_guard.is_some() {\n+        let state_guard = self.state.write();\n+\n+        // bail out if we're already watching\n+        if let StateWriteGuard::Recursive(guard) = &state_guard\n+            && matches!(**guard, RecursiveState::Watching { .. })\n+        {\n+            return Ok(());\n+        } else if let StateWriteGuard::NonRecursive(guard) = &state_guard\n+            && matches!(**guard, NonRecursiveState::Watching(..))\n+        {\n             return Ok(());\n         }\n \n@@ -284,27 +356,29 @@ impl DiskWatcher {\n         // Create a watcher object, delivering debounced events.\n         // The notification back-end is selected based on the platform.\n         let config = Config::default();\n-        // we should track and invalidate each part of a symlink chain ourselves in turbo-tasks-fs\n+        // we should track and invalidate each part of a symlink chain ourselves in\n+        // turbo-tasks-fs\n         config.with_follow_symlinks(false);\n \n-        let mut internal = if let Some(poll_interval) = poll_interval {\n+        let mut notify_watcher = if let Some(poll_interval) = poll_interval {\n             let config = config.with_poll_interval(poll_interval);\n-\n-            DiskWatcherInternal::Polling(PollWatcher::new(tx, config)?)\n+            NotifyWatcher::Polling(PollWatcher::new(tx, config)?)\n         } else {\n-            DiskWatcherInternal::Recommended(RecommendedWatcher::new(tx, Config::default())?)\n+            NotifyWatcher::Recommended(RecommendedWatcher::new(tx, Config::default())?)\n         };\n \n-        if let Some(non_recursive) = &self.non_recursive_state {\n-            internal.watch(fs_inner.root_path(), RecursiveMode::NonRecursive)?;\n-            for dir_path in non_recursive.watching.iter() {\n-                internal.watch(&dir_path, RecursiveMode::NonRecursive)?;\n-            }\n-        } else {\n-            internal.watch(fs_inner.root_path(), RecursiveMode::Recursive)?;\n-        }\n+        // TOCTOU: we must watch `root_path` before calling any invalidators and setting up the\n+        // watchers in their associated functions\n+        let root_path = fs_inner.root_path();\n+        let recursive_mode = match state_guard {\n+            StateWriteGuard::Recursive(_) => RecursiveMode::Recursive,\n+            StateWriteGuard::NonRecursive(_) => RecursiveMode::NonRecursive,\n+        };\n+        notify_watcher.watch(root_path, recursive_mode)?;\n \n-        // We need to invalidate all reads that happened before watching\n+        // We need to invalidate all reads or writes that happened before watching. As a\n+        // side-effect, this will call `ensure_watched` again, setting up any watchers needed.\n+        //\n         // Best is to start_watching before starting to read\n         {\n             let span = tracing::info_span!(\"invalidate filesystem\");\n@@ -345,24 +419,39 @@ impl DiskWatcher {\n             }\n         }\n \n-        internal_guard.replace(internal);\n-        drop(internal_guard);\n-\n         spawn_thread(move || {\n             fs_inner\n                 .clone()\n                 .watcher\n                 .watch_thread(rx, fs_inner, report_invalidation_reason)\n         });\n \n+        // Updating `self.state` is done last. If we panic while setting up the watcher, it'll\n+        // stay in the `Stopped` state.\n+        match state_guard {\n+            StateWriteGuard::Recursive(mut recursive) => {\n+                *recursive = RecursiveState::Watching {\n+                    _notify_watcher: notify_watcher,\n+                }\n+            }\n+            StateWriteGuard::NonRecursive(mut non_recursive) => {\n+                *non_recursive = NonRecursiveState::Watching(NonRecursiveWatchingState {\n+                    notify_watcher,\n+                    watched: BTreeSet::new(),\n+                })\n+            }\n+        };\n+\n         Ok(())\n     }\n \n-    pub(crate) fn stop_watching(&self) {\n-        if let Some(watcher) = self.internal.lock().unwrap().take() {\n-            drop(watcher);\n-            // thread will detect the stop because the channel is disconnected\n+    pub fn stop_watching(&self) {\n+        match &self.state {\n+            State::Recursive(state) => *state.write().unwrap() = RecursiveState::Stopped,\n+            State::NonRecursive(state) => *state.write().unwrap() = NonRecursiveState::Stopped,\n         }\n+        // thread will detect the stop because the channel is disconnected when `NotifyWatcher` is\n+        // dropped\n     }\n \n     /// Internal thread that processes the events from the watcher\n@@ -372,15 +461,15 @@ impl DiskWatcher {\n     fn watch_thread(\n         &self,\n         rx: Receiver<notify::Result<notify::Event>>,\n-        inner: Arc<DiskFileSystemInner>,\n+        fs_inner: Arc<DiskFileSystemInner>,\n         report_invalidation_reason: bool,\n     ) {\n         let mut batched_invalidate_path = FxHashSet::default();\n         let mut batched_invalidate_path_dir = FxHashSet::default();\n         let mut batched_invalidate_path_and_children = FxHashSet::default();\n         let mut batched_invalidate_path_and_children_dir = FxHashSet::default();\n \n-        let mut batched_new_paths = if self.non_recursive_state.is_some() {\n+        let mut batched_new_paths = if let State::NonRecursive(_) = self.state {\n             Some(FxHashSet::default())\n         } else {\n             None\n@@ -402,25 +491,30 @@ impl DiskWatcher {\n                         // echo 3 | sudo tee /proc/sys/fs/inotify/max_queued_events\n                         // ```\n                         if event.need_rescan() {\n-                            let _lock = inner.invalidation_lock.blocking_write();\n+                            let _lock = fs_inner.invalidation_lock.blocking_write();\n \n-                            if let Some(non_recursive) = &self.non_recursive_state {\n+                            if let State::NonRecursive(non_recursive) = &self.state {\n                                 // we can't narrow this down to a smaller set of paths: Rescan\n                                 // events (at least when tested on Linux) come with no `paths`, and\n                                 // we use only one global `notify::Watcher` instance.\n-                                non_recursive.restore_all_watching(self, inner.root_path());\n+                                //\n+                                // TODO: Report diagnostics if an error happens\n+                                non_recursive_helpers::restore_all_watched_ignore_errors(\n+                                    non_recursive,\n+                                    fs_inner.root_path(),\n+                                );\n                                 if let Some(batched_new_paths) = &mut batched_new_paths {\n                                     batched_new_paths.clear();\n                                 }\n                             }\n \n                             if report_invalidation_reason {\n-                                inner.invalidate_with_reason(|path| InvalidateRescan {\n+                                fs_inner.invalidate_with_reason(|path| InvalidateRescan {\n                                     // this path is just used for display purposes\n                                     path: RcStr::from(path.to_string_lossy()),\n                                 });\n                             } else {\n-                                inner.invalidate();\n+                                fs_inner.invalidate();\n                             }\n \n                             // no need to process the rest of the batch as we just\n@@ -537,9 +631,9 @@ impl DiskWatcher {\n \n                         if paths.is_empty() {\n                             batched_invalidate_path_and_children\n-                                .insert(inner.root_path().to_path_buf());\n+                                .insert(fs_inner.root_path().to_path_buf());\n                             batched_invalidate_path_and_children_dir\n-                                .insert(inner.root_path().to_path_buf());\n+                                .insert(fs_inner.root_path().to_path_buf());\n                         } else {\n                             batched_invalidate_path_and_children.extend(paths.clone());\n                             batched_invalidate_path_and_children_dir.extend(paths.clone());\n@@ -572,49 +666,78 @@ impl DiskWatcher {\n \n             // We need to start watching first before invalidating the changed paths...\n             // This is only needed on platforms we don't do recursive watching on.\n-            if let Some(non_recursive) = &self.non_recursive_state {\n+            if let State::NonRecursive(non_recursive) = &self.state {\n                 for path in batched_new_paths.as_mut().unwrap().drain() {\n                     // TODO: Report diagnostics if this error happens\n-                    let _ = non_recursive.restore_if_watching(self, &path, inner.root_path());\n+                    let _ = non_recursive_helpers::restore_if_watched(\n+                        non_recursive,\n+                        &path,\n+                        fs_inner.root_path(),\n+                    );\n                 }\n             }\n \n-            let _lock = inner.invalidation_lock.blocking_write();\n+            let _lock = fs_inner.invalidation_lock.blocking_write();\n             {\n-                let mut invalidator_map = inner.invalidator_map.lock().unwrap();\n+                let mut invalidator_map = fs_inner.invalidator_map.lock().unwrap();\n                 invalidate_path(\n-                    &inner,\n+                    &fs_inner,\n                     report_invalidation_reason,\n                     &mut invalidator_map,\n                     batched_invalidate_path.drain(),\n                 );\n                 invalidate_path_and_children_execute(\n-                    &inner,\n+                    &fs_inner,\n                     report_invalidation_reason,\n                     &mut invalidator_map,\n                     batched_invalidate_path_and_children.drain(),\n                 );\n             }\n             {\n-                let mut dir_invalidator_map = inner.dir_invalidator_map.lock().unwrap();\n+                let mut dir_invalidator_map = fs_inner.dir_invalidator_map.lock().unwrap();\n                 invalidate_path(\n-                    &inner,\n+                    &fs_inner,\n                     report_invalidation_reason,\n                     &mut dir_invalidator_map,\n                     batched_invalidate_path_dir.drain(),\n                 );\n                 invalidate_path_and_children_execute(\n-                    &inner,\n+                    &fs_inner,\n                     report_invalidation_reason,\n                     &mut dir_invalidator_map,\n                     batched_invalidate_path_and_children_dir.drain(),\n                 );\n             }\n         }\n     }\n+\n+    pub fn ensure_watched_file(&self, path: &Path, root_path: &Path) -> Result<()> {\n+        // Watch the parent directory instead of the specified file, since directories also track\n+        // their immediate children (even in non-recursive mode), and we need to watch all the\n+        // parents anyways.\n+        if let State::NonRecursive(non_recursive) = &self.state\n+            && let Some(dir_path) = path.parent()\n+        {\n+            non_recursive_helpers::ensure_watched(non_recursive, dir_path, root_path)?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn ensure_watched_dir(&self, dir_path: &Path, root_path: &Path) -> Result<()> {\n+        if let State::NonRecursive(non_recursive) = &self.state {\n+            non_recursive_helpers::ensure_watched(non_recursive, dir_path, root_path)?;\n+        }\n+        Ok(())\n+    }\n }\n \n-#[instrument(parent = None, level = \"info\", name = \"DiskFileSystem file change\", skip_all, fields(name = display(path.display())))]\n+#[instrument(\n+    parent = None,\n+    level = \"info\",\n+    name = \"DiskFileSystem file change\",\n+    skip_all,\n+    fields(name = %path.display())\n+)]\n fn invalidate(\n     inner: &DiskFileSystemInner,\n     report_invalidation_reason: bool,"
        },
        {
            "sha": "f5610a47e05d4b738eadff89503095f2e6dc038a",
            "filename": "turbopack/crates/turbo-tasks-fuzz/src/main.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/0ad13118dda40eb1275ef00e0d3aabcf906eb2e7/turbopack%2Fcrates%2Fturbo-tasks-fuzz%2Fsrc%2Fmain.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0ad13118dda40eb1275ef00e0d3aabcf906eb2e7/turbopack%2Fcrates%2Fturbo-tasks-fuzz%2Fsrc%2Fmain.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fuzz%2Fsrc%2Fmain.rs?ref=0ad13118dda40eb1275ef00e0d3aabcf906eb2e7",
            "patch": "@@ -52,6 +52,9 @@ struct FsWatcher {\n     directory_modifications: u32,\n     #[arg(long)]\n     print_missing_invalidations: bool,\n+    /// Call `start_watching` after the initial read of files instead of before (the default).\n+    #[arg(long)]\n+    start_watching_late: bool,\n }\n \n #[tokio::main]\n@@ -91,7 +94,9 @@ async fn fuzz_fs_watcher(args: FsWatcher) -> anyhow::Result<()> {\n             .await?;\n         create_directory_tree(&mut FxHashSet::default(), &fs_root, args.depth, args.width)?;\n \n-        project_fs.await?.start_watching(None).await?;\n+        if !args.start_watching_late {\n+            project_fs.await?.start_watching(None).await?;\n+        }\n \n         let read_all_paths_op =\n             read_all_paths_operation(invalidations.clone(), project_root, args.depth, args.width);\n@@ -102,6 +107,10 @@ async fn fuzz_fs_watcher(args: FsWatcher) -> anyhow::Result<()> {\n             invalidations.clear();\n         }\n \n+        if args.start_watching_late {\n+            project_fs.await?.start_watching(None).await?;\n+        }\n+\n         let mut rand_buf = [0; 16];\n         let mut rng = rand::rngs::SmallRng::from_rng(&mut rand::rng());\n         loop {"
        }
    ],
    "stats": {
        "total": 492,
        "additions": 343,
        "deletions": 149
    }
}