{
    "author": "bgw",
    "message": "refactor(turbopack): Rewrite `EsRegex::captures` to return an iterator, use `None` for unmatched capture groups (#81200)\n\nThis is a follow-up to #81119.\n\n- Make each returned capture use `Option` and return `None` if the capture doesn't match instead of an empty string. There is a meaningful difference between a capture not matching at all or a zero-width capture.\n- Return an iterator instead of a `Vec`. Some lifetime issues with both `regex` and `regress` pushed me to make this a manual iterator implementation (versus using `Either`), but the upside is that the type is now named!",
    "sha": "203adbd5d054609812d1f3666184875dcca13f3a",
    "files": [
        {
            "sha": "2e322dd2a728ff636907b7bf13fcba1043ff064a",
            "filename": "turbopack/crates/turbo-esregex/src/lib.rs",
            "status": "modified",
            "additions": 92,
            "deletions": 23,
            "changes": 115,
            "blob_url": "https://github.com/vercel/next.js/blob/203adbd5d054609812d1f3666184875dcca13f3a/turbopack%2Fcrates%2Fturbo-esregex%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/203adbd5d054609812d1f3666184875dcca13f3a/turbopack%2Fcrates%2Fturbo-esregex%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-esregex%2Fsrc%2Flib.rs?ref=203adbd5d054609812d1f3666184875dcca13f3a",
            "patch": "@@ -1,5 +1,7 @@\n #![feature(arbitrary_self_types_pointers)]\n \n+use std::vec;\n+\n use anyhow::{Result, bail};\n \n pub fn register() {\n@@ -116,26 +118,92 @@ impl EsRegex {\n         })\n     }\n \n-    /// Returns true if there is any match for this regex in the `haystac`\n+    /// Returns true if there is any match for this regex in the `haystack`.\n     pub fn is_match(&self, haystack: &str) -> bool {\n         match &self.delegate {\n             EsRegexImpl::Regex(r) => r.is_match(haystack),\n             EsRegexImpl::Regress(r) => r.find(haystack).is_some(),\n         }\n     }\n \n-    pub fn captures<'h>(&self, haystack: &'h str) -> Option<Vec<&'h str>> {\n-        match &self.delegate {\n-            EsRegexImpl::Regex(r) => r.captures(haystack).map(|caps| {\n-                caps.iter()\n-                    .map(|m| m.map(|m| m.as_str()).unwrap_or(\"\"))\n-                    .collect::<Vec<_>>()\n-            }),\n-            EsRegexImpl::Regress(r) => r.find(haystack).map(|m| {\n-                m.groups()\n-                    .map(|range_opt| range_opt.map(|range| &haystack[range]).unwrap_or(\"\"))\n-                    .collect::<Vec<_>>()\n-            }),\n+    /// Searches for the first match of the regex in the `haystack`, and iterates over the capture\n+    /// groups within that first match.\n+    ///\n+    /// `None` is returned if there is no match. Individual capture groups may be `None` if the\n+    /// capture group wasn't included in the match.\n+    ///\n+    /// The first capture group is always present ([`Some`]) and represents the entire match.\n+    ///\n+    /// Capture groups are represented as string slices of the `haystack`, and live for the lifetime\n+    /// of `haystack`.\n+    pub fn captures<'h>(&self, haystack: &'h str) -> Option<Captures<'h>> {\n+        let delegate = match &self.delegate {\n+            EsRegexImpl::Regex(r) => CapturesImpl::Regex {\n+                captures: r.captures(haystack)?,\n+                idx: 0,\n+            },\n+            EsRegexImpl::Regress(r) => {\n+                let re_match = r.find(haystack)?;\n+                CapturesImpl::Regress {\n+                    captures_iter: re_match.captures.into_iter(),\n+                    haystack,\n+                    match_range: Some(re_match.range),\n+                }\n+            }\n+        };\n+        Some(Captures { delegate })\n+    }\n+}\n+\n+pub struct Captures<'h> {\n+    delegate: CapturesImpl<'h>,\n+}\n+\n+enum CapturesImpl<'h> {\n+    // We have to use `regex::Captures` (which is not an iterator) here instead of\n+    // `regex::SubCaptureMatches` (an iterator) because `SubCaptureMatches` must have a reference\n+    // to `Capture`, and that would require a self-referential struct.\n+    //\n+    // Ideally, `regex::Capture` would implement `IntoIterator`, and we could use that here\n+    // instead.\n+    Regex {\n+        captures: regex::Captures<'h>,\n+        idx: usize,\n+    },\n+    // We can't use the iterator from `regress::Match::groups()` due to similar lifetime issues.\n+    Regress {\n+        captures_iter: vec::IntoIter<Option<regress::Range>>,\n+        haystack: &'h str,\n+        match_range: Option<regress::Range>,\n+    },\n+}\n+\n+impl<'h> Iterator for Captures<'h> {\n+    type Item = Option<&'h str>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match &mut self.delegate {\n+            CapturesImpl::Regex { captures, idx } => {\n+                if *idx >= captures.len() {\n+                    None\n+                } else {\n+                    let capture = Some(captures.get(*idx).map(|sub_match| sub_match.as_str()));\n+                    *idx += 1;\n+                    capture\n+                }\n+            }\n+            CapturesImpl::Regress {\n+                captures_iter,\n+                haystack,\n+                match_range,\n+            } => {\n+                if let Some(range) = match_range.take() {\n+                    // always yield range first\n+                    Some(Some(&haystack[range]))\n+                } else {\n+                    Some(captures_iter.next()?.map(|range| &haystack[range]))\n+                }\n+            }\n         }\n     }\n }\n@@ -178,17 +246,18 @@ mod tests {\n \n     #[test]\n     fn captures_with_regex() {\n-        let regex = EsRegex::new(r\"(\\d{4})-(\\d{2})-(\\d{2})\", \"\").unwrap();\n+        let regex = EsRegex::new(r\"(notmatched)|(\\d{4})-(\\d{2})-(\\d{2})\", \"\").unwrap();\n         assert!(matches!(regex.delegate, EsRegexImpl::Regex { .. }));\n \n         let captures = regex.captures(\"Today is 2024-01-15\");\n         assert!(captures.is_some());\n-        let caps: Vec<&str> = captures.unwrap();\n-        assert_eq!(caps.len(), 4); // full match + 3 groups\n-        assert_eq!(caps[0], \"2024-01-15\"); // full match\n-        assert_eq!(caps[1], \"2024\"); // year\n-        assert_eq!(caps[2], \"01\"); // month\n-        assert_eq!(caps[3], \"15\"); // day\n+        let caps: Vec<_> = captures.unwrap().collect();\n+        assert_eq!(caps.len(), 5); // full match + 4 groups\n+        assert_eq!(caps[0], Some(\"2024-01-15\")); // full match\n+        assert_eq!(caps[1], None); // 'notmatched' -- this branch isn't taken\n+        assert_eq!(caps[2], Some(\"2024\")); // year\n+        assert_eq!(caps[3], Some(\"01\")); // month\n+        assert_eq!(caps[4], Some(\"15\")); // day\n     }\n \n     #[test]\n@@ -201,9 +270,9 @@ mod tests {\n \n         let captures = regex.captures(\"foobaz\");\n         assert!(captures.is_some());\n-        let caps: Vec<&str> = captures.unwrap();\n+        let caps: Vec<_> = captures.unwrap().collect();\n         assert_eq!(caps.len(), 2); // full match + 1 group\n-        assert_eq!(caps[0], \"foo\"); // full match\n-        assert_eq!(caps[1], \"foo\"); // captured group\n+        assert_eq!(caps[0], Some(\"foo\")); // full match\n+        assert_eq!(caps[1], Some(\"foo\")); // captured group\n     }\n }"
        }
    ],
    "stats": {
        "total": 115,
        "additions": 92,
        "deletions": 23
    }
}