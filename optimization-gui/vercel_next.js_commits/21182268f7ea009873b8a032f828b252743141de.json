{
    "author": "lukesandberg",
    "message": "[turbopack] Reduce the size of module graph datastructures (#79706)\n\n## Refactor module graph to reduce memory usage\n\n### What?\nThis PR refactors the module graph implementation to reduce memory usage by:\n1. Changing `graph_idx` from `usize` to `u32` to reduce memory footprint\n2. Removing unused fields from `SingleModuleGraphModuleNode` (layer and issues)\n3. Moving layer resolution to the point of use in dynamic imports and server actions\n\nThis is a small progression in runtime:\n\n![image.png](https://graphite-user-uploaded-assets-prod.s3.amazonaws.com/AwJ29EfoPcPdLSwCZxAz/d669023b-9ac4-44d5-ac9f-54e42b71d341.png)\n\n### Why?\nThese changes optimize memory usage in the module graph, which is particularly important for large applications. By removing unused fields and using more compact types, we can reduce the memory footprint of the graph.\n\nNotably, SingleModuleGraphNode is now 24 bytes instead of  48.  To make it smaller still we would need to reduce the size of visited moduel, perhaps by storing a reference to the graph that did the original visit?  This would be tricky from a lifetimes perspective but much more optimal.",
    "sha": "21182268f7ea009873b8a032f828b252743141de",
    "files": [
        {
            "sha": "4e13070843825d9c7bf1202142228d76c47859af",
            "filename": "crates/next-api/src/dynamic_imports.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/21182268f7ea009873b8a032f828b252743141de/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/21182268f7ea009873b8a032f828b252743141de/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs?ref=21182268f7ea009873b8a032f828b252743141de",
            "patch": "@@ -125,12 +125,12 @@ pub async fn map_next_dynamic(graph: Vc<SingleModuleGraph>) -> Result<Vc<Dynamic\n         .await?\n         .iter_nodes()\n         .map(|node| async move {\n-            let SingleModuleGraphModuleNode { module, layer, .. } = node;\n-\n-            if layer\n-                .as_ref()\n-                .is_some_and(|layer| &**layer == \"app-client\" || &**layer == \"client\")\n-            {\n+            let SingleModuleGraphModuleNode { module } = node;\n+            let layer = match module.ident().await?.layer {\n+                Some(l) => Some(l.await?),\n+                None => None,\n+            };\n+            if layer.is_some_and(|layer| *layer == \"app-client\" || *layer == \"client\") {\n                 if let Some(dynamic_entry_module) =\n                     ResolvedVc::try_downcast_type::<NextDynamicEntryModule>(*module)\n                 {"
        },
        {
            "sha": "34552cf3564c4d21bbbfbc67fc9db38eec68456a",
            "filename": "crates/next-api/src/server_actions.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 5,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/21182268f7ea009873b8a032f828b252743141de/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/21182268f7ea009873b8a032f828b252743141de/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs?ref=21182268f7ea009873b8a032f828b252743141de",
            "patch": "@@ -435,14 +435,17 @@ pub async fn map_server_actions(graph: Vc<SingleModuleGraph>) -> Result<Vc<AllMo\n         .iter_nodes()\n         .map(|node| {\n             async move {\n-                let SingleModuleGraphModuleNode { module, layer, .. } = node;\n-\n+                let SingleModuleGraphModuleNode { module } = node;\n+                let layer = match module.ident().await?.layer {\n+                    Some(l) => Some(l.await?),\n+                    None => None,\n+                };\n                 // TODO: compare module contexts instead?\n-                let layer = match &layer {\n-                    Some(layer) if &**layer == \"app-rsc\" || &**layer == \"app-edge-rsc\" => {\n+                let layer = match layer {\n+                    Some(layer) if *layer == \"app-rsc\" || *layer == \"app-edge-rsc\" => {\n                         ActionLayer::Rsc\n                     }\n-                    Some(layer) if &**layer == \"app-client\" => ActionLayer::ActionBrowser,\n+                    Some(layer) if *layer == \"app-client\" => ActionLayer::ActionBrowser,\n                     // TODO really ignore SSR?\n                     _ => return Ok(None),\n                 };"
        },
        {
            "sha": "e44f283cf8b941076a3e3aef77058c1247722ffa",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 69,
            "deletions": 120,
            "changes": 189,
            "blob_url": "https://github.com/vercel/next.js/blob/21182268f7ea009873b8a032f828b252743141de/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/21182268f7ea009873b8a032f828b252743141de/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=21182268f7ea009873b8a032f828b252743141de",
            "patch": "@@ -47,17 +47,24 @@ pub use self::module_batches::BatchingConfig;\n )]\n pub struct GraphNodeIndex {\n     #[turbo_tasks(trace_ignore)]\n-    graph_idx: usize,\n+    graph_idx: u32,\n     #[turbo_tasks(trace_ignore)]\n     node_idx: NodeIndex,\n }\n+impl GraphNodeIndex {\n+    #[inline(always)]\n+    fn graph_idx(&self) -> usize {\n+        self.graph_idx as usize\n+    }\n+}\n+\n unsafe impl NonLocalValue for GraphNodeIndex {}\n \n #[turbo_tasks::value]\n #[derive(Clone, Debug)]\n pub struct VisitedModules {\n     pub modules: FxIndexMap<ResolvedVc<Box<dyn Module>>, GraphNodeIndex>,\n-    next_graph_idx: usize,\n+    next_graph_idx: u32,\n }\n \n #[turbo_tasks::value_impl]\n@@ -236,29 +243,18 @@ impl SingleModuleGraph {\n                         // Handled when visiting ChunkableReference below\n                         continue;\n                     }\n-                    Some(\n-                        SingleModuleGraphBuilderNode::VisitedModule { .. }\n-                        | SingleModuleGraphBuilderNode::Issues { .. },\n-                    ) => unreachable!(),\n+                    Some(SingleModuleGraphBuilderNode::VisitedModule { .. }) => unreachable!(),\n                     None => None,\n                 };\n \n                 match current {\n-                    SingleModuleGraphBuilderNode::Module {\n-                        module,\n-                        layer,\n-                        ident: _,\n-                    } => {\n+                    SingleModuleGraphBuilderNode::Module { module, ident: _ } => {\n                         // Find the current node, if it was already added\n                         let current_idx = if let Some(current_idx) = modules.get(&module) {\n                             *current_idx\n                         } else {\n                             let idx = graph.add_node(SingleModuleGraphNode::Module(\n-                                SingleModuleGraphModuleNode {\n-                                    module,\n-                                    issues: Default::default(),\n-                                    layer,\n-                                },\n+                                SingleModuleGraphModuleNode { module },\n                             ));\n                             number_of_modules += 1;\n                             modules.insert(module, idx);\n@@ -287,7 +283,6 @@ impl SingleModuleGraph {\n                     SingleModuleGraphBuilderNode::ChunkableReference {\n                         source,\n                         target,\n-                        target_layer,\n                         chunking_type,\n                         ..\n                     } => {\n@@ -304,8 +299,6 @@ impl SingleModuleGraph {\n                                 None => {\n                                     SingleModuleGraphNode::Module(SingleModuleGraphModuleNode {\n                                         module: target,\n-                                        issues: Default::default(),\n-                                        layer: target_layer,\n                                     })\n                                 }\n                             });\n@@ -314,18 +307,6 @@ impl SingleModuleGraph {\n                         };\n                         graph.add_edge(*modules.get(&source).unwrap(), target_idx, chunking_type);\n                     }\n-                    SingleModuleGraphBuilderNode::Issues(new_issues) => {\n-                        let (parent_idx, _) = parent_edge.unwrap();\n-                        let SingleModuleGraphNode::Module(SingleModuleGraphModuleNode {\n-                            issues,\n-                            ..\n-                        }) = graph.node_weight_mut(parent_idx).unwrap()\n-                        else {\n-                            bail!(\"Expected Module node\");\n-                        };\n-\n-                        issues.extend(new_issues);\n-                    }\n                 }\n             }\n         }\n@@ -794,32 +775,33 @@ impl ModuleGraph {\n         let async_modules_info = self.async_module_info().await?;\n \n         let entry = ModuleGraph::get_entry(&graphs, module).await?;\n-        let referenced_modules = iter_neighbors_rev(&graphs[entry.graph_idx].graph, entry.node_idx)\n-            .filter(|(edge_idx, _)| {\n-                let ty = graphs[entry.graph_idx]\n-                    .graph\n-                    .edge_weight(*edge_idx)\n-                    .unwrap();\n-                ty.is_inherit_async()\n-            })\n-            .map(|(_, child_idx)| {\n-                anyhow::Ok(\n-                    get_node!(\n-                        graphs,\n-                        GraphNodeIndex {\n-                            graph_idx: entry.graph_idx,\n-                            node_idx: child_idx\n-                        }\n-                    )?\n-                    .module,\n-                )\n-            })\n-            .collect::<Result<Vec<_>>>()?\n-            .into_iter()\n-            .rev()\n-            .filter(|m| async_modules_info.contains(m))\n-            .map(|m| *m)\n-            .collect();\n+        let referenced_modules =\n+            iter_neighbors_rev(&graphs[entry.graph_idx()].graph, entry.node_idx)\n+                .filter(|(edge_idx, _)| {\n+                    let ty = graphs[entry.graph_idx()]\n+                        .graph\n+                        .edge_weight(*edge_idx)\n+                        .unwrap();\n+                    ty.is_inherit_async()\n+                })\n+                .map(|(_, child_idx)| {\n+                    anyhow::Ok(\n+                        get_node!(\n+                            graphs,\n+                            GraphNodeIndex {\n+                                graph_idx: entry.graph_idx,\n+                                node_idx: child_idx\n+                            }\n+                        )?\n+                        .module,\n+                    )\n+                })\n+                .collect::<Result<Vec<_>>>()?\n+                .into_iter()\n+                .rev()\n+                .filter(|m| async_modules_info.contains(m))\n+                .map(|m| *m)\n+                .collect();\n \n         Ok(AsyncModuleInfo::new(referenced_modules))\n     }\n@@ -832,13 +814,13 @@ impl ModuleGraph {\n macro_rules! get_node {\n     ($graphs:expr, $node:expr) => {{\n         let node_idx = $node;\n-        match $graphs[node_idx.graph_idx]\n+        match $graphs[node_idx.graph_idx()]\n             .graph\n             .node_weight(node_idx.node_idx)\n         {\n             Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok(node),\n             Some(SingleModuleGraphNode::VisitedModule { idx, .. }) => {\n-                match $graphs[idx.graph_idx].graph.node_weight(idx.node_idx) {\n+                match $graphs[idx.graph_idx()].graph.node_weight(idx.node_idx) {\n                     Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok(node),\n                     Some(SingleModuleGraphNode::VisitedModule { .. }) => Err(::anyhow::anyhow!(\n                         \"Expected visited target node to be module\"\n@@ -854,13 +836,13 @@ pub(crate) use get_node;\n macro_rules! get_node_idx {\n     ($graphs:expr, $node:expr) => {{\n         let node_idx = $node;\n-        match $graphs[node_idx.graph_idx]\n+        match $graphs[node_idx.graph_idx()]\n             .graph\n             .node_weight(node_idx.node_idx)\n         {\n             Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok((node, node_idx)),\n             Some(SingleModuleGraphNode::VisitedModule { idx, .. }) => {\n-                match $graphs[idx.graph_idx].graph.node_weight(idx.node_idx) {\n+                match $graphs[idx.graph_idx()].graph.node_weight(idx.node_idx) {\n                     Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok((node, *idx)),\n                     Some(SingleModuleGraphNode::VisitedModule { .. }) => Err(::anyhow::anyhow!(\n                         \"Expected visited target node to be module\"\n@@ -885,7 +867,7 @@ impl ModuleGraph {\n     ) -> Result<GraphNodeIndex> {\n         let Some(idx) = graphs.iter().enumerate().find_map(|(graph_idx, graph)| {\n             graph.modules.get(&entry).map(|node_idx| GraphNodeIndex {\n-                graph_idx,\n+                graph_idx: u32::try_from(graph_idx).unwrap(),\n                 node_idx: *node_idx,\n             })\n         }) else {\n@@ -936,7 +918,7 @@ impl ModuleGraph {\n             visitor(None, get_node!(graphs, entry_node)?)?;\n         }\n         while let Some(node) = queue.pop_front() {\n-            let graph = &graphs[node.graph_idx].graph;\n+            let graph = &graphs[node.graph_idx()].graph;\n             let node_weight = get_node!(graphs, node)?;\n             if visited.insert(node) {\n                 let neighbors = iter_neighbors_rev(graph, node.node_idx);\n@@ -989,7 +971,7 @@ impl ModuleGraph {\n             visitor(None, get_node!(graphs, entry_node)?);\n         }\n         while let Some(node) = stack.pop() {\n-            let graph = &graphs[node.graph_idx].graph;\n+            let graph = &graphs[node.graph_idx()].graph;\n             let node_weight = get_node!(graphs, node)?;\n             if visited.insert(node) {\n                 let neighbors = iter_neighbors_rev(graph, node.node_idx);\n@@ -1106,7 +1088,7 @@ impl ModuleGraph {\n             let parent_arg = match parent {\n                 Some((parent_node, parent_edge)) => Some((\n                     get_node!(graphs, parent_node)?,\n-                    graphs[parent_node.graph_idx]\n+                    graphs[parent_node.graph_idx()]\n                         .graph\n                         .edge_weight(parent_edge)\n                         .unwrap(),\n@@ -1125,18 +1107,20 @@ impl ModuleGraph {\n                     }\n                     stack.push((TopologicalPass::Visit, parent, current));\n                     if action == GraphTraversalAction::Continue && expanded.insert(current) {\n-                        let graph = &graphs[current.graph_idx].graph;\n-                        let (neighbors_rev, current) =\n-                            match graph.node_weight(current.node_idx).unwrap() {\n-                                SingleModuleGraphNode::Module(_) => {\n-                                    (iter_neighbors_rev(graph, current.node_idx), current)\n-                                }\n-                                SingleModuleGraphNode::VisitedModule { idx, .. } => (\n-                                    // We switch graphs\n-                                    iter_neighbors_rev(&graphs[idx.graph_idx].graph, idx.node_idx),\n-                                    *idx,\n-                                ),\n-                            };\n+                        let graph = &graphs[current.graph_idx()].graph;\n+                        let (neighbors_rev, current) = match graph\n+                            .node_weight(current.node_idx)\n+                            .unwrap()\n+                        {\n+                            SingleModuleGraphNode::Module(_) => {\n+                                (iter_neighbors_rev(graph, current.node_idx), current)\n+                            }\n+                            SingleModuleGraphNode::VisitedModule { idx, .. } => (\n+                                // We switch graphs\n+                                iter_neighbors_rev(&graphs[idx.graph_idx()].graph, idx.node_idx),\n+                                *idx,\n+                            ),\n+                        };\n                         stack.extend(neighbors_rev.map(|(edge, child)| {\n                             (\n                                 TopologicalPass::ExpandAndVisit,\n@@ -1244,7 +1228,7 @@ impl ModuleGraph {\n         while let Some(NodeWithPriority { node, .. }) = queue.pop() {\n             queue_set.remove(&node);\n             let (node_weight, node) = get_node_idx!(graphs, node)?;\n-            let graph = &graphs[node.graph_idx].graph;\n+            let graph = &graphs[node.graph_idx()].graph;\n             let neighbors = iter_neighbors_rev(graph, node.node_idx);\n \n             visit_count += 1;\n@@ -1310,8 +1294,6 @@ impl SingleModuleGraph {\n #[derive(Clone, Debug, Serialize, Deserialize, TraceRawVcs, NonLocalValue)]\n pub struct SingleModuleGraphModuleNode {\n     pub module: ResolvedVc<Box<dyn Module>>,\n-    pub layer: Option<ReadRef<RcStr>>,\n-    pub issues: Vec<ResolvedVc<Box<dyn Issue>>>,\n }\n \n #[derive(Clone, Debug, Serialize, Deserialize, TraceRawVcs, NonLocalValue)]\n@@ -1326,21 +1308,10 @@ pub enum SingleModuleGraphNode {\n impl SingleModuleGraphNode {\n     pub fn module(&self) -> ResolvedVc<Box<dyn Module>> {\n         match self {\n-            SingleModuleGraphNode::Module(SingleModuleGraphModuleNode { module, .. }) => *module,\n+            SingleModuleGraphNode::Module(SingleModuleGraphModuleNode { module }) => *module,\n             SingleModuleGraphNode::VisitedModule { module, .. } => *module,\n         }\n     }\n-\n-    // fn emit_issues(&self) {\n-    //     match self {\n-    //         SingleModuleGraphNode::Module { issues, .. } => {\n-    //             for issue in issues {\n-    //                 issue.emit();\n-    //             }\n-    //         }\n-    //         SingleModuleGraphNode::VisitedModule { .. } => todo!(),\n-    //     }\n-    // }\n }\n \n #[derive(PartialEq, Eq, Debug)]\n@@ -1361,36 +1332,30 @@ enum SingleModuleGraphBuilderNode {\n     ChunkableReference {\n         chunking_type: ChunkingType,\n         source: ResolvedVc<Box<dyn Module>>,\n-        source_ident: ReadRef<RcStr>,\n         target: ResolvedVc<Box<dyn Module>>,\n+        // These two fields are only used for tracing. Derived from `source.ident()` and\n+        // `target.ident()`\n+        source_ident: ReadRef<RcStr>,\n         target_ident: ReadRef<RcStr>,\n-        target_layer: Option<ReadRef<RcStr>>,\n     },\n     /// A regular module\n     Module {\n         module: ResolvedVc<Box<dyn Module>>,\n-        layer: Option<ReadRef<RcStr>>,\n+        // module.ident().to_string(), eagerly computed for tracing\n         ident: ReadRef<RcStr>,\n     },\n     /// A reference to a module that is already listed in visited_modules\n     VisitedModule {\n         module: ResolvedVc<Box<dyn Module>>,\n         idx: GraphNodeIndex,\n     },\n-    /// Issues to be added to the parent Module node\n-    #[allow(dead_code)]\n-    Issues(Vec<ResolvedVc<Box<dyn Issue>>>),\n }\n \n impl SingleModuleGraphBuilderNode {\n     async fn new_module(module: ResolvedVc<Box<dyn Module>>) -> Result<Self> {\n         let ident = module.ident();\n         Ok(Self::Module {\n             module,\n-            layer: match ident.await?.layer {\n-                Some(layer) => Some(layer.await?),\n-                None => None,\n-            },\n             ident: ident.to_string().await?,\n         })\n     }\n@@ -1405,10 +1370,6 @@ impl SingleModuleGraphBuilderNode {\n             source_ident: source.ident().to_string().await?,\n             target,\n             target_ident: target.ident().to_string().await?,\n-            target_layer: match target.ident().await?.layer {\n-                Some(layer) => Some(layer.await?),\n-                None => None,\n-            },\n         })\n     }\n     fn new_visited_module(module: ResolvedVc<Box<dyn Module>>, idx: GraphNodeIndex) -> Self {\n@@ -1447,8 +1408,6 @@ impl Visit<SingleModuleGraphBuilderNode> for SingleModuleGraphBuilder<'_> {\n             },\n             // Module was already visited previously\n             SingleModuleGraphBuilderNode::VisitedModule { .. } => VisitControlFlow::Skip(edge.to),\n-            // Issues doen't have any children\n-            SingleModuleGraphBuilderNode::Issues(_) => VisitControlFlow::Skip(edge.to),\n         }\n     }\n \n@@ -1460,8 +1419,7 @@ impl Visit<SingleModuleGraphBuilderNode> for SingleModuleGraphBuilder<'_> {\n                 (None, Some(*target))\n             }\n             // These are always skipped in `visit()`\n-            SingleModuleGraphBuilderNode::VisitedModule { .. }\n-            | SingleModuleGraphBuilderNode::Issues(_) => unreachable!(),\n+            SingleModuleGraphBuilderNode::VisitedModule { .. } => unreachable!(),\n         };\n         let visited_modules = self.visited_modules;\n         let include_traced = self.include_traced;\n@@ -1475,13 +1433,6 @@ impl Visit<SingleModuleGraphBuilderNode> for SingleModuleGraphBuilder<'_> {\n                             return Err(e.context(module.ident().to_string().await?));\n                         }\n                     };\n-                    // TODO This is currently too slow\n-                    // let refs_issues = refs_cell\n-                    //     .take_collectibles::<Box<dyn Issue>>()\n-                    //     .iter()\n-                    //     .map(|issue| issue.to_resolved())\n-                    //     .try_join()\n-                    // .await?;\n \n                     refs.iter()\n                         .flat_map(|(ty, modules)| modules.iter().map(|m| (ty.clone(), *m)))\n@@ -1523,9 +1474,7 @@ impl Visit<SingleModuleGraphBuilderNode> for SingleModuleGraphBuilder<'_> {\n             SingleModuleGraphBuilderNode::Module { ident, .. } => {\n                 tracing::info_span!(\"module\", name = display(ident))\n             }\n-            SingleModuleGraphBuilderNode::Issues(_) => {\n-                tracing::info_span!(\"issues\")\n-            }\n+\n             SingleModuleGraphBuilderNode::ChunkableReference {\n                 chunking_type,\n                 source_ident,"
        }
    ],
    "stats": {
        "total": 214,
        "additions": 83,
        "deletions": 131
    }
}