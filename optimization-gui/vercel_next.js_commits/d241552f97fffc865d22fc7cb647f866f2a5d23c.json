{
    "author": "lukesandberg",
    "message": "[turbopack] Rename graph traversal algorithms (#87119)\n\n* remove `traverse_edges_from_entry_dfs` it is dead\n* rename a number of traversal methods to shorter names. mostly by dropping `from_entries` which i don't believe is useful.\n* rename `travserve_edges_from_entries_dfs_reversed` to `traverse_edges_reverse_dfs` which is a bit better, but could probably still use some work.\n\nI explored ways to share logic across our DFS implementations and ultimately determined that the juice wasn't worth the squeeze",
    "sha": "d241552f97fffc865d22fc7cb647f866f2a5d23c",
    "files": [
        {
            "sha": "5c22267499d25cc27ebf01387b35601fc486c251",
            "filename": "crates/next-api/src/analyze.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d241552f97fffc865d22fc7cb647f866f2a5d23c/crates%2Fnext-api%2Fsrc%2Fanalyze.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d241552f97fffc865d22fc7cb647f866f2a5d23c/crates%2Fnext-api%2Fsrc%2Fanalyze.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fanalyze.rs?ref=d241552f97fffc865d22fc7cb647f866f2a5d23c",
            "patch": "@@ -424,7 +424,7 @@ pub async fn analyze_module_graphs(module_graphs: Vc<ModuleGraphs>) -> Result<Vc\n     let mut all_async_edges = FxIndexSet::default();\n     for &module_graph in module_graphs.await? {\n         let module_graph = module_graph.read_graphs().await?;\n-        module_graph.traverse_all_edges_unordered(|parent, node| {\n+        module_graph.traverse_edges_unordered(|parent, node| {\n             if let Some((parent_node, reference)) = parent {\n                 all_modules.insert(parent_node);\n                 all_modules.insert(node);"
        },
        {
            "sha": "b7124c18a7e293cb14e192690b7fc8d8ffcfccb0",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/d241552f97fffc865d22fc7cb647f866f2a5d23c/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d241552f97fffc865d22fc7cb647f866f2a5d23c/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=d241552f97fffc865d22fc7cb647f866f2a5d23c",
            "patch": "@@ -173,7 +173,7 @@ impl NextDynamicGraph {\n \n             // module -> the client reference entry (if any)\n             let mut state_map = FxHashMap::default();\n-            graph.traverse_edges_from_entries_dfs(\n+            graph.traverse_edges_dfs(\n                 entries,\n                 &mut (),\n                 |parent_info, node, _| {\n@@ -351,7 +351,7 @@ impl ServerActionsGraph {\n                 }\n \n                 let mut result = FxIndexMap::default();\n-                graph.traverse_nodes_from_entries_dfs(\n+                graph.traverse_nodes_dfs(\n                     vec![entry],\n                     &mut result,\n                     |node, result| {\n@@ -559,7 +559,7 @@ impl ClientReferencesGraph {\n             let mut server_components = FxIndexSet::default();\n \n             // Perform a DFS traversal to find all server components included by this page.\n-            graph.traverse_nodes_from_entries_dfs(\n+            graph.traverse_nodes_dfs(\n                 entries,\n                 &mut (),\n                 |node, _| {\n@@ -615,7 +615,7 @@ impl ClientReferencesGraph {\n             // necessarily rendered at the same time (not-found, or parallel routes), we need to\n             // determine the order of client references individually for each server component.\n             for sc in server_components.iter().copied() {\n-                graph.traverse_nodes_from_entries_dfs(\n+                graph.traverse_nodes_dfs(\n                     std::iter::once(ResolvedVc::upcast(sc)),\n                     &mut (),\n                     |node, _| {\n@@ -786,7 +786,7 @@ async fn validate_pages_css_imports_individual(\n \n     let mut candidates = vec![];\n \n-    graph.traverse_edges_from_entries_dfs(\n+    graph.traverse_edges_dfs(\n         entries,\n         &mut (),\n         |parent_info, node, _| {"
        },
        {
            "sha": "87597db9a742ccd2d483aefd63b2f2e8e3f73446",
            "filename": "crates/next-api/src/routes_hashes_manifest.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d241552f97fffc865d22fc7cb647f866f2a5d23c/crates%2Fnext-api%2Fsrc%2Froutes_hashes_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d241552f97fffc865d22fc7cb647f866f2a5d23c/crates%2Fnext-api%2Fsrc%2Froutes_hashes_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Froutes_hashes_manifest.rs?ref=d241552f97fffc865d22fc7cb647f866f2a5d23c",
            "patch": "@@ -64,7 +64,7 @@ pub async fn endpoint_hashes(\n \n     let module_graph = module_graph.read_graphs().await?;\n \n-    module_graph.traverse_nodes_from_entries_dfs(\n+    module_graph.traverse_nodes_dfs(\n         modules,\n         &mut all_modules,\n         |module, all_modules| {"
        },
        {
            "sha": "bed5c32e4ad9e23aff5a181d31761e821dfb4cfe",
            "filename": "crates/next-api/src/webpack_stats.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d241552f97fffc865d22fc7cb647f866f2a5d23c/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d241552f97fffc865d22fc7cb647f866f2a5d23c/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs?ref=d241552f97fffc865d22fc7cb647f866f2a5d23c",
            "patch": "@@ -58,7 +58,7 @@ where\n     let asset_reasons = {\n         let module_graph = module_graph.read_graphs().await?;\n         let mut edges = vec![];\n-        module_graph.traverse_all_edges_unordered(|parent, current| {\n+        module_graph.traverse_edges_unordered(|parent, current| {\n             if let Some((parent_node, r)) = parent {\n                 edges.push((\n                     parent_node,"
        },
        {
            "sha": "881fbda7bdd6c1a2449257226441be52c85689e9",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/async_module_info.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs?ref=d241552f97fffc865d22fc7cb647f866f2a5d23c",
            "patch": "@@ -80,7 +80,7 @@ async fn compute_async_module_info_single(\n     let mut async_modules = FxHashSet::default();\n     async_modules.extend(self_async_modules.iter());\n \n-    graph.traverse_edges_from_entries_dfs_reversed(\n+    graph.traverse_edges_reverse_dfs(\n         self_async_modules,\n         &mut (),\n         // child is the previously visited module which must be async"
        },
        {
            "sha": "a37e2886f0b151879c1767b03bbcaa249d9152e0",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=d241552f97fffc865d22fc7cb647f866f2a5d23c",
            "patch": "@@ -411,7 +411,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n         let module_depth: FxHashMap<ResolvedVc<Box<dyn Module>>, usize> = {\n             let mut module_depth =\n                 FxHashMap::with_capacity_and_hasher(module_count, Default::default());\n-            graph.traverse_edges_from_entries_bfs(\n+            graph.traverse_edges_bfs(\n                 entries.iter().flat_map(|e| e.entries()),\n                 |parent, node| {\n                     if let Some((parent, _)) = parent {"
        },
        {
            "sha": "0dfe2f9e8541ad6e8e2cd50b50d5939922f54fc8",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/merged_modules.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 16,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs?ref=d241552f97fffc865d22fc7cb647f866f2a5d23c",
            "patch": "@@ -93,21 +93,18 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n \n             let mut module_depth =\n                 FxHashMap::with_capacity_and_hasher(module_count, Default::default());\n-            module_graph.traverse_edges_from_entries_bfs(\n-                entries.iter().copied(),\n-                |parent, node| {\n-                    if let Some((parent, _)) = parent {\n-                        let parent_depth = *module_depth\n-                            .get(&parent)\n-                            .context(\"Module depth not found\")?;\n-                        module_depth.entry(node).or_insert(parent_depth + 1);\n-                    } else {\n-                        module_depth.insert(node, 0);\n-                    };\n+            module_graph.traverse_edges_bfs(entries.iter().copied(), |parent, node| {\n+                if let Some((parent, _)) = parent {\n+                    let parent_depth = *module_depth\n+                        .get(&parent)\n+                        .context(\"Module depth not found\")?;\n+                    module_depth.entry(node).or_insert(parent_depth + 1);\n+                } else {\n+                    module_depth.insert(node, 0);\n+                };\n \n-                    Ok(GraphTraversalAction::Continue)\n-                },\n-            )?;\n+                Ok(GraphTraversalAction::Continue)\n+            })?;\n             module_depth\n         };\n \n@@ -326,7 +323,7 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                         // leading to the list `a, b` which is not execution order.\n                         let mut visited = FxHashSet::default();\n \n-                        module_graph.traverse_edges_from_entries_dfs(\n+                        module_graph.traverse_edges_dfs(\n                             chunk_group.entries(),\n                             &mut (),\n                             |parent_info, node, _| {\n@@ -468,7 +465,7 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n         let mut exposed_modules_namespace: FxHashSet<ResolvedVc<Box<dyn Module>>> =\n             FxHashSet::with_capacity_and_hasher(module_merged_groups.len(), Default::default());\n \n-        module_graph.traverse_edges_from_entries_dfs(\n+        module_graph.traverse_edges_dfs(\n             entries,\n             &mut (),\n             |_, _, _| Ok(GraphTraversalAction::Continue),"
        },
        {
            "sha": "f7afd58c663e08ec08b3bcc36e0230186cd83bf0",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 63,
            "changes": 79,
            "blob_url": "https://github.com/vercel/next.js/blob/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=d241552f97fffc865d22fc7cb647f866f2a5d23c",
            "patch": "@@ -1107,7 +1107,7 @@ impl ModuleGraphRef {\n     ///    - Receives the module and the `state`\n     ///    - Can return [GraphTraversalAction]s to control the traversal\n     /// * `visit_postorder` - Called after visiting children of a node.\n-    pub fn traverse_nodes_from_entries_dfs<S>(\n+    pub fn traverse_nodes_dfs<S>(\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         state: &mut S,\n@@ -1168,7 +1168,7 @@ impl ModuleGraphRef {\n     ///    - Receives (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode, state &S\n     ///    - Can return [GraphTraversalAction]s to control the traversal\n-    pub fn traverse_edges_from_entries_bfs(\n+    pub fn traverse_edges_bfs(\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         mut visitor: impl FnMut(\n@@ -1209,55 +1209,6 @@ impl ModuleGraphRef {\n         Ok(())\n     }\n \n-    /// Traverses all reachable edges exactly once and calls the visitor with the edge source and\n-    /// target.\n-    ///\n-    /// This means that target nodes can be revisited (once per incoming edge).\n-    ///\n-    /// * `entry` - The entry module to start the traversal from\n-    /// * `visitor` - Called before visiting the children of a node.\n-    ///    - Receives (originating &SingleModuleGraphNode, edge &ChunkingType), target\n-    ///      &SingleModuleGraphNode, state &S\n-    ///    - Can return [GraphTraversalAction]s to control the traversal\n-    pub fn traverse_edges_from_entry_dfs(\n-        &self,\n-        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n-        mut visitor: impl FnMut(\n-            Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n-            ResolvedVc<Box<dyn Module>>,\n-        ) -> GraphTraversalAction,\n-    ) -> Result<()> {\n-        let mut stack = entries\n-            .into_iter()\n-            .map(|e| self.get_entry(e))\n-            .collect::<Result<Vec<_>>>()?;\n-        let mut visited = FxHashSet::default();\n-        for entry_node in &stack {\n-            visitor(None, self.get_node(*entry_node)?.module());\n-        }\n-        while let Some(node) = stack.pop() {\n-            if visited.insert(node) {\n-                let node_weight = self.get_node(node)?;\n-                for (edge, succ) in self.iter_graphs_neighbors_rev(node, Direction::Outgoing) {\n-                    let succ_weight = self.get_node(succ)?;\n-                    let action = visitor(\n-                        Some((node_weight.module(), self.get_edge(edge)?)),\n-                        succ_weight.module(),\n-                    );\n-                    if !self.should_visit_node(succ_weight, Direction::Outgoing) {\n-                        continue;\n-                    }\n-                    let succ = succ_weight.target_idx(Direction::Outgoing).unwrap_or(succ);\n-                    if !visited.contains(&succ) && action == GraphTraversalAction::Continue {\n-                        stack.push(succ);\n-                    }\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n     /// Traverses all edges exactly once (in an unspecified order) and calls the visitor with the\n     /// edge source and target.\n     ///\n@@ -1266,7 +1217,7 @@ impl ModuleGraphRef {\n     /// * `visitor` - Called before visiting the children of a node.\n     ///    - Receives (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode\n-    pub fn traverse_all_edges_unordered(\n+    pub fn traverse_edges_unordered(\n         &self,\n         mut visitor: impl FnMut(\n             Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n@@ -1275,7 +1226,9 @@ impl ModuleGraphRef {\n     ) -> Result<()> {\n         let entries = self.graphs.iter().flat_map(|g| g.entry_modules());\n \n-        self.traverse_edges_from_entries_dfs(\n+        // Despite the name we need to do a DFS to respect 'reachability' if an edge was trimmed we\n+        // should not follow it, and this is a reasonable way to do that.\n+        self.traverse_edges_dfs(\n             entries,\n             &mut (),\n             |parent, target, _| {\n@@ -1304,7 +1257,7 @@ impl ModuleGraphRef {\n     /// * `visit_postorder` - Called after visiting the children of a node. Return\n     ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode, state &S\n-    pub fn traverse_edges_from_entries_dfs<S>(\n+    pub fn traverse_edges_dfs<S>(\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         state: &mut S,\n@@ -1319,7 +1272,7 @@ impl ModuleGraphRef {\n             &mut S,\n         ) -> Result<()>,\n     ) -> Result<()> {\n-        self.traverse_edges_from_entries_dfs_impl::<S>(\n+        self.traverse_edges_dfs_impl::<S>(\n             entries,\n             state,\n             visit_preorder,\n@@ -1344,7 +1297,7 @@ impl ModuleGraphRef {\n     /// * `visit_postorder` - Called after visiting the parents of a node. Return\n     ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode, state &S\n-    pub fn traverse_edges_from_entries_dfs_reversed<S>(\n+    pub fn traverse_edges_reverse_dfs<S>(\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         state: &mut S,\n@@ -1359,7 +1312,7 @@ impl ModuleGraphRef {\n             &mut S,\n         ) -> Result<()>,\n     ) -> Result<()> {\n-        self.traverse_edges_from_entries_dfs_impl::<S>(\n+        self.traverse_edges_dfs_impl::<S>(\n             entries,\n             state,\n             visit_preorder,\n@@ -1368,7 +1321,7 @@ impl ModuleGraphRef {\n         )\n     }\n \n-    fn traverse_edges_from_entries_dfs_impl<S>(\n+    fn traverse_edges_dfs_impl<S>(\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         state: &mut S,\n@@ -1972,7 +1925,7 @@ pub mod tests {\n                 let mut preorder_visits = Vec::new();\n                 let mut postorder_visits = Vec::new();\n \n-                graph.traverse_edges_from_entries_dfs(\n+                graph.traverse_edges_dfs(\n                     entry_modules,\n                     &mut (),\n                     |parent, target, _| {\n@@ -2032,7 +1985,7 @@ pub mod tests {\n                 let mut preorder_visits = Vec::new();\n                 let mut postorder_visits = Vec::new();\n \n-                graph.traverse_edges_from_entries_dfs(\n+                graph.traverse_edges_dfs(\n                     entry_modules,\n                     &mut (),\n                     |parent, target, _| {\n@@ -2186,7 +2139,7 @@ pub mod tests {\n             // test traversing forward from a in the child graph\n             {\n                 let mut visited_forward = Vec::new();\n-                child_graph.traverse_edges_from_entries_dfs(\n+                child_graph.traverse_edges_dfs(\n                     vec![a_module],\n                     &mut (),\n                     |_parent, child, _state_| {\n@@ -2237,7 +2190,7 @@ pub mod tests {\n                     .next()\n                     .unwrap();\n                 let mut visited_reverse = Vec::new();\n-                child_graph.traverse_edges_from_entries_dfs_reversed(\n+                child_graph.traverse_edges_reverse_dfs(\n                     vec![d_module],\n                     &mut (),\n                     |_parent, child, _state_| {\n@@ -2259,7 +2212,7 @@ pub mod tests {\n             // VisitedModule in this graph\n             {\n                 let mut visited_reverse = Vec::new();\n-                child_graph.traverse_edges_from_entries_dfs_reversed(\n+                child_graph.traverse_edges_reverse_dfs(\n                     vec![b_module],\n                     &mut (),\n                     |_parent, child, _state_| {"
        },
        {
            "sha": "452f17ed06573d22d2358fcff60393d78dfe6585",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/module_batches.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs?ref=d241552f97fffc865d22fc7cb647f866f2a5d23c",
            "patch": "@@ -289,7 +289,7 @@ impl PreBatches {\n             this: self,\n         };\n         let mut visited = FxHashSet::default();\n-        module_graph.traverse_edges_from_entries_dfs(\n+        module_graph.traverse_edges_dfs(\n             std::iter::once(entry),\n             &mut state,\n             |parent_info, node, state| {\n@@ -355,7 +355,7 @@ pub async fn compute_module_batches(\n \n         // Walk the module graph and mark all modules that are boundary modules (referenced from a\n         // different chunk group bitmap)\n-        module_graph.traverse_all_edges_unordered(|parent, node| {\n+        module_graph.traverse_edges_unordered(|parent, node| {\n             if let Some((parent, ty)) = parent {\n                 let std::collections::hash_set::Entry::Vacant(entry) =\n                     pre_batches.boundary_modules.entry(node)"
        },
        {
            "sha": "9e080131941471beb48d50e94fc564cf6d824c92",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/side_effect_module_info.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fside_effect_module_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fside_effect_module_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fside_effect_module_info.rs?ref=d241552f97fffc865d22fc7cb647f866f2a5d23c",
            "patch": "@@ -75,7 +75,7 @@ async fn compute_side_effect_free_module_info_single(\n     // dependencies are side effect free.\n \n     let mut locally_side_effect_free_modules_that_have_side_effects = FxHashSet::default();\n-    graph.traverse_edges_from_entries_dfs_reversed(\n+    graph.traverse_edges_reverse_dfs(\n         // Start from all the side effectful nodes\n         module_side_effects.iter().filter_map(|(m, e)| {\n             if *e == ModuleSideEffects::SideEffectful {"
        },
        {
            "sha": "d800e5eca15acd90bf7803e9195b449fb9711518",
            "filename": "turbopack/crates/turbopack/src/global_module_ids.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fglobal_module_ids.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d241552f97fffc865d22fc7cb647f866f2a5d23c/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fglobal_module_ids.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fglobal_module_ids.rs?ref=d241552f97fffc865d22fc7cb647f866f2a5d23c",
            "patch": "@@ -30,7 +30,7 @@ pub async fn get_global_module_id_strategy(\n \n         // And additionally, all the modules that are inserted by chunking (i.e. async loaders)\n         let mut async_idents = vec![];\n-        module_graph.traverse_all_edges_unordered(|parent, current| {\n+        module_graph.traverse_edges_unordered(|parent, current| {\n             if let Some((\n                 _,\n                 &RefData {"
        }
    ],
    "stats": {
        "total": 136,
        "additions": 43,
        "deletions": 93
    }
}