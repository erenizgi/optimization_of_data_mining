{
    "author": "sokra",
    "message": "Turbopack: only schedule tasks when task becomes active on active counter increase (#81414)\n\n### What?\n\nWe only need to schedule the task when it was not active before when the active counter is increased",
    "sha": "8367faedd61501025299e92d43a28393c7bb50e2",
    "files": [
        {
            "sha": "1521e059cd654f6e46fa89e940270bff438a929a",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/aggregation_update.rs",
            "status": "modified",
            "additions": 29,
            "deletions": 3,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/8367faedd61501025299e92d43a28393c7bb50e2/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/8367faedd61501025299e92d43a28393c7bb50e2/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs?ref=8367faedd61501025299e92d43a28393c7bb50e2",
            "patch": "@@ -2144,19 +2144,34 @@ impl AggregationUpdateQueue {\n             TaskDataCategory::Meta,\n         );\n         let state = get_mut_or_insert_with!(task, Activeness, || ActivenessState::new(task_id));\n+        let is_new = state.is_empty();\n         let is_zero = state.decrement_active_counter();\n         let is_empty = state.is_empty();\n         if is_empty {\n             task.remove(&CachedDataItemKey::Activeness {});\n         }\n-        if is_zero {\n+        debug_assert!(\n+            !(is_new && is_zero),\n+            // This allows us to but the `if is_zero` block in the else branch of the `if is_new`\n+            // block below for fewer checks and less problems with the borrow checker.\n+            \"A new Activeness will never be zero after decrementing\"\n+        );\n+        if is_new {\n+            // A task is considered \"active\" purely by the existence of an `Activeness` item, even\n+            // if that item has an negative active counter. So we need to make sure to\n+            // schedule it here. That case is pretty rare and only happens under extreme race\n+            // conditions.\n+            self.find_and_schedule_dirty_internal(task_id, task, ctx);\n+        } else if is_zero {\n             let followers = get_followers(&task);\n             drop(task);\n             if !followers.is_empty() {\n                 self.push(AggregationUpdateJob::DecreaseActiveCounts {\n                     task_ids: followers,\n                 });\n             }\n+        } else {\n+            drop(task);\n         }\n     }\n \n@@ -2173,16 +2188,27 @@ impl AggregationUpdateQueue {\n             TaskDataCategory::Meta,\n         );\n         let state = get_mut_or_insert_with!(task, Activeness, || ActivenessState::new(task_id));\n+        let is_new = state.is_empty();\n         let is_positive_now = state.increment_active_counter();\n         let is_empty = state.is_empty();\n         // This can happen if active count was negative before\n         if is_empty {\n             task.remove(&CachedDataItemKey::Activeness {});\n         }\n+        debug_assert!(\n+            !is_new || is_positive_now,\n+            // This allows us to nest the `if is_new` block below `if is_positive_now` for fewer\n+            // checks.\n+            \"A new Activeness will always be positive after incrementing\"\n+        );\n         if is_positive_now {\n             let followers = get_followers(&task);\n-            // Fast path to schedule\n-            self.find_and_schedule_dirty_internal(task_id, task, ctx);\n+            if is_new {\n+                // Fast path to schedule\n+                self.find_and_schedule_dirty_internal(task_id, task, ctx);\n+            } else {\n+                drop(task);\n+            }\n \n             if !followers.is_empty() {\n                 self.push(AggregationUpdateJob::IncreaseActiveCounts {"
        }
    ],
    "stats": {
        "total": 32,
        "additions": 29,
        "deletions": 3
    }
}