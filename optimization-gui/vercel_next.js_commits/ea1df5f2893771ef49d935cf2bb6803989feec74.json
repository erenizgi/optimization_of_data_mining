{
    "author": "lukesandberg",
    "message": "[turbopack] Break ties using a counter instead of node index (#87252)\n\nThis should ensure that if priorities are ambiguous we revert to a BFS order\n\nBFS is better than DFS for the `fixed point` traversals since we are generally propogating information 'down' the graph so to the extent we can we should visit all r-deps first.  BFS approximates this.",
    "sha": "ea1df5f2893771ef49d935cf2bb6803989feec74",
    "files": [
        {
            "sha": "5ddd4cd2b206a1eefb3215697d25ca07daa20563",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 70,
            "deletions": 2,
            "changes": 72,
            "blob_url": "https://github.com/vercel/next.js/blob/ea1df5f2893771ef49d935cf2bb6803989feec74/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ea1df5f2893771ef49d935cf2bb6803989feec74/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=ea1df5f2893771ef49d935cf2bb6803989feec74",
            "patch": "@@ -1451,10 +1451,17 @@ impl ModuleGraphRef {\n             );\n         }\n \n+        let mut visit_order = 0usize;\n+        let mut order = || {\n+            let order = visit_order;\n+            visit_order += 1;\n+            order\n+        };\n         #[derive(PartialEq, Eq)]\n         struct NodeWithPriority<T: Ord> {\n             node: GraphNodeIndex,\n             priority: T,\n+            visit_order: usize,\n         }\n         impl<T: Ord> PartialOrd for NodeWithPriority<T> {\n             fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n@@ -1467,8 +1474,9 @@ impl ModuleGraphRef {\n \n                 self.priority\n                     .cmp(&other.priority)\n-                    // include GraphNodeIndex for total and deterministic ordering\n-                    .then(other.node.cmp(&self.node))\n+                    // Use visit_order, so when there are ties we prioritize earlier discovered\n+                    // nodes, reverting to a BFS in the the case where all priorities are equal\n+                    .then(self.visit_order.cmp(&other.visit_order))\n             }\n         }\n \n@@ -1480,6 +1488,7 @@ impl ModuleGraphRef {\n                     Ok(NodeWithPriority {\n                         node: self.get_entry(m)?,\n                         priority,\n+                        visit_order: order(),\n                     })\n                 })\n                 .collect::<Result<Vec<_>>>()?,\n@@ -1511,6 +1520,7 @@ impl ModuleGraphRef {\n                     queue.push(NodeWithPriority {\n                         node: succ,\n                         priority: priority(succ_weight.module(), state)?,\n+                        visit_order: order(),\n                     });\n                 }\n             }\n@@ -2081,6 +2091,64 @@ pub mod tests {\n         .await;\n     }\n \n+    #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+    async fn test_traverse_edges_fixed_point_no_priority_is_bfs() {\n+        run_graph_test(\n+            vec![rcstr!(\"a.js\")],\n+            {\n+                let mut deps = FxHashMap::default();\n+                // a simple triangle\n+                //        a\n+                //      b   c\n+                //   d    e    f\n+                deps.insert(rcstr!(\"a.js\"), vec![rcstr!(\"b.js\"), rcstr!(\"c.js\")]);\n+                deps.insert(rcstr!(\"b.js\"), vec![rcstr!(\"d.js\"), rcstr!(\"e.js\")]);\n+                deps.insert(rcstr!(\"c.js\"), vec![rcstr!(\"e.js\"), rcstr!(\"f.js\")]);\n+                deps\n+            },\n+            |graph, entry_modules, module_to_name| {\n+                let mut visits = Vec::new();\n+                let mut count = 0;\n+\n+                graph.traverse_edges_fixed_point_with_priority(\n+                    entry_modules.into_iter().map(|m| (m, 0)),\n+                    &mut (),\n+                    |parent, target, _| {\n+                        visits.push((\n+                            parent.map(|(node, _, _)| module_to_name.get(&node).unwrap().clone()),\n+                            module_to_name.get(&target).unwrap().clone(),\n+                        ));\n+                        count += 1;\n+\n+                        // We are a cycle so we need to break the loop eventually\n+                        Ok(if count < 6 {\n+                            GraphTraversalAction::Continue\n+                        } else {\n+                            GraphTraversalAction::Skip\n+                        })\n+                    },\n+                    |_, _| Ok(0),\n+                )?;\n+\n+                assert_eq!(\n+                    vec![\n+                        (None, rcstr!(\"a.js\")),\n+                        (Some(rcstr!(\"a.js\")), rcstr!(\"c.js\")),\n+                        (Some(rcstr!(\"a.js\")), rcstr!(\"b.js\")),\n+                        (Some(rcstr!(\"b.js\")), rcstr!(\"e.js\")),\n+                        (Some(rcstr!(\"b.js\")), rcstr!(\"d.js\")),\n+                        (Some(rcstr!(\"c.js\")), rcstr!(\"f.js\")),\n+                        (Some(rcstr!(\"c.js\")), rcstr!(\"e.js\")),\n+                    ],\n+                    visits\n+                );\n+\n+                Ok(())\n+            },\n+        )\n+        .await;\n+    }\n+\n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n     async fn test_reverse_edges_through_layered_graph() {\n         let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new("
        }
    ],
    "stats": {
        "total": 72,
        "additions": 70,
        "deletions": 2
    }
}