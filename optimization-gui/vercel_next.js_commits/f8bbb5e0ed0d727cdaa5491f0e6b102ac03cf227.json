{
    "author": "delbaoliveira",
    "message": "Docs IA 2.0: Review fetching page and move examples (#79200)\n\nPart of:\nhttps://linear.app/vercel/issue/DOC-4639/ia-20-migrate-bya-pages\nNo redirects needed yet as the page hasn't been deleted.",
    "sha": "f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227",
    "files": [
        {
            "sha": "9bbd0ceeff2559672f182a3ecb9d6ce42003d6fa",
            "filename": "docs/01-app/01-getting-started/09-fetching-data.mdx",
            "status": "modified",
            "additions": 272,
            "deletions": 1,
            "changes": 273,
            "blob_url": "https://github.com/vercel/next.js/blob/f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227/docs%2F01-app%2F01-getting-started%2F09-fetching-data.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227/docs%2F01-app%2F01-getting-started%2F09-fetching-data.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F09-fetching-data.mdx?ref=f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227",
            "patch": "@@ -8,9 +8,11 @@ related:\n   links:\n     - app/api-reference/functions/fetch\n     - app/api-reference/file-conventions/loading\n+    - app/api-reference/config/next-config-js/logging\n+    - app/api-reference/config/next-config-js/taint\n ---\n \n-This page will walk you through how you can fetch data in [Server Components](#server-components) and [Client Components](#client-components). As well as how to [stream](#streaming) content that depends on data.\n+This page will walk you through how you can fetch data in [Server and Client Components](/docs/app/getting-started/server-and-client-components), and how to [stream](#streaming) components that depend on data.\n \n ## Fetching data\n \n@@ -53,6 +55,11 @@ export default async function Page() {\n }\n ```\n \n+> **Good to know:**\n+>\n+> - `fetch` responses are not cached by default. However, Next.js will [prerender](/docs/app/getting-started/partial-prerendering#static-rendering) the route and the output will be cached for improved performance. If you'd like to opt into [dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering), use the `{ cache: 'no-store' }` option. See the [`fetch` API Reference](/docs/app/api-reference/functions/fetch).\n+> - During development, you can log `fetch` calls for better visibility and debugging. See the [`logging` API reference](/docs/app/api-reference/config/next-config-js/logging).\n+\n #### With an ORM or database\n \n Since Server Components are rendered on the server, you can safely make database queries using an ORM or database client. Turn your component into an asynchronous function, and await the call:\n@@ -203,6 +210,7 @@ export default function BlogPage() {\n \n ```jsx filename=\"app/blog/page.js\" switcher\n 'use client'\n+\n import useSWR from 'swr'\n \n const fetcher = (url) => fetch(url).then((r) => r.json())\n@@ -352,3 +360,266 @@ export default function BlogPage() {\n An instant loading state is fallback UI that is shown immediately to the user after navigation. For the best user experience, we recommend designing loading states that are meaningful and help users understand the app is responding. For example, you can use skeletons and spinners, or a small but meaningful part of future screens such as a cover photo, title, etc.\n \n In development, you can preview and inspect the loading state of your components using the [React Devtools](https://react.dev/learn/react-developer-tools).\n+\n+## Examples\n+\n+### Sequential data fetching\n+\n+Sequential data fetching happens when nested components in a tree each fetch their own data and the requests are not [deduplicated](/docs/app/deep-dive/caching#request-memoization), leading to longer response times.\n+\n+<Image\n+  alt=\"Sequential and Parallel Data Fetching\"\n+  srcLight=\"/docs/light/sequential-parallel-data-fetching.png\"\n+  srcDark=\"/docs/dark/sequential-parallel-data-fetching.png\"\n+  width=\"1600\"\n+  height=\"525\"\n+/>\n+\n+There may be cases where you want this pattern because one fetch depends on the result of the other.\n+\n+For example, the `<Playlists>` component will only start fetching data once the `<Artist>` component has finished fetching data because `<Playlists>` depends on the `artistID` prop:\n+\n+```tsx filename=\"app/artist/[username]/page.tsx\" switcher\n+export default async function Page({\n+  params,\n+}: {\n+  params: Promise<{ username: string }>\n+}) {\n+  const { username } = await params\n+  // Get artist information\n+  const artist = await getArtist(username)\n+\n+  return (\n+    <>\n+      <h1>{artist.name}</h1>\n+      {/* Show fallback UI while the Playlists component is loading */}\n+      <Suspense fallback={<div>Loading...</div>}>\n+        {/* Pass the artist ID to the Playlists component */}\n+        <Playlists artistID={artist.id} />\n+      </Suspense>\n+    </>\n+  )\n+}\n+\n+async function Playlists({ artistID }: { artistID: string }) {\n+  // Use the artist ID to fetch playlists\n+  const playlists = await getArtistPlaylists(artistID)\n+\n+  return (\n+    <ul>\n+      {playlists.map((playlist) => (\n+        <li key={playlist.id}>{playlist.name}</li>\n+      ))}\n+    </ul>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/artist/[username]/page.js\" switcher\n+export default async function Page({ params }) {\n+  const { username } = await params\n+  // Get artist information\n+  const artist = await getArtist(username)\n+\n+  return (\n+    <>\n+      <h1>{artist.name}</h1>\n+      {/* Show fallback UI while the Playlists component is loading */}\n+      <Suspense fallback={<div>Loading...</div>}>\n+        {/* Pass the artist ID to the Playlists component */}\n+        <Playlists artistID={artist.id} />\n+      </Suspense>\n+    </>\n+  )\n+}\n+\n+async function Playlists({ artistID }) {\n+  // Use the artist ID to fetch playlists\n+  const playlists = await getArtistPlaylists(artistID)\n+\n+  return (\n+    <ul>\n+      {playlists.map((playlist) => (\n+        <li key={playlist.id}>{playlist.name}</li>\n+      ))}\n+    </ul>\n+  )\n+}\n+```\n+\n+To improve the user experience, you should use [React `<Suspense>`](/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense) to show a `fallback` while data is being fetch. This will enable [streaming](#streaming) and prevent the whole route from being blocked by the sequential data requests.\n+\n+### Parallel data fetching\n+\n+Parallel data fetching happens when data requests in a route are eagerly initiated and start at the same time.\n+\n+By default, [layouts and pages](/docs/app/getting-started/layouts-and-pages) are rendered in parallel. So each segment starts fetching data as soon as possible.\n+\n+However, within _any_ component, multiple `async`/`await` requests can still be sequential if placed after the other. For example, `getAlbums` will be blocked until `getArtist` is resolved:\n+\n+```tsx filename=\"app/artist/[username]/page.tsx\" switcher\n+import { getArtist, getAlbums } from '@/app/lib/data'\n+\n+export default async function Page({ params }) {\n+  // These requests will be sequential\n+  const { username } = await params\n+  const artist = await getArtist(username)\n+  const albums = await getAlbums(username)\n+  return <div>{artist.name}</div>\n+}\n+```\n+\n+You can initiate requests in parallel by defining them outside the components that use the data, and resolving them together, for example, with [`Promise.all`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all):\n+\n+```tsx filename=\"app/artist/[username]/page.tsx\" highlight={3,8,23} switcher\n+import Albums from './albums'\n+\n+async function getArtist(username: string) {\n+  const res = await fetch(`https://api.example.com/artist/${username}`)\n+  return res.json()\n+}\n+\n+async function getAlbums(username: string) {\n+  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\n+  return res.json()\n+}\n+\n+export default async function Page({\n+  params,\n+}: {\n+  params: Promise<{ username: string }>\n+}) {\n+  const { username } = await params\n+  const artistData = getArtist(username)\n+  const albumsData = getAlbums(username)\n+\n+  // Initiate both requests in parallel\n+  const [artist, albums] = await Promise.all([artistData, albumsData])\n+\n+  return (\n+    <>\n+      <h1>{artist.name}</h1>\n+      <Albums list={albums} />\n+    </>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/artist/[username]/page.js\" highlight={3,8,19} switcher\n+import Albums from './albums'\n+\n+async function getArtist(username) {\n+  const res = await fetch(`https://api.example.com/artist/${username}`)\n+  return res.json()\n+}\n+\n+async function getAlbums(username) {\n+  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\n+  return res.json()\n+}\n+\n+export default async function Page({ params }) {\n+  const { username } = await params\n+  const artistData = getArtist(username)\n+  const albumsData = getAlbums(username)\n+\n+  // Initiate both requests in parallel\n+  const [artist, albums] = await Promise.all([artistData, albumsData])\n+\n+  return (\n+    <>\n+      <h1>{artist.name}</h1>\n+      <Albums list={albums} />\n+    </>\n+  )\n+}\n+```\n+\n+> **Good to know:** If one request fails when using `Promise.all`, the entire operation will fail. To handle this, you can use the [`Promise.allSettled`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled) method instead.\n+\n+### Preloading data\n+\n+You can preload data by creating an utility function that you eagerly call above blocking requests. `<Item>` conditionally renders based on the `checkIsAvailable()` function.\n+\n+You can call `preload()` before `checkIsAvailable()` to eagerly initiate `<Item/>` data dependencies. By the time `<Item/>` is rendered, its data has already been fetched.\n+\n+```tsx filename=\"app/item/[id]/page.tsx\" switcher\n+import { getItem } from '@/lib/data'\n+\n+export default async function Page({\n+  params,\n+}: {\n+  params: Promise<{ id: string }>\n+}) {\n+  const { id } = await params\n+  // starting loading item data\n+  preload(id)\n+  // perform another asynchronous task\n+  const isAvailable = await checkIsAvailable()\n+\n+  return isAvailable ? <Item id={id} /> : null\n+}\n+\n+export const preload = (id: string) => {\n+  // void evaluates the given expression and returns undefined\n+  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n+  void getItem(id)\n+}\n+export async function Item({ id }: { id: string }) {\n+  const result = await getItem(id)\n+  // ...\n+}\n+```\n+\n+```jsx filename=\"app/item/[id]/page.js\" switcher\n+import { getItem } from '@/lib/data'\n+\n+export default async function Page({ params }) {\n+  const { id } = await params\n+  // starting loading item data\n+  preload(id)\n+  // perform another asynchronous task\n+  const isAvailable = await checkIsAvailable()\n+\n+  return isAvailable ? <Item id={id} /> : null\n+}\n+\n+export const preload = (id) => {\n+  // void evaluates the given expression and returns undefined\n+  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n+  void getItem(id)\n+}\n+export async function Item({ id }) {\n+  const result = await getItem(id)\n+  // ...\n+```\n+\n+Additionally, you can use React's [`cache` function](https://react.dev/reference/react/cache) and the [`server-only` package](https://www.npmjs.com/package/server-only) to create a reusable utility function. This approach allows you to cache the data fetching function and ensure that it's only executed on the server.\n+\n+```ts filename=\"utils/get-item.ts\" switcher\n+import { cache } from 'react'\n+import 'server-only'\n+import { getItem } from '@/lib/data'\n+\n+export const preload = (id: string) => {\n+  void getItem(id)\n+}\n+\n+export const getItem = cache(async (id: string) => {\n+  // ...\n+})\n+```\n+\n+```js filename=\"utils/get-item.js\" switcher\n+import { cache } from 'react'\n+import 'server-only'\n+import { getItem } from '@/lib/data'\n+\n+export const preload = (id) => {\n+  void getItem(id)\n+}\n+\n+export const getItem = cache(async (id) => {\n+  // ...\n+})\n+```"
        },
        {
            "sha": "8a423f4c360ce82f12bcc17b6abedd0e9aeada35",
            "filename": "docs/01-app/02-guides/index.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227/docs%2F01-app%2F02-guides%2Findex.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227/docs%2F01-app%2F02-guides%2Findex.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Findex.mdx?ref=f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227",
            "patch": "@@ -5,8 +5,8 @@ description: Learn how to implement common UI patterns and use cases using Next.\n \n ### Data Fetching\n \n-- [Using the `fetch` API](/docs/app/building-your-application/data-fetching/fetching#fetching-data-on-the-server-with-the-fetch-api)\n-- [Using an ORM or database client](/docs/app/building-your-application/data-fetching/fetching#fetching-data-on-the-server-with-an-orm-or-database)\n+- [Using the `fetch` API](/docs/app/getting-started/fetching-data#with-the-fetch-api)\n+- [Using an ORM or database client](/docs/app/getting-started/fetching-data#with-an-orm-or-database)\n - [Reading search params on the server](/docs/app/api-reference/file-conventions/page)\n - [Reading search params on the client](/docs/app/api-reference/functions/use-search-params)\n "
        },
        {
            "sha": "290684a346b1a6bdba700f14a32602d8b0372c88",
            "filename": "docs/01-app/02-guides/production-checklist.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227/docs%2F01-app%2F02-guides%2Fproduction-checklist.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227/docs%2F01-app%2F02-guides%2Fproduction-checklist.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fproduction-checklist.mdx?ref=f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227",
            "patch": "@@ -64,7 +64,7 @@ While building your application, we recommend using the following features to en\n - **[Server Components](/docs/app/building-your-application/data-fetching/fetching):** Leverage the benefits of fetching data on the server using Server Components.\n - **[Route Handlers](/docs/app/building-your-application/routing/route-handlers):** Use Route Handlers to access your backend resources from Client Components. But do not call Route Handlers from Server Components to avoid an additional server request.\n - **[Streaming](/docs/app/building-your-application/routing/loading-ui-and-streaming):** Use Loading UI and React Suspense to progressively send UI from the server to the client, and prevent the whole route from blocking while data is being fetched.\n-- **[Parallel Data Fetching](/docs/app/building-your-application/data-fetching/fetching#parallel-and-sequential-data-fetching):** Reduce network waterfalls by fetching data in parallel, where appropriate. Also, consider [preloading data](/docs/app/building-your-application/data-fetching/fetching#preloading-data) where appropriate.\n+- **[Parallel Data Fetching](/docs/app/getting-started/fetching-data#parallel-data-fetching):** Reduce network waterfalls by fetching data in parallel, where appropriate. Also, consider [preloading data](/docs/app/getting-started/fetching-data#preloading-data) where appropriate.\n - **[Data Caching](/docs/app/deep-dive/caching#data-cache):** Verify whether your data requests are being cached or not, and opt into caching, where appropriate. Ensure requests that don't use `fetch` are [cached](/docs/app/api-reference/functions/unstable_cache).\n - **[Static Images](/docs/app/api-reference/file-conventions/public-folder):** Use the `public` directory to automatically cache your application's static assets, e.g. images.\n \n@@ -96,7 +96,7 @@ While building your application, we recommend using the following features to en\n \n <AppOnly>\n \n-- **[Tainting](/docs/app/building-your-application/data-fetching/fetching#preventing-sensitive-data-from-being-exposed-to-the-client):** Prevent sensitive data from being exposed to the client by tainting data objects and/or specific values.\n+- **[Tainting](/docs/app/api-reference/config/next-config-js/taint):** Prevent sensitive data from being exposed to the client by tainting data objects and/or specific values.\n - **[Server Actions](/docs/app/building-your-application/data-fetching/server-actions-and-mutations#authentication-and-authorization):** Ensure users are authorized to call Server Actions. Review the recommended [security practices](/blog/security-nextjs-server-components-actions).\n \n </AppOnly>"
        },
        {
            "sha": "5f80df24350e0be4527bc91b33972fefbe316c51",
            "filename": "docs/01-app/03-building-your-application/02-data-fetching/01-fetching.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 518,
            "changes": 519,
            "blob_url": "https://github.com/vercel/next.js/blob/f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227/docs%2F01-app%2F03-building-your-application%2F02-data-fetching%2F01-fetching.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227/docs%2F01-app%2F03-building-your-application%2F02-data-fetching%2F01-fetching.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-building-your-application%2F02-data-fetching%2F01-fetching.mdx?ref=f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227",
            "patch": "@@ -53,158 +53,6 @@ This example demonstrates a basic server-side data fetch using the `fetch` API i\n - React [`cache`](https://react.dev/reference/react/cache)\n - Next.js [`unstable_cache`](/docs/app/api-reference/functions/unstable_cache)\n \n-## Examples\n-\n-### Fetching data on the server with the `fetch` API\n-\n-This component will fetch and display a list of blog posts. The response from `fetch` is not cached by default.\n-\n-```tsx filename=\"app/page.tsx\" switcher\n-export default async function Page() {\n-  const data = await fetch('https://api.vercel.app/blog')\n-  const posts = await data.json()\n-  return (\n-    <ul>\n-      {posts.map((post) => (\n-        <li key={post.id}>{post.title}</li>\n-      ))}\n-    </ul>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/page.js\" switcher\n-export default async function Page() {\n-  const data = await fetch('https://api.vercel.app/blog')\n-  const posts = await data.json()\n-  return (\n-    <ul>\n-      {posts.map((post) => (\n-        <li key={post.id}>{post.title}</li>\n-      ))}\n-    </ul>\n-  )\n-}\n-```\n-\n-If you are not using any [Dynamic APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering) anywhere else in this route, it will be prerendered during `next build` to a static page. The data can then be updated using [Incremental Static Regeneration](/docs/app/guides/incremental-static-regeneration).\n-\n-To prevent the page from prerendering, you can add the following to your file:\n-\n-```js\n-export const dynamic = 'force-dynamic'\n-```\n-\n-However, you will commonly use functions like `cookies`, `headers`, or reading the incoming `searchParams` from the page props, which will automatically make the page render dynamically. In this case, you do _not_ need to explicitly use `force-dynamic`.\n-\n-### Fetching data on the server with an ORM or database\n-\n-This component will fetch and display a list of blog posts. The response from the database is not cached by default but could be with [additional configuration](#caching-data-with-an-orm-or-database).\n-\n-```tsx filename=\"app/page.tsx\" switcher\n-import { db, posts } from '@/lib/db'\n-\n-export default async function Page() {\n-  const allPosts = await db.select().from(posts)\n-  return (\n-    <ul>\n-      {allPosts.map((post) => (\n-        <li key={post.id}>{post.title}</li>\n-      ))}\n-    </ul>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/page.js\" switcher\n-import { db, posts } from '@/lib/db'\n-\n-export default async function Page() {\n-  const allPosts = await db.select().from(posts)\n-  return (\n-    <ul>\n-      {allPosts.map((post) => (\n-        <li key={post.id}>{post.title}</li>\n-      ))}\n-    </ul>\n-  )\n-}\n-```\n-\n-If you are not using any [Dynamic APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering) anywhere else in this route, it will be prerendered during `next build` to a static page. The data can then be updated using [Incremental Static Regeneration](/docs/app/guides/incremental-static-regeneration).\n-\n-To prevent the page from prerendering, you can add the following to your file:\n-\n-```js\n-export const dynamic = 'force-dynamic'\n-```\n-\n-However, you will commonly use functions like `cookies`, `headers`, or reading the incoming `searchParams` from the page props, which will automatically make the page render dynamically. In this case, you do _not_ need to explicitly use `force-dynamic`.\n-\n-### Fetching data on the client\n-\n-We recommend first attempting to fetch data on the server-side.\n-\n-However, there are still cases where client-side data fetching makes sense. In these scenarios, you can manually call `fetch` in a `useEffect` (not recommended), or lean on popular React libraries in the community (such as [SWR](https://swr.vercel.app/) or [React Query](https://tanstack.com/query/latest)) for client fetching.\n-\n-```tsx filename=\"app/page.tsx\" switcher\n-'use client'\n-\n-import { useState, useEffect } from 'react'\n-\n-export function Posts() {\n-  const [posts, setPosts] = useState(null)\n-\n-  useEffect(() => {\n-    async function fetchPosts() {\n-      const res = await fetch('https://api.vercel.app/blog')\n-      const data = await res.json()\n-      setPosts(data)\n-    }\n-    fetchPosts()\n-  }, [])\n-\n-  if (!posts) return <div>Loading...</div>\n-\n-  return (\n-    <ul>\n-      {posts.map((post) => (\n-        <li key={post.id}>{post.title}</li>\n-      ))}\n-    </ul>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/page.js\" switcher\n-'use client'\n-\n-import { useState, useEffect } from 'react'\n-\n-export function Posts() {\n-  const [posts, setPosts] = useState(null)\n-\n-  useEffect(() => {\n-    async function fetchPosts() {\n-      const res = await fetch('https://api.vercel.app/blog')\n-      const data = await res.json()\n-      setPosts(data)\n-    }\n-    fetchPosts()\n-  }, [])\n-\n-  if (!posts) return <div>Loading...</div>\n-\n-  return (\n-    <ul>\n-      {posts.map((post) => (\n-        <li key={post.id}>{post.title}</li>\n-      ))}\n-    </ul>\n-  )\n-}\n-```\n-\n ### Caching data with an ORM or Database\n \n You can use the `unstable_cache` API to cache the response when running `next build`.\n@@ -390,369 +238,4 @@ export const getPost = cache(async (id) => {\n \n ### Revalidating cached data\n \n-Learn more about revalidating cached data with [Incremental Static Regeneration](/docs/app/guides/incremental-static-regeneration).\n-\n-## Patterns\n-\n-### Parallel and sequential data fetching\n-\n-When fetching data inside components, you need to be aware of two data fetching patterns: Parallel and Sequential.\n-\n-<Image\n-  alt=\"Sequential and Parallel Data Fetching\"\n-  srcLight=\"/docs/light/sequential-parallel-data-fetching.png\"\n-  srcDark=\"/docs/dark/sequential-parallel-data-fetching.png\"\n-  width=\"1600\"\n-  height=\"525\"\n-/>\n-\n-- **Sequential**: requests in a component tree are dependent on each other. This can lead to longer loading times.\n-- **Parallel**: requests in a route are eagerly initiated and will load data at the same time. This reduces the total time it takes to load data.\n-\n-#### Sequential data fetching\n-\n-If you have nested components, and each component fetches its own data, then data fetching will happen sequentially if those data requests are not [memoized](/docs/app/deep-dive/caching#request-memoization).\n-\n-There may be cases where you want this pattern because one fetch depends on the result of the other. For example, the `Playlists` component will only start fetching data once the `Artist` component has finished fetching data because `Playlists` depends on the `artistID` prop:\n-\n-```tsx filename=\"app/artist/[username]/page.tsx\" switcher\n-export default async function Page({\n-  params,\n-}: {\n-  params: Promise<{ username: string }>\n-}) {\n-  const { username } = await params\n-  // Get artist information\n-  const artist = await getArtist(username)\n-\n-  return (\n-    <>\n-      <h1>{artist.name}</h1>\n-      {/* Show fallback UI while the Playlists component is loading */}\n-      <Suspense fallback={<div>Loading...</div>}>\n-        {/* Pass the artist ID to the Playlists component */}\n-        <Playlists artistID={artist.id} />\n-      </Suspense>\n-    </>\n-  )\n-}\n-\n-async function Playlists({ artistID }: { artistID: string }) {\n-  // Use the artist ID to fetch playlists\n-  const playlists = await getArtistPlaylists(artistID)\n-\n-  return (\n-    <ul>\n-      {playlists.map((playlist) => (\n-        <li key={playlist.id}>{playlist.name}</li>\n-      ))}\n-    </ul>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/artist/[username]/page.js\" switcher\n-export default async function Page({ params }) {\n-  const { username } = await params\n-  // Get artist information\n-  const artist = await getArtist(username)\n-\n-  return (\n-    <>\n-      <h1>{artist.name}</h1>\n-      {/* Show fallback UI while the Playlists component is loading */}\n-      <Suspense fallback={<div>Loading...</div>}>\n-        {/* Pass the artist ID to the Playlists component */}\n-        <Playlists artistID={artist.id} />\n-      </Suspense>\n-    </>\n-  )\n-}\n-\n-async function Playlists({ artistID }) {\n-  // Use the artist ID to fetch playlists\n-  const playlists = await getArtistPlaylists(artistID)\n-\n-  return (\n-    <ul>\n-      {playlists.map((playlist) => (\n-        <li key={playlist.id}>{playlist.name}</li>\n-      ))}\n-    </ul>\n-  )\n-}\n-```\n-\n-You can use [`loading.js`](/docs/app/building-your-application/routing/loading-ui-and-streaming) (for route segments) or [React `<Suspense>`](/docs/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense) (for nested components) to show an instant loading state while React streams in the result.\n-\n-This will prevent the whole route from being blocked by data requests, and the user will be able to interact with the parts of the page that are ready.\n-\n-#### Parallel Data Fetching\n-\n-By default, layout and page segments are rendered in parallel. This means requests will be initiated in parallel.\n-\n-However, due to the nature of `async`/`await`, an awaited request inside the same segment or component will block any requests below it.\n-\n-To fetch data in parallel, you can eagerly initiate requests by defining them outside the components that use the data. This saves time by initiating both requests in parallel, however, the user won't see the rendered result until both promises are resolved.\n-\n-In the example below, the `getArtist` and `getAlbums` functions are defined outside the `Page` component and initiated inside the component using `Promise.all`:\n-\n-```tsx filename=\"app/artist/[username]/page.tsx\" switcher\n-import Albums from './albums'\n-\n-async function getArtist(username: string) {\n-  const res = await fetch(`https://api.example.com/artist/${username}`)\n-  return res.json()\n-}\n-\n-async function getAlbums(username: string) {\n-  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\n-  return res.json()\n-}\n-\n-export default async function Page({\n-  params,\n-}: {\n-  params: Promise<{ username: string }>\n-}) {\n-  const { username } = await params\n-  const artistData = getArtist(username)\n-  const albumsData = getAlbums(username)\n-\n-  // Initiate both requests in parallel\n-  const [artist, albums] = await Promise.all([artistData, albumsData])\n-\n-  return (\n-    <>\n-      <h1>{artist.name}</h1>\n-      <Albums list={albums} />\n-    </>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/artist/[username]/page.js\" switcher\n-import Albums from './albums'\n-\n-async function getArtist(username) {\n-  const res = await fetch(`https://api.example.com/artist/${username}`)\n-  return res.json()\n-}\n-\n-async function getAlbums(username) {\n-  const res = await fetch(`https://api.example.com/artist/${username}/albums`)\n-  return res.json()\n-}\n-\n-export default async function Page({ params }) {\n-  const { username } = await params\n-  const artistData = getArtist(username)\n-  const albumsData = getAlbums(username)\n-\n-  // Initiate both requests in parallel\n-  const [artist, albums] = await Promise.all([artistData, albumsData])\n-\n-  return (\n-    <>\n-      <h1>{artist.name}</h1>\n-      <Albums list={albums} />\n-    </>\n-  )\n-}\n-```\n-\n-In addition, you can add a [Suspense Boundary](/docs/app/building-your-application/routing/loading-ui-and-streaming) to break up the rendering work and show part of the result as soon as possible.\n-\n-### Preloading Data\n-\n-Another way to prevent waterfalls is to use the _preload_ pattern by creating an utility function that you eagerly call above blocking requests. For example, `checkIsAvailable()` blocks `<Item/>` from rendering, so you can call `preload()` before it to eagerly initiate `<Item/>` data dependencies. By the time `<Item/>` is rendered, its data has already been fetched.\n-\n-Note that `preload` function doesn't block `checkIsAvailable()` from running.\n-\n-```tsx filename=\"components/Item.tsx\" switcher\n-import { getItem } from '@/utils/get-item'\n-\n-export const preload = (id: string) => {\n-  // void evaluates the given expression and returns undefined\n-  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n-  void getItem(id)\n-}\n-export default async function Item({ id }: { id: string }) {\n-  const result = await getItem(id)\n-  // ...\n-}\n-```\n-\n-```jsx filename=\"components/Item.js\" switcher\n-import { getItem } from '@/utils/get-item'\n-\n-export const preload = (id) => {\n-  // void evaluates the given expression and returns undefined\n-  // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/void\n-  void getItem(id)\n-}\n-export default async function Item({ id }) {\n-  const result = await getItem(id)\n-  // ...\n-}\n-```\n-\n-```tsx filename=\"app/item/[id]/page.tsx\" switcher\n-import Item, { preload, checkIsAvailable } from '@/components/Item'\n-\n-export default async function Page({\n-  params,\n-}: {\n-  params: Promise<{ id: string }>\n-}) {\n-  const { id } = await params\n-  // starting loading item data\n-  preload(id)\n-  // perform another asynchronous task\n-  const isAvailable = await checkIsAvailable()\n-\n-  return isAvailable ? <Item id={id} /> : null\n-}\n-```\n-\n-```jsx filename=\"app/item/[id]/page.js\" switcher\n-import Item, { preload, checkIsAvailable } from '@/components/Item'\n-\n-export default async function Page({ params }) {\n-  const { id } = await params\n-  // starting loading item data\n-  preload(id)\n-  // perform another asynchronous task\n-  const isAvailable = await checkIsAvailable()\n-\n-  return isAvailable ? <Item id={id} /> : null\n-}\n-```\n-\n-> **Good to know:** The \"preload\" function can also have any name as it's a pattern, not an API.\n-\n-#### Using React `cache` and `server-only` with the Preload Pattern\n-\n-You can combine the `cache` function, the `preload` pattern, and the `server-only` package to create a data fetching utility that can be used throughout your app.\n-\n-```ts filename=\"utils/get-item.ts\" switcher\n-import { cache } from 'react'\n-import 'server-only'\n-\n-export const preload = (id: string) => {\n-  void getItem(id)\n-}\n-\n-export const getItem = cache(async (id: string) => {\n-  // ...\n-})\n-```\n-\n-```js filename=\"utils/get-item.js\" switcher\n-import { cache } from 'react'\n-import 'server-only'\n-\n-export const preload = (id) => {\n-  void getItem(id)\n-}\n-\n-export const getItem = cache(async (id) => {\n-  // ...\n-})\n-```\n-\n-With this approach, you can eagerly fetch data, cache responses, and guarantee that this data fetching [only happens on the server](/docs/app/getting-started/server-and-client-components#examples#keeping-server-only-code-out-of-the-client-environment).\n-\n-The `utils/get-item` exports can be used by Layouts, Pages, or other components to give them control over when an item's data is fetched.\n-\n-> **Good to know:**\n->\n-> - We recommend using the [`server-only` package](/docs/app/getting-started/server-and-client-components#examples#keeping-server-only-code-out-of-the-client-environment) to make sure server data fetching functions are never used on the client.\n-\n-### Preventing sensitive data from being exposed to the client\n-\n-We recommend using React's taint APIs, [`taintObjectReference`](https://react.dev/reference/react/experimental_taintObjectReference) and [`taintUniqueValue`](https://react.dev/reference/react/experimental_taintUniqueValue), to prevent whole object instances or sensitive values from being passed to the client.\n-\n-To enable tainting in your application, set the Next.js Config `experimental.taint` option to `true`:\n-\n-```js filename=\"next.config.js\"\n-module.exports = {\n-  experimental: {\n-    taint: true,\n-  },\n-}\n-```\n-\n-Then pass the object or value you want to taint to the `experimental_taintObjectReference` or `experimental_taintUniqueValue` functions:\n-\n-```ts filename=\"app/utils.ts\" switcher\n-import { queryDataFromDB } from './api'\n-import {\n-  experimental_taintObjectReference,\n-  experimental_taintUniqueValue,\n-} from 'react'\n-\n-export async function getUserData() {\n-  const data = await queryDataFromDB()\n-  experimental_taintObjectReference(\n-    'Do not pass the whole user object to the client',\n-    data\n-  )\n-  experimental_taintUniqueValue(\n-    \"Do not pass the user's address to the client\",\n-    data,\n-    data.address\n-  )\n-  return data\n-}\n-```\n-\n-```js filename=\"app/utils.js\" switcher\n-import { queryDataFromDB } from './api'\n-import {\n-  experimental_taintObjectReference,\n-  experimental_taintUniqueValue,\n-} from 'react'\n-\n-export async function getUserData() {\n-  const data = await queryDataFromDB()\n-  experimental_taintObjectReference(\n-    'Do not pass the whole user object to the client',\n-    data\n-  )\n-  experimental_taintUniqueValue(\n-    \"Do not pass the user's address to the client\",\n-    data,\n-    data.address\n-  )\n-  return data\n-}\n-```\n-\n-```tsx filename=\"app/page.tsx\" switcher\n-import { getUserData } from './data'\n-\n-export async function Page() {\n-  const userData = getUserData()\n-  return (\n-    <ClientComponent\n-      user={userData} // this will cause an error because of taintObjectReference\n-      address={userData.address} // this will cause an error because of taintUniqueValue\n-    />\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/page.js\" switcher\n-import { getUserData } from './data'\n-\n-export async function Page() {\n-  const userData = await getUserData()\n-  return (\n-    <ClientComponent\n-      user={userData} // this will cause an error because of taintObjectReference\n-      address={userData.address} // this will cause an error because of taintUniqueValue\n-    />\n-  )\n-}\n-```\n+Learn more about revalidating cached data with [Incremental Static Regeneration](/docs/app/building-your-application/data-fetching/incremental-static-regeneration)."
        },
        {
            "sha": "9ab7fb73dc880cfb4a79ae7471a3cfde8278e905",
            "filename": "docs/01-app/03-building-your-application/02-data-fetching/03-server-actions-and-mutations.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227/docs%2F01-app%2F03-building-your-application%2F02-data-fetching%2F03-server-actions-and-mutations.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227/docs%2F01-app%2F03-building-your-application%2F02-data-fetching%2F03-server-actions-and-mutations.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-building-your-application%2F02-data-fetching%2F03-server-actions-and-mutations.mdx?ref=f8bbb5e0ed0d727cdaa5491f0e6b102ac03cf227",
            "patch": "@@ -973,7 +973,7 @@ Closures are useful when you need to capture a _snapshot_ of data (e.g. `publish\n \n However, for this to happen, the captured variables are sent to the client and back to the server when the action is invoked. To prevent sensitive data from being exposed to the client, Next.js automatically encrypts the closed-over variables. A new private key is generated for each action every time a Next.js application is built. This means actions can only be invoked for a specific build.\n \n-> **Good to know:** We don't recommend relying on encryption alone to prevent sensitive values from being exposed on the client. Instead, you should use the [React taint APIs](/docs/app/building-your-application/data-fetching/fetching#preventing-sensitive-data-from-being-exposed-to-the-client) to proactively prevent specific data from being sent to the client.\n+> **Good to know:** We don't recommend relying on encryption alone to prevent sensitive values from being exposed on the client. Instead, you should use the [React taint APIs](/docs/app/api-reference/config/next-config-js/taint) to proactively prevent specific data from being sent to the client.\n \n ### Overwriting encryption keys (advanced)\n "
        }
    ],
    "stats": {
        "total": 802,
        "additions": 278,
        "deletions": 524
    }
}