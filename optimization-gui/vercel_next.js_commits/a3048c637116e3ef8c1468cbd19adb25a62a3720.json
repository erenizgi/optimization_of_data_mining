{
    "author": "bgw",
    "message": "Turbopack: Create junction points instead of symlinks on Windows (#87606)\n\nNext 16.1 changed Turbopack's external packaging to use symlinks.\n\nSymlinks require elevated privileges on Windows if \"Developer Mode\" is\nnot enabled. We can work around this by using junction points, which are\nmostly equivalent, but:\n\n- They only work with directories.\n- They can only point to absolute paths, not relative paths.\n\nFixes #87334\nFixes #87607\nFixes #87603\nFixes #87605\nFixes #87559\nFixes #87604\nFixes #87601\nFixes #87599\nFixes #87598\nFixes #87596\nFixes #87595\nFixes #87592\nFixes #87590\nFixes #87589\nFixes #87473\nFixes #87586\nFixes #87585\nFixes #87584\nFixes #87583\nFixes #87582\nFixes #87576\nFixes #87575\nFixes #87574\nFixes #87573\nFixes #87572\nFixes #87571\nFixes #87568\n... and many more\n\nAlso:\nFixes #69858 (related issue about `output: 'standalone'` on Windows.\n\n## Testing\n\n- Disable Developer Mode on Windows, reboot, and then verify that\nsymlink creation fails.\n- Make a payload app with `pnpx create-payload-app` (just pick sqlite\nfor the database when prompted), and then update the app with `pnpx\n@next/codemod upgrade 16.1.0`.\n- Add `output: 'standalone'` to the `next.config.js`.\n- Try running `pnpm build`\n\n---------\n\nCo-authored-by: Tobias Koppers <tobias.koppers@googlemail.com>",
    "sha": "a3048c637116e3ef8c1468cbd19adb25a62a3720",
    "files": [
        {
            "sha": "383f557aea57cddae084dde238ff928fe74ee5e1",
            "filename": "packages/next/src/build/utils.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 3,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/a3048c637116e3ef8c1468cbd19adb25a62a3720/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/a3048c637116e3ef8c1468cbd19adb25a62a3720/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Futils.ts?ref=a3048c637116e3ef8c1468cbd19adb25a62a3720",
            "patch": "@@ -1274,9 +1274,29 @@ export async function copyTracedFiles(\n           if (symlink) {\n             try {\n               await fs.symlink(symlink, fileOutputPath)\n-            } catch (e: any) {\n-              if (e.code !== 'EEXIST') {\n-                throw e\n+            } catch (err: any) {\n+              // Windows doesn't support creating symlinks without elevated privileges, unless\n+              // \"Developer Mode\" is turned on. If we failed to crate a symlink due to EPERM, try\n+              // creating a junction point instead.\n+              //\n+              // Ideally we'd just preserve the input file type (junction point or symlink), but\n+              // there's no API in node.js to differentiate between a junction point and a symlink,\n+              // so we just try making a symlink first. Symlinks are preferred because they support\n+              // relative paths and non-directory (file) targets.\n+              if (\n+                process.platform === 'win32' &&\n+                err.code === 'EPERM' &&\n+                path.isAbsolute(symlink)\n+              ) {\n+                try {\n+                  await fs.symlink(symlink, fileOutputPath, 'junction')\n+                } catch (junctionErr: any) {\n+                  if (junctionErr.code !== 'EEXIST') {\n+                    throw junctionErr\n+                  }\n+                }\n+              } else if (err.code !== 'EEXIST') {\n+                throw err\n               }\n             }\n           } else {"
        },
        {
            "sha": "c342300570b1a48cf0a3bb2a062cfdd432502c78",
            "filename": "turbopack/crates/turbo-tasks-fs/src/attach.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/a3048c637116e3ef8c1468cbd19adb25a62a3720/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fattach.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3048c637116e3ef8c1468cbd19adb25a62a3720/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fattach.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fattach.rs?ref=a3048c637116e3ef8c1468cbd19adb25a62a3720",
            "patch": "@@ -130,7 +130,10 @@ impl FileSystem for AttachedFileSystem {\n         path: FileSystemPath,\n         target: Vc<LinkContent>,\n     ) -> Result<Vc<()>> {\n-        Ok(self.get_inner_fs_path(path).await?.write_link(target))\n+        Ok(self\n+            .get_inner_fs_path(path)\n+            .await?\n+            .write_symbolic_link_dir(target))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "d58f9920d3438dc68babd4ddf517969d9ee55eeb",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 148,
            "deletions": 63,
            "changes": 211,
            "blob_url": "https://github.com/vercel/next.js/blob/a3048c637116e3ef8c1468cbd19adb25a62a3720/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3048c637116e3ef8c1468cbd19adb25a62a3720/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=a3048c637116e3ef8c1468cbd19adb25a62a3720",
            "patch": "@@ -8,6 +8,9 @@\n // stdlib into our source tree\n #![feature(normalize_lexically)]\n #![feature(trivial_bounds)]\n+// Junction points are used on Windows. We could use a third-party crate for this if the junction\n+// API isn't eventually stabilized.\n+#![cfg_attr(windows, feature(junction_point))]\n #![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n #![allow(clippy::mutable_key_type)]\n \n@@ -120,7 +123,7 @@ pub const MAX_SAFE_FILE_NAME_LENGTH: usize = 200;\n pub fn validate_path_length(path: &Path) -> Result<Cow<'_, Path>> {\n     /// Here we check if the path is too long for windows, and if so, attempt to canonicalize it\n     /// to a UNC path.\n-    #[cfg(target_family = \"windows\")]\n+    #[cfg(windows)]\n     fn validate_path_length_inner(path: &Path) -> Result<Cow<'_, Path>> {\n         const MAX_PATH_LENGTH_WINDOWS: usize = 260;\n         const UNC_PREFIX: &str = \"\\\\\\\\?\\\\\";\n@@ -141,7 +144,7 @@ pub fn validate_path_length(path: &Path) -> Result<Cow<'_, Path>> {\n     /// Here we are only going to check if the total length exceeds, or the last segment exceeds.\n     /// This heuristic is primarily to avoid long file names, and it makes the operation much\n     /// cheaper.\n-    #[cfg(not(target_family = \"windows\"))]\n+    #[cfg(not(windows))]\n     fn validate_path_length_inner(path: &Path) -> Result<Cow<'_, Path>> {\n         const MAX_FILE_NAME_LENGTH_UNIX: usize = 255;\n         // macOS reports a limit of 1024, but I (@arlyon) have had issues with paths above 1016\n@@ -240,6 +243,7 @@ pub trait FileSystem: ValueToString {\n     fn raw_read_dir(self: Vc<Self>, fs_path: FileSystemPath) -> Vc<RawDirectoryContent>;\n     #[turbo_tasks::function]\n     fn write(self: Vc<Self>, fs_path: FileSystemPath, content: Vc<FileContent>) -> Vc<()>;\n+    /// See [`FileSystemPath::write_symbolic_link_dir`].\n     #[turbo_tasks::function]\n     fn write_link(self: Vc<Self>, fs_path: FileSystemPath, target: Vc<LinkContent>) -> Vc<()>;\n     #[turbo_tasks::function]\n@@ -819,13 +823,13 @@ impl FileSystem for DiskFileSystem {\n             if let Some(normalized_linked_path) = full_path.parent().and_then(|p| {\n                 normalize_path(&sys_to_unix(p.join(&file).to_string_lossy().as_ref()))\n             }) {\n-                #[cfg(target_family = \"windows\")]\n+                #[cfg(windows)]\n                 {\n                     file = PathBuf::from(normalized_linked_path);\n                 }\n                 // `normalize_path` stripped the leading `/` of the path\n                 // add it back here or the `strip_prefix` will return `Err`\n-                #[cfg(not(target_family = \"windows\"))]\n+                #[cfg(not(windows))]\n                 {\n                     file = PathBuf::from(format!(\"/{normalized_linked_path}\"));\n                 }\n@@ -966,7 +970,7 @@ impl FileSystem for DiskFileSystem {\n                             unreachable!()\n                         };\n                         std::io::copy(&mut file.read(), &mut f)?;\n-                        #[cfg(target_family = \"unix\")]\n+                        #[cfg(unix)]\n                         f.set_permissions(file.meta.permissions.into())?;\n                         f.flush()?;\n \n@@ -986,7 +990,7 @@ impl FileSystem for DiskFileSystem {\n                             full_path.set_extension(ext);\n                             let mut f = std::fs::File::create(&full_path)?;\n                             std::io::copy(&mut file.read(), &mut f)?;\n-                            #[cfg(target_family = \"unix\")]\n+                            #[cfg(unix)]\n                             f.set_permissions(file.meta.permissions.into())?;\n                             f.flush()?;\n                         }\n@@ -1031,9 +1035,9 @@ impl FileSystem for DiskFileSystem {\n \n     #[turbo_tasks::function(fs)]\n     async fn write_link(&self, fs_path: FileSystemPath, target: Vc<LinkContent>) -> Result<()> {\n-        // You might be tempted to use `mark_session_dependent` here, but\n-        // `write_link` purely declares a side effect and does not need to be reexecuted in the next\n-        // session. All side effects are reexecuted in general.\n+        // You might be tempted to use `mark_session_dependent` here, but we purely declare a side\n+        // effect and does not need to be re-executed in the next session. All side effects are\n+        // re-executed in general.\n \n         // Check if path is denied - if so, return an error\n         if self.inner.is_path_denied(&fs_path) {\n@@ -1042,9 +1046,10 @@ impl FileSystem for DiskFileSystem {\n                 fs_path.value_to_string().await?\n             );\n         }\n-        let full_path = self.to_sys_path(&fs_path);\n \n         let content = target.await?;\n+\n+        let full_path = self.to_sys_path(&fs_path);\n         let inner = self.inner.clone();\n         let invalidator = turbo_tasks::get_invalidator();\n \n@@ -1064,7 +1069,7 @@ impl FileSystem for DiskFileSystem {\n                 .transpose()?\n                 .unwrap_or_default();\n \n-            // TODO(sokra) preform a untracked read here, register an invalidator and get\n+            // TODO(sokra) perform a untracked read here, register an invalidator and get\n             // all existing invalidators\n             let old_content = match retry_blocking(full_path.clone().into_owned(), |path| {\n                 std::fs::read_link(path)\n@@ -1080,8 +1085,17 @@ impl FileSystem for DiskFileSystem {\n                 Err(_) => None,\n             };\n             let is_equal = match (&*content, &old_content) {\n+                // TODO(bgw): Is this logic correct? This might give us `is_equal = false` when it\n+                // shouldn't, and cause us to do extra work.\n+                // - `old_content` may have windows path separators, but `LinkContent` normalizes\n+                //   them.\n+                // - Windows junction points are always transformed to absolute before being stored.\n+                // - `LinkContent`'s target field stores absolute paths as relative to the project\n+                //   root, but `old_target` is relative to the real filesystem's root.\n+                // We should compute the final target `Path` first, and then it with that value, not\n+                // the normalized format stored in\n                 (LinkContent::Link { target, link_type }, Some((old_is_absolute, old_target))) => {\n-                    Path::new(&**target) == old_target\n+                    Path::new(target) == old_target\n                         && link_type.contains(LinkType::ABSOLUTE) == *old_is_absolute\n                 }\n                 (LinkContent::NotFound, None) => true,\n@@ -1102,6 +1116,23 @@ impl FileSystem for DiskFileSystem {\n \n             match &*content {\n                 LinkContent::Link { target, link_type } => {\n+                    let is_directory = link_type.contains(LinkType::DIRECTORY);\n+                    let target_path = if link_type.contains(LinkType::ABSOLUTE) {\n+                        Path::new(&inner.root).join(unix_to_sys(target).as_ref())\n+                    } else {\n+                        let relative_target = PathBuf::from(unix_to_sys(target).as_ref());\n+                        if cfg!(windows) && is_directory {\n+                            // Windows junction points must always be stored as absolute\n+                            full_path\n+                                .parent()\n+                                .unwrap_or(&full_path)\n+                                .join(relative_target)\n+                        } else {\n+                            relative_target\n+                        }\n+                    };\n+                    let full_path = full_path.into_owned();\n+\n                     let create_directory = old_content.is_none();\n                     if create_directory && let Some(parent) = full_path.parent() {\n                         inner.create_directory(parent).await.with_context(|| {\n@@ -1113,28 +1144,13 @@ impl FileSystem for DiskFileSystem {\n                         })?;\n                     }\n \n-                    let link_type = *link_type;\n-                    let target_path = if link_type.contains(LinkType::ABSOLUTE) {\n-                        Path::new(&inner.root).join(unix_to_sys(target).as_ref())\n-                    } else {\n-                        PathBuf::from(unix_to_sys(target).as_ref())\n-                    };\n-                    let full_path = full_path.into_owned();\n-\n                     if old_content.is_some() {\n-                        // Remove existing symlink before creating a new one. At least on Unix,\n-                        // symlink(2) fails with EEXIST if the link already exists instead of\n-                        // overwriting it\n-                        retry_blocking(full_path.clone(), |path| std::fs::remove_file(path))\n+                        // Remove existing symlink before creating a new one. On Unix, symlink(2)\n+                        // fails with EEXIST if the link already exists instead of overwriting it.\n+                        // Windows has similar behavior with junction points.\n+                        remove_symbolic_link_dir_helper(&full_path)\n                             .concurrency_limited(&inner.write_semaphore)\n                             .await\n-                            .or_else(|err| {\n-                                if err.kind() == ErrorKind::NotFound {\n-                                    Ok(())\n-                                } else {\n-                                    Err(err)\n-                                }\n-                            })\n                             .with_context(|| {\n                                 anyhow!(\"removing existing symlink {} failed\", full_path.display())\n                             })?;\n@@ -1146,41 +1162,43 @@ impl FileSystem for DiskFileSystem {\n                             name = display(target_path.display())\n                         )\n                         .entered();\n-                        // we use the sync std method here because `symlink` is fast\n-                        // if we put it into a task, it will be slower\n-                        #[cfg(not(target_family = \"windows\"))]\n+                        #[cfg(not(windows))]\n                         {\n                             std::os::unix::fs::symlink(target_path, &full_path)\n                         }\n-                        #[cfg(target_family = \"windows\")]\n+                        #[cfg(windows)]\n                         {\n-                            if link_type.contains(LinkType::DIRECTORY) {\n-                                std::os::windows::fs::symlink_dir(target_path, &full_path)\n+                            if is_directory {\n+                                std::os::windows::fs::junction_point(target_path, &full_path)\n                             } else {\n                                 std::os::windows::fs::symlink_file(target_path, &full_path)\n                             }\n                         }\n                     })\n                     .await\n-                    .with_context(|| format!(\"create symlink to {target}\"))?;\n+                    .with_context(|| {\n+                        #[cfg(not(windows))]\n+                        let message = format!(\"failed to create symlink to {target}\");\n+                        #[cfg(windows)]\n+                        let message = if is_directory {\n+                            format!(\"failed to create junction point to {target}\")\n+                        } else {\n+                            format!(\n+                                \"failed to create symlink to {target}\\n\\\n+                                (Note: creating file symlinks on Windows require developer mode or admin permissions: https://learn.microsoft.com/en-us/windows/advanced-settings/developer-mode)\"\n+                            )\n+                        };\n+                        message\n+                    })?;\n                 }\n                 LinkContent::Invalid => {\n-                    anyhow::bail!(\"invalid symlink target: {}\", full_path.display())\n+                    bail!(\"invalid symlink target: {}\", full_path.display())\n                 }\n                 LinkContent::NotFound => {\n-                    retry_blocking(full_path.clone().into_owned(), |path| {\n-                        std::fs::remove_file(path)\n-                    })\n-                    .concurrency_limited(&inner.write_semaphore)\n-                    .await\n-                    .or_else(|err| {\n-                        if err.kind() == ErrorKind::NotFound {\n-                            Ok(())\n-                        } else {\n-                            Err(err)\n-                        }\n-                    })\n-                    .with_context(|| anyhow!(\"removing {} failed\", full_path.display()))?;\n+                    remove_symbolic_link_dir_helper(&full_path)\n+                        .concurrency_limited(&inner.write_semaphore)\n+                        .await\n+                        .with_context(|| anyhow!(\"removing {} failed\", full_path.display()))?;\n                 }\n             }\n \n@@ -1218,6 +1236,44 @@ impl FileSystem for DiskFileSystem {\n     }\n }\n \n+async fn remove_symbolic_link_dir_helper(path: impl AsRef<Path>) -> Result<()> {\n+    let path = path.as_ref();\n+    retry_blocking(path.to_owned(), move |path| {\n+        if cfg!(windows) {\n+            // Junction points on Windows are treated as directories, and therefore need\n+            // `remove_dir`:\n+            //\n+            // > `RemoveDirectory` can be used to remove a directory junction. Since the target\n+            // > directory and its contents will remain accessible through its canonical path, the\n+            // > target directory itself is not affected by removing a junction which targets it.\n+            //\n+            // -- https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-removedirectoryw\n+            //\n+            // However, Next 16.1.0 shipped with symlinks, before we switched to junction links on\n+            // Windows, and `remove_dir` won't work on symlinks. So try to remove it as a directory\n+            // (junction) first, and then fall back to removing it as a file (symlink).\n+            std::fs::remove_dir(path).or_else(|err| {\n+                if err.kind() == ErrorKind::NotADirectory {\n+                    std::fs::remove_file(path)\n+                } else {\n+                    Err(err)\n+                }\n+            })\n+        } else {\n+            std::fs::remove_file(path)\n+        }\n+    })\n+    .await\n+    .or_else(|err| {\n+        if err.kind() == ErrorKind::NotFound {\n+            Ok(())\n+        } else {\n+            Err(err)\n+        }\n+    })\n+    .with_context(|| format!(\"removing existing symlink {path:?} failed\"))\n+}\n+\n #[turbo_tasks::value_impl]\n impl ValueToString for DiskFileSystem {\n     #[turbo_tasks::function]\n@@ -1615,7 +1671,24 @@ impl FileSystemPath {\n         self.fs().write(self.clone(), content)\n     }\n \n-    pub fn write_link(&self, target: Vc<LinkContent>) -> Vc<()> {\n+    /// Creates a symbolic link to a directory on *nix platforms, or a directory junction point on\n+    /// Windows.\n+    ///\n+    /// [Windows supports symbolic links][windows-symlink], but they [can require elevated\n+    /// privileges][windows-privileges] if \"developer mode\" is not enabled, so we can't safely use\n+    /// them. Using junction points [matches the behavior of pnpm][pnpm-windows].\n+    ///\n+    /// This only supports directories because Windows junction points are incompatible with files.\n+    /// To ensure compatibility, this will return an error if the target is a file, even on\n+    /// platforms with full symlink support.\n+    ///\n+    /// **We intentionally do not provide an API for symlinking a file**, as we cannot support that\n+    /// on all Windows configurations.\n+    ///\n+    /// [windows-symlink]: https://blogs.windows.com/windowsdeveloper/2016/12/02/symlinks-windows-10/\n+    /// [windows-privileges]: https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/create-symbolic-links\n+    /// [pnpm-windows]: https://pnpm.io/faq#does-it-work-on-windows\n+    pub fn write_symbolic_link_dir(&self, target: Vc<LinkContent>) -> Vc<()> {\n         self.fs().write_link(self.clone(), target)\n     }\n \n@@ -1733,7 +1806,7 @@ pub enum Permissions {\n \n // Only handle the permissions on unix platform for now\n \n-#[cfg(target_family = \"unix\")]\n+#[cfg(unix)]\n impl From<Permissions> for std::fs::Permissions {\n     fn from(perm: Permissions) -> Self {\n         use std::os::unix::fs::PermissionsExt;\n@@ -1745,7 +1818,7 @@ impl From<Permissions> for std::fs::Permissions {\n     }\n }\n \n-#[cfg(target_family = \"unix\")]\n+#[cfg(unix)]\n impl From<std::fs::Permissions> for Permissions {\n     fn from(perm: std::fs::Permissions) -> Self {\n         use std::os::unix::fs::PermissionsExt;\n@@ -1762,7 +1835,7 @@ impl From<std::fs::Permissions> for Permissions {\n     }\n }\n \n-#[cfg(not(target_family = \"unix\"))]\n+#[cfg(not(unix))]\n impl From<std::fs::Permissions> for Permissions {\n     fn from(_: std::fs::Permissions) -> Self {\n         Permissions::default()\n@@ -1871,16 +1944,28 @@ bitflags! {\n   }\n }\n \n+/// The contents of a symbolic link. On Windows, this may be a junction point.\n+///\n+/// When reading, we treat symbolic links and junction points on Windows as equivalent. When\n+/// creating a new link, we always create junction points, because symlink creation may fail if\n+/// Windows \"developer mode\" is not enabled and we're running in an unprivileged environment.\n #[turbo_tasks::value(shared)]\n #[derive(Debug)]\n pub enum LinkContent {\n-    // for the relative link, the target is raw value read from the link\n-    // for the absolute link, the target is stripped of the root path while reading\n-    // We don't use the `FileSystemPath` here for now, because the `FileSystemPath` is always\n-    // normalized, which means in `fn write_link` we couldn't restore the raw value of the file\n-    // link because there is only **dist** path in `fn write_link`, and we need the raw path if\n-    // we want to restore the link value in `fn write_link`\n-    Link { target: RcStr, link_type: LinkType },\n+    /// A valid symbolic link pointing to `target`.\n+    ///\n+    /// When reading a relative link, the target is raw value read from the link.\n+    ///\n+    /// When reading an absolute link, the target is stripped of the root path while reading. This\n+    /// ensures we don't store absolute paths inside of the persistent cache.\n+    ///\n+    /// We don't use the [`FileSystemPath`] to store the target, because the [`FileSystemPath`] is\n+    /// always normalized. In [`FileSystemPath::write_symbolic_link_dir`] we need to compare\n+    /// `target` with the value returned by [`sys::fs::read_link`].\n+    Link {\n+        target: RcStr,\n+        link_type: LinkType,\n+    },\n     // Invalid means the link is invalid it points out of the filesystem root\n     Invalid,\n     // The target was not found"
        },
        {
            "sha": "7f03d336c39cdf05666915474329e0940b785bf3",
            "filename": "turbopack/crates/turbo-tasks-fs/src/virtual_fs.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/a3048c637116e3ef8c1468cbd19adb25a62a3720/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fvirtual_fs.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3048c637116e3ef8c1468cbd19adb25a62a3720/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fvirtual_fs.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fvirtual_fs.rs?ref=a3048c637116e3ef8c1468cbd19adb25a62a3720",
            "patch": "@@ -2,8 +2,7 @@ use anyhow::{Result, bail};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ValueDefault, ValueToString, Vc};\n \n-use super::{FileContent, FileMeta, FileSystem, FileSystemPath, LinkContent};\n-use crate::RawDirectoryContent;\n+use crate::{FileContent, FileMeta, FileSystem, FileSystemPath, LinkContent, RawDirectoryContent};\n \n #[turbo_tasks::value]\n pub struct VirtualFileSystem {"
        },
        {
            "sha": "49f24c45185ea50f07cb198d71ac63a8d7a51983",
            "filename": "turbopack/crates/turbopack-core/src/asset.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/a3048c637116e3ef8c1468cbd19adb25a62a3720/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fasset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3048c637116e3ef8c1468cbd19adb25a62a3720/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fasset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fasset.rs?ref=a3048c637116e3ef8c1468cbd19adb25a62a3720",
            "patch": "@@ -98,7 +98,7 @@ impl AssetContent {\n                 path.write(**file).as_side_effect().await?;\n             }\n             AssetContent::Redirect { target, link_type } => {\n-                path.write_link(\n+                path.write_symbolic_link_dir(\n                     LinkContent::Link {\n                         target: target.clone(),\n                         link_type: *link_type,"
        }
    ],
    "stats": {
        "total": 247,
        "additions": 177,
        "deletions": 70
    }
}