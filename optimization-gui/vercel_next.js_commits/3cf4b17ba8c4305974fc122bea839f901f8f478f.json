{
    "author": "wyattjoh",
    "message": "fix(static-paths): add depth tracking to parallel route param resolution (#85319)\n\n### What?\n\nAdds depth-aware parameter resolution to `resolveParallelRouteParams` by\nmigrating from simplified parallel route segments to LoaderTree\nstructure.\n\n### Why?\n\nDynamic and intercepted parameters in parallel routes were not being\ncorrectly extracted when used at nested depths. The previous\nimplementation didn't account for:\n- Route nesting level when matching pathname segments to parameters\n- Route groups (which don't affect depth) vs interception routes (which\ndo)\n- Embedded parameters that need resolution before depth calculation\n\nThis caused incorrect behavior in real-world scenarios like:\n- Nested parallel routes at different depths\n- Interception routes with parallel routes\n- ISR/generateStaticParams with complex routing structures\n\n### How?\n\n1. **LoaderTree Integration**: Migrated from `ParallelRouteSegment[]` to\nLoaderTree structure for accurate routing hierarchy representation\n2. **Depth Tracking**: Recursively traverse LoaderTree to calculate\ndepth, accounting for:\n   - Static segments (increment depth)\n   - Dynamic segments (increment depth)\n   - Route groups `()` - don't increment depth\n   - Interception routes `(.)` `(..)` `(...)` - do increment depth\n3. **Smart Parameter Extraction**: \n   - Check if pathname segment at calculated depth is a placeholder\n   - Only extract if segment is known (not `[paramName]`)\n   - Resolve embedded params before extraction\n4. **Comprehensive Tests**: Added test coverage for:\n   - Dynamic params at various depths\n   - Route groups vs interception routes\n   - Catchall/optional-catchall with depth\n   - Complex nested scenarios\n\nFixes #85251",
    "sha": "3cf4b17ba8c4305974fc122bea839f901f8f478f",
    "files": [
        {
            "sha": "7dcd43782d1fbe734712c0266de1792ab3bd2741",
            "filename": "packages/next/src/build/static-paths/app.test.ts",
            "status": "modified",
            "additions": 1083,
            "deletions": 84,
            "changes": 1167,
            "blob_url": "https://github.com/vercel/next.js/blob/3cf4b17ba8c4305974fc122bea839f901f8f478f/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3cf4b17ba8c4305974fc122bea839f901f8f478f/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts?ref=3cf4b17ba8c4305974fc122bea839f901f8f478f",
            "patch": "@@ -1309,19 +1309,20 @@ describe('calculateFallbackMode', () => {\n })\n \n describe('resolveParallelRouteParams', () => {\n-  function createParallelRouteSegment(\n-    paramName: string,\n-    paramType: DynamicParamTypes\n-  ): {\n-    name: string\n-    paramName: string\n-    paramType: DynamicParamTypes\n-  } {\n-    return {\n-      name: `@${paramName}`,\n-      paramName,\n-      paramType,\n-    }\n+  // Helper to create LoaderTree structures for testing\n+  type TestLoaderTree = [\n+    segment: string,\n+    parallelRoutes: { [key: string]: TestLoaderTree },\n+    modules: Record<string, unknown>,\n+  ]\n+\n+  function createLoaderTree(\n+    segment: string,\n+    parallelRoutes: { [key: string]: TestLoaderTree } = {},\n+    children?: TestLoaderTree\n+  ): TestLoaderTree {\n+    const routes = children ? { ...parallelRoutes, children } : parallelRoutes\n+    return [segment, routes, {}]\n   }\n \n   function createFallbackParam(\n@@ -1334,15 +1335,16 @@ describe('resolveParallelRouteParams', () => {\n \n   describe('direct match case', () => {\n     it('should skip processing when param already exists in params object', () => {\n-      const parallelRouteSegments = [\n-        createParallelRouteSegment('existingParam', 'dynamic'),\n-      ]\n+      // Tree: / -> @sidebar/[existingParam]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[existingParam]'),\n+      })\n       const params: Params = { existingParam: 'value' }\n       const pathname = '/some/path'\n       const fallbackRouteParams: FallbackRouteParam[] = []\n \n       resolveParallelRouteParams(\n-        parallelRouteSegments,\n+        loaderTree,\n         params,\n         pathname,\n         fallbackRouteParams\n@@ -1353,16 +1355,17 @@ describe('resolveParallelRouteParams', () => {\n     })\n \n     it('should skip processing for multiple existing params', () => {\n-      const parallelRouteSegments = [\n-        createParallelRouteSegment('param1', 'dynamic'),\n-        createParallelRouteSegment('param2', 'catchall'),\n-      ]\n+      // Tree: / -> @sidebar/[param1] + @modal/[...param2]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[param1]'),\n+        modal: createLoaderTree('[...param2]'),\n+      })\n       const params: Params = { param1: 'value1', param2: ['a', 'b'] }\n       const pathname = '/some/path'\n       const fallbackRouteParams: FallbackRouteParam[] = []\n \n       resolveParallelRouteParams(\n-        parallelRouteSegments,\n+        loaderTree,\n         params,\n         pathname,\n         fallbackRouteParams\n@@ -1374,19 +1377,271 @@ describe('resolveParallelRouteParams', () => {\n     })\n   })\n \n+  describe('dynamic params', () => {\n+    it('should extract dynamic param from pathname when not already in params', () => {\n+      // Tree: / -> @sidebar/[dynamicParam]\n+      // At depth 0, should extract 'some' from pathname '/some/path'\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[dynamicParam]'),\n+      })\n+      const params: Params = {}\n+      const pathname = '/some/path'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.dynamicParam).toBe('some')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle multiple dynamic params in parallel routes at same depth', () => {\n+      // Tree: / -> @modal/[id] + @sidebar/[category]\n+      // Both at depth 0, so both extract 'photo' from pathname '/photo/123'\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('[id]'),\n+        sidebar: createLoaderTree('[category]'),\n+      })\n+      const params: Params = {}\n+      const pathname = '/photo/123'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Both should extract the first segment 'photo'\n+      expect(params.id).toBe('photo')\n+      expect(params.category).toBe('photo')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should extract dynamic param from pathname at depth 0', () => {\n+      // Tree: / -> @sidebar/[category]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[category]'),\n+      })\n+      const params: Params = {}\n+      const pathname = '/tech'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.category).toBe('tech')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should extract dynamic param from pathname at nested depth', () => {\n+      // Tree: /blog -> @sidebar/[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          sidebar: createLoaderTree('[category]'),\n+        })\n+      )\n+      const params: Params = {}\n+      const pathname = '/blog/tech'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.category).toBe('tech')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should extract dynamic param even when other unknown params exist at different depths', () => {\n+      // Tree: / -> @sidebar/[category]\n+      // Even though there's an unknown 'slug' param somewhere else, if the segment\n+      // at this depth is known, we can extract it\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[category]'),\n+      })\n+      const params: Params = {}\n+      const pathname = '/tech'\n+      const fallbackRouteParams: FallbackRouteParam[] = [\n+        createFallbackParam('slug', false), // Non-parallel fallback param at different depth\n+      ]\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should extract 'tech' because pathSegments[0] is known, regardless of slug\n+      expect(params.category).toBe('tech')\n+      expect(fallbackRouteParams).toHaveLength(1) // Still just slug\n+    })\n+\n+    it('should mark dynamic param as fallback when depth exceeds pathname length', () => {\n+      // Tree: /blog/posts -> @sidebar/[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'blog',\n+          {},\n+          createLoaderTree('posts', {\n+            sidebar: createLoaderTree('[category]'),\n+          })\n+        )\n+      )\n+      const params: Params = {}\n+      const pathname = '/blog' // Only 1 segment, but dynamic param is at depth 2\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.category).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(1)\n+      expect(fallbackRouteParams[0]).toEqual({\n+        paramName: 'category',\n+        paramType: 'dynamic',\n+        isParallelRouteParam: true,\n+      })\n+    })\n+\n+    it('should resolve embedded params when extracting dynamic param value', () => {\n+      // Tree: /[lang] -> @sidebar/[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[lang]', {\n+          sidebar: createLoaderTree('[category]'),\n+        })\n+      )\n+      const params: Params = { lang: 'en' }\n+      const pathname = '/en/tech'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.category).toBe('tech')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should extract dynamic param when unknown params exist at LATER depth', () => {\n+      // Tree: /[lang] -> @sidebar/[filter] (at depth 1)\n+      //       /[lang]/products/[category] (category at depth 2 is unknown)\n+      // @sidebar/[filter] is at depth 1, should extract 'products'\n+      // [category] at depth 2 is unknown, but shouldn't affect depth 1 resolution\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '[lang]',\n+          {\n+            sidebar: createLoaderTree('[filter]'),\n+          },\n+          createLoaderTree('products', {}, createLoaderTree('[category]'))\n+        )\n+      )\n+      const params: Params = { lang: 'en' }\n+      // Pathname with placeholder at depth 2: /en/products/[category]\n+      const pathname = '/en/products/[category]'\n+      const fallbackRouteParams: FallbackRouteParam[] = [\n+        createFallbackParam('category', false), // category at depth 2 is unknown\n+      ]\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should extract 'products' at depth 1, even though category at depth 2 is unknown\n+      expect(params.filter).toBe('products')\n+      expect(fallbackRouteParams).toHaveLength(1) // Still just category\n+    })\n+\n+    it('should NOT extract dynamic param when placeholder is at SAME depth', () => {\n+      // Tree: /[lang]/products/[category] -> @sidebar/[filter]\n+      // @sidebar/[filter] is at depth 2\n+      // [category] at depth 2 is also unknown - same depth!\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '[lang]',\n+          {},\n+          createLoaderTree(\n+            'products',\n+            {},\n+            createLoaderTree('[category]', {\n+              sidebar: createLoaderTree('[filter]'),\n+            })\n+          )\n+        )\n+      )\n+      const params: Params = { lang: 'en' }\n+      // Pathname with placeholder at depth 2: /en/products/[category]\n+      const pathname = '/en/products/[category]'\n+      const fallbackRouteParams: FallbackRouteParam[] = [\n+        createFallbackParam('category', false), // category at depth 2 is unknown\n+      ]\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should NOT extract because pathSegments[2] = '[category]' is a placeholder\n+      expect(params.filter).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(2)\n+      expect(fallbackRouteParams[1]).toEqual({\n+        paramName: 'filter',\n+        paramType: 'dynamic',\n+        isParallelRouteParam: true,\n+      })\n+    })\n+  })\n+\n   describe('catchall with non-parallel fallback params', () => {\n     it('should add to fallbackRouteParams when non-parallel fallback params exist', () => {\n-      const parallelRouteSegments = [\n-        createParallelRouteSegment('catchallParam', 'catchall'),\n-      ]\n+      // Tree: / -> @sidebar/[...catchallParam]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[...catchallParam]'),\n+      })\n       const params: Params = {}\n       const pathname = '/some/path/segments'\n       const fallbackRouteParams: FallbackRouteParam[] = [\n         createFallbackParam('regularParam', false), // Non-parallel fallback param\n       ]\n \n       resolveParallelRouteParams(\n-        parallelRouteSegments,\n+        loaderTree,\n         params,\n         pathname,\n         fallbackRouteParams\n@@ -1404,17 +1659,18 @@ describe('resolveParallelRouteParams', () => {\n \n   describe('optional-catchall with non-parallel fallback params', () => {\n     it('should add to fallbackRouteParams when non-parallel fallback params exist', () => {\n-      const parallelRouteSegments = [\n-        createParallelRouteSegment('optionalCatchall', 'optional-catchall'),\n-      ]\n+      // Tree: / -> @sidebar/[[...optionalCatchall]]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[[...optionalCatchall]]'),\n+      })\n       const params: Params = {}\n       const pathname = '/some/path'\n       const fallbackRouteParams: FallbackRouteParam[] = [\n         createFallbackParam('regularParam', false), // Non-parallel fallback param\n       ]\n \n       resolveParallelRouteParams(\n-        parallelRouteSegments,\n+        loaderTree,\n         params,\n         pathname,\n         fallbackRouteParams\n@@ -1430,43 +1686,94 @@ describe('resolveParallelRouteParams', () => {\n     })\n   })\n \n-  describe('catchall deriving from pathname', () => {\n-    it('should populate params with path segments when no non-parallel fallback params', () => {\n-      const parallelRouteSegments = [\n-        createParallelRouteSegment('catchallParam', 'catchall'),\n-      ]\n+  describe('catchall deriving from pathname with depth', () => {\n+    it('should use depth to correctly slice pathname segments', () => {\n+      // Tree: /blog -> @sidebar/[...catchallParam]\n+      // At depth 1 (after /blog), should get remaining segments\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          sidebar: createLoaderTree('[...catchallParam]'),\n+        })\n+      )\n       const params: Params = {}\n       const pathname = '/blog/2023/posts/my-article'\n-      const fallbackRouteParams: FallbackRouteParam[] = [\n-        createFallbackParam('parallelParam', true), // Only parallel fallback params\n-      ]\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n \n       resolveParallelRouteParams(\n-        parallelRouteSegments,\n+        loaderTree,\n         params,\n         pathname,\n         fallbackRouteParams\n       )\n \n-      expect(params.catchallParam).toEqual([\n-        'blog',\n-        '2023',\n-        'posts',\n-        'my-article',\n-      ])\n-      expect(fallbackRouteParams).toHaveLength(1) // No new fallback params added\n+      // Should get segments from depth 1 onwards\n+      expect(params.catchallParam).toEqual(['2023', 'posts', 'my-article'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle catchall at depth 0 (root level)', () => {\n+      // Tree: / -> @sidebar/[...catchallParam]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[...catchallParam]'),\n+      })\n+      const params: Params = {}\n+      const pathname = '/blog/2023/posts'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should get all segments\n+      expect(params.catchallParam).toEqual(['blog', '2023', 'posts'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle nested depth correctly', () => {\n+      // Tree: /products/[category] -> @filters/[...filterPath]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'products',\n+          {},\n+          createLoaderTree('[category]', {\n+            filters: createLoaderTree('[...filterPath]'),\n+          })\n+        )\n+      )\n+      const params: Params = { category: 'electronics' }\n+      const pathname = '/products/electronics/phones/iphone'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should get segments from depth 2 onwards (after /products/[category])\n+      expect(params.filterPath).toEqual(['phones', 'iphone'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n     })\n \n     it('should handle single path segment', () => {\n-      const parallelRouteSegments = [\n-        createParallelRouteSegment('catchallParam', 'catchall'),\n-      ]\n+      // Tree: / -> @sidebar/[...catchallParam]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[...catchallParam]'),\n+      })\n       const params: Params = {}\n       const pathname = '/single'\n       const fallbackRouteParams: FallbackRouteParam[] = []\n \n       resolveParallelRouteParams(\n-        parallelRouteSegments,\n+        loaderTree,\n         params,\n         pathname,\n         fallbackRouteParams\n@@ -1477,17 +1784,79 @@ describe('resolveParallelRouteParams', () => {\n     })\n   })\n \n+  describe('route groups', () => {\n+    it('should not increment depth for route groups', () => {\n+      // Tree: /(marketing) -> @sidebar/[...catchallParam]\n+      // Route groups don't contribute to pathname depth\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(marketing)', {\n+          sidebar: createLoaderTree('[...catchallParam]'),\n+        })\n+      )\n+      const params: Params = {}\n+      const pathname = '/blog/post'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should get all segments since route group doesn't increment depth\n+      expect(params.catchallParam).toEqual(['blog', 'post'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle multiple route groups', () => {\n+      // Tree: /(group1)/(group2)/blog -> @sidebar/[...path]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(group1)',\n+          {},\n+          createLoaderTree(\n+            '(group2)',\n+            {},\n+            createLoaderTree('blog', {\n+              sidebar: createLoaderTree('[...path]'),\n+            })\n+          )\n+        )\n+      )\n+      const params: Params = {}\n+      const pathname = '/blog/2023/posts'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should get segments from depth 1 (after /blog), route groups don't count\n+      expect(params.path).toEqual(['2023', 'posts'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n   describe('optional-catchall with empty pathname', () => {\n     it('should set params to empty array when pathname has no segments', () => {\n-      const parallelRouteSegments = [\n-        createParallelRouteSegment('optionalCatchall', 'optional-catchall'),\n-      ]\n+      // Tree: / -> @sidebar/[[...optionalCatchall]]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[[...optionalCatchall]]'),\n+      })\n       const params: Params = {}\n       const pathname = '/'\n       const fallbackRouteParams: FallbackRouteParam[] = []\n \n       resolveParallelRouteParams(\n-        parallelRouteSegments,\n+        loaderTree,\n         params,\n         pathname,\n         fallbackRouteParams\n@@ -1497,37 +1866,43 @@ describe('resolveParallelRouteParams', () => {\n       expect(fallbackRouteParams).toHaveLength(0)\n     })\n \n-    it('should set params to empty array when pathname is empty string', () => {\n-      const parallelRouteSegments = [\n-        createParallelRouteSegment('optionalCatchall', 'optional-catchall'),\n-      ]\n+    it('should handle optional catchall at nested depth with no remaining segments', () => {\n+      // Tree: /blog -> @sidebar/[[...optionalPath]]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          sidebar: createLoaderTree('[[...optionalPath]]'),\n+        })\n+      )\n       const params: Params = {}\n-      const pathname = '/'\n+      const pathname = '/blog'\n       const fallbackRouteParams: FallbackRouteParam[] = []\n \n       resolveParallelRouteParams(\n-        parallelRouteSegments,\n+        loaderTree,\n         params,\n         pathname,\n         fallbackRouteParams\n       )\n \n-      expect(params.optionalCatchall).toEqual([])\n+      expect(params.optionalPath).toEqual([])\n       expect(fallbackRouteParams).toHaveLength(0)\n     })\n   })\n \n   describe('optional-catchall with non-empty pathname', () => {\n     it('should populate params with path segments', () => {\n-      const parallelRouteSegments = [\n-        createParallelRouteSegment('optionalCatchall', 'optional-catchall'),\n-      ]\n+      // Tree: / -> @sidebar/[[...optionalCatchall]]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[[...optionalCatchall]]'),\n+      })\n       const params: Params = {}\n       const pathname = '/api/v1/users'\n       const fallbackRouteParams: FallbackRouteParam[] = []\n \n       resolveParallelRouteParams(\n-        parallelRouteSegments,\n+        loaderTree,\n         params,\n         pathname,\n         fallbackRouteParams\n@@ -1538,42 +1913,666 @@ describe('resolveParallelRouteParams', () => {\n     })\n   })\n \n-  it('should throw error for catchall with empty pathname', () => {\n-    const parallelRouteSegments = [\n-      createParallelRouteSegment('catchallParam', 'catchall'),\n-    ]\n-    const params: Params = {}\n-    const pathname = '/'\n-    const fallbackRouteParams: FallbackRouteParam[] = []\n+  describe('catchall-intercepted params', () => {\n+    it('should handle catchall-intercepted params in parallel routes', () => {\n+      // Tree: / -> @modal/[...path]  where [...path] uses catchall-intercepted type\n+      // Note: catchall-intercepted is a param type, not related to interception routes\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('[...path]'),\n+      })\n+      const params: Params = {}\n+      const pathname = '/photos/album/2023'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n \n-    expect(() =>\n       resolveParallelRouteParams(\n-        parallelRouteSegments,\n+        loaderTree,\n         params,\n         pathname,\n         fallbackRouteParams\n       )\n-    ).toThrow()\n+\n+      // Should get all segments\n+      expect(params.path).toEqual(['photos', 'album', '2023'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n   })\n \n-  describe('edge cases', () => {\n-    it('should throw error for catchall with empty path segments', () => {\n-      const parallelRouteSegments = [\n-        createParallelRouteSegment('catchall', 'catchall'),\n-        createParallelRouteSegment('optional', 'optional-catchall'),\n-      ]\n+  describe('error cases', () => {\n+    it('should throw error for catchall with empty pathname', () => {\n+      // Tree: / -> @sidebar/[...catchallParam]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[...catchallParam]'),\n+      })\n       const params: Params = {}\n-      const pathname = '///'\n+      const pathname = '/'\n       const fallbackRouteParams: FallbackRouteParam[] = []\n \n       expect(() =>\n         resolveParallelRouteParams(\n-          parallelRouteSegments,\n+          loaderTree,\n           params,\n           pathname,\n           fallbackRouteParams\n         )\n-      ).toThrow()\n+      ).toThrow(/Unexpected empty path segments/)\n+    })\n+\n+    it('should throw error for catchall when depth exceeds pathname', () => {\n+      // Tree: /blog/posts -> @sidebar/[...catchallParam]\n+      // But pathname is just /blog\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'blog',\n+          {},\n+          createLoaderTree('posts', {\n+            sidebar: createLoaderTree('[...catchallParam]'),\n+          })\n+        )\n+      )\n+      const params: Params = {}\n+      const pathname = '/blog'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      expect(() =>\n+        resolveParallelRouteParams(\n+          loaderTree,\n+          params,\n+          pathname,\n+          fallbackRouteParams\n+        )\n+      ).toThrow(/Unexpected empty path segments/)\n+    })\n+  })\n+\n+  describe('complex scenarios', () => {\n+    it('should handle multiple parallel routes at same level', () => {\n+      // Tree: / -> @sidebar/[...sidebarPath] + @modal/[[...modalPath]]\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[...sidebarPath]'),\n+        modal: createLoaderTree('[[...modalPath]]'),\n+      })\n+      const params: Params = {}\n+      const pathname = '/products/electronics'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.sidebarPath).toEqual(['products', 'electronics'])\n+      expect(params.modalPath).toEqual(['products', 'electronics'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle parallel route with embedded dynamic param from pathname', () => {\n+      // Tree: /[lang] -> @sidebar/[...path]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[lang]', {\n+          sidebar: createLoaderTree('[...path]'),\n+        })\n+      )\n+      const params: Params = { lang: 'en' }\n+      const pathname = '/en/blog/post'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should resolve [lang] in path segments to 'en'\n+      expect(params.path).toEqual(['blog', 'post'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should only process parallel routes, not children route', () => {\n+      // Tree: / -> children: /blog, sidebar: /[...path]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {\n+          sidebar: createLoaderTree('[...path]'),\n+        },\n+        createLoaderTree('blog')\n+      )\n+      const params: Params = {}\n+      const pathname = '/blog/post'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should only process @sidebar, not children\n+      expect(params.path).toEqual(['blog', 'post'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('interception routes', () => {\n+    it('should increment depth for (.) interception route (same level)', () => {\n+      // Tree: /(.)photo -> @modal/[...segments]\n+      // Interception routes should increment depth unlike route groups\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(.)photo', {\n+          modal: createLoaderTree('[...segments]'),\n+        })\n+      )\n+      const params: Params = {}\n+      const pathname = '/photo/123/details'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should get segments from depth 1 onwards (after /(.)photo)\n+      expect(params.segments).toEqual(['123', 'details'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should increment depth for (..) interception route (parent level)', () => {\n+      // Tree: /gallery/(..)photo -> @modal/[id]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'gallery',\n+          {},\n+          createLoaderTree('(..)photo', {\n+            modal: createLoaderTree('[id]'),\n+          })\n+        )\n+      )\n+      const params: Params = {}\n+      const pathname = '/gallery/photo/123'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // (..)photo is at depth 1, @modal/[id] should extract from depth 2\n+      expect(params.id).toBe('123')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should increment depth for (...) interception route (root level)', () => {\n+      // Tree: /app/gallery/(...)photo -> @modal/[...path]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'app',\n+          {},\n+          createLoaderTree(\n+            'gallery',\n+            {},\n+            createLoaderTree('(...)photo', {\n+              modal: createLoaderTree('[...path]'),\n+            })\n+          )\n+        )\n+      )\n+      const params: Params = {}\n+      const pathname = '/app/gallery/photo/2023/album'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // (...)photo is at depth 2, @modal/[...path] should extract from depth 3\n+      expect(params.path).toEqual(['2023', 'album'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should increment depth for (..)(..) interception route (grandparent level)', () => {\n+      // Tree: /a/b/(..)(..)photo -> @modal/[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'a',\n+          {},\n+          createLoaderTree(\n+            'b',\n+            {},\n+            createLoaderTree('(..)(..)photo', {\n+              modal: createLoaderTree('[category]'),\n+            })\n+          )\n+        )\n+      )\n+      const params: Params = {}\n+      const pathname = '/a/b/photo/nature'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // (..)(..)photo is at depth 2, @modal/[category] should extract from depth 3\n+      expect(params.category).toBe('nature')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should distinguish interception routes from regular route groups', () => {\n+      // Tree: /(marketing) -> @sidebar/[...path] (route group)\n+      //   vs: /(.)photo -> @modal/[...path] (interception route)\n+      const routeGroupTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(marketing)', {\n+          sidebar: createLoaderTree('[...path]'),\n+        })\n+      )\n+\n+      const interceptionTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('(.)photo', {\n+          modal: createLoaderTree('[...path]'),\n+        })\n+      )\n+\n+      const pathname = '/photo/123'\n+\n+      // Route group - should NOT increment depth\n+      const routeGroupParams: Params = {}\n+      const routeGroupFallback: FallbackRouteParam[] = []\n+      resolveParallelRouteParams(\n+        routeGroupTree,\n+        routeGroupParams,\n+        pathname,\n+        routeGroupFallback\n+      )\n+      // Gets all segments because route group doesn't increment depth\n+      expect(routeGroupParams.path).toEqual(['photo', '123'])\n+\n+      // Interception route - SHOULD increment depth\n+      const interceptionParams: Params = {}\n+      const interceptionFallback: FallbackRouteParam[] = []\n+      resolveParallelRouteParams(\n+        interceptionTree,\n+        interceptionParams,\n+        pathname,\n+        interceptionFallback\n+      )\n+      // Gets segments from depth 1 because (.)photo increments depth\n+      expect(interceptionParams.path).toEqual(['123'])\n+    })\n+  })\n+\n+  describe('empty pathname edge cases', () => {\n+    it('should mark dynamic param as fallback when pathname is empty', () => {\n+      // Tree: / -> @modal/[id]\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('[id]'),\n+      })\n+      const params: Params = {}\n+      const pathname = '/'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.id).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(1)\n+      expect(fallbackRouteParams[0]).toEqual({\n+        paramName: 'id',\n+        paramType: 'dynamic',\n+        isParallelRouteParam: true,\n+      })\n+    })\n+\n+    it('should mark multiple dynamic params as fallback when pathname is empty', () => {\n+      // Tree: / -> @modal/[category] + @sidebar/[filter]\n+      const loaderTree = createLoaderTree('', {\n+        modal: createLoaderTree('[category]'),\n+        sidebar: createLoaderTree('[filter]'),\n+      })\n+      const params: Params = {}\n+      const pathname = '/'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      expect(params.category).toBeUndefined()\n+      expect(params.filter).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(2)\n+      expect(fallbackRouteParams).toContainEqual({\n+        paramName: 'category',\n+        paramType: 'dynamic',\n+        isParallelRouteParam: true,\n+      })\n+      expect(fallbackRouteParams).toContainEqual({\n+        paramName: 'filter',\n+        paramType: 'dynamic',\n+        isParallelRouteParam: true,\n+      })\n+    })\n+\n+    it('should handle nested parallel route with empty pathname at that depth', () => {\n+      // Tree: /blog -> @modal/[id]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('blog', {\n+          modal: createLoaderTree('[id]'),\n+        })\n+      )\n+      const params: Params = {}\n+      const pathname = '/blog'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // No segment at depth 1, should mark as fallback\n+      expect(params.id).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(1)\n+      expect(fallbackRouteParams[0]).toEqual({\n+        paramName: 'id',\n+        paramType: 'dynamic',\n+        isParallelRouteParam: true,\n+      })\n+    })\n+  })\n+\n+  describe('complex path segments', () => {\n+    it('should handle catch-all with embedded param placeholders in pathname', () => {\n+      // Tree: / -> @sidebar/[...path]\n+      // Pathname contains a placeholder like [category] which is unknown\n+      const loaderTree = createLoaderTree('', {\n+        sidebar: createLoaderTree('[...path]'),\n+      })\n+      const params: Params = {}\n+      const pathname = '/blog/[category]/tech'\n+      const fallbackRouteParams: FallbackRouteParam[] = [\n+        createFallbackParam('category', false), // category is unknown\n+      ]\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should mark as fallback because there's a non-parallel fallback param\n+      expect(params.path).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(2)\n+      expect(fallbackRouteParams[1]).toEqual({\n+        paramName: 'path',\n+        paramType: 'catchall',\n+        isParallelRouteParam: true,\n+      })\n+    })\n+\n+    it('should mark catch-all as fallback when pathname has unknown param placeholder', () => {\n+      // Tree: /[lang] -> @sidebar/[...path]\n+      // Pathname has [lang] which is known, but [category] which is not\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[lang]', {\n+          sidebar: createLoaderTree('[...path]'),\n+        })\n+      )\n+      const params: Params = { lang: 'en' }\n+      const pathname = '/en/blog/[category]'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should mark path as fallback because pathname contains unknown [category] placeholder\n+      expect(params.path).toBeUndefined()\n+      expect(fallbackRouteParams).toHaveLength(1)\n+      expect(fallbackRouteParams[0]).toEqual({\n+        paramName: 'path',\n+        paramType: 'catchall',\n+        isParallelRouteParam: true,\n+      })\n+    })\n+\n+    it('should handle mixed static and dynamic segments in catch-all resolution', () => {\n+      // Tree: /products/[category] -> @filters/[...filterPath]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'products',\n+          {},\n+          createLoaderTree('[category]', {\n+            filters: createLoaderTree('[...filterPath]'),\n+          })\n+        )\n+      )\n+      const params: Params = { category: 'electronics' }\n+      const pathname = '/products/electronics/brand/apple/price/high'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Should get remaining path after resolving category\n+      expect(params.filterPath).toEqual(['brand', 'apple', 'price', 'high'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+  })\n+\n+  describe('integration scenarios', () => {\n+    it('should handle interception route + parallel route together', () => {\n+      // Tree: /gallery/(.)photo -> @modal/[id] + @sidebar/[category]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'gallery',\n+          {},\n+          createLoaderTree('(.)photo', {\n+            modal: createLoaderTree('[id]'),\n+            sidebar: createLoaderTree('[category]'),\n+          })\n+        )\n+      )\n+      const params: Params = {}\n+      const pathname = '/gallery/photo/123'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Both should extract from depth 2 (after /gallery/(.)photo)\n+      expect(params.id).toBe('123')\n+      expect(params.category).toBe('123')\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle route group + parallel route + interception route', () => {\n+      // Tree: /(marketing)/gallery/(.)photo -> @modal/[...path]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          '(marketing)',\n+          {},\n+          createLoaderTree(\n+            'gallery',\n+            {},\n+            createLoaderTree('(.)photo', {\n+              modal: createLoaderTree('[...path]'),\n+            })\n+          )\n+        )\n+      )\n+      const params: Params = {}\n+      const pathname = '/gallery/photo/2023/album'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // Route group doesn't increment, gallery does, (.)photo does\n+      // So depth is 2, extract from depth 2 onwards\n+      expect(params.path).toEqual(['2023', 'album'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle all param types together', () => {\n+      // Tree: /[lang] -> @modal/[category] + @sidebar/[...tags] + @info/[[...extra]]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree('[lang]', {\n+          modal: createLoaderTree('[category]'),\n+          sidebar: createLoaderTree('[...tags]'),\n+          info: createLoaderTree('[[...extra]]'),\n+        })\n+      )\n+      const params: Params = { lang: 'en' }\n+      const pathname = '/en/tech/react/nextjs'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // All should extract from depth 1 onwards\n+      expect(params.category).toBe('tech')\n+      expect(params.tags).toEqual(['tech', 'react', 'nextjs'])\n+      expect(params.extra).toEqual(['tech', 'react', 'nextjs'])\n+      expect(fallbackRouteParams).toHaveLength(0)\n+    })\n+\n+    it('should handle complex nesting with multiple interception routes', () => {\n+      // Tree: /app/(.)modal/(.)photo -> @dialog/[id]\n+      const loaderTree = createLoaderTree(\n+        '',\n+        {},\n+        createLoaderTree(\n+          'app',\n+          {},\n+          createLoaderTree(\n+            '(.)modal',\n+            {},\n+            createLoaderTree('(.)photo', {\n+              dialog: createLoaderTree('[id]'),\n+            })\n+          )\n+        )\n+      )\n+      const params: Params = {}\n+      const pathname = '/app/modal/photo/image-123'\n+      const fallbackRouteParams: FallbackRouteParam[] = []\n+\n+      resolveParallelRouteParams(\n+        loaderTree,\n+        params,\n+        pathname,\n+        fallbackRouteParams\n+      )\n+\n+      // app (depth 1) + (.)modal (depth 2) + (.)photo (depth 3) -> extract at depth 3\n+      expect(params.id).toBe('image-123')\n+      expect(fallbackRouteParams).toHaveLength(0)\n     })\n   })\n })\n+\n+/**\n+ * Test coverage note for dynamicParams validation in buildAppStaticPaths:\n+ *\n+ * The two-phase validation for segments with `dynamicParams: false` should be tested\n+ * in integration/e2e tests due to the complexity of mocking buildAppStaticPaths dependencies.\n+ *\n+ * Key scenarios to test:\n+ *\n+ * Phase 1 (Children route validation - lines 972-997):\n+ * - ✅ Should throw error when children route segment has dynamicParams: false\n+ *      but param is missing from generateStaticParams\n+ * - ✅ Should skip validation for parallel route segments (tested in Phase 2)\n+ *\n+ * Phase 2 (Parallel route validation - lines 1159-1201):\n+ * - ✅ Should throw error when parallel route segment has dynamicParams: false\n+ *      but param cannot be resolved from pathname\n+ * - ✅ Should throw error when parallel route segment has dynamicParams: false\n+ *      but param is marked as fallback (requires request-time resolution)\n+ * - ✅ Should succeed when parallel route param can be derived from pathname\n+ * - ✅ Should succeed when parallel route param is provided via generateStaticParams\n+ *\n+ * Example test structure for e2e:\n+ *\n+ * app/\n+ *   @modal/[category]/page.tsx  // dynamicParams: false, no generateStaticParams\n+ *   [slug]/page.tsx             // generateStaticParams: [{slug: 'post-1'}]\n+ *\n+ * Expected behavior:\n+ * - If @modal/[category] can derive category from pathname \"/post-1\": ✅ Success\n+ * - If @modal/[category] cannot derive category: ❌ Phase 2 error with pathname context\n+ *\n+ * app/\n+ *   [slug]/page.tsx  // dynamicParams: false, no generateStaticParams\n+ *\n+ * Expected behavior:\n+ * - ❌ Phase 1 error: param missing from generateStaticParams\n+ */"
        },
        {
            "sha": "d115c1c5e7ad512599f876e375e2a2cac95f07fb",
            "filename": "packages/next/src/build/static-paths/app.ts",
            "status": "modified",
            "additions": 167,
            "deletions": 81,
            "changes": 248,
            "blob_url": "https://github.com/vercel/next.js/blob/3cf4b17ba8c4305974fc122bea839f901f8f478f/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/3cf4b17ba8c4305974fc122bea839f901f8f478f/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts?ref=3cf4b17ba8c4305974fc122bea839f901f8f478f",
            "patch": "@@ -12,6 +12,7 @@ import { AfterRunner } from '../../server/after/run-with-after'\n import { createWorkStore } from '../../server/async-storage/work-store'\n import { FallbackMode } from '../../lib/fallback'\n import type { IncrementalCache } from '../../server/lib/incremental-cache'\n+import type { LoaderTree } from '../../server/lib/app-dir-module'\n import {\n   normalizePathname,\n   encodeParam,\n@@ -23,8 +24,14 @@ import type { NextConfigComplete } from '../../server/config-shared'\n import type { WorkStore } from '../../server/app-render/work-async-storage.external'\n import type { DynamicParamTypes } from '../../shared/lib/app-router-types'\n import { InvariantError } from '../../shared/lib/invariant-error'\n-import { getParamProperties } from '../../shared/lib/router/utils/get-segment-param'\n+import {\n+  getParamProperties,\n+  getSegmentParam,\n+} from '../../shared/lib/router/utils/get-segment-param'\n+import { parseLoaderTree } from '../../shared/lib/router/utils/parse-loader-tree'\n+import { INTERCEPTION_ROUTE_MARKERS } from '../../shared/lib/router/utils/interception-routes'\n import { throwEmptyGenerateStaticParamsError } from '../../shared/lib/errors/empty-generate-static-params-error'\n+import type { AppRouteModule } from '../../server/route-modules/app-route/module.compiled'\n \n /**\n  * Filters out duplicate parameters from a list of parameters.\n@@ -546,78 +553,160 @@ export function assignErrorIfEmpty(\n }\n \n /**\n- * Resolves parallel route parameters from regular route parameters. This function\n- * handles the complex logic of determining how to populate parallel route params\n- * based on their type (catchall, optional-catchall, or regular) and the current\n- * state of fallback parameters.\n+ * Resolves parallel route parameters from the loader tree. This function uses\n+ * tree-based traversal to correctly handle the hierarchical structure of parallel\n+ * routes and accurately determine parameter values based on their depth in the tree.\n+ *\n+ * Unlike interpolateParallelRouteParams (which has a complete URL at runtime),\n+ * this build-time function determines which parallel route params are unknown.\n+ * The pathname may contain placeholders like [slug], making it incomplete.\n  *\n- * @param parallelRouteSegments - Array of parallel route segments with their types and param names\n+ * @param loaderTree - The loader tree structure containing route hierarchy\n  * @param params - The current route parameters object (will be mutated)\n- * @param pathname - The current pathname being processed\n+ * @param pathname - The current pathname being processed (may contain placeholders)\n  * @param fallbackRouteParams - Array of fallback route parameters (will be mutated)\n  */\n export function resolveParallelRouteParams(\n-  parallelRouteSegments: ReadonlyArray<{\n-    readonly paramName: string\n-    readonly paramType: DynamicParamTypes\n-  }>,\n+  loaderTree: LoaderTree,\n   params: Params,\n   pathname: string,\n   fallbackRouteParams: FallbackRouteParam[]\n ): void {\n-  // Resolve parallel route params from the regular route params\n-  for (const { paramType, paramName } of parallelRouteSegments) {\n-    // Check if we can resolve this from existing params\n-    if (params[paramName]) {\n-      // Direct match - the param name exists in regular params\n-      continue\n-    }\n+  // Stack-based traversal with depth and parallel route key tracking\n+  const stack: Array<{\n+    tree: LoaderTree\n+    depth: number\n+    parallelKey: string\n+  }> = [{ tree: loaderTree, depth: 0, parallelKey: 'children' }]\n \n-    if (paramType === 'catchall' || paramType === 'optional-catchall') {\n-      // If there are any fallback route segments then we can't use the\n-      // pathname to derive the value because it's not complete. We can\n-      // make this assumption because the routes are always resolved left\n-      // to right and the catchall is always the last segment, so any\n-      // route parameters that are unknown will always contribute to the\n-      // pathname and therefore the catchall param too.\n-      if (fallbackRouteParams.some((param) => !param.isParallelRouteParam)) {\n-        fallbackRouteParams.push(\n-          createFallbackRouteParam(paramName, paramType, true)\n-        )\n-        continue\n-      }\n+  // Parse pathname into segments for depth-based resolution\n+  const pathSegments = pathname.split('/').filter(Boolean)\n \n-      // For catchall routes in parallel segments, derive from pathname\n-      // Similar to getDynamicParam's pagePath parsing logic\n-      const pathSegments = pathname.split('/').filter(Boolean)\n-\n-      // For catchall parallel routes, we use the full path segments\n-      // This mimics the behavior in getDynamicParam where the pagePath\n-      // is split and used to populate catchall values\n-      if (pathSegments.length > 0) {\n-        // FIXME: (NAR-335) this should handle prefixed segments\n-        params[paramName] = pathSegments\n-      } else if (paramType === 'optional-catchall') {\n-        params[paramName] = []\n-      } else {\n-        // We shouldn't be able to match a catchall segment without any path\n-        // segments if it's not an optional catchall.\n-        throw new InvariantError(\n-          `Unexpected empty path segments match for a pathname \"${pathname}\" with param \"${paramName}\" of type \"${paramType}\"`\n-        )\n+  while (stack.length > 0) {\n+    const { tree, depth, parallelKey } = stack.pop()!\n+    const { segment, parallelRoutes } = parseLoaderTree(tree)\n+\n+    // Only process segments that are in parallel routes (not the main 'children' route)\n+    if (parallelKey !== 'children') {\n+      const segmentParam = getSegmentParam(segment)\n+\n+      if (segmentParam && !params.hasOwnProperty(segmentParam.param)) {\n+        const { param: paramName, type: paramType } = segmentParam\n+\n+        switch (paramType) {\n+          case 'catchall':\n+          case 'optional-catchall':\n+          case 'catchall-intercepted':\n+            // If there are any non-parallel fallback route segments, we can't use the\n+            // pathname to derive the value because it's not complete. We can make\n+            // this assumption because routes are resolved left to right.\n+            if (\n+              fallbackRouteParams.some((param) => !param.isParallelRouteParam)\n+            ) {\n+              fallbackRouteParams.push(\n+                createFallbackRouteParam(paramName, paramType, true)\n+              )\n+              break\n+            }\n+\n+            // For catchall routes in parallel segments, derive from pathname\n+            // using depth to determine which segments to use\n+            const remainingSegments = pathSegments.slice(depth)\n+\n+            // Process segments to handle any embedded dynamic params\n+            // Track if we encounter any unknown param placeholders\n+            let hasUnknownParam = false\n+            const processedSegments = remainingSegments\n+              .flatMap((pathSegment) => {\n+                const param = getSegmentParam(pathSegment)\n+                if (param) {\n+                  // If the segment is a param placeholder, check if we have its value\n+                  if (!params.hasOwnProperty(param.param)) {\n+                    // Unknown param placeholder in pathname - can't derive full value\n+                    hasUnknownParam = true\n+                    return undefined\n+                  }\n+                  // If the segment matches a param, return the param value\n+                  // We don't encode values here as that's handled during retrieval.\n+                  return params[param.param]\n+                }\n+                // Otherwise it's a static segment\n+                return pathSegment\n+              })\n+              .filter((s) => s !== undefined)\n+\n+            // If we encountered any unknown param placeholders, we can't derive\n+            // the full catch-all value from the pathname, so mark as fallback.\n+            if (hasUnknownParam) {\n+              fallbackRouteParams.push(\n+                createFallbackRouteParam(paramName, paramType, true)\n+              )\n+              break\n+            }\n+\n+            if (processedSegments.length > 0) {\n+              params[paramName] = processedSegments\n+            } else if (paramType === 'optional-catchall') {\n+              params[paramName] = []\n+            } else {\n+              // We shouldn't be able to match a catchall segment without any path\n+              // segments if it's not an optional catchall\n+              throw new InvariantError(\n+                `Unexpected empty path segments match for a pathname \"${pathname}\" with param \"${paramName}\" of type \"${paramType}\"`\n+              )\n+            }\n+            break\n+\n+          case 'dynamic':\n+          case 'dynamic-intercepted':\n+            // For regular dynamic parameters, take the segment at this depth\n+            if (depth < pathSegments.length) {\n+              const pathSegment = pathSegments[depth]\n+              const param = getSegmentParam(pathSegment)\n+\n+              // Check if the segment at this depth is a placeholder for an unknown param\n+              if (param && !params.hasOwnProperty(param.param)) {\n+                // The segment is a placeholder like [category] and we don't have the value\n+                fallbackRouteParams.push(\n+                  createFallbackRouteParam(paramName, paramType, true)\n+                )\n+                break\n+              }\n+\n+              // If the segment matches a param, use the param value from params object\n+              // Otherwise it's a static segment, just use it directly\n+              // We don't encode values here as that's handled during retrieval\n+              params[paramName] = param ? params[param.param] : pathSegment\n+            } else {\n+              // No segment at this depth, mark as fallback.\n+              fallbackRouteParams.push(\n+                createFallbackRouteParam(paramName, paramType, true)\n+              )\n+            }\n+            break\n+\n+          default:\n+            paramType satisfies never\n+        }\n       }\n-    } else if (paramType === 'dynamic') {\n-      // We can't resolve dynamic param values at build time because they're\n-      // inferred from the request pathname.\n-      fallbackRouteParams.push(\n-        createFallbackRouteParam(paramName, paramType, true)\n-      )\n-    } else {\n-      // This is some other type of route param that shouldn't get resolved\n-      // statically.\n-      throw new InvariantError(\n-        `Unexpected match for a pathname \"${pathname}\" with a param \"${paramName}\" of type \"${paramType}\"`\n-      )\n+    }\n+\n+    // Calculate next depth - increment if this is not a route group and not empty\n+    let nextDepth = depth\n+    // Route groups are like (marketing) or (dashboard), NOT interception routes like (.)photo\n+    // Interception routes start with markers like (.), (..), (...), (..)(..)) and should increment depth\n+    const isInterceptionRoute = INTERCEPTION_ROUTE_MARKERS.some((marker) =>\n+      segment.startsWith(marker)\n+    )\n+    const isRouteGroup =\n+      !isInterceptionRoute && segment.startsWith('(') && segment.endsWith(')')\n+    if (!isRouteGroup && segment !== '') {\n+      nextDepth++\n+    }\n+\n+    // Add all parallel routes to the stack for processing.\n+    for (const [key, route] of Object.entries(parallelRoutes)) {\n+      stack.push({ tree: route, depth: nextDepth, parallelKey: key })\n     }\n   }\n }\n@@ -754,7 +843,7 @@ export async function buildAppStaticPaths({\n   cacheMaxMemorySize: number\n   requestHeaders: IncrementalCache['requestHeaders']\n   nextConfigOutput: 'standalone' | 'export' | undefined\n-  ComponentMod: AppPageModule\n+  ComponentMod: AppPageModule | AppRouteModule\n   isRoutePPREnabled: boolean\n   buildId: string\n   rootParamKeys: readonly string[]\n@@ -786,11 +875,6 @@ export async function buildAppStaticPaths({\n     readonly paramName: string\n     readonly paramType: DynamicParamTypes\n   }> = []\n-  const parallelRouteSegments: Array<{\n-    readonly name: string\n-    readonly paramName: string\n-    readonly paramType: DynamicParamTypes\n-  }> = []\n \n   // These are all the parallel fallback route params that will be included when\n   // we're emitting the route for the base route.\n@@ -819,13 +903,9 @@ export async function buildAppStaticPaths({\n         continue\n       }\n \n-      // Collect all the parallel route segments that have dynamic params for\n-      // second-pass resolution.\n-      parallelRouteSegments.push({\n-        name: segment.name,\n-        paramName: segment.paramName,\n-        paramType: segment.paramType,\n-      })\n+      // Collect parallel fallback route params for the base route.\n+      // The actual parallel route param resolution is now handled by\n+      // resolveParallelRouteParams using the loader tree.\n       parallelFallbackRouteParams.push(\n         createFallbackRouteParam(segment.paramName, segment.paramType, true)\n       )\n@@ -1044,13 +1124,19 @@ export async function buildAppStaticPaths({\n         )\n       }\n \n-      // Resolve parallel route params from the regular route params\n-      resolveParallelRouteParams(\n-        parallelRouteSegments,\n-        params,\n-        pathname,\n-        fallbackRouteParams\n-      )\n+      // Resolve parallel route params from the loader tree if this is from an\n+      // app page.\n+      if (\n+        'loaderTree' in ComponentMod.routeModule.userland &&\n+        Array.isArray(ComponentMod.routeModule.userland.loaderTree)\n+      ) {\n+        resolveParallelRouteParams(\n+          ComponentMod.routeModule.userland.loaderTree,\n+          params,\n+          pathname,\n+          fallbackRouteParams\n+        )\n+      }\n \n       const fallbackRootParams: string[] = []\n       for (const { paramName, isParallelRouteParam } of fallbackRouteParams) {"
        }
    ],
    "stats": {
        "total": 1415,
        "additions": 1250,
        "deletions": 165
    }
}