{
    "author": "mischnic",
    "message": "Turbopack: correctly trace files with npm (#85323)\n\nThe `.contains(\"/node_modules/\")` condition didn't work for npm, where the path might be `\"node_modules/.prisma/client\"`\r\n\r\nThis fixes cases of the following error with Prisma and npm\r\n```\r\nPrisma Client could not locate the Query Engine for runtime \"rhel-openssl-3.0.x\".\r\n\r\nWe detected that you are using Next.js, learn how to fix this: https://pris.ly/d/engine-not-found-nextjs.\r\n\r\nThis is likely caused by tooling that has not copied \"libquery_engine-rhel-openssl-3.0.x.so.node\" to the deployment folder.\r\nEnsure that you ran `prisma generate` and that \"libquery_engine-rhel-openssl-3.0.x.so.node\" has been copied to \"node_modules/.prisma/client\".\r\n\r\nWe would appreciate if you could take the time to share some information with us.\r\nPlease help us by answering a few questions: https://pris.ly/engine-not-found-tooling-investigation\r\n\r\nThe following locations have been searched:\r\n  /var/task/node_modules/.prisma/client\r\n  /var/task/node_modules/@prisma/client\r\n  /vercel/path0/node_modules/@prisma/client\r\n  /tmp/prisma-engines\r\n\r\n```",
    "sha": "406721415df918d4eda14a54d1866569aeb5765b",
    "files": [
        {
            "sha": "9372de26f036bfa92a5f8f628f891d658027d9fc",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 8,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/406721415df918d4eda14a54d1866569aeb5765b/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/406721415df918d4eda14a54d1866569aeb5765b/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=406721415df918d4eda14a54d1866569aeb5765b",
            "patch": "@@ -568,14 +568,7 @@ async fn validate_pages_css_imports(\n         .map(async |issue| {\n             // We allow imports of global CSS files which are inside of `node_modules`.\n             Ok(\n-                if !issue\n-                    .module\n-                    .ident()\n-                    .path()\n-                    .await?\n-                    .path\n-                    .contains(\"/node_modules/\")\n-                {\n+                if !issue.module.ident().path().await?.is_in_node_modules() {\n                     Some(issue)\n                 } else {\n                     None"
        },
        {
            "sha": "04b6d10b8fe48032003456ac584116d3f00920fa",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/406721415df918d4eda14a54d1866569aeb5765b/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/406721415df918d4eda14a54d1866569aeb5765b/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=406721415df918d4eda14a54d1866569aeb5765b",
            "patch": "@@ -1239,6 +1239,10 @@ impl FileSystemPath {\n         self.path.is_empty()\n     }\n \n+    pub fn is_in_node_modules(&self) -> bool {\n+        self.path.starts_with(\"node_modules/\") || self.path.contains(\"/node_modules/\")\n+    }\n+\n     /// Returns the path of `inner` relative to `self`.\n     ///\n     /// Note: this method always strips the leading `/` from the result."
        },
        {
            "sha": "13395b5f56a91462b1229d8323e7ff98f5e18f99",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 87,
            "deletions": 91,
            "changes": 178,
            "blob_url": "https://github.com/vercel/next.js/blob/406721415df918d4eda14a54d1866569aeb5765b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/406721415df918d4eda14a54d1866569aeb5765b/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=406721415df918d4eda14a54d1866569aeb5765b",
            "patch": "@@ -974,12 +974,7 @@ async fn analyze_ecmascript_module_internal(\n             origin,\n             compile_time_info,\n             var_graph: &var_graph,\n-            allow_project_root_tracing: !source\n-                .ident()\n-                .path()\n-                .await?\n-                .path\n-                .contains(\"/node_modules/\"),\n+            allow_project_root_tracing: !source.ident().path().await?.is_in_node_modules(),\n             fun_args_values: Default::default(),\n             var_cache: Default::default(),\n             first_import_meta: true,\n@@ -1742,15 +1737,21 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n         return Ok(());\n     }\n \n-    let get_traced_project_dir = async || {\n+    let get_traced_project_dir = async || -> Result<FileSystemPath> {\n         // readFileSync(\"./foo\") should always be relative to the project root, but this is\n-        // dangerous inside of node_modules as it can cause a lot of false positives in the\n-        // tracing, if some package does `path.join(dynamic)`, it would include everything from\n-        // the project root as well.\n-        if allow_project_root_tracing {\n-            compile_time_info.environment().cwd().owned().await\n+        // dangerous inside of node_modules as it can cause a lot of false positives in the tracing,\n+        // if some package does `path.join(dynamic)`, it would include everything from the project\n+        // root as well.\n+        //\n+        // Also, when there's no cwd set (i.e. in a tracing-specific module context, as we shouldn't\n+        // assume a `process.cwd()` for all of node_modules), fallback to the source file directory.\n+        // This still allows relative file accesses, just not from the project root.\n+        if allow_project_root_tracing\n+            && let Some(cwd) = compile_time_info.environment().cwd().owned().await?\n+        {\n+            Ok(cwd)\n         } else {\n-            Ok(Some(source.ident().path().await?.parent()))\n+            Ok(source.ident().path().await?.parent())\n         }\n     };\n \n@@ -1982,18 +1983,16 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                         return Ok(());\n                     }\n                 }\n-                if let Some(context_dir) = get_traced_project_dir().await? {\n-                    analysis.add_reference(\n-                        FileSourceReference::new(\n-                            context_dir,\n-                            Pattern::new(pat),\n-                            collect_affecting_sources,\n-                            make_issue_source(),\n-                        )\n-                        .to_resolved()\n-                        .await?,\n-                    );\n-                }\n+                analysis.add_reference(\n+                    FileSourceReference::new(\n+                        get_traced_project_dir().await?,\n+                        Pattern::new(pat),\n+                        collect_affecting_sources,\n+                        make_issue_source(),\n+                    )\n+                    .to_resolved()\n+                    .await?,\n+                );\n                 return Ok(());\n             }\n             let (args, hints) = explain_args(&args);\n@@ -2038,13 +2037,15 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     return Ok(());\n                 }\n             }\n-            if let Some(context_dir) = get_traced_project_dir().await? {\n-                analysis.add_reference(\n-                    DirAssetReference::new(context_dir, Pattern::new(pat), make_issue_source())\n-                        .to_resolved()\n-                        .await?,\n-                );\n-            }\n+            analysis.add_reference(\n+                DirAssetReference::new(\n+                    get_traced_project_dir().await?,\n+                    Pattern::new(pat),\n+                    make_issue_source(),\n+                )\n+                .to_resolved()\n+                .await?,\n+            );\n             return Ok(());\n         }\n \n@@ -2080,13 +2081,15 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     return Ok(());\n                 }\n             }\n-            if let Some(context_dir) = get_traced_project_dir().await? {\n-                analysis.add_reference(\n-                    DirAssetReference::new(context_dir, Pattern::new(pat), make_issue_source())\n-                        .to_resolved()\n-                        .await?,\n-                );\n-            }\n+            analysis.add_reference(\n+                DirAssetReference::new(\n+                    get_traced_project_dir().await?,\n+                    Pattern::new(pat),\n+                    make_issue_source(),\n+                )\n+                .to_resolved()\n+                .await?,\n+            );\n             return Ok(());\n         }\n         JsValue::WellKnownFunction(WellKnownFunctionKind::ChildProcessSpawnMethod(name))\n@@ -2130,12 +2133,10 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 if dynamic {\n                     show_dynamic_warning = true;\n                 }\n-                if (!dynamic || !ignore_dynamic_requests)\n-                    && let Some(context_dir) = get_traced_project_dir().await?\n-                {\n+                if !dynamic || !ignore_dynamic_requests {\n                     analysis.add_reference(\n                         FileSourceReference::new(\n-                            context_dir,\n+                            get_traced_project_dir().await?,\n                             Pattern::new(pat),\n                             collect_affecting_sources,\n                             IssueSource::from_swc_offsets(\n@@ -2371,17 +2372,15 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                                     .await?;\n                                 js_value_to_pattern(&linked_func_call)\n                             };\n-                            if let Some(context_dir) = get_traced_project_dir().await? {\n-                                analysis.add_reference(\n-                                    DirAssetReference::new(\n-                                        context_dir,\n-                                        Pattern::new(abs_pattern),\n-                                        make_issue_source(),\n-                                    )\n-                                    .to_resolved()\n-                                    .await?,\n-                                );\n-                            }\n+                            analysis.add_reference(\n+                                DirAssetReference::new(\n+                                    get_traced_project_dir().await?,\n+                                    Pattern::new(abs_pattern),\n+                                    make_issue_source(),\n+                                )\n+                                .to_resolved()\n+                                .await?,\n+                            );\n                             return Ok(());\n                         }\n                     }\n@@ -2440,17 +2439,15 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                         .await?;\n                     js_value_to_pattern(&linked_func_call)\n                 };\n-                if let Some(context_dir) = get_traced_project_dir().await? {\n-                    analysis.add_reference(\n-                        DirAssetReference::new(\n-                            context_dir,\n-                            Pattern::new(abs_pattern),\n-                            make_issue_source(),\n-                        )\n-                        .to_resolved()\n-                        .await?,\n-                    );\n-                }\n+                analysis.add_reference(\n+                    DirAssetReference::new(\n+                        get_traced_project_dir().await?,\n+                        Pattern::new(abs_pattern),\n+                        make_issue_source(),\n+                    )\n+                    .to_resolved()\n+                    .await?,\n+                );\n                 return Ok(());\n             }\n             let (args, hints) = explain_args(&args);\n@@ -2498,33 +2495,32 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n             if args.len() == 2\n                 && let Some(JsValue::Object { parts, .. }) = args.get(1)\n             {\n-                if let Some(context_dir) = get_traced_project_dir().await? {\n-                    let resolved_dirs = parts\n-                        .iter()\n-                        .filter_map(|object_part| match object_part {\n-                            ObjectPart::KeyValue(\n-                                JsValue::Constant(key),\n-                                JsValue::Array { items: dirs, .. },\n-                            ) if key.as_str() == Some(\"includeDirs\") => {\n-                                Some(dirs.iter().filter_map(|dir| dir.as_str()))\n-                            }\n-                            _ => None,\n-                        })\n-                        .flatten()\n-                        .map(|dir| {\n-                            DirAssetReference::new(\n-                                context_dir.clone(),\n-                                Pattern::new(Pattern::Constant(dir.into())),\n-                                make_issue_source(),\n-                            )\n-                            .to_resolved()\n-                        })\n-                        .try_join()\n-                        .await?;\n+                let context_dir = get_traced_project_dir().await?;\n+                let resolved_dirs = parts\n+                    .iter()\n+                    .filter_map(|object_part| match object_part {\n+                        ObjectPart::KeyValue(\n+                            JsValue::Constant(key),\n+                            JsValue::Array { items: dirs, .. },\n+                        ) if key.as_str() == Some(\"includeDirs\") => {\n+                            Some(dirs.iter().filter_map(|dir| dir.as_str()))\n+                        }\n+                        _ => None,\n+                    })\n+                    .flatten()\n+                    .map(|dir| {\n+                        DirAssetReference::new(\n+                            context_dir.clone(),\n+                            Pattern::new(Pattern::Constant(dir.into())),\n+                            make_issue_source(),\n+                        )\n+                        .to_resolved()\n+                    })\n+                    .try_join()\n+                    .await?;\n \n-                    for resolved_dir_ref in resolved_dirs {\n-                        analysis.add_reference(resolved_dir_ref);\n-                    }\n+                for resolved_dir_ref in resolved_dirs {\n+                    analysis.add_reference(resolved_dir_ref);\n                 }\n \n                 return Ok(());"
        }
    ],
    "stats": {
        "total": 191,
        "additions": 92,
        "deletions": 99
    }
}