{
    "author": "lukesandberg",
    "message": "[turbopack] Fix URL fragment and query handling in Turbopack (#79993)\n\nFix URL fragment and query handling in Turbopack\n\n## What?\nThis PR improves how URL fragments and query strings are handled in Turbopack by:\n\n1. Standardizing the representation of fragments and queries in `AssetIdent`\n2. Ensuring fragments and queries are either empty or include their prefix characters (`#` and `?`)\n3. Fixing the URL parsing logic to correctly handle fragments that contain `?` character\n4. Removing some ad-hoc workarounds for this issue in the `resolver` and `Assetident::to_string`\n\n## Why?\nThe previous implementation had inconsistencies in how fragments and queries were represented which lead to a variety of confusing issues e.g. does `AssetIdent::to_string` need to add a `?` ?, well sometimes depending on how it was constructed.",
    "sha": "0084361f4ba8b4298aa77afe9eff652d1830c352",
    "files": [
        {
            "sha": "32aadcbffc8228d3c4a14694466d861db2d01e27",
            "filename": "crates/next-api/src/server_actions.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/0084361f4ba8b4298aa77afe9eff652d1830c352/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0084361f4ba8b4298aa77afe9eff652d1830c352/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs?ref=0084361f4ba8b4298aa77afe9eff652d1830c352",
            "patch": "@@ -213,7 +213,7 @@ pub async fn to_rsc_context(\n     // module.\n     let source = FileSource::new_with_query(\n         client_module.ident().path().root().join(entry_path.into()),\n-        Vc::cell(entry_query.into()),\n+        entry_query.into(),\n     );\n     let module = asset_context\n         .process("
        },
        {
            "sha": "a782250d8e3d375b1d9da84047335217eda81bfa",
            "filename": "crates/next-core/src/next_client_reference/ecmascript_client_reference/ecmascript_client_reference_transition.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/0084361f4ba8b4298aa77afe9eff652d1830c352/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_transition.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0084361f4ba8b4298aa77afe9eff652d1830c352/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_transition.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_transition.rs?ref=0084361f4ba8b4298aa77afe9eff652d1830c352",
            "patch": "@@ -71,7 +71,11 @@ impl Transition for NextEcmascriptClientReferenceTransition {\n                     .replace(\"next/dist/esm/\", \"next/dist/\")\n                     .into(),\n             );\n-            Vc::upcast(FileSource::new_with_query(path, *ident_ref.query))\n+            Vc::upcast(FileSource::new_with_query_and_fragment(\n+                path,\n+                (*ident_ref.query.await?).clone(),\n+                (*ident_ref.fragment.await?).clone(),\n+            ))\n         } else {\n             source\n         };"
        },
        {
            "sha": "1b43e7b99316e39756a4d64d97a4206f4d77daa6",
            "filename": "turbopack/crates/turbopack-core/src/file_source.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 17,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Ffile_source.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Ffile_source.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Ffile_source.rs?ref=0084361f4ba8b4298aa77afe9eff652d1830c352",
            "patch": "@@ -13,38 +13,48 @@ use crate::{\n /// references to other [Source]s.\n #[turbo_tasks::value]\n pub struct FileSource {\n-    pub path: ResolvedVc<FileSystemPath>,\n-    pub query: ResolvedVc<RcStr>,\n+    path: ResolvedVc<FileSystemPath>,\n+    query: RcStr,\n+    fragment: RcStr,\n+}\n+\n+impl FileSource {\n+    pub fn new(path: Vc<FileSystemPath>) -> Vc<Self> {\n+        FileSource::new_with_query_and_fragment(path, RcStr::default(), RcStr::default())\n+    }\n+    pub fn new_with_query(path: Vc<FileSystemPath>, query: RcStr) -> Vc<Self> {\n+        FileSource::new_with_query_and_fragment(path, query, RcStr::default())\n+    }\n }\n \n #[turbo_tasks::value_impl]\n impl FileSource {\n     #[turbo_tasks::function]\n-    pub fn new(path: ResolvedVc<FileSystemPath>) -> Vc<Self> {\n+    pub fn new_with_query_and_fragment(\n+        path: ResolvedVc<FileSystemPath>,\n+        query: RcStr,\n+        fragment: RcStr,\n+    ) -> Vc<Self> {\n         Self::cell(FileSource {\n             path,\n-            query: ResolvedVc::cell(RcStr::default()),\n+            query,\n+            fragment,\n         })\n     }\n-\n-    #[turbo_tasks::function]\n-    pub async fn new_with_query(\n-        path: ResolvedVc<FileSystemPath>,\n-        query: ResolvedVc<RcStr>,\n-    ) -> Result<Vc<Self>> {\n-        if query.await?.is_empty() {\n-            Ok(Self::new(*path))\n-        } else {\n-            Ok(Self::cell(FileSource { path, query }))\n-        }\n-    }\n }\n \n #[turbo_tasks::value_impl]\n impl Source for FileSource {\n     #[turbo_tasks::function]\n     fn ident(&self) -> Vc<AssetIdent> {\n-        AssetIdent::from_path(*self.path).with_query(*self.query)\n+        let mut ident = AssetIdent::from_path(*self.path);\n+        if !self.query.is_empty() {\n+            ident = ident.with_query(Vc::cell(self.query.clone()));\n+        }\n+        if !self.fragment.is_empty() {\n+            ident = ident.with_fragment(Vc::cell(self.fragment.clone()));\n+        }\n+        ident\n     }\n }\n "
        },
        {
            "sha": "09dd709fe4b66ebbe7755999bbbbb35d467b0ab1",
            "filename": "turbopack/crates/turbopack-core/src/ident.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 16,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fident.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fident.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fident.rs?ref=0084361f4ba8b4298aa77afe9eff652d1830c352",
            "patch": "@@ -15,10 +15,12 @@ use crate::resolve::ModulePart;\n pub struct AssetIdent {\n     /// The primary path of the asset\n     pub path: ResolvedVc<FileSystemPath>,\n-    /// The query string of the asset (e.g. `?foo=bar`)\n+    /// The query string of the asset this is either the empty string or a query string that starts\n+    /// with a `?` (e.g. `?foo=bar`)\n     pub query: ResolvedVc<RcStr>,\n-    /// The fragment of the asset (e.g. `#foo`)\n-    pub fragment: Option<ResolvedVc<RcStr>>,\n+    /// The fragment of the asset, this is either the empty string or a fragment string that starts\n+    /// with a `#` (e.g. `#foo`)\n+    pub fragment: ResolvedVc<RcStr>,\n     /// The assets that are nested in this asset\n     pub assets: Vec<(ResolvedVc<RcStr>, ResolvedVc<AssetIdent>)>,\n     /// The modifiers of this asset (e.g. `client chunks`)\n@@ -57,14 +59,10 @@ impl ValueToString for AssetIdent {\n     async fn to_string(&self) -> Result<Vc<RcStr>> {\n         let mut s = self.path.to_string().owned().await?.into_owned();\n \n-        let query = self.query.await?;\n-        if !query.is_empty() {\n-            write!(s, \"?{}\", &*query)?;\n-        }\n-\n-        if let Some(fragment) = &self.fragment {\n-            write!(s, \"#{}\", fragment.await?)?;\n-        }\n+        // The query string is either empty or non-empty starting with `?` so we can just concat\n+        s.push_str(&self.query.await?);\n+        // ditto for fragment\n+        s.push_str(&self.fragment.await?);\n \n         if !self.assets.is_empty() {\n             s.push_str(\" {\");\n@@ -121,8 +119,19 @@ impl ValueToString for AssetIdent {\n #[turbo_tasks::value_impl]\n impl AssetIdent {\n     #[turbo_tasks::function]\n-    pub fn new(ident: Value<AssetIdent>) -> Vc<Self> {\n-        ident.into_value().cell()\n+    pub async fn new(ident: Value<AssetIdent>) -> Result<Vc<Self>> {\n+        let query = &*ident.query.await?;\n+        // TODO(lukesandberg); downgrade to debug_assert\n+        assert!(\n+            query.is_empty() || query.starts_with(\"?\"),\n+            \"query should be empty or start with a `?`\"\n+        );\n+        let fragment = &*ident.fragment.await?;\n+        assert!(\n+            fragment.is_empty() || fragment.starts_with(\"#\"),\n+            \"query should be empty or start with a `?`\"\n+        );\n+        Ok(ident.into_value().cell())\n     }\n \n     /// Creates an [AssetIdent] from a [Vc<FileSystemPath>]\n@@ -131,7 +140,7 @@ impl AssetIdent {\n         Self::new(Value::new(AssetIdent {\n             path,\n             query: ResolvedVc::cell(RcStr::default()),\n-            fragment: None,\n+            fragment: ResolvedVc::cell(RcStr::default()),\n             assets: Vec::new(),\n             modifiers: Vec::new(),\n             parts: Vec::new(),\n@@ -147,6 +156,13 @@ impl AssetIdent {\n         Self::new(Value::new(this))\n     }\n \n+    #[turbo_tasks::function]\n+    pub fn with_fragment(&self, fragment: ResolvedVc<RcStr>) -> Vc<Self> {\n+        let mut this = self.clone();\n+        this.fragment = fragment;\n+        Self::new(Value::new(this))\n+    }\n+\n     #[turbo_tasks::function]\n     pub fn with_modifier(&self, modifier: ResolvedVc<RcStr>) -> Vc<Self> {\n         let mut this = self.clone();\n@@ -252,9 +268,10 @@ impl AssetIdent {\n             query.deterministic_hash(&mut hasher);\n             has_hash = true;\n         }\n-        if let Some(fragment) = fragment {\n+        let fragment = fragment.await?;\n+        if !fragment.is_empty() {\n             1_u8.deterministic_hash(&mut hasher);\n-            fragment.await?.deterministic_hash(&mut hasher);\n+            fragment.deterministic_hash(&mut hasher);\n             has_hash = true;\n         }\n         for (key, ident) in assets.iter() {"
        },
        {
            "sha": "0ba4790563ade8649a0a31edf075d437e1f57280",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 13,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=0084361f4ba8b4298aa77afe9eff652d1830c352",
            "patch": "@@ -2203,18 +2203,17 @@ async fn resolve_relative_request(\n \n     let fragment_val = fragment.await?;\n     if !fragment_val.is_empty() {\n-        new_path.push(Pattern::Alternatives(\n-            once(Pattern::Constant(\"\".into()))\n-                .chain(once(Pattern::Constant(format!(\"#{fragment_val}\").into())))\n-                .collect(),\n-        ));\n+        new_path.push(Pattern::Alternatives(vec![\n+            Pattern::Constant(RcStr::default()),\n+            Pattern::Constant((*fragment_val).clone()),\n+        ]));\n     }\n \n     if !options_value.fully_specified {\n         // Add the extensions as alternatives to the path\n         // read_matches keeps the order of alternatives intact\n         new_path.push(Pattern::Alternatives(\n-            once(Pattern::Constant(\"\".into()))\n+            once(Pattern::Constant(RcStr::default()))\n                 .chain(\n                     options_value\n                         .extensions\n@@ -2328,10 +2327,7 @@ async fn resolve_relative_request(\n             }\n             if !fragment_val.is_empty() {\n                 // If the fragment is not empty, we need to strip it from the matched pattern\n-                if let Some(matched_pattern) = matched_pattern\n-                    .strip_suffix(&**fragment_val)\n-                    .and_then(|s| s.strip_suffix('#'))\n-                {\n+                if let Some(matched_pattern) = matched_pattern.strip_suffix(&**fragment_val) {\n                     results.push(\n                         resolved(\n                             RequestKey::new(matched_pattern.into()),\n@@ -2864,9 +2860,13 @@ async fn resolved(\n     Ok(*ResolveResult::source_with_affecting_sources(\n         request_key,\n         ResolvedVc::upcast(\n-            FileSource::new_with_query(**path, query)\n-                .to_resolved()\n-                .await?,\n+            FileSource::new_with_query_and_fragment(\n+                **path,\n+                (*query.await?).clone(),\n+                (*fragment.await?).clone(),\n+            )\n+            .to_resolved()\n+            .await?,\n         ),\n         symlinks\n             .iter()"
        },
        {
            "sha": "deb00a6347ff96a9214d2f66200f41da4bc51fd5",
            "filename": "turbopack/crates/turbopack-core/src/resolve/parse.rs",
            "status": "modified",
            "additions": 95,
            "deletions": 33,
            "changes": 128,
            "blob_url": "https://github.com/vercel/next.js/blob/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs?ref=0084361f4ba8b4298aa77afe9eff652d1830c352",
            "patch": "@@ -61,30 +61,32 @@ pub enum Request {\n     },\n }\n \n-fn split_off_query_fragment(raw: RcStr) -> (Pattern, Vc<RcStr>, Vc<RcStr>) {\n-    let Some((raw, query)) = raw.split_once('?') else {\n-        if let Some((raw, fragment)) = raw.split_once('#') {\n-            return (\n-                Pattern::Constant(raw.into()),\n-                Vc::<RcStr>::default(),\n-                Vc::cell(fragment.into()),\n-            );\n+/// Splits a string like `foo?bar#baz` into `(Pattern::Constant('foo'), '?bar', '#baz')`\n+///\n+/// If the hash or query portion are missing they will be empty strings otherwise they will be\n+/// non-empty along with their prepender characters\n+fn split_off_query_fragment(mut raw: &str) -> (Pattern, RcStr, RcStr) {\n+    // Per the URI spec fragments can contain `?` characters, so we should trim it off first\n+    // https://datatracker.ietf.org/doc/html/rfc3986#section-3.5\n+\n+    let hash = match raw.as_bytes().iter().position(|&b| b == b'#') {\n+        Some(pos) => {\n+            let (prefix, hash) = raw.split_at(pos);\n+            raw = prefix;\n+            RcStr::from(hash)\n         }\n-\n-        return (\n-            Pattern::Constant(raw),\n-            Vc::<RcStr>::default(),\n-            Vc::<RcStr>::default(),\n-        );\n+        None => RcStr::default(),\n     };\n \n-    let (query, fragment) = query.split_once('#').unwrap_or((query, \"\"));\n-\n-    (\n-        Pattern::Constant(raw.into()),\n-        Vc::cell(format!(\"?{query}\").into()),\n-        Vc::cell(format!(\"#{fragment}\").into()),\n-    )\n+    let query = match raw.as_bytes().iter().position(|&b| b == b'?') {\n+        Some(pos) => {\n+            let (prefix, query) = raw.split_at(pos);\n+            raw = prefix;\n+            RcStr::from(query)\n+        }\n+        None => RcStr::default(),\n+    };\n+    (Pattern::Constant(RcStr::from(raw)), query, hash)\n }\n \n lazy_static! {\n@@ -164,12 +166,12 @@ impl Request {\n         }\n \n         if r.starts_with('/') {\n-            let (path, query, fragment) = split_off_query_fragment(r);\n+            let (path, query, fragment) = split_off_query_fragment(&r);\n \n             return Ok(Request::ServerRelative {\n                 path,\n-                query: query.to_resolved().await?,\n-                fragment: fragment.to_resolved().await?,\n+                query: ResolvedVc::cell(query),\n+                fragment: ResolvedVc::cell(fragment),\n             });\n         }\n \n@@ -180,23 +182,23 @@ impl Request {\n         }\n \n         if r.starts_with(\"./\") || r.starts_with(\"../\") || r == \".\" || r == \"..\" {\n-            let (path, query, fragment) = split_off_query_fragment(r);\n+            let (path, query, fragment) = split_off_query_fragment(&r);\n \n             return Ok(Request::Relative {\n                 path,\n                 force_in_lookup_dir: false,\n-                query: query.to_resolved().await?,\n-                fragment: fragment.to_resolved().await?,\n+                query: ResolvedVc::cell(query),\n+                fragment: ResolvedVc::cell(fragment),\n             });\n         }\n \n         if WINDOWS_PATH.is_match(&r) {\n-            let (path, query, fragment) = split_off_query_fragment(r);\n+            let (path, query, fragment) = split_off_query_fragment(&r);\n \n             return Ok(Request::Windows {\n                 path,\n-                query: query.to_resolved().await?,\n-                fragment: fragment.to_resolved().await?,\n+                query: ResolvedVc::cell(query),\n+                fragment: ResolvedVc::cell(fragment),\n             });\n         }\n \n@@ -227,13 +229,13 @@ impl Request {\n             .captures(&r)\n             .and_then(|caps| caps.get(1).zip(caps.get(2)))\n         {\n-            let (path, query, fragment) = split_off_query_fragment(path.as_str().into());\n+            let (path, query, fragment) = split_off_query_fragment(path.as_str());\n \n             return Ok(Request::Module {\n                 module: module.as_str().into(),\n                 path,\n-                query: query.to_resolved().await?,\n-                fragment: fragment.to_resolved().await?,\n+                query: ResolvedVc::cell(query),\n+                fragment: ResolvedVc::cell(fragment),\n             });\n         }\n \n@@ -817,3 +819,63 @@ pub async fn stringify_data_uri(\n         data.await?\n     ))\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_split_query_fragment() {\n+        assert_eq!(\n+            (\n+                Pattern::Constant(\"foo\".into()),\n+                RcStr::default(),\n+                RcStr::default()\n+            ),\n+            split_off_query_fragment(\"foo\")\n+        );\n+        // These two cases are a bit odd, but it is important to treat `import './foo?'` differently\n+        // from `import './foo'`, ditto for fragments.\n+        assert_eq!(\n+            (\n+                Pattern::Constant(\"foo\".into()),\n+                RcStr::from(\"?\"),\n+                RcStr::default()\n+            ),\n+            split_off_query_fragment(\"foo?\")\n+        );\n+        assert_eq!(\n+            (\n+                Pattern::Constant(\"foo\".into()),\n+                RcStr::default(),\n+                RcStr::from(\"#\")\n+            ),\n+            split_off_query_fragment(\"foo#\")\n+        );\n+        assert_eq!(\n+            (\n+                Pattern::Constant(\"foo\".into()),\n+                RcStr::from(\"?bar=baz\"),\n+                RcStr::default()\n+            ),\n+            split_off_query_fragment(\"foo?bar=baz\")\n+        );\n+        assert_eq!(\n+            (\n+                Pattern::Constant(\"foo\".into()),\n+                RcStr::default(),\n+                RcStr::from(\"#stuff?bar=baz\")\n+            ),\n+            split_off_query_fragment(\"foo#stuff?bar=baz\")\n+        );\n+\n+        assert_eq!(\n+            (\n+                Pattern::Constant(\"foo\".into()),\n+                RcStr::from(\"?bar=baz\"),\n+                RcStr::from(\"#stuff\")\n+            ),\n+            split_off_query_fragment(\"foo?bar=baz#stuff\")\n+        );\n+    }\n+}"
        },
        {
            "sha": "64f8b8c01e1b6e4fab38f396905891e4a6df13bc",
            "filename": "turbopack/crates/turbopack-css/src/chunk/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs?ref=0084361f4ba8b4298aa77afe9eff652d1830c352",
            "patch": "@@ -194,7 +194,7 @@ impl CssChunk {\n                 ServerFileSystem::new().root().to_resolved().await?\n             },\n             query: ResolvedVc::cell(RcStr::default()),\n-            fragment: None,\n+            fragment: ResolvedVc::cell(RcStr::default()),\n             assets,\n             modifiers: Vec::new(),\n             parts: Vec::new(),"
        },
        {
            "sha": "38a4d98d57d7d053383172d18ee9ed835e3078a3",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fmod.rs?ref=0084361f4ba8b4298aa77afe9eff652d1830c352",
            "patch": "@@ -123,7 +123,7 @@ impl Chunk for EcmascriptChunk {\n                 ServerFileSystem::new().root().to_resolved().await?\n             },\n             query: ResolvedVc::cell(RcStr::default()),\n-            fragment: None,\n+            fragment: ResolvedVc::cell(RcStr::default()),\n             assets,\n             modifiers: Vec::new(),\n             parts: Vec::new(),"
        },
        {
            "sha": "3885dd6f333909576291c2857c0484ff1f61ab5b",
            "filename": "turbopack/crates/turbopack/src/module_options/rule_condition.rs",
            "status": "modified",
            "additions": 269,
            "deletions": 265,
            "changes": 534,
            "blob_url": "https://github.com/vercel/next.js/blob/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0084361f4ba8b4298aa77afe9eff652d1830c352/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs?ref=0084361f4ba8b4298aa77afe9eff652d1830c352",
            "patch": "@@ -222,7 +222,7 @@ impl RuleCondition {\n }\n \n #[cfg(test)]\n-mod tests {\n+pub mod tests {\n     use turbo_tasks::Vc;\n     use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n     use turbo_tasks_fs::{FileContent, FileSystem, VirtualFileSystem};\n@@ -237,144 +237,146 @@ mod tests {\n             BackendOptions::default(),\n             noop_backing_storage(),\n         ));\n-        tt.run_once(async {\n-            let fs = VirtualFileSystem::new();\n-            let virtual_path = fs.root().join(\"foo.js\".into());\n-            let virtual_source = Vc::upcast::<Box<dyn Source>>(VirtualSource::new(\n-                virtual_path,\n-                AssetContent::File(FileContent::NotFound.cell().to_resolved().await?).cell(),\n-            ))\n+        tt.run_once(async { run_leaves_test().await })\n+            .await\n+            .unwrap();\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub async fn run_leaves_test() -> Result<()> {\n+        let fs = VirtualFileSystem::new();\n+        let virtual_path = fs.root().join(\"foo.js\".into());\n+        let virtual_source = Vc::upcast::<Box<dyn Source>>(VirtualSource::new(\n+            virtual_path,\n+            AssetContent::File(FileContent::NotFound.cell().to_resolved().await?).cell(),\n+        ))\n+        .to_resolved()\n+        .await?;\n+\n+        let non_virtual_path = fs.root().join(\"bar.js\".into());\n+        let non_virtual_source = Vc::upcast::<Box<dyn Source>>(FileSource::new(non_virtual_path))\n             .to_resolved()\n             .await?;\n \n-            let non_virtual_path = fs.root().join(\"bar.js\".into());\n-            let non_virtual_source =\n-                Vc::upcast::<Box<dyn Source>>(FileSource::new(non_virtual_path))\n-                    .to_resolved()\n-                    .await?;\n-\n-            {\n-                let condition = RuleCondition::ReferenceType(ReferenceType::Runtime);\n-                assert!(\n-                    condition\n-                        .matches(\n-                            virtual_source,\n-                            &*virtual_path.await?,\n-                            &ReferenceType::Runtime\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-                assert!(\n-                    !condition\n-                        .matches(\n-                            non_virtual_source,\n-                            &*non_virtual_path.await?,\n-                            &ReferenceType::Css(\n-                                turbopack_core::reference_type::CssReferenceSubType::Compose\n-                            )\n+        {\n+            let condition = RuleCondition::ReferenceType(ReferenceType::Runtime);\n+            assert!(\n+                condition\n+                    .matches(\n+                        virtual_source,\n+                        &*virtual_path.await?,\n+                        &ReferenceType::Runtime\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+            assert!(\n+                !condition\n+                    .matches(\n+                        non_virtual_source,\n+                        &*non_virtual_path.await?,\n+                        &ReferenceType::Css(\n+                            turbopack_core::reference_type::CssReferenceSubType::Compose\n                         )\n-                        .await\n-                        .unwrap()\n-                );\n-            }\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+        }\n \n-            {\n-                let condition = RuleCondition::ResourceIsVirtualSource;\n-                assert!(\n-                    condition\n-                        .matches(\n-                            virtual_source,\n-                            &*virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-                assert!(\n-                    !condition\n-                        .matches(\n-                            non_virtual_source,\n-                            &*non_virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-            }\n-            {\n-                let condition = RuleCondition::ResourcePathEquals(virtual_path.await?);\n-                assert!(\n-                    condition\n-                        .matches(\n-                            virtual_source,\n-                            &*virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-                assert!(\n-                    !condition\n-                        .matches(\n-                            non_virtual_source,\n-                            &*non_virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-            }\n-            {\n-                let condition = RuleCondition::ResourcePathHasNoExtension;\n-                assert!(\n-                    condition\n-                        .matches(\n-                            virtual_source,\n-                            &*fs.root().join(\"foo\".into()).await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-                assert!(\n-                    !condition\n-                        .matches(\n-                            non_virtual_source,\n-                            &*non_virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-            }\n-            {\n-                let condition = RuleCondition::ResourcePathEndsWith(\"foo.js\".to_string());\n-                assert!(\n-                    condition\n-                        .matches(\n-                            virtual_source,\n-                            &*virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-                assert!(\n-                    !condition\n-                        .matches(\n-                            non_virtual_source,\n-                            &*non_virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-            }\n-            anyhow::Ok(())\n-        })\n-        .await\n-        .unwrap();\n+        {\n+            let condition = RuleCondition::ResourceIsVirtualSource;\n+            assert!(\n+                condition\n+                    .matches(\n+                        virtual_source,\n+                        &*virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+            assert!(\n+                !condition\n+                    .matches(\n+                        non_virtual_source,\n+                        &*non_virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+        }\n+        {\n+            let condition = RuleCondition::ResourcePathEquals(virtual_path.await?);\n+            assert!(\n+                condition\n+                    .matches(\n+                        virtual_source,\n+                        &*virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+            assert!(\n+                !condition\n+                    .matches(\n+                        non_virtual_source,\n+                        &*non_virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+        }\n+        {\n+            let condition = RuleCondition::ResourcePathHasNoExtension;\n+            assert!(\n+                condition\n+                    .matches(\n+                        virtual_source,\n+                        &*fs.root().join(\"foo\".into()).await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+            assert!(\n+                !condition\n+                    .matches(\n+                        non_virtual_source,\n+                        &*non_virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+        }\n+        {\n+            let condition = RuleCondition::ResourcePathEndsWith(\"foo.js\".to_string());\n+            assert!(\n+                condition\n+                    .matches(\n+                        virtual_source,\n+                        &*virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+            assert!(\n+                !condition\n+                    .matches(\n+                        non_virtual_source,\n+                        &*non_virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+        }\n+        anyhow::Ok(())\n     }\n \n     #[tokio::test]\n@@ -384,141 +386,143 @@ mod tests {\n             BackendOptions::default(),\n             noop_backing_storage(),\n         ));\n-        tt.run_once(async {\n-            let fs = VirtualFileSystem::new();\n-            let virtual_path = fs.root().join(\"foo.js\".into());\n-            let virtual_source = Vc::upcast::<Box<dyn Source>>(VirtualSource::new(\n-                virtual_path,\n-                AssetContent::File(FileContent::NotFound.cell().to_resolved().await?).cell(),\n-            ))\n+        tt.run_once(async { run_rule_condition_tree_test().await })\n+            .await\n+            .unwrap();\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub async fn run_rule_condition_tree_test() -> Result<()> {\n+        let fs = VirtualFileSystem::new();\n+        let virtual_path = fs.root().join(\"foo.js\".into());\n+        let virtual_source = Vc::upcast::<Box<dyn Source>>(VirtualSource::new(\n+            virtual_path,\n+            AssetContent::File(FileContent::NotFound.cell().to_resolved().await?).cell(),\n+        ))\n+        .to_resolved()\n+        .await?;\n+\n+        let non_virtual_path = fs.root().join(\"bar.js\".into());\n+        let non_virtual_source = Vc::upcast::<Box<dyn Source>>(FileSource::new(non_virtual_path))\n             .to_resolved()\n             .await?;\n \n-            let non_virtual_path = fs.root().join(\"bar.js\".into());\n-            let non_virtual_source =\n-                Vc::upcast::<Box<dyn Source>>(FileSource::new(non_virtual_path))\n-                    .to_resolved()\n-                    .await?;\n+        {\n+            // not\n+            let condition = RuleCondition::not(RuleCondition::ResourceIsVirtualSource);\n+            assert!(\n+                !condition\n+                    .matches(\n+                        virtual_source,\n+                        &*virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+            assert!(\n+                condition\n+                    .matches(\n+                        non_virtual_source,\n+                        &*non_virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+        }\n+        {\n+            // any\n+            // Only one of the conditions matches our virtual source\n+            let condition = RuleCondition::any(vec![\n+                RuleCondition::ResourcePathInDirectory(\"doesnt/exist\".to_string()),\n+                RuleCondition::ResourceIsVirtualSource,\n+                RuleCondition::ResourcePathHasNoExtension,\n+            ]);\n+            assert!(\n+                condition\n+                    .matches(\n+                        virtual_source,\n+                        &*virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+            assert!(\n+                !condition\n+                    .matches(\n+                        non_virtual_source,\n+                        &*non_virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+        }\n+        {\n+            // all\n+            // Only one of the conditions matches our virtual source\n+            let condition = RuleCondition::all(vec![\n+                RuleCondition::ResourcePathEndsWith(\"foo.js\".to_string()),\n+                RuleCondition::ResourceIsVirtualSource,\n+                RuleCondition::ResourcePathEquals(virtual_path.await?),\n+            ]);\n+            assert!(\n+                condition\n+                    .matches(\n+                        virtual_source,\n+                        &*virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+            assert!(\n+                !condition\n+                    .matches(\n+                        non_virtual_source,\n+                        &*non_virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+        }\n+        {\n+            // bigger tree\n \n-            {\n-                // not\n-                let condition = RuleCondition::not(RuleCondition::ResourceIsVirtualSource);\n-                assert!(\n-                    !condition\n-                        .matches(\n-                            virtual_source,\n-                            &*virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-                assert!(\n-                    condition\n-                        .matches(\n-                            non_virtual_source,\n-                            &*non_virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-            }\n-            {\n-                // any\n-                // Only one of the conditions matches our virtual source\n-                let condition = RuleCondition::any(vec![\n-                    RuleCondition::ResourcePathInDirectory(\"doesnt/exist\".to_string()),\n-                    RuleCondition::ResourceIsVirtualSource,\n-                    RuleCondition::ResourcePathHasNoExtension,\n-                ]);\n-                assert!(\n-                    condition\n-                        .matches(\n-                            virtual_source,\n-                            &*virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-                assert!(\n-                    !condition\n-                        .matches(\n-                            non_virtual_source,\n-                            &*non_virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-            }\n-            {\n-                // all\n-                // Only one of the conditions matches our virtual source\n-                let condition = RuleCondition::all(vec![\n+            // Build a simple tree to cover our various composite conditions\n+            let condition = RuleCondition::all(vec![\n+                RuleCondition::ResourceIsVirtualSource,\n+                RuleCondition::ResourcePathEquals(virtual_path.await?),\n+                RuleCondition::Not(Box::new(RuleCondition::ResourcePathHasNoExtension)),\n+                RuleCondition::Any(vec![\n                     RuleCondition::ResourcePathEndsWith(\"foo.js\".to_string()),\n-                    RuleCondition::ResourceIsVirtualSource,\n-                    RuleCondition::ResourcePathEquals(virtual_path.await?),\n-                ]);\n-                assert!(\n-                    condition\n-                        .matches(\n-                            virtual_source,\n-                            &*virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-                assert!(\n-                    !condition\n-                        .matches(\n-                            non_virtual_source,\n-                            &*non_virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-            }\n-            {\n-                // bigger tree\n-\n-                // Build a simple tree to cover our various composite conditions\n-                let condition = RuleCondition::all(vec![\n-                    RuleCondition::ResourceIsVirtualSource,\n-                    RuleCondition::ResourcePathEquals(virtual_path.await?),\n-                    RuleCondition::Not(Box::new(RuleCondition::ResourcePathHasNoExtension)),\n-                    RuleCondition::Any(vec![\n-                        RuleCondition::ResourcePathEndsWith(\"foo.js\".to_string()),\n-                        RuleCondition::ContentTypeEmpty,\n-                    ]),\n-                ]);\n-                assert!(\n-                    condition\n-                        .matches(\n-                            virtual_source,\n-                            &*virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-                assert!(\n-                    !condition\n-                        .matches(\n-                            non_virtual_source,\n-                            &*non_virtual_path.await?,\n-                            &ReferenceType::Undefined\n-                        )\n-                        .await\n-                        .unwrap()\n-                );\n-            }\n-            anyhow::Ok(())\n-        })\n-        .await\n-        .unwrap();\n+                    RuleCondition::ContentTypeEmpty,\n+                ]),\n+            ]);\n+            assert!(\n+                condition\n+                    .matches(\n+                        virtual_source,\n+                        &*virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+            assert!(\n+                !condition\n+                    .matches(\n+                        non_virtual_source,\n+                        &*non_virtual_path.await?,\n+                        &ReferenceType::Undefined\n+                    )\n+                    .await\n+                    .unwrap()\n+            );\n+        }\n+        anyhow::Ok(())\n     }\n }"
        }
    ],
    "stats": {
        "total": 793,
        "additions": 445,
        "deletions": 348
    }
}