{
    "author": "mischnic",
    "message": "Turbopack: make graph traversal sync (#83891)\n\nWe can make them sync now.",
    "sha": "f2ebb0701989c0d2456b8fd98a9267358d5ed0bb",
    "files": [
        {
            "sha": "b6927f12243de1d3524a7f6bc026b0a5b39ef9cf",
            "filename": "crates/next-api/src/webpack_stats.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 10,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs?ref=f2ebb0701989c0d2456b8fd98a9267358d5ed0bb",
            "patch": "@@ -58,16 +58,14 @@ where\n     let asset_reasons = {\n         let module_graph = module_graph.read_graphs().await?;\n         let mut edges = vec![];\n-        module_graph\n-            .traverse_all_edges_unordered(|(parent_node, r), current| {\n-                edges.push((\n-                    parent_node.module,\n-                    RcStr::from(format!(\"{}: {}\", r.chunking_type, r.export)),\n-                    current.module,\n-                ));\n-                Ok(())\n-            })\n-            .await?;\n+        module_graph.traverse_all_edges_unordered(|(parent_node, r), current| {\n+            edges.push((\n+                parent_node.module,\n+                RcStr::from(format!(\"{}: {}\", r.chunking_type, r.export)),\n+                current.module,\n+            ));\n+            Ok(())\n+        })?;\n \n         let edges = edges\n             .into_iter()"
        },
        {
            "sha": "86e34ecad1564b104e9356afef7a8777b6bd12c2",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 191,
            "deletions": 197,
            "changes": 388,
            "blob_url": "https://github.com/vercel/next.js/blob/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=f2ebb0701989c0d2456b8fd98a9267358d5ed0bb",
            "patch": "@@ -406,25 +406,23 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n         // First, compute the depth for each module in the graph\n         let module_depth: FxHashMap<ResolvedVc<Box<dyn Module>>, usize> = {\n             let mut module_depth = FxHashMap::default();\n-            graph\n-                .traverse_edges_from_entries_bfs(\n-                    entries.iter().flat_map(|e| e.entries()),\n-                    |parent, node| {\n-                        if let Some((parent, _)) = parent {\n-                            let parent_depth = *module_depth\n-                                .get(&parent.module)\n-                                .context(\"Module depth not found\")?;\n-                            module_depth.entry(node.module).or_insert(parent_depth + 1);\n-                        } else {\n-                            module_depth.insert(node.module, 0);\n-                        };\n+            graph.traverse_edges_from_entries_bfs(\n+                entries.iter().flat_map(|e| e.entries()),\n+                |parent, node| {\n+                    if let Some((parent, _)) = parent {\n+                        let parent_depth = *module_depth\n+                            .get(&parent.module)\n+                            .context(\"Module depth not found\")?;\n+                        module_depth.entry(node.module).or_insert(parent_depth + 1);\n+                    } else {\n+                        module_depth.insert(node.module, 0);\n+                    };\n \n-                        module_chunk_groups.insert(node.module, RoaringBitmapWrapper::default());\n+                    module_chunk_groups.insert(node.module, RoaringBitmapWrapper::default());\n \n-                        Ok(GraphTraversalAction::Continue)\n-                    },\n-                )\n-                .await?;\n+                    Ok(GraphTraversalAction::Continue)\n+                },\n+            )?;\n             module_depth\n         };\n \n@@ -493,200 +491,196 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n             })\n             .collect::<FxHashMap<_, _>>();\n \n-        let visit_count = graph\n-            .traverse_edges_fixed_point_with_priority(\n-                entries\n-                    .iter()\n-                    .flat_map(|e| e.entries())\n-                    .map(|e| {\n-                        Ok((\n-                            e,\n-                            TraversalPriority {\n-                                depth: *module_depth.get(&e).context(\"Module depth not found\")?,\n-                                chunk_group_len: 0,\n-                            },\n-                        ))\n-                    })\n-                    .collect::<Result<Vec<_>>>()?,\n-                &mut module_chunk_groups,\n-                |parent_info: Option<(&'_ SingleModuleGraphModuleNode, &'_ RefData)>,\n-                 node: &'_ SingleModuleGraphModuleNode,\n-                 module_chunk_groups: &mut FxHashMap<\n-                    ResolvedVc<Box<dyn Module>>,\n-                    RoaringBitmapWrapper,\n-                >|\n-                 -> Result<GraphTraversalAction> {\n-                    enum ChunkGroupInheritance<It: Iterator<Item = ChunkGroupKey>> {\n-                        Inherit(ResolvedVc<Box<dyn Module>>),\n-                        ChunkGroup(It),\n-                    }\n-                    let chunk_groups = if let Some((parent, ref_data)) = parent_info {\n-                        match &ref_data.chunking_type {\n-                            ChunkingType::Parallel { .. } => {\n-                                ChunkGroupInheritance::Inherit(parent.module)\n-                            }\n-                            ChunkingType::Async => ChunkGroupInheritance::ChunkGroup(Either::Left(\n-                                std::iter::once(ChunkGroupKey::Async(node.module)),\n-                            )),\n-                            ChunkingType::Isolated {\n-                                merge_tag: None, ..\n-                            } => ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n-                                ChunkGroupKey::Isolated(node.module),\n-                            ))),\n-                            ChunkingType::Shared {\n-                                merge_tag: None, ..\n-                            } => ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n-                                ChunkGroupKey::Shared(node.module),\n-                            ))),\n-                            ChunkingType::Isolated {\n-                                merge_tag: Some(merge_tag),\n-                                ..\n-                            } => {\n-                                let parents = module_chunk_groups\n-                                    .get(&parent.module)\n-                                    .context(\"Module chunk group not found\")?;\n-                                let chunk_groups =\n-                                    parents.iter().map(|parent| ChunkGroupKey::IsolatedMerged {\n-                                        parent: ChunkGroupId(parent),\n-                                        merge_tag: merge_tag.clone(),\n-                                    });\n-                                ChunkGroupInheritance::ChunkGroup(Either::Right(Either::Left(\n-                                    chunk_groups,\n-                                )))\n-                            }\n-                            ChunkingType::Shared {\n-                                merge_tag: Some(merge_tag),\n-                                ..\n-                            } => {\n-                                let parents = module_chunk_groups\n-                                    .get(&parent.module)\n-                                    .context(\"Module chunk group not found\")?;\n-                                let chunk_groups =\n-                                    parents.iter().map(|parent| ChunkGroupKey::SharedMerged {\n-                                        parent: ChunkGroupId(parent),\n-                                        merge_tag: merge_tag.clone(),\n-                                    });\n-                                ChunkGroupInheritance::ChunkGroup(Either::Right(Either::Right(\n-                                    chunk_groups,\n-                                )))\n-                            }\n-                            ChunkingType::Traced => {\n-                                // Traced modules are not placed in chunk groups\n-                                return Ok(GraphTraversalAction::Skip);\n-                            }\n+        let visit_count = graph.traverse_edges_fixed_point_with_priority(\n+            entries\n+                .iter()\n+                .flat_map(|e| e.entries())\n+                .map(|e| {\n+                    Ok((\n+                        e,\n+                        TraversalPriority {\n+                            depth: *module_depth.get(&e).context(\"Module depth not found\")?,\n+                            chunk_group_len: 0,\n+                        },\n+                    ))\n+                })\n+                .collect::<Result<Vec<_>>>()?,\n+            &mut module_chunk_groups,\n+            |parent_info: Option<(&'_ SingleModuleGraphModuleNode, &'_ RefData)>,\n+             node: &'_ SingleModuleGraphModuleNode,\n+             module_chunk_groups: &mut FxHashMap<\n+                ResolvedVc<Box<dyn Module>>,\n+                RoaringBitmapWrapper,\n+            >|\n+             -> Result<GraphTraversalAction> {\n+                enum ChunkGroupInheritance<It: Iterator<Item = ChunkGroupKey>> {\n+                    Inherit(ResolvedVc<Box<dyn Module>>),\n+                    ChunkGroup(It),\n+                }\n+                let chunk_groups = if let Some((parent, ref_data)) = parent_info {\n+                    match &ref_data.chunking_type {\n+                        ChunkingType::Parallel { .. } => {\n+                            ChunkGroupInheritance::Inherit(parent.module)\n                         }\n-                    } else {\n-                        ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n-                            // TODO remove clone\n-                            entry_chunk_group_keys\n-                                .get(&node.module)\n-                                .context(\"Module chunk group not found\")?\n-                                .clone(),\n-                        )))\n-                    };\n+                        ChunkingType::Async => ChunkGroupInheritance::ChunkGroup(Either::Left(\n+                            std::iter::once(ChunkGroupKey::Async(node.module)),\n+                        )),\n+                        ChunkingType::Isolated {\n+                            merge_tag: None, ..\n+                        } => ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n+                            ChunkGroupKey::Isolated(node.module),\n+                        ))),\n+                        ChunkingType::Shared {\n+                            merge_tag: None, ..\n+                        } => ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n+                            ChunkGroupKey::Shared(node.module),\n+                        ))),\n+                        ChunkingType::Isolated {\n+                            merge_tag: Some(merge_tag),\n+                            ..\n+                        } => {\n+                            let parents = module_chunk_groups\n+                                .get(&parent.module)\n+                                .context(\"Module chunk group not found\")?;\n+                            let chunk_groups =\n+                                parents.iter().map(|parent| ChunkGroupKey::IsolatedMerged {\n+                                    parent: ChunkGroupId(parent),\n+                                    merge_tag: merge_tag.clone(),\n+                                });\n+                            ChunkGroupInheritance::ChunkGroup(Either::Right(Either::Left(\n+                                chunk_groups,\n+                            )))\n+                        }\n+                        ChunkingType::Shared {\n+                            merge_tag: Some(merge_tag),\n+                            ..\n+                        } => {\n+                            let parents = module_chunk_groups\n+                                .get(&parent.module)\n+                                .context(\"Module chunk group not found\")?;\n+                            let chunk_groups =\n+                                parents.iter().map(|parent| ChunkGroupKey::SharedMerged {\n+                                    parent: ChunkGroupId(parent),\n+                                    merge_tag: merge_tag.clone(),\n+                                });\n+                            ChunkGroupInheritance::ChunkGroup(Either::Right(Either::Right(\n+                                chunk_groups,\n+                            )))\n+                        }\n+                        ChunkingType::Traced => {\n+                            // Traced modules are not placed in chunk groups\n+                            return Ok(GraphTraversalAction::Skip);\n+                        }\n+                    }\n+                } else {\n+                    ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n+                        // TODO remove clone\n+                        entry_chunk_group_keys\n+                            .get(&node.module)\n+                            .context(\"Module chunk group not found\")?\n+                            .clone(),\n+                    )))\n+                };\n \n-                    Ok(match chunk_groups {\n-                        ChunkGroupInheritance::ChunkGroup(chunk_groups) => {\n-                            // Start of a new chunk group, don't inherit anything from parent\n-                            let chunk_group_ids = chunk_groups.map(|chunk_group| {\n-                                let len = chunk_groups_map.len();\n-                                let is_merged = matches!(\n-                                    chunk_group,\n-                                    ChunkGroupKey::IsolatedMerged { .. }\n-                                        | ChunkGroupKey::SharedMerged { .. }\n-                                );\n-                                match chunk_groups_map.entry(chunk_group) {\n-                                    Entry::Occupied(mut e) => {\n-                                        let (id, merged_entries) = e.get_mut();\n-                                        if is_merged {\n-                                            merged_entries.insert(node.module);\n-                                        }\n-                                        **id\n+                Ok(match chunk_groups {\n+                    ChunkGroupInheritance::ChunkGroup(chunk_groups) => {\n+                        // Start of a new chunk group, don't inherit anything from parent\n+                        let chunk_group_ids = chunk_groups.map(|chunk_group| {\n+                            let len = chunk_groups_map.len();\n+                            let is_merged = matches!(\n+                                chunk_group,\n+                                ChunkGroupKey::IsolatedMerged { .. }\n+                                    | ChunkGroupKey::SharedMerged { .. }\n+                            );\n+                            match chunk_groups_map.entry(chunk_group) {\n+                                Entry::Occupied(mut e) => {\n+                                    let (id, merged_entries) = e.get_mut();\n+                                    if is_merged {\n+                                        merged_entries.insert(node.module);\n                                     }\n-                                    Entry::Vacant(e) => {\n-                                        let chunk_group_id = len as u32;\n-                                        let mut set = FxIndexSet::default();\n-                                        if is_merged {\n-                                            set.insert(node.module);\n-                                        }\n-                                        e.insert((ChunkGroupId(chunk_group_id), set));\n-                                        chunk_group_id\n+                                    **id\n+                                }\n+                                Entry::Vacant(e) => {\n+                                    let chunk_group_id = len as u32;\n+                                    let mut set = FxIndexSet::default();\n+                                    if is_merged {\n+                                        set.insert(node.module);\n                                     }\n+                                    e.insert((ChunkGroupId(chunk_group_id), set));\n+                                    chunk_group_id\n                                 }\n-                            });\n+                            }\n+                        });\n \n-                            let chunk_groups =\n-                                RoaringBitmapWrapper(RoaringBitmap::from_iter(chunk_group_ids));\n+                        let chunk_groups =\n+                            RoaringBitmapWrapper(RoaringBitmap::from_iter(chunk_group_ids));\n \n-                            // Assign chunk group to the target node (the entry of the chunk group)\n-                            let bitset = module_chunk_groups\n-                                .get_mut(&node.module)\n-                                .context(\"Module chunk group not found\")?;\n-                            if chunk_groups.is_proper_superset(bitset) {\n-                                // Add bits from parent, and continue traversal because changed\n-                                **bitset |= chunk_groups.into_inner();\n+                        // Assign chunk group to the target node (the entry of the chunk group)\n+                        let bitset = module_chunk_groups\n+                            .get_mut(&node.module)\n+                            .context(\"Module chunk group not found\")?;\n+                        if chunk_groups.is_proper_superset(bitset) {\n+                            // Add bits from parent, and continue traversal because changed\n+                            **bitset |= chunk_groups.into_inner();\n \n+                            GraphTraversalAction::Continue\n+                        } else {\n+                            // Unchanged, no need to forward to children\n+                            GraphTraversalAction::Skip\n+                        }\n+                    }\n+                    ChunkGroupInheritance::Inherit(parent) => {\n+                        // Inherit chunk groups from parent, merge parent chunk groups into\n+                        // current\n+\n+                        if parent == node.module {\n+                            // A self-reference\n+                            GraphTraversalAction::Skip\n+                        } else {\n+                            let [Some(parent_chunk_groups), Some(current_chunk_groups)] =\n+                                module_chunk_groups.get_disjoint_mut([&parent, &node.module])\n+                            else {\n+                                // All modules are inserted in the previous iteration\n+                                // Technically unreachable, but could be reached due to eventual\n+                                // consistency\n+                                bail!(\"Module chunk groups not found\");\n+                            };\n+\n+                            if current_chunk_groups.is_empty() {\n+                                // Initial visit, clone instead of merging\n+                                *current_chunk_groups = parent_chunk_groups.clone();\n+                                GraphTraversalAction::Continue\n+                            } else if parent_chunk_groups.is_proper_superset(current_chunk_groups) {\n+                                // Add bits from parent, and continue traversal because changed\n+                                **current_chunk_groups |= &**parent_chunk_groups;\n                                 GraphTraversalAction::Continue\n                             } else {\n                                 // Unchanged, no need to forward to children\n                                 GraphTraversalAction::Skip\n                             }\n                         }\n-                        ChunkGroupInheritance::Inherit(parent) => {\n-                            // Inherit chunk groups from parent, merge parent chunk groups into\n-                            // current\n-\n-                            if parent == node.module {\n-                                // A self-reference\n-                                GraphTraversalAction::Skip\n-                            } else {\n-                                let [Some(parent_chunk_groups), Some(current_chunk_groups)] =\n-                                    module_chunk_groups.get_disjoint_mut([&parent, &node.module])\n-                                else {\n-                                    // All modules are inserted in the previous iteration\n-                                    // Technically unreachable, but could be reached due to eventual\n-                                    // consistency\n-                                    bail!(\"Module chunk groups not found\");\n-                                };\n-\n-                                if current_chunk_groups.is_empty() {\n-                                    // Initial visit, clone instead of merging\n-                                    *current_chunk_groups = parent_chunk_groups.clone();\n-                                    GraphTraversalAction::Continue\n-                                } else if parent_chunk_groups\n-                                    .is_proper_superset(current_chunk_groups)\n-                                {\n-                                    // Add bits from parent, and continue traversal because changed\n-                                    **current_chunk_groups |= &**parent_chunk_groups;\n-                                    GraphTraversalAction::Continue\n-                                } else {\n-                                    // Unchanged, no need to forward to children\n-                                    GraphTraversalAction::Skip\n-                                }\n-                            }\n-                        }\n-                    })\n-                },\n-                // This priority is used as a heuristic to keep the number of retraversals down, by\n-                // - keeping it similar to a BFS via the depth priority\n-                // - prioritizing smaller chunk groups which are expected to themselves reference\n-                //   bigger chunk groups (i.e. shared code deeper down in the graph).\n-                //\n-                // Both try to first visit modules with a large dependency subgraph first (which\n-                // would be higher in the graph and are included by few chunks themselves).\n-                |successor, module_chunk_groups| {\n-                    Ok(TraversalPriority {\n-                        depth: *module_depth\n-                            .get(&successor.module)\n-                            .context(\"Module depth not found\")?,\n-                        chunk_group_len: module_chunk_groups\n-                            .get(&successor.module)\n-                            .context(\"Module chunk group not found\")?\n-                            .len(),\n-                    })\n-                },\n-            )\n-            .await?;\n+                    }\n+                })\n+            },\n+            // This priority is used as a heuristic to keep the number of retraversals down, by\n+            // - keeping it similar to a BFS via the depth priority\n+            // - prioritizing smaller chunk groups which are expected to themselves reference\n+            //   bigger chunk groups (i.e. shared code deeper down in the graph).\n+            //\n+            // Both try to first visit modules with a large dependency subgraph first (which\n+            // would be higher in the graph and are included by few chunks themselves).\n+            |successor, module_chunk_groups| {\n+                Ok(TraversalPriority {\n+                    depth: *module_depth\n+                        .get(&successor.module)\n+                        .context(\"Module depth not found\")?,\n+                    chunk_group_len: module_chunk_groups\n+                        .get(&successor.module)\n+                        .context(\"Module chunk group not found\")?\n+                        .len(),\n+                })\n+            },\n+        )?;\n \n         span.record(\"visit_count\", visit_count);\n         span.record(\"chunk_group_count\", chunk_groups_map.len());"
        },
        {
            "sha": "a6f8a68617b19f8ab7c5195f45f6898a6e823a19",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/export_usage.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 26,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fexport_usage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fexport_usage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fexport_usage.rs?ref=f2ebb0701989c0d2456b8fd98a9267358d5ed0bb",
            "patch": "@@ -14,38 +14,35 @@ pub async fn compute_export_usage_info(\n ) -> Result<Vc<ExportUsageInfo>> {\n     let mut used_exports = FxHashMap::<_, ModuleExportUsageInfo>::default();\n     let graph = graph.read_graphs().await?;\n-    graph\n-        .traverse_all_edges_unordered(|(_, ref_data), target| {\n-            let e = used_exports.entry(target.module).or_default();\n+    graph.traverse_all_edges_unordered(|(_, ref_data), target| {\n+        let e = used_exports.entry(target.module).or_default();\n \n-            e.add(&ref_data.export);\n+        e.add(&ref_data.export);\n+\n+        Ok(())\n+    })?;\n \n-            Ok(())\n-        })\n-        .await?;\n     // Compute cycles and select modules to be 'circuit breakers'\n     // A circuit breaker module will need to eagerly export lazy getters for its exports to break an\n     // evaluation cycle all other modules can export values after defining them\n     let mut circuit_breakers = FxHashSet::default();\n-    graph\n-        .traverse_cycles(\n-            |e| e.chunking_type.is_parallel(),\n-            |cycle| {\n-                // To break cycles we need to ensure that no importing module can observe a\n-                // partially populated exports object.\n-\n-                // We could compute this based on the module graph via a DFS from each entry point\n-                // to the cycle.  Whatever node is hit first is an entry point to the cycle.\n-                // (scope hoisting does something similar) and then we would only need to\n-                // mark 'entry' modules (basically the targets of back edges in the export graph) as\n-                // circuit breakers.  For now we just mark everything on the theory that cycles are\n-                // rare.  For vercel-site on 8/22/2025 there were 106 cycles covering 800 modules\n-                // (or 1.2% of all modules).  So with this analysis we could potentially drop 80% of\n-                // the cycle breaker modules.\n-                circuit_breakers.extend(cycle.iter().map(|n| n.module));\n-            },\n-        )\n-        .await?;\n+    graph.traverse_cycles(\n+        |e| e.chunking_type.is_parallel(),\n+        |cycle| {\n+            // To break cycles we need to ensure that no importing module can observe a\n+            // partially populated exports object.\n+\n+            // We could compute this based on the module graph via a DFS from each entry point\n+            // to the cycle.  Whatever node is hit first is an entry point to the cycle.\n+            // (scope hoisting does something similar) and then we would only need to\n+            // mark 'entry' modules (basically the targets of back edges in the export graph) as\n+            // circuit breakers.  For now we just mark everything on the theory that cycles are\n+            // rare.  For vercel-site on 8/22/2025 there were 106 cycles covering 800 modules\n+            // (or 1.2% of all modules).  So with this analysis we could potentially drop 80% of\n+            // the cycle breaker modules.\n+            circuit_breakers.extend(cycle.iter().map(|n| n.module));\n+        },\n+    )?;\n \n     Ok(ExportUsageInfo {\n         used_exports,"
        },
        {
            "sha": "61fc6f06155484a562ef031e0f0bbeccee2c12f9",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/merged_modules.rs",
            "status": "modified",
            "additions": 164,
            "deletions": 172,
            "changes": 336,
            "blob_url": "https://github.com/vercel/next.js/blob/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs?ref=f2ebb0701989c0d2456b8fd98a9267358d5ed0bb",
            "patch": "@@ -118,87 +118,84 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             .collect::<FxHashSet<_>>();\n \n         let mut next_index = 0u32;\n-        let visit_count = module_graph\n-            .traverse_edges_fixed_point_with_priority(\n-                entries.iter().map(|e| (*e, 0)),\n-                &mut (),\n-                |parent_info: Option<(&'_ SingleModuleGraphModuleNode, &'_ RefData)>,\n-                 node: &'_ SingleModuleGraphModuleNode,\n-                 _|\n-                 -> Result<GraphTraversalAction> {\n-                    // On the down traversal, establish which edges are mergeable and set the list\n-                    // indices.\n-                    let (parent_module, hoisted) =\n-                        parent_info.map_or((None, false), |(node, ty)| {\n-                            (\n-                                Some(node.module),\n-                                match &ty.chunking_type {\n-                                    ChunkingType::Parallel { hoisted, .. } => *hoisted,\n-                                    _ => false,\n-                                },\n-                            )\n-                        });\n-                    let module = node.module;\n-\n-                    Ok(if parent_module.is_some_and(|p| p == module) {\n-                        // A self-reference\n+        let visit_count = module_graph.traverse_edges_fixed_point_with_priority(\n+            entries.iter().map(|e| (*e, 0)),\n+            &mut (),\n+            |parent_info: Option<(&'_ SingleModuleGraphModuleNode, &'_ RefData)>,\n+             node: &'_ SingleModuleGraphModuleNode,\n+             _|\n+             -> Result<GraphTraversalAction> {\n+                // On the down traversal, establish which edges are mergeable and set the list\n+                // indices.\n+                let (parent_module, hoisted) = parent_info.map_or((None, false), |(node, ty)| {\n+                    (\n+                        Some(node.module),\n+                        match &ty.chunking_type {\n+                            ChunkingType::Parallel { hoisted, .. } => *hoisted,\n+                            _ => false,\n+                        },\n+                    )\n+                });\n+                let module = node.module;\n+\n+                Ok(if parent_module.is_some_and(|p| p == module) {\n+                    // A self-reference\n+                    GraphTraversalAction::Skip\n+                } else if hoisted\n+                    && let Some(parent_module) = parent_module\n+                    && mergeable.contains(&parent_module)\n+                    && mergeable.contains(&module)\n+                    && !async_module_info.contains(&parent_module)\n+                    && !async_module_info.contains(&module)\n+                {\n+                    // ^ TODO technically we could merge a sync child into an async parent\n+\n+                    // A hoisted reference from a mergeable module to a non-async mergeable\n+                    // module, inherit bitmaps from parent.\n+                    module_merged_groups.entry(node.module).or_default();\n+                    let [Some(parent_merged_groups), Some(current_merged_groups)] =\n+                        module_merged_groups.get_disjoint_mut([&parent_module, &node.module])\n+                    else {\n+                        // All modules are inserted in the previous iteration\n+                        bail!(\"unreachable except for eventual consistency\");\n+                    };\n+\n+                    if current_merged_groups.is_empty() {\n+                        // Initial visit, clone instead of merging\n+                        *current_merged_groups = parent_merged_groups.clone();\n+                        GraphTraversalAction::Continue\n+                    } else if parent_merged_groups.is_proper_superset(current_merged_groups) {\n+                        // Add bits from parent, and continue traversal because changed\n+                        **current_merged_groups |= &**parent_merged_groups;\n+                        GraphTraversalAction::Continue\n+                    } else {\n+                        // Unchanged, no need to forward to children\n                         GraphTraversalAction::Skip\n-                    } else if hoisted\n-                        && let Some(parent_module) = parent_module\n-                        && mergeable.contains(&parent_module)\n-                        && mergeable.contains(&module)\n-                        && !async_module_info.contains(&parent_module)\n-                        && !async_module_info.contains(&module)\n-                    {\n-                        // ^ TODO technically we could merge a sync child into an async parent\n-\n-                        // A hoisted reference from a mergeable module to a non-async mergeable\n-                        // module, inherit bitmaps from parent.\n-                        module_merged_groups.entry(node.module).or_default();\n-                        let [Some(parent_merged_groups), Some(current_merged_groups)] =\n-                            module_merged_groups.get_disjoint_mut([&parent_module, &node.module])\n-                        else {\n-                            // All modules are inserted in the previous iteration\n-                            bail!(\"unreachable except for eventual consistency\");\n-                        };\n+                    }\n+                } else {\n+                    // Either a non-hoisted reference or an incompatible parent or child module\n \n-                        if current_merged_groups.is_empty() {\n-                            // Initial visit, clone instead of merging\n-                            *current_merged_groups = parent_merged_groups.clone();\n-                            GraphTraversalAction::Continue\n-                        } else if parent_merged_groups.is_proper_superset(current_merged_groups) {\n-                            // Add bits from parent, and continue traversal because changed\n-                            **current_merged_groups |= &**parent_merged_groups;\n+                    if entry_modules.insert(module) {\n+                        // Not assigned a new group before, create a new one.\n+                        let idx = next_index;\n+                        next_index += 1;\n+\n+                        if module_merged_groups.entry(module).or_default().insert(idx) {\n+                            // Mark and continue traversal because modified (or first visit)\n                             GraphTraversalAction::Continue\n                         } else {\n                             // Unchanged, no need to forward to children\n                             GraphTraversalAction::Skip\n                         }\n                     } else {\n-                        // Either a non-hoisted reference or an incompatible parent or child module\n-\n-                        if entry_modules.insert(module) {\n-                            // Not assigned a new group before, create a new one.\n-                            let idx = next_index;\n-                            next_index += 1;\n-\n-                            if module_merged_groups.entry(module).or_default().insert(idx) {\n-                                // Mark and continue traversal because modified (or first visit)\n-                                GraphTraversalAction::Continue\n-                            } else {\n-                                // Unchanged, no need to forward to children\n-                                GraphTraversalAction::Skip\n-                            }\n-                        } else {\n-                            // Already visited and assigned a new group, no need to forward to\n-                            // children.\n-                            GraphTraversalAction::Skip\n-                        }\n-                    })\n-                },\n-                |_, _| Ok(0),\n-            )\n-            .await?;\n+                        // Already visited and assigned a new group, no need to forward to\n+                        // children.\n+                        GraphTraversalAction::Skip\n+                    }\n+                })\n+            },\n+            |_, _| Ok(0),\n+        )?;\n \n         span.record(\"visit_count\", visit_count);\n \n@@ -250,73 +247,70 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             // execution order.\n             let mut visited = FxHashSet::default();\n \n-            module_graph\n-                .traverse_edges_from_entries_dfs(\n-                    chunk_group.entries(),\n-                    &mut (),\n-                    |parent_info, node, _| {\n-                        if parent_info.is_none_or(|(_, r)| r.chunking_type.is_parallel())\n-                            && visited.insert(node.module)\n-                        {\n-                            Ok(GraphTraversalAction::Continue)\n-                        } else {\n-                            Ok(GraphTraversalAction::Exclude)\n-                        }\n-                    },\n-                    |parent_info, node, _| {\n-                        let module = node.module;\n-                        let bitmap = module_merged_groups\n-                            .get(&module)\n-                            .context(\"every module should have a bitmap at this point\")?;\n-\n-                        if mergeable.contains(&module) {\n-                            let mergeable_module =\n-                                ResolvedVc::try_downcast::<Box<dyn MergeableModule>>(module)\n-                                    .unwrap();\n-                            match chunk_lists.entry(bitmap) {\n-                                Entry::Vacant(e) => {\n-                                    // New list, insert the module\n-                                    let idx = lists.len();\n-                                    e.insert(idx);\n-                                    lists.push(vec![mergeable_module]);\n-                                    lists_reverse_indices\n-                                        .entry(mergeable_module)\n-                                        .or_default()\n-                                        .insert(ListOccurrence {\n-                                            list: idx,\n-                                            entry: 0,\n-                                        });\n-                                }\n-                                Entry::Occupied(e) => {\n-                                    let list_idx = *e.get();\n-                                    let list = &mut lists[list_idx];\n-                                    list.push(mergeable_module);\n-                                    lists_reverse_indices\n-                                        .entry(mergeable_module)\n-                                        .or_default()\n-                                        .insert(ListOccurrence {\n-                                            list: list_idx,\n-                                            entry: list.len() - 1,\n-                                        });\n-                                }\n+            module_graph.traverse_edges_from_entries_dfs(\n+                chunk_group.entries(),\n+                &mut (),\n+                |parent_info, node, _| {\n+                    if parent_info.is_none_or(|(_, r)| r.chunking_type.is_parallel())\n+                        && visited.insert(node.module)\n+                    {\n+                        Ok(GraphTraversalAction::Continue)\n+                    } else {\n+                        Ok(GraphTraversalAction::Exclude)\n+                    }\n+                },\n+                |parent_info, node, _| {\n+                    let module = node.module;\n+                    let bitmap = module_merged_groups\n+                        .get(&module)\n+                        .context(\"every module should have a bitmap at this point\")?;\n+\n+                    if mergeable.contains(&module) {\n+                        let mergeable_module =\n+                            ResolvedVc::try_downcast::<Box<dyn MergeableModule>>(module).unwrap();\n+                        match chunk_lists.entry(bitmap) {\n+                            Entry::Vacant(e) => {\n+                                // New list, insert the module\n+                                let idx = lists.len();\n+                                e.insert(idx);\n+                                lists.push(vec![mergeable_module]);\n+                                lists_reverse_indices\n+                                    .entry(mergeable_module)\n+                                    .or_default()\n+                                    .insert(ListOccurrence {\n+                                        list: idx,\n+                                        entry: 0,\n+                                    });\n+                            }\n+                            Entry::Occupied(e) => {\n+                                let list_idx = *e.get();\n+                                let list = &mut lists[list_idx];\n+                                list.push(mergeable_module);\n+                                lists_reverse_indices\n+                                    .entry(mergeable_module)\n+                                    .or_default()\n+                                    .insert(ListOccurrence {\n+                                        list: list_idx,\n+                                        entry: list.len() - 1,\n+                                    });\n                             }\n                         }\n+                    }\n \n-                        if let Some((parent, _)) = parent_info {\n-                            let same_bitmap = module_merged_groups.get(&parent.module).unwrap()\n-                                == module_merged_groups.get(&module).unwrap();\n+                    if let Some((parent, _)) = parent_info {\n+                        let same_bitmap = module_merged_groups.get(&parent.module).unwrap()\n+                            == module_merged_groups.get(&module).unwrap();\n \n-                            if same_bitmap {\n-                                intra_group_references_rev\n-                                    .entry(module)\n-                                    .or_default()\n-                                    .insert(parent.module);\n-                            }\n+                        if same_bitmap {\n+                            intra_group_references_rev\n+                                .entry(module)\n+                                .or_default()\n+                                .insert(parent.module);\n                         }\n-                        Ok(())\n-                    },\n-                )\n-                .await?;\n+                    }\n+                    Ok(())\n+                },\n+            )?;\n         }\n \n         // We use list.pop() below, so reverse order using negation\n@@ -331,45 +325,43 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n         let mut exposed_modules_namespace: FxHashSet<ResolvedVc<Box<dyn Module>>> =\n             FxHashSet::with_capacity_and_hasher(module_merged_groups.len(), Default::default());\n \n-        module_graph\n-            .traverse_edges_from_entries_dfs(\n-                entries,\n-                &mut (),\n-                |_, _, _| Ok(GraphTraversalAction::Continue),\n-                |parent_info, node, _| {\n-                    let module = node.module;\n-\n-                    if let Some((parent, _)) = parent_info {\n-                        let same_bitmap = module_merged_groups.get(&parent.module).unwrap()\n-                            == module_merged_groups.get(&module).unwrap();\n-\n-                        if same_bitmap {\n-                            intra_group_references\n-                                .entry(parent.module)\n-                                .or_default()\n-                                .insert(module);\n-                        }\n+        module_graph.traverse_edges_from_entries_dfs(\n+            entries,\n+            &mut (),\n+            |_, _, _| Ok(GraphTraversalAction::Continue),\n+            |parent_info, node, _| {\n+                let module = node.module;\n+\n+                if let Some((parent, _)) = parent_info {\n+                    let same_bitmap = module_merged_groups.get(&parent.module).unwrap()\n+                        == module_merged_groups.get(&module).unwrap();\n+\n+                    if same_bitmap {\n+                        intra_group_references\n+                            .entry(parent.module)\n+                            .or_default()\n+                            .insert(module);\n                     }\n+                }\n \n-                    if parent_info.is_none_or(|(parent, _)| {\n-                        module_merged_groups.get(&parent.module).unwrap()\n-                            != module_merged_groups.get(&module).unwrap()\n-                    }) {\n-                        // This module needs to be exposed:\n-                        // - referenced from another group or\n-                        // - an entry module (TODO assume it will be required for Node/Edge, but not\n-                        // necessarily needed for browser),\n-                        exposed_modules_imported.insert(module);\n-                    }\n-                    if parent_info.is_some_and(|(_, r)| matches!(r.export, ExportUsage::All)) {\n-                        // This module needs to be exposed:\n-                        // - namespace import from another group\n-                        exposed_modules_namespace.insert(module);\n-                    }\n-                    Ok(())\n-                },\n-            )\n-            .await?;\n+                if parent_info.is_none_or(|(parent, _)| {\n+                    module_merged_groups.get(&parent.module).unwrap()\n+                        != module_merged_groups.get(&module).unwrap()\n+                }) {\n+                    // This module needs to be exposed:\n+                    // - referenced from another group or\n+                    // - an entry module (TODO assume it will be required for Node/Edge, but not\n+                    // necessarily needed for browser),\n+                    exposed_modules_imported.insert(module);\n+                }\n+                if parent_info.is_some_and(|(_, r)| matches!(r.export, ExportUsage::All)) {\n+                    // This module needs to be exposed:\n+                    // - namespace import from another group\n+                    exposed_modules_namespace.insert(module);\n+                }\n+                Ok(())\n+            },\n+        )?;\n \n         while let Some((_, common_occurrences)) = lists_reverse_indices.pop() {\n             if common_occurrences.len() < 2 {"
        },
        {
            "sha": "d639a9b8df6883dae96a9faebfd35ce60e5c68b9",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=f2ebb0701989c0d2456b8fd98a9267358d5ed0bb",
            "patch": "@@ -1247,7 +1247,7 @@ impl ModuleGraphRef {\n     ///    - Receives (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode, state &S\n     ///    - Can return [GraphTraversalAction]s to control the traversal\n-    pub async fn traverse_edges_from_entries_bfs(\n+    pub fn traverse_edges_from_entries_bfs(\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         mut visitor: impl FnMut(\n@@ -1301,7 +1301,7 @@ impl ModuleGraphRef {\n     ///    - Receives (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode, state &S\n     ///    - Can return [GraphTraversalAction]s to control the traversal\n-    pub async fn traverse_edges_from_entry(\n+    pub fn traverse_edges_from_entry(\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         mut visitor: impl FnMut(\n@@ -1352,7 +1352,7 @@ impl ModuleGraphRef {\n     /// * `visitor` - Called before visiting the children of a node.\n     ///    - Receives (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode\n-    pub async fn traverse_all_edges_unordered(\n+    pub fn traverse_all_edges_unordered(\n         &self,\n         mut visitor: impl FnMut(\n             (&'_ SingleModuleGraphModuleNode, &'_ RefData),\n@@ -1398,7 +1398,7 @@ impl ModuleGraphRef {\n     ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode, state &S\n     ///    - Can return [GraphTraversalAction]s to control the traversal\n-    pub async fn traverse_edges_from_entries_dfs<S>(\n+    pub fn traverse_edges_from_entries_dfs<S>(\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         state: &mut S,\n@@ -1485,7 +1485,7 @@ impl ModuleGraphRef {\n \n     /// Traverse all cycles in the graph (where the edge filter returns true for the whole cycle)\n     /// and call the visitor with the nodes in the cycle.\n-    pub async fn traverse_cycles(\n+    pub fn traverse_cycles(\n         &self,\n         edge_filter: impl Fn(&RefData) -> bool,\n         mut visit_cycle: impl FnMut(&[&SingleModuleGraphModuleNode]),\n@@ -1517,7 +1517,7 @@ impl ModuleGraphRef {\n     ///\n     /// Returns the number of node visits (i.e. higher than the node count if there are\n     /// retraversals).\n-    pub async fn traverse_edges_fixed_point_with_priority<S, P: Ord>(\n+    pub fn traverse_edges_fixed_point_with_priority<S, P: Ord>(\n         &self,\n         entries: impl IntoIterator<Item = (ResolvedVc<Box<dyn Module>>, P)>,\n         state: &mut S,"
        },
        {
            "sha": "3401ec0b9e7fcb617961adb3f73d9fcf87ef512f",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/module_batches.rs",
            "status": "modified",
            "additions": 73,
            "deletions": 79,
            "changes": 152,
            "blob_url": "https://github.com/vercel/next.js/blob/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs?ref=f2ebb0701989c0d2456b8fd98a9267358d5ed0bb",
            "patch": "@@ -284,48 +284,46 @@ impl PreBatches {\n             this: self,\n         };\n         let mut visited = FxHashSet::default();\n-        module_graph\n-            .traverse_edges_from_entries_dfs(\n-                std::iter::once(entry),\n-                &mut state,\n-                |parent_info, node, state| {\n-                    let ty = parent_info.map_or(\n-                        &ChunkingType::Parallel {\n-                            inherit_async: false,\n-                            hoisted: false,\n-                        },\n-                        |(_, ty)| &ty.chunking_type,\n-                    );\n-                    let module = node.module;\n-                    if !ty.is_parallel() {\n-                        state.items.push(PreBatchItem::NonParallelEdge(\n-                            ty.without_inherit_async(),\n+        module_graph.traverse_edges_from_entries_dfs(\n+            std::iter::once(entry),\n+            &mut state,\n+            |parent_info, node, state| {\n+                let ty = parent_info.map_or(\n+                    &ChunkingType::Parallel {\n+                        inherit_async: false,\n+                        hoisted: false,\n+                    },\n+                    |(_, ty)| &ty.chunking_type,\n+                );\n+                let module = node.module;\n+                if !ty.is_parallel() {\n+                    state.items.push(PreBatchItem::NonParallelEdge(\n+                        ty.without_inherit_async(),\n+                        module,\n+                    ));\n+                    return Ok(GraphTraversalAction::Exclude);\n+                }\n+                if visited.insert(module) {\n+                    if parent_info.is_some() && state.this.boundary_modules.contains(&module) {\n+                        let idx = state.this.ensure_pre_batch_for_module(\n                             module,\n-                        ));\n+                            chunk_group_info,\n+                            queue,\n+                        )?;\n+                        state.items.push(PreBatchItem::ParallelReference(idx));\n                         return Ok(GraphTraversalAction::Exclude);\n                     }\n-                    if visited.insert(module) {\n-                        if parent_info.is_some() && state.this.boundary_modules.contains(&module) {\n-                            let idx = state.this.ensure_pre_batch_for_module(\n-                                module,\n-                                chunk_group_info,\n-                                queue,\n-                            )?;\n-                            state.items.push(PreBatchItem::ParallelReference(idx));\n-                            return Ok(GraphTraversalAction::Exclude);\n-                        }\n-                        Ok(GraphTraversalAction::Continue)\n-                    } else {\n-                        Ok(GraphTraversalAction::Exclude)\n-                    }\n-                },\n-                |_, node, state| {\n-                    let item = PreBatchItem::ParallelModule(node.module);\n-                    state.items.push(item);\n-                    Ok(())\n-                },\n-            )\n-            .await?;\n+                    Ok(GraphTraversalAction::Continue)\n+                } else {\n+                    Ok(GraphTraversalAction::Exclude)\n+                }\n+            },\n+            |_, node, state| {\n+                let item = PreBatchItem::ParallelModule(node.module);\n+                state.items.push(item);\n+                Ok(())\n+            },\n+        )?;\n         Ok(state.items)\n     }\n }\n@@ -352,33 +350,31 @@ pub async fn compute_module_batches(\n \n         // Walk the module graph and mark all modules that are boundary modules (referenced from a\n         // different chunk group bitmap)\n-        module_graph\n-            .traverse_all_edges_unordered(|(parent, ty), node| {\n-                let std::collections::hash_set::Entry::Vacant(entry) =\n-                    pre_batches.boundary_modules.entry(node.module)\n-                else {\n-                    // Already a boundary module, can skip check\n-                    return Ok(());\n-                };\n-                if ty.chunking_type.is_parallel() {\n-                    let parent_chunk_groups = chunk_group_info\n-                        .module_chunk_groups\n-                        .get(&parent.module)\n-                        .context(\"all modules need to have chunk group info\")?;\n-                    let chunk_groups = chunk_group_info\n-                        .module_chunk_groups\n-                        .get(&node.module)\n-                        .context(\"all modules need to have chunk group info\")?;\n-                    if parent_chunk_groups != chunk_groups {\n-                        // This is a boundary module\n-                        entry.insert();\n-                    }\n-                } else {\n+        module_graph.traverse_all_edges_unordered(|(parent, ty), node| {\n+            let std::collections::hash_set::Entry::Vacant(entry) =\n+                pre_batches.boundary_modules.entry(node.module)\n+            else {\n+                // Already a boundary module, can skip check\n+                return Ok(());\n+            };\n+            if ty.chunking_type.is_parallel() {\n+                let parent_chunk_groups = chunk_group_info\n+                    .module_chunk_groups\n+                    .get(&parent.module)\n+                    .context(\"all modules need to have chunk group info\")?;\n+                let chunk_groups = chunk_group_info\n+                    .module_chunk_groups\n+                    .get(&node.module)\n+                    .context(\"all modules need to have chunk group info\")?;\n+                if parent_chunk_groups != chunk_groups {\n+                    // This is a boundary module\n                     entry.insert();\n                 }\n-                Ok(())\n-            })\n-            .await?;\n+            } else {\n+                entry.insert();\n+            }\n+            Ok(())\n+        })?;\n \n         // All entries are boundary modules too\n         for chunk_group in &chunk_group_info.chunk_groups {\n@@ -389,21 +385,19 @@ pub async fn compute_module_batches(\n \n         // Pre batches would be incorrect with cycles, so we need to opt-out of pre batches for\n         // cycles that include boundary modules\n-        module_graph\n-            .traverse_cycles(\n-                |ref_data| ref_data.chunking_type.is_parallel(),\n-                |cycle| {\n-                    if cycle\n-                        .iter()\n-                        .any(|node| pre_batches.boundary_modules.contains(&node.module))\n-                    {\n-                        pre_batches\n-                            .boundary_modules\n-                            .extend(cycle.iter().map(|node| node.module));\n-                    }\n-                },\n-            )\n-            .await?;\n+        module_graph.traverse_cycles(\n+            |ref_data| ref_data.chunking_type.is_parallel(),\n+            |cycle| {\n+                if cycle\n+                    .iter()\n+                    .any(|node| pre_batches.boundary_modules.contains(&node.module))\n+                {\n+                    pre_batches\n+                        .boundary_modules\n+                        .extend(cycle.iter().map(|node| node.module));\n+                }\n+            },\n+        )?;\n \n         let mut queue: VecDeque<(ResolvedVc<Box<dyn Module>>, PreBatchIndex)> = VecDeque::new();\n "
        },
        {
            "sha": "390cf7d633f45d6c9323e70600dd2366a56671e4",
            "filename": "turbopack/crates/turbopack/src/global_module_ids.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 18,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fglobal_module_ids.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f2ebb0701989c0d2456b8fd98a9267358d5ed0bb/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fglobal_module_ids.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fglobal_module_ids.rs?ref=f2ebb0701989c0d2456b8fd98a9267358d5ed0bb",
            "patch": "@@ -30,24 +30,21 @@ pub async fn get_global_module_id_strategy(\n \n         // And additionally, all the modules that are inserted by chunking (i.e. async loaders)\n         let mut async_idents = vec![];\n-        module_graph\n-            .traverse_all_edges_unordered(|parent, current| {\n-                if let (\n-                    _,\n-                    &RefData {\n-                        chunking_type: ChunkingType::Async,\n-                        ..\n-                    },\n-                ) = parent\n-                {\n-                    let module =\n-                        ResolvedVc::try_sidecast::<Box<dyn ChunkableModule>>(current.module)\n-                            .context(\"expected chunkable module for async reference\")?;\n-                    async_idents.push(AsyncLoaderModule::asset_ident_for(*module));\n-                }\n-                Ok(())\n-            })\n-            .await?;\n+        module_graph.traverse_all_edges_unordered(|parent, current| {\n+            if let (\n+                _,\n+                &RefData {\n+                    chunking_type: ChunkingType::Async,\n+                    ..\n+                },\n+            ) = parent\n+            {\n+                let module = ResolvedVc::try_sidecast::<Box<dyn ChunkableModule>>(current.module)\n+                    .context(\"expected chunkable module for async reference\")?;\n+                async_idents.push(AsyncLoaderModule::asset_ident_for(*module));\n+            }\n+            Ok(())\n+        })?;\n \n         let mut module_id_map = module_idents\n             .chain(async_idents.into_iter())"
        }
    ],
    "stats": {
        "total": 988,
        "additions": 480,
        "deletions": 508
    }
}