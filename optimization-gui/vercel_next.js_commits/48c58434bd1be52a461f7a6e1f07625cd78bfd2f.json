{
    "author": "eps1lon",
    "message": "[test] Use `next.browser` instead of `webdriver` in pages/ client-navigation (#76867)",
    "sha": "48c58434bd1be52a461f7a6e1f07625cd78bfd2f",
    "files": [
        {
            "sha": "2927cf93a0dbc387ad3503850f141b416f8daf7d",
            "filename": "test/development/pages-dir/client-navigation/index.test.ts",
            "status": "modified",
            "additions": 543,
            "deletions": 806,
            "changes": 1349,
            "blob_url": "https://github.com/vercel/next.js/blob/48c58434bd1be52a461f7a6e1f07625cd78bfd2f/test%2Fdevelopment%2Fpages-dir%2Fclient-navigation%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/48c58434bd1be52a461f7a6e1f07625cd78bfd2f/test%2Fdevelopment%2Fpages-dir%2Fclient-navigation%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fpages-dir%2Fclient-navigation%2Findex.test.ts?ref=48c58434bd1be52a461f7a6e1f07625cd78bfd2f",
            "patch": "@@ -8,7 +8,6 @@ import {\n   retry,\n   getRedboxTotalErrorCount,\n } from 'next-test-utils'\n-import webdriver, { BrowserInterface } from 'next-webdriver'\n import path from 'path'\n import { nextTestSetup } from 'e2e-utils'\n \n@@ -24,7 +23,7 @@ describe('Client Navigation', () => {\n \n   it('should not reload when visiting /_error directly', async () => {\n     const { status } = await fetchViaHTTP(next.appPort, '/_error')\n-    const browser = await webdriver(next.appPort, '/_error')\n+    const browser = await next.browser('/_error')\n \n     await browser.eval('window.hello = true')\n \n@@ -43,7 +42,7 @@ describe('Client Navigation', () => {\n \n   describe('with <Link/>', () => {\n     it('should navigate the page', async () => {\n-      const browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n       const text = await browser\n         .elementByCss('#about-link')\n         .click()\n@@ -56,13 +55,13 @@ describe('Client Navigation', () => {\n     })\n \n     it('should not throw error when one number type child is provided', async () => {\n-      const browser = await webdriver(next.appPort, '/link-number-child')\n+      const browser = await next.browser('/link-number-child')\n       await assertNoRedbox(browser)\n       if (browser) await browser.close()\n     })\n \n     it('should navigate back after reload', async () => {\n-      const browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n       await browser.elementByCss('#about-link').click()\n       await browser.waitForElementByCss('.nav-about')\n       await browser.refresh()\n@@ -75,7 +74,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should navigate forwards after reload', async () => {\n-      const browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n       await browser.elementByCss('#about-link').click()\n       await browser.waitForElementByCss('.nav-about')\n       await browser.back()\n@@ -89,14 +88,14 @@ describe('Client Navigation', () => {\n     })\n \n     it('should error when calling onClick without event', async () => {\n-      const browser = await webdriver(next.appPort, '/link-invalid-onclick')\n+      const browser = await next.browser('/link-invalid-onclick')\n       expect(await browser.elementByCss('#errors').text()).toBe('0')\n       await browser.elementByCss('#custom-button').click()\n       expect(await browser.elementByCss('#errors').text()).toBe('1')\n     })\n \n     it('should navigate via the client side', async () => {\n-      const browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n \n       const counterText = await browser\n         .elementByCss('#increase')\n@@ -115,10 +114,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should navigate an absolute url', async () => {\n-      const browser = await webdriver(\n-        next.appPort,\n-        `/absolute-url?port=${next.appPort}`\n-      )\n+      const browser = await next.browser(`/absolute-url?port=${next.appPort}`)\n       await browser.waitForElementByCss('#absolute-link').click()\n       await check(\n         () => browser.eval(() => window.location.origin),\n@@ -127,10 +123,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should call mouse handlers with an absolute url', async () => {\n-      const browser = await webdriver(\n-        next.appPort,\n-        `/absolute-url?port=${next.appPort}`\n-      )\n+      const browser = await next.browser(`/absolute-url?port=${next.appPort}`)\n \n       await browser.elementByCss('#absolute-link-mouse-events').moveTo()\n \n@@ -142,10 +135,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should navigate an absolute local url', async () => {\n-      const browser = await webdriver(\n-        next.appPort,\n-        `/absolute-url?port=${next.appPort}`\n-      )\n+      const browser = await next.browser(`/absolute-url?port=${next.appPort}`)\n       // @ts-expect-error _didNotNavigate is set intentionally\n       await browser.eval(() => (window._didNotNavigate = true))\n       await browser.waitForElementByCss('#absolute-local-link').click()\n@@ -160,10 +150,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should navigate an absolute local url with as', async () => {\n-      const browser = await webdriver(\n-        next.appPort,\n-        `/absolute-url?port=${next.appPort}`\n-      )\n+      const browser = await next.browser(`/absolute-url?port=${next.appPort}`)\n       // @ts-expect-error _didNotNavigate is set intentionally\n       await browser.eval(() => (window._didNotNavigate = true))\n       await browser.waitForElementByCss('#absolute-local-dynamic-link').click()\n@@ -177,7 +164,7 @@ describe('Client Navigation', () => {\n \n   describe('with <a/> tag inside the <Link />', () => {\n     it('should navigate the page', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/about')\n+      const browser = await next.browser('/nav/about')\n       const text = await browser\n         .elementByCss('#home-link')\n         .click()\n@@ -190,7 +177,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should not navigate if the <a/> tag has a target', async () => {\n-      const browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n \n       await browser\n         .elementByCss('#increase')\n@@ -207,7 +194,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should not navigate if the click-event is modified', async () => {\n-      const browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n \n       await browser.elementByCss('#increase').click()\n \n@@ -227,7 +214,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should not reload when link in svg is clicked', async () => {\n-      const browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n       await browser.eval('window.hello = true')\n       await browser\n         .elementByCss('#in-svg-link')\n@@ -241,7 +228,7 @@ describe('Client Navigation', () => {\n \n   describe('with unexpected <a/> nested tag', () => {\n     it('should not redirect if passHref prop is not defined in Link', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/pass-href-prop')\n+      const browser = await next.browser('/nav/pass-href-prop')\n       const text = await browser\n         .elementByCss('#without-href')\n         .click()\n@@ -254,7 +241,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should redirect if passHref prop is defined in Link', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/pass-href-prop')\n+      const browser = await next.browser('/nav/pass-href-prop')\n       const text = await browser\n         .elementByCss('#with-href')\n         .click()\n@@ -269,18 +256,16 @@ describe('Client Navigation', () => {\n \n   describe('with empty getInitialProps()', () => {\n     it('should render a redbox', async () => {\n-      let browser: BrowserInterface\n-      try {\n-        const pageErrors: unknown[] = []\n-        browser = await webdriver(next.appPort, '/nav', {\n-          beforePageLoad: (page) => {\n-            page.on('pageerror', (error: unknown) => {\n-              pageErrors.push(error)\n-            })\n-          },\n-        })\n-        await browser.elementByCss('#empty-props').click()\n-        await expect(browser).toDisplayRedbox(`\n+      const pageErrors: unknown[] = []\n+      const browser = await next.browser('/nav', {\n+        beforePageLoad: (page) => {\n+          page.on('pageerror', (error: unknown) => {\n+            pageErrors.push(error)\n+          })\n+        },\n+      })\n+      await browser.elementByCss('#empty-props').click()\n+      await expect(browser).toDisplayRedbox(`\n          {\n            \"count\": 1,\n            \"description\": \"Error: \"EmptyInitialPropsPage.getInitialProps()\" should resolve to an object. But found \"null\" instead.\",\n@@ -290,23 +275,18 @@ describe('Client Navigation', () => {\n            \"stack\": [],\n          }\n         `)\n-        expect(pageErrors).toEqual([\n-          expect.objectContaining({\n-            message:\n-              '\"EmptyInitialPropsPage.getInitialProps()\" should resolve to an object. But found \"null\" instead.',\n-          }),\n-        ])\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      expect(pageErrors).toEqual([\n+        expect.objectContaining({\n+          message:\n+            '\"EmptyInitialPropsPage.getInitialProps()\" should resolve to an object. But found \"null\" instead.',\n+        }),\n+      ])\n     })\n   })\n \n   describe('with the same page but different querystring', () => {\n     it('should navigate the page', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/querystring?id=1')\n+      const browser = await next.browser('/nav/querystring?id=1')\n       const text = await browser\n         .elementByCss('#next-id-link')\n         .click()\n@@ -319,7 +299,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should remove querystring', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/querystring?id=1')\n+      const browser = await next.browser('/nav/querystring?id=1')\n       const text = await browser\n         .elementByCss('#main-page')\n         .click()\n@@ -334,7 +314,7 @@ describe('Client Navigation', () => {\n \n   describe('with the current url', () => {\n     it('should reload the page', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/self-reload')\n+      const browser = await next.browser('/nav/self-reload')\n       const defaultCount = await browser.elementByCss('p').text()\n       expect(defaultCount).toBe('COUNT: 0')\n \n@@ -347,7 +327,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should always replace the state', async () => {\n-      const browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n \n       const countAfterClicked = await browser\n         .elementByCss('#self-reload-link')\n@@ -372,210 +352,168 @@ describe('Client Navigation', () => {\n \n   describe('with onClick action', () => {\n     it('should reload the page and perform additional action', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/nav/on-click')\n-        const defaultCountQuery = await browser\n-          .elementByCss('#query-count')\n-          .text()\n-        const defaultCountState = await browser\n-          .elementByCss('#state-count')\n-          .text()\n-        expect(defaultCountQuery).toBe('QUERY COUNT: 0')\n-        expect(defaultCountState).toBe('STATE COUNT: 0')\n+      const browser = await next.browser('/nav/on-click')\n+      const defaultCountQuery = await browser\n+        .elementByCss('#query-count')\n+        .text()\n+      const defaultCountState = await browser\n+        .elementByCss('#state-count')\n+        .text()\n+      expect(defaultCountQuery).toBe('QUERY COUNT: 0')\n+      expect(defaultCountState).toBe('STATE COUNT: 0')\n \n-        await browser.elementByCss('#on-click-link').click()\n+      await browser.elementByCss('#on-click-link').click()\n \n-        const countQueryAfterClicked = await browser\n-          .elementByCss('#query-count')\n-          .text()\n-        const countStateAfterClicked = await browser\n-          .elementByCss('#state-count')\n-          .text()\n-        expect(countQueryAfterClicked).toBe('QUERY COUNT: 1')\n-        expect(countStateAfterClicked).toBe('STATE COUNT: 1')\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      const countQueryAfterClicked = await browser\n+        .elementByCss('#query-count')\n+        .text()\n+      const countStateAfterClicked = await browser\n+        .elementByCss('#state-count')\n+        .text()\n+      expect(countQueryAfterClicked).toBe('QUERY COUNT: 1')\n+      expect(countStateAfterClicked).toBe('STATE COUNT: 1')\n     })\n \n     it('should not reload if default was prevented', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/nav/on-click')\n-        const defaultCountQuery = await browser\n-          .elementByCss('#query-count')\n-          .text()\n-        const defaultCountState = await browser\n-          .elementByCss('#state-count')\n-          .text()\n-        expect(defaultCountQuery).toBe('QUERY COUNT: 0')\n-        expect(defaultCountState).toBe('STATE COUNT: 0')\n+      const browser = await next.browser('/nav/on-click')\n+      const defaultCountQuery = await browser\n+        .elementByCss('#query-count')\n+        .text()\n+      const defaultCountState = await browser\n+        .elementByCss('#state-count')\n+        .text()\n+      expect(defaultCountQuery).toBe('QUERY COUNT: 0')\n+      expect(defaultCountState).toBe('STATE COUNT: 0')\n \n-        await browser.elementByCss('#on-click-link-prevent-default').click()\n+      await browser.elementByCss('#on-click-link-prevent-default').click()\n \n-        const countQueryAfterClicked = await browser\n-          .elementByCss('#query-count')\n-          .text()\n-        const countStateAfterClicked = await browser\n-          .elementByCss('#state-count')\n-          .text()\n-        expect(countQueryAfterClicked).toBe('QUERY COUNT: 0')\n-        expect(countStateAfterClicked).toBe('STATE COUNT: 1')\n+      const countQueryAfterClicked = await browser\n+        .elementByCss('#query-count')\n+        .text()\n+      const countStateAfterClicked = await browser\n+        .elementByCss('#state-count')\n+        .text()\n+      expect(countQueryAfterClicked).toBe('QUERY COUNT: 0')\n+      expect(countStateAfterClicked).toBe('STATE COUNT: 1')\n \n-        await browser.elementByCss('#on-click-link').click()\n+      await browser.elementByCss('#on-click-link').click()\n \n-        const countQueryAfterClickedAgain = await browser\n-          .elementByCss('#query-count')\n-          .text()\n-        const countStateAfterClickedAgain = await browser\n-          .elementByCss('#state-count')\n-          .text()\n-        expect(countQueryAfterClickedAgain).toBe('QUERY COUNT: 1')\n-        expect(countStateAfterClickedAgain).toBe('STATE COUNT: 2')\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      const countQueryAfterClickedAgain = await browser\n+        .elementByCss('#query-count')\n+        .text()\n+      const countStateAfterClickedAgain = await browser\n+        .elementByCss('#state-count')\n+        .text()\n+      expect(countQueryAfterClickedAgain).toBe('QUERY COUNT: 1')\n+      expect(countStateAfterClickedAgain).toBe('STATE COUNT: 2')\n     })\n \n     it('should always replace the state and perform additional action', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n \n-        await browser\n-          .elementByCss('#on-click-link')\n-          .click()\n-          .waitForElementByCss('#on-click-page')\n+      await browser\n+        .elementByCss('#on-click-link')\n+        .click()\n+        .waitForElementByCss('#on-click-page')\n \n-        const defaultCountQuery = await browser\n-          .elementByCss('#query-count')\n-          .text()\n-        expect(defaultCountQuery).toBe('QUERY COUNT: 1')\n+      const defaultCountQuery = await browser\n+        .elementByCss('#query-count')\n+        .text()\n+      expect(defaultCountQuery).toBe('QUERY COUNT: 1')\n \n-        await browser.elementByCss('#on-click-link').click()\n-        const countQueryAfterClicked = await browser\n-          .elementByCss('#query-count')\n-          .text()\n-        const countStateAfterClicked = await browser\n-          .elementByCss('#state-count')\n-          .text()\n-        expect(countQueryAfterClicked).toBe('QUERY COUNT: 2')\n-        expect(countStateAfterClicked).toBe('STATE COUNT: 1')\n-\n-        // Since we replace the state, back button would simply go us back to /nav\n-        await browser.back().waitForElementByCss('.nav-home')\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      await browser.elementByCss('#on-click-link').click()\n+      const countQueryAfterClicked = await browser\n+        .elementByCss('#query-count')\n+        .text()\n+      const countStateAfterClicked = await browser\n+        .elementByCss('#state-count')\n+        .text()\n+      expect(countQueryAfterClicked).toBe('QUERY COUNT: 2')\n+      expect(countStateAfterClicked).toBe('STATE COUNT: 1')\n+\n+      // Since we replace the state, back button would simply go us back to /nav\n+      await browser.back().waitForElementByCss('.nav-home')\n     })\n   })\n   describe('resets scroll at the correct time', () => {\n     it('should reset scroll before the new page runs its lifecycles (<Link />)', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/nav/long-page-to-snap-scroll')\n+      const browser = await next.browser('/nav/long-page-to-snap-scroll')\n \n-        // Scrolls to item 400 on the page\n-        await browser\n-          .waitForElementByCss('#long-page-to-snap-scroll')\n-          .elementByCss('#scroll-to-item-400')\n-          .click()\n+      // Scrolls to item 400 on the page\n+      await browser\n+        .waitForElementByCss('#long-page-to-snap-scroll')\n+        .elementByCss('#scroll-to-item-400')\n+        .click()\n \n-        const scrollPosition = await browser.eval('window.pageYOffset')\n-        expect(scrollPosition).toBe(7208)\n+      const scrollPosition = await browser.eval('window.pageYOffset')\n+      expect(scrollPosition).toBe(7208)\n \n-        // Go to snap scroll page\n-        await browser\n-          .elementByCss('#goto-snap-scroll-position')\n-          .click()\n-          .waitForElementByCss('#scroll-pos-y')\n+      // Go to snap scroll page\n+      await browser\n+        .elementByCss('#goto-snap-scroll-position')\n+        .click()\n+        .waitForElementByCss('#scroll-pos-y')\n \n-        const snappedScrollPosition = await browser.eval(\n-          'document.getElementById(\"scroll-pos-y\").innerText'\n-        )\n-        expect(snappedScrollPosition).toBe('0')\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      const snappedScrollPosition = await browser.eval(\n+        'document.getElementById(\"scroll-pos-y\").innerText'\n+      )\n+      expect(snappedScrollPosition).toBe('0')\n     })\n \n     it('should reset scroll before the new page runs its lifecycles (Router#push)', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/nav/long-page-to-snap-scroll')\n+      const browser = await next.browser('/nav/long-page-to-snap-scroll')\n \n-        // Scrolls to item 400 on the page\n-        await browser\n-          .waitForElementByCss('#long-page-to-snap-scroll')\n-          .elementByCss('#scroll-to-item-400')\n-          .click()\n+      // Scrolls to item 400 on the page\n+      await browser\n+        .waitForElementByCss('#long-page-to-snap-scroll')\n+        .elementByCss('#scroll-to-item-400')\n+        .click()\n \n-        const scrollPosition = await browser.eval('window.pageYOffset')\n-        expect(scrollPosition).toBe(7208)\n+      const scrollPosition = await browser.eval('window.pageYOffset')\n+      expect(scrollPosition).toBe(7208)\n \n-        // Go to snap scroll page\n-        await browser\n-          .elementByCss('#goto-snap-scroll-position-imperative')\n-          .click()\n-          .waitForElementByCss('#scroll-pos-y')\n+      // Go to snap scroll page\n+      await browser\n+        .elementByCss('#goto-snap-scroll-position-imperative')\n+        .click()\n+        .waitForElementByCss('#scroll-pos-y')\n \n-        const snappedScrollPosition = await browser.eval(\n-          'document.getElementById(\"scroll-pos-y\").innerText'\n-        )\n-        expect(snappedScrollPosition).toBe('0')\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      const snappedScrollPosition = await browser.eval(\n+        'document.getElementById(\"scroll-pos-y\").innerText'\n+      )\n+      expect(snappedScrollPosition).toBe('0')\n     })\n \n     it('should intentionally not reset scroll before the new page runs its lifecycles (Router#push)', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/nav/long-page-to-snap-scroll')\n+      const browser = await next.browser('/nav/long-page-to-snap-scroll')\n \n-        // Scrolls to item 400 on the page\n-        await browser\n-          .waitForElementByCss('#long-page-to-snap-scroll')\n-          .elementByCss('#scroll-to-item-400')\n-          .click()\n+      // Scrolls to item 400 on the page\n+      await browser\n+        .waitForElementByCss('#long-page-to-snap-scroll')\n+        .elementByCss('#scroll-to-item-400')\n+        .click()\n \n-        const scrollPosition = await browser.eval('window.pageYOffset')\n-        expect(scrollPosition).toBe(7208)\n+      const scrollPosition = await browser.eval('window.pageYOffset')\n+      expect(scrollPosition).toBe(7208)\n \n-        // Go to snap scroll page\n-        await browser\n-          .elementByCss('#goto-snap-scroll-position-imperative-noscroll')\n-          .click()\n-          .waitForElementByCss('#scroll-pos-y')\n+      // Go to snap scroll page\n+      await browser\n+        .elementByCss('#goto-snap-scroll-position-imperative-noscroll')\n+        .click()\n+        .waitForElementByCss('#scroll-pos-y')\n \n-        const snappedScrollPosition = await browser.eval(\n-          'document.getElementById(\"scroll-pos-y\").innerText'\n-        )\n-        expect(snappedScrollPosition).not.toBe('0')\n-        expect(Number(snappedScrollPosition)).toBeGreaterThanOrEqual(7208)\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      const snappedScrollPosition = await browser.eval(\n+        'document.getElementById(\"scroll-pos-y\").innerText'\n+      )\n+      expect(snappedScrollPosition).not.toBe('0')\n+      expect(Number(snappedScrollPosition)).toBeGreaterThanOrEqual(7208)\n     })\n   })\n \n   describe('with hash changes', () => {\n     describe('check hydration mis-match', () => {\n       it('should not have hydration mis-match for hash link', async () => {\n-        const browser = await webdriver(next.appPort, '/nav/hash-changes')\n+        const browser = await next.browser('/nav/hash-changes')\n         const browserLogs = await browser.log()\n         let found = false\n         browserLogs.forEach((log) => {\n@@ -590,7 +528,7 @@ describe('Client Navigation', () => {\n \n     describe('when hash change via Link', () => {\n       it('should not run getInitialProps', async () => {\n-        const browser = await webdriver(next.appPort, '/nav/hash-changes')\n+        const browser = await next.browser('/nav/hash-changes')\n \n         const counter = await browser\n           .elementByCss('#via-link')\n@@ -604,57 +542,50 @@ describe('Client Navigation', () => {\n       })\n \n       it('should scroll to the specified position on the same page', async () => {\n-        let browser\n-        try {\n-          browser = await webdriver(next.appPort, '/nav/hash-changes')\n+        const browser = await next.browser('/nav/hash-changes')\n \n-          // Scrolls to item 400 on the page\n-          await browser.elementByCss('#scroll-to-item-400').click()\n+        // Scrolls to item 400 on the page\n+        await browser.elementByCss('#scroll-to-item-400').click()\n \n-          const scrollPositionBeforeEmptyHash =\n-            await browser.eval('window.pageYOffset')\n+        const scrollPositionBeforeEmptyHash =\n+          await browser.eval('window.pageYOffset')\n \n-          expect(scrollPositionBeforeEmptyHash).toBe(7258)\n+        expect(scrollPositionBeforeEmptyHash).toBe(7258)\n \n-          // Scrolls back to top when scrolling to `#` with no value.\n-          await browser.elementByCss('#via-empty-hash').click()\n+        // Scrolls back to top when scrolling to `#` with no value.\n+        await browser.elementByCss('#via-empty-hash').click()\n \n-          const scrollPositionAfterEmptyHash =\n-            await browser.eval('window.pageYOffset')\n+        const scrollPositionAfterEmptyHash =\n+          await browser.eval('window.pageYOffset')\n \n-          expect(scrollPositionAfterEmptyHash).toBe(0)\n+        expect(scrollPositionAfterEmptyHash).toBe(0)\n \n-          // Scrolls to item 400 on the page\n-          await browser.elementByCss('#scroll-to-item-400').click()\n+        // Scrolls to item 400 on the page\n+        await browser.elementByCss('#scroll-to-item-400').click()\n \n-          const scrollPositionBeforeTopHash =\n-            await browser.eval('window.pageYOffset')\n+        const scrollPositionBeforeTopHash =\n+          await browser.eval('window.pageYOffset')\n \n-          expect(scrollPositionBeforeTopHash).toBe(7258)\n+        expect(scrollPositionBeforeTopHash).toBe(7258)\n \n-          // Scrolls back to top when clicking link with href `#top`.\n-          await browser.elementByCss('#via-top-hash').click()\n+        // Scrolls back to top when clicking link with href `#top`.\n+        await browser.elementByCss('#via-top-hash').click()\n \n-          const scrollPositionAfterTopHash =\n-            await browser.eval('window.pageYOffset')\n+        const scrollPositionAfterTopHash =\n+          await browser.eval('window.pageYOffset')\n \n-          expect(scrollPositionAfterTopHash).toBe(0)\n+        expect(scrollPositionAfterTopHash).toBe(0)\n \n-          // Scrolls to cjk anchor on the page\n-          await browser.elementByCss('#scroll-to-cjk-anchor').click()\n+        // Scrolls to cjk anchor on the page\n+        await browser.elementByCss('#scroll-to-cjk-anchor').click()\n \n-          const scrollPositionCJKHash = await browser.eval('window.pageYOffset')\n+        const scrollPositionCJKHash = await browser.eval('window.pageYOffset')\n \n-          expect(scrollPositionCJKHash).toBe(17436)\n-        } finally {\n-          if (browser) {\n-            await browser.close()\n-          }\n-        }\n+        expect(scrollPositionCJKHash).toBe(17436)\n       })\n \n       it('should not scroll to hash when scroll={false} is set', async () => {\n-        const browser = await webdriver(next.appPort, '/nav/hash-changes')\n+        const browser = await next.browser('/nav/hash-changes')\n         const curScroll = await browser.eval(\n           'document.documentElement.scrollTop'\n         )\n@@ -665,91 +596,63 @@ describe('Client Navigation', () => {\n       })\n \n       it('should scroll to the specified position on the same page with a name property', async () => {\n-        let browser\n-        try {\n-          browser = await webdriver(next.appPort, '/nav/hash-changes')\n+        const browser = await next.browser('/nav/hash-changes')\n \n-          // Scrolls to item 400 with name=\"name-item-400\" on the page\n-          await browser.elementByCss('#scroll-to-name-item-400').click()\n+        // Scrolls to item 400 with name=\"name-item-400\" on the page\n+        await browser.elementByCss('#scroll-to-name-item-400').click()\n \n-          const scrollPosition = await browser.eval('window.pageYOffset')\n+        const scrollPosition = await browser.eval('window.pageYOffset')\n \n-          expect(scrollPosition).toBe(16258)\n+        expect(scrollPosition).toBe(16258)\n \n-          // Scrolls back to top when scrolling to `#` with no value.\n-          await browser.elementByCss('#via-empty-hash').click()\n+        // Scrolls back to top when scrolling to `#` with no value.\n+        await browser.elementByCss('#via-empty-hash').click()\n \n-          const scrollPositionAfterEmptyHash =\n-            await browser.eval('window.pageYOffset')\n+        const scrollPositionAfterEmptyHash =\n+          await browser.eval('window.pageYOffset')\n \n-          expect(scrollPositionAfterEmptyHash).toBe(0)\n-        } finally {\n-          if (browser) {\n-            await browser.close()\n-          }\n-        }\n+        expect(scrollPositionAfterEmptyHash).toBe(0)\n       })\n \n       it('should scroll to the specified position to a new page', async () => {\n-        let browser\n-        try {\n-          browser = await webdriver(next.appPort, '/nav')\n-\n-          // Scrolls to item 400 on the page\n-          await browser\n-            .elementByCss('#scroll-to-hash')\n-            .click()\n-            .waitForElementByCss('#hash-changes-page')\n-\n-          const scrollPosition = await browser.eval('window.pageYOffset')\n-          expect(scrollPosition).toBe(7258)\n-        } finally {\n-          if (browser) {\n-            await browser.close()\n-          }\n-        }\n+        const browser = await next.browser('/nav')\n+\n+        // Scrolls to item 400 on the page\n+        await browser\n+          .elementByCss('#scroll-to-hash')\n+          .click()\n+          .waitForElementByCss('#hash-changes-page')\n+\n+        const scrollPosition = await browser.eval('window.pageYOffset')\n+        expect(scrollPosition).toBe(7258)\n       })\n \n       it('should scroll to the specified CJK position to a new page', async () => {\n-        let browser\n-        try {\n-          browser = await webdriver(next.appPort, '/nav')\n-\n-          // Scrolls to CJK anchor on the page\n-          await browser\n-            .elementByCss('#scroll-to-cjk-hash')\n-            .click()\n-            .waitForElementByCss('#hash-changes-page')\n-\n-          const scrollPosition = await browser.eval('window.pageYOffset')\n-          expect(scrollPosition).toBe(17436)\n-        } finally {\n-          if (browser) {\n-            await browser.close()\n-          }\n-        }\n+        const browser = await next.browser('/nav')\n+\n+        // Scrolls to CJK anchor on the page\n+        await browser\n+          .elementByCss('#scroll-to-cjk-hash')\n+          .click()\n+          .waitForElementByCss('#hash-changes-page')\n+\n+        const scrollPosition = await browser.eval('window.pageYOffset')\n+        expect(scrollPosition).toBe(17436)\n       })\n \n       it('Should update asPath', async () => {\n-        let browser\n-        try {\n-          browser = await webdriver(next.appPort, '/nav/hash-changes')\n+        const browser = await next.browser('/nav/hash-changes')\n \n-          await browser.elementByCss('#via-link').click()\n+        await browser.elementByCss('#via-link').click()\n \n-          const asPath = await browser.elementByCss('div#asPath').text()\n-          expect(asPath).toBe('ASPATH: /nav/hash-changes#via-link')\n-        } finally {\n-          if (browser) {\n-            await browser.close()\n-          }\n-        }\n+        const asPath = await browser.elementByCss('div#asPath').text()\n+        expect(asPath).toBe('ASPATH: /nav/hash-changes#via-link')\n       })\n     })\n \n     describe('when hash change via A tag', () => {\n       it('should not run getInitialProps', async () => {\n-        const browser = await webdriver(next.appPort, '/nav/hash-changes')\n+        const browser = await next.browser('/nav/hash-changes')\n \n         const counter = await browser\n           .elementByCss('#via-a')\n@@ -765,7 +668,7 @@ describe('Client Navigation', () => {\n \n     describe('when hash get removed', () => {\n       it('should not run getInitialProps', async () => {\n-        const browser = await webdriver(next.appPort, '/nav/hash-changes')\n+        const browser = await next.browser('/nav/hash-changes')\n \n         const counter = await browser\n           .elementByCss('#via-a')\n@@ -781,7 +684,7 @@ describe('Client Navigation', () => {\n       })\n \n       it('should not run getInitialProps when removing via back', async () => {\n-        const browser = await webdriver(next.appPort, '/nav/hash-changes')\n+        const browser = await next.browser('/nav/hash-changes')\n \n         const counter = await browser\n           .elementByCss('#scroll-to-item-400')\n@@ -797,7 +700,7 @@ describe('Client Navigation', () => {\n \n     describe('when hash set to empty', () => {\n       it('should not run getInitialProps', async () => {\n-        const browser = await webdriver(next.appPort, '/nav/hash-changes')\n+        const browser = await next.browser('/nav/hash-changes')\n \n         const counter = await browser\n           .elementByCss('#via-a')\n@@ -817,10 +720,7 @@ describe('Client Navigation', () => {\n   describe('with hash changes with state', () => {\n     describe('when passing state via hash change', () => {\n       it('should increment the history state counter', async () => {\n-        const browser = await webdriver(\n-          next.appPort,\n-          '/nav/hash-changes-with-state#'\n-        )\n+        const browser = await next.browser('/nav/hash-changes-with-state#')\n \n         const historyCount = await browser\n           .elementByCss('#increment-history-count')\n@@ -841,10 +741,7 @@ describe('Client Navigation', () => {\n       })\n \n       it('should increment the shallow history state counter', async () => {\n-        const browser = await webdriver(\n-          next.appPort,\n-          '/nav/hash-changes-with-state#'\n-        )\n+        const browser = await next.browser('/nav/hash-changes-with-state#')\n \n         const historyCount = await browser\n           .elementByCss('#increment-shallow-history-count')\n@@ -867,7 +764,7 @@ describe('Client Navigation', () => {\n \n   describe('with shallow routing', () => {\n     it('should update the url without running getInitialProps', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/shallow-routing')\n+      const browser = await next.browser('/nav/shallow-routing')\n       const counter = await browser\n         .elementByCss('#increase')\n         .click()\n@@ -886,7 +783,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should handle the back button and should not run getInitialProps', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/shallow-routing')\n+      const browser = await next.browser('/nav/shallow-routing')\n       let counter = await browser\n         .elementByCss('#increase')\n         .click()\n@@ -908,7 +805,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should run getInitialProps always when rending the page to the screen', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/shallow-routing')\n+      const browser = await next.browser('/nav/shallow-routing')\n \n       const counter = await browser\n         .elementByCss('#increase')\n@@ -933,7 +830,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should keep the scroll position on shallow routing', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/shallow-routing')\n+      const browser = await next.browser('/nav/shallow-routing')\n       await browser.eval(() =>\n         document.querySelector('#increase').scrollIntoView()\n       )\n@@ -969,7 +866,7 @@ describe('Client Navigation', () => {\n   })\n \n   it('should scroll to top when the scroll option is set to true', async () => {\n-    const browser = await webdriver(next.appPort, '/nav/shallow-routing')\n+    const browser = await next.browser('/nav/shallow-routing')\n     await browser.eval(() =>\n       document.querySelector('#increaseWithScroll').scrollIntoView()\n     )\n@@ -986,7 +883,7 @@ describe('Client Navigation', () => {\n \n   describe('with URL objects', () => {\n     it('should work with <Link/>', async () => {\n-      const browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n       const text = await browser\n         .elementByCss('#query-string-link')\n         .click()\n@@ -1002,7 +899,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should work with \"Router.push\"', async () => {\n-      const browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n       const text = await browser\n         .elementByCss('#query-string-button')\n         .click()\n@@ -1018,7 +915,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should work with the \"replace\" prop', async () => {\n-      const browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n \n       let stackLength = await browser.eval('window.history.length')\n \n@@ -1052,7 +949,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should handle undefined in router.push', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/query-params')\n+      const browser = await next.browser('/nav/query-params')\n       await browser.elementByCss('#click-me').click()\n       const query = JSON.parse(\n         await browser.waitForElementByCss('#query-value').text()\n@@ -1074,58 +971,42 @@ describe('Client Navigation', () => {\n \n   describe('with querystring relative urls', () => {\n     it('should work with Link', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/query-only')\n-      try {\n-        await browser.elementByCss('#link').click()\n+      const browser = await next.browser('/nav/query-only')\n+      await browser.elementByCss('#link').click()\n \n-        await check(() => browser.waitForElementByCss('#prop').text(), 'foo')\n-      } finally {\n-        await browser.close()\n-      }\n+      await check(() => browser.waitForElementByCss('#prop').text(), 'foo')\n     })\n \n     it('should work with router.push', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/query-only')\n-      try {\n-        await browser.elementByCss('#router-push').click()\n+      const browser = await next.browser('/nav/query-only')\n+      await browser.elementByCss('#router-push').click()\n \n-        await check(() => browser.waitForElementByCss('#prop').text(), 'bar')\n-      } finally {\n-        await browser.close()\n-      }\n+      await check(() => browser.waitForElementByCss('#prop').text(), 'bar')\n     })\n \n     it('should work with router.replace', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/query-only')\n-      try {\n-        await browser.elementByCss('#router-replace').click()\n+      const browser = await next.browser('/nav/query-only')\n+      await browser.elementByCss('#router-replace').click()\n \n-        await check(() => browser.waitForElementByCss('#prop').text(), 'baz')\n-      } finally {\n-        await browser.close()\n-      }\n+      await check(() => browser.waitForElementByCss('#prop').text(), 'baz')\n     })\n \n     it('router.replace with shallow=true shall not throw route cancelled errors', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/query-only-shallow')\n-      try {\n-        await browser.elementByCss('#router-replace').click()\n-        // the error occurs on every replace() after the first one\n-        await browser.elementByCss('#router-replace').click()\n+      const browser = await next.browser('/nav/query-only-shallow')\n+      await browser.elementByCss('#router-replace').click()\n+      // the error occurs on every replace() after the first one\n+      await browser.elementByCss('#router-replace').click()\n \n-        await check(\n-          () => browser.waitForElementByCss('#routeState').text(),\n-          '{\"completed\":2,\"errors\":0}'\n-        )\n-      } finally {\n-        await browser.close()\n-      }\n+      await check(\n+        () => browser.waitForElementByCss('#routeState').text(),\n+        '{\"completed\":2,\"errors\":0}'\n+      )\n     })\n   })\n \n   describe('with getInitialProp redirect', () => {\n     it('should redirect the page via client side', async () => {\n-      const browser = await webdriver(next.appPort, '/nav')\n+      const browser = await next.browser('/nav')\n       const text = await browser\n         .elementByCss('#redirect-link')\n         .click()\n@@ -1138,7 +1019,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should redirect the page when loading', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/redirect')\n+      const browser = await next.browser('/nav/redirect')\n       const text = await browser\n         .waitForElementByCss('.nav-about')\n         .elementByCss('p')\n@@ -1151,23 +1032,23 @@ describe('Client Navigation', () => {\n \n   describe('with different types of urls', () => {\n     it('should work with normal page', async () => {\n-      const browser = await webdriver(next.appPort, '/with-cdm')\n+      const browser = await next.browser('/with-cdm')\n       const text = await browser.elementByCss('p').text()\n \n       expect(text).toBe('ComponentDidMount executed on client.')\n       await browser.close()\n     })\n \n     it('should work with dir/ page', async () => {\n-      const browser = await webdriver(next.appPort, '/nested-cdm')\n+      const browser = await next.browser('/nested-cdm')\n       const text = await browser.elementByCss('p').text()\n \n       expect(text).toBe('ComponentDidMount executed on client.')\n       await browser.close()\n     })\n \n     it('should not work with /index page', async () => {\n-      const browser = await webdriver(next.appPort, '/index')\n+      const browser = await next.browser('/index')\n       expect(await browser.elementByCss('h1').text()).toBe('404')\n       expect(await browser.elementByCss('h2').text()).toBe(\n         'This page could not be found.'\n@@ -1176,7 +1057,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should work with / page', async () => {\n-      const browser = await webdriver(next.appPort, '/')\n+      const browser = await next.browser('/')\n       const text = await browser.elementByCss('p').text()\n \n       expect(text).toBe('ComponentDidMount executed on client.')\n@@ -1186,7 +1067,7 @@ describe('Client Navigation', () => {\n \n   describe('with the HOC based router', () => {\n     it('should navigate as expected', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/with-hoc')\n+      const browser = await next.browser('/nav/with-hoc')\n \n       const pathname = await browser.elementByCss('#pathname').text()\n       expect(pathname).toBe('Current path: /nav/with-hoc')\n@@ -1209,7 +1090,7 @@ describe('Client Navigation', () => {\n   describe('with asPath', () => {\n     describe('inside getInitialProps', () => {\n       it('should show the correct asPath with a Link with as prop', async () => {\n-        const browser = await webdriver(next.appPort, '/nav')\n+        const browser = await next.browser('/nav')\n         const asPath = await browser\n           .elementByCss('#as-path-link')\n           .click()\n@@ -1222,7 +1103,7 @@ describe('Client Navigation', () => {\n       })\n \n       it('should show the correct asPath with a Link without the as prop', async () => {\n-        const browser = await webdriver(next.appPort, '/nav')\n+        const browser = await next.browser('/nav')\n         const asPath = await browser\n           .elementByCss('#as-path-link-no-as')\n           .click()\n@@ -1237,7 +1118,7 @@ describe('Client Navigation', () => {\n \n     describe('with next/router', () => {\n       it('should show the correct asPath', async () => {\n-        const browser = await webdriver(next.appPort, '/nav')\n+        const browser = await next.browser('/nav')\n         const asPath = await browser\n           .elementByCss('#as-path-using-router-link')\n           .click()\n@@ -1250,10 +1131,7 @@ describe('Client Navigation', () => {\n       })\n \n       it('should navigate an absolute url on push', async () => {\n-        const browser = await webdriver(\n-          next.appPort,\n-          `/absolute-url?port=${next.appPort}`\n-        )\n+        const browser = await next.browser(`/absolute-url?port=${next.appPort}`)\n         await browser.waitForElementByCss('#router-push').click()\n         await check(\n           () => browser.eval(() => window.location.origin),\n@@ -1262,10 +1140,7 @@ describe('Client Navigation', () => {\n       })\n \n       it('should navigate an absolute url on replace', async () => {\n-        const browser = await webdriver(\n-          next.appPort,\n-          `/absolute-url?port=${next.appPort}`\n-        )\n+        const browser = await next.browser(`/absolute-url?port=${next.appPort}`)\n         await browser.waitForElementByCss('#router-replace').click()\n         await check(\n           () => browser.eval(() => window.location.origin),\n@@ -1274,10 +1149,7 @@ describe('Client Navigation', () => {\n       })\n \n       it('should navigate an absolute local url on push', async () => {\n-        const browser = await webdriver(\n-          next.appPort,\n-          `/absolute-url?port=${next.appPort}`\n-        )\n+        const browser = await next.browser(`/absolute-url?port=${next.appPort}`)\n         // @ts-expect-error _didNotNavigate is set intentionally\n         await browser.eval(() => (window._didNotNavigate = true))\n         await browser.waitForElementByCss('#router-local-push').click()\n@@ -1291,10 +1163,7 @@ describe('Client Navigation', () => {\n       })\n \n       it('should navigate an absolute local url on replace', async () => {\n-        const browser = await webdriver(\n-          next.appPort,\n-          `/absolute-url?port=${next.appPort}`\n-        )\n+        const browser = await next.browser(`/absolute-url?port=${next.appPort}`)\n         // @ts-expect-error _didNotNavigate is set intentionally\n         await browser.eval(() => (window._didNotNavigate = true))\n         await browser.waitForElementByCss('#router-local-replace').click()\n@@ -1310,98 +1179,80 @@ describe('Client Navigation', () => {\n \n     describe('with next/link', () => {\n       it('should use pushState with same href and different asPath', async () => {\n-        let browser\n-        try {\n-          browser = await webdriver(next.appPort, '/nav/as-path-pushstate')\n-          await browser\n-            .elementByCss('#hello')\n-            .click()\n-            .waitForElementByCss('#something-hello')\n-          const queryOne = JSON.parse(\n-            await browser.elementByCss('#router-query').text()\n-          )\n-          expect(queryOne.something).toBe('hello')\n-          await browser\n-            .elementByCss('#same-query')\n-            .click()\n-            .waitForElementByCss('#something-same-query')\n-          const queryTwo = JSON.parse(\n-            await browser.elementByCss('#router-query').text()\n-          )\n-          expect(queryTwo.something).toBe('hello')\n-          await browser.back().waitForElementByCss('#something-hello')\n-          const queryThree = JSON.parse(\n-            await browser.elementByCss('#router-query').text()\n-          )\n-          expect(queryThree.something).toBe('hello')\n-          await browser\n-            .elementByCss('#else')\n-            .click()\n-            .waitForElementByCss('#something-else')\n-          await browser\n-            .elementByCss('#hello2')\n-            .click()\n-            .waitForElementByCss('#nav-as-path-pushstate')\n-          await browser.back().waitForElementByCss('#something-else')\n-          const queryFour = JSON.parse(\n-            await browser.elementByCss('#router-query').text()\n-          )\n-          expect(queryFour.something).toBe(undefined)\n-        } finally {\n-          if (browser) {\n-            await browser.close()\n-          }\n-        }\n+        const browser = await next.browser('/nav/as-path-pushstate')\n+        await browser\n+          .elementByCss('#hello')\n+          .click()\n+          .waitForElementByCss('#something-hello')\n+        const queryOne = JSON.parse(\n+          await browser.elementByCss('#router-query').text()\n+        )\n+        expect(queryOne.something).toBe('hello')\n+        await browser\n+          .elementByCss('#same-query')\n+          .click()\n+          .waitForElementByCss('#something-same-query')\n+        const queryTwo = JSON.parse(\n+          await browser.elementByCss('#router-query').text()\n+        )\n+        expect(queryTwo.something).toBe('hello')\n+        await browser.back().waitForElementByCss('#something-hello')\n+        const queryThree = JSON.parse(\n+          await browser.elementByCss('#router-query').text()\n+        )\n+        expect(queryThree.something).toBe('hello')\n+        await browser\n+          .elementByCss('#else')\n+          .click()\n+          .waitForElementByCss('#something-else')\n+        await browser\n+          .elementByCss('#hello2')\n+          .click()\n+          .waitForElementByCss('#nav-as-path-pushstate')\n+        await browser.back().waitForElementByCss('#something-else')\n+        const queryFour = JSON.parse(\n+          await browser.elementByCss('#router-query').text()\n+        )\n+        expect(queryFour.something).toBe(undefined)\n       })\n \n       it('should detect asPath query changes correctly', async () => {\n-        let browser\n-        try {\n-          browser = await webdriver(next.appPort, '/nav/as-path-query')\n-          await browser\n-            .elementByCss('#hello')\n-            .click()\n-            .waitForElementByCss('#something-hello-something-hello')\n-          const queryOne = JSON.parse(\n-            await browser.elementByCss('#router-query').text()\n-          )\n-          expect(queryOne.something).toBe('hello')\n-          await browser\n-            .elementByCss('#hello2')\n-            .click()\n-            .waitForElementByCss('#something-hello-something-else')\n-          const queryTwo = JSON.parse(\n-            await browser.elementByCss('#router-query').text()\n-          )\n-          expect(queryTwo.something).toBe('else')\n-        } finally {\n-          if (browser) {\n-            await browser.close()\n-          }\n-        }\n+        const browser = await next.browser('/nav/as-path-query')\n+        await browser\n+          .elementByCss('#hello')\n+          .click()\n+          .waitForElementByCss('#something-hello-something-hello')\n+        const queryOne = JSON.parse(\n+          await browser.elementByCss('#router-query').text()\n+        )\n+        expect(queryOne.something).toBe('hello')\n+        await browser\n+          .elementByCss('#hello2')\n+          .click()\n+          .waitForElementByCss('#something-hello-something-else')\n+        const queryTwo = JSON.parse(\n+          await browser.elementByCss('#router-query').text()\n+        )\n+        expect(queryTwo.something).toBe('else')\n       })\n     })\n   })\n \n   describe('runtime errors', () => {\n     it('should show redbox when a client side error is thrown inside a component', async () => {\n       const isReact18 = process.env.NEXT_TEST_REACT_VERSION?.startsWith('18')\n-      let browser: BrowserInterface\n-      try {\n-        const pageErrors: unknown[] = []\n-        browser = await webdriver(next.appPort, '/error-inside-browser-page', {\n-          beforePageLoad: (page) => {\n-            page.on('pageerror', (error: unknown) => {\n-              pageErrors.push(error)\n-            })\n-          },\n-        })\n-        await retry(async () => {\n-          expect(await getRedboxTotalErrorCount(browser)).toBe(\n-            isReact18 ? 3 : 1\n-          )\n-        })\n-        await expect(browser).toDisplayRedbox(`\n+      const pageErrors: unknown[] = []\n+      const browser = await next.browser('/error-inside-browser-page', {\n+        beforePageLoad: (page) => {\n+          page.on('pageerror', (error: unknown) => {\n+            pageErrors.push(error)\n+          })\n+        },\n+      })\n+      await retry(async () => {\n+        expect(await getRedboxTotalErrorCount(browser)).toBe(isReact18 ? 3 : 1)\n+      })\n+      await expect(browser).toDisplayRedbox(`\n          {\n            \"count\": ${isReact18 ? 3 : 1},\n            \"description\": \"Error: An Expected error occurred\",\n@@ -1415,48 +1266,37 @@ describe('Client Navigation', () => {\n            ],\n          }\n         `)\n-        expect(pageErrors).toEqual(\n-          isReact18\n-            ? [\n-                expect.objectContaining({\n-                  message: 'An Expected error occurred',\n-                }),\n-                expect.objectContaining({\n-                  message: 'An Expected error occurred',\n-                }),\n-                expect.objectContaining({\n-                  message:\n-                    'There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.',\n-                }),\n-              ]\n-            : // TODO(veil): Should contain thrown error\n-              []\n-        )\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      expect(pageErrors).toEqual(\n+        isReact18\n+          ? [\n+              expect.objectContaining({\n+                message: 'An Expected error occurred',\n+              }),\n+              expect.objectContaining({\n+                message: 'An Expected error occurred',\n+              }),\n+              expect.objectContaining({\n+                message:\n+                  'There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.',\n+              }),\n+            ]\n+          : // TODO(veil): Should contain thrown error\n+            []\n+      )\n     })\n \n     it('should show redbox when a client side error is thrown outside a component', async () => {\n-      let browser: BrowserInterface\n-      try {\n-        const pageErrors: unknown[] = []\n-        browser = await webdriver(\n-          next.appPort,\n-          '/error-in-the-browser-global-scope',\n-          {\n-            beforePageLoad: (page) => {\n-              page.on('pageerror', (error: unknown) => {\n-                pageErrors.push(error)\n-              })\n-            },\n-          }\n-        )\n+      const pageErrors: unknown[] = []\n+      const browser = await next.browser('/error-in-the-browser-global-scope', {\n+        beforePageLoad: (page) => {\n+          page.on('pageerror', (error: unknown) => {\n+            pageErrors.push(error)\n+          })\n+        },\n+      })\n \n-        if (isTurbopack) {\n-          await expect(browser).toDisplayRedbox(`\n+      if (isTurbopack) {\n+        await expect(browser).toDisplayRedbox(`\n            {\n              \"count\": 1,\n              \"description\": \"Error: An Expected error occurred\",\n@@ -1470,8 +1310,8 @@ describe('Client Navigation', () => {\n              ],\n            }\n           `)\n-        } else {\n-          await expect(browser).toDisplayRedbox(`\n+      } else {\n+        await expect(browser).toDisplayRedbox(`\n            {\n              \"count\": 1,\n              \"description\": \"Error: An Expected error occurred\",\n@@ -1489,21 +1329,16 @@ describe('Client Navigation', () => {\n              ],\n            }\n           `)\n-        }\n-        expect(pageErrors).toEqual([\n-          expect.objectContaining({ message: 'An Expected error occurred' }),\n-        ])\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n       }\n+      expect(pageErrors).toEqual([\n+        expect.objectContaining({ message: 'An Expected error occurred' }),\n+      ])\n     })\n   })\n \n   describe('with 404 pages', () => {\n     it('should 404 on not existent page', async () => {\n-      const browser = await webdriver(next.appPort, '/non-existent')\n+      const browser = await next.browser('/non-existent')\n       expect(await browser.elementByCss('h1').text()).toBe('404')\n       expect(await browser.elementByCss('h2').text()).toBe(\n         'This page could not be found.'\n@@ -1512,7 +1347,7 @@ describe('Client Navigation', () => {\n     })\n \n     it('should 404 on wrong casing', async () => {\n-      const browser = await webdriver(next.appPort, '/nAv/AbOuT')\n+      const browser = await next.browser('/nAv/AbOuT')\n       expect(await browser.elementByCss('h1').text()).toBe('404')\n       expect(await browser.elementByCss('h2').text()).toBe(\n         'This page could not be found.'\n@@ -1521,19 +1356,13 @@ describe('Client Navigation', () => {\n     })\n \n     it('should get url dynamic param', async () => {\n-      const browser = await webdriver(\n-        next.appPort,\n-        '/dynamic/dynamic-part/route'\n-      )\n+      const browser = await next.browser('/dynamic/dynamic-part/route')\n       expect(await browser.elementByCss('p').text()).toBe('dynamic-part')\n       await browser.close()\n     })\n \n     it('should 404 on wrong casing of url dynamic param', async () => {\n-      const browser = await webdriver(\n-        next.appPort,\n-        '/dynamic/dynamic-part/RoUtE'\n-      )\n+      const browser = await next.browser('/dynamic/dynamic-part/RoUtE')\n       expect(await browser.elementByCss('h1').text()).toBe('404')\n       expect(await browser.elementByCss('h2').text()).toBe(\n         'This page could not be found.'\n@@ -1542,14 +1371,14 @@ describe('Client Navigation', () => {\n     })\n \n     it('should not 404 for <page>/', async () => {\n-      const browser = await webdriver(next.appPort, '/nav/about/')\n+      const browser = await next.browser('/nav/about/')\n       const text = await browser.elementByCss('p').text()\n       expect(text).toBe('This is the about page.')\n       await browser.close()\n     })\n \n     it('should should not contain a page script in a 404 page', async () => {\n-      const browser = await webdriver(next.appPort, '/non-existent')\n+      const browser = await next.browser('/non-existent')\n       const scripts = await browser.elementsByCss('script[src]')\n       for (const script of scripts) {\n         const src = await script.getAttribute('src')\n@@ -1561,88 +1390,60 @@ describe('Client Navigation', () => {\n \n   describe('foreign history manipulation', () => {\n     it('should ignore history state without options', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/nav')\n-        // push history object without options\n-        await browser.eval(\n-          'window.history.pushState({ url: \"/whatever\" }, \"\", \"/whatever\")'\n-        )\n-        await browser.elementByCss('#about-link').click()\n-        await browser.waitForElementByCss('.nav-about')\n-        await browser.back()\n-        await waitFor(1000)\n-        await assertNoRedbox(browser)\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      const browser = await next.browser('/nav')\n+      // push history object without options\n+      await browser.eval(\n+        'window.history.pushState({ url: \"/whatever\" }, \"\", \"/whatever\")'\n+      )\n+      await browser.elementByCss('#about-link').click()\n+      await browser.waitForElementByCss('.nav-about')\n+      await browser.back()\n+      await waitFor(1000)\n+      await assertNoRedbox(browser)\n     })\n \n     it('should ignore history state with an invalid url', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/nav')\n-        // push history object wit invalid url (not relative)\n-        await browser.eval(\n-          'window.history.pushState({ url: \"http://google.com\" }, \"\", \"/whatever\")'\n-        )\n-        await browser.elementByCss('#about-link').click()\n-        await browser.waitForElementByCss('.nav-about')\n-        await browser.back()\n-        await waitFor(1000)\n-        await assertNoRedbox(browser)\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      const browser = await next.browser('/nav')\n+      // push history object wit invalid url (not relative)\n+      await browser.eval(\n+        'window.history.pushState({ url: \"http://google.com\" }, \"\", \"/whatever\")'\n+      )\n+      await browser.elementByCss('#about-link').click()\n+      await browser.waitForElementByCss('.nav-about')\n+      await browser.back()\n+      await waitFor(1000)\n+      await assertNoRedbox(browser)\n     })\n \n     it('should ignore foreign history state with missing properties', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/nav')\n-        // push empty history state\n-        await browser.eval('window.history.pushState({}, \"\", \"/whatever\")')\n-        await browser.elementByCss('#about-link').click()\n-        await browser.waitForElementByCss('.nav-about')\n-        await browser.back()\n-        await waitFor(1000)\n-        await assertNoRedbox(browser)\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      const browser = await next.browser('/nav')\n+      // push empty history state\n+      await browser.eval('window.history.pushState({}, \"\", \"/whatever\")')\n+      await browser.elementByCss('#about-link').click()\n+      await browser.waitForElementByCss('.nav-about')\n+      await browser.back()\n+      await waitFor(1000)\n+      await assertNoRedbox(browser)\n     })\n   })\n \n   it('should not error on module.exports + polyfills', async () => {\n-    let browser\n-    try {\n-      browser = await webdriver(next.appPort, '/read-only-object-error')\n-      expect(await browser.elementByCss('body').text()).toBe(\n-        'this is just a placeholder component'\n-      )\n-    } finally {\n-      if (browser) {\n-        await browser.close()\n-      }\n-    }\n+    const browser = await next.browser('/read-only-object-error')\n+    expect(await browser.elementByCss('body').text()).toBe(\n+      'this is just a placeholder component'\n+    )\n   })\n \n   it('should work on nested /index/index.js', async () => {\n-    const browser = await webdriver(next.appPort, '/nested-index/index')\n+    const browser = await next.browser('/nested-index/index')\n     expect(await browser.elementByCss('p').text()).toBe(\n       'This is an index.js nested in an index/ folder.'\n     )\n     await browser.close()\n   })\n \n   it('should handle undefined prop in head client-side', async () => {\n-    const browser = await webdriver(next.appPort, '/head')\n+    const browser = await next.browser('/head')\n     const value = await browser.eval(\n       `document.querySelector('meta[name=\"empty-content\"]').hasAttribute('content')`\n     )\n@@ -1653,7 +1454,7 @@ describe('Client Navigation', () => {\n   it.each([true, false])(\n     'should handle boolean async prop in next/script client-side: %s',\n     async (bool) => {\n-      const browser = await webdriver(next.appPort, '/script')\n+      const browser = await next.browser('/script')\n       const value = await browser.eval(\n         `document.querySelector('script[src=\"/test-async-${JSON.stringify(\n           bool\n@@ -1665,27 +1466,16 @@ describe('Client Navigation', () => {\n   )\n \n   it('should only execute async and defer scripts with next/script once', async () => {\n-    let browser\n-    try {\n-      browser = await webdriver(next.appPort, '/script')\n+    const browser = await next.browser('/script')\n \n-      await browser.waitForElementByCss('h1')\n-      await waitFor(2000)\n-      expect(Number(await browser.eval('window.__test_async_executions'))).toBe(\n-        1\n-      )\n-      expect(Number(await browser.eval('window.__test_defer_executions'))).toBe(\n-        1\n-      )\n-    } finally {\n-      if (browser) {\n-        await browser.close()\n-      }\n-    }\n+    await browser.waitForElementByCss('h1')\n+    await waitFor(2000)\n+    expect(Number(await browser.eval('window.__test_async_executions'))).toBe(1)\n+    expect(Number(await browser.eval('window.__test_defer_executions'))).toBe(1)\n   })\n \n   it('should emit routeChangeError on hash change cancel', async () => {\n-    const browser = await webdriver(next.appPort, '/')\n+    const browser = await next.browser('/')\n \n     await browser.eval(`(function() {\n       window.routeErrors = []\n@@ -1705,7 +1495,7 @@ describe('Client Navigation', () => {\n   })\n \n   it('should navigate to paths relative to the current page', async () => {\n-    const browser = await webdriver(next.appPort, '/nav/relative')\n+    const browser = await next.browser('/nav/relative')\n     let page\n \n     await browser.elementByCss('a').click()\n@@ -1741,7 +1531,7 @@ describe.each([[false], [true]])(\n     it.each([true, false])(\n       'should handle boolean async prop in next/head client-side: %s',\n       async (bool) => {\n-        const browser = await webdriver(next.appPort, '/head')\n+        const browser = await next.browser('/head')\n         const value = await browser.eval(\n           `document.querySelector('script[src=\"/test-async-${JSON.stringify(\n             bool\n@@ -1753,228 +1543,175 @@ describe.each([[false], [true]])(\n     )\n \n     it('should only execute async and defer scripts once', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/head')\n-\n-        await browser.waitForElementByCss('h1')\n-        await waitFor(2000)\n-        expect(\n-          Number(await browser.eval('window.__test_async_executions'))\n-        ).toBe(\n-          strictNextHead || isReact18\n-            ? 1\n-            : // <meta name=\"next-head-count\" /> is floated before <script />.\n-              // head-manager thinks it needs to add these again resulting in another execution.\n-              2\n-        )\n-        expect(\n-          Number(await browser.eval('window.__test_defer_executions'))\n-        ).toBe(\n-          strictNextHead || isReact18\n-            ? 1\n-            : // <meta name=\"next-head-count\" /> is floated before <script defer />.\n-              // head-manager thinks it needs to add these again resulting in another execution.\n-              2\n-        )\n+      const browser = await next.browser('/head')\n \n-        await browser.elementByCss('#reverseScriptOrder').click()\n-        await waitFor(2000)\n-\n-        expect(\n-          Number(await browser.eval('window.__test_async_executions'))\n-        ).toBe(strictNextHead || isReact18 ? 1 : 2)\n-        expect(\n-          Number(await browser.eval('window.__test_defer_executions'))\n-        ).toBe(strictNextHead || isReact18 ? 1 : 2)\n-\n-        await browser.elementByCss('#toggleScript').click()\n-        await waitFor(2000)\n-\n-        expect(\n-          Number(await browser.eval('window.__test_async_executions'))\n-        ).toBe(strictNextHead || isReact18 ? 1 : 2)\n-        expect(\n-          Number(await browser.eval('window.__test_defer_executions'))\n-        ).toBe(strictNextHead || isReact18 ? 1 : 2)\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      await browser.waitForElementByCss('h1')\n+      await waitFor(2000)\n+      expect(Number(await browser.eval('window.__test_async_executions'))).toBe(\n+        strictNextHead || isReact18\n+          ? 1\n+          : // <meta name=\"next-head-count\" /> is floated before <script />.\n+            // head-manager thinks it needs to add these again resulting in another execution.\n+            2\n+      )\n+      expect(Number(await browser.eval('window.__test_defer_executions'))).toBe(\n+        strictNextHead || isReact18\n+          ? 1\n+          : // <meta name=\"next-head-count\" /> is floated before <script defer />.\n+            // head-manager thinks it needs to add these again resulting in another execution.\n+            2\n+      )\n+\n+      await browser.elementByCss('#reverseScriptOrder').click()\n+      await waitFor(2000)\n+\n+      expect(Number(await browser.eval('window.__test_async_executions'))).toBe(\n+        strictNextHead || isReact18 ? 1 : 2\n+      )\n+      expect(Number(await browser.eval('window.__test_defer_executions'))).toBe(\n+        strictNextHead || isReact18 ? 1 : 2\n+      )\n+\n+      await browser.elementByCss('#toggleScript').click()\n+      await waitFor(2000)\n+\n+      expect(Number(await browser.eval('window.__test_async_executions'))).toBe(\n+        strictNextHead || isReact18 ? 1 : 2\n+      )\n+      expect(Number(await browser.eval('window.__test_defer_executions'))).toBe(\n+        strictNextHead || isReact18 ? 1 : 2\n+      )\n     })\n \n     it('should warn when stylesheets or scripts are in head', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/head')\n+      const browser = await next.browser('/head')\n \n-        await browser.waitForElementByCss('h1')\n-        await waitFor(1000)\n-        const browserLogs = await browser.log()\n-        let foundStyles = false\n-        let foundScripts = false\n-        const logs = []\n-        browserLogs.forEach(({ message }) => {\n-          if (message.includes('Do not add stylesheets using next/head')) {\n-            foundStyles = true\n-            logs.push(message)\n-          }\n-          if (message.includes('Do not add <script> tags using next/head')) {\n-            foundScripts = true\n-            logs.push(message)\n-          }\n-        })\n+      await browser.waitForElementByCss('h1')\n+      await waitFor(1000)\n+      const browserLogs = await browser.log()\n+      let foundStyles = false\n+      let foundScripts = false\n+      const logs = []\n+      browserLogs.forEach(({ message }) => {\n+        if (message.includes('Do not add stylesheets using next/head')) {\n+          foundStyles = true\n+          logs.push(message)\n+        }\n+        if (message.includes('Do not add <script> tags using next/head')) {\n+          foundScripts = true\n+          logs.push(message)\n+        }\n+      })\n \n-        expect(foundStyles).toEqual(true)\n-        expect(foundScripts).toEqual(true)\n+      expect(foundStyles).toEqual(true)\n+      expect(foundScripts).toEqual(true)\n \n-        // Warnings are unique\n-        expect(logs.length).toEqual(new Set(logs).size)\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      // Warnings are unique\n+      expect(logs.length).toEqual(new Set(logs).size)\n     })\n \n     it('should warn when scripts are in head', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/head')\n-        await browser.waitForElementByCss('h1')\n-        await waitFor(1000)\n-        const browserLogs = await browser.log()\n-        let found = false\n-        browserLogs.forEach((log) => {\n-          if (log.message.includes('Use next/script instead')) {\n-            found = true\n-          }\n-        })\n-        expect(found).toEqual(true)\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n+      const browser = await next.browser('/head')\n+      await browser.waitForElementByCss('h1')\n+      await waitFor(1000)\n+      const browserLogs = await browser.log()\n+      let found = false\n+      browserLogs.forEach((log) => {\n+        if (log.message.includes('Use next/script instead')) {\n+          found = true\n         }\n-      }\n+      })\n+      expect(found).toEqual(true)\n     })\n \n     it('should not warn when application/ld+json scripts are in head', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/head-with-json-ld-snippet')\n-        await browser.waitForElementByCss('h1')\n-        await waitFor(1000)\n-        const browserLogs = await browser.log()\n-        let found = false\n-        browserLogs.forEach((log) => {\n-          if (log.message.includes('Use next/script instead')) {\n-            found = true\n-          }\n-        })\n-        expect(found).toEqual(false)\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n+      const browser = await next.browser('/head-with-json-ld-snippet')\n+      await browser.waitForElementByCss('h1')\n+      await waitFor(1000)\n+      const browserLogs = await browser.log()\n+      let found = false\n+      browserLogs.forEach((log) => {\n+        if (log.message.includes('Use next/script instead')) {\n+          found = true\n         }\n-      }\n+      })\n+      expect(found).toEqual(false)\n     })\n \n     it('should update head during client routing', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/nav/head-1')\n-        expect(\n-          await browser\n-            .elementByCss('meta[name=\"description\"]')\n-            .getAttribute('content')\n-        ).toBe('Head One')\n+      const browser = await next.browser('/nav/head-1')\n+      expect(\n+        await browser\n+          .elementByCss('meta[name=\"description\"]')\n+          .getAttribute('content')\n+      ).toBe('Head One')\n \n+      await browser\n+        .elementByCss('#to-head-2')\n+        .click()\n+        .waitForElementByCss('#head-2', 3000)\n+      expect(\n         await browser\n-          .elementByCss('#to-head-2')\n-          .click()\n-          .waitForElementByCss('#head-2', 3000)\n-        expect(\n-          await browser\n-            .elementByCss('meta[name=\"description\"]')\n-            .getAttribute('content')\n-        ).toBe('Head Two')\n+          .elementByCss('meta[name=\"description\"]')\n+          .getAttribute('content')\n+      ).toBe('Head Two')\n \n+      await browser\n+        .elementByCss('#to-head-1')\n+        .click()\n+        .waitForElementByCss('#head-1', 3000)\n+      expect(\n         await browser\n-          .elementByCss('#to-head-1')\n-          .click()\n-          .waitForElementByCss('#head-1', 3000)\n-        expect(\n-          await browser\n-            .elementByCss('meta[name=\"description\"]')\n-            .getAttribute('content')\n-        ).toBe('Head One')\n+          .elementByCss('meta[name=\"description\"]')\n+          .getAttribute('content')\n+      ).toBe('Head One')\n \n+      await browser\n+        .elementByCss('#to-head-3')\n+        .click()\n+        .waitForElementByCss('#head-3', 3000)\n+      expect(\n         await browser\n-          .elementByCss('#to-head-3')\n-          .click()\n-          .waitForElementByCss('#head-3', 3000)\n-        expect(\n-          await browser\n-            .elementByCss('meta[name=\"description\"]')\n-            .getAttribute('content')\n-        ).toBe('Head Three')\n-        expect(await browser.eval('document.title')).toBe('')\n+          .elementByCss('meta[name=\"description\"]')\n+          .getAttribute('content')\n+      ).toBe('Head Three')\n+      expect(await browser.eval('document.title')).toBe('')\n \n+      await browser\n+        .elementByCss('#to-head-1')\n+        .click()\n+        .waitForElementByCss('#head-1', 3000)\n+      expect(\n         await browser\n-          .elementByCss('#to-head-1')\n-          .click()\n-          .waitForElementByCss('#head-1', 3000)\n-        expect(\n-          await browser\n-            .elementByCss('meta[name=\"description\"]')\n-            .getAttribute('content')\n-        ).toBe('Head One')\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+          .elementByCss('meta[name=\"description\"]')\n+          .getAttribute('content')\n+      ).toBe('Head One')\n     })\n \n     it('should update title during client routing', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/nav/head-1')\n-        expect(await browser.eval('document.title')).toBe('this is head-1')\n+      const browser = await next.browser('/nav/head-1')\n+      expect(await browser.eval('document.title')).toBe('this is head-1')\n \n-        await browser\n-          .elementByCss('#to-head-2')\n-          .click()\n-          .waitForElementByCss('#head-2', 3000)\n-        expect(await browser.eval('document.title')).toBe('this is head-2')\n+      await browser\n+        .elementByCss('#to-head-2')\n+        .click()\n+        .waitForElementByCss('#head-2', 3000)\n+      expect(await browser.eval('document.title')).toBe('this is head-2')\n \n-        await browser\n-          .elementByCss('#to-head-1')\n-          .click()\n-          .waitForElementByCss('#head-1', 3000)\n-        expect(await browser.eval('document.title')).toBe('this is head-1')\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      await browser\n+        .elementByCss('#to-head-1')\n+        .click()\n+        .waitForElementByCss('#head-1', 3000)\n+      expect(await browser.eval('document.title')).toBe('this is head-1')\n     })\n \n     it('should update head when unmounting component', async () => {\n-      let browser\n-      try {\n-        browser = await webdriver(next.appPort, '/head-dynamic')\n-        expect(await browser.eval('document.title')).toBe('B')\n-        await browser.elementByCss('button').click()\n-        expect(await browser.eval('document.title')).toBe('A')\n-        await browser.elementByCss('button').click()\n-        expect(await browser.eval('document.title')).toBe('B')\n-      } finally {\n-        if (browser) {\n-          await browser.close()\n-        }\n-      }\n+      const browser = await next.browser('/head-dynamic')\n+      expect(await browser.eval('document.title')).toBe('B')\n+      await browser.elementByCss('button').click()\n+      expect(await browser.eval('document.title')).toBe('A')\n+      await browser.elementByCss('button').click()\n+      expect(await browser.eval('document.title')).toBe('B')\n     })\n   }\n )"
        }
    ],
    "stats": {
        "total": 1349,
        "additions": 543,
        "deletions": 806
    }
}