{
    "author": "lukesandberg",
    "message": "[turbopack] Remove `Clone` from `Effect` (#86110)\n\nDisallow cloning effects.\n\nThis was only performed in one location to address an issue with modeling calls functions that had alternates. However, this had the unfortunate effect of producing duplicate `CodeGen` objects. (it also could link values redundantly). This was fixed by refactoring the recursion and moving the the effect collection to one place.\n\nMany CodeGens are naturally idempotent so this wouldn't typically cause trouble, but it is wasteful and potentially hides other bugs.  For example, this also adds detection for duplicate code gens and doing so found that we were generating unreachable effects for finalizers incorrectly.",
    "sha": "a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
    "files": [
        {
            "sha": "fb7fa8cc38e9a7ce738cca104177f96dbe68b0e4",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/graph.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 8,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fgraph.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -35,7 +35,7 @@ use crate::{\n     utils::{AstPathRange, unparen},\n };\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub struct EffectsBlock {\n     pub effects: Vec<Effect>,\n     pub range: AstPathRange,\n@@ -47,7 +47,7 @@ impl EffectsBlock {\n     }\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub enum ConditionalKind {\n     /// The blocks of an `if` statement without an `else` block.\n     If { then: Box<EffectsBlock> },\n@@ -117,7 +117,7 @@ impl ConditionalKind {\n     }\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub enum EffectArg {\n     Value(JsValue),\n     Closure(JsValue, Box<EffectsBlock>),\n@@ -140,7 +140,7 @@ impl EffectArg {\n     }\n }\n \n-#[derive(Debug, Clone)]\n+#[derive(Debug)]\n pub enum Effect {\n     /// Some condition which affects which effects might be executed. If the\n     /// condition evaluates to some compile-time constant, we can use that\n@@ -2428,14 +2428,16 @@ impl VisitAstPath for Analyzer<'_> {\n         self.effects.append(&mut block);\n         self.effects.append(&mut handler);\n         if let Some(finalizer) = stmt.finalizer.as_ref() {\n-            let mut ast_path =\n-                ast_path.with_guard(AstParentNodeRef::TryStmt(stmt, TryStmtField::Finalizer));\n-            finalizer.visit_with_ast_path(self, &mut ast_path);\n+            {\n+                let mut ast_path =\n+                    ast_path.with_guard(AstParentNodeRef::TryStmt(stmt, TryStmtField::Finalizer));\n+                finalizer.visit_with_ast_path(self, &mut ast_path);\n+            }\n             // If a finally block early returns the parent block does too.\n             if self.end_early_return_block() {\n                 self.early_return_stack.push(EarlyReturn::Always {\n                     prev_effects: take(&mut self.effects),\n-                    start_ast_path: as_parent_path(&ast_path),\n+                    start_ast_path: as_parent_path(ast_path),\n                 });\n             }\n         };"
        },
        {
            "sha": "2af172fb6e00d15d193cda037491c3a08e44b76f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/code_gen.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fcode_gen.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fcode_gen.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fcode_gen.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -173,7 +173,9 @@ impl_modify!(visit_mut_block_stmt, BlockStmt);\n impl_modify!(visit_mut_switch_case, SwitchCase);\n impl_modify!(visit_mut_program, Program);\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub enum CodeGen {\n     // AMD occurs very rarely and makes the enum much bigger\n     AmdDefineWithDependenciesCodeGen(Box<AmdDefineWithDependenciesCodeGen>),"
        },
        {
            "sha": "ccaa1136b3e579178d57946b28dd1e4f1c61e5ed",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/amd.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Famd.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Famd.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Famd.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -98,6 +98,7 @@ impl ChunkableModuleReference for AmdDefineAssetReference {}\n     TraceRawVcs,\n     Clone,\n     NonLocalValue,\n+    Hash,\n )]\n pub enum AmdDefineDependencyElement {\n     Request {\n@@ -120,14 +121,17 @@ pub enum AmdDefineDependencyElement {\n     Copy,\n     Clone,\n     NonLocalValue,\n+    Hash,\n )]\n pub enum AmdDefineFactoryType {\n     Unknown,\n     Function,\n     Value,\n }\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub struct AmdDefineWithDependenciesCodeGen {\n     dependencies_requests: Vec<AmdDefineDependencyElement>,\n     origin: ResolvedVc<Box<dyn ResolveOrigin>>,"
        },
        {
            "sha": "d22a482133973a3fbf453bdac38a8033c940b6f6",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/cjs.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fcjs.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fcjs.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fcjs.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -150,7 +150,9 @@ impl IntoCodeGenReference for CjsRequireAssetReference {\n     }\n }\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub struct CjsRequireAssetReferenceCodeGen {\n     reference: ResolvedVc<CjsRequireAssetReference>,\n     path: AstPath,\n@@ -274,7 +276,9 @@ impl IntoCodeGenReference for CjsRequireResolveAssetReference {\n     }\n }\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub struct CjsRequireResolveAssetReferenceCodeGen {\n     reference: ResolvedVc<CjsRequireResolveAssetReference>,\n     path: AstPath,\n@@ -334,7 +338,9 @@ impl CjsRequireResolveAssetReferenceCodeGen {\n     }\n }\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Debug, Hash,\n+)]\n pub struct CjsRequireCacheAccess {\n     pub path: AstPath,\n }"
        },
        {
            "sha": "dc6fd8b57faca3e41e7769ee160f3641e6a4a40a",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/constant_condition.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fconstant_condition.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fconstant_condition.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fconstant_condition.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -19,7 +19,9 @@ pub enum ConstantConditionValue {\n     Nullish,\n }\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Debug, Hash,\n+)]\n pub struct ConstantConditionCodeGen {\n     value: ConstantConditionValue,\n     path: AstPath,"
        },
        {
            "sha": "45fea8527893b7ed9f5cf8eca3856ccfb695da24",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/dynamic_expression.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fdynamic_expression.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fdynamic_expression.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fdynamic_expression.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -10,13 +10,17 @@ use crate::{\n     create_visitor,\n };\n \n-#[derive(PartialEq, Eq, TraceRawVcs, Serialize, Deserialize, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, TraceRawVcs, Serialize, Deserialize, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n enum DynamicExpressionType {\n     Promise,\n     Normal,\n }\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Debug, Hash,\n+)]\n pub struct DynamicExpression {\n     path: AstPath,\n     ty: DynamicExpressionType,"
        },
        {
            "sha": "33f438f3ed4233ddd0f7e446b1e024aaa44505b7",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/dynamic.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fdynamic.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fdynamic.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fdynamic.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -121,7 +121,9 @@ impl IntoCodeGenReference for EsmAsyncAssetReference {\n     }\n }\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub struct EsmAsyncAssetReferenceCodeGen {\n     path: AstPath,\n     reference: ResolvedVc<EsmAsyncAssetReference>,"
        },
        {
            "sha": "8b516d39e7e76624e94a563768528dc582d99ff6",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/meta.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmeta.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmeta.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmeta.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -26,7 +26,9 @@ use crate::{\n /// in the file. But we must only initialize the binding a single time.\n ///\n /// This singleton behavior must be enforced by the caller!\n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Debug, Hash,\n+)]\n pub struct ImportMetaBinding {\n     path: FileSystemPath,\n }\n@@ -85,7 +87,9 @@ impl From<ImportMetaBinding> for CodeGen {\n ///\n /// There can be many references to import.meta, and they appear at any nesting\n /// in the file. But all references refer to the same mutable object.\n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub struct ImportMetaRef {\n     ast_path: AstPath,\n }"
        },
        {
            "sha": "a5f69e967d526585c78bb0fad14bc86207d0507b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/module_id.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmodule_id.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmodule_id.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmodule_id.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -73,7 +73,9 @@ impl IntoCodeGenReference for EsmModuleIdAssetReference {\n     }\n }\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub struct EsmModuleIdAssetReferenceCodeGen {\n     path: AstPath,\n     reference: ResolvedVc<EsmModuleIdAssetReference>,"
        },
        {
            "sha": "67dc999ca5571004cf7dd98f4cfc6efdc3384ebb",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/module_item.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmodule_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmodule_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fmodule_item.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -22,7 +22,9 @@ use crate::{\n /// Makes code changes to remove export/import declarations and places the\n /// expr/decl in a normal statement. Unnamed expr/decl will be named with the\n /// magic identifier \"export default\"\n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Debug, Hash,\n+)]\n pub struct EsmModuleItem {\n     pub path: AstPath,\n }"
        },
        {
            "sha": "18a9a8bfa2856ca35d8c32c57fb76ed00009f33e",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/url.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Furl.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Furl.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Furl.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -146,7 +146,9 @@ impl IntoCodeGenReference for UrlAssetReference {\n     }\n }\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub struct UrlAssetReferenceCodeGen {\n     reference: ResolvedVc<UrlAssetReference>,\n     path: AstPath,"
        },
        {
            "sha": "d37379a9f91c1c8feac2979e806143b541449d05",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/exports_info.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexports_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexports_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexports_info.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -23,7 +23,9 @@ use crate::{\n /// initialize the binding a single time.\n ///\n /// This singleton behavior must be enforced by the caller!\n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub struct ExportsInfoBinding {}\n \n impl ExportsInfoBinding {\n@@ -89,7 +91,9 @@ impl From<ExportsInfoBinding> for CodeGen {\n ///\n /// There can be many references, and they appear at any nesting in the file. But all references\n /// refer to the same mutable object.\n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub struct ExportsInfoRef {\n     ast_path: AstPath,\n }"
        },
        {
            "sha": "8e6167e87b4458b60b3c84379f1e685a067e207e",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/ident.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fident.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fident.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fident.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -11,7 +11,9 @@ use crate::{\n     create_visitor,\n };\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Debug, Hash,\n+)]\n pub struct IdentReplacement {\n     value: RcStr,\n     path: AstPath,"
        },
        {
            "sha": "d78141970e210548930f8d538f016f4c5c6345e0",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/member.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmember.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmember.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmember.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -20,7 +20,9 @@ use crate::{\n     create_visitor,\n };\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub struct MemberReplacement {\n     key: RcStr,\n     value: RcStr,"
        },
        {
            "sha": "1e5fdfdbdb86e5b1ca718d564ca73b5db924d2e5",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 245,
            "deletions": 176,
            "changes": 421,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -59,6 +59,7 @@ use swc_core::{\n         },\n     },\n };\n+use tokio::sync::OnceCell;\n use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n@@ -210,9 +211,16 @@ impl AnalyzeEcmascriptModuleResult {\n     }\n }\n \n+/// In debug builds, use FxIndexSet to catch duplicate code gens\n+/// In release builds, use Vec for better performance\n+#[cfg(debug_assertions)]\n+type CodeGenCollection = FxIndexSet<CodeGen>;\n+#[cfg(not(debug_assertions))]\n+type CodeGenCollection = Vec<CodeGen>;\n+\n /// A temporary analysis result builder to pass around, to be turned into an\n /// `Vc<AnalyzeEcmascriptModuleResult>` eventually.\n-pub struct AnalyzeEcmascriptModuleResultBuilder {\n+struct AnalyzeEcmascriptModuleResultBuilder {\n     analyze_mode: AnalyzeMode,\n \n     references: FxIndexSet<ResolvedVc<Box<dyn ModuleReference>>>,\n@@ -226,16 +234,18 @@ pub struct AnalyzeEcmascriptModuleResultBuilder {\n     // This caches repeated access because EsmAssetReference::new is not a turbo task function.\n     esm_references_rewritten: FxHashMap<usize, FxIndexMap<RcStr, ResolvedVc<EsmAssetReference>>>,\n \n-    code_gens: Vec<CodeGen>,\n+    code_gens: CodeGenCollection,\n     exports: EcmascriptExports,\n     async_module: ResolvedVc<OptionAsyncModule>,\n     successful: bool,\n     source_map: Option<ResolvedVc<Box<dyn GenerateSourceMap>>>,\n     has_side_effect_free_directive: bool,\n+    #[cfg(debug_assertions)]\n+    ident: RcStr,\n }\n \n impl AnalyzeEcmascriptModuleResultBuilder {\n-    pub fn new(analyze_mode: AnalyzeMode) -> Self {\n+    fn new(analyze_mode: AnalyzeMode) -> Self {\n         Self {\n             analyze_mode,\n             references: Default::default(),\n@@ -250,6 +260,8 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n             successful: false,\n             source_map: None,\n             has_side_effect_free_directive: false,\n+            #[cfg(debug_assertions)]\n+            ident: Default::default(),\n         }\n     }\n \n@@ -292,7 +304,20 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n         C: Into<CodeGen>,\n     {\n         if self.analyze_mode.is_code_gen() {\n-            self.code_gens.push(code_gen.into())\n+            #[cfg(debug_assertions)]\n+            {\n+                let (index, added) = self.code_gens.insert_full(code_gen.into());\n+                debug_assert!(\n+                    added,\n+                    \"Duplicate code gen added: {:?} in {}\",\n+                    self.code_gens.get_index(index).unwrap(),\n+                    self.ident\n+                );\n+            }\n+            #[cfg(not(debug_assertions))]\n+            {\n+                self.code_gens.push(code_gen.into());\n+            }\n         }\n     }\n \n@@ -311,7 +336,7 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n         self.async_module = ResolvedVc::cell(Some(async_module));\n     }\n \n-    /// Set whether this module is side-efffect free according to a user-provided directive.\n+    /// Set whether this module is side-effect free according to a user-provided directive.\n     pub fn set_has_side_effect_free_directive(&mut self, value: bool) {\n         self.has_side_effect_free_directive = value;\n     }\n@@ -407,6 +432,12 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n         }\n \n         self.code_gens.shrink_to_fit();\n+\n+        #[cfg(debug_assertions)]\n+        let code_generation = self.code_gens.into_iter().collect::<Vec<_>>();\n+        #[cfg(not(debug_assertions))]\n+        let code_generation = self.code_gens;\n+\n         Ok(AnalyzeEcmascriptModuleResult::cell(\n             AnalyzeEcmascriptModuleResult {\n                 references,\n@@ -415,7 +446,7 @@ impl AnalyzeEcmascriptModuleResultBuilder {\n                 esm_reexport_references: ResolvedVc::cell(\n                     esm_reexport_references.unwrap_or_default(),\n                 ),\n-                code_generation: ResolvedVc::cell(self.code_gens),\n+                code_generation: ResolvedVc::cell(code_generation),\n                 exports: self.exports.resolved_cell(),\n                 async_module: self.async_module,\n                 has_side_effect_free_directive: self.has_side_effect_free_directive,\n@@ -527,8 +558,12 @@ async fn analyze_ecmascript_module_internal(\n     let analyze_mode = options.analyze_mode;\n \n     let origin = ResolvedVc::upcast::<Box<dyn ResolveOrigin>>(module);\n-    let mut analysis = AnalyzeEcmascriptModuleResultBuilder::new(analyze_mode);\n     let path = &*origin.origin_path().await?;\n+    let mut analysis = AnalyzeEcmascriptModuleResultBuilder::new(analyze_mode);\n+    #[cfg(debug_assertions)]\n+    {\n+        analysis.ident = source.ident().to_string().owned().await?;\n+    }\n \n     // Is this a typescript file that requires analyzing type references?\n     let analyze_types = match &ty {\n@@ -1633,44 +1668,133 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n         ignore_dynamic_requests,\n         url_rewrite_behavior,\n         collect_affecting_sources,\n-        allow_project_root_tracing,\n+        allow_project_root_tracing: _,\n         ..\n     } = state;\n-    fn explain_args(args: &[JsValue]) -> (String, String) {\n-        JsValue::explain_args(args, 10, 2)\n-    }\n-    let linked_args = |args: Vec<EffectArg>| async move {\n-        args.into_iter()\n-            .map(|arg| {\n-                let add_effects = &add_effects;\n-                async move {\n-                    let value = match arg {\n-                        EffectArg::Value(value) => value,\n-                        EffectArg::Closure(value, block) => {\n-                            add_effects(block.effects);\n-                            value\n-                        }\n-                        EffectArg::Spread => {\n-                            JsValue::unknown_empty(true, \"spread is not supported yet\")\n-                        }\n-                    };\n-                    state.link_value(value, ImportAttributes::empty_ref()).await\n-                }\n+\n+    // Process all effects first so they happen exactly once.\n+    // If we end up modeling the behavior of the closures passed to any of these functions then we\n+    // will need to inline this into the appropriate spot just like Array.prototype.map support.\n+    let unlinked_args = args\n+        .into_iter()\n+        .map(|effect_arg| match effect_arg {\n+            EffectArg::Value(value) => value,\n+            EffectArg::Closure(value, block) => {\n+                add_effects(block.effects);\n+                value\n+            }\n+            EffectArg::Spread => JsValue::unknown_empty(true, \"spread is not supported yet\"),\n+        })\n+        .collect::<Vec<_>>();\n+\n+    // Create a OnceCell to cache linked args across multiple calls\n+    let linked_args_cache = OnceCell::new();\n+\n+    // Create the lazy linking closure that will be passed to handle_well_known_function_call\n+    let linked_args = || async {\n+        linked_args_cache\n+            .get_or_try_init(|| async {\n+                unlinked_args\n+                    .iter()\n+                    .cloned()\n+                    .map(|arg| state.link_value(arg, ImportAttributes::empty_ref()))\n+                    .try_join()\n+                    .await\n             })\n-            .try_join()\n             .await\n     };\n \n+    match func {\n+        JsValue::Alternatives {\n+            total_nodes: _,\n+            values,\n+            logical_property: _,\n+        } => {\n+            for alt in values {\n+                if let JsValue::WellKnownFunction(wkf) = alt {\n+                    handle_well_known_function_call(\n+                        wkf,\n+                        new,\n+                        &linked_args,\n+                        handler,\n+                        span,\n+                        ignore_dynamic_requests,\n+                        analysis,\n+                        origin,\n+                        compile_time_info,\n+                        url_rewrite_behavior,\n+                        source,\n+                        ast_path,\n+                        in_try,\n+                        state,\n+                        collect_affecting_sources,\n+                    )\n+                    .await?;\n+                }\n+            }\n+        }\n+        JsValue::WellKnownFunction(wkf) => {\n+            handle_well_known_function_call(\n+                wkf,\n+                new,\n+                &linked_args,\n+                handler,\n+                span,\n+                ignore_dynamic_requests,\n+                analysis,\n+                origin,\n+                compile_time_info,\n+                url_rewrite_behavior,\n+                source,\n+                ast_path,\n+                in_try,\n+                state,\n+                collect_affecting_sources,\n+            )\n+            .await?;\n+        }\n+        _ => {}\n+    }\n+\n+    Ok(())\n+}\n+\n+async fn handle_well_known_function_call<'a, F, Fut>(\n+    func: WellKnownFunctionKind,\n+    new: bool,\n+    linked_args: &F,\n+    handler: &Handler,\n+    span: Span,\n+    ignore_dynamic_requests: bool,\n+    analysis: &mut AnalyzeEcmascriptModuleResultBuilder,\n+    origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n+    compile_time_info: ResolvedVc<CompileTimeInfo>,\n+    url_rewrite_behavior: Option<UrlRewriteBehavior>,\n+    source: ResolvedVc<Box<dyn Source>>,\n+    ast_path: &[AstParentKind],\n+    in_try: bool,\n+    state: &'a AnalysisState<'a>,\n+    collect_affecting_sources: bool,\n+) -> Result<()>\n+where\n+    F: Fn() -> Fut,\n+    Fut: Future<Output = Result<&'a Vec<JsValue>>>,\n+{\n+    fn explain_args(args: &[JsValue]) -> (String, String) {\n+        JsValue::explain_args(args, 10, 2)\n+    }\n+\n     let get_traced_project_dir = async || -> Result<FileSystemPath> {\n         // readFileSync(\"./foo\") should always be relative to the project root, but this is\n-        // dangerous inside of node_modules as it can cause a lot of false positives in the tracing,\n-        // if some package does `path.join(dynamic)`, it would include everything from the project\n-        // root as well.\n+        // dangerous inside of node_modules as it can cause a lot of false positives in the\n+        // tracing, if some package does `path.join(dynamic)`, it would include\n+        // everything from the project root as well.\n         //\n-        // Also, when there's no cwd set (i.e. in a tracing-specific module context, as we shouldn't\n-        // assume a `process.cwd()` for all of node_modules), fallback to the source file directory.\n-        // This still allows relative file accesses, just not from the project root.\n-        if allow_project_root_tracing\n+        // Also, when there's no cwd set (i.e. in a tracing-specific module context, as we\n+        // shouldn't assume a `process.cwd()` for all of node_modules), fallback to\n+        // the source file directory. This still allows relative file accesses, just\n+        // not from the project root.\n+        if state.allow_project_root_tracing\n             && let Some(cwd) = compile_time_info.environment().cwd().owned().await?\n         {\n             Ok(cwd)\n@@ -1681,11 +1805,10 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n \n     let get_issue_source =\n         || IssueSource::from_swc_offsets(source, span.lo.to_u32(), span.hi.to_u32());\n-\n     if new {\n         match func {\n-            JsValue::WellKnownFunction(WellKnownFunctionKind::URLConstructor) => {\n-                let args = linked_args(args).await?;\n+            WellKnownFunctionKind::URLConstructor => {\n+                let args = linked_args().await?;\n                 if let [\n                     url,\n                     JsValue::Member(\n@@ -1698,7 +1821,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 {\n                     let pat = js_value_to_pattern(url);\n                     if !pat.has_constant_parts() {\n-                        let (args, hints) = explain_args(&args);\n+                        let (args, hints) = explain_args(args);\n                         handler.span_warn_with_code(\n                             span,\n                             &format!(\"new URL({args}) is very dynamic{hints}\",),\n@@ -1725,12 +1848,12 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 }\n                 return Ok(());\n             }\n-            JsValue::WellKnownFunction(WellKnownFunctionKind::WorkerConstructor) => {\n-                let args = linked_args(args).await?;\n+            WellKnownFunctionKind::WorkerConstructor => {\n+                let args = linked_args().await?;\n                 if let Some(url @ JsValue::Url(_, JsValueUrlKind::Relative)) = args.first() {\n                     let pat = js_value_to_pattern(url);\n                     if !pat.has_constant_parts() {\n-                        let (args, hints) = explain_args(&args);\n+                        let (args, hints) = explain_args(args);\n                         handler.span_warn_with_code(\n                             span,\n                             &format!(\"new Worker({args}) is very dynamic{hints}\",),\n@@ -1760,15 +1883,13 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 // Ignore (e.g. dynamic parameter or string literal), just as Webpack does\n                 return Ok(());\n             }\n-            JsValue::WellKnownFunction(WellKnownFunctionKind::NodeWorkerConstructor)\n-                if analysis.analyze_mode.is_tracing() =>\n-            {\n+            WellKnownFunctionKind::NodeWorkerConstructor if analysis.analyze_mode.is_tracing() => {\n                 // Only for tracing, not for bundling (yet?)\n-                let args = linked_args(args).await?;\n+                let args = linked_args().await?;\n                 if !args.is_empty() {\n                     let pat = js_value_to_pattern(&args[0]);\n                     if !pat.has_constant_parts() {\n-                        let (args, hints) = explain_args(&args);\n+                        let (args, hints) = explain_args(args);\n                         handler.span_warn_with_code(\n                             span,\n                             &format!(\"new Worker({args}) is very dynamic{hints}\",),\n@@ -1793,7 +1914,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     );\n                     return Ok(());\n                 }\n-                let (args, hints) = explain_args(&args);\n+                let (args, hints) = explain_args(args);\n                 handler.span_warn_with_code(\n                     span,\n                     &format!(\"new Worker({args}) is not statically analyze-able{hints}\",),\n@@ -1807,38 +1928,12 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n             _ => {}\n         }\n \n-        // linked_args wasn't called, so manually add the closure effects\n-        for arg in args {\n-            if let EffectArg::Closure(_, block) = arg {\n-                add_effects(block.effects);\n-            }\n-        }\n         return Ok(());\n     }\n \n     match func {\n-        JsValue::Alternatives {\n-            total_nodes: _,\n-            values,\n-            logical_property: _,\n-        } => {\n-            for alt in values {\n-                Box::pin(handle_call(\n-                    ast_path,\n-                    span,\n-                    alt,\n-                    args.clone(),\n-                    state,\n-                    add_effects,\n-                    analysis,\n-                    in_try,\n-                    new,\n-                ))\n-                .await?;\n-            }\n-        }\n-        JsValue::WellKnownFunction(WellKnownFunctionKind::Import) => {\n-            let args = linked_args(args).await?;\n+        WellKnownFunctionKind::Import => {\n+            let args = linked_args().await?;\n             if args.len() == 1 || args.len() == 2 {\n                 let pat = js_value_to_pattern(&args[0]);\n                 let options = args.get(1);\n@@ -1863,7 +1958,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     .and_then(ImportAnnotations::parse_dynamic)\n                     .unwrap_or_default();\n                 if !pat.has_constant_parts() {\n-                    let (args, hints) = explain_args(&args);\n+                    let (args, hints) = explain_args(args);\n                     handler.span_warn_with_code(\n                         span,\n                         &format!(\"import({args}) is very dynamic{hints}\",),\n@@ -1890,7 +1985,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 );\n                 return Ok(());\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n                 span,\n                 &format!(\"import({args}) is not statically analyze-able{hints}\",),\n@@ -1899,12 +1994,12 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 ),\n             )\n         }\n-        JsValue::WellKnownFunction(WellKnownFunctionKind::Require) => {\n-            let args = linked_args(args).await?;\n+        WellKnownFunctionKind::Require => {\n+            let args = linked_args().await?;\n             if args.len() == 1 {\n                 let pat = js_value_to_pattern(&args[0]);\n                 if !pat.has_constant_parts() {\n-                    let (args, hints) = explain_args(&args);\n+                    let (args, hints) = explain_args(args);\n                     handler.span_warn_with_code(\n                         span,\n                         &format!(\"require({args}) is very dynamic{hints}\",),\n@@ -1928,35 +2023,36 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 );\n                 return Ok(());\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n                 span,\n                 &format!(\"require({args}) is not statically analyze-able{hints}\",),\n                 DiagnosticId::Error(errors::failed_to_analyze::ecmascript::REQUIRE.to_string()),\n             )\n         }\n-        JsValue::WellKnownFunction(WellKnownFunctionKind::Define) => {\n+        WellKnownFunctionKind::Define => {\n             analyze_amd_define(\n                 source,\n                 analysis,\n                 origin,\n                 handler,\n                 span,\n                 ast_path,\n-                linked_args(args).await?,\n+                linked_args().await?,\n                 in_try,\n             )\n             .await?;\n         }\n \n-        JsValue::WellKnownFunction(WellKnownFunctionKind::RequireResolve) => {\n-            let args = linked_args(args).await?;\n+        WellKnownFunctionKind::RequireResolve => {\n+            let args = linked_args().await?;\n             if args.len() == 1 || args.len() == 2 {\n-                // TODO error TP1003 require.resolve(???*0*, {\"paths\": [???*1*]}) is not statically\n-                // analyze-able with ignore_dynamic_requests = true\n+                // TODO error TP1003 require.resolve(???*0*, {\"paths\": [???*1*]}) is not\n+                // statically analyze-able with ignore_dynamic_requests =\n+                // true\n                 let pat = js_value_to_pattern(&args[0]);\n                 if !pat.has_constant_parts() {\n-                    let (args, hints) = explain_args(&args);\n+                    let (args, hints) = explain_args(args);\n                     handler.span_warn_with_code(\n                         span,\n                         &format!(\"require.resolve({args}) is very dynamic{hints}\",),\n@@ -1980,7 +2076,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 );\n                 return Ok(());\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n                 span,\n                 &format!(\"require.resolve({args}) is not statically analyze-able{hints}\",),\n@@ -1990,12 +2086,12 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n             )\n         }\n \n-        JsValue::WellKnownFunction(WellKnownFunctionKind::RequireContext) => {\n-            let args = linked_args(args).await?;\n-            let options = match parse_require_context(&args) {\n+        WellKnownFunctionKind::RequireContext => {\n+            let args = linked_args().await?;\n+            let options = match parse_require_context(args) {\n                 Ok(options) => options,\n                 Err(err) => {\n-                    let (args, hints) = explain_args(&args);\n+                    let (args, hints) = explain_args(args);\n                     handler.span_err_with_code(\n                         span,\n                         &format!(\n@@ -2025,14 +2121,12 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n             );\n         }\n \n-        JsValue::WellKnownFunction(WellKnownFunctionKind::FsReadMethod(name))\n-            if analysis.analyze_mode.is_tracing() =>\n-        {\n-            let args = linked_args(args).await?;\n+        WellKnownFunctionKind::FsReadMethod(name) if analysis.analyze_mode.is_tracing() => {\n+            let args = linked_args().await?;\n             if !args.is_empty() {\n                 let pat = js_value_to_pattern(&args[0]);\n                 if !pat.has_constant_parts() {\n-                    let (args, hints) = explain_args(&args);\n+                    let (args, hints) = explain_args(args);\n                     handler.span_warn_with_code(\n                         span,\n                         &format!(\"fs.{name}({args}) is very dynamic{hints}\",),\n@@ -2056,19 +2150,17 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 );\n                 return Ok(());\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n                 span,\n                 &format!(\"fs.{name}({args}) is not statically analyze-able{hints}\",),\n                 DiagnosticId::Error(errors::failed_to_analyze::ecmascript::FS_METHOD.to_string()),\n             )\n         }\n \n-        JsValue::WellKnownFunction(WellKnownFunctionKind::PathResolve(..))\n-            if analysis.analyze_mode.is_tracing() =>\n-        {\n+        WellKnownFunctionKind::PathResolve(..) if analysis.analyze_mode.is_tracing() => {\n             let parent_path = origin.origin_path().owned().await?.parent();\n-            let args = linked_args(args).await?;\n+            let args = linked_args().await?;\n \n             let linked_func_call = state\n                 .link_value(\n@@ -2086,7 +2178,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n \n             let pat = js_value_to_pattern(&linked_func_call);\n             if !pat.has_constant_parts() {\n-                let (args, hints) = explain_args(&args);\n+                let (args, hints) = explain_args(args);\n                 handler.span_warn_with_code(\n                     span,\n                     &format!(\"path.resolve({args}) is very dynamic{hints}\",),\n@@ -2110,15 +2202,13 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n             return Ok(());\n         }\n \n-        JsValue::WellKnownFunction(WellKnownFunctionKind::PathJoin)\n-            if analysis.analyze_mode.is_tracing() =>\n-        {\n+        WellKnownFunctionKind::PathJoin if analysis.analyze_mode.is_tracing() => {\n             let context_path = source.ident().path().await?;\n             // ignore path.join in `node-gyp`, it will includes too many files\n             if context_path.path.contains(\"node_modules/node-gyp\") {\n                 return Ok(());\n             }\n-            let args = linked_args(args).await?;\n+            let args = linked_args().await?;\n             let linked_func_call = state\n                 .link_value(\n                     JsValue::call(\n@@ -2130,7 +2220,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 .await?;\n             let pat = js_value_to_pattern(&linked_func_call);\n             if !pat.has_constant_parts() {\n-                let (args, hints) = explain_args(&args);\n+                let (args, hints) = explain_args(args);\n                 handler.span_warn_with_code(\n                     span,\n                     &format!(\"path.join({args}) is very dynamic{hints}\",),\n@@ -2153,13 +2243,13 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n             );\n             return Ok(());\n         }\n-        JsValue::WellKnownFunction(WellKnownFunctionKind::ChildProcessSpawnMethod(name))\n+        WellKnownFunctionKind::ChildProcessSpawnMethod(name)\n             if analysis.analyze_mode.is_tracing() =>\n         {\n-            let args = linked_args(args).await?;\n+            let args = linked_args().await?;\n \n             // Is this specifically `spawn(process.argv[0], ['-e', ...])`?\n-            if is_invoking_node_process_eval(&args) {\n+            if is_invoking_node_process_eval(args) {\n                 return Ok(());\n             }\n \n@@ -2211,7 +2301,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     );\n                 }\n                 if show_dynamic_warning {\n-                    let (args, hints) = explain_args(&args);\n+                    let (args, hints) = explain_args(args);\n                     handler.span_warn_with_code(\n                         span,\n                         &format!(\"child_process.{name}({args}) is very dynamic{hints}\",),\n@@ -2222,7 +2312,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 }\n                 return Ok(());\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n                 span,\n                 &format!(\"child_process.{name}({args}) is not statically analyze-able{hints}\",),\n@@ -2231,15 +2321,13 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 ),\n             )\n         }\n-        JsValue::WellKnownFunction(WellKnownFunctionKind::ChildProcessFork)\n-            if analysis.analyze_mode.is_tracing() =>\n-        {\n-            let args = linked_args(args).await?;\n+        WellKnownFunctionKind::ChildProcessFork if analysis.analyze_mode.is_tracing() => {\n+            let args = linked_args().await?;\n             if !args.is_empty() {\n                 let first_arg = &args[0];\n                 let pat = js_value_to_pattern(first_arg);\n                 if !pat.has_constant_parts() {\n-                    let (args, hints) = explain_args(&args);\n+                    let (args, hints) = explain_args(args);\n                     handler.span_warn_with_code(\n                         span,\n                         &format!(\"child_process.fork({args}) is very dynamic{hints}\",),\n@@ -2263,7 +2351,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 );\n                 return Ok(());\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n                 span,\n                 &format!(\"child_process.fork({args}) is not statically analyze-able{hints}\",),\n@@ -2272,17 +2360,15 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 ),\n             )\n         }\n-        JsValue::WellKnownFunction(WellKnownFunctionKind::NodePreGypFind)\n-            if analysis.analyze_mode.is_tracing() =>\n-        {\n+        WellKnownFunctionKind::NodePreGypFind if analysis.analyze_mode.is_tracing() => {\n             use turbopack_resolve::node_native_binding::NodePreGypConfigReference;\n \n-            let args = linked_args(args).await?;\n+            let args = linked_args().await?;\n             if args.len() == 1 {\n                 let first_arg = &args[0];\n                 let pat = js_value_to_pattern(first_arg);\n                 if !pat.has_constant_parts() {\n-                    let (args, hints) = explain_args(&args);\n+                    let (args, hints) = explain_args(args);\n                     handler.span_warn_with_code(\n                         span,\n                         &format!(\"node-pre-gyp.find({args}) is very dynamic{hints}\",),\n@@ -2305,7 +2391,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 );\n                 return Ok(());\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n                 span,\n                 &format!(\n@@ -2317,12 +2403,10 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 ),\n             )\n         }\n-        JsValue::WellKnownFunction(WellKnownFunctionKind::NodeGypBuild)\n-            if analysis.analyze_mode.is_tracing() =>\n-        {\n+        WellKnownFunctionKind::NodeGypBuild if analysis.analyze_mode.is_tracing() => {\n             use turbopack_resolve::node_native_binding::NodeGypBuildReference;\n \n-            let args = linked_args(args).await?;\n+            let args = linked_args().await?;\n             if args.len() == 1 {\n                 let first_arg = state\n                     .link_value(args[0].clone(), ImportAttributes::empty_ref())\n@@ -2347,23 +2431,21 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     return Ok(());\n                 }\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n-                span,\n-                &format!(\n-                    \"require('node-gyp-build')({args}) is not statically analyze-able{hints}\",\n-                ),\n-                DiagnosticId::Error(\n-                    errors::failed_to_analyze::ecmascript::NODE_GYP_BUILD.to_string(),\n-                ),\n-            )\n+                    span,\n+                    &format!(\n+                        \"require('node-gyp-build')({args}) is not statically analyze-able{hints}\",\n+                    ),\n+                    DiagnosticId::Error(\n+                        errors::failed_to_analyze::ecmascript::NODE_GYP_BUILD.to_string(),\n+                    ),\n+                )\n         }\n-        JsValue::WellKnownFunction(WellKnownFunctionKind::NodeBindings)\n-            if analysis.analyze_mode.is_tracing() =>\n-        {\n+        WellKnownFunctionKind::NodeBindings if analysis.analyze_mode.is_tracing() => {\n             use turbopack_resolve::node_native_binding::NodeBindingsReference;\n \n-            let args = linked_args(args).await?;\n+            let args = linked_args().await?;\n             if args.len() == 1 {\n                 let first_arg = state\n                     .link_value(args[0].clone(), ImportAttributes::empty_ref())\n@@ -2381,7 +2463,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     return Ok(());\n                 }\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n                 span,\n                 &format!(\"require('bindings')({args}) is not statically analyze-able{hints}\",),\n@@ -2390,17 +2472,15 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 ),\n             )\n         }\n-        JsValue::WellKnownFunction(WellKnownFunctionKind::NodeExpressSet)\n-            if analysis.analyze_mode.is_tracing() =>\n-        {\n-            let args = linked_args(args).await?;\n+        WellKnownFunctionKind::NodeExpressSet if analysis.analyze_mode.is_tracing() => {\n+            let args = linked_args().await?;\n             if args.len() == 2\n                 && let Some(s) = args.first().and_then(|arg| arg.as_str())\n             {\n                 let pkg_or_dir = args.get(1).unwrap();\n                 let pat = js_value_to_pattern(pkg_or_dir);\n                 if !pat.has_constant_parts() {\n-                    let (args, hints) = explain_args(&args);\n+                    let (args, hints) = explain_args(args);\n                     handler.span_warn_with_code(\n                         span,\n                         &format!(\"require('express')().set({args}) is very dynamic{hints}\",),\n@@ -2466,7 +2546,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                     _ => {}\n                 }\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n                 span,\n                 &format!(\"require('express')().set({args}) is not statically analyze-able{hints}\",),\n@@ -2475,10 +2555,10 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 ),\n             )\n         }\n-        JsValue::WellKnownFunction(WellKnownFunctionKind::NodeStrongGlobalizeSetRootDir)\n+        WellKnownFunctionKind::NodeStrongGlobalizeSetRootDir\n             if analysis.analyze_mode.is_tracing() =>\n         {\n-            let args = linked_args(args).await?;\n+            let args = linked_args().await?;\n             if let Some(p) = args.first().and_then(|arg| arg.as_str()) {\n                 let abs_pattern = if p.starts_with(\"/ROOT/\") {\n                     Pattern::Constant(format!(\"{p}/intl\").into())\n@@ -2511,7 +2591,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 );\n                 return Ok(());\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n                 span,\n                 &format!(\n@@ -2523,10 +2603,8 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 ),\n             )\n         }\n-        JsValue::WellKnownFunction(WellKnownFunctionKind::NodeResolveFrom)\n-            if analysis.analyze_mode.is_tracing() =>\n-        {\n-            let args = linked_args(args).await?;\n+        WellKnownFunctionKind::NodeResolveFrom if analysis.analyze_mode.is_tracing() => {\n+            let args = linked_args().await?;\n             if args.len() == 2 && args.get(1).and_then(|arg| arg.as_str()).is_some() {\n                 analysis.add_reference(\n                     CjsAssetReference::new(\n@@ -2540,7 +2618,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 );\n                 return Ok(());\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n                 span,\n                 &format!(\"require('resolve-from')({args}) is not statically analyze-able{hints}\",),\n@@ -2549,10 +2627,8 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 ),\n             )\n         }\n-        JsValue::WellKnownFunction(WellKnownFunctionKind::NodeProtobufLoad)\n-            if analysis.analyze_mode.is_tracing() =>\n-        {\n-            let args = linked_args(args).await?;\n+        WellKnownFunctionKind::NodeProtobufLoad if analysis.analyze_mode.is_tracing() => {\n+            let args = linked_args().await?;\n             if args.len() == 2\n                 && let Some(JsValue::Object { parts, .. }) = args.get(1)\n             {\n@@ -2586,7 +2662,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n \n                 return Ok(());\n             }\n-            let (args, hints) = explain_args(&args);\n+            let (args, hints) = explain_args(args);\n             handler.span_warn_with_code(\n                 span,\n                 &format!(\n@@ -2598,17 +2674,10 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 ),\n             )\n         }\n-        _ => {\n-            for arg in args {\n-                if let EffectArg::Closure(_, block) = arg {\n-                    add_effects(block.effects);\n-                }\n-            }\n-        }\n-    }\n+        _ => {}\n+    };\n     Ok(())\n }\n-\n async fn handle_member(\n     ast_path: &[AstParentKind],\n     link_obj: impl Future<Output = Result<JsValue>> + Send + Sync,\n@@ -2843,10 +2912,10 @@ async fn analyze_amd_define(\n     handler: &Handler,\n     span: Span,\n     ast_path: &[AstParentKind],\n-    args: Vec<JsValue>,\n+    args: &[JsValue],\n     in_try: bool,\n ) -> Result<()> {\n-    match &args[..] {\n+    match args {\n         [JsValue::Constant(id), JsValue::Array { items: deps, .. }, _] if id.as_str().is_some() => {\n             analyze_amd_define_with_deps(\n                 source,"
        },
        {
            "sha": "7d5c3f535517da0e28635381bf8ee6d3bf76e1b9",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/require_context.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -317,7 +317,9 @@ impl IntoCodeGenReference for RequireContextAssetReference {\n     }\n }\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub struct RequireContextAssetReferenceCodeGen {\n     path: AstPath,\n     reference: ResolvedVc<RequireContextAssetReference>,"
        },
        {
            "sha": "805d51d15095359f1e046f340d7cd3d7b15e2b9b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/unreachable.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Funreachable.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Funreachable.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Funreachable.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -31,7 +31,9 @@ use crate::{\n     utils::AstPathRange,\n };\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Debug, Hash,\n+)]\n \n pub struct Unreachable {\n     range: AstPathRange,"
        },
        {
            "sha": "8c8d555a7332592896cc1c0112ac9abe0af10305",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/worker.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -125,7 +125,9 @@ impl IntoCodeGenReference for WorkerAssetReference {\n     }\n }\n \n-#[derive(PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue)]\n+#[derive(\n+    PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat, NonLocalValue, Hash, Debug,\n+)]\n pub struct WorkerAssetReferenceCodeGen {\n     reference: ResolvedVc<WorkerAssetReference>,\n     path: AstPath,"
        },
        {
            "sha": "4f0b24d6e17492452fde087aa495fa2275373aec",
            "filename": "turbopack/crates/turbopack-ecmascript/src/utils.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Futils.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a3aadbd37c2c19bdeac021b78a474d90bff9f9c0/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Futils.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Futils.rs?ref=a3aadbd37c2c19bdeac021b78a474d90bff9f9c0",
            "patch": "@@ -178,7 +178,7 @@ format_iter!(std::fmt::Pointer);\n format_iter!(std::fmt::UpperExp);\n format_iter!(std::fmt::UpperHex);\n \n-#[derive(Clone, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, Debug, NonLocalValue)]\n+#[derive(Clone, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs, Debug, NonLocalValue, Hash)]\n pub enum AstPathRange {\n     /// The ast path to the block or expression.\n     Exact(#[turbo_tasks(trace_ignore)] Vec<AstParentKind>),"
        }
    ],
    "stats": {
        "total": 527,
        "additions": 321,
        "deletions": 206
    }
}