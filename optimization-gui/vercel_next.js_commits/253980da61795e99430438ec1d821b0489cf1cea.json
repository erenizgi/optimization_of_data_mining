{
    "author": "bgw",
    "message": "Turbopack: Watch the root and every parent directory in non-recursive mode (#82129)\n\nThis only impacts the non-recursive codepath.\n\nThe notify-rs docs explain that you need to watch every parent of the file/directory you care about: https://docs.rs/notify/latest/notify/#parent-folder-deletion\n\nThis reduces the missing invalidations on Linux detected by my fuzzer, but does not eliminate them:\n\n```\nrm -rf /tmp/fuzz && cargo run --release -p turbo-tasks-fuzz -- fs-watcher --fs-root /tmp/fuzz\n```",
    "sha": "253980da61795e99430438ec1d821b0489cf1cea",
    "files": [
        {
            "sha": "860ce446d77c775f4d6305325fce4d44d4772334",
            "filename": "turbopack/crates/turbo-tasks-fs/src/watcher.rs",
            "status": "modified",
            "additions": 55,
            "deletions": 40,
            "changes": 95,
            "blob_url": "https://github.com/vercel/next.js/blob/253980da61795e99430438ec1d821b0489cf1cea/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/253980da61795e99430438ec1d821b0489cf1cea/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs?ref=253980da61795e99430438ec1d821b0489cf1cea",
            "patch": "@@ -10,7 +10,7 @@ use std::{\n     time::Duration,\n };\n \n-use anyhow::{Context, Result};\n+use anyhow::{Context, Result, anyhow};\n use dashmap::DashSet;\n use notify::{\n     Config, EventKind, PollWatcher, RecommendedWatcher, RecursiveMode, Watcher,\n@@ -105,6 +105,11 @@ impl Default for DiskWatcher {\n /// [`RecursiveMode::NonRecursive`] (default on Linux).\n pub(crate) struct NonRecursiveDiskWatcherState {\n     /// Keeps track of which directories are currently (or were previously) watched.\n+    ///\n+    /// Invariants:\n+    /// - Never contains `root_path`. A watcher for `root_path` is implicitly set up during\n+    ///   [`DiskWatcher::start_watching`].\n+    /// - Contains all parent directories up to `root_path` for every entry.\n     watching: DashSet<PathBuf>,\n }\n \n@@ -127,28 +132,31 @@ impl NonRecursiveDiskWatcherState {\n         }\n     }\n \n-    /// Called when a new directory is found in a parent directory we're watching.\n+    /// Called when a new directory is found in a parent directory we're watching. Restores the\n+    /// watcher if we were previously watching it.\n     pub(crate) fn restore_if_watching(\n         &self,\n         watcher: &DiskWatcher,\n         dir_path: &Path,\n         root_path: &Path,\n     ) -> Result<()> {\n-        if self.watching.contains(dir_path) {\n-            let mut internal = watcher.internal.lock().unwrap();\n-            // TODO: Also restore any watchers for children of this directory\n-            self.start_watching_dir(&mut internal, dir_path, root_path)?;\n+        if dir_path == root_path || !self.watching.contains(dir_path) {\n+            return Ok(());\n         }\n-        Ok(())\n+        let mut internal = watcher.internal.lock().unwrap();\n+        // TODO: Also restore any watchers for children of this directory\n+        self.start_watching_dir(&mut internal, dir_path, root_path)\n     }\n \n+    /// Called when a file in `dir_path` or `dir_path` itself is read or written. Adds a new watcher\n+    /// if we're not already watching the directory.\n     pub(crate) fn ensure_watching(\n         &self,\n         watcher: &DiskWatcher,\n         dir_path: &Path,\n         root_path: &Path,\n     ) -> Result<()> {\n-        if self.watching.contains(dir_path) {\n+        if dir_path == root_path || self.watching.contains(dir_path) {\n             return Ok(());\n         }\n         let mut internal = watcher.internal.lock().unwrap();\n@@ -165,42 +173,48 @@ impl NonRecursiveDiskWatcherState {\n         dir_path: &Path,\n         root_path: &Path,\n     ) -> Result<()> {\n-        if let Some(watcher_internal_guard) = watcher_internal_guard.as_mut() {\n-            let mut path = dir_path;\n-            let err_with_context = |err| {\n-                return Err(err).context(format!(\n-                    \"Unable to watch {} (tried up to {})\",\n-                    dir_path.display(),\n-                    path.display()\n-                ));\n-            };\n-            while let Err(err) = watcher_internal_guard.watch(path, RecursiveMode::NonRecursive) {\n-                match err {\n-                    notify::Error {\n-                        kind: notify::ErrorKind::PathNotFound,\n-                        ..\n-                    } => {\n-                        // The path was probably deleted before we could process the event. That's\n-                        // okay, just make sure we're watching the parent directory, so we can know\n-                        // if it gets recreated.\n-                        let Some(parent_path) = path.parent() else {\n-                            // this should never happen as we break before we reach the root path\n-                            return err_with_context(err);\n-                        };\n-                        if parent_path == root_path {\n-                            // assume there's already a root watcher\n-                            break;\n-                        }\n-                        if !self.watching.insert(parent_path.to_owned()) {\n-                            // we're already watching the parent path!\n-                            break;\n-                        }\n-                        path = parent_path;\n+        debug_assert_ne!(dir_path, root_path);\n+        let Some(watcher_internal_guard) = watcher_internal_guard.as_mut() else {\n+            return Ok(());\n+        };\n+\n+        let mut path = dir_path;\n+        let err_with_context = |err: anyhow::Error| {\n+            return Err(err).context(format!(\n+                \"Unable to watch {} (tried up to {})\",\n+                dir_path.display(),\n+                path.display()\n+            ));\n+        };\n+\n+        // watch every parent: https://docs.rs/notify/latest/notify/#parent-folder-deletion\n+        loop {\n+            match watcher_internal_guard.watch(path, RecursiveMode::NonRecursive) {\n+                res @ Ok(())\n+                | res @ Err(notify::Error {\n+                    // The path was probably deleted before we could process the event. That's\n+                    // okay, just make sure we're watching the parent directory, so we can know\n+                    // if it gets recreated.\n+                    kind: notify::ErrorKind::PathNotFound,\n+                    ..\n+                }) => {\n+                    let Some(parent_path) = path.parent() else {\n+                        // this should never happen as we break before we reach the root path\n+                        return err_with_context(res.err().map_or_else(\n+                            || anyhow!(\"failed to compute parent path\"),\n+                            |err| err.into(),\n+                        ));\n+                    };\n+                    if parent_path == root_path || !self.watching.insert(parent_path.to_path_buf())\n+                    {\n+                        break;\n                     }\n-                    _ => return err_with_context(err),\n+                    path = parent_path;\n                 }\n+                Err(err) => return err_with_context(err.into()),\n             }\n         }\n+\n         Ok(())\n     }\n }\n@@ -256,6 +270,7 @@ impl DiskWatcher {\n         };\n \n         if let Some(non_recursive) = &self.non_recursive_state {\n+            internal.watch(fs_inner.root_path(), RecursiveMode::NonRecursive)?;\n             for dir_path in non_recursive.watching.iter() {\n                 internal.watch(&dir_path, RecursiveMode::NonRecursive)?;\n             }"
        }
    ],
    "stats": {
        "total": 95,
        "additions": 55,
        "deletions": 40
    }
}