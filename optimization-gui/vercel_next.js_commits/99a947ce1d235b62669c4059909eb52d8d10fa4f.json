{
    "author": "unstubbable",
    "message": "Fix error propagation and teardown in Server Action request decoding (#87193)\n\nThis change switches to promise-based pipelines and uses\n`AbortController` to ensure multipart pipelines are properly canceled\nwhen decoding fails. Request bodies are fully consumed or aborted so\ndecoding cannot hang or silently drop errors.",
    "sha": "99a947ce1d235b62669c4059909eb52d8d10fa4f",
    "files": [
        {
            "sha": "c77bf7884411dbfdf03920e5269b313b031fddda",
            "filename": "packages/next/src/server/app-render/action-handler.ts",
            "status": "modified",
            "additions": 45,
            "deletions": 40,
            "changes": 85,
            "blob_url": "https://github.com/vercel/next.js/blob/99a947ce1d235b62669c4059909eb52d8d10fa4f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/99a947ce1d235b62669c4059909eb52d8d10fa4f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts?ref=99a947ce1d235b62669c4059909eb52d8d10fa4f",
            "patch": "@@ -858,8 +858,10 @@ export async function handleAction({\n \n           temporaryReferences = createTemporaryReferenceSet()\n \n-          const { Transform, pipeline } =\n+          const { PassThrough, Readable, Transform } =\n             require('node:stream') as typeof import('node:stream')\n+          const { pipeline } =\n+            require('node:stream/promises') as typeof import('node:stream/promises')\n \n           const defaultBodySizeLimit = '1 MB'\n           const bodySizeLimit =\n@@ -893,14 +895,6 @@ export async function handleAction({\n             },\n           })\n \n-          const sizeLimitedBody = pipeline(\n-            req.body,\n-            sizeLimitTransform,\n-            // Avoid unhandled errors from `pipeline()` by passing an empty completion callback.\n-            // We'll propagate the errors properly when consuming the stream.\n-            () => {}\n-          )\n-\n           if (isMultipartAction) {\n             if (isFetchAction) {\n               // A fetch action with a multipart body.\n@@ -919,47 +913,51 @@ export async function handleAction({\n                 limits: { fieldSize: bodySizeLimitBytes },\n               })\n \n-              // We need to use `pipeline(one, two)` instead of `one.pipe(two)` to propagate size limit errors correctly.\n-              pipeline(\n-                sizeLimitedBody,\n-                busboy,\n-                // Avoid unhandled errors from `pipeline()` by passing an empty completion callback.\n-                // We'll propagate the errors properly when consuming the stream.\n-                () => {}\n-              )\n-\n-              boundActionArguments = await decodeReplyFromBusboy(\n-                busboy,\n-                serverModuleMap,\n-                { temporaryReferences }\n-              )\n+              const abortController = new AbortController()\n+              try {\n+                ;[, boundActionArguments] = await Promise.all([\n+                  pipeline(req.body, sizeLimitTransform, busboy, {\n+                    signal: abortController.signal,\n+                  }),\n+                  decodeReplyFromBusboy(busboy, serverModuleMap, {\n+                    temporaryReferences,\n+                  }),\n+                ])\n+              } catch (err) {\n+                abortController.abort()\n+                throw err\n+              }\n             } else {\n               // Multipart POST, but not a fetch action.\n               // Potentially an MPA action, we have to try decoding it to check.\n \n+              const sizeLimitedBody = new PassThrough()\n+\n               // React doesn't yet publish a busboy version of decodeAction\n               // so we polyfill the parsing of FormData.\n               const fakeRequest = new Request('http://localhost', {\n                 method: 'POST',\n                 // @ts-expect-error\n                 headers: { 'Content-Type': contentType },\n-                body: new ReadableStream({\n-                  start: (controller) => {\n-                    sizeLimitedBody.on('data', (chunk) => {\n-                      controller.enqueue(new Uint8Array(chunk))\n-                    })\n-                    sizeLimitedBody.on('end', () => {\n-                      controller.close()\n-                    })\n-                    sizeLimitedBody.on('error', (err) => {\n-                      controller.error(err)\n-                    })\n-                  },\n-                }),\n+                body: Readable.toWeb(\n+                  sizeLimitedBody\n+                ) as ReadableStream<Uint8Array>,\n                 duplex: 'half',\n               })\n \n-              const formData = await fakeRequest.formData()\n+              let formData: FormData\n+              const abortController = new AbortController()\n+              try {\n+                ;[, formData] = await Promise.all([\n+                  pipeline(req.body, sizeLimitTransform, sizeLimitedBody, {\n+                    signal: abortController.signal,\n+                  }),\n+                  fakeRequest.formData(),\n+                ])\n+              } catch (err) {\n+                abortController.abort()\n+                throw err\n+              }\n \n               if (areAllActionIdsValid(formData, serverModuleMap) === false) {\n                 // TODO: This can be from skew or manipulated input. We should handle this case\n@@ -1023,10 +1021,17 @@ export async function handleAction({\n             // In practice, this happens if `encodeReply` returned a string instead of FormData,\n             // which can happen for very simple JSON-like values that don't need multiple flight rows.\n \n+            const sizeLimitedBody = new PassThrough()\n+\n             const chunks: Buffer[] = []\n-            for await (const chunk of sizeLimitedBody) {\n-              chunks.push(Buffer.from(chunk))\n-            }\n+            await Promise.all([\n+              pipeline(req.body, sizeLimitTransform, sizeLimitedBody),\n+              (async () => {\n+                for await (const chunk of sizeLimitedBody) {\n+                  chunks.push(Buffer.from(chunk))\n+                }\n+              })(),\n+            ])\n \n             const actionData = Buffer.concat(chunks).toString('utf-8')\n "
        }
    ],
    "stats": {
        "total": 85,
        "additions": 45,
        "deletions": 40
    }
}