{
    "author": "acdlite",
    "message": "[Segment Cache] Support output: \"export\" mode (#75671)\n\nAdds support for output: \"export\" mode to the Segment Cache\nimplementation. We output an additional `.txt` data file per segment per\npage. When the client issues a per-segment request, it appends the\nsegment path to the end of the page URL, rather than passing it as a\nrequest header.\n\nThe segment file output follows this convention:\n\n```\n/a/b/c.html\n/a/b/c/__next.a.txt         <- corresponds to segment /a\n/a/b/c/__next.a.b.txt       <- corresponds to segment /a/b\n/a/b/c/__next.a.b.c.txt     <- corresponds to segment /a/b/c\n\n... and so on\n```\n\nThis scheme is designed so that the server can implement patterns like\nprotection rules or rewrites using just the original path. i.e. by\nblocking access to `/a/b`, you also block access to all of its\nassociated segment data.\n\nTechnically it's possible for the segment files to clash with a nested\nsegment config. We add a `__next` prefix to make a clash less likely.\nIt's unlikely this will ever be an issue in practice but if needed we\ncould make this prefix configurable at build time.",
    "sha": "db0a723db980eee81b8252031217dbb79e4321f3",
    "files": [
        {
            "sha": "481fcfa7ad3a243011078be3a2a08463f50745ca",
            "filename": "packages/next/src/client/components/router-reducer/fetch-server-response.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 10,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/db0a723db980eee81b8252031217dbb79e4321f3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/db0a723db980eee81b8252031217dbb79e4321f3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts?ref=db0a723db980eee81b8252031217dbb79e4321f3",
            "patch": "@@ -160,6 +160,20 @@ export async function fetchServerResponse(\n         : 'low'\n       : 'auto'\n \n+    if (process.env.NODE_ENV === 'production') {\n+      if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n+        // In \"output: export\" mode, we can't rely on headers to distinguish\n+        // between HTML and RSC requests. Instead, we append an extra prefix\n+        // to the request.\n+        url = new URL(url)\n+        if (url.pathname.endsWith('/')) {\n+          url.pathname += 'index.txt'\n+        } else {\n+          url.pathname += '.txt'\n+        }\n+      }\n+    }\n+\n     const res = await createFetch(\n       url,\n       headers,\n@@ -255,16 +269,9 @@ export function createFetch(\n ) {\n   const fetchUrl = new URL(url)\n \n-  if (process.env.NODE_ENV === 'production') {\n-    if (process.env.__NEXT_CONFIG_OUTPUT === 'export') {\n-      if (fetchUrl.pathname.endsWith('/')) {\n-        fetchUrl.pathname += 'index.txt'\n-      } else {\n-        fetchUrl.pathname += '.txt'\n-      }\n-    }\n-  }\n-\n+  // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n+  // cache busting search param) from the request so they're\n+  // maximally cacheable.\n   setCacheBustingSearchParam(fetchUrl, headers)\n \n   if (process.env.__NEXT_TEST_MODE && fetchPriority !== null) {"
        },
        {
            "sha": "d31ed43e9571c284febc2d397302866c6769f223",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 151,
            "deletions": 42,
            "changes": 193,
            "blob_url": "https://github.com/vercel/next.js/blob/db0a723db980eee81b8252031217dbb79e4321f3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/db0a723db980eee81b8252031217dbb79e4321f3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=db0a723db980eee81b8252031217dbb79e4321f3",
            "patch": "@@ -24,7 +24,6 @@ import {\n import {\n   createFetch,\n   createFromNextReadableStream,\n-  urlToUrlWithoutFlightMarker,\n   type RequestHeaders,\n } from '../router-reducer/fetch-server-response'\n import {\n@@ -42,6 +41,7 @@ import type {\n import { createTupleMap, type TupleMap, type Prefix } from './tuple-map'\n import { createLRU } from './lru'\n import {\n+  convertSegmentPathToStaticExportFilename,\n   encodeChildSegmentKey,\n   encodeSegment,\n   ROOT_SEGMENT_KEY,\n@@ -206,6 +206,10 @@ export type NonEmptySegmentCacheEntry = Exclude<\n   EmptySegmentCacheEntry\n >\n \n+const isOutputExportMode =\n+  process.env.NODE_ENV === 'production' &&\n+  process.env.__NEXT_CONFIG_OUTPUT === 'export'\n+\n // Route cache entries vary on multiple keys: the href and the Next-Url. Each of\n // these parts needs to be included in the internal cache key. Rather than\n // concatenate the keys into a single key, we use a multi-level map, where the\n@@ -821,8 +825,24 @@ export async function fetchRouteOnCacheMiss(\n   const key = task.key\n   const href = key.href\n   const nextUrl = key.nextUrl\n+  const segmentPath = '/_tree'\n+\n+  const headers: RequestHeaders = {\n+    [RSC_HEADER]: '1',\n+    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n+    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n+  }\n+  if (nextUrl !== null) {\n+    headers[NEXT_URL] = nextUrl\n+  }\n+\n+  // In output: \"export\" mode, we need to add the segment path to the URL.\n+  const requestUrl = isOutputExportMode\n+    ? addSegmentPathToUrlInOutputExportMode(href, segmentPath)\n+    : href\n+\n   try {\n-    const response = await fetchSegmentPrefetchResponse(href, '/_tree', nextUrl)\n+    const response = await fetchPrefetchResponse(requestUrl, headers)\n     if (\n       !response ||\n       !response.ok ||\n@@ -841,7 +861,15 @@ export async function fetchRouteOnCacheMiss(\n     // This is a bit convoluted but it's taken from router-reducer and\n     // fetch-server-response\n     const canonicalUrl = response.redirected\n-      ? createHrefFromUrl(urlToUrlWithoutFlightMarker(response.url))\n+      ? createHrefFromUrl(\n+          new URL(\n+            removeSegmentPathFromURLInOutputExportMode(\n+              href,\n+              requestUrl,\n+              response.url\n+            )\n+          )\n+        )\n       : href\n \n     // Check whether the response varies based on the Next-Url header.\n@@ -855,9 +883,13 @@ export async function fetchRouteOnCacheMiss(\n     // This checks whether the response was served from the per-segment cache,\n     // rather than the old prefetching flow. If it fails, it implies that PPR\n     // is disabled on this route.\n-    // TODO: Add support for non-PPR routes.\n     const routeIsPPREnabled =\n-      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2'\n+      response.headers.get(NEXT_DID_POSTPONE_HEADER) === '2' ||\n+      // In output: \"export\" mode, we can't rely on response headers. But if we\n+      // receive a well-formed response, we can assume it's a static response,\n+      // because all data is static in this mode.\n+      isOutputExportMode\n+\n     if (routeIsPPREnabled) {\n       const prefetchStream = createPrefetchResponseStream(\n         response.body,\n@@ -956,7 +988,7 @@ export async function fetchSegmentOnCacheMiss(\n   route: FulfilledRouteCacheEntry,\n   segmentCacheEntry: PendingSegmentCacheEntry,\n   routeKey: RouteCacheKey,\n-  segmentKeyPath: string\n+  segmentPath: string\n ): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n   // This function is allowed to use async/await because it contains the actual\n   // fetch that gets issued on a cache miss. Notice it writes the result to the\n@@ -965,21 +997,50 @@ export async function fetchSegmentOnCacheMiss(\n   //\n   // Segment fetches are non-blocking so we don't need to ping the scheduler\n   // on completion.\n-  const href = routeKey.href\n+  const href =\n+    route.canonicalUrl !== routeKey.href\n+      ? // The route was redirected. If we request the segment data using the\n+        // same URL, that request will be redirected, too. To avoid an extra\n+        // waterfall on every segment request, pass the redirected URL instead\n+        // of the original one.\n+        //\n+        // Since the redirected URL might be a relative path, we need to resolve\n+        // it against the original href, which is a fully qualified URL.\n+        //\n+        // TODO: We should just store the fully qualified URL as canonical URL.\n+        // There are other parts of the router that currently expect a relative\n+        // path, so need to update those, too.\n+        new URL(route.canonicalUrl, routeKey.href).href\n+      : routeKey.href\n+  const nextUrl = routeKey.nextUrl\n+\n+  const normalizedSegmentPath =\n+    segmentPath === ROOT_SEGMENT_KEY\n+      ? // The root segment is a special case. To simplify the server-side\n+        // handling of these requests, we encode the root segment path as\n+        // `_index` instead of as an empty string. This should be treated as\n+        // an implementation detail and not as a stable part of the protocol.\n+        // It just needs to match the equivalent logic that happens when\n+        // prerendering the responses. It should not leak outside of Next.js.\n+        '/_index'\n+      : segmentPath\n+\n+  const headers: RequestHeaders = {\n+    [RSC_HEADER]: '1',\n+    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n+    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedSegmentPath,\n+  }\n+  if (nextUrl !== null) {\n+    headers[NEXT_URL] = nextUrl\n+  }\n+\n+  // In output: \"export\" mode, we need to add the segment path to the URL.\n+  const requestUrl = isOutputExportMode\n+    ? addSegmentPathToUrlInOutputExportMode(href, normalizedSegmentPath)\n+    : href\n+\n   try {\n-    const response = await fetchSegmentPrefetchResponse(\n-      href,\n-      segmentKeyPath === ROOT_SEGMENT_KEY\n-        ? // The root segment is a special case. To simplify the server-side\n-          // handling of these requests, we encode the root segment path as\n-          // `_index` instead of as an empty string. This should be treated as\n-          // an implementation detail and not as a stable part of the protocol.\n-          // It just needs to match the equivalent logic that happens when\n-          // prerendering the responses. It should not leak outside of Next.js.\n-          '/_index'\n-        : segmentKeyPath,\n-      routeKey.nextUrl\n-    )\n+    const response = await fetchPrefetchResponse(requestUrl, headers)\n     if (\n       !response ||\n       !response.ok ||\n@@ -989,7 +1050,11 @@ export async function fetchSegmentOnCacheMiss(\n       // is disabled on this route. Theoretically this should never happen\n       // because we only issue requests for segments once we've verified that\n       // the route supports PPR.\n-      response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' ||\n+      (response.headers.get(NEXT_DID_POSTPONE_HEADER) !== '2' &&\n+        // In output: \"export\" mode, we can't rely on response headers. But if\n+        // we receive a well-formed response, we can assume it's a static\n+        // response, because all data is static in this mode.\n+        !isOutputExportMode) ||\n       !response.body\n     ) {\n       // Server responded with an error, or with a miss. We should still cache\n@@ -1337,34 +1402,30 @@ function writeSeedDataIntoCache(\n   }\n }\n \n-async function fetchSegmentPrefetchResponse(\n-  href: NormalizedHref,\n-  segmentPath: string,\n-  nextUrl: NormalizedNextUrl | null\n-): Promise<Response | null> {\n-  const headers: RequestHeaders = {\n-    [RSC_HEADER]: '1',\n-    [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n-    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: segmentPath,\n-  }\n-  if (nextUrl !== null) {\n-    headers[NEXT_URL] = nextUrl\n-  }\n-  return fetchPrefetchResponse(href, headers)\n-}\n-\n async function fetchPrefetchResponse(\n-  href: NormalizedHref,\n+  href: string,\n   headers: RequestHeaders\n ): Promise<Response | null> {\n   const fetchPriority = 'low'\n   const response = await createFetch(new URL(href), headers, fetchPriority)\n-  const contentType = response.headers.get('content-type')\n-  const isFlightResponse =\n-    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n-  if (!response.ok || !isFlightResponse) {\n+  if (!response.ok) {\n     return null\n   }\n+\n+  // Check the content type\n+  if (isOutputExportMode) {\n+    // In output: \"export\" mode, we relaxed about the content type, since it's\n+    // not Next.js that's serving the response. If the status is OK, assume the\n+    // response is valid. If it's not a valid response, the Flight client won't\n+    // be able to decode it, and we'll treat it as a miss.\n+  } else {\n+    const contentType = response.headers.get('content-type')\n+    const isFlightResponse =\n+      contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n+    if (!isFlightResponse) {\n+      return null\n+    }\n+  }\n   return response\n }\n \n@@ -1415,6 +1476,54 @@ function createPrefetchResponseStream(\n   })\n }\n \n+function addSegmentPathToUrlInOutputExportMode(\n+  url: string,\n+  segmentPath: string\n+) {\n+  if (isOutputExportMode) {\n+    // In output: \"export\" mode, we cannot use a header to encode the segment\n+    // path. Instead, we append it to the end of the pathname.\n+    const staticUrl = new URL(url)\n+    const routeDir = staticUrl.pathname.endsWith('/')\n+      ? staticUrl.pathname.substring(0, -1)\n+      : staticUrl.pathname\n+    const staticExportFilename =\n+      convertSegmentPathToStaticExportFilename(segmentPath)\n+    staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n+    return staticUrl.href\n+  }\n+  return url\n+}\n+\n+function removeSegmentPathFromURLInOutputExportMode(\n+  href: string,\n+  requestUrl: string,\n+  redirectUrl: string\n+) {\n+  if (isOutputExportMode) {\n+    // Reverse of addSegmentPathToUrlInOutputExportMode.\n+    //\n+    // In output: \"export\" mode, we append an extra string to the URL that\n+    // represents the segment path. If the server performs a redirect, it must\n+    // include the segment path in new URL.\n+    //\n+    // This removes the segment path from the redirected URL to obtain the\n+    // URL of the page.\n+    const segmentPath = requestUrl.substring(href.length)\n+    if (redirectUrl.endsWith(segmentPath)) {\n+      // Remove the segment path from the redirect URL to get the page URL.\n+      return redirectUrl.substring(0, redirectUrl.length - segmentPath.length)\n+    } else {\n+      // The server redirected to a URL that doesn't include the segment path.\n+      // This suggests the server may not have been configured correctly, but\n+      // we'll assume the redirected URL represents the page URL and continue.\n+      // TODO: Consider printing a warning with a link to a page that explains\n+      // how to configure redirects and rewrites correctly.\n+    }\n+  }\n+  return redirectUrl\n+}\n+\n function createPromiseWithResolvers<T>(): PromiseWithResolvers<T> {\n   // Shim of Stage 4 Promise.withResolvers proposal\n   let resolve: (value: T | PromiseLike<T>) => void"
        },
        {
            "sha": "ad5321648d37bdb6fc3af0c2d7eee0008686cf37",
            "filename": "packages/next/src/export/index.ts",
            "status": "modified",
            "additions": 80,
            "deletions": 7,
            "changes": 87,
            "blob_url": "https://github.com/vercel/next.js/blob/db0a723db980eee81b8252031217dbb79e4321f3/packages%2Fnext%2Fsrc%2Fexport%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/db0a723db980eee81b8252031217dbb79e4321f3/packages%2Fnext%2Fsrc%2Fexport%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fexport%2Findex.ts?ref=db0a723db980eee81b8252031217dbb79e4321f3",
            "patch": "@@ -12,11 +12,16 @@ import { existsSync, promises as fs } from 'fs'\n \n import '../server/require-hook'\n \n-import { dirname, join, resolve, sep } from 'path'\n+import { dirname, join, resolve, sep, relative } from 'path'\n import { formatAmpMessages } from '../build/output/index'\n import type { AmpPageStatus } from '../build/output/index'\n import * as Log from '../build/output/log'\n-import { RSC_SUFFIX, SSG_FALLBACK_EXPORT_ERROR } from '../lib/constants'\n+import {\n+  RSC_SEGMENT_SUFFIX,\n+  RSC_SEGMENTS_DIR_SUFFIX,\n+  RSC_SUFFIX,\n+  SSG_FALLBACK_EXPORT_ERROR,\n+} from '../lib/constants'\n import { recursiveCopy } from '../lib/recursive-copy'\n import {\n   BUILD_ID_FILE,\n@@ -57,6 +62,7 @@ import type { DeepReadonly } from '../shared/lib/deep-readonly'\n import { isInterceptionRouteRewrite } from '../lib/generate-interception-routes-rewrites'\n import type { ActionManifest } from '../build/webpack/plugins/flight-client-entry-plugin'\n import { extractInfoFromServerReferenceId } from '../shared/lib/server-reference-info'\n+import { convertSegmentPathToStaticExportFilename } from '../server/app-render/segment-value-encoding'\n \n export class ExportError extends Error {\n   code = 'NEXT_EXPORT_ERROR'\n@@ -684,19 +690,23 @@ async function exportAppImpl(\n   // copy prerendered routes to outDir\n   if (!options.buildExport && prerenderManifest) {\n     await Promise.all(\n-      Object.keys(prerenderManifest.routes).map(async (route) => {\n-        const { srcRoute } = prerenderManifest!.routes[route]\n+      Object.keys(prerenderManifest.routes).map(async (unnormalizedRoute) => {\n+        const { srcRoute } = prerenderManifest!.routes[unnormalizedRoute]\n         const appPageName = mapAppRouteToPage.get(srcRoute || '')\n-        const pageName = appPageName || srcRoute || route\n+        const pageName = appPageName || srcRoute || unnormalizedRoute\n         const isAppPath = Boolean(appPageName)\n         const isAppRouteHandler = appPageName && isAppRouteRoute(appPageName)\n \n         // returning notFound: true from getStaticProps will not\n         // output html/json files during the build\n-        if (prerenderManifest!.notFoundRoutes.includes(route)) {\n+        if (prerenderManifest!.notFoundRoutes.includes(unnormalizedRoute)) {\n           return\n         }\n-        route = normalizePagePath(route)\n+        // TODO: This rewrites /index/foo to /index/index/foo. Investigate and\n+        // fix. I presume this was because normalizePagePath was designed for\n+        // some other use case and then reused here for static exports without\n+        // realizing the implications.\n+        const route = normalizePagePath(unnormalizedRoute)\n \n         const pagePath = getPagePath(pageName, distDir, undefined, isAppPath)\n         const distPagesDir = join(\n@@ -752,6 +762,35 @@ async function exportAppImpl(\n           await fs.mkdir(dirname(ampHtmlDest), { recursive: true })\n           await fs.copyFile(`${orig}.amp.html`, ampHtmlDest)\n         }\n+\n+        const segmentsDir = `${orig}${RSC_SEGMENTS_DIR_SUFFIX}`\n+        if (isAppPath && existsSync(segmentsDir)) {\n+          // Output a data file for each of this page's segments\n+          //\n+          // These files are requested by the client router's internal\n+          // prefetcher, not the user directly. So we don't need to account for\n+          // things like trailing slash handling.\n+          //\n+          // To keep the protocol simple, we can use the non-normalized route\n+          // path instead of the normalized one (which, among other things,\n+          // rewrites `/` to `/index`).\n+          const segmentsDirDest = join(outDir, unnormalizedRoute)\n+          const segmentPaths = await collectSegmentPaths(segmentsDir)\n+          await Promise.all(\n+            segmentPaths.map(async (segmentFileSrc) => {\n+              const segmentPath =\n+                '/' + segmentFileSrc.slice(0, -RSC_SEGMENT_SUFFIX.length)\n+              const segmentFilename =\n+                convertSegmentPathToStaticExportFilename(segmentPath)\n+              const segmentFileDest = join(segmentsDirDest, segmentFilename)\n+              await fs.mkdir(dirname(segmentFileDest), { recursive: true })\n+              await fs.copyFile(\n+                join(segmentsDir, segmentFileSrc),\n+                segmentFileDest\n+              )\n+            })\n+          )\n+        }\n       })\n     )\n   }\n@@ -793,6 +832,40 @@ async function exportAppImpl(\n   return collector\n }\n \n+async function collectSegmentPaths(segmentsDirectory: string) {\n+  const results: Array<string> = []\n+  await collectSegmentPathsImpl(segmentsDirectory, segmentsDirectory, results)\n+  return results\n+}\n+\n+async function collectSegmentPathsImpl(\n+  segmentsDirectory: string,\n+  directory: string,\n+  results: Array<string>\n+) {\n+  const segmentFiles = await fs.readdir(directory, {\n+    withFileTypes: true,\n+  })\n+  await Promise.all(\n+    segmentFiles.map(async (segmentFile) => {\n+      if (segmentFile.isDirectory()) {\n+        await collectSegmentPathsImpl(\n+          segmentsDirectory,\n+          join(directory, segmentFile.name),\n+          results\n+        )\n+        return\n+      }\n+      if (!segmentFile.name.endsWith(RSC_SEGMENT_SUFFIX)) {\n+        return\n+      }\n+      results.push(\n+        relative(segmentsDirectory, join(directory, segmentFile.name))\n+      )\n+    })\n+  )\n+}\n+\n export default async function exportApp(\n   dir: string,\n   options: ExportAppOptions,"
        },
        {
            "sha": "09d47de9e7e02aedd52472969c61730263aa43be",
            "filename": "packages/next/src/server/app-render/segment-value-encoding.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/db0a723db980eee81b8252031217dbb79e4321f3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fsegment-value-encoding.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/db0a723db980eee81b8252031217dbb79e4321f3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fsegment-value-encoding.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fsegment-value-encoding.ts?ref=db0a723db980eee81b8252031217dbb79e4321f3",
            "patch": "@@ -73,3 +73,9 @@ function encodeToFilesystemAndURLSafeString(value: string) {\n     .replace(/=+$/, '') // Remove trailing '='\n   return '!' + base64url\n }\n+\n+export function convertSegmentPathToStaticExportFilename(\n+  segmentPath: string\n+): string {\n+  return `__next${segmentPath.replace(/\\//g, '.')}.txt`\n+}"
        },
        {
            "sha": "dbce4ea8e3aeb6cb61b81712b62288d5abaf776b",
            "filename": "test/e2e/app-dir/segment-cache/export/app/layout.tsx",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fapp%2Flayout.tsx?ref=db0a723db980eee81b8252031217dbb79e4321f3",
            "patch": "@@ -0,0 +1,11 @@\n+export default function RootLayout({\n+  children,\n+}: {\n+  children: React.ReactNode\n+}) {\n+  return (\n+    <html lang=\"en\">\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "af0ea301ccc6d98c7fe6e17ca47f981ae7a7f8cd",
            "filename": "test/e2e/app-dir/segment-cache/export/app/page.tsx",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fapp%2Fpage.tsx?ref=db0a723db980eee81b8252031217dbb79e4321f3",
            "patch": "@@ -0,0 +1,39 @@\n+import { LinkAccordion } from '../components/link-accordion'\n+\n+export default function OutputExport() {\n+  return (\n+    <>\n+      <p>\n+        Demonstrates that per-segment prefetching works in{' '}\n+        <code>output: export</code> mode.\n+      </p>\n+      <ul>\n+        <li>\n+          <LinkAccordion href=\"/target-page\">Target</LinkAccordion>\n+        </li>\n+      </ul>\n+      <p>\n+        The following link is rewritten on the server to the same page as the\n+        link above:\n+      </p>\n+      <ul>\n+        <li>\n+          <LinkAccordion href=\"/rewrite-to-target-page\">\n+            Rewrite to target page\n+          </LinkAccordion>\n+        </li>\n+      </ul>\n+      <p>\n+        The following link is redirected on the server to the same page as the\n+        link above:\n+      </p>\n+      <ul>\n+        <li>\n+          <LinkAccordion href=\"/redirect-to-target-page\">\n+            Redirect to target page\n+          </LinkAccordion>\n+        </li>\n+      </ul>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "b9392122d574e3b7b310ae6fd436d615ba24ae56",
            "filename": "test/e2e/app-dir/segment-cache/export/app/target-page/page.tsx",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fapp%2Ftarget-page%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fapp%2Ftarget-page%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fapp%2Ftarget-page%2Fpage.tsx?ref=db0a723db980eee81b8252031217dbb79e4321f3",
            "patch": "@@ -0,0 +1,10 @@\n+import Link from 'next/link'\n+\n+export default function TargetPage() {\n+  return (\n+    <>\n+      <div id=\"target-page\">Target page</div>\n+      <Link href=\"/\">Back to home</Link>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "4b253eab3adf36164d260dbafc6e89286719e164",
            "filename": "test/e2e/app-dir/segment-cache/export/components/link-accordion.tsx",
            "status": "added",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fcomponents%2Flink-accordion.tsx?ref=db0a723db980eee81b8252031217dbb79e4321f3",
            "patch": "@@ -0,0 +1,23 @@\n+'use client'\n+\n+import Link from 'next/link'\n+import { useState } from 'react'\n+\n+export function LinkAccordion({ href, children }) {\n+  const [isVisible, setIsVisible] = useState(false)\n+  return (\n+    <>\n+      <input\n+        type=\"checkbox\"\n+        checked={isVisible}\n+        onChange={() => setIsVisible(!isVisible)}\n+        data-link-accordion={href}\n+      />\n+      {isVisible ? (\n+        <Link href={href}>{children}</Link>\n+      ) : (\n+        `${children} (link is hidden)`\n+      )}\n+    </>\n+  )\n+}"
        },
        {
            "sha": "e740e0c5233beaf52f357c8869d9beb947290ad5",
            "filename": "test/e2e/app-dir/segment-cache/export/next.config.js",
            "status": "added",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fnext.config.js?ref=db0a723db980eee81b8252031217dbb79e4321f3",
            "patch": "@@ -0,0 +1,13 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  output: 'export',\n+  experimental: {\n+    ppr: false,\n+    dynamicIO: true,\n+    clientSegmentCache: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "e813a25a8db56e1e0754260694f7af7dc469c0e3",
            "filename": "test/e2e/app-dir/segment-cache/export/segment-cache-output-export.test.ts",
            "status": "added",
            "additions": 163,
            "deletions": 0,
            "changes": 163,
            "blob_url": "https://github.com/vercel/next.js/blob/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fsegment-cache-output-export.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fsegment-cache-output-export.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fsegment-cache-output-export.test.ts?ref=db0a723db980eee81b8252031217dbb79e4321f3",
            "patch": "@@ -0,0 +1,163 @@\n+import type * as Playwright from 'playwright'\n+import webdriver from 'next-webdriver'\n+import { createRouterAct } from '../router-act'\n+import { findPort, nextBuild } from 'next-test-utils'\n+import { isNextStart } from 'e2e-utils'\n+import { server } from './server.mjs'\n+\n+describe('segment cache (output: \"export\")', () => {\n+  if (!isNextStart) {\n+    test('build test should not run during dev test run', () => {})\n+    return\n+  }\n+\n+  // To debug these tests locally, first build the app, then run:\n+  //\n+  // node start.mjs\n+  //\n+  // This will serve the static `/out` directory, and also set up a server-side\n+  // rewrite, which some of the tests below rely on.\n+\n+  let port: number\n+\n+  beforeAll(async () => {\n+    const appDir = __dirname\n+    await nextBuild(appDir, undefined, { cwd: appDir })\n+    port = await findPort()\n+    server.listen(port)\n+  })\n+\n+  afterAll(() => {\n+    server.close()\n+  })\n+\n+  it('basic prefetch in output: \"export\" mode', async () => {\n+    let act\n+    const browser = await webdriver(port, '/', {\n+      beforePageLoad(p: Playwright.Page) {\n+        act = createRouterAct(p)\n+      },\n+    })\n+\n+    // Initiate a prefetch\n+    await act(\n+      async () => {\n+        const checkbox = await browser.elementByCss(\n+          '[data-link-accordion=\"/target-page\"]'\n+        )\n+        await checkbox.click()\n+      },\n+      {\n+        includes: 'Target page',\n+      }\n+    )\n+\n+    // Navigate to the prefetched target page.\n+    await act(\n+      async () => {\n+        const link = await browser.elementByCss('a[href=\"/target-page\"]')\n+        await link.click()\n+\n+        // The page was prefetched, so we're able to render the target\n+        // page immediately.\n+        const div = await browser.elementById('target-page')\n+        expect(await div.text()).toBe('Target page')\n+\n+        // The target page includes a link back to the home page\n+        await browser.elementByCss('a[href=\"/\"]')\n+      },\n+      {\n+        // Should have prefetched the home page\n+        includes: 'Demonstrates that per-segment prefetching works',\n+      }\n+    )\n+  })\n+\n+  it('prefetch a link to a page that is rewritten server side', async () => {\n+    let act\n+    const browser = await webdriver(port, '/', {\n+      beforePageLoad(p: Playwright.Page) {\n+        act = createRouterAct(p)\n+      },\n+    })\n+\n+    // Initiate a prefetch\n+    await act(\n+      async () => {\n+        const checkbox = await browser.elementByCss(\n+          '[data-link-accordion=\"/rewrite-to-target-page\"]'\n+        )\n+        await checkbox.click()\n+      },\n+      {\n+        includes: 'Target page',\n+      }\n+    )\n+\n+    // Navigate to the prefetched page.\n+    await act(\n+      async () => {\n+        const link = await browser.elementByCss(\n+          'a[href=\"/rewrite-to-target-page\"]'\n+        )\n+        await link.click()\n+\n+        // The page was prefetched, so we're able to render the target\n+        // page immediately.\n+        const div = await browser.elementById('target-page')\n+        expect(await div.text()).toBe('Target page')\n+\n+        // The target page includes a link back to the home page\n+        await browser.elementByCss('a[href=\"/\"]')\n+      },\n+      {\n+        // Should have prefetched the home page\n+        includes: 'Demonstrates that per-segment prefetching works',\n+      }\n+    )\n+  })\n+\n+  it('prefetch a link to a page that is redirected server side', async () => {\n+    let act\n+    const browser = await webdriver(port, '/', {\n+      beforePageLoad(p: Playwright.Page) {\n+        act = createRouterAct(p)\n+      },\n+    })\n+\n+    // Initiate a prefetch\n+    await act(\n+      async () => {\n+        const checkbox = await browser.elementByCss(\n+          '[data-link-accordion=\"/redirect-to-target-page\"]'\n+        )\n+        await checkbox.click()\n+      },\n+      {\n+        includes: 'Target page',\n+      }\n+    )\n+\n+    // Navigate to the prefetched page.\n+    await act(\n+      async () => {\n+        const link = await browser.elementByCss(\n+          'a[href=\"/redirect-to-target-page\"]'\n+        )\n+        await link.click()\n+\n+        // The page was prefetched, so we're able to render the target\n+        // page immediately.\n+        const div = await browser.elementById('target-page')\n+        expect(await div.text()).toBe('Target page')\n+\n+        // The target page includes a link back to the home page\n+        await browser.elementByCss('a[href=\"/\"]')\n+      },\n+      {\n+        // Should have prefetched the home page\n+        includes: 'Demonstrates that per-segment prefetching works',\n+      }\n+    )\n+  })\n+})"
        },
        {
            "sha": "74fa179fff52c25b361c4fe4a3f2448fab8fa22c",
            "filename": "test/e2e/app-dir/segment-cache/export/server.mjs",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fserver.mjs",
            "raw_url": "https://github.com/vercel/next.js/raw/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fserver.mjs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fserver.mjs?ref=db0a723db980eee81b8252031217dbb79e4321f3",
            "patch": "@@ -0,0 +1,37 @@\n+import express from 'express'\n+import { join, dirname } from 'node:path'\n+import { fileURLToPath } from 'node:url'\n+import { createServer } from 'node:http'\n+\n+const OUT_DIR = join(dirname(fileURLToPath(import.meta.url)), 'out')\n+\n+const app = express()\n+\n+// Redirect /redirect-to-target-page/* to /target-page/*\n+app.get('/redirect-to-target-page/:file?', (req, res) => {\n+  const { file } = req.params\n+  const newUrl = file ? `/target-page/${file}` : '/target-page'\n+  console.log(`Redirecting to ${newUrl}`)\n+  res.redirect(302, newUrl)\n+})\n+\n+// Rewrite /rewrite-to-target-page/* to /target-page/*\n+// NOTE: This intentionally uses `app.use` instead of `app.get` because\n+// the latter doesn't let you modify the `req.url` property.\n+app.use((req, res, next) => {\n+  const url = req.originalUrl\n+  if (/^\\/rewrite-to-target-page\\/?[^/]*$/.test(url)) {\n+    const newUrl = req.originalUrl.replace(\n+      '/rewrite-to-target-page',\n+      '/target-page'\n+    )\n+    console.log(`Rewriting to ${newUrl}`)\n+    req.url = newUrl\n+  }\n+  next()\n+})\n+\n+// Serve static files from the out directory\n+app.use(express.static(OUT_DIR, { extensions: ['html'] }))\n+\n+export const server = createServer(app)"
        },
        {
            "sha": "0a1f576295c8c4e0d08748790f9eeee52759f125",
            "filename": "test/e2e/app-dir/segment-cache/export/start.mjs",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fstart.mjs",
            "raw_url": "https://github.com/vercel/next.js/raw/db0a723db980eee81b8252031217dbb79e4321f3/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fstart.mjs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fexport%2Fstart.mjs?ref=db0a723db980eee81b8252031217dbb79e4321f3",
            "patch": "@@ -0,0 +1,6 @@\n+import { server } from './server.mjs'\n+\n+const port = 3000\n+server.listen(3000, () => {\n+  console.log(`Server running at http://localhost:${port}/`)\n+})"
        }
    ],
    "stats": {
        "total": 615,
        "additions": 556,
        "deletions": 59
    }
}