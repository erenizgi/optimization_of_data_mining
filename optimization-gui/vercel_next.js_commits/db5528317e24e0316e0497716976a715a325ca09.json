{
    "author": "sokra",
    "message": "Turbopack: remove the streaming hack for improved stability (#85858)\n\n### What?\r\n\r\nRemove the hack we use for streaming in turbo-tasks.\r\nWe don't use the stream capability and the streaming hack causes some problems.\r\n\r\nfixes `Item already exists` error\r\n\r\nCloses https://github.com/vercel/next.js/issues/85833",
    "sha": "db5528317e24e0316e0497716976a715a325ca09",
    "files": [
        {
            "sha": "b12b923a28f364ad9494fcbdde8c36197d8ccb2f",
            "filename": "crates/next-core/src/next_font/google/mod.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/db5528317e24e0316e0497716976a715a325ca09/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/db5528317e24e0316e0497716976a715a325ca09/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs?ref=db5528317e24e0316e0497716976a715a325ca09",
            "patch": "@@ -8,7 +8,6 @@ use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{Completion, FxIndexMap, ResolvedVc, Vc};\n-use turbo_tasks_bytes::stream::SingleValue;\n use turbo_tasks_env::{CommandLineProcessEnv, ProcessEnv};\n use turbo_tasks_fetch::{FetchClientConfig, HttpResponseBody};\n use turbo_tasks_fs::{\n@@ -768,10 +767,9 @@ async fn get_mock_stylesheet(\n     )\n     .await?;\n \n-    match &val.try_into_single().await? {\n-        SingleValue::Single(val) => {\n-            let val: FxHashMap<RcStr, Option<RcStr>> =\n-                parse_json_with_source_context(val.to_str()?)?;\n+    match &*val {\n+        Some(val) => {\n+            let val: FxHashMap<RcStr, Option<RcStr>> = parse_json_with_source_context(val)?;\n             Ok(val\n                 .get(&stylesheet_url)\n                 .context(\"url not found\")?"
        },
        {
            "sha": "7882f167f1b6f20ac9621488eeacb41842de0f50",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/db5528317e24e0316e0497716976a715a325ca09/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/db5528317e24e0316e0497716976a715a325ca09/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=db5528317e24e0316e0497716976a715a325ca09",
            "patch": "@@ -1953,8 +1953,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             && !session_dependent\n             // Task has no invalidator\n             && !task.has_key(&CachedDataItemKey::HasInvalidator {})\n-            // This is a hack for the streaming hack.\n-            && !task.has_key(&CachedDataItemKey::Stateful {})\n             // Task has no dependencies on collectibles\n             && count!(task, CollectiblesDependency) == 0\n         {"
        },
        {
            "sha": "dd26a84615ec97a688a1f0c7567faaaca5129e03",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_cell.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 5,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/db5528317e24e0316e0497716976a715a325ca09/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/db5528317e24e0316e0497716976a715a325ca09/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs?ref=db5528317e24e0316e0497716976a715a325ca09",
            "patch": "@@ -58,14 +58,11 @@ impl UpdateCellOperation {\n \n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n \n-        let is_stateful = task.has_key(&CachedDataItemKey::Stateful {});\n         // We need to detect recomputation, because here the content has not actually changed (even\n         // if it's not equal to the old content, as not all values implement Eq). We have to\n         // assume that tasks are deterministic and pure.\n-        let assume_unchanged = !ctx.should_track_dependencies()\n-            || (!task.has_key(&CachedDataItemKey::Dirty {})\n-            // This is a hack for the streaming hack. Stateful tasks are never recomputed, so this forces invalidation for them in case of this hack.\n-            && !is_stateful);\n+        let assume_unchanged =\n+            !ctx.should_track_dependencies() || !task.has_key(&CachedDataItemKey::Dirty {});\n \n         let old_content = get!(task, CellData { cell });\n "
        },
        {
            "sha": "d925991ef4e91d18c791f1ab1df4f5a2f52ca371",
            "filename": "turbopack/crates/turbopack-node/src/evaluate.rs",
            "status": "modified",
            "additions": 53,
            "deletions": 207,
            "changes": 260,
            "blob_url": "https://github.com/vercel/next.js/blob/db5528317e24e0316e0497716976a715a325ca09/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/db5528317e24e0316e0497716976a715a325ca09/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs?ref=db5528317e24e0316e0497716976a715a325ca09",
            "patch": "@@ -1,25 +1,14 @@\n-use std::{\n-    borrow::Cow, iter, ops::ControlFlow, sync::Arc, thread::available_parallelism, time::Duration,\n-};\n+use std::{borrow::Cow, iter, sync::Arc, thread::available_parallelism, time::Duration};\n \n-use anyhow::{Result, anyhow, bail};\n-use async_stream::try_stream as generator;\n-use futures::{\n-    SinkExt, StreamExt,\n-    channel::mpsc::{UnboundedSender, unbounded},\n-    pin_mut,\n-};\n+use anyhow::{Result, bail};\n use futures_retry::{FutureRetry, RetryPolicy};\n-use parking_lot::Mutex;\n use serde::{Deserialize, Serialize, de::DeserializeOwned};\n use serde_json::Value as JsonValue;\n-use turbo_rcstr::rcstr;\n+use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n-    Completion, Effects, FxIndexMap, NonLocalValue, OperationVc, RawVc, ReadRef, ResolvedVc,\n-    TaskInput, TryJoinIterExt, Vc, VcValueType, backend::VerificationMode, duration_span,\n-    fxindexmap, get_effects, mark_finished, prevent_gc, trace::TraceRawVcs, util::SharedError,\n+    Completion, Effects, FxIndexMap, NonLocalValue, OperationVc, ReadRef, ResolvedVc, TaskInput,\n+    TryJoinIterExt, Vc, duration_span, fxindexmap, get_effects, trace::TraceRawVcs,\n };\n-use turbo_tasks_bytes::{Bytes, Stream};\n use turbo_tasks_env::{EnvMap, ProcessEnv};\n use turbo_tasks_fs::{File, FileSystemPath, to_sys_path};\n use turbopack_core::{\n@@ -70,21 +59,6 @@ enum EvalJavaScriptIncomingMessage {\n     Error(StructuredError),\n }\n \n-type LoopResult = ControlFlow<Result<Option<String>, StructuredError>, String>;\n-\n-type EvaluationItem = Result<Bytes, SharedError>;\n-type JavaScriptStream = Stream<EvaluationItem>;\n-\n-#[turbo_tasks::value(eq = \"manual\", cell = \"new\", serialization = \"none\")]\n-pub struct JavaScriptStreamSender {\n-    #[turbo_tasks(trace_ignore, debug_ignore)]\n-    get: Box<dyn Fn() -> UnboundedSender<Result<Bytes, SharedError>> + Send + Sync>,\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-#[derive(Clone, Debug)]\n-pub struct JavaScriptEvaluation(#[turbo_tasks(trace_ignore)] JavaScriptStream);\n-\n #[turbo_tasks::value]\n struct EmittedEvaluatePoolAssets {\n     bootstrap: ResolvedVc<Box<dyn OutputAsset>>,\n@@ -350,8 +324,6 @@ pub trait EvaluateContext {\n     type ResponseMessage: Serialize;\n     type State: Default;\n \n-    fn compute(self, sender: Vc<JavaScriptStreamSender>)\n-    -> impl Future<Output = Result<()>> + Send;\n     fn pool(&self) -> OperationVc<NodeJsPool>;\n     fn keep_alive(&self) -> bool {\n         false\n@@ -382,59 +354,51 @@ pub trait EvaluateContext {\n     ) -> impl Future<Output = Result<()>> + Send;\n }\n \n-pub async fn custom_evaluate(\n-    evaluate_context: impl EvaluateContext,\n-) -> Result<Vc<JavaScriptEvaluation>> {\n-    // TODO: The way we invoke compute_evaluate_stream as side effect is not\n-    // GC-safe, so we disable GC for this task.\n-    prevent_gc();\n+pub async fn custom_evaluate(evaluate_context: impl EvaluateContext) -> Result<Vc<Option<RcStr>>> {\n+    let pool_op = evaluate_context.pool();\n+    let mut state = Default::default();\n+\n+    // Read this strongly consistent, since we don't want to run inconsistent\n+    // node.js code.\n+    let pool = pool_op.read_strongly_consistent().await?;\n+\n+    let args = evaluate_context.args().iter().try_join().await?;\n+    // Assume this is a one-off operation, so we can kill the process\n+    // TODO use a better way to decide that.\n+    let kill = !evaluate_context.keep_alive();\n+\n+    // Workers in the pool could be in a bad state that we didn't detect yet.\n+    // The bad state might even be unnoticeable until we actually send the job to the\n+    // worker. So we retry picking workers from the pools until we succeed\n+    // sending the job.\n+\n+    let (mut operation, _) = FutureRetry::new(\n+        || async {\n+            let mut operation = pool.operation().await?;\n+            operation\n+                .send(EvalJavaScriptOutgoingMessage::Evaluate {\n+                    args: args.iter().map(|v| &**v).collect(),\n+                })\n+                .await?;\n+            Ok(operation)\n+        },\n+        PoolErrorHandler,\n+    )\n+    .await\n+    .map_err(|(e, _)| e)?;\n \n-    // Note the following code uses some hacks to create a child task that produces\n-    // a stream that is returned by this task.\n+    // The evaluation sent an initial intermediate value without completing. We'll\n+    // need to spawn a new thread to continually pull data out of the process,\n+    // and ferry that along.\n+    let result = pull_operation(&mut operation, &pool, &evaluate_context, &mut state).await?;\n \n-    // We create a new cell in this task, which will be updated from the\n-    // [compute_evaluate_stream] task.\n-    let cell = turbo_tasks::macro_helpers::find_cell_by_type(\n-        <JavaScriptEvaluation as VcValueType>::get_value_type_id(),\n-    );\n+    evaluate_context.finish(state, &pool).await?;\n \n-    // We initialize the cell with a stream that is open, but has no values.\n-    // The first [compute_evaluate_stream] pipe call will pick up that stream.\n-    let (sender, receiver) = unbounded();\n-    cell.update(\n-        JavaScriptEvaluation(JavaScriptStream::new_open(vec![], Box::new(receiver))),\n-        VerificationMode::Skip,\n-    );\n-    let initial = Mutex::new(Some(sender));\n-\n-    // run the evaluation as side effect\n-    evaluate_context\n-        .compute(\n-            JavaScriptStreamSender {\n-                get: Box::new(move || {\n-                    if let Some(sender) = initial.lock().take() {\n-                        sender\n-                    } else {\n-                        // In cases when only [compute_evaluate_stream] is (re)executed, we need to\n-                        // update the old stream with a new value.\n-                        let (sender, receiver) = unbounded();\n-                        cell.update(\n-                            JavaScriptEvaluation(JavaScriptStream::new_open(\n-                                vec![],\n-                                Box::new(receiver),\n-                            )),\n-                            VerificationMode::Skip,\n-                        );\n-                        sender\n-                    }\n-                }),\n-            }\n-            .cell(),\n-        )\n-        .await?;\n+    if kill {\n+        operation.wait_or_kill().await?;\n+    }\n \n-    let raw: RawVc = cell.into();\n-    Ok(raw.into())\n+    Ok(Vc::cell(result.map(RcStr::from)))\n }\n \n /// Pass the file you cared as `runtime_entries` to invalidate and reload the\n@@ -451,7 +415,7 @@ pub async fn evaluate(\n     args: Vec<ResolvedVc<JsonValue>>,\n     additional_invalidation: ResolvedVc<Completion>,\n     debug: bool,\n-) -> Result<Vc<JavaScriptEvaluation>> {\n+) -> Result<Vc<Option<RcStr>>> {\n     custom_evaluate(BasicEvaluateContext {\n         module_asset,\n         cwd,\n@@ -467,115 +431,26 @@ pub async fn evaluate(\n     .await\n }\n \n-pub async fn compute(\n-    evaluate_context: impl EvaluateContext,\n-    sender: Vc<JavaScriptStreamSender>,\n-) -> Result<Vc<()>> {\n-    mark_finished();\n-    let Ok(sender) = sender.await else {\n-        // Impossible to handle the error in a good way.\n-        return Ok(Default::default());\n-    };\n-\n-    let stream = generator! {\n-        let pool_op = evaluate_context.pool();\n-        let mut state = Default::default();\n-\n-        // Read this strongly consistent, since we don't want to run inconsistent\n-        // node.js code.\n-        let pool = pool_op.read_strongly_consistent().await?;\n-\n-        let args = evaluate_context.args().iter().try_join().await?;\n-        // Assume this is a one-off operation, so we can kill the process\n-        // TODO use a better way to decide that.\n-        let kill = !evaluate_context.keep_alive();\n-\n-        // Workers in the pool could be in a bad state that we didn't detect yet.\n-        // The bad state might even be unnoticeable until we actually send the job to the\n-        // worker. So we retry picking workers from the pools until we succeed\n-        // sending the job.\n-\n-        let (mut operation, _) = FutureRetry::new(\n-            || async {\n-                let mut operation = pool.operation().await?;\n-                operation\n-                    .send(EvalJavaScriptOutgoingMessage::Evaluate {\n-                        args: args.iter().map(|v| &**v).collect(),\n-                    })\n-                    .await?;\n-                Ok(operation)\n-            },\n-            PoolErrorHandler,\n-        )\n-        .await\n-        .map_err(|(e, _)| e)?;\n-\n-        // The evaluation sent an initial intermediate value without completing. We'll\n-        // need to spawn a new thread to continually pull data out of the process,\n-        // and ferry that along.\n-        loop {\n-            let output = pull_operation(&mut operation, &pool, &evaluate_context, &mut state).await?;\n-\n-            match output {\n-                LoopResult::Continue(data) => {\n-                    yield data.into();\n-                }\n-                LoopResult::Break(Ok(Some(data))) => {\n-                    yield data.into();\n-                    break;\n-                }\n-                LoopResult::Break(Err(e)) => {\n-                    let error = print_error(e, &pool, &evaluate_context).await?;\n-                    Err(anyhow!(\"Node.js evaluation failed: {}\", error))?;\n-                    break;\n-                }\n-                LoopResult::Break(Ok(None)) => {\n-                    break;\n-                }\n-            }\n-        }\n-\n-        evaluate_context.finish(state, &pool).await?;\n-\n-        if kill {\n-            operation.wait_or_kill().await?;\n-        }\n-    };\n-\n-    let mut sender = (sender.get)();\n-    pin_mut!(stream);\n-    while let Some(value) = stream.next().await {\n-        if sender.send(value).await.is_err() {\n-            return Ok(Default::default());\n-        }\n-        if sender.flush().await.is_err() {\n-            return Ok(Default::default());\n-        }\n-    }\n-\n-    Ok(Default::default())\n-}\n-\n /// Repeatedly pulls from the NodeJsOperation until we receive a\n /// value/error/end.\n async fn pull_operation<T: EvaluateContext>(\n     operation: &mut NodeJsOperation,\n     pool: &NodeJsPool,\n     evaluate_context: &T,\n     state: &mut T::State,\n-) -> Result<LoopResult> {\n-    let guard = duration_span!(\"Node.js evaluation\");\n+) -> Result<Option<String>> {\n+    let _guard = duration_span!(\"Node.js evaluation\");\n \n-    let output = loop {\n+    loop {\n         match operation.recv().await? {\n             EvalJavaScriptIncomingMessage::Error(error) => {\n                 evaluate_context.emit_error(error, pool).await?;\n                 // Do not reuse the process in case of error\n                 operation.disallow_reuse();\n                 // Issue emitted, we want to break but don't want to return an error\n-                break ControlFlow::Break(Ok(None));\n+                return Ok(None);\n             }\n-            EvalJavaScriptIncomingMessage::End { data } => break ControlFlow::Break(Ok(data)),\n+            EvalJavaScriptIncomingMessage::End { data } => return Ok(data),\n             EvalJavaScriptIncomingMessage::Info { data } => {\n                 evaluate_context\n                     .info(state, serde_json::from_value(data)?, pool)\n@@ -607,18 +482,7 @@ async fn pull_operation<T: EvaluateContext>(\n                 }\n             }\n         }\n-    };\n-    drop(guard);\n-\n-    Ok(output)\n-}\n-\n-#[turbo_tasks::function]\n-async fn basic_compute(\n-    evaluate_context: BasicEvaluateContext,\n-    sender: Vc<JavaScriptStreamSender>,\n-) -> Result<Vc<()>> {\n-    compute(evaluate_context, sender).await\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, TaskInput, Debug, Serialize, Deserialize, TraceRawVcs)]\n@@ -641,10 +505,6 @@ impl EvaluateContext for BasicEvaluateContext {\n     type ResponseMessage = ();\n     type State = ();\n \n-    async fn compute(self, sender: Vc<JavaScriptStreamSender>) -> Result<()> {\n-        basic_compute(self, sender).as_side_effect().await\n-    }\n-\n     fn pool(&self) -> OperationVc<crate::pool::NodeJsPool> {\n         get_evaluate_pool(\n             self.module_asset,\n@@ -715,20 +575,6 @@ pub fn scale_down() {\n     NodeJsPool::scale_down();\n }\n \n-async fn print_error(\n-    error: StructuredError,\n-    pool: &NodeJsPool,\n-    evaluate_context: &impl EvaluateContext,\n-) -> Result<String> {\n-    error\n-        .print(\n-            *pool.assets_for_source_mapping,\n-            pool.assets_root.clone(),\n-            evaluate_context.cwd().owned().await?,\n-            FormattingMode::Plain,\n-        )\n-        .await\n-}\n /// An issue that occurred while evaluating node code.\n #[turbo_tasks::value(shared)]\n pub struct EvaluationIssue {"
        },
        {
            "sha": "f746b100cf2912718c071a749424e058452dd2cb",
            "filename": "turbopack/crates/turbopack-node/src/transforms/postcss.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/db5528317e24e0316e0497716976a715a325ca09/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fpostcss.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/db5528317e24e0316e0497716976a715a325ca09/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fpostcss.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fpostcss.rs?ref=db5528317e24e0316e0497716976a715a325ca09",
            "patch": "@@ -6,7 +6,6 @@ use turbo_tasks::{\n     Completion, Completions, NonLocalValue, ResolvedVc, TaskInput, TryFlatJoinIterExt, Vc,\n     fxindexmap, trace::TraceRawVcs,\n };\n-use turbo_tasks_bytes::stream::SingleValue;\n use turbo_tasks_fs::{\n     File, FileContent, FileSystemEntryType, FileSystemPath, json::parse_json_with_source_context,\n };\n@@ -519,15 +518,15 @@ impl PostCssTransformedAsset {\n         })\n         .await?;\n \n-        let SingleValue::Single(val) = config_value.try_into_single().await? else {\n+        let Some(val) = &*config_value else {\n             // An error happened, which has already been converted into an issue.\n             return Ok(ProcessPostCssResult {\n                 content: AssetContent::File(FileContent::NotFound.resolved_cell()).resolved_cell(),\n                 assets: Vec::new(),\n             }\n             .cell());\n         };\n-        let processed_css: PostCssProcessingResult = parse_json_with_source_context(val.to_str()?)\n+        let processed_css: PostCssProcessingResult = parse_json_with_source_context(val)\n             .context(\"Unable to deserializate response from PostCSS transform operation\")?;\n \n         // TODO handle SourceMap"
        },
        {
            "sha": "d8a02b68e17d5e8bf7dd2e87bfa29cadc38c8660",
            "filename": "turbopack/crates/turbopack-node/src/transforms/webpack.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 23,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/db5528317e24e0316e0497716976a715a325ca09/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/db5528317e24e0316e0497716976a715a325ca09/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs?ref=db5528317e24e0316e0497716976a715a325ca09",
            "patch": "@@ -12,7 +12,6 @@ use turbo_tasks::{\n     Completion, NonLocalValue, OperationValue, OperationVc, ResolvedVc, TaskInput, TryJoinIterExt,\n     ValueToString, Vc, trace::TraceRawVcs,\n };\n-use turbo_tasks_bytes::stream::SingleValue;\n use turbo_tasks_env::ProcessEnv;\n use turbo_tasks_fs::{\n     File, FileContent, FileSystemPath,\n@@ -56,8 +55,7 @@ use crate::{\n     debug::should_debug,\n     embed_js::embed_file_path,\n     evaluate::{\n-        EnvVarTracking, EvaluateContext, EvaluationIssue, JavaScriptEvaluation,\n-        JavaScriptStreamSender, compute, custom_evaluate, get_evaluate_pool,\n+        EnvVarTracking, EvaluateContext, EvaluationIssue, custom_evaluate, get_evaluate_pool,\n     },\n     execution_context::ExecutionContext,\n     pool::{FormattingMode, NodeJsPool},\n@@ -275,7 +273,7 @@ impl WebpackLoadersProcessedAsset {\n         })\n         .await?;\n \n-        let SingleValue::Single(val) = config_value.try_into_single().await? else {\n+        let Some(val) = &*config_value else {\n             // An error happened, which has already been converted into an issue.\n             return Ok(ProcessWebpackLoadersResult {\n                 content: AssetContent::File(FileContent::NotFound.resolved_cell()).resolved_cell(),\n@@ -284,10 +282,8 @@ impl WebpackLoadersProcessedAsset {\n             }\n             .cell());\n         };\n-        let processed: WebpackLoadersProcessingResult = parse_json_with_source_context(\n-            val.to_str()?,\n-        )\n-        .context(\"Unable to deserializate response from webpack loaders transform operation\")?;\n+        let processed: WebpackLoadersProcessingResult = parse_json_with_source_context(val)\n+            .context(\"Unable to deserializate response from webpack loaders transform operation\")?;\n \n         // handle SourceMap\n         let source_map = if !transform.source_maps {\n@@ -319,18 +315,10 @@ impl WebpackLoadersProcessedAsset {\n #[turbo_tasks::function]\n pub(crate) async fn evaluate_webpack_loader(\n     webpack_loader_context: WebpackLoaderContext,\n-) -> Result<Vc<JavaScriptEvaluation>> {\n+) -> Result<Vc<Option<RcStr>>> {\n     custom_evaluate(webpack_loader_context).await\n }\n \n-#[turbo_tasks::function]\n-async fn compute_webpack_loader_evaluation(\n-    webpack_loader_context: WebpackLoaderContext,\n-    sender: Vc<JavaScriptStreamSender>,\n-) -> Result<Vc<()>> {\n-    compute(webpack_loader_context, sender).await\n-}\n-\n #[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]\n #[serde(rename_all = \"camelCase\")]\n enum LogType {\n@@ -439,12 +427,6 @@ impl EvaluateContext for WebpackLoaderContext {\n     type ResponseMessage = ResponseMessage;\n     type State = Vec<LogInfo>;\n \n-    async fn compute(self, sender: Vc<JavaScriptStreamSender>) -> Result<()> {\n-        compute_webpack_loader_evaluation(self, sender)\n-            .as_side_effect()\n-            .await\n-    }\n-\n     fn pool(&self) -> OperationVc<crate::pool::NodeJsPool> {\n         get_evaluate_pool(\n             self.module_asset,"
        },
        {
            "sha": "a52a89391476db182533be041487b2fd18bf045f",
            "filename": "turbopack/crates/turbopack-tests/tests/execution.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 8,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/db5528317e24e0316e0497716976a715a325ca09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/db5528317e24e0316e0497716976a715a325ca09/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs?ref=db5528317e24e0316e0497716976a715a325ca09",
            "patch": "@@ -17,7 +17,6 @@ use turbo_tasks::{\n     debug::ValueDebugFormat, fxindexmap, trace::TraceRawVcs,\n };\n use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n-use turbo_tasks_bytes::stream::SingleValue;\n use turbo_tasks_env::CommandLineProcessEnv;\n use turbo_tasks_fs::{\n     DiskFileSystem, FileContent, FileSystem, FileSystemEntryType, FileSystemPath,\n@@ -528,12 +527,7 @@ async fn run_test_operation(prepared_test: ResolvedVc<PreparedTest>) -> Result<V\n     )\n     .await?;\n \n-    let single = res\n-        .try_into_single()\n-        .await\n-        .context(\"test node result did not emit anything\")?;\n-\n-    let SingleValue::Single(bytes) = single else {\n+    let Some(str) = &*res else {\n         return Ok(RunTestResult {\n             js_result: JsResult {\n                 uncaught_exceptions: vec![],\n@@ -549,7 +543,7 @@ async fn run_test_operation(prepared_test: ResolvedVc<PreparedTest>) -> Result<V\n     };\n \n     Ok(RunTestResult {\n-        js_result: JsResult::resolved_cell(parse_json_with_source_context(bytes.to_str()?)?),\n+        js_result: JsResult::resolved_cell(parse_json_with_source_context(str)?),\n         path: path.clone(),\n     }\n     .cell())"
        }
    ],
    "stats": {
        "total": 320,
        "additions": 67,
        "deletions": 253
    }
}