{
    "author": "sokra",
    "message": "Turbopack: improve debugging features (#81415)\n\n### What?\n\n* add no_fast_stale feature\n* nicer hanging messages\n* print details on strongly consistent hanging (prints which tasks are\nnot completing and the chain to them)",
    "sha": "17a1fd8f4caa56e31ed4541068f19ea4963f3036",
    "files": [
        {
            "sha": "eb3ee57b720930f1044f3fb22e204c1bcb5eae85",
            "filename": "turbopack/crates/turbo-tasks-backend/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/17a1fd8f4caa56e31ed4541068f19ea4963f3036/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/17a1fd8f4caa56e31ed4541068f19ea4963f3036/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml?ref=17a1fd8f4caa56e31ed4541068f19ea4963f3036",
            "patch": "@@ -15,6 +15,7 @@ workspace = true\n [features]\n default = []\n print_cache_item_size = []\n+no_fast_stale = []\n verify_serialization = []\n verify_aggregation_graph = []\n verify_immutable = []"
        },
        {
            "sha": "addfc48bdca8f304113855922b0e3d6f2f5b69a6",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 119,
            "deletions": 7,
            "changes": 126,
            "blob_url": "https://github.com/vercel/next.js/blob/17a1fd8f4caa56e31ed4541068f19ea4963f3036/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/17a1fd8f4caa56e31ed4541068f19ea4963f3036/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=17a1fd8f4caa56e31ed4541068f19ea4963f3036",
            "patch": "@@ -50,7 +50,7 @@ use crate::{\n             AggregatedDataUpdate, AggregationUpdateJob, AggregationUpdateQueue,\n             CleanupOldEdgesOperation, ConnectChildOperation, ExecuteContext, ExecuteContextImpl,\n             Operation, OutdatedEdge, TaskGuard, connect_children, get_aggregation_number,\n-            is_root_node, prepare_new_children,\n+            get_uppers, is_root_node, prepare_new_children,\n         },\n         storage::{\n             InnerStorageSnapshot, Storage, count, get, get_many, get_mut, get_mut_or_insert_with,\n@@ -435,7 +435,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n     }\n \n     fn try_read_task_output(\n-        &self,\n+        self: &Arc<Self>,\n         task_id: TaskId,\n         reader: Option<TaskId>,\n         consistency: ReadConsistency,\n@@ -560,7 +560,111 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     get!(task, Activeness).unwrap()\n                 };\n                 let listener = activeness.all_clean_event.listen_with_note(move || {\n-                    move || format!(\"try_read_task_output (strongly consistent) from {reader:?}\")\n+                    let this = self.clone();\n+                    let tt = turbo_tasks.pin();\n+                    move || {\n+                        let tt: &dyn TurboTasksBackendApi<TurboTasksBackend<B>> = &*tt;\n+                        let mut ctx = this.execute_context(tt);\n+                        let mut visited = FxHashSet::default();\n+                        fn indent(s: &str) -> String {\n+                            s.split_inclusive('\\n')\n+                                .flat_map(|line: &str| [\"  \", line].into_iter())\n+                                .collect::<String>()\n+                        }\n+                        fn get_info(\n+                            ctx: &mut impl ExecuteContext<'_>,\n+                            task_id: TaskId,\n+                            parent_and_count: Option<(TaskId, i32)>,\n+                            visited: &mut FxHashSet<TaskId>,\n+                        ) -> String {\n+                            let task = ctx.task(task_id, TaskDataCategory::Data);\n+                            let is_dirty = get!(task, Dirty)\n+                                .map_or(false, |dirty_state| dirty_state.get(ctx.session_id()));\n+                            let in_progress =\n+                                get!(task, InProgress).map_or(\"not in progress\", |p| match p {\n+                                    InProgressState::InProgress(_) => \"in progress\",\n+                                    InProgressState::Scheduled { .. } => \"scheduled\",\n+                                    InProgressState::Canceled => \"canceled\",\n+                                });\n+                            let activeness = get!(task, Activeness).map_or_else(\n+                                || \"not active\".to_string(),\n+                                |activeness| format!(\"{activeness:?}\"),\n+                            );\n+                            let aggregation_number = get_aggregation_number(&task);\n+                            let missing_upper = if let Some((parent_task_id, _)) = parent_and_count\n+                            {\n+                                let uppers = get_uppers(&task);\n+                                !uppers.contains(&parent_task_id)\n+                            } else {\n+                                false\n+                            };\n+\n+                            // Check the dirty count of the root node\n+                            let dirty_tasks = get!(task, AggregatedDirtyContainerCount)\n+                                .cloned()\n+                                .unwrap_or_default()\n+                                .get(ctx.session_id());\n+\n+                            let task_description = ctx.get_task_description(task_id);\n+                            let is_dirty = if is_dirty { \", dirty\" } else { \"\" };\n+                            let count = if let Some((_, count)) = parent_and_count {\n+                                format!(\" {count}\")\n+                            } else {\n+                                String::new()\n+                            };\n+                            let mut info = format!(\n+                                \"{task_id} {task_description}{count} (aggr={aggregation_number}, \\\n+                                 {in_progress}, {activeness}{is_dirty})\",\n+                            );\n+                            let children: Vec<_> = iter_many!(\n+                                task,\n+                                AggregatedDirtyContainer {\n+                                    task\n+                                } count => {\n+                                    (task, count.get(ctx.session_id()))\n+                                }\n+                            )\n+                            .filter(|(_, count)| *count > 0)\n+                            .collect();\n+                            drop(task);\n+\n+                            if missing_upper {\n+                                info.push_str(\"\\n  ERROR: missing upper connection\");\n+                            }\n+\n+                            if dirty_tasks > 0 || !children.is_empty() {\n+                                writeln!(info, \"\\n  {dirty_tasks} dirty tasks:\").unwrap();\n+\n+                                for (child_task_id, count) in children {\n+                                    let task_description = ctx.get_task_description(child_task_id);\n+                                    if visited.insert(child_task_id) {\n+                                        let child_info = get_info(\n+                                            ctx,\n+                                            child_task_id,\n+                                            Some((task_id, count)),\n+                                            visited,\n+                                        );\n+                                        info.push_str(&indent(&child_info));\n+                                        if !info.ends_with('\\n') {\n+                                            info.push('\\n');\n+                                        }\n+                                    } else {\n+                                        writeln!(\n+                                            info,\n+                                            \"  {child_task_id} {task_description} {count} \\\n+                                             (already visited)\"\n+                                        )\n+                                        .unwrap();\n+                                    }\n+                                }\n+                            }\n+                            info\n+                        }\n+                        let info = get_info(&mut ctx, task_id, None, &mut visited);\n+                        format!(\n+                            \"try_read_task_output (strongly consistent) from {reader:?}\\n{info}\"\n+                        )\n+                    }\n                 });\n                 drop(task);\n                 if !task_ids_to_schedule.is_empty() {\n@@ -1617,6 +1721,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         };\n \n         // If the task is stale, reschedule it\n+        #[cfg(not(feature = \"no_fast_stale\"))]\n         if stale {\n             let Some(InProgressState::InProgress(box InProgressStateInner {\n                 done_event,\n@@ -1650,9 +1755,11 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             return true;\n         }\n \n-        // mark the task as completed, so dependent tasks can continue working\n-        *done = true;\n-        done_event.notify(usize::MAX);\n+        if cfg!(not(feature = \"no_fast_stale\")) || !stale {\n+            // mark the task as completed, so dependent tasks can continue working\n+            *done = true;\n+            done_event.notify(usize::MAX);\n+        }\n \n         // take the children from the task to process them\n         let mut new_children = take(new_children);\n@@ -1815,12 +1922,17 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         let Some(in_progress) = get!(task, InProgress) else {\n             panic!(\"Task execution completed, but task is not in progress: {task:#?}\");\n         };\n-        let InProgressState::InProgress(box InProgressStateInner { stale, .. }) = in_progress\n+        let InProgressState::InProgress(box InProgressStateInner {\n+            #[cfg(not(feature = \"no_fast_stale\"))]\n+            stale,\n+            ..\n+        }) = in_progress\n         else {\n             panic!(\"Task execution completed, but task is not in progress: {task:#?}\");\n         };\n \n         // If the task is stale, reschedule it\n+        #[cfg(not(feature = \"no_fast_stale\"))]\n         if *stale {\n             let Some(InProgressState::InProgress(box InProgressStateInner { done_event, .. })) =\n                 remove!(task, InProgress)"
        },
        {
            "sha": "cc42fc2b1f98ed17db2bec89f83e965dc22fce5d",
            "filename": "turbopack/crates/turbo-tasks/src/event.rs",
            "status": "modified",
            "additions": 20,
            "deletions": 10,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/17a1fd8f4caa56e31ed4541068f19ea4963f3036/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fevent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/17a1fd8f4caa56e31ed4541068f19ea4963f3036/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fevent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fevent.rs?ref=17a1fd8f4caa56e31ed4541068f19ea4963f3036",
            "patch": "@@ -61,10 +61,10 @@ impl Event {\n             description: self.description.clone(),\n             note: Arc::new(String::new),\n             future: Some(Box::pin(timeout(\n-                Duration::from_secs(10),\n+                Duration::from_secs(30),\n                 self.event.listen(),\n             ))),\n-            duration: Duration::from_secs(10),\n+            duration: Duration::from_secs(30),\n         };\n     }\n \n@@ -93,10 +93,10 @@ impl Event {\n             description: self.description.clone(),\n             note: Arc::new((_note)()),\n             future: Some(Box::pin(timeout(\n-                Duration::from_secs(10),\n+                Duration::from_secs(30),\n                 self.event.listen(),\n             ))),\n-            duration: Duration::from_secs(10),\n+            duration: Duration::from_secs(30),\n         };\n     }\n \n@@ -193,12 +193,22 @@ impl Future for EventListener {\n                     return Poll::Ready(());\n                 }\n                 Err(_) => {\n-                    use crate::util::FormatDuration;\n-                    eprintln!(\n-                        \"{:?} is potentially hanging (waiting for {})\",\n-                        self,\n-                        FormatDuration(self.duration)\n-                    );\n+                    let note = (self.note)();\n+                    let description = (self.description)();\n+                    if note.is_empty() {\n+                        eprintln!(\n+                            \"EventListener({}) is potentially hanging, waiting for {}s\",\n+                            description,\n+                            self.duration.as_secs(),\n+                        );\n+                    } else {\n+                        eprintln!(\n+                            \"EventListener({}) is potentially hanging, waiting for {}s from {}\",\n+                            description,\n+                            self.duration.as_secs(),\n+                            note\n+                        );\n+                    }\n                     self.duration *= 2;\n                     // SAFETY: Taking from Option is safe because the value is inside of a pinned\n                     // Box. Pinning must continue until dropped."
        }
    ],
    "stats": {
        "total": 157,
        "additions": 140,
        "deletions": 17
    }
}