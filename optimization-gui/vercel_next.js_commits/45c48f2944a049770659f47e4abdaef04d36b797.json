{
    "author": "sokra",
    "message": "Turbopack: improve fuzz testing to handle more cases (#81204)\n\n### What?\n\n* Improve fuzz testing to test tasks becoming active and inactive.\n* Improve the verify_aggregation_graph feature to panic to allow running\nit during fuzz testing",
    "sha": "45c48f2944a049770659f47e4abdaef04d36b797",
    "files": [
        {
            "sha": "681b875eb2766ae00e323fca56cc059d67f429ee",
            "filename": "turbopack/crates/turbo-tasks-backend/fuzz/src/graph.rs",
            "status": "modified",
            "additions": 128,
            "deletions": 30,
            "changes": 158,
            "blob_url": "https://github.com/vercel/next.js/blob/45c48f2944a049770659f47e4abdaef04d36b797/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ffuzz%2Fsrc%2Fgraph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/45c48f2944a049770659f47e4abdaef04d36b797/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ffuzz%2Fsrc%2Fgraph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ffuzz%2Fsrc%2Fgraph.rs?ref=45c48f2944a049770659f47e4abdaef04d36b797",
            "patch": "@@ -1,12 +1,24 @@\n+use std::sync::Arc;\n+\n use anyhow::Result;\n use arbitrary::Arbitrary;\n use once_cell::sync::Lazy;\n use serde::{Deserialize, Serialize};\n-use turbo_tasks::{self, NonLocalValue, TurboTasks, Vc, trace::TraceRawVcs};\n+use turbo_tasks::{self, NonLocalValue, State, TaskInput, TurboTasks, Vc, trace::TraceRawVcs};\n use turbo_tasks_malloc::TurboMalloc;\n \n #[derive(\n-    Arbitrary, Clone, Debug, PartialEq, Eq, NonLocalValue, Serialize, Deserialize, TraceRawVcs,\n+    Arbitrary,\n+    Clone,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    NonLocalValue,\n+    Serialize,\n+    Deserialize,\n+    TraceRawVcs,\n+    TaskInput,\n )]\n pub struct TaskReferenceSpec {\n     task: u16,\n@@ -16,11 +28,57 @@ pub struct TaskReferenceSpec {\n }\n \n #[derive(\n-    Arbitrary, Clone, Debug, PartialEq, Eq, NonLocalValue, Serialize, Deserialize, TraceRawVcs,\n+    Arbitrary,\n+    Clone,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Hash,\n+    NonLocalValue,\n+    Serialize,\n+    Deserialize,\n+    TraceRawVcs,\n+    TaskInput,\n )]\n pub struct TaskSpec {\n     references: Vec<TaskReferenceSpec>,\n     children: u8,\n+    change: Option<Box<TaskSpec>>,\n+}\n+\n+impl TaskSpec {\n+    fn iter(&self) -> impl Iterator<Item = &TaskSpec> {\n+        Iter::new(self)\n+    }\n+}\n+\n+struct Iter<'a> {\n+    current: Option<&'a TaskSpec>,\n+}\n+\n+impl<'a> Iter<'a> {\n+    fn new(task: &'a TaskSpec) -> Self {\n+        Self {\n+            current: Some(task),\n+        }\n+    }\n+}\n+\n+impl<'a> Iterator for Iter<'a> {\n+    type Item = &'a TaskSpec;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(current) = self.current {\n+            if let Some(change) = &current.change {\n+                self.current = Some(change);\n+            } else {\n+                self.current = None;\n+            }\n+            Some(current)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n static RUNTIME: Lazy<tokio::runtime::Runtime> = Lazy::new(|| {\n@@ -38,21 +96,26 @@ pub fn init() {\n }\n \n pub fn run(data: Vec<TaskSpec>) {\n-    let mut data = data;\n     let len = data.len();\n     if len == 0 {\n         return;\n     }\n-    for (i, task) in data.iter_mut().enumerate() {\n-        for reference in task.references.iter_mut() {\n-            let task = reference.task as usize;\n-            if task <= i {\n-                return;\n-            }\n-            if task >= len {\n-                return;\n+    let mut max_count = 1;\n+    for (i, task) in data.iter().enumerate() {\n+        let mut count = 0;\n+        for task in task.iter() {\n+            count += 1;\n+            for reference in task.references.iter() {\n+                let task = reference.task as usize;\n+                if task <= i {\n+                    return;\n+                }\n+                if task >= len {\n+                    return;\n+                }\n             }\n         }\n+        max_count = max_count.max(count);\n     }\n     let mut referenced = vec![false; data.len()];\n     for task in &data {\n@@ -63,10 +126,13 @@ pub fn run(data: Vec<TaskSpec>) {\n     if !referenced.iter().skip(1).all(|&x| x) {\n         return;\n     }\n-    actual_operation(data);\n+    actual_operation(Arc::new(data), max_count);\n }\n \n-fn actual_operation(data: Vec<TaskSpec>) {\n+#[turbo_tasks::value(transparent)]\n+struct Iteration(State<usize>);\n+\n+fn actual_operation(spec: Arc<Vec<TaskSpec>>, iterations: usize) {\n     let tt = TurboTasks::new(turbo_tasks_backend::TurboTasksBackend::new(\n         turbo_tasks_backend::BackendOptions {\n             storage_mode: None,\n@@ -77,47 +143,79 @@ fn actual_operation(data: Vec<TaskSpec>) {\n     ));\n     RUNTIME\n         .block_on(async {\n-            tt.run_once(async move {\n-                let spec: Vc<TasksSpec> = Vc::cell(data);\n-                run_task(spec, 0).strongly_consistent().await?;\n-                Ok(())\n-            })\n-            .await\n+            for i in 0..iterations {\n+                let spec = spec.clone();\n+                tt.run_once(async move {\n+                    let it = create_state().resolve().await?;\n+                    it.await?.set(i);\n+                    let task = run_task(spec.clone(), it, 0);\n+                    task.strongly_consistent().await?;\n+                    Ok(())\n+                })\n+                .await?;\n+            }\n+            tt.stop_and_wait().await;\n+            drop(tt);\n+            anyhow::Ok(())\n         })\n         .unwrap();\n }\n \n-#[turbo_tasks::value(transparent)]\n-struct TasksSpec(Vec<TaskSpec>);\n+#[turbo_tasks::function]\n+fn create_state() -> Vc<Iteration> {\n+    Vc::cell(State::new(0))\n+}\n \n #[turbo_tasks::function]\n async fn run_task_chain(\n-    spec: Vc<TasksSpec>,\n+    spec: Arc<Vec<TaskSpec>>,\n+    iteration: Vc<Iteration>,\n     from: u16,\n     ref_index: usize,\n     to: u16,\n     chain: u8,\n ) -> Result<Vc<()>> {\n     if chain > 0 {\n-        run_task_chain(spec, from, ref_index, to, chain - 1).await?;\n+        run_task_chain(spec, iteration, from, ref_index, to, chain - 1).await?;\n     } else {\n-        run_task(spec, to).await?;\n+        run_task(spec, iteration, to).await?;\n     }\n     Ok(Vc::cell(()))\n }\n \n #[turbo_tasks::function]\n-async fn run_task(spec: Vc<TasksSpec>, task_index: u16) -> Result<Vc<()>> {\n-    let spec_ref = spec.await?;\n-    let task = &spec_ref[task_index as usize];\n+async fn run_task(\n+    spec: Arc<Vec<TaskSpec>>,\n+    iteration: Vc<Iteration>,\n+    task_index: u16,\n+) -> Result<Vc<()>> {\n+    let mut task = &spec[task_index as usize];\n+    if task.change.is_some() {\n+        let iteration = iteration.await?;\n+        let it = *iteration.get();\n+        for _ in 0..it {\n+            task = if let Some(change) = &task.change {\n+                change\n+            } else {\n+                task\n+            };\n+        }\n+    }\n     for i in 0..task.children {\n         run_task_child(task_index, i).await?;\n     }\n     for (i, reference) in task.references.iter().enumerate() {\n         let call = if reference.chain > 0 {\n-            run_task_chain(spec, task_index, i, reference.task, reference.chain)\n+            run_task_chain(\n+                spec.clone(),\n+                iteration,\n+                task_index,\n+                i,\n+                reference.task,\n+                reference.chain,\n+            )\n         } else {\n-            run_task(spec, reference.task)\n+            run_task(spec.clone(), iteration, reference.task)\n         };\n         if reference.read {\n             call.await?;"
        },
        {
            "sha": "827ac9d37a8b535fa974208bbe37660f16dd8854",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 14,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/45c48f2944a049770659f47e4abdaef04d36b797/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/45c48f2944a049770659f47e4abdaef04d36b797/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=45c48f2944a049770659f47e4abdaef04d36b797",
            "patch": "@@ -2418,10 +2418,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         let mut ctx = self.execute_context(turbo_tasks);\n         let root_tasks = self.root_tasks.lock().clone();\n-        let len = root_tasks.len();\n \n-        for (i, task_id) in root_tasks.into_iter().enumerate() {\n-            println!(\"Verifying graph from root {task_id} {i}/{len}...\");\n+        for task_id in root_tasks.into_iter() {\n             let mut queue = VecDeque::new();\n             let mut visited = FxHashSet::default();\n             let mut aggregated_nodes = FxHashSet::default();\n@@ -2450,7 +2448,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 if task_id != root_task_id\n                     && !uppers.iter().any(|upper| aggregated_nodes.contains(upper))\n                 {\n-                    println!(\n+                    panic!(\n                         \"Task {} {} doesn't report to any root but is reachable from one (uppers: \\\n                          {:?})\",\n                         task_id,\n@@ -2473,7 +2471,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     if let Some((flag, _)) = collectibles.get_mut(&collectible) {\n                         *flag = true\n                     } else {\n-                        println!(\n+                        panic!(\n                             \"Task {} has a collectible {:?} that is not in any upper task\",\n                             task_id, collectible\n                         );\n@@ -2509,9 +2507,13 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                         let in_upper = get!(task, AggregatedDirtyContainer { task: task_id })\n                             .is_some_and(|dirty| dirty.get(self.session_id) > 0);\n                         if !in_upper {\n-                            println!(\n-                                \"Task {} is dirty, but is not listed in the upper task {}\",\n-                                task_id, upper_id\n+                            panic!(\n+                                \"Task {} ({}) is dirty, but is not listed in the upper task {} \\\n+                                 ({})\",\n+                                task_id,\n+                                ctx.get_task_description(task_id),\n+                                upper_id,\n+                                ctx.get_task_description(upper_id)\n                             );\n                         }\n                     }\n@@ -2531,7 +2533,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                             .iter()\n                             .map(|t| format!(\"{t} {}\", ctx.get_task_description(*t)))\n                             .collect::<Vec<_>>()\n-                    );\n+                    )\n+                    .unwrap();\n \n                     let task_id = collectible.cell.task;\n                     let mut queue = {\n@@ -2541,7 +2544,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     let mut visited = FxHashSet::default();\n                     for &upper_id in queue.iter() {\n                         visited.insert(upper_id);\n-                        writeln!(stdout, \"{task_id:?} -> {upper_id:?}\");\n+                        writeln!(stdout, \"{task_id:?} -> {upper_id:?}\").unwrap();\n                     }\n                     while let Some(task_id) = queue.pop() {\n                         let desc = ctx.get_task_description(task_id);\n@@ -2555,24 +2558,26 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                         writeln!(\n                             stdout,\n                             \"upper {task_id} {desc} collectible={aggregated_collectible}\"\n-                        );\n+                        )\n+                        .unwrap();\n                         if task_ids.contains(&task_id) {\n                             writeln!(\n                                 stdout,\n                                 \"Task has an upper connection to an aggregated task that doesn't \\\n                                  reference it. Upper connection is invalid!\"\n-                            );\n+                            )\n+                            .unwrap();\n                         }\n                         for upper_id in uppers {\n-                            writeln!(stdout, \"{task_id:?} -> {upper_id:?}\");\n+                            writeln!(stdout, \"{task_id:?} -> {upper_id:?}\").unwrap();\n                             if !visited.contains(&upper_id) {\n                                 queue.push(upper_id);\n                             }\n                         }\n                     }\n+                    panic!(\"See stdout for more details\");\n                 }\n             }\n-            println!(\"visited {task_id} {} tasks\", visited.len());\n         }\n     }\n "
        }
    ],
    "stats": {
        "total": 191,
        "additions": 147,
        "deletions": 44
    }
}