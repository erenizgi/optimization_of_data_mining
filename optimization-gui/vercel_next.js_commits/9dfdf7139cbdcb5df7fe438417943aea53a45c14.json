{
    "author": "mischnic",
    "message": "Turbopack: RawEcmascriptModule (#81806)\n\nAdd a JS module type that does no analysis, and just concatenates the source file into the output file.\r\nAs a consequence however, the input module cannot have\r\n- `import`s/`require`s/`new Worker`/...\r\n- ~~`process.env.*` that should be replaced~~\r\n- JSX/any new syntax, since the module won't be transpiled using the user's browserslist\r\n\r\n```\r\nbefore:\r\n\r\n ✓ Starting...\r\n ✓ Ready in 335ms\r\n ○ Compiling / ...\r\n ✓ Compiled / in 980ms\r\n GET / 200 in 1258ms\r\n\r\nafter:\r\n\r\n ✓ Starting...\r\n ✓ Ready in 406ms\r\n ✓ Compiled / in 406ms\r\n GET / 200 in 692ms\r\n```\r\n\r\n<img width=\"1358\" height=\"959\" alt=\"Bildschirmfoto 2025-09-16 um 12 09 47\" src=\"https://github.com/user-attachments/assets/87bb3161-8749-475b-9a84-bf62324735e4\" />\r\n\r\n<img width=\"1352\" height=\"939\" alt=\"Bildschirmfoto 2025-09-16 um 12 12 48\" src=\"https://github.com/user-attachments/assets/4a42e724-7090-4ca7-bad9-41e5cf1af80b\" />",
    "sha": "9dfdf7139cbdcb5df7fe438417943aea53a45c14",
    "files": [
        {
            "sha": "c09bfa8b5bb5dc44930840f87ece7b8d325fba75",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/9dfdf7139cbdcb5df7fe438417943aea53a45c14/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/9dfdf7139cbdcb5df7fe438417943aea53a45c14/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=9dfdf7139cbdcb5df7fe438417943aea53a45c14",
            "patch": "@@ -4291,6 +4291,7 @@ dependencies = [\n  \"serde_json\",\n  \"serde_path_to_error\",\n  \"swc_core\",\n+ \"swc_sourcemap\",\n  \"thiserror 1.0.69\",\n  \"tracing\",\n  \"turbo-esregex\","
        },
        {
            "sha": "90f77cbcd556fbfafaec0e99bd0cf1839e5c43a1",
            "filename": "crates/next-core/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/9dfdf7139cbdcb5df7fe438417943aea53a45c14/crates%2Fnext-core%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/9dfdf7139cbdcb5df7fe438417943aea53a45c14/crates%2Fnext-core%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2FCargo.toml?ref=9dfdf7139cbdcb5df7fe438417943aea53a45c14",
            "patch": "@@ -35,6 +35,7 @@ remove_console = { workspace = true }\n itertools = { workspace = true }\n percent-encoding = \"2.3.1\"\n serde_path_to_error = { workspace = true }\n+swc_sourcemap = { workspace = true }\n \n swc_core = { workspace = true, features = [\n   \"base\","
        },
        {
            "sha": "bcdaf709d9d22161ca07e14da69fbe804bc41413",
            "filename": "crates/next-core/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/9dfdf7139cbdcb5df7fe438417943aea53a45c14/crates%2Fnext-core%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9dfdf7139cbdcb5df7fe438417943aea53a45c14/crates%2Fnext-core%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Flib.rs?ref=9dfdf7139cbdcb5df7fe438417943aea53a45c14",
            "patch": "@@ -35,6 +35,7 @@ mod next_shared;\n pub mod next_telemetry;\n mod page_loader;\n pub mod pages_structure;\n+pub mod raw_ecmascript_module;\n pub mod segment_config;\n pub mod tracing_presets;\n mod transform_options;"
        },
        {
            "sha": "1f65778643fc659c74438fa219ecf07411074e89",
            "filename": "crates/next-core/src/next_client/transforms.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 1,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/9dfdf7139cbdcb5df7fe438417943aea53a45c14/crates%2Fnext-core%2Fsrc%2Fnext_client%2Ftransforms.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9dfdf7139cbdcb5df7fe438417943aea53a45c14/crates%2Fnext-core%2Fsrc%2Fnext_client%2Ftransforms.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client%2Ftransforms.rs?ref=9dfdf7139cbdcb5df7fe438417943aea53a45c14",
            "patch": "@@ -2,7 +2,7 @@ use anyhow::Result;\n use next_custom_transforms::transforms::strip_page_exports::ExportFilter;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, Vc};\n-use turbopack::module_options::ModuleRule;\n+use turbopack::module_options::{ModuleRule, ModuleRuleEffect, ModuleType, RuleCondition};\n \n use crate::{\n     mode::NextMode,\n@@ -17,6 +17,7 @@ use crate::{\n         next_disallow_re_export_all_in_page::get_next_disallow_export_all_in_page_rule,\n         next_pure::get_next_pure_rule, server_actions::ActionsTransform,\n     },\n+    raw_ecmascript_module::RawEcmascriptModuleType,\n };\n \n /// Returns a list of module rules which apply client-side, Next.js-specific\n@@ -44,6 +45,20 @@ pub async fn get_next_client_transforms_rules(\n         ));\n     }\n \n+    // This is purely a performance optimization:\n+    // - The next-devtools file is very large and rather slow to analyze (unforatunately, at least\n+    //   with our current implementation)\n+    // - It's used by every single application in dev, even tiny (CNA) apps\n+    // - It's prebundled already and doesn't contain any imports/requires\n+    rules.push(ModuleRule::new(\n+        RuleCondition::ResourcePathEndsWith(\n+            \"next/dist/compiled/next-devtools/index.js\".to_string(),\n+        ),\n+        vec![ModuleRuleEffect::ModuleType(ModuleType::Custom(\n+            ResolvedVc::upcast(RawEcmascriptModuleType {}.resolved_cell()),\n+        ))],\n+    ));\n+\n     rules.push(get_next_font_transform_rule(enable_mdx_rs));\n \n     let is_development = mode.await?.is_development();"
        },
        {
            "sha": "286748d7336b839e401887dbe66d2c7f920397d0",
            "filename": "crates/next-core/src/next_image/module.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 1,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/9dfdf7139cbdcb5df7fe438417943aea53a45c14/crates%2Fnext-core%2Fsrc%2Fnext_image%2Fmodule.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9dfdf7139cbdcb5df7fe438417943aea53a45c14/crates%2Fnext-core%2Fsrc%2Fnext_image%2Fmodule.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_image%2Fmodule.rs?ref=9dfdf7139cbdcb5df7fe438417943aea53a45c14",
            "patch": "@@ -1,4 +1,4 @@\n-use anyhow::Result;\n+use anyhow::{Result, bail};\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::rcstr;\n use turbo_tasks::{NonLocalValue, ResolvedVc, TaskInput, Vc, fxindexmap, trace::TraceRawVcs};\n@@ -7,6 +7,7 @@ use turbopack_core::{\n     context::AssetContext, module::Module, reference_type::ReferenceType, resolve::ModulePart,\n     source::Source,\n };\n+use turbopack_ecmascript::EcmascriptInputTransforms;\n use turbopack_static::ecma::StaticUrlJsModule;\n \n use super::source_asset::StructuredImageFileSource;\n@@ -95,4 +96,14 @@ impl CustomModuleType for StructuredImageModuleType {\n             module_asset_context,\n         )\n     }\n+\n+    #[turbo_tasks::function]\n+    fn extend_ecmascript_transforms(\n+        self: Vc<Self>,\n+        _preprocess: Vc<EcmascriptInputTransforms>,\n+        _main: Vc<EcmascriptInputTransforms>,\n+        _postprocess: Vc<EcmascriptInputTransforms>,\n+    ) -> Result<Vc<Box<dyn CustomModuleType>>> {\n+        bail!(\"StructuredImageModuleType does not support adding Ecmascript transforms\");\n+    }\n }"
        },
        {
            "sha": "82bb104be16303289d2ef87cd6e3ba3ccd34468a",
            "filename": "crates/next-core/src/raw_ecmascript_module.rs",
            "status": "added",
            "additions": 317,
            "deletions": 0,
            "changes": 317,
            "blob_url": "https://github.com/vercel/next.js/blob/9dfdf7139cbdcb5df7fe438417943aea53a45c14/crates%2Fnext-core%2Fsrc%2Fraw_ecmascript_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9dfdf7139cbdcb5df7fe438417943aea53a45c14/crates%2Fnext-core%2Fsrc%2Fraw_ecmascript_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fraw_ecmascript_module.rs?ref=9dfdf7139cbdcb5df7fe438417943aea53a45c14",
            "patch": "@@ -0,0 +1,317 @@\n+use std::io::Write;\n+\n+use anyhow::{Result, bail};\n+use either::Either;\n+use once_cell::sync::Lazy;\n+use regex::Regex;\n+use tracing::Instrument;\n+use turbo_rcstr::rcstr;\n+use turbo_tasks::{FxIndexMap, FxIndexSet, ResolvedVc, TryJoinIterExt, ValueToString, Vc};\n+use turbo_tasks_fs::{FileContent, glob::Glob, rope::Rope};\n+use turbopack::{ModuleAssetContext, module_options::CustomModuleType};\n+use turbopack_core::{\n+    asset::{Asset, AssetContent},\n+    chunk::{ChunkItem, ChunkType, ChunkableModule, ChunkingContext},\n+    code_builder::CodeBuilder,\n+    compile_time_info::{\n+        CompileTimeDefineValue, CompileTimeInfo, DefinableNameSegment, FreeVarReference,\n+    },\n+    context::AssetContext,\n+    ident::AssetIdent,\n+    module::Module,\n+    module_graph::ModuleGraph,\n+    resolve::ModulePart,\n+    source::Source,\n+    source_map::GenerateSourceMap,\n+};\n+use turbopack_ecmascript::{\n+    EcmascriptInputTransforms,\n+    chunk::{\n+        EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkItemOptions,\n+        EcmascriptChunkPlaceable, EcmascriptChunkType, EcmascriptExports,\n+    },\n+    source_map::parse_source_map_comment,\n+    utils::StringifyJs,\n+};\n+\n+#[turbo_tasks::value(shared)]\n+pub struct RawEcmascriptModuleType {}\n+\n+#[turbo_tasks::value_impl]\n+impl CustomModuleType for RawEcmascriptModuleType {\n+    #[turbo_tasks::function]\n+    fn create_module(\n+        &self,\n+        source: Vc<Box<dyn Source>>,\n+        module_asset_context: Vc<ModuleAssetContext>,\n+        _part: Option<ModulePart>,\n+    ) -> Vc<Box<dyn Module>> {\n+        Vc::upcast(RawEcmascriptModule::new(\n+            source,\n+            module_asset_context.compile_time_info(),\n+        ))\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn extend_ecmascript_transforms(\n+        self: Vc<Self>,\n+        _preprocess: Vc<EcmascriptInputTransforms>,\n+        _main: Vc<EcmascriptInputTransforms>,\n+        _postprocess: Vc<EcmascriptInputTransforms>,\n+    ) -> Vc<Box<dyn CustomModuleType>> {\n+        // Just ignore them\n+        Vc::upcast(self)\n+    }\n+}\n+\n+#[turbo_tasks::value]\n+pub struct RawEcmascriptModule {\n+    source: ResolvedVc<Box<dyn Source>>,\n+    compile_time_info: ResolvedVc<CompileTimeInfo>,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl RawEcmascriptModule {\n+    #[turbo_tasks::function]\n+    pub fn new(\n+        source: ResolvedVc<Box<dyn Source>>,\n+        compile_time_info: ResolvedVc<CompileTimeInfo>,\n+    ) -> Vc<Self> {\n+        RawEcmascriptModule {\n+            source,\n+            compile_time_info,\n+        }\n+        .cell()\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Module for RawEcmascriptModule {\n+    #[turbo_tasks::function]\n+    fn ident(&self) -> Vc<AssetIdent> {\n+        self.source.ident().with_modifier(rcstr!(\"raw\"))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Asset for RawEcmascriptModule {\n+    #[turbo_tasks::function]\n+    fn content(&self) -> Vc<AssetContent> {\n+        self.source.content()\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ChunkableModule for RawEcmascriptModule {\n+    #[turbo_tasks::function]\n+    fn as_chunk_item(\n+        self: ResolvedVc<Self>,\n+        _module_graph: Vc<ModuleGraph>,\n+        chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+    ) -> Vc<Box<dyn turbopack_core::chunk::ChunkItem>> {\n+        Vc::upcast(\n+            RawEcmascriptChunkItem {\n+                module: self,\n+                chunking_context,\n+            }\n+            .cell(),\n+        )\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl EcmascriptChunkPlaceable for RawEcmascriptModule {\n+    #[turbo_tasks::function]\n+    fn get_exports(&self) -> Vc<EcmascriptExports> {\n+        EcmascriptExports::CommonJs.cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn is_marked_as_side_effect_free(&self, _side_effect_free_packages: Vc<Glob>) -> Vc<bool> {\n+        Vc::cell(false)\n+    }\n+}\n+\n+#[turbo_tasks::value]\n+struct RawEcmascriptChunkItem {\n+    module: ResolvedVc<RawEcmascriptModule>,\n+    chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ChunkItem for RawEcmascriptChunkItem {\n+    #[turbo_tasks::function]\n+    fn asset_ident(&self) -> Vc<AssetIdent> {\n+        self.module.ident()\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn chunking_context(&self) -> Vc<Box<dyn ChunkingContext>> {\n+        *self.chunking_context\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn ty(&self) -> Result<Vc<Box<dyn ChunkType>>> {\n+        Ok(Vc::upcast(\n+            Vc::<EcmascriptChunkType>::default().resolve().await?,\n+        ))\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn module(&self) -> Vc<Box<dyn Module>> {\n+        Vc::upcast(*self.module)\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl EcmascriptChunkItem for RawEcmascriptChunkItem {\n+    #[turbo_tasks::function]\n+    async fn content(&self) -> Result<Vc<EcmascriptChunkItemContent>> {\n+        let span = tracing::info_span!(\n+            \"code generation raw module\",\n+            name = display(self.module.ident().to_string().await?)\n+        );\n+\n+        async {\n+            let module = self.module.await?;\n+            let source = module.source;\n+            let content = source.content().file_content().await?;\n+            let content = match &*content {\n+                FileContent::Content(file) => file.content(),\n+                FileContent::NotFound => bail!(\"RawEcmascriptModule content not found\"),\n+            };\n+\n+            static ENV_REGEX: Lazy<Regex> =\n+                Lazy::new(|| Regex::new(r\"process\\.env\\.([a-zA-Z0-9_]+)\").unwrap());\n+\n+            let content_str = content.to_str()?;\n+\n+            let mut env_vars = FxIndexSet::default();\n+            for (_, [name]) in ENV_REGEX.captures_iter(&content_str).map(|c| c.extract()) {\n+                env_vars.insert(name);\n+            }\n+\n+            let mut code = CodeBuilder::default();\n+            if !env_vars.is_empty() {\n+                let replacements = module\n+                    .compile_time_info\n+                    .await?\n+                    .free_var_references\n+                    .individual()\n+                    .await?;\n+                code += \"var process = {env:\\n\";\n+                writeln!(\n+                    code,\n+                    \"{}\",\n+                    StringifyJs(\n+                        &env_vars\n+                            .into_iter()\n+                            .map(async |name| {\n+                                Ok((\n+                                    name,\n+                                    if let Some(value) =\n+                                        replacements.get(&DefinableNameSegment::Name(name.into()))\n+                                        && let Some((_, value)) = value.iter().find(|(path, _)| {\n+                                            matches!(\n+                                                path.as_slice(),\n+                                                [\n+                                                    DefinableNameSegment::Name(a),\n+                                                    DefinableNameSegment::Name(b)\n+                                                ] if a == \"process\" && b == \"env\"\n+                                            )\n+                                        })\n+                                    {\n+                                        let value = value.await?;\n+                                        let value = match &*value {\n+                                            FreeVarReference::Value(\n+                                                CompileTimeDefineValue::String(value),\n+                                            ) => serde_json::Value::String(value.to_string()),\n+                                            FreeVarReference::Value(\n+                                                CompileTimeDefineValue::Bool(value),\n+                                            ) => serde_json::Value::Bool(*value),\n+                                            _ => {\n+                                                bail!(\n+                                                    \"Unexpected replacement for \\\n+                                                     process.env.{name} in RawEcmascriptModule: \\\n+                                                     {value:?}\"\n+                                                );\n+                                            }\n+                                        };\n+                                        Some(value)\n+                                    } else {\n+                                        None\n+                                    },\n+                                ))\n+                            })\n+                            .try_join()\n+                            .await?\n+                            .into_iter()\n+                            .collect::<FxIndexMap<_, _>>()\n+                    )\n+                )?;\n+                code += \"};\\n\";\n+            }\n+\n+            code += \"(function(){\\n\";\n+            let source_map = if let Some((source_map, _)) = parse_source_map_comment(\n+                source,\n+                Either::Right(&content_str),\n+                &*self.module.ident().path().await?,\n+            )\n+            .await?\n+            {\n+                source_map.generate_source_map().owned().await?\n+            } else {\n+                None\n+            };\n+            code.push_source(content, source_map);\n+\n+            // Add newline in case the raw code had a comment as the last line and no final newline.\n+            code += \"\\n})();\\n\";\n+\n+            let code = code.build();\n+            let source_map = if code.has_source_map() {\n+                let source_map = code.generate_source_map_ref()?;\n+\n+                static SECTIONS_REGEX: Lazy<Regex> =\n+                    Lazy::new(|| Regex::new(r#\"sections\"[\\s\\n]*:\"#).unwrap());\n+                Some(if !SECTIONS_REGEX.is_match(&source_map.to_str()?) {\n+                    // This is definitely not an index source map\n+                    source_map\n+                } else {\n+                    let _span = tracing::span!(\n+                        tracing::Level::WARN,\n+                        \"flattening index source map in RawEcmascriptModule\"\n+                    )\n+                    .entered();\n+                    match swc_sourcemap::lazy::decode(&source_map.to_bytes())? {\n+                        swc_sourcemap::lazy::DecodedMap::Regular(_) => source_map,\n+                        // without flattening the index map, we would get nested index source maps\n+                        // in the output chunks, which are apparently not\n+                        // supported\n+                        swc_sourcemap::lazy::DecodedMap::Index(source_map) => {\n+                            let source_map = source_map.flatten()?.into_raw_sourcemap();\n+                            let result = serde_json::to_vec(&source_map)?;\n+                            Rope::from(result)\n+                        }\n+                    }\n+                })\n+            } else {\n+                None\n+            };\n+\n+            Ok(EcmascriptChunkItemContent {\n+                source_map,\n+                inner_code: code.into_source_code(),\n+                options: EcmascriptChunkItemOptions {\n+                    module_and_exports: true,\n+                    ..Default::default()\n+                },\n+                ..Default::default()\n+            }\n+            .into())\n+        }\n+        .instrument(span)\n+        .await\n+    }\n+}"
        },
        {
            "sha": "e1b4f0f3c566d0db8d1357a314adb5bfbfa2435d",
            "filename": "turbopack/crates/turbopack/src/lib.rs",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/9dfdf7139cbdcb5df7fe438417943aea53a45c14/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9dfdf7139cbdcb5df7fe438417943aea53a45c14/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs?ref=9dfdf7139cbdcb5df7fe438417943aea53a45c14",
            "patch": "@@ -622,6 +622,38 @@ async fn process_default_internal(\n                                 analyze_types,\n                                 options,\n                             }),\n+                            Some(ModuleType::Custom(custom_module_type)) => {\n+                                match custom_module_type\n+                                    .extend_ecmascript_transforms(\n+                                        **extend_preprocess,\n+                                        **extend_main,\n+                                        **extend_postprocess,\n+                                    )\n+                                    .to_resolved()\n+                                    .await\n+                                {\n+                                    Ok(custom_module_type) => {\n+                                        Some(ModuleType::Custom(custom_module_type))\n+                                    }\n+                                    // TODO ideally this would print the actual error message\n+                                    // returned by the CustomModuleType\n+                                    Err(_) => {\n+                                        ModuleIssue::new(\n+                                            *ident,\n+                                            rcstr!(\"Invalid module type\"),\n+                                            rcstr!(\n+                                                \"The custom module type didn't accept the \\\n+                                                 additional Ecmascript transforms\"\n+                                            ),\n+                                            Some(IssueSource::from_source_only(current_source)),\n+                                        )\n+                                        .to_resolved()\n+                                        .await?\n+                                        .emit();\n+                                        Some(ModuleType::Custom(custom_module_type))\n+                                    }\n+                                }\n+                            }\n                             Some(module_type) => {\n                                 ModuleIssue::new(\n                                     *ident,"
        },
        {
            "sha": "85f7051b582291ae0bee5a3bef77041c32d7c7bc",
            "filename": "turbopack/crates/turbopack/src/module_options/custom_module_type.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/9dfdf7139cbdcb5df7fe438417943aea53a45c14/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fcustom_module_type.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9dfdf7139cbdcb5df7fe438417943aea53a45c14/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fcustom_module_type.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fcustom_module_type.rs?ref=9dfdf7139cbdcb5df7fe438417943aea53a45c14",
            "patch": "@@ -1,5 +1,6 @@\n use turbo_tasks::Vc;\n use turbopack_core::{module::Module, resolve::ModulePart, source::Source};\n+use turbopack_ecmascript::EcmascriptInputTransforms;\n \n use crate::ModuleAssetContext;\n \n@@ -12,4 +13,12 @@ pub trait CustomModuleType {\n         module_asset_context: Vc<ModuleAssetContext>,\n         part: Option<ModulePart>,\n     ) -> Vc<Box<dyn Module>>;\n+\n+    #[turbo_tasks::function]\n+    fn extend_ecmascript_transforms(\n+        self: Vc<Self>,\n+        preprocess: Vc<EcmascriptInputTransforms>,\n+        main: Vc<EcmascriptInputTransforms>,\n+        postprocess: Vc<EcmascriptInputTransforms>,\n+    ) -> Vc<Box<dyn CustomModuleType>>;\n }"
        }
    ],
    "stats": {
        "total": 391,
        "additions": 389,
        "deletions": 2
    }
}