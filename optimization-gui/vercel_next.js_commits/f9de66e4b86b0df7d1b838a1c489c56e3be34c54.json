{
    "author": "lukesandberg",
    "message": "[turbopack] Drop turbo_tasks::function from EcmascriptAnalyzable::module_content (#83277)\n\nThis function simply plugs two other VCs together, and it never gets a cache hit because it is \"dominated\" by other tasks.\n\nThe only reason it is a turbotask is because it is defined as a trait item, however, we recently (#79217) allowed for value_trait items to not be turbo tasks.  This PR builds on that to additionally allow for non-turbo_task trait items to accept `Vc<Self>`.  This only really works if there is also a default implementation which works for this case.\n\nA tiny speed up progression in production\n\n![image.png](https://app.graphite.dev/user-attachments/assets/c6d82929-5fb2-4921-b566-d648751a00ee.png)",
    "sha": "f9de66e4b86b0df7d1b838a1c489c56e3be34c54",
    "files": [
        {
            "sha": "4ac9cc291996d49fc716b5518611f40bacc4a056",
            "filename": "turbopack/crates/turbo-tasks-macros/src/func.rs",
            "status": "modified",
            "additions": 58,
            "deletions": 40,
            "changes": 98,
            "blob_url": "https://github.com/vercel/next.js/blob/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs?ref=f9de66e4b86b0df7d1b838a1c489c56e3be34c54",
            "patch": "@@ -108,46 +108,8 @@ impl TurboFn<'_> {\n                         _ => &definition_context,\n                     };\n \n-                    match self_type.as_ref() {\n-                        // we allow `&Self` but not `&mut Self`\n-                        syn::Type::Reference(type_reference) => {\n-                            if let Some(m) = type_reference.mutability {\n-                                m.span()\n-                                    .unwrap()\n-                                    .error(format!(\n-                                        \"{} cannot take self by mutable reference, use &self or \\\n-                                         self: Vc<Self> instead\",\n-                                        definition_context.function_type(),\n-                                    ))\n-                                    .emit();\n-                                return None;\n-                            }\n-\n-                            match type_reference.elem.as_ref() {\n-                                syn::Type::Path(TypePath { qself: None, path })\n-                                    if path.is_ident(\"Self\") => {}\n-                                _ => {\n-                                    self_type\n-                                        .span()\n-                                        .unwrap()\n-                                        .error(\n-                                            \"Unexpected `self` type, use `&self` or `self: \\\n-                                             Vc<Self>\",\n-                                        )\n-                                        .emit();\n-                                    return None;\n-                                }\n-                            }\n-                        }\n-                        syn::Type::Path(_) => {}\n-                        _ => {\n-                            self_type\n-                                .span()\n-                                .unwrap()\n-                                .error(\"Unexpected `self` type, use `&self` or `self: Vc<Self>\")\n-                                .emit();\n-                            return None;\n-                        }\n+                    if get_receiver_style(self_type, definition_context) == ReceiverStyle::Error {\n+                        return None;\n                     }\n                     // We don't validate that the user provided a valid `turbo_tasks::Vc<Self>`\n                     // here. We'll rely on the compiler to emit an error if the user provided an\n@@ -695,6 +657,62 @@ impl TurboFn<'_> {\n     }\n }\n \n+#[derive(PartialEq, Eq)]\n+pub enum ReceiverStyle {\n+    // A reference like &self or self: &Self\n+    Reference,\n+    // A Vc<> type, this is optimistic\n+    Vc,\n+    Error,\n+}\n+\n+pub(crate) fn get_receiver_style(\n+    self_type: &Type,\n+    definition_context: &DefinitionContext,\n+) -> ReceiverStyle {\n+    match self_type {\n+        // we allow `&Self` but not `&mut Self`\n+        syn::Type::Reference(type_reference) => {\n+            if let Some(m) = type_reference.mutability {\n+                m.span()\n+                    .unwrap()\n+                    .error(format!(\n+                        \"{} cannot take self by mutable reference, use &self or self: Vc<Self> \\\n+                         instead\",\n+                        definition_context.function_type(),\n+                    ))\n+                    .emit();\n+                return ReceiverStyle::Error;\n+            }\n+\n+            match type_reference.elem.as_ref() {\n+                syn::Type::Path(TypePath { qself: None, path }) if path.is_ident(\"Self\") => {}\n+                _ => {\n+                    self_type\n+                        .span()\n+                        .unwrap()\n+                        .error(\"Unexpected `self` type, use `&self` or `self: Vc<Self>\")\n+                        .emit();\n+                    return ReceiverStyle::Error;\n+                }\n+            }\n+            return ReceiverStyle::Reference;\n+        }\n+        syn::Type::Path(_) => {}\n+        _ => {\n+            self_type\n+                .span()\n+                .unwrap()\n+                .error(\"Unexpected `self` type, use `&self` or `self: Vc<Self>\")\n+                .emit();\n+            return ReceiverStyle::Error;\n+        }\n+    }\n+    // All other cases are assumed to be a VC, this is not guaranteed but we are happy to just have\n+    // compiler errors when this assumption is wrong.\n+    ReceiverStyle::Vc\n+}\n+\n /// An indication of what kind of IO this function does. Currently only used for\n /// static analysis, and ignored within this macro.\n #[derive(Hash, PartialEq, Eq)]"
        },
        {
            "sha": "e9c0682d0c48baa33d80b5a4f187909c1eede3e4",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_trait_macro.rs",
            "status": "modified",
            "additions": 29,
            "deletions": 5,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs?ref=f9de66e4b86b0df7d1b838a1c489c56e3be34c54",
            "patch": "@@ -2,7 +2,8 @@ use proc_macro::TokenStream;\n use proc_macro2::{Ident, TokenStream as TokenStream2};\n use quote::{quote, quote_spanned};\n use syn::{\n-    FnArg, ItemTrait, Pat, TraitItem, TraitItemFn, parse_macro_input, parse_quote, spanned::Spanned,\n+    FnArg, ItemTrait, Pat, Receiver, TraitItem, TraitItemFn, parse_macro_input, parse_quote,\n+    spanned::Spanned,\n };\n use turbo_tasks_macros_shared::{\n     ValueTraitArguments, get_trait_default_impl_function_ident, get_trait_type_ident, is_self_used,\n@@ -11,7 +12,7 @@ use turbo_tasks_macros_shared::{\n use crate::{\n     func::{\n         DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n-        split_function_attributes,\n+        get_receiver_style, split_function_attributes,\n     },\n     global_name::global_name,\n };\n@@ -94,15 +95,29 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n         let (func_args, attrs) = split_function_attributes(attrs);\n         let func_args = match func_args {\n             Ok(None) => {\n-                // There is no turbo_tasks::function annotation, preserve this item\n+                // There is no turbo_tasks::function annotation, preserve this item as is in the\n+                // trait\n                 items.push(item.clone());\n                 // But we still need to add a forwarding implementation to the\n                 // impl for `turbo_tasks::Dynamic<Box<dyn T>>`\n                 // This will have the same signature, but simply forward the call\n                 let mut args = Vec::new();\n+                let mut is_vc_receiver = false;\n                 for arg in &sig.inputs {\n                     let ident = match arg {\n-                        FnArg::Receiver(_) => {\n+                        FnArg::Receiver(Receiver { ty, .. }) => {\n+                            match get_receiver_style(ty, &DefinitionContext::ValueTrait) {\n+                                crate::func::ReceiverStyle::Reference => {\n+                                    is_vc_receiver = false;\n+                                }\n+                                crate::func::ReceiverStyle::Vc => {\n+                                    is_vc_receiver = true;\n+                                }\n+                                crate::func::ReceiverStyle::Error => {}\n+                            }\n+                            // We allow either `&self` or `self: Vc<Self>`\n+                            // we cannot really validate Vc<Self> so instead we simply assume that\n+                            // any type that isn't a reference is Vc<Self>\n                             continue;\n                         }\n                         FnArg::Typed(pat) => match &*pat.pat {\n@@ -120,8 +135,17 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n                     };\n                     args.push(ident);\n                 }\n+                if is_vc_receiver {\n+                    item.span()\n+                        .unwrap()\n+                        .error(\n+                            \"`self: Vc<Self>` is only supported on trait items with a \\\n+                             `turbo-tasks::function` annotation\",\n+                        )\n+                        .emit();\n+                }\n                 // Add a dummy implementation that derefences the box and delegates to the\n-                // actual implementation.\n+                // actual implementation.  We need to conditionally add an await if it is async\n                 dynamic_trait_fns.push(if sig.asyncness.is_some() {\n                     quote! {\n                         #sig {"
        },
        {
            "sha": "36d64e0aa75d661e62c6773db8a2cd1ba3425ed8",
            "filename": "turbopack/crates/turbo-tasks/src/vc/resolved.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fresolved.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fresolved.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvc%2Fresolved.rs?ref=f9de66e4b86b0df7d1b838a1c489c56e3be34c54",
            "patch": "@@ -243,7 +243,7 @@ where\n     /// Returns `None` if the underlying value type does not implement `K`.\n     ///\n     /// **Note:** if the trait `T` is required to implement `K`, use [`ResolvedVc::upcast`] instead.\n-    /// This provides stronger guarantees, removing the need for a [`Option`] return type.\n+    /// That method provides stronger guarantees, removing the need for a [`Option`] return type.\n     ///\n     /// See also: [`Vc::try_resolve_sidecast`].\n     pub fn try_sidecast<K>(this: Self) -> Option<ResolvedVc<K>>"
        },
        {
            "sha": "24a37e4b4a9a5b49b26c585bd1ac3da2b35a8ee2",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 18,
            "deletions": 5,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=f9de66e4b86b0df7d1b838a1c489c56e3be34c54",
            "patch": "@@ -84,7 +84,7 @@ pub use transform::{\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n     FxDashMap, FxIndexMap, IntoTraitRef, NonLocalValue, ReadRef, ResolvedVc, TaskInput,\n-    TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc, trace::TraceRawVcs,\n+    TryFlatJoinIterExt, TryJoinIterExt, Upcast, ValueToString, Vc, trace::TraceRawVcs,\n };\n use turbo_tasks_fs::{FileJsonContent, FileSystemPath, glob::Glob, rope::Rope};\n use turbopack_core::{\n@@ -367,15 +367,28 @@ pub trait EcmascriptAnalyzable: Module + Asset {\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n         async_module_info: Option<Vc<AsyncModuleInfo>>,\n     ) -> Result<Vc<EcmascriptModuleContentOptions>>;\n+}\n \n-    #[turbo_tasks::function]\n+pub trait EcmascriptAnalyzableExt {\n     fn module_content(\n         self: Vc<Self>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n         async_module_info: Option<Vc<AsyncModuleInfo>>,\n-    ) -> Result<Vc<EcmascriptModuleContent>> {\n-        let own_options = self.module_content_options(chunking_context, async_module_info);\n-        Ok(EcmascriptModuleContent::new(own_options))\n+    ) -> Vc<EcmascriptModuleContent>;\n+}\n+\n+impl<T> EcmascriptAnalyzableExt for T\n+where\n+    T: EcmascriptAnalyzable + Upcast<Box<dyn EcmascriptAnalyzable>>,\n+{\n+    fn module_content(\n+        self: Vc<Self>,\n+        chunking_context: Vc<Box<dyn ChunkingContext>>,\n+        async_module_info: Option<Vc<AsyncModuleInfo>>,\n+    ) -> Vc<EcmascriptModuleContent> {\n+        let analyzable = Vc::upcast_non_strict::<Box<dyn EcmascriptAnalyzable>>(self);\n+        let own_options = analyzable.module_content_options(chunking_context, async_module_info);\n+        EcmascriptModuleContent::new(own_options)\n     }\n }\n "
        },
        {
            "sha": "5e92f731aa1fcf6b7b5cdb38c337a0c2ed03d0b1",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/facade/chunk_item.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fchunk_item.rs?ref=f9de66e4b86b0df7d1b838a1c489c56e3be34c54",
            "patch": "@@ -8,7 +8,7 @@ use turbopack_core::{\n \n use super::module::EcmascriptModuleFacadeModule;\n use crate::{\n-    EcmascriptAnalyzable,\n+    EcmascriptAnalyzableExt,\n     chunk::{\n         EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkPlaceable,\n         EcmascriptChunkType,"
        },
        {
            "sha": "e95229b330ecb5a5b315a3ed33ae753655dabc8d",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/locals/chunk_item.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs?ref=f9de66e4b86b0df7d1b838a1c489c56e3be34c54",
            "patch": "@@ -8,7 +8,7 @@ use turbopack_core::{\n \n use super::module::EcmascriptModuleLocalsModule;\n use crate::{\n-    EcmascriptAnalyzable,\n+    EcmascriptAnalyzableExt,\n     chunk::{EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkType},\n };\n "
        },
        {
            "sha": "9a1cebe9398b317f50e0ba9dc132d617904912e0",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/chunk_item.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f9de66e4b86b0df7d1b838a1c489c56e3be34c54/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs?ref=f9de66e4b86b0df7d1b838a1c489c56e3be34c54",
            "patch": "@@ -10,7 +10,7 @@ use turbopack_core::{\n \n use super::asset::EcmascriptModulePartAsset;\n use crate::{\n-    EcmascriptAnalyzable,\n+    EcmascriptAnalyzableExt,\n     chunk::{\n         EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkItemOptions,\n         EcmascriptChunkPlaceable, EcmascriptChunkType,"
        }
    ],
    "stats": {
        "total": 163,
        "additions": 109,
        "deletions": 54
    }
}