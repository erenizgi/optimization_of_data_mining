{
    "author": "sokra",
    "message": "Turbopack: rename reverse topological to postorder topological, fix async referenced modules (#76429)\n\n### What?\r\n\r\n* move iter_neighbors into shared file, rename to iter_neighbors_rev\r\n* fix async referenced modules by filtering by chunking type\r\n* rename reverse topological to postorder topological",
    "sha": "9b994bf80ecc6188faf527a057f93119d522384e",
    "files": [
        {
            "sha": "9d23a8174c7f8fcdc3edb66a55b7f81305e4565d",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/9b994bf80ecc6188faf527a057f93119d522384e/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9b994bf80ecc6188faf527a057f93119d522384e/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=9b994bf80ecc6188faf527a057f93119d522384e",
            "patch": "@@ -1678,7 +1678,7 @@ async fn any_output_changed(\n         .await\n         .completed()?\n         .into_inner()\n-        .into_reverse_topological()\n+        .into_postorder_topological()\n         .map(|m| async move {\n             let asset_path = m.path().await?;\n             if !asset_path.path.ends_with(\".map\")"
        },
        {
            "sha": "cabd41970c62b63ec6d326d7aeb7b811eac63419",
            "filename": "crates/next-core/src/emit.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/9b994bf80ecc6188faf527a057f93119d522384e/crates%2Fnext-core%2Fsrc%2Femit.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9b994bf80ecc6188faf527a057f93119d522384e/crates%2Fnext-core%2Fsrc%2Femit.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Femit.rs?ref=9b994bf80ecc6188faf527a057f93119d522384e",
            "patch": "@@ -112,7 +112,7 @@ pub async fn all_assets_from_entries(entries: Vc<OutputAssets>) -> Result<Vc<Out\n             .await\n             .completed()?\n             .into_inner()\n-            .into_reverse_topological()\n+            .into_postorder_topological()\n             .collect::<FxHashSet<_>>()\n             .into_iter()\n             .collect(),"
        },
        {
            "sha": "e4c775285cd74fdfdd280d565a907331eca9df02",
            "filename": "crates/next-core/src/next_client_reference/visit_client_reference.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/9b994bf80ecc6188faf527a057f93119d522384e/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9b994bf80ecc6188faf527a057f93119d522384e/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs?ref=9b994bf80ecc6188faf527a057f93119d522384e",
            "patch": "@@ -174,7 +174,7 @@ pub async fn find_server_entries(entry: ResolvedVc<Box<dyn Module>>) -> Result<V\n \n         let mut server_component_entries = vec![];\n         let mut server_utils = vec![];\n-        for node in graph.reverse_topological() {\n+        for node in graph.postorder_topological() {\n             match &node.ty {\n                 VisitClientReferenceNodeType::ServerUtilEntry(server_util, _) => {\n                     server_utils.push(*server_util);"
        },
        {
            "sha": "0f00203f10e858b09e77afc21a093f2c1eb7fd9a",
            "filename": "turbopack/crates/turbo-tasks/src/graph/adjacency_map.rs",
            "status": "modified",
            "additions": 20,
            "deletions": 20,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fadjacency_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fadjacency_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fgraph%2Fadjacency_map.rs?ref=9b994bf80ecc6188faf527a057f93119d522384e",
            "patch": "@@ -88,10 +88,10 @@ impl<T> AdjacencyMap<T>\n where\n     T: Eq + Hash + Clone,\n {\n-    /// Returns an owned iterator over the nodes in reverse topological order,\n+    /// Returns an owned iterator over the nodes in postorder topological order,\n     /// starting from the roots.\n-    pub fn into_reverse_topological(self) -> IntoReverseTopologicalIter<T> {\n-        IntoReverseTopologicalIter {\n+    pub fn into_postorder_topological(self) -> IntoPostorderTopologicalIter<T> {\n+        IntoPostorderTopologicalIter {\n             adjacency_map: self.adjacency_map,\n             stack: self\n                 .roots\n@@ -108,7 +108,7 @@ where\n     pub fn into_breadth_first_edges(self) -> IntoBreadthFirstEdges<T> {\n         IntoBreadthFirstEdges {\n             adjacency_map: self.adjacency_map,\n-            stack: self\n+            queue: self\n                 .roots\n                 .into_iter()\n                 .rev()\n@@ -118,10 +118,10 @@ where\n         }\n     }\n \n-    /// Returns an iterator over the nodes in reverse topological order,\n+    /// Returns an iterator over the nodes in postorder topological order,\n     /// starting from the roots.\n-    pub fn reverse_topological(&self) -> ReverseTopologicalIter<T> {\n-        ReverseTopologicalIter {\n+    pub fn postorder_topological(&self) -> PostorderTopologicalIter<T> {\n+        PostorderTopologicalIter {\n             adjacency_map: &self.adjacency_map,\n             stack: self\n                 .roots\n@@ -133,13 +133,13 @@ where\n         }\n     }\n \n-    /// Returns an iterator over the nodes in reverse topological order,\n+    /// Returns an iterator over the nodes in postorder topological order,\n     /// starting from the given node.\n-    pub fn reverse_topological_from_node<'graph>(\n+    pub fn postorder_topological_from_node<'graph>(\n         &'graph self,\n         node: &'graph T,\n-    ) -> ReverseTopologicalIter<'graph, T> {\n-        ReverseTopologicalIter {\n+    ) -> PostorderTopologicalIter<'graph, T> {\n+        PostorderTopologicalIter {\n             adjacency_map: &self.adjacency_map,\n             stack: vec![(ReverseTopologicalPass::Pre, node)],\n             visited: FxHashSet::default(),\n@@ -153,9 +153,9 @@ enum ReverseTopologicalPass {\n     Post,\n }\n \n-/// An iterator over the nodes of a graph in reverse topological order, starting\n+/// An iterator over the nodes of a graph in postorder topological order, starting\n /// from the roots.\n-pub struct IntoReverseTopologicalIter<T>\n+pub struct IntoPostorderTopologicalIter<T>\n where\n     T: Eq + Hash + Clone,\n {\n@@ -164,7 +164,7 @@ where\n     visited: FxHashSet<T>,\n }\n \n-impl<T> Iterator for IntoReverseTopologicalIter<T>\n+impl<T> Iterator for IntoPostorderTopologicalIter<T>\n where\n     T: Eq + Hash + Clone,\n {\n@@ -209,7 +209,7 @@ where\n     T: Eq + std::hash::Hash + Clone,\n {\n     adjacency_map: FxHashMap<T, Vec<T>>,\n-    stack: VecDeque<(Option<T>, T)>,\n+    queue: VecDeque<(Option<T>, T)>,\n     expanded: FxHashSet<T>,\n }\n \n@@ -220,14 +220,14 @@ where\n     type Item = (Option<T>, T);\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        let (parent, current) = self.stack.pop_front()?;\n+        let (parent, current) = self.queue.pop_front()?;\n \n         let Some(neighbors) = self.adjacency_map.get(&current) else {\n             return Some((parent, current));\n         };\n \n         if self.expanded.insert(current.clone()) {\n-            self.stack.extend(\n+            self.queue.extend(\n                 neighbors\n                     .iter()\n                     .map(|neighbor| (Some(current.clone()), neighbor.clone())),\n@@ -238,9 +238,9 @@ where\n     }\n }\n \n-/// An iterator over the nodes of a graph in reverse topological order, starting\n+/// An iterator over the nodes of a graph in postorder topological order, starting\n /// from the roots.\n-pub struct ReverseTopologicalIter<'graph, T>\n+pub struct PostorderTopologicalIter<'graph, T>\n where\n     T: Eq + Hash + Clone,\n {\n@@ -249,7 +249,7 @@ where\n     visited: FxHashSet<&'graph T>,\n }\n \n-impl<'graph, T> Iterator for ReverseTopologicalIter<'graph, T>\n+impl<'graph, T> Iterator for PostorderTopologicalIter<'graph, T>\n where\n     T: Eq + Hash + Clone,\n {"
        },
        {
            "sha": "92dde62af686f4a474d5c6d759c83419a1e3b3f7",
            "filename": "turbopack/crates/turbopack-core/src/chunk/mod.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs?ref=9b994bf80ecc6188faf527a057f93119d522384e",
            "patch": "@@ -191,6 +191,19 @@ pub enum ChunkingType {\n     Traced,\n }\n \n+impl ChunkingType {\n+    pub fn is_inherit_async(&self) -> bool {\n+        match self {\n+            ChunkingType::Parallel => false,\n+            ChunkingType::ParallelInheritAsync => true,\n+            ChunkingType::Async => false,\n+            ChunkingType::Isolated { .. } => false,\n+            ChunkingType::Shared { inherit_async, .. } => *inherit_async,\n+            ChunkingType::Traced => false,\n+        }\n+    }\n+}\n+\n #[turbo_tasks::value(transparent)]\n pub struct ChunkingTypeOption(Option<ChunkingType>);\n "
        },
        {
            "sha": "d14e2968422629d9e6ba3a3511d53fe160ca17a9",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 12,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=9b994bf80ecc6188faf527a057f93119d522384e",
            "patch": "@@ -7,7 +7,6 @@ use std::{\n use anyhow::{bail, Result};\n use either::Either;\n use indexmap::map::Entry;\n-use petgraph::graph::{DiGraph, EdgeIndex, NodeIndex};\n use roaring::RoaringBitmap;\n use rustc_hash::{FxHashMap, FxHashSet};\n use serde::{Deserialize, Serialize};\n@@ -22,8 +21,8 @@ use crate::{\n     chunk::{ChunkGroupType, ChunkingType},\n     module::Module,\n     module_graph::{\n-        get_node, get_node_idx, GraphNodeIndex, GraphTraversalAction, ModuleGraph,\n-        SingleModuleGraphModuleNode, SingleModuleGraphNode,\n+        get_node, get_node_idx, traced_di_graph::iter_neighbors_rev, GraphNodeIndex,\n+        GraphTraversalAction, ModuleGraph, SingleModuleGraphModuleNode, SingleModuleGraphNode,\n     },\n };\n \n@@ -178,14 +177,6 @@ impl Deref for ChunkGroupId {\n     }\n }\n \n-fn iter_neighbors<N, E>(\n-    graph: &DiGraph<N, E>,\n-    node: NodeIndex,\n-) -> impl Iterator<Item = (EdgeIndex, NodeIndex)> + '_ {\n-    let mut walker = graph.neighbors(node).detach();\n-    std::iter::from_fn(move || walker.next(graph))\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n struct NodeWithPriority {\n     depth: usize,\n@@ -448,7 +439,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                 queue_set.remove(&node);\n                 let (node_weight, node) = get_node_idx!(graphs, node)?;\n                 let graph = &graphs[node.graph_idx].graph;\n-                let neighbors = iter_neighbors(graph, node.node_idx);\n+                let neighbors = iter_neighbors_rev(graph, node.node_idx);\n \n                 visit_count += 1;\n "
        },
        {
            "sha": "d25eb72f5e26a2c377a73ea544ef2be10e494ef1",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 48,
            "deletions": 55,
            "changes": 103,
            "blob_url": "https://github.com/vercel/next.js/blob/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=9b994bf80ecc6188faf527a057f93119d522384e",
            "patch": "@@ -26,7 +26,7 @@ use crate::{\n     module_graph::{\n         async_module_info::{compute_async_module_info, AsyncModulesInfo},\n         chunk_group_info::{compute_chunk_group_info, ChunkGroupInfo},\n-        traced_di_graph::TracedDiGraph,\n+        traced_di_graph::{iter_neighbors_rev, TracedDiGraph},\n     },\n     reference::primary_chunkable_referenced_modules,\n };\n@@ -528,18 +528,14 @@ impl SingleModuleGraph {\n         let graph = &self.graph;\n         let entries = entries.into_iter().map(|e| self.get_module(e).unwrap());\n \n-        enum ReverseTopologicalPass {\n+        enum TopologicalPass {\n             Visit,\n             ExpandAndVisit,\n         }\n \n         #[allow(clippy::type_complexity)] // This is a temporary internal structure\n-        let mut stack: Vec<(\n-            ReverseTopologicalPass,\n-            Option<(NodeIndex, EdgeIndex)>,\n-            NodeIndex,\n-        )> = entries\n-            .map(|e| (ReverseTopologicalPass::ExpandAndVisit, None, e))\n+        let mut stack: Vec<(TopologicalPass, Option<(NodeIndex, EdgeIndex)>, NodeIndex)> = entries\n+            .map(|e| (TopologicalPass::ExpandAndVisit, None, e))\n             .collect();\n         let mut expanded = HashSet::new();\n         while let Some((pass, parent, current)) = stack.pop() {\n@@ -555,36 +551,33 @@ impl SingleModuleGraph {\n                 )\n             });\n             match pass {\n-                ReverseTopologicalPass::Visit => {\n+                TopologicalPass::Visit => {\n                     visit_postorder(parent_arg, graph.node_weight(current).unwrap(), state);\n                 }\n-                ReverseTopologicalPass::ExpandAndVisit => {\n-                    match graph.node_weight(current).unwrap() {\n-                        current_node @ SingleModuleGraphNode::Module(_) => {\n-                            let action = visit_preorder(parent_arg, current_node, state)?;\n-                            if action == GraphTraversalAction::Exclude {\n-                                continue;\n-                            }\n-                            stack.push((ReverseTopologicalPass::Visit, parent, current));\n-                            if action == GraphTraversalAction::Continue && expanded.insert(current)\n-                            {\n-                                stack.extend(iter_neighbors(graph, current).map(\n-                                    |(edge, child)| {\n-                                        (\n-                                            ReverseTopologicalPass::ExpandAndVisit,\n-                                            Some((current, edge)),\n-                                            child,\n-                                        )\n-                                    },\n-                                ));\n-                            }\n+                TopologicalPass::ExpandAndVisit => match graph.node_weight(current).unwrap() {\n+                    current_node @ SingleModuleGraphNode::Module(_) => {\n+                        let action = visit_preorder(parent_arg, current_node, state)?;\n+                        if action == GraphTraversalAction::Exclude {\n+                            continue;\n                         }\n-                        current_node @ SingleModuleGraphNode::VisitedModule { .. } => {\n-                            visit_preorder(parent_arg, current_node, state)?;\n-                            visit_postorder(parent_arg, current_node, state);\n+                        stack.push((TopologicalPass::Visit, parent, current));\n+                        if action == GraphTraversalAction::Continue && expanded.insert(current) {\n+                            stack.extend(iter_neighbors_rev(graph, current).map(\n+                                |(edge, child)| {\n+                                    (\n+                                        TopologicalPass::ExpandAndVisit,\n+                                        Some((current, edge)),\n+                                        child,\n+                                    )\n+                                },\n+                            ));\n                         }\n                     }\n-                }\n+                    current_node @ SingleModuleGraphNode::VisitedModule { .. } => {\n+                        visit_preorder(parent_arg, current_node, state)?;\n+                        visit_postorder(parent_arg, current_node, state);\n+                    }\n+                },\n             }\n         }\n \n@@ -655,7 +648,14 @@ impl ModuleGraph {\n         let async_modules_info = self.async_module_info().await?;\n \n         let entry = ModuleGraph::get_entry(&graphs, module).await?;\n-        let referenced_modules = iter_neighbors(&graphs[entry.graph_idx].graph, entry.node_idx)\n+        let referenced_modules = iter_neighbors_rev(&graphs[entry.graph_idx].graph, entry.node_idx)\n+            .filter(|(edge_idx, _)| {\n+                let ty = graphs[entry.graph_idx]\n+                    .graph\n+                    .edge_weight(*edge_idx)\n+                    .unwrap();\n+                ty.is_inherit_async()\n+            })\n             .map(|(_, child_idx)| {\n                 anyhow::Ok(\n                     get_node!(\n@@ -670,6 +670,7 @@ impl ModuleGraph {\n             })\n             .collect::<Result<Vec<_>>>()?\n             .into_iter()\n+            .rev()\n             .filter(|m| async_modules_info.contains(m))\n             .map(|m| *m)\n             .collect();\n@@ -808,7 +809,7 @@ impl ModuleGraph {\n             let graph = &graphs[node.graph_idx].graph;\n             let node_weight = get_node!(graphs, node)?;\n             if visited.insert(node) {\n-                let neighbors = iter_neighbors(graph, node.node_idx);\n+                let neighbors = iter_neighbors_rev(graph, node.node_idx);\n \n                 for (edge, succ) in neighbors {\n                     let succ = GraphNodeIndex {\n@@ -861,7 +862,7 @@ impl ModuleGraph {\n             let graph = &graphs[node.graph_idx].graph;\n             let node_weight = get_node!(graphs, node)?;\n             if visited.insert(node) {\n-                let neighbors = iter_neighbors(graph, node.node_idx);\n+                let neighbors = iter_neighbors_rev(graph, node.node_idx);\n \n                 for (edge, succ) in neighbors {\n                     let succ = GraphNodeIndex {\n@@ -953,19 +954,19 @@ impl ModuleGraph {\n \n         let entries = entries.into_iter().collect::<Vec<_>>();\n \n-        enum ReverseTopologicalPass {\n+        enum TopologicalPass {\n             Visit,\n             ExpandAndVisit,\n         }\n         #[allow(clippy::type_complexity)] // This is a temporary internal structure\n         let mut stack: Vec<(\n-            ReverseTopologicalPass,\n+            TopologicalPass,\n             Option<(GraphNodeIndex, EdgeIndex)>,\n             GraphNodeIndex,\n         )> = Vec::with_capacity(entries.len());\n         for entry in entries.into_iter().rev() {\n             stack.push((\n-                ReverseTopologicalPass::ExpandAndVisit,\n+                TopologicalPass::ExpandAndVisit,\n                 None,\n                 ModuleGraph::get_entry(&graphs, entry).await?,\n             ));\n@@ -984,31 +985,31 @@ impl ModuleGraph {\n             };\n             let current_node = get_node!(graphs, current)?;\n             match pass {\n-                ReverseTopologicalPass::Visit => {\n+                TopologicalPass::Visit => {\n                     visit_postorder(parent_arg, current_node, state);\n                 }\n-                ReverseTopologicalPass::ExpandAndVisit => {\n+                TopologicalPass::ExpandAndVisit => {\n                     let action = visit_preorder(parent_arg, current_node, state)?;\n                     if action == GraphTraversalAction::Exclude {\n                         continue;\n                     }\n-                    stack.push((ReverseTopologicalPass::Visit, parent, current));\n+                    stack.push((TopologicalPass::Visit, parent, current));\n                     if action == GraphTraversalAction::Continue && expanded.insert(current) {\n                         let graph = &graphs[current.graph_idx].graph;\n-                        let (neighbors, current) =\n+                        let (neighbors_rev, current) =\n                             match graph.node_weight(current.node_idx).unwrap() {\n                                 SingleModuleGraphNode::Module(_) => {\n-                                    (iter_neighbors(graph, current.node_idx), current)\n+                                    (iter_neighbors_rev(graph, current.node_idx), current)\n                                 }\n                                 SingleModuleGraphNode::VisitedModule { idx, .. } => (\n                                     // We switch graphs\n-                                    iter_neighbors(&graphs[idx.graph_idx].graph, idx.node_idx),\n+                                    iter_neighbors_rev(&graphs[idx.graph_idx].graph, idx.node_idx),\n                                     *idx,\n                                 ),\n                             };\n-                        stack.extend(neighbors.map(|(edge, child)| {\n+                        stack.extend(neighbors_rev.map(|(edge, child)| {\n                             (\n-                                ReverseTopologicalPass::ExpandAndVisit,\n+                                TopologicalPass::ExpandAndVisit,\n                                 Some((current, edge)),\n                                 GraphNodeIndex {\n                                     graph_idx: current.graph_idx,\n@@ -1277,11 +1278,3 @@ impl Visit<SingleModuleGraphBuilderNode> for SingleModuleGraphBuilder<'_> {\n         }\n     }\n }\n-\n-fn iter_neighbors<N, E>(\n-    graph: &DiGraph<N, E>,\n-    node: NodeIndex,\n-) -> impl Iterator<Item = (EdgeIndex, NodeIndex)> + '_ {\n-    let mut walker = graph.neighbors(node).detach();\n-    std::iter::from_fn(move || walker.next(graph))\n-}"
        },
        {
            "sha": "2f51933591a7c5484e614166b577dc16e37dfd95",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/traced_di_graph.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Ftraced_di_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Ftraced_di_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Ftraced_di_graph.rs?ref=9b994bf80ecc6188faf527a057f93119d522384e",
            "patch": "@@ -1,6 +1,6 @@\n use std::ops::Deref;\n \n-use petgraph::graph::DiGraph;\n+use petgraph::graph::{DiGraph, EdgeIndex, NodeIndex};\n use serde::{Deserialize, Serialize};\n use turbo_tasks::{\n     debug::ValueDebugFormat,\n@@ -50,3 +50,12 @@ where\n     E: NonLocalValue,\n {\n }\n+\n+/// Iterate the edges of a node REVERSED!\n+pub fn iter_neighbors_rev<N, E>(\n+    graph: &DiGraph<N, E>,\n+    node: NodeIndex,\n+) -> impl Iterator<Item = (EdgeIndex, NodeIndex)> + '_ {\n+    let mut walker = graph.neighbors(node).detach();\n+    std::iter::from_fn(move || walker.next(graph))\n+}"
        },
        {
            "sha": "2d49a0f261691bbdcb2a0078217c81d31305e9ac",
            "filename": "turbopack/crates/turbopack-core/src/reference/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs?ref=9b994bf80ecc6188faf527a057f93119d522384e",
            "patch": "@@ -323,7 +323,7 @@ pub async fn all_assets_from_entries(entries: Vc<OutputAssets>) -> Result<Vc<Out\n             .await\n             .completed()?\n             .into_inner()\n-            .into_reverse_topological()\n+            .into_postorder_topological()\n             .collect(),\n     ))\n }"
        },
        {
            "sha": "b708f9c3ca4eb44f014783526ab1e3dbc468e0a2",
            "filename": "turbopack/crates/turbopack-node/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9b994bf80ecc6188faf527a057f93119d522384e/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Flib.rs?ref=9b994bf80ecc6188faf527a057f93119d522384e",
            "patch": "@@ -166,7 +166,7 @@ async fn separate_assets_operation(\n     let mut internal_assets = FxIndexSet::default();\n     let mut external_asset_entrypoints = FxIndexSet::default();\n \n-    for item in graph.into_reverse_topological() {\n+    for item in graph.into_postorder_topological() {\n         match item {\n             Type::Internal(asset) => {\n                 internal_assets.insert(asset);"
        }
    ],
    "stats": {
        "total": 192,
        "additions": 99,
        "deletions": 93
    }
}