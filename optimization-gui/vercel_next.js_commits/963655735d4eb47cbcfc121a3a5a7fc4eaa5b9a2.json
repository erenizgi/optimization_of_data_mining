{
    "author": "lukesandberg",
    "message": "[turbopack] Improve handling of symlink resolution errors in track_glob and read_glob (#83357)\n\n# Improve symlink handling in turbo-tasks-fs\n\nThis PR enhances symlink handling in the filesystem layer to better handle error cases and provide more detailed error messages. The key changes include:\n\n- Refactored `realpath_with_links` to return a more structured error instead of silently returning the input path when hitting a resolution error\n    - propagate this through the callers\n- Improved `DirectoryEntry::Error` to include error messages instead of just signaling an error occurred\n- Enhanced `resolve_symlink()` to handle more edge cases like dead symlinks\n\nThese changes make the system more robust when dealing with complex symlink scenarios, including symlink loops, dead links, and excessive symlink chains.\n\nA few customers have hit errors where broad tailwind globs cause turbopack to navigate through symlinks that trigger crashes, this is due a a few reasons:\n* a symlink pointing at a non-existent file.\n* a symlink pointing outside the filesystem root\n\nThis can happen with certain package managers and we need to be defensive.  For `track_glob` we just want to track matching files and directories, but we don't want to navigate out of the filesystem so just ignore links that trigger these conditions.\n\nCloses PACK-5383\n\nOne interesting thing is that `read_glob` does not resolve symlinks, and therefore doesn't trigger the errors, that behavior is unchanged.",
    "sha": "963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2",
    "files": [
        {
            "sha": "9055852bb8ec8d605680d3b95b245c8042f5b1ca",
            "filename": "crates/next-core/src/pages_structure.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/crates%2Fnext-core%2Fsrc%2Fpages_structure.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/crates%2Fnext-core%2Fsrc%2Fpages_structure.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fpages_structure.rs?ref=963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2",
            "patch": "@@ -106,11 +106,11 @@ pub async fn find_pages_structure(\n     page_extensions: Vc<Vec<RcStr>>,\n     next_mode: Vc<crate::mode::NextMode>,\n ) -> Result<Vc<PagesStructure>> {\n-    let pages_root = project_root.join(\"pages\")?.realpath().owned().await?;\n+    let pages_root = project_root.join(\"pages\")?.realpath().await?;\n     let pages_root = if *pages_root.get_type().await? == FileSystemEntryType::Directory {\n         Some(pages_root)\n     } else {\n-        let src_pages_root = project_root.join(\"src/pages\")?.realpath().owned().await?;\n+        let src_pages_root = project_root.join(\"src/pages\")?.realpath().await?;\n         if *src_pages_root.get_type().await? == FileSystemEntryType::Directory {\n             Some(src_pages_root)\n         } else {"
        },
        {
            "sha": "b4dda30448599606fbf2aa2cf7cbb099ec5b8558",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 108,
            "deletions": 48,
            "changes": 156,
            "blob_url": "https://github.com/vercel/next.js/blob/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2",
            "patch": "@@ -1383,8 +1383,14 @@ impl FileSystemPath {\n         self.fs().metadata(self.clone())\n     }\n \n-    pub fn realpath(&self) -> Vc<FileSystemPath> {\n-        self.realpath_with_links().path()\n+    // Returns the realpath to the file, resolving all symlinks and reporting an error if the path\n+    // is invalid.\n+    pub async fn realpath(&self) -> Result<FileSystemPath> {\n+        let result = &(*self.realpath_with_links().await?);\n+        match &result.path_or_error {\n+            Ok(path) => Ok(path.clone()),\n+            Err(error) => Err(anyhow::anyhow!(error.as_error_message(self, result))),\n+        }\n     }\n \n     pub fn rebase(\n@@ -1443,15 +1449,37 @@ impl ValueToString for FileSystemPath {\n #[derive(Clone, Debug)]\n #[turbo_tasks::value(shared)]\n pub struct RealPathResult {\n-    pub path: FileSystemPath,\n+    pub path_or_error: Result<FileSystemPath, RealPathResultError>,\n     pub symlinks: Vec<FileSystemPath>,\n }\n \n-#[turbo_tasks::value_impl]\n-impl RealPathResult {\n-    #[turbo_tasks::function]\n-    pub fn path(&self) -> Vc<FileSystemPath> {\n-        self.path.clone().cell()\n+/// Errors that can occur when resolving a path with symlinks.\n+/// Many of these can be transient conditions that might happen when package managers are running.\n+#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize, NonLocalValue, TraceRawVcs)]\n+pub enum RealPathResultError {\n+    TooManySymlinks,\n+    CycleDetected,\n+    Invalid,\n+    NotFound,\n+}\n+impl RealPathResultError {\n+    /// Formats the error message\n+    pub fn as_error_message(&self, orig: &FileSystemPath, result: &RealPathResult) -> String {\n+        match self {\n+            RealPathResultError::TooManySymlinks => format!(\n+                \"Symlink {orig} leads to too many other symlinks ({len} links)\",\n+                len = result.symlinks.len()\n+            ),\n+            RealPathResultError::CycleDetected => {\n+                format!(\"Symlink {orig} is in a symlink loop: {:?}\", result.symlinks)\n+            }\n+            RealPathResultError::Invalid => {\n+                format!(\"Symlink {orig} is invalid, it points out of the filesystem root\")\n+            }\n+            RealPathResultError::NotFound => {\n+                format!(\"Symlink {orig} is invalid, it points at a file that doesn't exist\")\n+            }\n+        }\n     }\n }\n \n@@ -1618,7 +1646,9 @@ pub enum LinkContent {\n     // link because there is only **dist** path in `fn write_link`, and we need the raw path if\n     // we want to restore the link value in `fn write_link`\n     Link { target: RcStr, link_type: LinkType },\n+    // Invalid means the link is invalid it points out of the filesystem root\n     Invalid,\n+    // The target was not found\n     NotFound,\n }\n \n@@ -2071,8 +2101,8 @@ pub enum RawDirectoryEntry {\n     File,\n     Directory,\n     Symlink,\n+    // Other just means 'not a file, directory, or symlink'\n     Other,\n-    Error,\n }\n \n #[derive(Hash, Clone, Debug, PartialEq, Eq, TraceRawVcs, Serialize, Deserialize, NonLocalValue)]\n@@ -2081,7 +2111,7 @@ pub enum DirectoryEntry {\n     Directory(FileSystemPath),\n     Symlink(FileSystemPath),\n     Other(FileSystemPath),\n-    Error,\n+    Error(RcStr),\n }\n \n impl DirectoryEntry {\n@@ -2090,12 +2120,28 @@ impl DirectoryEntry {\n     /// `DirectoryEntry::Directory`.\n     pub async fn resolve_symlink(self) -> Result<Self> {\n         if let DirectoryEntry::Symlink(symlink) = &self {\n-            let real_path = symlink.realpath().owned().await?;\n-            match *real_path.get_type().await? {\n-                FileSystemEntryType::Directory => Ok(DirectoryEntry::Directory(real_path)),\n-                FileSystemEntryType::File => Ok(DirectoryEntry::File(real_path)),\n-                _ => Ok(self),\n-            }\n+            let result = &*symlink.realpath_with_links().await?;\n+            let real_path = match &result.path_or_error {\n+                Ok(path) => path,\n+                Err(error) => {\n+                    return Ok(DirectoryEntry::Error(\n+                        error.as_error_message(symlink, result).into(),\n+                    ));\n+                }\n+            };\n+            Ok(match *real_path.get_type().await? {\n+                FileSystemEntryType::Directory => DirectoryEntry::Directory(real_path.clone()),\n+                FileSystemEntryType::File => DirectoryEntry::File(real_path.clone()),\n+                // Happens if the link is to a non-existent file\n+                FileSystemEntryType::NotFound => DirectoryEntry::Error(\n+                    format!(\"Symlink {symlink} points at {real_path} which does not exist\").into(),\n+                ),\n+                FileSystemEntryType::Symlink => bail!(\n+                    \"Symlink {symlink} points at a symlink but realpath_with_links returned a \\\n+                     path, this is caused by eventual consistency.\"\n+                ),\n+                _ => self,\n+            })\n         } else {\n             Ok(self)\n         }\n@@ -2107,7 +2153,7 @@ impl DirectoryEntry {\n             | DirectoryEntry::Directory(path)\n             | DirectoryEntry::Symlink(path)\n             | DirectoryEntry::Other(path) => Some(path),\n-            DirectoryEntry::Error => None,\n+            DirectoryEntry::Error(_) => None,\n         }\n     }\n }\n@@ -2119,6 +2165,7 @@ pub enum FileSystemEntryType {\n     File,\n     Directory,\n     Symlink,\n+    /// These would be things like named pipes, sockets, etc.\n     Other,\n     Error,\n }\n@@ -2147,7 +2194,7 @@ impl From<&DirectoryEntry> for FileSystemEntryType {\n             DirectoryEntry::Directory(_) => FileSystemEntryType::Directory,\n             DirectoryEntry::Symlink(_) => FileSystemEntryType::Symlink,\n             DirectoryEntry::Other(_) => FileSystemEntryType::Other,\n-            DirectoryEntry::Error => FileSystemEntryType::Error,\n+            DirectoryEntry::Error(_) => FileSystemEntryType::Error,\n         }\n     }\n }\n@@ -2165,7 +2212,6 @@ impl From<&RawDirectoryEntry> for FileSystemEntryType {\n             RawDirectoryEntry::Directory => FileSystemEntryType::Directory,\n             RawDirectoryEntry::Symlink => FileSystemEntryType::Symlink,\n             RawDirectoryEntry::Other => FileSystemEntryType::Other,\n-            RawDirectoryEntry::Error => FileSystemEntryType::Error,\n         }\n     }\n }\n@@ -2290,7 +2336,6 @@ async fn read_dir(path: FileSystemPath) -> Result<Vc<DirectoryContent>> {\n                     RawDirectoryEntry::Directory => DirectoryEntry::Directory(entry_path),\n                     RawDirectoryEntry::Symlink => DirectoryEntry::Symlink(entry_path),\n                     RawDirectoryEntry::Other => DirectoryEntry::Other(entry_path),\n-                    RawDirectoryEntry::Error => DirectoryEntry::Error,\n                 };\n                 normalized_entries.insert(name.clone(), entry);\n             }\n@@ -2321,64 +2366,79 @@ async fn get_type(path: FileSystemPath) -> Result<Vc<FileSystemEntryType>> {\n \n #[turbo_tasks::function]\n async fn realpath_with_links(path: FileSystemPath) -> Result<Vc<RealPathResult>> {\n-    let mut current_vc = path.clone();\n+    let mut current_path = path;\n     let mut symlinks: IndexSet<FileSystemPath> = IndexSet::new();\n     let mut visited: AutoSet<RcStr> = AutoSet::new();\n+    let mut error = RealPathResultError::TooManySymlinks;\n     // Pick some arbitrary symlink depth limit... similar to the ELOOP logic for realpath(3).\n     // SYMLOOP_MAX is 40 for Linux: https://unix.stackexchange.com/q/721724\n     for _i in 0..40 {\n-        let current = current_vc.clone();\n-        if current.is_root() {\n+        if current_path.is_root() {\n             // fast path\n             return Ok(RealPathResult {\n-                path: current_vc,\n+                path_or_error: Ok(current_path),\n                 symlinks: symlinks.into_iter().collect(),\n             }\n             .cell());\n         }\n \n-        if !visited.insert(current.path.clone()) {\n+        if !visited.insert(current_path.path.clone()) {\n+            error = RealPathResultError::CycleDetected;\n             break; // we detected a cycle\n         }\n \n         // see if a parent segment of the path is a symlink and resolve that first\n-        let parent = current_vc.parent();\n+        let parent = current_path.parent();\n         let parent_result = parent.realpath_with_links().owned().await?;\n-        let basename = current\n+        let basename = current_path\n             .path\n             .rsplit_once('/')\n-            .map_or(current.path.as_str(), |(_, name)| name);\n-        if parent_result.path != parent {\n-            current_vc = parent_result.path.join(basename)?;\n-        }\n+            .map_or(current_path.path.as_str(), |(_, name)| name);\n         symlinks.extend(parent_result.symlinks);\n+        let parent_path = match parent_result.path_or_error {\n+            Ok(path) => {\n+                if path != parent {\n+                    current_path = path.join(basename)?;\n+                }\n+                path\n+            }\n+            Err(parent_error) => {\n+                error = parent_error;\n+                break;\n+            }\n+        };\n \n         // use `get_type` before trying `read_link`, as there's a good chance of a cache hit on\n         // `get_type`, and `read_link` isn't the common codepath.\n-        if !matches!(*current_vc.get_type().await?, FileSystemEntryType::Symlink) {\n+        if !matches!(\n+            *current_path.get_type().await?,\n+            FileSystemEntryType::Symlink\n+        ) {\n             return Ok(RealPathResult {\n-                path: current_vc,\n+                path_or_error: Ok(current_path),\n                 symlinks: symlinks.into_iter().collect(), // convert set to vec\n             }\n             .cell());\n         }\n \n-        if let LinkContent::Link { target, link_type } = &*current_vc.read_link().await? {\n-            symlinks.insert(current_vc.clone());\n-            current_vc = if link_type.contains(LinkType::ABSOLUTE) {\n-                current_vc.root().owned().await?\n-            } else {\n-                parent_result.path\n+        match &*current_path.read_link().await? {\n+            LinkContent::Link { target, link_type } => {\n+                symlinks.insert(current_path.clone());\n+                current_path = if link_type.contains(LinkType::ABSOLUTE) {\n+                    current_path.root().owned().await?\n+                } else {\n+                    parent_path\n+                }\n+                .join(target)?;\n             }\n-            .join(target)?;\n-        } else {\n-            // get_type() and read_link() might disagree temporarily due to turbo-tasks\n-            // eventual consistency or if the file gets invalidated before the directory does\n-            return Ok(RealPathResult {\n-                path: current_vc,\n-                symlinks: symlinks.into_iter().collect(), // convert set to vec\n+            LinkContent::NotFound => {\n+                error = RealPathResultError::NotFound;\n+                break;\n+            }\n+            LinkContent::Invalid => {\n+                error = RealPathResultError::Invalid;\n+                break;\n             }\n-            .cell());\n         }\n     }\n \n@@ -2390,7 +2450,7 @@ async fn realpath_with_links(path: FileSystemPath) -> Result<Vc<RealPathResult>>\n     // Returning the followed symlinks is still important, even if there is an error! Otherwise\n     // we may never notice if the symlink loop is fixed.\n     Ok(RealPathResult {\n-        path,\n+        path_or_error: Err(error),\n         symlinks: symlinks.into_iter().collect(),\n     }\n     .cell())"
        },
        {
            "sha": "28a9a08599299c3a0c5604641827b91406105a90",
            "filename": "turbopack/crates/turbo-tasks-fs/src/read_glob.rs",
            "status": "modified",
            "additions": 105,
            "deletions": 7,
            "changes": 112,
            "blob_url": "https://github.com/vercel/next.js/blob/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs?ref=963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2",
            "patch": "@@ -99,7 +99,7 @@ async fn read_glob_internal(\n                             }\n                         }\n                     }\n-                    DirectoryEntry::Other(_) | DirectoryEntry::Error => continue,\n+                    DirectoryEntry::Other(_) | DirectoryEntry::Error(_) => continue,\n                 }\n             }\n         }\n@@ -198,9 +198,9 @@ async fn track_glob_internal(\n                         }\n                     }\n                     DirectoryEntry::Symlink(symlink_path) => bail!(\n-                        \"resolve_symlink_safely() should have resolved all symlinks, but found \\\n-                         unresolved symlink at path: '{}'. Found path: '{}'. Please report this \\\n-                         as a bug.\",\n+                        \"resolve_symlink_safely() should have resolved all symlinks or returned \\\n+                         an error, but found unresolved symlink at path: '{}'. Found path: '{}'. \\\n+                         Please report this as a bug.\",\n                         entry_path,\n                         symlink_path\n                     ),\n@@ -209,7 +209,11 @@ async fn track_glob_internal(\n                             types.push(path.get_type())\n                         }\n                     }\n-                    DirectoryEntry::Error => {}\n+                    // The most likely case of this is actually a sylink resolution error, it is\n+                    // fine to ignore since the mere act of attempting to resolve it has triggered\n+                    // the ncecessary dependencies.  If this file is actually a dependency we should\n+                    // get an error in the actual webpack loader when it reads it.\n+                    DirectoryEntry::Error(_) => {}\n                 }\n             }\n         }\n@@ -524,8 +528,6 @@ pub mod tests {\n         ));\n         let path: RcStr = scratch.path().to_str().unwrap().into();\n         tt.run_once(async {\n-            use turbo_rcstr::rcstr;\n-\n             let fs = Vc::upcast::<Box<dyn FileSystem>>(DiskFileSystem::new(rcstr!(\"temp\"), path));\n             let err = fs\n                 .root()\n@@ -558,6 +560,102 @@ pub mod tests {\n         .unwrap();\n     }\n \n+    // Reproduces an issue where a dead symlink would cause a panic when tracking/reading a glob\n+    #[cfg(unix)]\n+    #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+    async fn dead_symlinks() {\n+        let scratch = tempfile::tempdir().unwrap();\n+        {\n+            use std::os::unix::fs::symlink;\n+\n+            // Create a simple directory with 1 file and a symlink pointing at a non-existent file\n+            let path = scratch.path();\n+            let sub = &path.join(\"sub\");\n+            create_dir(sub).unwrap();\n+            let foo = sub.join(\"foo.js\");\n+            File::create_new(&foo).unwrap().write_all(b\"foo\").unwrap();\n+            // put a link in sub that points to a sibling file that doesn't exist\n+            symlink(sub.join(\"doesntexist.js\"), sub.join(\"dead_link.js\")).unwrap();\n+        }\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        let path: RcStr = scratch.path().to_str().unwrap().into();\n+        tt.run_once(async {\n+            let fs = Vc::upcast::<Box<dyn FileSystem>>(DiskFileSystem::new(rcstr!(\"temp\"), path));\n+            fs.root()\n+                .await?\n+                .track_glob(Glob::new(rcstr!(\"sub/*.js\"), GlobOptions::default()), false)\n+                .await\n+        })\n+        .await\n+        .unwrap();\n+        let path: RcStr = scratch.path().to_str().unwrap().into();\n+        tt.run_once(async {\n+            let fs = Vc::upcast::<Box<dyn FileSystem>>(DiskFileSystem::new(rcstr!(\"temp\"), path));\n+            let root = fs.root().owned().await?;\n+            let read_dir = root\n+                .read_glob(Glob::new(rcstr!(\"sub/*.js\"), GlobOptions::default()))\n+                .await?;\n+            assert_eq!(read_dir.results.len(), 0);\n+            assert_eq!(read_dir.inner.len(), 1);\n+            let inner_sub = &*read_dir.inner.get(\"sub\").unwrap().await?;\n+            assert_eq!(inner_sub.inner.len(), 0);\n+            assert_eq!(\n+                inner_sub.results,\n+                HashMap::from_iter([\n+                    (\n+                        \"foo.js\".into(),\n+                        DirectoryEntry::File(root.join(\"sub/foo.js\")?),\n+                    ),\n+                    // read_glob doesn't resolve symlinks and thus doesn't detect that it is dead\n+                    (\n+                        \"dead_link.js\".into(),\n+                        DirectoryEntry::Symlink(root.join(\"sub/dead_link.js\")?),\n+                    )\n+                ])\n+            );\n+\n+            anyhow::Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n+\n+    // Reproduces an issue where a dead symlink would cause a panic when tracking/reading a glob\n+    #[cfg(unix)]\n+    #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+    async fn symlink_escapes_fs_root() {\n+        let scratch = tempfile::tempdir().unwrap();\n+        {\n+            use std::os::unix::fs::symlink;\n+\n+            // Create a simple directory with 1 file and a symlink pointing at a non-existent file\n+            let path = scratch.path();\n+            let sub = &path.join(\"sub\");\n+            create_dir(sub).unwrap();\n+            let foo = scratch.path().join(\"foo.js\");\n+            File::create_new(&foo).unwrap().write_all(b\"foo\").unwrap();\n+            // put a link in sub that points to a parent file\n+            symlink(foo, sub.join(\"escape.js\")).unwrap();\n+        }\n+        let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        let root: RcStr = scratch.path().join(\"sub\").to_str().unwrap().into();\n+        tt.run_once(async {\n+            let fs = Vc::upcast::<Box<dyn FileSystem>>(DiskFileSystem::new(rcstr!(\"temp\"), root));\n+            fs.root()\n+                .await?\n+                .track_glob(Glob::new(rcstr!(\"*.js\"), GlobOptions::default()), false)\n+                .await\n+        })\n+        .await\n+        .unwrap();\n+    }\n+\n     #[cfg(unix)]\n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n     async fn read_glob_symlinks_loop() {"
        },
        {
            "sha": "24da2ddb81ada903a5ad3da460a229e1ca800700",
            "filename": "turbopack/crates/turbopack-core/src/node_addon_module.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fnode_addon_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fnode_addon_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fnode_addon_module.rs?ref=963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2",
            "patch": "@@ -1,6 +1,6 @@\n use std::sync::LazyLock;\n \n-use anyhow::Result;\n+use anyhow::{Result, bail};\n use regex::Regex;\n use turbo_rcstr::rcstr;\n use turbo_tasks::{FxIndexSet, ResolvedVc, TryJoinIterExt, Vc};\n@@ -121,7 +121,12 @@ async fn dir_references(package_dir: FileSystemPath) -> Result<Vc<ModuleReferenc\n             PatternMatch::File(_, file) => {\n                 let realpath = file.realpath_with_links().await?;\n                 results.extend(realpath.symlinks.iter().cloned());\n-                results.insert(realpath.path.clone());\n+                match &realpath.path_or_error {\n+                    Ok(path) => {\n+                        results.insert(path.clone());\n+                    }\n+                    Err(e) => bail!(e.as_error_message(file, &realpath)),\n+                }\n             }\n             PatternMatch::Directory(..) => {}\n         }"
        },
        {
            "sha": "90d5d2de6fbfe90bc0b1e99b6b578a18cb708929",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 22,
            "deletions": 9,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2",
            "patch": "@@ -15,7 +15,7 @@ use turbo_tasks::{\n     FxIndexMap, FxIndexSet, NonLocalValue, ReadRef, ResolvedVc, SliceMap, TaskInput,\n     TryJoinIterExt, ValueToString, Vc, trace::TraceRawVcs,\n };\n-use turbo_tasks_fs::{FileSystemEntryType, FileSystemPath, RealPathResult};\n+use turbo_tasks_fs::{FileSystemEntryType, FileSystemPath};\n use turbo_unix_path::normalize_request;\n \n use self::{\n@@ -1172,20 +1172,23 @@ async fn realpath(\n     fs_path: &FileSystemPath,\n     refs: &mut Vec<ResolvedVc<Box<dyn Source>>>,\n ) -> Result<FileSystemPath> {\n-    let result = fs_path.realpath_with_links().owned().await?;\n+    let result = fs_path.realpath_with_links().await?;\n     refs.extend(\n         result\n             .symlinks\n-            .into_iter()\n+            .iter()\n             .map(|path| async move {\n                 Ok(ResolvedVc::upcast(\n-                    FileSource::new(path).to_resolved().await?,\n+                    FileSource::new(path.clone()).to_resolved().await?,\n                 ))\n             })\n             .try_join()\n             .await?,\n     );\n-    Ok(result.path)\n+    match &result.path_or_error {\n+        Ok(path) => Ok(path.clone()),\n+        Err(e) => bail!(e.as_error_message(fs_path, &result)),\n+    }\n }\n \n #[turbo_tasks::value(shared)]\n@@ -1516,11 +1519,16 @@ pub async fn resolve_raw(\n     force_in_lookup_dir: bool,\n ) -> Result<Vc<ResolveResult>> {\n     async fn to_result(request: RcStr, path: FileSystemPath) -> Result<Vc<ResolveResult>> {\n-        let RealPathResult { path, symlinks } = &*path.realpath_with_links().await?;\n+        let result = &*path.realpath_with_links().await?;\n+        let path = match &result.path_or_error {\n+            Ok(path) => path,\n+            Err(e) => bail!(e.as_error_message(&path, result)),\n+        };\n         Ok(*ResolveResult::source_with_affecting_sources(\n             RequestKey::new(request),\n             ResolvedVc::upcast(FileSource::new(path.clone()).to_resolved().await?),\n-            symlinks\n+            result\n+                .symlinks\n                 .iter()\n                 .map(|symlink| async move {\n                     anyhow::Ok(ResolvedVc::upcast(\n@@ -2864,7 +2872,11 @@ async fn resolved(\n     query: RcStr,\n     fragment: RcStr,\n ) -> Result<Vc<ResolveResult>> {\n-    let RealPathResult { path, symlinks } = &*fs_path.realpath_with_links().await?;\n+    let result = &*fs_path.realpath_with_links().await?;\n+    let path = match &result.path_or_error {\n+        Ok(path) => path,\n+        Err(e) => bail!(e.as_error_message(&fs_path, result)),\n+    };\n \n     let path_ref = path.clone();\n     // Check alias field for path aliases first\n@@ -2908,7 +2920,8 @@ async fn resolved(\n                 .to_resolved()\n                 .await?,\n         ),\n-        symlinks\n+        result\n+            .symlinks\n             .iter()\n             .map(|symlink| async move {\n                 anyhow::Ok(ResolvedVc::upcast("
        },
        {
            "sha": "8a323a5499f9ef5f3f7db22e21b48c13e442ffd9",
            "filename": "turbopack/crates/turbopack-core/src/resolve/pattern.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs?ref=963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2",
            "patch": "@@ -1847,7 +1847,6 @@ pub async fn read_matches(\n                                 prefix.truncate(len)\n                             }\n                             RawDirectoryEntry::Other => {}\n-                            RawDirectoryEntry::Error => {}\n                         }\n                     }\n                 }"
        },
        {
            "sha": "7e27e1f75400edad2fb23a0e9975ca873cf9eccc",
            "filename": "turbopack/crates/turbopack-dev-server/src/source/static_assets.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fstatic_assets.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fstatic_assets.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fstatic_assets.rs?ref=963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2",
            "patch": "@@ -142,7 +142,7 @@ impl Introspectable for StaticAssetsContentSource {\n                             .to_resolved()\n                             .await?,\n                         ),\n-                        DirectoryEntry::Other(_) | DirectoryEntry::Error => {\n+                        DirectoryEntry::Other(_) | DirectoryEntry::Error(_) => {\n                             todo!(\"unsupported DirectoryContent variant: {entry:?}\")\n                         }\n                     };"
        },
        {
            "sha": "b50012b714a950263c9cf21a9287cf16b45fd2a9",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/node.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs?ref=963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2",
            "patch": "@@ -1,4 +1,4 @@\n-use anyhow::Result;\n+use anyhow::{Result, bail};\n use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n@@ -124,10 +124,14 @@ async fn resolve_reference_from_dir(\n                         FileSource::new(symlink.clone()).to_resolved().await?,\n                     ));\n                 }\n+                let path: FileSystemPath = match &realpath.path_or_error {\n+                    Ok(path) => path.clone(),\n+                    Err(e) => bail!(e.as_error_message(file, &realpath)),\n+                };\n                 results.push((\n                     RequestKey::new(matched_path.clone()),\n                     ResolvedVc::upcast(\n-                        RawModule::new(Vc::upcast(FileSource::new(realpath.path.clone())))\n+                        RawModule::new(Vc::upcast(FileSource::new(path)))\n                             .to_resolved()\n                             .await?,\n                     ),"
        },
        {
            "sha": "4e26cb686fde0625c14b002b8964371e321cf9da",
            "filename": "turbopack/crates/turbopack-resolve/src/node_native_binding.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs?ref=963655735d4eb47cbcfc121a3a5a7fc4eaa5b9a2",
            "patch": "@@ -1,6 +1,6 @@\n use std::sync::LazyLock;\n \n-use anyhow::Result;\n+use anyhow::{Result, bail};\n use regex::Regex;\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::{RcStr, rcstr};\n@@ -185,7 +185,10 @@ pub async fn resolve_node_pre_gyp_files(\n                         }\n                         sources.insert(\n                             format!(\"deps/lib/{key}\").into(),\n-                            Vc::upcast(FileSource::new(realpath_with_links.path.clone())),\n+                            Vc::upcast(FileSource::new(match &realpath_with_links.path_or_error {\n+                                Ok(path) => path.clone(),\n+                                Err(e) => bail!(e.as_error_message(dylib, &realpath_with_links)),\n+                            })),\n                         );\n                     }\n                     _ => {}"
        }
    ],
    "stats": {
        "total": 330,
        "additions": 256,
        "deletions": 74
    }
}