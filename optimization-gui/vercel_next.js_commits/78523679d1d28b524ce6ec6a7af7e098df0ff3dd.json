{
    "author": "sokra",
    "message": "Turbopack: only invalidate removed cells once (#77936)\n\n### What?\n\nWhen cells are removed, dependents on these cells should be invalidated.\nBut we want to make sure to invalidate them only once (when the cells are removed), otherwise we could end up in an invalidation cycle, since dependents are only removed when the dependent tasks is finished.",
    "sha": "78523679d1d28b524ce6ec6a7af7e098df0ff3dd",
    "files": [
        {
            "sha": "ebd28f41a63ef371f06977e495cbb39f3efb99f0",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 10,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/78523679d1d28b524ce6ec6a7af7e098df0ff3dd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/78523679d1d28b524ce6ec6a7af7e098df0ff3dd/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=78523679d1d28b524ce6ec6a7af7e098df0ff3dd",
            "patch": "@@ -1332,10 +1332,11 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         }\n \n         // handle cell counters: update max index and remove cells that are no longer used\n-        let mut old_counters: FxHashMap<_, _> =\n+        let old_counters: FxHashMap<_, _> =\n             get_many!(task, CellTypeMaxIndex { cell_type } max_index => (cell_type, *max_index));\n+        let mut counters_to_remove = old_counters.clone();\n         for (&cell_type, &max_index) in cell_counters.iter() {\n-            if let Some(old_max_index) = old_counters.remove(&cell_type) {\n+            if let Some(old_max_index) = counters_to_remove.remove(&cell_type) {\n                 if old_max_index != max_index {\n                     task.insert(CachedDataItem::CellTypeMaxIndex {\n                         cell_type,\n@@ -1349,7 +1350,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 });\n             }\n         }\n-        for (cell_type, _) in old_counters {\n+        for (cell_type, _) in counters_to_remove {\n             task.remove(&CachedDataItemKey::CellTypeMaxIndex { cell_type });\n         }\n \n@@ -1404,14 +1405,17 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                             .get(&cell.type_id)\n                             .is_none_or(|start_index| cell.index >= *start_index)\n                         {\n-                            Some(OutdatedEdge::RemovedCellDependent {\n-                                task_id: task,\n-                                #[cfg(feature = \"trace_task_dirty\")]\n-                                value_type_id: cell.type_id,\n-                            })\n-                        } else {\n-                            None\n+                            if let Some(old_counter) = old_counters.get(&cell.type_id) {\n+                                if cell.index < *old_counter {\n+                                    return Some(OutdatedEdge::RemovedCellDependent {\n+                                        task_id: task,\n+                                        #[cfg(feature = \"trace_task_dirty\")]\n+                                        value_type_id: cell.type_id,\n+                                    });\n+                                }\n+                            }\n                         }\n+                        None\n                     },\n                 ),\n             );"
        }
    ],
    "stats": {
        "total": 24,
        "additions": 14,
        "deletions": 10
    }
}