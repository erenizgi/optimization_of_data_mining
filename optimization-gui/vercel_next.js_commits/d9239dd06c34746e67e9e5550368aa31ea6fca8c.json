{
    "author": "sokra",
    "message": "Turbopack: assign a high aggregation number to session dependent tasks (#78668)\n\n### What?\n\nThis is important to avoid high number of aggregated tasks that need to be restored on a new session. By keeping the session dependent tasks high in the aggregation graph, they are cheaper to restore.",
    "sha": "d9239dd06c34746e67e9e5550368aa31ea6fca8c",
    "files": [
        {
            "sha": "de63acd9826bd919c415f329e85dca9e611e4ee5",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 18,
            "deletions": 2,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/d9239dd06c34746e67e9e5550368aa31ea6fca8c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/d9239dd06c34746e67e9e5550368aa31ea6fca8c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=d9239dd06c34746e67e9e5550368aa31ea6fca8c",
            "patch": "@@ -2031,15 +2031,31 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n     fn mark_own_task_as_session_dependent(\n         &self,\n-        task: TaskId,\n+        task_id: TaskId,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n         if !self.should_track_dependencies() {\n             // Without dependency tracking we don't need session dependent tasks\n             return;\n         }\n+        const SESSION_DEPENDENT_AGGREGATION_NUMBER: u32 = u32::MAX >> 2;\n         let mut ctx = self.execute_context(turbo_tasks);\n-        let mut task = ctx.task(task, TaskDataCategory::Data);\n+        let mut task = ctx.task(task_id, TaskDataCategory::Meta);\n+        let aggregation_number = get_aggregation_number(&task);\n+        if aggregation_number < SESSION_DEPENDENT_AGGREGATION_NUMBER {\n+            drop(task);\n+            // We want to use a high aggregation number to avoid large aggregation chains for\n+            // session dependent tasks (which change on every run)\n+            AggregationUpdateQueue::run(\n+                AggregationUpdateJob::UpdateAggregationNumber {\n+                    task_id,\n+                    base_aggregation_number: SESSION_DEPENDENT_AGGREGATION_NUMBER,\n+                    distance: None,\n+                },\n+                &mut ctx,\n+            );\n+            task = ctx.task(task_id, TaskDataCategory::Meta);\n+        }\n         if let Some(InProgressState::InProgress(box InProgressStateInner {\n             session_dependent,\n             .."
        }
    ],
    "stats": {
        "total": 20,
        "additions": 18,
        "deletions": 2
    }
}