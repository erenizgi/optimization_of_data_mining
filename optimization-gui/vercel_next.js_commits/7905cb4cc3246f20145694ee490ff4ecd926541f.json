{
    "author": "mischnic",
    "message": "Turbopack: write symlinks to access transitive `serverExternalPackages`\n (#86375)\n\nCloses PACK-5936\n\nThis alleviates a long-standing painpoint of `serverExternalPackages`. If you are using\n`some-utility` which uses `lodash`, and you have to make `lodash` a `serverExternalPackages`, then\nyou'd have to add the correct version of `lodash` to your application's dependencies in package.json.\n\nThis is not very ergonomic as it leaks the internal implementation of your direct dependencies (you\nshoudln't have to care about their transitive dependencies). And it's easy to run into a situation\nwhere it's impossible to satisfy all dependencies, if you'd have to add two conflicting versions of `lodash` for example.\n\nInstead, Turbopack now emits symlinks like\n\n```\n.next/node_modules/lodash-98e63531e9336dd0@ -> ../../../../node_modules/.pnpm/lodash@4.17.20/node_modules/lodash\n.next/node_modules/lodash-ee4fa714b6d81ca3@ -> ../../../../node_modules/.pnpm/lodash@3.10.1/node_modules/lodash\n```\n\n.so that `.next/server/chunks/29adj2sd9.js` can then contain a `require(\"lodash-98e63531e9336dd0\")`\nand alway get the correct version (and without the user having to declare them).",
    "sha": "7905cb4cc3246f20145694ee490ff4ecd926541f",
    "files": [
        {
            "sha": "8de16818065def549e73492da18594c1e3e0a475",
            "filename": "crates/next-core/src/next_server/context.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fcontext.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fcontext.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fcontext.rs?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -199,7 +199,6 @@ pub async fn get_server_resolve_options_context(\n     external_packages.retain(|item| !transpiled_packages.contains(item));\n \n     let server_external_packages_plugin = ExternalCjsModulesResolvePlugin::new(\n-        project_path.clone(),\n         project_path.root().owned().await?,\n         ExternalPredicate::Only(ResolvedVc::cell(external_packages)).cell(),\n         *next_config.import_externals().await?,\n@@ -225,7 +224,6 @@ pub async fn get_server_resolve_options_context(\n         server_external_packages_plugin\n     } else {\n         ExternalCjsModulesResolvePlugin::new(\n-            project_path.clone(),\n             project_path.root().owned().await?,\n             ExternalPredicate::AllExcept(ResolvedVc::cell(transpiled_packages)).cell(),\n             *next_config.import_externals().await?,"
        },
        {
            "sha": "527544653ee4176eb18077a9d371d159edbacc11",
            "filename": "crates/next-core/src/next_server/resolve.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 104,
            "changes": 115,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -41,7 +41,6 @@ pub enum ExternalPredicate {\n /// possible to resolve them at runtime.\n #[turbo_tasks::value]\n pub(crate) struct ExternalCjsModulesResolvePlugin {\n-    project_path: FileSystemPath,\n     root: FileSystemPath,\n     predicate: ResolvedVc<ExternalPredicate>,\n     import_externals: bool,\n@@ -51,13 +50,11 @@ pub(crate) struct ExternalCjsModulesResolvePlugin {\n impl ExternalCjsModulesResolvePlugin {\n     #[turbo_tasks::function]\n     pub fn new(\n-        project_path: FileSystemPath,\n         root: FileSystemPath,\n         predicate: ResolvedVc<ExternalPredicate>,\n         import_externals: bool,\n     ) -> Vc<Self> {\n         ExternalCjsModulesResolvePlugin {\n-            project_path,\n             root,\n             predicate,\n             import_externals,\n@@ -259,104 +256,9 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n             };\n             break result_from_original_location;\n         };\n-        let node_resolved = resolve(\n-            self.project_path.clone(),\n-            reference_type.clone(),\n-            request,\n-            node_resolve_options,\n-        );\n-\n-        let Some(result) = *node_resolved.first_source().await? else {\n-            // this can't resolve with node.js from the project directory, so bundle it\n-            return unable_to_externalize(vec![\n-                StyledString::Text(\n-                    \"The request could not be resolved by Node.js from the project \\\n-                     directory.\\nPackages that should be external need to be installed in the \\\n-                     project directory, so they can be resolved from the output files.\\nTry to \\\n-                     install it into the project directory by running \"\n-                        .into(),\n-                ),\n-                StyledString::Code(format!(\"npm install {package}\").into()),\n-                StyledString::Text(rcstr!(\" from the project directory.\")),\n-            ]);\n-        };\n \n-        if result_from_original_location != result {\n-            let package_json_file =\n-                find_context_file(result.ident().path().await?.parent(), package_json(), false);\n-            let package_json_from_original_location = find_context_file(\n-                result_from_original_location.ident().path().await?.parent(),\n-                package_json(),\n-                false,\n-            );\n-            let FindContextFileResult::Found(package_json_file, _) = &*package_json_file.await?\n-            else {\n-                return unable_to_externalize(vec![StyledString::Text(\n-                    \"The package.json of the package resolved from the project directory can't be \\\n-                     found.\"\n-                        .into(),\n-                )]);\n-            };\n-            let FindContextFileResult::Found(package_json_from_original_location, _) =\n-                &*package_json_from_original_location.await?\n-            else {\n-                return unable_to_externalize(vec![StyledString::Text(rcstr!(\n-                    \"The package.json of the package can't be found.\"\n-                ))]);\n-            };\n-            let FileJsonContent::Content(package_json_file) =\n-                &*package_json_file.read_json().await?\n-            else {\n-                return unable_to_externalize(vec![StyledString::Text(\n-                    \"The package.json of the package resolved from project directory can't be \\\n-                     parsed.\"\n-                        .into(),\n-                )]);\n-            };\n-            let FileJsonContent::Content(package_json_from_original_location) =\n-                &*package_json_from_original_location.read_json().await?\n-            else {\n-                return unable_to_externalize(vec![StyledString::Text(rcstr!(\n-                    \"The package.json of the package can't be parsed.\"\n-                ))]);\n-            };\n-            let (Some(name), Some(version)) = (\n-                package_json_file.get(\"name\").and_then(|v| v.as_str()),\n-                package_json_file.get(\"version\").and_then(|v| v.as_str()),\n-            ) else {\n-                return unable_to_externalize(vec![StyledString::Text(rcstr!(\n-                    \"The package.json of the package has no name or version.\"\n-                ))]);\n-            };\n-            let (Some(name2), Some(version2)) = (\n-                package_json_from_original_location\n-                    .get(\"name\")\n-                    .and_then(|v| v.as_str()),\n-                package_json_from_original_location\n-                    .get(\"version\")\n-                    .and_then(|v| v.as_str()),\n-            ) else {\n-                return unable_to_externalize(vec![StyledString::Text(\n-                    \"The package.json of the package resolved from project directory has no name \\\n-                     or version.\"\n-                        .into(),\n-                )]);\n-            };\n-            if (name, version) != (name2, version2) {\n-                // this can't resolve with node.js from the original location, so bundle it\n-                return unable_to_externalize(vec![StyledString::Text(\n-                    format!(\n-                        \"The package resolves to a different version when requested from the \\\n-                         project directory ({version}) compared to the package requested from the \\\n-                         importing module ({version2}).\\nMake sure to install the same version of \\\n-                         the package in both locations.\"\n-                    )\n-                    .into(),\n-                )]);\n-            }\n-        }\n-        let path = result.ident().path().owned().await?;\n-        let file_type = get_file_type(path.clone(), &path).await?;\n+        let path = result_from_original_location.ident().path().await?;\n+        let file_type = get_file_type((*path).clone(), &path).await?;\n \n         let external_type = match (file_type, is_esm) {\n             (FileType::UnsupportedExtension, _) => {\n@@ -375,18 +277,19 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n             (FileType::CommonJs, false) => ExternalType::CommonJs,\n             (FileType::CommonJs, true) => {\n                 // It would be more efficient to use an CJS external instead of an ESM external,\n-                // but we need to verify if that would be correct (as in resolves to the same file).\n+                // but we need to verify if that would be correct (as in resolves to the same\n+                // file).\n                 let node_resolve_options =\n                     node_cjs_resolve_options(lookup_path.root().owned().await?);\n                 let node_resolved = resolve(\n-                    self.project_path.clone(),\n+                    lookup_path.clone(),\n                     reference_type.clone(),\n                     request,\n                     node_resolve_options,\n                 );\n                 let resolves_equal = if let Some(result) = *node_resolved.first_source().await? {\n                     let cjs_path = result.ident().path().owned().await?;\n-                    cjs_path == path\n+                    cjs_path == *path\n                 } else {\n                     false\n                 };\n@@ -407,7 +310,8 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n             // ecmascript with esm is always external\n             (FileType::EcmaScriptModule, true) => ExternalType::EcmaScriptModule,\n             (FileType::EcmaScriptModule, false) => {\n-                // even with require() this resolves to a ESM, which would break node.js, bundle it\n+                // even with require() this resolves to a ESM, which would break node.js, bundle\n+                // it\n                 return unable_to_externalize(vec![StyledString::Text(\n                     \"The package seems invalid. require() resolves to a EcmaScript module, which \\\n                      would result in an error in Node.js.\"\n@@ -416,11 +320,14 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n             }\n         };\n \n+        let target = result_from_original_location.ident().path().owned().await?;\n+\n         Ok(ResolveResultOption::some(*ResolveResult::primary(\n             ResolveResultItem::External {\n                 name: request_str.into(),\n                 ty: external_type,\n                 traced: ExternalTraced::Traced,\n+                target: Some(target),\n             },\n         )))\n     }"
        },
        {
            "sha": "cbc0c75fda6270deac7c4da2816cbe09467e67fe",
            "filename": "crates/next-core/src/next_shared/resolve.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -254,6 +254,7 @@ impl AfterResolvePlugin for NextExternalResolvePlugin {\n                 name: specifier.clone(),\n                 ty: ExternalType::CommonJs,\n                 traced: ExternalTraced::Traced,\n+                target: None,\n             },\n         ))))\n     }"
        },
        {
            "sha": "0facb2f8c269ddfb2edd99e8263b568745136593",
            "filename": "test/e2e/externals-transitive/app/layout.js",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fapp%2Flayout.js",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fapp%2Flayout.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fexternals-transitive%2Fapp%2Flayout.js?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -0,0 +1,8 @@\n+export default function Root({ children }) {\n+  return (\n+    <html>\n+      <head></head>\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "9f64d88a477e64fa18e160d39ba7f0f5bdca7853",
            "filename": "test/e2e/externals-transitive/app/page.js",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fapp%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fapp%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fexternals-transitive%2Fapp%2Fpage.js?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -0,0 +1,12 @@\n+import depA from 'dep-a'\n+import depB from 'dep-b'\n+\n+export default function page() {\n+  return (\n+    <body>\n+      <p>\n+        depA: {depA}, depB: {depB.join(', ')}\n+      </p>\n+    </body>\n+  )\n+}"
        },
        {
            "sha": "6aee019fc70e0ad6bc7cc31c246181ffb89c8279",
            "filename": "test/e2e/externals-transitive/dep-a/index.js",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fdep-a%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fdep-a%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fexternals-transitive%2Fdep-a%2Findex.js?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -0,0 +1,3 @@\n+import lodash from 'lodash'\n+\n+export default lodash.VERSION"
        },
        {
            "sha": "8b7017f815f05163142eabfeab3c6ad1f85a9cf4",
            "filename": "test/e2e/externals-transitive/dep-a/package.json",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fdep-a%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fdep-a%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fexternals-transitive%2Fdep-a%2Fpackage.json?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -0,0 +1,7 @@\n+{\n+  \"name\": \"dep-a\",\n+  \"version\": \"1.0.0\",\n+  \"dependencies\": {\n+    \"lodash\": \"3.10.1\"\n+  }\n+}"
        },
        {
            "sha": "c4a836abf5e5dec67763c66a87543b420adc815a",
            "filename": "test/e2e/externals-transitive/dep-b/index.js",
            "status": "added",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fdep-b%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fdep-b%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fexternals-transitive%2Fdep-b%2Findex.js?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -0,0 +1,4 @@\n+import lodash from 'lodash'\n+import pkg from 'lodash/package.json'\n+\n+export default [lodash.VERSION, pkg.version]"
        },
        {
            "sha": "aade35e45faa1d418f9c21a04197e701146395fb",
            "filename": "test/e2e/externals-transitive/dep-b/package.json",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fdep-b%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fdep-b%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fexternals-transitive%2Fdep-b%2Fpackage.json?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -0,0 +1,7 @@\n+{\n+  \"name\": \"dep-b\",\n+  \"version\": \"1.0.0\",\n+  \"dependencies\": {\n+    \"lodash\": \"4.17.21\"\n+  }\n+}"
        },
        {
            "sha": "41f56487da2057315fe8a622346ab7796e1a782e",
            "filename": "test/e2e/externals-transitive/externals-transitive.test.ts",
            "status": "added",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fexternals-transitive.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fexternals-transitive.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fexternals-transitive%2Fexternals-transitive.test.ts?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -0,0 +1,63 @@\n+import glob from 'glob'\n+import path from 'path'\n+import fs from 'fs/promises'\n+import { nextTestSetup } from 'e2e-utils'\n+\n+describe('externals-transitive', () => {\n+  const { next, isTurbopack, isNextDeploy, isNextStart } = nextTestSetup({\n+    files: __dirname,\n+    dependencies: require('./package.json').dependencies,\n+  })\n+\n+  it('uses the right version of transitive externals', async () => {\n+    const $ = await next.render$('/')\n+    const body = $('body > p').text().trim()\n+    expect(body).toEqual(`depA: 3.10.1, depB: 4.17.21, 4.17.21`)\n+\n+    if (!isNextDeploy) {\n+      const files = glob.sync('**/*.js', {\n+        cwd: path.join(next.testDir, next.distDir, 'server'),\n+      })\n+      let isLodashBundled = false\n+      for (const file of files) {\n+        const content = await next.readFile(\n+          path.join(next.distDir, 'server', file)\n+        )\n+        isLodashBundled =\n+          isLodashBundled ||\n+          // Code\n+          content.includes('__lodash_hash_undefined__') ||\n+          // Package.json\n+          content.includes('Lodash modular utilities.')\n+      }\n+\n+      if (isTurbopack) {\n+        // Assert that lodash wasn't bundled. Turbopack creates symlinks to be able to access\n+        // transitive dependencies at runtime.\n+        expect(isLodashBundled).toBe(false)\n+\n+        let symlinks = (\n+          await fs.readdir(\n+            path.join(next.testDir, next.distDir, 'node_modules')\n+          )\n+        ).filter((file) => file.startsWith('lodash-'))\n+\n+        expect(symlinks.length).toBeGreaterThanOrEqual(2)\n+\n+        if (isNextStart) {\n+          // Lists the two symlinks in the NFT\n+          const trace = (await next.readJSON(\n+            '.next/server/app/page.js.nft.json'\n+          )) as { files: string[] }\n+\n+          for (let symlink of symlinks) {\n+            expect(trace.files).toContain(`../../node_modules/${symlink}`)\n+          }\n+        }\n+      } else {\n+        // Webpack ends up bundling lodash in dep-a\n+        expect(isLodashBundled).toBe(true)\n+      }\n+    }\n+  })\n+})"
        },
        {
            "sha": "5bde62a7f939d1e89e859d89e858de605a3dfabf",
            "filename": "test/e2e/externals-transitive/next.config.js",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fexternals-transitive%2Fnext.config.js?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -0,0 +1,8 @@\n+module.exports = {\n+  serverExternalPackages: ['lodash'],\n+  experimental: {\n+    turbopackModuleIds: 'named',\n+    turbopackMinify: false,\n+    turbopackScopeHoisting: false,\n+  },\n+}"
        },
        {
            "sha": "6d22f00d66257b0dc45a6b16a3029e185dd2e119",
            "filename": "test/e2e/externals-transitive/package.json",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fe2e%2Fexternals-transitive%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fexternals-transitive%2Fpackage.json?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -0,0 +1,7 @@\n+{\n+  \"dependencies\": {\n+    \"dep-a\": \"file:./dep-a\",\n+    \"dep-b\": \"file:./dep-b\",\n+    \"lodash\": \"3.10.1\"\n+  }\n+}"
        },
        {
            "sha": "7be408c4bb6063f76b78eeb86b5c10221fb4b20a",
            "filename": "test/integration/externals-pages-bundle/test/externals.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fintegration%2Fexternals-pages-bundle%2Ftest%2Fexternals.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fintegration%2Fexternals-pages-bundle%2Ftest%2Fexternals.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fexternals-pages-bundle%2Ftest%2Fexternals.test.ts?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -37,7 +37,7 @@ describe('default', () => {\n         }\n \n         // we don't know the name of the minified `__turbopack_external_require__`, so we just check the content.\n-        expect(allBundles).toContain('\"external-package\"')\n+        expect(allBundles).toMatch(/\"external-package(-[0-9a-f]+)?\"/)\n         expect(allBundles).not.toContain('\"external-package content\"')\n       } else {\n         const output = await fs.readFile("
        },
        {
            "sha": "56be852c7420c4c549f4c29185958870417ab091",
            "filename": "test/production/required-server-files-ssr-404/test/index.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fproduction%2Frequired-server-files-ssr-404%2Ftest%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/test%2Fproduction%2Frequired-server-files-ssr-404%2Ftest%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Frequired-server-files-ssr-404%2Ftest%2Findex.test.ts?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -43,6 +43,7 @@ describe('Required Server Files', () => {\n           if (\n             file === 'server' ||\n             file === 'required-server-files.json' ||\n+            file === 'node_modules' ||\n             requiredFilesManifest.files.includes(join('.next', file))\n           ) {\n             continue"
        },
        {
            "sha": "87fec1865e64fa8c9def4c6ec3ccc9175b3c0ed7",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 34,
            "deletions": 10,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -444,6 +444,9 @@ pub enum ResolveResultItem {\n         name: RcStr,\n         ty: ExternalType,\n         traced: ExternalTraced,\n+        /// The file path to the resolved file. Passing a value will create a symlink in the output\n+        /// root to be able to access potentially transitive dependencies.\n+        target: Option<FileSystemPath>,\n     },\n     Ignore,\n     Error(ResolvedVc<RcStr>),\n@@ -524,10 +527,19 @@ impl ValueToString for ResolveResult {\n                     name: s,\n                     ty,\n                     traced,\n+                    target,\n                 } => {\n                     result.push_str(\"external \");\n                     result.push_str(s);\n-                    write!(result, \" ({ty}, {traced})\")?;\n+                    write!(\n+                        result,\n+                        \" ({ty}, {traced}, {:?})\",\n+                        if let Some(target) = target {\n+                            Some(target.value_to_string().await?)\n+                        } else {\n+                            None\n+                        }\n+                    )?;\n                 }\n                 ResolveResultItem::Ignore => {\n                     result.push_str(\"ignore\");\n@@ -656,8 +668,13 @@ impl ResolveResult {\n                             request,\n                             match item {\n                                 ResolveResultItem::Source(source) => asset_fn(source).await?,\n-                                ResolveResultItem::External { name, ty, traced } => {\n-                                    if traced == ExternalTraced::Traced {\n+                                ResolveResultItem::External {\n+                                    name,\n+                                    ty,\n+                                    traced,\n+                                    target,\n+                                } => {\n+                                    if traced == ExternalTraced::Traced || target.is_some() {\n                                         // Should use map_primary_items instead\n                                         bail!(\"map_module doesn't handle traced externals\");\n                                     }\n@@ -2009,6 +2026,7 @@ async fn resolve_internal_inline(\n                             name: uri,\n                             ty: ExternalType::Url,\n                             traced: ExternalTraced::Untraced,\n+                            target: None,\n                         },\n                     )\n                 }\n@@ -2026,6 +2044,7 @@ async fn resolve_internal_inline(\n                         name: uri,\n                         ty: ExternalType::Url,\n                         traced: ExternalTraced::Untraced,\n+                        target: None,\n                     },\n                 )\n             }\n@@ -2751,13 +2770,17 @@ async fn resolve_import_map_result(\n                 ))\n             }\n         }\n-        ImportMapResult::External { name, ty, traced } => {\n-            Some(*ResolveResult::primary(ResolveResultItem::External {\n-                name: name.clone(),\n-                ty: *ty,\n-                traced: *traced,\n-            }))\n-        }\n+        ImportMapResult::External {\n+            name,\n+            ty,\n+            traced,\n+            target,\n+        } => Some(*ResolveResult::primary(ResolveResultItem::External {\n+            name: name.clone(),\n+            ty: *ty,\n+            traced: *traced,\n+            target: target.clone(),\n+        })),\n         ImportMapResult::AliasExternal {\n             name,\n             ty,\n@@ -2793,6 +2816,7 @@ async fn resolve_import_map_result(\n                         name: name.clone(),\n                         ty: *ty,\n                         traced: *traced,\n+                        target: None,\n                     }))\n                 } else {\n                     None"
        },
        {
            "sha": "8967ec08416aaeebd615fb5703becbae5ab830f6",
            "filename": "turbopack/crates/turbopack-core/src/resolve/options.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -138,6 +138,7 @@ pub enum ReplacedImportMapping {\n         name_override: Option<RcStr>,\n         ty: ExternalType,\n         traced: ExternalTraced,\n+        target: Option<FileSystemPath>,\n     },\n     PrimaryAlternativeExternal {\n         name: Option<RcStr>,\n@@ -198,6 +199,8 @@ impl AliasTemplate for Vc<ImportMapping> {\n                     name_override: name.clone(),\n                     ty: *ty,\n                     traced: *traced,\n+                    // TODO\n+                    target: None,\n                 },\n                 ImportMapping::PrimaryAlternativeExternal {\n                     name,\n@@ -246,12 +249,14 @@ impl AliasTemplate for Vc<ImportMapping> {\n                                 .cloned(),\n                             ty: *ty,\n                             traced: *traced,\n+                            target: None,\n                         }\n                     } else {\n                         ReplacedImportMapping::External {\n                             name_override: None,\n                             ty: *ty,\n                             traced: *traced,\n+                            target: None,\n                         }\n                     }\n                 }\n@@ -410,6 +415,7 @@ pub enum ImportMapResult {\n         name: RcStr,\n         ty: ExternalType,\n         traced: ExternalTraced,\n+        target: Option<FileSystemPath>,\n     },\n     AliasExternal {\n         name: RcStr,\n@@ -433,6 +439,7 @@ async fn import_mapping_to_result(\n             name_override,\n             ty,\n             traced,\n+            target,\n         } => ImportMapResult::External {\n             name: if let Some(name) = name_override {\n                 name.clone()\n@@ -446,6 +453,7 @@ async fn import_mapping_to_result(\n             },\n             ty: *ty,\n             traced: *traced,\n+            target: target.clone(),\n         },\n         ReplacedImportMapping::PrimaryAlternativeExternal {\n             name,"
        },
        {
            "sha": "39d2f691f019ae561a7f541c92fac4611cb8793d",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/external_module.rs",
            "status": "modified",
            "additions": 175,
            "deletions": 18,
            "changes": 193,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -1,17 +1,24 @@\n-use std::{fmt::Display, io::Write};\n+use std::{borrow::Cow, fmt::Display, io::Write};\n \n-use anyhow::Result;\n+use anyhow::{Context, Result};\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{NonLocalValue, ResolvedVc, TaskInput, TryJoinIterExt, Vc, trace::TraceRawVcs};\n-use turbo_tasks_fs::{FileContent, FileSystem, VirtualFileSystem, glob::Glob, rope::RopeBuilder};\n+use turbo_tasks_fs::{\n+    FileContent, FileSystem, FileSystemPath, LinkType, VirtualFileSystem, glob::Glob,\n+    rope::RopeBuilder,\n+};\n+use turbo_tasks_hash::{encode_hex, hash_xxh3_hash64};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::{AsyncModuleInfo, ChunkItem, ChunkType, ChunkableModule, ChunkingContext},\n     ident::{AssetIdent, Layer},\n     module::Module,\n     module_graph::ModuleGraph,\n-    output::OutputAssetsReference,\n+    output::{\n+        OutputAsset, OutputAssets, OutputAssetsReference, OutputAssetsReferences,\n+        OutputAssetsWithReferenced,\n+    },\n     raw_module::RawModule,\n     reference::{ModuleReference, ModuleReferences, TracedModuleReference},\n     reference_type::ReferenceType,\n@@ -84,20 +91,65 @@ impl Display for CachedExternalType {\n #[turbo_tasks::value]\n pub struct CachedExternalModule {\n     request: RcStr,\n+    target: Option<FileSystemPath>,\n     external_type: CachedExternalType,\n     analyze_mode: CachedExternalTracingMode,\n }\n \n+/// For a given package folder inside of node_modules, generate a unique hashed package name.\n+///\n+/// E.g. `/path/to/node_modules/@swc/core` becomes `@swc/core-1149fa2b3c4d5e6f`\n+fn hashed_package_name(folder: &FileSystemPath) -> String {\n+    let hash = encode_hex(hash_xxh3_hash64(&folder.path));\n+\n+    let parent = folder.parent();\n+    let parent = parent.file_name();\n+    let pkg = folder.file_name();\n+    if parent.starts_with('@') {\n+        format!(\"{parent}/{pkg}-{hash}\")\n+    } else {\n+        format!(\"{pkg}-{hash}\")\n+    }\n+}\n+\n+impl CachedExternalModule {\n+    /// Rewrites `self.request` to include the hashed package name if `self.target` is set.\n+    pub fn request(&self) -> Cow<'_, str> {\n+        if let Some(target) = &self.target {\n+            let hashed_package = hashed_package_name(target);\n+\n+            let request = if self.request.starts_with('@') {\n+                // Potentially strip off `@org/...`\n+                self.request.split_once('/').unwrap().1\n+            } else {\n+                &*self.request\n+            };\n+\n+            if let Some((_, subpath)) = request.split_once('/') {\n+                // `pkg/subpath` case\n+                Cow::Owned(format!(\"{hashed_package}/{subpath}\"))\n+            } else {\n+                // `pkg` case\n+                Cow::Owned(hashed_package)\n+            }\n+        } else {\n+            Cow::Borrowed(&*self.request)\n+        }\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl CachedExternalModule {\n     #[turbo_tasks::function]\n     pub fn new(\n         request: RcStr,\n+        target: Option<FileSystemPath>,\n         external_type: CachedExternalType,\n         analyze_mode: CachedExternalTracingMode,\n     ) -> Vc<Self> {\n         Self::cell(CachedExternalModule {\n             request,\n+            target,\n             external_type,\n             analyze_mode,\n         })\n@@ -112,7 +164,16 @@ impl CachedExternalModule {\n                 writeln!(\n                     code,\n                     \"const mod = await {TURBOPACK_EXTERNAL_IMPORT}({});\",\n-                    StringifyJs(&self.request)\n+                    StringifyJs(&self.request())\n+                )?;\n+            }\n+            CachedExternalType::EcmaScriptViaRequire | CachedExternalType::CommonJs => {\n+                let request = self.request();\n+                writeln!(\n+                    code,\n+                    \"const mod = {TURBOPACK_EXTERNAL_REQUIRE}({}, () => require({}));\",\n+                    StringifyJs(&request),\n+                    StringifyJs(&request)\n                 )?;\n             }\n             CachedExternalType::Global => {\n@@ -180,14 +241,6 @@ impl CachedExternalModule {\n                     writeln!(code, \"const mod = undefined;\")?;\n                 }\n             }\n-            CachedExternalType::EcmaScriptViaRequire | CachedExternalType::CommonJs => {\n-                writeln!(\n-                    code,\n-                    \"const mod = {TURBOPACK_EXTERNAL_REQUIRE}({}, () => require({}));\",\n-                    StringifyJs(&self.request),\n-                    StringifyJs(&self.request)\n-                )?;\n-            }\n         }\n \n         writeln!(code)?;\n@@ -213,16 +266,26 @@ impl CachedExternalModule {\n     }\n }\n \n+/// A separate turbotask to create only a single VirtualFileSystem\n+#[turbo_tasks::function]\n+fn externals_fs_root() -> Vc<FileSystemPath> {\n+    VirtualFileSystem::new_with_name(rcstr!(\"externals\")).root()\n+}\n+\n #[turbo_tasks::value_impl]\n impl Module for CachedExternalModule {\n     #[turbo_tasks::function]\n     async fn ident(&self) -> Result<Vc<AssetIdent>> {\n-        let fs = VirtualFileSystem::new_with_name(rcstr!(\"externals\"));\n-\n-        Ok(AssetIdent::from_path(fs.root().await?.join(&self.request)?)\n+        let mut ident = AssetIdent::from_path(externals_fs_root().await?.join(&self.request)?)\n             .with_layer(Layer::new(rcstr!(\"external\")))\n             .with_modifier(self.request.clone())\n-            .with_modifier(self.external_type.to_string().into()))\n+            .with_modifier(self.external_type.to_string().into());\n+\n+        if let Some(target) = &self.target {\n+            ident = ident.with_modifier(target.value_to_string().owned().await?);\n+        }\n+\n+        Ok(ident)\n     }\n \n     #[turbo_tasks::function]\n@@ -379,7 +442,31 @@ pub struct CachedExternalModuleChunkItem {\n }\n \n #[turbo_tasks::value_impl]\n-impl OutputAssetsReference for CachedExternalModuleChunkItem {}\n+impl OutputAssetsReference for CachedExternalModuleChunkItem {\n+    #[turbo_tasks::function]\n+    async fn references(&self) -> Result<Vc<OutputAssetsWithReferenced>> {\n+        let module = self.module.await?;\n+        let assets = if let Some(target) = &module.target {\n+            ResolvedVc::cell(vec![ResolvedVc::upcast(\n+                ExternalsSymlinkAsset::new(\n+                    *self.chunking_context,\n+                    hashed_package_name(target).into(),\n+                    module.target.clone().unwrap(),\n+                )\n+                .to_resolved()\n+                .await?,\n+            )])\n+        } else {\n+            OutputAssets::empty_resolved()\n+        };\n+        Ok(OutputAssetsWithReferenced {\n+            assets,\n+            referenced_assets: OutputAssets::empty_resolved(),\n+            references: OutputAssetsReferences::empty_resolved(),\n+        }\n+        .cell())\n+    }\n+}\n \n #[turbo_tasks::value_impl]\n impl ChunkItem for CachedExternalModuleChunkItem {\n@@ -472,3 +559,73 @@ impl Module for ModuleWithoutSelfAsync {\n \n     // Don't override and use default is_self_async that always returns false\n }\n+\n+#[derive(Debug)]\n+#[turbo_tasks::value(shared)]\n+pub struct ExternalsSymlinkAsset {\n+    chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+    hashed_package: RcStr,\n+    target: FileSystemPath,\n+}\n+#[turbo_tasks::value_impl]\n+impl ExternalsSymlinkAsset {\n+    #[turbo_tasks::function]\n+    pub fn new(\n+        chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+        hashed_package: RcStr,\n+        target: FileSystemPath,\n+    ) -> Vc<Self> {\n+        ExternalsSymlinkAsset {\n+            chunking_context,\n+            hashed_package,\n+            target,\n+        }\n+        .cell()\n+    }\n+}\n+#[turbo_tasks::value_impl]\n+impl OutputAssetsReference for ExternalsSymlinkAsset {}\n+\n+#[turbo_tasks::value_impl]\n+impl OutputAsset for ExternalsSymlinkAsset {\n+    #[turbo_tasks::function]\n+    async fn path(&self) -> Result<Vc<FileSystemPath>> {\n+        Ok(self\n+            .chunking_context\n+            .output_root()\n+            .await?\n+            .join(\"node_modules\")?\n+            .join(&self.hashed_package)?\n+            .cell())\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Asset for ExternalsSymlinkAsset {\n+    #[turbo_tasks::function]\n+    async fn content(self: Vc<Self>) -> Result<Vc<AssetContent>> {\n+        let this = self.await?;\n+        // path: [output]/bench/app-router-server/.next/node_modules/lodash-ee4fa714b6d81ca3\n+        // target: [project]/node_modules/.pnpm/lodash@3.10.1/node_modules/lodash\n+\n+        let output_root_to_project_root = this.chunking_context.output_root_to_root_path().await?;\n+        let project_root_to_target = &this.target.path;\n+\n+        let path = self.path().await?;\n+        let path_to_output_root = path\n+            .parent()\n+            .get_relative_path_to(&*this.chunking_context.output_root().await?)\n+            .context(\"path must be inside output root\")?;\n+\n+        let target = format!(\n+            \"{path_to_output_root}/{output_root_to_project_root}/{project_root_to_target}\",\n+        )\n+        .into();\n+\n+        Ok(AssetContent::Redirect {\n+            target,\n+            link_type: LinkType::DIRECTORY,\n+        }\n+        .cell())\n+    }\n+}"
        },
        {
            "sha": "b875f69b9fd47d762d8824815bbcc91a355a3969",
            "filename": "turbopack/crates/turbopack/src/lib.rs",
            "status": "modified",
            "additions": 43,
            "deletions": 6,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/7905cb4cc3246f20145694ee490ff4ecd926541f/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7905cb4cc3246f20145694ee490ff4ecd926541f/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Flib.rs?ref=7905cb4cc3246f20145694ee490ff4ecd926541f",
            "patch": "@@ -898,24 +898,59 @@ impl AssetContext for ModuleAssetContext {\n                                 ProcessResult::Ignore => ModuleResolveResultItem::Ignore,\n                             }\n                         }\n-                        ResolveResultItem::External { name, ty, traced } => {\n+                        ResolveResultItem::External {\n+                            name,\n+                            ty,\n+                            traced,\n+                            target,\n+                        } => {\n                             let replacement = if replace_externals {\n+                                // Determine the package folder, `target` is the full path to the\n+                                // resolved file.\n+                                let target = if let Some(mut target) = target {\n+                                    loop {\n+                                        let parent = target.parent();\n+                                        if parent.is_root() {\n+                                            break;\n+                                        }\n+                                        if parent.file_name() == \"node_modules\" {\n+                                            break;\n+                                        }\n+                                        if parent.file_name().starts_with(\"@\")\n+                                            && parent.parent().file_name() == \"node_modules\"\n+                                        {\n+                                            break;\n+                                        }\n+                                        target = parent;\n+                                    }\n+                                    Some(target)\n+                                } else {\n+                                    None\n+                                };\n+\n                                 let analyze_mode = if traced == ExternalTraced::Traced\n                                     && let Some(options) = &self\n                                         .module_options_context()\n                                         .await?\n                                         .enable_externals_tracing\n                                 {\n                                     // result.affecting_sources can be ignored for tracing, as this\n-                                    // request will later be resolved relative to tracing_root\n-                                    // anyway.\n+                                    // request will later be resolved relative to tracing_root (or\n+                                    // the .next/node_modules/lodash-1238123 symlink) anyway.\n \n                                     let options = options.await?;\n                                     let origin = PlainResolveOrigin::new(\n                                         Vc::upcast(externals_tracing_module_context(\n                                             *options.compile_time_info,\n                                         )),\n-                                        options.tracing_root.join(\"_\")?,\n+                                        // If target is specified, a symlink will be created to\n+                                        // make the folder\n+                                        // itself available, but we still need to trace\n+                                        // resolving the individual file(s) inside the package.\n+                                        target\n+                                            .as_ref()\n+                                            .unwrap_or(&options.tracing_root)\n+                                            .join(\"_\")?,\n                                     );\n                                     CachedExternalTracingMode::Traced {\n                                         origin: ResolvedVc::upcast(origin.to_resolved().await?),\n@@ -924,7 +959,8 @@ impl AssetContext for ModuleAssetContext {\n                                     CachedExternalTracingMode::Untraced\n                                 };\n \n-                                replace_external(&name, ty, import_externals, analyze_mode).await?\n+                                replace_external(&name, ty, target, import_externals, analyze_mode)\n+                                    .await?\n                             } else {\n                                 None\n                             };\n@@ -1051,6 +1087,7 @@ pub async fn emit_assets_into_dir_operation(\n pub async fn replace_external(\n     name: &RcStr,\n     ty: ExternalType,\n+    target: Option<FileSystemPath>,\n     import_externals: bool,\n     analyze_mode: CachedExternalTracingMode,\n ) -> Result<Option<ModuleResolveResultItem>> {\n@@ -1071,7 +1108,7 @@ pub async fn replace_external(\n         }\n     };\n \n-    let module = CachedExternalModule::new(name.clone(), external_type, analyze_mode)\n+    let module = CachedExternalModule::new(name.clone(), target, external_type, analyze_mode)\n         .to_resolved()\n         .await?;\n "
        }
    ],
    "stats": {
        "total": 534,
        "additions": 393,
        "deletions": 141
    }
}