{
    "author": "ztanner",
    "message": "improve segment cache lru typesafety (#87129)\n\nThe LRU and cache map code was using any types in several places\n`(MapEntry<any>`,` type LRUNode = MapEntry<any>`) which meant we had no\ntype safety for those operations. This masked a bug fixed in #87124\nwhere `deleteFromCacheMap(tail.value)` was being called incorrectly -\nthe `any` typing let it compile when it shouldn't have.\n\nThis PR introduces a `LRUNode` type that captures the structure needed\nfor heterogeneous LRU operations (since the LRU holds both\n`RouteCacheEntry` and `SegmentCacheEntry`). The generic `MapEntry<V>` is\nkept for type-safe map operations, while `LRUNode` is used for deletion\nand LRU logic.",
    "sha": "32f6ed396e483f141df40dc57a98dfe1be4ddd50",
    "files": [
        {
            "sha": "6993fba1a6087263bed16865c5edce405f67daab",
            "filename": "packages/next/src/client/components/segment-cache/cache-map.ts",
            "status": "modified",
            "additions": 62,
            "deletions": 58,
            "changes": 120,
            "blob_url": "https://github.com/vercel/next.js/blob/32f6ed396e483f141df40dc57a98dfe1be4ddd50/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache-map.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/32f6ed396e483f141df40dc57a98dfe1be4ddd50/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache-map.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache-map.ts?ref=32f6ed396e483f141df40dc57a98dfe1be4ddd50",
            "patch": "@@ -65,41 +65,61 @@ import { lruPut, updateLruSize, deleteFromLru } from './lru'\n  * should prefer to put it in cache.ts.\n  */\n \n-type MapEntryShared<V extends MapValue> = {\n-  parent: MapEntry<V> | null\n-  key: any\n-  map: Map<any, MapEntry<V>> | null\n-\n-  // LRU-related fields\n-  prev: MapEntry<any> | null\n-  next: MapEntry<any> | null\n-  size: number\n-}\n-\n-type EmptyMapEntry<V extends MapValue> = MapEntryShared<V> & {\n-  value: null\n-}\n-\n-type FullMapEntry<V extends MapValue> = MapEntryShared<V> & {\n-  value: V\n-}\n-\n-export type MapEntry<V extends MapValue> = EmptyMapEntry<V> | FullMapEntry<V>\n-\n-// The CacheMap type is just the root entry of the map.\n-export type CacheMap<V extends MapValue> = MapEntry<V>\n-\n // The protocol that values must implement. In practice, the only two types that\n // we ever actually deal with in this module are RouteCacheEntry and\n // SegmentCacheEntry; this is just to keep track of the coupling so we don't\n // leak concerns between the modules unnecessarily.\n export interface MapValue {\n-  ref: MapEntry<any> | null\n+  ref: UnknownMapEntry | null\n   size: number\n   staleAt: number\n   version: number\n }\n \n+/**\n+ * Represents a node in the cache map and LRU.\n+ * MapEntry<V> structurally satisfies this interface for any V extends MapValue.\n+ *\n+ * The LRU can contain entries of different value types\n+ * (e.g., both RouteCacheEntry and SegmentCacheEntry). This interface captures\n+ * the common structure needed for cache map and LRU operations without\n+ * requiring knowledge of the specific value type.\n+ */\n+export interface MapEntry<V extends MapValue> {\n+  // Cache map structure fields\n+  parent: MapEntry<V> | null\n+  key: unknown\n+  map: Map<unknown, MapEntry<V>> | null\n+  value: V | null\n+\n+  // LRU linked list fields\n+  prev: MapEntry<V> | null\n+  next: MapEntry<V> | null\n+  size: number\n+}\n+\n+/**\n+ * A looser type for MapEntry\n+ * This allows the LRU to work with entries of different\n+ * value types while still providing type safety.\n+ *\n+ * The `map` field lets Map<unknown, MapEntry<V>> be assignable to this\n+ * type since we're only reading from the map, not inserting into it.\n+ */\n+export type UnknownMapEntry = {\n+  parent: UnknownMapEntry | null\n+  key: unknown\n+  map: Pick<Map<unknown, UnknownMapEntry>, 'get' | 'delete' | 'size'> | null\n+  value: MapValue | null\n+\n+  prev: UnknownMapEntry | null\n+  next: UnknownMapEntry | null\n+  size: number\n+}\n+\n+// The CacheMap type is just the root entry of the map.\n+export type CacheMap<V extends MapValue> = MapEntry<V>\n+\n export type FallbackType = { __brand: 'Fallback' }\n export const Fallback = {} as FallbackType\n \n@@ -172,7 +192,7 @@ function getOrInitialize<V extends MapValue>(\n       entry.map = map\n     }\n     // No entry exists yet at this level. Create a new one.\n-    const newEntry: EmptyMapEntry<V> = {\n+    const newEntry: MapEntry<V> = {\n       parent: entry,\n       key,\n       value: null,\n@@ -213,10 +233,10 @@ export function getFromCacheMap<V extends MapValue>(\n   return entry.value\n }\n \n-export function isValueExpired<V extends MapValue>(\n+export function isValueExpired(\n   now: number,\n   currentCacheVersion: number,\n-  value: V\n+  value: MapValue\n ): boolean {\n   return value.staleAt <= now || value.version < currentCacheVersion\n }\n@@ -286,7 +306,7 @@ function getEntryWithFallbackImpl<V extends MapValue>(\n     const existingEntry = map.get(key)\n     if (existingEntry !== undefined) {\n       // Found an exact match for this key. Keep searching.\n-      const result = getEntryWithFallbackImpl<V>(\n+      const result = getEntryWithFallbackImpl(\n         now,\n         currentCacheVersion,\n         existingEntry,\n@@ -332,38 +352,23 @@ export function setInCacheMap<V extends MapValue>(\n   updateLruSize(entry, value.size)\n }\n \n-function setMapEntryValue<V extends MapValue>(\n-  entry: MapEntry<V>,\n-  value: V\n-): void {\n+function setMapEntryValue(entry: UnknownMapEntry, value: MapValue): void {\n   if (entry.value !== null) {\n     // There's already a value at the given keypath. Disconnect the old value\n     // from the map. We're not calling `deleteMapEntry` here because the\n     // entry itself is still in the map. We just want to overwrite its value.\n     dropRef(entry.value)\n-\n-    // Fill the entry with the updated value.\n-    const emptyEntry: EmptyMapEntry<V> = entry as any\n-    emptyEntry.value = null\n-    fillEmptyReference(emptyEntry, value)\n-  } else {\n-    fillEmptyReference(entry as any, value)\n+    entry.value = null\n   }\n-}\n \n-function fillEmptyReference<V extends MapValue>(\n-  entry: EmptyMapEntry<V>,\n-  value: V\n-): void {\n   // This value may already be in the map at a different keypath.\n   // Grab a reference before we overwrite it.\n   const oldEntry = value.ref\n \n-  const fullEntry: FullMapEntry<V> = entry as any\n-  fullEntry.value = value\n-  value.ref = fullEntry\n+  entry.value = value\n+  value.ref = entry\n \n-  updateLruSize(fullEntry, value.size)\n+  updateLruSize(entry, value.size)\n \n   if (oldEntry !== null && oldEntry !== entry && oldEntry.value === value) {\n     // This value is already in the map at a different keypath in the map.\n@@ -377,7 +382,7 @@ function fillEmptyReference<V extends MapValue>(\n   }\n }\n \n-export function deleteFromCacheMap<V extends MapValue>(value: V): void {\n+export function deleteFromCacheMap(value: MapValue): void {\n   const entry = value.ref\n   if (entry === null) {\n     // This value is not a member of any map.\n@@ -388,29 +393,28 @@ export function deleteFromCacheMap<V extends MapValue>(value: V): void {\n   deleteMapEntry(entry)\n }\n \n-function dropRef<V extends MapValue>(value: V): void {\n+function dropRef(value: MapValue): void {\n   // Drop the value from the map by setting its `ref` backpointer to\n   // null. This is a separate operation from `deleteMapEntry` because when\n   // re-keying a value we need to be able to delete the old, internal map\n   // entry without garbage collecting the value itself.\n   value.ref = null\n }\n \n-export function deleteMapEntry<V extends MapValue>(entry: MapEntry<V>): void {\n+export function deleteMapEntry(entry: UnknownMapEntry): void {\n   // Delete the entry from the cache.\n-  const emptyEntry: EmptyMapEntry<V> = entry as any\n-  emptyEntry.value = null\n+  entry.value = null\n \n   deleteFromLru(entry)\n \n   // Check if we can garbage collect the entry.\n-  const map = emptyEntry.map\n+  const map = entry.map\n   if (map === null) {\n     // Since this entry has no value, and also no child entries, we can\n     // garbage collect it. Remove it from its parent, and keep garbage\n     // collecting the parents until we reach a non-empty entry.\n-    let parent = emptyEntry.parent\n-    let key = emptyEntry.key\n+    let parent = entry.parent\n+    let key = entry.key\n     while (parent !== null) {\n       const parentMap = parent.map\n       if (parentMap !== null) {\n@@ -435,7 +439,7 @@ export function deleteMapEntry<V extends MapValue>(entry: MapEntry<V>): void {\n     // \"normal\" entry, since the normal one was just deleted.\n     const revalidatingEntry = map.get(Revalidation)\n     if (revalidatingEntry !== undefined && revalidatingEntry.value !== null) {\n-      setMapEntryValue(emptyEntry, revalidatingEntry.value)\n+      setMapEntryValue(entry, revalidatingEntry.value)\n     }\n   }\n }"
        },
        {
            "sha": "6cbf4600b496a45fd3e0e752f7f322eb23e19f31",
            "filename": "packages/next/src/client/components/segment-cache/cache.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/32f6ed396e483f141df40dc57a98dfe1be4ddd50/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/32f6ed396e483f141df40dc57a98dfe1be4ddd50/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts?ref=32f6ed396e483f141df40dc57a98dfe1be4ddd50",
            "patch": "@@ -66,7 +66,7 @@ import {\n   deleteFromCacheMap,\n   isValueExpired,\n   type CacheMap,\n-  type MapEntry,\n+  type UnknownMapEntry,\n } from './cache-map'\n import {\n   appendSegmentRequestKeyPart,\n@@ -166,7 +166,7 @@ type RouteCacheEntryShared = {\n   couldBeIntercepted: boolean\n \n   // Map-related fields.\n-  ref: null | MapEntry<RouteCacheEntry>\n+  ref: UnknownMapEntry | null\n   size: number\n   staleAt: number\n   version: number\n@@ -223,7 +223,7 @@ type SegmentCacheEntryShared = {\n   fetchStrategy: FetchStrategy\n \n   // Map-related fields.\n-  ref: null | MapEntry<SegmentCacheEntry>\n+  ref: UnknownMapEntry | null\n   size: number\n   staleAt: number\n   version: number"
        },
        {
            "sha": "f5f8dc01a43760f326d4c81927c4af64e91615b9",
            "filename": "packages/next/src/client/components/segment-cache/lru.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 10,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/32f6ed396e483f141df40dc57a98dfe1be4ddd50/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Flru.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/32f6ed396e483f141df40dc57a98dfe1be4ddd50/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Flru.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Flru.ts?ref=32f6ed396e483f141df40dc57a98dfe1be4ddd50",
            "patch": "@@ -1,15 +1,10 @@\n-import type { MapEntry } from './cache-map'\n import { deleteMapEntry } from './cache-map'\n+import type { UnknownMapEntry } from './cache-map'\n \n // We use an LRU for memory management. We must update this whenever we add or\n // remove a new cache entry, or when an entry changes size.\n \n-// The MapEntry type is used as an LRU node, too. We choose this one instead of\n-// the inner cache entry type (RouteCacheEntry, SegmentCacheEntry) because it's\n-// monomorphic and can be optimized by the VM.\n-type LRUNode = MapEntry<any>\n-\n-let head: LRUNode | null = null\n+let head: UnknownMapEntry | null = null\n let didScheduleCleanup: boolean = false\n let lruSize: number = 0\n \n@@ -18,7 +13,7 @@ let lruSize: number = 0\n // customizable via the Next.js config, too.\n const maxLruSize = 50 * 1024 * 1024 // 50 MB\n \n-export function lruPut(node: LRUNode) {\n+export function lruPut(node: UnknownMapEntry) {\n   if (head === node) {\n     // Already at the head\n     return\n@@ -57,7 +52,7 @@ export function lruPut(node: LRUNode) {\n   head = node\n }\n \n-export function updateLruSize(node: LRUNode, newNodeSize: number) {\n+export function updateLruSize(node: UnknownMapEntry, newNodeSize: number) {\n   // This is a separate function from `put` so that we can resize the entry\n   // regardless of whether it's currently being tracked by the LRU.\n   const prevNodeSize = node.size\n@@ -71,7 +66,7 @@ export function updateLruSize(node: LRUNode, newNodeSize: number) {\n   ensureCleanupIsScheduled()\n }\n \n-export function deleteFromLru(deleted: LRUNode) {\n+export function deleteFromLru(deleted: UnknownMapEntry) {\n   const next = deleted.next\n   const prev = deleted.prev\n   if (next !== null && prev !== null) {"
        }
    ],
    "stats": {
        "total": 141,
        "additions": 70,
        "deletions": 71
    }
}