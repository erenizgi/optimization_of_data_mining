{
    "author": "sokra",
    "message": "Turbopack: reduce the amount of task modifications caused by recomputation (#78728)\n\n### What?\n\nImprove backend code to avoid flagging a task as modified when it is just recomputed without changes.",
    "sha": "ad399701d08a95482cab486d14a025476f847c83",
    "files": [
        {
            "sha": "52b954b55e487c24548c99337e108902e288b579",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 54,
            "deletions": 47,
            "changes": 101,
            "blob_url": "https://github.com/vercel/next.js/blob/ad399701d08a95482cab486d14a025476f847c83/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ad399701d08a95482cab486d14a025476f847c83/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=ad399701d08a95482cab486d14a025476f847c83",
            "patch": "@@ -56,9 +56,8 @@ use crate::{\n     backing_storage::BackingStorage,\n     data::{\n         ActivenessState, AggregationNumber, CachedDataItem, CachedDataItemKey, CachedDataItemType,\n-        CachedDataItemValue, CachedDataItemValueRef, CellRef, CollectibleRef, CollectiblesRef,\n-        DirtyState, InProgressCellState, InProgressState, InProgressStateInner, OutputValue,\n-        RootType,\n+        CachedDataItemValueRef, CellRef, CollectibleRef, CollectiblesRef, DirtyState,\n+        InProgressCellState, InProgressState, InProgressStateInner, OutputValue, RootType,\n     },\n     utils::{\n         bi_map::BiMap, chunked_vec::ChunkedVec, ptr_eq_arc::PtrEqArc, sharded::Sharded, swap_retain,\n@@ -422,7 +421,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         }\n \n         let mut ctx = self.execute_context(turbo_tasks);\n-        let mut task = ctx.task(task_id, TaskDataCategory::All);\n+        let mut task = ctx.task(task_id, TaskDataCategory::Meta);\n \n         fn listen_to_done_event<B: BackingStorage>(\n             this: &TurboTasksBackendInner<B>,\n@@ -493,7 +492,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                         &mut ctx,\n                     );\n                 }\n-                task = ctx.task(task_id, TaskDataCategory::All);\n+                task = ctx.task(task_id, TaskDataCategory::Meta);\n             }\n \n             let is_dirty =\n@@ -1552,10 +1551,16 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         // Remove no longer existing cells and\n         // find all outdated data items (removed cells, outdated edges)\n-        removed_data.extend(task.extract_if(CachedDataItemType::CellData, |key, _| {\n-            matches!(key, CachedDataItemKey::CellData { cell } if cell_counters\n-                        .get(&cell.type_id).is_none_or(|start_index| cell.index >= *start_index))\n-        }));\n+        // Note: For persistent tasks we only want to call extract_if when there are actual cells to\n+        // remove to avoid tracking that as modification.\n+        if task_id.is_transient() || iter_many!(task, CellData { cell }\n+            if cell_counters.get(&cell.type_id).is_none_or(|start_index| cell.index >= *start_index) => cell\n+        ).count() > 0 {\n+            removed_data.extend(task.extract_if(CachedDataItemType::CellData, |key, _| {\n+                matches!(key, CachedDataItemKey::CellData { cell } if cell_counters\n+                            .get(&cell.type_id).is_none_or(|start_index| cell.index >= *start_index))\n+            }));\n+        }\n         if self.should_track_children() {\n             old_edges.extend(\n                 task.iter(CachedDataItemType::OutdatedCollectible)\n@@ -1708,6 +1713,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         ));\n \n         // Update the dirty state\n+        let old_dirty_state = get!(task, Dirty).copied();\n+\n         let new_dirty_state = if session_dependent {\n             Some(DirtyState {\n                 clean_in_session: Some(self.session_id),\n@@ -1716,48 +1723,48 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             None\n         };\n \n-        let old_dirty = if let Some(new_dirty_state) = new_dirty_state {\n-            task.insert(CachedDataItem::Dirty {\n-                value: new_dirty_state,\n-            })\n-        } else {\n-            task.remove(&CachedDataItemKey::Dirty {})\n-        };\n-\n-        let old_dirty_state = old_dirty.map(|old_dirty| match old_dirty {\n-            CachedDataItemValue::Dirty { value } => value,\n-            _ => unreachable!(),\n-        });\n-\n-        let data_update = if self.should_track_children()\n-            && (old_dirty_state.is_some() || new_dirty_state.is_some())\n-        {\n-            let mut dirty_containers = get!(task, AggregatedDirtyContainerCount)\n-                .cloned()\n-                .unwrap_or_default();\n-            if let Some(old_dirty_state) = old_dirty_state {\n-                dirty_containers.update_with_dirty_state(&old_dirty_state);\n+        let data_update = if old_dirty_state != new_dirty_state {\n+            if let Some(new_dirty_state) = new_dirty_state {\n+                task.insert(CachedDataItem::Dirty {\n+                    value: new_dirty_state,\n+                });\n+            } else {\n+                task.remove(&CachedDataItemKey::Dirty {});\n             }\n-            let aggregated_update = match (old_dirty_state, new_dirty_state) {\n-                (None, None) => unreachable!(),\n-                (Some(old), None) => dirty_containers.undo_update_with_dirty_state(&old),\n-                (None, Some(new)) => dirty_containers.update_with_dirty_state(&new),\n-                (Some(old), Some(new)) => dirty_containers.replace_dirty_state(&old, &new),\n-            };\n-            if !aggregated_update.is_zero() {\n-                if aggregated_update.get(self.session_id) < 0 {\n-                    if let Some(root_state) = get_mut!(task, Activeness) {\n-                        root_state.all_clean_event.notify(usize::MAX);\n-                        root_state.unset_active_until_clean();\n-                        if root_state.is_empty() {\n-                            task.remove(&CachedDataItemKey::Activeness {});\n+\n+            if self.should_track_children()\n+                && (old_dirty_state.is_some() || new_dirty_state.is_some())\n+            {\n+                let mut dirty_containers = get!(task, AggregatedDirtyContainerCount)\n+                    .cloned()\n+                    .unwrap_or_default();\n+                if let Some(old_dirty_state) = old_dirty_state {\n+                    dirty_containers.update_with_dirty_state(&old_dirty_state);\n+                }\n+                let aggregated_update = match (old_dirty_state, new_dirty_state) {\n+                    (None, None) => unreachable!(),\n+                    (Some(old), None) => dirty_containers.undo_update_with_dirty_state(&old),\n+                    (None, Some(new)) => dirty_containers.update_with_dirty_state(&new),\n+                    (Some(old), Some(new)) => dirty_containers.replace_dirty_state(&old, &new),\n+                };\n+                if !aggregated_update.is_zero() {\n+                    if aggregated_update.get(self.session_id) < 0 {\n+                        if let Some(root_state) = get_mut!(task, Activeness) {\n+                            root_state.all_clean_event.notify(usize::MAX);\n+                            root_state.unset_active_until_clean();\n+                            if root_state.is_empty() {\n+                                task.remove(&CachedDataItemKey::Activeness {});\n+                            }\n                         }\n                     }\n+                    AggregationUpdateJob::data_update(\n+                        &mut task,\n+                        AggregatedDataUpdate::new()\n+                            .dirty_container_update(task_id, aggregated_update),\n+                    )\n+                } else {\n+                    None\n                 }\n-                AggregationUpdateJob::data_update(\n-                    &mut task,\n-                    AggregatedDataUpdate::new().dirty_container_update(task_id, aggregated_update),\n-                )\n             } else {\n                 None\n             }"
        }
    ],
    "stats": {
        "total": 101,
        "additions": 54,
        "deletions": 47
    }
}