{
    "author": "bgw",
    "message": "refactor(turbo-tasks): Make TraceRawVcs a supertrait of TaskInput (#77397)\n\nFor a tracing GC to work (different for cache eviction), we need `TraceRawVcs` to be able to inspect function arguments.\n\nWhile a tracing GC is still far off, the immediate motivation here is using tracing to improve logging for \"transient task called from persistent task\" error messages.\n\nThere's one non-test mpsc queue (`ComputeUpdateStreamSender`) with a sketchy `TraceRawVcs` impl. We should have a way of excluding certain objects from GC (marking them as roots) to fix this in the GC case. IMO this doesn't really matter for non-GC debug use-cases of `TraceRawVcs`.",
    "sha": "2e76e15f59d4695ee783ff370f39e2921e5368a9",
    "files": [
        {
            "sha": "f3b8b8db7b2079312ca57e3bd2b903363cdfb117",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -9711,6 +9711,7 @@ dependencies = [\n  \"tracing\",\n  \"turbo-rcstr\",\n  \"turbo-tasks\",\n+ \"turbo-tasks-backend\",\n  \"turbo-tasks-build\",\n  \"turbo-tasks-bytes\",\n  \"turbo-tasks-fs\","
        },
        {
            "sha": "d5bb7a42bbd95e4541e88495b51d798f45eaba88",
            "filename": "crates/next-core/src/next_manifests/client_reference_manifest.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -7,8 +7,8 @@ use serde::{Deserialize, Serialize};\n use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    FxIndexSet, ReadRef, ResolvedVc, TaskInput, TryFlatJoinIterExt, TryJoinIterExt, ValueToString,\n-    Vc,\n+    trace::TraceRawVcs, FxIndexSet, ReadRef, ResolvedVc, TaskInput, TryFlatJoinIterExt,\n+    TryJoinIterExt, ValueToString, Vc,\n };\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n@@ -30,7 +30,7 @@ use crate::{\n     util::NextRuntime,\n };\n \n-#[derive(TaskInput, Clone, Hash, Debug, PartialEq, Eq, Serialize, Deserialize)]\n+#[derive(TaskInput, Clone, Hash, Debug, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs)]\n pub struct ClientReferenceManifestOptions {\n     pub node_root: Vc<FileSystemPath>,\n     pub client_relative_path: Vc<FileSystemPath>,"
        },
        {
            "sha": "164c4415e4a0851fae64a37c290626703b3dce4e",
            "filename": "crates/next-core/src/util.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/crates%2Fnext-core%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/crates%2Fnext-core%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Futil.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -40,7 +40,9 @@ use crate::{\n \n const NEXT_TEMPLATE_PATH: &str = \"dist/esm/build/templates\";\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, TaskInput, Serialize, Deserialize)]\n+#[derive(\n+    Debug, Clone, Copy, PartialEq, Eq, Hash, TaskInput, Serialize, Deserialize, TraceRawVcs,\n+)]\n pub enum PathType {\n     PagesPage,\n     PagesApi,"
        },
        {
            "sha": "53d0f2c10bcb374adf9ba921d8ed7d3ded1f3ee5",
            "filename": "turbopack/crates/turbo-tasks-macros-tests/tests/task_input.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ftask_input.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ftask_input.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ftask_input.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -4,12 +4,12 @@\n #![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n \n use serde::{Deserialize, Serialize};\n-use turbo_tasks::{Completion, ReadRef, TaskInput, Vc};\n+use turbo_tasks::{trace::TraceRawVcs, Completion, ReadRef, TaskInput, Vc};\n use turbo_tasks_testing::{register, run, Registration};\n \n static REGISTRATION: Registration = register!();\n \n-#[derive(Clone, TaskInput, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]\n+#[derive(Clone, TaskInput, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, TraceRawVcs)]\n struct OneUnnamedField(u32);\n \n #[turbo_tasks::function]"
        },
        {
            "sha": "97c2d297f3fc8f259db24cb50c6646fd3e4024bc",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/detached.rs",
            "status": "modified",
            "additions": 35,
            "deletions": 10,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdetached.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdetached.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdetached.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -6,19 +6,26 @@ use tokio::{\n     sync::{watch, Notify},\n     time::{sleep, timeout, Duration},\n };\n-use turbo_tasks::{turbo_tasks, State, TransientInstance, Vc};\n+use turbo_tasks::{\n+    prevent_gc,\n+    trace::{TraceRawVcs, TraceRawVcsContext},\n+    turbo_tasks, State, TransientInstance, Vc,\n+};\n use turbo_tasks_testing::{register, run, Registration};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test]\n async fn test_spawns_detached() -> anyhow::Result<()> {\n     run(&REGISTRATION, || async {\n+        // HACK: The watch channel we use has an incorrect implementation of `TraceRawVcs`, just\n+        // disable GC for the test so this can't cause any problems.\n+        prevent_gc();\n         // timeout: prevent the test from hanging, and fail instead if this is broken\n         timeout(Duration::from_secs(5), async {\n-            let notify = TransientInstance::new(Notify::new());\n+            let notify = TransientInstance::new(NotifyTaskInput(Notify::new()));\n             let (tx, mut rx) = watch::channel(None);\n-            let tx = TransientInstance::new(tx);\n+            let tx = TransientInstance::new(WatchSenderTaskInput(tx));\n \n             // create the task\n             let out_vc = spawns_detached(notify.clone(), tx.clone());\n@@ -29,7 +36,7 @@ async fn test_spawns_detached() -> anyhow::Result<()> {\n                 .expect_err(\"should wait on the detached task\");\n \n             // let the detached future exit\n-            notify.notify_waiters();\n+            notify.0.notify_waiters();\n \n             // it should send us back a cell\n             let detached_vc: Vc<u32> = rx.wait_for(|opt| opt.is_some()).await?.unwrap();\n@@ -45,16 +52,31 @@ async fn test_spawns_detached() -> anyhow::Result<()> {\n     .await\n }\n \n+#[derive(TraceRawVcs)]\n+struct NotifyTaskInput(\n+    // trace_ignore: `notify` doesn't store any data\n+    #[turbo_tasks(trace_ignore)] Notify,\n+);\n+\n+struct WatchSenderTaskInput<T>(watch::Sender<T>);\n+\n+impl<T: TraceRawVcs> TraceRawVcs for WatchSenderTaskInput<T> {\n+    fn trace_raw_vcs(&self, _trace_context: &mut TraceRawVcsContext) {\n+        // HACK: This implementation is wrong (the channel contains a `Vc`), but we can't access it.\n+        // Instead we just `prevent_gc` in the tests.\n+    }\n+}\n+\n #[turbo_tasks::function]\n async fn spawns_detached(\n-    notify: TransientInstance<Notify>,\n-    sender: TransientInstance<watch::Sender<Option<Vc<u32>>>>,\n+    notify: TransientInstance<NotifyTaskInput>,\n+    sender: TransientInstance<WatchSenderTaskInput<Option<Vc<u32>>>>,\n ) -> Vc<()> {\n     tokio::spawn(turbo_tasks().detached_for_testing(Box::pin(async move {\n-        notify.notified().await;\n+        notify.0.notified().await;\n         // creating cells after the normal lifetime of the task should be okay, as the parent task\n         // is waiting on us before exiting!\n-        sender.send(Some(Vc::cell(42))).unwrap();\n+        sender.0.send(Some(Vc::cell(42))).unwrap();\n         Ok(())\n     })));\n     Vc::cell(())\n@@ -63,10 +85,12 @@ async fn spawns_detached(\n #[tokio::test]\n async fn test_spawns_detached_changing() -> anyhow::Result<()> {\n     run(&REGISTRATION, || async {\n+        // HACK: The watch channel we use has an incorrect implementation of `TraceRawVcs`\n+        prevent_gc();\n         // timeout: prevent the test from hanging, and fail instead if this is broken\n         timeout(Duration::from_secs(5), async {\n             let (tx, mut rx) = watch::channel(None);\n-            let tx = TransientInstance::new(tx);\n+            let tx = TransientInstance::new(WatchSenderTaskInput(tx));\n \n             // state that's read by the detached future\n             let changing_input_detached = ChangingInput {\n@@ -113,7 +137,7 @@ struct ChangingInput {\n \n #[turbo_tasks::function]\n async fn spawns_detached_changing(\n-    sender: TransientInstance<watch::Sender<Option<Vc<u32>>>>,\n+    sender: TransientInstance<WatchSenderTaskInput<Option<Vc<u32>>>>,\n     changing_input_detached: Vc<ChangingInput>,\n     changing_input_outer: Vc<ChangingInput>,\n ) -> Vc<u32> {\n@@ -126,6 +150,7 @@ async fn spawns_detached_changing(\n             // creating cells after the normal lifetime of the task should be okay, as the parent\n             // task is waiting on us before exiting!\n             sender\n+                .0\n                 .send(Some(Vc::cell(\n                     *read_changing_input(changing_input_detached).await.unwrap(),\n                 )))"
        },
        {
            "sha": "7429ed4b5cef5b2a0ae24f3f1c19813fa69e0ad2",
            "filename": "turbopack/crates/turbo-tasks/src/id.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -7,7 +7,11 @@ use std::{\n \n use serde::{de::Visitor, Deserialize, Serialize};\n \n-use crate::{registry, TaskPersistence};\n+use crate::{\n+    registry,\n+    trace::{TraceRawVcs, TraceRawVcsContext},\n+    TaskPersistence,\n+};\n \n macro_rules! define_id {\n     (\n@@ -69,6 +73,10 @@ macro_rules! define_id {\n                 Ok(Self { id: NonZero::try_from(id)? })\n             }\n         }\n+\n+        impl TraceRawVcs for $name {\n+            fn trace_raw_vcs(&self, _trace_context: &mut TraceRawVcsContext) {}\n+        }\n     };\n }\n "
        },
        {
            "sha": "2b0d16d0e38941394efd3efe1d9d96215c54e6bd",
            "filename": "turbopack/crates/turbo-tasks/src/marker_trait.rs",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmarker_trait.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmarker_trait.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmarker_trait.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -43,6 +43,7 @@ macro_rules! impl_auto_marker_trait {\n             ::serde_json::Value, ::serde_json::Map<String, ::serde_json::Value>\n         );\n \n+        $crate::marker_trait::impl_marker_trait_fn_ptr!($trait: E D C B A Z Y X W V U T);\n         $crate::marker_trait::impl_marker_trait_tuple!($trait: E D C B A Z Y X W V U T);\n \n         unsafe impl<T: $trait> $trait for ::std::option::Option<T> {}\n@@ -101,6 +102,24 @@ macro_rules! impl_marker_trait {\n     }\n }\n \n+/// Create an implementation for every possible `fn` pointer type, regardless of the type of the\n+/// arguments and return type.\n+///\n+/// This is typically valid for marker traits as `fn` pointer types (not the `Fn` trait) do not\n+/// contain any data, they are compile-time pointers to static code.\n+macro_rules! impl_marker_trait_fn_ptr {\n+    ($trait:ident: $T:ident) => {\n+        $crate::marker_trait::impl_marker_trait_fn_ptr!(@impl $trait: $T);\n+    };\n+    ($trait:ident: $T:ident $( $U:ident )+) => {\n+        $crate::marker_trait::impl_marker_trait_fn_ptr!($trait: $( $U )+);\n+        $crate::marker_trait::impl_marker_trait_fn_ptr!(@impl $trait: $T $( $U )+);\n+    };\n+    (@impl $trait:ident: $( $T:ident )+) => {\n+        unsafe impl<$($T,)+ Return> $trait for fn($($T),+) -> Return {}\n+    };\n+}\n+\n /// Create an implementation for every possible tuple where every element implements `$trait`.\n ///\n /// Must be passed a sequence of identifier fo the tuple's generic parameters. This will only\n@@ -122,4 +141,5 @@ macro_rules! impl_marker_trait_tuple {\n \n pub(crate) use impl_auto_marker_trait;\n pub(crate) use impl_marker_trait;\n+pub(crate) use impl_marker_trait_fn_ptr;\n pub(crate) use impl_marker_trait_tuple;"
        },
        {
            "sha": "b0d936475dcad55ff52bf8f63619a1df0a3e3278",
            "filename": "turbopack/crates/turbo-tasks/src/task/task_input.rs",
            "status": "modified",
            "additions": 32,
            "deletions": 14,
            "changes": 46,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Ftask_input.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -6,14 +6,15 @@ use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n \n use crate::{\n-    MagicAny, ResolvedVc, TaskId, TransientInstance, TransientValue, Value, ValueTypeId, Vc,\n+    trace::TraceRawVcs, MagicAny, ResolvedVc, TaskId, TransientInstance, TransientValue, Value,\n+    ValueTypeId, Vc,\n };\n \n /// Trait to implement in order for a type to be accepted as a\n /// [`#[turbo_tasks::function]`][crate::function] argument.\n ///\n /// See also [`ConcreteTaskInput`].\n-pub trait TaskInput: Send + Sync + Clone + Debug + PartialEq + Eq + Hash {\n+pub trait TaskInput: Send + Sync + Clone + Debug + PartialEq + Eq + Hash + TraceRawVcs {\n     fn resolve_input(&self) -> impl Future<Output = Result<Self>> + Send + '_ {\n         async { Ok(self.clone()) }\n     }\n@@ -161,6 +162,7 @@ where\n         + Sync\n         + Serialize\n         + for<'de> Deserialize<'de>\n+        + TraceRawVcs\n         + 'static,\n {\n     fn is_resolved(&self) -> bool {\n@@ -174,7 +176,7 @@ where\n \n impl<T> TaskInput for TransientValue<T>\n where\n-    T: MagicAny + Clone + Debug + Hash + Eq + 'static,\n+    T: MagicAny + Clone + Debug + Hash + Eq + TraceRawVcs + 'static,\n {\n     fn is_transient(&self) -> bool {\n         true\n@@ -211,7 +213,7 @@ where\n \n impl<T> TaskInput for TransientInstance<T>\n where\n-    T: Sync + Send + 'static,\n+    T: Sync + Send + TraceRawVcs + 'static,\n {\n     fn is_transient(&self) -> bool {\n         true\n@@ -320,7 +322,9 @@ mod tests {\n \n     #[test]\n     fn test_no_fields() -> Result<()> {\n-        #[derive(Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]\n+        #[derive(\n+            Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize, TraceRawVcs,\n+        )]\n         struct NoFields;\n \n         assert_task_input(NoFields);\n@@ -329,7 +333,9 @@ mod tests {\n \n     #[test]\n     fn test_one_unnamed_field() -> Result<()> {\n-        #[derive(Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]\n+        #[derive(\n+            Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize, TraceRawVcs,\n+        )]\n         struct OneUnnamedField(u32);\n \n         assert_task_input(OneUnnamedField(42));\n@@ -338,7 +344,9 @@ mod tests {\n \n     #[test]\n     fn test_multiple_unnamed_fields() -> Result<()> {\n-        #[derive(Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]\n+        #[derive(\n+            Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize, TraceRawVcs,\n+        )]\n         struct MultipleUnnamedFields(u32, RcStr);\n \n         assert_task_input(MultipleUnnamedFields(42, \"42\".into()));\n@@ -347,7 +355,9 @@ mod tests {\n \n     #[test]\n     fn test_one_named_field() -> Result<()> {\n-        #[derive(Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]\n+        #[derive(\n+            Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize, TraceRawVcs,\n+        )]\n         struct OneNamedField {\n             named: u32,\n         }\n@@ -358,7 +368,9 @@ mod tests {\n \n     #[test]\n     fn test_multiple_named_fields() -> Result<()> {\n-        #[derive(Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]\n+        #[derive(\n+            Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize, TraceRawVcs,\n+        )]\n         struct MultipleNamedFields {\n             named: u32,\n             other: RcStr,\n@@ -373,15 +385,17 @@ mod tests {\n \n     #[test]\n     fn test_generic_field() -> Result<()> {\n-        #[derive(Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]\n+        #[derive(\n+            Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize, TraceRawVcs,\n+        )]\n         struct GenericField<T>(T);\n \n         assert_task_input(GenericField(42));\n         assert_task_input(GenericField(RcStr::from(\"42\")));\n         Ok(())\n     }\n \n-    #[derive(Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]\n+    #[derive(Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize, TraceRawVcs)]\n     enum OneVariant {\n         Variant,\n     }\n@@ -394,7 +408,9 @@ mod tests {\n \n     #[test]\n     fn test_multiple_variants() -> Result<()> {\n-        #[derive(Clone, TaskInput, PartialEq, Eq, Hash, Debug, Serialize, Deserialize)]\n+        #[derive(\n+            Clone, TaskInput, PartialEq, Eq, Hash, Debug, Serialize, Deserialize, TraceRawVcs,\n+        )]\n         enum MultipleVariants {\n             Variant1,\n             Variant2,\n@@ -404,7 +420,7 @@ mod tests {\n         Ok(())\n     }\n \n-    #[derive(Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]\n+    #[derive(Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize, TraceRawVcs)]\n     enum MultipleVariantsAndHeterogeneousFields {\n         Variant1,\n         Variant2(u32),\n@@ -424,7 +440,9 @@ mod tests {\n \n     #[test]\n     fn test_nested_variants() -> Result<()> {\n-        #[derive(Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize)]\n+        #[derive(\n+            Clone, TaskInput, Eq, PartialEq, Hash, Debug, Serialize, Deserialize, TraceRawVcs,\n+        )]\n         enum NestedVariants {\n             Variant1,\n             Variant2(MultipleVariantsAndHeterogeneousFields),"
        },
        {
            "sha": "d732776562ca0fc98ae2bbc2e006528e2365382b",
            "filename": "turbopack/crates/turbo-tasks/src/trace.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrace.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -107,6 +107,25 @@ macro_rules! impl_trace_tuple {\n \n impl_trace_tuple!(E D C B A Z Y X W V U T);\n \n+/// Function pointers (the lowercase `fn` type, not `Fn`) don't contain any data, so it's not\n+/// possible for them to contain a `Vc`.\n+macro_rules! impl_trace_fn_ptr {\n+    ($T:ident) => {\n+        impl_trace_fn_ptr!(@impl $T);\n+    };\n+    ($T:ident $( $U:ident )+) => {\n+        impl_trace_fn_ptr!($( $U )+);\n+        impl_trace_fn_ptr!(@impl $T $( $U )+);\n+    };\n+    (@impl $( $T:ident )+) => {\n+        impl<$($T,)+ Return> TraceRawVcs for fn($($T),+) -> Return {\n+            fn trace_raw_vcs(&self, _trace_context: &mut TraceRawVcsContext) {}\n+        }\n+    };\n+}\n+\n+impl_trace_fn_ptr!(E D C B A Z Y X W V U T);\n+\n impl<T: TraceRawVcs> TraceRawVcs for Option<T> {\n     fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n         if let Some(item) = self {"
        },
        {
            "sha": "6c5cab2ae1576b881c0c673e9ec057cca9a3580d",
            "filename": "turbopack/crates/turbo-tasks/src/value.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvalue.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvalue.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvalue.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -5,6 +5,7 @@ use serde::{Deserialize, Serialize};\n \n use crate::{\n     debug::{ValueDebugFormat, ValueDebugString},\n+    trace::{TraceRawVcs, TraceRawVcsContext},\n     ReadRef, SharedReference,\n };\n \n@@ -56,6 +57,12 @@ impl<T: ValueDebugFormat> Value<T> {\n     }\n }\n \n+impl<T: TraceRawVcs> TraceRawVcs for Value<T> {\n+    fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n+        self.inner.trace_raw_vcs(trace_context)\n+    }\n+}\n+\n /// Pass a value by value (`Value<Xxx>`) instead of by reference (`Vc<Xxx>`).\n ///\n /// Doesn't require serialization, and won't be stored in the persistent cache\n@@ -83,6 +90,12 @@ impl<T> Deref for TransientValue<T> {\n     }\n }\n \n+impl<T: TraceRawVcs> TraceRawVcs for TransientValue<T> {\n+    fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n+        self.inner.trace_raw_vcs(trace_context)\n+    }\n+}\n+\n /// Pass a reference to an instance to a turbo-tasks function.\n ///\n /// Equality and hash is implemented as pointer comparison.\n@@ -177,3 +190,9 @@ impl<T: 'static> Deref for TransientInstance<T> {\n         self.inner.0.downcast_ref().unwrap()\n     }\n }\n+\n+impl<T: TraceRawVcs + 'static> TraceRawVcs for TransientInstance<T> {\n+    fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n+        self.inner.downcast_ref::<T>().trace_raw_vcs(trace_context)\n+    }\n+}"
        },
        {
            "sha": "e5caf20f321a969aa99481ef3d58775ea1b7c00d",
            "filename": "turbopack/crates/turbopack-cli/src/arguments.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Farguments.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Farguments.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Farguments.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -5,7 +5,7 @@ use std::{\n \n use clap::{Args, Parser, ValueEnum};\n use serde::{Deserialize, Serialize};\n-use turbo_tasks::{NonLocalValue, TaskInput};\n+use turbo_tasks::{trace::TraceRawVcs, NonLocalValue, TaskInput};\n use turbopack_cli_utils::issue::IssueSeverityCliOption;\n \n #[derive(Debug, Parser)]\n@@ -37,6 +37,7 @@ impl Arguments {\n     Hash,\n     TaskInput,\n     NonLocalValue,\n+    TraceRawVcs,\n )]\n pub enum Target {\n     Browser,"
        },
        {
            "sha": "5e65d13d1d1c6be1304bcda1e5946cf27dc11ca1",
            "filename": "turbopack/crates/turbopack-cli/src/dev/mod.rs",
            "status": "modified",
            "additions": 28,
            "deletions": 12,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fdev%2Fmod.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -13,8 +13,9 @@ use owo_colors::OwoColorize;\n use rustc_hash::FxHashSet;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n+    trace::TraceRawVcs,\n     util::{FormatBytes, FormatDuration},\n-    ResolvedVc, TransientInstance, TurboTasks, UpdateInfo, Value, Vc,\n+    NonLocalValue, OperationVc, ResolvedVc, TransientInstance, TurboTasks, UpdateInfo, Value, Vc,\n };\n use turbo_tasks_backend::{\n     noop_backing_storage, BackendOptions, NoopBackingStorage, TurboTasksBackend,\n@@ -34,7 +35,7 @@ use turbopack_dev_server::{\n         combined::CombinedContentSource, router::PrefixedRouterContentSource,\n         static_assets::StaticAssetsContentSource, ContentSource,\n     },\n-    DevServer, DevServerBuilder, NonLocalSourceProvider,\n+    DevServer, DevServerBuilder, SourceProvider,\n };\n use turbopack_ecmascript_runtime::RuntimeType;\n use turbopack_env::dotenv::load_env;\n@@ -215,17 +216,32 @@ impl TurbopackDevServerBuilder {\n             Box::new(move || Vc::upcast(ConsoleUi::new(log_args.clone())))\n         });\n \n-        let source = move || {\n-            source(\n-                root_dir.clone(),\n-                project_dir.clone(),\n-                entry_requests.clone(),\n-                eager_compile,\n-                browserslist_query.clone(),\n-            )\n+        #[derive(Clone, TraceRawVcs, NonLocalValue)]\n+        struct ServerSourceProvider {\n+            root_dir: RcStr,\n+            project_dir: RcStr,\n+            entry_requests: TransientInstance<Vec<EntryRequest>>,\n+            eager_compile: bool,\n+            browserslist_query: RcStr,\n+        }\n+        impl SourceProvider for ServerSourceProvider {\n+            fn get_source(&self) -> OperationVc<Box<dyn ContentSource>> {\n+                source(\n+                    self.root_dir.clone(),\n+                    self.project_dir.clone(),\n+                    self.entry_requests.clone(),\n+                    self.eager_compile,\n+                    self.browserslist_query.clone(),\n+                )\n+            }\n+        }\n+        let source = ServerSourceProvider {\n+            root_dir,\n+            project_dir,\n+            entry_requests,\n+            eager_compile,\n+            browserslist_query,\n         };\n-        // safety: Everything that `source` captures in its closure is a `NonLocalValue`\n-        let source = unsafe { NonLocalSourceProvider::new(source) };\n \n         let issue_reporter_arc = Arc::new(move || issue_provider.get_issue_reporter());\n         Ok(server.serve(tasks, source, issue_reporter_arc))"
        },
        {
            "sha": "716ea1e4ddc106f76832e2bb01b50db43cac97fb",
            "filename": "turbopack/crates/turbopack-cli/src/util.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Futil.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -4,10 +4,12 @@ use anyhow::{Context, Result};\n use dunce::canonicalize;\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{NonLocalValue, TaskInput, Vc};\n+use turbo_tasks::{trace::TraceRawVcs, NonLocalValue, TaskInput, Vc};\n use turbo_tasks_fs::{DiskFileSystem, FileSystem};\n \n-#[derive(Clone, Debug, TaskInput, Hash, PartialEq, Eq, NonLocalValue, Serialize, Deserialize)]\n+#[derive(\n+    Clone, Debug, TaskInput, Hash, PartialEq, Eq, NonLocalValue, Serialize, Deserialize, TraceRawVcs,\n+)]\n pub enum EntryRequest {\n     Relative(RcStr),\n     Module(RcStr, RcStr),"
        },
        {
            "sha": "91776a7f8d673332d1193f73ada109b6c8423b30",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -151,7 +151,7 @@ impl ChunkGroupEntry {\n     }\n }\n \n-#[derive(Debug, Clone, Hash, TaskInput, PartialEq, Eq, Serialize, Deserialize)]\n+#[derive(Debug, Clone, Hash, TaskInput, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs)]\n pub enum ChunkGroup {\n     /// e.g. a page\n     Entry(Vec<ResolvedVc<Box<dyn Module>>>),"
        },
        {
            "sha": "8e450570c51001470122b3ce5585daff93a52257",
            "filename": "turbopack/crates/turbopack-dev-server/Cargo.toml",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-dev-server%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-dev-server%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2FCargo.toml?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -48,5 +48,8 @@ turbopack-ecmascript = { workspace = true }\n turbopack-ecmascript-hmr-protocol = { workspace = true }\n urlencoding = \"2.1.2\"\n \n+[dev-dependencies]\n+turbo-tasks-backend = { workspace = true }\n+\n [build-dependencies]\n turbo-tasks-build = { workspace = true }"
        },
        {
            "sha": "4032f07ff8b77b2997e7b34542f7338cd12507db",
            "filename": "turbopack/crates/turbopack-dev-server/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 31,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Flib.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -61,36 +61,6 @@ where\n     }\n }\n \n-#[derive(Clone)]\n-pub struct NonLocalSourceProvider<T>(T);\n-\n-impl<T> NonLocalSourceProvider<T> {\n-    /// Wrap a `SourceProvider` in a type that implements `NonLocalValue`. This is useful for\n-    /// closures that cannot implement `NonLocalValue` themselves.\n-    ///\n-    /// In the future, `auto_traits` may be be able to implement `NonLocalValue` for us, and avoid\n-    /// this wrapper type and unsafe constructor.\n-    ///\n-    /// # Safety\n-    ///\n-    /// `source_provider` must be a type that could safely implement `NonLocalValue`. If it's a\n-    /// closure, the closure must not capture any values that are not a `NonLocalValue`.\n-    pub unsafe fn new(source_provider: T) -> Self {\n-        Self(source_provider)\n-    }\n-}\n-\n-unsafe impl<T> NonLocalValue for NonLocalSourceProvider<T> {}\n-\n-impl<T> SourceProvider for NonLocalSourceProvider<T>\n-where\n-    T: SourceProvider,\n-{\n-    fn get_source(&self) -> OperationVc<Box<dyn ContentSource>> {\n-        self.0.get_source()\n-    }\n-}\n-\n #[derive(TraceRawVcs, Debug, NonLocalValue)]\n pub struct DevServerBuilder {\n     #[turbo_tasks(trace_ignore)]\n@@ -146,7 +116,7 @@ impl DevServerBuilder {\n     pub fn serve(\n         self,\n         turbo_tasks: Arc<dyn TurboTasksApi>,\n-        source_provider: impl SourceProvider + NonLocalValue + Sync,\n+        source_provider: impl SourceProvider + NonLocalValue + TraceRawVcs + Sync,\n         get_issue_reporter: Arc<dyn Fn() -> Vc<Box<dyn IssueReporter>> + Send + Sync>,\n     ) -> DevServer {\n         let ongoing_side_effects = Arc::new(Mutex::new(VecDeque::<"
        },
        {
            "sha": "a3e4e2e12d0b44505bf4854e510d066851147d4a",
            "filename": "turbopack/crates/turbopack-dev-server/src/source/request.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Frequest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Frequest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Frequest.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -1,10 +1,10 @@\n use hyper::{HeaderMap, Uri};\n-use turbo_tasks::NonLocalValue;\n+use turbo_tasks::{trace::TraceRawVcs, NonLocalValue};\n \n use super::Body;\n \n /// A request to a content source.\n-#[derive(Debug, Clone, NonLocalValue)]\n+#[derive(Debug, Clone, NonLocalValue, TraceRawVcs)]\n pub struct SourceRequest {\n     /// The HTTP method to use.\n     pub method: String,"
        },
        {
            "sha": "d1740261fa00bcd79c7ee0318b7840427ab79323",
            "filename": "turbopack/crates/turbopack-dev-server/src/source/resolve.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fresolve.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -24,7 +24,7 @@ use super::{\n /// The result of [`resolve_source_request`]. Similar to a\n /// `ContentSourceContent`, but without the `Rewrite` variant as this is taken\n /// care in the function.\n-#[turbo_tasks::value(serialization = \"none\")]\n+#[turbo_tasks::value(serialization = \"none\", shared)]\n pub enum ResolveSourceRequestResult {\n     NotFound,\n     Static(ResolvedVc<StaticContent>, ResolvedVc<HeaderList>),"
        },
        {
            "sha": "be6a6bc5308cc2b94ec89cc3b3145f67e3e3938b",
            "filename": "turbopack/crates/turbopack-dev-server/src/update/server.rs",
            "status": "modified",
            "additions": 100,
            "deletions": 55,
            "changes": 155,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fserver.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fserver.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fserver.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -1,4 +1,5 @@\n use std::{\n+    ops::ControlFlow,\n     pin::Pin,\n     task::{Context, Poll},\n };\n@@ -11,15 +12,21 @@ use pin_project_lite::pin_project;\n use tokio::select;\n use tokio_stream::StreamMap;\n use tracing::{instrument, Level};\n-use turbo_tasks::{NonLocalValue, TransientInstance, TurboTasksApi, Vc};\n+use turbo_tasks::{\n+    trace::TraceRawVcs, NonLocalValue, OperationVc, ReadRef, TransientInstance, TurboTasksApi, Vc,\n+};\n use turbo_tasks_fs::json::parse_json_with_source_context;\n use turbopack_core::{error::PrettyPrintError, issue::IssueReporter, version::Update};\n use turbopack_ecmascript_hmr_protocol::{\n     ClientMessage, ClientUpdateInstruction, Issue, ResourceIdentifier,\n };\n \n use crate::{\n-    source::{request::SourceRequest, resolve::resolve_source_request, Body},\n+    source::{\n+        request::SourceRequest,\n+        resolve::{resolve_source_request, ResolveSourceRequestResult},\n+        Body,\n+    },\n     update::stream::{GetContentFn, UpdateStream, UpdateStreamItem},\n     SourceProvider,\n };\n@@ -33,7 +40,7 @@ pub(crate) struct UpdateServer<P: SourceProvider> {\n \n impl<P> UpdateServer<P>\n where\n-    P: SourceProvider + NonLocalValue + Clone + Send + Sync,\n+    P: SourceProvider + NonLocalValue + TraceRawVcs + Clone + Send + Sync,\n {\n     /// Create a new update server with the given websocket and content source.\n     pub fn new(source_provider: P, issue_reporter: Vc<Box<dyn IssueReporter>>) -> Self {\n@@ -60,60 +67,25 @@ where\n         let mut streams = StreamMap::new();\n \n         loop {\n+            // most logic is in helper functions as rustfmt cannot format code inside the macro\n             select! {\n                 message = client.try_next() => {\n-                    match message? {\n-                        Some(ClientMessage::Subscribe { resource }) => {\n-                            let get_content = {\n-                                let source_provider = self.source_provider.clone();\n-                                let request = resource_to_request(&resource)?;\n-                                move || {\n-                                    let request = request.clone();\n-                                    let source = source_provider.get_source();\n-                                    resolve_source_request(\n-                                        source,\n-                                        TransientInstance::new(request)\n-                                    )\n-                                }\n-                            };\n-                            match UpdateStream::new(\n-                                resource.to_string().into(),\n-                                // safety: Everything that `get_content` captures in it's closure is\n-                                // a `NonLocalValue`.\n-                                TransientInstance::new(unsafe { GetContentFn::new(get_content) })\n-                            ).await {\n-                                Ok(stream) => {\n-                                    streams.insert(resource, stream);\n-                                }\n-                                Err(err) => {\n-                                    eprintln!(\n-                                        \"Failed to create update stream for {resource}: {}\",\n-                                        PrettyPrintError(&err),\n-                                    );\n-                                    client\n-                                        .send(ClientUpdateInstruction::not_found(&resource))\n-                                        .await?;\n-                                }\n-                            }\n-                        }\n-                        Some(ClientMessage::Unsubscribe { resource }) => {\n-                            streams.remove(&resource);\n-                        }\n-                        None => {\n-                            // WebSocket was closed, stop sending updates\n-                            break;\n-                        }\n+                    if Self::on_message(\n+                        &mut client,\n+                        &mut streams,\n+                        &self.source_provider,\n+                        message?,\n+                    ).await?.is_break() {\n+                        break;\n                     }\n                 }\n-                Some((resource, update)) = streams.next() => {\n-                    match update {\n-                        Ok(update) => {\n-                            Self::send_update(&mut client, &mut streams, resource, &update).await?;\n-                        }\n-                        Err(err) => {\n-                            eprintln!(\"Failed to get update for {resource}: {}\", PrettyPrintError(&err));\n-                        }\n-                    }\n+                Some((resource, update_result)) = streams.next() => {\n+                    Self::on_stream(\n+                        &mut client,\n+                        &mut streams,\n+                        resource,\n+                        update_result,\n+                    ).await?\n                 }\n                 else => break\n             }\n@@ -122,13 +94,86 @@ where\n         Ok(())\n     }\n \n+    /// Helper for `on_message` used to construct a `GetContentFn`. Argument must match\n+    /// `get_content_capture`.\n+    fn get_content(\n+        (source_provider, request): &(P, SourceRequest),\n+    ) -> OperationVc<ResolveSourceRequestResult> {\n+        let request = request.clone();\n+        let source = source_provider.get_source();\n+        resolve_source_request(source, TransientInstance::new(request))\n+    }\n+\n+    /// receives ClientMessages and passes subscriptions to `on_stream` via the `streams` map.\n+    async fn on_message(\n+        client: &mut UpdateClient,\n+        streams: &mut StreamMap<ResourceIdentifier, UpdateStream>,\n+        source_provider: &P,\n+        message: Option<ClientMessage>,\n+    ) -> Result<ControlFlow<()>> {\n+        match message {\n+            Some(ClientMessage::Subscribe { resource }) => {\n+                let get_content_capture =\n+                    (source_provider.clone(), resource_to_request(&resource)?);\n+                match UpdateStream::new(\n+                    resource.to_string().into(),\n+                    TransientInstance::new(GetContentFn::new(\n+                        get_content_capture,\n+                        Self::get_content,\n+                    )),\n+                )\n+                .await\n+                {\n+                    Ok(stream) => {\n+                        streams.insert(resource, stream);\n+                    }\n+                    Err(err) => {\n+                        eprintln!(\n+                            \"Failed to create update stream for {resource}: {}\",\n+                            PrettyPrintError(&err),\n+                        );\n+                        client\n+                            .send(ClientUpdateInstruction::not_found(&resource))\n+                            .await?;\n+                    }\n+                }\n+            }\n+            Some(ClientMessage::Unsubscribe { resource }) => {\n+                streams.remove(&resource);\n+            }\n+            None => {\n+                // WebSocket was closed, stop sending updates\n+                return Ok(ControlFlow::Break(()));\n+            }\n+        }\n+        Ok(ControlFlow::Continue(()))\n+    }\n+\n+    async fn on_stream(\n+        client: &mut UpdateClient,\n+        streams: &mut StreamMap<ResourceIdentifier, UpdateStream>,\n+        resource: ResourceIdentifier,\n+        update_result: Result<ReadRef<UpdateStreamItem>>,\n+    ) -> Result<()> {\n+        match update_result {\n+            Ok(update_item) => Self::send_update(client, streams, resource, &update_item).await,\n+            Err(err) => {\n+                eprintln!(\n+                    \"Failed to get update for {resource}: {}\",\n+                    PrettyPrintError(&err)\n+                );\n+                Ok(())\n+            }\n+        }\n+    }\n+\n     async fn send_update(\n         client: &mut UpdateClient,\n         streams: &mut StreamMap<ResourceIdentifier, UpdateStream>,\n         resource: ResourceIdentifier,\n-        item: &UpdateStreamItem,\n+        update_item: &UpdateStreamItem,\n     ) -> Result<()> {\n-        match item {\n+        match update_item {\n             UpdateStreamItem::NotFound => {\n                 // If the resource was not found, we remove the stream and indicate that to the\n                 // client."
        },
        {
            "sha": "ea344ae0376d0b28d95053c30fc2b753920557d8",
            "filename": "turbopack/crates/turbopack-dev-server/src/update/stream.rs",
            "status": "modified",
            "additions": 116,
            "deletions": 40,
            "changes": 156,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fstream.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fstream.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fupdate%2Fstream.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -1,4 +1,4 @@\n-use std::{ops::Deref, pin::Pin};\n+use std::pin::Pin;\n \n use anyhow::Result;\n use futures::prelude::*;\n@@ -7,6 +7,7 @@ use tokio_stream::wrappers::ReceiverStream;\n use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n+    trace::{TraceRawVcs, TraceRawVcsContext},\n     IntoTraitRef, NonLocalValue, OperationVc, ReadRef, ResolvedVc, TransientInstance, Vc,\n };\n use turbo_tasks_fs::{FileSystem, FileSystemPath};\n@@ -25,48 +26,64 @@ use turbopack_core::{\n \n use crate::source::{resolve::ResolveSourceRequestResult, ProxyResult};\n \n-/// A wrapper type returning\n-/// [`OperationVc<ResolveSourceRequestResult>`][ResolveSourceRequestResult] that implements\n-/// [`NonLocalValue`].\n-pub struct GetContentFn(Box<dyn Fn() -> OperationVc<ResolveSourceRequestResult> + Send + Sync>);\n+struct TypedGetContentFn<C> {\n+    capture: C,\n+    func: for<'a> fn(&'a C) -> OperationVc<ResolveSourceRequestResult>,\n+}\n \n-impl GetContentFn {\n-    /// Wrap a function in `GetContentFn`.\n-    ///\n-    /// # Safety\n-    ///\n-    /// The closure must not include any types that aren't `NonLocalValue`, or that couldn't\n-    /// otherwise safely implement `NonLocalValue`.\n-    ///\n-    /// In the future, `auto_traits` may be be able to implement `NonLocalValue` for us, and avoid\n-    /// this wrapper type and unsafe constructor.\n-    pub unsafe fn new(\n-        func: impl Fn() -> OperationVc<ResolveSourceRequestResult> + Send + Sync + 'static,\n-    ) -> Self {\n-        Self::new_boxed(Box::new(func))\n+// Manual (non-derive) impl required due to: https://github.com/rust-lang/rust/issues/70263\n+// Safety: `capture` is `NonLocalValue`, `func` stores no data (is a static pointer to code)\n+unsafe impl<C: NonLocalValue> NonLocalValue for TypedGetContentFn<C> {}\n+\n+// Manual (non-derive) impl required due to: https://github.com/rust-lang/rust/issues/70263\n+impl<C: TraceRawVcs> TraceRawVcs for TypedGetContentFn<C> {\n+    fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n+        self.capture.trace_raw_vcs(trace_context);\n     }\n+}\n+\n+trait TypedGetContentFnTrait: NonLocalValue + TraceRawVcs {\n+    fn call(&self) -> OperationVc<ResolveSourceRequestResult>;\n+}\n \n-    /// Wrap a boxed function in `GetContentFn`. This specialized version of [`GetContentFn::new`]\n-    /// avoids double-boxing if you already have a boxed function.\n-    ///\n-    /// # Safety\n-    ///\n-    /// Same as [`GetContentFn::new`].\n-    pub unsafe fn new_boxed(\n-        func: Box<dyn Fn() -> OperationVc<ResolveSourceRequestResult> + Send + Sync>,\n-    ) -> Self {\n-        Self(func)\n+impl<C> TypedGetContentFnTrait for TypedGetContentFn<C>\n+where\n+    C: NonLocalValue + TraceRawVcs,\n+{\n+    fn call(&self) -> OperationVc<ResolveSourceRequestResult> {\n+        (self.func)(&self.capture)\n     }\n }\n \n-// Safety: It's up to the caller of `GetContentFn::new` to ensure this.\n-unsafe impl NonLocalValue for GetContentFn {}\n+/// A wrapper type returning [`OperationVc<ResolveSourceRequestResult>`][ResolveSourceRequestResult]\n+/// that implements [`NonLocalValue`] and [`TraceRawVcs`].\n+///\n+/// The capture (e.g. moved values in a closure) and function pointer are stored separately to allow\n+/// safe implementation of these desired traits.\n+#[derive(NonLocalValue, TraceRawVcs)]\n+pub struct GetContentFn {\n+    inner: Box<dyn TypedGetContentFnTrait + Send + Sync>,\n+}\n \n-impl Deref for GetContentFn {\n-    type Target = Box<dyn Fn() -> OperationVc<ResolveSourceRequestResult> + Send + Sync>;\n+impl GetContentFn {\n+    /// Wrap a function and an optional capture variable (used to simulate a closure) in\n+    /// `GetContentFn`.\n+    pub fn new<C>(\n+        capture: C,\n+        func: for<'a> fn(&'a C) -> OperationVc<ResolveSourceRequestResult>,\n+    ) -> Self\n+    where\n+        C: NonLocalValue + TraceRawVcs + Send + Sync + 'static,\n+    {\n+        Self {\n+            inner: Box::new(TypedGetContentFn { capture, func }),\n+        }\n+    }\n+}\n \n-    fn deref(&self) -> &Self::Target {\n-        &self.0\n+impl GetContentFn {\n+    fn call(&self) -> OperationVc<ResolveSourceRequestResult> {\n+        self.inner.call()\n     }\n }\n \n@@ -100,7 +117,7 @@ async fn get_update_stream_item_operation(\n     from: ResolvedVc<VersionState>,\n     get_content: TransientInstance<GetContentFn>,\n ) -> Result<Vc<UpdateStreamItem>> {\n-    let content_op = get_content();\n+    let content_op = get_content.call();\n     let content_result = content_op.read_strongly_consistent().await;\n     let mut plain_issues = peek_issues(content_op).await?;\n \n@@ -211,19 +228,32 @@ async fn get_update_stream_item_operation(\n     }\n }\n \n+#[derive(TraceRawVcs)]\n+struct ComputeUpdateStreamSender(\n+    // HACK: `trace_ignore`: It's not correct or safe to send `Vc`s across this mpsc channel, but\n+    // (without nightly auto traits) there's no easy way for us to statically assert that\n+    // `UpdateStreamItem` does not contain a `RawVc`.\n+    //\n+    // It could be safe (at least for the GC use-case) if we had some way of wrapping arbitrary\n+    // objects in a GC root container.\n+    #[turbo_tasks(trace_ignore)] Sender<Result<ReadRef<UpdateStreamItem>>>,\n+);\n+\n+/// This function sends an [`UpdateStreamItem`] to `sender` every time it gets recomputed by\n+/// turbo-tasks due to invalidation.\n #[turbo_tasks::function]\n async fn compute_update_stream(\n     resource: RcStr,\n     from: ResolvedVc<VersionState>,\n     get_content: TransientInstance<GetContentFn>,\n-    sender: TransientInstance<Sender<Result<ReadRef<UpdateStreamItem>>>>,\n+    sender: TransientInstance<ComputeUpdateStreamSender>,\n ) -> Vc<()> {\n     let item = get_update_stream_item_operation(resource, from, get_content)\n         .read_strongly_consistent()\n         .await;\n \n     // Send update. Ignore channel closed error.\n-    let _ = sender.send(item).await;\n+    let _ = sender.0.send(item).await;\n \n     Default::default()\n }\n@@ -240,7 +270,7 @@ impl UpdateStream {\n     ) -> Result<UpdateStream> {\n         let (sx, rx) = tokio::sync::mpsc::channel(32);\n \n-        let content = get_content();\n+        let content = get_content.call();\n         // We can ignore issues reported in content here since [compute_update_stream]\n         // will handle them\n         let version = match *content.connect().await? {\n@@ -258,7 +288,7 @@ impl UpdateStream {\n             resource,\n             version_state,\n             get_content,\n-            TransientInstance::new(sx),\n+            TransientInstance::new(ComputeUpdateStreamSender(sx)),\n         );\n \n         let mut last_had_issues = false;\n@@ -367,3 +397,49 @@ impl Issue for FatalStreamIssue {\n         Vc::cell(Some(self.description))\n     }\n }\n+\n+#[cfg(test)]\n+pub mod test {\n+    use std::sync::{\n+        atomic::{AtomicI32, Ordering},\n+        Arc,\n+    };\n+\n+    use turbo_tasks::TurboTasks;\n+    use turbo_tasks_backend::{noop_backing_storage, BackendOptions, TurboTasksBackend};\n+\n+    use super::*;\n+\n+    #[turbo_tasks::function(operation)]\n+    pub fn noop_operation() -> Vc<ResolveSourceRequestResult> {\n+        ResolveSourceRequestResult::NotFound.cell()\n+    }\n+\n+    #[tokio::test]\n+    async fn test_get_content_fn() {\n+        crate::register();\n+        let tt = TurboTasks::new(TurboTasksBackend::new(\n+            BackendOptions::default(),\n+            noop_backing_storage(),\n+        ));\n+        tt.run_once(async move {\n+            let number = Arc::new(AtomicI32::new(0));\n+            fn func(number: &Arc<AtomicI32>) -> OperationVc<ResolveSourceRequestResult> {\n+                number.store(42, Ordering::SeqCst);\n+                noop_operation()\n+            }\n+            let wrapped_func = GetContentFn::new(number.clone(), func);\n+            let return_value = wrapped_func\n+                .call()\n+                .read_strongly_consistent()\n+                .await\n+                .unwrap();\n+            assert_eq!(number.load(Ordering::SeqCst), 42);\n+            // ResolveSourceRequestResult doesn't impl Debug\n+            assert!(*return_value == ResolveSourceRequestResult::NotFound);\n+            Ok(())\n+        })\n+        .await\n+        .unwrap();\n+    }\n+}"
        },
        {
            "sha": "d9490912cb769ec6109a126001167491828f2295",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -772,7 +772,7 @@ pub struct EcmascriptModuleContent {\n     // pub refresh: bool,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, TaskInput)]\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, TaskInput, TraceRawVcs)]\n pub struct EcmascriptModuleContentOptions {\n     parsed: ResolvedVc<ParseResult>,\n     ident: Vc<AssetIdent>,"
        },
        {
            "sha": "c4f3b2697e229c9c22d3c2ef2ea78a443402b8e9",
            "filename": "turbopack/crates/turbopack-node/src/evaluate.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 5,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -12,9 +12,9 @@ use parking_lot::Mutex;\n use serde::{de::DeserializeOwned, Deserialize, Serialize};\n use serde_json::Value as JsonValue;\n use turbo_tasks::{\n-    apply_effects, duration_span, fxindexmap, mark_finished, prevent_gc, util::SharedError,\n-    Completion, FxIndexMap, NonLocalValue, OperationVc, RawVc, ResolvedVc, TaskInput,\n-    TryJoinIterExt, Value, Vc,\n+    apply_effects, duration_span, fxindexmap, mark_finished, prevent_gc, trace::TraceRawVcs,\n+    util::SharedError, Completion, FxIndexMap, NonLocalValue, OperationVc, RawVc, ResolvedVc,\n+    TaskInput, TryJoinIterExt, Value, Vc,\n };\n use turbo_tasks_bytes::{Bytes, Stream};\n use turbo_tasks_env::{EnvMap, ProcessEnv};\n@@ -201,7 +201,17 @@ async fn emit_evaluate_pool_assets_with_effects_operation(\n }\n \n #[derive(\n-    Clone, Copy, Hash, Debug, PartialEq, Eq, Serialize, Deserialize, TaskInput, NonLocalValue,\n+    Clone,\n+    Copy,\n+    Hash,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    Serialize,\n+    Deserialize,\n+    TaskInput,\n+    NonLocalValue,\n+    TraceRawVcs,\n )]\n pub enum EnvVarTracking {\n     WholeEnvTracked,\n@@ -567,7 +577,7 @@ async fn basic_compute(\n     compute(evaluate_context, sender).await\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, TaskInput, Debug, Serialize, Deserialize)]\n+#[derive(Clone, PartialEq, Eq, Hash, TaskInput, Debug, Serialize, Deserialize, TraceRawVcs)]\n struct BasicEvaluateContext {\n     module_asset: ResolvedVc<Box<dyn Module>>,\n     cwd: ResolvedVc<FileSystemPath>,"
        },
        {
            "sha": "78795e93310e220a9b6279f678e11719392c7ed9",
            "filename": "turbopack/crates/turbopack-node/src/render/render_proxy.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_proxy.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_proxy.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_proxy.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -8,8 +8,8 @@ use parking_lot::Mutex;\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    duration_span, mark_finished, prevent_gc, util::SharedError, RawVc, ResolvedVc, TaskInput,\n-    ValueToString, Vc,\n+    duration_span, mark_finished, prevent_gc, trace::TraceRawVcs, util::SharedError, RawVc,\n+    ResolvedVc, TaskInput, ValueToString, Vc,\n };\n use turbo_tasks_bytes::{Bytes, Stream};\n use turbo_tasks_env::ProcessEnv;\n@@ -149,7 +149,7 @@ struct RenderStreamSender {\n #[turbo_tasks::value(transparent)]\n struct RenderStream(#[turbo_tasks(trace_ignore)] Stream<RenderItemResult>);\n \n-#[derive(Clone, Debug, TaskInput, PartialEq, Eq, Hash, Serialize, Deserialize)]\n+#[derive(Clone, Debug, TaskInput, PartialEq, Eq, Hash, Serialize, Deserialize, TraceRawVcs)]\n struct RenderStreamOptions {\n     cwd: ResolvedVc<FileSystemPath>,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,"
        },
        {
            "sha": "5ce3bda29e8b79bba07ffc388f28464662bf7c60",
            "filename": "turbopack/crates/turbopack-node/src/render/render_static.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_static.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_static.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Frender%2Frender_static.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -7,8 +7,8 @@ use futures::{\n use parking_lot::Mutex;\n use serde::{Deserialize, Serialize};\n use turbo_tasks::{\n-    duration_span, mark_finished, prevent_gc, util::SharedError, RawVc, ResolvedVc, TaskInput,\n-    ValueToString, Vc,\n+    duration_span, mark_finished, prevent_gc, trace::TraceRawVcs, util::SharedError, RawVc,\n+    ResolvedVc, TaskInput, ValueToString, Vc,\n };\n use turbo_tasks_bytes::{Bytes, Stream};\n use turbo_tasks_env::ProcessEnv;\n@@ -199,7 +199,7 @@ struct RenderStreamSender {\n #[turbo_tasks::value(transparent)]\n struct RenderStream(#[turbo_tasks(trace_ignore)] Stream<RenderItemResult>);\n \n-#[derive(Clone, Debug, TaskInput, PartialEq, Eq, Hash, Deserialize, Serialize)]\n+#[derive(Clone, Debug, TaskInput, PartialEq, Eq, Hash, Deserialize, Serialize, TraceRawVcs)]\n struct RenderStreamOptions {\n     cwd: ResolvedVc<FileSystemPath>,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,"
        },
        {
            "sha": "32603639d1721b2978eebed9a06364467c3e3667",
            "filename": "turbopack/crates/turbopack-node/src/transforms/webpack.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2e76e15f59d4695ee783ff370f39e2921e5368a9/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs?ref=2e76e15f59d4695ee783ff370f39e2921e5368a9",
            "patch": "@@ -368,7 +368,7 @@ pub enum InfoMessage {\n     Log(LogInfo),\n }\n \n-#[derive(Debug, Clone, TaskInput, Hash, PartialEq, Eq, Serialize, Deserialize)]\n+#[derive(Debug, Clone, TaskInput, Hash, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs)]\n #[serde(rename_all = \"camelCase\")]\n pub struct WebpackResolveOptions {\n     alias_fields: Option<Vec<RcStr>>,\n@@ -399,7 +399,7 @@ pub enum ResponseMessage {\n     Resolve { path: RcStr },\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, TaskInput, Serialize, Deserialize, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, TaskInput, Serialize, Deserialize, Debug, TraceRawVcs)]\n pub struct WebpackLoaderContext {\n     pub module_asset: ResolvedVc<Box<dyn Module>>,\n     pub cwd: ResolvedVc<FileSystemPath>,"
        }
    ],
    "stats": {
        "total": 615,
        "additions": 425,
        "deletions": 190
    }
}