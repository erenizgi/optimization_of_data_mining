{
    "author": "lubieowoce",
    "message": "fix: bodySizeLimit error responses + limit for non-multipart actions (#77746)\n\nThis PR fixes some bugs in our handling of\n`serverActions.bodySizeLimit`. There's a couple fixes here, which can be\nviewed commit by commit.\n\n### 1. Uncaught exception error when exceeding the size limit\nWe were using `body.pipe(busboy)`, which does not forward errors from\nthe source to the sink, so the busboy stream would just hang, and we'd\nlog an error, but never produce a response. It seems like node is\n(usually) smart enough to abort the request when this happens (because\nit was triggering an uncaught exception), but we should be returning a\nproper response instead. This is fixed by using\n`require('node:stream').pipeline(body, busboy)`, which propagates errors\ncorrectly.\n\n### 2. Apply size limit to non-multipart fetch actions\n\nWe have a separate codepath for non-multipart fetch actions. This can\nhappen if the action arguments are simple enough that react doesn't need\nto use multiple rows to serialize them -- generally, this means that\nthey're JSON-esque without any complex types like Promises, Maps, or\nSets.\n\nThis codepath was consuming the original request body, not the one piped\nthrough the size limit transform. So we'd print the error (because the\ntransform is subscribed to the body), but still execute the action.\n\n### 3. Tests\n\nThe likely reason that these bugs slipped through is that the tests were\nonly checking if an error was printed to the console, and not checking\nif the server actually responded with an error. To prevent this, I've\nadded some assertions on the responses' status codes + checking whether\nan error boundary was triggered. I've also tweaked the tests so that the\nparts that submit actions can run in deploy mode.\n\nThe request interception code proved subtle/complicated enough that i\ndecided to pull it out into a separate helper. We have a whole bunch of\ntests that intercept requests/responses using various ad-hoc tangles of\n`page/browser.on('request', ...)` which i'd like to migrate to this\nhelper, because that'd make them easier to understand, but I'll leave\nthat for a follow up when there's time.",
    "sha": "1a07ce2005317bda2763b16159aeec77f30aaa04",
    "files": [
        {
            "sha": "ec07aa0d4785b889c40c41e43b6f4592b905c484",
            "filename": "packages/next/src/server/app-render/action-handler.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 24,
            "changes": 64,
            "blob_url": "https://github.com/vercel/next.js/blob/1a07ce2005317bda2763b16159aeec77f30aaa04/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1a07ce2005317bda2763b16159aeec77f30aaa04/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts?ref=1a07ce2005317bda2763b16159aeec77f30aaa04",
            "patch": "@@ -752,7 +752,7 @@ export async function handleAction({\n \n         temporaryReferences = createTemporaryReferenceSet()\n \n-        const { Transform } =\n+        const { Transform, pipeline } =\n           require('node:stream') as typeof import('node:stream')\n \n         const defaultBodySizeLimit = '1 MB'\n@@ -766,26 +766,32 @@ export async function handleAction({\n             : 1024 * 1024 // 1 MB\n \n         let size = 0\n-        const body = req.body.pipe(\n-          new Transform({\n-            transform(chunk, encoding, callback) {\n-              size += Buffer.byteLength(chunk, encoding)\n-              if (size > bodySizeLimitBytes) {\n-                const { ApiError } = require('../api-utils')\n-\n-                callback(\n-                  new ApiError(\n-                    413,\n-                    `Body exceeded ${bodySizeLimit} limit.\n-                To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`\n-                  )\n+        const sizeLimitTransform = new Transform({\n+          transform(chunk, encoding, callback) {\n+            size += Buffer.byteLength(chunk, encoding)\n+            if (size > bodySizeLimitBytes) {\n+              const { ApiError } = require('../api-utils')\n+\n+              callback(\n+                new ApiError(\n+                  413,\n+                  `Body exceeded ${bodySizeLimit} limit.\\n` +\n+                    `To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`\n                 )\n-                return\n-              }\n+              )\n+              return\n+            }\n \n-              callback(null, chunk)\n-            },\n-          })\n+            callback(null, chunk)\n+          },\n+        })\n+\n+        const sizeLimitedBody = pipeline(\n+          req.body,\n+          sizeLimitTransform,\n+          // Avoid unhandled errors from `pipeline()` by passing an empty completion callback.\n+          // We'll propagate the errors properly when consuming the stream.\n+          () => {}\n         )\n \n         if (isMultipartAction) {\n@@ -796,7 +802,14 @@ export async function handleAction({\n               limits: { fieldSize: bodySizeLimitBytes },\n             })\n \n-            body.pipe(busboy)\n+            // We need to use `pipeline(one, two)` instead of `one.pipe(two)` to propagate size limit errors correctly.\n+            pipeline(\n+              sizeLimitedBody,\n+              busboy,\n+              // Avoid unhandled errors from `pipeline()` by passing an empty completion callback.\n+              // We'll propagate the errors properly when consuming the stream.\n+              () => {}\n+            )\n \n             boundActionArguments = await decodeReplyFromBusboy(\n               busboy,\n@@ -812,13 +825,13 @@ export async function handleAction({\n               headers: { 'Content-Type': contentType },\n               body: new ReadableStream({\n                 start: (controller) => {\n-                  body.on('data', (chunk) => {\n+                  sizeLimitedBody.on('data', (chunk) => {\n                     controller.enqueue(new Uint8Array(chunk))\n                   })\n-                  body.on('end', () => {\n+                  sizeLimitedBody.on('end', () => {\n                     controller.close()\n                   })\n-                  body.on('error', (err) => {\n+                  sizeLimitedBody.on('error', (err) => {\n                     controller.error(err)\n                   })\n                 },\n@@ -865,7 +878,7 @@ export async function handleAction({\n           }\n \n           const chunks: Buffer[] = []\n-          for await (const chunk of req.body) {\n+          for await (const chunk of sizeLimitedBody) {\n             chunks.push(Buffer.from(chunk))\n           }\n \n@@ -1016,6 +1029,9 @@ export async function handleAction({\n     }\n \n     if (isFetchAction) {\n+      // TODO: consider checking if the error is an `ApiError` and change status code\n+      // so that we can respond with a 413 to requests that break the body size limit\n+      // (but if we do that, we also need to make sure that whatever handles the non-fetch error path below does the same)\n       res.statusCode = 500\n       await executeRevalidates(workStore)\n       const promise = Promise.reject(err)"
        },
        {
            "sha": "5375cfa24c5c82875060ac70f49c58aac75fc71e",
            "filename": "test/e2e/app-dir/actions/app-action-size-limit-invalid.test.ts",
            "status": "modified",
            "additions": 191,
            "deletions": 81,
            "changes": 272,
            "blob_url": "https://github.com/vercel/next.js/blob/1a07ce2005317bda2763b16159aeec77f30aaa04/test%2Fe2e%2Fapp-dir%2Factions%2Fapp-action-size-limit-invalid.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1a07ce2005317bda2763b16159aeec77f30aaa04/test%2Fe2e%2Fapp-dir%2Factions%2Fapp-action-size-limit-invalid.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions%2Fapp-action-size-limit-invalid.test.ts?ref=1a07ce2005317bda2763b16159aeec77f30aaa04",
            "patch": "@@ -1,5 +1,6 @@\n-import { nextTestSetup } from 'e2e-utils'\n+import { NextInstance, nextTestSetup } from 'e2e-utils'\n import { retry } from 'next-test-utils'\n+import { createRequestTracker } from 'e2e-utils/request-tracker'\n import stripAnsi from 'strip-ansi'\n import { accountForOverhead } from './account-for-overhead'\n \n@@ -9,7 +10,6 @@ const CONFIG_ERROR =\n describe('app-dir action size limit invalid config', () => {\n   const { next, isNextStart, isNextDeploy, skipped } = nextTestSetup({\n     files: __dirname,\n-    skipDeployment: true,\n     skipStart: true,\n     dependencies: {\n       nanoid: '4.0.1',\n@@ -18,11 +18,6 @@ describe('app-dir action size limit invalid config', () => {\n   })\n   if (skipped) return\n \n-  if (!isNextStart) {\n-    it('skip test for development mode', () => {})\n-    return\n-  }\n-\n   const logs: string[] = []\n \n   beforeAll(() => {\n@@ -40,118 +35,233 @@ describe('app-dir action size limit invalid config', () => {\n     await next.stop()\n   })\n \n-  it('should error if serverActions.bodySizeLimit config is a negative number', async function () {\n-    await next.patchFile(\n-      'next.config.js',\n-      `\n+  if (isNextStart) {\n+    it('should error if serverActions.bodySizeLimit config is a negative number', async function () {\n+      await using _ = await patchFileWithCleanup(\n+        next,\n+        'next.config.js',\n+        `\n       module.exports = {\n         experimental: {\n           serverActions: { bodySizeLimit: -3000 }\n         },\n       }\n       `\n-    )\n-    try {\n-      await next.start()\n-    } catch {}\n-    expect(next.cliOutput).toContain(CONFIG_ERROR)\n-  })\n+      )\n+      try {\n+        await next.start()\n+      } catch {}\n+      expect(next.cliOutput).toContain(CONFIG_ERROR)\n+    })\n \n-  it('should error if serverActions.bodySizeLimit config is invalid', async function () {\n-    await next.patchFile(\n-      'next.config.js',\n-      `\n+    it('should error if serverActions.bodySizeLimit config is invalid', async function () {\n+      await using _ = await patchFileWithCleanup(\n+        next,\n+        'next.config.js',\n+        `\n       module.exports = {\n         experimental: {\n           serverActions: { bodySizeLimit: 'testmb' }\n         },\n       }\n       `\n-    )\n-    try {\n-      await next.start()\n-    } catch {}\n-    expect(next.cliOutput).toContain(CONFIG_ERROR)\n-  })\n-\n-  it('should error if serverActions.bodySizeLimit config is a negative size', async function () {\n-    await next.patchFile(\n-      'next.config.js',\n-      `\n-      module.exports = {\n-        experimental: {\n-          serverActions: { bodySizeLimit: '-3000mb' }\n-        },\n-      }\n-      `\n-    )\n-    try {\n-      await next.start()\n-    } catch {}\n-    expect(next.cliOutput).toContain(CONFIG_ERROR)\n-  })\n+      )\n+      try {\n+        await next.start()\n+      } catch {}\n+      expect(next.cliOutput).toContain(CONFIG_ERROR)\n+    })\n \n-  if (!isNextDeploy) {\n-    it('should respect the size set in serverActions.bodySizeLimit', async function () {\n-      await next.patchFile(\n+    it('should error if serverActions.bodySizeLimit config is a negative size', async function () {\n+      await using _ = await patchFileWithCleanup(\n+        next,\n         'next.config.js',\n         `\n       module.exports = {\n         experimental: {\n-          serverActions: { bodySizeLimit: '1.5mb' }\n+          serverActions: { bodySizeLimit: '-3000mb' }\n         },\n       }\n       `\n       )\n+      try {\n+        await next.start()\n+      } catch {}\n+      expect(next.cliOutput).toContain(CONFIG_ERROR)\n+    })\n+  }\n+\n+  describe('should respect the size set in serverActions.bodySizeLimit for plaintext fetch actions', () => {\n+    beforeEach(async () => {\n       await next.start()\n+    })\n \n+    it('should not error for requests that stay below the size limit', async () => {\n       const browser = await next.browser('/file')\n-      await browser.elementByCss('#size-1mb').click()\n+      const requestTracker = createRequestTracker(browser)\n \n-      await retry(() => {\n-        expect(logs).toContainEqual(`size = ${accountForOverhead(1)}`)\n-      })\n-\n-      await browser.elementByCss('#size-2mb').click()\n+      // below the limit: ok\n+      const [, actionResponse] = await requestTracker.captureResponse(\n+        () => browser.elementByCss('#size-1mb').click(),\n+        { request: { method: 'POST', pathname: '/file' } }\n+      )\n+      expect(actionResponse.status()).toBe(200)\n+      expect(\n+        await actionResponse.request().headerValue('content-type')\n+      ).toStartWith('text/plain')\n \n-      await retry(() => {\n-        expect(logs).toContainEqual(\n-          expect.stringContaining('Error: Body exceeded 1.5mb limit')\n-        )\n-        expect(logs).toContainEqual(\n-          expect.stringContaining(\n-            'To configure the body size limit for Server Actions, see'\n+      if (!isNextDeploy) {\n+        await retry(() =>\n+          expect(logs).toContainEqual(\n+            expect.stringContaining(`size = ${accountForOverhead(1)}`)\n           )\n         )\n-      })\n+        expect(logs).not.toContainEqual(\n+          expect.stringContaining('Error: Body exceeded 2mb limit')\n+        )\n+      }\n     })\n \n-    it('should respect the size set in serverActions.bodySizeLimit when submitting form', async function () {\n-      await next.patchFile(\n-        'next.config.js',\n-        `\n-      module.exports = {\n-        experimental: {\n-          serverActions: { bodySizeLimit: '2mb' }\n-        },\n-      }\n-      `\n+    it('should error for requests that exceed the size limit', async () => {\n+      const browser = await next.browser('/file')\n+      const requestTracker = createRequestTracker(browser)\n+\n+      const [, actionResponse] = await requestTracker.captureResponse(\n+        () => browser.elementByCss('#size-3mb').click(),\n+        { request: { method: 'POST', pathname: '/file' } }\n+      )\n+      expect(actionResponse.status()).toBe(500) // TODO: 413?\n+      expect(\n+        await actionResponse.request().headerValue('content-type')\n+      ).toStartWith('text/plain')\n+\n+      // The error should have been returned to the client and thrown, triggering the nearest error boundary.\n+      expect(await browser.elementByCss('#error').text()).toBe(\n+        'Something went wrong!'\n       )\n \n+      if (!isNextDeploy) {\n+        await retry(() => {\n+          expect(logs).toContainEqual(\n+            expect.stringContaining('Error: Body exceeded 2mb limit')\n+          )\n+          expect(logs).toContainEqual(\n+            expect.stringContaining(\n+              'To configure the body size limit for Server Actions, see'\n+            )\n+          )\n+        })\n+        expect(logs).not.toContainEqual(expect.stringMatching(/^size = /))\n+      }\n+    })\n+  })\n+\n+  describe('should respect the size set in serverActions.bodySizeLimit for multipart fetch actions', () => {\n+    beforeEach(async () => {\n       await next.start()\n+    })\n+\n+    it('should not error for requests that stay below the size limit', async () => {\n+      const browser = await next.browser('/form')\n+      const requestTracker = createRequestTracker(browser)\n+\n+      const [, actionResponse] = await requestTracker.captureResponse(\n+        () => browser.elementByCss('#size-1mb').click(),\n+        { request: { method: 'POST', pathname: '/form' } }\n+      )\n+      expect(actionResponse.status()).toBe(200)\n+      expect(\n+        await actionResponse.request().headerValue('content-type')\n+      ).toStartWith('multipart/form-data')\n+\n+      if (!isNextDeploy) {\n+        await retry(() =>\n+          expect(logs).toContainEqual(\n+            expect.stringContaining(`size = ${accountForOverhead(1)}`)\n+          )\n+        )\n+        expect(logs).not.toContainEqual(\n+          expect.stringContaining('Error: Body exceeded 2mb limit')\n+        )\n+      }\n+    })\n \n+    it('should not error for requests that are at the size limit', async () => {\n       const browser = await next.browser('/form')\n-      await browser.elementByCss('#size-1mb').click()\n+      const requestTracker = createRequestTracker(browser)\n \n-      await retry(() => {\n-        expect(logs).toContainEqual(`size = ${accountForOverhead(1)}`)\n-      })\n+      const [, actionResponse] = await requestTracker.captureResponse(\n+        () => browser.elementByCss('#size-2mb').click(),\n+        { request: { method: 'POST', pathname: '/form' } }\n+      )\n+      expect(actionResponse.status()).toBe(200)\n+      expect(\n+        await actionResponse.request().headerValue('content-type')\n+      ).toStartWith('multipart/form-data')\n \n-      await browser.elementByCss('#size-2mb').click()\n+      if (!isNextDeploy) {\n+        await retry(() =>\n+          expect(logs).toContainEqual(\n+            expect.stringContaining(`size = ${accountForOverhead(2)}`)\n+          )\n+        )\n+        expect(logs).not.toContainEqual(\n+          expect.stringContaining('Error: Body exceeded 2mb limit')\n+        )\n+      }\n+    })\n \n-      await retry(() => {\n-        expect(logs).toContainEqual(`size = ${accountForOverhead(2)}`)\n-      })\n+    it('should error for requests that exceed the size limit', async () => {\n+      const browser = await next.browser('/form')\n+      const requestTracker = createRequestTracker(browser)\n+\n+      const [, actionResponse] = await requestTracker.captureResponse(\n+        () => browser.elementByCss('#size-3mb').click(),\n+        { request: { method: 'POST', pathname: '/form' } }\n+      )\n+      expect(actionResponse.status()).toBe(500) // TODO: 413?\n+      expect(\n+        await actionResponse.request().headerValue('content-type')\n+      ).toStartWith('multipart/form-data')\n+\n+      // The error should have been returned to the client and thrown, triggering the nearest error boundary.\n+      expect(await browser.elementByCss('#error').text()).toBe(\n+        'Something went wrong!'\n+      )\n+\n+      if (!isNextDeploy) {\n+        await retry(() => {\n+          expect(logs).toContainEqual(\n+            expect.stringContaining('Error: Body exceeded 2mb limit')\n+          )\n+          expect(logs).toContainEqual(\n+            expect.stringContaining(\n+              'To configure the body size limit for Server Actions, see'\n+            )\n+          )\n+        })\n+        expect(logs).not.toContainEqual(expect.stringMatching(/^size = /))\n+      }\n     })\n-  }\n+  })\n })\n+\n+async function patchFileWithCleanup(\n+  next: NextInstance,\n+  filename: Parameters<NextInstance['patchFile']>[0],\n+  contents: Parameters<NextInstance['patchFile']>[1]\n+): Promise<AsyncDisposable> {\n+  const originalFile = (await next.hasFile(filename))\n+    ? await next.readFile(filename)\n+    : null\n+  await next.patchFile(filename, contents)\n+  return {\n+    async [Symbol.asyncDispose]() {\n+      if (originalFile === null) {\n+        await next.deleteFile(filename)\n+      } else {\n+        await next.patchFile(filename, originalFile)\n+      }\n+    },\n+  }\n+}"
        },
        {
            "sha": "aaa644fb8f88aa4d9d32646b8c128b2bb327e423",
            "filename": "test/e2e/app-dir/actions/app/file/error.js",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/1a07ce2005317bda2763b16159aeec77f30aaa04/test%2Fe2e%2Fapp-dir%2Factions%2Fapp%2Ffile%2Ferror.js",
            "raw_url": "https://github.com/vercel/next.js/raw/1a07ce2005317bda2763b16159aeec77f30aaa04/test%2Fe2e%2Fapp-dir%2Factions%2Fapp%2Ffile%2Ferror.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions%2Fapp%2Ffile%2Ferror.js?ref=1a07ce2005317bda2763b16159aeec77f30aaa04",
            "patch": "@@ -0,0 +1,9 @@\n+'use client'\n+\n+export default function Error() {\n+  return (\n+    <div>\n+      <h2 id=\"error\">Something went wrong!</h2>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "a505bfa3e86473e3ed4921cd6ddeca70493fcb9b",
            "filename": "test/e2e/app-dir/actions/app/file/form.js",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/1a07ce2005317bda2763b16159aeec77f30aaa04/test%2Fe2e%2Fapp-dir%2Factions%2Fapp%2Ffile%2Fform.js",
            "raw_url": "https://github.com/vercel/next.js/raw/1a07ce2005317bda2763b16159aeec77f30aaa04/test%2Fe2e%2Fapp-dir%2Factions%2Fapp%2Ffile%2Fform.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions%2Fapp%2Ffile%2Fform.js?ref=1a07ce2005317bda2763b16159aeec77f30aaa04",
            "patch": "@@ -1,17 +1,19 @@\n 'use client'\n+import { useActionState } from 'react'\n import { accountForOverhead } from '../../account-for-overhead'\n \n export default function Form({ action }) {\n   const submit = (megaBytes) =>\n     action('a'.repeat(accountForOverhead(megaBytes)))\n-\n+  const [, submit1] = useActionState(() => submit(1), undefined)\n+  const [, submit3] = useActionState(() => submit(3), undefined)\n   return (\n     <>\n-      <button id=\"size-1mb\" onClick={() => submit(1)}>\n+      <button id=\"size-1mb\" onClick={submit1}>\n         1mb\n       </button>\n-      <button id=\"size-2mb\" onClick={() => submit(2)}>\n-        2mb\n+      <button id=\"size-3mb\" onClick={submit3}>\n+        3mb\n       </button>\n     </>\n   )"
        },
        {
            "sha": "aaa644fb8f88aa4d9d32646b8c128b2bb327e423",
            "filename": "test/e2e/app-dir/actions/app/form/error.js",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/1a07ce2005317bda2763b16159aeec77f30aaa04/test%2Fe2e%2Fapp-dir%2Factions%2Fapp%2Fform%2Ferror.js",
            "raw_url": "https://github.com/vercel/next.js/raw/1a07ce2005317bda2763b16159aeec77f30aaa04/test%2Fe2e%2Fapp-dir%2Factions%2Fapp%2Fform%2Ferror.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions%2Fapp%2Fform%2Ferror.js?ref=1a07ce2005317bda2763b16159aeec77f30aaa04",
            "patch": "@@ -0,0 +1,9 @@\n+'use client'\n+\n+export default function Error() {\n+  return (\n+    <div>\n+      <h2 id=\"error\">Something went wrong!</h2>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "1e2e7c9e67e718660fc694d5ba889e4ace3cf99e",
            "filename": "test/e2e/app-dir/actions/next.config.js",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/1a07ce2005317bda2763b16159aeec77f30aaa04/test%2Fe2e%2Fapp-dir%2Factions%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/1a07ce2005317bda2763b16159aeec77f30aaa04/test%2Fe2e%2Fapp-dir%2Factions%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions%2Fnext.config.js?ref=1a07ce2005317bda2763b16159aeec77f30aaa04",
            "patch": "@@ -4,4 +4,7 @@ module.exports = {\n   logging: {\n     fetches: {},\n   },\n+  experimental: {\n+    serverActions: { bodySizeLimit: '2mb' },\n+  },\n }"
        },
        {
            "sha": "31316fb697c1856c717d48e1d3bd4a85fbabea5c",
            "filename": "test/lib/e2e-utils/request-tracker.ts",
            "status": "added",
            "additions": 176,
            "deletions": 0,
            "changes": 176,
            "blob_url": "https://github.com/vercel/next.js/blob/1a07ce2005317bda2763b16159aeec77f30aaa04/test%2Flib%2Fe2e-utils%2Frequest-tracker.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1a07ce2005317bda2763b16159aeec77f30aaa04/test%2Flib%2Fe2e-utils%2Frequest-tracker.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Flib%2Fe2e-utils%2Frequest-tracker.ts?ref=1a07ce2005317bda2763b16159aeec77f30aaa04",
            "patch": "@@ -0,0 +1,176 @@\n+import {\n+  Request as PlaywrightRequest,\n+  Response as PlaywrightResponse,\n+} from 'playwright'\n+import { inspect } from 'node:util'\n+import { Playwright } from '../browsers/playwright'\n+\n+export type RequestMatcherObject = {\n+  pathname: string\n+  search?: string\n+  method?: 'GET' | 'POST' | 'PUT' | 'PATCH' | 'HEAD' | 'OPTIONS'\n+}\n+\n+export type RequestMatcher =\n+  | RequestMatcherObject\n+  | ((request: PlaywrightRequest) => Promise<boolean>)\n+\n+/** Allows capturing responses to requests that happened as a result of running a callback. */\n+export function createRequestTracker(browser: Playwright) {\n+  /** Run a callback and capture requests with the given `method` and `pathname`. */\n+  async function captureResponse<T>(\n+    action: () => Promise<T>,\n+    {\n+      request: requestMatcher,\n+      timeoutMs = 5000,\n+    }: {\n+      request: RequestMatcher\n+      timeoutMs?: number\n+    }\n+  ): Promise<[result: T, captured: PlaywrightResponse]> {\n+    const isMatchingRequest = async (request: PlaywrightRequest) => {\n+      if (typeof requestMatcher === 'function') {\n+        // This can be async to allow matching on things like `request.allHeaders()` which is a promise.\n+        return await requestMatcher(request)\n+      } else {\n+        const url = new URL(request.url())\n+        if (requestMatcher.pathname !== url.pathname) {\n+          return false\n+        }\n+        if (requestMatcher.search !== undefined) {\n+          if (url.search !== requestMatcher.search) {\n+            return false\n+          }\n+        }\n+        if (requestMatcher.method !== undefined) {\n+          if (request.method() !== requestMatcher.method) {\n+            return false\n+          }\n+        }\n+        return true\n+      }\n+    }\n+\n+    const responseCtrl = promiseWithResolvers<PlaywrightResponse>()\n+    let isSettled = false\n+\n+    let capturedRequest: PlaywrightRequest | undefined\n+\n+    const cleanups: (() => void)[] = []\n+\n+    // Make sure we clean up all event listeners and timers after we're done.\n+    responseCtrl.promise.finally(() => {\n+      isSettled = true\n+      cleanups.forEach((cb) => cb())\n+    })\n+\n+    // Listen for requests that match the criteria.\n+    const onRequest = async (request: PlaywrightRequest) => {\n+      if (!(await isMatchingRequest(request))) {\n+        return\n+      }\n+\n+      // If `capturedRequest` is already set, then we've got multiple requests that match the criteria.\n+      // This is currently not supported, though if needed, we could extend the API\n+      // to allow capturing multiple requests and returning them as an array.\n+      if (capturedRequest) {\n+        const criteriaDescription =\n+          typeof requestMatcher === 'function'\n+            ? 'the specified criteria'\n+            : inspect(requestMatcher)\n+        return responseCtrl.reject(\n+          new Error(\n+            [\n+              `Captured multiple requests that match ${criteriaDescription} during a \\`captureResponse\\` call:`,\n+              ...[capturedRequest, request].map(\n+                (req) => `  - ${req.method} ${req.url}`\n+              ),\n+              'This is currently not supported.',\n+            ].join('\\n')\n+          )\n+        )\n+      }\n+\n+      // We found a request that matches our criteria. Now we'll wait for a response.\n+      capturedRequest = request\n+      console.log(\n+        `[request-tracker] request: ${request.method()} ${request.url()}` +\n+          (['POST', 'PUT', 'PATCH'].includes(request.method())\n+            ? ` (content-type: ${request.headers()['content-type']})`\n+            : '')\n+      )\n+      const onResponse = (response: PlaywrightResponse) => {\n+        if (isSettled) {\n+          return\n+        }\n+        if (response.request() === request) {\n+          // We found a response to our request. We're done.\n+          console.log(`[request-tracker] response: ${response.status()}`)\n+          return responseCtrl.resolve(response)\n+        }\n+      }\n+      browser.on('response', onResponse)\n+      cleanups.push(() => browser.off('response', onResponse))\n+    }\n+\n+    // Install the handler before running the action callback to avoid races.\n+    browser.on('request', onRequest)\n+    cleanups.push(() => browser.off('request', onRequest))\n+\n+    // Run the action callback. We expect this to result in requests being initiated.\n+    // If this doesn't happen before the specified timeout, we'll error below.\n+    const actionPromise = Promise.resolve().then(action)\n+\n+    const resultPromise = Promise.all([\n+      actionPromise,\n+      responseCtrl.promise,\n+    ] as const)\n+\n+    actionPromise.then(\n+      () => {\n+        // The action callback and the request it triggered can finish before this gets the chance to run.\n+        // In that case, we don't need to install the timeout at all.\n+        if (isSettled) {\n+          return\n+        }\n+\n+        // After the action callback resolves, start a timer.\n+        // If we don't capture a request/response pair within that time limit, error.\n+        const abortTimeoutId = setTimeout(() => {\n+          if (isSettled) {\n+            return\n+          }\n+          return responseCtrl.reject(\n+            new Error(\n+              capturedRequest === undefined\n+                ? `Did not intercept a request within ${timeoutMs}ms of the action callback finishing`\n+                : `Did not intercept a response within ${timeoutMs}ms of the action callback finishing`\n+            )\n+          )\n+        }, timeoutMs)\n+        cleanups.push(() => clearTimeout(abortTimeoutId))\n+      },\n+      () => {\n+        // If the action callback errored, we don't want to reject the response promise,\n+        // because then jest would unnecessarily print both errors.\n+        // We're returning a `Promise.all` that'll reject because `actionPromise` rejected,\n+        // so we can just quietly resolve this with `null` -- it will never reach the caller anyway.\n+        return responseCtrl.resolve(null!)\n+      }\n+    )\n+\n+    return resultPromise\n+  }\n+\n+  return { captureResponse }\n+}\n+\n+function promiseWithResolvers<T>() {\n+  let resolve: (value: T) => void = undefined!\n+  let reject: (error: unknown) => void = undefined!\n+  const promise = new Promise<T>((_resolve, _reject) => {\n+    resolve = _resolve\n+    reject = _reject\n+  })\n+  return { promise, resolve, reject }\n+}"
        }
    ],
    "stats": {
        "total": 543,
        "additions": 434,
        "deletions": 109
    }
}