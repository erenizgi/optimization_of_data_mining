{
    "author": "acdlite",
    "message": "[Segment Cache] Fix: Key by rewritten search (#81986)\n\nWhen a request URL is rewritten, the resulting data must be keyed by its\nrewritten search params — the ones that were used by the server to\nrender the page — not the original search params. This works in most\nplaces by encoding the rewritten search params into page's segment key\nin the server response. However, the Segment Cache implementation did\nnot handle this correctly.\n\nThe fix is to read the rewritten search params from the\nx-nextjs-rewritten-query header in the server response.\n\nIn upcoming PRs, we will use a similar approach for regular route\nparams, too, so that we can lift the params out of the body of the\nserver response.\n\n---------\n\nCo-authored-by: Janka Uryga <lolzatu2@gmail.com>",
    "sha": "1964b17e20b52144d4ecd0a8d66a19924f7159e5",
    "files": [
        {
            "sha": "83ebd98df57cde4ee4d43dec943a5b037a678770",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache-key.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/1964b17e20b52144d4ecd0a8d66a19924f7159e5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache-key.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1964b17e20b52144d4ecd0a8d66a19924f7159e5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache-key.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache-key.ts?ref=1964b17e20b52144d4ecd0a8d66a19924f7159e5",
            "patch": "@@ -1,3 +1,6 @@\n+import { NEXT_REWRITTEN_QUERY_HEADER } from '../app-router-headers'\n+import type { RSCResponse } from '../router-reducer/fetch-server-response'\n+\n // TypeScript trick to simulate opaque types, like in Flow.\n type Opaque<K, T> = T & { __brand: K }\n \n@@ -29,3 +32,18 @@ export function createCacheKey(\n   } as RouteCacheKey\n   return cacheKey\n }\n+\n+export function getRenderedSearch(response: RSCResponse): NormalizedSearch {\n+  // If the server performed a rewrite, the search params used to render the\n+  // page will be different from the params in the request URL. In this case,\n+  // the response will include a header that gives the rewritten search query.\n+  const rewrittenQuery = response.headers.get(NEXT_REWRITTEN_QUERY_HEADER)\n+  if (rewrittenQuery !== null) {\n+    return (\n+      rewrittenQuery === '' ? '' : '?' + rewrittenQuery\n+    ) as NormalizedSearch\n+  }\n+  // If the header is not present, there was no rewrite, so we use the search\n+  // query of the response URL.\n+  return new URL(response.url).search as NormalizedSearch\n+}"
        },
        {
            "sha": "656a6e4fa0579a5bde111ce4749ef69752f47e47",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 46,
            "deletions": 11,
            "changes": 57,
            "blob_url": "https://github.com/vercel/next.js/blob/1964b17e20b52144d4ecd0a8d66a19924f7159e5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1964b17e20b52144d4ecd0a8d66a19924f7159e5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=1964b17e20b52144d4ecd0a8d66a19924f7159e5",
            "patch": "@@ -42,6 +42,7 @@ import type {\n   NormalizedSearch,\n   RouteCacheKey,\n } from './cache-key'\n+import { getRenderedSearch } from './cache-key'\n import { createTupleMap, type TupleMap, type Prefix } from './tuple-map'\n import { createLRU } from './lru'\n import {\n@@ -130,6 +131,7 @@ type PendingRouteCacheEntry = RouteCacheEntryShared & {\n   status: EntryStatus.Empty | EntryStatus.Pending\n   blockedTasks: Set<PrefetchTask> | null\n   canonicalUrl: null\n+  renderedSearch: null\n   tree: null\n   head: HeadData | null\n   isHeadPartial: true\n@@ -140,6 +142,7 @@ type RejectedRouteCacheEntry = RouteCacheEntryShared & {\n   status: EntryStatus.Rejected\n   blockedTasks: Set<PrefetchTask> | null\n   canonicalUrl: null\n+  renderedSearch: null\n   tree: null\n   head: null\n   isHeadPartial: true\n@@ -150,6 +153,7 @@ export type FulfilledRouteCacheEntry = RouteCacheEntryShared & {\n   status: EntryStatus.Fulfilled\n   blockedTasks: null\n   canonicalUrl: string\n+  renderedSearch: NormalizedSearch\n   tree: RouteTree\n   head: HeadData\n   isHeadPartial: boolean\n@@ -413,29 +417,32 @@ export function getSegmentKeypathForTask(\n   // cache entry is valid for all possible search param values.\n   const isDynamicTask = task.includeDynamicData || !route.isPPREnabled\n   return isDynamicTask && path.endsWith('/' + PAGE_SEGMENT_KEY)\n-    ? [path, task.key.search]\n+    ? [path, route.renderedSearch]\n     : [path]\n }\n \n export function readSegmentCacheEntry(\n   now: number,\n-  routeCacheKey: RouteCacheKey,\n+  route: FulfilledRouteCacheEntry,\n   path: string\n ): SegmentCacheEntry | null {\n   if (!path.endsWith('/' + PAGE_SEGMENT_KEY)) {\n     // Fast path. Search params only exist on page segments.\n     return readExactSegmentCacheEntry(now, [path])\n   }\n \n-  // Page segments may or may not contain search params. If they were prefetched\n-  // using a dynamic request, then we will have an entry with search params.\n-  // Check for that case first.\n-  const entryWithSearchParams = readExactSegmentCacheEntry(now, [\n-    path,\n-    routeCacheKey.search,\n-  ])\n-  if (entryWithSearchParams !== null) {\n-    return entryWithSearchParams\n+  const renderedSearch = route.renderedSearch\n+  if (renderedSearch !== null) {\n+    // Page segments may or may not contain search params. If they were prefetched\n+    // using a dynamic request, then we will have an entry with search params.\n+    // Check for that case first.\n+    const entryWithSearchParams = readExactSegmentCacheEntry(now, [\n+      path,\n+      renderedSearch,\n+    ])\n+    if (entryWithSearchParams !== null) {\n+      return entryWithSearchParams\n+    }\n   }\n \n   // If we did not find an entry with the given search params, check for a\n@@ -550,6 +557,7 @@ export function readOrCreateRouteCacheEntry(\n     couldBeIntercepted: true,\n     // Similarly, we don't yet know if the route supports PPR.\n     isPPREnabled: false,\n+    renderedSearch: null,\n \n     // LRU-related fields\n     keypath: null,\n@@ -783,6 +791,7 @@ function fulfillRouteCacheEntry(\n   staleAt: number,\n   couldBeIntercepted: boolean,\n   canonicalUrl: string,\n+  renderedSearch: NormalizedSearch,\n   isPPREnabled: boolean\n ): FulfilledRouteCacheEntry {\n   const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n@@ -793,6 +802,7 @@ function fulfillRouteCacheEntry(\n   fulfilledEntry.staleAt = staleAt\n   fulfilledEntry.couldBeIntercepted = couldBeIntercepted\n   fulfilledEntry.canonicalUrl = canonicalUrl\n+  fulfilledEntry.renderedSearch = renderedSearch\n   fulfilledEntry.isPPREnabled = isPPREnabled\n   pingBlockedTasks(entry)\n   return fulfilledEntry\n@@ -1133,6 +1143,11 @@ export async function fetchRouteOnCacheMiss(\n         return null\n       }\n \n+      // Get the search params that were used to render the target page. This may\n+      // be different from the search params in the request URL, if the page\n+      // was rewritten.\n+      const renderedSearch = getRenderedSearch(response)\n+\n       const staleTimeMs = serverData.staleTime * 1000\n       fulfillRouteCacheEntry(\n         entry,\n@@ -1142,6 +1157,7 @@ export async function fetchRouteOnCacheMiss(\n         Date.now() + staleTimeMs,\n         couldBeIntercepted,\n         canonicalUrl,\n+        renderedSearch,\n         routeIsPPREnabled\n       )\n     } else {\n@@ -1366,6 +1382,19 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n       return null\n     }\n \n+    const renderedSearch = getRenderedSearch(response)\n+    if (renderedSearch !== route.renderedSearch) {\n+      // The search params that were used to render the target page are\n+      // different from the search params in the request URL. This only happens\n+      // when there's a dynamic rewrite in between the tree prefetch and the\n+      // data prefetch.\n+      // TODO: For now, since this is an edge case, we reject the prefetch, but\n+      // the proper way to handle this is to evict the stale route tree entry\n+      // then fill the cache with the new response.\n+      rejectSegmentEntriesIfStillPending(spawnedEntries, Date.now() + 10 * 1000)\n+      return null\n+    }\n+\n     // Track when the network connection closes.\n     const closed = createPromiseWithResolvers<void>()\n \n@@ -1462,6 +1491,11 @@ function writeDynamicTreeResponseIntoCache(\n   const isResponsePartial =\n     response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n \n+  // Get the search params that were used to render the target page. This may\n+  // be different from the search params in the request URL, if the page\n+  // was rewritten.\n+  const renderedSearch = getRenderedSearch(response)\n+\n   const fulfilledEntry = fulfillRouteCacheEntry(\n     entry,\n     convertRootFlightRouterStateToRouteTree(flightRouterState),\n@@ -1470,6 +1504,7 @@ function writeDynamicTreeResponseIntoCache(\n     now + staleTimeMs,\n     couldBeIntercepted,\n     canonicalUrl,\n+    renderedSearch,\n     routeIsPPREnabled\n   )\n "
        },
        {
            "sha": "e7bdcf2807d382ced465130128cd9e15075b2c71",
            "filename": "packages/next/src/client/components/segment-cache-impl/navigation.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 30,
            "changes": 51,
            "blob_url": "https://github.com/vercel/next.js/blob/1964b17e20b52144d4ecd0a8d66a19924f7159e5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1964b17e20b52144d4ecd0a8d66a19924f7159e5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts?ref=1964b17e20b52144d4ecd0a8d66a19924f7159e5",
            "patch": "@@ -22,12 +22,10 @@ import {\n   readSegmentCacheEntry,\n   waitForSegmentCacheEntry,\n   type RouteTree,\n+  type FulfilledRouteCacheEntry,\n } from './cache'\n-import { createCacheKey, type RouteCacheKey } from './cache-key'\n-import {\n-  addSearchParamsIfPageSegment,\n-  PAGE_SEGMENT_KEY,\n-} from '../../../shared/lib/segment'\n+import { createCacheKey } from './cache-key'\n+import { addSearchParamsIfPageSegment } from '../../../shared/lib/segment'\n import { NavigationResultTag } from '../segment-cache'\n \n type MPANavigationResult = {\n@@ -116,7 +114,7 @@ export function navigate(\n   const route = readRouteCacheEntry(now, cacheKey)\n   if (route !== null && route.status === EntryStatus.Fulfilled) {\n     // We have a matching prefetch.\n-    const snapshot = readRenderSnapshotFromCache(now, cacheKey, route.tree)\n+    const snapshot = readRenderSnapshotFromCache(now, route, route.tree)\n     const prefetchFlightRouterState = snapshot.flightRouterState\n     const prefetchSeedData = snapshot.seedData\n     const prefetchHead = route.head\n@@ -255,7 +253,7 @@ function navigationTaskToResult(\n \n function readRenderSnapshotFromCache(\n   now: number,\n-  routeCacheKey: RouteCacheKey,\n+  route: FulfilledRouteCacheEntry,\n   tree: RouteTree\n ): { flightRouterState: FlightRouterState; seedData: CacheNodeSeedData } {\n   let childRouterStates: { [parallelRouteKey: string]: FlightRouterState } = {}\n@@ -266,11 +264,7 @@ function readRenderSnapshotFromCache(\n   if (slots !== null) {\n     for (const parallelRouteKey in slots) {\n       const childTree = slots[parallelRouteKey]\n-      const childResult = readRenderSnapshotFromCache(\n-        now,\n-        routeCacheKey,\n-        childTree\n-      )\n+      const childResult = readRenderSnapshotFromCache(now, route, childTree)\n       childRouterStates[parallelRouteKey] = childResult.flightRouterState\n       childSeedDatas[parallelRouteKey] = childResult.seedData\n     }\n@@ -280,7 +274,7 @@ function readRenderSnapshotFromCache(\n   let loading: LoadingModuleData | Promise<LoadingModuleData> = null\n   let isPartial: boolean = true\n \n-  const segmentEntry = readSegmentCacheEntry(now, routeCacheKey, tree.key)\n+  const segmentEntry = readSegmentCacheEntry(now, route, tree.key)\n   if (segmentEntry !== null) {\n     switch (segmentEntry.status) {\n       case EntryStatus.Fulfilled: {\n@@ -315,23 +309,20 @@ function readRenderSnapshotFromCache(\n     }\n   }\n \n-  const segment =\n-    tree.segment === PAGE_SEGMENT_KEY && routeCacheKey.search\n-      ? // The navigation implementation expects the search params to be\n-        // included in the segment. However, the Segment Cache tracks search\n-        // params separately from the rest of the segment key. So we need to\n-        // add them back here.\n-        //\n-        // See corresponding comment in convertFlightRouterStateToTree.\n-        //\n-        // TODO: What we should do instead is update the navigation diffing\n-        // logic to compare search params explicitly. This is a temporary\n-        // solution until more of the Segment Cache implementation has settled.\n-        addSearchParamsIfPageSegment(\n-          tree.segment,\n-          Object.fromEntries(new URLSearchParams(routeCacheKey.search))\n-        )\n-      : tree.segment\n+  // The navigation implementation expects the search params to be\n+  // included in the segment. However, the Segment Cache tracks search\n+  // params separately from the rest of the segment key. So we need to\n+  // add them back here.\n+  //\n+  // See corresponding comment in convertFlightRouterStateToTree.\n+  //\n+  // TODO: What we should do instead is update the navigation diffing\n+  // logic to compare search params explicitly. This is a temporary\n+  // solution until more of the Segment Cache implementation has settled.\n+  const segment = addSearchParamsIfPageSegment(\n+    tree.segment,\n+    Object.fromEntries(new URLSearchParams(route.renderedSearch))\n+  )\n \n   return {\n     flightRouterState: ["
        },
        {
            "sha": "3008b99fee9fed6ae40f2cdbf7e4167d62f94295",
            "filename": "packages/next/src/client/components/segment-cache-impl/scheduler.ts",
            "status": "modified",
            "additions": 38,
            "deletions": 1,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/1964b17e20b52144d4ecd0a8d66a19924f7159e5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1964b17e20b52144d4ecd0a8d66a19924f7159e5/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts?ref=1964b17e20b52144d4ecd0a8d66a19924f7159e5",
            "patch": "@@ -1,6 +1,7 @@\n import type {\n   FlightRouterState,\n   Segment as FlightRouterStateSegment,\n+  Segment,\n } from '../../../server/app-render/types'\n import { HasLoadingBoundary } from '../../../server/app-render/types'\n import { matchSegment } from '../match-segments'\n@@ -28,6 +29,10 @@ import {\n } from './cache'\n import type { RouteCacheKey } from './cache-key'\n import { getCurrentCacheVersion, PrefetchPriority } from '../segment-cache'\n+import {\n+  addSearchParamsIfPageSegment,\n+  PAGE_SEGMENT_KEY,\n+} from '../../../shared/lib/segment'\n \n const scheduleMicrotask =\n   typeof queueMicrotask === 'function'\n@@ -657,7 +662,11 @@ function diffRouteTreeAgainstCurrent(\n         oldTreeChild?.[0]\n       if (\n         oldTreeChildSegment !== undefined &&\n-        matchSegment(newTreeChildSegment, oldTreeChildSegment)\n+        doesCurrentSegmentMatchCachedSegment(\n+          route,\n+          newTreeChildSegment,\n+          oldTreeChildSegment\n+        )\n       ) {\n         // This segment is already part of the current route. Keep traversing.\n         const requestTreeChild = diffRouteTreeAgainstCurrent(\n@@ -1177,6 +1186,34 @@ function upsertSegmentOnCompletion(\n   }, noop)\n }\n \n+function doesCurrentSegmentMatchCachedSegment(\n+  route: FulfilledRouteCacheEntry,\n+  currentSegment: Segment,\n+  cachedSegment: Segment\n+): boolean {\n+  if (cachedSegment === PAGE_SEGMENT_KEY) {\n+    // In the FlightRouterState stored by the router, the page segment has the\n+    // rendered search params appended to the name of the segment. In the\n+    // prefetch cache, however, this is stored separately. So, when comparing\n+    // the router's current FlightRouterState to the cached FlightRouterState,\n+    // we need to make sure we compare both parts of the segment.\n+    // TODO: This is not modeled clearly. We use the same type,\n+    // FlightRouterState, for both the CacheNode tree _and_ the prefetch cache\n+    // _and_ the server response format, when conceptually those are three\n+    // different things and treated in different ways. We should encode more of\n+    // this information into the type design so mistakes are less likely.\n+    return (\n+      currentSegment ===\n+      addSearchParamsIfPageSegment(\n+        PAGE_SEGMENT_KEY,\n+        Object.fromEntries(new URLSearchParams(route.renderedSearch))\n+      )\n+    )\n+  }\n+  // Non-page segments are compared using the same function as the server\n+  return matchSegment(cachedSegment, currentSegment)\n+}\n+\n // -----------------------------------------------------------------------------\n // The remainder of the module is a MinHeap implementation. Try not to put any\n // logic below here unless it's related to the heap algorithm. We can extract"
        },
        {
            "sha": "0a3e9818a70b8d969aa4a920fb7aae8ee898743a",
            "filename": "test/e2e/app-dir/segment-cache/search-params/app/search-params/page.tsx",
            "status": "modified",
            "additions": 69,
            "deletions": 1,
            "changes": 70,
            "blob_url": "https://github.com/vercel/next.js/blob/1964b17e20b52144d4ecd0a8d66a19924f7159e5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/1964b17e20b52144d4ecd0a8d66a19924f7159e5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Fpage.tsx?ref=1964b17e20b52144d4ecd0a8d66a19924f7159e5",
            "patch": "@@ -1,6 +1,11 @@\n+import { Suspense } from 'react'\n import { LinkAccordion } from '../../components/link-accordion'\n \n-export default function SearchParamsPage() {\n+export default function SearchParamsPage({\n+  searchParams,\n+}: {\n+  searchParams: Promise<{ greeting?: string }>\n+}) {\n   return (\n     <>\n       <p>\n@@ -34,6 +39,69 @@ export default function SearchParamsPage() {\n           </LinkAccordion>\n         </li>\n       </ul>\n+      <p>\n+        Demonstrates that pages that render based on search params are cached\n+        correctly even during a rewrite. Because each of the links below rewrite\n+        to the same URL, they only need to fetch the page once (note: there will\n+        still be separate requests for the route trees, but not for the page\n+        data itself).\n+      </p>\n+      <ul>\n+        <li>\n+          <LinkAccordion\n+            prefetch={true}\n+            href=\"/search-params/target-page?searchParam=rewritesToANewSearchParam\"\n+          >\n+            searchParam=rewritesToANewSearchParam, prefetch=true\n+          </LinkAccordion>\n+        </li>\n+        <li>\n+          <LinkAccordion\n+            prefetch={true}\n+            href=\"/search-params/target-page?searchParam=alsoRewritesToThatSameSearchParam\"\n+          >\n+            searchParam=alsoRewritesToThatSameSearchParam, prefetch=true\n+          </LinkAccordion>\n+        </li>\n+      </ul>\n+      <p>\n+        The first link rewrites to the current page, but with an additional\n+        search param. The router must be able to detect that something on the\n+        new page has changed. So, clicking the first link should cause the\n+        current page to re-render, but with a greeting rendered below.\n+      </p>\n+      <p>\n+        The second link rewrites to the current page, but without any search\n+        params. Clicking this link after clicking the first one should cause the\n+        greeting to disappear.\n+      </p>\n+      <ul>\n+        <li>\n+          <LinkAccordion prefetch={true} href=\"/search-params-with-greeting\">\n+            Rewrite to current page with additional ?greeting=hello search\n+            param, prefetch=true\n+          </LinkAccordion>\n+        </li>\n+        <li>\n+          <LinkAccordion prefetch={true} href=\"/search-params-with-no-greeting\">\n+            Rewrite to current page without any search params, prefetch=true\n+          </LinkAccordion>\n+        </li>\n+      </ul>\n+      <Suspense fallback={null}>\n+        <Greeting searchParams={searchParams} />\n+      </Suspense>\n     </>\n   )\n }\n+\n+async function Greeting({\n+  searchParams,\n+}: {\n+  searchParams: Promise<{ greeting?: string }>\n+}) {\n+  const { greeting } = await searchParams\n+  return (\n+    <p id=\"greeting\">{`Greeting (from search params): ${greeting ?? '(none)'}`}</p>\n+  )\n+}"
        },
        {
            "sha": "7f5df9731e3f251fa09577ee58c1f49dba4fad68",
            "filename": "test/e2e/app-dir/segment-cache/search-params/middleware.ts",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/1964b17e20b52144d4ecd0a8d66a19924f7159e5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fmiddleware.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1964b17e20b52144d4ecd0a8d66a19924f7159e5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fmiddleware.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fmiddleware.ts?ref=1964b17e20b52144d4ecd0a8d66a19924f7159e5",
            "patch": "@@ -0,0 +1,29 @@\n+import { NextResponse } from 'next/server'\n+import type { NextRequest } from 'next/server'\n+\n+export function middleware(request: NextRequest) {\n+  if (request.nextUrl.pathname.startsWith('/search-params/target-page')) {\n+    const searchParam = request.nextUrl.searchParams.get('searchParam')\n+    if (\n+      searchParam === 'rewritesToANewSearchParam' ||\n+      searchParam === 'alsoRewritesToThatSameSearchParam'\n+    ) {\n+      return NextResponse.rewrite(\n+        new URL(\n+          '/search-params/target-page?searchParam=rewrittenSearchParam',\n+          request.url\n+        )\n+      )\n+    }\n+  }\n+\n+  if (request.nextUrl.pathname.startsWith('/search-params-with-greeting')) {\n+    return NextResponse.rewrite(\n+      new URL('/search-params?greeting=hello', request.url)\n+    )\n+  }\n+\n+  if (request.nextUrl.pathname.startsWith('/search-params-with-no-greeting')) {\n+    return NextResponse.rewrite(new URL('/search-params', request.url))\n+  }\n+}"
        },
        {
            "sha": "ef2269a8f52f1cfe9f823f3cd29c38f2b7c68faf",
            "filename": "test/e2e/app-dir/segment-cache/search-params/segment-cache-search-params.test.ts",
            "status": "modified",
            "additions": 146,
            "deletions": 1,
            "changes": 147,
            "blob_url": "https://github.com/vercel/next.js/blob/1964b17e20b52144d4ecd0a8d66a19924f7159e5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fsegment-cache-search-params.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1964b17e20b52144d4ecd0a8d66a19924f7159e5/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fsegment-cache-search-params.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fsegment-cache-search-params.test.ts?ref=1964b17e20b52144d4ecd0a8d66a19924f7159e5",
            "patch": "@@ -1,8 +1,9 @@\n import { nextTestSetup } from 'e2e-utils'\n import { createRouterAct } from '../router-act'\n+import { retry } from '../../../../lib/next-test-utils'\n \n describe('segment cache (search params)', () => {\n-  const { next, isNextDev } = nextTestSetup({\n+  const { next, isNextDev, isNextDeploy } = nextTestSetup({\n     files: __dirname,\n   })\n   if (isNextDev) {\n@@ -139,4 +140,148 @@ describe('segment cache (search params)', () => {\n       'no-requests'\n     )\n   })\n+\n+  it('stores prefetched data by its rewritten search params, not the original ones', async () => {\n+    let act: ReturnType<typeof createRouterAct>\n+    const browser = await next.browser('/search-params', {\n+      beforePageLoad(page) {\n+        act = createRouterAct(page)\n+      },\n+    })\n+\n+    const revealLinkThatRewritesToANewSearchParam = await browser.elementByCss(\n+      'input[data-link-accordion=\"/search-params/target-page?searchParam=rewritesToANewSearchParam\"]'\n+    )\n+    const revealLinkThatAlsoRewritesToThatSameSearchParam =\n+      await browser.elementByCss(\n+        'input[data-link-accordion=\"/search-params/target-page?searchParam=alsoRewritesToThatSameSearchParam\"]'\n+      )\n+    await act(\n+      async () => {\n+        await revealLinkThatRewritesToANewSearchParam.click()\n+      },\n+      {\n+        includes: 'Search param: rewrittenSearchParam',\n+      }\n+    )\n+\n+    // This should not fetch the page data again, because it was rewritten to\n+    // the same page.\n+    await act(\n+      async () => {\n+        await revealLinkThatAlsoRewritesToThatSameSearchParam.click()\n+      },\n+      {\n+        includes: 'Search param: rewrittenSearchParam',\n+        block: 'reject',\n+      }\n+    )\n+\n+    // However, fetching any other search param value does a new fetch\n+    const revealB = await browser.elementByCss(\n+      'input[data-link-accordion=\"/search-params/target-page?searchParam=b_full\"]'\n+    )\n+    await act(\n+      async () => {\n+        await revealB.click()\n+      },\n+      {\n+        includes: 'Search param: b_full',\n+      }\n+    )\n+  })\n+\n+  it('handles rewrites to the same page but with different search params', async () => {\n+    let act: ReturnType<typeof createRouterAct>\n+    const browser = await next.browser('/search-params', {\n+      beforePageLoad(page) {\n+        act = createRouterAct(page)\n+      },\n+    })\n+\n+    // Make sure HTML streaming finishes, so that we don't get\n+    // multiple `<div id=\"greeting\">` elements in the document when we navigate\n+    // TODO: this seems like it should be handled by waitForHydration?\n+    await retry(async () => {\n+      const greeting = browser.locator('#greeting')\n+      expect(await greeting.isVisible()).toBe(true)\n+      expect(await greeting.innerText()).toEqual(\n+        'Greeting (from search params): (none)'\n+      )\n+    })\n+\n+    // This link rewrites to the current page, but with a search param that\n+    // causes a greeting to be rendered.\n+    const revealLink = await browser.elementByCss(\n+      'input[data-link-accordion=\"/search-params-with-greeting\"]'\n+    )\n+    await act(\n+      async () => {\n+        await revealLink.click()\n+      },\n+      {\n+        includes: 'Greeting (from search params): hello',\n+      }\n+    )\n+\n+    // Clicking the link should update the greeting\n+    const link = await browser.elementByCss(\n+      'a[href=\"/search-params-with-greeting\"]'\n+    )\n+    await act(async () => {\n+      await link.click()\n+    }, 'no-requests')\n+\n+    expect(await browser.elementById('greeting').text()).toBe(\n+      'Greeting (from search params): hello'\n+    )\n+  })\n+\n+  // FIXME: search params seem to be dropped from the resume render when deployed\n+  if (!isNextDeploy) {\n+    it('handles rewrites to the same page but with no search params', async () => {\n+      let act: ReturnType<typeof createRouterAct>\n+      const browser = await next.browser('/search-params-with-greeting', {\n+        beforePageLoad(page) {\n+          act = createRouterAct(page)\n+        },\n+      })\n+\n+      // Make sure HTML streaming finishes, so that we don't get\n+      // multiple `<div id=\"greeting\">` elements in the document when we navigate\n+      // TODO: this seems like it should be handled by waitForHydration?\n+      await retry(async () => {\n+        const greeting = browser.locator('#greeting')\n+        expect(await greeting.isVisible()).toBe(true)\n+        expect(await greeting.innerText()).toEqual(\n+          'Greeting (from search params): hello'\n+        )\n+      })\n+\n+      // This link rewrites to same target pathname as the current page, but with\n+      // an internal search param removed\n+      const revealLink = await browser.elementByCss(\n+        'input[data-link-accordion=\"/search-params-with-no-greeting\"]'\n+      )\n+      await act(\n+        async () => {\n+          await revealLink.click()\n+        },\n+        {\n+          includes: 'Greeting (from search params): (none)',\n+        }\n+      )\n+\n+      // Clicking the link should remove the greeting\n+      const link = await browser.elementByCss(\n+        'a[href=\"/search-params-with-no-greeting\"]'\n+      )\n+      await act(async () => {\n+        await link.click()\n+      }, 'no-requests')\n+      expect(await browser.elementById('greeting').text()).toBe(\n+        'Greeting (from search params): (none)'\n+      )\n+    })\n+  }\n })"
        },
        {
            "sha": "3dbce69dafe8660f936a906ca3f3e9d737188be6",
            "filename": "test/lib/browsers/playwright.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1964b17e20b52144d4ecd0a8d66a19924f7159e5/test%2Flib%2Fbrowsers%2Fplaywright.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/1964b17e20b52144d4ecd0a8d66a19924f7159e5/test%2Flib%2Fbrowsers%2Fplaywright.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Flib%2Fbrowsers%2Fplaywright.ts?ref=1964b17e20b52144d4ecd0a8d66a19924f7159e5",
            "patch": "@@ -543,6 +543,10 @@ export class Playwright<TCurrent = undefined> {\n     return page.locator('nextjs-portal [data-nextjs-dev-tools-button]')\n   }\n \n+  locator(selector: string, options?: Parameters<(typeof page)['locator']>[1]) {\n+    return page.locator(selector, options)\n+  }\n+\n   /** A call that expects to be chained after a previous call, because it needs its value. */\n   private continueChain<TNext>(nextCall: (value: TCurrent) => Promise<TNext>) {\n     return this._chain(true, nextCall)"
        }
    ],
    "stats": {
        "total": 415,
        "additions": 371,
        "deletions": 44
    }
}