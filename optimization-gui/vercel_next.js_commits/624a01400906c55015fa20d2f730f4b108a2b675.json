{
    "author": "lukesandberg",
    "message": "[turbopack] Add support for debug_ids (#84319)\n\n## What?\n\nAdd a new feature to turbopack for generating debug_ids based on the\n[TC39 Debug ID\nproposal](https://github.com/tc39/ecma426/blob/main/proposals/debug-id.md)\n\nIf a user sets `turbopack.debugIds = true` then we will\n* register the debug id with the global `_debugIds` object\n* this object is keyed by a stack trace for the script. This enables\nassociating debug ids with stack frames when reporting errors.\n* add a ` //# debugId=XXX` comment at the end of the generated code \n* add a `\"debugId\": \"XXX\"` property to the source map json file\n\nThe debug id value is a hash of the file contents using the\n`xxhash3_128` hash algorithm represented as a UUID hyphentated string.\n\nOne oddity is Indexed source maps. Turbopack uses indexed source maps\nfor simple performance and 'incremental execution' reasons, but the\ndebug id spec says that debugIds only apply to non-indexed source maps.\nReading between the lines (thanks @bgw! ), this appears to be a simple\nspec issue related to older versions of the indexed-source maps\nspecification. Adding the debugId to the indexed map is unlikely to be\nharmful and the authors agree this should be covered ([see\nissue](https://github.com/tc39/ecma426/issues/203)).\n\n## Why?\n\nDebug Ids make javascript source files and source maps self identifying\nwithout relying on URLs. This improves the ability for offline processes\nto ensure a proper association regardless of how sources our source maps\nare served.\n\n## How?\n\n* thread the `debug_ids` bit from the next config down to the chunking\ncontext and finally to the `Code` structs\n* implement a uuid generator that can content address the code to\ngenerate the id\n- neither content addressing nor even determinism are _required_ by the\nspec but this is the simplest approach. We could use a simple 128 bit\nrandom number, but this is chaotic and goes against our own natural\ndesires for determinism.\n* compute the debug id in a turbotask on the `Code` struct and embed\nwhen generating chunks and source maps.\n* add a few tiny snapshot tests to demonstrate the feature.\n\n\nFixes PACK-417\n\n---------\n\nCo-authored-by: Tim Neutkens <tim@timneutkens.nl>",
    "sha": "624a01400906c55015fa20d2f730f4b108a2b675",
    "files": [
        {
            "sha": "e3080545492d022dc509e9708e34d7edbc747ba8",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -9564,8 +9564,10 @@ dependencies = [\n  \"turbo-tasks-hash\",\n  \"turbo-tasks-testing\",\n  \"turbo-unix-path\",\n+ \"twox-hash 2.1.0\",\n  \"url\",\n  \"urlencoding\",\n+ \"uuid\",\n ]\n \n [[package]]\n@@ -10223,9 +10225,9 @@ checksum = \"711b9620af191e0cdc7468a8d14e709c3dcdb115b36f838e601583af800a370a\"\n \n [[package]]\n name = \"uuid\"\n-version = \"1.17.0\"\n+version = \"1.18.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3cf4199d1e5d15ddd86a694e4d0dffa9c323ce759fea589f00fef9d81cc1931d\"\n+checksum = \"2f87b8aa10b915a06587d0dec516c282ff295b475d94abf425d62b57710070a2\"\n dependencies = [\n  \"getrandom 0.3.3\",\n  \"js-sys\","
        },
        {
            "sha": "11d94d3774a818ce85453c8abe2e7d8091139183",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -414,7 +414,7 @@ ringmap = \"0.1.3\"\n roaring = \"0.10.10\"\n rstest = \"0.16.0\"\n rustc-hash = \"2.1.1\"\n-twox-hash = { version = \"2.0.1\", features = [\"xxhash64\"] }\n+twox-hash = { version = \"2.1.0\", features = [\"xxhash64\", \"xxhash3_128\"] }\n semver = \"1.0.16\"\n serde = { version = \"1.0.217\", features = [\"derive\"] }\n serde_json = \"1.0.138\"\n@@ -443,6 +443,7 @@ triomphe = { git = \"https://github.com/sokra/triomphe\", branch = \"sokra/unstable\n unsize = \"1.1.0\"\n url = \"2.2.2\"\n urlencoding = \"2.1.2\"\n+uuid = \"1.18.1\"\n vergen = { version = \"9.0.6\", features = [\"cargo\"] }\n vergen-gitcl = { version = \"1.0.8\", features = [\"cargo\"] }\n webbrowser = \"0.8.7\""
        },
        {
            "sha": "d0aecf389a10f7aa0d45b995d5f34b3e4d328588",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -1048,6 +1048,7 @@ impl Project {\n             source_maps: self.next_config().client_source_maps(self.next_mode()),\n             no_mangling: self.no_mangling(),\n             scope_hoisting: self.next_config().turbo_scope_hoisting(self.next_mode()),\n+            debug_ids: self.next_config().turbopack_debug_ids(),\n         }))\n     }\n "
        },
        {
            "sha": "2de13637dffe89c07d66c09d72f0946eb11566bb",
            "filename": "crates/next-core/src/next_client/context.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client%2Fcontext.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -421,6 +421,7 @@ pub struct ClientChunkingContextOptions {\n     pub source_maps: Vc<bool>,\n     pub no_mangling: Vc<bool>,\n     pub scope_hoisting: Vc<bool>,\n+    pub debug_ids: Vc<bool>,\n }\n \n #[turbo_tasks::function]\n@@ -441,6 +442,7 @@ pub async fn get_client_chunking_context(\n         source_maps,\n         no_mangling,\n         scope_hoisting,\n+        debug_ids,\n     } = options;\n \n     let next_mode = mode.await?;\n@@ -473,7 +475,8 @@ pub async fn get_client_chunking_context(\n     .asset_base_path(asset_prefix)\n     .current_chunk_method(CurrentChunkMethod::DocumentCurrentScript)\n     .export_usage(*export_usage.await?)\n-    .module_id_strategy(module_id_strategy.to_resolved().await?);\n+    .module_id_strategy(module_id_strategy.to_resolved().await?)\n+    .debug_ids(*debug_ids.await?);\n \n     if next_mode.is_development() {\n         builder = builder"
        },
        {
            "sha": "5f94dcd7aad3326d4f5ab168bd104b5b7beb1562",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -561,6 +561,7 @@ pub struct TurbopackConfig {\n     pub rules: Option<FxIndexMap<RcStr, RuleConfigCollection>>,\n     pub resolve_alias: Option<FxIndexMap<RcStr, JsonValue>>,\n     pub resolve_extensions: Option<Vec<RcStr>>,\n+    pub debug_ids: Option<bool>,\n }\n \n #[derive(\n@@ -1855,6 +1856,16 @@ impl NextConfig {\n         Ok(Vc::cell(source_maps.unwrap_or(true)))\n     }\n \n+    #[turbo_tasks::function]\n+    pub fn turbopack_debug_ids(&self) -> Vc<bool> {\n+        Vc::cell(\n+            self.turbopack\n+                .as_ref()\n+                .and_then(|turbopack| turbopack.debug_ids)\n+                .unwrap_or(false),\n+        )\n+    }\n+\n     #[turbo_tasks::function]\n     pub fn typescript_tsconfig_path(&self) -> Result<Vc<Option<RcStr>>> {\n         Ok(Vc::cell("
        },
        {
            "sha": "46c53033342312f2cd5214632e2eb4a558fffe3a",
            "filename": "crates/next-core/src/raw_ecmascript_module.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/crates%2Fnext-core%2Fsrc%2Fraw_ecmascript_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/crates%2Fnext-core%2Fsrc%2Fraw_ecmascript_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fraw_ecmascript_module.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -271,7 +271,7 @@ impl EcmascriptChunkItem for RawEcmascriptChunkItem {\n \n             let code = code.build();\n             let source_map = if code.has_source_map() {\n-                let source_map = code.generate_source_map_ref()?;\n+                let source_map = code.generate_source_map_ref(None);\n \n                 static SECTIONS_REGEX: Lazy<Regex> =\n                     Lazy::new(|| Regex::new(r#\"sections\"[\\s\\n]*:\"#).unwrap());"
        },
        {
            "sha": "9145bf4ba088c57108289b41e4231d2d0704377a",
            "filename": "packages/next/src/server/config-schema.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -159,6 +159,7 @@ const zTurbopackConfig: zod.ZodType<TurbopackOptions> = z.strictObject({\n     .optional(),\n   resolveExtensions: z.array(z.string()).optional(),\n   root: z.string().optional(),\n+  debugIds: z.boolean().optional(),\n })\n \n export const configSchema: zod.ZodType<NextConfig> = z.lazy(() =>"
        },
        {
            "sha": "4abffef709503536e2a749fa77216ad1d7d3f33e",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -172,6 +172,14 @@ export interface TurbopackOptions {\n    * directory can be resolved by turbopack.\n    */\n   root?: string\n+\n+  /**\n+   * Enables generation of debug IDs in JavaScript bundles and source maps.\n+   * These debug IDs help with debugging and error tracking by providing stable identifiers.\n+   *\n+   * @see https://github.com/tc39/ecma426/blob/main/proposals/debug-id.md TC39 Debug ID Proposal\n+   */\n+  debugIds?: boolean\n }\n \n export interface WebpackConfigContext {"
        },
        {
            "sha": "8092a9bddd2024fd69272090b2771ea39fc69106",
            "filename": "turbopack/crates/turbo-tasks-fs/src/rope.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Frope.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Frope.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Frope.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -760,6 +760,7 @@ impl AsyncRead for RopeReader {\n }\n \n impl BufRead for RopeReader {\n+    /// Never returns an error.\n     fn fill_buf(&mut self) -> IoResult<&[u8]> {\n         // Returns the full buffer without coping any data. The same bytes will\n         // continue to be returned until [consume] is called."
        },
        {
            "sha": "a0e1f3049fd6084959862d2e69fa632848134e3b",
            "filename": "turbopack/crates/turbopack-browser/src/chunking_context.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fchunking_context.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -168,6 +168,11 @@ impl BrowserChunkingContextBuilder {\n         self\n     }\n \n+    pub fn debug_ids(mut self, debug_ids: bool) -> Self {\n+        self.chunking_context.debug_ids = debug_ids;\n+        self\n+    }\n+\n     pub fn chunking_config<T>(mut self, ty: ResolvedVc<T>, chunking_config: ChunkingConfig) -> Self\n     where\n         T: Upcast<Box<dyn ChunkType>>,\n@@ -229,6 +234,8 @@ pub struct BrowserChunkingContext {\n     enable_module_merging: bool,\n     /// Enable dynamic chunk content loading.\n     enable_dynamic_chunk_content_loading: bool,\n+    /// Enable debug IDs for chunks and source maps.\n+    debug_ids: bool,\n     /// The environment chunks will be evaluated in.\n     environment: ResolvedVc<Environment>,\n     /// The kind of runtime to include in the output.\n@@ -279,6 +286,7 @@ impl BrowserChunkingContext {\n                 enable_tracing: false,\n                 enable_module_merging: false,\n                 enable_dynamic_chunk_content_loading: false,\n+                debug_ids: false,\n                 environment,\n                 runtime_type,\n                 minify_type: MinifyType::NoMinify,\n@@ -780,4 +788,9 @@ impl ChunkingContext for BrowserChunkingContext {\n             Ok(ModuleExportUsage::all())\n         }\n     }\n+\n+    #[turbo_tasks::function]\n+    async fn debug_ids_enabled(self: Vc<Self>) -> Result<Vc<bool>> {\n+        Ok(Vc::cell(self.await?.debug_ids))\n+    }\n }"
        },
        {
            "sha": "5697aecfc4ba00d636a95ceb649fc3e15145b653",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/content.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 18,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fcontent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fcontent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fcontent.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -4,7 +4,7 @@ use anyhow::{Result, bail};\n use either::Either;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, Vc};\n-use turbo_tasks_fs::{File, rope::RopeBuilder};\n+use turbo_tasks_fs::File;\n use turbopack_core::{\n     asset::AssetContent,\n     chunk::{ChunkingContext, MinifyType, ModuleId},\n@@ -96,7 +96,10 @@ impl EcmascriptBrowserChunkContent {\n                 Either::Right(CURRENT_CHUNK_METHOD_DOCUMENT_CURRENT_SCRIPT_EXPR)\n             }\n         };\n-        let mut code = CodeBuilder::new(source_maps);\n+        let mut code = CodeBuilder::new(\n+            source_maps,\n+            *this.chunking_context.debug_ids_enabled().await?,\n+        );\n \n         // When a chunk is executed, it will either register itself with the current\n         // instance of the runtime, or it will push itself onto the list of pending\n@@ -139,23 +142,15 @@ impl VersionedContent for EcmascriptBrowserChunkContent {\n     #[turbo_tasks::function]\n     async fn content(self: Vc<Self>) -> Result<Vc<AssetContent>> {\n         let this = self.await?;\n-        let code = self.code().await?;\n-\n-        let rope = if code.has_source_map() {\n-            let mut rope_builder = RopeBuilder::default();\n-            rope_builder.concat(code.source_code());\n-            let source_map_path = this.source_map.path().await?;\n-            write!(\n-                rope_builder,\n-                \"\\n\\n//# sourceMappingURL={}\",\n-                urlencoding::encode(source_map_path.file_name())\n-            )?;\n-            rope_builder.build()\n-        } else {\n-            code.source_code().clone()\n-        };\n \n-        Ok(AssetContent::file(File::from(rope).into()))\n+        Ok(AssetContent::file(\n+            File::from(\n+                self.code()\n+                    .to_rope_with_magic_comments(|| *this.source_map)\n+                    .await?,\n+            )\n+            .into(),\n+        ))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "9f45733430b870cd7306ea1039e09aacb1c24208",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/evaluate/chunk.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 19,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -6,7 +6,7 @@ use indoc::writedoc;\n use serde::Serialize;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ReadRef, ResolvedVc, TryJoinIterExt, ValueToString, Vc};\n-use turbo_tasks_fs::{File, FileSystemPath, rope::RopeBuilder};\n+use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::{\n@@ -150,7 +150,10 @@ impl EcmascriptBrowserEvaluateChunk {\n             runtime_module_ids,\n         };\n \n-        let mut code = CodeBuilder::new(source_maps);\n+        let mut code = CodeBuilder::new(\n+            source_maps,\n+            *this.chunking_context.debug_ids_enabled().await?,\n+        );\n \n         // We still use the `TURBOPACK` global variable to store the chunk here,\n         // as there may be another runtime already loaded in the page.\n@@ -281,23 +284,14 @@ impl OutputAsset for EcmascriptBrowserEvaluateChunk {\n impl Asset for EcmascriptBrowserEvaluateChunk {\n     #[turbo_tasks::function]\n     async fn content(self: Vc<Self>) -> Result<Vc<AssetContent>> {\n-        let code = self.code().await?;\n-\n-        let rope = if code.has_source_map() {\n-            let mut rope_builder = RopeBuilder::default();\n-            rope_builder.concat(code.source_code());\n-            let source_map_path = self.source_map().path().await?;\n-            write!(\n-                rope_builder,\n-                \"\\n\\n//# sourceMappingURL={}\",\n-                urlencoding::encode(source_map_path.file_name())\n-            )?;\n-            rope_builder.build()\n-        } else {\n-            code.source_code().clone()\n-        };\n-\n-        Ok(AssetContent::file(File::from(rope).into()))\n+        Ok(AssetContent::file(\n+            File::from(\n+                self.code()\n+                    .to_rope_with_magic_comments(|| self.source_map())\n+                    .await?,\n+            )\n+            .into(),\n+        ))\n     }\n }\n "
        },
        {
            "sha": "f9b0f227b778a95fe363fbaa9323ec7bc2becfda",
            "filename": "turbopack/crates/turbopack-core/Cargo.toml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2FCargo.toml?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -43,8 +43,10 @@ turbo-tasks-env = { workspace = true }\n turbo-tasks-fs = { workspace = true }\n turbo-tasks-hash = { workspace = true }\n turbo-unix-path = { workspace = true }\n+twox-hash = { workspace = true }\n url = { workspace = true }\n urlencoding = { workspace = true }\n+uuid = { workspace = true}\n \n \n [dev-dependencies]"
        },
        {
            "sha": "519b1cb1bb66f4694d600bcc1bf2d36f0011e6a9",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunking_context.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking_context.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -299,6 +299,10 @@ pub trait ChunkingContext {\n         self: Vc<Self>,\n         module: Vc<Box<dyn Module>>,\n     ) -> Result<Vc<ModuleExportUsage>>;\n+\n+    /// Returns whether debug IDs are enabled for this chunking context.\n+    #[turbo_tasks::function]\n+    fn debug_ids_enabled(self: Vc<Self>) -> Vc<bool>;\n }\n \n pub trait ChunkingContextExt {"
        },
        {
            "sha": "39d0905d3de56af08eb752ec2e6558ad9113cacb",
            "filename": "turbopack/crates/turbopack-core/src/code_builder.rs",
            "status": "modified",
            "additions": 116,
            "deletions": 12,
            "changes": 128,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcode_builder.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcode_builder.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcode_builder.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -6,12 +6,15 @@ use std::{\n \n use anyhow::Result;\n use tracing::instrument;\n-use turbo_tasks::Vc;\n+use turbo_rcstr::RcStr;\n+use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::rope::{Rope, RopeBuilder};\n use turbo_tasks_hash::hash_xxh3_hash64;\n \n use crate::{\n-    source_map::{GenerateSourceMap, OptionStringifiedSourceMap, SourceMap},\n+    debug_id::generate_debug_id,\n+    output::OutputAsset,\n+    source_map::{GenerateSourceMap, OptionStringifiedSourceMap, SourceMap, SourceMapAsset},\n     source_pos::SourcePos,\n };\n \n@@ -24,6 +27,7 @@ pub type Mapping = (usize, Option<Rope>);\n pub struct Code {\n     code: Rope,\n     mappings: Vec<Mapping>,\n+    should_generate_debug_id: bool,\n }\n \n impl Code {\n@@ -35,33 +39,95 @@ impl Code {\n     pub fn has_source_map(&self) -> bool {\n         !self.mappings.is_empty()\n     }\n+    // Whether this code should have a debug id generated for it\n+    pub fn should_generate_debug_id(&self) -> bool {\n+        self.should_generate_debug_id\n+    }\n \n     /// Take the source code out of the Code.\n     pub fn into_source_code(self) -> Rope {\n         self.code\n     }\n+\n+    // Formats the code with the source map and debug id comments as\n+    pub async fn to_rope_with_magic_comments(\n+        self: Vc<Self>,\n+        source_map_path_fn: impl FnOnce() -> Vc<SourceMapAsset>,\n+    ) -> Result<Rope> {\n+        let code = self.await?;\n+        Ok(\n+            if code.has_source_map() || code.should_generate_debug_id() {\n+                let mut rope_builder = RopeBuilder::default();\n+                let debug_id = self.debug_id().await?;\n+                // hand minified version of\n+                // ```javascript\n+                //  !() => {\n+                //    (globalThis ??= {})[new g.Error().stack] = <debug_id>;\n+                // }()\n+                // ```\n+                // But we need to be compatible with older runtimes since this code isn't transpiled\n+                // according to a browser list. So we use `var`, `function` and\n+                // try-caatch since we cannot rely on `Error.stack` being available.\n+                // And finally to ensure it is on one line since that is what the source map\n+                // expects.\n+                // So like Thanos we have to do it ourselves.\n+                if let Some(debug_id) = &*debug_id {\n+                    // Test for `globalThis` first since it is available on all platforms released\n+                    // since 2018! so it will mostly work\n+                    const GLOBALTHIS_EXPR: &str = r#\"\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof global?global:\"undefined\"!=typeof window?window:\"undefined\"!=typeof self?self:{}\"#;\n+                    const GLOBAL_VAR_NAME: &str = \"_debugIds\";\n+                    writeln!(\n+                        rope_builder,\n+                        r#\";!function(){{try {{ var e={GLOBALTHIS_EXPR},n=(new e.Error).stack;n&&((e.{GLOBAL_VAR_NAME}|| (e.{GLOBAL_VAR_NAME}={{}}))[n]=\"{debug_id}\")}}catch(e){{}}}}();\"#,\n+                    )?;\n+                }\n+\n+                rope_builder.concat(&code.code);\n+                rope_builder.push_static_bytes(b\"\\n\");\n+                // Add debug ID comment if enabled\n+                if let Some(debug_id) = &*debug_id {\n+                    write!(rope_builder, \"\\n//# debugId={}\", debug_id)?;\n+                }\n+\n+                if code.has_source_map() {\n+                    let source_map_path = source_map_path_fn().path().await?;\n+                    write!(\n+                        rope_builder,\n+                        \"\\n//# sourceMappingURL={}\",\n+                        urlencoding::encode(source_map_path.file_name())\n+                    )?;\n+                }\n+                rope_builder.build()\n+            } else {\n+                code.code.clone()\n+            },\n+        )\n+    }\n }\n \n /// CodeBuilder provides a mutable container to append source code.\n pub struct CodeBuilder {\n     code: RopeBuilder,\n     mappings: Option<Vec<Mapping>>,\n+    should_generate_debug_id: bool,\n }\n \n impl Default for CodeBuilder {\n     fn default() -> Self {\n         Self {\n             code: RopeBuilder::default(),\n             mappings: Some(Vec::new()),\n+            should_generate_debug_id: false,\n         }\n     }\n }\n \n impl CodeBuilder {\n-    pub fn new(collect_mappings: bool) -> Self {\n+    pub fn new(collect_mappings: bool, should_generate_debug_id: bool) -> Self {\n         Self {\n             code: RopeBuilder::default(),\n             mappings: collect_mappings.then(Vec::new),\n+            should_generate_debug_id,\n         }\n     }\n \n@@ -83,6 +149,8 @@ impl CodeBuilder {\n \n     /// Copies the Synthetic/Original code of an already constructed Code into\n     /// this instance.\n+    ///\n+    /// This adjusts the source map to be relative to the new code object\n     pub fn push_code(&mut self, prebuilt: &Code) {\n         if let Some((index, _)) = prebuilt.mappings.first() {\n             if *index > 0 {\n@@ -140,6 +208,7 @@ impl CodeBuilder {\n         Code {\n             code: self.code.build(),\n             mappings: self.mappings.unwrap_or_default(),\n+            should_generate_debug_id: self.should_generate_debug_id,\n         }\n     }\n }\n@@ -186,11 +255,19 @@ impl GenerateSourceMap for Code {\n     /// far the simplest way to concatenate the source maps of the multiple\n     /// chunk items into a single map file.\n     #[turbo_tasks::function]\n-    pub fn generate_source_map(&self) -> Result<Vc<OptionStringifiedSourceMap>> {\n-        Ok(Vc::cell(Some(self.generate_source_map_ref()?)))\n+    pub async fn generate_source_map(\n+        self: ResolvedVc<Self>,\n+    ) -> Result<Vc<OptionStringifiedSourceMap>> {\n+        let debug_id = self.debug_id().owned().await?;\n+        Ok(Vc::cell(Some(\n+            self.await?.generate_source_map_ref(debug_id),\n+        )))\n     }\n }\n \n+#[turbo_tasks::value(transparent)]\n+pub struct OptionDebugId(Option<RcStr>);\n+\n #[turbo_tasks::value_impl]\n impl Code {\n     /// Returns the hash of the source code of this Code.\n@@ -200,20 +277,37 @@ impl Code {\n         let hash = hash_xxh3_hash64(code.source_code());\n         Vc::cell(hash)\n     }\n+\n+    #[turbo_tasks::function]\n+    pub fn debug_id(&self) -> Vc<OptionDebugId> {\n+        Vc::cell(if self.should_generate_debug_id {\n+            Some(generate_debug_id(self.source_code()))\n+        } else {\n+            None\n+        })\n+    }\n }\n \n impl Code {\n+    /// Generates a source map from the code's mappings.\n     #[instrument(level = \"trace\", name = \"Code::generate_source_map\", skip_all)]\n-    pub fn generate_source_map_ref(&self) -> Result<Rope> {\n-        let mut pos = SourcePos::new();\n+    pub fn generate_source_map_ref(&self, debug_id: Option<RcStr>) -> Rope {\n+        // A debug id should be passed only if the code should generate a debug id, it is however\n+        // allowed to turn it off to access intermediate states of the code (e.g. for minification)\n+        debug_assert!(debug_id.is_none() || self.should_generate_debug_id);\n+        // If there is a debug id the first line will be modifying the global object. see\n+        // `[to_rope_with_magic_comments]` for more details.\n+        let mut pos = SourcePos::new(if debug_id.is_some() { 1 } else { 0 });\n+\n         let mut last_byte_pos = 0;\n \n         let mut sections = Vec::with_capacity(self.mappings.len());\n         let mut read = self.code.read();\n         for (byte_pos, map) in &self.mappings {\n             let mut want = byte_pos - last_byte_pos;\n             while want > 0 {\n-                let buf = read.fill_buf()?;\n+                // `fill_buf` never returns an error.\n+                let buf = read.fill_buf().unwrap();\n                 debug_assert!(!buf.is_empty());\n \n                 let end = min(want, buf.len());\n@@ -228,16 +322,26 @@ impl Code {\n                 sections.push((pos, map.clone()))\n             } else {\n                 // We don't need an empty source map when column is 0 or the next char is a newline.\n-                if pos.column != 0 && read.fill_buf()?.first().is_some_and(|&b| b != b'\\n') {\n+                if pos.column != 0\n+                    && read\n+                        .fill_buf()\n+                        .unwrap()\n+                        .first()\n+                        .is_some_and(|&b| b != b'\\n')\n+                {\n                     sections.push((pos, SourceMap::empty_rope()));\n                 }\n             }\n         }\n \n-        if sections.len() == 1 && sections[0].0.line == 0 && sections[0].0.column == 0 {\n-            Ok(sections.into_iter().next().unwrap().1)\n+        if sections.len() == 1\n+            && sections[0].0.line == 0\n+            && sections[0].0.column == 0\n+            && debug_id.is_none()\n+        {\n+            sections.into_iter().next().unwrap().1\n         } else {\n-            SourceMap::sections_to_rope(sections)\n+            SourceMap::sections_to_rope(sections, debug_id)\n         }\n     }\n }"
        },
        {
            "sha": "519943cc9cbb91d5f2a39fb499aea930efaed433",
            "filename": "turbopack/crates/turbopack-core/src/debug_id.rs",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fdebug_id.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fdebug_id.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fdebug_id.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1,74 @@\n+use turbo_rcstr::RcStr;\n+use turbo_tasks_fs::rope::Rope;\n+use twox_hash::xxhash3_128;\n+\n+/// Generate a deterministic debug ID from content using hash-based UUID generation\n+///\n+/// This follows the TC39 debug ID proposal by generating UUIDs that are deterministic\n+/// based on the content, ensuring reproducible builds while maintaining uniqueness.\n+/// Uses xxHash3-128 for fast, stable, and collision-resistant hashing.\n+pub fn generate_debug_id(content: &Rope) -> RcStr {\n+    let mut hasher = xxhash3_128::Hasher::new();\n+    for bytes in content.read() {\n+        hasher.write(bytes.as_ref());\n+    }\n+    let hash = hasher.finish_128();\n+    uuid::Uuid::from_u128(hash)\n+        .as_hyphenated()\n+        .to_string()\n+        .into()\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_generate_debug_id_deterministic() {\n+        // Create test content\n+        let content = Rope::from(\"console.log('Hello World');\");\n+\n+        // Generate debug ID twice\n+        let id1 = generate_debug_id(&content);\n+        let id2 = generate_debug_id(&content);\n+\n+        // Should be identical (deterministic)\n+        assert_eq!(id1, id2);\n+\n+        // Should be valid UUID format (8-4-4-4-12)\n+        assert_eq!(id1.len(), 36);\n+        assert!(id1.contains('-'));\n+    }\n+\n+    #[test]\n+    fn test_generate_debug_id_different_content() {\n+        // Create two different pieces of content\n+        let content1 = Rope::from(\"console.log('Hello');\");\n+        let content2 = Rope::from(\"console.log('World');\");\n+\n+        // Generate debug IDs\n+        let id1 = generate_debug_id(&content1);\n+        let id2 = generate_debug_id(&content2);\n+\n+        // Should be different\n+        assert_ne!(id1, id2);\n+    }\n+\n+    #[test]\n+    fn test_debug_id_format() {\n+        let content = Rope::from(\"test content\");\n+        let debug_id = generate_debug_id(&content);\n+\n+        // Verify UUID format: 8-4-4-4-12 characters\n+        let parts: Vec<&str> = debug_id.split('-').collect();\n+        assert_eq!(parts.len(), 5);\n+        assert_eq!(parts[0].len(), 8);\n+        assert_eq!(parts[1].len(), 4);\n+        assert_eq!(parts[2].len(), 4);\n+        assert_eq!(parts[3].len(), 4);\n+        assert_eq!(parts[4].len(), 12);\n+\n+        // Should be lowercase\n+        assert_eq!(debug_id, debug_id.to_lowercase());\n+    }\n+}"
        },
        {
            "sha": "6e00a818864c720983d8f4a9827e3fc3a56ba7cb",
            "filename": "turbopack/crates/turbopack-core/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Flib.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -16,6 +16,7 @@ pub mod compile_time_info;\n pub mod condition;\n pub mod context;\n pub mod data_uri_source;\n+pub mod debug_id;\n pub mod diagnostics;\n pub mod environment;\n pub mod error;"
        },
        {
            "sha": "f832222380b88027cc9b8b5e75a13ed4fde689a4",
            "filename": "turbopack/crates/turbopack-core/src/source_map/mod.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 5,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fmod.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -274,16 +274,20 @@ impl SourceMap {\n         EMPTY_SOURCE_MAP_ROPE.clone()\n     }\n \n-    pub fn sections_to_rope(sections: impl IntoIterator<Item = (SourcePos, Rope)>) -> Result<Rope> {\n+    pub fn sections_to_rope(\n+        sections: impl IntoIterator<Item = (SourcePos, Rope)>,\n+        debug_id: Option<RcStr>,\n+    ) -> Rope {\n         let mut sections = sections.into_iter().peekable();\n \n         let mut first = sections.next();\n         if let Some((offset, map)) = &mut first\n             && sections.peek().is_none()\n             && *offset == (0, 0)\n+            && debug_id.is_none()\n         {\n             // There is just a single sourcemap that starts at the beginning of the file.\n-            return Ok(std::mem::take(map));\n+            return std::mem::take(map);\n         }\n \n         // My kingdom for a decent dedent macro with interpolation!\n@@ -293,8 +297,12 @@ impl SourceMap {\n             r#\"{\n   \"version\": 3,\n   \"sources\": [],\n-  \"sections\": [\"#,\n+\"#,\n         );\n+        if let Some(debug_id) = debug_id {\n+            writeln!(rope, r#\"  \"debugId\": \"{debug_id}\",\"#).unwrap();\n+        }\n+        rope += \"  \\\"sections\\\": [\";\n \n         let mut first_section = true;\n         for (offset, section_map) in first.into_iter().chain(sections) {\n@@ -308,7 +316,8 @@ impl SourceMap {\n                 r#\"\n     {{\"offset\": {{\"line\": {}, \"column\": {}}}, \"map\": \"#,\n                 offset.line, offset.column,\n-            )?;\n+            )\n+            .unwrap();\n \n             rope += &section_map;\n \n@@ -319,7 +328,7 @@ impl SourceMap {\n \n         rope += \"\\n}\";\n \n-        Ok(rope.build())\n+        rope.build()\n     }\n \n     /// Stringifies the source map into JSON bytes."
        },
        {
            "sha": "9d19c0d01afb60a7a9258399f62eaf94d9e3c605",
            "filename": "turbopack/crates/turbopack-core/src/source_pos.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_pos.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_pos.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_pos.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -32,8 +32,11 @@ pub struct SourcePos {\n }\n \n impl SourcePos {\n-    pub fn new() -> Self {\n-        Default::default()\n+    pub fn new(start_line: u32) -> Self {\n+        Self {\n+            line: start_line,\n+            column: 0,\n+        }\n     }\n \n     pub fn max() -> Self {"
        },
        {
            "sha": "76c1e4c261fa3e3583f8f0141061c79c7b43415b",
            "filename": "turbopack/crates/turbopack-css/src/chunk/mod.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -74,8 +74,9 @@ impl CssChunk {\n             .reference_chunk_source_maps(Vc::upcast(self))\n             .await?;\n \n-        let mut code = CodeBuilder::new(source_maps);\n-        let mut body = CodeBuilder::new(source_maps);\n+        // CSS chunks never have debug IDs\n+        let mut code = CodeBuilder::new(source_maps, false);\n+        let mut body = CodeBuilder::new(source_maps, false);\n         let mut external_imports = FxIndexSet::default();\n         for css_item in &this.content.await?.chunk_items {\n             let content = &css_item.content().await?;"
        },
        {
            "sha": "dc1331668e5ae422f57d4ada47d1ed27191d4a49",
            "filename": "turbopack/crates/turbopack-css/src/chunk/single_item_chunk/chunk.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fchunk.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -53,7 +53,8 @@ impl SingleItemCssChunk {\n             .chunking_context\n             .reference_chunk_source_maps(Vc::upcast(self))\n             .await?;\n-        let mut code = CodeBuilder::new(source_maps);\n+        // CSS chunks never have debug IDs\n+        let mut code = CodeBuilder::new(source_maps, false);\n \n         if matches!(\n             &*this.chunking_context.minify_type().await?,"
        },
        {
            "sha": "02687706af3e19c73668dd725e27d6ab9ac2fd17",
            "filename": "turbopack/crates/turbopack-ecmascript/src/minify.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fminify.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fminify.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fminify.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -34,10 +34,11 @@ use crate::parse::generate_js_source_map;\n \n #[instrument(level = \"info\", name = \"minify ecmascript code\", skip_all)]\n pub fn minify(code: Code, source_maps: bool, mangle: Option<MangleType>) -> Result<Code> {\n-    let source_maps = source_maps\n-        .then(|| code.generate_source_map_ref())\n-        .transpose()?;\n+    // Pass None for the debug ID so we don't needlessly compute it for the pre-minified content, it\n+    // will be added by the Code object returned from this function\n+    let source_maps = source_maps.then(|| code.generate_source_map_ref(None));\n \n+    let generate_debug_id = code.should_generate_debug_id();\n     let source_code = BytesStr::from_utf8(code.into_source_code().into_bytes())?;\n \n     let cm = Arc::new(SwcSourceMap::new(FilePathMapping::empty()));\n@@ -129,7 +130,7 @@ pub fn minify(code: Code, source_maps: bool, mangle: Option<MangleType>) -> Resu\n         print_program(cm.clone(), program, source_maps.is_some())?\n     };\n \n-    let mut builder = CodeBuilder::new(source_maps.is_some());\n+    let mut builder = CodeBuilder::new(source_maps.is_some(), generate_debug_id);\n     if let Some(original_map) = source_maps.as_ref() {\n         src_map_buf.shrink_to_fit();\n         builder.push_source("
        },
        {
            "sha": "e19d1dcb7f8006f5e41780c67eeae8faffcf70d4",
            "filename": "turbopack/crates/turbopack-nodejs/src/chunking_context.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fchunking_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fchunking_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fchunking_context.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -112,6 +112,11 @@ impl NodeJsChunkingContextBuilder {\n         self\n     }\n \n+    pub fn debug_ids(mut self, debug_ids: bool) -> Self {\n+        self.chunking_context.debug_ids = debug_ids;\n+        self\n+    }\n+\n     /// Builds the chunking context.\n     pub fn build(self) -> Vc<NodeJsChunkingContext> {\n         NodeJsChunkingContext::cell(self.chunking_context)\n@@ -160,6 +165,8 @@ pub struct NodeJsChunkingContext {\n     should_use_file_source_map_uris: bool,\n     /// The chunking configs\n     chunking_configs: Vec<(ResolvedVc<Box<dyn ChunkType>>, ChunkingConfig)>,\n+    /// Enable debug IDs for chunks and source maps.\n+    debug_ids: bool,\n }\n \n impl NodeJsChunkingContext {\n@@ -195,6 +202,7 @@ impl NodeJsChunkingContext {\n                 module_id_strategy: ResolvedVc::upcast(DevModuleIdStrategy::new_resolved()),\n                 export_usage: None,\n                 chunking_configs: Default::default(),\n+                debug_ids: false,\n             },\n         }\n     }\n@@ -549,4 +557,9 @@ impl ChunkingContext for NodeJsChunkingContext {\n             Ok(ModuleExportUsage::all())\n         }\n     }\n+\n+    #[turbo_tasks::function]\n+    fn debug_ids_enabled(&self) -> Vc<bool> {\n+        Vc::cell(self.debug_ids)\n+    }\n }"
        },
        {
            "sha": "ea49a821bad7029211cbaa6d906e1dab48aa894b",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/content.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 20,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fcontent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fcontent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fcontent.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -1,6 +1,6 @@\n use anyhow::Result;\n use turbo_tasks::{ResolvedVc, Vc};\n-use turbo_tasks_fs::{File, rope::RopeBuilder};\n+use turbo_tasks_fs::File;\n use turbopack_core::{\n     asset::AssetContent,\n     chunk::{ChunkingContext, MinifyType},\n@@ -52,7 +52,7 @@ impl EcmascriptBuildNodeChunkContent {\n             .reference_chunk_source_maps(*ResolvedVc::upcast(this.chunk))\n             .await?;\n \n-        let mut code = CodeBuilder::default();\n+        let mut code = CodeBuilder::new(true, *this.chunking_context.debug_ids_enabled().await?);\n \n         write!(code, \"module.exports = [\")?;\n \n@@ -101,24 +101,14 @@ impl VersionedContent for EcmascriptBuildNodeChunkContent {\n     #[turbo_tasks::function]\n     async fn content(self: Vc<Self>) -> Result<Vc<AssetContent>> {\n         let this = self.await?;\n-        let code = self.code().await?;\n-\n-        let rope = if code.has_source_map() {\n-            use std::io::Write;\n-            let mut rope_builder = RopeBuilder::default();\n-            rope_builder.concat(code.source_code());\n-            let source_map_path = this.source_map.path().await?;\n-            write!(\n-                rope_builder,\n-                \"\\n\\n//# sourceMappingURL={}\",\n-                urlencoding::encode(source_map_path.file_name())\n-            )?;\n-            rope_builder.build()\n-        } else {\n-            code.source_code().clone()\n-        };\n-\n-        Ok(AssetContent::file(File::from(rope).into()))\n+        Ok(AssetContent::file(\n+            File::from(\n+                self.code()\n+                    .to_rope_with_magic_comments(|| *this.source_map)\n+                    .await?,\n+            )\n+            .into(),\n+        ))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "bc83260d8c98dc8a800335eb38f9b9488b7367b2",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/entry/runtime.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 18,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fruntime.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fruntime.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fruntime.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -4,7 +4,7 @@ use anyhow::{Result, bail};\n use indoc::writedoc;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n-use turbo_tasks_fs::{File, FileSystem, FileSystemPath, rope::RopeBuilder};\n+use turbo_tasks_fs::{File, FileSystem, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::ChunkingContext,\n@@ -156,23 +156,14 @@ impl OutputAsset for EcmascriptBuildNodeRuntimeChunk {\n impl Asset for EcmascriptBuildNodeRuntimeChunk {\n     #[turbo_tasks::function]\n     async fn content(self: Vc<Self>) -> Result<Vc<AssetContent>> {\n-        let code = self.code().await?;\n-\n-        let rope = if code.has_source_map() {\n-            let mut rope_builder = RopeBuilder::default();\n-            rope_builder.concat(code.source_code());\n-            let source_map_path = self.source_map().path().await?;\n-            write!(\n-                rope_builder,\n-                \"\\n\\n//# sourceMappingURL={}\",\n-                urlencoding::encode(source_map_path.file_name())\n-            )?;\n-            rope_builder.build()\n-        } else {\n-            code.source_code().clone()\n-        };\n-\n-        Ok(AssetContent::file(File::from(rope).into()))\n+        Ok(AssetContent::file(\n+            File::from(\n+                self.code()\n+                    .to_rope_with_magic_comments(|| self.source_map())\n+                    .await?,\n+            )\n+            .into(),\n+        ))\n     }\n }\n "
        },
        {
            "sha": "012196f28fd446cf8acc49b46a4cf659f5322456",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot.rs?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -89,6 +89,8 @@ struct SnapshotOptions {\n     scope_hoisting: bool,\n     #[serde(default)]\n     production_chunking: bool,\n+    #[serde(default)]\n+    enable_debug_ids: bool,\n }\n \n #[derive(Debug, Deserialize, Default)]\n@@ -118,6 +120,7 @@ impl Default for SnapshotOptions {\n             remove_unused_exports: false,\n             scope_hoisting: false,\n             production_chunking: false,\n+            enable_debug_ids: false,\n         }\n     }\n }\n@@ -456,7 +459,8 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n             )\n             .minify_type(options.minify_type)\n             .module_merging(options.scope_hoisting)\n-            .export_usage(export_usage);\n+            .export_usage(export_usage)\n+            .debug_ids(options.enable_debug_ids);\n \n             if options.production_chunking {\n                 builder = builder.chunking_config(\n@@ -484,7 +488,8 @@ async fn run_test_operation(resource: RcStr) -> Result<Vc<FileSystemPath>> {\n             )\n             .minify_type(options.minify_type)\n             .module_merging(options.scope_hoisting)\n-            .export_usage(export_usage);\n+            .export_usage(export_usage)\n+            .debug_ids(options.enable_debug_ids);\n \n             if options.production_chunking {\n                 builder = builder.chunking_config("
        },
        {
            "sha": "ba72797f7faa9f73154ab3578e1aca3558ddada1",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/browser/input/index.js",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Finput%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Finput%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Finput%2Findex.js?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1 @@\n+console.log('Hello World')"
        },
        {
            "sha": "6a4cc1029b53f6e00519a206c0099ce778e3bc30",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/browser/options.json",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foptions.json",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foptions.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foptions.json?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1,7 @@\n+{\n+  \"runtime\": \"Browser\",\n+  \"runtimeType\": \"Development\",\n+  \"minifyType\": \"NoMinify\",\n+  \"environment\": \"Browser\",\n+  \"enableDebugIds\": true\n+}"
        },
        {
            "sha": "a30c747c12b218b37f27e8a4ffa092f71961f139",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/browser/output/aaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0151fefb.js.map",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0151fefb.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0151fefb.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0151fefb.js.map?ref=624a01400906c55015fa20d2f730f4b108a2b675"
        },
        {
            "sha": "74243b5e47d423196095d8655574e29fbc33a286",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/browser/output/aaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0b8736b3.js",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0b8736b3.js",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0b8736b3.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0b8736b3.js?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1,10 @@\n+;!function(){try { var e=\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof global?global:\"undefined\"!=typeof window?window:\"undefined\"!=typeof self?self:{},n=(new e.Error).stack;n&&((e._debugIds|| (e._debugIds={}))[n]=\"63c63dcc-bb90-d982-2cba-3b40c49a2b4a\")}catch(e){}}();\n+(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([\"output/aaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0b8736b3.js\",\n+\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/browser/input/index.js [test] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n+\n+console.log('Hello World');\n+}),\n+]);\n+\n+//# debugId=63c63dcc-bb90-d982-2cba-3b40c49a2b4a\n+//# sourceMappingURL=aaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0b8736b3.js.map\n\\ No newline at end of file"
        },
        {
            "sha": "84ecb56fe0dc61397d6054351bcc76151d218e09",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/browser/output/aaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0b8736b3.js.map",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0b8736b3.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0b8736b3.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0b8736b3.js.map?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1,7 @@\n+{\n+  \"version\": 3,\n+  \"sources\": [],\n+  \"debugId\": \"63c63dcc-bb90-d982-2cba-3b40c49a2b4a\",\n+  \"sections\": [\n+    {\"offset\": {\"line\": 4, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/browser/input/index.js\"],\"sourcesContent\":[\"console.log('Hello World')\\n\"],\"names\":[],\"mappings\":\"AAAA,QAAQ,GAAG,CAAC\"}}]\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "a98eab096eb5c2c158e3c8dbd70ba09694086438",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/browser/output/ba425_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0151fefb.js",
            "status": "added",
            "additions": 1838,
            "deletions": 0,
            "changes": 1838,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foutput%2Fba425_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0151fefb.js",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foutput%2Fba425_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0151fefb.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fbrowser%2Foutput%2Fba425_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0151fefb.js?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1,1838 @@\n+;!function(){try { var e=\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof global?global:\"undefined\"!=typeof window?window:\"undefined\"!=typeof self?self:{},n=(new e.Error).stack;n&&((e._debugIds|| (e._debugIds={}))[n]=\"9cf0cfff-fe6b-e2a6-ed5a-275f25467c66\")}catch(e){}}();\n+(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([\n+    \"output/ba425_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0151fefb.js\",\n+    {\"otherChunks\":[\"output/aaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0b8736b3.js\"],\"runtimeModuleIds\":[\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/browser/input/index.js [test] (ecmascript)\"]}\n+]);\n+(() => {\n+if (!Array.isArray(globalThis.TURBOPACK)) {\n+    return;\n+}\n+\n+const CHUNK_BASE_PATH = \"\";\n+const CHUNK_SUFFIX_PATH = \"\";\n+const RELATIVE_ROOT_PATH = \"../../../../../../..\";\n+const RUNTIME_PUBLIC_PATH = \"\";\n+/**\n+ * This file contains runtime types and functions that are shared between all\n+ * TurboPack ECMAScript runtimes.\n+ *\n+ * It will be prepended to the runtime code of each runtime.\n+ */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"./runtime-types.d.ts\" />\n+const REEXPORTED_OBJECTS = new WeakMap();\n+/**\n+ * Constructs the `__turbopack_context__` object for a module.\n+ */ function Context(module, exports) {\n+    this.m = module;\n+    // We need to store this here instead of accessing it from the module object to:\n+    // 1. Make it available to factories directly, since we rewrite `this` to\n+    //    `__turbopack_context__.e` in CJS modules.\n+    // 2. Support async modules which rewrite `module.exports` to a promise, so we\n+    //    can still access the original exports object from functions like\n+    //    `esmExport`\n+    // Ideally we could find a new approach for async modules and drop this property altogether.\n+    this.e = exports;\n+}\n+const contextPrototype = Context.prototype;\n+const hasOwnProperty = Object.prototype.hasOwnProperty;\n+const toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag;\n+function defineProp(obj, name, options) {\n+    if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options);\n+}\n+function getOverwrittenModule(moduleCache, id) {\n+    let module = moduleCache[id];\n+    if (!module) {\n+        // This is invoked when a module is merged into another module, thus it wasn't invoked via\n+        // instantiateModule and the cache entry wasn't created yet.\n+        module = createModuleObject(id);\n+        moduleCache[id] = module;\n+    }\n+    return module;\n+}\n+/**\n+ * Creates the module object. Only done here to ensure all module objects have the same shape.\n+ */ function createModuleObject(id) {\n+    return {\n+        exports: {},\n+        error: undefined,\n+        id,\n+        namespaceObject: undefined\n+    };\n+}\n+const BindingTag_Value = 0;\n+/**\n+ * Adds the getters to the exports object.\n+ */ function esm(exports, bindings) {\n+    defineProp(exports, '__esModule', {\n+        value: true\n+    });\n+    if (toStringTag) defineProp(exports, toStringTag, {\n+        value: 'Module'\n+    });\n+    let i = 0;\n+    while(i < bindings.length){\n+        const propName = bindings[i++];\n+        const tagOrFunction = bindings[i++];\n+        if (typeof tagOrFunction === 'number') {\n+            if (tagOrFunction === BindingTag_Value) {\n+                defineProp(exports, propName, {\n+                    value: bindings[i++],\n+                    enumerable: true,\n+                    writable: false\n+                });\n+            } else {\n+                throw new Error(`unexpected tag: ${tagOrFunction}`);\n+            }\n+        } else {\n+            const getterFn = tagOrFunction;\n+            if (typeof bindings[i] === 'function') {\n+                const setterFn = bindings[i++];\n+                defineProp(exports, propName, {\n+                    get: getterFn,\n+                    set: setterFn,\n+                    enumerable: true\n+                });\n+            } else {\n+                defineProp(exports, propName, {\n+                    get: getterFn,\n+                    enumerable: true\n+                });\n+            }\n+        }\n+    }\n+    Object.seal(exports);\n+}\n+/**\n+ * Makes the module an ESM with exports\n+ */ function esmExport(bindings, id) {\n+    let module;\n+    let exports;\n+    if (id != null) {\n+        module = getOverwrittenModule(this.c, id);\n+        exports = module.exports;\n+    } else {\n+        module = this.m;\n+        exports = this.e;\n+    }\n+    module.namespaceObject = exports;\n+    esm(exports, bindings);\n+}\n+contextPrototype.s = esmExport;\n+function ensureDynamicExports(module, exports) {\n+    let reexportedObjects = REEXPORTED_OBJECTS.get(module);\n+    if (!reexportedObjects) {\n+        REEXPORTED_OBJECTS.set(module, reexportedObjects = []);\n+        module.exports = module.namespaceObject = new Proxy(exports, {\n+            get (target, prop) {\n+                if (hasOwnProperty.call(target, prop) || prop === 'default' || prop === '__esModule') {\n+                    return Reflect.get(target, prop);\n+                }\n+                for (const obj of reexportedObjects){\n+                    const value = Reflect.get(obj, prop);\n+                    if (value !== undefined) return value;\n+                }\n+                return undefined;\n+            },\n+            ownKeys (target) {\n+                const keys = Reflect.ownKeys(target);\n+                for (const obj of reexportedObjects){\n+                    for (const key of Reflect.ownKeys(obj)){\n+                        if (key !== 'default' && !keys.includes(key)) keys.push(key);\n+                    }\n+                }\n+                return keys;\n+            }\n+        });\n+    }\n+    return reexportedObjects;\n+}\n+/**\n+ * Dynamically exports properties from an object\n+ */ function dynamicExport(object, id) {\n+    let module;\n+    let exports;\n+    if (id != null) {\n+        module = getOverwrittenModule(this.c, id);\n+        exports = module.exports;\n+    } else {\n+        module = this.m;\n+        exports = this.e;\n+    }\n+    const reexportedObjects = ensureDynamicExports(module, exports);\n+    if (typeof object === 'object' && object !== null) {\n+        reexportedObjects.push(object);\n+    }\n+}\n+contextPrototype.j = dynamicExport;\n+function exportValue(value, id) {\n+    let module;\n+    if (id != null) {\n+        module = getOverwrittenModule(this.c, id);\n+    } else {\n+        module = this.m;\n+    }\n+    module.exports = value;\n+}\n+contextPrototype.v = exportValue;\n+function exportNamespace(namespace, id) {\n+    let module;\n+    if (id != null) {\n+        module = getOverwrittenModule(this.c, id);\n+    } else {\n+        module = this.m;\n+    }\n+    module.exports = module.namespaceObject = namespace;\n+}\n+contextPrototype.n = exportNamespace;\n+function createGetter(obj, key) {\n+    return ()=>obj[key];\n+}\n+/**\n+ * @returns prototype of the object\n+ */ const getProto = Object.getPrototypeOf ? (obj)=>Object.getPrototypeOf(obj) : (obj)=>obj.__proto__;\n+/** Prototypes that are not expanded for exports */ const LEAF_PROTOTYPES = [\n+    null,\n+    getProto({}),\n+    getProto([]),\n+    getProto(getProto)\n+];\n+/**\n+ * @param raw\n+ * @param ns\n+ * @param allowExportDefault\n+ *   * `false`: will have the raw module as default export\n+ *   * `true`: will have the default property as default export\n+ */ function interopEsm(raw, ns, allowExportDefault) {\n+    const bindings = [];\n+    let defaultLocation = -1;\n+    for(let current = raw; (typeof current === 'object' || typeof current === 'function') && !LEAF_PROTOTYPES.includes(current); current = getProto(current)){\n+        for (const key of Object.getOwnPropertyNames(current)){\n+            bindings.push(key, createGetter(raw, key));\n+            if (defaultLocation === -1 && key === 'default') {\n+                defaultLocation = bindings.length - 1;\n+            }\n+        }\n+    }\n+    // this is not really correct\n+    // we should set the `default` getter if the imported module is a `.cjs file`\n+    if (!(allowExportDefault && defaultLocation >= 0)) {\n+        // Replace the binding with one for the namespace itself in order to preserve iteration order.\n+        if (defaultLocation >= 0) {\n+            // Replace the getter with the value\n+            bindings.splice(defaultLocation, 1, BindingTag_Value, raw);\n+        } else {\n+            bindings.push('default', BindingTag_Value, raw);\n+        }\n+    }\n+    esm(ns, bindings);\n+    return ns;\n+}\n+function createNS(raw) {\n+    if (typeof raw === 'function') {\n+        return function(...args) {\n+            return raw.apply(this, args);\n+        };\n+    } else {\n+        return Object.create(null);\n+    }\n+}\n+function esmImport(id) {\n+    const module = getOrInstantiateModuleFromParent(id, this.m);\n+    // any ES module has to have `module.namespaceObject` defined.\n+    if (module.namespaceObject) return module.namespaceObject;\n+    // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n+    const raw = module.exports;\n+    return module.namespaceObject = interopEsm(raw, createNS(raw), raw && raw.__esModule);\n+}\n+contextPrototype.i = esmImport;\n+function asyncLoader(moduleId) {\n+    const loader = this.r(moduleId);\n+    return loader(esmImport.bind(this));\n+}\n+contextPrototype.A = asyncLoader;\n+// Add a simple runtime require so that environments without one can still pass\n+// `typeof require` CommonJS checks so that exports are correctly registered.\n+const runtimeRequire = // @ts-ignore\n+typeof require === 'function' ? require : function require1() {\n+    throw new Error('Unexpected use of runtime require');\n+};\n+contextPrototype.t = runtimeRequire;\n+function commonJsRequire(id) {\n+    return getOrInstantiateModuleFromParent(id, this.m).exports;\n+}\n+contextPrototype.r = commonJsRequire;\n+/**\n+ * `require.context` and require/import expression runtime.\n+ */ function moduleContext(map) {\n+    function moduleContext(id) {\n+        if (hasOwnProperty.call(map, id)) {\n+            return map[id].module();\n+        }\n+        const e = new Error(`Cannot find module '${id}'`);\n+        e.code = 'MODULE_NOT_FOUND';\n+        throw e;\n+    }\n+    moduleContext.keys = ()=>{\n+        return Object.keys(map);\n+    };\n+    moduleContext.resolve = (id)=>{\n+        if (hasOwnProperty.call(map, id)) {\n+            return map[id].id();\n+        }\n+        const e = new Error(`Cannot find module '${id}'`);\n+        e.code = 'MODULE_NOT_FOUND';\n+        throw e;\n+    };\n+    moduleContext.import = async (id)=>{\n+        return await moduleContext(id);\n+    };\n+    return moduleContext;\n+}\n+contextPrototype.f = moduleContext;\n+/**\n+ * Returns the path of a chunk defined by its data.\n+ */ function getChunkPath(chunkData) {\n+    return typeof chunkData === 'string' ? chunkData : chunkData.path;\n+}\n+function isPromise(maybePromise) {\n+    return maybePromise != null && typeof maybePromise === 'object' && 'then' in maybePromise && typeof maybePromise.then === 'function';\n+}\n+function isAsyncModuleExt(obj) {\n+    return turbopackQueues in obj;\n+}\n+function createPromise() {\n+    let resolve;\n+    let reject;\n+    const promise = new Promise((res, rej)=>{\n+        reject = rej;\n+        resolve = res;\n+    });\n+    return {\n+        promise,\n+        resolve: resolve,\n+        reject: reject\n+    };\n+}\n+// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\n+// The CompressedModuleFactories format is\n+// - 1 or more module ids\n+// - a module factory function\n+// So walking this is a little complex but the flat structure is also fast to\n+// traverse, we can use `typeof` operators to distinguish the two cases.\n+function installCompressedModuleFactories(chunkModules, offset, moduleFactories, newModuleId) {\n+    let i = offset;\n+    while(i < chunkModules.length){\n+        let moduleId = chunkModules[i];\n+        let end = i + 1;\n+        // Find our factory function\n+        while(end < chunkModules.length && typeof chunkModules[end] !== 'function'){\n+            end++;\n+        }\n+        if (end === chunkModules.length) {\n+            throw new Error('malformed chunk format, expected a factory function');\n+        }\n+        // Each chunk item has a 'primary id' and optional additional ids. If the primary id is already\n+        // present we know all the additional ids are also present, so we don't need to check.\n+        if (!moduleFactories.has(moduleId)) {\n+            const moduleFactoryFn = chunkModules[end];\n+            applyModuleFactoryName(moduleFactoryFn);\n+            newModuleId?.(moduleId);\n+            for(; i < end; i++){\n+                moduleId = chunkModules[i];\n+                moduleFactories.set(moduleId, moduleFactoryFn);\n+            }\n+        }\n+        i = end + 1; // end is pointing at the last factory advance to the next id or the end of the array.\n+    }\n+}\n+// everything below is adapted from webpack\n+// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\n+const turbopackQueues = Symbol('turbopack queues');\n+const turbopackExports = Symbol('turbopack exports');\n+const turbopackError = Symbol('turbopack error');\n+function resolveQueue(queue) {\n+    if (queue && queue.status !== 1) {\n+        queue.status = 1;\n+        queue.forEach((fn)=>fn.queueCount--);\n+        queue.forEach((fn)=>fn.queueCount-- ? fn.queueCount++ : fn());\n+    }\n+}\n+function wrapDeps(deps) {\n+    return deps.map((dep)=>{\n+        if (dep !== null && typeof dep === 'object') {\n+            if (isAsyncModuleExt(dep)) return dep;\n+            if (isPromise(dep)) {\n+                const queue = Object.assign([], {\n+                    status: 0\n+                });\n+                const obj = {\n+                    [turbopackExports]: {},\n+                    [turbopackQueues]: (fn)=>fn(queue)\n+                };\n+                dep.then((res)=>{\n+                    obj[turbopackExports] = res;\n+                    resolveQueue(queue);\n+                }, (err)=>{\n+                    obj[turbopackError] = err;\n+                    resolveQueue(queue);\n+                });\n+                return obj;\n+            }\n+        }\n+        return {\n+            [turbopackExports]: dep,\n+            [turbopackQueues]: ()=>{}\n+        };\n+    });\n+}\n+function asyncModule(body, hasAwait) {\n+    const module = this.m;\n+    const queue = hasAwait ? Object.assign([], {\n+        status: -1\n+    }) : undefined;\n+    const depQueues = new Set();\n+    const { resolve, reject, promise: rawPromise } = createPromise();\n+    const promise = Object.assign(rawPromise, {\n+        [turbopackExports]: module.exports,\n+        [turbopackQueues]: (fn)=>{\n+            queue && fn(queue);\n+            depQueues.forEach(fn);\n+            promise['catch'](()=>{});\n+        }\n+    });\n+    const attributes = {\n+        get () {\n+            return promise;\n+        },\n+        set (v) {\n+            // Calling `esmExport` leads to this.\n+            if (v !== promise) {\n+                promise[turbopackExports] = v;\n+            }\n+        }\n+    };\n+    Object.defineProperty(module, 'exports', attributes);\n+    Object.defineProperty(module, 'namespaceObject', attributes);\n+    function handleAsyncDependencies(deps) {\n+        const currentDeps = wrapDeps(deps);\n+        const getResult = ()=>currentDeps.map((d)=>{\n+                if (d[turbopackError]) throw d[turbopackError];\n+                return d[turbopackExports];\n+            });\n+        const { promise, resolve } = createPromise();\n+        const fn = Object.assign(()=>resolve(getResult), {\n+            queueCount: 0\n+        });\n+        function fnQueue(q) {\n+            if (q !== queue && !depQueues.has(q)) {\n+                depQueues.add(q);\n+                if (q && q.status === 0) {\n+                    fn.queueCount++;\n+                    q.push(fn);\n+                }\n+            }\n+        }\n+        currentDeps.map((dep)=>dep[turbopackQueues](fnQueue));\n+        return fn.queueCount ? promise : getResult();\n+    }\n+    function asyncResult(err) {\n+        if (err) {\n+            reject(promise[turbopackError] = err);\n+        } else {\n+            resolve(promise[turbopackExports]);\n+        }\n+        resolveQueue(queue);\n+    }\n+    body(handleAsyncDependencies, asyncResult);\n+    if (queue && queue.status === -1) {\n+        queue.status = 0;\n+    }\n+}\n+contextPrototype.a = asyncModule;\n+/**\n+ * A pseudo \"fake\" URL object to resolve to its relative path.\n+ *\n+ * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\n+ * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\n+ * hydration mismatch.\n+ *\n+ * This is based on webpack's existing implementation:\n+ * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\n+ */ const relativeURL = function relativeURL(inputUrl) {\n+    const realUrl = new URL(inputUrl, 'x:/');\n+    const values = {};\n+    for(const key in realUrl)values[key] = realUrl[key];\n+    values.href = inputUrl;\n+    values.pathname = inputUrl.replace(/[?#].*/, '');\n+    values.origin = values.protocol = '';\n+    values.toString = values.toJSON = (..._args)=>inputUrl;\n+    for(const key in values)Object.defineProperty(this, key, {\n+        enumerable: true,\n+        configurable: true,\n+        value: values[key]\n+    });\n+};\n+relativeURL.prototype = URL.prototype;\n+contextPrototype.U = relativeURL;\n+/**\n+ * Utility function to ensure all variants of an enum are handled.\n+ */ function invariant(never, computeMessage) {\n+    throw new Error(`Invariant: ${computeMessage(never)}`);\n+}\n+/**\n+ * A stub function to make `require` available but non-functional in ESM.\n+ */ function requireStub(_moduleId) {\n+    throw new Error('dynamic usage of require is not supported');\n+}\n+contextPrototype.z = requireStub;\n+// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\n+contextPrototype.g = globalThis;\n+function applyModuleFactoryName(factory) {\n+    // Give the module factory a nice name to improve stack traces.\n+    Object.defineProperty(factory, 'name', {\n+        value: '__TURBOPACK__module__evaluation__'\n+    });\n+}\n+/**\n+ * This file contains runtime types and functions that are shared between all\n+ * Turbopack *development* ECMAScript runtimes.\n+ *\n+ * It will be appended to the runtime code of each runtime right after the\n+ * shared runtime utils.\n+ */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../base/globals.d.ts\" />\n+/// <reference path=\"../../../shared/runtime-utils.ts\" />\n+// Used in WebWorkers to tell the runtime about the chunk base path\n+const browserContextPrototype = Context.prototype;\n+var SourceType = /*#__PURE__*/ function(SourceType) {\n+    /**\n+   * The module was instantiated because it was included in an evaluated chunk's\n+   * runtime.\n+   * SourceData is a ChunkPath.\n+   */ SourceType[SourceType[\"Runtime\"] = 0] = \"Runtime\";\n+    /**\n+   * The module was instantiated because a parent module imported it.\n+   * SourceData is a ModuleId.\n+   */ SourceType[SourceType[\"Parent\"] = 1] = \"Parent\";\n+    /**\n+   * The module was instantiated because it was included in a chunk's hot module\n+   * update.\n+   * SourceData is an array of ModuleIds or undefined.\n+   */ SourceType[SourceType[\"Update\"] = 2] = \"Update\";\n+    return SourceType;\n+}(SourceType || {});\n+const moduleFactories = new Map();\n+contextPrototype.M = moduleFactories;\n+const availableModules = new Map();\n+const availableModuleChunks = new Map();\n+function factoryNotAvailable(moduleId, sourceType, sourceData) {\n+    let instantiationReason;\n+    switch(sourceType){\n+        case 0:\n+            instantiationReason = `as a runtime entry of chunk ${sourceData}`;\n+            break;\n+        case 1:\n+            instantiationReason = `because it was required from module ${sourceData}`;\n+            break;\n+        case 2:\n+            instantiationReason = 'because of an HMR update';\n+            break;\n+        default:\n+            invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);\n+    }\n+    throw new Error(`Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`);\n+}\n+function loadChunk(chunkData) {\n+    return loadChunkInternal(1, this.m.id, chunkData);\n+}\n+browserContextPrototype.l = loadChunk;\n+function loadInitialChunk(chunkPath, chunkData) {\n+    return loadChunkInternal(0, chunkPath, chunkData);\n+}\n+async function loadChunkInternal(sourceType, sourceData, chunkData) {\n+    if (typeof chunkData === 'string') {\n+        return loadChunkPath(sourceType, sourceData, chunkData);\n+    }\n+    const includedList = chunkData.included || [];\n+    const modulesPromises = includedList.map((included)=>{\n+        if (moduleFactories.has(included)) return true;\n+        return availableModules.get(included);\n+    });\n+    if (modulesPromises.length > 0 && modulesPromises.every((p)=>p)) {\n+        // When all included items are already loaded or loading, we can skip loading ourselves\n+        await Promise.all(modulesPromises);\n+        return;\n+    }\n+    const includedModuleChunksList = chunkData.moduleChunks || [];\n+    const moduleChunksPromises = includedModuleChunksList.map((included)=>{\n+        // TODO(alexkirsz) Do we need this check?\n+        // if (moduleFactories[included]) return true;\n+        return availableModuleChunks.get(included);\n+    }).filter((p)=>p);\n+    let promise;\n+    if (moduleChunksPromises.length > 0) {\n+        // Some module chunks are already loaded or loading.\n+        if (moduleChunksPromises.length === includedModuleChunksList.length) {\n+            // When all included module chunks are already loaded or loading, we can skip loading ourselves\n+            await Promise.all(moduleChunksPromises);\n+            return;\n+        }\n+        const moduleChunksToLoad = new Set();\n+        for (const moduleChunk of includedModuleChunksList){\n+            if (!availableModuleChunks.has(moduleChunk)) {\n+                moduleChunksToLoad.add(moduleChunk);\n+            }\n+        }\n+        for (const moduleChunkToLoad of moduleChunksToLoad){\n+            const promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad);\n+            availableModuleChunks.set(moduleChunkToLoad, promise);\n+            moduleChunksPromises.push(promise);\n+        }\n+        promise = Promise.all(moduleChunksPromises);\n+    } else {\n+        promise = loadChunkPath(sourceType, sourceData, chunkData.path);\n+        // Mark all included module chunks as loading if they are not already loaded or loading.\n+        for (const includedModuleChunk of includedModuleChunksList){\n+            if (!availableModuleChunks.has(includedModuleChunk)) {\n+                availableModuleChunks.set(includedModuleChunk, promise);\n+            }\n+        }\n+    }\n+    for (const included of includedList){\n+        if (!availableModules.has(included)) {\n+            // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\n+            // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\n+            availableModules.set(included, promise);\n+        }\n+    }\n+    await promise;\n+}\n+const loadedChunk = Promise.resolve(undefined);\n+const instrumentedBackendLoadChunks = new WeakMap();\n+// Do not make this async. React relies on referential equality of the returned Promise.\n+function loadChunkByUrl(chunkUrl) {\n+    return loadChunkByUrlInternal(1, this.m.id, chunkUrl);\n+}\n+browserContextPrototype.L = loadChunkByUrl;\n+// Do not make this async. React relies on referential equality of the returned Promise.\n+function loadChunkByUrlInternal(sourceType, sourceData, chunkUrl) {\n+    const thenable = BACKEND.loadChunkCached(sourceType, chunkUrl);\n+    let entry = instrumentedBackendLoadChunks.get(thenable);\n+    if (entry === undefined) {\n+        const resolve = instrumentedBackendLoadChunks.set.bind(instrumentedBackendLoadChunks, thenable, loadedChunk);\n+        entry = thenable.then(resolve).catch((error)=>{\n+            let loadReason;\n+            switch(sourceType){\n+                case 0:\n+                    loadReason = `as a runtime dependency of chunk ${sourceData}`;\n+                    break;\n+                case 1:\n+                    loadReason = `from module ${sourceData}`;\n+                    break;\n+                case 2:\n+                    loadReason = 'from an HMR update';\n+                    break;\n+                default:\n+                    invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);\n+            }\n+            throw new Error(`Failed to load chunk ${chunkUrl} ${loadReason}${error ? `: ${error}` : ''}`, error ? {\n+                cause: error\n+            } : undefined);\n+        });\n+        instrumentedBackendLoadChunks.set(thenable, entry);\n+    }\n+    return entry;\n+}\n+// Do not make this async. React relies on referential equality of the returned Promise.\n+function loadChunkPath(sourceType, sourceData, chunkPath) {\n+    const url = getChunkRelativeUrl(chunkPath);\n+    return loadChunkByUrlInternal(sourceType, sourceData, url);\n+}\n+/**\n+ * Returns an absolute url to an asset.\n+ */ function resolvePathFromModule(moduleId) {\n+    const exported = this.r(moduleId);\n+    return exported?.default ?? exported;\n+}\n+browserContextPrototype.R = resolvePathFromModule;\n+/**\n+ * no-op for browser\n+ * @param modulePath\n+ */ function resolveAbsolutePath(modulePath) {\n+    return `/ROOT/${modulePath ?? ''}`;\n+}\n+browserContextPrototype.P = resolveAbsolutePath;\n+/**\n+ * Returns a blob URL for the worker.\n+ * @param chunks list of chunks to load\n+ */ function getWorkerBlobURL(chunks) {\n+    // It is important to reverse the array so when bootstrapping we can infer what chunk is being\n+    // evaluated by poping urls off of this array.  See `getPathFromScript`\n+    let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};\n+self.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};\n+importScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_LOCATION + c).reverse());`;\n+    let blob = new Blob([\n+        bootstrap\n+    ], {\n+        type: 'text/javascript'\n+    });\n+    return URL.createObjectURL(blob);\n+}\n+browserContextPrototype.b = getWorkerBlobURL;\n+/**\n+ * Instantiates a runtime module.\n+ */ function instantiateRuntimeModule(moduleId, chunkPath) {\n+    return instantiateModule(moduleId, 0, chunkPath);\n+}\n+/**\n+ * Returns the URL relative to the origin where a chunk can be fetched from.\n+ */ function getChunkRelativeUrl(chunkPath) {\n+    return `${CHUNK_BASE_PATH}${chunkPath.split('/').map((p)=>encodeURIComponent(p)).join('/')}${CHUNK_SUFFIX_PATH}`;\n+}\n+function getPathFromScript(chunkScript) {\n+    if (typeof chunkScript === 'string') {\n+        return chunkScript;\n+    }\n+    const chunkUrl = typeof TURBOPACK_NEXT_CHUNK_URLS !== 'undefined' ? TURBOPACK_NEXT_CHUNK_URLS.pop() : chunkScript.getAttribute('src');\n+    const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, ''));\n+    const path = src.startsWith(CHUNK_BASE_PATH) ? src.slice(CHUNK_BASE_PATH.length) : src;\n+    return path;\n+}\n+const regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n+/**\n+ * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n+ */ function isJs(chunkUrlOrPath) {\n+    return regexJsUrl.test(chunkUrlOrPath);\n+}\n+const regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/;\n+/**\n+ * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\n+ */ function isCss(chunkUrl) {\n+    return regexCssUrl.test(chunkUrl);\n+}\n+function loadWebAssembly(chunkPath, edgeModule, importsObj) {\n+    return BACKEND.loadWebAssembly(1, this.m.id, chunkPath, edgeModule, importsObj);\n+}\n+contextPrototype.w = loadWebAssembly;\n+function loadWebAssemblyModule(chunkPath, edgeModule) {\n+    return BACKEND.loadWebAssemblyModule(1, this.m.id, chunkPath, edgeModule);\n+}\n+contextPrototype.u = loadWebAssemblyModule;\n+/// <reference path=\"./dev-globals.d.ts\" />\n+/// <reference path=\"./dev-protocol.d.ts\" />\n+/// <reference path=\"./dev-extensions.ts\" />\n+const devContextPrototype = Context.prototype;\n+/**\n+ * This file contains runtime types and functions that are shared between all\n+ * Turbopack *development* ECMAScript runtimes.\n+ *\n+ * It will be appended to the runtime code of each runtime right after the\n+ * shared runtime utils.\n+ */ /* eslint-disable @typescript-eslint/no-unused-vars */ const devModuleCache = Object.create(null);\n+devContextPrototype.c = devModuleCache;\n+class UpdateApplyError extends Error {\n+    name = 'UpdateApplyError';\n+    dependencyChain;\n+    constructor(message, dependencyChain){\n+        super(message);\n+        this.dependencyChain = dependencyChain;\n+    }\n+}\n+/**\n+ * Module IDs that are instantiated as part of the runtime of a chunk.\n+ */ const runtimeModules = new Set();\n+/**\n+ * Map from module ID to the chunks that contain this module.\n+ *\n+ * In HMR, we need to keep track of which modules are contained in which so\n+ * chunks. This is so we don't eagerly dispose of a module when it is removed\n+ * from chunk A, but still exists in chunk B.\n+ */ const moduleChunksMap = new Map();\n+/**\n+ * Map from a chunk path to all modules it contains.\n+ */ const chunkModulesMap = new Map();\n+/**\n+ * Chunk lists that contain a runtime. When these chunk lists receive an update\n+ * that can't be reconciled with the current state of the page, we need to\n+ * reload the runtime entirely.\n+ */ const runtimeChunkLists = new Set();\n+/**\n+ * Map from a chunk list to the chunk paths it contains.\n+ */ const chunkListChunksMap = new Map();\n+/**\n+ * Map from a chunk path to the chunk lists it belongs to.\n+ */ const chunkChunkListsMap = new Map();\n+/**\n+ * Maps module IDs to persisted data between executions of their hot module\n+ * implementation (`hot.data`).\n+ */ const moduleHotData = new Map();\n+/**\n+ * Maps module instances to their hot module state.\n+ */ const moduleHotState = new Map();\n+/**\n+ * Modules that call `module.hot.invalidate()` (while being updated).\n+ */ const queuedInvalidatedModules = new Set();\n+/**\n+ * Gets or instantiates a runtime module.\n+ */ // @ts-ignore\n+function getOrInstantiateRuntimeModule(chunkPath, moduleId) {\n+    const module = devModuleCache[moduleId];\n+    if (module) {\n+        if (module.error) {\n+            throw module.error;\n+        }\n+        return module;\n+    }\n+    // @ts-ignore\n+    return instantiateModule(moduleId, SourceType.Runtime, chunkPath);\n+}\n+/**\n+ * Retrieves a module from the cache, or instantiate it if it is not cached.\n+ */ // @ts-ignore Defined in `runtime-utils.ts`\n+const getOrInstantiateModuleFromParent = (id, sourceModule)=>{\n+    if (!sourceModule.hot.active) {\n+        console.warn(`Unexpected import of module ${id} from module ${sourceModule.id}, which was deleted by an HMR update`);\n+    }\n+    const module = devModuleCache[id];\n+    if (sourceModule.children.indexOf(id) === -1) {\n+        sourceModule.children.push(id);\n+    }\n+    if (module) {\n+        if (module.error) {\n+            throw module.error;\n+        }\n+        if (module.parents.indexOf(sourceModule.id) === -1) {\n+            module.parents.push(sourceModule.id);\n+        }\n+        return module;\n+    }\n+    return instantiateModule(id, SourceType.Parent, sourceModule.id);\n+};\n+function DevContext(module, exports, refresh) {\n+    Context.call(this, module, exports);\n+    this.k = refresh;\n+}\n+DevContext.prototype = Context.prototype;\n+function instantiateModule(moduleId, sourceType, sourceData) {\n+    // We are in development, this is always a string.\n+    let id = moduleId;\n+    const moduleFactory = moduleFactories.get(id);\n+    if (typeof moduleFactory !== 'function') {\n+        // This can happen if modules incorrectly handle HMR disposes/updates,\n+        // e.g. when they keep a `setTimeout` around which still executes old code\n+        // and contains e.g. a `require(\"something\")` call.\n+        factoryNotAvailable(id, sourceType, sourceData);\n+    }\n+    const hotData = moduleHotData.get(id);\n+    const { hot, hotState } = createModuleHot(id, hotData);\n+    let parents;\n+    switch(sourceType){\n+        case SourceType.Runtime:\n+            runtimeModules.add(id);\n+            parents = [];\n+            break;\n+        case SourceType.Parent:\n+            // No need to add this module as a child of the parent module here, this\n+            // has already been taken care of in `getOrInstantiateModuleFromParent`.\n+            parents = [\n+                sourceData\n+            ];\n+            break;\n+        case SourceType.Update:\n+            parents = sourceData || [];\n+            break;\n+        default:\n+            invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);\n+    }\n+    const module = createModuleObject(id);\n+    const exports = module.exports;\n+    module.parents = parents;\n+    module.children = [];\n+    module.hot = hot;\n+    devModuleCache[id] = module;\n+    moduleHotState.set(module, hotState);\n+    // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n+    try {\n+        runModuleExecutionHooks(module, (refresh)=>{\n+            const context = new DevContext(module, exports, refresh);\n+            moduleFactory(context, module, exports);\n+        });\n+    } catch (error) {\n+        module.error = error;\n+        throw error;\n+    }\n+    if (module.namespaceObject && module.exports !== module.namespaceObject) {\n+        // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n+        interopEsm(module.exports, module.namespaceObject);\n+    }\n+    return module;\n+}\n+const DUMMY_REFRESH_CONTEXT = {\n+    register: (_type, _id)=>{},\n+    signature: ()=>(_type)=>{},\n+    registerExports: (_module, _helpers)=>{}\n+};\n+/**\n+ * NOTE(alexkirsz) Webpack has a \"module execution\" interception hook that\n+ * Next.js' React Refresh runtime hooks into to add module context to the\n+ * refresh registry.\n+ */ function runModuleExecutionHooks(module, executeModule) {\n+    if (typeof globalThis.$RefreshInterceptModuleExecution$ === 'function') {\n+        const cleanupReactRefreshIntercept = globalThis.$RefreshInterceptModuleExecution$(module.id);\n+        try {\n+            executeModule({\n+                register: globalThis.$RefreshReg$,\n+                signature: globalThis.$RefreshSig$,\n+                registerExports: registerExportsAndSetupBoundaryForReactRefresh\n+            });\n+        } finally{\n+            // Always cleanup the intercept, even if module execution failed.\n+            cleanupReactRefreshIntercept();\n+        }\n+    } else {\n+        // If the react refresh hooks are not installed we need to bind dummy functions.\n+        // This is expected when running in a Web Worker.  It is also common in some of\n+        // our test environments.\n+        executeModule(DUMMY_REFRESH_CONTEXT);\n+    }\n+}\n+/**\n+ * This is adapted from https://github.com/vercel/next.js/blob/3466862d9dc9c8bb3131712134d38757b918d1c0/packages/react-refresh-utils/internal/ReactRefreshModule.runtime.ts\n+ */ function registerExportsAndSetupBoundaryForReactRefresh(module, helpers) {\n+    const currentExports = module.exports;\n+    const prevExports = module.hot.data.prevExports ?? null;\n+    helpers.registerExportsForReactRefresh(currentExports, module.id);\n+    // A module can be accepted automatically based on its exports, e.g. when\n+    // it is a Refresh Boundary.\n+    if (helpers.isReactRefreshBoundary(currentExports)) {\n+        // Save the previous exports on update, so we can compare the boundary\n+        // signatures.\n+        module.hot.dispose((data)=>{\n+            data.prevExports = currentExports;\n+        });\n+        // Unconditionally accept an update to this module, we'll check if it's\n+        // still a Refresh Boundary later.\n+        module.hot.accept();\n+        // This field is set when the previous version of this module was a\n+        // Refresh Boundary, letting us know we need to check for invalidation or\n+        // enqueue an update.\n+        if (prevExports !== null) {\n+            // A boundary can become ineligible if its exports are incompatible\n+            // with the previous exports.\n+            //\n+            // For example, if you add/remove/change exports, we'll want to\n+            // re-execute the importing modules, and force those components to\n+            // re-render. Similarly, if you convert a class component to a\n+            // function, we want to invalidate the boundary.\n+            if (helpers.shouldInvalidateReactRefreshBoundary(helpers.getRefreshBoundarySignature(prevExports), helpers.getRefreshBoundarySignature(currentExports))) {\n+                module.hot.invalidate();\n+            } else {\n+                helpers.scheduleUpdate();\n+            }\n+        }\n+    } else {\n+        // Since we just executed the code for the module, it's possible that the\n+        // new exports made it ineligible for being a boundary.\n+        // We only care about the case when we were _previously_ a boundary,\n+        // because we already accepted this update (accidental side effect).\n+        const isNoLongerABoundary = prevExports !== null;\n+        if (isNoLongerABoundary) {\n+            module.hot.invalidate();\n+        }\n+    }\n+}\n+function formatDependencyChain(dependencyChain) {\n+    return `Dependency chain: ${dependencyChain.join(' -> ')}`;\n+}\n+function computeOutdatedModules(added, modified) {\n+    const newModuleFactories = new Map();\n+    for (const [moduleId, entry] of added){\n+        if (entry != null) {\n+            newModuleFactories.set(moduleId, _eval(entry));\n+        }\n+    }\n+    const outdatedModules = computedInvalidatedModules(modified.keys());\n+    for (const [moduleId, entry] of modified){\n+        newModuleFactories.set(moduleId, _eval(entry));\n+    }\n+    return {\n+        outdatedModules,\n+        newModuleFactories\n+    };\n+}\n+function computedInvalidatedModules(invalidated) {\n+    const outdatedModules = new Set();\n+    for (const moduleId of invalidated){\n+        const effect = getAffectedModuleEffects(moduleId);\n+        switch(effect.type){\n+            case 'unaccepted':\n+                throw new UpdateApplyError(`cannot apply update: unaccepted module. ${formatDependencyChain(effect.dependencyChain)}.`, effect.dependencyChain);\n+            case 'self-declined':\n+                throw new UpdateApplyError(`cannot apply update: self-declined module. ${formatDependencyChain(effect.dependencyChain)}.`, effect.dependencyChain);\n+            case 'accepted':\n+                for (const outdatedModuleId of effect.outdatedModules){\n+                    outdatedModules.add(outdatedModuleId);\n+                }\n+                break;\n+            // TODO(alexkirsz) Dependencies: handle dependencies effects.\n+            default:\n+                invariant(effect, (effect)=>`Unknown effect type: ${effect?.type}`);\n+        }\n+    }\n+    return outdatedModules;\n+}\n+function computeOutdatedSelfAcceptedModules(outdatedModules) {\n+    const outdatedSelfAcceptedModules = [];\n+    for (const moduleId of outdatedModules){\n+        const module = devModuleCache[moduleId];\n+        const hotState = moduleHotState.get(module);\n+        if (module && hotState.selfAccepted && !hotState.selfInvalidated) {\n+            outdatedSelfAcceptedModules.push({\n+                moduleId,\n+                errorHandler: hotState.selfAccepted\n+            });\n+        }\n+    }\n+    return outdatedSelfAcceptedModules;\n+}\n+/**\n+ * Adds, deletes, and moves modules between chunks. This must happen before the\n+ * dispose phase as it needs to know which modules were removed from all chunks,\n+ * which we can only compute *after* taking care of added and moved modules.\n+ */ function updateChunksPhase(chunksAddedModules, chunksDeletedModules) {\n+    for (const [chunkPath, addedModuleIds] of chunksAddedModules){\n+        for (const moduleId of addedModuleIds){\n+            addModuleToChunk(moduleId, chunkPath);\n+        }\n+    }\n+    const disposedModules = new Set();\n+    for (const [chunkPath, addedModuleIds] of chunksDeletedModules){\n+        for (const moduleId of addedModuleIds){\n+            if (removeModuleFromChunk(moduleId, chunkPath)) {\n+                disposedModules.add(moduleId);\n+            }\n+        }\n+    }\n+    return {\n+        disposedModules\n+    };\n+}\n+function disposePhase(outdatedModules, disposedModules) {\n+    for (const moduleId of outdatedModules){\n+        disposeModule(moduleId, 'replace');\n+    }\n+    for (const moduleId of disposedModules){\n+        disposeModule(moduleId, 'clear');\n+    }\n+    // Removing modules from the module cache is a separate step.\n+    // We also want to keep track of previous parents of the outdated modules.\n+    const outdatedModuleParents = new Map();\n+    for (const moduleId of outdatedModules){\n+        const oldModule = devModuleCache[moduleId];\n+        outdatedModuleParents.set(moduleId, oldModule?.parents);\n+        delete devModuleCache[moduleId];\n+    }\n+    // TODO(alexkirsz) Dependencies: remove outdated dependency from module\n+    // children.\n+    return {\n+        outdatedModuleParents\n+    };\n+}\n+/**\n+ * Disposes of an instance of a module.\n+ *\n+ * Returns the persistent hot data that should be kept for the next module\n+ * instance.\n+ *\n+ * NOTE: mode = \"replace\" will not remove modules from the devModuleCache\n+ * This must be done in a separate step afterwards.\n+ * This is important because all modules need to be disposed to update the\n+ * parent/child relationships before they are actually removed from the devModuleCache.\n+ * If this was done in this method, the following disposeModule calls won't find\n+ * the module from the module id in the cache.\n+ */ function disposeModule(moduleId, mode) {\n+    const module = devModuleCache[moduleId];\n+    if (!module) {\n+        return;\n+    }\n+    const hotState = moduleHotState.get(module);\n+    const data = {};\n+    // Run the `hot.dispose` handler, if any, passing in the persistent\n+    // `hot.data` object.\n+    for (const disposeHandler of hotState.disposeHandlers){\n+        disposeHandler(data);\n+    }\n+    // This used to warn in `getOrInstantiateModuleFromParent` when a disposed\n+    // module is still importing other modules.\n+    module.hot.active = false;\n+    moduleHotState.delete(module);\n+    // TODO(alexkirsz) Dependencies: delete the module from outdated deps.\n+    // Remove the disposed module from its children's parent list.\n+    // It will be added back once the module re-instantiates and imports its\n+    // children again.\n+    for (const childId of module.children){\n+        const child = devModuleCache[childId];\n+        if (!child) {\n+            continue;\n+        }\n+        const idx = child.parents.indexOf(module.id);\n+        if (idx >= 0) {\n+            child.parents.splice(idx, 1);\n+        }\n+    }\n+    switch(mode){\n+        case 'clear':\n+            delete devModuleCache[module.id];\n+            moduleHotData.delete(module.id);\n+            break;\n+        case 'replace':\n+            moduleHotData.set(module.id, data);\n+            break;\n+        default:\n+            invariant(mode, (mode)=>`invalid mode: ${mode}`);\n+    }\n+}\n+function applyPhase(outdatedSelfAcceptedModules, newModuleFactories, outdatedModuleParents, reportError) {\n+    // Update module factories.\n+    for (const [moduleId, factory] of newModuleFactories.entries()){\n+        applyModuleFactoryName(factory);\n+        moduleFactories.set(moduleId, factory);\n+    }\n+    // TODO(alexkirsz) Run new runtime entries here.\n+    // TODO(alexkirsz) Dependencies: call accept handlers for outdated deps.\n+    // Re-instantiate all outdated self-accepted modules.\n+    for (const { moduleId, errorHandler } of outdatedSelfAcceptedModules){\n+        try {\n+            instantiateModule(moduleId, SourceType.Update, outdatedModuleParents.get(moduleId));\n+        } catch (err) {\n+            if (typeof errorHandler === 'function') {\n+                try {\n+                    errorHandler(err, {\n+                        moduleId,\n+                        module: devModuleCache[moduleId]\n+                    });\n+                } catch (err2) {\n+                    reportError(err2);\n+                    reportError(err);\n+                }\n+            } else {\n+                reportError(err);\n+            }\n+        }\n+    }\n+}\n+function applyUpdate(update) {\n+    switch(update.type){\n+        case 'ChunkListUpdate':\n+            applyChunkListUpdate(update);\n+            break;\n+        default:\n+            invariant(update, (update)=>`Unknown update type: ${update.type}`);\n+    }\n+}\n+function applyChunkListUpdate(update) {\n+    if (update.merged != null) {\n+        for (const merged of update.merged){\n+            switch(merged.type){\n+                case 'EcmascriptMergedUpdate':\n+                    applyEcmascriptMergedUpdate(merged);\n+                    break;\n+                default:\n+                    invariant(merged, (merged)=>`Unknown merged type: ${merged.type}`);\n+            }\n+        }\n+    }\n+    if (update.chunks != null) {\n+        for (const [chunkPath, chunkUpdate] of Object.entries(update.chunks)){\n+            const chunkUrl = getChunkRelativeUrl(chunkPath);\n+            switch(chunkUpdate.type){\n+                case 'added':\n+                    BACKEND.loadChunkCached(SourceType.Update, chunkUrl);\n+                    break;\n+                case 'total':\n+                    DEV_BACKEND.reloadChunk?.(chunkUrl);\n+                    break;\n+                case 'deleted':\n+                    DEV_BACKEND.unloadChunk?.(chunkUrl);\n+                    break;\n+                case 'partial':\n+                    invariant(chunkUpdate.instruction, (instruction)=>`Unknown partial instruction: ${JSON.stringify(instruction)}.`);\n+                    break;\n+                default:\n+                    invariant(chunkUpdate, (chunkUpdate)=>`Unknown chunk update type: ${chunkUpdate.type}`);\n+            }\n+        }\n+    }\n+}\n+function applyEcmascriptMergedUpdate(update) {\n+    const { entries = {}, chunks = {} } = update;\n+    const { added, modified, chunksAdded, chunksDeleted } = computeChangedModules(entries, chunks);\n+    const { outdatedModules, newModuleFactories } = computeOutdatedModules(added, modified);\n+    const { disposedModules } = updateChunksPhase(chunksAdded, chunksDeleted);\n+    applyInternal(outdatedModules, disposedModules, newModuleFactories);\n+}\n+function applyInvalidatedModules(outdatedModules) {\n+    if (queuedInvalidatedModules.size > 0) {\n+        computedInvalidatedModules(queuedInvalidatedModules).forEach((moduleId)=>{\n+            outdatedModules.add(moduleId);\n+        });\n+        queuedInvalidatedModules.clear();\n+    }\n+    return outdatedModules;\n+}\n+function applyInternal(outdatedModules, disposedModules, newModuleFactories) {\n+    outdatedModules = applyInvalidatedModules(outdatedModules);\n+    const outdatedSelfAcceptedModules = computeOutdatedSelfAcceptedModules(outdatedModules);\n+    const { outdatedModuleParents } = disposePhase(outdatedModules, disposedModules);\n+    // we want to continue on error and only throw the error after we tried applying all updates\n+    let error;\n+    function reportError(err) {\n+        if (!error) error = err;\n+    }\n+    applyPhase(outdatedSelfAcceptedModules, newModuleFactories, outdatedModuleParents, reportError);\n+    if (error) {\n+        throw error;\n+    }\n+    if (queuedInvalidatedModules.size > 0) {\n+        applyInternal(new Set(), [], new Map());\n+    }\n+}\n+function computeChangedModules(entries, updates) {\n+    const chunksAdded = new Map();\n+    const chunksDeleted = new Map();\n+    const added = new Map();\n+    const modified = new Map();\n+    const deleted = new Set();\n+    for (const [chunkPath, mergedChunkUpdate] of Object.entries(updates)){\n+        switch(mergedChunkUpdate.type){\n+            case 'added':\n+                {\n+                    const updateAdded = new Set(mergedChunkUpdate.modules);\n+                    for (const moduleId of updateAdded){\n+                        added.set(moduleId, entries[moduleId]);\n+                    }\n+                    chunksAdded.set(chunkPath, updateAdded);\n+                    break;\n+                }\n+            case 'deleted':\n+                {\n+                    // We could also use `mergedChunkUpdate.modules` here.\n+                    const updateDeleted = new Set(chunkModulesMap.get(chunkPath));\n+                    for (const moduleId of updateDeleted){\n+                        deleted.add(moduleId);\n+                    }\n+                    chunksDeleted.set(chunkPath, updateDeleted);\n+                    break;\n+                }\n+            case 'partial':\n+                {\n+                    const updateAdded = new Set(mergedChunkUpdate.added);\n+                    const updateDeleted = new Set(mergedChunkUpdate.deleted);\n+                    for (const moduleId of updateAdded){\n+                        added.set(moduleId, entries[moduleId]);\n+                    }\n+                    for (const moduleId of updateDeleted){\n+                        deleted.add(moduleId);\n+                    }\n+                    chunksAdded.set(chunkPath, updateAdded);\n+                    chunksDeleted.set(chunkPath, updateDeleted);\n+                    break;\n+                }\n+            default:\n+                invariant(mergedChunkUpdate, (mergedChunkUpdate)=>`Unknown merged chunk update type: ${mergedChunkUpdate.type}`);\n+        }\n+    }\n+    // If a module was added from one chunk and deleted from another in the same update,\n+    // consider it to be modified, as it means the module was moved from one chunk to another\n+    // AND has new code in a single update.\n+    for (const moduleId of added.keys()){\n+        if (deleted.has(moduleId)) {\n+            added.delete(moduleId);\n+            deleted.delete(moduleId);\n+        }\n+    }\n+    for (const [moduleId, entry] of Object.entries(entries)){\n+        // Modules that haven't been added to any chunk but have new code are considered\n+        // to be modified.\n+        // This needs to be under the previous loop, as we need it to get rid of modules\n+        // that were added and deleted in the same update.\n+        if (!added.has(moduleId)) {\n+            modified.set(moduleId, entry);\n+        }\n+    }\n+    return {\n+        added,\n+        deleted,\n+        modified,\n+        chunksAdded,\n+        chunksDeleted\n+    };\n+}\n+function getAffectedModuleEffects(moduleId) {\n+    const outdatedModules = new Set();\n+    const queue = [\n+        {\n+            moduleId,\n+            dependencyChain: []\n+        }\n+    ];\n+    let nextItem;\n+    while(nextItem = queue.shift()){\n+        const { moduleId, dependencyChain } = nextItem;\n+        if (moduleId != null) {\n+            if (outdatedModules.has(moduleId)) {\n+                continue;\n+            }\n+            outdatedModules.add(moduleId);\n+        }\n+        // We've arrived at the runtime of the chunk, which means that nothing\n+        // else above can accept this update.\n+        if (moduleId === undefined) {\n+            return {\n+                type: 'unaccepted',\n+                dependencyChain\n+            };\n+        }\n+        const module = devModuleCache[moduleId];\n+        const hotState = moduleHotState.get(module);\n+        if (// The module is not in the cache. Since this is a \"modified\" update,\n+        // it means that the module was never instantiated before.\n+        !module || hotState.selfAccepted && !hotState.selfInvalidated) {\n+            continue;\n+        }\n+        if (hotState.selfDeclined) {\n+            return {\n+                type: 'self-declined',\n+                dependencyChain,\n+                moduleId\n+            };\n+        }\n+        if (runtimeModules.has(moduleId)) {\n+            queue.push({\n+                moduleId: undefined,\n+                dependencyChain: [\n+                    ...dependencyChain,\n+                    moduleId\n+                ]\n+            });\n+            continue;\n+        }\n+        for (const parentId of module.parents){\n+            const parent = devModuleCache[parentId];\n+            if (!parent) {\n+                continue;\n+            }\n+            // TODO(alexkirsz) Dependencies: check accepted and declined\n+            // dependencies here.\n+            queue.push({\n+                moduleId: parentId,\n+                dependencyChain: [\n+                    ...dependencyChain,\n+                    moduleId\n+                ]\n+            });\n+        }\n+    }\n+    return {\n+        type: 'accepted',\n+        moduleId,\n+        outdatedModules\n+    };\n+}\n+function handleApply(chunkListPath, update) {\n+    switch(update.type){\n+        case 'partial':\n+            {\n+                // This indicates that the update is can be applied to the current state of the application.\n+                applyUpdate(update.instruction);\n+                break;\n+            }\n+        case 'restart':\n+            {\n+                // This indicates that there is no way to apply the update to the\n+                // current state of the application, and that the application must be\n+                // restarted.\n+                DEV_BACKEND.restart();\n+                break;\n+            }\n+        case 'notFound':\n+            {\n+                // This indicates that the chunk list no longer exists: either the dynamic import which created it was removed,\n+                // or the page itself was deleted.\n+                // If it is a dynamic import, we simply discard all modules that the chunk has exclusive access to.\n+                // If it is a runtime chunk list, we restart the application.\n+                if (runtimeChunkLists.has(chunkListPath)) {\n+                    DEV_BACKEND.restart();\n+                } else {\n+                    disposeChunkList(chunkListPath);\n+                }\n+                break;\n+            }\n+        default:\n+            throw new Error(`Unknown update type: ${update.type}`);\n+    }\n+}\n+function createModuleHot(moduleId, hotData) {\n+    const hotState = {\n+        selfAccepted: false,\n+        selfDeclined: false,\n+        selfInvalidated: false,\n+        disposeHandlers: []\n+    };\n+    const hot = {\n+        // TODO(alexkirsz) This is not defined in the HMR API. It was used to\n+        // decide whether to warn whenever an HMR-disposed module required other\n+        // modules. We might want to remove it.\n+        active: true,\n+        data: hotData ?? {},\n+        // TODO(alexkirsz) Support full (dep, callback, errorHandler) form.\n+        accept: (modules, _callback, _errorHandler)=>{\n+            if (modules === undefined) {\n+                hotState.selfAccepted = true;\n+            } else if (typeof modules === 'function') {\n+                hotState.selfAccepted = modules;\n+            } else {\n+                throw new Error('unsupported `accept` signature');\n+            }\n+        },\n+        decline: (dep)=>{\n+            if (dep === undefined) {\n+                hotState.selfDeclined = true;\n+            } else {\n+                throw new Error('unsupported `decline` signature');\n+            }\n+        },\n+        dispose: (callback)=>{\n+            hotState.disposeHandlers.push(callback);\n+        },\n+        addDisposeHandler: (callback)=>{\n+            hotState.disposeHandlers.push(callback);\n+        },\n+        removeDisposeHandler: (callback)=>{\n+            const idx = hotState.disposeHandlers.indexOf(callback);\n+            if (idx >= 0) {\n+                hotState.disposeHandlers.splice(idx, 1);\n+            }\n+        },\n+        invalidate: ()=>{\n+            hotState.selfInvalidated = true;\n+            queuedInvalidatedModules.add(moduleId);\n+        },\n+        // NOTE(alexkirsz) This is part of the management API, which we don't\n+        // implement, but the Next.js React Refresh runtime uses this to decide\n+        // whether to schedule an update.\n+        status: ()=>'idle',\n+        // NOTE(alexkirsz) Since we always return \"idle\" for now, these are no-ops.\n+        addStatusHandler: (_handler)=>{},\n+        removeStatusHandler: (_handler)=>{},\n+        // NOTE(jridgewell) Check returns the list of updated modules, but we don't\n+        // want the webpack code paths to ever update (the turbopack paths handle\n+        // this already).\n+        check: ()=>Promise.resolve(null)\n+    };\n+    return {\n+        hot,\n+        hotState\n+    };\n+}\n+/**\n+ * Removes a module from a chunk.\n+ * Returns `true` if there are no remaining chunks including this module.\n+ */ function removeModuleFromChunk(moduleId, chunkPath) {\n+    const moduleChunks = moduleChunksMap.get(moduleId);\n+    moduleChunks.delete(chunkPath);\n+    const chunkModules = chunkModulesMap.get(chunkPath);\n+    chunkModules.delete(moduleId);\n+    const noRemainingModules = chunkModules.size === 0;\n+    if (noRemainingModules) {\n+        chunkModulesMap.delete(chunkPath);\n+    }\n+    const noRemainingChunks = moduleChunks.size === 0;\n+    if (noRemainingChunks) {\n+        moduleChunksMap.delete(moduleId);\n+    }\n+    return noRemainingChunks;\n+}\n+/**\n+ * Disposes of a chunk list and its corresponding exclusive chunks.\n+ */ function disposeChunkList(chunkListPath) {\n+    const chunkPaths = chunkListChunksMap.get(chunkListPath);\n+    if (chunkPaths == null) {\n+        return false;\n+    }\n+    chunkListChunksMap.delete(chunkListPath);\n+    for (const chunkPath of chunkPaths){\n+        const chunkChunkLists = chunkChunkListsMap.get(chunkPath);\n+        chunkChunkLists.delete(chunkListPath);\n+        if (chunkChunkLists.size === 0) {\n+            chunkChunkListsMap.delete(chunkPath);\n+            disposeChunk(chunkPath);\n+        }\n+    }\n+    // We must also dispose of the chunk list's chunk itself to ensure it may\n+    // be reloaded properly in the future.\n+    const chunkListUrl = getChunkRelativeUrl(chunkListPath);\n+    DEV_BACKEND.unloadChunk?.(chunkListUrl);\n+    return true;\n+}\n+/**\n+ * Disposes of a chunk and its corresponding exclusive modules.\n+ *\n+ * @returns Whether the chunk was disposed of.\n+ */ function disposeChunk(chunkPath) {\n+    const chunkUrl = getChunkRelativeUrl(chunkPath);\n+    // This should happen whether the chunk has any modules in it or not.\n+    // For instance, CSS chunks have no modules in them, but they still need to be unloaded.\n+    DEV_BACKEND.unloadChunk?.(chunkUrl);\n+    const chunkModules = chunkModulesMap.get(chunkPath);\n+    if (chunkModules == null) {\n+        return false;\n+    }\n+    chunkModules.delete(chunkPath);\n+    for (const moduleId of chunkModules){\n+        const moduleChunks = moduleChunksMap.get(moduleId);\n+        moduleChunks.delete(chunkPath);\n+        const noRemainingChunks = moduleChunks.size === 0;\n+        if (noRemainingChunks) {\n+            moduleChunksMap.delete(moduleId);\n+            disposeModule(moduleId, 'clear');\n+            availableModules.delete(moduleId);\n+        }\n+    }\n+    return true;\n+}\n+/**\n+ * Adds a module to a chunk.\n+ */ function addModuleToChunk(moduleId, chunkPath) {\n+    let moduleChunks = moduleChunksMap.get(moduleId);\n+    if (!moduleChunks) {\n+        moduleChunks = new Set([\n+            chunkPath\n+        ]);\n+        moduleChunksMap.set(moduleId, moduleChunks);\n+    } else {\n+        moduleChunks.add(chunkPath);\n+    }\n+    let chunkModules = chunkModulesMap.get(chunkPath);\n+    if (!chunkModules) {\n+        chunkModules = new Set([\n+            moduleId\n+        ]);\n+        chunkModulesMap.set(chunkPath, chunkModules);\n+    } else {\n+        chunkModules.add(moduleId);\n+    }\n+}\n+/**\n+ * Marks a chunk list as a runtime chunk list. There can be more than one\n+ * runtime chunk list. For instance, integration tests can have multiple chunk\n+ * groups loaded at runtime, each with its own chunk list.\n+ */ function markChunkListAsRuntime(chunkListPath) {\n+    runtimeChunkLists.add(chunkListPath);\n+}\n+function registerChunk(registration) {\n+    const chunkPath = getPathFromScript(registration[0]);\n+    let runtimeParams;\n+    // When bootstrapping we are passed a single runtimeParams object so we can distinguish purely based on length\n+    if (registration.length === 2) {\n+        runtimeParams = registration[1];\n+    } else {\n+        runtimeParams = undefined;\n+        installCompressedModuleFactories(registration, /* offset= */ 1, moduleFactories, (id)=>addModuleToChunk(id, chunkPath));\n+    }\n+    return BACKEND.registerChunk(chunkPath, runtimeParams);\n+}\n+/**\n+ * Subscribes to chunk list updates from the update server and applies them.\n+ */ function registerChunkList(chunkList) {\n+    const chunkListScript = chunkList.script;\n+    const chunkListPath = getPathFromScript(chunkListScript);\n+    // The \"chunk\" is also registered to finish the loading in the backend\n+    BACKEND.registerChunk(chunkListPath);\n+    globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS.push([\n+        chunkListPath,\n+        handleApply.bind(null, chunkListPath)\n+    ]);\n+    // Adding chunks to chunk lists and vice versa.\n+    const chunkPaths = new Set(chunkList.chunks.map(getChunkPath));\n+    chunkListChunksMap.set(chunkListPath, chunkPaths);\n+    for (const chunkPath of chunkPaths){\n+        let chunkChunkLists = chunkChunkListsMap.get(chunkPath);\n+        if (!chunkChunkLists) {\n+            chunkChunkLists = new Set([\n+                chunkListPath\n+            ]);\n+            chunkChunkListsMap.set(chunkPath, chunkChunkLists);\n+        } else {\n+            chunkChunkLists.add(chunkListPath);\n+        }\n+    }\n+    if (chunkList.source === 'entry') {\n+        markChunkListAsRuntime(chunkListPath);\n+    }\n+}\n+globalThis.TURBOPACK_CHUNK_UPDATE_LISTENERS ??= [];\n+/**\n+ * This file contains the runtime code specific to the Turbopack development\n+ * ECMAScript DOM runtime.\n+ *\n+ * It will be appended to the base development runtime code.\n+ */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../../../browser/runtime/base/runtime-base.ts\" />\n+/// <reference path=\"../../../shared/runtime-types.d.ts\" />\n+let BACKEND;\n+/**\n+ * Maps chunk paths to the corresponding resolver.\n+ */ const chunkResolvers = new Map();\n+(()=>{\n+    BACKEND = {\n+        async registerChunk (chunkPath, params) {\n+            const chunkUrl = getChunkRelativeUrl(chunkPath);\n+            const resolver = getOrCreateResolver(chunkUrl);\n+            resolver.resolve();\n+            if (params == null) {\n+                return;\n+            }\n+            for (const otherChunkData of params.otherChunks){\n+                const otherChunkPath = getChunkPath(otherChunkData);\n+                const otherChunkUrl = getChunkRelativeUrl(otherChunkPath);\n+                // Chunk might have started loading, so we want to avoid triggering another load.\n+                getOrCreateResolver(otherChunkUrl);\n+            }\n+            // This waits for chunks to be loaded, but also marks included items as available.\n+            await Promise.all(params.otherChunks.map((otherChunkData)=>loadInitialChunk(chunkPath, otherChunkData)));\n+            if (params.runtimeModuleIds.length > 0) {\n+                for (const moduleId of params.runtimeModuleIds){\n+                    getOrInstantiateRuntimeModule(chunkPath, moduleId);\n+                }\n+            }\n+        },\n+        /**\n+     * Loads the given chunk, and returns a promise that resolves once the chunk\n+     * has been loaded.\n+     */ loadChunkCached (sourceType, chunkUrl) {\n+            return doLoadChunk(sourceType, chunkUrl);\n+        },\n+        async loadWebAssembly (_sourceType, _sourceData, wasmChunkPath, _edgeModule, importsObj) {\n+            const req = fetchWebAssembly(wasmChunkPath);\n+            const { instance } = await WebAssembly.instantiateStreaming(req, importsObj);\n+            return instance.exports;\n+        },\n+        async loadWebAssemblyModule (_sourceType, _sourceData, wasmChunkPath, _edgeModule) {\n+            const req = fetchWebAssembly(wasmChunkPath);\n+            return await WebAssembly.compileStreaming(req);\n+        }\n+    };\n+    function getOrCreateResolver(chunkUrl) {\n+        let resolver = chunkResolvers.get(chunkUrl);\n+        if (!resolver) {\n+            let resolve;\n+            let reject;\n+            const promise = new Promise((innerResolve, innerReject)=>{\n+                resolve = innerResolve;\n+                reject = innerReject;\n+            });\n+            resolver = {\n+                resolved: false,\n+                loadingStarted: false,\n+                promise,\n+                resolve: ()=>{\n+                    resolver.resolved = true;\n+                    resolve();\n+                },\n+                reject: reject\n+            };\n+            chunkResolvers.set(chunkUrl, resolver);\n+        }\n+        return resolver;\n+    }\n+    /**\n+   * Loads the given chunk, and returns a promise that resolves once the chunk\n+   * has been loaded.\n+   */ function doLoadChunk(sourceType, chunkUrl) {\n+        const resolver = getOrCreateResolver(chunkUrl);\n+        if (resolver.loadingStarted) {\n+            return resolver.promise;\n+        }\n+        if (sourceType === SourceType.Runtime) {\n+            // We don't need to load chunks references from runtime code, as they're already\n+            // present in the DOM.\n+            resolver.loadingStarted = true;\n+            if (isCss(chunkUrl)) {\n+                // CSS chunks do not register themselves, and as such must be marked as\n+                // loaded instantly.\n+                resolver.resolve();\n+            }\n+            // We need to wait for JS chunks to register themselves within `registerChunk`\n+            // before we can start instantiating runtime modules, hence the absence of\n+            // `resolver.resolve()` in this branch.\n+            return resolver.promise;\n+        }\n+        if (typeof importScripts === 'function') {\n+            // We're in a web worker\n+            if (isCss(chunkUrl)) {\n+            // ignore\n+            } else if (isJs(chunkUrl)) {\n+                self.TURBOPACK_NEXT_CHUNK_URLS.push(chunkUrl);\n+                importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl);\n+            } else {\n+                throw new Error(`can't infer type of chunk from URL ${chunkUrl} in worker`);\n+            }\n+        } else {\n+            // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n+            const decodedChunkUrl = decodeURI(chunkUrl);\n+            if (isCss(chunkUrl)) {\n+                const previousLinks = document.querySelectorAll(`link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`);\n+                if (previousLinks.length > 0) {\n+                    // CSS chunks do not register themselves, and as such must be marked as\n+                    // loaded instantly.\n+                    resolver.resolve();\n+                } else {\n+                    const link = document.createElement('link');\n+                    link.rel = 'stylesheet';\n+                    link.href = chunkUrl;\n+                    link.onerror = ()=>{\n+                        resolver.reject();\n+                    };\n+                    link.onload = ()=>{\n+                        // CSS chunks do not register themselves, and as such must be marked as\n+                        // loaded instantly.\n+                        resolver.resolve();\n+                    };\n+                    // Append to the `head` for webpack compatibility.\n+                    document.head.appendChild(link);\n+                }\n+            } else if (isJs(chunkUrl)) {\n+                const previousScripts = document.querySelectorAll(`script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`);\n+                if (previousScripts.length > 0) {\n+                    // There is this edge where the script already failed loading, but we\n+                    // can't detect that. The Promise will never resolve in this case.\n+                    for (const script of Array.from(previousScripts)){\n+                        script.addEventListener('error', ()=>{\n+                            resolver.reject();\n+                        });\n+                    }\n+                } else {\n+                    const script = document.createElement('script');\n+                    script.src = chunkUrl;\n+                    // We'll only mark the chunk as loaded once the script has been executed,\n+                    // which happens in `registerChunk`. Hence the absence of `resolve()` in\n+                    // this branch.\n+                    script.onerror = ()=>{\n+                        resolver.reject();\n+                    };\n+                    // Append to the `head` for webpack compatibility.\n+                    document.head.appendChild(script);\n+                }\n+            } else {\n+                throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\n+            }\n+        }\n+        resolver.loadingStarted = true;\n+        return resolver.promise;\n+    }\n+    function fetchWebAssembly(wasmChunkPath) {\n+        return fetch(getChunkRelativeUrl(wasmChunkPath));\n+    }\n+})();\n+/**\n+ * This file contains the runtime code specific to the Turbopack development\n+ * ECMAScript DOM runtime.\n+ *\n+ * It will be appended to the base development runtime code.\n+ */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../base/runtime-base.ts\" />\n+/// <reference path=\"../base/dev-base.ts\" />\n+/// <reference path=\"./runtime-backend-dom.ts\" />\n+/// <reference path=\"../../../shared/require-type.d.ts\" />\n+let DEV_BACKEND;\n+(()=>{\n+    DEV_BACKEND = {\n+        unloadChunk (chunkUrl) {\n+            deleteResolver(chunkUrl);\n+            // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n+            const decodedChunkUrl = decodeURI(chunkUrl);\n+            if (isCss(chunkUrl)) {\n+                const links = document.querySelectorAll(`link[href=\"${chunkUrl}\"],link[href^=\"${chunkUrl}?\"],link[href=\"${decodedChunkUrl}\"],link[href^=\"${decodedChunkUrl}?\"]`);\n+                for (const link of Array.from(links)){\n+                    link.remove();\n+                }\n+            } else if (isJs(chunkUrl)) {\n+                // Unloading a JS chunk would have no effect, as it lives in the JS\n+                // runtime once evaluated.\n+                // However, we still want to remove the script tag from the DOM to keep\n+                // the HTML somewhat consistent from the user's perspective.\n+                const scripts = document.querySelectorAll(`script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`);\n+                for (const script of Array.from(scripts)){\n+                    script.remove();\n+                }\n+            } else {\n+                throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\n+            }\n+        },\n+        reloadChunk (chunkUrl) {\n+            return new Promise((resolve, reject)=>{\n+                if (!isCss(chunkUrl)) {\n+                    reject(new Error('The DOM backend can only reload CSS chunks'));\n+                    return;\n+                }\n+                const decodedChunkUrl = decodeURI(chunkUrl);\n+                const previousLinks = document.querySelectorAll(`link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`);\n+                if (previousLinks.length === 0) {\n+                    reject(new Error(`No link element found for chunk ${chunkUrl}`));\n+                    return;\n+                }\n+                const link = document.createElement('link');\n+                link.rel = 'stylesheet';\n+                if (navigator.userAgent.includes('Firefox')) {\n+                    // Firefox won't reload CSS files that were previously loaded on the current page,\n+                    // we need to add a query param to make sure CSS is actually reloaded from the server.\n+                    //\n+                    // I believe this is this issue: https://bugzilla.mozilla.org/show_bug.cgi?id=1037506\n+                    //\n+                    // Safari has a similar issue, but only if you have a `<link rel=preload ... />` tag\n+                    // pointing to the same URL as the stylesheet: https://bugs.webkit.org/show_bug.cgi?id=187726\n+                    link.href = `${chunkUrl}?ts=${Date.now()}`;\n+                } else {\n+                    link.href = chunkUrl;\n+                }\n+                link.onerror = ()=>{\n+                    reject();\n+                };\n+                link.onload = ()=>{\n+                    // First load the new CSS, then remove the old ones. This prevents visible\n+                    // flickering that would happen in-between removing the previous CSS and\n+                    // loading the new one.\n+                    for (const previousLink of Array.from(previousLinks))previousLink.remove();\n+                    // CSS chunks do not register themselves, and as such must be marked as\n+                    // loaded instantly.\n+                    resolve();\n+                };\n+                // Make sure to insert the new CSS right after the previous one, so that\n+                // its precedence is higher.\n+                previousLinks[0].parentElement.insertBefore(link, previousLinks[0].nextSibling);\n+            });\n+        },\n+        restart: ()=>self.location.reload()\n+    };\n+    function deleteResolver(chunkUrl) {\n+        chunkResolvers.delete(chunkUrl);\n+    }\n+})();\n+function _eval({ code, url, map }) {\n+    code += `\\n\\n//# sourceURL=${encodeURI(location.origin + CHUNK_BASE_PATH + url + CHUNK_SUFFIX_PATH)}`;\n+    if (map) {\n+        code += `\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,${btoa(// btoa doesn't handle nonlatin characters, so escape them as \\x sequences\n+        // See https://stackoverflow.com/a/26603875\n+        unescape(encodeURIComponent(map)))}`;\n+    }\n+    // eslint-disable-next-line no-eval\n+    return eval(code);\n+}\n+const chunksToRegister = globalThis.TURBOPACK;\n+globalThis.TURBOPACK = { push: registerChunk };\n+chunksToRegister.forEach(registerChunk);\n+const chunkListsToRegister = globalThis.TURBOPACK_CHUNK_LISTS || [];\n+globalThis.TURBOPACK_CHUNK_LISTS = { push: registerChunkList };\n+chunkListsToRegister.forEach(registerChunkList);\n+})();\n+\n+\n+//# debugId=9cf0cfff-fe6b-e2a6-ed5a-275f25467c66\n+//# sourceMappingURL=aaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_browser_input_index_0151fefb.js.map\n\\ No newline at end of file"
        },
        {
            "sha": "ba72797f7faa9f73154ab3578e1aca3558ddada1",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/node/input/index.js",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Finput%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Finput%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Finput%2Findex.js?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1 @@\n+console.log('Hello World')"
        },
        {
            "sha": "21dada2cba4b192807687e460ed771e1423d7a7d",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/node/options.json",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foptions.json",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foptions.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foptions.json?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1,7 @@\n+{\n+  \"runtime\": \"NodeJs\",\n+  \"runtimeType\": \"Development\",\n+  \"minifyType\": \"NoMinify\",\n+  \"environment\": \"NodeJs\",\n+  \"enableDebugIds\": true\n+}"
        },
        {
            "sha": "fe6a79404b3878d9ba86fe83621580070332ab11",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/node/output/[turbopack]_runtime.js",
            "status": "added",
            "additions": 770,
            "deletions": 0,
            "changes": 770,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2F%5Bturbopack%5D_runtime.js",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2F%5Bturbopack%5D_runtime.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2F%5Bturbopack%5D_runtime.js?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1,770 @@\n+const RUNTIME_PUBLIC_PATH = \"output/[turbopack]_runtime.js\";\n+const RELATIVE_ROOT_PATH = \"../../../../../../..\";\n+const ASSET_PREFIX = \"/\";\n+/**\n+ * This file contains runtime types and functions that are shared between all\n+ * TurboPack ECMAScript runtimes.\n+ *\n+ * It will be prepended to the runtime code of each runtime.\n+ */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"./runtime-types.d.ts\" />\n+const REEXPORTED_OBJECTS = new WeakMap();\n+/**\n+ * Constructs the `__turbopack_context__` object for a module.\n+ */ function Context(module, exports) {\n+    this.m = module;\n+    // We need to store this here instead of accessing it from the module object to:\n+    // 1. Make it available to factories directly, since we rewrite `this` to\n+    //    `__turbopack_context__.e` in CJS modules.\n+    // 2. Support async modules which rewrite `module.exports` to a promise, so we\n+    //    can still access the original exports object from functions like\n+    //    `esmExport`\n+    // Ideally we could find a new approach for async modules and drop this property altogether.\n+    this.e = exports;\n+}\n+const contextPrototype = Context.prototype;\n+const hasOwnProperty = Object.prototype.hasOwnProperty;\n+const toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag;\n+function defineProp(obj, name, options) {\n+    if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options);\n+}\n+function getOverwrittenModule(moduleCache, id) {\n+    let module = moduleCache[id];\n+    if (!module) {\n+        // This is invoked when a module is merged into another module, thus it wasn't invoked via\n+        // instantiateModule and the cache entry wasn't created yet.\n+        module = createModuleObject(id);\n+        moduleCache[id] = module;\n+    }\n+    return module;\n+}\n+/**\n+ * Creates the module object. Only done here to ensure all module objects have the same shape.\n+ */ function createModuleObject(id) {\n+    return {\n+        exports: {},\n+        error: undefined,\n+        id,\n+        namespaceObject: undefined\n+    };\n+}\n+const BindingTag_Value = 0;\n+/**\n+ * Adds the getters to the exports object.\n+ */ function esm(exports, bindings) {\n+    defineProp(exports, '__esModule', {\n+        value: true\n+    });\n+    if (toStringTag) defineProp(exports, toStringTag, {\n+        value: 'Module'\n+    });\n+    let i = 0;\n+    while(i < bindings.length){\n+        const propName = bindings[i++];\n+        const tagOrFunction = bindings[i++];\n+        if (typeof tagOrFunction === 'number') {\n+            if (tagOrFunction === BindingTag_Value) {\n+                defineProp(exports, propName, {\n+                    value: bindings[i++],\n+                    enumerable: true,\n+                    writable: false\n+                });\n+            } else {\n+                throw new Error(`unexpected tag: ${tagOrFunction}`);\n+            }\n+        } else {\n+            const getterFn = tagOrFunction;\n+            if (typeof bindings[i] === 'function') {\n+                const setterFn = bindings[i++];\n+                defineProp(exports, propName, {\n+                    get: getterFn,\n+                    set: setterFn,\n+                    enumerable: true\n+                });\n+            } else {\n+                defineProp(exports, propName, {\n+                    get: getterFn,\n+                    enumerable: true\n+                });\n+            }\n+        }\n+    }\n+    Object.seal(exports);\n+}\n+/**\n+ * Makes the module an ESM with exports\n+ */ function esmExport(bindings, id) {\n+    let module;\n+    let exports;\n+    if (id != null) {\n+        module = getOverwrittenModule(this.c, id);\n+        exports = module.exports;\n+    } else {\n+        module = this.m;\n+        exports = this.e;\n+    }\n+    module.namespaceObject = exports;\n+    esm(exports, bindings);\n+}\n+contextPrototype.s = esmExport;\n+function ensureDynamicExports(module, exports) {\n+    let reexportedObjects = REEXPORTED_OBJECTS.get(module);\n+    if (!reexportedObjects) {\n+        REEXPORTED_OBJECTS.set(module, reexportedObjects = []);\n+        module.exports = module.namespaceObject = new Proxy(exports, {\n+            get (target, prop) {\n+                if (hasOwnProperty.call(target, prop) || prop === 'default' || prop === '__esModule') {\n+                    return Reflect.get(target, prop);\n+                }\n+                for (const obj of reexportedObjects){\n+                    const value = Reflect.get(obj, prop);\n+                    if (value !== undefined) return value;\n+                }\n+                return undefined;\n+            },\n+            ownKeys (target) {\n+                const keys = Reflect.ownKeys(target);\n+                for (const obj of reexportedObjects){\n+                    for (const key of Reflect.ownKeys(obj)){\n+                        if (key !== 'default' && !keys.includes(key)) keys.push(key);\n+                    }\n+                }\n+                return keys;\n+            }\n+        });\n+    }\n+    return reexportedObjects;\n+}\n+/**\n+ * Dynamically exports properties from an object\n+ */ function dynamicExport(object, id) {\n+    let module;\n+    let exports;\n+    if (id != null) {\n+        module = getOverwrittenModule(this.c, id);\n+        exports = module.exports;\n+    } else {\n+        module = this.m;\n+        exports = this.e;\n+    }\n+    const reexportedObjects = ensureDynamicExports(module, exports);\n+    if (typeof object === 'object' && object !== null) {\n+        reexportedObjects.push(object);\n+    }\n+}\n+contextPrototype.j = dynamicExport;\n+function exportValue(value, id) {\n+    let module;\n+    if (id != null) {\n+        module = getOverwrittenModule(this.c, id);\n+    } else {\n+        module = this.m;\n+    }\n+    module.exports = value;\n+}\n+contextPrototype.v = exportValue;\n+function exportNamespace(namespace, id) {\n+    let module;\n+    if (id != null) {\n+        module = getOverwrittenModule(this.c, id);\n+    } else {\n+        module = this.m;\n+    }\n+    module.exports = module.namespaceObject = namespace;\n+}\n+contextPrototype.n = exportNamespace;\n+function createGetter(obj, key) {\n+    return ()=>obj[key];\n+}\n+/**\n+ * @returns prototype of the object\n+ */ const getProto = Object.getPrototypeOf ? (obj)=>Object.getPrototypeOf(obj) : (obj)=>obj.__proto__;\n+/** Prototypes that are not expanded for exports */ const LEAF_PROTOTYPES = [\n+    null,\n+    getProto({}),\n+    getProto([]),\n+    getProto(getProto)\n+];\n+/**\n+ * @param raw\n+ * @param ns\n+ * @param allowExportDefault\n+ *   * `false`: will have the raw module as default export\n+ *   * `true`: will have the default property as default export\n+ */ function interopEsm(raw, ns, allowExportDefault) {\n+    const bindings = [];\n+    let defaultLocation = -1;\n+    for(let current = raw; (typeof current === 'object' || typeof current === 'function') && !LEAF_PROTOTYPES.includes(current); current = getProto(current)){\n+        for (const key of Object.getOwnPropertyNames(current)){\n+            bindings.push(key, createGetter(raw, key));\n+            if (defaultLocation === -1 && key === 'default') {\n+                defaultLocation = bindings.length - 1;\n+            }\n+        }\n+    }\n+    // this is not really correct\n+    // we should set the `default` getter if the imported module is a `.cjs file`\n+    if (!(allowExportDefault && defaultLocation >= 0)) {\n+        // Replace the binding with one for the namespace itself in order to preserve iteration order.\n+        if (defaultLocation >= 0) {\n+            // Replace the getter with the value\n+            bindings.splice(defaultLocation, 1, BindingTag_Value, raw);\n+        } else {\n+            bindings.push('default', BindingTag_Value, raw);\n+        }\n+    }\n+    esm(ns, bindings);\n+    return ns;\n+}\n+function createNS(raw) {\n+    if (typeof raw === 'function') {\n+        return function(...args) {\n+            return raw.apply(this, args);\n+        };\n+    } else {\n+        return Object.create(null);\n+    }\n+}\n+function esmImport(id) {\n+    const module = getOrInstantiateModuleFromParent(id, this.m);\n+    // any ES module has to have `module.namespaceObject` defined.\n+    if (module.namespaceObject) return module.namespaceObject;\n+    // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n+    const raw = module.exports;\n+    return module.namespaceObject = interopEsm(raw, createNS(raw), raw && raw.__esModule);\n+}\n+contextPrototype.i = esmImport;\n+function asyncLoader(moduleId) {\n+    const loader = this.r(moduleId);\n+    return loader(esmImport.bind(this));\n+}\n+contextPrototype.A = asyncLoader;\n+// Add a simple runtime require so that environments without one can still pass\n+// `typeof require` CommonJS checks so that exports are correctly registered.\n+const runtimeRequire = // @ts-ignore\n+typeof require === 'function' ? require : function require1() {\n+    throw new Error('Unexpected use of runtime require');\n+};\n+contextPrototype.t = runtimeRequire;\n+function commonJsRequire(id) {\n+    return getOrInstantiateModuleFromParent(id, this.m).exports;\n+}\n+contextPrototype.r = commonJsRequire;\n+/**\n+ * `require.context` and require/import expression runtime.\n+ */ function moduleContext(map) {\n+    function moduleContext(id) {\n+        if (hasOwnProperty.call(map, id)) {\n+            return map[id].module();\n+        }\n+        const e = new Error(`Cannot find module '${id}'`);\n+        e.code = 'MODULE_NOT_FOUND';\n+        throw e;\n+    }\n+    moduleContext.keys = ()=>{\n+        return Object.keys(map);\n+    };\n+    moduleContext.resolve = (id)=>{\n+        if (hasOwnProperty.call(map, id)) {\n+            return map[id].id();\n+        }\n+        const e = new Error(`Cannot find module '${id}'`);\n+        e.code = 'MODULE_NOT_FOUND';\n+        throw e;\n+    };\n+    moduleContext.import = async (id)=>{\n+        return await moduleContext(id);\n+    };\n+    return moduleContext;\n+}\n+contextPrototype.f = moduleContext;\n+/**\n+ * Returns the path of a chunk defined by its data.\n+ */ function getChunkPath(chunkData) {\n+    return typeof chunkData === 'string' ? chunkData : chunkData.path;\n+}\n+function isPromise(maybePromise) {\n+    return maybePromise != null && typeof maybePromise === 'object' && 'then' in maybePromise && typeof maybePromise.then === 'function';\n+}\n+function isAsyncModuleExt(obj) {\n+    return turbopackQueues in obj;\n+}\n+function createPromise() {\n+    let resolve;\n+    let reject;\n+    const promise = new Promise((res, rej)=>{\n+        reject = rej;\n+        resolve = res;\n+    });\n+    return {\n+        promise,\n+        resolve: resolve,\n+        reject: reject\n+    };\n+}\n+// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\n+// The CompressedModuleFactories format is\n+// - 1 or more module ids\n+// - a module factory function\n+// So walking this is a little complex but the flat structure is also fast to\n+// traverse, we can use `typeof` operators to distinguish the two cases.\n+function installCompressedModuleFactories(chunkModules, offset, moduleFactories, newModuleId) {\n+    let i = offset;\n+    while(i < chunkModules.length){\n+        let moduleId = chunkModules[i];\n+        let end = i + 1;\n+        // Find our factory function\n+        while(end < chunkModules.length && typeof chunkModules[end] !== 'function'){\n+            end++;\n+        }\n+        if (end === chunkModules.length) {\n+            throw new Error('malformed chunk format, expected a factory function');\n+        }\n+        // Each chunk item has a 'primary id' and optional additional ids. If the primary id is already\n+        // present we know all the additional ids are also present, so we don't need to check.\n+        if (!moduleFactories.has(moduleId)) {\n+            const moduleFactoryFn = chunkModules[end];\n+            applyModuleFactoryName(moduleFactoryFn);\n+            newModuleId?.(moduleId);\n+            for(; i < end; i++){\n+                moduleId = chunkModules[i];\n+                moduleFactories.set(moduleId, moduleFactoryFn);\n+            }\n+        }\n+        i = end + 1; // end is pointing at the last factory advance to the next id or the end of the array.\n+    }\n+}\n+// everything below is adapted from webpack\n+// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\n+const turbopackQueues = Symbol('turbopack queues');\n+const turbopackExports = Symbol('turbopack exports');\n+const turbopackError = Symbol('turbopack error');\n+function resolveQueue(queue) {\n+    if (queue && queue.status !== 1) {\n+        queue.status = 1;\n+        queue.forEach((fn)=>fn.queueCount--);\n+        queue.forEach((fn)=>fn.queueCount-- ? fn.queueCount++ : fn());\n+    }\n+}\n+function wrapDeps(deps) {\n+    return deps.map((dep)=>{\n+        if (dep !== null && typeof dep === 'object') {\n+            if (isAsyncModuleExt(dep)) return dep;\n+            if (isPromise(dep)) {\n+                const queue = Object.assign([], {\n+                    status: 0\n+                });\n+                const obj = {\n+                    [turbopackExports]: {},\n+                    [turbopackQueues]: (fn)=>fn(queue)\n+                };\n+                dep.then((res)=>{\n+                    obj[turbopackExports] = res;\n+                    resolveQueue(queue);\n+                }, (err)=>{\n+                    obj[turbopackError] = err;\n+                    resolveQueue(queue);\n+                });\n+                return obj;\n+            }\n+        }\n+        return {\n+            [turbopackExports]: dep,\n+            [turbopackQueues]: ()=>{}\n+        };\n+    });\n+}\n+function asyncModule(body, hasAwait) {\n+    const module = this.m;\n+    const queue = hasAwait ? Object.assign([], {\n+        status: -1\n+    }) : undefined;\n+    const depQueues = new Set();\n+    const { resolve, reject, promise: rawPromise } = createPromise();\n+    const promise = Object.assign(rawPromise, {\n+        [turbopackExports]: module.exports,\n+        [turbopackQueues]: (fn)=>{\n+            queue && fn(queue);\n+            depQueues.forEach(fn);\n+            promise['catch'](()=>{});\n+        }\n+    });\n+    const attributes = {\n+        get () {\n+            return promise;\n+        },\n+        set (v) {\n+            // Calling `esmExport` leads to this.\n+            if (v !== promise) {\n+                promise[turbopackExports] = v;\n+            }\n+        }\n+    };\n+    Object.defineProperty(module, 'exports', attributes);\n+    Object.defineProperty(module, 'namespaceObject', attributes);\n+    function handleAsyncDependencies(deps) {\n+        const currentDeps = wrapDeps(deps);\n+        const getResult = ()=>currentDeps.map((d)=>{\n+                if (d[turbopackError]) throw d[turbopackError];\n+                return d[turbopackExports];\n+            });\n+        const { promise, resolve } = createPromise();\n+        const fn = Object.assign(()=>resolve(getResult), {\n+            queueCount: 0\n+        });\n+        function fnQueue(q) {\n+            if (q !== queue && !depQueues.has(q)) {\n+                depQueues.add(q);\n+                if (q && q.status === 0) {\n+                    fn.queueCount++;\n+                    q.push(fn);\n+                }\n+            }\n+        }\n+        currentDeps.map((dep)=>dep[turbopackQueues](fnQueue));\n+        return fn.queueCount ? promise : getResult();\n+    }\n+    function asyncResult(err) {\n+        if (err) {\n+            reject(promise[turbopackError] = err);\n+        } else {\n+            resolve(promise[turbopackExports]);\n+        }\n+        resolveQueue(queue);\n+    }\n+    body(handleAsyncDependencies, asyncResult);\n+    if (queue && queue.status === -1) {\n+        queue.status = 0;\n+    }\n+}\n+contextPrototype.a = asyncModule;\n+/**\n+ * A pseudo \"fake\" URL object to resolve to its relative path.\n+ *\n+ * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\n+ * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\n+ * hydration mismatch.\n+ *\n+ * This is based on webpack's existing implementation:\n+ * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\n+ */ const relativeURL = function relativeURL(inputUrl) {\n+    const realUrl = new URL(inputUrl, 'x:/');\n+    const values = {};\n+    for(const key in realUrl)values[key] = realUrl[key];\n+    values.href = inputUrl;\n+    values.pathname = inputUrl.replace(/[?#].*/, '');\n+    values.origin = values.protocol = '';\n+    values.toString = values.toJSON = (..._args)=>inputUrl;\n+    for(const key in values)Object.defineProperty(this, key, {\n+        enumerable: true,\n+        configurable: true,\n+        value: values[key]\n+    });\n+};\n+relativeURL.prototype = URL.prototype;\n+contextPrototype.U = relativeURL;\n+/**\n+ * Utility function to ensure all variants of an enum are handled.\n+ */ function invariant(never, computeMessage) {\n+    throw new Error(`Invariant: ${computeMessage(never)}`);\n+}\n+/**\n+ * A stub function to make `require` available but non-functional in ESM.\n+ */ function requireStub(_moduleId) {\n+    throw new Error('dynamic usage of require is not supported');\n+}\n+contextPrototype.z = requireStub;\n+// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\n+contextPrototype.g = globalThis;\n+function applyModuleFactoryName(factory) {\n+    // Give the module factory a nice name to improve stack traces.\n+    Object.defineProperty(factory, 'name', {\n+        value: '__TURBOPACK__module__evaluation__'\n+    });\n+}\n+/* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../shared/runtime-utils.ts\" />\n+/// A 'base' utilities to support runtime can have externals.\n+/// Currently this is for node.js / edge runtime both.\n+/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\n+async function externalImport(id) {\n+    let raw;\n+    try {\n+        raw = await import(id);\n+    } catch (err) {\n+        // TODO(alexkirsz) This can happen when a client-side module tries to load\n+        // an external module we don't provide a shim for (e.g. querystring, url).\n+        // For now, we fail semi-silently, but in the future this should be a\n+        // compilation error.\n+        throw new Error(`Failed to load external module ${id}: ${err}`);\n+    }\n+    if (raw && raw.__esModule && raw.default && 'default' in raw.default) {\n+        return interopEsm(raw.default, createNS(raw), true);\n+    }\n+    return raw;\n+}\n+contextPrototype.y = externalImport;\n+function externalRequire(id, thunk, esm = false) {\n+    let raw;\n+    try {\n+        raw = thunk();\n+    } catch (err) {\n+        // TODO(alexkirsz) This can happen when a client-side module tries to load\n+        // an external module we don't provide a shim for (e.g. querystring, url).\n+        // For now, we fail semi-silently, but in the future this should be a\n+        // compilation error.\n+        throw new Error(`Failed to load external module ${id}: ${err}`);\n+    }\n+    if (!esm || raw.__esModule) {\n+        return raw;\n+    }\n+    return interopEsm(raw, createNS(raw), true);\n+}\n+externalRequire.resolve = (id, options)=>{\n+    return require.resolve(id, options);\n+};\n+contextPrototype.x = externalRequire;\n+/* eslint-disable @typescript-eslint/no-unused-vars */ const path = require('path');\n+const relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, '.');\n+// Compute the relative path to the `distDir`.\n+const relativePathToDistRoot = path.join(relativePathToRuntimeRoot, RELATIVE_ROOT_PATH);\n+const RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot);\n+// Compute the absolute path to the root, by stripping distDir from the absolute path to this file.\n+const ABSOLUTE_ROOT = path.resolve(__filename, relativePathToDistRoot);\n+/**\n+ * Returns an absolute path to the given module path.\n+ * Module path should be relative, either path to a file or a directory.\n+ *\n+ * This fn allows to calculate an absolute path for some global static values, such as\n+ * `__dirname` or `import.meta.url` that Turbopack will not embeds in compile time.\n+ * See ImportMetaBinding::code_generation for the usage.\n+ */ function resolveAbsolutePath(modulePath) {\n+    if (modulePath) {\n+        return path.join(ABSOLUTE_ROOT, modulePath);\n+    }\n+    return ABSOLUTE_ROOT;\n+}\n+Context.prototype.P = resolveAbsolutePath;\n+/* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../shared/runtime-utils.ts\" />\n+function readWebAssemblyAsResponse(path) {\n+    const { createReadStream } = require('fs');\n+    const { Readable } = require('stream');\n+    const stream = createReadStream(path);\n+    // @ts-ignore unfortunately there's a slight type mismatch with the stream.\n+    return new Response(Readable.toWeb(stream), {\n+        headers: {\n+            'content-type': 'application/wasm'\n+        }\n+    });\n+}\n+async function compileWebAssemblyFromPath(path) {\n+    const response = readWebAssemblyAsResponse(path);\n+    return await WebAssembly.compileStreaming(response);\n+}\n+async function instantiateWebAssemblyFromPath(path, importsObj) {\n+    const response = readWebAssemblyAsResponse(path);\n+    const { instance } = await WebAssembly.instantiateStreaming(response, importsObj);\n+    return instance.exports;\n+}\n+/* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../shared/runtime-utils.ts\" />\n+/// <reference path=\"../shared-node/base-externals-utils.ts\" />\n+/// <reference path=\"../shared-node/node-externals-utils.ts\" />\n+/// <reference path=\"../shared-node/node-wasm-utils.ts\" />\n+var SourceType = /*#__PURE__*/ function(SourceType) {\n+    /**\n+   * The module was instantiated because it was included in an evaluated chunk's\n+   * runtime.\n+   * SourceData is a ChunkPath.\n+   */ SourceType[SourceType[\"Runtime\"] = 0] = \"Runtime\";\n+    /**\n+   * The module was instantiated because a parent module imported it.\n+   * SourceData is a ModuleId.\n+   */ SourceType[SourceType[\"Parent\"] = 1] = \"Parent\";\n+    return SourceType;\n+}(SourceType || {});\n+process.env.TURBOPACK = '1';\n+const nodeContextPrototype = Context.prototype;\n+const url = require('url');\n+const moduleFactories = new Map();\n+nodeContextPrototype.M = moduleFactories;\n+const moduleCache = Object.create(null);\n+nodeContextPrototype.c = moduleCache;\n+/**\n+ * Returns an absolute path to the given module's id.\n+ */ function resolvePathFromModule(moduleId) {\n+    const exported = this.r(moduleId);\n+    const exportedPath = exported?.default ?? exported;\n+    if (typeof exportedPath !== 'string') {\n+        return exported;\n+    }\n+    const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length);\n+    const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix);\n+    return url.pathToFileURL(resolved).href;\n+}\n+nodeContextPrototype.R = resolvePathFromModule;\n+function loadRuntimeChunk(sourcePath, chunkData) {\n+    if (typeof chunkData === 'string') {\n+        loadRuntimeChunkPath(sourcePath, chunkData);\n+    } else {\n+        loadRuntimeChunkPath(sourcePath, chunkData.path);\n+    }\n+}\n+const loadedChunks = new Set();\n+const unsupportedLoadChunk = Promise.resolve(undefined);\n+const loadedChunk = Promise.resolve(undefined);\n+const chunkCache = new Map();\n+function clearChunkCache() {\n+    chunkCache.clear();\n+}\n+function loadRuntimeChunkPath(sourcePath, chunkPath) {\n+    if (!isJs(chunkPath)) {\n+        // We only support loading JS chunks in Node.js.\n+        // This branch can be hit when trying to load a CSS chunk.\n+        return;\n+    }\n+    if (loadedChunks.has(chunkPath)) {\n+        return;\n+    }\n+    try {\n+        const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n+        const chunkModules = require(resolved);\n+        installCompressedModuleFactories(chunkModules, 0, moduleFactories);\n+        loadedChunks.add(chunkPath);\n+    } catch (e) {\n+        let errorMessage = `Failed to load chunk ${chunkPath}`;\n+        if (sourcePath) {\n+            errorMessage += ` from runtime for chunk ${sourcePath}`;\n+        }\n+        throw new Error(errorMessage, {\n+            cause: e\n+        });\n+    }\n+}\n+function loadChunkAsync(chunkData) {\n+    const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path;\n+    if (!isJs(chunkPath)) {\n+        // We only support loading JS chunks in Node.js.\n+        // This branch can be hit when trying to load a CSS chunk.\n+        return unsupportedLoadChunk;\n+    }\n+    let entry = chunkCache.get(chunkPath);\n+    if (entry === undefined) {\n+        try {\n+            // resolve to an absolute path to simplify `require` handling\n+            const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n+            // TODO: consider switching to `import()` to enable concurrent chunk loading and async file io\n+            // However this is incompatible with hot reloading (since `import` doesn't use the require cache)\n+            const chunkModules = require(resolved);\n+            installCompressedModuleFactories(chunkModules, 0, moduleFactories);\n+            entry = loadedChunk;\n+        } catch (e) {\n+            const errorMessage = `Failed to load chunk ${chunkPath} from module ${this.m.id}`;\n+            // Cache the failure promise, future requests will also get this same rejection\n+            entry = Promise.reject(new Error(errorMessage, {\n+                cause: e\n+            }));\n+        }\n+        chunkCache.set(chunkPath, entry);\n+    }\n+    // TODO: Return an instrumented Promise that React can use instead of relying on referential equality.\n+    return entry;\n+}\n+contextPrototype.l = loadChunkAsync;\n+function loadChunkAsyncByUrl(chunkUrl) {\n+    const path1 = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT));\n+    return loadChunkAsync.call(this, path1);\n+}\n+contextPrototype.L = loadChunkAsyncByUrl;\n+function loadWebAssembly(chunkPath, _edgeModule, imports) {\n+    const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n+    return instantiateWebAssemblyFromPath(resolved, imports);\n+}\n+contextPrototype.w = loadWebAssembly;\n+function loadWebAssemblyModule(chunkPath, _edgeModule) {\n+    const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n+    return compileWebAssemblyFromPath(resolved);\n+}\n+contextPrototype.u = loadWebAssemblyModule;\n+function getWorkerBlobURL(_chunks) {\n+    throw new Error('Worker blobs are not implemented yet for Node.js');\n+}\n+nodeContextPrototype.b = getWorkerBlobURL;\n+function instantiateModule(id, sourceType, sourceData) {\n+    const moduleFactory = moduleFactories.get(id);\n+    if (typeof moduleFactory !== 'function') {\n+        // This can happen if modules incorrectly handle HMR disposes/updates,\n+        // e.g. when they keep a `setTimeout` around which still executes old code\n+        // and contains e.g. a `require(\"something\")` call.\n+        let instantiationReason;\n+        switch(sourceType){\n+            case 0:\n+                instantiationReason = `as a runtime entry of chunk ${sourceData}`;\n+                break;\n+            case 1:\n+                instantiationReason = `because it was required from module ${sourceData}`;\n+                break;\n+            default:\n+                invariant(sourceType, (sourceType)=>`Unknown source type: ${sourceType}`);\n+        }\n+        throw new Error(`Module ${id} was instantiated ${instantiationReason}, but the module factory is not available.`);\n+    }\n+    const module1 = createModuleObject(id);\n+    const exports = module1.exports;\n+    moduleCache[id] = module1;\n+    const context = new Context(module1, exports);\n+    // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n+    try {\n+        moduleFactory(context, module1, exports);\n+    } catch (error) {\n+        module1.error = error;\n+        throw error;\n+    }\n+    module1.loaded = true;\n+    if (module1.namespaceObject && module1.exports !== module1.namespaceObject) {\n+        // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n+        interopEsm(module1.exports, module1.namespaceObject);\n+    }\n+    return module1;\n+}\n+/**\n+ * Retrieves a module from the cache, or instantiate it if it is not cached.\n+ */ // @ts-ignore\n+function getOrInstantiateModuleFromParent(id, sourceModule) {\n+    const module1 = moduleCache[id];\n+    if (module1) {\n+        if (module1.error) {\n+            throw module1.error;\n+        }\n+        return module1;\n+    }\n+    return instantiateModule(id, 1, sourceModule.id);\n+}\n+/**\n+ * Instantiates a runtime module.\n+ */ function instantiateRuntimeModule(chunkPath, moduleId) {\n+    return instantiateModule(moduleId, 0, chunkPath);\n+}\n+/**\n+ * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\n+ */ // @ts-ignore TypeScript doesn't separate this module space from the browser runtime\n+function getOrInstantiateRuntimeModule(chunkPath, moduleId) {\n+    const module1 = moduleCache[moduleId];\n+    if (module1) {\n+        if (module1.error) {\n+            throw module1.error;\n+        }\n+        return module1;\n+    }\n+    return instantiateRuntimeModule(chunkPath, moduleId);\n+}\n+const regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n+/**\n+ * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n+ */ function isJs(chunkUrlOrPath) {\n+    return regexJsUrl.test(chunkUrlOrPath);\n+}\n+module.exports = (sourcePath)=>({\n+        m: (id)=>getOrInstantiateRuntimeModule(sourcePath, id),\n+        c: (chunkData)=>loadRuntimeChunk(sourcePath, chunkData)\n+    });\n+\n+\n+//# sourceMappingURL=%5Bturbopack%5D_runtime.js.map\n\\ No newline at end of file"
        },
        {
            "sha": "95e3b88f41c49b53262edfaaac345d62b921a328",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/node/output/[turbopack]_runtime.js.map",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2F%5Bturbopack%5D_runtime.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2F%5Bturbopack%5D_runtime.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2F%5Bturbopack%5D_runtime.js.map?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1,10 @@\n+{\n+  \"version\": 3,\n+  \"sources\": [],\n+  \"sections\": [\n+    {\"offset\": {\"line\": 3, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared/runtime-utils.ts\"],\"sourcesContent\":[\"/**\\n * This file contains runtime types and functions that are shared between all\\n * TurboPack ECMAScript runtimes.\\n *\\n * It will be prepended to the runtime code of each runtime.\\n */\\n\\n/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"./runtime-types.d.ts\\\" />\\n\\ntype EsmNamespaceObject = Record<string, any>\\n\\n// @ts-ignore Defined in `dev-base.ts`\\ndeclare function getOrInstantiateModuleFromParent<M>(\\n  id: ModuleId,\\n  sourceModule: M\\n): M\\n\\nconst REEXPORTED_OBJECTS = new WeakMap<Module, ReexportedObjects>()\\n\\n/**\\n * Constructs the `__turbopack_context__` object for a module.\\n */\\nfunction Context(\\n  this: TurbopackBaseContext<Module>,\\n  module: Module,\\n  exports: Exports\\n) {\\n  this.m = module\\n  // We need to store this here instead of accessing it from the module object to:\\n  // 1. Make it available to factories directly, since we rewrite `this` to\\n  //    `__turbopack_context__.e` in CJS modules.\\n  // 2. Support async modules which rewrite `module.exports` to a promise, so we\\n  //    can still access the original exports object from functions like\\n  //    `esmExport`\\n  // Ideally we could find a new approach for async modules and drop this property altogether.\\n  this.e = exports\\n}\\nconst contextPrototype = Context.prototype as TurbopackBaseContext<Module>\\n\\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\\n\\ninterface ModuleContextEntry {\\n  id: () => ModuleId\\n  module: () => any\\n}\\n\\ninterface ModuleContext {\\n  // require call\\n  (moduleId: ModuleId): Exports | EsmNamespaceObject\\n\\n  // async import call\\n  import(moduleId: ModuleId): Promise<Exports | EsmNamespaceObject>\\n\\n  keys(): ModuleId[]\\n\\n  resolve(moduleId: ModuleId): ModuleId\\n}\\n\\ntype GetOrInstantiateModuleFromParent<M extends Module> = (\\n  moduleId: M['id'],\\n  parentModule: M\\n) => M\\n\\ndeclare function getOrInstantiateRuntimeModule(\\n  chunkPath: ChunkPath,\\n  moduleId: ModuleId\\n): Module\\n\\nconst hasOwnProperty = Object.prototype.hasOwnProperty\\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\\n\\nfunction defineProp(\\n  obj: any,\\n  name: PropertyKey,\\n  options: PropertyDescriptor & ThisType<any>\\n) {\\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\\n}\\n\\nfunction getOverwrittenModule(\\n  moduleCache: ModuleCache<Module>,\\n  id: ModuleId\\n): Module {\\n  let module = moduleCache[id]\\n  if (!module) {\\n    // This is invoked when a module is merged into another module, thus it wasn't invoked via\\n    // instantiateModule and the cache entry wasn't created yet.\\n    module = createModuleObject(id)\\n    moduleCache[id] = module\\n  }\\n  return module\\n}\\n\\n/**\\n * Creates the module object. Only done here to ensure all module objects have the same shape.\\n */\\nfunction createModuleObject(id: ModuleId): Module {\\n  return {\\n    exports: {},\\n    error: undefined,\\n    id,\\n    namespaceObject: undefined,\\n  }\\n}\\n\\ntype BindingTag = 0\\nconst BindingTag_Value = 0 as BindingTag\\n\\n// an arbitrary sequence of bindings as\\n// - a prop name\\n// - BindingTag_Value, a value to be bound directly, or\\n// - 1 or 2 functions to bind as getters and sdetters\\ntype EsmBindings = Array<\\n  string | BindingTag | (() => unknown) | ((v: unknown) => void) | unknown\\n>\\n\\n/**\\n * Adds the getters to the exports object.\\n */\\nfunction esm(exports: Exports, bindings: EsmBindings) {\\n  defineProp(exports, '__esModule', { value: true })\\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\\n  let i = 0\\n  while (i < bindings.length) {\\n    const propName = bindings[i++] as string\\n    const tagOrFunction = bindings[i++]\\n    if (typeof tagOrFunction === 'number') {\\n      if (tagOrFunction === BindingTag_Value) {\\n        defineProp(exports, propName, {\\n          value: bindings[i++],\\n          enumerable: true,\\n          writable: false,\\n        })\\n      } else {\\n        throw new Error(`unexpected tag: ${tagOrFunction}`)\\n      }\\n    } else {\\n      const getterFn = tagOrFunction as () => unknown\\n      if (typeof bindings[i] === 'function') {\\n        const setterFn = bindings[i++] as (v: unknown) => void\\n        defineProp(exports, propName, {\\n          get: getterFn,\\n          set: setterFn,\\n          enumerable: true,\\n        })\\n      } else {\\n        defineProp(exports, propName, {\\n          get: getterFn,\\n          enumerable: true,\\n        })\\n      }\\n    }\\n  }\\n  Object.seal(exports)\\n}\\n\\n/**\\n * Makes the module an ESM with exports\\n */\\nfunction esmExport(\\n  this: TurbopackBaseContext<Module>,\\n  bindings: EsmBindings,\\n  id: ModuleId | undefined\\n) {\\n  let module: Module\\n  let exports: Module['exports']\\n  if (id != null) {\\n    module = getOverwrittenModule(this.c, id)\\n    exports = module.exports\\n  } else {\\n    module = this.m\\n    exports = this.e\\n  }\\n  module.namespaceObject = exports\\n  esm(exports, bindings)\\n}\\ncontextPrototype.s = esmExport\\n\\ntype ReexportedObjects = Record<PropertyKey, unknown>[]\\nfunction ensureDynamicExports(\\n  module: Module,\\n  exports: Exports\\n): ReexportedObjects {\\n  let reexportedObjects: ReexportedObjects | undefined =\\n    REEXPORTED_OBJECTS.get(module)\\n\\n  if (!reexportedObjects) {\\n    REEXPORTED_OBJECTS.set(module, (reexportedObjects = []))\\n    module.exports = module.namespaceObject = new Proxy(exports, {\\n      get(target, prop) {\\n        if (\\n          hasOwnProperty.call(target, prop) ||\\n          prop === 'default' ||\\n          prop === '__esModule'\\n        ) {\\n          return Reflect.get(target, prop)\\n        }\\n        for (const obj of reexportedObjects!) {\\n          const value = Reflect.get(obj, prop)\\n          if (value !== undefined) return value\\n        }\\n        return undefined\\n      },\\n      ownKeys(target) {\\n        const keys = Reflect.ownKeys(target)\\n        for (const obj of reexportedObjects!) {\\n          for (const key of Reflect.ownKeys(obj)) {\\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\\n          }\\n        }\\n        return keys\\n      },\\n    })\\n  }\\n  return reexportedObjects\\n}\\n\\n/**\\n * Dynamically exports properties from an object\\n */\\nfunction dynamicExport(\\n  this: TurbopackBaseContext<Module>,\\n  object: Record<string, any>,\\n  id: ModuleId | undefined\\n) {\\n  let module: Module\\n  let exports: Exports\\n  if (id != null) {\\n    module = getOverwrittenModule(this.c, id)\\n    exports = module.exports\\n  } else {\\n    module = this.m\\n    exports = this.e\\n  }\\n  const reexportedObjects = ensureDynamicExports(module, exports)\\n\\n  if (typeof object === 'object' && object !== null) {\\n    reexportedObjects.push(object)\\n  }\\n}\\ncontextPrototype.j = dynamicExport\\n\\nfunction exportValue(\\n  this: TurbopackBaseContext<Module>,\\n  value: any,\\n  id: ModuleId | undefined\\n) {\\n  let module: Module\\n  if (id != null) {\\n    module = getOverwrittenModule(this.c, id)\\n  } else {\\n    module = this.m\\n  }\\n  module.exports = value\\n}\\ncontextPrototype.v = exportValue\\n\\nfunction exportNamespace(\\n  this: TurbopackBaseContext<Module>,\\n  namespace: any,\\n  id: ModuleId | undefined\\n) {\\n  let module: Module\\n  if (id != null) {\\n    module = getOverwrittenModule(this.c, id)\\n  } else {\\n    module = this.m\\n  }\\n  module.exports = module.namespaceObject = namespace\\n}\\ncontextPrototype.n = exportNamespace\\n\\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\\n  return () => obj[key]\\n}\\n\\n/**\\n * @returns prototype of the object\\n */\\nconst getProto: (obj: any) => any = Object.getPrototypeOf\\n  ? (obj) => Object.getPrototypeOf(obj)\\n  : (obj) => obj.__proto__\\n\\n/** Prototypes that are not expanded for exports */\\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\\n\\n/**\\n * @param raw\\n * @param ns\\n * @param allowExportDefault\\n *   * `false`: will have the raw module as default export\\n *   * `true`: will have the default property as default export\\n */\\nfunction interopEsm(\\n  raw: Exports,\\n  ns: EsmNamespaceObject,\\n  allowExportDefault?: boolean\\n) {\\n  const bindings: EsmBindings = []\\n  let defaultLocation = -1\\n  for (\\n    let current = raw;\\n    (typeof current === 'object' || typeof current === 'function') &&\\n    !LEAF_PROTOTYPES.includes(current);\\n    current = getProto(current)\\n  ) {\\n    for (const key of Object.getOwnPropertyNames(current)) {\\n      bindings.push(key, createGetter(raw, key))\\n      if (defaultLocation === -1 && key === 'default') {\\n        defaultLocation = bindings.length - 1\\n      }\\n    }\\n  }\\n\\n  // this is not really correct\\n  // we should set the `default` getter if the imported module is a `.cjs file`\\n  if (!(allowExportDefault && defaultLocation >= 0)) {\\n    // Replace the binding with one for the namespace itself in order to preserve iteration order.\\n    if (defaultLocation >= 0) {\\n      // Replace the getter with the value\\n      bindings.splice(defaultLocation, 1, BindingTag_Value, raw)\\n    } else {\\n      bindings.push('default', BindingTag_Value, raw)\\n    }\\n  }\\n\\n  esm(ns, bindings)\\n  return ns\\n}\\n\\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\\n  if (typeof raw === 'function') {\\n    return function (this: any, ...args: any[]) {\\n      return raw.apply(this, args)\\n    }\\n  } else {\\n    return Object.create(null)\\n  }\\n}\\n\\nfunction esmImport(\\n  this: TurbopackBaseContext<Module>,\\n  id: ModuleId\\n): Exclude<Module['namespaceObject'], undefined> {\\n  const module = getOrInstantiateModuleFromParent(id, this.m)\\n\\n  // any ES module has to have `module.namespaceObject` defined.\\n  if (module.namespaceObject) return module.namespaceObject\\n\\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\\n  const raw = module.exports\\n  return (module.namespaceObject = interopEsm(\\n    raw,\\n    createNS(raw),\\n    raw && (raw as any).__esModule\\n  ))\\n}\\ncontextPrototype.i = esmImport\\n\\nfunction asyncLoader(\\n  this: TurbopackBaseContext<Module>,\\n  moduleId: ModuleId\\n): Promise<Exports> {\\n  const loader = this.r(moduleId) as (\\n    importFunction: EsmImport\\n  ) => Promise<Exports>\\n  return loader(esmImport.bind(this))\\n}\\ncontextPrototype.A = asyncLoader\\n\\n// Add a simple runtime require so that environments without one can still pass\\n// `typeof require` CommonJS checks so that exports are correctly registered.\\nconst runtimeRequire =\\n  // @ts-ignore\\n  typeof require === 'function'\\n    ? // @ts-ignore\\n      require\\n    : function require() {\\n        throw new Error('Unexpected use of runtime require')\\n      }\\ncontextPrototype.t = runtimeRequire\\n\\nfunction commonJsRequire(\\n  this: TurbopackBaseContext<Module>,\\n  id: ModuleId\\n): Exports {\\n  return getOrInstantiateModuleFromParent(id, this.m).exports\\n}\\ncontextPrototype.r = commonJsRequire\\n\\n/**\\n * `require.context` and require/import expression runtime.\\n */\\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\\n  function moduleContext(id: ModuleId): Exports {\\n    if (hasOwnProperty.call(map, id)) {\\n      return map[id].module()\\n    }\\n\\n    const e = new Error(`Cannot find module '${id}'`)\\n    ;(e as any).code = 'MODULE_NOT_FOUND'\\n    throw e\\n  }\\n\\n  moduleContext.keys = (): ModuleId[] => {\\n    return Object.keys(map)\\n  }\\n\\n  moduleContext.resolve = (id: ModuleId): ModuleId => {\\n    if (hasOwnProperty.call(map, id)) {\\n      return map[id].id()\\n    }\\n\\n    const e = new Error(`Cannot find module '${id}'`)\\n    ;(e as any).code = 'MODULE_NOT_FOUND'\\n    throw e\\n  }\\n\\n  moduleContext.import = async (id: ModuleId) => {\\n    return await (moduleContext(id) as Promise<Exports>)\\n  }\\n\\n  return moduleContext\\n}\\ncontextPrototype.f = moduleContext\\n\\n/**\\n * Returns the path of a chunk defined by its data.\\n */\\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\\n}\\n\\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\\n  return (\\n    maybePromise != null &&\\n    typeof maybePromise === 'object' &&\\n    'then' in maybePromise &&\\n    typeof maybePromise.then === 'function'\\n  )\\n}\\n\\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\\n  return turbopackQueues in obj\\n}\\n\\nfunction createPromise<T>() {\\n  let resolve: (value: T | PromiseLike<T>) => void\\n  let reject: (reason?: any) => void\\n\\n  const promise = new Promise<T>((res, rej) => {\\n    reject = rej\\n    resolve = res\\n  })\\n\\n  return {\\n    promise,\\n    resolve: resolve!,\\n    reject: reject!,\\n  }\\n}\\n\\n// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\\n// The CompressedModuleFactories format is\\n// - 1 or more module ids\\n// - a module factory function\\n// So walking this is a little complex but the flat structure is also fast to\\n// traverse, we can use `typeof` operators to distinguish the two cases.\\nfunction installCompressedModuleFactories(\\n  chunkModules: CompressedModuleFactories,\\n  offset: number,\\n  moduleFactories: ModuleFactories,\\n  newModuleId?: (id: ModuleId) => void\\n) {\\n  let i = offset\\n  while (i < chunkModules.length) {\\n    let moduleId = chunkModules[i] as ModuleId\\n    let end = i + 1\\n    // Find our factory function\\n    while (\\n      end < chunkModules.length &&\\n      typeof chunkModules[end] !== 'function'\\n    ) {\\n      end++\\n    }\\n    if (end === chunkModules.length) {\\n      throw new Error('malformed chunk format, expected a factory function')\\n    }\\n    // Each chunk item has a 'primary id' and optional additional ids. If the primary id is already\\n    // present we know all the additional ids are also present, so we don't need to check.\\n    if (!moduleFactories.has(moduleId)) {\\n      const moduleFactoryFn = chunkModules[end] as Function\\n      applyModuleFactoryName(moduleFactoryFn)\\n      newModuleId?.(moduleId)\\n      for (; i < end; i++) {\\n        moduleId = chunkModules[i] as ModuleId\\n        moduleFactories.set(moduleId, moduleFactoryFn)\\n      }\\n    }\\n    i = end + 1 // end is pointing at the last factory advance to the next id or the end of the array.\\n  }\\n}\\n\\n// everything below is adapted from webpack\\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\\n\\nconst turbopackQueues = Symbol('turbopack queues')\\nconst turbopackExports = Symbol('turbopack exports')\\nconst turbopackError = Symbol('turbopack error')\\n\\nconst enum QueueStatus {\\n  Unknown = -1,\\n  Unresolved = 0,\\n  Resolved = 1,\\n}\\n\\ntype AsyncQueueFn = (() => void) & { queueCount: number }\\ntype AsyncQueue = AsyncQueueFn[] & {\\n  status: QueueStatus\\n}\\n\\nfunction resolveQueue(queue?: AsyncQueue) {\\n  if (queue && queue.status !== QueueStatus.Resolved) {\\n    queue.status = QueueStatus.Resolved\\n    queue.forEach((fn) => fn.queueCount--)\\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\\n  }\\n}\\n\\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\\n\\ntype AsyncModuleExt = {\\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\\n  [turbopackExports]: Exports\\n  [turbopackError]?: any\\n}\\n\\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\\n\\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\\n  return deps.map((dep): AsyncModuleExt => {\\n    if (dep !== null && typeof dep === 'object') {\\n      if (isAsyncModuleExt(dep)) return dep\\n      if (isPromise(dep)) {\\n        const queue: AsyncQueue = Object.assign([], {\\n          status: QueueStatus.Unresolved,\\n        })\\n\\n        const obj: AsyncModuleExt = {\\n          [turbopackExports]: {},\\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\\n        }\\n\\n        dep.then(\\n          (res) => {\\n            obj[turbopackExports] = res\\n            resolveQueue(queue)\\n          },\\n          (err) => {\\n            obj[turbopackError] = err\\n            resolveQueue(queue)\\n          }\\n        )\\n\\n        return obj\\n      }\\n    }\\n\\n    return {\\n      [turbopackExports]: dep,\\n      [turbopackQueues]: () => {},\\n    }\\n  })\\n}\\n\\nfunction asyncModule(\\n  this: TurbopackBaseContext<Module>,\\n  body: (\\n    handleAsyncDependencies: (\\n      deps: Dep[]\\n    ) => Exports[] | Promise<() => Exports[]>,\\n    asyncResult: (err?: any) => void\\n  ) => void,\\n  hasAwait: boolean\\n) {\\n  const module = this.m\\n  const queue: AsyncQueue | undefined = hasAwait\\n    ? Object.assign([], { status: QueueStatus.Unknown })\\n    : undefined\\n\\n  const depQueues: Set<AsyncQueue> = new Set()\\n\\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\\n\\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\\n    [turbopackExports]: module.exports,\\n    [turbopackQueues]: (fn) => {\\n      queue && fn(queue)\\n      depQueues.forEach(fn)\\n      promise['catch'](() => {})\\n    },\\n  } satisfies AsyncModuleExt)\\n\\n  const attributes: PropertyDescriptor = {\\n    get(): any {\\n      return promise\\n    },\\n    set(v: any) {\\n      // Calling `esmExport` leads to this.\\n      if (v !== promise) {\\n        promise[turbopackExports] = v\\n      }\\n    },\\n  }\\n\\n  Object.defineProperty(module, 'exports', attributes)\\n  Object.defineProperty(module, 'namespaceObject', attributes)\\n\\n  function handleAsyncDependencies(deps: Dep[]) {\\n    const currentDeps = wrapDeps(deps)\\n\\n    const getResult = () =>\\n      currentDeps.map((d) => {\\n        if (d[turbopackError]) throw d[turbopackError]\\n        return d[turbopackExports]\\n      })\\n\\n    const { promise, resolve } = createPromise<() => Exports[]>()\\n\\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\\n      queueCount: 0,\\n    })\\n\\n    function fnQueue(q: AsyncQueue) {\\n      if (q !== queue && !depQueues.has(q)) {\\n        depQueues.add(q)\\n        if (q && q.status === QueueStatus.Unresolved) {\\n          fn.queueCount++\\n          q.push(fn)\\n        }\\n      }\\n    }\\n\\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\\n\\n    return fn.queueCount ? promise : getResult()\\n  }\\n\\n  function asyncResult(err?: any) {\\n    if (err) {\\n      reject((promise[turbopackError] = err))\\n    } else {\\n      resolve(promise[turbopackExports])\\n    }\\n\\n    resolveQueue(queue)\\n  }\\n\\n  body(handleAsyncDependencies, asyncResult)\\n\\n  if (queue && queue.status === QueueStatus.Unknown) {\\n    queue.status = QueueStatus.Unresolved\\n  }\\n}\\ncontextPrototype.a = asyncModule\\n\\n/**\\n * A pseudo \\\"fake\\\" URL object to resolve to its relative path.\\n *\\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\\n * hydration mismatch.\\n *\\n * This is based on webpack's existing implementation:\\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\\n */\\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\\n  const realUrl = new URL(inputUrl, 'x:/')\\n  const values: Record<string, any> = {}\\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\\n  values.href = inputUrl\\n  values.pathname = inputUrl.replace(/[?#].*/, '')\\n  values.origin = values.protocol = ''\\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\\n  for (const key in values)\\n    Object.defineProperty(this, key, {\\n      enumerable: true,\\n      configurable: true,\\n      value: values[key],\\n    })\\n}\\nrelativeURL.prototype = URL.prototype\\ncontextPrototype.U = relativeURL\\n\\n/**\\n * Utility function to ensure all variants of an enum are handled.\\n */\\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\\n  throw new Error(`Invariant: ${computeMessage(never)}`)\\n}\\n\\n/**\\n * A stub function to make `require` available but non-functional in ESM.\\n */\\nfunction requireStub(_moduleId: ModuleId): never {\\n  throw new Error('dynamic usage of require is not supported')\\n}\\ncontextPrototype.z = requireStub\\n\\n// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\\ncontextPrototype.g = globalThis\\n\\ntype ContextConstructor<M> = {\\n  new (module: Module, exports: Exports): TurbopackBaseContext<M>\\n}\\n\\nfunction applyModuleFactoryName(factory: Function) {\\n  // Give the module factory a nice name to improve stack traces.\\n  Object.defineProperty(factory, 'name', {\\n    value: '__TURBOPACK__module__evaluation__',\\n  })\\n}\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}},\n+    {\"offset\": {\"line\": 483, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/base-externals-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n\\n/// A 'base' utilities to support runtime can have externals.\\n/// Currently this is for node.js / edge runtime both.\\n/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\\n\\nasync function externalImport(id: DependencySpecifier) {\\n  let raw\\n  try {\\n    raw = await import(id)\\n  } catch (err) {\\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\\n    // an external module we don't provide a shim for (e.g. querystring, url).\\n    // For now, we fail semi-silently, but in the future this should be a\\n    // compilation error.\\n    throw new Error(`Failed to load external module ${id}: ${err}`)\\n  }\\n\\n  if (raw && raw.__esModule && raw.default && 'default' in raw.default) {\\n    return interopEsm(raw.default, createNS(raw), true)\\n  }\\n\\n  return raw\\n}\\ncontextPrototype.y = externalImport\\n\\nfunction externalRequire(\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm: boolean = false\\n): Exports | EsmNamespaceObject {\\n  let raw\\n  try {\\n    raw = thunk()\\n  } catch (err) {\\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\\n    // an external module we don't provide a shim for (e.g. querystring, url).\\n    // For now, we fail semi-silently, but in the future this should be a\\n    // compilation error.\\n    throw new Error(`Failed to load external module ${id}: ${err}`)\\n  }\\n\\n  if (!esm || raw.__esModule) {\\n    return raw\\n  }\\n\\n  return interopEsm(raw, createNS(raw), true)\\n}\\n\\nexternalRequire.resolve = (\\n  id: string,\\n  options?: {\\n    paths?: string[]\\n  }\\n) => {\\n  return require.resolve(id, options)\\n}\\ncontextPrototype.x = externalRequire\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,6DAA6D;AAC7D,sDAAsD;AACtD,qGAAqG;AAErG,eAAe,eAAe,EAAuB;IACnD,IAAI;IACJ,IAAI;QACF,MAAM,MAAM,MAAM,CAAC;IACrB,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,OAAO,IAAI,UAAU,IAAI,IAAI,OAAO,IAAI,aAAa,IAAI,OAAO,EAAE;QACpE,OAAO,WAAW,IAAI,OAAO,EAAE,SAAS,MAAM;IAChD;IAEA,OAAO;AACT;AACA,iBAAiB,CAAC,GAAG;AAErB,SAAS,gBACP,EAAY,EACZ,KAAgB,EAChB,MAAe,KAAK;IAEpB,IAAI;IACJ,IAAI;QACF,MAAM;IACR,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,CAAC,OAAO,IAAI,UAAU,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO,WAAW,KAAK,SAAS,MAAM;AACxC;AAEA,gBAAgB,OAAO,GAAG,CACxB,IACA;IAIA,OAAO,QAAQ,OAAO,CAAC,IAAI;AAC7B;AACA,iBAAiB,CAAC,GAAG\",\"ignoreList\":[0]}},\n+    {\"offset\": {\"line\": 524, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/node-externals-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\ndeclare var RUNTIME_PUBLIC_PATH: string\\ndeclare var RELATIVE_ROOT_PATH: string\\ndeclare var ASSET_PREFIX: string\\n\\nconst path = require('path')\\n\\nconst relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, '.')\\n// Compute the relative path to the `distDir`.\\nconst relativePathToDistRoot = path.join(\\n  relativePathToRuntimeRoot,\\n  RELATIVE_ROOT_PATH\\n)\\nconst RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot)\\n// Compute the absolute path to the root, by stripping distDir from the absolute path to this file.\\nconst ABSOLUTE_ROOT = path.resolve(__filename, relativePathToDistRoot)\\n\\n/**\\n * Returns an absolute path to the given module path.\\n * Module path should be relative, either path to a file or a directory.\\n *\\n * This fn allows to calculate an absolute path for some global static values, such as\\n * `__dirname` or `import.meta.url` that Turbopack will not embeds in compile time.\\n * See ImportMetaBinding::code_generation for the usage.\\n */\\nfunction resolveAbsolutePath(modulePath?: string): string {\\n  if (modulePath) {\\n    return path.join(ABSOLUTE_ROOT, modulePath)\\n  }\\n  return ABSOLUTE_ROOT\\n}\\nContext.prototype.P = resolveAbsolutePath\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAMpD,MAAM,OAAO,QAAQ;AAErB,MAAM,4BAA4B,KAAK,QAAQ,CAAC,qBAAqB;AACrE,8CAA8C;AAC9C,MAAM,yBAAyB,KAAK,IAAI,CACtC,2BACA;AAEF,MAAM,eAAe,KAAK,OAAO,CAAC,YAAY;AAC9C,mGAAmG;AACnG,MAAM,gBAAgB,KAAK,OAAO,CAAC,YAAY;AAE/C;;;;;;;CAOC,GACD,SAAS,oBAAoB,UAAmB;IAC9C,IAAI,YAAY;QACd,OAAO,KAAK,IAAI,CAAC,eAAe;IAClC;IACA,OAAO;AACT;AACA,QAAQ,SAAS,CAAC,CAAC,GAAG\",\"ignoreList\":[0]}},\n+    {\"offset\": {\"line\": 545, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/node-wasm-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n\\nfunction readWebAssemblyAsResponse(path: string) {\\n  const { createReadStream } = require('fs') as typeof import('fs')\\n  const { Readable } = require('stream') as typeof import('stream')\\n\\n  const stream = createReadStream(path)\\n\\n  // @ts-ignore unfortunately there's a slight type mismatch with the stream.\\n  return new Response(Readable.toWeb(stream), {\\n    headers: {\\n      'content-type': 'application/wasm',\\n    },\\n  })\\n}\\n\\nasync function compileWebAssemblyFromPath(\\n  path: string\\n): Promise<WebAssembly.Module> {\\n  const response = readWebAssemblyAsResponse(path)\\n\\n  return await WebAssembly.compileStreaming(response)\\n}\\n\\nasync function instantiateWebAssemblyFromPath(\\n  path: string,\\n  importsObj: WebAssembly.Imports\\n): Promise<Exports> {\\n  const response = readWebAssemblyAsResponse(path)\\n\\n  const { instance } = await WebAssembly.instantiateStreaming(\\n    response,\\n    importsObj\\n  )\\n\\n  return instance.exports\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,SAAS,0BAA0B,IAAY;IAC7C,MAAM,EAAE,gBAAgB,EAAE,GAAG,QAAQ;IACrC,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ;IAE7B,MAAM,SAAS,iBAAiB;IAEhC,2EAA2E;IAC3E,OAAO,IAAI,SAAS,SAAS,KAAK,CAAC,SAAS;QAC1C,SAAS;YACP,gBAAgB;QAClB;IACF;AACF;AAEA,eAAe,2BACb,IAAY;IAEZ,MAAM,WAAW,0BAA0B;IAE3C,OAAO,MAAM,YAAY,gBAAgB,CAAC;AAC5C;AAEA,eAAe,+BACb,IAAY,EACZ,UAA+B;IAE/B,MAAM,WAAW,0BAA0B;IAE3C,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,YAAY,oBAAoB,CACzD,UACA;IAGF,OAAO,SAAS,OAAO;AACzB\",\"ignoreList\":[0]}},\n+    {\"offset\": {\"line\": 566, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/nodejs/runtime.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/base-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-wasm-utils.ts\\\" />\\n\\nenum SourceType {\\n  /**\\n   * The module was instantiated because it was included in an evaluated chunk's\\n   * runtime.\\n   * SourceData is a ChunkPath.\\n   */\\n  Runtime = 0,\\n  /**\\n   * The module was instantiated because a parent module imported it.\\n   * SourceData is a ModuleId.\\n   */\\n  Parent = 1,\\n}\\n\\ntype SourceData = ChunkPath | ModuleId\\n\\nprocess.env.TURBOPACK = '1'\\n\\ninterface TurbopackNodeBuildContext extends TurbopackBaseContext<Module> {\\n  R: ResolvePathFromModule\\n  x: ExternalRequire\\n  y: ExternalImport\\n}\\n\\nconst nodeContextPrototype = Context.prototype as TurbopackNodeBuildContext\\n\\ntype ModuleFactory = (\\n  this: Module['exports'],\\n  context: TurbopackNodeBuildContext\\n) => unknown\\n\\nconst url = require('url') as typeof import('url')\\n\\nconst moduleFactories: ModuleFactories = new Map()\\nnodeContextPrototype.M = moduleFactories\\nconst moduleCache: ModuleCache<Module> = Object.create(null)\\nnodeContextPrototype.c = moduleCache\\n\\n/**\\n * Returns an absolute path to the given module's id.\\n */\\nfunction resolvePathFromModule(\\n  this: TurbopackBaseContext<Module>,\\n  moduleId: string\\n): string {\\n  const exported = this.r(moduleId)\\n  const exportedPath = exported?.default ?? exported\\n  if (typeof exportedPath !== 'string') {\\n    return exported as any\\n  }\\n\\n  const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length)\\n  const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix)\\n\\n  return url.pathToFileURL(resolved).href\\n}\\nnodeContextPrototype.R = resolvePathFromModule\\n\\nfunction loadRuntimeChunk(sourcePath: ChunkPath, chunkData: ChunkData): void {\\n  if (typeof chunkData === 'string') {\\n    loadRuntimeChunkPath(sourcePath, chunkData)\\n  } else {\\n    loadRuntimeChunkPath(sourcePath, chunkData.path)\\n  }\\n}\\n\\nconst loadedChunks = new Set<ChunkPath>()\\nconst unsupportedLoadChunk = Promise.resolve(undefined)\\nconst loadedChunk: Promise<void> = Promise.resolve(undefined)\\nconst chunkCache = new Map<ChunkPath, Promise<void>>()\\n\\nfunction clearChunkCache() {\\n  chunkCache.clear()\\n}\\n\\nfunction loadRuntimeChunkPath(\\n  sourcePath: ChunkPath,\\n  chunkPath: ChunkPath\\n): void {\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return\\n  }\\n\\n  if (loadedChunks.has(chunkPath)) {\\n    return\\n  }\\n\\n  try {\\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n    const chunkModules: CompressedModuleFactories = require(resolved)\\n    installCompressedModuleFactories(chunkModules, 0, moduleFactories)\\n    loadedChunks.add(chunkPath)\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`\\n\\n    if (sourcePath) {\\n      errorMessage += ` from runtime for chunk ${sourcePath}`\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    })\\n  }\\n}\\n\\nfunction loadChunkAsync(\\n  this: TurbopackBaseContext<Module>,\\n  chunkData: ChunkData\\n): Promise<void> {\\n  const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return unsupportedLoadChunk\\n  }\\n\\n  let entry = chunkCache.get(chunkPath)\\n  if (entry === undefined) {\\n    try {\\n      // resolve to an absolute path to simplify `require` handling\\n      const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n      // TODO: consider switching to `import()` to enable concurrent chunk loading and async file io\\n      // However this is incompatible with hot reloading (since `import` doesn't use the require cache)\\n      const chunkModules: CompressedModuleFactories = require(resolved)\\n      installCompressedModuleFactories(chunkModules, 0, moduleFactories)\\n      entry = loadedChunk\\n    } catch (e) {\\n      const errorMessage = `Failed to load chunk ${chunkPath} from module ${this.m.id}`\\n\\n      // Cache the failure promise, future requests will also get this same rejection\\n      entry = Promise.reject(\\n        new Error(errorMessage, {\\n          cause: e,\\n        })\\n      )\\n    }\\n    chunkCache.set(chunkPath, entry)\\n  }\\n  // TODO: Return an instrumented Promise that React can use instead of relying on referential equality.\\n  return entry\\n}\\ncontextPrototype.l = loadChunkAsync\\n\\nfunction loadChunkAsyncByUrl(\\n  this: TurbopackBaseContext<Module>,\\n  chunkUrl: string\\n) {\\n  const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath\\n  return loadChunkAsync.call(this, path)\\n}\\ncontextPrototype.L = loadChunkAsyncByUrl\\n\\nfunction loadWebAssembly(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module,\\n  imports: WebAssembly.Imports\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return instantiateWebAssemblyFromPath(resolved, imports)\\n}\\ncontextPrototype.w = loadWebAssembly\\n\\nfunction loadWebAssemblyModule(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return compileWebAssemblyFromPath(resolved)\\n}\\ncontextPrototype.u = loadWebAssemblyModule\\n\\nfunction getWorkerBlobURL(_chunks: ChunkPath[]): string {\\n  throw new Error('Worker blobs are not implemented yet for Node.js')\\n}\\n\\nnodeContextPrototype.b = getWorkerBlobURL\\n\\nfunction instantiateModule(\\n  id: ModuleId,\\n  sourceType: SourceType,\\n  sourceData: SourceData\\n): Module {\\n  const moduleFactory = moduleFactories.get(id)\\n  if (typeof moduleFactory !== 'function') {\\n    // This can happen if modules incorrectly handle HMR disposes/updates,\\n    // e.g. when they keep a `setTimeout` around which still executes old code\\n    // and contains e.g. a `require(\\\"something\\\")` call.\\n    let instantiationReason: string\\n    switch (sourceType) {\\n      case SourceType.Runtime:\\n        instantiationReason = `as a runtime entry of chunk ${sourceData}`\\n        break\\n      case SourceType.Parent:\\n        instantiationReason = `because it was required from module ${sourceData}`\\n        break\\n      default:\\n        invariant(\\n          sourceType,\\n          (sourceType) => `Unknown source type: ${sourceType}`\\n        )\\n    }\\n    throw new Error(\\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available.`\\n    )\\n  }\\n\\n  const module: Module = createModuleObject(id)\\n  const exports = module.exports\\n  moduleCache[id] = module\\n\\n  const context = new (Context as any as ContextConstructor<Module>)(\\n    module,\\n    exports\\n  )\\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\\n  try {\\n    moduleFactory(context, module, exports)\\n  } catch (error) {\\n    module.error = error as any\\n    throw error\\n  }\\n\\n  module.loaded = true\\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\\n    interopEsm(module.exports, module.namespaceObject)\\n  }\\n\\n  return module\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it if it is not cached.\\n */\\n// @ts-ignore\\nfunction getOrInstantiateModuleFromParent(\\n  id: ModuleId,\\n  sourceModule: Module\\n): Module {\\n  const module = moduleCache[id]\\n\\n  if (module) {\\n    if (module.error) {\\n      throw module.error\\n    }\\n\\n    return module\\n  }\\n\\n  return instantiateModule(id, SourceType.Parent, sourceModule.id)\\n}\\n\\n/**\\n * Instantiates a runtime module.\\n */\\nfunction instantiateRuntimeModule(\\n  chunkPath: ChunkPath,\\n  moduleId: ModuleId\\n): Module {\\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\\n */\\n// @ts-ignore TypeScript doesn't separate this module space from the browser runtime\\nfunction getOrInstantiateRuntimeModule(\\n  chunkPath: ChunkPath,\\n  moduleId: ModuleId\\n): Module {\\n  const module = moduleCache[moduleId]\\n  if (module) {\\n    if (module.error) {\\n      throw module.error\\n    }\\n    return module\\n  }\\n\\n  return instantiateRuntimeModule(chunkPath, moduleId)\\n}\\n\\nconst regexJsUrl = /\\\\.js(?:\\\\?[^#]*)?(?:#.*)?$/\\n/**\\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\\n */\\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\\n  return regexJsUrl.test(chunkUrlOrPath)\\n}\\n\\nmodule.exports = (sourcePath: ChunkPath) => ({\\n  m: (id: ModuleId) => getOrInstantiateRuntimeModule(sourcePath, id),\\n  c: (chunkData: ChunkData) => loadRuntimeChunk(sourcePath, chunkData),\\n})\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}}]\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "6da838029da579373791b48c0063f7581b1491a5",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/node/output/aaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_node_input_index_b515b56f.js",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_node_input_index_b515b56f.js",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_node_input_index_b515b56f.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_node_input_index_b515b56f.js?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1,10 @@\n+;!function(){try { var e=\"undefined\"!=typeof globalThis?globalThis:\"undefined\"!=typeof global?global:\"undefined\"!=typeof window?window:\"undefined\"!=typeof self?self:{},n=(new e.Error).stack;n&&((e._debugIds|| (e._debugIds={}))[n]=\"3d97c2d1-90e5-a3ef-c710-5c78b21b3b3a\")}catch(e){}}();\n+module.exports = [\n+\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/node/input/index.js [test] (ecmascript)\", ((__turbopack_context__, module, exports) => {\n+\n+console.log('Hello World');\n+}),\n+];\n+\n+//# debugId=3d97c2d1-90e5-a3ef-c710-5c78b21b3b3a\n+//# sourceMappingURL=aaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_node_input_index_b515b56f.js.map\n\\ No newline at end of file"
        },
        {
            "sha": "f2ee6c74569091fb396c76be0c69f32470fe557e",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/node/output/aaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_node_input_index_b515b56f.js.map",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_node_input_index_b515b56f.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_node_input_index_b515b56f.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_node_input_index_b515b56f.js.map?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1,7 @@\n+{\n+  \"version\": 3,\n+  \"sources\": [],\n+  \"debugId\": \"3d97c2d1-90e5-a3ef-c710-5c78b21b3b3a\",\n+  \"sections\": [\n+    {\"offset\": {\"line\": 4, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/node/input/index.js\"],\"sourcesContent\":[\"console.log('Hello World')\\n\"],\"names\":[],\"mappings\":\"AAAA,QAAQ,GAAG,CAAC\"}}]\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "4fc0e1aaee07f02389ca5804cc6686d71bb455f8",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/node/output/index.entry.js",
            "status": "added",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2Findex.entry.js",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2Findex.entry.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2Findex.entry.js?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1,4 @@\n+var R=require(\"./[turbopack]_runtime.js\")(\"output/index.entry.js\")\n+R.c(\"output/aaf3a_crates_turbopack-tests_tests_snapshot_debug-ids_node_input_index_b515b56f.js\")\n+R.m(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/node/input/index.js [test] (ecmascript)\")\n+module.exports=R.m(\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/node/input/index.js [test] (ecmascript)\").exports\n\\ No newline at end of file"
        },
        {
            "sha": "c15d7ec00382d3604310ddb8b53cbdb90d9e1942",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/debug-ids/node/output/index.entry.js.map",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2Findex.entry.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/624a01400906c55015fa20d2f730f4b108a2b675/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2Findex.entry.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fdebug-ids%2Fnode%2Foutput%2Findex.entry.js.map?ref=624a01400906c55015fa20d2f730f4b108a2b675",
            "patch": "@@ -0,0 +1,5 @@\n+{\n+  \"version\": 3,\n+  \"sources\": [],\n+  \"sections\": []\n+}\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 3133,
        "additions": 3025,
        "deletions": 108
    }
}