{
    "author": "acdlite",
    "message": "Remove param values from static route tree (#82376)\n\nRemoves the param values from the router tree sent by the server during\na client-side prefetch.\n    \nThis increases the cacheability of prefetch responses because if the\nresponse does not include a certain param in the component data, it can\nbe reused for all possible values of that param. Previously this was not\npossible because even if the components did not reference a param, it\nwas included in the router tree regardless.\n    \nThis does not affect the router tree sent during dynamic navigations, or\nduring initial render. We should remove the param values from those\nresponses, too, both for consistency and to increase the cacheability of\nHTML fallback responses. That work will land in future PRs.",
    "sha": "d016157ce646565a6ca806afa260e1ceb89b063e",
    "files": [
        {
            "sha": "31e4920de28763e9820d6e2c27879cbcf4dfd38f",
            "filename": "packages/next/src/client/components/router-reducer/fetch-server-response.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 20,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/d016157ce646565a6ca806afa260e1ceb89b063e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d016157ce646565a6ca806afa260e1ceb89b063e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts?ref=d016157ce646565a6ca806afa260e1ceb89b063e",
            "patch": "@@ -31,7 +31,10 @@ import {\n } from '../../flight-data-helpers'\n import { getAppBuildId } from '../../app-build-id'\n import { setCacheBustingSearchParam } from './set-cache-busting-search-param'\n-import { getRenderedPathname } from '../../route-params'\n+import {\n+  getRenderedPathname,\n+  urlToUrlWithoutFlightMarker,\n+} from '../../route-params'\n \n const createFromReadableStream =\n   createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\n@@ -64,26 +67,11 @@ export type RequestHeaders = {\n   'Next-Test-Fetch-Priority'?: RequestInit['priority']\n }\n \n-export function urlToUrlWithoutFlightMarker(url: string): URL {\n-  const urlWithoutFlightParameters = new URL(url, location.origin)\n-  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n-  if (process.env.NODE_ENV === 'production') {\n-    if (\n-      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n-      urlWithoutFlightParameters.pathname.endsWith('.txt')\n-    ) {\n-      const { pathname } = urlWithoutFlightParameters\n-      const length = pathname.endsWith('/index.txt') ? 10 : 4\n-      // Slice off `/index.txt` or `.txt` from the end of the pathname\n-      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n-    }\n-  }\n-  return urlWithoutFlightParameters\n-}\n-\n function doMpaNavigation(url: string): FetchServerResponseResult {\n   return {\n-    flightData: urlToUrlWithoutFlightMarker(url).toString(),\n+    flightData: urlToUrlWithoutFlightMarker(\n+      new URL(url, location.origin)\n+    ).toString(),\n     canonicalUrl: undefined,\n     couldBeIntercepted: false,\n     prerendered: false,\n@@ -180,7 +168,7 @@ export async function fetchServerResponse(\n       abortController.signal\n     )\n \n-    const responseUrl = urlToUrlWithoutFlightMarker(res.url)\n+    const responseUrl = urlToUrlWithoutFlightMarker(new URL(res.url))\n     const canonicalUrl = res.redirected ? responseUrl : undefined\n \n     const contentType = res.headers.get('content-type') || ''"
        },
        {
            "sha": "5388b4fff0ae94442a128d04896326ce0a128a9c",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 67,
            "deletions": 40,
            "changes": 107,
            "blob_url": "https://github.com/vercel/next.js/blob/d016157ce646565a6ca806afa260e1ceb89b063e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d016157ce646565a6ca806afa260e1ceb89b063e/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=d016157ce646565a6ca806afa260e1ceb89b063e",
            "patch": "@@ -45,6 +45,7 @@ import type {\n } from './cache-key'\n import {\n   doesStaticSegmentAppearInURL,\n+  getCacheKeyForDynamicParam,\n   getRenderedPathname,\n   getRenderedSearch,\n   parseDynamicParamFromURLPart,\n@@ -900,8 +901,11 @@ function convertRootTreePrefetchToRouteTree(\n   // Remove trailing and leading slashes\n   const pathnameParts = renderedPathname.split('/').filter((p) => p !== '')\n   const index = 0\n+  const rootSegment = ROOT_SEGMENT_CACHE_KEY\n   return convertTreePrefetchToRouteTree(\n     rootTree.tree,\n+    rootSegment,\n+    null,\n     ROOT_SEGMENT_REQUEST_KEY,\n     ROOT_SEGMENT_CACHE_KEY,\n     pathnameParts,\n@@ -911,6 +915,8 @@ function convertRootTreePrefetchToRouteTree(\n \n function convertTreePrefetchToRouteTree(\n   prefetch: TreePrefetch,\n+  segment: FlightRouterStateSegment,\n+  param: RouteParam | null,\n   requestKey: SegmentRequestKey,\n   cacheKey: SegmentCacheKey,\n   pathnameParts: Array<string>,\n@@ -922,52 +928,71 @@ function convertTreePrefetchToRouteTree(\n   // it once instead of on every access. This same cache key is also used to\n   // request the segment from the server.\n \n-  let segment = prefetch.segment\n-\n-  let doesAppearInURL: boolean\n-  let param: RouteParam | null = null\n-  if (Array.isArray(segment)) {\n-    // This segment is parameterized. Get the param from the pathname.\n-    const paramType = segment[2] as DynamicParamTypesShort\n-    const paramValue = parseDynamicParamFromURLPart(\n-      paramType,\n-      pathnameParts,\n-      pathnamePartsIndex\n-    )\n-    param = {\n-      name: segment[0],\n-      value: paramValue,\n-      type: paramType,\n-    }\n-\n-    // Assign a cache key to the segment, based on the param value. In the\n-    // pre-Segment Cache implementation, the server computes this and sends it\n-    // in the body of the response. In the Segment Cache implementation, the\n-    // server sends an empty string and we fill it in here.\n-    // TODO: This will land in a follow up PR.\n-    // segment[1] = getCacheKeyForDynamicParam(paramValue)\n-\n-    doesAppearInURL = true\n-  } else {\n-    doesAppearInURL = doesStaticSegmentAppearInURL(segment)\n-  }\n-\n-  // Only increment the index if the segment appears in the URL. If it's a\n-  // \"virtual\" segment, like a route group, it remains the same.\n-  const childPathnamePartsIndex = doesAppearInURL\n-    ? pathnamePartsIndex + 1\n-    : pathnamePartsIndex\n-\n   let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n   const prefetchSlots = prefetch.slots\n   if (prefetchSlots !== null) {\n     slots = {}\n     for (let parallelRouteKey in prefetchSlots) {\n       const childPrefetch = prefetchSlots[parallelRouteKey]\n-      const childSegment = childPrefetch.segment\n-      // TODO: Eventually, the param values will not be included in the response\n-      // from the server. We'll instead fill them in on the client by parsing\n-      // the URL. This is where we'll do that.\n+      const childParamName = childPrefetch.name\n+      const childParamType = childPrefetch.paramType\n+      const childServerSentParamKey = childPrefetch.paramKey\n+\n+      let childDoesAppearInURL: boolean\n+      let childParam: RouteParam | null = null\n+      let childSegment: FlightRouterStateSegment\n+      if (childParamType !== null) {\n+        // This segment is parameterized. Get the param from the pathname.\n+        const childParamValue = parseDynamicParamFromURLPart(\n+          childParamType,\n+          pathnameParts,\n+          pathnamePartsIndex\n+        )\n+\n+        // Assign a cache key to the segment, based on the param value. In the\n+        // pre-Segment Cache implementation, the server computes this and sends\n+        // it in the body of the response. In the Segment Cache implementation,\n+        // the server sends an empty string and we fill it in here.\n+\n+        // TODO: We're intentionally not adding the search param to page\n+        // segments here; it's tracked separately and added back during a read.\n+        // This would clearer if we waited to construct the segment until it's\n+        // read from the cache, since that's effectively what we're\n+        // doing anyway.\n+        const renderedSearch = '' as NormalizedSearch\n+        const childParamKey =\n+          // The server omits this field from the prefetch response when\n+          // clientParamParsing is enabled. The flag only exists while we're\n+          // testing the feature, in case there's a bug and we need to revert.\n+          // TODO: Remove once clientParamParsing is enabled everywhere.\n+          childServerSentParamKey !== null\n+            ? childServerSentParamKey\n+            : // If no param key was sent, use the value parsed on the client.\n+              getCacheKeyForDynamicParam(childParamValue, renderedSearch)\n+\n+        childParam = {\n+          name: childParamName,\n+          value: childParamValue,\n+          type: childParamType,\n+        }\n+        childSegment = [\n+          childParamName,\n+          childParamKey,\n+          childParamType,\n+          childParamValue,\n+        ]\n+        childDoesAppearInURL = true\n+      } else {\n+        childSegment = childParamName\n+        childDoesAppearInURL = doesStaticSegmentAppearInURL(childParamName)\n+      }\n+\n+      // Only increment the index if the segment appears in the URL. If it's a\n+      // \"virtual\" segment, like a route group, it remains the same.\n+      const childPathnamePartsIndex = childDoesAppearInURL\n+        ? pathnamePartsIndex + 1\n+        : pathnamePartsIndex\n+\n       const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n       const childRequestKey = appendSegmentRequestKeyPart(\n         requestKey,\n@@ -981,6 +1006,8 @@ function convertTreePrefetchToRouteTree(\n       )\n       slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n         childPrefetch,\n+        childSegment,\n+        childParam,\n         childRequestKey,\n         childCacheKey,\n         pathnameParts,"
        },
        {
            "sha": "15900ae1860ff3e8bcd0e64d461f776002b9f1a5",
            "filename": "packages/next/src/client/route-params.ts",
            "status": "modified",
            "additions": 49,
            "deletions": 12,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/d016157ce646565a6ca806afa260e1ceb89b063e/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d016157ce646565a6ca806afa260e1ceb89b063e/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts?ref=d016157ce646565a6ca806afa260e1ceb89b063e",
            "patch": "@@ -1,14 +1,19 @@\n import type { DynamicParamTypesShort } from '../server/app-render/types'\n-import { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\n+import {\n+  addSearchParamsIfPageSegment,\n+  DEFAULT_SEGMENT_KEY,\n+  PAGE_SEGMENT_KEY,\n+} from '../shared/lib/segment'\n import { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\n import {\n   NEXT_REWRITTEN_PATH_HEADER,\n   NEXT_REWRITTEN_QUERY_HEADER,\n+  NEXT_RSC_UNION_QUERY,\n } from './components/app-router-headers'\n-import type { RSCResponse } from './components/router-reducer/fetch-server-response'\n import type { NormalizedSearch } from './components/segment-cache'\n+import type { RSCResponse } from './components/router-reducer/fetch-server-response'\n \n-type RouteParamValue = string | Array<string> | null\n+export type RouteParamValue = string | Array<string> | null\n \n export type RouteParam = {\n   name: string\n@@ -28,15 +33,18 @@ export function getRenderedSearch(response: RSCResponse): NormalizedSearch {\n   }\n   // If the header is not present, there was no rewrite, so we use the search\n   // query of the response URL.\n-  return new URL(response.url).search as NormalizedSearch\n+  return urlToUrlWithoutFlightMarker(new URL(response.url))\n+    .search as NormalizedSearch\n }\n \n export function getRenderedPathname(response: RSCResponse): string {\n   // If the server performed a rewrite, the pathname used to render the\n   // page will be different from the pathname in the request URL. In this case,\n   // the response will include a header that gives the rewritten pathname.\n   const rewrittenPath = response.headers.get(NEXT_REWRITTEN_PATH_HEADER)\n-  return rewrittenPath ?? new URL(response.url).pathname\n+  return (\n+    rewrittenPath ?? urlToUrlWithoutFlightMarker(new URL(response.url)).pathname\n+  )\n }\n \n export function parseDynamicParamFromURLPart(\n@@ -101,7 +109,9 @@ export function doesStaticSegmentAppearInURL(segment: string): boolean {\n     // TODO: Investigate why the loader produces these fake page segments.\n     segment.startsWith(PAGE_SEGMENT_KEY) ||\n     // Route groups.\n-    (segment[0] === '(' && segment.endsWith(')'))\n+    (segment[0] === '(' && segment.endsWith(')')) ||\n+    segment === DEFAULT_SEGMENT_KEY ||\n+    segment === '/_not-found'\n   ) {\n     return false\n   } else {\n@@ -111,14 +121,41 @@ export function doesStaticSegmentAppearInURL(segment: string): boolean {\n }\n \n export function getCacheKeyForDynamicParam(\n-  paramValue: RouteParamValue\n+  paramValue: RouteParamValue,\n+  renderedSearch: NormalizedSearch\n ): string {\n   // This needs to match the logic in get-dynamic-param.ts, until we're able to\n   // unify the various implementations so that these are always computed on\n   // the client.\n-  return typeof paramValue === 'string'\n-    ? paramValue\n-    : paramValue === null\n-      ? ''\n-      : paramValue.join('/')\n+  if (typeof paramValue === 'string') {\n+    // TODO: Refactor or remove this helper function to accept a string rather\n+    // than the whole segment type. Also we can probably just append the\n+    // search string instead of turning it into JSON.\n+    const pageSegmentWithSearchParams = addSearchParamsIfPageSegment(\n+      paramValue,\n+      Object.fromEntries(new URLSearchParams(renderedSearch))\n+    ) as string\n+    return pageSegmentWithSearchParams\n+  } else if (paramValue === null) {\n+    return ''\n+  } else {\n+    return paramValue.join('/')\n+  }\n+}\n+\n+export function urlToUrlWithoutFlightMarker(url: URL): URL {\n+  const urlWithoutFlightParameters = new URL(url)\n+  urlWithoutFlightParameters.searchParams.delete(NEXT_RSC_UNION_QUERY)\n+  if (process.env.NODE_ENV === 'production') {\n+    if (\n+      process.env.__NEXT_CONFIG_OUTPUT === 'export' &&\n+      urlWithoutFlightParameters.pathname.endsWith('.txt')\n+    ) {\n+      const { pathname } = urlWithoutFlightParameters\n+      const length = pathname.endsWith('/index.txt') ? 10 : 4\n+      // Slice off `/index.txt` or `.txt` from the end of the pathname\n+      urlWithoutFlightParameters.pathname = pathname.slice(0, -length)\n+    }\n+  }\n+  return urlWithoutFlightParameters\n }"
        },
        {
            "sha": "69e6ccc38c18eed4a953ddcbcb7c88b1f4db4d33",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/d016157ce646565a6ca806afa260e1ceb89b063e/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d016157ce646565a6ca806afa260e1ceb89b063e/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=d016157ce646565a6ca806afa260e1ceb89b063e",
            "patch": "@@ -4679,6 +4679,7 @@ async function collectSegmentData(\n \n   const staleTime = prerenderStore.stale\n   return await ComponentMod.collectSegmentData(\n+    renderOpts.experimental.clientParamParsing,\n     fullPageDataBuffer,\n     staleTime,\n     clientReferenceManifest.clientModules as ManifestNode,"
        },
        {
            "sha": "709eb98a5ccb323631d954b2f5f4350e293ed771",
            "filename": "packages/next/src/server/app-render/collect-segment-data.tsx",
            "status": "modified",
            "additions": 36,
            "deletions": 4,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/d016157ce646565a6ca806afa260e1ceb89b063e/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d016157ce646565a6ca806afa260e1ceb89b063e/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx?ref=d016157ce646565a6ca806afa260e1ceb89b063e",
            "patch": "@@ -2,7 +2,7 @@ import type {\n   CacheNodeSeedData,\n   FlightRouterState,\n   InitialRSCPayload,\n-  Segment as FlightRouterStateSegment,\n+  DynamicParamTypesShort,\n } from './types'\n import type { ManifestNode } from '../../build/webpack/plugins/flight-manifest-plugin'\n \n@@ -39,8 +39,13 @@ export type RootTreePrefetch = {\n }\n \n export type TreePrefetch = {\n-  // The segment, in the format expected by a FlightRouterState.\n-  segment: FlightRouterStateSegment\n+  name: string\n+  paramType: DynamicParamTypesShort | null\n+  // TODO: When clientParamParsing is enabled, this field is always null.\n+  // Instead we parse the param on the client, allowing us to omit it from\n+  // the prefetch response and increase its cacheability. Remove this field\n+  // once clientParamParsing is enabled everywhere.\n+  paramKey: string | null\n \n   // Child segments.\n   slots: null | {\n@@ -83,6 +88,7 @@ function onSegmentPrerenderError(error: unknown) {\n }\n \n export async function collectSegmentData(\n+  isClientParamParsingEnabled: boolean,\n   fullPageDataBuffer: Buffer,\n   staleTime: number,\n   clientModules: ManifestNode,\n@@ -127,6 +133,7 @@ export async function collectSegmentData(\n     // inside of it, the side effects are transferred to the new stream.\n     // @ts-expect-error\n     <PrefetchTreeData\n+      isClientParamParsingEnabled={isClientParamParsingEnabled}\n       fullPageDataBuffer={fullPageDataBuffer}\n       serverConsumerManifest={serverConsumerManifest}\n       clientModules={clientModules}\n@@ -157,13 +164,15 @@ export async function collectSegmentData(\n }\n \n async function PrefetchTreeData({\n+  isClientParamParsingEnabled,\n   fullPageDataBuffer,\n   serverConsumerManifest,\n   clientModules,\n   staleTime,\n   segmentTasks,\n   onCompletedProcessingRouteTree,\n }: {\n+  isClientParamParsingEnabled: boolean\n   fullPageDataBuffer: Buffer\n   serverConsumerManifest: any\n   clientModules: ManifestNode\n@@ -203,6 +212,7 @@ async function PrefetchTreeData({\n   // walk the tree, we will also spawn a task to produce a prefetch response for\n   // each segment.\n   const tree = collectSegmentDataImpl(\n+    isClientParamParsingEnabled,\n     flightRouterState,\n     buildId,\n     seedData,\n@@ -230,6 +240,7 @@ async function PrefetchTreeData({\n }\n \n function collectSegmentDataImpl(\n+  isClientParamParsingEnabled: boolean,\n   route: FlightRouterState,\n   buildId: string,\n   seedData: CacheNodeSeedData | null,\n@@ -255,6 +266,7 @@ function collectSegmentDataImpl(\n       createSegmentRequestKeyPart(childSegment)\n     )\n     const childTree = collectSegmentDataImpl(\n+      isClientParamParsingEnabled,\n       childRoute,\n       buildId,\n       childSeedData,\n@@ -285,10 +297,30 @@ function collectSegmentDataImpl(\n     // ever happen in practice, though.\n   }\n \n+  const segment = route[0]\n+  let name\n+  let paramType: DynamicParamTypesShort | null = null\n+  let paramKey: string | null = null\n+  if (typeof segment === 'string') {\n+    name = segment\n+    paramKey = segment\n+    paramType = null\n+  } else {\n+    name = segment[0]\n+    paramKey = segment[1]\n+    paramType = segment[2] as DynamicParamTypesShort\n+  }\n+\n   // Metadata about the segment. Sent to the client as part of the\n   // tree prefetch.\n   return {\n-    segment: route[0],\n+    name,\n+    paramType,\n+    // This value is ommitted from the prefetch response when clientParamParsing\n+    // is enabled. The flag only exists while we're testing the feature, in\n+    // case there's a bug and we need to revert.\n+    // TODO: Remove once clientParamParsing is enabled everywhere.\n+    paramKey: isClientParamParsingEnabled ? null : paramKey,\n     slots: slotMetadata,\n     isRootLayout: route[4] === true,\n   }"
        }
    ],
    "stats": {
        "total": 237,
        "additions": 161,
        "deletions": 76
    }
}