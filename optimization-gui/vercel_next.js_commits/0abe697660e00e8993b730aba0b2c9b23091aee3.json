{
    "author": "mischnic",
    "message": "Turbopack: refactor into `traverse_edges_fixed_point` (#79078)\n\nAbstract the existing ad-hoc traversal logic into a function\r\n\r\n**View diff without whitespace, the chunk_group_info visitor was merely reindented**",
    "sha": "0abe697660e00e8993b730aba0b2c9b23091aee3",
    "files": [
        {
            "sha": "29143f2c865fecbd94257061dcaaa1465bc4f26f",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 187,
            "deletions": 216,
            "changes": 403,
            "blob_url": "https://github.com/vercel/next.js/blob/0abe697660e00e8993b730aba0b2c9b23091aee3/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0abe697660e00e8993b730aba0b2c9b23091aee3/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=0abe697660e00e8993b730aba0b2c9b23091aee3",
            "patch": "@@ -1,5 +1,4 @@\n use std::{\n-    collections::BinaryHeap,\n     hash::Hash,\n     ops::{Deref, DerefMut},\n };\n@@ -8,7 +7,7 @@ use anyhow::{bail, Result};\n use either::Either;\n use indexmap::map::Entry;\n use roaring::RoaringBitmap;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n use tracing::Instrument;\n use turbo_rcstr::RcStr;\n@@ -20,10 +19,7 @@ use turbo_tasks::{\n use crate::{\n     chunk::ChunkingType,\n     module::Module,\n-    module_graph::{\n-        get_node, get_node_idx, traced_di_graph::iter_neighbors_rev, GraphNodeIndex,\n-        GraphTraversalAction, ModuleGraph, SingleModuleGraphModuleNode, SingleModuleGraphNode,\n-    },\n+    module_graph::{GraphTraversalAction, ModuleGraph, SingleModuleGraphModuleNode},\n };\n \n #[derive(\n@@ -308,17 +304,16 @@ impl Deref for ChunkGroupId {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-struct NodeWithPriority {\n+struct TraversalPriority {\n     depth: usize,\n     chunk_group_len: u64,\n-    node: GraphNodeIndex,\n }\n-impl PartialOrd for NodeWithPriority {\n+impl PartialOrd for TraversalPriority {\n     fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n         Some(self.cmp(other))\n     }\n }\n-impl Ord for NodeWithPriority {\n+impl Ord for TraversalPriority {\n     fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n         // BinaryHeap prioritizes high values\n \n@@ -327,10 +322,7 @@ impl Ord for NodeWithPriority {\n         // Smaller group length has higher priority\n         let chunk_group_len_order = self.chunk_group_len.cmp(&other.chunk_group_len).reverse();\n \n-        depth_order\n-            .then(chunk_group_len_order)\n-            // include GraphNodeIndex for total and deterministic ordering\n-            .then(other.node.cmp(&self.node))\n+        depth_order.then(chunk_group_len_order)\n     }\n }\n \n@@ -350,37 +342,43 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n             (ChunkGroupId, FxIndexSet<ResolvedVc<Box<dyn Module>>>),\n         > = FxIndexMap::default();\n \n+        // For each module, the indices in the bitmap store which chunk groups in `chunk_groups_map`\n+        // that module is part of.\n         let mut module_chunk_groups: FxHashMap<ResolvedVc<Box<dyn Module>>, RoaringBitmapWrapper> =\n             FxHashMap::default();\n \n         let graphs = graph.graphs.iter().try_join().await?;\n         let module_count = graphs.iter().map(|g| g.graph.node_count()).sum::<usize>();\n         span.record(\"module_count\", module_count);\n \n-        // First, compute the depth for each module in the graph\n-        let mut module_depth: FxHashMap<ResolvedVc<Box<dyn Module>>, usize> = FxHashMap::default();\n         // use all entries from all graphs\n         let entries = graphs\n             .iter()\n             .flat_map(|g| g.entries.iter())\n             .collect::<Vec<_>>();\n-        graph\n-            .traverse_edges_from_entries_bfs(\n-                entries.iter().flat_map(|e| e.entries()),\n-                |parent, node| {\n-                    if let Some((parent, _)) = parent {\n-                        let parent_depth = *module_depth.get(&parent.module).unwrap();\n-                        module_depth.entry(node.module).or_insert(parent_depth + 1);\n-                    } else {\n-                        module_depth.insert(node.module, 0);\n-                    };\n \n-                    module_chunk_groups.insert(node.module, RoaringBitmapWrapper::default());\n+        // First, compute the depth for each module in the graph\n+        let module_depth: FxHashMap<ResolvedVc<Box<dyn Module>>, usize> = {\n+            let mut module_depth = FxHashMap::default();\n+            graph\n+                .traverse_edges_from_entries_bfs(\n+                    entries.iter().flat_map(|e| e.entries()),\n+                    |parent, node| {\n+                        if let Some((parent, _)) = parent {\n+                            let parent_depth = *module_depth.get(&parent.module).unwrap();\n+                            module_depth.entry(node.module).or_insert(parent_depth + 1);\n+                        } else {\n+                            module_depth.insert(node.module, 0);\n+                        };\n \n-                    GraphTraversalAction::Continue\n-                },\n-            )\n-            .await?;\n+                        module_chunk_groups.insert(node.module, RoaringBitmapWrapper::default());\n+\n+                        GraphTraversalAction::Continue\n+                    },\n+                )\n+                .await?;\n+            module_depth\n+        };\n \n         // ----\n \n@@ -446,205 +444,178 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n             })\n             .collect::<FxHashMap<_, _>>();\n \n-        let mut visitor =\n-            |parent_info: Option<(&'_ SingleModuleGraphModuleNode, &'_ ChunkingType)>,\n-             node: &'_ SingleModuleGraphModuleNode,\n-             module_chunk_groups: &mut FxHashMap<\n-                ResolvedVc<Box<dyn Module>>,\n-                RoaringBitmapWrapper,\n-            >|\n-             -> GraphTraversalAction {\n-                enum ChunkGroupInheritance<It: Iterator<Item = ChunkGroupKey>> {\n-                    Inherit(ResolvedVc<Box<dyn Module>>),\n-                    ChunkGroup(It),\n-                }\n-                let chunk_groups = if let Some((parent, chunking_type)) = parent_info {\n-                    match chunking_type {\n-                        ChunkingType::Parallel { .. } => {\n-                            ChunkGroupInheritance::Inherit(parent.module)\n-                        }\n-                        ChunkingType::Async => ChunkGroupInheritance::ChunkGroup(Either::Left(\n-                            std::iter::once(ChunkGroupKey::Async(node.module)),\n-                        )),\n-                        ChunkingType::Isolated {\n-                            merge_tag: None, ..\n-                        } => ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n-                            ChunkGroupKey::Isolated(node.module),\n-                        ))),\n-                        ChunkingType::Shared {\n-                            merge_tag: None, ..\n-                        } => ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n-                            ChunkGroupKey::Shared(node.module),\n-                        ))),\n-                        ChunkingType::Isolated {\n-                            merge_tag: Some(merge_tag),\n-                            ..\n-                        } => {\n-                            let parents = module_chunk_groups.get(&parent.module).unwrap();\n-                            let chunk_groups =\n-                                parents.iter().map(|parent| ChunkGroupKey::IsolatedMerged {\n-                                    parent: ChunkGroupId(parent),\n-                                    merge_tag: merge_tag.clone(),\n-                                });\n-                            ChunkGroupInheritance::ChunkGroup(Either::Right(Either::Left(\n-                                chunk_groups,\n-                            )))\n-                        }\n-                        ChunkingType::Shared {\n-                            merge_tag: Some(merge_tag),\n-                            ..\n-                        } => {\n-                            let parents = module_chunk_groups.get(&parent.module).unwrap();\n-                            let chunk_groups =\n-                                parents.iter().map(|parent| ChunkGroupKey::SharedMerged {\n-                                    parent: ChunkGroupId(parent),\n-                                    merge_tag: merge_tag.clone(),\n-                                });\n-                            ChunkGroupInheritance::ChunkGroup(Either::Right(Either::Right(\n-                                chunk_groups,\n-                            )))\n-                        }\n-                        ChunkingType::Traced => {\n-                            // Traced modules are not placed in chunk groups\n-                            return GraphTraversalAction::Skip;\n-                        }\n+        let visit_count = graph\n+            .traverse_edges_fixed_point_with_priority(\n+                entries.iter().flat_map(|e| e.entries()).map(|e| {\n+                    (\n+                        e,\n+                        TraversalPriority {\n+                            depth: *module_depth.get(&e).unwrap(),\n+                            chunk_group_len: 0,\n+                        },\n+                    )\n+                }),\n+                &mut module_chunk_groups,\n+                |parent_info: Option<(&'_ SingleModuleGraphModuleNode, &'_ ChunkingType)>,\n+                 node: &'_ SingleModuleGraphModuleNode,\n+                 module_chunk_groups: &mut FxHashMap<\n+                    ResolvedVc<Box<dyn Module>>,\n+                    RoaringBitmapWrapper,\n+                >|\n+                 -> GraphTraversalAction {\n+                    enum ChunkGroupInheritance<It: Iterator<Item = ChunkGroupKey>> {\n+                        Inherit(ResolvedVc<Box<dyn Module>>),\n+                        ChunkGroup(It),\n                     }\n-                } else {\n-                    ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n-                        entry_chunk_group_keys.get(&node.module).unwrap().clone(),\n-                    )))\n-                };\n-\n-                match chunk_groups {\n-                    ChunkGroupInheritance::ChunkGroup(chunk_groups) => {\n-                        // Start of a new chunk group, don't inherit anything from parent\n-                        let chunk_group_ids = chunk_groups.map(|chunk_group| {\n-                            let len = chunk_groups_map.len();\n-                            let is_merged = matches!(\n-                                chunk_group,\n-                                ChunkGroupKey::IsolatedMerged { .. }\n-                                    | ChunkGroupKey::SharedMerged { .. }\n-                            );\n-                            match chunk_groups_map.entry(chunk_group) {\n-                                Entry::Occupied(mut e) => {\n-                                    let (id, merged_entries) = e.get_mut();\n-                                    if is_merged {\n-                                        merged_entries.insert(node.module);\n+                    let chunk_groups = if let Some((parent, chunking_type)) = parent_info {\n+                        match chunking_type {\n+                            ChunkingType::Parallel { .. } => {\n+                                ChunkGroupInheritance::Inherit(parent.module)\n+                            }\n+                            ChunkingType::Async => ChunkGroupInheritance::ChunkGroup(Either::Left(\n+                                std::iter::once(ChunkGroupKey::Async(node.module)),\n+                            )),\n+                            ChunkingType::Isolated {\n+                                merge_tag: None, ..\n+                            } => ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n+                                ChunkGroupKey::Isolated(node.module),\n+                            ))),\n+                            ChunkingType::Shared {\n+                                merge_tag: None, ..\n+                            } => ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n+                                ChunkGroupKey::Shared(node.module),\n+                            ))),\n+                            ChunkingType::Isolated {\n+                                merge_tag: Some(merge_tag),\n+                                ..\n+                            } => {\n+                                let parents = module_chunk_groups.get(&parent.module).unwrap();\n+                                let chunk_groups =\n+                                    parents.iter().map(|parent| ChunkGroupKey::IsolatedMerged {\n+                                        parent: ChunkGroupId(parent),\n+                                        merge_tag: merge_tag.clone(),\n+                                    });\n+                                ChunkGroupInheritance::ChunkGroup(Either::Right(Either::Left(\n+                                    chunk_groups,\n+                                )))\n+                            }\n+                            ChunkingType::Shared {\n+                                merge_tag: Some(merge_tag),\n+                                ..\n+                            } => {\n+                                let parents = module_chunk_groups.get(&parent.module).unwrap();\n+                                let chunk_groups =\n+                                    parents.iter().map(|parent| ChunkGroupKey::SharedMerged {\n+                                        parent: ChunkGroupId(parent),\n+                                        merge_tag: merge_tag.clone(),\n+                                    });\n+                                ChunkGroupInheritance::ChunkGroup(Either::Right(Either::Right(\n+                                    chunk_groups,\n+                                )))\n+                            }\n+                            ChunkingType::Traced => {\n+                                // Traced modules are not placed in chunk groups\n+                                return GraphTraversalAction::Skip;\n+                            }\n+                        }\n+                    } else {\n+                        ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n+                            entry_chunk_group_keys.get(&node.module).unwrap().clone(),\n+                        )))\n+                    };\n+\n+                    match chunk_groups {\n+                        ChunkGroupInheritance::ChunkGroup(chunk_groups) => {\n+                            // Start of a new chunk group, don't inherit anything from parent\n+                            let chunk_group_ids = chunk_groups.map(|chunk_group| {\n+                                let len = chunk_groups_map.len();\n+                                let is_merged = matches!(\n+                                    chunk_group,\n+                                    ChunkGroupKey::IsolatedMerged { .. }\n+                                        | ChunkGroupKey::SharedMerged { .. }\n+                                );\n+                                match chunk_groups_map.entry(chunk_group) {\n+                                    Entry::Occupied(mut e) => {\n+                                        let (id, merged_entries) = e.get_mut();\n+                                        if is_merged {\n+                                            merged_entries.insert(node.module);\n+                                        }\n+                                        **id\n                                     }\n-                                    **id\n-                                }\n-                                Entry::Vacant(e) => {\n-                                    let chunk_group_id = len as u32;\n-                                    let mut set = FxIndexSet::default();\n-                                    if is_merged {\n-                                        set.insert(node.module);\n+                                    Entry::Vacant(e) => {\n+                                        let chunk_group_id = len as u32;\n+                                        let mut set = FxIndexSet::default();\n+                                        if is_merged {\n+                                            set.insert(node.module);\n+                                        }\n+                                        e.insert((ChunkGroupId(chunk_group_id), set));\n+                                        chunk_group_id\n                                     }\n-                                    e.insert((ChunkGroupId(chunk_group_id), set));\n-                                    chunk_group_id\n                                 }\n-                            }\n-                        });\n-\n-                        let chunk_groups =\n-                            RoaringBitmapWrapper(RoaringBitmap::from_iter(chunk_group_ids));\n+                            });\n \n-                        // Assign chunk group to the target node (the entry of the chunk group)\n-                        let bitset = module_chunk_groups.get_mut(&node.module).unwrap();\n-                        if chunk_groups.is_proper_superset(bitset) {\n-                            // Add bits from parent, and continue traversal because changed\n-                            **bitset |= chunk_groups.into_inner();\n-\n-                            GraphTraversalAction::Continue\n-                        } else {\n-                            // Unchanged, no need to forward to children\n-                            GraphTraversalAction::Skip\n-                        }\n-                    }\n-                    ChunkGroupInheritance::Inherit(parent) => {\n-                        // Inherit chunk groups from parent, merge parent chunk groups into current\n+                            let chunk_groups =\n+                                RoaringBitmapWrapper(RoaringBitmap::from_iter(chunk_group_ids));\n \n-                        if parent == node.module {\n-                            // A self-reference\n-                            GraphTraversalAction::Skip\n-                        } else {\n-                            // Fast path\n-                            let [Some(parent_chunk_groups), Some(current_chunk_groups)] =\n-                                module_chunk_groups.get_disjoint_mut([&parent, &node.module])\n-                            else {\n-                                // All modules are inserted in the previous iteration\n-                                unreachable!()\n-                            };\n-\n-                            if current_chunk_groups.is_empty() {\n-                                // Initial visit, clone instead of merging\n-                                *current_chunk_groups = parent_chunk_groups.clone();\n-                                GraphTraversalAction::Continue\n-                            } else if parent_chunk_groups.is_proper_superset(current_chunk_groups) {\n+                            // Assign chunk group to the target node (the entry of the chunk group)\n+                            let bitset = module_chunk_groups.get_mut(&node.module).unwrap();\n+                            if chunk_groups.is_proper_superset(bitset) {\n                                 // Add bits from parent, and continue traversal because changed\n-                                **current_chunk_groups |= &**parent_chunk_groups;\n+                                **bitset |= chunk_groups.into_inner();\n+\n                                 GraphTraversalAction::Continue\n                             } else {\n                                 // Unchanged, no need to forward to children\n                                 GraphTraversalAction::Skip\n                             }\n                         }\n+                        ChunkGroupInheritance::Inherit(parent) => {\n+                            // Inherit chunk groups from parent, merge parent chunk groups into\n+                            // current\n+\n+                            if parent == node.module {\n+                                // A self-reference\n+                                GraphTraversalAction::Skip\n+                            } else {\n+                                // Fast path\n+                                let [Some(parent_chunk_groups), Some(current_chunk_groups)] =\n+                                    module_chunk_groups.get_disjoint_mut([&parent, &node.module])\n+                                else {\n+                                    // All modules are inserted in the previous iteration\n+                                    unreachable!()\n+                                };\n+\n+                                if current_chunk_groups.is_empty() {\n+                                    // Initial visit, clone instead of merging\n+                                    *current_chunk_groups = parent_chunk_groups.clone();\n+                                    GraphTraversalAction::Continue\n+                                } else if parent_chunk_groups\n+                                    .is_proper_superset(current_chunk_groups)\n+                                {\n+                                    // Add bits from parent, and continue traversal because changed\n+                                    **current_chunk_groups |= &**parent_chunk_groups;\n+                                    GraphTraversalAction::Continue\n+                                } else {\n+                                    // Unchanged, no need to forward to children\n+                                    GraphTraversalAction::Skip\n+                                }\n+                            }\n+                        }\n                     }\n-                }\n-            };\n-\n-        let mut visit_count = 0usize;\n-\n-        {\n-            let mut queue_set = FxHashSet::default();\n-            let mut queue = BinaryHeap::with_capacity(entries.len());\n-            for e in entries.iter().flat_map(|e| e.entries()) {\n-                queue.push(NodeWithPriority {\n-                    depth: *module_depth.get(&e).unwrap(),\n-                    chunk_group_len: 0,\n-                    node: ModuleGraph::get_entry(&graphs, e).await?,\n-                });\n-            }\n-            for entry_node in &queue {\n-                visitor(\n-                    None,\n-                    get_node!(graphs, entry_node.node)?,\n-                    &mut module_chunk_groups,\n-                );\n-            }\n-            while let Some(NodeWithPriority { node, .. }) = queue.pop() {\n-                queue_set.remove(&node);\n-                let (node_weight, node) = get_node_idx!(graphs, node)?;\n-                let graph = &graphs[node.graph_idx].graph;\n-                let neighbors = iter_neighbors_rev(graph, node.node_idx);\n-\n-                visit_count += 1;\n-\n-                for (edge, succ) in neighbors {\n-                    let succ = GraphNodeIndex {\n-                        graph_idx: node.graph_idx,\n-                        node_idx: succ,\n-                    };\n-                    let (succ_weight, succ) = get_node_idx!(graphs, succ)?;\n-                    let edge_weight = graph.edge_weight(edge).unwrap();\n-                    let action = visitor(\n-                        Some((node_weight, edge_weight)),\n-                        succ_weight,\n-                        &mut module_chunk_groups,\n-                    );\n-\n-                    if action == GraphTraversalAction::Continue && queue_set.insert(succ) {\n-                        queue.push(NodeWithPriority {\n-                            depth: *module_depth.get(&succ_weight.module).unwrap(),\n-                            chunk_group_len: module_chunk_groups\n-                                .get(&succ_weight.module)\n-                                .unwrap()\n-                                .len(),\n-                            node: succ,\n-                        });\n-                    }\n-                }\n-            }\n-        }\n+                },\n+                // This priority is used as a heuristic to keep the number of retraversals down, by\n+                // - keeping it similar to a BFS via the depth priority\n+                // - prioritizing smaller chunk groups which are expected to themselves reference\n+                //   bigger chunk groups (i.e. shared code deeper down in the graph).\n+                //\n+                // Both try to first visit modules with a large dependency subgraph first (which\n+                // would be higher in the graph and are included by few chunks themselves).\n+                |successor, module_chunk_groups| TraversalPriority {\n+                    depth: *module_depth.get(&successor.module).unwrap(),\n+                    chunk_group_len: module_chunk_groups.get(&successor.module).unwrap().len(),\n+                },\n+            )\n+            .await?;\n \n         span.record(\"visit_count\", visit_count);\n         span.record(\"chunk_group_count\", chunk_groups_map.len());"
        },
        {
            "sha": "f16714a1028ae70dd60bc50a8b4c7f501e016076",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 105,
            "deletions": 1,
            "changes": 106,
            "blob_url": "https://github.com/vercel/next.js/blob/0abe697660e00e8993b730aba0b2c9b23091aee3/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0abe697660e00e8993b730aba0b2c9b23091aee3/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=0abe697660e00e8993b730aba0b2c9b23091aee3",
            "patch": "@@ -1,5 +1,5 @@\n use std::{\n-    collections::{HashSet, VecDeque},\n+    collections::{BinaryHeap, HashSet, VecDeque},\n     future::Future,\n };\n \n@@ -1155,6 +1155,8 @@ impl ModuleGraph {\n         Ok(())\n     }\n \n+    /// Traverse all cycles in the graph (where the edge filter returns true for the whole cycle)\n+    /// and call the visitor with the nodes in the cycle.\n     pub async fn traverse_cycles(\n         &self,\n         edge_filter: impl Fn(&ChunkingType) -> bool,\n@@ -1165,6 +1167,108 @@ impl ModuleGraph {\n         }\n         Ok(())\n     }\n+\n+    /// Traverses all reachable nodes and also continue revisiting them as long the visitor returns\n+    /// GraphTraversalAction::Continue. The visitor is responsible for the runtime complexity and\n+    /// eventual termination of the traversal. This corresponds to computing a fixed point state for\n+    /// the graph.\n+    ///\n+    /// Nodes are (re)visited according to the returned priority of the node, prioritizing high\n+    /// values. This priority is intended to be used a heuristic to reduce the number of\n+    /// retraversals.\n+    ///\n+    /// * `entries` - The entry modules to start the traversal from\n+    /// * `state` - The state to be passed to the callbacks\n+    /// * `visit` - Called for a specific edge\n+    ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n+    ///      &SingleModuleGraphNode, state &S\n+    ///    - Return [GraphTraversalAction]s to control the traversal\n+    /// * `priority` - Called for before visiting the children of a node to determine its priority.\n+    ///    - Receives: target &SingleModuleGraphNode, state &S\n+    ///    - Return a priority value for the node\n+    ///\n+    /// Returns the number of node visits (i.e. higher than the node count if there are\n+    /// retraversals).\n+    pub async fn traverse_edges_fixed_point_with_priority<S, P: Ord>(\n+        &self,\n+        entries: impl IntoIterator<Item = (ResolvedVc<Box<dyn Module>>, P)>,\n+        state: &mut S,\n+        mut visit: impl FnMut(\n+            Option<(&'_ SingleModuleGraphModuleNode, &'_ ChunkingType)>,\n+            &'_ SingleModuleGraphModuleNode,\n+            &mut S,\n+        ) -> GraphTraversalAction,\n+        priority: impl Fn(&'_ SingleModuleGraphModuleNode, &mut S) -> P,\n+    ) -> Result<usize> {\n+        let graphs = self.get_graphs().await?;\n+\n+        #[derive(PartialEq, Eq)]\n+        struct NodeWithPriority<T: Ord> {\n+            node: GraphNodeIndex,\n+            priority: T,\n+        }\n+        impl<T: Ord> PartialOrd for NodeWithPriority<T> {\n+            fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n+                Some(self.cmp(other))\n+            }\n+        }\n+        impl<T: Ord> Ord for NodeWithPriority<T> {\n+            fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+                // BinaryHeap prioritizes high values\n+\n+                self.priority\n+                    .cmp(&other.priority)\n+                    // include GraphNodeIndex for total and deterministic ordering\n+                    .then(other.node.cmp(&self.node))\n+            }\n+        }\n+\n+        let mut queue_set = FxHashSet::default();\n+        let mut queue = BinaryHeap::from_iter(\n+            entries\n+                .into_iter()\n+                .map(async |(m, priority)| {\n+                    Ok(NodeWithPriority {\n+                        node: ModuleGraph::get_entry(&graphs, m).await?,\n+                        priority,\n+                    })\n+                })\n+                .try_join()\n+                .await?,\n+        );\n+        for entry_node in &queue {\n+            visit(None, get_node!(graphs, entry_node.node)?, state);\n+        }\n+\n+        let mut visit_count = 0usize;\n+        while let Some(NodeWithPriority { node, .. }) = queue.pop() {\n+            queue_set.remove(&node);\n+            let (node_weight, node) = get_node_idx!(graphs, node)?;\n+            let graph = &graphs[node.graph_idx].graph;\n+            let neighbors = iter_neighbors_rev(graph, node.node_idx);\n+\n+            visit_count += 1;\n+\n+            for (edge, succ) in neighbors {\n+                let succ = GraphNodeIndex {\n+                    graph_idx: node.graph_idx,\n+                    node_idx: succ,\n+                };\n+                let (succ_weight, succ) = get_node_idx!(graphs, succ)?;\n+                let edge_weight = graph.edge_weight(edge).unwrap();\n+                let action = visit(Some((node_weight, edge_weight)), succ_weight, state);\n+\n+                if action == GraphTraversalAction::Continue && queue_set.insert(succ) {\n+                    queue.push(NodeWithPriority {\n+                        node: succ,\n+                        priority: priority(succ_weight, state),\n+                    });\n+                }\n+            }\n+        }\n+\n+        Ok(visit_count)\n+    }\n }\n \n #[turbo_tasks::value_impl]"
        }
    ],
    "stats": {
        "total": 509,
        "additions": 292,
        "deletions": 217
    }
}