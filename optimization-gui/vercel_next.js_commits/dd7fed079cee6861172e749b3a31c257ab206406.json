{
    "author": "lukesandberg",
    "message": "Fork the globset strategy for turbopack (#79333)\n\n## What \nAfter discussion with [upstream](https://github.com/BurntSushi/ripgrep/issues/3049) it was determined that upstreaming a function like `can_skip_directory` wasn't aligned. It turns out the needs of ripgrep and ours are somewhat divergent.  Instead they encouraged me to just fork and modify which is what we do here.\n\nThis copies the glob->regex translation logic and drops much of the other functionality that is optimized for large sets of globs.   Then I have added our `can_skip_directory` function following a similar pattern.\n\n## Why\n\nThis approach allows us to easily support for character ranges (e.g. `[A-Za-z0-9_-]`) and improves performance.  I also suspect that this will be easier to maintain as debugging the generated regular expressions should be quite straightforward.\n\n## Alternatives\n\nWe could just adopt globset directly as proposed in #79116 however we would lose the ability to skip directories during traversal which can reduce the cost of setting up turbotasks dependencies and directory watchers.  The other alternative that i pursued was a direct NFA implementation (see #78976).  This would be more memory efficient than regular expressions since both queries can share the same NFA, but the regex crate is much faster and better maintained.  If memory overhead becomes a concern we can configure the regexes to use less, however, i suspect many of our generated regexes will be quite simple and thus generate small automata.\n\nCloses PACK-4401\nFixes #72196",
    "sha": "dd7fed079cee6861172e749b3a31c257ab206406",
    "files": [
        {
            "sha": "6757f037ab4474a68cc5f6f0c6e34a3a2d49639e",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/dd7fed079cee6861172e749b3a31c257ab206406/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/dd7fed079cee6861172e749b3a31c257ab206406/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=dd7fed079cee6861172e749b3a31c257ab206406",
            "patch": "@@ -9736,6 +9736,7 @@ dependencies = [\n  \"notify\",\n  \"parking_lot\",\n  \"rayon\",\n+ \"regex\",\n  \"rstest\",\n  \"rustc-hash 2.1.1\",\n  \"serde\","
        },
        {
            "sha": "e48c1a04d1c3f61355651f85c45b9e2b882a9488",
            "filename": "crates/next-core/src/next_server/resolve.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/dd7fed079cee6861172e749b3a31c257ab206406/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/dd7fed079cee6861172e749b3a31c257ab206406/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs?ref=dd7fed079cee6861172e749b3a31c257ab206406",
            "patch": "@@ -119,8 +119,8 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n                     request_glob,\n                 }) = *exception_glob\n                 {\n-                    let path_match = path_glob.await?.execute(&raw_fs_path.path);\n-                    let request_match = request_glob.await?.execute(&request_str);\n+                    let path_match = path_glob.await?.matches(&raw_fs_path.path);\n+                    let request_match = request_glob.await?.matches(&request_str);\n                     if path_match || request_match {\n                         return Ok(ResolveResultOption::none());\n                     }\n@@ -135,8 +135,8 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n                     request_glob,\n                 }) = *external_glob\n                 {\n-                    let path_match = path_glob.await?.execute(&raw_fs_path.path);\n-                    let request_match = request_glob.await?.execute(&request_str);\n+                    let path_match = path_glob.await?.matches(&raw_fs_path.path);\n+                    let request_match = request_glob.await?.matches(&request_str);\n \n                     if !path_match && !request_match {\n                         return Ok(ResolveResultOption::none());"
        },
        {
            "sha": "28b4b7ee9680880e4a8353d6b772699653a5dac4",
            "filename": "turbopack/crates/turbo-tasks-fs/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbo-tasks-fs%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbo-tasks-fs%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2FCargo.toml?ref=dd7fed079cee6861172e749b3a31c257ab206406",
            "patch": "@@ -41,6 +41,7 @@ mime = { workspace = true }\n notify = { workspace = true }\n parking_lot = { workspace = true }\n rayon = { workspace = true }\n+regex = { workspace = true }\n rustc-hash = { workspace = true }\n serde = { workspace = true, features = [\"rc\"] }\n serde_bytes = { workspace = true }"
        },
        {
            "sha": "eea435d4c9dbfe48dd804b968e0657c3c1316f3a",
            "filename": "turbopack/crates/turbo-tasks-fs/src/glob.rs",
            "status": "modified",
            "additions": 106,
            "deletions": 387,
            "changes": 493,
            "blob_url": "https://github.com/vercel/next.js/blob/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs?ref=dd7fed079cee6861172e749b3a31c257ab206406",
            "patch": "@@ -1,34 +1,10 @@\n-use std::mem::take;\n-\n-use anyhow::{Context, Result, anyhow, bail};\n+use anyhow::Result;\n+use regex::bytes::{Regex, RegexBuilder};\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{NonLocalValue, TryJoinIterExt, Vc, trace::TraceRawVcs};\n-use unicode_segmentation::GraphemeCursor;\n-\n-#[derive(PartialEq, Eq, Debug, Clone, TraceRawVcs, Serialize, Deserialize, NonLocalValue)]\n-enum GlobPart {\n-    /// `/**/`: Matches any path of directories\n-    AnyDirectories,\n-\n-    /// `*`: Matches any filename (no path separator)\n-    AnyFile,\n-\n-    /// `?`: Matches a single filename character (no path separator)\n-    AnyFileChar,\n+use turbo_tasks::Vc;\n \n-    /// `/`: Matches the path separator\n-    PathSeparator,\n-\n-    /// `[abc]`: Matches any char of the list\n-    FileChar(Vec<char>),\n-\n-    /// `abc`: Matches literal filename\n-    File(String),\n-\n-    /// `{a,b,c}`: Matches any of the globs in the list\n-    Alternatives(Vec<Glob>),\n-}\n+use crate::globset::parse;\n \n // Examples:\n // - file.js = File(file.js)\n@@ -42,360 +18,67 @@ enum GlobPart {\n // Note: a/**/b does match a/b, so we need some special logic about path\n // separators\n \n-#[turbo_tasks::value]\n+#[turbo_tasks::value(eq = \"manual\")]\n #[derive(Debug, Clone)]\n+#[serde(into = \"GlobForm\", try_from = \"GlobForm\")]\n pub struct Glob {\n-    expression: Vec<GlobPart>,\n+    glob: String,\n+    #[turbo_tasks(trace_ignore)]\n+    regex: Regex,\n+    #[turbo_tasks(trace_ignore)]\n+    directory_match_regex: Regex,\n }\n-\n-impl Glob {\n-    pub fn execute(&self, path: &str) -> bool {\n-        // TODO(lukesandberg): deprecate this implicit behavior\n-        let match_partial = path.ends_with('/');\n-        self.iter_matches(path, true, match_partial)\n-            .any(|result| matches!(result, (\"\", _)))\n-    }\n-\n-    // Returns true if the glob could match a filename underneath this `path` where the path\n-    // represents a directory.\n-    pub fn match_in_directory(&self, path: &str) -> bool {\n-        debug_assert!(!path.ends_with('/'));\n-        // TODO(lukesandberg): see if we can avoid this allocation by changing the matching\n-        // algorithm\n-        let path = format!(\"{path}/\");\n-        self.iter_matches(&path, true, true)\n-            .any(|result| matches!(result, (\"\", _)))\n-    }\n-\n-    fn iter_matches<'a>(\n-        &'a self,\n-        path: &'a str,\n-        previous_part_is_path_separator_equivalent: bool,\n-        match_in_directory: bool,\n-    ) -> GlobMatchesIterator<'a> {\n-        GlobMatchesIterator {\n-            current: path,\n-            glob: self,\n-            match_in_directory,\n-            is_path_separator_equivalent: previous_part_is_path_separator_equivalent,\n-            stack: Vec::new(),\n-            index: 0,\n-        }\n-    }\n-\n-    pub fn parse(input: &str) -> Result<Glob> {\n-        let mut current = input;\n-        let mut expression = Vec::new();\n-\n-        while !current.is_empty() {\n-            let (part, remainder) = GlobPart::parse(current, false)\n-                .with_context(|| anyhow!(\"Failed to parse glob {input}\"))?;\n-            expression.push(part);\n-            current = remainder;\n-        }\n-\n-        Ok(Glob { expression })\n+impl PartialEq for Glob {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.glob == other.glob\n     }\n }\n+impl Eq for Glob {}\n \n-struct GlobMatchesIterator<'a> {\n-    current: &'a str,\n-    glob: &'a Glob,\n-    // In this mode we are checking if the glob might match something in the directory represented\n-    // by this path.\n-    match_in_directory: bool,\n-    is_path_separator_equivalent: bool,\n-    stack: Vec<GlobPartMatchesIterator<'a>>,\n-    index: usize,\n+#[derive(Serialize, Deserialize)]\n+#[serde(transparent)]\n+#[repr(transparent)]\n+struct GlobForm {\n+    glob: String,\n }\n-\n-impl<'a> Iterator for GlobMatchesIterator<'a> {\n-    type Item = (&'a str, bool);\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        loop {\n-            if let Some(part) = self.glob.expression.get(self.index) {\n-                let iter = if let Some(iter) = self.stack.get_mut(self.index) {\n-                    iter\n-                } else {\n-                    let iter = part.iter_matches(\n-                        self.current,\n-                        self.is_path_separator_equivalent,\n-                        self.match_in_directory,\n-                    );\n-                    self.stack.push(iter);\n-                    self.stack.last_mut().unwrap()\n-                };\n-                if let Some((new_path, new_is_path_separator_equivalent)) = iter.next() {\n-                    self.current = new_path;\n-                    self.is_path_separator_equivalent = new_is_path_separator_equivalent;\n-\n-                    self.index += 1;\n-\n-                    if self.match_in_directory && self.current.is_empty() {\n-                        return Some((\"\", self.is_path_separator_equivalent));\n-                    }\n-                } else {\n-                    if self.index == 0 {\n-                        // failed to match\n-                        return None;\n-                    }\n-                    // backtrack\n-                    self.stack.pop();\n-                    self.index -= 1;\n-                }\n-            } else {\n-                // end of expression, matched successfully\n-\n-                // backtrack for the next iteration\n-                self.index -= 1;\n-\n-                return Some((self.current, self.is_path_separator_equivalent));\n-            }\n-        }\n+impl From<Glob> for GlobForm {\n+    fn from(value: Glob) -> Self {\n+        Self { glob: value.glob }\n     }\n }\n-\n-impl GlobPart {\n-    /// Iterates over all possible matches of this part with the provided path.\n-    /// The least greedy match is returned first. This is usually used for\n-    /// backtracking. The string slice returned is the remaining part or the\n-    /// path. The boolean flag returned specifies if the matched part should\n-    /// be considered as path-separator equivalent.\n-    fn iter_matches<'a>(\n-        &'a self,\n-        path: &'a str,\n-        previous_part_is_path_separator_equivalent: bool,\n-        match_in_directory: bool,\n-    ) -> GlobPartMatchesIterator<'a> {\n-        GlobPartMatchesIterator {\n-            path,\n-            part: self,\n-            match_in_directory,\n-            previous_part_is_path_separator_equivalent,\n-            cursor: GraphemeCursor::new(0, path.len(), true),\n-            index: 0,\n-            glob_iterator: None,\n-        }\n-    }\n-\n-    fn parse(input: &str, inside_of_braces: bool) -> Result<(GlobPart, &str)> {\n-        debug_assert!(!input.is_empty());\n-        let two_chars = {\n-            let mut chars = input.chars();\n-            (chars.next().unwrap(), chars.next())\n-        };\n-        match two_chars {\n-            ('/', _) => Ok((GlobPart::PathSeparator, &input[1..])),\n-            ('*', Some('*')) => Ok((GlobPart::AnyDirectories, &input[2..])),\n-            ('*', _) => Ok((GlobPart::AnyFile, &input[1..])),\n-            ('?', _) => Ok((GlobPart::AnyFileChar, &input[1..])),\n-            ('[', Some('[')) => todo!(\"glob char classes are not implemented yet\"),\n-            ('[', _) => todo!(\"glob char sequences are not implemented yet\"),\n-            ('{', Some(_)) => {\n-                let mut current = &input[1..];\n-                let mut alternatives = Vec::new();\n-                let mut expression = Vec::new();\n-\n-                loop {\n-                    let (part, remainder) = GlobPart::parse(current, true)?;\n-                    expression.push(part);\n-                    current = remainder;\n-                    match current.chars().next() {\n-                        Some(',') => {\n-                            alternatives.push(Glob {\n-                                expression: take(&mut expression),\n-                            });\n-                            current = &current[1..];\n-                        }\n-                        Some('}') => {\n-                            alternatives.push(Glob {\n-                                expression: take(&mut expression),\n-                            });\n-                            current = &current[1..];\n-                            break;\n-                        }\n-                        None => bail!(\"Unterminated glob braces\"),\n-                        _ => {\n-                            // next part of the glob\n-                        }\n-                    }\n-                }\n-\n-                Ok((GlobPart::Alternatives(alternatives), current))\n-            }\n-            ('{', None) => {\n-                bail!(\"Unterminated glob braces\")\n-            }\n-            _ => {\n-                let mut is_escaped = false;\n-                let mut literal = String::new();\n-\n-                let mut cursor = GraphemeCursor::new(0, input.len(), true);\n-\n-                let mut start = cursor.cur_cursor();\n-                let mut end_cursor = cursor\n-                    .next_boundary(input, 0)\n-                    .map_err(|e| anyhow!(\"{:?}\", e))?;\n-\n-                while let Some(end) = end_cursor {\n-                    let c = &input[start..end];\n-                    if is_escaped {\n-                        is_escaped = false;\n-                    } else if c == \"\\\\\" {\n-                        is_escaped = true;\n-                    } else if c == \"/\"\n-                        || c == \"*\"\n-                        || c == \"?\"\n-                        || c == \"[\"\n-                        || c == \"{\"\n-                        || (inside_of_braces && (c == \",\" || c == \"}\"))\n-                    {\n-                        break;\n-                    }\n-                    literal.push_str(c);\n-\n-                    start = cursor.cur_cursor();\n-                    end_cursor = cursor\n-                        .next_boundary(input, end)\n-                        .map_err(|e| anyhow!(\"{:?}\", e))?;\n-                }\n-\n-                Ok((GlobPart::File(literal), &input[start..]))\n-            }\n-        }\n+impl TryFrom<GlobForm> for Glob {\n+    type Error = anyhow::Error;\n+    fn try_from(value: GlobForm) -> Result<Self, Self::Error> {\n+        Glob::parse(&value.glob)\n     }\n }\n \n-struct GlobPartMatchesIterator<'a> {\n-    path: &'a str,\n-    part: &'a GlobPart,\n-    match_in_directory: bool,\n-    previous_part_is_path_separator_equivalent: bool,\n-    cursor: GraphemeCursor,\n-    index: usize,\n-    glob_iterator: Option<Box<GlobMatchesIterator<'a>>>,\n-}\n-\n-impl<'a> Iterator for GlobPartMatchesIterator<'a> {\n-    type Item = (&'a str, bool);\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        match self.part {\n-            GlobPart::AnyDirectories => {\n-                if self.cursor.cur_cursor() == 0 {\n-                    let Ok(Some(_)) = self.cursor.next_boundary(self.path, 0) else {\n-                        return None;\n-                    };\n-                    return Some((self.path, true));\n-                }\n-\n-                if self.cursor.cur_cursor() == self.path.len() {\n-                    return None;\n-                }\n-\n-                loop {\n-                    let start = self.cursor.cur_cursor();\n-                    // next_boundary does not set cursor offset to the end of the string\n-                    // if there is no next boundary - manually set cursor to the end\n-                    let end = match self.cursor.next_boundary(self.path, 0) {\n-                        Ok(end) => {\n-                            if let Some(end) = end {\n-                                end\n-                            } else {\n-                                self.cursor.set_cursor(self.path.len());\n-                                self.cursor.cur_cursor()\n-                            }\n-                        }\n-                        _ => return None,\n-                    };\n-\n-                    if &self.path[start..end] == \"/\" {\n-                        return Some((&self.path[end..], true));\n-                    } else if start == end {\n-                        return Some((&self.path[start..], false));\n-                    }\n-                }\n-            }\n-            GlobPart::AnyFile => {\n-                let Ok(Some(c)) = self.cursor.next_boundary(self.path, 0) else {\n-                    return None;\n-                };\n+impl Glob {\n+    // Returns true if the glob matches the given path.\n+    pub fn matches(&self, path: &str) -> bool {\n+        self.regex.is_match(path.as_bytes())\n+    }\n \n-                let idx = self.path[0..c].len();\n+    // Returns true if the glob might match a filename underneath this `path` where the\n+    // path represents a directory.\n+    pub fn can_match_in_directory(&self, path: &str) -> bool {\n+        debug_assert!(\n+            !path.ends_with('/'),\n+            \"Path should be a directory name and not end with /\"\n+        );\n+        self.directory_match_regex.is_match(path.as_bytes())\n+    }\n \n-                // TODO verify if `*` does match zero chars?\n-                if let Some(slice) = self.path.get(0..c) {\n-                    if slice.ends_with('/') {\n-                        None\n-                    } else {\n-                        Some((\n-                            &self.path[c..],\n-                            self.previous_part_is_path_separator_equivalent && idx == 1,\n-                        ))\n-                    }\n-                } else {\n-                    None\n-                }\n-            }\n-            GlobPart::AnyFileChar => todo!(),\n-            GlobPart::PathSeparator => {\n-                if self.cursor.cur_cursor() == 0 {\n-                    let Ok(Some(b)) = self.cursor.next_boundary(self.path, 0) else {\n-                        return None;\n-                    };\n-                    if self.path.starts_with('/') {\n-                        Some((&self.path[b..], true))\n-                    } else if self.previous_part_is_path_separator_equivalent {\n-                        Some((self.path, true))\n-                    } else {\n-                        None\n-                    }\n-                } else {\n-                    None\n-                }\n-            }\n-            GlobPart::FileChar(chars) => {\n-                let start = self.cursor.cur_cursor();\n-                let Ok(Some(end)) = self.cursor.next_boundary(self.path, 0) else {\n-                    return None;\n-                };\n-                let mut chars_in_path = self.path[start..end].chars();\n-                let c = chars_in_path.next()?;\n-                if chars_in_path.next().is_some() {\n-                    return None;\n-                }\n-                chars.contains(&c).then(|| (&self.path[end..], false))\n-            }\n-            GlobPart::File(name) => {\n-                if self.cursor.cur_cursor() == 0 && self.path.starts_with(name) {\n-                    let Ok(Some(_)) = self.cursor.next_boundary(self.path, 0) else {\n-                        return None;\n-                    };\n-                    Some((&self.path[name.len()..], false))\n-                } else {\n-                    None\n-                }\n-            }\n-            GlobPart::Alternatives(alternatives) => loop {\n-                if let Some(glob_iterator) = &mut self.glob_iterator {\n-                    if let Some((path, is_path_separator_equivalent)) = glob_iterator.next() {\n-                        return Some((path, is_path_separator_equivalent));\n-                    } else {\n-                        self.index += 1;\n-                        self.glob_iterator = None;\n-                    }\n-                } else if let Some(alternative) = alternatives.get(self.index) {\n-                    self.glob_iterator = Some(Box::new(alternative.iter_matches(\n-                        self.path,\n-                        self.previous_part_is_path_separator_equivalent,\n-                        self.match_in_directory,\n-                    )));\n-                } else {\n-                    return None;\n-                }\n-            },\n-        }\n+    pub fn parse(input: &str) -> Result<Glob> {\n+        let (glob_re, directory_match_re) = parse(input)?;\n+        let regex = new_regex(glob_re.as_str());\n+        let directory_match_regex = new_regex(directory_match_re.as_str());\n+\n+        Ok(Glob {\n+            glob: input.to_string(),\n+            regex,\n+            directory_match_regex,\n+        })\n     }\n }\n \n@@ -411,22 +94,37 @@ impl TryFrom<&str> for Glob {\n impl Glob {\n     #[turbo_tasks::function]\n     pub fn new(glob: RcStr) -> Result<Vc<Self>> {\n-        Ok(Self::cell(Glob::try_from(glob.as_str())?))\n+        Ok(Self::cell(Glob::parse(glob.as_str())?))\n     }\n \n     #[turbo_tasks::function]\n     pub async fn alternatives(globs: Vec<Vc<Glob>>) -> Result<Vc<Self>> {\n-        if globs.len() == 1 {\n-            return Ok(globs.into_iter().next().unwrap());\n+        match globs.len() {\n+            0 => Ok(Glob::new(\"\".into())),\n+            1 => Ok(globs.into_iter().next().unwrap()),\n+            _ => {\n+                let mut new_glob = String::new();\n+                new_glob.push('{');\n+                for (index, glob) in globs.iter().enumerate() {\n+                    if index > 0 {\n+                        new_glob.push(',');\n+                    }\n+                    new_glob.push_str(&glob.await?.glob);\n+                }\n+                new_glob.push('}');\n+                Ok(Glob::new(new_glob.into()))\n+            }\n         }\n-        Ok(Self::cell(Glob {\n-            expression: vec![GlobPart::Alternatives(\n-                globs.into_iter().map(|g| g.owned()).try_join().await?,\n-            )],\n-        }))\n     }\n }\n \n+fn new_regex(pattern: &str) -> Regex {\n+    RegexBuilder::new(pattern)\n+        .dot_matches_new_line(true)\n+        .build()\n+        .expect(\"A successfully parsed glob should produce a valid regex\")\n+}\n+\n #[cfg(test)]\n mod tests {\n     use rstest::*;\n@@ -437,31 +135,23 @@ mod tests {\n     #[case::file(\"file.js\", \"file.js\")]\n     #[case::dir_and_file(\"../public/äöüščří.png\", \"../public/äöüščří.png\")]\n     #[case::dir_and_file(\"dir/file.js\", \"dir/file.js\")]\n-    #[case::dir_and_file_partial(\"dir/file.js\", \"dir/\")]\n     #[case::file_braces(\"file.{ts,js}\", \"file.js\")]\n     #[case::dir_and_file_braces(\"dir/file.{ts,js}\", \"dir/file.js\")]\n     #[case::dir_and_file_dir_braces(\"{dir,other}/file.{ts,js}\", \"dir/file.js\")]\n     #[case::star(\"*.js\", \"file.js\")]\n     #[case::dir_star(\"dir/*.js\", \"dir/file.js\")]\n-    #[case::dir_star_partial(\"dir/*.js\", \"dir/\")]\n     #[case::globstar(\"**/*.js\", \"file.js\")]\n     #[case::globstar(\"**/*.js\", \"dir/file.js\")]\n     #[case::globstar(\"**/*.js\", \"dir/sub/file.js\")]\n     #[case::globstar(\"**/**/*.js\", \"file.js\")]\n     #[case::globstar(\"**/**/*.js\", \"dir/sub/file.js\")]\n-    #[case::globstar_partial(\"**/**/*.js\", \"dir/sub/\")]\n-    #[case::globstar_partial(\"**/**/*.js\", \"dir/\")]\n     #[case::globstar_in_dir(\"dir/**/sub/file.js\", \"dir/sub/file.js\")]\n     #[case::globstar_in_dir(\"dir/**/sub/file.js\", \"dir/a/sub/file.js\")]\n     #[case::globstar_in_dir(\"dir/**/sub/file.js\", \"dir/a/b/sub/file.js\")]\n     #[case::globstar_in_dir(\n         \"**/next/dist/**/*.shared-runtime.js\",\n         \"next/dist/shared/lib/app-router-context.shared-runtime.js\"\n     )]\n-    #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir/a/b/sub/\")]\n-    #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir/a/b/\")]\n-    #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir/a/\")]\n-    #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir/\")]\n     #[case::star_dir(\n         \"**/*/next/dist/server/next.js\",\n         \"node_modules/next/dist/server/next.js\"\n@@ -503,13 +193,13 @@ mod tests {\n     #[case::alternatives_nested2(\"{a,b/c,d/e/{f,g/h}}\", \"b/c\")]\n     #[case::alternatives_nested3(\"{a,b/c,d/e/{f,g/h}}\", \"d/e/f\")]\n     #[case::alternatives_nested4(\"{a,b/c,d/e/{f,g/h}}\", \"d/e/g/h\")]\n-    // #[case::alternatives_chars(\"[abc]\", \"b\")]\n+    #[case::alternatives_chars(\"[abc]\", \"b\")]\n     fn glob_match(#[case] glob: &str, #[case] path: &str) {\n         let glob = Glob::parse(glob).unwrap();\n \n         println!(\"{glob:?} {path}\");\n \n-        assert!(glob.execute(path));\n+        assert!(glob.matches(path));\n     }\n \n     #[rstest]\n@@ -523,6 +213,35 @@ mod tests {\n \n         println!(\"{glob:?} {path}\");\n \n-        assert!(!glob.execute(path));\n+        assert!(!glob.matches(path));\n+    }\n+\n+    #[rstest]\n+    #[case::dir_and_file_partial(\"dir/file.js\", \"dir\")]\n+    #[case::dir_star_partial(\"dir/*.js\", \"dir\")]\n+    #[case::globstar_partial(\"**/**/*.js\", \"dir\")]\n+    #[case::globstar_partial(\"**/**/*.js\", \"dir/sub\")]\n+    #[case::globstar_partial(\"**/**/*.js\", \"dir/sub/file.js\")] // This demonstrates some ambiguity in naming. `file.js` might be a directory name.\n+    #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir\")]\n+    #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir/a\")]\n+    #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir/a/b\")]\n+    #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir/a/b/sub\")]\n+    #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir/a/b/sub/file.js\")]\n+    fn glob_can_match_directory(#[case] glob: &str, #[case] path: &str) {\n+        let glob = Glob::parse(glob).unwrap();\n+\n+        println!(\"{glob:?} {path}\");\n+\n+        assert!(glob.can_match_in_directory(path));\n+    }\n+    #[rstest]\n+    #[case::dir_and_file_partial(\"dir/file.js\", \"dir/file.js\")] // even if there was a dir, named `file.js` we know the glob wasn't intended to match it.\n+    #[case::alternatives_chars(\"[abc]\", \"b\")]\n+    fn glob_not_can_match_directory(#[case] glob: &str, #[case] path: &str) {\n+        let glob = Glob::parse(glob).unwrap();\n+\n+        println!(\"{glob:?} {path}\");\n+\n+        assert!(!glob.can_match_in_directory(path));\n     }\n }"
        },
        {
            "sha": "2b3dc9ca63ed080323d0ff515c079873e8281c22",
            "filename": "turbopack/crates/turbo-tasks-fs/src/globset.rs",
            "status": "added",
            "additions": 653,
            "deletions": 0,
            "changes": 653,
            "blob_url": "https://github.com/vercel/next.js/blob/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglobset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglobset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglobset.rs?ref=dd7fed079cee6861172e749b3a31c257ab206406",
            "patch": "@@ -0,0 +1,653 @@\n+/// The parsing and construction algorithms here are based on the the `globset` crate.\n+/// After discussing upstreaming our usecase with the authors of `globset`, we decided that a\n+/// fork was appropriate given our divergent usecases. See discussion https://github.com/BurntSushi/ripgrep/issues/3049\n+/// The original code had the following license:\n+/// ```\n+/// The MIT License (MIT)\n+///\n+/// Copyright (c) 2015 Andrew Gallant\n+///\n+/// Permission is hereby granted, free of charge, to any person obtaining a copy\n+/// of this software and associated documentation files (the \"Software\"), to deal\n+/// in the Software without restriction, including without limitation the rights\n+/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+/// copies of the Software, and to permit persons to whom the Software is\n+/// furnished to do so, subject to the following conditions:\n+/// ```\n+///\n+/// Here it has been heavily modified to:\n+/// - Eliminate various configuration options we don't need\n+/// - Eliminate the more complex `GlobSet` matcher strategies. We don't anticipate needing to\n+///   compose thousands of globs like ripgrep does and so don't need the performance\n+///   optimizations that come with that.\n+/// - Add the can_match_directory regex (this is what was rejected by upstream), this allows us\n+///   to check if a directory is a valid prefix of a path that would match the glob.\n+/// - Add support for nested alternations, a minor detail (this was also sent upstream in https://github.com/BurntSushi/ripgrep/pull/3048)\n+/// - Add a number of comments to clarify the code.\n+///\n+/// Still some of the cleverest ideas in the original code were in the parsing and construction\n+/// of regexes and those are mostly preserved.\n+use anyhow::Error;\n+\n+/// The parsed tokens of a glob pattern.\n+#[derive(Clone, Debug, Default, Eq, PartialEq)]\n+#[repr(transparent)]\n+struct Tokens(Vec<Token>);\n+\n+impl std::ops::Deref for Tokens {\n+    type Target = Vec<Token>;\n+    fn deref(&self) -> &Vec<Token> {\n+        &self.0\n+    }\n+}\n+\n+impl std::ops::DerefMut for Tokens {\n+    fn deref_mut(&mut self) -> &mut Vec<Token> {\n+        &mut self.0\n+    }\n+}\n+\n+#[derive(Clone, Debug, Eq, PartialEq)]\n+enum Token {\n+    Literal(char),\n+    /// Any Single non path separator character\n+    Any,\n+    /// Any number of non path separator characters\n+    ZeroOrMore,\n+    /// A `**` at the beginning of the pattern\n+    RecursivePrefix,\n+    // A `/**` at the end of the pattern\n+    RecursiveSuffix,\n+    // A `**` in the middle of a pattern\n+    RecursiveZeroOrMore,\n+    Class {\n+        negated: bool,\n+        ranges: Vec<(char, char)>,\n+        // This is just precomputed since it is used in two places.\n+        matches_slash: bool,\n+    },\n+    Alternates(Vec<Tokens>),\n+}\n+\n+impl Tokens {\n+    /// Convert this pattern to a string that is guaranteed to be a valid\n+    /// regular expression and will represent the matching semantics of this\n+    /// glob pattern and the options given.\n+    fn to_regex(&self) -> String {\n+        self.to_regex_impl(Self::tokens_to_regex)\n+    }\n+\n+    /// Convert this pattern to a string that is guaranteed to be a valid\n+    /// regular expression and will represent the matching semantics of this\n+    /// glob pattern when used to check if a directory path might contain files that match this\n+    /// glob.\n+    /// This means we care about matching prefixes that are bounded by `/` characters.\n+    /// The basic strategy is to add 'early exits' to the regex at `/` boundaries.\n+    /// e.g. `foo/bar/baz` -> `foo(?:/bar(?:/baz(?:/.*)?)?)?`\n+    /// that way 'foo' will match but foo/baz will not\n+    fn to_directory_match_regex(&self) -> String {\n+        self.to_regex_impl(Self::tokens_to_directory_match_regex)\n+    }\n+\n+    fn to_regex_impl(&self, tokens_to_regex_fn: fn(&[Token], &mut String)) -> String {\n+        let mut re = String::new();\n+        // Our patterns are always anchored to the beginning and end of the string and we care not\n+        // for unicode correctness.  Paths do not require this and if the caller does they can\n+        // simply take care to pass us valid utf8 themselves.\n+        re.push_str(\"(?-u)^\");\n+        // Special case. If the entire glob is just `**`, then it should match\n+        // everything.\n+        if self.len() == 1 && self[0] == Token::RecursivePrefix {\n+            re.push_str(\".*$\");\n+            return re;\n+        }\n+        tokens_to_regex_fn(self, &mut re);\n+        re.push('$');\n+        re\n+    }\n+\n+    fn tokens_to_regex(tokens: &[Token], re: &mut String) {\n+        for tok in tokens.iter() {\n+            match *tok {\n+                Token::Literal(c) => {\n+                    re.push_str(&char_to_escaped_literal(c));\n+                }\n+                Token::Any => {\n+                    re.push_str(\"[^/]\");\n+                }\n+                Token::ZeroOrMore => {\n+                    re.push_str(\"[^/]*\");\n+                }\n+                Token::RecursivePrefix => {\n+                    re.push_str(\"(?:/?|.*/)\");\n+                }\n+                Token::RecursiveSuffix => {\n+                    re.push_str(\"/.*\");\n+                }\n+                Token::RecursiveZeroOrMore => {\n+                    re.push_str(\"(?:/|/.*/)\");\n+                }\n+                Token::Class {\n+                    negated,\n+                    ref ranges,\n+                    matches_slash: _,\n+                } => {\n+                    build_char_class(re, negated, ranges);\n+                }\n+                Token::Alternates(ref patterns) => {\n+                    build_alternates(re, patterns, Self::tokens_to_regex);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn tokens_to_directory_match_regex(tokens: &[Token], re: &mut String) {\n+        Self::tokens_to_directory_match_regex_inner(tokens, re, true)\n+    }\n+    fn tokens_to_directory_match_regex_inner(mut tokens: &[Token], re: &mut String, at_end: bool) {\n+        // If this branch is in a suffix position, then we need to try to trim any trailing filename\n+        // patterns. We do this by scanning\n+        if at_end {\n+            // first trim any trailing literal filename matches\n+            // e.g. foo/file.js -> foo/\n+            // globs match filenames so any trailing literal should not match a directory name.\n+            while let Some(tok) = tokens.last() {\n+                match tok {\n+                    Token::Literal(c) => {\n+                        tokens = &tokens[..tokens.len() - 1];\n+                        if *c == '/' {\n+                            // This is a directory separator, so we can stop trimming after this\n+                            break;\n+                        }\n+                    }\n+                    Token::Class {\n+                        negated: _,\n+                        ranges: _,\n+                        matches_slash,\n+                    } => {\n+                        if !*matches_slash {\n+                            // This is a non-slash literal or class that doesn't match a slash\n+                            // so we can trim it.\n+                            tokens = &tokens[..tokens.len() - 1];\n+                        } else {\n+                            break;\n+                        }\n+                    }\n+                    Token::ZeroOrMore | Token::Any => {\n+                        tokens = &tokens[..tokens.len() - 1];\n+                    }\n+                    Token::Alternates(_)\n+                    | Token::RecursiveZeroOrMore\n+                    | Token::RecursiveSuffix\n+                    | Token::RecursivePrefix => {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        let mut open_optional_suffixes: usize = 0;\n+        for (index, tok) in tokens.iter().enumerate() {\n+            match *tok {\n+                Token::Literal(c) => {\n+                    if c == '/' {\n+                        re.push_str(\"(?:\");\n+                        open_optional_suffixes += 1;\n+                    }\n+                    re.push_str(&char_to_escaped_literal(c));\n+                }\n+                Token::Any => {\n+                    re.push_str(\"[^/]\");\n+                }\n+                Token::ZeroOrMore => {\n+                    re.push_str(\"[^/]*\");\n+                }\n+                Token::RecursivePrefix => {\n+                    re.push_str(\".*\");\n+                    // A match like this will match all directories, so we don't need to examine the\n+                    // rest of the tokens.\n+                    break;\n+                }\n+                Token::RecursiveZeroOrMore | Token::RecursiveSuffix => {\n+                    re.push_str(\"(?:/.*)?\");\n+                    break;\n+                }\n+\n+                Token::Class {\n+                    negated,\n+                    ref ranges,\n+                    matches_slash,\n+                } => {\n+                    // If the class matches then a valid directory match is the prefix starting here\n+                    // so make the rest optional.\n+                    if matches_slash {\n+                        re.push_str(\"(?:\");\n+                        open_optional_suffixes += 1;\n+                    }\n+                    build_char_class(re, negated, ranges);\n+                }\n+                Token::Alternates(ref patterns) => {\n+                    build_alternates(\n+                        re,\n+                        patterns,\n+                        if index + 1 == tokens.len() {\n+                            Self::tokens_to_directory_match_regex\n+                        } else {\n+                            fn tokens_to_directory_match_regex_middle(\n+                                tokens: &[Token],\n+                                re: &mut String,\n+                            ) {\n+                                Tokens::tokens_to_directory_match_regex_inner(tokens, re, false)\n+                            }\n+                            tokens_to_directory_match_regex_middle\n+                        },\n+                    );\n+                }\n+            }\n+        }\n+        // close all the optional suffixes\n+        for _ in 0..open_optional_suffixes {\n+            re.push_str(\")?\")\n+        }\n+    }\n+}\n+\n+fn build_alternates(re: &mut String, patterns: &Vec<Tokens>, branch_fn: fn(&[Token], &mut String)) {\n+    let mut parts = Vec::with_capacity(patterns.len());\n+    for pat in patterns {\n+        let mut altre = String::new();\n+        branch_fn(pat, &mut altre);\n+        if !altre.is_empty() {\n+            parts.push(altre);\n+        }\n+    }\n+\n+    // It is possible to have an empty set in which case the\n+    // resulting alternation '()' would be an error.\n+    if !parts.is_empty() {\n+        re.push_str(\"(?:\");\n+        re.push_str(&parts.join(\"|\"));\n+        re.push(')');\n+    }\n+}\n+\n+fn build_char_class(re: &mut String, negated: bool, ranges: &Vec<(char, char)>) {\n+    re.push('[');\n+    if negated {\n+        re.push('^');\n+    }\n+    for r in ranges {\n+        if r.0 == r.1 {\n+            // Not strictly necessary, but nicer to look at.\n+            re.push_str(&char_to_escaped_literal(r.0));\n+        } else {\n+            re.push_str(&char_to_escaped_literal(r.0));\n+            re.push('-');\n+            re.push_str(&char_to_escaped_literal(r.1));\n+        }\n+    }\n+    re.push(']');\n+}\n+\n+/// Convert a Unicode scalar value to an escaped string suitable for use as\n+/// a literal in a non-Unicode regex.\n+fn char_to_escaped_literal(c: char) -> String {\n+    let mut buf = [0; 4];\n+    return regex::escape(c.encode_utf8(&mut buf));\n+}\n+\n+/// The kind of error that can occur when parsing a glob pattern.\n+#[derive(Clone, Debug, Eq, PartialEq)]\n+enum ErrorKind {\n+    /// Occurs when a character class (e.g., `[abc]`) is not closed.\n+    UnclosedClass,\n+    /// Occurs when a range in a character (e.g., `[a-z]`) is invalid. For\n+    /// example, if the range starts with a lexicographically larger character\n+    /// than it ends with.\n+    InvalidRange(char, char),\n+    /// Occurs when a `}` is found without a matching `{`.\n+    UnopenedAlternates,\n+    /// Occurs when a `{` is found without a matching `}`.\n+    UnclosedAlternates,\n+    /// Occurs when an unescaped '\\' is found at the end of a glob.\n+    DanglingEscape,\n+}\n+\n+impl ErrorKind {\n+    fn description(&self, pos: usize) -> String {\n+        let str: &'static str = match *self {\n+            ErrorKind::UnclosedClass => \"unclosed character class; missing ']'\",\n+            ErrorKind::InvalidRange(_, _) => \"invalid character range\",\n+            ErrorKind::UnopenedAlternates => {\n+                \"unopened alternate group; missing '{' (maybe escape '}' with '[}]'?)\"\n+            }\n+            ErrorKind::UnclosedAlternates => {\n+                \"unclosed alternate group; missing '}' (maybe escape '{' with '[{]'?)\"\n+            }\n+            ErrorKind::DanglingEscape => \"dangling '\\\\'\",\n+        };\n+        format!(\"{str} @{pos}\")\n+    }\n+}\n+\n+// Parse the glob and return a tuple of the regex and the directory match regex\n+// The regex is guaranteed to be valid and will match the same semantics as the glob.\n+// The directory match regex is guaranteed to be valid and will match the same\n+// semantics as the glob when used to check if a directory path might contain files that match\n+// this glob. This means we care about matching prefixes that are bounded by `/` characters.\n+pub(crate) fn parse(glob: &str) -> Result<(String, String), Error> {\n+    let tokens = Parser::new(glob).parse()?;\n+    Ok((tokens.to_regex(), tokens.to_directory_match_regex()))\n+}\n+\n+struct Parser<'a> {\n+    glob: &'a str,\n+    // Stores the offsets of where each set of nested alternates started.\n+    alternates_stack: Vec<usize>,\n+    // The current set of alternate branches being parsed.\n+    // Guaranteed to be non-empty.\n+    branches: Vec<Tokens>,\n+    chars: std::iter::Peekable<std::str::Chars<'a>>,\n+    // position in terms of characters, not bytes.\n+    char_pos: usize,\n+    prev: Option<char>,\n+    cur: Option<char>,\n+}\n+fn is_separator(c: char) -> bool {\n+    c == '/'\n+}\n+impl<'a> Parser<'a> {\n+    fn new(glob: &'a str) -> Self {\n+        Parser {\n+            glob,\n+            alternates_stack: vec![],\n+            branches: vec![Tokens::default()],\n+            chars: glob.chars().peekable(),\n+            char_pos: 0,\n+            prev: None,\n+            cur: None,\n+        }\n+    }\n+    fn error(&self, kind: ErrorKind) -> Error {\n+        Error::msg(kind.description(self.char_pos))\n+            .context(format!(\"Parsing glob pattern: {}\", self.glob))\n+    }\n+\n+    // Parsing consumes the parser\n+    fn parse(mut self) -> Result<Tokens, Error> {\n+        while let Some(c) = self.bump() {\n+            match c {\n+                '?' => self.push_token(Token::Any),\n+                '*' => self.parse_star(),\n+                '[' => self.parse_class()?,\n+                '{' => self.push_alternate(),\n+                '}' => self.pop_alternate()?,\n+                ',' => self.parse_comma(),\n+                '\\\\' => self.parse_backslash()?,\n+                c => self.push_token(Token::Literal(c)),\n+            }\n+        }\n+        if !self.alternates_stack.is_empty() {\n+            return Err(self.error(ErrorKind::UnclosedAlternates));\n+        }\n+        debug_assert!(self.branches.len() == 1);\n+        return Ok(self.branches.pop().unwrap());\n+    }\n+\n+    fn push_alternate(&mut self) {\n+        self.alternates_stack.push(self.branches.len());\n+        self.branches.push(Tokens::default());\n+    }\n+\n+    fn pop_alternate(&mut self) -> Result<(), Error> {\n+        let Some(start) = self.alternates_stack.pop() else {\n+            return Err(self.error(ErrorKind::UnopenedAlternates));\n+        };\n+        let alts = self.branches.split_off(start);\n+        self.push_token(Token::Alternates(alts));\n+        Ok(())\n+    }\n+\n+    fn push_token(&mut self, tok: Token) {\n+        self.branches.last_mut().unwrap().push(tok);\n+    }\n+\n+    // Panics if there are no tokens to pop.\n+    fn pop_token_unchecked(&mut self) -> Token {\n+        self.branches.last_mut().unwrap().pop().unwrap()\n+    }\n+\n+    fn have_tokens(&self) -> bool {\n+        !self.branches.last().unwrap().is_empty()\n+    }\n+\n+    fn parse_comma(&mut self) {\n+        // If we aren't inside a group alternation, then don't\n+        // treat commas specially. Otherwise, we need to start\n+        // a new alternate.\n+        if self.alternates_stack.is_empty() {\n+            self.push_token(Token::Literal(','))\n+        } else {\n+            self.branches.push(Tokens::default())\n+        }\n+    }\n+\n+    fn parse_backslash(&mut self) -> Result<(), Error> {\n+        match self.bump() {\n+            None => Err(self.error(ErrorKind::DanglingEscape)),\n+            Some(c) => {\n+                self.push_token(Token::Literal(c));\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    fn parse_star(&mut self) {\n+        // A trivial isolated '*'\n+        if self.peek() != Some('*') {\n+            self.push_token(Token::ZeroOrMore);\n+            return;\n+        }\n+        let prev = self.prev;\n+        // consume the next '*'\n+        assert!(self.bump() == Some('*'));\n+        // Are we at the very beginning of a branch?\n+        if !self.have_tokens() {\n+            // Are we at the end of the glob or a separator?\n+            if !self.peek().is_none_or(is_separator) {\n+                // Just push two zero or mores.\n+                // This is for something like '**foo/...`\n+                // See https://git-scm.com/docs/gitignore#_pattern_format for where this comes from\n+                self.push_token(Token::ZeroOrMore);\n+            } else {\n+                // this is just `**/....`\n+                self.push_token(Token::RecursivePrefix);\n+                assert!(self.bump().is_none_or(is_separator));\n+            }\n+            return;\n+        }\n+\n+        // Are we at the beginning or not following a `/`?\n+        if !prev.map(is_separator).unwrap_or(false) {\n+            // same as the above, this is just an odd `a**/` pattern\n+            self.push_token(Token::ZeroOrMore);\n+            return;\n+        }\n+        debug_assert!(prev == Some('/'));\n+        let is_suffix = match self.peek() {\n+            None => {\n+                assert!(self.bump().is_none());\n+                true\n+            }\n+            Some(',') | Some('}') if !self.alternates_stack.is_empty() => true,\n+            Some(c) if is_separator(c) => {\n+                assert!(self.bump().map(is_separator).unwrap_or(false));\n+                false\n+            }\n+            _ => {\n+                self.push_token(Token::ZeroOrMore);\n+                return;\n+            }\n+        };\n+        // we don't need to check because we already checked 'have_tokens' above.\n+        match self.pop_token_unchecked() {\n+            // This is for `/**/**` which is kind of silly, just skip the second occurence\n+            Token::RecursivePrefix => {\n+                self.push_token(Token::RecursivePrefix);\n+            }\n+            Token::RecursiveSuffix => {\n+                self.push_token(Token::RecursiveSuffix);\n+            }\n+            t => {\n+                // merge with the prior '/' token\n+                debug_assert!(Token::Literal('/') == t, \"unexpected token {t:?}\");\n+                if is_suffix {\n+                    // This is a `/**` at the end of a pattern.\n+                    self.push_token(Token::RecursiveSuffix);\n+                } else {\n+                    // This is a `/**/` in the middle of a pattern.\n+                    self.push_token(Token::RecursiveZeroOrMore);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn parse_class(&mut self) -> Result<(), Error> {\n+        fn add_to_last_range(r: &mut (char, char), add: char) -> Option<ErrorKind> {\n+            r.1 = add;\n+            if r.1 < r.0 {\n+                Some(ErrorKind::InvalidRange(r.0, r.1))\n+            } else {\n+                None\n+            }\n+        }\n+        let mut ranges = vec![];\n+        let negated = match self.chars.peek() {\n+            Some(&'!') | Some(&'^') => {\n+                let bump = self.bump();\n+                assert!(bump == Some('!') || bump == Some('^'));\n+                true\n+            }\n+            _ => false,\n+        };\n+        let mut first = true;\n+        let mut in_range = false;\n+        loop {\n+            let c = match self.bump() {\n+                Some(c) => c,\n+                // The only way to successfully break this loop is to observe\n+                // a ']'.\n+                None => return Err(self.error(ErrorKind::UnclosedClass)),\n+            };\n+            match c {\n+                ']' => {\n+                    if first {\n+                        ranges.push((']', ']'));\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                '-' => {\n+                    if first {\n+                        ranges.push(('-', '-'));\n+                    } else if in_range {\n+                        // invariant: in_range is only set when there is\n+                        // already at least one character seen.\n+                        let r = ranges.last_mut().unwrap();\n+                        if let Some(kind) = add_to_last_range(r, '-') {\n+                            return Err(self.error(kind));\n+                        }\n+                        in_range = false;\n+                    } else {\n+                        assert!(!ranges.is_empty());\n+                        in_range = true;\n+                    }\n+                }\n+                c => {\n+                    if in_range {\n+                        // invariant: in_range is only set when there is\n+                        // already at least one character seen.\n+                        if let Some(kind) = add_to_last_range(ranges.last_mut().unwrap(), '-') {\n+                            return Err(self.error(kind));\n+                        }\n+                    } else {\n+                        ranges.push((c, c));\n+                    }\n+                    in_range = false;\n+                }\n+            }\n+            first = false;\n+        }\n+        if in_range {\n+            // Means that the last character in the class was a '-', so add\n+            // it as a literal.\n+            ranges.push(('-', '-'));\n+        }\n+        // handle this as an alternation if it matches a `/`\n+        let matches_slash = if negated {\n+            // If all of the ranges exclude `/`, then the negation includes it.\n+            !ranges.iter().all(|r| r.0 > '/' || r.1 < '/')\n+        } else {\n+            // If any of the ranges include `/`, then the class includes it.\n+            ranges.iter().any(|r| r.0 <= '/' && r.1 >= '/')\n+        };\n+\n+        self.push_token(Token::Class {\n+            negated,\n+            ranges,\n+            matches_slash,\n+        });\n+        Ok(())\n+    }\n+\n+    fn bump(&mut self) -> Option<char> {\n+        self.prev = self.cur;\n+        self.cur = self.chars.next();\n+        if self.cur.is_some() {\n+            self.char_pos += 1;\n+        }\n+        self.cur\n+    }\n+\n+    fn peek(&mut self) -> Option<char> {\n+        self.chars.peek().copied()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use rstest::*;\n+\n+    use super::parse;\n+\n+    #[rstest]\n+    #[case::literal(\"dir/file.js\", \"dir/file\\\\.js\", \"dir\")]\n+    #[case::literal(\"a/b/c/file.js\", \"a/b/c/file\\\\.js\", \"a(?:/b(?:/c)?)?\")]\n+    #[case::globstar(\"**/file.js\", \"(?:/?|.*/)file\\\\.js\", \".*\")]\n+    #[case::globstar(\"/**/file.js\", \"(?:/|/.*/)file\\\\.js\", \"(?:/.*)?\")] // this one is a little silly since it does match the empty string\n+    #[case::globstar(\"a/**/file.js\", \"a(?:/|/.*/)file\\\\.js\", \"a(?:/.*)?\")]\n+    #[case::globstar(\"a/**\", \"a/.*\", \"a(?:/.*)?\")]\n+    #[case::alternates(\"{a,b,c}/d/**\", \"(?:a|b|c)/d/.*\", \"(?:a|b|c)(?:/d(?:/.*)?)?\")]\n+    #[case::nested_alternates(\n+        \"{a,b,c/{e,f,g}}/h/**\",\n+        \"(?:a|b|c/(?:e|f|g))/h/.*\",\n+        \"(?:a|b|c(?:/)?)(?:/h(?:/.*)?)?\"\n+    )]\n+    #[case::classes(\"[abc]/d/**\", \"[abc]/d/.*\", \"[abc](?:/d(?:/.*)?)?\")]\n+    fn glob_regex_mapping(\n+        #[case] glob: &str,\n+        #[case] glob_regex: &str,\n+        #[case] directory_match_regex: &str,\n+    ) {\n+        let (glob_re, directory_match_re) = parse(glob).unwrap();\n+        // All our regexes come with a fixed prefix and suffix, just assert and drop them\n+        fn strip_overhead(s: String) -> String {\n+            assert!(s.starts_with(\"(?-u)^\"));\n+            assert!(s.ends_with(\"$\"));\n+            s[\"(?-u)^\".len()..s.len() - 1].to_string()\n+        }\n+\n+        assert_eq!(glob_regex, strip_overhead(glob_re));\n+        assert_eq!(directory_match_regex, strip_overhead(directory_match_re));\n+    }\n+}"
        },
        {
            "sha": "a2679c5d7cf08e70962fb9c0252395bc6bda3b71",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=dd7fed079cee6861172e749b3a31c257ab206406",
            "patch": "@@ -11,6 +11,7 @@\n pub mod attach;\n pub mod embed;\n pub mod glob;\n+mod globset;\n pub mod invalidation;\n mod invalidator_map;\n pub mod json;"
        },
        {
            "sha": "24b5da87b7a50c357bd49b20af9a7d312995908c",
            "filename": "turbopack/crates/turbo-tasks-fs/src/read_glob.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs?ref=dd7fed079cee6861172e749b3a31c257ab206406",
            "patch": "@@ -83,7 +83,7 @@ async fn track_glob_internal(\n \n                 match resolve_symlink_safely(entry).await? {\n                     DirectoryEntry::Directory(path) => {\n-                        if glob_value.match_in_directory(&entry_path) {\n+                        if glob_value.can_match_in_directory(&entry_path) {\n                             completions.push(track_glob_inner(\n                                 entry_path,\n                                 *path,\n@@ -93,13 +93,13 @@ async fn track_glob_internal(\n                         }\n                     }\n                     DirectoryEntry::File(path) => {\n-                        if glob_value.execute(&entry_path) {\n+                        if glob_value.matches(&entry_path) {\n                             reads.push(fs.read(*path))\n                         }\n                     }\n-                    DirectoryEntry::Symlink(_) => panic!(\"we already resolved symlinks\"),\n+                    DirectoryEntry::Symlink(_) => unreachable!(\"we already resolved symlinks\"),\n                     DirectoryEntry::Other(path) => {\n-                        if glob_value.execute(&entry_path) {\n+                        if glob_value.matches(&entry_path) {\n                             types.push(path.get_type())\n                         }\n                     }"
        },
        {
            "sha": "6dbc69cfee7d981ddcc90f0ed82afc5f4abc40c3",
            "filename": "turbopack/crates/turbopack-core/src/resolve/options.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs?ref=dd7fed079cee6861172e749b3a31c257ab206406",
            "patch": "@@ -557,7 +557,7 @@ impl ResolvedMap {\n         for (root, glob, mapping) in self.by_glob.iter() {\n             let root = root.await?;\n             if let Some(path) = root.get_path_to(&resolved) {\n-                if glob.await?.execute(path) {\n+                if glob.await?.matches(path) {\n                     return Ok(import_mapping_to_result(\n                         *mapping.convert().await?,\n                         lookup_path,"
        },
        {
            "sha": "88f4b8eaf0279acb88f3e2f8e0473ae46b6ca9df",
            "filename": "turbopack/crates/turbopack-core/src/resolve/plugin.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fplugin.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fplugin.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fplugin.rs?ref=dd7fed079cee6861172e749b3a31c257ab206406",
            "patch": "@@ -31,7 +31,7 @@ impl AfterResolvePluginCondition {\n         let path = fs_path.await?;\n \n         if let Some(path) = root.get_path_to(&path) {\n-            if glob.execute(path) {\n+            if glob.matches(path) {\n                 return Ok(Vc::cell(true));\n             }\n         }\n@@ -66,7 +66,7 @@ impl BeforeResolvePluginCondition {\n     pub async fn matches(&self, request: Vc<Request>) -> Result<Vc<bool>> {\n         Ok(Vc::cell(match self {\n             BeforeResolvePluginCondition::Request(glob) => match request.await?.request() {\n-                Some(request) => glob.await?.execute(request.as_str()),\n+                Some(request) => glob.await?.matches(request.as_str()),\n                 None => false,\n             },\n             BeforeResolvePluginCondition::Modules(modules) => {"
        },
        {
            "sha": "aeedf0029055b1da8e47b5006341efe958091675",
            "filename": "turbopack/crates/turbopack-ecmascript/src/chunk/placeable.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fchunk%2Fplaceable.rs?ref=dd7fed079cee6861172e749b3a31c257ab206406",
            "patch": "@@ -164,7 +164,7 @@ pub async fn is_marked_as_side_effect_free(\n     path: Vc<FileSystemPath>,\n     side_effect_free_packages: Vc<Glob>,\n ) -> Result<Vc<bool>> {\n-    if side_effect_free_packages.await?.execute(&path.await?.path) {\n+    if side_effect_free_packages.await?.matches(&path.await?.path) {\n         return Ok(Vc::cell(true));\n     }\n \n@@ -181,7 +181,7 @@ pub async fn is_marked_as_side_effect_free(\n                     .get_relative_path_to(&*path.await?)\n                 {\n                     let rel_path = rel_path.strip_prefix(\"./\").unwrap_or(&rel_path);\n-                    return Ok(Vc::cell(!glob.await?.execute(rel_path)));\n+                    return Ok(Vc::cell(!glob.await?.matches(rel_path)));\n                 }\n             }\n         }"
        },
        {
            "sha": "b2d1fb573f30ce2c7ef372302a1c99a9a1044ae0",
            "filename": "turbopack/crates/turbopack/src/module_options/rule_condition.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/dd7fed079cee6861172e749b3a31c257ab206406/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Frule_condition.rs?ref=dd7fed079cee6861172e749b3a31c257ab206406",
            "patch": "@@ -148,17 +148,17 @@ impl RuleCondition {\n                     }\n                     RuleCondition::ResourcePathGlob { glob, base } => {\n                         return Ok(if let Some(rel_path) = base.get_relative_path_to(path) {\n-                            glob.execute(&rel_path)\n+                            glob.matches(&rel_path)\n                         } else {\n-                            glob.execute(&path.path)\n+                            glob.matches(&path.path)\n                         });\n                     }\n                     RuleCondition::ResourceBasePathGlob(glob) => {\n                         let basename = path\n                             .path\n                             .rsplit_once('/')\n                             .map_or(path.path.as_str(), |(_, b)| b);\n-                        return Ok(glob.execute(basename));\n+                        return Ok(glob.matches(basename));\n                     }\n                     RuleCondition::ResourcePathRegex(_) => {\n                         bail!(\"ResourcePathRegex not implemented yet\");"
        }
    ],
    "stats": {
        "total": 1181,
        "additions": 778,
        "deletions": 403
    }
}