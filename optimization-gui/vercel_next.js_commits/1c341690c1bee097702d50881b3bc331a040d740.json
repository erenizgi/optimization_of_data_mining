{
    "author": "lukesandberg",
    "message": "[turbopack] Lazily construct `resolved::Requests` for `EsmAssetReference` (#83662)\n\nRight now we construct `Request` objects eagerly when analyzing modules.   This is on the critical path for analysis and can be expensive if there are a lot of exports (See [thread](https://vercel.slack.com/archives/C06PPGZ0FD3/p1757517287294729))\n\nInstead just store the string and `parse` when resolving the reference.  This should have identical caching semantics and by deferring the work we may be able to avoid it altogether if certain references never get resolved due to `sideEffects` configuration.",
    "sha": "1c341690c1bee097702d50881b3bc331a040d740",
    "files": [
        {
            "sha": "83fda00d78dfbc5bee13335b7b61c9ea45500a5d",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/base.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 20,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/1c341690c1bee097702d50881b3bc331a040d740/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1c341690c1bee097702d50881b3bc331a040d740/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs?ref=1c341690c1bee097702d50881b3bc331a040d740",
            "patch": "@@ -43,10 +43,7 @@ use crate::{\n     code_gen::{CodeGeneration, CodeGenerationHoistedStmt},\n     export::Liveness,\n     magic_identifier,\n-    references::{\n-        esm::EsmExport,\n-        util::{request_to_string, throw_module_not_found_expr},\n-    },\n+    references::{esm::EsmExport, util::throw_module_not_found_expr},\n     runtime_functions::{TURBOPACK_EXTERNAL_IMPORT, TURBOPACK_EXTERNAL_REQUIRE, TURBOPACK_IMPORT},\n     tree_shake::{TURBOPACK_PART_IMPORT_SOURCE, asset::EcmascriptModulePartAsset},\n     utils::module_id_to_lit,\n@@ -321,7 +318,8 @@ impl EsmAssetReferences {\n #[derive(Hash, Debug)]\n pub struct EsmAssetReference {\n     pub origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n-    pub request: ResolvedVc<Request>,\n+    // Request is a string to avoid eagerly parsing into a `Request` VC\n+    pub request: RcStr,\n     pub annotations: ImportAnnotations,\n     pub issue_source: IssueSource,\n     pub export_name: Option<ModulePart>,\n@@ -342,7 +340,7 @@ impl EsmAssetReference {\n impl EsmAssetReference {\n     pub fn new(\n         origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n-        request: ResolvedVc<Request>,\n+        request: RcStr,\n         issue_source: IssueSource,\n         annotations: ImportAnnotations,\n         export_name: Option<ModulePart>,\n@@ -361,7 +359,7 @@ impl EsmAssetReference {\n \n     pub fn new_pure(\n         origin: ResolvedVc<Box<dyn ResolveOrigin>>,\n-        request: ResolvedVc<Request>,\n+        request: RcStr,\n         issue_source: IssueSource,\n         annotations: ImportAnnotations,\n         export_name: Option<ModulePart>,\n@@ -424,8 +422,9 @@ impl ModuleReference for EsmAssetReference {\n                 }\n             }\n         }\n+        let request = Request::parse(self.request.clone().into());\n \n-        if let Request::Module { module, .. } = &*self.request.await?\n+        if let Request::Module { module, .. } = &*request.await?\n             && module.is_match(TURBOPACK_PART_IMPORT_SOURCE)\n         {\n             if let Some(part) = &self.export_name {\n@@ -445,7 +444,7 @@ impl ModuleReference for EsmAssetReference {\n \n         let result = esm_resolve(\n             self.get_origin().resolve().await?,\n-            *self.request,\n+            request,\n             ty,\n             false,\n             Some(self.issue_source),\n@@ -475,15 +474,8 @@ impl ModuleReference for EsmAssetReference {\n #[turbo_tasks::value_impl]\n impl ValueToString for EsmAssetReference {\n     #[turbo_tasks::function]\n-    async fn to_string(&self) -> Result<Vc<RcStr>> {\n-        Ok(Vc::cell(\n-            format!(\n-                \"import {} with {}\",\n-                self.request.to_string().await?,\n-                self.annotations\n-            )\n-            .into(),\n-        ))\n+    fn to_string(&self) -> Vc<RcStr> {\n+        Vc::cell(format!(\"import {} with {}\", self.request, self.annotations).into())\n     }\n }\n \n@@ -537,9 +529,9 @@ impl EsmAssetReference {\n                 ReferencedAsset::Unresolvable => {\n                     // Insert code that throws immediately at time of import if a request is\n                     // unresolvable\n-                    let request = request_to_string(*this.request).await?.to_string();\n+                    let request = &this.request;\n                     let stmt = Stmt::Expr(ExprStmt {\n-                        expr: Box::new(throw_module_not_found_expr(&request)),\n+                        expr: Box::new(throw_module_not_found_expr(request)),\n                         span: DUMMY_SP,\n                     });\n                     return Ok(CodeGeneration::hoisted_stmt("
        },
        {
            "sha": "f1f8d3259174d1c51bf1f74548ac15bd6aed78d5",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 29,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/1c341690c1bee097702d50881b3bc331a040d740/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1c341690c1bee097702d50881b3bc331a040d740/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=1c341690c1bee097702d50881b3bc331a040d740",
            "patch": "@@ -738,42 +738,38 @@ pub async fn analyse_ecmascript_module_internal(\n             let mut should_add_evaluation = false;\n             let reference = EsmAssetReference::new(\n                 origin,\n-                Request::parse(RcStr::from(&*r.module_path).into())\n-                    .to_resolved()\n-                    .await?,\n+                RcStr::from(&*r.module_path),\n                 r.issue_source\n                     .unwrap_or_else(|| IssueSource::from_source_only(source)),\n                 r.annotations.clone(),\n-                match options.tree_shaking_mode {\n-                    Some(TreeShakingMode::ModuleFragments) => match &r.imported_symbol {\n-                        ImportedSymbol::ModuleEvaluation => {\n-                            should_add_evaluation = true;\n-                            Some(ModulePart::evaluation())\n-                        }\n-                        ImportedSymbol::Symbol(name) => Some(ModulePart::export((&**name).into())),\n-                        ImportedSymbol::PartEvaluation(part_id) => {\n-                            should_add_evaluation = true;\n-                            Some(ModulePart::internal(*part_id))\n-                        }\n-                        ImportedSymbol::Part(part_id) => Some(ModulePart::internal(*part_id)),\n-                        ImportedSymbol::Exports => Some(ModulePart::exports()),\n-                    },\n-                    _ => match &r.imported_symbol {\n-                        ImportedSymbol::ModuleEvaluation => {\n-                            should_add_evaluation = true;\n-                            Some(ModulePart::evaluation())\n-                        }\n-                        ImportedSymbol::Symbol(name) => Some(ModulePart::export((&**name).into())),\n-                        ImportedSymbol::PartEvaluation(_) | ImportedSymbol::Part(_) => {\n+                match &r.imported_symbol {\n+                    ImportedSymbol::ModuleEvaluation => {\n+                        should_add_evaluation = true;\n+                        Some(ModulePart::evaluation())\n+                    }\n+                    ImportedSymbol::Symbol(name) => Some(ModulePart::export((&**name).into())),\n+                    ImportedSymbol::PartEvaluation(part_id) | ImportedSymbol::Part(part_id) => {\n+                        if !matches!(\n+                            options.tree_shaking_mode,\n+                            Some(TreeShakingMode::ModuleFragments)\n+                        ) {\n                             bail!(\n-                                \"Internal imports doesn't exist in reexports only mode when \\\n+                                \"Internal imports only exist in reexports only mode when \\\n                                  importing {:?} from {}\",\n                                 r.imported_symbol,\n                                 r.module_path\n                             );\n                         }\n-                        ImportedSymbol::Exports => None,\n-                    },\n+                        if matches!(&r.imported_symbol, ImportedSymbol::PartEvaluation(_)) {\n+                            should_add_evaluation = true;\n+                        }\n+                        Some(ModulePart::internal(*part_id))\n+                    }\n+                    ImportedSymbol::Exports => matches!(\n+                        options.tree_shaking_mode,\n+                        Some(TreeShakingMode::ModuleFragments)\n+                    )\n+                    .then(ModulePart::exports),\n                 },\n                 import_externals,\n             )\n@@ -1406,7 +1402,7 @@ pub async fn analyse_ecmascript_module_internal(\n                                         || {\n                                             EsmAssetReference::new(\n                                                 original_reference.origin,\n-                                                original_reference.request,\n+                                                original_reference.request.clone(),\n                                                 original_reference.issue_source,\n                                                 original_reference.annotations.clone(),\n                                                 Some(ModulePart::export(export.clone())),\n@@ -2668,7 +2664,7 @@ async fn handle_free_var_reference(\n                         } else {\n                             state.origin\n                         },\n-                        Request::parse(request.clone().into()).to_resolved().await?,\n+                        request.clone(),\n                         IssueSource::from_swc_offsets(\n                             state.source,\n                             span.lo.to_u32(),"
        }
    ],
    "stats": {
        "total": 86,
        "additions": 37,
        "deletions": 49
    }
}