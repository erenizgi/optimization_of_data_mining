{
    "author": "sokra",
    "message": "[Turbopack] improve race condition handling of scheduling (#75748)\n\n<!-- Thanks for opening a PR! Your contribution is much appreciated.\r\nTo make sure your PR is handled as smoothly as possible we request that\r\nyou follow the checklist sections below.\r\nChoose the right checklist for the change(s) that you're making:\r\n\r\n## For Contributors\r\n\r\n### Improving Documentation\r\n\r\n- Run `pnpm prettier-fix` to fix formatting issues before opening the\r\nPR.\r\n- Read the Docs Contribution Guide to ensure your contribution follows\r\nthe docs guidelines:\r\nhttps://nextjs.org/docs/community/contribution-guide\r\n\r\n### Adding or Updating Examples\r\n\r\n- The \"examples guidelines\" are followed from our contributing doc\r\nhttps://github.com/vercel/next.js/blob/canary/contributing/examples/adding-examples.md\r\n- Make sure the linting passes by running `pnpm build && pnpm lint`. See\r\nhttps://github.com/vercel/next.js/blob/canary/contributing/repository/linting.md\r\n\r\n### Fixing a bug\r\n\r\n- Related issues linked using `fixes #number`\r\n- Tests added. See:\r\nhttps://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs\r\n- Errors have a helpful link attached, see\r\nhttps://github.com/vercel/next.js/blob/canary/contributing.md\r\n\r\n### Adding a feature\r\n\r\n- Implements an existing feature request or RFC. Make sure the feature\r\nrequest has been accepted for implementation before opening a PR. (A\r\ndiscussion must be opened, see\r\nhttps://github.com/vercel/next.js/discussions/new?category=ideas)\r\n- Related issues/discussions are linked using `fixes #number`\r\n- e2e tests added\r\n(https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs)\r\n- Documentation added\r\n- Telemetry added. In case of a feature if it's used or not.\r\n- Errors have a helpful link attached, see\r\nhttps://github.com/vercel/next.js/blob/canary/contributing.md\r\n\r\n\r\n## For Maintainers\r\n\r\n- Minimal description (aim for explaining to someone not on the team to\r\nunderstand the PR)\r\n- When linking to a Slack thread, you might want to share details of the\r\nconclusion\r\n- Link both the Linear (Fixes NEXT-xxx) and the GitHub issues\r\n- Add review comments if necessary to explain to the reviewer the logic\r\nbehind a change\r\n\r\n### What?\r\n\r\n### Why?\r\n\r\n### How?\r\n\r\nCloses NEXT-\r\nFixes #\r\n\r\n-->",
    "sha": "f95d8b98067103b452ed202e94e40ea6834f3526",
    "files": [
        {
            "sha": "086298c619f5b164d39caaed43565eeee4fc75e3",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/aggregation_update.rs",
            "status": "modified",
            "additions": 96,
            "deletions": 71,
            "changes": 167,
            "blob_url": "https://github.com/vercel/next.js/blob/f95d8b98067103b452ed202e94e40ea6834f3526/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f95d8b98067103b452ed202e94e40ea6834f3526/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs?ref=f95d8b98067103b452ed202e94e40ea6834f3526",
            "patch": "@@ -1575,25 +1575,35 @@ impl AggregationUpdateQueue {\n                 let children = get_followers(&follower);\n                 drop(follower);\n \n-                if !data.is_empty() {\n+                let has_data = !data.is_empty();\n+                if has_data || !is_active {\n                     for upper_id in upper_ids.iter() {\n                         // add data to upper\n                         let mut upper = ctx.task(*upper_id, TaskDataCategory::Meta);\n-                        let diff = data.apply(\n-                            &mut upper,\n-                            ctx.session_id(),\n-                            ctx.should_track_activeness(),\n-                            self,\n-                        );\n-                        if !diff.is_empty() {\n-                            let upper_ids = get_uppers(&upper);\n-                            self.push(\n-                                AggregatedDataUpdateJob {\n-                                    upper_ids,\n-                                    update: diff,\n-                                }\n-                                .into(),\n-                            )\n+                        if has_data {\n+                            let diff = data.apply(\n+                                &mut upper,\n+                                ctx.session_id(),\n+                                ctx.should_track_activeness(),\n+                                self,\n+                            );\n+                            if !diff.is_empty() {\n+                                let upper_ids = get_uppers(&upper);\n+                                self.push(\n+                                    AggregatedDataUpdateJob {\n+                                        upper_ids,\n+                                        update: diff,\n+                                    }\n+                                    .into(),\n+                                )\n+                            }\n+                        }\n+                        if !is_active {\n+                            // We need to check this again, since this might have changed in the\n+                            // meantime due to race conditions\n+                            if upper.has_key(&CachedDataItemKey::Activeness {}) {\n+                                is_active = true;\n+                            }\n                         }\n                     }\n                 }\n@@ -1647,7 +1657,7 @@ impl AggregationUpdateQueue {\n                 let follower = ctx.task(new_follower_id, TaskDataCategory::Meta);\n                 (new_follower_id, get_aggregation_number(&follower))\n             })\n-            .collect::<Vec<_>>();\n+            .collect::<SmallVec<[_; 4]>>();\n \n         let mut new_followers_of_upper_uppers = SmallVec::new();\n         let mut is_active = false;\n@@ -1699,43 +1709,51 @@ impl AggregationUpdateQueue {\n             }\n         }\n \n-        if !followers_with_aggregation_number.is_empty() {\n+        let mut inner_tasks_with_aggregation_number = followers_with_aggregation_number;\n+\n+        if !inner_tasks_with_aggregation_number.is_empty() {\n             #[cfg(feature = \"trace_aggregation_update\")]\n             let _span = trace_span!(\"new inner\").entered();\n             let mut upper_data_updates = Vec::new();\n             let mut upper_new_followers = SmallVec::new();\n-            for &(follower_id, _) in followers_with_aggregation_number.iter() {\n-                let mut follower = ctx.task(follower_id, TaskDataCategory::Meta);\n-                if update_count!(follower, Upper { task: upper_id }, 1) {\n-                    if count!(follower, Upper).is_power_of_two() {\n-                        self.push_optimize_task(follower_id);\n-                    }\n+            swap_retain(\n+                &mut inner_tasks_with_aggregation_number,\n+                |&mut (inner_id, _)| {\n+                    let mut inner = ctx.task(inner_id, TaskDataCategory::Meta);\n+                    if update_count!(inner, Upper { task: upper_id }, 1) {\n+                        if count!(inner, Upper).is_power_of_two() {\n+                            self.push_optimize_task(inner_id);\n+                        }\n \n-                    // It's a new upper\n-                    let data = AggregatedDataUpdate::from_task(&mut follower);\n-                    let children = get_followers(&follower);\n-                    let follower_aggregation_number = get_aggregation_number(&follower);\n-                    drop(follower);\n+                        // It's a new upper\n+                        let data = AggregatedDataUpdate::from_task(&mut inner);\n+                        let children = get_followers(&inner);\n+                        let follower_aggregation_number = get_aggregation_number(&inner);\n+                        drop(inner);\n \n-                    if !data.is_empty() {\n-                        upper_data_updates.push(data);\n-                    }\n-                    upper_new_followers.extend(children);\n-\n-                    // Balancing is only needed when they are equal (or could have become equal in\n-                    // the meantime). This is not perfect from concurrent\n-                    // perspective, but we can accept a few incorrect invariants\n-                    // in the graph.\n-                    if upper_aggregation_number <= follower_aggregation_number\n-                        && !is_root_node(upper_aggregation_number)\n-                    {\n-                        self.push(AggregationUpdateJob::BalanceEdge {\n-                            upper_id,\n-                            task_id: follower_id,\n-                        })\n+                        if !data.is_empty() {\n+                            upper_data_updates.push(data);\n+                        }\n+                        upper_new_followers.extend(children);\n+\n+                        // Balancing is only needed when they are equal (or could have become equal\n+                        // in the meantime). This is not perfect from\n+                        // concurrent perspective, but we can accept a few\n+                        // incorrect invariants in the graph.\n+                        if upper_aggregation_number <= follower_aggregation_number\n+                            && !is_root_node(upper_aggregation_number)\n+                        {\n+                            self.push(AggregationUpdateJob::BalanceEdge {\n+                                upper_id,\n+                                task_id: inner_id,\n+                            })\n+                        }\n+                        true\n+                    } else {\n+                        false\n                     }\n-                }\n-            }\n+                },\n+            );\n \n             if !upper_new_followers.is_empty() {\n                 self.push(AggregationUpdateJob::InnerOfUpperHasNewFollowers {\n@@ -1782,12 +1800,20 @@ impl AggregationUpdateQueue {\n                     );\n                 }\n             }\n-            if is_active {\n-                self.extend_find_and_schedule_dirty(\n-                    followers_with_aggregation_number\n-                        .into_iter()\n-                        .map(|(id, _)| id),\n-                );\n+            if !inner_tasks_with_aggregation_number.is_empty() {\n+                if !is_active {\n+                    // We need to check this again, since this might have changed in the\n+                    // meantime due to race conditions\n+                    let upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+                    is_active = upper.has_key(&CachedDataItemKey::Activeness {});\n+                }\n+                if is_active {\n+                    self.extend_find_and_schedule_dirty(\n+                        inner_tasks_with_aggregation_number\n+                            .into_iter()\n+                            .map(|(id, _)| id),\n+                    );\n+                }\n             }\n         }\n         if !new_followers_of_upper_uppers.is_empty() {\n@@ -1821,23 +1847,13 @@ impl AggregationUpdateQueue {\n     ) {\n         #[cfg(feature = \"trace_aggregation_update\")]\n         let _span = trace_span!(\"process new follower\").entered();\n-        let should_track_activeness = ctx.should_track_activeness();\n \n-        let (follower_aggregation_number, already_active) = {\n+        let follower_aggregation_number = {\n             let follower = ctx.task(new_follower_id, TaskDataCategory::Meta);\n-            (\n-                get_aggregation_number(&follower),\n-                should_track_activeness && follower.has_key(&CachedDataItemKey::Activeness {}),\n-            )\n+            get_aggregation_number(&follower)\n         };\n \n         let mut upper = ctx.task(upper_id, TaskDataCategory::Meta);\n-        if should_track_activeness\n-            && !already_active\n-            && upper.has_key(&CachedDataItemKey::Activeness {})\n-        {\n-            self.push_find_and_schedule_dirty(new_follower_id);\n-        }\n         // decide if it should be an inner or follower\n         let upper_aggregation_number = get_aggregation_number(&upper);\n \n@@ -1893,16 +1909,18 @@ impl AggregationUpdateQueue {\n             let _span = trace_span!(\"new inner\").entered();\n \n             // It's an inner node, continue with the list\n+            let mut is_active = upper.has_key(&CachedDataItemKey::Activeness {});\n             drop(upper);\n-            let mut follower = ctx.task(new_follower_id, TaskDataCategory::Meta);\n-            if update_count!(follower, Upper { task: upper_id }, 1) {\n-                if count!(follower, Upper).is_power_of_two() {\n+\n+            let mut inner = ctx.task(new_follower_id, TaskDataCategory::Meta);\n+            if update_count!(inner, Upper { task: upper_id }, 1) {\n+                if count!(inner, Upper).is_power_of_two() {\n                     self.push_optimize_task(new_follower_id);\n                 }\n                 // It's a new upper\n-                let data = AggregatedDataUpdate::from_task(&mut follower);\n-                let followers = get_followers(&follower);\n-                drop(follower);\n+                let data = AggregatedDataUpdate::from_task(&mut inner);\n+                let followers = get_followers(&inner);\n+                drop(inner);\n \n                 if !data.is_empty() {\n                     // add data to upper\n@@ -1930,6 +1948,13 @@ impl AggregationUpdateQueue {\n                         new_follower_ids: followers,\n                     });\n                 }\n+                if !is_active {\n+                    let upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+                    is_active = upper.has_key(&CachedDataItemKey::Activeness {});\n+                }\n+                if is_active {\n+                    self.push_find_and_schedule_dirty(new_follower_id);\n+                }\n             }\n         }\n     }"
        }
    ],
    "stats": {
        "total": 167,
        "additions": 96,
        "deletions": 71
    }
}