{
    "author": "lukesandberg",
    "message": "[turbopack] Fix a few small things in the analyzer (#82899)\n\n* Delete some dead code\n* Remove some unnecessary `async` and `pub` modifiers\n     * i think the `async`'s were made unnecesssary when we made `FilesystemPath` no longer be a `Vc<>`",
    "sha": "b478e57de89fb1611e7124b38bbbe7070b6eb1a3",
    "files": [
        {
            "sha": "ef4e8306c841bf2d9eaf923e99dd0c3fb13a138e",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/mod.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 300,
            "changes": 300,
            "blob_url": "https://github.com/vercel/next.js/blob/b478e57de89fb1611e7124b38bbbe7070b6eb1a3/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b478e57de89fb1611e7124b38bbbe7070b6eb1a3/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fmod.rs?ref=b478e57de89fb1611e7124b38bbbe7070b6eb1a3",
            "patch": "@@ -4,10 +4,8 @@ use std::{\n     borrow::Cow,\n     cmp::Ordering,\n     fmt::{Display, Formatter, Write},\n-    future::Future,\n     hash::{BuildHasherDefault, Hash, Hasher},\n     mem::take,\n-    pin::Pin,\n     sync::Arc,\n };\n \n@@ -45,11 +43,6 @@ pub mod linker;\n pub mod top_level_await;\n pub mod well_known;\n \n-type PinnedAsyncUntilSettledBox<'a, E> =\n-    Pin<Box<dyn Future<Output = Result<(JsValue, bool), E>> + Send + 'a>>;\n-\n-type PinnedAsyncBox<'a, E> = Pin<Box<dyn Future<Output = Result<(JsValue, bool), E>> + 'a>>;\n-\n #[derive(Debug, Clone, Hash, PartialEq, Eq)]\n pub enum ObjectPart {\n     KeyValue(JsValue, JsValue),\n@@ -2610,301 +2603,8 @@ fn shortcircuit_if_known<T: Copy>(\n     None\n }\n \n-/// Macro to visit all children of a node with an async function\n-macro_rules! for_each_children_async {\n-    ($value:expr, $visit_fn:expr, $($args:expr),+) => {\n-        Ok(match &mut $value {\n-            JsValue::Alternatives { total_nodes: _, values: list, logical_property: _ }\n-            | JsValue::Concat(_, list)\n-            | JsValue::Add(_, list)\n-            | JsValue::Logical(_, _, list)\n-            | JsValue::Array{ items: list, ..} => {\n-                let mut modified = false;\n-                for item in list.iter_mut() {\n-                    let (v, m) = $visit_fn(take(item), $($args),+).await?;\n-                    *item = v;\n-                    if m {\n-                        modified = true\n-                    }\n-                }\n-                $value.update_total_nodes();\n-                ($value, modified)\n-            }\n-            JsValue::Object{ parts, ..} => {\n-                let mut modified = false;\n-                for item in parts.iter_mut() {\n-                    match item {\n-                        ObjectPart::KeyValue(key, value) => {\n-                            let (v, m) = $visit_fn(take(key), $($args),+).await?;\n-                            *key = v;\n-                            if m {\n-                                modified = true\n-                            }\n-                            let (v, m) = $visit_fn(take(value), $($args),+).await?;\n-                            *value = v;\n-                            if m {\n-                                modified = true\n-                            }\n-                        }\n-                        ObjectPart::Spread(value) => {\n-                            let (v, m) = $visit_fn(take(value), $($args),+).await?;\n-                            *value = v;\n-                            if m {\n-                                modified = true\n-                            }\n-                        }\n-                    }\n-\n-                }\n-                $value.update_total_nodes();\n-                ($value, modified)\n-            }\n-            JsValue::New(_, box callee, list) => {\n-                let (new_callee, mut modified) = $visit_fn(take(callee), $($args),+).await?;\n-                *callee = new_callee;\n-                for item in list.iter_mut() {\n-                    let (v, m) = $visit_fn(take(item), $($args),+).await?;\n-                    *item = v;\n-                    if m {\n-                        modified = true\n-                    }\n-                }\n-                $value.update_total_nodes();\n-                ($value, modified)\n-            }\n-            JsValue::Call(_, box callee, list) => {\n-                let (new_callee, mut modified) = $visit_fn(take(callee), $($args),+).await?;\n-                *callee = new_callee;\n-                for item in list.iter_mut() {\n-                    let (v, m) = $visit_fn(take(item), $($args),+).await?;\n-                    *item = v;\n-                    if m {\n-                        modified = true\n-                    }\n-                }\n-                $value.update_total_nodes();\n-                ($value, modified)\n-            }\n-            JsValue::SuperCall(_, list) => {\n-                let mut modified = false;\n-                for item in list.iter_mut() {\n-                    let (v, m) = $visit_fn(take(item), $($args),+).await?;\n-                    *item = v;\n-                    if m {\n-                        modified = true\n-                    }\n-                }\n-                $value.update_total_nodes();\n-                ($value, modified)\n-            }\n-            JsValue::MemberCall(_, box obj, box prop, list) => {\n-                let (new_callee, m1) = $visit_fn(take(obj), $($args),+).await?;\n-                *obj = new_callee;\n-                let (new_member, m2) = $visit_fn(take(prop), $($args),+).await?;\n-                *prop = new_member;\n-                let mut modified = m1 || m2;\n-                for item in list.iter_mut() {\n-                    let (v, m) = $visit_fn(take(item), $($args),+).await?;\n-                    *item = v;\n-                    if m {\n-                        modified = true\n-                    }\n-                }\n-                $value.update_total_nodes();\n-                ($value, modified)\n-            }\n-\n-            JsValue::Function(_, _, box return_value) => {\n-                let (new_return_value, modified) = $visit_fn(take(return_value), $($args),+).await?;\n-                *return_value = new_return_value;\n-\n-                $value.update_total_nodes();\n-                ($value, modified)\n-            }\n-            JsValue::Not(_, box value) => {\n-                let (new_value, modified) = $visit_fn(take(value), $($args),+).await?;\n-                *value = new_value;\n-\n-                $value.update_total_nodes();\n-                ($value, modified)\n-            }\n-            JsValue::Binary(_, box a, _, box b) => {\n-                let (v, m1) = $visit_fn(take(a), $($args),+).await?;\n-                *a = v;\n-                let (v, m2) = $visit_fn(take(b), $($args),+).await?;\n-                *b = v;\n-                $value.update_total_nodes();\n-                ($value, m1 || m2)\n-            }\n-            JsValue::Tenary(_, box test, box cons, box alt) => {\n-                let (v, m1) = $visit_fn(take(test), $($args),+).await?;\n-                *test = v;\n-                let (v, m2) = $visit_fn(take(cons), $($args),+).await?;\n-                *cons = v;\n-                let (v, m3) = $visit_fn(take(alt), $($args),+).await?;\n-                *alt = v;\n-                $value.update_total_nodes();\n-                ($value, m1 || m2 || m3)\n-            }\n-            JsValue::Member(_, box obj, box prop) => {\n-                let (v, m1) = $visit_fn(take(obj), $($args),+).await?;\n-                *obj = v;\n-                let (v, m2) = $visit_fn(take(prop), $($args),+).await?;\n-                *prop = v;\n-                $value.update_total_nodes();\n-                ($value, m1 || m2)\n-            }\n-            JsValue::Iterated(_, box operand)\n-            | JsValue::TypeOf(_, box operand)\n-            | JsValue::Promise(_, box operand)\n-            | JsValue::Awaited(_, box operand) => {\n-                let (new_operand, modified) = $visit_fn(take(operand), $($args),+).await?;\n-                *operand = new_operand;\n-\n-                $value.update_total_nodes();\n-                ($value, modified)\n-            }\n-            JsValue::Constant(_)\n-            | JsValue::FreeVar(_)\n-            | JsValue::Variable(_)\n-            | JsValue::Module(..)\n-            | JsValue::Url(_, _)\n-            | JsValue::WellKnownObject(_)\n-            | JsValue::WellKnownFunction(_)\n-            | JsValue::Unknown { .. }\n-            | JsValue::Argument(..) => ($value, false),\n-        })\n-    }\n-}\n-\n // Visiting\n impl JsValue {\n-    /// Visit the node and all its children with a function in a loop until the\n-    /// visitor returns false for the node and all children\n-    pub async fn visit_async_until_settled<'a, F, R, E>(\n-        self,\n-        visitor: &mut F,\n-    ) -> Result<(Self, bool), E>\n-    where\n-        R: 'a + Future<Output = Result<(Self, bool), E>> + Send,\n-        F: 'a + FnMut(JsValue) -> R + Send,\n-    {\n-        let mut modified = false;\n-        let mut v = self;\n-        loop {\n-            let m;\n-            (v, m) = visitor(take(&mut v)).await?;\n-            if !m {\n-                break;\n-            }\n-            modified = true;\n-            v = take(&mut v)\n-                .visit_each_children_async_until_settled(visitor)\n-                .await?;\n-        }\n-        Ok((v, modified))\n-    }\n-\n-    /// Visit all children of the node with an async function in a loop until\n-    /// the visitor returns false\n-    pub async fn visit_each_children_async_until_settled<'a, F, R, E>(\n-        mut self,\n-        visitor: &mut F,\n-    ) -> Result<Self, E>\n-    where\n-        R: 'a + Future<Output = Result<(Self, bool), E>> + Send,\n-        F: 'a + FnMut(JsValue) -> R + Send,\n-    {\n-        fn visit_async_until_settled_box<'a, F, R, E>(\n-            value: JsValue,\n-            visitor: &'a mut F,\n-        ) -> PinnedAsyncUntilSettledBox<'a, E>\n-        where\n-            R: 'a + Future<Output = Result<(JsValue, bool), E>> + Send,\n-            F: 'a + FnMut(JsValue) -> R + Send,\n-            E: 'a,\n-        {\n-            Box::pin(value.visit_async_until_settled(visitor))\n-        }\n-        let (v, _) = for_each_children_async!(self, visit_async_until_settled_box, visitor)?;\n-        Ok(v)\n-    }\n-\n-    /// Visit the node and all its children with an async function.\n-    pub async fn visit_async<'a, F, R, E>(self, visitor: &mut F) -> Result<(Self, bool), E>\n-    where\n-        R: 'a + Future<Output = Result<(Self, bool), E>>,\n-        F: 'a + FnMut(JsValue) -> R,\n-    {\n-        let (v, modified) = self.visit_each_children_async(visitor).await?;\n-        let (v, m) = visitor(v).await?;\n-        if m { Ok((v, true)) } else { Ok((v, modified)) }\n-    }\n-\n-    /// Visit all children of the node with an async function.\n-    pub async fn visit_each_children_async<'a, F, R, E>(\n-        mut self,\n-        visitor: &mut F,\n-    ) -> Result<(Self, bool), E>\n-    where\n-        R: 'a + Future<Output = Result<(Self, bool), E>>,\n-        F: 'a + FnMut(JsValue) -> R,\n-    {\n-        fn visit_async_box<'a, F, R, E>(value: JsValue, visitor: &'a mut F) -> PinnedAsyncBox<'a, E>\n-        where\n-            R: 'a + Future<Output = Result<(JsValue, bool), E>>,\n-            F: 'a + FnMut(JsValue) -> R,\n-            E: 'a,\n-        {\n-            Box::pin(value.visit_async(visitor))\n-        }\n-        for_each_children_async!(self, visit_async_box, visitor)\n-    }\n-\n-    /// Call an async function for each child of the node.\n-    pub async fn for_each_children_async<'a, F, R, E>(\n-        mut self,\n-        visitor: &mut F,\n-    ) -> Result<(Self, bool), E>\n-    where\n-        R: 'a + Future<Output = Result<(Self, bool), E>>,\n-        F: 'a + FnMut(JsValue) -> R,\n-    {\n-        for_each_children_async!(self, |v, ()| visitor(v), ())\n-    }\n-\n-    /// Visit the node and all its children with a function in a loop until the\n-    /// visitor returns false\n-    pub fn visit_mut_until_settled(&mut self, visitor: &mut impl FnMut(&mut JsValue) -> bool) {\n-        while visitor(self) {\n-            self.for_each_children_mut(&mut |value| {\n-                value.visit_mut_until_settled(visitor);\n-                false\n-            });\n-        }\n-    }\n-\n-    /// Visit the node and all its children with a function.\n-    pub fn visit_mut(&mut self, visitor: &mut impl FnMut(&mut JsValue) -> bool) -> bool {\n-        let modified = self.for_each_children_mut(&mut |value| value.visit_mut(visitor));\n-        if visitor(self) { true } else { modified }\n-    }\n-\n-    /// Visit all children of the node with a function. Only visits nodes where\n-    /// the condition is true.\n-    pub fn visit_mut_conditional(\n-        &mut self,\n-        condition: impl Fn(&JsValue) -> bool,\n-        visitor: &mut impl FnMut(&mut JsValue) -> bool,\n-    ) -> bool {\n-        if condition(self) {\n-            let modified = self.for_each_children_mut(&mut |value| value.visit_mut(visitor));\n-            if visitor(self) { true } else { modified }\n-        } else {\n-            false\n-        }\n-    }\n-\n     /// Calls a function for each child of the node. Allows mutating the node.\n     /// Updates the total nodes count after mutation.\n     pub fn for_each_children_mut("
        },
        {
            "sha": "254ee8d4b997fa7f0a7dce832e5ae5369f71f560",
            "filename": "turbopack/crates/turbopack-ecmascript/src/analyzer/well_known.rs",
            "status": "modified",
            "additions": 18,
            "deletions": 21,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/b478e57de89fb1611e7124b38bbbe7070b6eb1a3/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fwell_known.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b478e57de89fb1611e7124b38bbbe7070b6eb1a3/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fwell_known.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fanalyzer%2Fwell_known.rs?ref=b478e57de89fb1611e7124b38bbbe7070b6eb1a3",
            "patch": "@@ -61,13 +61,13 @@ pub async fn well_known_function_call(\n         WellKnownFunctionKind::Import => import(args),\n         WellKnownFunctionKind::Require => require(args),\n         WellKnownFunctionKind::RequireContextRequire(value) => {\n-            require_context_require(value, args).await?\n+            require_context_require(value, args)?\n         }\n         WellKnownFunctionKind::RequireContextRequireKeys(value) => {\n-            require_context_require_keys(value, args).await?\n+            require_context_require_keys(value, args)?\n         }\n         WellKnownFunctionKind::RequireContextRequireResolve(value) => {\n-            require_context_require_resolve(value, args).await?\n+            require_context_require_resolve(value, args)?\n         }\n         WellKnownFunctionKind::PathToFileUrl => path_to_file_url(args),\n         WellKnownFunctionKind::OsArch => compile_time_info\n@@ -118,7 +118,7 @@ pub async fn well_known_function_call(\n     })\n }\n \n-pub fn object_assign(args: Vec<JsValue>) -> JsValue {\n+fn object_assign(args: Vec<JsValue>) -> JsValue {\n     if args.iter().all(|arg| matches!(arg, JsValue::Object { .. })) {\n         if let Some(mut merged_object) = args.into_iter().reduce(|mut acc, cur| {\n             if let JsValue::Object { parts, mutable, .. } = &mut acc\n@@ -161,7 +161,7 @@ pub fn object_assign(args: Vec<JsValue>) -> JsValue {\n     }\n }\n \n-pub fn path_join(args: Vec<JsValue>) -> JsValue {\n+fn path_join(args: Vec<JsValue>) -> JsValue {\n     if args.is_empty() {\n         return rcstr!(\".\").into();\n     }\n@@ -217,7 +217,7 @@ pub fn path_join(args: Vec<JsValue>) -> JsValue {\n     JsValue::concat(results)\n }\n \n-pub fn path_resolve(cwd: JsValue, mut args: Vec<JsValue>) -> JsValue {\n+fn path_resolve(cwd: JsValue, mut args: Vec<JsValue>) -> JsValue {\n     // If no path segments are passed, `path.resolve()` will return the absolute\n     // path of the current working directory.\n     if args.is_empty() {\n@@ -292,7 +292,7 @@ pub fn path_resolve(cwd: JsValue, mut args: Vec<JsValue>) -> JsValue {\n     JsValue::concat(results)\n }\n \n-pub fn path_dirname(mut args: Vec<JsValue>) -> JsValue {\n+fn path_dirname(mut args: Vec<JsValue>) -> JsValue {\n     if let Some(arg) = args.iter_mut().next() {\n         if let Some(str) = arg.as_str() {\n             if let Some(i) = str.rfind('/') {\n@@ -344,7 +344,7 @@ pub fn import(args: Vec<JsValue>) -> JsValue {\n \n /// Resolve the contents of a require call, throwing errors\n /// if we come across any unsupported syntax.\n-pub fn require(args: Vec<JsValue>) -> JsValue {\n+fn require(args: Vec<JsValue>) -> JsValue {\n     if args.len() == 1 {\n         if let Some(s) = args[0].as_str() {\n             JsValue::Module(ModuleValue {\n@@ -374,7 +374,7 @@ pub fn require(args: Vec<JsValue>) -> JsValue {\n }\n \n /// (try to) statically evaluate `require.context(...)()`\n-async fn require_context_require(val: RequireContextValue, args: Vec<JsValue>) -> Result<JsValue> {\n+fn require_context_require(val: RequireContextValue, args: Vec<JsValue>) -> Result<JsValue> {\n     if args.is_empty() {\n         return Ok(JsValue::unknown(\n             JsValue::call(\n@@ -422,10 +422,7 @@ async fn require_context_require(val: RequireContextValue, args: Vec<JsValue>) -\n }\n \n /// (try to) statically evaluate `require.context(...).keys()`\n-async fn require_context_require_keys(\n-    val: RequireContextValue,\n-    args: Vec<JsValue>,\n-) -> Result<JsValue> {\n+fn require_context_require_keys(val: RequireContextValue, args: Vec<JsValue>) -> Result<JsValue> {\n     Ok(if args.is_empty() {\n         JsValue::array(val.0.keys().cloned().map(|k| k.into()).collect())\n     } else {\n@@ -443,7 +440,7 @@ async fn require_context_require_keys(\n }\n \n /// (try to) statically evaluate `require.context(...).resolve()`\n-async fn require_context_require_resolve(\n+fn require_context_require_resolve(\n     val: RequireContextValue,\n     args: Vec<JsValue>,\n ) -> Result<JsValue> {\n@@ -490,7 +487,7 @@ async fn require_context_require_resolve(\n     Ok(m.as_str().into())\n }\n \n-pub fn path_to_file_url(args: Vec<JsValue>) -> JsValue {\n+fn path_to_file_url(args: Vec<JsValue>) -> JsValue {\n     if args.len() == 1 {\n         if let Some(path) = args[0].as_str() {\n             Url::from_file_path(path)\n@@ -533,7 +530,7 @@ pub fn path_to_file_url(args: Vec<JsValue>) -> JsValue {\n     }\n }\n \n-pub fn well_known_function_member(kind: WellKnownFunctionKind, prop: JsValue) -> (JsValue, bool) {\n+fn well_known_function_member(kind: WellKnownFunctionKind, prop: JsValue) -> (JsValue, bool) {\n     let new_value = match (kind, prop.as_str()) {\n         (WellKnownFunctionKind::Require, Some(\"resolve\")) => {\n             JsValue::WellKnownFunction(WellKnownFunctionKind::RequireResolve)\n@@ -570,7 +567,7 @@ pub fn well_known_function_member(kind: WellKnownFunctionKind, prop: JsValue) ->\n     (new_value, true)\n }\n \n-pub async fn well_known_object_member(\n+async fn well_known_object_member(\n     kind: WellKnownObjectKind,\n     prop: JsValue,\n     compile_time_info: Vc<CompileTimeInfo>,\n@@ -621,7 +618,7 @@ fn global_object(prop: JsValue) -> JsValue {\n     }\n }\n \n-pub fn path_module_member(kind: WellKnownObjectKind, prop: JsValue) -> JsValue {\n+fn path_module_member(kind: WellKnownObjectKind, prop: JsValue) -> JsValue {\n     match (kind, prop.as_str()) {\n         (.., Some(\"join\")) => JsValue::WellKnownFunction(WellKnownFunctionKind::PathJoin),\n         (.., Some(\"dirname\")) => JsValue::WellKnownFunction(WellKnownFunctionKind::PathDirname),\n@@ -645,7 +642,7 @@ pub fn path_module_member(kind: WellKnownObjectKind, prop: JsValue) -> JsValue {\n     }\n }\n \n-pub fn fs_module_member(kind: WellKnownObjectKind, prop: JsValue) -> JsValue {\n+fn fs_module_member(kind: WellKnownObjectKind, prop: JsValue) -> JsValue {\n     if let Some(word) = prop.as_str() {\n         match (kind, word) {\n             (\n@@ -676,7 +673,7 @@ pub fn fs_module_member(kind: WellKnownObjectKind, prop: JsValue) -> JsValue {\n     )\n }\n \n-pub fn url_module_member(kind: WellKnownObjectKind, prop: JsValue) -> JsValue {\n+fn url_module_member(kind: WellKnownObjectKind, prop: JsValue) -> JsValue {\n     match (kind, prop.as_str()) {\n         (.., Some(\"pathToFileURL\")) => {\n             JsValue::WellKnownFunction(WellKnownFunctionKind::PathToFileUrl)\n@@ -695,7 +692,7 @@ pub fn url_module_member(kind: WellKnownObjectKind, prop: JsValue) -> JsValue {\n     }\n }\n \n-pub fn child_process_module_member(kind: WellKnownObjectKind, prop: JsValue) -> JsValue {\n+fn child_process_module_member(kind: WellKnownObjectKind, prop: JsValue) -> JsValue {\n     let prop_str = prop.as_str();\n     match (kind, prop_str) {\n         (.., Some(\"spawn\" | \"spawnSync\" | \"execFile\" | \"execFileSync\")) => {"
        },
        {
            "sha": "8f4d3e1ce3f69e9e3741a90760de2103c003015b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/external_module.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 6,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/b478e57de89fb1611e7124b38bbbe7070b6eb1a3/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b478e57de89fb1611e7124b38bbbe7070b6eb1a3/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fexternal_module.rs?ref=b478e57de89fb1611e7124b38bbbe7070b6eb1a3",
            "patch": "@@ -360,12 +360,6 @@ pub struct CachedExternalModuleChunkItem {\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n }\n \n-// Without this wrapper, VirtualFileSystem::new_with_name always returns a new filesystem\n-#[turbo_tasks::function]\n-fn external_fs() -> Vc<VirtualFileSystem> {\n-    VirtualFileSystem::new_with_name(rcstr!(\"externals\"))\n-}\n-\n #[turbo_tasks::value_impl]\n impl ChunkItem for CachedExternalModuleChunkItem {\n     #[turbo_tasks::function]"
        },
        {
            "sha": "9be88de0b5a349cd2854b5e67d6d3d8677de31db",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 14,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/b478e57de89fb1611e7124b38bbbe7070b6eb1a3/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b478e57de89fb1611e7124b38bbbe7070b6eb1a3/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=b478e57de89fb1611e7124b38bbbe7070b6eb1a3",
            "patch": "@@ -2638,7 +2638,7 @@ async fn handle_free_var_reference(\n                 InputRelativeConstant::FileName => source_path,\n             };\n             analysis.add_code_gen(ConstantValueCodeGen::new(\n-                as_abs_path(source_path).await?.into(),\n+                as_abs_path(source_path).into(),\n                 ast_path.to_vec().into(),\n             ));\n         }\n@@ -2840,17 +2840,17 @@ async fn analyze_amd_define_with_deps(\n \n /// Used to generate the \"root\" path to a __filename/__dirname/import.meta.url\n /// reference.\n-pub async fn as_abs_path(path: FileSystemPath) -> Result<String> {\n+pub fn as_abs_path(path: FileSystemPath) -> String {\n     // TODO: This should be updated to generate a real system path on the fly\n     // during runtime, so that the generated code is constant between systems\n     // but the runtime evaluation can take into account the project's\n     // actual root directory.\n-    require_resolve(path).await\n+    require_resolve(path)\n }\n \n /// Generates an absolute path usable for `require.resolve()` calls.\n-async fn require_resolve(path: FileSystemPath) -> Result<String> {\n-    Ok(format!(\"/ROOT/{}\", path.path.as_str()))\n+fn require_resolve(path: FileSystemPath) -> String {\n+    format!(\"/ROOT/{}\", path.path.as_str())\n }\n \n async fn early_value_visitor(mut v: JsValue) -> Result<(JsValue, bool)> {\n@@ -2977,12 +2977,8 @@ async fn value_visitor_inner(\n             }\n         }\n         JsValue::FreeVar(ref kind) => match &**kind {\n-            \"__dirname\" => as_abs_path(origin.origin_path().owned().await?.parent())\n-                .await?\n-                .into(),\n-            \"__filename\" => as_abs_path(origin.origin_path().owned().await?)\n-                .await?\n-                .into(),\n+            \"__dirname\" => as_abs_path(origin.origin_path().owned().await?.parent()).into(),\n+            \"__filename\" => as_abs_path(origin.origin_path().owned().await?).into(),\n \n             \"require\" => JsValue::unknown_if(\n                 ignore,\n@@ -3051,9 +3047,7 @@ async fn require_resolve_visitor(\n             .await?\n             .iter()\n             .map(|&source| async move {\n-                require_resolve(source.ident().path().owned().await?)\n-                    .await\n-                    .map(JsValue::from)\n+                Ok(require_resolve(source.ident().path().owned().await?).into())\n             })\n             .try_join()\n             .await?;"
        }
    ],
    "stats": {
        "total": 367,
        "additions": 26,
        "deletions": 341
    }
}