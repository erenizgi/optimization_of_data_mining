{
    "author": "acdlite",
    "message": "Add onInvalidate option to router.prefetch (#77880)\n\nThis commit adds an `onInvalidate` callback to `router.prefetch()` so\ncustom `<Link>` implementations can re-prefetch data when it becomes\nstale.\n\nThe callback is invoked when the data associated with the prefetch may\nhave been invalidated (e.g. by `revalidatePath` or `revalidateTag`).\n\nThis is not a live subscription and should not be treated as one. It's a\none-time callback per prefetch request that acts as a signal: \"If you\ncare about the freshness of this data, now would be a good time to\nre-prefetch.\"\n\nThe supported use case is for advanced clients who opt out of rendering\nthe built-in `<Link>` component (e.g. to customize visibility tracking\nor polling behavior) but still want to retain proper cache integration.\nWhen the callback is fired, the component can trigger a new call to\n`router.prefetch()` with the same parameters, including a new\n`onInvalidate` callback to continue the cycle.\n\n(For reference, `<Link>` handles this automatically. This API exists to\ngive custom implementations access to the same underlying behavior.)\n\nNote that the callback *may* be invoked even if the prefetched data is\nstill cached. This is intentional—prefetching in the app router is a\npull-based mechanism, not a push-based one. Rather than subscribing to\nthe lifecycle of specific cache entries, the app occasionally polls the\nprefetch layer to check for missing or stale data.\n\nCalling `router.prefetch()` does not necessarily result in a network\nrequest. If the data is already cached, the call is a no-op. This makes\npolling a practical way to check cache freshness over time without\nincurring unnecessary requests.",
    "sha": "4df1a08f578ab29c60bb54aeece1adb82e6fdc01",
    "files": [
        {
            "sha": "d01cc9e37a771f77d26170bfedd04fa786b7bfe5",
            "filename": "packages/next/src/client/components/app-router-instance.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-instance.ts?ref=4df1a08f578ab29c60bb54aeece1adb82e6fdc01",
            "patch": "@@ -321,7 +321,8 @@ export const publicAppRouterInstance: AppRouterInstance = {\n           href,\n           actionQueue.state.nextUrl,\n           actionQueue.state.tree,\n-          options?.kind === PrefetchKind.FULL\n+          options?.kind === PrefetchKind.FULL,\n+          options?.onInvalidate ?? null\n         )\n       }\n     : (href: string, options?: PrefetchOptions) => {"
        },
        {
            "sha": "60131d0e4909c5c9b01828c928a52b02178628ab",
            "filename": "packages/next/src/client/components/links.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 23,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flinks.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flinks.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Flinks.ts?ref=4df1a08f578ab29c60bb54aeece1adb82e6fdc01",
            "patch": "@@ -3,7 +3,7 @@ import type { AppRouterInstance } from '../../shared/lib/app-router-context.shar\n import { getCurrentAppRouterState } from './app-router-instance'\n import { createPrefetchURL } from './app-router'\n import { PrefetchKind } from './router-reducer/router-reducer-types'\n-import { getCurrentCacheVersion } from './segment-cache'\n+import { isPrefetchTaskDirty } from './segment-cache'\n import { createCacheKey } from './segment-cache'\n import {\n   type PrefetchTask,\n@@ -28,13 +28,9 @@ type LinkOrFormInstanceShared = {\n   wasHoveredOrTouched: boolean\n \n   // The most recently initiated prefetch task. It may or may not have\n-  // already completed.  The same prefetch task object can be reused across\n+  // already completed. The same prefetch task object can be reused across\n   // multiple prefetches of the same link.\n   prefetchTask: PrefetchTask | null\n-\n-  // The cache version at the time the task was initiated. This is used to\n-  // determine if the cache was invalidated since the task was initiated.\n-  cacheVersion: number\n }\n \n export type FormInstance = LinkOrFormInstanceShared & {\n@@ -158,7 +154,6 @@ export function mountLinkInstance(\n         isVisible: false,\n         wasHoveredOrTouched: false,\n         prefetchTask: null,\n-        cacheVersion: -1,\n         prefetchHref: prefetchURL.href,\n         setOptimisticLinkStatus,\n       }\n@@ -176,7 +171,6 @@ export function mountLinkInstance(\n     isVisible: false,\n     wasHoveredOrTouched: false,\n     prefetchTask: null,\n-    cacheVersion: -1,\n     prefetchHref: null,\n     setOptimisticLinkStatus,\n   }\n@@ -203,7 +197,6 @@ export function mountFormInstance(\n     isVisible: false,\n     wasHoveredOrTouched: false,\n     prefetchTask: null,\n-    cacheVersion: -1,\n     prefetchHref: prefetchURL.href,\n     setOptimisticLinkStatus: null,\n   }\n@@ -322,7 +315,8 @@ function rescheduleLinkPrefetch(instance: PrefetchableInstance) {\n         cacheKey,\n         treeAtTimeOfPrefetch,\n         instance.kind === PrefetchKind.FULL,\n-        priority\n+        priority,\n+        null\n       )\n     } else {\n       // We already have an old task object that we can reschedule. This is\n@@ -334,10 +328,6 @@ function rescheduleLinkPrefetch(instance: PrefetchableInstance) {\n         priority\n       )\n     }\n-\n-    // Keep track of the cache version at the time the prefetch was requested.\n-    // This is used to check if the prefetch is stale.\n-    instance.cacheVersion = getCurrentCacheVersion()\n   }\n }\n \n@@ -352,15 +342,9 @@ export function pingVisibleLinks(\n   // This is called when the Next-Url or the base tree changes, since those\n   // may affect the result of a prefetch task. It's also called after a\n   // cache invalidation.\n-  const currentCacheVersion = getCurrentCacheVersion()\n   for (const instance of prefetchableAndVisible) {\n     const task = instance.prefetchTask\n-    if (\n-      task !== null &&\n-      instance.cacheVersion === currentCacheVersion &&\n-      task.key.nextUrl === nextUrl &&\n-      task.treeAtTimeOfPrefetch === tree\n-    ) {\n+    if (task !== null && !isPrefetchTaskDirty(task, nextUrl, tree)) {\n       // The cache has not been invalidated, and none of the inputs have\n       // changed. Bail out.\n       continue\n@@ -378,9 +362,9 @@ export function pingVisibleLinks(\n       cacheKey,\n       tree,\n       instance.kind === PrefetchKind.FULL,\n-      priority\n+      priority,\n+      null\n     )\n-    instance.cacheVersion = getCurrentCacheVersion()\n   }\n }\n "
        },
        {
            "sha": "8662a8adf38ae085b285e27d2d68698f3d5a5afa",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/vercel/next.js/blob/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=4df1a08f578ab29c60bb54aeece1adb82e6fdc01",
            "patch": "@@ -28,6 +28,7 @@ import {\n } from '../router-reducer/fetch-server-response'\n import {\n   pingPrefetchTask,\n+  isPrefetchTaskDirty,\n   type PrefetchTask,\n   type PrefetchSubtaskResult,\n } from './scheduler'\n@@ -245,6 +246,14 @@ let segmentCacheLru = createLRU<SegmentCacheEntry>(\n   onSegmentLRUEviction\n )\n \n+// All invalidation listeners for the whole cache are tracked in single set.\n+// Since we don't yet support tag or path-based invalidation, there's no point\n+// tracking them any more granularly than this. Once we add granular\n+// invalidation, that may change, though generally the model is to just notify\n+// the listeners and allow the caller to poll the prefetch cache with a new\n+// prefetch task if desired.\n+let invalidationListeners: Set<PrefetchTask> | null = null\n+\n // Incrementing counter used to track cache invalidations.\n let currentCacheVersion = 0\n \n@@ -276,6 +285,65 @@ export function revalidateEntireCache(\n \n   // Prefetch all the currently visible links again, to re-fill the cache.\n   pingVisibleLinks(nextUrl, tree)\n+\n+  // Similarly, notify all invalidation listeners (i.e. those passed to\n+  // `router.prefetch(onInvalidate)`), so they can trigger a new prefetch\n+  // if needed.\n+  pingInvalidationListeners(nextUrl, tree)\n+}\n+\n+function attachInvalidationListener(task: PrefetchTask): void {\n+  // This function is called whenever a prefetch task reads a cache entry. If\n+  // the task has an onInvalidate function associated with it — i.e. the one\n+  // optionally passed to router.prefetch(onInvalidate) — then we attach that\n+  // listener to the every cache entry that the task reads. Then, if an entry\n+  // is invalidated, we call the function.\n+  if (task.onInvalidate !== null) {\n+    if (invalidationListeners === null) {\n+      invalidationListeners = new Set([task])\n+    } else {\n+      invalidationListeners.add(task)\n+    }\n+  }\n+}\n+\n+function notifyInvalidationListener(task: PrefetchTask): void {\n+  const onInvalidate = task.onInvalidate\n+  if (onInvalidate !== null) {\n+    // Clear the callback from the task object to guarantee it's not called more\n+    // than once.\n+    task.onInvalidate = null\n+\n+    // This is a user-space function, so we must wrap in try/catch.\n+    try {\n+      onInvalidate()\n+    } catch (error) {\n+      if (typeof reportError === 'function') {\n+        reportError(error)\n+      } else {\n+        console.error(error)\n+      }\n+    }\n+  }\n+}\n+\n+export function pingInvalidationListeners(\n+  nextUrl: string | null,\n+  tree: FlightRouterState\n+): void {\n+  // The rough equivalent of pingVisibleLinks, but for onInvalidate callbacks.\n+  // This is called when the Next-Url or the base tree changes, since those\n+  // may affect the result of a prefetch task. It's also called after a\n+  // cache invalidation.\n+  if (invalidationListeners !== null) {\n+    const tasks = invalidationListeners\n+    invalidationListeners = null\n+    for (const task of tasks) {\n+      if (isPrefetchTaskDirty(task, nextUrl, tree)) {\n+        notifyInvalidationListener(task)\n+      }\n+    }\n+  }\n }\n \n export function readExactRouteCacheEntry(\n@@ -445,6 +513,8 @@ export function readOrCreateRouteCacheEntry(\n   now: number,\n   task: PrefetchTask\n ): RouteCacheEntry {\n+  attachInvalidationListener(task)\n+\n   const key = task.key\n   const existingEntry = readRouteCacheEntry(now, key)\n   if (existingEntry !== null) {"
        },
        {
            "sha": "2716104b6c55b1498e4748cbc033b23f560f159c",
            "filename": "packages/next/src/client/components/segment-cache-impl/prefetch.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 3,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fprefetch.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fprefetch.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fprefetch.ts?ref=4df1a08f578ab29c60bb54aeece1adb82e6fdc01",
            "patch": "@@ -9,17 +9,27 @@ import { PrefetchPriority } from '../segment-cache'\n  * @param href - The URL to prefetch. Typically this will come from a <Link>,\n  * or router.prefetch. It must be validated before we attempt to prefetch it.\n  * @param nextUrl - A special header used by the server for interception routes.\n- * Roughly  corresponds to the current URL.\n+ * Roughly corresponds to the current URL.\n  * @param treeAtTimeOfPrefetch - The FlightRouterState at the time the prefetch\n  * was requested. This is only used when PPR is disabled.\n  * @param includeDynamicData - Whether to prefetch dynamic data, in addition to\n  * static data. This is used by <Link prefetch={true}>.\n+ * @param onInvalidate - A callback that will be called when the prefetch cache\n+ * When called, it signals to the listener that the data associated with the\n+ * prefetch may have been invalidated from the cache. This is not a live\n+ * subscription — it's called at most once per `prefetch` call. The only\n+ * supported use case is to trigger a new prefetch inside the listener, if\n+ * desired. It also may be called even in cases where the associated data is\n+ * still cached. Prefetching is a poll-based (pull) operation, not an event-\n+ * based (push) one. Rather than subscribe to specific cache entries, you\n+ * occasionally poll the prefetch cache to check if anything is missing.\n  */\n export function prefetch(\n   href: string,\n   nextUrl: string | null,\n   treeAtTimeOfPrefetch: FlightRouterState,\n-  includeDynamicData: boolean\n+  includeDynamicData: boolean,\n+  onInvalidate: null | (() => void)\n ) {\n   const url = createPrefetchURL(href)\n   if (url === null) {\n@@ -31,6 +41,7 @@ export function prefetch(\n     cacheKey,\n     treeAtTimeOfPrefetch,\n     includeDynamicData,\n-    PrefetchPriority.Default\n+    PrefetchPriority.Default,\n+    onInvalidate\n   )\n }"
        },
        {
            "sha": "90473074b48ba560414547b617d092c2779fccc5",
            "filename": "packages/next/src/client/components/segment-cache-impl/scheduler.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 2,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts?ref=4df1a08f578ab29c60bb54aeece1adb82e6fdc01",
            "patch": "@@ -26,7 +26,7 @@ import {\n   getSegmentKeypathForTask,\n } from './cache'\n import type { RouteCacheKey } from './cache-key'\n-import { PrefetchPriority } from '../segment-cache'\n+import { getCurrentCacheVersion, PrefetchPriority } from '../segment-cache'\n \n const scheduleMicrotask =\n   typeof queueMicrotask === 'function'\n@@ -50,6 +50,12 @@ export type PrefetchTask = {\n    */\n   treeAtTimeOfPrefetch: FlightRouterState\n \n+  /**\n+   * The cache version at the time the task was initiated. This is used to\n+   * determine if the cache was invalidated since the task was initiated.\n+   */\n+  cacheVersion: number\n+\n   /**\n    * Whether to prefetch dynamic data, in addition to static data. This is\n    * used by <Link prefetch={true}>.\n@@ -105,6 +111,11 @@ export type PrefetchTask = {\n    */\n   isCanceled: boolean\n \n+  /**\n+   * The callback passed to `router.prefetch`, if given.\n+   */\n+  onInvalidate: null | (() => void)\n+\n   /**\n    * The index of the task in the heap's backing array. Used to efficiently\n    * change the priority of a task by re-sifting it, which requires knowing\n@@ -182,18 +193,21 @@ export function schedulePrefetchTask(\n   key: RouteCacheKey,\n   treeAtTimeOfPrefetch: FlightRouterState,\n   includeDynamicData: boolean,\n-  priority: PrefetchPriority\n+  priority: PrefetchPriority,\n+  onInvalidate: null | (() => void)\n ): PrefetchTask {\n   // Spawn a new prefetch task\n   const task: PrefetchTask = {\n     key,\n     treeAtTimeOfPrefetch,\n+    cacheVersion: getCurrentCacheVersion(),\n     priority,\n     phase: PrefetchPhase.RouteTree,\n     hasBackgroundWork: false,\n     includeDynamicData,\n     sortId: sortIdCounter++,\n     isCanceled: false,\n+    onInvalidate,\n     _heapIndex: -1,\n   }\n   heapPush(taskHeap, task)\n@@ -254,6 +268,24 @@ export function reschedulePrefetchTask(\n   ensureWorkIsScheduled()\n }\n \n+export function isPrefetchTaskDirty(\n+  task: PrefetchTask,\n+  nextUrl: string | null,\n+  tree: FlightRouterState\n+): boolean {\n+  // This is used to quickly bail out of a prefetch task if the result is\n+  // guaranteed to not have changed since the task was initiated. This is\n+  // strictly an optimization — theoretically, if it always returned true, no\n+  // behavior should change because a full prefetch task will effectively\n+  // perform the same checks.\n+  const currentCacheVersion = getCurrentCacheVersion()\n+  return (\n+    task.cacheVersion !== currentCacheVersion ||\n+    task.treeAtTimeOfPrefetch !== tree ||\n+    task.key.nextUrl !== nextUrl\n+  )\n+}\n+\n function ensureWorkIsScheduled() {\n   if (didScheduleMicrotask || !hasNetworkBandwidth()) {\n     // Either we already scheduled a task to process the queue, or there are\n@@ -344,6 +376,8 @@ function processQueueInMicrotask() {\n   // Process the task queue until we run out of network bandwidth.\n   let task = heapPeek(taskHeap)\n   while (task !== null && hasNetworkBandwidth()) {\n+    task.cacheVersion = getCurrentCacheVersion()\n+\n     const route = readOrCreateRouteCacheEntry(now, task)\n     const exitStatus = pingRootRouteTree(now, task, route)\n "
        },
        {
            "sha": "9513bd2b0a44545ae8f614b22aafe993bfc1654c",
            "filename": "packages/next/src/client/components/segment-cache.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache.ts?ref=4df1a08f578ab29c60bb54aeece1adb82e6fdc01",
            "patch": "@@ -85,6 +85,15 @@ export const reschedulePrefetchTask: typeof import('./segment-cache-impl/schedul\n       }\n     : notEnabled\n \n+export const isPrefetchTaskDirty: typeof import('./segment-cache-impl/scheduler').isPrefetchTaskDirty =\n+  process.env.__NEXT_CLIENT_SEGMENT_CACHE\n+    ? function (...args) {\n+        return require('./segment-cache-impl/scheduler').isPrefetchTaskDirty(\n+          ...args\n+        )\n+      }\n+    : notEnabled\n+\n export const createCacheKey: typeof import('./segment-cache-impl/cache-key').createCacheKey =\n   process.env.__NEXT_CLIENT_SEGMENT_CACHE\n     ? function (...args) {"
        },
        {
            "sha": "72f1d47be9568c56be57851fd436658aa8bce908",
            "filename": "packages/next/src/shared/lib/app-router-context.shared-runtime.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-context.shared-runtime.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-context.shared-runtime.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fapp-router-context.shared-runtime.ts?ref=4df1a08f578ab29c60bb54aeece1adb82e6fdc01",
            "patch": "@@ -122,6 +122,7 @@ export interface NavigateOptions {\n \n export interface PrefetchOptions {\n   kind: PrefetchKind\n+  onInvalidate?: () => void\n }\n \n export interface AppRouterInstance {"
        },
        {
            "sha": "d4a410c6f1061a44b4874199386aeb5560a52623",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/app/page.tsx",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Fpage.tsx?ref=4df1a08f578ab29c60bb54aeece1adb82e6fdc01",
            "patch": "@@ -1,5 +1,9 @@\n import { revalidatePath, revalidateTag } from 'next/cache'\n-import { LinkAccordion, FormAccordion } from '../components/link-accordion'\n+import {\n+  LinkAccordion,\n+  FormAccordion,\n+  ManualPrefetchLinkAccordion,\n+} from '../components/link-accordion'\n import Link from 'next/link'\n \n export default async function Page() {\n@@ -36,6 +40,12 @@ export default async function Page() {\n             Form pointing to target page with prefetching enabled\n           </FormAccordion>\n         </li>\n+        <li>\n+          <ManualPrefetchLinkAccordion href=\"/greeting\">\n+            Manual link (router.prefetch) to target page with prefetching\n+            enabled\n+          </ManualPrefetchLinkAccordion>\n+        </li>\n         <li>\n           <Link prefetch={false} href=\"/greeting\">\n             Link to target with prefetching disabled"
        },
        {
            "sha": "a11b931348c6b53121122e4eef1718a99abc21a1",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/components/link-accordion.tsx",
            "status": "modified",
            "additions": 73,
            "deletions": 1,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fcomponents%2Flink-accordion.tsx?ref=4df1a08f578ab29c60bb54aeece1adb82e6fdc01",
            "patch": "@@ -2,7 +2,8 @@\n \n import Link from 'next/link'\n import Form from 'next/form'\n-import { useState } from 'react'\n+import { useEffect, useState } from 'react'\n+import { useRouter } from 'next/navigation'\n \n export function LinkAccordion({\n   href,\n@@ -61,3 +62,74 @@ export function FormAccordion({\n     </>\n   )\n }\n+\n+export function ManualPrefetchLinkAccordion({\n+  href,\n+  children,\n+  prefetch,\n+}: {\n+  href: string\n+  children: React.ReactNode\n+  prefetch?: boolean\n+}) {\n+  const [isVisible, setIsVisible] = useState(false)\n+  return (\n+    <>\n+      <input\n+        type=\"checkbox\"\n+        checked={isVisible}\n+        onChange={() => setIsVisible(!isVisible)}\n+        data-manual-prefetch-link-accordion={href}\n+      />\n+      {isVisible ? (\n+        <ManualPrefetchLink href={href} prefetch={prefetch}>\n+          {children}\n+        </ManualPrefetchLink>\n+      ) : (\n+        <>{children} (form is hidden)</>\n+      )}\n+    </>\n+  )\n+}\n+\n+function ManualPrefetchLink({\n+  href,\n+  children,\n+  prefetch,\n+}: {\n+  href: string\n+  children: React.ReactNode\n+  prefetch?: boolean\n+}) {\n+  const router = useRouter()\n+  useEffect(() => {\n+    if (prefetch !== false) {\n+      // For as long as the link is mounted, poll the prefetch cache whenever\n+      // it's invalidated to ensure the data is fresh.\n+      let didUnmount = false\n+      const pollPrefetch = () => {\n+        if (!didUnmount) {\n+          // @ts-expect-error: onInvalidate is not yet part of public types\n+          router.prefetch(href, {\n+            onInvalidate: pollPrefetch,\n+          })\n+        }\n+      }\n+      pollPrefetch()\n+      return () => {\n+        didUnmount = true\n+      }\n+    }\n+  }, [href, prefetch, router])\n+  return (\n+    <a\n+      onClick={(event) => {\n+        event.preventDefault()\n+        router.push(href)\n+      }}\n+      href={href}\n+    >\n+      {children}\n+    </a>\n+  )\n+}"
        },
        {
            "sha": "aa8a1c3332231a4623183a5c18e73284b2903f3d",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/segment-cache-revalidation.test.ts",
            "status": "modified",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/vercel/next.js/blob/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fsegment-cache-revalidation.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4df1a08f578ab29c60bb54aeece1adb82e6fdc01/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fsegment-cache-revalidation.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fsegment-cache-revalidation.test.ts?ref=4df1a08f578ab29c60bb54aeece1adb82e6fdc01",
            "patch": "@@ -149,6 +149,57 @@ describe('segment cache (revalidation)', () => {\n     }, 'no-requests')\n   })\n \n+  it('call router.prefetch(..., {onInvalidate}) after cache is revalidated', async () => {\n+    // This is the similar to the previous tests, but uses a custom Link\n+    // implementation that calls router.prefetch manually. It demonstrates it's\n+    // possible to simulate the revalidating behavior of Link using the manual\n+    // prefetch API.\n+    let act: ReturnType<typeof createRouterAct>\n+    const browser = await next.browser('/', {\n+      beforePageLoad(page) {\n+        act = createRouterAct(page)\n+      },\n+    })\n+\n+    const linkVisibilityToggle = await browser.elementByCss(\n+      'input[data-manual-prefetch-link-accordion=\"/greeting\"]'\n+    )\n+\n+    // Reveal the link that points to the target page to trigger a prefetch\n+    await act(\n+      async () => {\n+        await linkVisibilityToggle.click()\n+      },\n+      {\n+        includes: 'random-greeting',\n+      }\n+    )\n+\n+    // Perform an action that calls revalidatePath. This should cause the\n+    // corresponding entry to be evicted from the client cache, and a new\n+    // prefetch to be requested.\n+    await act(\n+      async () => {\n+        const revalidateByPath = await browser.elementById('revalidate-by-path')\n+        await revalidateByPath.click()\n+      },\n+      {\n+        includes: 'random-greeting [1]',\n+      }\n+    )\n+    TestLog.assert(['REQUEST: random-greeting'])\n+\n+    // Navigate to the target page.\n+    await act(async () => {\n+      const link = await browser.elementByCss('a[href=\"/greeting\"]')\n+      await link.click()\n+      // Navigation should finish immedately because the page is\n+      // fully prefetched.\n+      const greeting = await browser.elementById('greeting')\n+      expect(await greeting.innerHTML()).toBe('random-greeting [1]')\n+    }, 'no-requests')\n+  })\n+\n   it('evict client cache when Server Action calls revalidateTag', async () => {\n     let act: ReturnType<typeof createRouterAct>\n     const browser = await next.browser('/', {"
        }
    ],
    "stats": {
        "total": 305,
        "additions": 274,
        "deletions": 31
    }
}