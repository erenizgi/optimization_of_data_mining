{
    "author": "sokra",
    "message": "Turbopack: Split AggregatedDirtyContainer (#86606)\n\nSplit AggregatedDirtyContainer\n\nrename and helper\n\nupdate from_task\n\nadd dirty_container_count method\n\nAllow infinite test runs\n\nimprove test case to test session dependent and restoring\n\nimprove names\n\n<!-- Thanks for opening a PR! Your contribution is much appreciated.\nTo make sure your PR is handled as smoothly as possible we request that you follow the checklist sections below.\nChoose the right checklist for the change(s) that you're making:\n\n## For Contributors\n\n### Improving Documentation\n\n- Run `pnpm prettier-fix` to fix formatting issues before opening the PR.\n- Read the Docs Contribution Guide to ensure your contribution follows the docs guidelines: https://nextjs.org/docs/community/contribution-guide\n\n### Fixing a bug\n\n- Related issues linked using `fixes #number`\n- Tests added. See: https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs\n- Errors have a helpful link attached, see https://github.com/vercel/next.js/blob/canary/contributing.md\n\n### Adding a feature\n\n- Implements an existing feature request or RFC. Make sure the feature request has been accepted for implementation before opening a PR. (A discussion must be opened, see https://github.com/vercel/next.js/discussions/new?category=ideas)\n- Related issues/discussions are linked using `fixes #number`\n- e2e tests added (https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs)\n- Documentation added\n- Telemetry added. In case of a feature if it's used or not.\n- Errors have a helpful link attached, see https://github.com/vercel/next.js/blob/canary/contributing.md\n\n\n## For Maintainers\n\n- Minimal description (aim for explaining to someone not on the team to understand the PR)\n- When linking to a Slack thread, you might want to share details of the conclusion\n- Link both the Linear (Fixes NEXT-xxx) and the GitHub issues\n- Add review comments if necessary to explain to the reviewer the logic behind a change\n\n### What?\n\n### Why?\n\n### How?\n\nCloses NEXT-\nFixes #\n\n-->",
    "sha": "3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8",
    "files": [
        {
            "sha": "e21e3f59fa66f964bec71634fe387dd2fa99a309",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 22,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8",
            "patch": "@@ -592,14 +592,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                         .set_active_until_clean();\n                     if ctx.should_track_activeness() {\n                         // A newly added Activeness need to make sure to schedule the tasks\n-                        task_ids_to_schedule = get_many!(\n-                            task,\n-                            AggregatedDirtyContainer {\n-                                task\n-                            } count if count.get(self.session_id) > 0 => {\n-                                task\n-                            }\n-                        );\n+                        task_ids_to_schedule = task.dirty_containers(self.session_id).collect();\n                         task_ids_to_schedule.push(task_id);\n                     }\n                     get!(task, Activeness).unwrap()\n@@ -660,16 +653,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                                 \"{task_id} {task_description}{count} (aggr={aggregation_number}, \\\n                                  {in_progress}, {activeness}{is_dirty})\",\n                             );\n-                            let children: Vec<_> = iter_many!(\n-                                task,\n-                                AggregatedDirtyContainer {\n-                                    task\n-                                } count => {\n-                                    (task, count.get(ctx.session_id()))\n-                                }\n-                            )\n-                            .filter(|(_, count)| *count > 0)\n-                            .collect();\n+                            let children: Vec<_> =\n+                                task.dirty_containers_with_count(ctx.session_id()).collect();\n                             drop(task);\n \n                             if missing_upper {\n@@ -2998,9 +2983,9 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     }\n                 }\n \n-                let is_dirty = task.is_dirty(self.session_id);\n-                let has_dirty_container = get!(task, AggregatedDirtyContainerCount)\n-                    .is_some_and(|count| count.get(self.session_id) > 0);\n+                let is_dirty = get!(task, Dirty).is_some();\n+                let has_dirty_container =\n+                    get!(task, AggregatedDirtyContainerCount).is_some_and(|count| count.count > 0);\n                 let should_be_in_upper = is_dirty || has_dirty_container;\n \n                 let aggregation_number = get_aggregation_number(&task);\n@@ -3025,7 +3010,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     for upper_id in uppers {\n                         let task = ctx.task(task_id, TaskDataCategory::All);\n                         let in_upper = get!(task, AggregatedDirtyContainer { task: task_id })\n-                            .is_some_and(|dirty| dirty.get(self.session_id) > 0);\n+                            .is_some_and(|&dirty| dirty > 0);\n                         if !in_upper {\n                             panic!(\n                                 \"Task {} ({}) is dirty, but is not listed in the upper task {} \\"
        },
        {
            "sha": "82679af48347edd584bd02dffe45843907dfb397",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/aggregation_update.rs",
            "status": "modified",
            "additions": 100,
            "deletions": 32,
            "changes": 132,
            "blob_url": "https://github.com/vercel/next.js/blob/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs?ref=3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8",
            "patch": "@@ -28,7 +28,9 @@ use crate::{\n     backend::{\n         TaskDataCategory, get_mut, get_mut_or_insert_with,\n         operation::{ExecuteContext, Operation, TaskGuard, invalidate::make_task_dirty},\n-        storage::{count, get, get_many, iter_many, remove, update, update_count},\n+        storage::{\n+            count, get, get_many, iter_many, remove, update, update_count, update_count_and_get,\n+        },\n     },\n     data::{\n         ActivenessState, AggregationNumber, CachedDataItem, CachedDataItemKey, CachedDataItemType,\n@@ -271,23 +273,23 @@ impl AggregatedDataUpdate {\n                 collectibles_update.push((collectible, 1));\n             }\n         }\n-        if let Some((dirtyness, clean_in_session)) = task.dirtyness_and_session() {\n-            dirty_container_count.update_with_dirtyness_and_session(dirtyness, clean_in_session);\n+        let mut dirty_count = dirty_container_count.count;\n+        let mut current_session_clean_count =\n+            dirty_container_count.current_session_clean(current_session_id);\n+        let (dirty, current_session_clean) = task.dirty(current_session_id);\n+        if dirty {\n+            dirty_count += 1;\n+        }\n+        if current_session_clean {\n+            current_session_clean_count += 1;\n         }\n \n         let mut result = Self::new().collectibles_update(collectibles_update);\n-        if !dirty_container_count.is_zero() {\n+        if dirty_count > 0 {\n             result = result.dirty_container_update(\n                 task.id(),\n-                if dirty_container_count.count > 0 {\n-                    1\n-                } else {\n-                    0\n-                },\n-                if dirty_container_count.count > 0\n-                    && dirty_container_count.current_session_clean(current_session_id)\n-                        >= dirty_container_count.count\n-                {\n+                if dirty_count > 0 { 1 } else { 0 },\n+                if dirty_count > 0 && dirty_count - current_session_clean_count <= 0 {\n                     1\n                 } else {\n                     0\n@@ -322,39 +324,105 @@ impl AggregatedDataUpdate {\n         should_track_activeness: bool,\n         queue: &mut AggregationUpdateQueue,\n     ) -> AggregatedDataUpdate {\n+        fn before_after_to_diff_value(before: bool, after: bool) -> i32 {\n+            match (before, after) {\n+                (true, false) => -1,\n+                (false, true) => 1,\n+                _ => 0,\n+            }\n+        }\n+\n         let Self {\n             dirty_container_update,\n             collectibles_update,\n         } = self;\n         let mut result = Self::default();\n-        if let &Some((dirty_container_id, count, session_dependent_clean_update)) =\n+        if let &Some((dirty_container_id, count, current_session_clean_update)) =\n             dirty_container_update\n         {\n             if should_track_activeness {\n                 // When a dirty container count is increased and the task is considered as active\n                 // we need to schedule the dirty tasks in the new dirty container\n-                let current_session_update = count - *session_dependent_clean_update;\n+                let current_session_update = count - *current_session_clean_update;\n                 if current_session_update > 0 && task.has_key(&CachedDataItemKey::Activeness {}) {\n                     queue.push_find_and_schedule_dirty(dirty_container_id)\n                 }\n             }\n \n-            let mut aggregated_update = DirtyContainerCount::default();\n-            update!(\n-                task,\n-                AggregatedDirtyContainer {\n-                    task: dirty_container_id\n-                },\n-                |old: Option<DirtyContainerCount>| {\n-                    let mut new = old.unwrap_or_default();\n-                    aggregated_update =\n-                        new.update_count(&DirtyContainerCount::from_current_session_clean(\n-                            count,\n-                            current_session_id,\n-                            *session_dependent_clean_update,\n-                        ));\n-                    (!new.is_zero()).then_some(new)\n-                }\n+            // Update AggregatedDirtyContainer and compute aggregated update\n+            let mut dirty_container_count_update = 0;\n+            let old_dirty_single_container_count;\n+            let new_dirty_single_container_count;\n+            if count != 0 {\n+                new_dirty_single_container_count = update_count_and_get!(\n+                    task,\n+                    AggregatedDirtyContainer {\n+                        task: dirty_container_id\n+                    },\n+                    count\n+                );\n+                old_dirty_single_container_count = new_dirty_single_container_count - count;\n+                dirty_container_count_update = before_after_to_diff_value(\n+                    old_dirty_single_container_count > 0,\n+                    new_dirty_single_container_count > 0,\n+                );\n+            } else {\n+                new_dirty_single_container_count = get!(\n+                    task,\n+                    AggregatedDirtyContainer {\n+                        task: dirty_container_id\n+                    }\n+                )\n+                .copied()\n+                .unwrap_or_default();\n+                old_dirty_single_container_count = new_dirty_single_container_count;\n+            }\n+\n+            // Update AggregatedSessionDependentCleanContainer\n+            let old_single_container_current_session_clean_count;\n+            let new_single_container_current_session_clean_count;\n+            if *current_session_clean_update != 0 {\n+                new_single_container_current_session_clean_count = update_count_and_get!(\n+                    task,\n+                    AggregatedSessionDependentCleanContainer {\n+                        task: dirty_container_id,\n+                        session_id: current_session_id\n+                    },\n+                    *current_session_clean_update\n+                );\n+                old_single_container_current_session_clean_count =\n+                    new_single_container_current_session_clean_count\n+                        - *current_session_clean_update;\n+            } else {\n+                new_single_container_current_session_clean_count = get!(\n+                    task,\n+                    AggregatedSessionDependentCleanContainer {\n+                        task: dirty_container_id,\n+                        session_id: current_session_id\n+                    }\n+                )\n+                .copied()\n+                .unwrap_or_default();\n+                old_single_container_current_session_clean_count =\n+                    new_single_container_current_session_clean_count;\n+            }\n+\n+            // compute aggregated update\n+            let was_single_container_clean = old_dirty_single_container_count > 0\n+                && old_dirty_single_container_count\n+                    - old_single_container_current_session_clean_count\n+                    <= 0;\n+            let is_single_container_clean = new_dirty_single_container_count > 0\n+                && new_dirty_single_container_count\n+                    - new_single_container_current_session_clean_count\n+                    <= 0;\n+            let current_session_clean_update =\n+                before_after_to_diff_value(was_single_container_clean, is_single_container_clean);\n+\n+            let aggregated_update = DirtyContainerCount::from_current_session_clean(\n+                dirty_container_count_update,\n+                current_session_id,\n+                current_session_clean_update,\n             );\n \n             if !aggregated_update.is_zero() {\n@@ -1273,7 +1341,7 @@ impl AggregationUpdateQueue {\n         // this would already be scheduled by the `Activeness`\n         let is_active_until_clean = get!(task, Activeness).is_some_and(|a| a.active_until_clean);\n         if !is_active_until_clean {\n-            let mut dirty_containers = iter_many!(task, AggregatedDirtyContainer { task } count if count.get(session_id) > 0 => task).peekable();\n+            let mut dirty_containers = task.dirty_containers(session_id).peekable();\n             let is_empty = dirty_containers.peek().is_none();\n             if !is_empty || dirty {\n                 self.extend_find_and_schedule_dirty(dirty_containers);"
        },
        {
            "sha": "63127a58b793910f7f19cd513f052e3b210fb9c1",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 45,
            "deletions": 1,
            "changes": 46,
            "blob_url": "https://github.com/vercel/next.js/blob/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8",
            "patch": "@@ -25,7 +25,7 @@ use crate::{\n     backing_storage::BackingStorage,\n     data::{\n         CachedDataItem, CachedDataItemKey, CachedDataItemType, CachedDataItemValue,\n-        CachedDataItemValueRef, CachedDataItemValueRefMut, Dirtyness,\n+        CachedDataItemValueRef, CachedDataItemValueRefMut, DirtyContainerCount, Dirtyness,\n     },\n };\n \n@@ -430,6 +430,50 @@ pub trait TaskGuard: Debug {\n             )),\n         }\n     }\n+    /// Returns (is_dirty, is_clean_in_current_session)\n+    fn dirty(&self, session_id: SessionId) -> (bool, bool) {\n+        match get!(self, Dirty) {\n+            None => (false, false),\n+            Some(Dirtyness::Dirty) => (true, false),\n+            Some(Dirtyness::SessionDependent) => (\n+                true,\n+                get!(self, CleanInSession).copied() == Some(session_id),\n+            ),\n+        }\n+    }\n+    fn dirty_containers(&self, session_id: SessionId) -> impl Iterator<Item = TaskId> {\n+        self.dirty_containers_with_count(session_id)\n+            .map(|(task_id, _)| task_id)\n+    }\n+    fn dirty_containers_with_count(\n+        &self,\n+        session_id: SessionId,\n+    ) -> impl Iterator<Item = (TaskId, i32)> {\n+        iter_many!(self, AggregatedDirtyContainer { task } count => (task, *count)).filter(\n+            move |&(task_id, count)| {\n+                if count > 0 {\n+                    let clean_count = get!(\n+                        self,\n+                        AggregatedSessionDependentCleanContainer {\n+                            task: task_id,\n+                            session_id\n+                        }\n+                    )\n+                    .copied()\n+                    .unwrap_or_default();\n+                    count > clean_count\n+                } else {\n+                    false\n+                }\n+            },\n+        )\n+    }\n+\n+    fn dirty_container_count(&self) -> DirtyContainerCount {\n+        get!(self, AggregatedDirtyContainerCount)\n+            .cloned()\n+            .unwrap_or_default()\n+    }\n }\n \n pub struct TaskGuardImpl<'a, B: BackingStorage> {"
        },
        {
            "sha": "5245b6101a064e4118420cae161b993e78c3bbda",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/storage.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs?ref=3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8",
            "patch": "@@ -1096,6 +1096,38 @@ macro_rules! update_count {\n     };\n }\n \n+macro_rules! update_count_and_get {\n+    ($task:ident, $key:ident $input:tt, -$update:expr) => {{\n+        let update = $update;\n+        let mut new = 0;\n+        $crate::backend::storage::update!($task, $key $input, |old: Option<_>| {\n+            let old = old.unwrap_or(0);\n+            new = old - update;\n+            (new != 0).then_some(new)\n+        });\n+        new\n+    }};\n+    ($task:ident, $key:ident $input:tt, $update:expr) => {\n+        match $update {\n+            update => {\n+                let mut new = 0;\n+                $crate::backend::storage::update!($task, $key $input, |old: Option<_>| {\n+                    let old = old.unwrap_or(0);\n+                    new = old + update;\n+                    (new != 0).then_some(new)\n+                });\n+                new\n+            }\n+        }\n+    };\n+    ($task:ident, $key:ident, -$update:expr) => {\n+        $crate::backend::storage::update_count_and_get!($task, $key {}, -$update)\n+    };\n+    ($task:ident, $key:ident, $update:expr) => {\n+        $crate::backend::storage::update_count_and_get!($task, $key {}, $update)\n+    };\n+}\n+\n macro_rules! remove {\n     ($task:ident, $key:ident $input:tt) => {{\n         #[allow(unused_imports)]\n@@ -1122,6 +1154,7 @@ pub(crate) use iter_many;\n pub(crate) use remove;\n pub(crate) use update;\n pub(crate) use update_count;\n+pub(crate) use update_count_and_get;\n \n pub struct SnapshotGuard<'l> {\n     storage: &'l Storage,"
        },
        {
            "sha": "02b4dbb18d67726e7c90115c5f8d4fc81aff5dcc",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 1,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs?ref=3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8",
            "patch": "@@ -653,7 +653,12 @@ pub enum CachedDataItem {\n     // Aggregated Data\n     AggregatedDirtyContainer {\n         task: TaskId,\n-        value: DirtyContainerCount,\n+        value: i32,\n+    },\n+    AggregatedSessionDependentCleanContainer {\n+        task: TaskId,\n+        session_id: SessionId,\n+        value: i32,\n     },\n     AggregatedCollectible {\n         collectible: CollectibleRef,\n@@ -734,6 +739,9 @@ impl CachedDataItem {\n             CachedDataItem::Follower { task, .. } => !task.is_transient(),\n             CachedDataItem::Upper { task, .. } => !task.is_transient(),\n             CachedDataItem::AggregatedDirtyContainer { task, .. } => !task.is_transient(),\n+            CachedDataItem::AggregatedSessionDependentCleanContainer { task, .. } => {\n+                !task.is_transient()\n+            }\n             CachedDataItem::AggregatedCollectible { collectible, .. } => {\n                 !collectible.cell.task.is_transient()\n             }\n@@ -808,6 +816,7 @@ impl CachedDataItem {\n             | Self::Child { .. }\n             | Self::Upper { .. }\n             | Self::AggregatedDirtyContainer { .. }\n+            | Self::AggregatedSessionDependentCleanContainer { .. }\n             | Self::AggregatedCollectible { .. }\n             | Self::AggregatedDirtyContainerCount { .. }\n             | Self::Stateful { .. }\n@@ -852,6 +861,9 @@ impl CachedDataItemKey {\n             CachedDataItemKey::Follower { task, .. } => !task.is_transient(),\n             CachedDataItemKey::Upper { task, .. } => !task.is_transient(),\n             CachedDataItemKey::AggregatedDirtyContainer { task, .. } => !task.is_transient(),\n+            CachedDataItemKey::AggregatedSessionDependentCleanContainer { task, .. } => {\n+                !task.is_transient()\n+            }\n             CachedDataItemKey::AggregatedCollectible { collectible, .. } => {\n                 !collectible.cell.task.is_transient()\n             }\n@@ -894,6 +906,7 @@ impl CachedDataItemType {\n             | Self::Child { .. }\n             | Self::Upper { .. }\n             | Self::AggregatedDirtyContainer { .. }\n+            | Self::AggregatedSessionDependentCleanContainer { .. }\n             | Self::AggregatedCollectible { .. }\n             | Self::AggregatedDirtyContainerCount { .. }\n             | Self::Stateful { .. }\n@@ -930,6 +943,7 @@ impl CachedDataItemType {\n             | Self::Follower\n             | Self::Upper\n             | Self::AggregatedDirtyContainer\n+            | Self::AggregatedSessionDependentCleanContainer\n             | Self::AggregatedCollectible\n             | Self::AggregatedDirtyContainerCount\n             | Self::Stateful"
        },
        {
            "sha": "7a23a8d4bfd42e8443e30fefa8ac2d00b5988b0e",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/emptied_cells.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 7,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs?ref=3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8",
            "patch": "@@ -4,19 +4,17 @@\n \n use anyhow::Result;\n use turbo_tasks::{State, Vc};\n-use turbo_tasks_testing::{Registration, register, run_once};\n+use turbo_tasks_testing::{Registration, register, run};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn recompute() {\n-    run_once(&REGISTRATION, || async {\n-        let input = ChangingInput {\n-            state: State::new(1),\n-        }\n-        .cell();\n+    run(&REGISTRATION, || async {\n+        let input = get_state().resolve().await?;\n+        input.await?.state.set(0);\n         let output = compute(input);\n-        assert_eq!(*output.await?, 1);\n+        assert_eq!(*output.strongly_consistent().await?, 0);\n \n         println!(\"changing input\");\n         input.await?.state.set(10);\n@@ -44,6 +42,14 @@ async fn recompute() {\n     .unwrap();\n }\n \n+#[turbo_tasks::function]\n+fn get_state() -> Vc<ChangingInput> {\n+    ChangingInput {\n+        state: State::new(0),\n+    }\n+    .cell()\n+}\n+\n #[turbo_tasks::value]\n struct ChangingInput {\n     state: State<u32>,"
        },
        {
            "sha": "b2ad8ec529b13630720c8b22dc27d79f837dc60c",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/emptied_cells_session_dependent.rs",
            "status": "added",
            "additions": 82,
            "deletions": 0,
            "changes": 82,
            "blob_url": "https://github.com/vercel/next.js/blob/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells_session_dependent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells_session_dependent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells_session_dependent.rs?ref=3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8",
            "patch": "@@ -0,0 +1,82 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use anyhow::Result;\n+use turbo_tasks::{State, Vc, mark_session_dependent};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+async fn recompute() {\n+    run(&REGISTRATION, || async {\n+        let input = get_state().resolve().await?;\n+        input.await?.state.set(0);\n+        let output = compute(input);\n+        assert_eq!(*output.strongly_consistent().await?, 0);\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(10);\n+        assert_eq!(*output.strongly_consistent().await?, 10);\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(5);\n+        assert_eq!(*output.strongly_consistent().await?, 5);\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(20);\n+        assert_eq!(*output.strongly_consistent().await?, 20);\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(15);\n+        assert_eq!(*output.strongly_consistent().await?, 15);\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(1);\n+        assert_eq!(*output.strongly_consistent().await?, 1);\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap();\n+}\n+\n+#[turbo_tasks::function]\n+fn get_state() -> Vc<ChangingInput> {\n+    ChangingInput {\n+        state: State::new(0),\n+    }\n+    .cell()\n+}\n+\n+#[turbo_tasks::value]\n+struct ChangingInput {\n+    state: State<u32>,\n+}\n+\n+#[turbo_tasks::function]\n+async fn compute(input: Vc<ChangingInput>) -> Result<Vc<u32>> {\n+    println!(\"compute()\");\n+    let value = *inner_compute(input).await?;\n+    Ok(Vc::cell(value))\n+}\n+\n+#[turbo_tasks::function]\n+async fn inner_compute(input: Vc<ChangingInput>) -> Result<Vc<u32>> {\n+    println!(\"inner_compute()\");\n+    let state_value = *input.await?.state.get();\n+    let mut last = None;\n+    for i in 0..=state_value {\n+        last = Some(compute2(Vc::cell(i)));\n+    }\n+    Ok(last.unwrap())\n+}\n+\n+#[turbo_tasks::function]\n+async fn compute2(input: Vc<u32>) -> Result<Vc<u32>> {\n+    mark_session_dependent();\n+    println!(\"compute2()\");\n+    let value = *input.await?;\n+    Ok(Vc::cell(value))\n+}"
        },
        {
            "sha": "b7e7a3b2ea095eacc744ee147bca94dfbedce13f",
            "filename": "turbopack/crates/turbo-tasks-testing/src/run.rs",
            "status": "modified",
            "additions": 37,
            "deletions": 26,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Frun.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Frun.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Frun.rs?ref=3b6f016f7707d8a1b5ba4d1a49d27d5d9d795dc8",
            "patch": "@@ -98,38 +98,49 @@ where\n     F: Future<Output = Result<T>> + Send + 'static,\n     T: Debug + PartialEq + Eq + TraceRawVcs + Send + 'static,\n {\n-    let single_run = env::var(\"SINGLE_RUN\").is_ok();\n+    let infinite_initial_runs = env::var(\"INFINITE_INITIAL_RUNS\").is_ok();\n+    let infinite_memory_runs = !infinite_initial_runs && env::var(\"INFINITE_MEMORY_RUNS\").is_ok();\n+    let single_run = infinite_initial_runs || env::var(\"SINGLE_RUN\").is_ok();\n     let name = closure_to_name(&fut);\n-    let tt = registration.create_turbo_tasks(&name, true);\n-    println!(\"Run #1 (without cache)\");\n-    let start = std::time::Instant::now();\n-    let first = fut(tt.clone()).await?;\n-    println!(\"Run #1 took {:?}\", start.elapsed());\n-    if !single_run {\n-        for i in 2..10 {\n-            println!(\"Run #{i} (with memory cache, same TurboTasks instance)\");\n-            let start = std::time::Instant::now();\n-            let second = fut(tt.clone()).await?;\n-            println!(\"Run #{i} took {:?}\", start.elapsed());\n-            assert_eq!(first, second);\n-        }\n-    }\n-    let start = std::time::Instant::now();\n-    tt.stop_and_wait().await;\n-    println!(\"Stopping TurboTasks took {:?}\", start.elapsed());\n-    if single_run {\n-        return Ok(());\n-    }\n-    for i in 10..20 {\n-        let tt = registration.create_turbo_tasks(&name, false);\n-        println!(\"Run #{i} (with filesystem cache if available, new TurboTasks instance)\");\n+    let mut i = 1;\n+    loop {\n+        let tt = registration.create_turbo_tasks(&name, true);\n+        println!(\"Run #{i} (without cache)\");\n         let start = std::time::Instant::now();\n-        let third = fut(tt.clone()).await?;\n+        let first = fut(tt.clone()).await?;\n         println!(\"Run #{i} took {:?}\", start.elapsed());\n+        i += 1;\n+        if !single_run {\n+            let max_run = if infinite_memory_runs { usize::MAX } else { 10 };\n+            for _ in 0..max_run {\n+                println!(\"Run #{i} (with memory cache, same TurboTasks instance)\");\n+                let start = std::time::Instant::now();\n+                let second = fut(tt.clone()).await?;\n+                println!(\"Run #{i} took {:?}\", start.elapsed());\n+                i += 1;\n+                assert_eq!(first, second);\n+            }\n+        }\n         let start = std::time::Instant::now();\n         tt.stop_and_wait().await;\n         println!(\"Stopping TurboTasks took {:?}\", start.elapsed());\n-        assert_eq!(first, third);\n+        if !single_run {\n+            for _ in 10..20 {\n+                let tt = registration.create_turbo_tasks(&name, false);\n+                println!(\"Run #{i} (with filesystem cache if available, new TurboTasks instance)\");\n+                let start = std::time::Instant::now();\n+                let third = fut(tt.clone()).await?;\n+                println!(\"Run #{i} took {:?}\", start.elapsed());\n+                i += 1;\n+                let start = std::time::Instant::now();\n+                tt.stop_and_wait().await;\n+                println!(\"Stopping TurboTasks took {:?}\", start.elapsed());\n+                assert_eq!(first, third);\n+            }\n+        }\n+        if !infinite_initial_runs {\n+            break;\n+        }\n     }\n     Ok(())\n }"
        }
    ],
    "stats": {
        "total": 421,
        "additions": 332,
        "deletions": 89
    }
}