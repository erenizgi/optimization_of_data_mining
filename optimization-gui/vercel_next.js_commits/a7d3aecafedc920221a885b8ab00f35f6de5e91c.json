{
    "author": "sokra",
    "message": "Turbopack: avoid race condition when updating cells (#84598)\n\n### What?\r\n\r\nThe update cell operation has a race condition. There is a time between changing the value and invalidating the dependent tasks. That sounds fine as tasks are eventually invalidated. But it's not due to recomputing tasks.\r\n\r\nTasks are considered as \"recomputing\" when they are not flagged as dirty while they update a cell/output. A recomputing tasks will not invalidate dependent tasks as a recomputation is considered as deterministic and must yield the same results.\r\n\r\nThe race happens when a recomputation of a dependent task happens while a cell is updated. During that time the cell value is already updated, but the dependent task is not marked as dirty.\r\n\r\nSo the recomputing tasks incorrectly doesn't trigger an invalidation for its cell change later, which depends on the already modified data",
    "sha": "a7d3aecafedc920221a885b8ab00f35f6de5e91c",
    "files": [
        {
            "sha": "7cef90bef8bdbbb0c0026f88e7dc7d5f3cbb04bc",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 8,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/a7d3aecafedc920221a885b8ab00f35f6de5e91c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a7d3aecafedc920221a885b8ab00f35f6de5e91c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=a7d3aecafedc920221a885b8ab00f35f6de5e91c",
            "patch": "@@ -831,7 +831,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             return Ok(Err(self.listen_to_cell(&mut task, task_id, reader, cell).0));\n         }\n         let is_cancelled = matches!(in_progress, Some(InProgressState::Canceled));\n-        let is_scheduled = matches!(in_progress, Some(InProgressState::Scheduled { .. }));\n \n         // Check cell index range (cell might not exist at all)\n         let max_id = get!(\n@@ -875,14 +874,12 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         // Schedule the task, if not already scheduled\n         if is_cancelled {\n             bail!(\"{} was canceled\", ctx.get_task_description(task_id));\n-        } else if !is_scheduled\n-            && task.add(CachedDataItem::new_scheduled(\n-                TaskExecutionReason::CellNotAvailable,\n-                || self.get_task_desc_fn(task_id),\n-            ))\n-        {\n-            ctx.schedule_task(task);\n         }\n+        task.add_new(CachedDataItem::new_scheduled(\n+            TaskExecutionReason::CellNotAvailable,\n+            || self.get_task_desc_fn(task_id),\n+        ));\n+        ctx.schedule_task(task);\n \n         Ok(Err(listener))\n     }"
        },
        {
            "sha": "70dee0010a772c6c56fe06d425b34b36521ce17a",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_cell.rs",
            "status": "modified",
            "additions": 99,
            "deletions": 33,
            "changes": 132,
            "blob_url": "https://github.com/vercel/next.js/blob/a7d3aecafedc920221a885b8ab00f35f6de5e91c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a7d3aecafedc920221a885b8ab00f35f6de5e91c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs?ref=a7d3aecafedc920221a885b8ab00f35f6de5e91c",
            "patch": "@@ -2,7 +2,7 @@ use std::mem::take;\n \n use serde::{Deserialize, Serialize};\n use smallvec::SmallVec;\n-use turbo_tasks::{CellId, TaskId, backend::CellContent};\n+use turbo_tasks::{CellId, TaskId, TypedSharedReference, backend::CellContent};\n \n #[cfg(feature = \"trace_task_dirty\")]\n use crate::backend::operation::invalidate::TaskDirtyCause;\n@@ -24,6 +24,12 @@ pub enum UpdateCellOperation {\n     InvalidateWhenCellDependency {\n         cell_ref: CellRef,\n         dependent_tasks: SmallVec<[TaskId; 4]>,\n+        content: Option<TypedSharedReference>,\n+        queue: AggregationUpdateQueue,\n+    },\n+    FinalCellChange {\n+        cell_ref: CellRef,\n+        content: Option<TypedSharedReference>,\n         queue: AggregationUpdateQueue,\n     },\n     AggregationUpdate {\n@@ -36,51 +42,82 @@ pub enum UpdateCellOperation {\n impl UpdateCellOperation {\n     pub fn run(task_id: TaskId, cell: CellId, content: CellContent, mut ctx: impl ExecuteContext) {\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n-        let old_content = if let CellContent(Some(new_content)) = content {\n-            task.insert(CachedDataItem::CellData {\n-                cell,\n-                value: new_content.into_typed(cell.type_id),\n-            })\n-        } else {\n-            task.remove(&CachedDataItemKey::CellData { cell })\n-        };\n-\n-        if let Some(in_progress) = remove!(task, InProgressCell { cell }) {\n-            in_progress.event.notify(usize::MAX);\n-        }\n \n         // We need to detect recomputation, because here the content has not actually changed (even\n         // if it's not equal to the old content, as not all values implement Eq). We have to\n         // assume that tasks are deterministic and pure.\n+        let should_invalidate = ctx.should_track_dependencies()\n+            && (task.has_key(&CachedDataItemKey::Dirty {}) ||\n+            // This is a hack for the streaming hack. Stateful tasks are never recomputed, so this forces invalidation for them in case of this hack.\n+            task.has_key(&CachedDataItemKey::Stateful {}));\n \n-        if ctx.should_track_dependencies()\n-            && (task.has_key(&CachedDataItemKey::Dirty {})\n-                ||\n-                // This is a hack for the streaming hack. Stateful tasks are never recomputed, so this forces invalidation for them in case of this hack.\n-                task.has_key(&CachedDataItemKey::Stateful {}))\n-        {\n-            let dependent_tasks = get_many!(\n+        if should_invalidate {\n+            let dependent_tasks: SmallVec<[TaskId; 4]> = get_many!(\n                 task,\n                 CellDependent { cell: dependent_cell, task }\n                 if dependent_cell == cell\n                 => task\n             );\n \n-            drop(task);\n-            drop(old_content);\n+            if !dependent_tasks.is_empty() {\n+                // Slow path: We need to invalidate tasks depending on this cell.\n+                // To avoid a race condition, we need to remove the old content first,\n+                // then invalidate dependent tasks and only then update the cell content.\n+\n+                // The reason behind this is that we consider tasks that haven't the dirty flag set\n+                // as \"recomputing\" tasks. Recomputing tasks won't invalidate\n+                // dependent tasks, when a cell is changed. This would cause missing invalidating if\n+                // a task is recomputing while a dependency is in the middle of a cell update (where\n+                // the value has been changed, but the dependent tasks have not be flagged dirty\n+                // yet). So to avoid that we first remove the cell content, invalidate all dependent\n+                // tasks and after that set the new cell content. When the cell content is unset,\n+                // readers will wait for it to be set via InProgressCell.\n+\n+                let old_content = task.remove(&CachedDataItemKey::CellData { cell });\n+\n+                drop(task);\n+                drop(old_content);\n \n-            UpdateCellOperation::InvalidateWhenCellDependency {\n-                cell_ref: CellRef {\n-                    task: task_id,\n-                    cell,\n-                },\n-                dependent_tasks,\n-                queue: AggregationUpdateQueue::new(),\n+                let content = if let CellContent(Some(new_content)) = content {\n+                    Some(new_content.into_typed(cell.type_id))\n+                } else {\n+                    None\n+                };\n+\n+                UpdateCellOperation::InvalidateWhenCellDependency {\n+                    cell_ref: CellRef {\n+                        task: task_id,\n+                        cell,\n+                    },\n+                    dependent_tasks,\n+                    content,\n+                    queue: AggregationUpdateQueue::new(),\n+                }\n+                .execute(&mut ctx);\n+                return;\n             }\n-            .execute(&mut ctx);\n+        }\n+\n+        // Fast path: We don't need to invalidate anything.\n+        // So we can just update the cell content.\n+\n+        let old_content = if let CellContent(Some(new_content)) = content {\n+            let new_content = new_content.into_typed(cell.type_id);\n+            task.insert(CachedDataItem::CellData {\n+                cell,\n+                value: new_content,\n+            })\n         } else {\n-            drop(task);\n-            drop(old_content);\n+            task.remove(&CachedDataItemKey::CellData { cell })\n+        };\n+\n+        let in_progress_cell = remove!(task, InProgressCell { cell });\n+\n+        drop(task);\n+        drop(old_content);\n+\n+        if let Some(in_progress) = in_progress_cell {\n+            in_progress.event.notify(usize::MAX);\n         }\n     }\n }\n@@ -93,6 +130,7 @@ impl Operation for UpdateCellOperation {\n                 UpdateCellOperation::InvalidateWhenCellDependency {\n                     cell_ref,\n                     ref mut dependent_tasks,\n+                    ref mut content,\n                     ref mut queue,\n                 } => {\n                     if let Some(dependent_task_id) = dependent_tasks.pop() {\n@@ -129,9 +167,37 @@ impl Operation for UpdateCellOperation {\n                         );\n                     }\n                     if dependent_tasks.is_empty() {\n-                        self = UpdateCellOperation::AggregationUpdate { queue: take(queue) };\n+                        self = UpdateCellOperation::FinalCellChange {\n+                            cell_ref,\n+                            content: take(content),\n+                            queue: take(queue),\n+                        };\n                     }\n                 }\n+                UpdateCellOperation::FinalCellChange {\n+                    cell_ref: CellRef { task, cell },\n+                    content,\n+                    ref mut queue,\n+                } => {\n+                    let mut task = ctx.task(task, TaskDataCategory::Data);\n+\n+                    if let Some(content) = content {\n+                        task.add_new(CachedDataItem::CellData {\n+                            cell,\n+                            value: content,\n+                        })\n+                    }\n+\n+                    let in_progress_cell = remove!(task, InProgressCell { cell });\n+\n+                    drop(task);\n+\n+                    if let Some(in_progress) = in_progress_cell {\n+                        in_progress.event.notify(usize::MAX);\n+                    }\n+\n+                    self = UpdateCellOperation::AggregationUpdate { queue: take(queue) };\n+                }\n                 UpdateCellOperation::AggregationUpdate { ref mut queue } => {\n                     if queue.process(ctx) {\n                         self = UpdateCellOperation::Done"
        }
    ],
    "stats": {
        "total": 145,
        "additions": 104,
        "deletions": 41
    }
}