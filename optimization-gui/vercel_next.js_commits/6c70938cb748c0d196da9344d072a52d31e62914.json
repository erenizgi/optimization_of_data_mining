{
    "author": "wyattjoh",
    "message": "[ppr] RDC for RSCs (#79638)\n\nThis pull request introduces support for handling postponed state in\ndynamic React Server Components (or RSC) requests, enabling the use of\nthe encoded Resume Data Cache (or RDC). The changes include adjustments\nto the server logic to better manage dynamic responses and improve\ncaching behavior for such requests.\n\nThis also updates the incremental cache to also add to the RDC when it's\nfetching already generated entries.\n\nThis pull request introduces changes to support dynamic React Server\nComponents (RSC) requests by enabling the use of postponed state and\nimproving cache handling. It also includes updates to error handling,\ntesting utilities, and incremental caching logic.\n\n### Enhancements for Dynamic RSC Requests\n\n* Added support for resuming renders with postponed data from the cache\nfor dynamic RSC requests, leveraging the `IncrementalCacheKind.APP_PAGE`\ncache type. This ensures efficient reuse of cached data when available.\n(`packages/next/src/server/base-server.ts`,\n[[1]](diffhunk://#diff-6f4291cc2bfc5073fdca12a014011769e840ee68583db1468acef075f037015aL3097-R3139)\n[[2]](diffhunk://#diff-6f4291cc2bfc5073fdca12a014011769e840ee68583db1468acef075f037015aL3262-R3294)\n* Updated cache control logic to handle dynamic RSC requests more\neffectively, ensuring they are not cached when containing dynamic\ncontent. (`packages/next/src/server/base-server.ts`,\n[packages/next/src/server/base-server.tsL3526-R3550](diffhunk://#diff-6f4291cc2bfc5073fdca12a014011769e840ee68583db1468acef075f037015aL3526-R3550))\n\n### Improvements to Incremental Caching\n\n* Introduced a `checkTags` method in the `IncrementalCache` class to\ndetermine if a tag has been revalidated, preventing stale data from\nbeing returned.\n(`packages/next/src/server/lib/incremental-cache/index.ts`,\n[packages/next/src/server/lib/incremental-cache/index.tsR599-R627](diffhunk://#diff-c990316f5df4319261936cd61b07566c5e12cd7e68c9e92f6da38a190a639154R599-R627))\n* Refactored logic to store prerender resume data in the cache for\nbetter performance and reliability.\n(`packages/next/src/server/lib/incremental-cache/index.ts`,\n[packages/next/src/server/lib/incremental-cache/index.tsL442-R461](diffhunk://#diff-c990316f5df4319261936cd61b07566c5e12cd7e68c9e92f6da38a190a639154L442-R461))\n\n### Testing Updates\n\n* Updated E2E tests in `app-action.test.ts` to use modern `fs/promises`\nand `node:path` modules, improving readability and consistency.\n(`test/e2e/app-dir/actions/app-action.test.ts`,\n[test/e2e/app-dir/actions/app-action.test.tsL11-R14](diffhunk://#diff-b3bc78ed83df32c7d5afa3d352038f8afd7eb37027be87ca22bac3d3cb33657aL11-R14))\n* Refactored test assertions to ensure dynamic RSC behavior and\nrevalidation logic are correctly validated.\n(`test/e2e/app-dir/actions/app-action.test.ts`,\n[[1]](diffhunk://#diff-b3bc78ed83df32c7d5afa3d352038f8afd7eb37027be87ca22bac3d3cb33657aR543-L546)\n[[2]](diffhunk://#diff-b3bc78ed83df32c7d5afa3d352038f8afd7eb37027be87ca22bac3d3cb33657aL1564-R1589)",
    "sha": "6c70938cb748c0d196da9344d072a52d31e62914",
    "files": [
        {
            "sha": "b2f99a20c3138eb0be9c2576306e8d29b296b162",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -712,5 +712,7 @@\n   \"711\": \"Can't resolve %s\",\n   \"712\": \"`rspack.warnForEdgeRuntime` is not supported by the wasm bindings.\",\n   \"713\": \"Unexpected error during process lookup\",\n-  \"714\": \"cannot run loadNative when `NEXT_TEST_WASM` is set\"\n+  \"714\": \"cannot run loadNative when `NEXT_TEST_WASM` is set\",\n+  \"715\": \"expected a result to be returned\",\n+  \"716\": \"expected a page response, got %s\"\n }"
        },
        {
            "sha": "f9ceb148a26645ac866f1b4e2a99632be503bc74",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -447,6 +447,7 @@ export type RoutesManifest = {\n     prefetchSegmentHeader: typeof NEXT_ROUTER_SEGMENT_PREFETCH_HEADER\n     prefetchSegmentDirSuffix: typeof RSC_SEGMENTS_DIR_SUFFIX\n     prefetchSegmentSuffix: typeof RSC_SEGMENT_SUFFIX\n+    dynamicRSCPrerender: boolean\n   }\n   rewriteHeaders: {\n     pathHeader: typeof NEXT_REWRITTEN_PATH_HEADER\n@@ -1370,6 +1371,7 @@ export default async function build(\n               prefetchSegmentHeader: NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n               prefetchSegmentSuffix: RSC_SEGMENT_SUFFIX,\n               prefetchSegmentDirSuffix: RSC_SEGMENTS_DIR_SUFFIX,\n+              dynamicRSCPrerender: isAppPPREnabled,\n             },\n             rewriteHeaders: {\n               pathHeader: NEXT_REWRITTEN_PATH_HEADER,"
        },
        {
            "sha": "f15aa8ef18d00d03fe11a26e07490c3a3dd9d006",
            "filename": "packages/next/src/build/templates/app-page.ts",
            "status": "modified",
            "additions": 62,
            "deletions": 60,
            "changes": 122,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -36,6 +36,7 @@ import {\n import { getBotType, isBot } from '../../shared/lib/router/utils/is-bot'\n import {\n   CachedRouteKind,\n+  IncrementalCacheKind,\n   type CachedAppPageValue,\n   type CachedPageValue,\n   type ResponseCacheEntry,\n@@ -126,7 +127,6 @@ export async function handler(\n   const multiZoneDraftMode = process.env\n     .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n \n-  const initialPostponed = getRequestMeta(req, 'postponed')\n   // TODO: replace with more specific flags\n   const minimalMode = getRequestMeta(req, 'minimalMode')\n \n@@ -260,7 +260,9 @@ export async function handler(\n   // If we're in minimal mode, then try to get the postponed information from\n   // the request metadata. If available, use it for resuming the postponed\n   // render.\n-  const minimalPostponed = isRoutePPREnabled ? initialPostponed : undefined\n+  const minimalPostponed = isRoutePPREnabled\n+    ? getRequestMeta(req, 'postponed')\n+    : undefined\n \n   // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n   // we can use this fact to only generate the flight data for the request\n@@ -297,10 +299,10 @@ export async function handler(\n     !isSSG ||\n     // If this request has provided postponed data, it supports dynamic\n     // HTML.\n-    typeof initialPostponed === 'string' ||\n+    typeof minimalPostponed === 'string' ||\n     // If this is a dynamic RSC request, then this render supports dynamic\n     // HTML (it's dynamic).\n-    isDynamicRSCRequest\n+    (isDynamicRSCRequest && !minimalMode)\n \n   // When html bots request PPR page, perform the full dynamic rendering.\n   const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled\n@@ -415,6 +417,8 @@ export async function handler(\n       })\n     }\n \n+    const incrementalCache = getRequestMeta(req, 'incrementalCache')\n+\n     const doRender = async ({\n       span,\n       postponed,\n@@ -432,6 +436,9 @@ export async function handler(\n        */\n       fallbackRouteParams: FallbackRouteParams | null\n     }): Promise<ResponseCacheEntry> => {\n+      // When we're resuming a render, we should allow dynamic response.\n+      if (typeof postponed === 'string') supportsDynamicResponse = true\n+\n       const context: AppPageRouteHandlerContext = {\n         query,\n         params,\n@@ -457,8 +464,7 @@ export async function handler(\n           postponed,\n           shouldWaitOnAllReady,\n           serveStreamingMetadata,\n-          supportsDynamicResponse:\n-            typeof postponed === 'string' || supportsDynamicResponse,\n+          supportsDynamicResponse,\n           buildManifest,\n           nextFontManifest,\n           reactLoadableManifest,\n@@ -486,21 +492,11 @@ export async function handler(\n           reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n \n           multiZoneDraftMode,\n-          incrementalCache: getRequestMeta(req, 'incrementalCache'),\n+          incrementalCache,\n           cacheLifeProfiles: nextConfig.experimental.cacheLife,\n           basePath: nextConfig.basePath,\n           serverActions: nextConfig.experimental.serverActions,\n \n-          ...(isDebugStaticShell || isDebugDynamicAccesses\n-            ? {\n-                nextExport: true,\n-                supportsDynamicResponse: false,\n-                isStaticGeneration: true,\n-                isRevalidate: true,\n-                isDebugDynamicAccesses: isDebugDynamicAccesses,\n-              }\n-            : {}),\n-\n           experimental: {\n             isRoutePPREnabled,\n             expireTime: nextConfig.expireTime,\n@@ -534,6 +530,14 @@ export async function handler(\n         },\n       }\n \n+      if (isDebugStaticShell || isDebugDynamicAccesses) {\n+        context.renderOpts.nextExport = true\n+        context.renderOpts.supportsDynamicResponse = false\n+        context.renderOpts.isStaticGeneration = true\n+        context.renderOpts.isRevalidate = true\n+        context.renderOpts.isDebugDynamicAccesses = isDebugDynamicAccesses\n+      }\n+\n       const result = await invokeRouteModule(span, context)\n \n       const { metadata } = result\n@@ -699,13 +703,42 @@ export async function handler(\n           }\n         }\n       }\n+\n       // Only requests that aren't revalidating can be resumed. If we have the\n       // minimal postponed data, then we should resume the render with it.\n-      const postponed =\n+      let postponed =\n         !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n           ? minimalPostponed\n           : undefined\n \n+      // If this is a dynamic RSC request, we should use the postponed data from\n+      // the static render (if available). This ensures that we can utilize the\n+      // resume data cache (RDC) from the static render to ensure that the data\n+      // is consistent between the static and dynamic renders.\n+      if (\n+        process.env.NEXT_RUNTIME !== 'edge' &&\n+        !minimalMode &&\n+        incrementalCache &&\n+        isDynamicRSCRequest\n+      ) {\n+        const cachedEntry = await incrementalCache.get(resolvedPathname, {\n+          kind: IncrementalCacheKind.APP_PAGE,\n+          isRoutePPREnabled: true,\n+          isFallback: false,\n+          allowStale: true,\n+        })\n+\n+        // If the cache entry is found, we should use the postponed data from\n+        // the cache.\n+        if (\n+          cachedEntry &&\n+          cachedEntry.value &&\n+          cachedEntry.value.kind === CachedRouteKind.APP_PAGE\n+        ) {\n+          postponed = cachedEntry.value.postponed\n+        }\n+      }\n+\n       // When we're in minimal mode, if we're trying to debug the static shell,\n       // we should just return nothing instead of resuming the dynamic render.\n       if (\n@@ -831,12 +864,7 @@ export async function handler(\n       // If this is in minimal mode and this is a flight request that isn't a\n       // prefetch request while PPR is enabled, it cannot be cached as it contains\n       // dynamic content.\n-      else if (\n-        minimalMode &&\n-        isRSCRequest &&\n-        !isPrefetchRSCRequest &&\n-        isRoutePPREnabled\n-      ) {\n+      else if (isDynamicRSCRequest) {\n         cacheControl = { revalidate: 0, expire: undefined }\n       } else if (!routeModule.isDev) {\n         // If this is a preview mode request, we shouldn't cache it\n@@ -933,34 +961,15 @@ export async function handler(\n \n       // If there's a callback for `onCacheEntry`, call it with the cache entry\n       // and the revalidate options.\n-      const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n+      const onCacheEntry =\n+        getRequestMeta(req, 'onCacheEntryV2') ??\n+        // TODO: Remove this once we've migrated to `onCacheEntryV2`\n+        getRequestMeta(req, 'onCacheEntry')\n       if (onCacheEntry) {\n-        const finished = await onCacheEntry(\n-          {\n-            ...cacheEntry,\n-            // TODO: remove this when upstream doesn't\n-            // always expect this value to be \"PAGE\"\n-            value: {\n-              ...cacheEntry.value,\n-              kind: 'PAGE',\n-            },\n-          },\n-          {\n-            url: getRequestMeta(req, 'initURL'),\n-          }\n-        )\n-        if (finished) {\n-          // TODO: maybe we have to end the request?\n-          return null\n-        }\n-      }\n-\n-      // If the request has a postponed state and it's a resume request we\n-      // should error.\n-      if (didPostpone && minimalPostponed) {\n-        throw new Error(\n-          'Invariant: postponed state should not be present on a resume request'\n-        )\n+        const finished = await onCacheEntry(cacheEntry, {\n+          url: getRequestMeta(req, 'initURL') ?? req.url,\n+        })\n+        if (finished) return null\n       }\n \n       if (cachedData.headers) {\n@@ -1033,14 +1042,7 @@ export async function handler(\n             generateEtags: nextConfig.generateEtags,\n             poweredByHeader: nextConfig.poweredByHeader,\n             result: cachedData.html,\n-            // Dynamic RSC responses cannot be cached, even if they're\n-            // configured with `force-static` because we have no way of\n-            // distinguishing between `force-static` and pages that have no\n-            // postponed state.\n-            // TODO: distinguish `force-static` from pages with no postponed state (static)\n-            cacheControl: isDynamicRSCRequest\n-              ? { revalidate: 0, expire: undefined }\n-              : cacheEntry.cacheControl,\n+            cacheControl: cacheEntry.cacheControl,\n           })\n         }\n \n@@ -1058,7 +1060,7 @@ export async function handler(\n       }\n \n       // This is a request for HTML data.\n-      let body = cachedData.html\n+      const body = cachedData.html\n \n       // If there's no postponed state, we should just serve the HTML. This\n       // should also be the case for a resume request because it's completed"
        },
        {
            "sha": "a7bd5ea4d2a8331d2da9c8abc6625b04ff662c18",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -1509,7 +1509,9 @@ async function renderToHTMLOrFlightImpl(\n   } else {\n     // We're rendering dynamically\n     const renderResumeDataCache =\n-      renderOpts.renderResumeDataCache ?? postponedState?.renderResumeDataCache\n+      renderOpts.renderResumeDataCache ??\n+      postponedState?.renderResumeDataCache ??\n+      null\n \n     const rootParams = getRootParams(loaderTree, ctx.getDynamicParamFromSegment)\n     const requestStore = createRequestStoreForRender(\n@@ -1563,6 +1565,9 @@ async function renderToHTMLOrFlightImpl(\n \n     let formState: null | any = null\n     if (isPossibleActionRequest) {\n+      // For action requests, we don't want to use the resume data cache.\n+      requestStore.renderResumeDataCache = null\n+\n       // For action requests, we handle them differently with a special render result.\n       const actionRequestResult = await handleAction({\n         req,\n@@ -1603,6 +1608,9 @@ async function renderToHTMLOrFlightImpl(\n           }\n         }\n       }\n+\n+      // Restore the resume data cache\n+      requestStore.renderResumeDataCache = renderResumeDataCache\n     }\n \n     const options: RenderResultOptions = {"
        },
        {
            "sha": "2334db7fb731af3152dea6d87e37d5af48b12df5",
            "filename": "packages/next/src/server/async-storage/request-store.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -114,7 +114,7 @@ export function createRequestStoreForRender(\n   previewProps: WrapperRenderOpts['previewProps'],\n   isHmrRefresh: RequestContext['isHmrRefresh'],\n   serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],\n-  renderResumeDataCache: RenderResumeDataCache | undefined\n+  renderResumeDataCache: RenderResumeDataCache | null\n ): RequestStore {\n   return createRequestStoreImpl(\n     // Pages start in render phase by default\n@@ -148,7 +148,7 @@ export function createRequestStoreForAPI(\n     {},\n     implicitTags,\n     onUpdateCookies,\n-    undefined,\n+    null,\n     previewProps,\n     false,\n     undefined\n@@ -163,7 +163,7 @@ function createRequestStoreImpl(\n   rootParams: Params,\n   implicitTags: RequestContext['implicitTags'],\n   onUpdateCookies: RenderOpts['onUpdateCookies'],\n-  renderResumeDataCache: RenderResumeDataCache | undefined,\n+  renderResumeDataCache: RenderResumeDataCache | null,\n   previewProps: WrapperRenderOpts['previewProps'],\n   isHmrRefresh: RequestContext['isHmrRefresh'],\n   serverComponentsHmrCache: RequestContext['serverComponentsHmrCache']"
        },
        {
            "sha": "b80d933e43abf3d56927232d7df6cab8deab2dce",
            "filename": "packages/next/src/server/base-server.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 48,
            "changes": 67,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -3034,9 +3034,7 @@ export default abstract class Server<\n           fallbackResponse = await this.responseCache.get(\n             isProduction ? (locale ? `/${locale}${pathname}` : pathname) : null,\n             // This is the response generator for the fallback shell.\n-            async ({\n-              previousCacheEntry: previousFallbackCacheEntry = null,\n-            }) => {\n+            ({ previousCacheEntry: previousFallbackCacheEntry = null }) => {\n               // For the pages router, fallbacks cannot be revalidated or\n               // generated in production. In the case of a missing fallback,\n               // we return null, but if it's being revalidated, we just return\n@@ -3077,7 +3075,7 @@ export default abstract class Server<\n           fallbackResponse = await this.responseCache.get(\n             isProduction ? pathname : null,\n             // This is the response generator for the fallback shell.\n-            async () =>\n+            () =>\n               doRender({\n                 // We pass `undefined` as rendering a fallback isn't resumed\n                 // here.\n@@ -3107,7 +3105,7 @@ export default abstract class Server<\n         if (fallbackResponse) {\n           // Remove the cache control from the response to prevent it from being\n           // used in the surrounding cache.\n-          delete fallbackResponse.cacheControl\n+          fallbackResponse.cacheControl = undefined\n \n           return fallbackResponse\n         }\n@@ -3272,15 +3270,9 @@ export default abstract class Server<\n       cacheControl = { revalidate: 0, expire: undefined }\n     }\n \n-    // If this is in minimal mode and this is a flight request that isn't a\n-    // prefetch request while PPR is enabled, it cannot be cached as it contains\n-    // dynamic content.\n-    else if (\n-      this.minimalMode &&\n-      isRSCRequest &&\n-      !isPrefetchRSCRequest &&\n-      isRoutePPREnabled\n-    ) {\n+    // If this is a flight request that isn't a pre-fetch request while PPR is\n+    // enabled, it cannot be cached as it contains dynamic content.\n+    else if (isDynamicRSCRequest) {\n       cacheControl = { revalidate: 0, expire: undefined }\n     } else if (!this.renderOpts.dev || (hasServerProps && !isNextDataRequest)) {\n       // If this is a preview mode request, we shouldn't cache it\n@@ -3390,29 +3382,15 @@ export default abstract class Server<\n \n     // If there's a callback for `onCacheEntry`, call it with the cache entry\n     // and the revalidate options.\n-    const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n+    const onCacheEntry =\n+      getRequestMeta(req, 'onCacheEntryV2') ??\n+      // TODO: Remove this once we've migrated to `onCacheEntryV2`\n+      getRequestMeta(req, 'onCacheEntry')\n     if (onCacheEntry) {\n-      const finished = await onCacheEntry(\n-        {\n-          ...cacheEntry,\n-          // TODO: remove this when upstream doesn't\n-          // always expect this value to be \"PAGE\"\n-          value: {\n-            ...cacheEntry.value,\n-            kind:\n-              cacheEntry.value?.kind === CachedRouteKind.APP_PAGE\n-                ? 'PAGE'\n-                : cacheEntry.value?.kind,\n-          },\n-        },\n-        {\n-          url: getRequestMeta(req, 'initURL'),\n-        }\n-      )\n-      if (finished) {\n-        // TODO: maybe we have to end the request?\n-        return null\n-      }\n+      const finished = await onCacheEntry(cacheEntry, {\n+        url: getRequestMeta(req, 'initURL') ?? req.url,\n+      })\n+      if (finished) return null\n     }\n \n     if (!cachedData) {\n@@ -3528,7 +3506,7 @@ export default abstract class Server<\n       }\n \n       // Mark that the request did postpone.\n-      if (didPostpone) {\n+      if (didPostpone && !isDynamicRSCRequest) {\n         res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n       }\n \n@@ -3546,14 +3524,7 @@ export default abstract class Server<\n           return {\n             type: 'rsc',\n             body: cachedData.html,\n-            // Dynamic RSC responses cannot be cached, even if they're\n-            // configured with `force-static` because we have no way of\n-            // distinguishing between `force-static` and pages that have no\n-            // postponed state.\n-            // TODO: distinguish `force-static` from pages with no postponed state (static)\n-            cacheControl: isDynamicRSCRequest\n-              ? { revalidate: 0, expire: undefined }\n-              : cacheEntry.cacheControl,\n+            cacheControl: cacheEntry.cacheControl,\n           }\n         }\n \n@@ -3621,12 +3592,12 @@ export default abstract class Server<\n       })\n         .then(async (result) => {\n           if (!result) {\n-            throw new Error('Invariant: expected a result to be returned')\n+            throw new InvariantError('expected a result to be returned')\n           }\n \n           if (result.value?.kind !== CachedRouteKind.APP_PAGE) {\n-            throw new Error(\n-              `Invariant: expected a page response, got ${result.value?.kind}`\n+            throw new InvariantError(\n+              `expected a page response, got ${result.value?.kind}`\n             )\n           }\n "
        },
        {
            "sha": "bb5c9b2182e3fbbaf1719c569e9139048c5648aa",
            "filename": "packages/next/src/server/lib/incremental-cache/file-system-cache.ts",
            "status": "modified",
            "additions": 28,
            "deletions": 9,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -276,6 +276,16 @@ export default class FileSystemCache implements CacheHandler {\n       }\n     }\n \n+    // If enabled, this will return the possibly stale data without validating\n+    // that the tags have expired or not yet been revalidated.\n+    if ('allowStale' in ctx && ctx.allowStale) {\n+      if (FileSystemCache.debug) {\n+        console.log('allow stale', ctx.allowStale)\n+      }\n+\n+      return data ?? null\n+    }\n+\n     if (\n       data?.value?.kind === CachedRouteKind.APP_PAGE ||\n       data?.value?.kind === CachedRouteKind.PAGES\n@@ -292,6 +302,10 @@ export default class FileSystemCache implements CacheHandler {\n         // had a tag revalidated, if we want to be a background\n         // revalidation instead we return data.lastModified = -1\n         if (isStale(cacheTags, data?.lastModified || Date.now())) {\n+          if (FileSystemCache.debug) {\n+            console.log('stale tags', cacheTags)\n+          }\n+\n           return null\n         }\n       }\n@@ -301,17 +315,22 @@ export default class FileSystemCache implements CacheHandler {\n           ? [...(ctx.tags || []), ...(ctx.softTags || [])]\n           : []\n \n-      const wasRevalidated = combinedTags.some((tag) => {\n-        if (this.revalidatedTags.includes(tag)) {\n-          return true\n+      // When revalidate tag is called we don't return stale data so it's\n+      // updated right away.\n+      if (combinedTags.some((tag) => this.revalidatedTags.includes(tag))) {\n+        if (FileSystemCache.debug) {\n+          console.log('was revalidated', combinedTags)\n+        }\n+\n+        return null\n+      }\n+\n+      if (isStale(combinedTags, data?.lastModified || Date.now())) {\n+        if (FileSystemCache.debug) {\n+          console.log('stale tags', combinedTags)\n         }\n \n-        return isStale([tag], data?.lastModified || Date.now())\n-      })\n-      // When revalidate tag is called we don't return\n-      // stale data so it's updated right away\n-      if (wasRevalidated) {\n-        data = undefined\n+        return null\n       }\n     }\n "
        },
        {
            "sha": "088bcc7806fc0806c8f902fb950b46a2268f88ef",
            "filename": "packages/next/src/server/lib/incremental-cache/index.ts",
            "status": "modified",
            "additions": 37,
            "deletions": 3,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -15,7 +15,6 @@ import {\n   type SetIncrementalResponseCacheContext,\n } from '../../response-cache'\n import type { DeepReadonly } from '../../../shared/lib/deep-readonly'\n-\n import FileSystemCache from './file-system-cache'\n import { normalizePagePath } from '../../../shared/lib/page-path/normalize-page-path'\n \n@@ -89,8 +88,8 @@ export class IncrementalCache implements IncrementalCacheType {\n   readonly allowedRevalidateHeaderKeys?: string[]\n   readonly minimalMode?: boolean\n   readonly fetchCacheKeyPrefix?: string\n-  readonly revalidatedTags?: string[]\n   readonly isOnDemandRevalidate?: boolean\n+  readonly revalidatedTags?: readonly string[]\n \n   private static readonly debug: boolean =\n     !!process.env.NEXT_PRIVATE_DEBUG_CACHE\n@@ -179,7 +178,7 @@ export class IncrementalCache implements IncrementalCacheType {\n     }\n \n     if (minimalMode) {\n-      revalidatedTags = getPreviouslyRevalidatedTags(\n+      revalidatedTags = this.revalidatedTags = getPreviouslyRevalidatedTags(\n         requestHeaders,\n         this.prerenderManifest?.preview?.previewModeId\n       )\n@@ -426,7 +425,13 @@ export class IncrementalCache implements IncrementalCacheType {\n       if (resumeDataCache) {\n         const memoryCacheData = resumeDataCache.fetch.get(cacheKey)\n         if (memoryCacheData?.kind === CachedRouteKind.FETCH) {\n+          if (IncrementalCache.debug) {\n+            console.log('rdc:hit', cacheKey)\n+          }\n+\n           return { isStale: false, value: memoryCacheData }\n+        } else if (IncrementalCache.debug) {\n+          console.log('rdc:miss', cacheKey)\n         }\n       }\n     }\n@@ -470,9 +475,34 @@ export class IncrementalCache implements IncrementalCacheType {\n             workStore?.pendingRevalidatedTags?.includes(tag)\n         )\n       ) {\n+        if (IncrementalCache.debug) {\n+          console.log('stale tag', cacheKey)\n+        }\n+\n         return null\n       }\n \n+      // As we're able to get the cache entry for this fetch, and the prerender\n+      // resume data cache (RDC) is available, it must have been populated by a\n+      // previous fetch, but was not yet present in the in-memory cache. This\n+      // could be the case when performing multiple renders in parallel during\n+      // build time where we de-duplicate the fetch calls.\n+      //\n+      // We add it to the RDC so that the next fetch call will be able to use it\n+      // and it won't have to reach into the fetch cache implementation.\n+      const workUnitStore = workUnitAsyncStorage.getStore()\n+      if (workUnitStore) {\n+        const prerenderResumeDataCache =\n+          getPrerenderResumeDataCache(workUnitStore)\n+        if (prerenderResumeDataCache) {\n+          if (IncrementalCache.debug) {\n+            console.log('rdc:set', cacheKey)\n+          }\n+\n+          prerenderResumeDataCache.fetch.set(cacheKey, cacheData.value)\n+        }\n+      }\n+\n       const revalidate = ctx.revalidate || cacheData.value.revalidate\n       const age =\n         (performance.timeOrigin +\n@@ -571,6 +601,10 @@ export class IncrementalCache implements IncrementalCacheType {\n         ? getPrerenderResumeDataCache(workUnitStore)\n         : null\n       if (prerenderResumeDataCache) {\n+        if (IncrementalCache.debug) {\n+          console.log('rdc:set', pathname)\n+        }\n+\n         prerenderResumeDataCache.fetch.set(pathname, data)\n       }\n     }"
        },
        {
            "sha": "f39d20b47cf81432745c369b7a6b6a908909f35a",
            "filename": "packages/next/src/server/request-meta.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 4,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -6,8 +6,12 @@ import type { BaseNextRequest } from './base-http'\n import type { CloneableBody } from './body-streams'\n import type { RouteMatch } from './route-matches/route-match'\n import type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\n-import type { ServerComponentsHmrCache } from './response-cache'\n+import type {\n+  ResponseCacheEntry,\n+  ServerComponentsHmrCache,\n+} from './response-cache'\n import type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'\n+import type { IncrementalCache } from './lib/incremental-cache'\n \n // FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules\n export const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')\n@@ -68,7 +72,7 @@ export interface RequestMeta {\n   /**\n    * The incremental cache to use for the request.\n    */\n-  incrementalCache?: any\n+  incrementalCache?: IncrementalCache\n \n   /**\n    * The server components HMR cache, only for dev.\n@@ -118,10 +122,25 @@ export interface RequestMeta {\n   /**\n    * If provided, this will be called when a response cache entry was generated\n    * or looked up in the cache.\n+   *\n+   * @deprecated Use `onCacheEntryV2` instead.\n    */\n   onCacheEntry?: (\n-    cacheEntry: any,\n-    requestMeta: any\n+    cacheEntry: ResponseCacheEntry,\n+    requestMeta: {\n+      url: string | undefined\n+    }\n+  ) => Promise<boolean | void> | boolean | void\n+\n+  /**\n+   * If provided, this will be called when a response cache entry was generated\n+   * or looked up in the cache.\n+   */\n+  onCacheEntryV2?: (\n+    cacheEntry: ResponseCacheEntry,\n+    requestMeta: {\n+      url: string | undefined\n+    }\n   ) => Promise<boolean | void> | boolean | void\n \n   /**"
        },
        {
            "sha": "eabefeb9a45e601ef02cc948164f47ce2bd7240e",
            "filename": "packages/next/src/server/response-cache/types.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -219,6 +219,11 @@ export interface GetIncrementalResponseCacheContext {\n    * True if this is a fallback request.\n    */\n   isFallback: boolean\n+\n+  /**\n+   * True if stale data is allowed to be returned.\n+   */\n+  allowStale?: boolean\n }\n \n export interface SetIncrementalFetchCacheContext {"
        },
        {
            "sha": "14e1de4937198c3cc0db3721cba8600cd859dd13",
            "filename": "test/integration/custom-routes/test/index.test.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -2570,6 +2570,7 @@ const runTests = (isDev = false) => {\n           prefetchSegmentSuffix: '.segment.rsc',\n           prefetchSuffix: '.prefetch.rsc',\n           suffix: '.rsc',\n+          dynamicRSCPrerender: !!process.env.__NEXT_EXPERIMENTAL_PPR,\n         },\n       })\n     })"
        },
        {
            "sha": "11b4929f456dd7c32203961c883aadb96a5145b5",
            "filename": "test/integration/dynamic-routing/test/index.test.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -1529,6 +1529,7 @@ function runTests({ dev }) {\n           prefetchSegmentSuffix: '.segment.rsc',\n           prefetchSuffix: '.prefetch.rsc',\n           suffix: '.rsc',\n+          dynamicRSCPrerender: !!process.env.__NEXT_EXPERIMENTAL_PPR,\n         },\n       })\n     })"
        },
        {
            "sha": "4bcad8af0589836568f9d3dd0f469f5bcd89c052",
            "filename": "test/ppr-tests-manifest.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fppr-tests-manifest.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fppr-tests-manifest.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fppr-tests-manifest.json?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -174,7 +174,8 @@\n       \"test/e2e/app-dir/use-cache-route-handler-only/**/*\",\n       \"test/integration/app-dir-export/**/*\",\n       \"test/production/app-dir/build-output-tree-view/build-output-tree-view.test.ts\",\n-      \"test/production/app-dir/global-default-cache-handler/global-default-cache-handler.test.ts\"\n+      \"test/production/app-dir/global-default-cache-handler/global-default-cache-handler.test.ts\",\n+      \"test/production/app-dir/resume-data-cache/resume-data-cache.test.ts\"\n     ]\n   }\n }"
        },
        {
            "sha": "9dfde1627512b37a73ed3912c0b31e351276e718",
            "filename": "test/production/app-dir/resume-data-cache/app/layout.tsx",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Flayout.tsx?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -0,0 +1,9 @@\n+import React, { ReactNode } from 'react'\n+\n+export default function Root({ children }: { children: ReactNode }) {\n+  return (\n+    <html>\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "a42bd6f524a3954725b84d2eb7b3480bd49ced27",
            "filename": "test/production/app-dir/resume-data-cache/app/page.tsx",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Fpage.tsx?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -0,0 +1,32 @@\n+import React, { Suspense } from 'react'\n+import { connection } from 'next/server'\n+\n+import { unstable_cacheTag } from 'next/cache'\n+\n+async function getRandomNumber() {\n+  'use cache'\n+  unstable_cacheTag('test')\n+  return Math.random()\n+}\n+\n+async function DynamicComponent() {\n+  await connection()\n+  return null\n+}\n+\n+export default async function Page() {\n+  const randomNumber = await getRandomNumber()\n+  const anotherRandomNumber = await fetch(\n+    'https://next-data-api-endpoint.vercel.app/api/random',\n+    { cache: 'force-cache', next: { tags: ['test'] } }\n+  ).then((res) => res.text())\n+  return (\n+    <>\n+      <p id=\"random-number\">{randomNumber}</p>\n+      <p id=\"another-random-number\">{anotherRandomNumber}</p>\n+      <Suspense>\n+        <DynamicComponent />\n+      </Suspense>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "4100bb53cdd06963db1274e8de7906a848adf954",
            "filename": "test/production/app-dir/resume-data-cache/app/revalidate/route.ts",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Frevalidate%2Froute.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Frevalidate%2Froute.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Frevalidate%2Froute.ts?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -0,0 +1,6 @@\n+import { revalidateTag } from 'next/cache'\n+\n+export function POST() {\n+  revalidateTag('test')\n+  return new Response(null, { status: 200 })\n+}"
        },
        {
            "sha": "bea0706290af6bfcb4d7dfbd29c8f6acfbc78477",
            "filename": "test/production/app-dir/resume-data-cache/next.config.js",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fnext.config.js?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -0,0 +1,11 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  experimental: {\n+    ppr: true,\n+    useCache: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "b7c3a0ec7f71e7e03c7d5165169204530edf3142",
            "filename": "test/production/app-dir/resume-data-cache/resume-data-cache.test.ts",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fresume-data-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fresume-data-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fresume-data-cache.test.ts?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -0,0 +1,109 @@\n+import { nextTestSetup } from 'e2e-utils'\n+import { retry } from 'next-test-utils'\n+\n+describe('resume-data-cache', () => {\n+  const { next, skipped } = nextTestSetup({\n+    files: __dirname,\n+    // TODO: re-enable once support has been added\n+    skipDeployment: true,\n+  })\n+  if (skipped) return\n+\n+  it.each([\n+    { name: 'use cache', id: 'random-number' },\n+    { name: 'fetch cache', id: 'another-random-number' },\n+  ])(\n+    'should have consistent data between static and dynamic renders with $name',\n+    async ({ id }) => {\n+      // First render the page statically, getting the random number from the\n+      // HTML.\n+      let $ = await next.render$('/')\n+      const first = $(`p#${id}`).text()\n+\n+      // Then get the Prefetch RSC and validate that it also contains the same\n+      // random number.\n+      let rsc\n+\n+      await retry(async () => {\n+        rsc = await next\n+          .fetch('/', {\n+            headers: {\n+              RSC: '1',\n+              'Next-Router-Prefetch': '1',\n+            },\n+          })\n+          .then((res) => res.text())\n+        expect(rsc).toContain(first)\n+      })\n+\n+      // Then get the dynamic RSC and validate that it also contains the same\n+      // random number.\n+      await retry(async () => {\n+        rsc = await next\n+          .fetch('/', {\n+            headers: {\n+              RSC: '1',\n+            },\n+          })\n+          .then((res) => res.text())\n+        expect(rsc).toContain(first)\n+      })\n+\n+      // Then revalidate the page\n+      await next.fetch('/revalidate', { method: 'POST' })\n+\n+      // Then get the dynamic RSC again and validate that it still contains the\n+      // same random number.\n+      await retry(async () => {\n+        rsc = await next\n+          .fetch('/', {\n+            headers: {\n+              RSC: '1',\n+            },\n+          })\n+          .then((res) => res.text())\n+        expect(rsc).toContain(first)\n+      })\n+\n+      // This proves that the dynamic RSC was able to use the resume data cache\n+      // (RDC) from the static render to ensure that the data is consistent\n+      // between the static and dynamic renders. Let's now try to render the\n+      // page statically and see that the random number changes.\n+\n+      $ = await next.render$('/')\n+      const random2 = $(`p#${id}`).text()\n+      expect(random2).not.toBe(first)\n+\n+      // Then get the Prefetch RSC and validate that it also contains the new\n+      // random number.\n+      await retry(async () => {\n+        rsc = await next\n+          .fetch('/', {\n+            headers: {\n+              RSC: '1',\n+              'Next-Router-Prefetch': '1',\n+            },\n+          })\n+          .then((res) => res.text())\n+        expect(rsc).toContain(random2)\n+      })\n+\n+      // Then get the dynamic RSC again and validate that it also contains the\n+      // new random number.\n+      await retry(async () => {\n+        rsc = await next\n+          .fetch('/', {\n+            headers: {\n+              RSC: '1',\n+            },\n+          })\n+          .then((res) => res.text())\n+        expect(rsc).toContain(random2)\n+      })\n+\n+      // This proves that the dynamic RSC was able to use the resume data cache\n+      // (RDC) from the static render to ensure that the data is consistent\n+      // between the static and dynamic renders.\n+    }\n+  )\n+})"
        },
        {
            "sha": "051ec6f7a05691b5c96f4b737d7321f3240ab26b",
            "filename": "test/production/standalone-mode/required-server-files/app/dyn/[slug]/page.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Fdyn%2F%5Bslug%5D%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Fdyn%2F%5Bslug%5D%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Fdyn%2F%5Bslug%5D%2Fpage.js?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -1,7 +1,7 @@\n import { headers } from 'next/headers'\n \n export default async function Page({ params }) {\n-  const data = headers()\n+  const data = await headers()\n \n   return (\n     <>"
        },
        {
            "sha": "729ce481ad762c9e0addaeca12ad65701282c470",
            "filename": "test/production/standalone-mode/required-server-files/app/rewrite/[slug]/page.js",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Frewrite%2F%5Bslug%5D%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Frewrite%2F%5Bslug%5D%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Frewrite%2F%5Bslug%5D%2Fpage.js?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -1,18 +1,24 @@\n import { Suspense } from 'react'\n-import { unstable_noStore } from 'next/cache'\n+import { connection } from 'next/server'\n \n export function generateStaticParams() {\n   return [{ slug: 'first-cookie' }]\n }\n \n-function Postpone({ children }) {\n-  unstable_noStore()\n+async function Postpone({ children }) {\n+  await connection()\n   return children\n }\n \n export default async function Page({ params }) {\n+  const random = await fetch(\n+    'https://next-data-api-endpoint.vercel.app/api/random',\n+    { cache: 'force-cache' }\n+  ).then((res) => res.text())\n+\n   return (\n     <>\n+      <p id=\"random\">{random}</p>\n       <Suspense>\n         <Postpone>\n           <p id=\"page\">/rewrite/[slug]</p>"
        },
        {
            "sha": "3834ec4818caf54e940959c5fe675f77d53e6d30",
            "filename": "test/production/standalone-mode/required-server-files/required-server-files-ppr.test.ts",
            "status": "modified",
            "additions": 140,
            "deletions": 72,
            "changes": 212,
            "blob_url": "https://github.com/vercel/next.js/blob/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Frequired-server-files-ppr.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6c70938cb748c0d196da9344d072a52d31e62914/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Frequired-server-files-ppr.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Frequired-server-files-ppr.test.ts?ref=6c70938cb748c0d196da9344d072a52d31e62914",
            "patch": "@@ -1,6 +1,5 @@\n-import glob from 'glob'\n-import fs from 'fs-extra'\n-import { join } from 'path'\n+import fs from 'node:fs/promises'\n+import { join } from 'node:path'\n import cheerio from 'cheerio'\n import { createNext, FileRef } from 'e2e-utils'\n import { NextInstance } from 'e2e-utils'\n@@ -11,27 +10,22 @@ import {\n   initNextServerScript,\n   killApp,\n } from 'next-test-utils'\n-import { ChildProcess } from 'child_process'\n+import { ChildProcess } from 'node:child_process'\n \n describe('required server files app router', () => {\n   let next: NextInstance\n   let server: ChildProcess\n   let appPort: number | string\n-  let delayedPostpone\n-  let rewritePostpone\n+  let delayedPostpone: string\n+  let rewritePostpone: string\n+  let rewriteHTML: string\n   let cliOutput = ''\n \n-  const setupNext = async ({\n-    nextEnv,\n-    minimalMode,\n-  }: {\n-    nextEnv?: boolean\n-    minimalMode?: boolean\n-  }) => {\n-    // test build against environment with next support\n-    process.env.NOW_BUILDER = nextEnv ? '1' : ''\n+  beforeAll(async () => {\n+    process.env.NOW_BUILDER = '1'\n     process.env.NEXT_PRIVATE_TEST_HEADERS = '1'\n \n+    // Setup the Next.js app and build it.\n     next = await createNext({\n       files: {\n         app: new FileRef(join(__dirname, 'app')),\n@@ -47,57 +41,57 @@ describe('required server files app router', () => {\n         cacheHandler: './cache-handler.js',\n         experimental: {\n           ppr: true,\n+          clientSegmentCache: true,\n         },\n         eslint: {\n           ignoreDuringBuilds: true,\n         },\n         output: 'standalone',\n       },\n     })\n+\n+    // Stop the server, we're going to restart it using the standalone server\n+    // below after some cleanup.\n     await next.stop()\n \n+    // Read the postponed state and the HTML that was generated at build time\n+    // from the output of the build.\n     delayedPostpone = (await next.readJSON('.next/server/app/delayed.meta'))\n       .postponed\n     rewritePostpone = (\n       await next.readJSON('.next/server/app/rewrite/first-cookie.meta')\n     ).postponed\n+    rewriteHTML = await next.readFile(\n+      '.next/server/app/rewrite/first-cookie.html'\n+    )\n \n-    await fs.move(\n+    await fs.rename(\n       join(next.testDir, '.next/standalone'),\n       join(next.testDir, 'standalone')\n     )\n-    for (const file of await fs.readdir(next.testDir)) {\n-      if (file !== 'standalone') {\n-        await fs.remove(join(next.testDir, file))\n-        console.log('removed', file)\n-      }\n-    }\n-    const files = glob.sync('**/*', {\n-      cwd: join(next.testDir, 'standalone/.next/server/pages'),\n-      dot: true,\n-    })\n \n-    for (const file of files) {\n-      if (file.endsWith('.json') || file.endsWith('.html')) {\n-        await fs.remove(join(next.testDir, '.next/server', file))\n-      }\n-    }\n+    const serverFilePath = join(next.testDir, 'standalone/server.js')\n \n-    const testServer = join(next.testDir, 'standalone/server.js')\n+    // We're going to use the minimal mode for the server.\n     await fs.writeFile(\n-      testServer,\n-      (await fs.readFile(testServer, 'utf8')).replace(\n+      serverFilePath,\n+      (await fs.readFile(serverFilePath, 'utf8')).replace(\n         'port:',\n-        `minimalMode: ${minimalMode},port:`\n+        `minimalMode: true, port:`\n       )\n     )\n+\n+    // Find a port to use for the server.\n     appPort = await findPort()\n+\n+    // Then we can start the server with the new environment variables.\n     server = await initNextServerScript(\n-      testServer,\n+      serverFilePath,\n       /- Local:/,\n       {\n         ...process.env,\n         PORT: `${appPort}`,\n+        NEXT_PRIVATE_DEBUG_CACHE: '1',\n       },\n       undefined,\n       {\n@@ -110,11 +104,8 @@ describe('required server files app router', () => {\n         },\n       }\n     )\n-  }\n-\n-  beforeAll(async () => {\n-    await setupNext({ nextEnv: true, minimalMode: true })\n   })\n+\n   afterAll(async () => {\n     delete process.env.NEXT_PRIVATE_TEST_HEADERS\n     await next.destroy()\n@@ -125,37 +116,35 @@ describe('required server files app router', () => {\n     expect(next.cliOutput).not.toContain('ERR_INVALID_URL')\n   })\n \n-  // this enables client segment cache in CI\n-  if (process.env.__NEXT_EXPERIMENTAL_PPR) {\n-    it('should de-dupe client segment tree revalidate requests', async () => {\n-      const { segmentPaths } = await next.readJSON(\n-        'standalone/.next/server/app/isr/first.meta'\n-      )\n-      const outputIdx = cliOutput.length\n+  it('should de-dupe client segment tree revalidate requests', async () => {\n+    const { segmentPaths } = await next.readJSON(\n+      'standalone/.next/server/app/isr/first.meta'\n+    )\n+    const outputIdx = cliOutput.length\n \n-      for (const segmentPath of segmentPaths) {\n-        const outputSegmentPath =\n-          join('/isr/[slug].segments', segmentPath) + '.segment.rsc'\n+    for (const segmentPath of segmentPaths) {\n+      const outputSegmentPath =\n+        join('/isr/[slug].segments', segmentPath) + '.segment.rsc'\n \n-        require('console').error('requesting', outputSegmentPath)\n+      require('console').error('requesting', outputSegmentPath)\n \n-        const res = await fetchViaHTTP(appPort, outputSegmentPath, undefined, {\n-          headers: {\n-            'x-matched-path': '/isr/[slug].segments/_tree.segment.rsc',\n-            'x-now-route-matches': 'slug=first&1=first',\n-          },\n-        })\n+      const res = await fetchViaHTTP(appPort, outputSegmentPath, undefined, {\n+        headers: {\n+          'x-matched-path': '/isr/[slug].segments/_tree.segment.rsc',\n+          'x-now-route-matches': createNowRouteMatches({\n+            slug: 'first',\n+          }).toString(),\n+        },\n+      })\n \n-        expect(res.status).toBe(200)\n-        expect(res.headers.get('content-type')).toBe('text/x-component')\n-      }\n+      expect(res.status).toBe(200)\n+      expect(res.headers.get('content-type')).toBe('text/x-component')\n+    }\n \n-      expect(\n-        cliOutput.substring(outputIdx).match(/rendering \\/isr\\/\\[slug\\]/g)\n-          .length\n-      ).toBe(1)\n-    })\n-  }\n+    expect(\n+      cliOutput.substring(outputIdx).match(/rendering \\/isr\\/\\[slug\\]/g).length\n+    ).toBe(1)\n+  })\n \n   it('should properly stream resume with Next-Resume', async () => {\n     const res = await fetchViaHTTP(appPort, '/delayed', undefined, {\n@@ -181,11 +170,6 @@ describe('required server files app router', () => {\n     const firstSuspense = chunks.find((item) => item.chunk.includes('time'))\n     const secondSuspense = chunks.find((item) => item.chunk.includes('random'))\n \n-    console.log({\n-      firstSuspense,\n-      secondSuspense,\n-    })\n-\n     expect(secondSuspense.time - firstSuspense.time).toBeGreaterThanOrEqual(\n       2 * 1000\n     )\n@@ -363,12 +347,15 @@ describe('required server files app router', () => {\n     const res = await fetchViaHTTP(appPort, '/dyn/first.rsc', undefined, {\n       headers: {\n         'x-matched-path': '/dyn/[slug]',\n+        'x-now-route-matches': createNowRouteMatches({\n+          slug: 'first',\n+        }).toString(),\n       },\n     })\n \n     expect(res.status).toBe(200)\n     expect(res.headers.get('content-type')).toEqual('text/x-component')\n-    expect(res.headers.has('x-nextjs-postponed')).toBeFalse()\n+    expect(res.headers.has('x-nextjs-postponed')).toBeTrue()\n   })\n \n   it('should handle prefetch RSC requests', async () => {\n@@ -379,6 +366,9 @@ describe('required server files app router', () => {\n       {\n         headers: {\n           'x-matched-path': '/dyn/[slug]',\n+          'x-now-route-matches': createNowRouteMatches({\n+            slug: 'first',\n+          }).toString(),\n         },\n       }\n     )\n@@ -388,6 +378,84 @@ describe('required server files app router', () => {\n     expect(res.headers.has('x-nextjs-postponed')).toBeTrue()\n   })\n \n+  it('should use the postponed state for the RSC requests', async () => {\n+    // Let's parse the random number out of the HTML that was generated at build\n+    // time. We want to use that value as it's the one that's tied to the\n+    // postponed state that we also have.\n+    const $ = cheerio.load(rewriteHTML)\n+\n+    const random = $('#random').text()\n+    expect(random).toBeDefined()\n+    expect(random.length).toBeGreaterThan(0)\n+\n+    // Record the start of the logs for this test.\n+    let start = cliOutput.length\n+\n+    // Then let's do a Dynamic RSC request and verify that the random value is\n+    // not present in the response without passing the postponed state.\n+    let res = await fetchViaHTTP(\n+      appPort,\n+      '/rewrite/first-cookie.rsc',\n+      undefined,\n+      {\n+        headers: {\n+          'x-matched-path': '/rewrite/[slug]',\n+          'x-now-route-matches': createNowRouteMatches({\n+            slug: 'first-cookie',\n+          }).toString(),\n+        },\n+      }\n+    )\n+\n+    expect(res.status).toBe(200)\n+    expect(res.headers.get('content-type')).toEqual('text/x-component')\n+    expect(res.headers.has('x-nextjs-postponed')).toBeTrue()\n+\n+    // Ensure that we hit the cache handler and not the resume data cache.\n+    expect(cliOutput.substring(start)).toContain('cache-handler get')\n+    expect(cliOutput.substring(start)).toContain('cache-handler set')\n+    expect(cliOutput.substring(start)).toContain('rdc:miss')\n+    expect(cliOutput.substring(start)).not.toContain('rdc:hit')\n+\n+    // We expect that the random value is not present in the response because\n+    // we're not providing a resume data cache via the postponed state.\n+    // Instead it'll contain another random number that's been generated at\n+    // runtime.\n+    let rsc = await res.text()\n+    expect(rsc).not.toContain(random)\n+\n+    // Reset the start of the logs for this test.\n+    start = cliOutput.length\n+\n+    // Then let's get the Dynamic RSC request and verify that the random value\n+    // is present in the response by passing the postponed state.\n+    res = await fetchViaHTTP(appPort, '/rewrite/first-cookie.rsc', undefined, {\n+      method: 'POST',\n+      headers: {\n+        'x-matched-path': '/rewrite/[slug]',\n+        'x-now-route-matches': createNowRouteMatches({\n+          slug: 'first-cookie',\n+        }).toString(),\n+        'next-resume': '1',\n+      },\n+      body: rewritePostpone,\n+    })\n+\n+    expect(res.status).toBe(200)\n+    expect(res.headers.get('content-type')).toEqual('text/x-component')\n+    expect(res.headers.has('x-nextjs-postponed')).toBeFalse()\n+\n+    // Ensure that we hit the resume data cache and not the cache handler.\n+    expect(cliOutput.substring(start)).not.toContain('cache-handler get')\n+    expect(cliOutput.substring(start)).not.toContain('cache-handler set')\n+    expect(cliOutput.substring(start)).toContain('rdc:hit')\n+\n+    // We expect that the random value is present in the response because\n+    // we're providing a resume data cache via the postponed state.\n+    rsc = await res.text()\n+    expect(rsc).toContain(random)\n+  })\n+\n   it('should handle revalidating the fallback page', async () => {\n     const res = await fetchViaHTTP(appPort, '/postpone/isr/[slug]', undefined, {\n       headers: {"
        }
    ],
    "stats": {
        "total": 718,
        "additions": 512,
        "deletions": 206
    }
}