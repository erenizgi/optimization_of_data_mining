{
    "author": "sokra",
    "message": "Turbopack: test if unused self arguments are filtered (#86353)\n\n### What?\n\nadd test case for self argument filtering",
    "sha": "2d01e08e471684ad943a8058c2aec4fb080a3c57",
    "files": [
        {
            "sha": "3f327d0015596efad007daa4f50891e14ef66c64",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/filter_unused_args.rs",
            "status": "modified",
            "additions": 158,
            "deletions": 8,
            "changes": 166,
            "blob_url": "https://github.com/vercel/next.js/blob/2d01e08e471684ad943a8058c2aec4fb080a3c57/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ffilter_unused_args.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2d01e08e471684ad943a8058c2aec4fb080a3c57/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ffilter_unused_args.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ffilter_unused_args.rs?ref=2d01e08e471684ad943a8058c2aec4fb080a3c57",
            "patch": "@@ -9,9 +9,9 @@ use turbo_tasks_testing::{Registration, register, run_once};\n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n-async fn filtered_trait_method_args() -> Result<()> {\n+async fn filtered_impl_method_args() -> Result<()> {\n     run_once(&REGISTRATION, || async {\n-        let uses_arg = UsesArg.cell();\n+        let uses_arg = UsesArg(0).cell();\n         assert_eq!(\n             uses_arg.method_with_arg(0).to_resolved().await?,\n             uses_arg.method_with_arg(0).to_resolved().await?,\n@@ -21,7 +21,7 @@ async fn filtered_trait_method_args() -> Result<()> {\n             uses_arg.method_with_arg(1).to_resolved().await?,\n         );\n \n-        let ignores_arg = IgnoresArg.cell();\n+        let ignores_arg = IgnoresArg(0).cell();\n         assert_eq!(\n             ignores_arg.method_with_arg(0).to_resolved().await?,\n             ignores_arg.method_with_arg(0).to_resolved().await?,\n@@ -30,6 +30,128 @@ async fn filtered_trait_method_args() -> Result<()> {\n             ignores_arg.method_with_arg(0).to_resolved().await?,\n             ignores_arg.method_with_arg(1).to_resolved().await?,\n         );\n+\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+async fn filtered_trait_method_args() -> Result<()> {\n+    run_once(&REGISTRATION, || async {\n+        let uses_arg = UsesArg(0).cell();\n+        assert_eq!(\n+            uses_arg.trait_method_with_arg(0).to_resolved().await?,\n+            uses_arg.trait_method_with_arg(0).to_resolved().await?,\n+        );\n+        assert_ne!(\n+            uses_arg.trait_method_with_arg(0).to_resolved().await?,\n+            uses_arg.trait_method_with_arg(1).to_resolved().await?,\n+        );\n+\n+        let ignores_arg = IgnoresArg(0).cell();\n+        assert_eq!(\n+            ignores_arg.trait_method_with_arg(0).to_resolved().await?,\n+            ignores_arg.trait_method_with_arg(0).to_resolved().await?,\n+        );\n+        assert_eq!(\n+            ignores_arg.trait_method_with_arg(0).to_resolved().await?,\n+            ignores_arg.trait_method_with_arg(1).to_resolved().await?,\n+        );\n+\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+async fn filtered_impl_method_self() -> Result<()> {\n+    run_once(&REGISTRATION, || async {\n+        let uses_arg = UsesArg(0).cell();\n+        let uses_arg2 = UsesArg(1).cell();\n+        assert_eq!(\n+            uses_arg.method_with_arg(0).to_resolved().await?,\n+            uses_arg2.method_with_arg(0).to_resolved().await?,\n+        );\n+        assert_eq!(\n+            uses_arg.method_with_arg(1).to_resolved().await?,\n+            uses_arg2.method_with_arg(1).to_resolved().await?,\n+        );\n+\n+        let ignores_arg = IgnoresArg(0).cell();\n+        let ignores_arg2 = IgnoresArg(1).cell();\n+        assert_eq!(\n+            ignores_arg.method_with_arg(0).to_resolved().await?,\n+            ignores_arg2.method_with_arg(0).to_resolved().await?,\n+        );\n+        assert_eq!(\n+            ignores_arg.method_with_arg(1).to_resolved().await?,\n+            ignores_arg2.method_with_arg(1).to_resolved().await?,\n+        );\n+        assert_eq!(\n+            ignores_arg.method_with_arg(0).to_resolved().await?,\n+            ignores_arg2.method_with_arg(1).to_resolved().await?,\n+        );\n+\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+async fn filtered_trait_method_self() -> Result<()> {\n+    run_once(&REGISTRATION, || async {\n+        let uses_arg = UsesArg(0).cell();\n+        let uses_arg2 = UsesArg(1).cell();\n+        assert_eq!(\n+            uses_arg.trait_method_with_arg(0).to_resolved().await?,\n+            uses_arg2.trait_method_with_arg(0).to_resolved().await?,\n+        );\n+        assert_eq!(\n+            uses_arg.trait_method_with_arg(1).to_resolved().await?,\n+            uses_arg2.trait_method_with_arg(1).to_resolved().await?,\n+        );\n+\n+        let ignores_arg = IgnoresArg(0).cell();\n+        let ignores_arg2 = IgnoresArg(1).cell();\n+        assert_eq!(\n+            ignores_arg.trait_method_with_arg(0).to_resolved().await?,\n+            ignores_arg2.trait_method_with_arg(0).to_resolved().await?,\n+        );\n+        assert_eq!(\n+            ignores_arg.trait_method_with_arg(1).to_resolved().await?,\n+            ignores_arg2.trait_method_with_arg(1).to_resolved().await?,\n+        );\n+        assert_eq!(\n+            ignores_arg.trait_method_with_arg(0).to_resolved().await?,\n+            ignores_arg2.trait_method_with_arg(1).to_resolved().await?,\n+        );\n+\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n+async fn filtered_plain_method_args() -> Result<()> {\n+    run_once(&REGISTRATION, || async {\n+        assert_eq!(\n+            method_with_arg(0).to_resolved().await?,\n+            method_with_arg(0).to_resolved().await?,\n+        );\n+        assert_ne!(\n+            method_with_arg(0).to_resolved().await?,\n+            method_with_arg(1).to_resolved().await?,\n+        );\n+        assert_eq!(\n+            method_with_ignored_arg(0).to_resolved().await?,\n+            method_with_ignored_arg(0).to_resolved().await?,\n+        );\n+        assert_eq!(\n+            method_with_ignored_arg(0).to_resolved().await?,\n+            method_with_ignored_arg(1).to_resolved().await?,\n+        );\n+\n         Ok(())\n     })\n     .await\n@@ -38,28 +160,56 @@ async fn filtered_trait_method_args() -> Result<()> {\n #[turbo_tasks::value_trait]\n trait ExampleTrait {\n     #[turbo_tasks::function]\n-    fn method_with_arg(&self, number: i32) -> Vc<()>;\n+    fn trait_method_with_arg(&self, number: i32) -> Vc<()>;\n }\n \n #[turbo_tasks::value]\n-struct UsesArg;\n+struct UsesArg(i32);\n \n #[turbo_tasks::value_impl]\n-impl ExampleTrait for UsesArg {\n+impl UsesArg {\n     #[turbo_tasks::function]\n     fn method_with_arg(&self, number: i32) -> Vc<()> {\n         let _ = number;\n         Vc::cell(())\n     }\n }\n \n+#[turbo_tasks::value_impl]\n+impl ExampleTrait for UsesArg {\n+    #[turbo_tasks::function]\n+    fn trait_method_with_arg(&self, number: i32) -> Vc<()> {\n+        let _ = number;\n+        Vc::cell(())\n+    }\n+}\n+\n #[turbo_tasks::value]\n-struct IgnoresArg;\n+struct IgnoresArg(i32);\n \n #[turbo_tasks::value_impl]\n-impl ExampleTrait for IgnoresArg {\n+impl IgnoresArg {\n     #[turbo_tasks::function]\n     fn method_with_arg(&self, _number: i32) -> Vc<()> {\n         Vc::cell(())\n     }\n }\n+\n+#[turbo_tasks::value_impl]\n+impl ExampleTrait for IgnoresArg {\n+    #[turbo_tasks::function]\n+    fn trait_method_with_arg(&self, _number: i32) -> Vc<()> {\n+        Vc::cell(())\n+    }\n+}\n+\n+#[turbo_tasks::function]\n+fn method_with_arg(number: i32) -> Vc<()> {\n+    let _ = number;\n+    Vc::cell(())\n+}\n+\n+#[turbo_tasks::function]\n+fn method_with_ignored_arg(_number: i32) -> Vc<()> {\n+    Vc::cell(())\n+}"
        }
    ],
    "stats": {
        "total": 166,
        "additions": 158,
        "deletions": 8
    }
}