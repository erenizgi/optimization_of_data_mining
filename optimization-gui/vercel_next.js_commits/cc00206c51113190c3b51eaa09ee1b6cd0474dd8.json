{
    "author": "Cy-Tek",
    "message": "fix(Turbopack): Enable scope hoisting for large files or module counts (#83399)\n\n# Improve BytePos encoding for large source maps\n\nThis PR enhances the BytePos encoding mechanism in scope-hoisted modules\nto handle larger source maps. The previous implementation had\nlimitations when dealing with large byte positions, which could cause\nerrors during source map generation.\n\n## Changes:\n\n- Added a lookup table to store byte positions and module indexes that\nare too large for the standard encoding\n- Implemented a continuation flag (using the highest bit) to indicate\nwhen a position is stored in the lookup table\n- Added a sign extension flag to properly handle padded values\n- Updated all relevant code paths to use the new encoding/decoding\nmechanism\n- Adjusted the header width calculation to accommodate the new flags\n- Made the encoding/decoding functions thread-safe with Arc<Mutex<>>\n\nThis approach allows us to handle arbitrarily large byte positions while\nmaintaining backward compatibility with the existing encoding scheme for\nsmaller values to ensure performance stays as optimal as possible.\n\nFixes PACK-5244\nFixes #82584",
    "sha": "cc00206c51113190c3b51eaa09ee1b6cd0474dd8",
    "files": [
        {
            "sha": "cd20de922ee891b924944235d2bb5682e3232af1",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 384,
            "deletions": 115,
            "changes": 499,
            "blob_url": "https://github.com/vercel/next.js/blob/cc00206c51113190c3b51eaa09ee1b6cd0474dd8/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cc00206c51113190c3b51eaa09ee1b6cd0474dd8/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=cc00206c51113190c3b51eaa09ee1b6cd0474dd8",
            "patch": "@@ -39,7 +39,7 @@ use std::{\n     collections::hash_map::Entry,\n     fmt::{Debug, Display, Formatter},\n     mem::take,\n-    sync::Arc,\n+    sync::{Arc, Mutex},\n };\n \n use anyhow::{Context, Result, anyhow, bail};\n@@ -1101,7 +1101,7 @@ impl EcmascriptModuleContent {\n                 .try_join()\n                 .await?;\n \n-            let (merged_ast, comments, source_maps, original_source_maps) =\n+            let (merged_ast, comments, source_maps, original_source_maps, lookup_table) =\n                 merge_modules(contents, &entry_points, &globals_merged).await?;\n \n             // Use the options from an arbitrary module, since they should all be the same with\n@@ -1113,10 +1113,12 @@ impl EcmascriptModuleContent {\n                 program: merged_ast,\n                 source_map: CodeGenResultSourceMap::ScopeHoisting {\n                     modules_header_width,\n+                    lookup_table: lookup_table.clone(),\n                     source_maps,\n                 },\n                 comments: CodeGenResultComments::ScopeHoisting {\n                     modules_header_width,\n+                    lookup_table,\n                     comments,\n                 },\n                 is_esm: true,\n@@ -1177,11 +1179,13 @@ async fn merge_modules(\n     Vec<CodeGenResultComments>,\n     Vec<CodeGenResultSourceMap>,\n     SmallVec<[ResolvedVc<Box<dyn GenerateSourceMap>>; 1]>,\n+    Arc<Mutex<Vec<ModulePosition>>>,\n )> {\n     struct SetSyntaxContextVisitor<'a> {\n         modules_header_width: u32,\n         current_module: ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>,\n         current_module_idx: u32,\n+        lookup_table: &'a mut Vec<ModulePosition>,\n         /// The export syntax contexts in the current AST, which will be mapped to merged_ctxts\n         reverse_module_contexts:\n             FxHashMap<SyntaxContext, ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>>,\n@@ -1272,19 +1276,21 @@ async fn merge_modules(\n         fn visit_mut_span(&mut self, span: &mut Span) {\n             // Encode the module index into the span, to be able to retrieve the module later for\n             // finding the correct Comments and SourceMap.\n-            span.lo = CodeGenResultComments::encode_bytepos(\n+            span.lo = CodeGenResultComments::encode_bytepos_with_vec(\n                 self.modules_header_width,\n                 self.current_module_idx,\n                 span.lo,\n+                self.lookup_table,\n             )\n             .unwrap_or_else(|err| {\n                 self.error = Err(err);\n                 span.lo\n             });\n-            span.hi = CodeGenResultComments::encode_bytepos(\n+            span.hi = CodeGenResultComments::encode_bytepos_with_vec(\n                 self.modules_header_width,\n                 self.current_module_idx,\n                 span.hi,\n+                self.lookup_table,\n             )\n             .unwrap_or_else(|err| {\n                 self.error = Err(err);\n@@ -1314,6 +1320,7 @@ async fn merge_modules(\n         })\n         .collect::<Result<FxHashMap<_, _>>>()?;\n \n+    let mut lookup_table = Vec::new();\n     let result = GLOBALS.set(globals_merged, || {\n         let _ = tracing::trace_span!(\"merge inner\").entered();\n         // As an optimization, assume an average number of 5 contexts per module.\n@@ -1324,7 +1331,8 @@ async fn merge_modules(\n             |module_count: usize,\n              current_module_idx: usize,\n              (module, content): &(ResolvedVc<Box<dyn EcmascriptChunkPlaceable>>, CodeGenResult),\n-             program: &mut Program| {\n+             program: &mut Program,\n+             lookup_table: &mut Vec<ModulePosition>| {\n                 let _ = tracing::trace_span!(\"prepare module\").entered();\n                 if let CodeGenResult {\n                     scope_hoisting_syntax_contexts: Some((module_contexts, _)),\n@@ -1337,6 +1345,7 @@ async fn merge_modules(\n                             modules_header_width,\n                             current_module: *module,\n                             current_module_idx: current_module_idx as u32,\n+                            lookup_table,\n                             reverse_module_contexts: module_contexts\n                                 .iter()\n                                 .map(|e| (*e.value(), *e.key()))\n@@ -1374,8 +1383,14 @@ async fn merge_modules(\n         let mut queue = entry_points\n             .iter()\n             .map(|&(_, i)| {\n-                prepare_module(contents.len(), i, &contents[i], &mut programs[i])\n-                    .map_err(|err| (i, err))\n+                prepare_module(\n+                    contents.len(),\n+                    i,\n+                    &contents[i],\n+                    &mut programs[i],\n+                    &mut lookup_table,\n+                )\n+                .map_err(|err| (i, err))\n             })\n             .flatten_ok()\n             .rev()\n@@ -1403,6 +1418,7 @@ async fn merge_modules(\n                                         index,\n                                         &contents[index],\n                                         &mut programs[index],\n+                                        &mut lookup_table,\n                                     )\n                                     .map_err(|err| (index, err))?\n                                     .into_iter()\n@@ -1506,7 +1522,13 @@ async fn merge_modules(\n         })\n         .collect();\n \n-    Ok((merged_ast, comments, source_maps, original_source_maps))\n+    Ok((\n+        merged_ast,\n+        comments,\n+        source_maps,\n+        original_source_maps,\n+        Arc::new(Mutex::new(lookup_table)),\n+    ))\n }\n \n /// Provides information about the other modules in the current scope hoisting group.\n@@ -2170,6 +2192,7 @@ enum CodeGenResultSourceMap {\n         /// The bitwidth of the modules header in the spans, see\n         /// [CodeGenResultComments::encode_bytepos]\n         modules_header_width: u32,\n+        lookup_table: Arc<Mutex<Vec<ModulePosition>>>,\n         source_maps: Vec<CodeGenResultSourceMap>,\n     },\n }\n@@ -2198,6 +2221,7 @@ impl Debug for CodeGenResultSourceMap {\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n                 source_maps,\n+                ..\n             } => write!(\n                 f,\n                 \"CodeGenResultSourceMap::ScopeHoisting {{ modules_header_width: \\\n@@ -2217,10 +2241,11 @@ impl Files for CodeGenResultSourceMap {\n             CodeGenResultSourceMap::Single { source_map } => source_map.try_lookup_source_file(pos),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 source_maps,\n             } => {\n                 let (module, pos) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos);\n+                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos, lookup_table);\n                 source_maps[module].try_lookup_source_file(pos)\n             }\n         }\n@@ -2247,8 +2272,9 @@ impl Files for CodeGenResultSourceMap {\n             CodeGenResultSourceMap::Single { .. } => pos,\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 ..\n-            } => CodeGenResultComments::decode_bytepos(*modules_header_width, pos).1,\n+            } => CodeGenResultComments::decode_bytepos(*modules_header_width, pos, lookup_table).1,\n         }\n     }\n }\n@@ -2262,10 +2288,11 @@ impl SourceMapper for CodeGenResultSourceMap {\n             CodeGenResultSourceMap::Single { source_map } => source_map.lookup_char_pos(pos),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 source_maps,\n             } => {\n                 let (module, pos) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos);\n+                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos, lookup_table);\n                 source_maps[module].lookup_char_pos(pos)\n             }\n         }\n@@ -2278,13 +2305,22 @@ impl SourceMapper for CodeGenResultSourceMap {\n             CodeGenResultSourceMap::Single { source_map } => source_map.span_to_lines(sp),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 source_maps,\n             } => {\n-                let (module, lo) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, sp.lo);\n+                let (module, lo) = CodeGenResultComments::decode_bytepos(\n+                    *modules_header_width,\n+                    sp.lo,\n+                    lookup_table,\n+                );\n                 source_maps[module].span_to_lines(Span {\n                     lo,\n-                    hi: CodeGenResultComments::decode_bytepos(*modules_header_width, sp.hi).1,\n+                    hi: CodeGenResultComments::decode_bytepos(\n+                        *modules_header_width,\n+                        sp.hi,\n+                        lookup_table,\n+                    )\n+                    .1,\n                 })\n             }\n         }\n@@ -2297,13 +2333,22 @@ impl SourceMapper for CodeGenResultSourceMap {\n             CodeGenResultSourceMap::Single { source_map } => source_map.span_to_string(sp),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 source_maps,\n             } => {\n-                let (module, lo) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, sp.lo);\n+                let (module, lo) = CodeGenResultComments::decode_bytepos(\n+                    *modules_header_width,\n+                    sp.lo,\n+                    lookup_table,\n+                );\n                 source_maps[module].span_to_string(Span {\n                     lo,\n-                    hi: CodeGenResultComments::decode_bytepos(*modules_header_width, sp.hi).1,\n+                    hi: CodeGenResultComments::decode_bytepos(\n+                        *modules_header_width,\n+                        sp.hi,\n+                        lookup_table,\n+                    )\n+                    .1,\n                 })\n             }\n         }\n@@ -2316,13 +2361,22 @@ impl SourceMapper for CodeGenResultSourceMap {\n             CodeGenResultSourceMap::Single { source_map } => source_map.span_to_filename(sp),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 source_maps,\n             } => {\n-                let (module, lo) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, sp.lo);\n+                let (module, lo) = CodeGenResultComments::decode_bytepos(\n+                    *modules_header_width,\n+                    sp.lo,\n+                    lookup_table,\n+                );\n                 source_maps[module].span_to_filename(Span {\n                     lo,\n-                    hi: CodeGenResultComments::decode_bytepos(*modules_header_width, sp.hi).1,\n+                    hi: CodeGenResultComments::decode_bytepos(\n+                        *modules_header_width,\n+                        sp.hi,\n+                        lookup_table,\n+                    )\n+                    .1,\n                 })\n             }\n         }\n@@ -2335,25 +2389,40 @@ impl SourceMapper for CodeGenResultSourceMap {\n             CodeGenResultSourceMap::Single { source_map } => source_map.merge_spans(sp_lhs, sp_rhs),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 source_maps,\n             } => {\n-                let (module_lhs, lo_lhs) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, sp_lhs.lo);\n-                let (module_rhs, lo_rhs) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, sp_rhs.lo);\n+                let (module_lhs, lo_lhs) = CodeGenResultComments::decode_bytepos(\n+                    *modules_header_width,\n+                    sp_lhs.lo,\n+                    lookup_table,\n+                );\n+                let (module_rhs, lo_rhs) = CodeGenResultComments::decode_bytepos(\n+                    *modules_header_width,\n+                    sp_rhs.lo,\n+                    lookup_table,\n+                );\n                 if module_lhs != module_rhs {\n                     return None;\n                 }\n                 source_maps[module_lhs].merge_spans(\n                     Span {\n                         lo: lo_lhs,\n-                        hi: CodeGenResultComments::decode_bytepos(*modules_header_width, sp_lhs.hi)\n-                            .1,\n+                        hi: CodeGenResultComments::decode_bytepos(\n+                            *modules_header_width,\n+                            sp_lhs.hi,\n+                            lookup_table,\n+                        )\n+                        .1,\n                     },\n                     Span {\n                         lo: lo_rhs,\n-                        hi: CodeGenResultComments::decode_bytepos(*modules_header_width, sp_rhs.hi)\n-                            .1,\n+                        hi: CodeGenResultComments::decode_bytepos(\n+                            *modules_header_width,\n+                            sp_rhs.hi,\n+                            lookup_table,\n+                        )\n+                        .1,\n                     },\n                 )\n             }\n@@ -2367,13 +2436,22 @@ impl SourceMapper for CodeGenResultSourceMap {\n             CodeGenResultSourceMap::Single { source_map } => source_map.call_span_if_macro(sp),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 source_maps,\n             } => {\n-                let (module, lo) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, sp.lo);\n+                let (module, lo) = CodeGenResultComments::decode_bytepos(\n+                    *modules_header_width,\n+                    sp.lo,\n+                    lookup_table,\n+                );\n                 source_maps[module].call_span_if_macro(Span {\n                     lo,\n-                    hi: CodeGenResultComments::decode_bytepos(*modules_header_width, sp.hi).1,\n+                    hi: CodeGenResultComments::decode_bytepos(\n+                        *modules_header_width,\n+                        sp.hi,\n+                        lookup_table,\n+                    )\n+                    .1,\n                 })\n             }\n         }\n@@ -2389,13 +2467,22 @@ impl SourceMapper for CodeGenResultSourceMap {\n             CodeGenResultSourceMap::Single { source_map } => source_map.span_to_snippet(sp),\n             CodeGenResultSourceMap::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 source_maps,\n             } => {\n-                let (module, lo) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, sp.lo);\n+                let (module, lo) = CodeGenResultComments::decode_bytepos(\n+                    *modules_header_width,\n+                    sp.lo,\n+                    lookup_table,\n+                );\n                 source_maps[module].span_to_snippet(Span {\n                     lo,\n-                    hi: CodeGenResultComments::decode_bytepos(*modules_header_width, sp.hi).1,\n+                    hi: CodeGenResultComments::decode_bytepos(\n+                        *modules_header_width,\n+                        sp.hi,\n+                        lookup_table,\n+                    )\n+                    .1,\n                 })\n             }\n         }\n@@ -2424,6 +2511,9 @@ impl CodeGenResultOriginalSourceMap {\n     }\n }\n \n+/// Stores a module index in position 0 and the full byte position of the source map in position 1\n+struct ModulePosition(u32, u32);\n+\n enum CodeGenResultComments {\n     Single {\n         comments: Either<ImmutableComments, Arc<ImmutableComments>>,\n@@ -2433,12 +2523,93 @@ enum CodeGenResultComments {\n         /// The bitwidth of the modules header in the spans, see\n         /// [CodeGenResultComments::encode_bytepos]\n         modules_header_width: u32,\n+        lookup_table: Arc<Mutex<Vec<ModulePosition>>>,\n         comments: Vec<CodeGenResultComments>,\n     },\n     Empty,\n }\n \n+unsafe impl Send for CodeGenResultComments {}\n+unsafe impl Sync for CodeGenResultComments {}\n+\n impl CodeGenResultComments {\n+    const CONTINUATION_BIT: u32 = 1 << 31;\n+    const SIGN_EXTENSION_BIT: u32 = 1 << 30;\n+\n+    #[inline]\n+    fn encode_bytepos_impl(\n+        modules_header_width: u32,\n+        module: u32,\n+        pos: BytePos,\n+        push_into_lookup: &mut impl FnMut(u32, u32) -> Result<u32>,\n+    ) -> Result<BytePos> {\n+        if pos.is_dummy() {\n+            // nothing to encode\n+            return Ok(pos);\n+        }\n+\n+        // Bit layout for encoded BytePos (32 bits):\n+        // [31] Continuation bit. If set (1), the remaining 31 bits [0..30] encode an index into\n+        //      the lookup vector where (module, original_bytepos) is stored.\n+        //      In this case, decoding ignores other fields and fetches from the table.\n+        // If not set (0):\n+        // [30] Sign-extend bit. Indicates whether the stolen high bits of the original bytepos\n+        //      were all 1s (1) or all 0s (0), so that decoding can restore the original high bits.\n+        // [30 - modules_header_width + 1 .. 30) Module id: modules_header_width bits immediately\n+        //      below the sign-extend bit.\n+        // [0 .. (32 - (2 + modules_header_width)) ) Remaining low bits store the truncated bytepos.\n+        //\n+        // Notes:\n+        // - We reserve 2 header bits always (continuation + sign-extend), so header_width =\n+        //   modules_header_width + 2, and pos_width = 32 - header_width.\n+        // - When the original value does not fit in the available pos_width with a uniform high bit\n+        //   pattern, we spill (set continuation) and store (module, pos) in the lookup table and\n+        //   encode the index with the continuation bit set.\n+        //\n+        // Example (diagrammatic only):\n+        // modules_header_width = 4\n+        // Key:\n+        // (c = continuation, s = sign-extend, m = module, p = pos bits, i = lookup table index)\n+        //\n+        // The continuation bit is set, and the remaining 31 bits are reinterpreted as the index\n+        // into the lookup table.\n+        // Bytes: 1iii iiii iiii iiii iiii iiii iiii iiii\n+        //\n+        // The continuation bit is not set,\n+        // Bytes: 0smm mmpp pppp pppp pppp pppp pppp pppp\n+\n+        let header_width = modules_header_width + 2;\n+        let pos_width = 32 - header_width;\n+\n+        let pos = pos.0;\n+\n+        let old_high_bits = pos >> pos_width;\n+        let high_bits_set = if (2u32.pow(header_width) - 1) == old_high_bits {\n+            true\n+        } else if old_high_bits == 0 {\n+            false\n+        } else {\n+            // The integer is too large for our desired header width and we need to store the result\n+            // in our vector and set the flag to reinterpret this data as the index of\n+            // the vector where the element is being stored.\n+            let ix = push_into_lookup(module, pos)?;\n+            // Make sure that the index fits within the allotted bits\n+            assert_eq!(ix & CodeGenResultComments::CONTINUATION_BIT, 0);\n+\n+            return Ok(BytePos(ix | CodeGenResultComments::CONTINUATION_BIT));\n+        };\n+\n+        let pos = pos & !((2u32.pow(header_width) - 1) << pos_width);\n+        let encoded_high_bits = if high_bits_set {\n+            CodeGenResultComments::SIGN_EXTENSION_BIT\n+        } else {\n+            0\n+        };\n+        let encoded_module = module << pos_width;\n+\n+        Ok(BytePos(encoded_module | encoded_high_bits | pos))\n+    }\n+\n     fn take(&mut self) -> Self {\n         std::mem::replace(self, CodeGenResultComments::Empty)\n     }\n@@ -2457,70 +2628,81 @@ impl CodeGenResultComments {\n             },\n             CodeGenResultComments::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 comments,\n             } => CodeGenResultCommentsConsumable::ScopeHoisting {\n                 modules_header_width: *modules_header_width,\n+                lookup_table: lookup_table.clone(),\n                 comments: comments.iter().map(|c| c.consumable()).collect(),\n             },\n             CodeGenResultComments::Empty => CodeGenResultCommentsConsumable::Empty,\n         }\n     }\n \n-    fn encode_bytepos(modules_header_width: u32, module: u32, pos: BytePos) -> Result<BytePos> {\n-        if pos.is_dummy() {\n-            // nothing to encode\n-            return Ok(pos);\n-        }\n-\n-        // 00010000000000100100011010100101\n-        // ^^^^ module id\n-        //     ^ whether the bits stolen for the module were once 1 (i.e. \"sign extend\" again later)\n-        //      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ the original bytepos\n-        //\n-        // # Example:\n-        // pos=11111111111111110000000000000101 with module=0001\n-        // would become\n-        // pos=00011111111111110000000000000101\n-        // # Example:\n-        // pos=00000111111111110000000000000101 with module=0001\n-        // would become\n-        // pos=00010111111111110000000000000101\n-\n-        let header_width = modules_header_width + 1;\n-        let pos_width = 32 - header_width;\n-\n-        let pos = pos.0;\n-\n-        let old_high_bits = pos >> pos_width;\n-        let high_bits_set = if (2u32.pow(header_width) - 1) == old_high_bits {\n-            true\n-        } else if old_high_bits == 0 {\n-            false\n-        } else {\n-            return Err(anyhow!(\n-                \"The high bits of the position {pos} are not all 0s or 1s. \\\n-                 modules_header_width={modules_header_width}, module={module}\",\n-            ));\n+    fn encode_bytepos(\n+        modules_header_width: u32,\n+        module: u32,\n+        pos: BytePos,\n+        lookup_table: Arc<Mutex<Vec<ModulePosition>>>,\n+    ) -> Result<BytePos> {\n+        let mut push = |module: u32, pos_u32: u32| -> Result<u32> {\n+            let mut lookup_table = lookup_table\n+                .lock()\n+                .map_err(|_| anyhow!(\"Failed to grab lock on the index map for byte positions\"))?;\n+            let ix = lookup_table.len() as u32;\n+            if ix >= 1 << 30 {\n+                return Err(anyhow!(\"Too many byte positions being stored\"));\n+            }\n+            lookup_table.push(ModulePosition(module, pos_u32));\n+            Ok(ix)\n         };\n+        Self::encode_bytepos_impl(modules_header_width, module, pos, &mut push)\n+    }\n \n-        let pos = pos & !((2u32.pow(header_width) - 1) << pos_width);\n-        let encoded_high_bits = if high_bits_set { 1 } else { 0 } << pos_width;\n-        let encoded_module = module << (pos_width + 1);\n-\n-        Ok(BytePos(encoded_module | encoded_high_bits | pos))\n+    fn encode_bytepos_with_vec(\n+        modules_header_width: u32,\n+        module: u32,\n+        pos: BytePos,\n+        lookup_table: &mut Vec<ModulePosition>,\n+    ) -> Result<BytePos> {\n+        let mut push = |module: u32, pos_u32: u32| -> Result<u32> {\n+            let ix = lookup_table.len() as u32;\n+            if ix >= 1 << 30 {\n+                return Err(anyhow!(\"Too many byte positions being stored\"));\n+            }\n+            lookup_table.push(ModulePosition(module, pos_u32));\n+            Ok(ix)\n+        };\n+        Self::encode_bytepos_impl(modules_header_width, module, pos, &mut push)\n     }\n \n-    fn decode_bytepos(modules_header_width: u32, pos: BytePos) -> (usize, BytePos) {\n+    fn decode_bytepos(\n+        modules_header_width: u32,\n+        pos: BytePos,\n+        lookup_table: &Mutex<Vec<ModulePosition>>,\n+    ) -> (usize, BytePos) {\n         if pos.is_dummy() {\n             // nothing to decode\n             panic!(\"Cannot decode dummy BytePos\");\n         }\n \n-        let header_width = modules_header_width + 1;\n+        let header_width = modules_header_width + 2;\n         let pos_width = 32 - header_width;\n \n-        let high_bits_set = ((pos.0 >> (pos_width)) & 1) == 1;\n-        let module = pos.0 >> (pos_width + 1);\n+        if (CodeGenResultComments::CONTINUATION_BIT & pos.0)\n+            == CodeGenResultComments::CONTINUATION_BIT\n+        {\n+            let lookup_table = lookup_table\n+                .lock()\n+                .expect(\"Failed to grab lock on the index map for byte position\");\n+            let ix = pos.0 & !CodeGenResultComments::CONTINUATION_BIT;\n+            let ModulePosition(module, pos) = lookup_table[ix as usize];\n+\n+            return (module as usize, BytePos(pos));\n+        }\n+\n+        let high_bits_set = pos.0 >> 30 & 1 == 1;\n+        let module = (pos.0 << 2) >> (pos_width + 2);\n         let pos = pos.0 & !((2u32.pow(header_width) - 1) << pos_width);\n         let pos = if high_bits_set {\n             pos | ((2u32.pow(header_width) - 1) << pos_width)\n@@ -2538,28 +2720,34 @@ enum CodeGenResultCommentsConsumable<'a> {\n     },\n     ScopeHoisting {\n         modules_header_width: u32,\n+        lookup_table: Arc<Mutex<Vec<ModulePosition>>>,\n         comments: Vec<CodeGenResultCommentsConsumable<'a>>,\n     },\n     Empty,\n }\n-\n-unsafe impl Send for CodeGenResultComments {}\n-unsafe impl Sync for CodeGenResultComments {}\n-\n /// All BytePos in Spans in the AST are encoded correctly in [`merge_modules`], but the Comments\n /// also contain spans. These also need to be encoded so that all pos in `mappings` are consistently\n /// encoded.\n fn encode_module_into_comment_span(\n     modules_header_width: u32,\n     module: usize,\n     mut comment: Comment,\n+    lookup_table: Arc<Mutex<Vec<ModulePosition>>>,\n ) -> Comment {\n-    comment.span.lo =\n-        CodeGenResultComments::encode_bytepos(modules_header_width, module as u32, comment.span.lo)\n-            .unwrap();\n-    comment.span.hi =\n-        CodeGenResultComments::encode_bytepos(modules_header_width, module as u32, comment.span.hi)\n-            .unwrap();\n+    comment.span.lo = CodeGenResultComments::encode_bytepos(\n+        modules_header_width,\n+        module as u32,\n+        comment.span.lo,\n+        lookup_table.clone(),\n+    )\n+    .unwrap();\n+    comment.span.hi = CodeGenResultComments::encode_bytepos(\n+        modules_header_width,\n+        module as u32,\n+        comment.span.hi,\n+        lookup_table,\n+    )\n+    .unwrap();\n     comment\n }\n \n@@ -2583,10 +2771,11 @@ impl Comments for CodeGenResultCommentsConsumable<'_> {\n             } => comments.has_leading(pos) || extra_comments.has_leading(pos),\n             Self::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 comments,\n             } => {\n                 let (module, pos) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos);\n+                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos, lookup_table);\n                 comments[module].has_leading(pos)\n             }\n             Self::Empty => false,\n@@ -2608,14 +2797,22 @@ impl Comments for CodeGenResultCommentsConsumable<'_> {\n             } => merge_option_vec(comments.take_leading(pos), extra_comments.take_leading(pos)),\n             Self::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 comments,\n             } => {\n                 let (module, pos) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos);\n+                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos, lookup_table);\n                 comments[module].take_leading(pos).map(|comments| {\n                     comments\n                         .into_iter()\n-                        .map(|c| encode_module_into_comment_span(*modules_header_width, module, c))\n+                        .map(|c| {\n+                            encode_module_into_comment_span(\n+                                *modules_header_width,\n+                                module,\n+                                c,\n+                                lookup_table.clone(),\n+                            )\n+                        })\n                         .collect()\n                 })\n             }\n@@ -2634,14 +2831,22 @@ impl Comments for CodeGenResultCommentsConsumable<'_> {\n             } => merge_option_vec(comments.get_leading(pos), extra_comments.get_leading(pos)),\n             Self::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 comments,\n             } => {\n                 let (module, pos) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos);\n+                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos, lookup_table);\n                 comments[module].get_leading(pos).map(|comments| {\n                     comments\n                         .into_iter()\n-                        .map(|c| encode_module_into_comment_span(*modules_header_width, module, c))\n+                        .map(|c| {\n+                            encode_module_into_comment_span(\n+                                *modules_header_width,\n+                                module,\n+                                c,\n+                                lookup_table.clone(),\n+                            )\n+                        })\n                         .collect()\n                 })\n             }\n@@ -2668,10 +2873,11 @@ impl Comments for CodeGenResultCommentsConsumable<'_> {\n             } => comments.has_trailing(pos) || extra_comments.has_trailing(pos),\n             Self::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 comments,\n             } => {\n                 let (module, pos) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos);\n+                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos, lookup_table);\n                 comments[module].has_trailing(pos)\n             }\n             Self::Empty => false,\n@@ -2696,14 +2902,22 @@ impl Comments for CodeGenResultCommentsConsumable<'_> {\n             ),\n             Self::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 comments,\n             } => {\n                 let (module, pos) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos);\n+                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos, lookup_table);\n                 comments[module].take_trailing(pos).map(|comments| {\n                     comments\n                         .into_iter()\n-                        .map(|c| encode_module_into_comment_span(*modules_header_width, module, c))\n+                        .map(|c| {\n+                            encode_module_into_comment_span(\n+                                *modules_header_width,\n+                                module,\n+                                c,\n+                                lookup_table.clone(),\n+                            )\n+                        })\n                         .collect()\n                 })\n             }\n@@ -2722,14 +2936,22 @@ impl Comments for CodeGenResultCommentsConsumable<'_> {\n             } => merge_option_vec(comments.get_leading(pos), extra_comments.get_leading(pos)),\n             Self::ScopeHoisting {\n                 modules_header_width,\n+                lookup_table,\n                 comments,\n             } => {\n                 let (module, pos) =\n-                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos);\n+                    CodeGenResultComments::decode_bytepos(*modules_header_width, pos, lookup_table);\n                 comments[module].get_leading(pos).map(|comments| {\n                     comments\n                         .into_iter()\n-                        .map(|c| encode_module_into_comment_span(*modules_header_width, module, c))\n+                        .map(|c| {\n+                            encode_module_into_comment_span(\n+                                *modules_header_width,\n+                                module,\n+                                c,\n+                                lookup_table.clone(),\n+                            )\n+                        })\n                         .collect()\n                 })\n             }\n@@ -2756,6 +2978,7 @@ mod tests {\n     use super::*;\n     fn bytepos_ensure_identical(modules_header_width: u32, pos: BytePos) {\n         let module_count = 2u32.pow(modules_header_width);\n+        let lookup_table = Arc::new(Mutex::new(Vec::new()));\n \n         for module in [\n             0,\n@@ -2768,10 +2991,15 @@ mod tests {\n         .into_iter()\n         .filter(|&m| m < module_count)\n         {\n-            let encoded =\n-                CodeGenResultComments::encode_bytepos(modules_header_width, module, pos).unwrap();\n+            let encoded = CodeGenResultComments::encode_bytepos(\n+                modules_header_width,\n+                module,\n+                pos,\n+                lookup_table.clone(),\n+            )\n+            .unwrap();\n             let (decoded_module, decoded_pos) =\n-                CodeGenResultComments::decode_bytepos(modules_header_width, encoded);\n+                CodeGenResultComments::decode_bytepos(modules_header_width, encoded, &lookup_table);\n             assert_eq!(\n                 decoded_module as u32, module,\n                 \"Testing width {modules_header_width} and pos {pos:?}\"\n@@ -2785,38 +3013,82 @@ mod tests {\n \n     #[test]\n     fn test_encode_decode_bytepos_format() {\n+        let table = Arc::new(Mutex::new(Vec::new()));\n+\n         for (pos, module, modules_header_width, result) in [\n             (\n                 0b00000000000000000000000000000101,\n                 0b1,\n                 1,\n-                0b10000000000000000000000000000101,\n+                0b00100000000000000000000000000101,\n             ),\n             (\n                 0b00000000000000000000000000000101,\n                 0b01,\n                 2,\n-                0b01000000000000000000000000000101,\n+                0b00010000000000000000000000000101,\n             ),\n             (\n                 0b11111111111111110000000000000101,\n-                0b0001,\n+                0b0110,\n                 4,\n-                0b00011111111111110000000000000101,\n+                0b01011011111111110000000000000101,\n+            ),\n+            (\n+                BytePos::PLACEHOLDER.0,\n+                0b01111,\n+                5,\n+                0b01011111111111111111111111111101,\n             ),\n+            (\n+                BytePos::PURE.0,\n+                0b01111,\n+                5,\n+                0b01011111111111111111111111111110,\n+            ),\n+            (\n+                BytePos::SYNTHESIZED.0,\n+                0b01111,\n+                5,\n+                0b01011111111111111111111111111111,\n+            ),\n+            // This is an index that should trigger the overflow to store the position into the\n+            // lookup table\n             (\n                 0b00000111111111110000000000000101,\n                 0b0001,\n                 4,\n-                0b00010111111111110000000000000101,\n+                0b10000000000000000000000000000000,\n+            ),\n+            // Another one should increase the index by 1\n+            (\n+                0b00000111111111110000000000111110,\n+                0b0001,\n+                4,\n+                0b10000000000000000000000000000001,\n             ),\n             // Special case, DUMMY stays a DUMMY\n             (BytePos::DUMMY.0, 0b0001, 4, BytePos::DUMMY.0),\n         ] {\n-            let encoded =\n-                CodeGenResultComments::encode_bytepos(modules_header_width, module, BytePos(pos))\n-                    .unwrap();\n+            let encoded = CodeGenResultComments::encode_bytepos(\n+                modules_header_width,\n+                module,\n+                BytePos(pos),\n+                table.clone(),\n+            )\n+            .unwrap();\n             assert_eq!(encoded.0, result);\n+\n+            // Ensure that the correct original module and bytepos are stored when overflow occurs\n+            if encoded.0 & CodeGenResultComments::CONTINUATION_BIT\n+                == CodeGenResultComments::CONTINUATION_BIT\n+            {\n+                let index = encoded.0 & !CodeGenResultComments::CONTINUATION_BIT;\n+                let ModulePosition(encoded_module, encoded_pos) =\n+                    table.lock().unwrap()[index as usize];\n+                assert_eq!(encoded_module, module);\n+                assert_eq!(encoded_pos, pos);\n+            }\n         }\n     }\n \n@@ -2825,25 +3097,22 @@ mod tests {\n         // This is copied from swc (it's not exported), comments the range above this value.\n         const DUMMY_RESERVE: u32 = u32::MAX - 2_u32.pow(16);\n \n-        for modules_header_width in 1..=6 {\n+        for modules_header_width in 1..=10 {\n             for pos in [\n                 // BytePos::DUMMY, // This must never get decoded in the first place\n                 BytePos(1),\n                 BytePos(2),\n                 BytePos(100),\n                 BytePos(4_000_000),\n-                BytePos(60_000_000),\n+                BytePos(600_000_000),\n+                BytePos(u32::MAX - 3), // The maximum allowed value that isn't reserved by SWC\n                 BytePos::PLACEHOLDER,\n                 BytePos::SYNTHESIZED,\n                 BytePos::PURE,\n                 BytePos(DUMMY_RESERVE),\n                 BytePos(DUMMY_RESERVE + 10),\n                 BytePos(DUMMY_RESERVE + 10000),\n             ] {\n-                if modules_header_width == 6 && pos.0 == 60_000_000 {\n-                    // this is unfortunately too large indeed, will trigger the panic.\n-                    continue;\n-                }\n                 bytepos_ensure_identical(modules_header_width, pos);\n             }\n         }"
        }
    ],
    "stats": {
        "total": 499,
        "additions": 384,
        "deletions": 115
    }
}