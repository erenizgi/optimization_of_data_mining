{
    "author": "lukesandberg",
    "message": "[turbopack] Move generation of `cacheLife` types out of the webpack plugin and into the dev bundler directly (#85539)\n\nEnsure that users configuring custom `cacheLife` configs with Typescript get support with turbopack\n\nThis follows the same pattern as typed-routes, so generation can happen during `next type-gen` and also via the dev bundler.\n\nAlso this fixes a subtle bug in the timestamp formatting where we believed months had 30 or 31 _weeks_ instead of 30 or 31 _days_s.\n\nBeyond the unit tests, i also tried out adding a `cacheLife` config to the `with-turbopack` example and observed that the types were generated and vscode was able to autocomplete my custom config type.\n\nFixes NAR-458",
    "sha": "89cd2058a6b2ff711a7237b0ba5003b73b4649c1",
    "files": [
        {
            "sha": "dfc22f11e77455e4a26593733a544a1ae2f3544e",
            "filename": "packages/next/src/build/webpack-config.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack-config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack-config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack-config.ts?ref=89cd2058a6b2ff711a7237b0ba5003b73b4649c1",
            "patch": "@@ -2155,7 +2155,6 @@ export default async function getBaseWebpackConfig(\n           dev,\n           isEdgeServer,\n           pageExtensions: config.pageExtensions,\n-          cacheLifeConfig: config.cacheLife,\n           originalRewrites,\n           originalRedirects,\n         }),"
        },
        {
            "sha": "e2e48e8d0e4088aef94d73284db7be1a4e948137",
            "filename": "packages/next/src/build/webpack/plugins/next-types-plugin/index.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.test.ts?ref=89cd2058a6b2ff711a7237b0ba5003b73b4649c1",
            "patch": "@@ -11,7 +11,6 @@ describe('next-types-plugin', () => {\n       dev: false,\n       isEdgeServer: false,\n       pageExtensions: ['tsx', 'ts', 'jsx', 'js'],\n-      cacheLifeConfig: undefined,\n       originalRewrites: undefined,\n       originalRedirects: undefined,\n     })\n@@ -39,7 +38,6 @@ describe('next-types-plugin', () => {\n       dev: false,\n       isEdgeServer: false,\n       pageExtensions: ['tsx', 'ts', 'jsx', 'js'],\n-      cacheLifeConfig: undefined,\n       originalRewrites: undefined,\n       originalRedirects: undefined,\n     })\n@@ -59,7 +57,7 @@ describe('next-types-plugin', () => {\n       dev: false,\n       isEdgeServer: false,\n       pageExtensions: ['tsx', 'ts', 'jsx', 'js'],\n-      cacheLifeConfig: undefined,\n+\n       originalRewrites: undefined,\n       originalRedirects: undefined,\n     })"
        },
        {
            "sha": "ae33956ba054d51d0750b73c71627b4d31293274",
            "filename": "packages/next/src/build/webpack/plugins/next-types-plugin/index.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 196,
            "changes": 200,
            "blob_url": "https://github.com/vercel/next.js/blob/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Fplugins%2Fnext-types-plugin%2Findex.ts?ref=89cd2058a6b2ff711a7237b0ba5003b73b4649c1",
            "patch": "@@ -1,3 +1,7 @@\n+// DO NOT ADD NEW FEATURES TO THIS PLUGIN\n+// DOING SO PREVENTS THEM FROM WORKING FOR TURBOPACK USERS.\n+// FOLLOW THE PATTERN OF TYPED-ROUTES AND CACHE-LIFE GENERATION\n+\n import type { Rewrite, Redirect } from '../../../../lib/load-custom-routes'\n \n import fs from 'fs/promises'\n@@ -14,7 +18,6 @@ import { normalizeAppPath } from '../../../../shared/lib/router/utils/app-paths'\n import { getPageFromPath } from '../../../entries'\n import type { PageExtensions } from '../../../page-extensions-type'\n import { getProxiedPluginState } from '../../../build-context'\n-import type { CacheLife } from '../../../../server/use-cache/cache-life'\n \n const PLUGIN_NAME = 'NextTypesPlugin'\n \n@@ -31,7 +34,6 @@ interface Options {\n   dev: boolean\n   isEdgeServer: boolean\n   pageExtensions: PageExtensions\n-  cacheLifeConfig: undefined | { [profile: string]: CacheLife }\n   originalRewrites: Rewrites | undefined\n   originalRedirects: Redirect[] | undefined\n }\n@@ -283,63 +285,6 @@ function formatRouteToRouteType(route: string) {\n   }\n }\n \n-function formatTimespan(seconds: number): string {\n-  if (seconds > 0) {\n-    if (seconds === 18748800) {\n-      return '1 month'\n-    }\n-    if (seconds === 18144000) {\n-      return '1 month'\n-    }\n-    if (seconds === 604800) {\n-      return '1 week'\n-    }\n-    if (seconds === 86400) {\n-      return '1 day'\n-    }\n-    if (seconds === 3600) {\n-      return '1 hour'\n-    }\n-    if (seconds === 60) {\n-      return '1 minute'\n-    }\n-    if (seconds % 18748800 === 0) {\n-      return seconds / 18748800 + ' months'\n-    }\n-    if (seconds % 18144000 === 0) {\n-      return seconds / 18144000 + ' months'\n-    }\n-    if (seconds % 604800 === 0) {\n-      return seconds / 604800 + ' weeks'\n-    }\n-    if (seconds % 86400 === 0) {\n-      return seconds / 86400 + ' days'\n-    }\n-    if (seconds % 3600 === 0) {\n-      return seconds / 3600 + ' hours'\n-    }\n-    if (seconds % 60 === 0) {\n-      return seconds / 60 + ' minutes'\n-    }\n-  }\n-  return seconds + ' seconds'\n-}\n-\n-function formatTimespanWithSeconds(seconds: undefined | number): string {\n-  if (seconds === undefined) {\n-    return 'default'\n-  }\n-  if (seconds >= 0xfffffffe) {\n-    return 'never'\n-  }\n-  const text = seconds + ' seconds'\n-  const descriptive = formatTimespan(seconds)\n-  if (descriptive === text) {\n-    return text\n-  }\n-  return text + ' (' + descriptive + ')'\n-}\n-\n function getRootParamsFromLayouts(layouts: Record<string, string[]>) {\n   // Sort layouts by depth (descending)\n   const sortedLayouts = Object.entries(layouts).sort(\n@@ -426,127 +371,6 @@ function createServerDefinitions() {\n   `\n }\n \n-function createCustomCacheLifeDefinitions(cacheLife: {\n-  [profile: string]: CacheLife\n-}) {\n-  let overloads = ''\n-\n-  const profileNames = Object.keys(cacheLife)\n-  for (let i = 0; i < profileNames.length; i++) {\n-    const profileName = profileNames[i]\n-    const profile = cacheLife[profileName]\n-    if (typeof profile !== 'object' || profile === null) {\n-      continue\n-    }\n-\n-    let description = ''\n-\n-    if (profile.stale === undefined) {\n-      description += `\n-     * This cache may be stale on clients for the default stale time of the scope before checking with the server.`\n-    } else if (profile.stale >= 0xfffffffe) {\n-      description += `\n-     * This cache may be stale on clients indefinitely before checking with the server.`\n-    } else {\n-      description += `\n-     * This cache may be stale on clients for ${formatTimespan(profile.stale)} before checking with the server.`\n-    }\n-    if (\n-      profile.revalidate !== undefined &&\n-      profile.expire !== undefined &&\n-      profile.revalidate >= profile.expire\n-    ) {\n-      description += `\n-     * This cache will expire after ${formatTimespan(profile.expire)}. The next request will recompute it.`\n-    } else {\n-      if (profile.revalidate === undefined) {\n-        description += `\n-     * It will inherit the default revalidate time of its scope since it does not define its own.`\n-      } else if (profile.revalidate >= 0xfffffffe) {\n-        // Nothing to mention.\n-      } else {\n-        description += `\n-     * If the server receives a new request after ${formatTimespan(profile.revalidate)}, start revalidating new values in the background.`\n-      }\n-      if (profile.expire === undefined) {\n-        description += `\n-     * It will inherit the default expiration time of its scope since it does not define its own.`\n-      } else if (profile.expire >= 0xfffffffe) {\n-        description += `\n-     * It lives for the maximum age of the server cache. If this entry has no traffic for a while, it may serve an old value the next request.`\n-      } else {\n-        description += `\n-     * If this entry has no traffic for ${formatTimespan(profile.expire)} it will expire. The next request will recompute it.`\n-      }\n-    }\n-\n-    overloads += `\n-    /**\n-     * Cache this \\`\"use cache\"\\` for a timespan defined by the \\`${JSON.stringify(profileName)}\\` profile.\n-     * \\`\\`\\`\n-     *   stale:      ${formatTimespanWithSeconds(profile.stale)}\n-     *   revalidate: ${formatTimespanWithSeconds(profile.revalidate)}\n-     *   expire:     ${formatTimespanWithSeconds(profile.expire)}\n-     * \\`\\`\\`\n-     * ${description}\n-     */\n-    export function cacheLife(profile: ${JSON.stringify(profileName)}): void\n-    `\n-  }\n-\n-  overloads += `\n-    /**\n-     * Cache this \\`\"use cache\"\\` using a custom timespan.\n-     * \\`\\`\\`\n-     *   stale: ... // seconds\n-     *   revalidate: ... // seconds\n-     *   expire: ... // seconds\n-     * \\`\\`\\`\n-     *\n-     * This is similar to Cache-Control: max-age=\\`stale\\`,s-max-age=\\`revalidate\\`,stale-while-revalidate=\\`expire-revalidate\\`\n-     *\n-     * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.\n-     */\n-    export function cacheLife(profile: {\n-      /**\n-       * This cache may be stale on clients for ... seconds before checking with the server.\n-       */\n-      stale?: number,\n-      /**\n-       * If the server receives a new request after ... seconds, start revalidating new values in the background.\n-       */\n-      revalidate?: number,\n-      /**\n-       * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.\n-       */\n-      expire?: number\n-    }): void\n-  `\n-\n-  // Redefine the cacheLife() accepted arguments.\n-  return `// Type definitions for Next.js cacheLife configs\n-\n-declare module 'next/cache' {\n-  export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'\n-  export {\n-    updateTag,\n-    revalidateTag,\n-    revalidatePath,\n-    refresh,\n-  } from 'next/dist/server/web/spec-extension/revalidate'\n-  export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'\n-\n-  ${overloads}\n-\n-  import { cacheTag } from 'next/dist/server/use-cache/cache-tag'\n-  export { cacheTag }\n-\n-  export const unstable_cacheTag: typeof cacheTag\n-  export const unstable_cacheLife: typeof cacheLife\n-}\n-`\n-}\n-\n const appTypesBasePath = path.join('types', 'app')\n \n export class NextTypesPlugin {\n@@ -557,7 +381,6 @@ export class NextTypesPlugin {\n   isEdgeServer: boolean\n   pageExtensions: string[]\n   pagesDir: string\n-  cacheLifeConfig: undefined | { [profile: string]: CacheLife }\n   distDirAbsolutePath: string\n \n   constructor(options: Options) {\n@@ -568,7 +391,6 @@ export class NextTypesPlugin {\n     this.isEdgeServer = options.isEdgeServer\n     this.pageExtensions = options.pageExtensions\n     this.pagesDir = path.join(this.appDir, '..', 'pages')\n-    this.cacheLifeConfig = options.cacheLifeConfig\n     this.distDirAbsolutePath = path.join(this.dir, this.distDir)\n   }\n \n@@ -829,20 +651,6 @@ export class NextTypesPlugin {\n             ) as unknown as webpack.sources.RawSource\n           )\n \n-          if (this.cacheLifeConfig) {\n-            const cacheLifeAssetPath = path.join(\n-              assetDirRelative,\n-              'types/cache-life.d.ts'\n-            )\n-\n-            compilation.emitAsset(\n-              cacheLifeAssetPath,\n-              new sources.RawSource(\n-                createCustomCacheLifeDefinitions(this.cacheLifeConfig)\n-              ) as unknown as webpack.sources.RawSource\n-            )\n-          }\n-\n           callback()\n         }\n       )"
        },
        {
            "sha": "94cf19cd145789cac747048ea0f60521ac9b5440",
            "filename": "packages/next/src/cli/next-typegen.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fcli%2Fnext-typegen.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fcli%2Fnext-typegen.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcli%2Fnext-typegen.ts?ref=89cd2058a6b2ff711a7237b0ba5003b73b4649c1",
            "patch": "@@ -30,6 +30,7 @@ import {\n   writeRouteTypesManifest,\n   writeValidatorFile,\n } from '../server/lib/router-utils/route-types-utils'\n+import { writeCacheLifeTypes } from '../server/lib/router-utils/cache-life-type-utils'\n import { createValidFileMatcher } from '../server/lib/find-page-file'\n \n export type NextTypegenOptions = {\n@@ -167,7 +168,11 @@ const nextTypegen = async (\n \n   await writeValidatorFile(routeTypesManifest, validatorFilePath)\n \n-  console.log('✓ Route types generated successfully')\n+  // Generate cache-life types if cacheLife config exists\n+  const cacheLifeFilePath = join(distDir, 'types', 'cache-life.d.ts')\n+  writeCacheLifeTypes(nextConfig.cacheLife, cacheLifeFilePath)\n+\n+  console.log('✓ Types generated successfully')\n }\n \n export { nextTypegen }"
        },
        {
            "sha": "639697d3983ca7eab2cc0cea4a356b423e030e33",
            "filename": "packages/next/src/server/lib/router-utils/cache-life-type-utils.test.ts",
            "status": "added",
            "additions": 553,
            "deletions": 0,
            "changes": 553,
            "blob_url": "https://github.com/vercel/next.js/blob/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fcache-life-type-utils.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fcache-life-type-utils.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fcache-life-type-utils.test.ts?ref=89cd2058a6b2ff711a7237b0ba5003b73b4649c1",
            "patch": "@@ -0,0 +1,553 @@\n+import { generateCacheLifeTypes } from './cache-life-type-utils'\n+\n+describe('cache-life-type-utils', () => {\n+  it('should generate cache-life types with custom profiles', () => {\n+    const cacheLifeConfig = {\n+      default: {\n+        stale: 3600,\n+        revalidate: 900,\n+        expire: 86400,\n+      },\n+      hours: {\n+        stale: 300,\n+        revalidate: 3600,\n+        expire: 7200,\n+      },\n+    }\n+\n+    const output = generateCacheLifeTypes(cacheLifeConfig)\n+\n+    expect(output).toMatchInlineSnapshot(`\n+     \"// Type definitions for Next.js cacheLife configs\n+\n+     declare module 'next/cache' {\n+       export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'\n+       export {\n+         updateTag,\n+         revalidateTag,\n+         revalidatePath,\n+         refresh,\n+       } from 'next/dist/server/web/spec-extension/revalidate'\n+       export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'\n+\n+       \n+         /**\n+          * Cache this \\`\"use cache\"\\` for a timespan defined by the \\`\"default\"\\` profile.\n+          * \\`\\`\\`\n+          *   stale:      3600 seconds (1 hour)\n+          *   revalidate: 900 seconds (15 minutes)\n+          *   expire:     86400 seconds (1 day)\n+          * \\`\\`\\`\n+          * \n+          * This cache may be stale on clients for 1 hour before checking with the server.\n+          * If the server receives a new request after 15 minutes, start revalidating new values in the background.\n+          * If this entry has no traffic for 1 day it will expire. The next request will recompute it.\n+          */\n+         export function cacheLife(profile: \"default\"): void\n+         \n+         /**\n+          * Cache this \\`\"use cache\"\\` for a timespan defined by the \\`\"hours\"\\` profile.\n+          * \\`\\`\\`\n+          *   stale:      300 seconds (5 minutes)\n+          *   revalidate: 3600 seconds (1 hour)\n+          *   expire:     7200 seconds (2 hours)\n+          * \\`\\`\\`\n+          * \n+          * This cache may be stale on clients for 5 minutes before checking with the server.\n+          * If the server receives a new request after 1 hour, start revalidating new values in the background.\n+          * If this entry has no traffic for 2 hours it will expire. The next request will recompute it.\n+          */\n+         export function cacheLife(profile: \"hours\"): void\n+         \n+         /**\n+          * Cache this \\`\"use cache\"\\` using a custom timespan.\n+          * \\`\\`\\`\n+          *   stale: ... // seconds\n+          *   revalidate: ... // seconds\n+          *   expire: ... // seconds\n+          * \\`\\`\\`\n+          *\n+          * This is similar to Cache-Control: max-age=\\`stale\\`,s-max-age=\\`revalidate\\`,stale-while-revalidate=\\`expire-revalidate\\`\n+          *\n+          * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.\n+          */\n+         export function cacheLife(profile: {\n+           /**\n+            * This cache may be stale on clients for ... seconds before checking with the server.\n+            */\n+           stale?: number,\n+           /**\n+            * If the server receives a new request after ... seconds, start revalidating new values in the background.\n+            */\n+           revalidate?: number,\n+           /**\n+            * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.\n+            */\n+           expire?: number\n+         }): void\n+       \n+\n+       import { cacheTag } from 'next/dist/server/use-cache/cache-tag'\n+       export { cacheTag }\n+\n+       export const unstable_cacheTag: typeof cacheTag\n+       export const unstable_cacheLife: typeof cacheLife\n+     }\n+     \"\n+    `)\n+  })\n+\n+  it('should format time periods correctly', () => {\n+    const cacheLifeConfig = {\n+      seconds: {\n+        stale: 30,\n+        revalidate: 45,\n+        expire: 90,\n+      },\n+      minutes: {\n+        stale: 60,\n+        revalidate: 300,\n+        expire: 600,\n+      },\n+      hours: {\n+        stale: 3600,\n+        revalidate: 7200,\n+        expire: 10800,\n+      },\n+      days: {\n+        stale: 86400,\n+        revalidate: 172800,\n+        expire: 259200,\n+      },\n+      weeks: {\n+        stale: 604800,\n+        revalidate: 1209600,\n+        expire: 1814400,\n+      },\n+      months: {\n+        stale: 30 * 24 * 60 * 60,\n+        revalidate: 2 * 30 * 24 * 60 * 60,\n+        expire: 4 * 30 * 24 * 60 * 60,\n+      },\n+    }\n+\n+    const output = generateCacheLifeTypes(cacheLifeConfig)\n+    // Filter to just the timeformatting lines\n+    const justConfigLines = output\n+      .split('\\n')\n+      .filter((line) => /stale:|revalidate:|expire:/.test(line))\n+      .join('\\n')\n+\n+    expect(justConfigLines).toMatchInlineSnapshot(`\n+     \"     *   stale:      30 seconds\n+          *   revalidate: 45 seconds\n+          *   expire:     90 seconds\n+          *   stale:      60 seconds (1 minute)\n+          *   revalidate: 300 seconds (5 minutes)\n+          *   expire:     600 seconds (10 minutes)\n+          *   stale:      3600 seconds (1 hour)\n+          *   revalidate: 7200 seconds (2 hours)\n+          *   expire:     10800 seconds (3 hours)\n+          *   stale:      86400 seconds (1 day)\n+          *   revalidate: 172800 seconds (2 days)\n+          *   expire:     259200 seconds (3 days)\n+          *   stale:      604800 seconds (1 week)\n+          *   revalidate: 1209600 seconds (2 weeks)\n+          *   expire:     1814400 seconds (3 weeks)\n+          *   stale:      2592000 seconds (1 month)\n+          *   revalidate: 5184000 seconds (2 months)\n+          *   expire:     10368000 seconds (4 months)\n+          *   stale: ... // seconds\n+          *   revalidate: ... // seconds\n+          *   expire: ... // seconds\"\n+    `)\n+  })\n+\n+  it('should handle undefined values correctly', () => {\n+    const cacheLifeConfig = {\n+      partial: {\n+        stale: undefined,\n+        revalidate: 3600,\n+        expire: undefined,\n+      },\n+    }\n+\n+    const output = generateCacheLifeTypes(cacheLifeConfig)\n+\n+    expect(output).toMatchInlineSnapshot(`\n+     \"// Type definitions for Next.js cacheLife configs\n+\n+     declare module 'next/cache' {\n+       export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'\n+       export {\n+         updateTag,\n+         revalidateTag,\n+         revalidatePath,\n+         refresh,\n+       } from 'next/dist/server/web/spec-extension/revalidate'\n+       export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'\n+\n+       \n+         /**\n+          * Cache this \\`\"use cache\"\\` for a timespan defined by the \\`\"partial\"\\` profile.\n+          * \\`\\`\\`\n+          *   stale:      default\n+          *   revalidate: 3600 seconds (1 hour)\n+          *   expire:     default\n+          * \\`\\`\\`\n+          * \n+          * This cache may be stale on clients for the default stale time of the scope before checking with the server.\n+          * If the server receives a new request after 1 hour, start revalidating new values in the background.\n+          * It will inherit the default expiration time of its scope since it does not define its own.\n+          */\n+         export function cacheLife(profile: \"partial\"): void\n+         \n+         /**\n+          * Cache this \\`\"use cache\"\\` using a custom timespan.\n+          * \\`\\`\\`\n+          *   stale: ... // seconds\n+          *   revalidate: ... // seconds\n+          *   expire: ... // seconds\n+          * \\`\\`\\`\n+          *\n+          * This is similar to Cache-Control: max-age=\\`stale\\`,s-max-age=\\`revalidate\\`,stale-while-revalidate=\\`expire-revalidate\\`\n+          *\n+          * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.\n+          */\n+         export function cacheLife(profile: {\n+           /**\n+            * This cache may be stale on clients for ... seconds before checking with the server.\n+            */\n+           stale?: number,\n+           /**\n+            * If the server receives a new request after ... seconds, start revalidating new values in the background.\n+            */\n+           revalidate?: number,\n+           /**\n+            * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.\n+            */\n+           expire?: number\n+         }): void\n+       \n+\n+       import { cacheTag } from 'next/dist/server/use-cache/cache-tag'\n+       export { cacheTag }\n+\n+       export const unstable_cacheTag: typeof cacheTag\n+       export const unstable_cacheLife: typeof cacheLife\n+     }\n+     \"\n+    `)\n+  })\n+\n+  it('should handle \"never\" values correctly', () => {\n+    const cacheLifeConfig = {\n+      infinite: {\n+        stale: 0xfffffffe,\n+        revalidate: 0xfffffffe,\n+        expire: 0xfffffffe,\n+      },\n+    }\n+\n+    const output = generateCacheLifeTypes(cacheLifeConfig)\n+\n+    expect(output).toMatchInlineSnapshot(`\n+     \"// Type definitions for Next.js cacheLife configs\n+\n+     declare module 'next/cache' {\n+       export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'\n+       export {\n+         updateTag,\n+         revalidateTag,\n+         revalidatePath,\n+         refresh,\n+       } from 'next/dist/server/web/spec-extension/revalidate'\n+       export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'\n+\n+       \n+         /**\n+          * Cache this \\`\"use cache\"\\` for a timespan defined by the \\`\"infinite\"\\` profile.\n+          * \\`\\`\\`\n+          *   stale:      never\n+          *   revalidate: never\n+          *   expire:     never\n+          * \\`\\`\\`\n+          * \n+          * This cache may be stale on clients indefinitely before checking with the server.\n+          * This cache will expire after 4294967294 seconds. The next request will recompute it.\n+          */\n+         export function cacheLife(profile: \"infinite\"): void\n+         \n+         /**\n+          * Cache this \\`\"use cache\"\\` using a custom timespan.\n+          * \\`\\`\\`\n+          *   stale: ... // seconds\n+          *   revalidate: ... // seconds\n+          *   expire: ... // seconds\n+          * \\`\\`\\`\n+          *\n+          * This is similar to Cache-Control: max-age=\\`stale\\`,s-max-age=\\`revalidate\\`,stale-while-revalidate=\\`expire-revalidate\\`\n+          *\n+          * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.\n+          */\n+         export function cacheLife(profile: {\n+           /**\n+            * This cache may be stale on clients for ... seconds before checking with the server.\n+            */\n+           stale?: number,\n+           /**\n+            * If the server receives a new request after ... seconds, start revalidating new values in the background.\n+            */\n+           revalidate?: number,\n+           /**\n+            * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.\n+            */\n+           expire?: number\n+         }): void\n+       \n+\n+       import { cacheTag } from 'next/dist/server/use-cache/cache-tag'\n+       export { cacheTag }\n+\n+       export const unstable_cacheTag: typeof cacheTag\n+       export const unstable_cacheLife: typeof cacheLife\n+     }\n+     \"\n+    `)\n+  })\n+\n+  it('should include base cacheLife function signature', () => {\n+    const cacheLifeConfig = {\n+      custom: {\n+        stale: 100,\n+        revalidate: 200,\n+        expire: 300,\n+      },\n+    }\n+\n+    const output = generateCacheLifeTypes(cacheLifeConfig)\n+\n+    expect(output).toMatchInlineSnapshot(`\n+     \"// Type definitions for Next.js cacheLife configs\n+\n+     declare module 'next/cache' {\n+       export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'\n+       export {\n+         updateTag,\n+         revalidateTag,\n+         revalidatePath,\n+         refresh,\n+       } from 'next/dist/server/web/spec-extension/revalidate'\n+       export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'\n+\n+       \n+         /**\n+          * Cache this \\`\"use cache\"\\` for a timespan defined by the \\`\"custom\"\\` profile.\n+          * \\`\\`\\`\n+          *   stale:      100 seconds\n+          *   revalidate: 200 seconds\n+          *   expire:     300 seconds (5 minutes)\n+          * \\`\\`\\`\n+          * \n+          * This cache may be stale on clients for 100 seconds before checking with the server.\n+          * If the server receives a new request after 200 seconds, start revalidating new values in the background.\n+          * If this entry has no traffic for 5 minutes it will expire. The next request will recompute it.\n+          */\n+         export function cacheLife(profile: \"custom\"): void\n+         \n+         /**\n+          * Cache this \\`\"use cache\"\\` using a custom timespan.\n+          * \\`\\`\\`\n+          *   stale: ... // seconds\n+          *   revalidate: ... // seconds\n+          *   expire: ... // seconds\n+          * \\`\\`\\`\n+          *\n+          * This is similar to Cache-Control: max-age=\\`stale\\`,s-max-age=\\`revalidate\\`,stale-while-revalidate=\\`expire-revalidate\\`\n+          *\n+          * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.\n+          */\n+         export function cacheLife(profile: {\n+           /**\n+            * This cache may be stale on clients for ... seconds before checking with the server.\n+            */\n+           stale?: number,\n+           /**\n+            * If the server receives a new request after ... seconds, start revalidating new values in the background.\n+            */\n+           revalidate?: number,\n+           /**\n+            * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.\n+            */\n+           expire?: number\n+         }): void\n+       \n+\n+       import { cacheTag } from 'next/dist/server/use-cache/cache-tag'\n+       export { cacheTag }\n+\n+       export const unstable_cacheTag: typeof cacheTag\n+       export const unstable_cacheLife: typeof cacheLife\n+     }\n+     \"\n+    `)\n+  })\n+\n+  it('should include module exports', () => {\n+    const cacheLifeConfig = {\n+      test: {\n+        stale: 100,\n+        revalidate: 200,\n+        expire: 300,\n+      },\n+    }\n+\n+    const output = generateCacheLifeTypes(cacheLifeConfig)\n+\n+    expect(output).toMatchInlineSnapshot(`\n+     \"// Type definitions for Next.js cacheLife configs\n+\n+     declare module 'next/cache' {\n+       export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'\n+       export {\n+         updateTag,\n+         revalidateTag,\n+         revalidatePath,\n+         refresh,\n+       } from 'next/dist/server/web/spec-extension/revalidate'\n+       export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'\n+\n+       \n+         /**\n+          * Cache this \\`\"use cache\"\\` for a timespan defined by the \\`\"test\"\\` profile.\n+          * \\`\\`\\`\n+          *   stale:      100 seconds\n+          *   revalidate: 200 seconds\n+          *   expire:     300 seconds (5 minutes)\n+          * \\`\\`\\`\n+          * \n+          * This cache may be stale on clients for 100 seconds before checking with the server.\n+          * If the server receives a new request after 200 seconds, start revalidating new values in the background.\n+          * If this entry has no traffic for 5 minutes it will expire. The next request will recompute it.\n+          */\n+         export function cacheLife(profile: \"test\"): void\n+         \n+         /**\n+          * Cache this \\`\"use cache\"\\` using a custom timespan.\n+          * \\`\\`\\`\n+          *   stale: ... // seconds\n+          *   revalidate: ... // seconds\n+          *   expire: ... // seconds\n+          * \\`\\`\\`\n+          *\n+          * This is similar to Cache-Control: max-age=\\`stale\\`,s-max-age=\\`revalidate\\`,stale-while-revalidate=\\`expire-revalidate\\`\n+          *\n+          * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.\n+          */\n+         export function cacheLife(profile: {\n+           /**\n+            * This cache may be stale on clients for ... seconds before checking with the server.\n+            */\n+           stale?: number,\n+           /**\n+            * If the server receives a new request after ... seconds, start revalidating new values in the background.\n+            */\n+           revalidate?: number,\n+           /**\n+            * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.\n+            */\n+           expire?: number\n+         }): void\n+       \n+\n+       import { cacheTag } from 'next/dist/server/use-cache/cache-tag'\n+       export { cacheTag }\n+\n+       export const unstable_cacheTag: typeof cacheTag\n+       export const unstable_cacheLife: typeof cacheLife\n+     }\n+     \"\n+    `)\n+  })\n+\n+  it('should skip non-object profile values', () => {\n+    const cacheLifeConfig = {\n+      valid: {\n+        stale: 100,\n+        revalidate: 200,\n+        expire: 300,\n+      },\n+      invalid1: null,\n+      invalid2: 'string',\n+      invalid3: 123,\n+    }\n+\n+    // @ts-expect-error\n+    const output = generateCacheLifeTypes(cacheLifeConfig)\n+\n+    expect(output).toMatchInlineSnapshot(`\n+     \"// Type definitions for Next.js cacheLife configs\n+\n+     declare module 'next/cache' {\n+       export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'\n+       export {\n+         updateTag,\n+         revalidateTag,\n+         revalidatePath,\n+         refresh,\n+       } from 'next/dist/server/web/spec-extension/revalidate'\n+       export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'\n+\n+       \n+         /**\n+          * Cache this \\`\"use cache\"\\` for a timespan defined by the \\`\"valid\"\\` profile.\n+          * \\`\\`\\`\n+          *   stale:      100 seconds\n+          *   revalidate: 200 seconds\n+          *   expire:     300 seconds (5 minutes)\n+          * \\`\\`\\`\n+          * \n+          * This cache may be stale on clients for 100 seconds before checking with the server.\n+          * If the server receives a new request after 200 seconds, start revalidating new values in the background.\n+          * If this entry has no traffic for 5 minutes it will expire. The next request will recompute it.\n+          */\n+         export function cacheLife(profile: \"valid\"): void\n+         \n+         /**\n+          * Cache this \\`\"use cache\"\\` using a custom timespan.\n+          * \\`\\`\\`\n+          *   stale: ... // seconds\n+          *   revalidate: ... // seconds\n+          *   expire: ... // seconds\n+          * \\`\\`\\`\n+          *\n+          * This is similar to Cache-Control: max-age=\\`stale\\`,s-max-age=\\`revalidate\\`,stale-while-revalidate=\\`expire-revalidate\\`\n+          *\n+          * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.\n+          */\n+         export function cacheLife(profile: {\n+           /**\n+            * This cache may be stale on clients for ... seconds before checking with the server.\n+            */\n+           stale?: number,\n+           /**\n+            * If the server receives a new request after ... seconds, start revalidating new values in the background.\n+            */\n+           revalidate?: number,\n+           /**\n+            * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.\n+            */\n+           expire?: number\n+         }): void\n+       \n+\n+       import { cacheTag } from 'next/dist/server/use-cache/cache-tag'\n+       export { cacheTag }\n+\n+       export const unstable_cacheTag: typeof cacheTag\n+       export const unstable_cacheLife: typeof cacheLife\n+     }\n+     \"\n+    `)\n+  })\n+})"
        },
        {
            "sha": "89b21c210c4de82ba417551300b93d718dd4248c",
            "filename": "packages/next/src/server/lib/router-utils/cache-life-type-utils.ts",
            "status": "added",
            "additions": 213,
            "deletions": 0,
            "changes": 213,
            "blob_url": "https://github.com/vercel/next.js/blob/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fcache-life-type-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fcache-life-type-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fcache-life-type-utils.ts?ref=89cd2058a6b2ff711a7237b0ba5003b73b4649c1",
            "patch": "@@ -0,0 +1,213 @@\n+import type { CacheLife } from '../../use-cache/cache-life'\n+import fs from 'fs'\n+import path from 'path'\n+\n+const MINUTE_IN_SECONDS = 60\n+const HOUR_IN_SECONDS = MINUTE_IN_SECONDS * 60 // nevermind leap seconds\n+const DAY_IN_SECONDS = HOUR_IN_SECONDS * 24\n+const WEEK_IN_SECONDS = DAY_IN_SECONDS * 7\n+// Nevermind leap years, or you know, July\n+const MONTH_30_DAYS_IN_SECONDS = DAY_IN_SECONDS * 30\n+\n+function formatTimespan(seconds: number): string {\n+  if (seconds > 0) {\n+    if (seconds === MONTH_30_DAYS_IN_SECONDS) {\n+      return '1 month'\n+    }\n+    if (seconds === WEEK_IN_SECONDS) {\n+      return '1 week'\n+    }\n+    if (seconds === DAY_IN_SECONDS) {\n+      return '1 day'\n+    }\n+    if (seconds === HOUR_IN_SECONDS) {\n+      return '1 hour'\n+    }\n+    if (seconds === MINUTE_IN_SECONDS) {\n+      return '1 minute'\n+    }\n+    if (seconds % MONTH_30_DAYS_IN_SECONDS === 0) {\n+      return seconds / MONTH_30_DAYS_IN_SECONDS + ' months'\n+    }\n+    if (seconds % 18144000 === 0) {\n+      return seconds / 18144000 + ' months'\n+    }\n+    if (seconds % WEEK_IN_SECONDS === 0) {\n+      return seconds / WEEK_IN_SECONDS + ' weeks'\n+    }\n+    if (seconds % DAY_IN_SECONDS === 0) {\n+      return seconds / DAY_IN_SECONDS + ' days'\n+    }\n+    if (seconds % HOUR_IN_SECONDS === 0) {\n+      return seconds / HOUR_IN_SECONDS + ' hours'\n+    }\n+    if (seconds % MINUTE_IN_SECONDS === 0) {\n+      return seconds / MINUTE_IN_SECONDS + ' minutes'\n+    }\n+  }\n+  return seconds + ' seconds'\n+}\n+\n+function formatTimespanWithSeconds(seconds: undefined | number): string {\n+  if (seconds === undefined) {\n+    return 'default'\n+  }\n+  if (seconds >= 0xfffffffe) {\n+    return 'never'\n+  }\n+  const text = seconds + ' seconds'\n+  const descriptive = formatTimespan(seconds)\n+  if (descriptive === text) {\n+    return text\n+  }\n+  return text + ' (' + descriptive + ')'\n+}\n+\n+/**\n+ * Generates TypeScript type definitions for custom cacheLife profiles.\n+ * This creates overloaded function signatures for the cacheLife() function\n+ * that provide autocomplete and documentation for each profile.\n+ */\n+export function generateCacheLifeTypes(cacheLife: {\n+  [profile: string]: CacheLife\n+}): string {\n+  let overloads = ''\n+\n+  const profileNames = Object.keys(cacheLife)\n+  for (let i = 0; i < profileNames.length; i++) {\n+    const profileName = profileNames[i]\n+    const profile = cacheLife[profileName]\n+    if (typeof profile !== 'object' || profile === null) {\n+      continue\n+    }\n+\n+    let description = ''\n+\n+    if (profile.stale === undefined) {\n+      description += `\n+     * This cache may be stale on clients for the default stale time of the scope before checking with the server.`\n+    } else if (profile.stale >= 0xfffffffe) {\n+      description += `\n+     * This cache may be stale on clients indefinitely before checking with the server.`\n+    } else {\n+      description += `\n+     * This cache may be stale on clients for ${formatTimespan(profile.stale)} before checking with the server.`\n+    }\n+    if (\n+      profile.revalidate !== undefined &&\n+      profile.expire !== undefined &&\n+      profile.revalidate >= profile.expire\n+    ) {\n+      description += `\n+     * This cache will expire after ${formatTimespan(profile.expire)}. The next request will recompute it.`\n+    } else {\n+      if (profile.revalidate === undefined) {\n+        description += `\n+     * It will inherit the default revalidate time of its scope since it does not define its own.`\n+      } else if (profile.revalidate >= 0xfffffffe) {\n+        // Nothing to mention.\n+      } else {\n+        description += `\n+     * If the server receives a new request after ${formatTimespan(profile.revalidate)}, start revalidating new values in the background.`\n+      }\n+      if (profile.expire === undefined) {\n+        description += `\n+     * It will inherit the default expiration time of its scope since it does not define its own.`\n+      } else if (profile.expire >= 0xfffffffe) {\n+        description += `\n+     * It lives for the maximum age of the server cache. If this entry has no traffic for a while, it may serve an old value the next request.`\n+      } else {\n+        description += `\n+     * If this entry has no traffic for ${formatTimespan(profile.expire)} it will expire. The next request will recompute it.`\n+      }\n+    }\n+\n+    overloads += `\n+    /**\n+     * Cache this \\`\"use cache\"\\` for a timespan defined by the \\`${JSON.stringify(profileName)}\\` profile.\n+     * \\`\\`\\`\n+     *   stale:      ${formatTimespanWithSeconds(profile.stale)}\n+     *   revalidate: ${formatTimespanWithSeconds(profile.revalidate)}\n+     *   expire:     ${formatTimespanWithSeconds(profile.expire)}\n+     * \\`\\`\\`\n+     * ${description}\n+     */\n+    export function cacheLife(profile: ${JSON.stringify(profileName)}): void\n+    `\n+  }\n+\n+  overloads += `\n+    /**\n+     * Cache this \\`\"use cache\"\\` using a custom timespan.\n+     * \\`\\`\\`\n+     *   stale: ... // seconds\n+     *   revalidate: ... // seconds\n+     *   expire: ... // seconds\n+     * \\`\\`\\`\n+     *\n+     * This is similar to Cache-Control: max-age=\\`stale\\`,s-max-age=\\`revalidate\\`,stale-while-revalidate=\\`expire-revalidate\\`\n+     *\n+     * If a value is left out, the lowest of other cacheLife() calls or the default, is used instead.\n+     */\n+    export function cacheLife(profile: {\n+      /**\n+       * This cache may be stale on clients for ... seconds before checking with the server.\n+       */\n+      stale?: number,\n+      /**\n+       * If the server receives a new request after ... seconds, start revalidating new values in the background.\n+       */\n+      revalidate?: number,\n+      /**\n+       * If this entry has no traffic for ... seconds it will expire. The next request will recompute it.\n+       */\n+      expire?: number\n+    }): void\n+  `\n+\n+  // Redefine the cacheLife() accepted arguments.\n+  return `// Type definitions for Next.js cacheLife configs\n+\n+declare module 'next/cache' {\n+  export { unstable_cache } from 'next/dist/server/web/spec-extension/unstable-cache'\n+  export {\n+    updateTag,\n+    revalidateTag,\n+    revalidatePath,\n+    refresh,\n+  } from 'next/dist/server/web/spec-extension/revalidate'\n+  export { unstable_noStore } from 'next/dist/server/web/spec-extension/unstable-no-store'\n+\n+  ${overloads}\n+\n+  import { cacheTag } from 'next/dist/server/use-cache/cache-tag'\n+  export { cacheTag }\n+\n+  export const unstable_cacheTag: typeof cacheTag\n+  export const unstable_cacheLife: typeof cacheLife\n+}\n+`\n+}\n+\n+/**\n+ * Writes cache-life type definitions to a file if cacheLifeConfig exists.\n+ * This is used by both the CLI (next type-gen) and dev server to generate\n+ * cache-life.d.ts in the types directory.\n+ */\n+export function writeCacheLifeTypes(\n+  cacheLifeConfig: undefined | { [profile: string]: CacheLife },\n+  filePath: string\n+) {\n+  if (!cacheLifeConfig || Object.keys(cacheLifeConfig).length === 0) {\n+    return\n+  }\n+\n+  const dirname = path.dirname(filePath)\n+\n+  if (!fs.existsSync(dirname)) {\n+    fs.mkdirSync(dirname, { recursive: true })\n+  }\n+\n+  const content = generateCacheLifeTypes(cacheLifeConfig)\n+  fs.writeFileSync(filePath, content)\n+}"
        },
        {
            "sha": "e980f0c3fe877639348667e331993b7f79b83293",
            "filename": "packages/next/src/server/lib/router-utils/setup-dev-bundler.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/89cd2058a6b2ff711a7237b0ba5003b73b4649c1/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Fsetup-dev-bundler.ts?ref=89cd2058a6b2ff711a7237b0ba5003b73b4649c1",
            "patch": "@@ -85,6 +85,7 @@ import {\n   writeRouteTypesManifest,\n   writeValidatorFile,\n } from './route-types-utils'\n+import { writeCacheLifeTypes } from './cache-life-type-utils'\n import { isParallelRouteSegment } from '../../../shared/lib/segment'\n import { ensureLeadingSlash } from '../../../shared/lib/page-path/ensure-leading-slash'\n import { Lockfile } from '../../../build/lockfile'\n@@ -1165,6 +1166,10 @@ async function startWatcher(\n             opts.nextConfig\n           )\n           await writeValidatorFile(routeTypesManifest, validatorFilePath)\n+\n+          // Generate cache-life types if cacheLife config exists\n+          const cacheLifeFilePath = path.join(distTypesDir, 'cache-life.d.ts')\n+          writeCacheLifeTypes(opts.nextConfig.cacheLife, cacheLifeFilePath)\n         }\n \n         if (!resolved) {"
        }
    ],
    "stats": {
        "total": 983,
        "additions": 782,
        "deletions": 201
    }
}