{
    "author": "bgw",
    "message": "Turbopack: Remove dead `turbo_tasks::persisted_graph` module (#86329)\n\nThis is dead code, likely left over from the memory backend and/or previous experiments with persistent caching.",
    "sha": "5b62dd8504650ab03a960039b86f63c5dcc22ef5",
    "files": [
        {
            "sha": "51aebc9a6e3da0b379fc06c77a4b380406c6f21c",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/5b62dd8504650ab03a960039b86f63c5dcc22ef5/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5b62dd8504650ab03a960039b86f63c5dcc22ef5/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=5b62dd8504650ab03a960039b86f63c5dcc22ef5",
            "patch": "@@ -66,7 +66,6 @@ mod once_map;\n mod output;\n pub mod panic_hooks;\n pub mod parallel;\n-pub mod persisted_graph;\n pub mod primitives;\n mod raw_vc;\n mod read_options;"
        },
        {
            "sha": "74ba218c5bf4f6ee7f72451b06e703980fcdb635",
            "filename": "turbopack/crates/turbo-tasks/src/persisted_graph.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 402,
            "changes": 402,
            "blob_url": "https://github.com/vercel/next.js/blob/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fpersisted_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fpersisted_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fpersisted_graph.rs?ref=5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f",
            "patch": "@@ -1,402 +0,0 @@\n-use anyhow::Result;\n-use serde::{Deserialize, Serialize, ser::SerializeSeq};\n-use smallvec::SmallVec;\n-\n-use crate::{\n-    CellId, RawVc, TaskId,\n-    backend::{CachedTaskType, CellContent},\n-    task::shared_reference::TypedSharedReference,\n-};\n-\n-#[derive(Clone, Debug)]\n-pub enum TaskCell {\n-    Content(CellContent),\n-    NeedComputation,\n-}\n-\n-impl Default for TaskCell {\n-    fn default() -> Self {\n-        TaskCell::Content(CellContent(None))\n-    }\n-}\n-\n-#[derive(Serialize, Deserialize, Debug)]\n-pub struct TaskData {\n-    pub children: SmallVec<[TaskId; 4]>,\n-    pub dependencies: SmallVec<[RawVc; 1]>,\n-    pub cells: TaskCells,\n-    pub output: RawVc,\n-}\n-\n-/// A newtype struct that intercepts serde. This is required\n-/// because for safety reasons, TaskCell<()> is not allowed to\n-/// be deserialized.\n-///\n-/// We augment it with type data then write it. This is inefficient\n-/// on disk but could be alleviated later.\n-#[derive(Debug)]\n-pub struct TaskCells(pub Vec<(CellId, TaskCell)>);\n-\n-// the on-disk representation of a task cell. it is local to this impl\n-// to prevent users accidentally ser/de the untyped data\n-#[derive(Serialize, Deserialize)]\n-struct SerializableTaskCell(Option<Option<TypedSharedReference>>);\n-impl From<SerializableTaskCell> for TaskCell {\n-    fn from(val: SerializableTaskCell) -> Self {\n-        match val.0 {\n-            Some(d) => TaskCell::Content(d.map(TypedSharedReference::into_untyped).into()),\n-            None => TaskCell::NeedComputation,\n-        }\n-    }\n-}\n-\n-impl Serialize for TaskCells {\n-    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n-    where\n-        S: serde::Serializer,\n-    {\n-        let mut seq = serializer.serialize_seq(Some(self.0.len()))?;\n-        for (cell_id, cell) in &self.0 {\n-            let task_cell = SerializableTaskCell(match cell {\n-                TaskCell::Content(CellContent(opt)) => {\n-                    Some(opt.clone().map(|d| d.into_typed(cell_id.type_id)))\n-                }\n-                TaskCell::NeedComputation => None,\n-            });\n-            seq.serialize_element(&(cell_id, task_cell))?;\n-        }\n-        seq.end()\n-    }\n-}\n-\n-impl<'de> Deserialize<'de> for TaskCells {\n-    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n-    where\n-        D: serde::Deserializer<'de>,\n-    {\n-        let data: Vec<(CellId, SerializableTaskCell)> = Vec::deserialize(deserializer)?;\n-        Ok(TaskCells(\n-            data.into_iter()\n-                .map(|(id, cell)| (id, cell.into()))\n-                .collect(),\n-        ))\n-    }\n-}\n-\n-pub struct ReadTaskState {\n-    pub clean: bool,\n-    pub keeps_external_active: bool,\n-}\n-\n-pub struct PersistTaskState {\n-    pub externally_active: bool,\n-}\n-\n-/*\n-\n-There are 4 kinds of task:\n-\n-(A) A task that exists only in memory.\n-(B) A task that exists in persistent graph and in memory (either \"store\" or \"read\" has been called)\n-(C) A task that exists only in persistent graph.\n-\n-Parent-child relationships:\n-\n-(A) as child: active_parents is tracked only in memory.\n-(B) as child: active_parents is tracked in memory and either as internal_active_parents or external_active_parents in the persisted graph.\n-(C) as child: either as internal_active_parents or external_active_parents in the persisted graph.\n-\n-(A) as parent: It will use external_active_parents for (B) or (C) as child.\n-               update_active_parents() is used to modify the external_active_parents count.\n-(B) as parent: It will use internal_active_parents for (B) or (C) as child.\n-               compute_active() returns the changes needed for (A) or (C) as child\n-(C) as parent: It will use internal_active_parents for (B) or (C) as child.\n-               compute_active() returns the changes needed for (A) or (C) as child\n-\n-(A) as child of (B) or (C): active count tracked as external_active_children, have task ids assigned in persistent graph\n-\n-*/\n-\n-#[derive(Debug)]\n-pub struct ActivateResult {\n-    /// Keeps the external version of the task active\n-    pub keeps_external_active: bool,\n-\n-    /// Task doesn't live in the persisted graph but\n-    /// should be track externally\n-    pub external: bool,\n-\n-    /// Task is dirty and need to be scheduled for execution\n-    pub dirty: bool,\n-\n-    /// Further tasks that need to be activated that\n-    /// didn't fit into that batch\n-    pub more_tasks_to_activate: SmallVec<[TaskId; 4]>,\n-}\n-\n-#[derive(Debug)]\n-pub struct PersistResult {\n-    /// Tasks that need to be activated\n-    pub tasks_to_activate: SmallVec<[TaskId; 4]>,\n-\n-    /// Tasks that need to be deactivated\n-    pub tasks_to_deactivate: SmallVec<[TaskId; 4]>,\n-}\n-\n-#[derive(Debug)]\n-pub struct DeactivateResult {\n-    /// Further tasks that need to be deactivated that\n-    /// didn't fit into that batch\n-    pub more_tasks_to_deactivate: SmallVec<[TaskId; 4]>,\n-}\n-\n-pub type TaskIds = SmallVec<[TaskId; 4]>;\n-\n-pub trait PersistedGraph: Sync + Send {\n-    /// read task data and state for a specific task.\n-    fn read(\n-        &self,\n-        task: TaskId,\n-        api: &dyn PersistedGraphApi,\n-    ) -> Result<Option<(TaskData, ReadTaskState)>>;\n-\n-    /// lookup all cache entries for a partial task type\n-    /// returns true if all cache entries has been initialized\n-    /// returns false if that were too many\n-    fn lookup(\n-        &self,\n-        partial_task_type: &CachedTaskType,\n-        api: &dyn PersistedGraphApi,\n-    ) -> Result<bool>;\n-\n-    /// lookup one cache entry\n-    fn lookup_one(\n-        &self,\n-        task_type: &CachedTaskType,\n-        api: &dyn PersistedGraphApi,\n-    ) -> Result<Option<TaskId>>;\n-\n-    /// checks if a task is persisted\n-    fn is_persisted(&self, task: TaskId, api: &dyn PersistedGraphApi) -> Result<bool>;\n-\n-    /// store a completed task into the persisted graph\n-    /// together with dependencies, children and cells.\n-    /// Returns false, if the task failed to persist.\n-    fn persist(\n-        &self,\n-        task: TaskId,\n-        data: TaskData,\n-        state: PersistTaskState,\n-        api: &dyn PersistedGraphApi,\n-    ) -> Result<Option<PersistResult>>;\n-\n-    /// Activate a task in the persisted graph when active_parents > 0 or it's\n-    /// externally kept alive.\n-    fn activate_when_needed(\n-        &self,\n-        task: TaskId,\n-        api: &dyn PersistedGraphApi,\n-    ) -> Result<Option<ActivateResult>>;\n-\n-    /// Deactivate a task in the persisted graph when active_parents == 0 and\n-    /// it's not externally kept alive.\n-    fn deactivate_when_needed(\n-        &self,\n-        task: TaskId,\n-        api: &dyn PersistedGraphApi,\n-    ) -> Result<Option<DeactivateResult>>;\n-\n-    /// Marks a task as kept alive by the consumer graph\n-    /// (usually from memory to persisted graph)\n-    /// Returns true when activate_when_needed should be called soonish\n-    fn set_externally_active(&self, task: TaskId, api: &dyn PersistedGraphApi) -> Result<bool>;\n-\n-    /// No longer marks a task as kept alive by the consumer graph\n-    /// (usually from memory to persisted graph)\n-    /// Returns true when deactivate_when_needed should be called soonish\n-    fn unset_externally_active(&self, task: TaskId, api: &dyn PersistedGraphApi) -> Result<bool>;\n-\n-    /// Removes all external keep alives that were not renewed this round.\n-    /// This is usually called after the initial build has finished and all\n-    /// external keep alives has been renewed.\n-    fn remove_outdated_externally_active(\n-        &self,\n-        api: &dyn PersistedGraphApi,\n-    ) -> Result<SmallVec<[TaskId; 4]>>;\n-\n-    /// update the dirty flag for a stored task\n-    /// Returns true, when the task is active and should be scheduled\n-    fn make_dirty(&self, task: TaskId, api: &dyn PersistedGraphApi) -> Result<bool>;\n-\n-    /// update the dirty flag for a stored task\n-    fn make_clean(&self, task: TaskId, api: &dyn PersistedGraphApi) -> Result<()>;\n-\n-    /// make all tasks that depend on that vc dirty and\n-    /// return a list of active tasks that should be scheduled\n-    fn make_dependent_dirty(\n-        &self,\n-        vc: RawVc,\n-        api: &dyn PersistedGraphApi,\n-    ) -> Result<SmallVec<[TaskId; 4]>>;\n-\n-    /// Get all tasks that are active, but not persisted.\n-    /// This is usually called at beginning to create and schedule\n-    /// tasks that are missing in the persisted graph\n-    fn get_active_external_tasks(\n-        &self,\n-        api: &dyn PersistedGraphApi,\n-    ) -> Result<SmallVec<[TaskId; 4]>>;\n-\n-    /// Get all tasks that are dirty and active.\n-    /// This is usually called at the beginning to schedule these tasks.\n-    fn get_dirty_active_tasks(&self, api: &dyn PersistedGraphApi) -> Result<SmallVec<[TaskId; 4]>>;\n-\n-    /// Get tasks that have active update pending that need to be continued\n-    /// returns (tasks_to_activate, tasks_to_deactivate)\n-    fn get_pending_active_update(&self, api: &dyn PersistedGraphApi) -> Result<(TaskIds, TaskIds)>;\n-\n-    /// Stop operations\n-    #[allow(unused_variables)]\n-    fn stop(&self, api: &dyn PersistedGraphApi) -> Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-pub trait PersistedGraphApi {\n-    fn get_or_create_task_type(&self, ty: CachedTaskType) -> TaskId;\n-\n-    fn lookup_task_type(&self, id: TaskId) -> &CachedTaskType;\n-}\n-\n-/*\n-\n-read:\n-\n-  data: (TaskId) => (TaskData)\n-  cache: (CachedTaskType) => (TaskId)\n-  type: (TaskId) => (CachedTaskType)\n-\n-read_dependents:\n-\n-  dependents: (RawVc) => [TaskId]\n-\n-store:\n-\n-  external_active_parents: (TaskId) -> (usize)\n-  internal_active_parents: (TaskId) -> (usize)\n-  inactive_tasks: [TaskId]\n-\n-B+C?\n-\n-\n-\n-\n-*/\n-\n-impl PersistedGraph for () {\n-    fn read(\n-        &self,\n-        _task: TaskId,\n-        _api: &dyn PersistedGraphApi,\n-    ) -> Result<Option<(TaskData, ReadTaskState)>> {\n-        Ok(None)\n-    }\n-\n-    fn lookup(\n-        &self,\n-        _partial_task_type: &CachedTaskType,\n-        _api: &dyn PersistedGraphApi,\n-    ) -> Result<bool> {\n-        Ok(false)\n-    }\n-\n-    fn lookup_one(\n-        &self,\n-        _task_type: &CachedTaskType,\n-        _api: &dyn PersistedGraphApi,\n-    ) -> Result<Option<TaskId>> {\n-        Ok(None)\n-    }\n-\n-    fn is_persisted(&self, _task: TaskId, _api: &dyn PersistedGraphApi) -> Result<bool> {\n-        Ok(false)\n-    }\n-\n-    fn persist(\n-        &self,\n-        _task: TaskId,\n-        _data: TaskData,\n-        _state: PersistTaskState,\n-        _api: &dyn PersistedGraphApi,\n-    ) -> Result<Option<PersistResult>> {\n-        Ok(None)\n-    }\n-\n-    fn activate_when_needed(\n-        &self,\n-        _task: TaskId,\n-        _api: &dyn PersistedGraphApi,\n-    ) -> Result<Option<ActivateResult>> {\n-        Ok(None)\n-    }\n-\n-    fn deactivate_when_needed(\n-        &self,\n-        _task: TaskId,\n-        _api: &dyn PersistedGraphApi,\n-    ) -> Result<Option<DeactivateResult>> {\n-        Ok(None)\n-    }\n-\n-    fn set_externally_active(&self, _task: TaskId, _api: &dyn PersistedGraphApi) -> Result<bool> {\n-        Ok(false)\n-    }\n-\n-    fn unset_externally_active(&self, _task: TaskId, _api: &dyn PersistedGraphApi) -> Result<bool> {\n-        Ok(false)\n-    }\n-\n-    fn remove_outdated_externally_active(\n-        &self,\n-        _api: &dyn PersistedGraphApi,\n-    ) -> Result<SmallVec<[TaskId; 4]>> {\n-        Ok(Default::default())\n-    }\n-\n-    fn make_dirty(&self, _task: TaskId, _api: &dyn PersistedGraphApi) -> Result<bool> {\n-        Ok(false)\n-    }\n-\n-    fn make_clean(&self, _task: TaskId, _api: &dyn PersistedGraphApi) -> Result<()> {\n-        Ok(())\n-    }\n-\n-    fn make_dependent_dirty(\n-        &self,\n-        _vc: RawVc,\n-        _api: &dyn PersistedGraphApi,\n-    ) -> Result<SmallVec<[TaskId; 4]>> {\n-        Ok(Default::default())\n-    }\n-\n-    fn get_active_external_tasks(\n-        &self,\n-        _api: &dyn PersistedGraphApi,\n-    ) -> Result<SmallVec<[TaskId; 4]>> {\n-        Ok(Default::default())\n-    }\n-\n-    fn get_dirty_active_tasks(\n-        &self,\n-        _api: &dyn PersistedGraphApi,\n-    ) -> Result<SmallVec<[TaskId; 4]>> {\n-        Ok(Default::default())\n-    }\n-\n-    fn get_pending_active_update(\n-        &self,\n-        _api: &dyn PersistedGraphApi,\n-    ) -> Result<(SmallVec<[TaskId; 4]>, SmallVec<[TaskId; 4]>)> {\n-        Ok((Default::default(), Default::default()))\n-    }\n-}"
        }
    ],
    "stats": {
        "total": 403,
        "additions": 0,
        "deletions": 403
    }
}