{
    "author": "lukesandberg",
    "message": "Update turbopack to syn2 (#78385)\n\nUpdate turbopack to syn2\n\nThis delivers a number of basic API improvements and is required for us to adopt later rust editions.\n\nI confirmed correctness by diffing `cargo expand` on the turbopack  crate across this change. \n\nMost of the changes are trivial updating to new names and ast structures, the more interesting ones were some changes to the `self` types, which improves consistency but broke a number of places were were working around the prior inconsistency (previously bare `self` or `&self` declarations were represented as `FnArg::Receiver` but a _typed_ receiver like `self: Vc<Self>` was a `FnArg::Typed`, now `self` declarations are always `FnArg::Receiver`)\n\nCloses PACK-4383",
    "sha": "515d9c1ec98b69dfc106910c4431411f5f1f23ff",
    "files": [
        {
            "sha": "df9b6ce5c342189c55b158e74bc21fd95405bb5d",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 12,
            "deletions": 5,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -8593,6 +8593,12 @@ version = \"0.12.16\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"61c41af27dd6d1e27b1b16b489db798443478cef1f06a660c96db617ba5de3b1\"\n \n+[[package]]\n+name = \"target-triple\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1ac9aa371f599d22256307c24a9d748c041e548cbf599f35d890f9d365361790\"\n+\n [[package]]\n name = \"tempfile\"\n version = \"3.14.0\"\n@@ -9167,14 +9173,15 @@ checksum = \"3528ecfd12c466c6f163363caf2d02a71161dd5e1cc6ae7b34207ea2d42d81ed\"\n \n [[package]]\n name = \"trybuild\"\n-version = \"1.0.99\"\n+version = \"1.0.104\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"207aa50d36c4be8d8c6ea829478be44a372c6a77669937bb39c698e52f1491e8\"\n+checksum = \"6ae08be68c056db96f0e6c6dd820727cca756ced9e1f4cc7fdd20e2a55e23898\"\n dependencies = [\n  \"glob\",\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n+ \"target-triple\",\n  \"termcolor\",\n  \"toml 0.8.19\",\n ]\n@@ -9386,7 +9393,7 @@ dependencies = [\n  \"glob\",\n  \"quote\",\n  \"rustc-hash 2.1.0\",\n- \"syn 1.0.109\",\n+ \"syn 2.0.100\",\n  \"turbo-tasks-macros-shared\",\n ]\n \n@@ -9513,7 +9520,7 @@ dependencies = [\n  \"quote\",\n  \"regex\",\n  \"rustc-hash 2.1.0\",\n- \"syn 1.0.109\",\n+ \"syn 2.0.100\",\n  \"turbo-tasks-macros-shared\",\n ]\n \n@@ -9523,7 +9530,7 @@ version = \"0.1.0\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n- \"syn 1.0.109\",\n+ \"syn 2.0.100\",\n ]\n \n [[package]]"
        },
        {
            "sha": "fd2dbc695bee241968c61eeff6523d23ed004b53",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -410,7 +410,7 @@ sourcemap = \"9.0.0\"\n strsim = \"0.11.1\"\n shrink-to-fit = \"0.2.10\"\n swc-rustc-hash = { package = \"rustc-hash\", version = \"1.1.0\" } # used with swc\n-syn = \"1.0.107\"\n+syn = \"2.0.100\"\n tempfile = \"3.3.0\"\n thread_local = \"1.1.8\"\n thiserror = \"1.0.48\""
        },
        {
            "sha": "9629ec4a4e4265cbc5dbd8e9007bf1d7c1d7c583",
            "filename": "turbopack/crates/turbo-tasks-build/src/lib.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-build%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-build%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-build%2Fsrc%2Flib.rs?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -12,7 +12,7 @@ use quote::ToTokens;\n use rustc_hash::{FxHashMap, FxHashSet};\n use syn::{\n     parse_quote, Attribute, Ident, Item, ItemEnum, ItemFn, ItemImpl, ItemMacro, ItemMod,\n-    ItemStruct, ItemTrait, TraitItem, TraitItemMethod,\n+    ItemStruct, ItemTrait, TraitItem, TraitItemFn,\n };\n use turbo_tasks_macros_shared::{\n     get_impl_function_ident, get_native_function_ident, get_path_ident,\n@@ -286,7 +286,7 @@ impl RegisterContext<'_> {\n             }\n \n             for item in &impl_item.items {\n-                if let syn::ImplItem::Method(method_item) = item {\n+                if let syn::ImplItem::Fn(method_item) = item {\n                     // TODO: if method_item.attrs.iter().any(|a|\n                     // is_attribute(a,\n                     // \"function\")) {\n@@ -371,7 +371,7 @@ impl RegisterContext<'_> {\n             let trait_ident = &trait_item.ident;\n \n             for item in &trait_item.items {\n-                if let TraitItem::Method(TraitItemMethod {\n+                if let TraitItem::Fn(TraitItemFn {\n                     default: Some(_),\n                     sig,\n                     ..\n@@ -583,7 +583,7 @@ fn has_turbo_attribute(attrs: &[Attribute], name: &str) -> bool {\n }\n \n fn is_turbo_attribute(attr: &Attribute, name: &str) -> bool {\n-    let path = &attr.path;\n+    let path = attr.path();\n     if path.leading_colon.is_some() {\n         return false;\n     }\n@@ -598,7 +598,7 @@ fn is_turbo_attribute(attr: &Attribute, name: &str) -> bool {\n }\n \n fn is_cfg_attribute(attr: &Attribute) -> bool {\n-    attr.path\n+    attr.path()\n         .get_ident()\n         .is_some_and(|ident| ident == \"cfg\" || ident == \"cfg_attr\")\n }"
        },
        {
            "sha": "688fe1cdbd8e488343c59465be15d7f17ab8e150",
            "filename": "turbopack/crates/turbo-tasks-macros-shared/src/primitive_input.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fprimitive_input.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fprimitive_input.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fprimitive_input.rs?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -1,7 +1,6 @@\n use proc_macro2::Span;\n use syn::{\n     parse::{Parse, ParseStream},\n-    punctuated::Punctuated,\n     spanned::Spanned,\n     Meta, Result, Token, Type,\n };\n@@ -20,7 +19,7 @@ impl Parse for PrimitiveInput {\n             manual_shrink_to_fit: None,\n         };\n         if input.parse::<Option<Token![,]>>()?.is_some() {\n-            let punctuated: Punctuated<Meta, Token![,]> = input.parse_terminated(Meta::parse)?;\n+            let punctuated = input.parse_terminated(Meta::parse, Token![,])?;\n             for meta in punctuated {\n                 match (\n                     meta.path()"
        },
        {
            "sha": "323b8a9f00b8d8a649aeab591ab47d263af67a03",
            "filename": "turbopack/crates/turbo-tasks-macros-shared/src/value_trait_arguments.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fvalue_trait_arguments.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fvalue_trait_arguments.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fvalue_trait_arguments.rs?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -1,7 +1,6 @@\n use proc_macro2::Span;\n use syn::{\n     parse::{Parse, ParseStream},\n-    punctuated::Punctuated,\n     spanned::Spanned,\n     Meta, Token,\n };\n@@ -32,7 +31,7 @@ impl Parse for ValueTraitArguments {\n             return Ok(result);\n         }\n \n-        let punctuated: Punctuated<Meta, Token![,]> = input.parse_terminated(Meta::parse)?;\n+        let punctuated = input.parse_terminated(Meta::parse, Token![,])?;\n         for meta in punctuated {\n             match meta.path().get_ident().map(ToString::to_string).as_deref() {\n                 Some(\"no_debug\") => {"
        },
        {
            "sha": "4972d8970d9e4497b0f4eb5ca63ac46f70d10b66",
            "filename": "turbopack/crates/turbo-tasks-macros-tests/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2FCargo.toml?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -9,7 +9,7 @@ edition = \"2021\"\n anyhow = { workspace = true }\n serde = { workspace = true }\n tokio = { workspace = true }\n-trybuild = { version = \"1.0.97\" }\n+trybuild = { version = \"1.0.104\" }\n turbo-tasks = { workspace = true }\n turbo-tasks-testing = { workspace = true }\n turbo-tasks-memory = { workspace = true }"
        },
        {
            "sha": "7abfa9badd4fa0709675112f5fd8ca64851d332e",
            "filename": "turbopack/crates/turbo-tasks-macros-tests/tests/function/fail_operation_method_self_type.stderr",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_operation_method_self_type.stderr",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_operation_method_self_type.stderr",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_operation_method_self_type.stderr?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -13,7 +13,7 @@ error[E0307]: invalid `self` parameter type: `OperationVc<Foobar>`\n    = note: type of `self` must be `Self` or some type implementing `Receiver`\n    = help: consider changing to `self`, `&self`, `&mut self`, or a type implementing `Receiver` such as `self: Box<Self>`, `self: Rc<Self>`, or `self: Arc<Self>`\n \n-error[E0277]: the trait bound `fn(...) -> ... {...::arbitrary_self_type_turbo_tasks_function_inline}: IntoTaskFnWithThis<_, _, _>` is not satisfied\n+error[E0277]: the trait bound `fn(OperationVc<Foobar>) -> Vc<()> {Foobar::arbitrary_self_type_turbo_tasks_function_inline}: turbo_tasks::task::function::IntoTaskFnWithThis<_, _, _>` is not satisfied\n   --> tests/function/fail_operation_method_self_type.rs:10:1\n    |\n 10 | #[turbo_tasks::value_impl]\n@@ -29,5 +29,4 @@ note: required by a bound in `NativeFunction::new_method`\n ...\n    |         I: IntoTaskFnWithThis<Mode, This, Inputs>,\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `NativeFunction::new_method`\n-   = note: consider using `--verbose` to print the full type name to the console\n    = note: this error originates in the attribute macro `turbo_tasks::value_impl` (in Nightly builds, run with -Z macro-backtrace for more info)"
        },
        {
            "sha": "09588ee77e2d23d4c2b908d812fd78a52a35e062",
            "filename": "turbopack/crates/turbo-tasks-macros-tests/tests/function/fail_operation_method_self_type_base_vc.stderr",
            "status": "modified",
            "additions": 0,
            "deletions": 22,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_operation_method_self_type_base_vc.stderr",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_operation_method_self_type_base_vc.stderr",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_operation_method_self_type_base_vc.stderr?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -3,25 +3,3 @@ error: methods taking `self` are not supported with `operation`\n    |\n 13 |     fn arbitrary_self_type_base_vc(self: Vc<Self>) -> Vc<()> {\n    |                                    ^^^^^^^^^^^^^^\n-\n-error[E0277]: the trait bound `Vc<Foobar>: NonLocalValue` is not satisfied\n-  --> tests/function/fail_operation_method_self_type_base_vc.rs:13:42\n-   |\n-13 |     fn arbitrary_self_type_base_vc(self: Vc<Self>) -> Vc<()> {\n-   |                                          ^^^^^^^^ the trait `NonLocalValue` is not implemented for `Vc<Foobar>`\n-   |\n-   = help: the following other types implement trait `NonLocalValue`:\n-             &T\n-             &mut T\n-             ()\n-             (A, Z, Y, X, W, V, U, T)\n-             (B, A, Z, Y, X, W, V, U, T)\n-             (C, B, A, Z, Y, X, W, V, U, T)\n-             (D, C, B, A, Z, Y, X, W, V, U, T)\n-             (E, D, C, B, A, Z, Y, X, W, V, U, T)\n-           and $N others\n-note: required by a bound in `assert_argument_is_non_local_value`\n-  --> $WORKSPACE/turbopack/crates/turbo-tasks/src/macro_helpers.rs\n-   |\n-   | pub fn assert_argument_is_non_local_value<Argument: NonLocalValue>() {}\n-   |                                                     ^^^^^^^^^^^^^ required by this bound in `assert_argument_is_non_local_value`"
        },
        {
            "sha": "12865ce9942b7b651495e4aa0e04c6f5496eb3f3",
            "filename": "turbopack/crates/turbo-tasks-macros/src/derive/mod.rs",
            "status": "modified",
            "additions": 31,
            "deletions": 17,
            "changes": 48,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fderive%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fderive%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fderive%2Fmod.rs?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -11,7 +11,7 @@ pub use deterministic_hash_macro::derive_deterministic_hash;\n pub use key_value_pair_macro::derive_key_value_pair;\n pub use non_local_value_macro::derive_non_local_value;\n pub use operation_value_macro::derive_operation_value;\n-use syn::{spanned::Spanned, Attribute, Meta, MetaList, NestedMeta};\n+use syn::{punctuated::Punctuated, spanned::Spanned, Attribute, Meta, Token};\n pub use task_input_macro::derive_task_input;\n pub use trace_raw_vcs_macro::derive_trace_raw_vcs;\n pub use value_debug_format_macro::derive_value_debug_format;\n@@ -31,34 +31,48 @@ impl From<&[Attribute]> for FieldAttributes {\n \n         for attr in attrs {\n             if !attr\n-                .path\n+                .path()\n                 .get_ident()\n                 .map(|ident| *ident == \"turbo_tasks\")\n                 .unwrap_or_default()\n             {\n                 continue;\n             }\n-            if let Ok(Meta::List(MetaList { nested, .. })) = attr\n-                .parse_meta()\n-                .map_err(|err| err.span().unwrap().error(err.to_string()).emit())\n+            let nested = match attr.parse_args_with(Punctuated::<Meta, Token![,]>::parse_terminated)\n             {\n-                for meta in nested {\n-                    if let NestedMeta::Meta(Meta::Path(path)) = &meta {\n-                        match path.get_ident().map(|ident| ident.to_string()).as_deref() {\n-                            Some(\"trace_ignore\") => result.trace_ignore = true,\n-                            Some(\"debug_ignore\") => result.debug_ignore = true,\n-                            _ => path\n+                Ok(punctuated) => punctuated,\n+                Err(e) => {\n+                    attr.meta\n+                        .span()\n+                        .unwrap()\n+                        .error(format!(\n+                            \"expected `trace_ignore` or `debug_ignore`, got: {e}\"\n+                        ))\n+                        .emit();\n+                    Punctuated::default()\n+                }\n+            };\n+            for meta in nested {\n+                match meta {\n+                    Meta::Path(path) => {\n+                        if path.is_ident(\"trace_ignore\") {\n+                            result.trace_ignore = true;\n+                        } else if path.is_ident(\"debug_ignore\") {\n+                            result.debug_ignore = true;\n+                        } else {\n+                            path.span()\n                                 .span()\n                                 .unwrap()\n                                 .error(\"expected `trace_ignore` or `debug_ignore`\")\n-                                .emit(),\n+                                .emit()\n                         }\n-                    } else {\n-                        meta.span()\n-                            .unwrap()\n-                            .error(\"expected `trace_ignore` or `debug_ignore`\")\n-                            .emit();\n                     }\n+                    _ => meta\n+                        .path()\n+                        .span()\n+                        .unwrap()\n+                        .error(\"expected `trace_ignore` or `debug_ignore`\")\n+                        .emit(),\n                 }\n             }\n         }"
        },
        {
            "sha": "7795106626c43fc62b1536b6b3c9863e6fe3541d",
            "filename": "turbopack/crates/turbo-tasks-macros/src/func.rs",
            "status": "modified",
            "additions": 180,
            "deletions": 213,
            "changes": 393,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -4,16 +4,15 @@ use proc_macro2::{Ident, Span, TokenStream};\n use quote::{quote, quote_spanned, ToTokens};\n use rustc_hash::FxHashSet;\n use syn::{\n-    parenthesized,\n     parse::{Parse, ParseStream},\n     parse_quote, parse_quote_spanned,\n     punctuated::{Pair, Punctuated},\n     spanned::Spanned,\n-    token::Paren,\n     visit_mut::VisitMut,\n     AngleBracketedGenericArguments, Attribute, Block, Expr, ExprBlock, ExprPath, FnArg,\n-    GenericArgument, Local, Meta, Pat, PatIdent, PatType, Path, PathArguments, PathSegment,\n-    Receiver, ReturnType, Signature, Stmt, Token, Type, TypeGroup, TypePath, TypeTuple,\n+    GenericArgument, Local, LocalInit, Meta, Pat, PatIdent, PatType, Path, PathArguments,\n+    PathSegment, Receiver, ReturnType, Signature, Stmt, Token, Type, TypeGroup, TypePath,\n+    TypeTuple,\n };\n \n #[derive(Debug)]\n@@ -84,16 +83,16 @@ impl TurboFn<'_> {\n                     receiver @ Receiver {\n                         attrs,\n                         self_token,\n-                        reference,\n-                        mutability,\n+                        ty: self_type,\n+                        ..\n                     },\n                 ) => {\n                     if !attrs.is_empty() {\n                         receiver\n                             .span()\n                             .unwrap()\n                             .error(format!(\n-                                \"{} do not support attributes on arguments\",\n+                                \"{} do not support attributes on self\",\n                                 definition_context.function_type(),\n                             ))\n                             .emit();\n@@ -109,61 +108,53 @@ impl TurboFn<'_> {\n                         _ => &definition_context,\n                     };\n \n-                    if !attrs.is_empty() {\n-                        receiver\n-                            .span()\n-                            .unwrap()\n-                            .error(format!(\n-                                \"{} do not support attributes on self\",\n-                                definition_context.function_type(),\n-                            ))\n-                            .emit();\n-                        return None;\n-                    }\n-\n-                    if mutability.is_some() {\n-                        receiver\n-                            .span()\n-                            .unwrap()\n-                            .error(format!(\n-                                \"{} cannot take self by mutable reference, use &self or self: \\\n-                                 Vc<Self> instead\",\n-                                definition_context.function_type(),\n-                            ))\n-                            .emit();\n-                        return None;\n-                    }\n+                    match self_type.as_ref() {\n+                        // we allow `&Self` but not `&mut Self`\n+                        syn::Type::Reference(type_reference) => {\n+                            if let Some(m) = type_reference.mutability {\n+                                m.span()\n+                                    .unwrap()\n+                                    .error(format!(\n+                                        \"{} cannot take self by mutable reference, use &self or \\\n+                                         self: Vc<Self> instead\",\n+                                        definition_context.function_type(),\n+                                    ))\n+                                    .emit();\n+                                return None;\n+                            }\n \n-                    match &reference {\n-                        None => {\n-                            receiver\n-                                .span()\n-                                .unwrap()\n-                                .error(format!(\n-                                    \"{} cannot take self by value, use &self or self: Vc<Self> \\\n-                                     instead\",\n-                                    definition_context.function_type(),\n-                                ))\n-                                .emit();\n-                            return None;\n+                            match type_reference.elem.as_ref() {\n+                                syn::Type::Path(TypePath { qself: None, path })\n+                                    if path.is_ident(\"Self\") => {}\n+                                _ => {\n+                                    self_type\n+                                        .span()\n+                                        .unwrap()\n+                                        .error(\n+                                            \"Unexpected `self` type, use `&self` or `self: \\\n+                                             Vc<Self>\",\n+                                        )\n+                                        .emit();\n+                                    return None;\n+                                }\n+                            }\n                         }\n-                        Some((_, Some(lifetime))) => {\n-                            lifetime\n+                        syn::Type::Path(_) => {}\n+                        _ => {\n+                            self_type\n                                 .span()\n                                 .unwrap()\n-                                .error(format!(\n-                                    \"{} cannot take self by reference with a custom lifetime, use \\\n-                                     &self or self: Vc<Self> instead\",\n-                                    definition_context.function_type(),\n-                                ))\n+                                .error(\"Unexpected `self` type, use `&self` or `self: Vc<Self>\")\n                                 .emit();\n                             return None;\n                         }\n-                        _ => {}\n                     }\n+                    // We don't validate that the user provided a valid `turbo_tasks::Vc<Self>`\n+                    // here. We'll rely on the compiler to emit an error if the user provided an\n+                    // invalid receiver type\n \n                     this = Some(Input {\n-                        ident: Ident::new(\"self\", self_token.span()),\n+                        ident: Ident::from(*self_token),\n                         ty: parse_quote! { turbo_tasks::Vc<Self> },\n                     });\n                 }\n@@ -181,49 +172,27 @@ impl TurboFn<'_> {\n                     }\n \n                     if let Pat::Ident(ident) = &*typed.pat {\n-                        if ident.ident == \"self\" {\n-                            if let DefinitionContext::NakedFn = definition_context {\n-                                // The function is not associated. The compiler will emit an error\n-                                // on its own.\n+                        match definition_context {\n+                            DefinitionContext::NakedFn | DefinitionContext::ValueInherentImpl => {}\n+                            DefinitionContext::ValueTraitImpl | DefinitionContext::ValueTrait => {\n+                                typed\n+                                    .span()\n+                                    .unwrap()\n+                                    .error(format!(\n+                                        \"{} must accept &self or self: Vc<Self> as the first \\\n+                                         argument\",\n+                                        definition_context.function_type(),\n+                                    ))\n+                                    .emit();\n                                 return None;\n-                            };\n-\n-                            // We don't validate that the user provided a valid\n-                            // `turbo_tasks::Vc<Self>` here.\n-                            // We'll rely on the compiler to emit an error\n-                            // if the user provided an invalid receiver type\n-\n-                            let ident = ident.ident.clone();\n-\n-                            this = Some(Input {\n-                                ident,\n-                                ty: parse_quote! { turbo_tasks::Vc<Self> },\n-                            });\n-                        } else {\n-                            match definition_context {\n-                                DefinitionContext::NakedFn\n-                                | DefinitionContext::ValueInherentImpl => {}\n-                                DefinitionContext::ValueTraitImpl\n-                                | DefinitionContext::ValueTrait => {\n-                                    typed\n-                                        .span()\n-                                        .unwrap()\n-                                        .error(format!(\n-                                            \"{} must accept &self or self: Vc<Self> as the first \\\n-                                             argument\",\n-                                            definition_context.function_type(),\n-                                        ))\n-                                        .emit();\n-                                    return None;\n-                                }\n                             }\n-                            let ident = ident.ident.clone();\n-\n-                            exposed_inputs.push(Input {\n-                                ident,\n-                                ty: (*typed.ty).clone(),\n-                            });\n                         }\n+                        let ident = ident.ident.clone();\n+\n+                        exposed_inputs.push(Input {\n+                            ident,\n+                            ty: (*typed.ty).clone(),\n+                        });\n                     } else {\n                         // We can't support destructuring patterns (or other kinds of patterns).\n                         let ident = Ident::new(\"arg1\", typed.pat.span());\n@@ -359,83 +328,104 @@ impl TurboFn<'_> {\n                 inline_inputs_identifier_filter(&pat_id.ident)\n             })\n             .enumerate()\n-            .map(|(idx, arg)| match arg {\n-                FnArg::Receiver(_) => (arg.clone(), None),\n-                FnArg::Typed(pat_type) => {\n-                    if self.operation {\n-                        // operations shouldn't have their arguments rewritten, they require all\n-                        // arguments are explicitly `NonLocalValue`s\n-                        return (arg.clone(), None);\n-                    }\n-                    let Cow::Owned(expanded_ty) = expand_task_input_type(&pat_type.ty) else {\n-                        // common-case: skip if no type conversion is needed\n-                        return (arg.clone(), None);\n-                    };\n-\n-                    let arg_id = if let Pat::Ident(pat_id) = &*pat_type.pat {\n-                        // common case: argument is just an identifier\n-                        Cow::Borrowed(&pat_id.ident)\n-                    } else {\n-                        // argument is a pattern, we need to rewrite it to a unique identifier\n-                        Cow::Owned(Ident::new(\n-                            &format!(\"arg{idx}\"),\n-                            pat_type.span().resolved_at(Span::mixed_site()),\n-                        ))\n-                    };\n-\n-                    let arg = FnArg::Typed(PatType {\n-                        pat: Box::new(Pat::Ident(PatIdent {\n-                            attrs: Vec::new(),\n-                            by_ref: None,\n-                            mutability: None,\n-                            ident: arg_id.clone().into_owned(),\n-                            subpat: None,\n-                        })),\n-                        ty: Box::new(expanded_ty),\n-                        ..pat_type.clone()\n-                    });\n-\n-                    // We can't shadow `self` variables, so it this argument is a `self` argument,\n-                    // generate a new identifier, and rewrite the body of the function later to use\n-                    // that new identifier.\n-                    // NOTE: arbitrary self types aren't `FnArg::Receiver` on syn 1.x (fixed in 2.x)\n-                    let transform_pat = match &*pat_type.pat {\n-                        Pat::Ident(pat_id) if pat_id.ident == \"self\" => {\n-                            let shadow_self_id = Ident::new(\n-                                \"turbo_tasks_self\",\n-                                Span::mixed_site().located_at(pat_id.ident.span()),\n-                            );\n-                            shadow_self = Some(shadow_self_id.clone());\n-                            Pat::Ident(PatIdent {\n-                                ident: shadow_self_id,\n-                                ..pat_id.clone()\n-                            })\n-                        }\n-                        pat => pat.clone(),\n-                    };\n-\n-                    // convert an argument of type `FromTaskInput<T>::TaskInput` into `T`.\n-                    // essentially, replace any instances of `Vc` with `ResolvedVc`.\n-                    let orig_ty = &*pat_type.ty;\n-                    let transform_stmt = Some(Stmt::Local(Local {\n+            .map(|(idx, arg)| {\n+                if self.operation {\n+                    // operations shouldn't have their arguments rewritten, they require all\n+                    // arguments are explicitly `NonLocalValue`s\n+                    return (arg.clone(), None);\n+                }\n+                let (FnArg::Receiver(Receiver { ty, .. }) | FnArg::Typed(PatType { ty, .. })) = arg;\n+                let Cow::Owned(expanded_ty) = expand_task_input_type(ty) else {\n+                    // common-case: skip if no type conversion is needed\n+                    return (arg.clone(), None);\n+                };\n+                // Helper to produce the transform statement\n+                let transform_from_task_input = |arg_id: Cow<'_, Ident>, pat: Pat| {\n+                    Stmt::Local(Local {\n                         attrs: Vec::new(),\n                         let_token: Default::default(),\n-                        pat: transform_pat,\n-                        init: Some((\n-                            Default::default(),\n+                        pat,\n+                        init: Some(LocalInit {\n+                            eq_token: Default::default(),\n                             // we know the argument implements `FromTaskInput` because\n                             // `expand_task_input_type` returned `Cow::Owned`\n-                            parse_quote_spanned! {\n-                                pat_type.span() =>\n-                                <#orig_ty as turbo_tasks::task::FromTaskInput>::from_task_input(\n+                            expr: parse_quote_spanned! {\n+                                arg.span() =>\n+                                <#ty as turbo_tasks::task::FromTaskInput>::from_task_input(\n                                     #arg_id\n                                 )\n                             },\n-                        )),\n+                            diverge: None,\n+                        }),\n                         semi_token: Default::default(),\n-                    }));\n+                    })\n+                };\n+                match arg {\n+                    FnArg::Receiver(\n+                        receiver @ Receiver {\n+                            attrs, self_token, ..\n+                        },\n+                    ) => {\n+                        let arg = FnArg::Receiver(Receiver {\n+                            attrs: Vec::new(),\n+                            mutability: None,\n+                            ty: Box::new(expanded_ty),\n+                            ..receiver.clone()\n+                        });\n+\n+                        // We can't shadow `self` variables, so it this argument is a `self`\n+                        // argument, generate a new identifier, and rewrite\n+                        // the body of the function later to use\n+                        // that new identifier.\n+                        let shadow_self_id = Ident::new(\n+                            \"turbo_tasks_self\",\n+                            Span::mixed_site().located_at(self_token.span()),\n+                        );\n+                        shadow_self = Some(shadow_self_id.clone());\n+                        let shadow_self_pattern = Pat::Ident(PatIdent {\n+                            ident: shadow_self_id,\n+                            attrs: attrs.clone(),\n+                            mutability: None,\n+                            by_ref: None,\n+                            subpat: None,\n+                        });\n+                        let self_ident = Cow::Owned(Ident::new(\"self\", self_token.span()));\n+                        let transform_stmt =\n+                            transform_from_task_input(self_ident, shadow_self_pattern);\n+\n+                        (arg, Some(transform_stmt))\n+                    }\n+                    FnArg::Typed(pat_type) => {\n+                        let arg_id = if let Pat::Ident(pat_id) = &*pat_type.pat {\n+                            // common case: argument is just an identifier\n+                            Cow::Borrowed(&pat_id.ident)\n+                        } else {\n+                            // argument is a pattern, we need to rewrite it to a unique identifier\n+                            Cow::Owned(Ident::new(\n+                                &format!(\"arg{idx}\"),\n+                                pat_type.span().resolved_at(Span::mixed_site()),\n+                            ))\n+                        };\n+\n+                        let arg = FnArg::Typed(PatType {\n+                            pat: Box::new(Pat::Ident(PatIdent {\n+                                attrs: Vec::new(),\n+                                by_ref: None,\n+                                mutability: None,\n+                                ident: arg_id.clone().into_owned(),\n+                                subpat: None,\n+                            })),\n+                            ty: Box::new(expanded_ty),\n+                            ..pat_type.clone()\n+                        });\n \n-                    (arg, transform_stmt)\n+                        // convert an argument of type `FromTaskInput<T>::TaskInput` into `T`.\n+                        // essentially, replace any instances of `Vc` with `ResolvedVc`.\n+                        let pat = (*pat_type.pat).clone();\n+                        let transform_stmt = transform_from_task_input(arg_id, pat);\n+\n+                        (arg, Some(transform_stmt))\n+                    }\n                 }\n             })\n             .unzip();\n@@ -452,21 +442,25 @@ impl TurboFn<'_> {\n             Cow::Borrowed(orig_block)\n         } else {\n             let mut stmts = transform_stmts;\n-            stmts.push(Stmt::Expr(Expr::Block(ExprBlock {\n-                attrs: Vec::new(),\n-                label: None,\n-                block: if let Some(shadow_self) = shadow_self {\n-                    // if `self` is a `ResolvedVc<Self>`, we need to rewrite references to `self`\n-                    let mut block = orig_block.clone();\n-                    RewriteSelfVisitMut {\n-                        self_ident: shadow_self,\n-                    }\n-                    .visit_block_mut(&mut block);\n-                    block\n-                } else {\n-                    orig_block.clone()\n-                },\n-            })));\n+            stmts.push(Stmt::Expr(\n+                Expr::Block(ExprBlock {\n+                    attrs: Vec::new(),\n+                    label: None,\n+                    block: if let Some(shadow_self) = shadow_self {\n+                        // if `self` is a `ResolvedVc<Self>`, we need to rewrite references to\n+                        // `self`\n+                        let mut block = orig_block.clone();\n+                        RewriteSelfVisitMut {\n+                            self_ident: shadow_self,\n+                        }\n+                        .visit_block_mut(&mut block);\n+                        block\n+                    } else {\n+                        orig_block.clone()\n+                    },\n+                }),\n+                None,\n+            ));\n             Cow::Owned(Block {\n                 brace_token: Default::default(),\n                 stmts,\n@@ -706,42 +700,15 @@ enum IoMarker {\n     Network,\n }\n \n-/// Unwraps a parenthesized set of tokens.\n-///\n-/// Syn's lower-level [`parenthesized`] macro which this uses requires a\n-/// [`ParseStream`] and cannot be used with [`parse_macro_input`],\n-/// [`syn::parse2`] or anything else accepting a [`TokenStream`]. This can be\n-/// used with those [`TokenStream`]-based parsing APIs.\n-pub struct Parenthesized<T: Parse> {\n-    pub _paren_token: Paren,\n-    pub inner: T,\n-}\n-\n-impl<T: Parse> Parse for Parenthesized<T> {\n-    fn parse(input: ParseStream) -> syn::Result<Self> {\n-        let inner;\n-        Ok(Self {\n-            _paren_token: parenthesized!(inner in input),\n-            inner: <T>::parse(&inner)?,\n-        })\n-    }\n-}\n-\n-/// A newtype wrapper for [`Option<Parenthesized>`][Parenthesized] that\n-/// implements [`Parse`].\n-pub struct MaybeParenthesized<T: Parse> {\n-    pub parenthesized: Option<Parenthesized<T>>,\n-}\n-\n-impl<T: Parse> Parse for MaybeParenthesized<T> {\n-    fn parse(input: ParseStream) -> syn::Result<Self> {\n-        Ok(Self {\n-            parenthesized: if input.peek(Paren) {\n-                Some(Parenthesized::<T>::parse(input)?)\n-            } else {\n-                None\n-            },\n-        })\n+// Optionally parses `T` from a parethensized attributes, returns `T::default` otherwise.\n+pub fn parse_with_optional_parens<T: Parse + Default>(attr: &Attribute) -> syn::Result<T> {\n+    match &attr.meta {\n+        Meta::Path(_) => Ok(T::default()),\n+        Meta::List(meta) => meta.parse_args_with(T::parse),\n+        Meta::NameValue(meta) => Err(syn::Error::new(\n+            meta.eq_token.span,\n+            \"Expected parenthized parameters\",\n+        )),\n     }\n }\n \n@@ -769,7 +736,7 @@ pub struct FunctionArguments {\n impl Parse for FunctionArguments {\n     fn parse(input: ParseStream) -> syn::Result<Self> {\n         let mut parsed_args = FunctionArguments::default();\n-        let punctuated: Punctuated<Meta, Token![,]> = input.parse_terminated(Meta::parse)?;\n+        let punctuated = input.parse_terminated(Meta::parse, Token![,])?;\n         for meta in punctuated {\n             match (\n                 meta.path()\n@@ -1166,7 +1133,7 @@ pub fn filter_inline_attributes<'a>(\n     // inline functions use #[doc(hidden)], so it's not useful to preserve/duplicate docs\n     attrs\n         .into_iter()\n-        .filter(|attr| attr.path.get_ident().is_none_or(|id| id != \"doc\"))\n+        .filter(|attr| attr.path().get_ident().is_none_or(|id| id != \"doc\"))\n         .collect()\n }\n "
        },
        {
            "sha": "4444f5a0582734651260a48d53af26c1ded0e3f5",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_impl_macro.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 13,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -4,10 +4,9 @@ use quote::{quote, ToTokens};\n use syn::{\n     parse::{Parse, ParseStream},\n     parse_macro_input, parse_quote,\n-    punctuated::Punctuated,\n     spanned::Spanned,\n-    Attribute, Error, Generics, ImplItem, ImplItemMethod, ItemImpl, Lit, LitStr, Meta,\n-    MetaNameValue, Path, Result, Token, Type,\n+    Attribute, Error, Expr, ExprLit, Generics, ImplItem, ImplItemFn, ItemImpl, Lit, LitStr, Meta,\n+    MetaNameValue, Path, Token, Type,\n };\n use turbo_tasks_macros_shared::{\n     get_inherent_impl_function_id_ident, get_inherent_impl_function_ident, get_path_ident,\n@@ -16,12 +15,12 @@ use turbo_tasks_macros_shared::{\n };\n \n use crate::func::{\n-    filter_inline_attributes, DefinitionContext, FunctionArguments, MaybeParenthesized, NativeFn,\n-    TurboFn,\n+    filter_inline_attributes, parse_with_optional_parens, DefinitionContext, FunctionArguments,\n+    NativeFn, TurboFn,\n };\n \n fn is_attribute(attr: &Attribute, name: &str) -> bool {\n-    let path = &attr.path;\n+    let path = &attr.path();\n     if path.leading_colon.is_some() {\n         return false;\n     }\n@@ -45,8 +44,7 @@ fn split_function_attributes<'a>(\n         .partition(|attr| is_attribute(attr, \"function\"));\n     let func_args = if let Some(func_attr) = func_attrs_vec.first() {\n         if func_attrs_vec.len() == 1 {\n-            syn::parse2::<MaybeParenthesized<FunctionArguments>>(func_attr.tokens.clone())\n-                .map(|a| a.parenthesized.map(|a| a.inner).unwrap_or_default())\n+            parse_with_optional_parens::<FunctionArguments>(func_attr)\n         } else {\n             Err(syn::Error::new(\n                 func_attr.span(),\n@@ -67,9 +65,9 @@ struct ValueImplArguments {\n }\n \n impl Parse for ValueImplArguments {\n-    fn parse(input: ParseStream) -> Result<Self> {\n+    fn parse(input: ParseStream) -> syn::Result<Self> {\n         let mut result = ValueImplArguments { ident: None };\n-        let punctuated: Punctuated<Meta, Token![,]> = input.parse_terminated(Meta::parse)?;\n+        let punctuated = input.parse_terminated(Meta::parse, Token![,])?;\n         for meta in punctuated {\n             match (\n                 meta.path()\n@@ -82,7 +80,11 @@ impl Parse for ValueImplArguments {\n                 (\n                     \"ident\",\n                     Meta::NameValue(MetaNameValue {\n-                        lit: Lit::Str(lit), ..\n+                        value:\n+                            Expr::Lit(ExprLit {\n+                                lit: Lit::Str(lit), ..\n+                            }),\n+                        ..\n                     }),\n                 ) => {\n                     result.ident = Some(lit);\n@@ -109,7 +111,7 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n         let mut errors = Vec::new();\n \n         for item in items.iter() {\n-            if let ImplItem::Method(ImplItemMethod {\n+            if let ImplItem::Fn(ImplItemFn {\n                 attrs,\n                 vis,\n                 defaultness: _,\n@@ -212,7 +214,7 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n         let mut errors = Vec::new();\n \n         for item in items.iter() {\n-            if let ImplItem::Method(ImplItemMethod {\n+            if let ImplItem::Fn(ImplItemFn {\n                 sig, attrs, block, ..\n             }) = item\n             {"
        },
        {
            "sha": "f55d8f48412e43c4b7cba83a72f3b9d9d4204b5f",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_macro.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 8,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -7,10 +7,9 @@ use regex::Regex;\n use syn::{\n     parse::{Parse, ParseStream},\n     parse_macro_input, parse_quote,\n-    punctuated::Punctuated,\n     spanned::Spanned,\n-    Error, Fields, FieldsUnnamed, Generics, Item, ItemEnum, ItemStruct, Lit, LitStr, Meta,\n-    MetaNameValue, Result, Token,\n+    Error, Expr, ExprLit, Fields, FieldsUnnamed, Generics, Item, ItemEnum, ItemStruct, Lit, LitStr,\n+    Meta, MetaNameValue, Result, Token,\n };\n use turbo_tasks_macros_shared::{\n     get_register_value_type_ident, get_value_type_id_ident, get_value_type_ident,\n@@ -124,7 +123,7 @@ impl Parse for ValueArguments {\n             transparent: false,\n             operation: None,\n         };\n-        let punctuated: Punctuated<Meta, Token![,]> = input.parse_terminated(Meta::parse)?;\n+        let punctuated = input.parse_terminated(Meta::parse, Token![,])?;\n         for meta in punctuated {\n             match (\n                 meta.path()\n@@ -141,31 +140,47 @@ impl Parse for ValueArguments {\n                 (\n                     \"into\",\n                     Meta::NameValue(MetaNameValue {\n-                        lit: Lit::Str(str), ..\n+                        value:\n+                            Expr::Lit(ExprLit {\n+                                lit: Lit::Str(str), ..\n+                            }),\n+                        ..\n                     }),\n                 ) => {\n                     result.into_mode = IntoMode::try_from(str)?;\n                 }\n                 (\n                     \"serialization\",\n                     Meta::NameValue(MetaNameValue {\n-                        lit: Lit::Str(str), ..\n+                        value:\n+                            Expr::Lit(ExprLit {\n+                                lit: Lit::Str(str), ..\n+                            }),\n+                        ..\n                     }),\n                 ) => {\n                     result.serialization_mode = SerializationMode::try_from(str)?;\n                 }\n                 (\n                     \"cell\",\n                     Meta::NameValue(MetaNameValue {\n-                        lit: Lit::Str(str), ..\n+                        value:\n+                            Expr::Lit(ExprLit {\n+                                lit: Lit::Str(str), ..\n+                            }),\n+                        ..\n                     }),\n                 ) => {\n                     result.cell_mode = CellMode::try_from(str)?;\n                 }\n                 (\n                     \"eq\",\n                     Meta::NameValue(MetaNameValue {\n-                        lit: Lit::Str(str), ..\n+                        value:\n+                            Expr::Lit(ExprLit {\n+                                lit: Lit::Str(str), ..\n+                            }),\n+                        ..\n                     }),\n                 ) => {\n                     result.manual_eq = if str.value() == \"manual\" {"
        },
        {
            "sha": "395348e5d15a8e6c660c5aad86e6bd35be64cc05",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_trait_macro.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/515d9c1ec98b69dfc106910c4431411f5f1f23ff/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs?ref=515d9c1ec98b69dfc106910c4431411f5f1f23ff",
            "patch": "@@ -1,9 +1,7 @@\n use proc_macro::TokenStream;\n use proc_macro2::{Ident, TokenStream as TokenStream2};\n use quote::{quote, quote_spanned};\n-use syn::{\n-    parse_macro_input, parse_quote, spanned::Spanned, ItemTrait, TraitItem, TraitItemMethod,\n-};\n+use syn::{parse_macro_input, parse_quote, spanned::Spanned, ItemTrait, TraitItem, TraitItemFn};\n use turbo_tasks_macros_shared::{\n     get_trait_default_impl_function_id_ident, get_trait_default_impl_function_ident,\n     get_trait_type_id_ident, get_trait_type_ident, ValueTraitArguments,\n@@ -30,6 +28,7 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n         auto_token,\n         generics,\n         brace_token: _,\n+        restriction: _,\n     } = &item;\n \n     if unsafety.is_some() {\n@@ -70,7 +69,7 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n     let mut items = Vec::with_capacity(raw_items.len());\n \n     for item in raw_items.iter() {\n-        let TraitItem::Method(TraitItemMethod {\n+        let TraitItem::Fn(TraitItemFn {\n             sig,\n             default,\n             attrs,\n@@ -177,7 +176,7 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n             None\n         };\n \n-        items.push(TraitItem::Method(TraitItemMethod {\n+        items.push(TraitItem::Fn(TraitItemFn {\n             sig: turbo_fn.trait_signature(),\n             default,\n             attrs: attrs.clone(),"
        }
    ],
    "stats": {
        "total": 571,
        "additions": 275,
        "deletions": 296
    }
}