{
    "author": "lukesandberg",
    "message": "[turbopack] Improve our `const` compatible hash routine performance (#82088)\n\nThe explicit operators can apparently not be folded by the compiler.\n\nThis is the const compatible way to take a slice and convert a slice to an array... sigh.\n\nhttps://godbolt.org/z/Wedn7hWvb  shows the 3 possible implementations.\n\nThe `std` option appears worse than it really would in practice where the bounds checks could be eliminated, but pointer arithmetic gets the goods nonetheless.\n\nDiscovered this while trying to integrate my 'static `rcstr!`' fix into SWC.  It ended up failing for subtle reasons but the benchmarks did reveal a hash regression which we can at least fix on our side.",
    "sha": "0bcb25fcdb331320806361d568813c74cc1b5718",
    "files": [
        {
            "sha": "57f3ca63abba7b61f81decc6e9f1f7ea8b6b0adb",
            "filename": "turbopack/crates/turbo-rcstr/src/dynamic.rs",
            "status": "modified",
            "additions": 37,
            "deletions": 24,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/0bcb25fcdb331320806361d568813c74cc1b5718/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Fdynamic.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0bcb25fcdb331320806361d568813c74cc1b5718/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Fdynamic.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Fdynamic.rs?ref=0bcb25fcdb331320806361d568813c74cc1b5718",
            "patch": "@@ -172,24 +172,31 @@ const fn multiply_mix(x: u64, y: u64) -> u64 {\n     }\n }\n \n-// Const compatible helper function to read a u64 from a byte array at a given offset\n-const fn read_u64_le(bytes: &[u8], offset: usize) -> u64 {\n-    (bytes[offset] as u64)\n-        | ((bytes[offset + 1] as u64) << 8)\n-        | ((bytes[offset + 2] as u64) << 16)\n-        | ((bytes[offset + 3] as u64) << 24)\n-        | ((bytes[offset + 4] as u64) << 32)\n-        | ((bytes[offset + 5] as u64) << 40)\n-        | ((bytes[offset + 6] as u64) << 48)\n-        | ((bytes[offset + 7] as u64) << 56)\n+// Const compatible helper function to read a u64 from a byte array at a given\n+// offset\n+// SAFETY: The caller must ensure that `bytes.len() >= offset + 8`\n+#[inline(always)]\n+const unsafe fn read_u64_le(bytes: &[u8], offset: usize) -> u64 {\n+    debug_assert!(offset + 8 <= bytes.len());\n+    // Reinterpret the pointer as an array of length 8 at the given offset\n+    // SAFETY: it is our callers responsibility to ensure the offset is in range\n+    let array = unsafe { bytes.as_ptr().add(offset) } as *const [u8; 8];\n+    // SAFETY: this dereference is safe since we started with a reference (non-null) and an in range\n+    // offset (callers responsibility)\n+    u64::from_le_bytes(unsafe { *array })\n }\n \n-// Const compatible helper function to read a u32 from a byte array at a given offset\n-const fn read_u32_le(bytes: &[u8], offset: usize) -> u32 {\n-    (bytes[offset] as u32)\n-        | ((bytes[offset + 1] as u32) << 8)\n-        | ((bytes[offset + 2] as u32) << 16)\n-        | ((bytes[offset + 3] as u32) << 24)\n+// Const compatible helper function to read a u32 from a byte array at a given\n+// offset\n+// SAFETY: The caller must ensure that `bytes.len() >= offset + 4`\n+#[inline(always)]\n+const unsafe fn read_u32_le(bytes: &[u8], offset: usize) -> u32 {\n+    debug_assert!(offset + 4 <= bytes.len());\n+    // SAFETY: it is our callers responsibility to ensure the offset is in range\n+    let array = unsafe { bytes.as_ptr().add(offset) } as *const [u8; 4];\n+    // SAFETY: this dereference is safe since we started with a reference (non-null) and an in range\n+    // offset (callers responsibility)\n+    u32::from_le_bytes(unsafe { *array })\n }\n \n /// Copied from `hash_bytes` of `rustc-hash`.\n@@ -219,11 +226,13 @@ pub const fn hash_bytes(bytes: &[u8]) -> u64 {\n     if len <= 16 {\n         // XOR the input into s0, s1.\n         if len >= 8 {\n-            s0 ^= read_u64_le(bytes, 0);\n-            s1 ^= read_u64_le(bytes, len - 8);\n+            // SAFETY: we just checked that len is `>= 8` so these offsets are in range\n+            s0 ^= unsafe { read_u64_le(bytes, 0) };\n+            s1 ^= unsafe { read_u64_le(bytes, len - 8) };\n         } else if len >= 4 {\n-            s0 ^= read_u32_le(bytes, 0) as u64;\n-            s1 ^= read_u32_le(bytes, len - 4) as u64;\n+            // SAFETY: we just checked that len is `>= 4` so these offsets are in range\n+            s0 ^= unsafe { read_u32_le(bytes, 0) } as u64;\n+            s1 ^= unsafe { read_u32_le(bytes, len - 4) } as u64;\n         } else if len > 0 {\n             let lo = bytes[0];\n             let mid = bytes[len / 2];\n@@ -235,8 +244,10 @@ pub const fn hash_bytes(bytes: &[u8]) -> u64 {\n         // Handle bulk (can partially overlap with suffix).\n         let mut off = 0;\n         while off < len - 16 {\n-            let x = read_u64_le(bytes, off);\n-            let y = read_u64_le(bytes, off + 8);\n+            // SAFETY: we just checked that `off >= 16`` away from the end\n+            // so these offsets are in range.\n+            let x = unsafe { read_u64_le(bytes, off) };\n+            let y = unsafe { read_u64_le(bytes, off + 8) };\n \n             // Replace s1 with a mix of s0, x, and y, and s0 with s1.\n             // This ensures the compiler can unroll this loop into two\n@@ -250,8 +261,10 @@ pub const fn hash_bytes(bytes: &[u8]) -> u64 {\n             off += 16;\n         }\n \n-        s0 ^= read_u64_le(bytes, len - 16);\n-        s1 ^= read_u64_le(bytes, len - 8);\n+        // SAFETY:At this point `len >16` so both these sutractions are >0 and more than 8 away from\n+        // the end.`\n+        s0 ^= unsafe { read_u64_le(bytes, len - 16) };\n+        s1 ^= unsafe { read_u64_le(bytes, len - 8) };\n     }\n \n     multiply_mix(s0, s1) ^ (len as u64)"
        }
    ],
    "stats": {
        "total": 61,
        "additions": 37,
        "deletions": 24
    }
}