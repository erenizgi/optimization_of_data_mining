{
    "author": "sokra",
    "message": "Turbopack: make tracing nicer (#84263)\n\n### What?\n\nCleanup the info level spans and add missing top-level spans for all operations",
    "sha": "11f721eeda6e6c4133faa8e484491d03f7a06a62",
    "files": [
        {
            "sha": "bb41523648a9647c93a5f651663da902d9d99328",
            "filename": "crates/napi/src/next_api/endpoint.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fendpoint.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -121,8 +121,8 @@ async fn get_written_endpoint_with_issues_operation(\n     .cell())\n }\n \n+#[tracing::instrument(level = \"info\", name = \"write endpoint to disk\", skip_all)]\n #[napi]\n-#[tracing::instrument(skip_all)]\n pub async fn endpoint_write_to_disk(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Endpoint\\\" }\")] endpoint: External<ExternalEndpoint>,\n ) -> napi::Result<TurbopackResult<NapiWrittenEndpoint>> {\n@@ -155,6 +155,7 @@ pub async fn endpoint_write_to_disk(\n     })\n }\n \n+#[tracing::instrument(level = \"info\", name = \"get server-side endpoint changes\", skip_all)]\n #[napi(ts_return_type = \"{ __napiType: \\\"RootTask\\\" }\")]\n pub fn endpoint_server_changed_subscribe(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Endpoint\\\" }\")] endpoint: External<ExternalEndpoint>,\n@@ -245,6 +246,7 @@ async fn subscribe_issues_and_diags_operation(\n     }\n }\n \n+#[tracing::instrument(level = \"info\", name = \"get client-side endpoint changes\", skip_all)]\n #[napi(ts_return_type = \"{ __napiType: \\\"RootTask\\\" }\")]\n pub fn endpoint_client_changed_subscribe(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Endpoint\\\" }\")] endpoint: External<ExternalEndpoint>,"
        },
        {
            "sha": "bcad0ab9eca9cda3d8143986c29cb220801fe02c",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 144,
            "deletions": 132,
            "changes": 276,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -27,7 +27,7 @@ use next_core::tracing_presets::{\n use once_cell::sync::Lazy;\n use rand::Rng;\n use serde::{Deserialize, Serialize};\n-use tokio::{io::AsyncWriteExt, time::Instant};\n+use tokio::{io::AsyncWriteExt, runtime::Handle, time::Instant};\n use tracing::Instrument;\n use tracing_subscriber::{Registry, layer::SubscriberExt, util::SubscriberInitExt};\n use turbo_rcstr::{RcStr, rcstr};\n@@ -341,149 +341,157 @@ pub fn project_new(\n     napi_callbacks: NapiNextTurbopackCallbacksJsObject,\n ) -> napi::Result<JsObject> {\n     let napi_callbacks = NapiNextTurbopackCallbacks::from_js(napi_callbacks)?;\n-    env.spawn_future(async move {\n-        let (exit, exit_receiver) = ExitHandler::new_receiver();\n+    let (exit, exit_receiver) = ExitHandler::new_receiver();\n \n-        if let Some(dhat_profiler) = DhatProfilerGuard::try_init() {\n-            exit.on_exit(async move {\n-                tokio::task::spawn_blocking(move || drop(dhat_profiler))\n-                    .await\n-                    .unwrap()\n-            });\n-        }\n+    if let Some(dhat_profiler) = DhatProfilerGuard::try_init() {\n+        exit.on_exit(async move {\n+            tokio::task::spawn_blocking(move || drop(dhat_profiler))\n+                .await\n+                .unwrap()\n+        });\n+    }\n \n-        let mut trace = std::env::var(\"NEXT_TURBOPACK_TRACING\")\n-            .ok()\n-            .filter(|v| !v.is_empty());\n+    let mut trace = std::env::var(\"NEXT_TURBOPACK_TRACING\")\n+        .ok()\n+        .filter(|v| !v.is_empty());\n \n-        if cfg!(feature = \"tokio-console\") && trace.is_none() {\n-            // ensure `trace` is set to *something* so that the `tokio-console` feature works,\n-            // otherwise you just get empty output from `tokio-console`, which can be\n-            // confusing.\n-            trace = Some(\"overview\".to_owned());\n-        }\n+    if cfg!(feature = \"tokio-console\") && trace.is_none() {\n+        // ensure `trace` is set to *something* so that the `tokio-console` feature works,\n+        // otherwise you just get empty output from `tokio-console`, which can be\n+        // confusing.\n+        trace = Some(\"overview\".to_owned());\n+    }\n \n-        if let Some(mut trace) = trace {\n-            // Trace presets\n-            match trace.as_str() {\n-                \"overview\" | \"1\" => {\n-                    trace = TRACING_NEXT_OVERVIEW_TARGETS.join(\",\");\n-                }\n-                \"next\" => {\n-                    trace = TRACING_NEXT_TARGETS.join(\",\");\n-                }\n-                \"turbopack\" => {\n-                    trace = TRACING_NEXT_TURBOPACK_TARGETS.join(\",\");\n-                }\n-                \"turbo-tasks\" => {\n-                    trace = TRACING_NEXT_TURBO_TASKS_TARGETS.join(\",\");\n-                }\n-                _ => {}\n+    if let Some(mut trace) = trace {\n+        // Trace presets\n+        match trace.as_str() {\n+            \"overview\" | \"1\" => {\n+                trace = TRACING_NEXT_OVERVIEW_TARGETS.join(\",\");\n             }\n-\n-            let subscriber = Registry::default();\n-\n-            if cfg!(feature = \"tokio-console\") {\n-                trace = format!(\"{trace},tokio=trace,runtime=trace\");\n+            \"next\" => {\n+                trace = TRACING_NEXT_TARGETS.join(\",\");\n             }\n-            #[cfg(feature = \"tokio-console\")]\n-            let subscriber = subscriber.with(console_subscriber::spawn());\n+            \"turbopack\" => {\n+                trace = TRACING_NEXT_TURBOPACK_TARGETS.join(\",\");\n+            }\n+            \"turbo-tasks\" => {\n+                trace = TRACING_NEXT_TURBO_TASKS_TARGETS.join(\",\");\n+            }\n+            _ => {}\n+        }\n \n-            let subscriber = subscriber.with(FilterLayer::try_new(&trace).unwrap());\n+        let subscriber = Registry::default();\n \n-            let internal_dir = PathBuf::from(&options.root_path)\n-                .join(&options.project_path)\n-                .join(&options.dist_dir);\n-            std::fs::create_dir_all(&internal_dir)\n-                .context(\"Unable to create .next directory\")\n+        if cfg!(feature = \"tokio-console\") {\n+            trace = format!(\"{trace},tokio=trace,runtime=trace\");\n+        }\n+        #[cfg(feature = \"tokio-console\")]\n+        let subscriber = subscriber.with(console_subscriber::spawn());\n+\n+        let subscriber = subscriber.with(FilterLayer::try_new(&trace).unwrap());\n+\n+        let internal_dir = PathBuf::from(&options.root_path)\n+            .join(&options.project_path)\n+            .join(&options.dist_dir);\n+        std::fs::create_dir_all(&internal_dir)\n+            .context(\"Unable to create .next directory\")\n+            .unwrap();\n+        let trace_file = internal_dir.join(\"trace-turbopack\");\n+        let trace_writer = std::fs::File::create(trace_file.clone()).unwrap();\n+        let (trace_writer, trace_writer_guard) = TraceWriter::new(trace_writer);\n+        let subscriber = subscriber.with(RawTraceLayer::new(trace_writer));\n+\n+        exit.on_exit(async move {\n+            tokio::task::spawn_blocking(move || drop(trace_writer_guard))\n+                .await\n                 .unwrap();\n-            let trace_file = internal_dir.join(\"trace-turbopack\");\n-            let trace_writer = std::fs::File::create(trace_file.clone()).unwrap();\n-            let (trace_writer, trace_writer_guard) = TraceWriter::new(trace_writer);\n-            let subscriber = subscriber.with(RawTraceLayer::new(trace_writer));\n+        });\n \n-            exit.on_exit(async move {\n-                tokio::task::spawn_blocking(move || drop(trace_writer_guard))\n-                    .await\n-                    .unwrap();\n+        let trace_server = std::env::var(\"NEXT_TURBOPACK_TRACE_SERVER\").ok();\n+        if trace_server.is_some() {\n+            thread::spawn(move || {\n+                turbopack_trace_server::start_turbopack_trace_server(trace_file, None);\n             });\n+            println!(\"Turbopack trace server started. View trace at https://trace.nextjs.org\");\n+        }\n \n-            let trace_server = std::env::var(\"NEXT_TURBOPACK_TRACE_SERVER\").ok();\n-            if trace_server.is_some() {\n-                thread::spawn(move || {\n-                    turbopack_trace_server::start_turbopack_trace_server(trace_file, None);\n+        subscriber.init();\n+    }\n+\n+    env.spawn_future(\n+        async move {\n+            let memory_limit = turbo_engine_options\n+                .memory_limit\n+                .map(|m| m as usize)\n+                .unwrap_or(usize::MAX);\n+            let persistent_caching = turbo_engine_options.persistent_caching.unwrap_or_default();\n+            let dependency_tracking = turbo_engine_options.dependency_tracking.unwrap_or(true);\n+            let is_ci = turbo_engine_options.is_ci.unwrap_or(false);\n+            let is_short_session = turbo_engine_options.is_short_session.unwrap_or(false);\n+            let turbo_tasks = create_turbo_tasks(\n+                PathBuf::from(&options.dist_dir),\n+                persistent_caching,\n+                memory_limit,\n+                dependency_tracking,\n+                is_ci,\n+                is_short_session,\n+            )?;\n+            let turbopack_ctx = NextTurbopackContext::new(turbo_tasks.clone(), napi_callbacks);\n+\n+            if let Some(stats_path) = std::env::var_os(\"NEXT_TURBOPACK_TASK_STATISTICS\") {\n+                let task_stats = turbo_tasks.task_statistics().enable().clone();\n+                exit.on_exit(async move {\n+                    tokio::task::spawn_blocking(move || {\n+                        let mut file = std::fs::File::create(&stats_path)\n+                            .with_context(|| format!(\"failed to create or open {stats_path:?}\"))?;\n+                        serde_json::to_writer(&file, &task_stats)\n+                            .context(\"failed to serialize or write task statistics\")?;\n+                        file.flush().context(\"failed to flush file\")\n+                    })\n+                    .await\n+                    .unwrap()\n+                    .unwrap();\n                 });\n-                println!(\"Turbopack trace server started. View trace at https://trace.nextjs.org\");\n             }\n \n-            subscriber.init();\n-        }\n-\n-        let memory_limit = turbo_engine_options\n-            .memory_limit\n-            .map(|m| m as usize)\n-            .unwrap_or(usize::MAX);\n-        let persistent_caching = turbo_engine_options.persistent_caching.unwrap_or_default();\n-        let dependency_tracking = turbo_engine_options.dependency_tracking.unwrap_or(true);\n-        let is_ci = turbo_engine_options.is_ci.unwrap_or(false);\n-        let is_short_session = turbo_engine_options.is_short_session.unwrap_or(false);\n-        let turbo_tasks = create_turbo_tasks(\n-            PathBuf::from(&options.dist_dir),\n-            persistent_caching,\n-            memory_limit,\n-            dependency_tracking,\n-            is_ci,\n-            is_short_session,\n-        )?;\n-        let turbopack_ctx = NextTurbopackContext::new(turbo_tasks.clone(), napi_callbacks);\n-\n-        if let Some(stats_path) = std::env::var_os(\"NEXT_TURBOPACK_TASK_STATISTICS\") {\n-            let task_stats = turbo_tasks.task_statistics().enable().clone();\n-            exit.on_exit(async move {\n-                tokio::task::spawn_blocking(move || {\n-                    let mut file = std::fs::File::create(&stats_path)\n-                        .with_context(|| format!(\"failed to create or open {stats_path:?}\"))?;\n-                    serde_json::to_writer(&file, &task_stats)\n-                        .context(\"failed to serialize or write task statistics\")?;\n-                    file.flush().context(\"failed to flush file\")\n+            let options: ProjectOptions = options.into();\n+            let container = turbo_tasks\n+                .run(async move {\n+                    let project = ProjectContainer::new(rcstr!(\"next.js\"), options.dev);\n+                    let project = project.to_resolved().await?;\n+                    project.initialize(options).await?;\n+                    Ok(project)\n                 })\n-                .await\n-                .unwrap()\n-                .unwrap();\n-            });\n-        }\n-\n-        let options: ProjectOptions = options.into();\n-        let container = turbo_tasks\n-            .run(async move {\n-                let project = ProjectContainer::new(rcstr!(\"next.js\"), options.dev);\n-                let project = project.to_resolved().await?;\n-                project.initialize(options).await?;\n-                Ok(project)\n-            })\n-            .or_else(|e| turbopack_ctx.throw_turbopack_internal_result(&e.into()))\n-            .await?;\n+                .or_else(|e| turbopack_ctx.throw_turbopack_internal_result(&e.into()))\n+                .await?;\n \n-        turbo_tasks.start_once_process({\n-            let tt = turbo_tasks.clone();\n-            Box::pin(async move {\n-                let future = async move {\n-                    benchmark_file_io(tt, container.project().node_root().owned().await?).await\n-                };\n-                if let Err(err) = future.await {\n-                    // TODO Not ideal to print directly to stdout.\n-                    // We should use a compilation event instead to report async errors.\n-                    println!(\"Failed to benchmark file IO: {err}\");\n+            Handle::current().spawn({\n+                let tt = turbo_tasks.clone();\n+                async move {\n+                    let result = tt\n+                        .clone()\n+                        .run(async move {\n+                            benchmark_file_io(tt, container.project().node_root().owned().await?)\n+                                .await\n+                        })\n+                        .await;\n+                    if let Err(err) = result {\n+                        // TODO Not ideal to print directly to stdout.\n+                        // We should use a compilation event instead to report async errors.\n+                        println!(\"Failed to benchmark file I/O: {err}\");\n+                    }\n                 }\n-            })\n-        });\n+                .instrument(tracing::info_span!(\"benchmark file I/O\"))\n+            });\n \n-        Ok(External::new(ProjectInstance {\n-            turbopack_ctx,\n-            container,\n-            exit_receiver: tokio::sync::Mutex::new(Some(exit_receiver)),\n-        }))\n-    })\n+            Ok(External::new(ProjectInstance {\n+                turbopack_ctx,\n+                container,\n+                exit_receiver: tokio::sync::Mutex::new(Some(exit_receiver)),\n+            }))\n+        }\n+        .instrument(tracing::info_span!(\"create project\")),\n+    )\n }\n \n #[derive(Debug, Clone, Serialize)]\n@@ -522,7 +530,6 @@ impl CompilationEvent for SlowFilesystemEvent {\n /// This idea is copied from Bun:\n /// - https://x.com/jarredsumner/status/1637549427677364224\n /// - https://github.com/oven-sh/bun/blob/06a9aa80c38b08b3148bfeabe560/src/install/install.zig#L3038\n-#[tracing::instrument(skip(turbo_tasks))]\n async fn benchmark_file_io(turbo_tasks: NextTurboTasks, directory: FileSystemPath) -> Result<()> {\n     // try to get the real file path on disk so that we can use it with tokio\n     let fs = ResolvedVc::try_downcast_type::<DiskFileSystem>(directory.fs)\n@@ -544,7 +551,7 @@ async fn benchmark_file_io(turbo_tasks: NextTurboTasks, directory: FileSystemPat\n     // additional noise/overhead of tasks caching, invalidation, file locks,\n     // etc.\n     let start = Instant::now();\n-    async move {\n+    async {\n         for _ in 0..3 {\n             // create a new empty file\n             let mut file = tokio::fs::File::create(&temp_path).await?;\n@@ -557,7 +564,7 @@ async fn benchmark_file_io(turbo_tasks: NextTurboTasks, directory: FileSystemPat\n         }\n         anyhow::Ok(())\n     }\n-    .instrument(tracing::info_span!(\"benchmark file IO (measurement)\"))\n+    .instrument(tracing::info_span!(\"benchmark file IO (measurement)\", path = %temp_path.display()))\n     .await?;\n \n     let duration = Instant::now().duration_since(start);\n@@ -571,6 +578,7 @@ async fn benchmark_file_io(turbo_tasks: NextTurboTasks, directory: FileSystemPat\n     Ok(())\n }\n \n+#[tracing::instrument(level = \"info\", name = \"update project\", skip_all)]\n #[napi]\n pub async fn project_update(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n@@ -633,6 +641,7 @@ async fn project_on_exit_internal(project: &ProjectInstance) {\n /// This is used in builds where it's important that we completely persist turbo-tasks to disk, but\n /// it's skipped in the development server (`project_on_exit` is used instead with a short timeout),\n /// where we prioritize fast exit and user responsiveness over all else.\n+#[tracing::instrument(level = \"info\", name = \"shutdown project\", skip_all)]\n #[napi]\n pub async fn project_shutdown(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n@@ -874,6 +883,7 @@ struct AllWrittenEntrypointsWithIssues {\n     effects: Arc<Effects>,\n }\n \n+#[tracing::instrument(level = \"info\", name = \"write all entrypoints to disk\", skip_all)]\n #[napi]\n pub async fn project_write_all_entrypoints_to_disk(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n@@ -988,6 +998,7 @@ async fn output_assets_operation(\n     ))\n }\n \n+#[tracing::instrument(level = \"info\", name = \"get entrypoints\", skip_all)]\n #[napi(ts_return_type = \"{ __napiType: \\\"RootTask\\\" }\")]\n pub fn project_entrypoints_subscribe(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n@@ -1066,6 +1077,7 @@ fn project_hmr_update_operation(\n     project.hmr_update(identifier, *state)\n }\n \n+#[tracing::instrument(level = \"info\", name = \"get HMR events\", skip(project, func))]\n #[napi(ts_return_type = \"{ __napiType: \\\"RootTask\\\" }\")]\n pub fn project_hmr_events(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n@@ -1111,10 +1123,6 @@ pub fn project_hmr_events(\n                     }\n                     Ok((Some(update.clone()), issues.clone(), diagnostics.clone()))\n                 }\n-                .instrument(tracing::info_span!(\n-                    \"HMR subscription\",\n-                    identifier = %outer_identifier\n-                ))\n             }\n         },\n         move |ctx| {\n@@ -1192,6 +1200,7 @@ fn project_container_hmr_identifiers_operation(\n     container.hmr_identifiers()\n }\n \n+#[tracing::instrument(level = \"info\", name = \"get HMR identifiers\", skip_all)]\n #[napi(ts_return_type = \"{ __napiType: \\\"RootTask\\\" }\")]\n pub fn project_hmr_identifiers_subscribe(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n@@ -1570,6 +1579,7 @@ pub async fn project_trace_source_operation(\n     })))\n }\n \n+#[tracing::instrument(level = \"info\", name = \"apply SourceMap to stack frame\", skip_all)]\n #[napi]\n pub async fn project_trace_source(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n@@ -1596,6 +1606,7 @@ pub async fn project_trace_source(\n         .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e.into()).to_string()))\n }\n \n+#[tracing::instrument(level = \"info\", name = \"get source content for asset\", skip_all)]\n #[napi]\n pub async fn project_get_source_for_asset(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,\n@@ -1629,6 +1640,7 @@ pub async fn project_get_source_for_asset(\n         .map_err(|e| napi::Error::from_reason(PrettyPrintError(&e.into()).to_string()))\n }\n \n+#[tracing::instrument(level = \"info\", name = \"get SourceMap for asset\", skip_all)]\n #[napi]\n pub async fn project_get_source_map(\n     #[napi(ts_arg_type = \"{ __napiType: \\\"Project\\\" }\")] project: External<ProjectInstance>,"
        },
        {
            "sha": "54cde1e7d7929337e31943c4573109b83c48971f",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -1993,7 +1993,6 @@ impl Endpoint for AppEndpoint {\n                     .await?;\n                 let client_paths = all_paths_in_root(output_assets, client_relative_root)\n                     .owned()\n-                    .instrument(tracing::info_span!(\"client_paths\"))\n                     .await?;\n                 (server_paths, client_paths)\n             } else {"
        },
        {
            "sha": "8afabc9a64f0ee47df4ae5c91f29c481407f09bb",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -511,7 +511,7 @@ type FxModuleNameMap = FxIndexMap<ResolvedVc<Box<dyn Module>>, RcStr>;\n #[turbo_tasks::value(transparent)]\n struct ModuleNameMap(pub FxModuleNameMap);\n \n-#[tracing::instrument(level = tracing::Level::INFO, name = \"validate pages css imports\", skip_all)]\n+#[tracing::instrument(level = \"info\", name = \"validate pages css imports\", skip_all)]\n #[turbo_tasks::function]\n async fn validate_pages_css_imports(\n     graph: Vc<SingleModuleGraph>,"
        },
        {
            "sha": "b156eda22d6f3a69a28bf276abaf5f0c10624dd5",
            "filename": "crates/next-api/src/nft_json.rs",
            "status": "modified",
            "additions": 184,
            "deletions": 176,
            "changes": 360,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fnft_json.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -2,7 +2,7 @@ use std::collections::{BTreeSet, VecDeque};\n \n use anyhow::{Result, bail};\n use serde_json::json;\n-use tracing::{Level, Span};\n+use tracing::{Instrument, Level, Span};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     FxIndexMap, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n@@ -144,204 +144,212 @@ impl Asset for NftJsonAsset {\n     #[turbo_tasks::function]\n     async fn content(self: Vc<Self>) -> Result<Vc<AssetContent>> {\n         let this = &*self.await?;\n-        let mut result: BTreeSet<RcStr> = BTreeSet::new();\n-\n-        let output_root_ref = this.project.output_fs().root().await?;\n-        let project_root_ref = this.project.project_fs().root().await?;\n-        let next_config = this.project.next_config();\n-\n-        let output_file_tracing_includes = &*next_config.output_file_tracing_includes().await?;\n-        let output_file_tracing_excludes = &*next_config.output_file_tracing_excludes().await?;\n-\n-        let client_root = this.project.client_fs().root();\n-        let client_root = client_root.owned().await?;\n-\n-        // [project]/\n-        let project_root_path = this.project.project_root_path().owned().await?;\n-        // Example: [output]/apps/my-website/.next/server/app -- without the `page.js.nft.json`\n-        let ident_folder = self.path().await?.parent();\n-        // Example: [project]/apps/my-website/.next/server/app -- without the `page.js.nft.json`\n-        let ident_folder_in_project_fs = project_root_path.join(&ident_folder.path)?;\n-\n-        let chunk = this.chunk;\n-        let entries = this\n-            .additional_assets\n-            .iter()\n-            .copied()\n-            .chain(std::iter::once(chunk))\n-            .collect();\n-\n-        let project_path = this.project.project_path().owned().await?;\n-        let exclude_glob = if let Some(route) = &this.page_name {\n-            if let Some(excludes_config) = output_file_tracing_excludes {\n-                let mut combined_excludes = BTreeSet::new();\n-\n-                if let Some(excludes_obj) = excludes_config.as_object() {\n-                    for (glob_pattern, exclude_patterns) in excludes_obj {\n-                        // Check if the route matches the glob pattern\n-                        let glob = Glob::new(\n-                            RcStr::from(glob_pattern.clone()),\n-                            GlobOptions { contains: true },\n-                        )\n-                        .await?;\n-                        if glob.matches(route)\n-                            && let Some(patterns) = exclude_patterns.as_array()\n-                        {\n-                            for pattern in patterns {\n-                                if let Some(pattern_str) = pattern.as_str() {\n-                                    let (glob, root) =\n-                                        relativize_glob(pattern_str, project_path.clone())?;\n-                                    let glob = if root.path.is_empty() {\n-                                        glob.to_string()\n-                                    } else {\n-                                        format!(\"{root}/{glob}\")\n-                                    };\n-                                    combined_excludes.insert(glob);\n+        let span = tracing::info_span!(\n+            \"output file tracing\",\n+            path = display(self.path().to_string().await?)\n+        );\n+        async move {\n+            let mut result: BTreeSet<RcStr> = BTreeSet::new();\n+\n+            let output_root_ref = this.project.output_fs().root().await?;\n+            let project_root_ref = this.project.project_fs().root().await?;\n+            let next_config = this.project.next_config();\n+\n+            let output_file_tracing_includes = &*next_config.output_file_tracing_includes().await?;\n+            let output_file_tracing_excludes = &*next_config.output_file_tracing_excludes().await?;\n+\n+            let client_root = this.project.client_fs().root();\n+            let client_root = client_root.owned().await?;\n+\n+            // [project]/\n+            let project_root_path = this.project.project_root_path().owned().await?;\n+            // Example: [output]/apps/my-website/.next/server/app -- without the `page.js.nft.json`\n+            let ident_folder = self.path().await?.parent();\n+            // Example: [project]/apps/my-website/.next/server/app -- without the `page.js.nft.json`\n+            let ident_folder_in_project_fs = project_root_path.join(&ident_folder.path)?;\n+\n+            let chunk = this.chunk;\n+            let entries = this\n+                .additional_assets\n+                .iter()\n+                .copied()\n+                .chain(std::iter::once(chunk))\n+                .collect();\n+\n+            let project_path = this.project.project_path().owned().await?;\n+            let exclude_glob = if let Some(route) = &this.page_name {\n+                if let Some(excludes_config) = output_file_tracing_excludes {\n+                    let mut combined_excludes = BTreeSet::new();\n+\n+                    if let Some(excludes_obj) = excludes_config.as_object() {\n+                        for (glob_pattern, exclude_patterns) in excludes_obj {\n+                            // Check if the route matches the glob pattern\n+                            let glob = Glob::new(\n+                                RcStr::from(glob_pattern.clone()),\n+                                GlobOptions { contains: true },\n+                            )\n+                            .await?;\n+                            if glob.matches(route)\n+                                && let Some(patterns) = exclude_patterns.as_array()\n+                            {\n+                                for pattern in patterns {\n+                                    if let Some(pattern_str) = pattern.as_str() {\n+                                        let (glob, root) =\n+                                            relativize_glob(pattern_str, project_path.clone())?;\n+                                        let glob = if root.path.is_empty() {\n+                                            glob.to_string()\n+                                        } else {\n+                                            format!(\"{root}/{glob}\")\n+                                        };\n+                                        combined_excludes.insert(glob);\n+                                    }\n                                 }\n                             }\n                         }\n                     }\n-                }\n \n-                if combined_excludes.is_empty() {\n-                    None\n+                    if combined_excludes.is_empty() {\n+                        None\n+                    } else {\n+                        let glob = Glob::new(\n+                            format!(\n+                                \"{{{}}}\",\n+                                combined_excludes\n+                                    .iter()\n+                                    .map(|s| s.as_str())\n+                                    .collect::<Vec<_>>()\n+                                    .join(\",\")\n+                            )\n+                            .into(),\n+                            GlobOptions { contains: true },\n+                        );\n+\n+                        Some(glob)\n+                    }\n                 } else {\n-                    let glob = Glob::new(\n-                        format!(\n-                            \"{{{}}}\",\n-                            combined_excludes\n-                                .iter()\n-                                .map(|s| s.as_str())\n-                                .collect::<Vec<_>>()\n-                                .join(\",\")\n-                        )\n-                        .into(),\n-                        GlobOptions { contains: true },\n-                    );\n-\n-                    Some(glob)\n+                    None\n                 }\n             } else {\n                 None\n-            }\n-        } else {\n-            None\n-        };\n-\n-        // Collect base assets first\n-        for referenced_chunk in\n-            all_assets_from_entries_filtered(Vc::cell(entries), Some(client_root), exclude_glob)\n-                .await?\n-        {\n-            if chunk.eq(referenced_chunk) {\n-                continue;\n-            }\n-\n-            let referenced_chunk_path = referenced_chunk.path().await?;\n-            if referenced_chunk_path.has_extension(\".map\") {\n-                continue;\n-            }\n+            };\n \n-            #[cfg(debug_assertions)]\n+            // Collect base assets first\n+            for referenced_chunk in\n+                all_assets_from_entries_filtered(Vc::cell(entries), Some(client_root), exclude_glob)\n+                    .await?\n             {\n-                // Verify that we there are no entries where a file is created inside of a symlink,\n-                // as this can result in invalid ZIP files and deployment failures.\n-                // For example\n-                // node_modules/.pnpm/node_modules/@libsql/client/package.json\n-                // where\n-                // node_modules/.pnpm/node_modules/@libsql/client is a symlink\n-                let mut current_path = referenced_chunk_path.parent();\n-                loop {\n-                    use turbo_tasks_fs::FileSystemEntryType;\n-\n-                    if current_path.is_root() {\n-                        break;\n-                    }\n-\n-                    if matches!(\n-                        &*current_path.get_type().await?,\n-                        FileSystemEntryType::Symlink\n-                    ) {\n-                        bail!(\n-                            \"Encountered file inside of symlink in NFT list: {} is a symlink, but \\\n-                             {} was created inside of it\",\n-                            current_path.value_to_string().await?,\n-                            referenced_chunk_path.value_to_string().await?\n-                        );\n-                    }\n+                if chunk.eq(referenced_chunk) {\n+                    continue;\n+                }\n \n-                    current_path = current_path.parent();\n+                let referenced_chunk_path = referenced_chunk.path().await?;\n+                if referenced_chunk_path.has_extension(\".map\") {\n+                    continue;\n                 }\n-            }\n \n-            let Some(specifier) = get_output_specifier(\n-                &referenced_chunk_path,\n-                &ident_folder,\n-                &ident_folder_in_project_fs,\n-                &output_root_ref,\n-                &project_root_ref,\n-            )?\n-            else {\n-                continue;\n-            };\n+                #[cfg(debug_assertions)]\n+                {\n+                    // Verify that we there are no entries where a file is created inside of a\n+                    // symlink, as this can result in invalid ZIP files and\n+                    // deployment failures. For example\n+                    // node_modules/.pnpm/node_modules/@libsql/client/package.json\n+                    // where\n+                    // node_modules/.pnpm/node_modules/@libsql/client is a symlink\n+                    let mut current_path = referenced_chunk_path.parent();\n+                    loop {\n+                        use turbo_tasks_fs::FileSystemEntryType;\n+\n+                        if current_path.is_root() {\n+                            break;\n+                        }\n \n-            result.insert(specifier);\n-        }\n+                        if matches!(\n+                            &*current_path.get_type().await?,\n+                            FileSystemEntryType::Symlink\n+                        ) {\n+                            bail!(\n+                                \"Encountered file inside of symlink in NFT list: {} is a symlink, \\\n+                                 but {} was created inside of it\",\n+                                current_path.value_to_string().await?,\n+                                referenced_chunk_path.value_to_string().await?\n+                            );\n+                        }\n+\n+                        current_path = current_path.parent();\n+                    }\n+                }\n \n-        // Apply outputFileTracingIncludes and outputFileTracingExcludes\n-        // Extract route from chunk path for pattern matching\n-        if let Some(route) = &this.page_name {\n-            let mut combined_includes_by_root: FxIndexMap<FileSystemPath, Vec<&str>> =\n-                FxIndexMap::default();\n+                let Some(specifier) = get_output_specifier(\n+                    &referenced_chunk_path,\n+                    &ident_folder,\n+                    &ident_folder_in_project_fs,\n+                    &output_root_ref,\n+                    &project_root_ref,\n+                )?\n+                else {\n+                    continue;\n+                };\n+\n+                result.insert(specifier);\n+            }\n \n-            // Process includes\n-            if let Some(includes_config) = output_file_tracing_includes\n-                && let Some(includes_obj) = includes_config.as_object()\n-            {\n-                for (glob_pattern, include_patterns) in includes_obj {\n-                    // Check if the route matches the glob pattern\n-                    let glob =\n-                        Glob::new(glob_pattern.as_str().into(), GlobOptions { contains: true })\n-                            .await?;\n-                    if glob.matches(route)\n-                        && let Some(patterns) = include_patterns.as_array()\n-                    {\n-                        for pattern in patterns {\n-                            if let Some(pattern_str) = pattern.as_str() {\n-                                let (glob, root) =\n-                                    relativize_glob(pattern_str, project_path.clone())?;\n-                                combined_includes_by_root\n-                                    .entry(root)\n-                                    .or_default()\n-                                    .push(glob);\n+            // Apply outputFileTracingIncludes and outputFileTracingExcludes\n+            // Extract route from chunk path for pattern matching\n+            if let Some(route) = &this.page_name {\n+                let mut combined_includes_by_root: FxIndexMap<FileSystemPath, Vec<&str>> =\n+                    FxIndexMap::default();\n+\n+                // Process includes\n+                if let Some(includes_config) = output_file_tracing_includes\n+                    && let Some(includes_obj) = includes_config.as_object()\n+                {\n+                    for (glob_pattern, include_patterns) in includes_obj {\n+                        // Check if the route matches the glob pattern\n+                        let glob =\n+                            Glob::new(glob_pattern.as_str().into(), GlobOptions { contains: true })\n+                                .await?;\n+                        if glob.matches(route)\n+                            && let Some(patterns) = include_patterns.as_array()\n+                        {\n+                            for pattern in patterns {\n+                                if let Some(pattern_str) = pattern.as_str() {\n+                                    let (glob, root) =\n+                                        relativize_glob(pattern_str, project_path.clone())?;\n+                                    combined_includes_by_root\n+                                        .entry(root)\n+                                        .or_default()\n+                                        .push(glob);\n+                                }\n                             }\n                         }\n                     }\n                 }\n-            }\n \n-            // Apply includes - find additional files that match the include patterns\n-            let includes = combined_includes_by_root\n-                .into_iter()\n-                .map(|(root, globs)| {\n-                    let glob = Glob::new(\n-                        format!(\"{{{}}}\", globs.join(\",\")).into(),\n-                        GlobOptions { contains: true },\n-                    );\n-                    apply_includes(root, glob, &ident_folder_in_project_fs)\n-                })\n-                .try_join()\n-                .await?;\n-\n-            result.extend(includes.into_iter().flatten());\n-        }\n+                // Apply includes - find additional files that match the include patterns\n+                let includes = combined_includes_by_root\n+                    .into_iter()\n+                    .map(|(root, globs)| {\n+                        let glob = Glob::new(\n+                            format!(\"{{{}}}\", globs.join(\",\")).into(),\n+                            GlobOptions { contains: true },\n+                        );\n+                        apply_includes(root, glob, &ident_folder_in_project_fs)\n+                    })\n+                    .try_join()\n+                    .await?;\n \n-        let json = json!({\n-          \"version\": 1,\n-          \"files\": result\n-        });\n+                result.extend(includes.into_iter().flatten());\n+            }\n+\n+            let json = json!({\n+              \"version\": 1,\n+              \"files\": result\n+            });\n \n-        Ok(AssetContent::file(File::from(json.to_string()).into()))\n+            Ok(AssetContent::file(File::from(json.to_string()).into()))\n+        }\n+        .instrument(span)\n+        .await\n     }\n }\n \n@@ -453,7 +461,7 @@ impl Visit<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)>\n         node: &(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n     ) -> tracing::Span {\n         if let Some(ident) = &node.1 {\n-            tracing::info_span!(\"asset\", name = display(ident))\n+            tracing::trace_span!(\"asset\", name = display(ident))\n         } else {\n             Span::current()\n         }"
        },
        {
            "sha": "fb5d37c0771cfe7300affdd4a93638479fd5b227",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -1630,7 +1630,6 @@ impl Endpoint for PageEndpoint {\n                     .await?;\n                 let client_paths = all_paths_in_root(output_assets, client_relative_root)\n                     .owned()\n-                    .instrument(tracing::info_span!(\"client_paths\"))\n                     .await?;\n                 (server_paths, client_paths)\n             } else {"
        },
        {
            "sha": "ec925d8a4d3749b37e662fbda0d97cc7db6ac95e",
            "filename": "crates/next-api/src/paths.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fpaths.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fpaths.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpaths.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -53,7 +53,7 @@ pub async fn all_server_paths(\n     node_root: FileSystemPath,\n ) -> Result<Vc<ServerPaths>> {\n     let span = tracing::info_span!(\n-        \"all_server_paths\",\n+        \"collect all server paths\",\n         assets_count = tracing::field::Empty,\n         server_assets_count = tracing::field::Empty\n     );"
        },
        {
            "sha": "8879c9c2ea2ff0a0c40f04ff6c276aabb424adbb",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -334,7 +334,7 @@ impl ProjectContainer {\n         Ok(())\n     }\n \n-    #[tracing::instrument(level = \"info\", name = \"update project\", skip_all)]\n+    #[tracing::instrument(level = \"info\", name = \"update project options\", skip_all)]\n     pub async fn update(self: Vc<Self>, options: PartialProjectOptions) -> Result<()> {\n         let PartialProjectOptions {\n             root_path,"
        },
        {
            "sha": "7e8eef0106bfa03b0f036a9ecd9e9b33dcdfd83d",
            "filename": "crates/next-api/src/webpack_stats.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -1,7 +1,7 @@\n use anyhow::Result;\n use rustc_hash::FxHashSet;\n use serde::Serialize;\n-use tracing::{Level, instrument};\n+use tracing::instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n     FxIndexMap, FxIndexSet, ResolvedVc, TryJoinIterExt, ValueToString, Vc, fxindexmap,\n@@ -14,7 +14,7 @@ use turbopack_core::{\n     output::OutputAsset,\n };\n \n-#[instrument(level = Level::INFO, skip_all)]\n+#[instrument(level = \"info\", name = \"generate webpack stats\", skip_all)]\n pub async fn generate_webpack_stats<I>(\n     module_graph: Vc<ModuleGraph>,\n     entry_name: RcStr,"
        },
        {
            "sha": "0e8f1b1f521901258f5851018ab089c3d8d10fe6",
            "filename": "crates/next-core/src/emit.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-core%2Fsrc%2Femit.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-core%2Fsrc%2Femit.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Femit.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -138,7 +138,7 @@ impl Visit<(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>)> for Outpu\n         node: &(ResolvedVc<Box<dyn OutputAsset>>, Option<ReadRef<RcStr>>),\n     ) -> tracing::Span {\n         if let Some(ident) = &node.1 {\n-            tracing::info_span!(\"asset\", name = display(ident))\n+            tracing::trace_span!(\"asset\", name = display(ident))\n         } else {\n             Span::current()\n         }"
        },
        {
            "sha": "532dc3af62451066e31036f06d691e0eb8b7332d",
            "filename": "crates/next-core/src/next_manifests/client_reference_manifest.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -158,7 +158,7 @@ async fn build_manifest(\n         mode,\n     } = &*manifest.await?;\n     let span = tracing::info_span!(\n-        \"build ClientReferenceManifest\",\n+        \"build client reference manifest\",\n         entry_name = display(&entry_name)\n     );\n     async move {"
        },
        {
            "sha": "378d8b7cabec3239432fb9491108bbc71373dd35",
            "filename": "turbopack/crates/turbo-persistence/src/compression.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompression.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompression.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fcompression.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -3,7 +3,7 @@ use std::{mem::MaybeUninit, sync::Arc};\n use anyhow::{Context, Result};\n use lzzzz::lz4::{ACC_LEVEL_DEFAULT, decompress, decompress_with_dict};\n \n-#[tracing::instrument(level = \"trace\", skip_all)]\n+#[tracing::instrument(level = \"trace\", skip_all, name = \"decompress database block\")]\n pub fn decompress_into_arc(\n     uncompressed_length: u32,\n     block: &[u8],"
        },
        {
            "sha": "0635965e265762556e5cb8b81bc013f39e46f891",
            "filename": "turbopack/crates/turbo-persistence/src/db.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -377,6 +377,7 @@ impl<S: ParallelScheduler> TurboPersistence<S> {\n     }\n \n     /// Reads and decompresses a blob file. This is not backed by any cache.\n+    #[tracing::instrument(level = \"info\", name = \"reading database blob\", skip_all)]\n     fn read_blob(&self, seq: u32) -> Result<ArcSlice<u8>> {\n         let path = self.path.join(format!(\"{seq:08}.blob\"));\n         let mmap = unsafe { Mmap::map(&File::open(&path)?)? };"
        },
        {
            "sha": "a3fcf7fc69c04614e72847d85c517ed298d940f5",
            "filename": "turbopack/crates/turbo-persistence/src/static_sorted_file.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fstatic_sorted_file.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fstatic_sorted_file.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fstatic_sorted_file.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -330,6 +330,7 @@ impl StaticSortedFile {\n     }\n \n     /// Reads a block from the file.\n+    #[tracing::instrument(level = \"info\", name = \"reading database block\", skip_all)]\n     fn read_block(\n         &self,\n         block_index: u16,"
        },
        {
            "sha": "2ba2f9038612c9c988dee460d0dd9ac0c037aad1",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 7,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -25,7 +25,7 @@ use parking_lot::{Condvar, Mutex};\n use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n use smallvec::{SmallVec, smallvec};\n use tokio::time::{Duration, Instant};\n-use tracing::{Span, field::Empty, info_span};\n+use tracing::{Span, field::Empty, info_span, trace_span};\n use turbo_tasks::{\n     CellId, FxDashMap, FxIndexMap, KeyValuePair, RawVc, ReadCellOptions, ReadConsistency,\n     SessionId, TRANSIENT_TASK_BIT, TaskExecutionReason, TaskId, TraitTypeId, TurboTasksBackendApi,\n@@ -1215,6 +1215,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         if self.should_persist() {\n             // Schedule the snapshot job\n+            let _span = Span::none().entered();\n             turbo_tasks.schedule_backend_background_job(TurboTasksBackendJob::InitialSnapshot);\n         }\n     }\n@@ -1232,6 +1233,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             self.verify_aggregation_graph(turbo_tasks, false);\n         }\n         if self.should_persist() {\n+            let _span = tracing::info_span!(\"persist on stop\").entered();\n             self.snapshot();\n         }\n         self.task_cache.drop_contents();\n@@ -2212,11 +2214,12 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                         const SNAPSHOT_INTERVAL: Duration = Duration::from_secs(120);\n                         const IDLE_TIMEOUT: Duration = Duration::from_secs(2);\n \n-                        let time = if matches!(job, TurboTasksBackendJob::InitialSnapshot) {\n-                            FIRST_SNAPSHOT_WAIT\n-                        } else {\n-                            SNAPSHOT_INTERVAL\n-                        };\n+                        let (time, mut reason) =\n+                            if matches!(job, TurboTasksBackendJob::InitialSnapshot) {\n+                                (FIRST_SNAPSHOT_WAIT, \"initial snapshot timeout\")\n+                            } else {\n+                                (SNAPSHOT_INTERVAL, \"regular snapshot interval\")\n+                            };\n \n                         let until = last_snapshot + time;\n                         if until > Instant::now() {\n@@ -2249,13 +2252,15 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                                     },\n                                     _ = tokio::time::sleep_until(idle_time) => {\n                                         if turbo_tasks.is_idle() {\n+                                            reason = \"idle timeout\";\n                                             break;\n                                         }\n                                     },\n                                 }\n                             }\n                         }\n \n+                        let _span = info_span!(\"persist\", reason = reason).entered();\n                         let this = self.clone();\n                         let snapshot = this.snapshot();\n                         if let Some((snapshot_start, new_data)) = snapshot {\n@@ -2269,6 +2274,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                                 Ordering::Relaxed,\n                             );\n \n+                            let _span = Span::none().entered();\n                             turbo_tasks.schedule_backend_background_job(\n                                 TurboTasksBackendJob::FollowUpSnapshot,\n                             );\n@@ -2298,7 +2304,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                         0..data.len()\n                     };\n \n-                    let _span = info_span!(\"prefetching\").entered();\n+                    let _span = trace_span!(\"prefetching\").entered();\n                     let mut ctx = self.execute_context(turbo_tasks);\n                     for i in range {\n                         let (&task, &with_data) = data.get_index(i).unwrap();"
        },
        {
            "sha": "f479f10ac826501c3c29de550c4680e1a2bda035",
            "filename": "turbopack/crates/turbo-tasks-fs/src/watcher.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -739,7 +739,7 @@ impl DiskWatcher {\n #[instrument(\n     parent = None,\n     level = \"info\",\n-    name = \"DiskFileSystem file change\",\n+    name = \"file change\",\n     skip_all,\n     fields(name = %path.display())\n )]"
        },
        {
            "sha": "15b7c4b98b069537ab2e57a494047a2c2c3f0a38",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -16,7 +16,7 @@ use rustc_hash::FxHasher;\n use serde::{Deserialize, Serialize};\n use tokio::{select, sync::mpsc::Receiver, task_local};\n use tokio_util::task::TaskTracker;\n-use tracing::{Instrument, Level, instrument};\n+use tracing::{Instrument, instrument};\n \n use crate::{\n     Completion, InvalidationReason, InvalidationReasonSet, OutputContent, ReadCellOptions,\n@@ -535,6 +535,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         rx.await?\n     }\n \n+    #[tracing::instrument(level = \"trace\", skip_all, name = \"turbo_tasks::run\")]\n     pub async fn run<T: TraceRawVcs + Send + 'static>(\n         &self,\n         future: impl Future<Output = Result<T>> + Send + 'static,\n@@ -1195,12 +1196,12 @@ impl<B: Backend + 'static> TurboTasksCallApi for TurboTasks<B> {\n }\n \n impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n-    #[instrument(level = Level::INFO, skip_all, name = \"invalidate\")]\n+    #[instrument(level = \"info\", skip_all, name = \"invalidate\")]\n     fn invalidate(&self, task: TaskId) {\n         self.backend.invalidate_task(task, self);\n     }\n \n-    #[instrument(level = Level::INFO, skip_all, name = \"invalidate\", fields(name = display(&reason)))]\n+    #[instrument(level = \"info\", skip_all, name = \"invalidate\", fields(name = display(&reason)))]\n     fn invalidate_with_reason(&self, task: TaskId, reason: StaticOrArc<dyn InvalidationReason>) {\n         {\n             let (_, reason_set) = &mut *self.aggregated_update.lock().unwrap();"
        },
        {
            "sha": "26d6a82f3d5d023a6551f1fe449d000a79c00168",
            "filename": "turbopack/crates/turbopack-cli/src/build/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Fbuild%2Fmod.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -157,9 +157,7 @@ impl TurbopackBuildBuilder {\n                 // Await the result to propagate any errors.\n                 build_result_op.read_strongly_consistent().await?;\n \n-                apply_effects(build_result_op)\n-                    .instrument(tracing::info_span!(\"apply effects\"))\n-                    .await?;\n+                apply_effects(build_result_op).await?;\n \n                 let issue_reporter: Vc<Box<dyn IssueReporter>> =\n                     Vc::upcast(ConsoleUi::new(TransientInstance::new(LogOptions {"
        },
        {
            "sha": "c70d75649e2e2b98b1daafcc9b91a1482b1524f2",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunking/style_production.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking%2Fstyle_production.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking%2Fstyle_production.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking%2Fstyle_production.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -21,7 +21,7 @@ pub async fn make_style_production_chunks(\n     mut split_context: SplitContext<'_>,\n ) -> Result<()> {\n     let span_outer = tracing::info_span!(\n-        \"make production chunks keeping order\",\n+        \"make style production chunks\",\n         chunk_items = chunk_items.len(),\n     );\n     async move {"
        },
        {
            "sha": "9610e29d0cc189c7a2f5bad58d573c33851a32c1",
            "filename": "turbopack/crates/turbopack-core/src/code_builder.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcode_builder.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcode_builder.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcode_builder.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -5,7 +5,7 @@ use std::{\n };\n \n use anyhow::Result;\n-use tracing::{Level, instrument};\n+use tracing::instrument;\n use turbo_tasks::Vc;\n use turbo_tasks_fs::rope::{Rope, RopeBuilder};\n use turbo_tasks_hash::hash_xxh3_hash64;\n@@ -203,7 +203,7 @@ impl Code {\n }\n \n impl Code {\n-    #[instrument(name = \"Code::generate_source_map\", level = Level::INFO, skip_all)]\n+    #[instrument(level = \"trace\", name = \"Code::generate_source_map\", skip_all)]\n     pub fn generate_source_map_ref(&self) -> Result<Rope> {\n         let mut pos = SourcePos::new();\n         let mut last_byte_pos = 0;"
        },
        {
            "sha": "e2d08a924636b2bc9fd26ebb6430d48a22caf0d0",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 20,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -1044,24 +1044,20 @@ impl EcmascriptModuleContent {\n             ..\n         } = &*input;\n \n-        async {\n-            let minify = chunking_context.minify_type().await?;\n-\n-            let content = process_parse_result(\n-                *parsed,\n-                module.ident(),\n-                *specified_module_type,\n-                *generate_source_map,\n-                *original_source_map,\n-                *minify,\n-                Some(&*input),\n-                None,\n-            )\n-            .await?;\n-            emit_content(content, Default::default()).await\n-        }\n-        .instrument(tracing::info_span!(\"gen content with code gens\"))\n-        .await\n+        let minify = chunking_context.minify_type().await?;\n+\n+        let content = process_parse_result(\n+            *parsed,\n+            module.ident(),\n+            *specified_module_type,\n+            *generate_source_map,\n+            *original_source_map,\n+            *minify,\n+            Some(&*input),\n+            None,\n+        )\n+        .await?;\n+        emit_content(content, Default::default()).await\n     }\n \n     /// Creates a new [`Vc<EcmascriptModuleContent>`] without an analysis pass.\n@@ -1204,11 +1200,11 @@ impl EcmascriptModuleContent {\n                 .into();\n \n             emit_content(content, additional_ids)\n-                .instrument(tracing::info_span!(\"emit\"))\n+                .instrument(tracing::info_span!(\"emit code\"))\n                 .await\n         }\n         .instrument(tracing::info_span!(\n-            \"merged EcmascriptModuleContent\",\n+            \"generate merged code\",\n             modules = module_options.len()\n         ))\n         .await"
        },
        {
            "sha": "3efab6017be613ca49991a6d313bf6f0dfe33772",
            "filename": "turbopack/crates/turbopack-ecmascript/src/minify.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fminify.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fminify.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fminify.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -24,15 +24,15 @@ use swc_core::{\n         },\n     },\n };\n-use tracing::{Level, instrument};\n+use tracing::instrument;\n use turbopack_core::{\n     chunk::MangleType,\n     code_builder::{Code, CodeBuilder},\n };\n \n use crate::parse::generate_js_source_map;\n \n-#[instrument(level = Level::INFO, skip_all)]\n+#[instrument(level = \"info\", name = \"minify ecmascript code\", skip_all)]\n pub fn minify(code: Code, source_maps: bool, mangle: Option<MangleType>) -> Result<Code> {\n     let source_maps = source_maps\n         .then(|| code.generate_source_map_ref())"
        },
        {
            "sha": "571b27f38098c047ac31a512412c2984618f15b9",
            "filename": "turbopack/crates/turbopack-ecmascript/src/parse.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -22,7 +22,7 @@ use swc_core::{\n         visit::{Visit, VisitMutWith, VisitWith, noop_visit_type},\n     },\n };\n-use tracing::{Instrument, Level, instrument};\n+use tracing::{Instrument, instrument};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, ValueToString, Vc, util::WrapFuture};\n use turbo_tasks_fs::{FileContent, FileSystemPath, rope::Rope};\n@@ -81,7 +81,7 @@ impl PartialEq for ParseResult {\n \n /// `original_source_maps_complete` indicates whether the `original_source_maps` cover the whole\n /// map, i.e. whether every module that ended up in `mappings` had an original sourcemap.\n-#[instrument(level = Level::INFO, skip_all)]\n+#[instrument(level = \"info\", name = \"generate source map\", skip_all)]\n pub fn generate_js_source_map<'a>(\n     files_map: &impl Files,\n     mappings: Vec<(BytePos, LineCol)>,"
        },
        {
            "sha": "381dc77c6e442b13a2bbb0d3fc3652fb97f3b96a",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/11f721eeda6e6c4133faa8e484491d03f7a06a62/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=11f721eeda6e6c4133faa8e484491d03f7a06a62",
            "patch": "@@ -547,7 +547,7 @@ async fn analyze_ecmascript_module_internal(\n     } = *module.determine_module_type().await?;\n \n     if let Some(package_json) = referenced_package_json {\n-        let span = tracing::info_span!(\"package.json reference\");\n+        let span = tracing::trace_span!(\"package.json reference\");\n         async {\n             analysis.add_reference(\n                 PackageJsonReference::new(package_json.clone())\n@@ -561,7 +561,7 @@ async fn analyze_ecmascript_module_internal(\n     }\n \n     if analyze_types {\n-        let span = tracing::info_span!(\"tsconfig reference\");\n+        let span = tracing::trace_span!(\"tsconfig reference\");\n         async {\n             match &*find_context_file(path.parent(), tsconfig(), false).await? {\n                 FindContextFileResult::Found(tsconfig, _) => {\n@@ -636,7 +636,7 @@ async fn analyze_ecmascript_module_internal(\n \n     let pos = program.span().lo;\n     if analyze_types {\n-        let span = tracing::info_span!(\"type references\");\n+        let span = tracing::trace_span!(\"type references\");\n         async {\n             if let Some(comments) = comments.get_leading(pos) {\n                 for comment in comments.iter() {\n@@ -675,7 +675,7 @@ async fn analyze_ecmascript_module_internal(\n     }\n \n     if options.extract_source_map {\n-        let span = tracing::info_span!(\"source map reference\");\n+        let span = tracing::trace_span!(\"source map reference\");\n         async {\n             if let Some((source_map, reference)) = parse_source_map_comment(\n                 source,\n@@ -699,13 +699,13 @@ async fn analyze_ecmascript_module_internal(\n     let handler = Handler::with_emitter(true, false, Box::new(emitter));\n \n     let mut var_graph = {\n-        let _span = tracing::info_span!(\"analyze variable values\").entered();\n+        let _span = tracing::trace_span!(\"analyze variable values\").entered();\n         set_handler_and_globals(&handler, globals, || {\n             create_graph(program, eval_context, analyze_mode)\n         })\n     };\n \n-    let span = tracing::info_span!(\"esm import references\");\n+    let span = tracing::trace_span!(\"esm import references\");\n     let import_references = async {\n         let mut import_references = Vec::with_capacity(eval_context.imports.references().len());\n         for (i, r) in eval_context.imports.references().enumerate() {\n@@ -759,7 +759,7 @@ async fn analyze_ecmascript_module_internal(\n     .instrument(span)\n     .await?;\n \n-    let span = tracing::info_span!(\"exports\");\n+    let span = tracing::trace_span!(\"exports\");\n     let (webpack_runtime, webpack_entry, webpack_chunks) = async {\n         let (webpack_runtime, webpack_entry, webpack_chunks, mut esm_exports) =\n             set_handler_and_globals(&handler, globals, || {\n@@ -885,7 +885,7 @@ async fn analyze_ecmascript_module_internal(\n     let mut ignore_effect_span = None;\n     // Check if it was a webpack entry\n     if let Some((request, webpack_runtime_span)) = webpack_runtime {\n-        let span = tracing::info_span!(\"webpack runtime reference\");\n+        let span = tracing::trace_span!(\"webpack runtime reference\");\n         async {\n             let request = Request::parse(request.into()).to_resolved().await?;\n             let runtime = resolve_as_webpack_runtime(*origin, *request, *transforms)\n@@ -932,7 +932,7 @@ async fn analyze_ecmascript_module_internal(\n         .await?;\n     }\n     // TODO: we can do this when constructing the var graph\n-    let span = tracing::info_span!(\"async module handling\");\n+    let span = tracing::trace_span!(\"async module handling\");\n     async {\n         let top_level_await_span =\n             set_handler_and_globals(&handler, globals, || has_top_level_await(program));\n@@ -964,7 +964,7 @@ async fn analyze_ecmascript_module_internal(\n     .instrument(span)\n     .await?;\n \n-    let span = tracing::info_span!(\"effects processing\");\n+    let span = tracing::trace_span!(\"effects processing\");\n     async {\n         let effects = take(&mut var_graph.effects);\n "
        }
    ],
    "stats": {
        "total": 763,
        "additions": 393,
        "deletions": 370
    }
}