{
    "author": "mischnic",
    "message": "Turbopack: lazier manifests, part deux (#84191)\n\nLazily compute the contents of the client reference and the font manifests, this moves the computation to `emit`​ (= writing out all chunks in parallel) as opposed to `Endpoint::output`​ (= where we are determining the list of chunks to emit).\n\n<img width=\"1891\" height=\"910\" alt=\"Bildschirmfoto 2025-09-24 um 18 30 13\" src=\"https://github.com/user-attachments/assets/3d3dbd83-4125-4bb5-bb90-e38c536cc44e\" />",
    "sha": "f1a650fc9c493bbc2ff2b900b82aef2521b65eb7",
    "files": [
        {
            "sha": "1a48c0fe0fcf0f32477e0289a72f756a2fcf5c0b",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 31,
            "changes": 56,
            "blob_url": "https://github.com/vercel/next.js/blob/f1a650fc9c493bbc2ff2b900b82aef2521b65eb7/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f1a650fc9c493bbc2ff2b900b82aef2521b65eb7/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=f1a650fc9c493bbc2ff2b900b82aef2521b65eb7",
            "patch": "@@ -23,9 +23,9 @@ use next_core::{\n     next_dynamic::NextDynamicTransition,\n     next_edge::route_regex::get_named_middleware_regex,\n     next_manifests::{\n-        AppPathsManifest, BuildManifest, ClientReferenceManifest, EdgeFunctionDefinition,\n-        MiddlewareMatcher, MiddlewaresManifestV2, PagesManifest, Regions,\n-        client_reference_manifest::ClientReferenceManifestOptions,\n+        AppPathsManifest, BuildManifest, EdgeFunctionDefinition, MiddlewareMatcher,\n+        MiddlewaresManifestV2, PagesManifest, Regions,\n+        client_reference_manifest::ClientReferenceManifest,\n     },\n     next_server::{\n         ServerContextType, get_server_module_options_context, get_server_resolve_options_context,\n@@ -74,7 +74,7 @@ use turbopack_ecmascript::resolve::cjs_resolve;\n \n use crate::{\n     dynamic_imports::{NextDynamicChunkAvailability, collect_next_dynamic_chunks},\n-    font::create_font_manifest,\n+    font::FontManifest,\n     loadable_manifest::create_react_loadable_manifest,\n     module_graph::get_global_information_for_endpoint,\n     nft_json::NftJsonAsset,\n@@ -1239,18 +1239,10 @@ impl AppEndpoint {\n             )\n             .await?;\n \n-            let mut client_shared_chunks = vec![];\n-            for &chunk in client_shared_chunk_group.assets.await? {\n-                client_assets.insert(chunk);\n+            client_assets.extend(client_shared_chunk_group.referenced_assets.await?);\n \n-                let chunk_path = chunk.path().await?;\n-                if chunk_path.has_extension(\".js\") {\n-                    client_shared_chunks.push(chunk);\n-                }\n-            }\n-            for &chunk in client_shared_chunk_group.referenced_assets.await? {\n-                client_assets.insert(chunk);\n-            }\n+            let client_shared_chunks = client_shared_chunk_group.assets.owned().await?;\n+            client_assets.extend(client_shared_chunks.iter().copied());\n \n             (\n                 client_shared_chunk_group.availability_info,\n@@ -1462,8 +1454,8 @@ impl AppEndpoint {\n         let mut client_reference_manifest = None;\n \n         if emit_rsc_manifests {\n-            let entry_manifest =\n-                ClientReferenceManifest::build_output(ClientReferenceManifestOptions {\n+            let entry_manifest = ResolvedVc::upcast(\n+                ClientReferenceManifest {\n                     node_root: node_root.clone(),\n                     client_relative_path: client_relative_path.clone(),\n                     entry_name: app_entry.original_name.clone(),\n@@ -1475,27 +1467,29 @@ impl AppEndpoint {\n                     next_config: project.next_config().to_resolved().await?,\n                     runtime,\n                     mode: *project.next_mode().await?,\n-                })\n-                .to_resolved()\n-                .await?;\n+                }\n+                .resolved_cell(),\n+            );\n             server_assets.insert(entry_manifest);\n             if runtime == NextRuntime::Edge {\n                 middleware_assets.insert(entry_manifest);\n             }\n             client_reference_manifest = Some(entry_manifest);\n         }\n         if emit_manifests == EmitManifests::Full {\n-            let next_font_manifest_output = create_font_manifest(\n-                project.client_root().owned().await?,\n-                node_root.clone(),\n-                this.app_project.app_dir().owned().await?,\n-                &app_entry.original_name,\n-                &app_entry.original_name,\n-                &app_entry.original_name,\n-                *client_assets,\n-                true,\n-            )\n-            .await?;\n+            let next_font_manifest_output = ResolvedVc::upcast(\n+                FontManifest {\n+                    client_root: project.client_root().owned().await?,\n+                    node_root: node_root.clone(),\n+                    dir: this.app_project.app_dir().owned().await?,\n+                    original_name: app_entry.original_name.clone(),\n+                    manifest_path_prefix: app_entry.original_name.clone(),\n+                    pathname: app_entry.original_name.clone(),\n+                    client_assets,\n+                    app_dir: true,\n+                }\n+                .resolved_cell(),\n+            );\n             server_assets.insert(next_font_manifest_output);\n         }\n "
        },
        {
            "sha": "2e480d514a98a2616691b3da2c5f115eb78f3c8a",
            "filename": "crates/next-api/src/font.rs",
            "status": "modified",
            "additions": 77,
            "deletions": 63,
            "changes": 140,
            "blob_url": "https://github.com/vercel/next.js/blob/f1a650fc9c493bbc2ff2b900b82aef2521b65eb7/crates%2Fnext-api%2Fsrc%2Ffont.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f1a650fc9c493bbc2ff2b900b82aef2521b65eb7/crates%2Fnext-api%2Fsrc%2Ffont.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Ffont.rs?ref=f1a650fc9c493bbc2ff2b900b82aef2521b65eb7",
            "patch": "@@ -4,79 +4,93 @@ use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n-    asset::AssetContent,\n+    asset::{Asset, AssetContent},\n     output::{OutputAsset, OutputAssets},\n-    virtual_output::VirtualOutputAsset,\n };\n \n use crate::paths::get_font_paths_from_root;\n \n-pub(crate) async fn create_font_manifest(\n-    client_root: FileSystemPath,\n-    node_root: FileSystemPath,\n-    dir: FileSystemPath,\n-    original_name: &str,\n-    manifest_path_prefix: &str,\n-    pathname: &str,\n-    client_assets: Vc<OutputAssets>,\n-    app_dir: bool,\n-) -> Result<ResolvedVc<Box<dyn OutputAsset>>> {\n-    let all_client_output_assets = all_assets_from_entries(client_assets).await?;\n+#[turbo_tasks::value(shared)]\n+pub struct FontManifest {\n+    pub client_root: FileSystemPath,\n+    pub node_root: FileSystemPath,\n+    pub dir: FileSystemPath,\n+    pub original_name: RcStr,\n+    pub manifest_path_prefix: RcStr,\n+    pub pathname: RcStr,\n+    pub client_assets: ResolvedVc<OutputAssets>,\n+    pub app_dir: bool,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl OutputAsset for FontManifest {\n+    #[turbo_tasks::function]\n+    async fn path(&self) -> Result<Vc<FileSystemPath>> {\n+        let manifest_path_prefix = &self.manifest_path_prefix;\n+        Ok(self\n+            .node_root\n+            .join(&format!(\n+                \"server/{}{manifest_path_prefix}/next-font-manifest.json\",\n+                if self.app_dir { \"app\" } else { \"pages\" }\n+            ))?\n+            .cell())\n+    }\n+}\n \n-    // `_next` gets added again later, so we \"strip\" it here via\n-    // `get_font_paths_from_root`.\n-    let font_paths: Vec<String> = get_font_paths_from_root(&client_root, &all_client_output_assets)\n-        .await?\n-        .iter()\n-        .filter_map(|p| p.split(\"_next/\").last().map(|f| f.to_string()))\n-        .collect();\n+#[turbo_tasks::value_impl]\n+impl Asset for FontManifest {\n+    #[turbo_tasks::function]\n+    async fn content(&self) -> Result<Vc<AssetContent>> {\n+        let FontManifest {\n+            client_root,\n+            dir,\n+            original_name,\n+            pathname,\n+            client_assets,\n+            app_dir,\n+            ..\n+        } = self;\n+        let all_client_output_assets = all_assets_from_entries(**client_assets).await?;\n \n-    let path = if app_dir {\n-        node_root.join(&format!(\n-            \"server/app{manifest_path_prefix}/next-font-manifest.json\",\n-        ))?\n-    } else {\n-        node_root.join(&format!(\n-            \"server/pages{manifest_path_prefix}/next-font-manifest.json\",\n-        ))?\n-    };\n+        // `_next` gets added again later, so we \"strip\" it here via\n+        // `get_font_paths_from_root`.\n+        let font_paths: Vec<String> =\n+            get_font_paths_from_root(client_root, &all_client_output_assets)\n+                .await?\n+                .iter()\n+                .filter_map(|p| p.split(\"_next/\").last().map(|f| f.to_string()))\n+                .collect();\n \n-    let has_fonts = !font_paths.is_empty();\n-    let using_size_adjust = font_paths.iter().any(|path| path.contains(\"-s\"));\n+        let has_fonts = !font_paths.is_empty();\n+        let using_size_adjust = font_paths.iter().any(|path| path.contains(\"-s\"));\n \n-    let font_paths = font_paths\n-        .into_iter()\n-        .filter(|path| path.contains(\".p.\"))\n-        .map(RcStr::from)\n-        .collect::<Vec<_>>();\n+        let font_paths = font_paths\n+            .into_iter()\n+            .filter(|path| path.contains(\".p.\"))\n+            .map(RcStr::from)\n+            .collect::<Vec<_>>();\n \n-    let next_font_manifest = if !has_fonts {\n-        Default::default()\n-    } else if app_dir {\n-        let dir_str = dir.value_to_string().await?;\n-        let page_path = format!(\"{dir_str}{original_name}\").into();\n+        let next_font_manifest = if !has_fonts {\n+            Default::default()\n+        } else if *app_dir {\n+            let dir_str = dir.value_to_string().await?;\n+            let page_path = format!(\"{dir_str}{original_name}\").into();\n \n-        NextFontManifest {\n-            app: [(page_path, font_paths)].into_iter().collect(),\n-            app_using_size_adjust: using_size_adjust,\n-            ..Default::default()\n-        }\n-    } else {\n-        NextFontManifest {\n-            pages: [(pathname.into(), font_paths)].into_iter().collect(),\n-            pages_using_size_adjust: using_size_adjust,\n-            ..Default::default()\n-        }\n-    };\n+            NextFontManifest {\n+                app: [(page_path, font_paths)].into_iter().collect(),\n+                app_using_size_adjust: using_size_adjust,\n+                ..Default::default()\n+            }\n+        } else {\n+            NextFontManifest {\n+                pages: [(pathname.clone(), font_paths)].into_iter().collect(),\n+                pages_using_size_adjust: using_size_adjust,\n+                ..Default::default()\n+            }\n+        };\n \n-    Ok(ResolvedVc::upcast(\n-        VirtualOutputAsset::new(\n-            path,\n-            AssetContent::file(\n-                File::from(serde_json::to_string_pretty(&next_font_manifest)?).into(),\n-            ),\n-        )\n-        .to_resolved()\n-        .await?,\n-    ))\n+        Ok(AssetContent::file(\n+            File::from(serde_json::to_string_pretty(&next_font_manifest)?).into(),\n+        ))\n+    }\n }"
        },
        {
            "sha": "0b9f2065277c91d34c49db0a1b281fd23aa60044",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 12,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/f1a650fc9c493bbc2ff2b900b82aef2521b65eb7/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f1a650fc9c493bbc2ff2b900b82aef2521b65eb7/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=f1a650fc9c493bbc2ff2b900b82aef2521b65eb7",
            "patch": "@@ -69,7 +69,7 @@ use crate::{\n     dynamic_imports::{\n         DynamicImportedChunks, NextDynamicChunkAvailability, collect_next_dynamic_chunks,\n     },\n-    font::create_font_manifest,\n+    font::FontManifest,\n     loadable_manifest::create_react_loadable_manifest,\n     module_graph::get_global_information_for_endpoint,\n     nft_json::NftJsonAsset,\n@@ -1350,17 +1350,19 @@ impl PageEndpoint {\n         let node_root = this.pages_project.project().node_root().owned().await?;\n \n         if emit_manifests == EmitManifests::Full {\n-            let next_font_manifest_output = create_font_manifest(\n-                this.pages_project.project().client_root().owned().await?,\n-                node_root.clone(),\n-                this.pages_project.pages_dir().owned().await?,\n-                &this.original_name,\n-                &manifest_path_prefix,\n-                &this.pathname,\n-                *client_assets,\n-                false,\n-            )\n-            .await?;\n+            let next_font_manifest_output = ResolvedVc::upcast(\n+                FontManifest {\n+                    client_root: this.pages_project.project().client_root().owned().await?,\n+                    node_root: node_root.clone(),\n+                    dir: this.pages_project.pages_dir().owned().await?,\n+                    original_name: this.original_name.clone(),\n+                    manifest_path_prefix: manifest_path_prefix.clone().into(),\n+                    pathname: this.pathname.clone(),\n+                    client_assets,\n+                    app_dir: false,\n+                }\n+                .resolved_cell(),\n+            );\n             server_assets.push(next_font_manifest_output);\n         }\n "
        },
        {
            "sha": "a7cca68045465e923f2025f7c1033620a2453a8c",
            "filename": "crates/next-core/src/next_manifests/client_reference_manifest.rs",
            "status": "modified",
            "additions": 420,
            "deletions": 338,
            "changes": 758,
            "blob_url": "https://github.com/vercel/next.js/blob/f1a650fc9c493bbc2ff2b900b82aef2521b65eb7/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f1a650fc9c493bbc2ff2b900b82aef2521b65eb7/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs?ref=f1a650fc9c493bbc2ff2b900b82aef2521b65eb7",
            "patch": "@@ -3,12 +3,11 @@ use either::Either;\n use indoc::formatdoc;\n use itertools::Itertools;\n use rustc_hash::FxHashMap;\n-use serde::{Deserialize, Serialize};\n+use serde::Serialize;\n use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n-    FxIndexSet, ResolvedVc, TaskInput, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n-    trace::TraceRawVcs,\n+    FxIndexMap, FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n };\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n@@ -17,23 +16,84 @@ use turbopack_core::{\n         ChunkGroupResult, ChunkingContext, ModuleChunkItemIdExt, ModuleId as TurbopackModuleId,\n     },\n     module_graph::async_module_info::AsyncModulesInfo,\n-    output::{OutputAsset, OutputAssetsWithReferenced},\n-    virtual_output::VirtualOutputAsset,\n+    output::{OutputAsset, OutputAssets, OutputAssetsWithReferenced},\n };\n use turbopack_ecmascript::utils::StringifyJs;\n \n-use super::{ClientReferenceManifest, CssResource, ManifestNode, ManifestNodeEntry, ModuleId};\n use crate::{\n     mode::NextMode,\n     next_app::ClientReferencesChunks,\n     next_client_reference::{ClientReferenceGraphResult, ClientReferenceType},\n-    next_config::NextConfig,\n-    next_manifests::encode_uri_component::encode_uri_component,\n+    next_config::{CrossOriginConfig, NextConfig},\n+    next_manifests::{ModuleId, encode_uri_component::encode_uri_component},\n     util::NextRuntime,\n };\n \n-#[derive(TaskInput, Clone, Hash, Debug, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs)]\n-pub struct ClientReferenceManifestOptions {\n+#[derive(Serialize, Default, Debug)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct SerializedClientReferenceManifest {\n+    pub module_loading: ModuleLoading,\n+    /// Mapping of module path and export name to client module ID and required\n+    /// client chunks.\n+    pub client_modules: ManifestNode,\n+    /// Mapping of client module ID to corresponding SSR module ID and required\n+    /// SSR chunks.\n+    pub ssr_module_mapping: FxIndexMap<ModuleId, ManifestNode>,\n+    /// Same as `ssr_module_mapping`, but for Edge SSR.\n+    #[serde(rename = \"edgeSSRModuleMapping\")]\n+    pub edge_ssr_module_mapping: FxIndexMap<ModuleId, ManifestNode>,\n+    /// Mapping of client module ID to corresponding RSC module ID and required\n+    /// RSC chunks.\n+    pub rsc_module_mapping: FxIndexMap<ModuleId, ManifestNode>,\n+    /// Same as `rsc_module_mapping`, but for Edge RSC.\n+    #[serde(rename = \"edgeRscModuleMapping\")]\n+    pub edge_rsc_module_mapping: FxIndexMap<ModuleId, ManifestNode>,\n+    /// Mapping of server component path to required CSS client chunks.\n+    #[serde(rename = \"entryCSSFiles\")]\n+    pub entry_css_files: FxIndexMap<RcStr, FxIndexSet<CssResource>>,\n+    /// Mapping of server component path to required JS client chunks.\n+    #[serde(rename = \"entryJSFiles\")]\n+    pub entry_js_files: FxIndexMap<RcStr, FxIndexSet<RcStr>>,\n+}\n+\n+#[derive(Serialize, Debug, Clone, Eq, Hash, PartialEq)]\n+pub struct CssResource {\n+    pub path: RcStr,\n+    pub inlined: bool,\n+    #[serde(skip_serializing_if = \"Option::is_none\")]\n+    pub content: Option<RcStr>,\n+}\n+\n+#[derive(Serialize, Default, Debug)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ModuleLoading {\n+    pub prefix: RcStr,\n+    pub cross_origin: Option<CrossOriginConfig>,\n+}\n+\n+#[derive(Serialize, Default, Debug, Clone)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ManifestNode {\n+    /// Mapping of export name to manifest node entry.\n+    #[serde(flatten)]\n+    pub module_exports: FxIndexMap<RcStr, ManifestNodeEntry>,\n+}\n+\n+#[derive(Serialize, Debug, Clone)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct ManifestNodeEntry {\n+    /// Turbopack module ID.\n+    pub id: ModuleId,\n+    /// Export name.\n+    pub name: RcStr,\n+    /// Chunks for the module. JS and CSS.\n+    pub chunks: Vec<RcStr>,\n+    // TODO(WEB-434)\n+    pub r#async: bool,\n+}\n+\n+#[turbo_tasks::value(shared)]\n+pub struct ClientReferenceManifest {\n     pub node_root: FileSystemPath,\n     pub client_relative_path: FileSystemPath,\n     pub entry_name: RcStr,\n@@ -48,380 +108,402 @@ pub struct ClientReferenceManifestOptions {\n }\n \n #[turbo_tasks::value_impl]\n-impl ClientReferenceManifest {\n+impl OutputAsset for ClientReferenceManifest {\n     #[turbo_tasks::function]\n-    pub async fn build_output(\n-        options: ClientReferenceManifestOptions,\n-    ) -> Result<Vc<Box<dyn OutputAsset>>> {\n-        let ClientReferenceManifestOptions {\n-            node_root,\n-            client_relative_path,\n-            entry_name,\n-            client_references,\n-            client_references_chunks,\n-            client_chunking_context,\n-            ssr_chunking_context,\n-            async_module_info,\n-            next_config,\n-            runtime,\n-            mode,\n-        } = options;\n-        let span = tracing::info_span!(\n-            \"ClientReferenceManifest build output\",\n-            entry_name = display(&entry_name)\n-        );\n-        async move {\n-            let mut entry_manifest: ClientReferenceManifest = Default::default();\n-            let mut references = FxIndexSet::default();\n-            let chunk_suffix_path = next_config.chunk_suffix_path().owned().await?;\n-            let prefix_path = next_config\n-                .computed_asset_prefix()\n-                .owned()\n-                .await?\n-                .unwrap_or_default();\n-            let suffix_path = chunk_suffix_path.unwrap_or_default();\n+    async fn path(&self) -> Result<Vc<FileSystemPath>> {\n+        let normalized_manifest_entry = self.entry_name.replace(\"%5F\", \"_\");\n+        Ok(self\n+            .node_root\n+            .join(&format!(\n+                \"server/app{normalized_manifest_entry}_client-reference-manifest.js\",\n+            ))?\n+            .cell())\n+    }\n \n-            // TODO: Add `suffix` to the manifest for React to use.\n-            // entry_manifest.module_loading.prefix = prefix_path;\n+    #[turbo_tasks::function]\n+    async fn references(self: Vc<Self>) -> Result<Vc<OutputAssets>> {\n+        Ok(*build_manifest(self).await?.references)\n+    }\n+}\n \n-            entry_manifest.module_loading.cross_origin = next_config\n-                .await?\n-                .cross_origin\n-                .as_ref()\n-                .map(|p| p.to_owned());\n-            let ClientReferencesChunks {\n-                client_component_client_chunks,\n-                layout_segment_client_chunks,\n-                client_component_ssr_chunks,\n-            } = &*client_references_chunks.await?;\n-            let client_relative_path = client_relative_path.clone();\n-            let node_root_ref = node_root.clone();\n-\n-            let client_references_ecmascript = client_references\n-                .await?\n-                .client_references\n-                .iter()\n-                .map(async |r| {\n-                    Ok(match r.ty() {\n-                        ClientReferenceType::EcmascriptClientReference(r) => Some((r, r.await?)),\n-                        ClientReferenceType::CssClientReference(_) => None,\n+#[turbo_tasks::value_impl]\n+impl Asset for ClientReferenceManifest {\n+    #[turbo_tasks::function]\n+    async fn content(self: Vc<Self>) -> Result<Vc<AssetContent>> {\n+        Ok(*build_manifest(self).await?.content)\n+    }\n+}\n+\n+#[turbo_tasks::value(shared)]\n+struct ClientReferenceManifestResult {\n+    content: ResolvedVc<AssetContent>,\n+    references: ResolvedVc<OutputAssets>,\n+}\n+\n+#[turbo_tasks::function]\n+async fn build_manifest(\n+    manifest: Vc<ClientReferenceManifest>,\n+) -> Result<Vc<ClientReferenceManifestResult>> {\n+    let ClientReferenceManifest {\n+        node_root,\n+        client_relative_path,\n+        entry_name,\n+        client_references,\n+        client_references_chunks,\n+        client_chunking_context,\n+        ssr_chunking_context,\n+        async_module_info,\n+        next_config,\n+        runtime,\n+        mode,\n+    } = &*manifest.await?;\n+    let span = tracing::info_span!(\n+        \"build ClientReferenceManifest\",\n+        entry_name = display(&entry_name)\n+    );\n+    async move {\n+        let mut entry_manifest: SerializedClientReferenceManifest = Default::default();\n+        let mut references = FxIndexSet::default();\n+        let chunk_suffix_path = next_config.chunk_suffix_path().owned().await?;\n+        let prefix_path = next_config\n+            .computed_asset_prefix()\n+            .owned()\n+            .await?\n+            .unwrap_or_default();\n+        let suffix_path = chunk_suffix_path.unwrap_or_default();\n+\n+        // TODO: Add `suffix` to the manifest for React to use.\n+        // entry_manifest.module_loading.prefix = prefix_path;\n+\n+        entry_manifest.module_loading.cross_origin = next_config\n+            .await?\n+            .cross_origin\n+            .as_ref()\n+            .map(|p| p.to_owned());\n+        let ClientReferencesChunks {\n+            client_component_client_chunks,\n+            layout_segment_client_chunks,\n+            client_component_ssr_chunks,\n+        } = &*client_references_chunks.await?;\n+        let client_relative_path = client_relative_path.clone();\n+        let node_root_ref = node_root.clone();\n+\n+        let client_references_ecmascript = client_references\n+            .await?\n+            .client_references\n+            .iter()\n+            .map(async |r| {\n+                Ok(match r.ty() {\n+                    ClientReferenceType::EcmascriptClientReference(r) => Some((r, r.await?)),\n+                    ClientReferenceType::CssClientReference(_) => None,\n+                })\n+            })\n+            .try_flat_join()\n+            .await?;\n+\n+        let async_modules = async_module_info\n+            .is_async_multiple(Vc::cell(\n+                client_references_ecmascript\n+                    .iter()\n+                    .flat_map(|(r, r_val)| {\n+                        [\n+                            ResolvedVc::upcast(*r),\n+                            ResolvedVc::upcast(r_val.client_module),\n+                            ResolvedVc::upcast(r_val.ssr_module),\n+                        ]\n+                    })\n+                    .collect(),\n+            ))\n+            .await?;\n+\n+        async fn cached_chunk_paths(\n+            cache: &mut FxHashMap<ResolvedVc<Box<dyn OutputAsset>>, FileSystemPath>,\n+            chunks: impl Iterator<Item = ResolvedVc<Box<dyn OutputAsset>>>,\n+        ) -> Result<impl Iterator<Item = (ResolvedVc<Box<dyn OutputAsset>>, FileSystemPath)>>\n+        {\n+            let results = chunks\n+                .into_iter()\n+                .map(|chunk| (chunk, cache.get(&chunk).cloned()))\n+                .map(async |(chunk, path)| {\n+                    Ok(if let Some(path) = path {\n+                        (chunk, Either::Left(path))\n+                    } else {\n+                        (chunk, Either::Right(chunk.path().owned().await?))\n                     })\n                 })\n-                .try_flat_join()\n+                .try_join()\n                 .await?;\n \n-            let async_modules = async_module_info\n-                .is_async_multiple(Vc::cell(\n-                    client_references_ecmascript\n-                        .iter()\n-                        .flat_map(|(r, r_val)| {\n-                            [\n-                                ResolvedVc::upcast(*r),\n-                                ResolvedVc::upcast(r_val.client_module),\n-                                ResolvedVc::upcast(r_val.ssr_module),\n-                            ]\n-                        })\n-                        .collect(),\n-                ))\n+            for (chunk, path) in &results {\n+                if let Either::Right(path) = path {\n+                    cache.insert(*chunk, path.clone());\n+                }\n+            }\n+            Ok(results.into_iter().map(|(chunk, path)| match path {\n+                Either::Left(path) => (chunk, path),\n+                Either::Right(path) => (chunk, path),\n+            }))\n+        }\n+        let mut client_chunk_path_cache: FxHashMap<\n+            ResolvedVc<Box<dyn OutputAsset>>,\n+            FileSystemPath,\n+        > = FxHashMap::default();\n+        let mut ssr_chunk_path_cache: FxHashMap<ResolvedVc<Box<dyn OutputAsset>>, FileSystemPath> =\n+            FxHashMap::default();\n+\n+        for (client_reference_module, client_reference_module_ref) in client_references_ecmascript {\n+            let app_client_reference_ty =\n+                ClientReferenceType::EcmascriptClientReference(client_reference_module);\n+\n+            let server_path = client_reference_module_ref.server_ident.to_string().await?;\n+            let client_module = client_reference_module_ref.client_module;\n+            let client_chunk_item_id = client_module\n+                .chunk_item_id(**client_chunking_context)\n                 .await?;\n \n-            async fn cached_chunk_paths(\n-                cache: &mut FxHashMap<ResolvedVc<Box<dyn OutputAsset>>, FileSystemPath>,\n-                chunks: impl Iterator<Item = ResolvedVc<Box<dyn OutputAsset>>>,\n-            ) -> Result<impl Iterator<Item = (ResolvedVc<Box<dyn OutputAsset>>, FileSystemPath)>>\n+            let (client_chunks_paths, client_is_async) = if let Some(ChunkGroupResult {\n+                assets: client_chunks,\n+                referenced_assets: client_referenced_assets,\n+                availability_info: _,\n+            }) =\n+                client_component_client_chunks.get(&app_client_reference_ty)\n             {\n-                let results = chunks\n-                    .into_iter()\n-                    .map(|chunk| (chunk, cache.get(&chunk).cloned()))\n-                    .map(async |(chunk, path)| {\n-                        Ok(if let Some(path) = path {\n-                            (chunk, Either::Left(path))\n-                        } else {\n-                            (chunk, Either::Right(chunk.path().owned().await?))\n-                        })\n+                let client_chunks = client_chunks.await?;\n+                let client_referenced_assets = client_referenced_assets.await?;\n+                references.extend(client_chunks.iter());\n+                references.extend(client_referenced_assets.iter());\n+\n+                let client_chunks_paths =\n+                    cached_chunk_paths(&mut client_chunk_path_cache, client_chunks.iter().copied())\n+                        .await?;\n+\n+                let chunk_paths = client_chunks_paths\n+                    .filter_map(|(_, chunk_path)| {\n+                        client_relative_path\n+                            .get_path_to(&chunk_path)\n+                            .map(ToString::to_string)\n                     })\n-                    .try_join()\n-                    .await?;\n+                    // It's possible that a chunk also emits CSS files, that will\n+                    // be handled separately.\n+                    .filter(|path| path.ends_with(\".js\"))\n+                    .map(|path| {\n+                        format!(\n+                            \"{}{}{}\",\n+                            prefix_path,\n+                            path.split('/').map(encode_uri_component).format(\"/\"),\n+                            suffix_path\n+                        )\n+                    })\n+                    .map(RcStr::from)\n+                    .collect::<Vec<_>>();\n \n-                for (chunk, path) in &results {\n-                    if let Either::Right(path) = path {\n-                        cache.insert(*chunk, path.clone());\n-                    }\n-                }\n-                Ok(results.into_iter().map(|(chunk, path)| match path {\n-                    Either::Left(path) => (chunk, path),\n-                    Either::Right(path) => (chunk, path),\n-                }))\n-            }\n-            let mut client_chunk_path_cache: FxHashMap<\n-                ResolvedVc<Box<dyn OutputAsset>>,\n-                FileSystemPath,\n-            > = FxHashMap::default();\n-            let mut ssr_chunk_path_cache: FxHashMap<\n-                ResolvedVc<Box<dyn OutputAsset>>,\n-                FileSystemPath,\n-            > = FxHashMap::default();\n-\n-            for (client_reference_module, client_reference_module_ref) in\n-                client_references_ecmascript\n-            {\n-                let app_client_reference_ty =\n-                    ClientReferenceType::EcmascriptClientReference(client_reference_module);\n+                let is_async = async_modules.contains(&ResolvedVc::upcast(client_module));\n+\n+                (chunk_paths, is_async)\n+            } else {\n+                (Vec::new(), false)\n+            };\n \n-                let server_path = client_reference_module_ref.server_ident.to_string().await?;\n-                let client_module = client_reference_module_ref.client_module;\n-                let client_chunk_item_id = client_module\n-                    .chunk_item_id(*client_chunking_context)\n+            if let Some(ssr_chunking_context) = *ssr_chunking_context {\n+                let ssr_module = client_reference_module_ref.ssr_module;\n+                let ssr_chunk_item_id = ssr_module.chunk_item_id(*ssr_chunking_context).await?;\n+\n+                let rsc_chunk_item_id = client_reference_module\n+                    .chunk_item_id(*ssr_chunking_context)\n                     .await?;\n \n-                let (client_chunks_paths, client_is_async) = if let Some(ChunkGroupResult {\n-                    assets: client_chunks,\n-                    referenced_assets: client_referenced_assets,\n+                let (ssr_chunks_paths, ssr_is_async) = if *runtime == NextRuntime::Edge {\n+                    // the chunks get added to the middleware-manifest.json instead\n+                    // of this file because the\n+                    // edge runtime doesn't support dynamically\n+                    // loading chunks.\n+                    (Vec::new(), false)\n+                } else if let Some(ChunkGroupResult {\n+                    assets: ssr_chunks,\n+                    referenced_assets: ssr_referenced_assets,\n                     availability_info: _,\n-                }) =\n-                    client_component_client_chunks.get(&app_client_reference_ty)\n+                }) = client_component_ssr_chunks.get(&app_client_reference_ty)\n                 {\n-                    let client_chunks = client_chunks.await?;\n-                    let client_referenced_assets = client_referenced_assets.await?;\n-                    references.extend(client_chunks.iter());\n-                    references.extend(client_referenced_assets.iter());\n-\n-                    let client_chunks_paths = cached_chunk_paths(\n-                        &mut client_chunk_path_cache,\n-                        client_chunks.iter().copied(),\n-                    )\n-                    .await?;\n-\n-                    let chunk_paths = client_chunks_paths\n+                    let ssr_chunks = ssr_chunks.await?;\n+                    let ssr_referenced_assets = ssr_referenced_assets.await?;\n+                    references.extend(ssr_chunks.iter());\n+                    references.extend(ssr_referenced_assets.iter());\n+\n+                    let ssr_chunks_paths =\n+                        cached_chunk_paths(&mut ssr_chunk_path_cache, ssr_chunks.iter().copied())\n+                            .await?;\n+                    let chunk_paths = ssr_chunks_paths\n                         .filter_map(|(_, chunk_path)| {\n-                            client_relative_path\n+                            node_root_ref\n                                 .get_path_to(&chunk_path)\n                                 .map(ToString::to_string)\n                         })\n-                        // It's possible that a chunk also emits CSS files, that will\n-                        // be handled separately.\n-                        .filter(|path| path.ends_with(\".js\"))\n-                        .map(|path| {\n-                            format!(\n-                                \"{}{}{}\",\n-                                prefix_path,\n-                                path.split('/').map(encode_uri_component).format(\"/\"),\n-                                suffix_path\n-                            )\n-                        })\n                         .map(RcStr::from)\n                         .collect::<Vec<_>>();\n \n-                    let is_async = async_modules.contains(&ResolvedVc::upcast(client_module));\n+                    let is_async = async_modules.contains(&ResolvedVc::upcast(ssr_module));\n \n                     (chunk_paths, is_async)\n                 } else {\n                     (Vec::new(), false)\n                 };\n \n-                if let Some(ssr_chunking_context) = ssr_chunking_context {\n-                    let ssr_module = client_reference_module_ref.ssr_module;\n-                    let ssr_chunk_item_id = ssr_module.chunk_item_id(*ssr_chunking_context).await?;\n-\n-                    let rsc_chunk_item_id = client_reference_module\n-                        .chunk_item_id(*ssr_chunking_context)\n-                        .await?;\n-\n-                    let (ssr_chunks_paths, ssr_is_async) = if runtime == NextRuntime::Edge {\n-                        // the chunks get added to the middleware-manifest.json instead\n-                        // of this file because the\n-                        // edge runtime doesn't support dynamically\n-                        // loading chunks.\n-                        (Vec::new(), false)\n-                    } else if let Some(ChunkGroupResult {\n-                        assets: ssr_chunks,\n-                        referenced_assets: ssr_referenced_assets,\n-                        availability_info: _,\n-                    }) = client_component_ssr_chunks.get(&app_client_reference_ty)\n-                    {\n-                        let ssr_chunks = ssr_chunks.await?;\n-                        let ssr_referenced_assets = ssr_referenced_assets.await?;\n-                        references.extend(ssr_chunks.iter());\n-                        references.extend(ssr_referenced_assets.iter());\n-\n-                        let ssr_chunks_paths = cached_chunk_paths(\n-                            &mut ssr_chunk_path_cache,\n-                            ssr_chunks.iter().copied(),\n-                        )\n-                        .await?;\n-                        let chunk_paths = ssr_chunks_paths\n-                            .filter_map(|(_, chunk_path)| {\n-                                node_root_ref\n-                                    .get_path_to(&chunk_path)\n-                                    .map(ToString::to_string)\n-                            })\n-                            .map(RcStr::from)\n-                            .collect::<Vec<_>>();\n-\n-                        let is_async = async_modules.contains(&ResolvedVc::upcast(ssr_module));\n-\n-                        (chunk_paths, is_async)\n-                    } else {\n-                        (Vec::new(), false)\n-                    };\n+                let rsc_is_async = if *runtime == NextRuntime::Edge {\n+                    false\n+                } else {\n+                    async_modules.contains(&ResolvedVc::upcast(client_reference_module))\n+                };\n \n-                    let rsc_is_async = if runtime == NextRuntime::Edge {\n-                        false\n-                    } else {\n-                        async_modules.contains(&ResolvedVc::upcast(client_reference_module))\n-                    };\n-\n-                    entry_manifest.client_modules.module_exports.insert(\n-                        get_client_reference_module_key(&server_path, \"*\"),\n-                        ManifestNodeEntry {\n-                            name: rcstr!(\"*\"),\n-                            id: (&*client_chunk_item_id).into(),\n-                            chunks: client_chunks_paths,\n-                            // This should of course be client_is_async, but SSR can become\n-                            // async due to ESM externals, and\n-                            // the ssr_manifest_node is currently ignored\n-                            // by React.\n-                            r#async: client_is_async || ssr_is_async,\n-                        },\n-                    );\n-\n-                    let mut ssr_manifest_node = ManifestNode::default();\n-                    ssr_manifest_node.module_exports.insert(\n-                        rcstr!(\"*\"),\n-                        ManifestNodeEntry {\n-                            name: rcstr!(\"*\"),\n-                            id: (&*ssr_chunk_item_id).into(),\n-                            chunks: ssr_chunks_paths,\n-                            // See above\n-                            r#async: client_is_async || ssr_is_async,\n-                        },\n-                    );\n-\n-                    let mut rsc_manifest_node = ManifestNode::default();\n-                    rsc_manifest_node.module_exports.insert(\n-                        rcstr!(\"*\"),\n-                        ManifestNodeEntry {\n-                            name: rcstr!(\"*\"),\n-                            id: (&*rsc_chunk_item_id).into(),\n-                            chunks: vec![],\n-                            r#async: rsc_is_async,\n-                        },\n-                    );\n-\n-                    match runtime {\n-                        NextRuntime::NodeJs => {\n-                            entry_manifest\n-                                .ssr_module_mapping\n-                                .insert((&*client_chunk_item_id).into(), ssr_manifest_node);\n-                            entry_manifest\n-                                .rsc_module_mapping\n-                                .insert((&*client_chunk_item_id).into(), rsc_manifest_node);\n-                        }\n-                        NextRuntime::Edge => {\n-                            entry_manifest\n-                                .edge_ssr_module_mapping\n-                                .insert((&*client_chunk_item_id).into(), ssr_manifest_node);\n-                            entry_manifest\n-                                .edge_rsc_module_mapping\n-                                .insert((&*client_chunk_item_id).into(), rsc_manifest_node);\n-                        }\n+                entry_manifest.client_modules.module_exports.insert(\n+                    get_client_reference_module_key(&server_path, \"*\"),\n+                    ManifestNodeEntry {\n+                        name: rcstr!(\"*\"),\n+                        id: (&*client_chunk_item_id).into(),\n+                        chunks: client_chunks_paths,\n+                        // This should of course be client_is_async, but SSR can become\n+                        // async due to ESM externals, and\n+                        // the ssr_manifest_node is currently ignored\n+                        // by React.\n+                        r#async: client_is_async || ssr_is_async,\n+                    },\n+                );\n+\n+                let mut ssr_manifest_node = ManifestNode::default();\n+                ssr_manifest_node.module_exports.insert(\n+                    rcstr!(\"*\"),\n+                    ManifestNodeEntry {\n+                        name: rcstr!(\"*\"),\n+                        id: (&*ssr_chunk_item_id).into(),\n+                        chunks: ssr_chunks_paths,\n+                        // See above\n+                        r#async: client_is_async || ssr_is_async,\n+                    },\n+                );\n+\n+                let mut rsc_manifest_node = ManifestNode::default();\n+                rsc_manifest_node.module_exports.insert(\n+                    rcstr!(\"*\"),\n+                    ManifestNodeEntry {\n+                        name: rcstr!(\"*\"),\n+                        id: (&*rsc_chunk_item_id).into(),\n+                        chunks: vec![],\n+                        r#async: rsc_is_async,\n+                    },\n+                );\n+\n+                match runtime {\n+                    NextRuntime::NodeJs => {\n+                        entry_manifest\n+                            .ssr_module_mapping\n+                            .insert((&*client_chunk_item_id).into(), ssr_manifest_node);\n+                        entry_manifest\n+                            .rsc_module_mapping\n+                            .insert((&*client_chunk_item_id).into(), rsc_manifest_node);\n+                    }\n+                    NextRuntime::Edge => {\n+                        entry_manifest\n+                            .edge_ssr_module_mapping\n+                            .insert((&*client_chunk_item_id).into(), ssr_manifest_node);\n+                        entry_manifest\n+                            .edge_rsc_module_mapping\n+                            .insert((&*client_chunk_item_id).into(), rsc_manifest_node);\n                     }\n                 }\n             }\n+        }\n \n-            // per layout segment chunks need to be emitted into the manifest too\n-            for (\n-                server_component,\n-                OutputAssetsWithReferenced {\n-                    assets: client_chunks,\n-                    referenced_assets: _,\n-                },\n-            ) in layout_segment_client_chunks.iter()\n-            {\n-                let server_component_name = server_component\n-                    .server_path()\n-                    .await?\n-                    .with_extension(\"\")\n-                    .value_to_string()\n-                    .owned()\n+        // per layout segment chunks need to be emitted into the manifest too\n+        for (\n+            server_component,\n+            OutputAssetsWithReferenced {\n+                assets: client_chunks,\n+                referenced_assets: _,\n+            },\n+        ) in layout_segment_client_chunks.iter()\n+        {\n+            let server_component_name = server_component\n+                .server_path()\n+                .await?\n+                .with_extension(\"\")\n+                .value_to_string()\n+                .owned()\n+                .await?;\n+            let entry_js_files = entry_manifest\n+                .entry_js_files\n+                .entry(server_component_name.clone())\n+                .or_default();\n+            let entry_css_files = entry_manifest\n+                .entry_css_files\n+                .entry(server_component_name)\n+                .or_default();\n+\n+            let client_chunks = &client_chunks.await?;\n+            let client_chunks_with_path =\n+                cached_chunk_paths(&mut client_chunk_path_cache, client_chunks.iter().copied())\n                     .await?;\n-                let entry_js_files = entry_manifest\n-                    .entry_js_files\n-                    .entry(server_component_name.clone())\n-                    .or_default();\n-                let entry_css_files = entry_manifest\n-                    .entry_css_files\n-                    .entry(server_component_name)\n-                    .or_default();\n-\n-                let client_chunks = &client_chunks.await?;\n-                let client_chunks_with_path =\n-                    cached_chunk_paths(&mut client_chunk_path_cache, client_chunks.iter().copied())\n-                        .await?;\n-                // Inlining breaks HMR so it is always disabled in dev.\n-                let inlined_css = next_config.await?.experimental.inline_css.unwrap_or(false)\n-                    && mode.is_production();\n-\n-                for (chunk, chunk_path) in client_chunks_with_path {\n-                    if let Some(path) = client_relative_path.get_path_to(&chunk_path) {\n-                        // The entry CSS files and entry JS files don't have prefix and suffix\n-                        // applied because it is added by Next.js during rendering.\n-                        let path = path.into();\n-                        if chunk_path.has_extension(\".css\") {\n-                            let content = if inlined_css {\n-                                Some(\n-                                    if let Some(content_file) =\n-                                        chunk.content().file_content().await?.as_content()\n-                                    {\n-                                        content_file.content().to_str()?.into()\n-                                    } else {\n-                                        RcStr::default()\n-                                    },\n-                                )\n-                            } else {\n-                                None\n-                            };\n-                            entry_css_files.insert(CssResource {\n-                                path,\n-                                inlined: inlined_css,\n-                                content,\n-                            });\n+            // Inlining breaks HMR so it is always disabled in dev.\n+            let inlined_css =\n+                next_config.await?.experimental.inline_css.unwrap_or(false) && mode.is_production();\n+\n+            for (chunk, chunk_path) in client_chunks_with_path {\n+                if let Some(path) = client_relative_path.get_path_to(&chunk_path) {\n+                    // The entry CSS files and entry JS files don't have prefix and suffix\n+                    // applied because it is added by Next.js during rendering.\n+                    let path = path.into();\n+                    if chunk_path.has_extension(\".css\") {\n+                        let content = if inlined_css {\n+                            Some(\n+                                if let Some(content_file) =\n+                                    chunk.content().file_content().await?.as_content()\n+                                {\n+                                    content_file.content().to_str()?.into()\n+                                } else {\n+                                    RcStr::default()\n+                                },\n+                            )\n                         } else {\n-                            entry_js_files.insert(path);\n-                        }\n+                            None\n+                        };\n+                        entry_css_files.insert(CssResource {\n+                            path,\n+                            inlined: inlined_css,\n+                            content,\n+                        });\n+                    } else {\n+                        entry_js_files.insert(path);\n                     }\n                 }\n             }\n+        }\n \n-            let client_reference_manifest_json = serde_json::to_string(&entry_manifest).unwrap();\n-\n-            // We put normalized path for the each entry key and the manifest output path,\n-            // to conform next.js's load client reference manifest behavior:\n-            // https://github.com/vercel/next.js/blob/2f9d718695e4c90be13c3bf0f3647643533071bf/packages/next/src/server/load-components.ts#L162-L164\n-            // note this only applies to the manifests, assets are placed to the original\n-            // path still (same as webpack does)\n-            let normalized_manifest_entry = entry_name.replace(\"%5F\", \"_\");\n-            Ok(Vc::upcast(VirtualOutputAsset::new_with_references(\n-                node_root.join(&format!(\n-                    \"server/app{normalized_manifest_entry}_client-reference-manifest.js\",\n-                ))?,\n-                AssetContent::file(\n-                    File::from(formatdoc! {\n-                        r#\"\n+        let client_reference_manifest_json = serde_json::to_string(&entry_manifest).unwrap();\n+\n+        // We put normalized path for the each entry key and the manifest output path,\n+        // to conform next.js's load client reference manifest behavior:\n+        // https://github.com/vercel/next.js/blob/2f9d718695e4c90be13c3bf0f3647643533071bf/packages/next/src/server/load-components.ts#L162-L164\n+        // note this only applies to the manifests, assets are placed to the original\n+        // path still (same as webpack does)\n+        let normalized_manifest_entry = entry_name.replace(\"%5F\", \"_\");\n+        Ok(ClientReferenceManifestResult {\n+            content: AssetContent::file(\n+                File::from(formatdoc! {\n+                    r#\"\n                         globalThis.__RSC_MANIFEST = globalThis.__RSC_MANIFEST || {{}};\n                         globalThis.__RSC_MANIFEST[{entry_name}] = {manifest}\n                     \"#,\n-                        entry_name = StringifyJs(&normalized_manifest_entry),\n-                        manifest = &client_reference_manifest_json\n-                    })\n-                    .into(),\n-                ),\n-                Vc::cell(references.into_iter().collect()),\n-            )))\n+                    entry_name = StringifyJs(&normalized_manifest_entry),\n+                    manifest = &client_reference_manifest_json\n+                })\n+                .into(),\n+            )\n+            .to_resolved()\n+            .await?,\n+            references: ResolvedVc::cell(references.into_iter().collect()),\n         }\n-        .instrument(span)\n-        .await\n+        .cell())\n     }\n+    .instrument(span)\n+    .await\n }\n \n impl From<&TurbopackModuleId> for ModuleId {"
        },
        {
            "sha": "fe98c56dee0d6c9640e97a2db58a03f0ecf2637d",
            "filename": "crates/next-core/src/next_manifests/mod.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 75,
            "changes": 100,
            "blob_url": "https://github.com/vercel/next.js/blob/f1a650fc9c493bbc2ff2b900b82aef2521b65eb7/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f1a650fc9c493bbc2ff2b900b82aef2521b65eb7/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fmod.rs?ref=f1a650fc9c493bbc2ff2b900b82aef2521b65eb7",
            "patch": "@@ -7,16 +7,16 @@ use anyhow::{Context, Result};\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    FxIndexMap, FxIndexSet, NonLocalValue, ReadRef, ResolvedVc, TaskInput, TryJoinIterExt, Vc,\n-    trace::TraceRawVcs,\n+    FxIndexMap, NonLocalValue, ReadRef, ResolvedVc, TaskInput, TryFlatJoinIterExt, TryJoinIterExt,\n+    Vc, trace::TraceRawVcs,\n };\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     output::{OutputAsset, OutputAssets},\n };\n \n-use crate::next_config::{CrossOriginConfig, RouteHas};\n+use crate::next_config::RouteHas;\n \n #[derive(Serialize, Default, Debug)]\n pub struct PagesManifest {\n@@ -46,10 +46,18 @@ impl OutputAsset for BuildManifest {\n     async fn references(&self) -> Result<Vc<OutputAssets>> {\n         let chunks: Vec<ReadRef<OutputAssets>> = self.pages.values().try_join().await?;\n \n+        let root_main_files = self\n+            .root_main_files\n+            .iter()\n+            .map(async |c| Ok(c.path().await?.has_extension(\".js\").then_some(*c)))\n+            .try_flat_join()\n+            .await?;\n+\n         let references = chunks\n             .into_iter()\n-            .flat_map(|c| c.into_iter().copied()) // once again, rustc struggles here\n-            .chain(self.root_main_files.iter().copied())\n+            .flatten()\n+            .copied()\n+            .chain(root_main_files.into_iter())\n             .chain(self.polyfill_files.iter().copied())\n             .collect();\n \n@@ -78,7 +86,7 @@ impl Asset for BuildManifest {\n         let pages: Vec<(RcStr, Vec<RcStr>)> = self\n             .pages\n             .iter()\n-            .map(|(k, chunks)| async move {\n+            .map(async |(k, chunks)| {\n                 Ok((\n                     k.clone(),\n                     chunks\n@@ -116,15 +124,20 @@ impl Asset for BuildManifest {\n         let root_main_files: Vec<RcStr> = self\n             .root_main_files\n             .iter()\n-            .copied()\n             .map(async |chunk| {\n                 let chunk_path = chunk.path().await?;\n-                Ok(client_relative_path\n-                    .get_path_to(&chunk_path)\n-                    .context(\"failed to resolve client-relative path to root_main_file\")?\n-                    .into())\n+                if !chunk_path.has_extension(\".js\") {\n+                    Ok(None)\n+                } else {\n+                    Ok(Some(\n+                        client_relative_path\n+                            .get_path_to(&chunk_path)\n+                            .context(\"failed to resolve client-relative path to root_main_file\")?\n+                            .into(),\n+                    ))\n+                }\n             })\n-            .try_join()\n+            .try_flat_join()\n             .await?;\n \n         let manifest = SerializedBuildManifest {\n@@ -405,69 +418,6 @@ pub enum ActionLayer {\n     ActionBrowser,\n }\n \n-#[derive(Serialize, Default, Debug)]\n-#[serde(rename_all = \"camelCase\")]\n-pub struct ClientReferenceManifest {\n-    pub module_loading: ModuleLoading,\n-    /// Mapping of module path and export name to client module ID and required\n-    /// client chunks.\n-    pub client_modules: ManifestNode,\n-    /// Mapping of client module ID to corresponding SSR module ID and required\n-    /// SSR chunks.\n-    pub ssr_module_mapping: FxIndexMap<ModuleId, ManifestNode>,\n-    /// Same as `ssr_module_mapping`, but for Edge SSR.\n-    #[serde(rename = \"edgeSSRModuleMapping\")]\n-    pub edge_ssr_module_mapping: FxIndexMap<ModuleId, ManifestNode>,\n-    /// Mapping of client module ID to corresponding RSC module ID and required\n-    /// RSC chunks.\n-    pub rsc_module_mapping: FxIndexMap<ModuleId, ManifestNode>,\n-    /// Same as `rsc_module_mapping`, but for Edge RSC.\n-    #[serde(rename = \"edgeRscModuleMapping\")]\n-    pub edge_rsc_module_mapping: FxIndexMap<ModuleId, ManifestNode>,\n-    /// Mapping of server component path to required CSS client chunks.\n-    #[serde(rename = \"entryCSSFiles\")]\n-    pub entry_css_files: FxIndexMap<RcStr, FxIndexSet<CssResource>>,\n-    /// Mapping of server component path to required JS client chunks.\n-    #[serde(rename = \"entryJSFiles\")]\n-    pub entry_js_files: FxIndexMap<RcStr, FxIndexSet<RcStr>>,\n-}\n-\n-#[derive(Serialize, Debug, Clone, Eq, Hash, PartialEq)]\n-pub struct CssResource {\n-    pub path: RcStr,\n-    pub inlined: bool,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub content: Option<RcStr>,\n-}\n-\n-#[derive(Serialize, Default, Debug)]\n-#[serde(rename_all = \"camelCase\")]\n-pub struct ModuleLoading {\n-    pub prefix: RcStr,\n-    pub cross_origin: Option<CrossOriginConfig>,\n-}\n-\n-#[derive(Serialize, Default, Debug, Clone)]\n-#[serde(rename_all = \"camelCase\")]\n-pub struct ManifestNode {\n-    /// Mapping of export name to manifest node entry.\n-    #[serde(flatten)]\n-    pub module_exports: FxIndexMap<RcStr, ManifestNodeEntry>,\n-}\n-\n-#[derive(Serialize, Debug, Clone)]\n-#[serde(rename_all = \"camelCase\")]\n-pub struct ManifestNodeEntry {\n-    /// Turbopack module ID.\n-    pub id: ModuleId,\n-    /// Export name.\n-    pub name: RcStr,\n-    /// Chunks for the module. JS and CSS.\n-    pub chunks: Vec<RcStr>,\n-    // TODO(WEB-434)\n-    pub r#async: bool,\n-}\n-\n #[derive(Serialize, Debug, Eq, PartialEq, Hash, Clone)]\n #[serde(rename_all = \"camelCase\")]\n #[serde(untagged)]"
        }
    ],
    "stats": {
        "total": 1080,
        "additions": 561,
        "deletions": 519
    }
}