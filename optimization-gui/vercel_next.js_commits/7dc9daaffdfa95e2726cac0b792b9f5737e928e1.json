{
    "author": "mischnic",
    "message": "Turbopack: add traces to merged module computation (#83908)\n\n<img width=\"1473\" height=\"317\" alt=\"Bildschirmfoto 2025-09-17 um 20 53 50\" src=\"https://github.com/user-attachments/assets/37954991-35e0-4bcb-9aad-772feff35148\" />",
    "sha": "7dc9daaffdfa95e2726cac0b792b9f5737e928e1",
    "files": [
        {
            "sha": "ffe79b4340aa3117ecaa4eff344fc1c427d5af63",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/merged_modules.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 7,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/7dc9daaffdfa95e2726cac0b792b9f5737e928e1/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7dc9daaffdfa95e2726cac0b792b9f5737e928e1/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs?ref=7dc9daaffdfa95e2726cac0b792b9f5737e928e1",
            "patch": "@@ -3,9 +3,7 @@ use std::collections::hash_map::Entry;\n use anyhow::{Context, Result, bail};\n use rustc_hash::{FxHashMap, FxHashSet};\n use tracing::Instrument;\n-use turbo_tasks::{\n-    FxIndexMap, FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc,\n-};\n+use turbo_tasks::{FxIndexMap, FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Vc};\n \n use crate::{\n     chunk::{\n@@ -99,6 +97,7 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n         let mut entry_modules =\n             FxHashSet::with_capacity_and_hasher(module_count, Default::default());\n \n+        let inner_span = tracing::info_span!(\"collect mergeable modules\");\n         let mergeable = graphs\n             .iter()\n             .flat_map(|g| g.iter_nodes())\n@@ -113,10 +112,13 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                 Ok(None)\n             })\n             .try_flat_join()\n+            .instrument(inner_span)\n             .await?\n             .into_iter()\n             .collect::<FxHashSet<_>>();\n \n+        let inner_span = tracing::info_span!(\"fixed point traversal\").entered();\n+\n         let mut next_index = 0u32;\n         let visit_count = module_graph.traverse_edges_fixed_point_with_priority(\n             entries.iter().map(|e| (*e, 0)),\n@@ -197,6 +199,9 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             |_, _| Ok(0),\n         )?;\n \n+        drop(inner_span);\n+        let inner_span = tracing::info_span!(\"chunk group collection\").entered();\n+\n         span.record(\"visit_count\", visit_count);\n \n         #[derive(Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n@@ -313,6 +318,9 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             )?;\n         }\n \n+        drop(inner_span);\n+        let inner_span = tracing::info_span!(\"exposed computation\").entered();\n+\n         // We use list.pop() below, so reverse order using negation\n         lists_reverse_indices\n             .sort_by_cached_key(|_, b| b.iter().map(|o| o.entry).min().map(|v| -(v as i64)));\n@@ -363,6 +371,8 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             },\n         )?;\n \n+        drop(inner_span);\n+        let inner_span = tracing::info_span!(\"reconciliation\").entered();\n         while let Some((_, common_occurrences)) = lists_reverse_indices.pop() {\n             if common_occurrences.len() < 2 {\n                 // Module exists only in one list, no need to split\n@@ -485,10 +495,7 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                     lists.push(after_list.clone());\n                     for (i, &m) in after_list.iter().enumerate() {\n                         let Some(occurrences) = lists_reverse_indices.get_mut(&m) else {\n-                            bail!(\n-                                \"Couldn't find module in list {:?}\",\n-                                m.ident().to_string().await?,\n-                            );\n+                            bail!(\"Couldn't find module in reverse list\");\n                         };\n \n                         let removed = occurrences.swap_remove(&ListOccurrence {\n@@ -509,6 +516,8 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n         // Dedupe the lists\n         let lists = lists.into_iter().collect::<FxHashSet<_>>();\n \n+        drop(inner_span);\n+        let inner_span = tracing::info_span!(\"merging\");\n         // Call MergeableModule impl to merge the modules.\n         let result = lists\n             .into_iter()\n@@ -570,6 +579,7 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                 )))\n             })\n             .try_join()\n+            .instrument(inner_span)\n             .await?;\n \n         #[allow(clippy::type_complexity)]"
        }
    ],
    "stats": {
        "total": 24,
        "additions": 17,
        "deletions": 7
    }
}