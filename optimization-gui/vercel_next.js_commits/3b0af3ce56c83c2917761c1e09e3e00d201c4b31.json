{
    "author": "sokra",
    "message": "Turbopack: more checks on verify_serialization (#84952)\n\n### What?\n\nAdd a few more checks when verify_serialization is enabled",
    "sha": "3b0af3ce56c83c2917761c1e09e3e00d201c4b31",
    "files": [
        {
            "sha": "bb21b8fa64f249f5936acf9e958da6725d94b32b",
            "filename": "turbopack/crates/turbo-tasks-backend/src/kv_backing_storage.rs",
            "status": "modified",
            "additions": 51,
            "deletions": 4,
            "changes": 55,
            "blob_url": "https://github.com/vercel/next.js/blob/3b0af3ce56c83c2917761c1e09e3e00d201c4b31/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3b0af3ce56c83c2917761c1e09e3e00d201c4b31/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs?ref=3b0af3ce56c83c2917761c1e09e3e00d201c4b31",
            "patch": "@@ -679,9 +679,53 @@ fn serialize_task_type(\n         let deserialize: Result<CachedTaskType, _> = serde_path_to_error::deserialize(\n             &mut pot_de_symbol_list().deserializer_for_slice(&*task_type_bytes)?,\n         );\n-        if let Err(err) = deserialize {\n-            println!(\"Task type would not be deserializable {task_id:?}: {err:?}\\n{task_type:#?}\");\n-            panic!(\"Task type would not be deserializable {task_id:?}: {err:?}\");\n+        match deserialize {\n+            Err(err) => {\n+                println!(\n+                    \"Task type would not be deserializable {task_id:?}: {err:?}\\n{task_type:#?}\"\n+                );\n+                panic!(\"Task type would not be deserializable {task_id:?}: {err:?}\");\n+            }\n+            Ok(task_type2) => {\n+                if &task_type2 != task_type {\n+                    println!(\n+                        \"Task type would not round-trip {task_id:?}:\\noriginal: \\\n+                         {task_type:#?}\\nround-tripped: {task_type2:#?}\"\n+                    );\n+                    panic!(\n+                        \"Task type would not round-trip {task_id:?}:\\noriginal: \\\n+                         {task_type:#?}\\nround-tripped: {task_type2:#?}\"\n+                    );\n+                }\n+                let mut bytes2 = Vec::new();\n+                let result2 = POT_CONFIG.serialize_into(&task_type2, &mut bytes2);\n+                match result2 {\n+                    Err(err) => {\n+                        println!(\n+                            \"Task type would not be serializable the second time {task_id:?}: \\\n+                             {err:?}\\n{task_type2:#?}\"\n+                        );\n+                        panic!(\n+                            \"Task type would not be serializable the second time {task_id:?}: \\\n+                             {err:?}\\n{task_type2:#?}\"\n+                        );\n+                    }\n+                    Ok(()) => {\n+                        if bytes2 != *task_type_bytes {\n+                            println!(\n+                                \"Task type would not serialize to the same bytes the second time \\\n+                                 {task_id:?}:\\noriginal: {:x?}\\nsecond: {:x?}\\n{task_type2:#?}\",\n+                                task_type_bytes, bytes2\n+                            );\n+                            panic!(\n+                                \"Task type would not serialize to the same bytes the second time \\\n+                                 {task_id:?}:\\noriginal: {:x?}\\nsecond: {:x?}\\n{task_type2:#?}\",\n+                                task_type_bytes, bytes2\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n         }\n     }\n     Ok(())\n@@ -757,7 +801,10 @@ fn serialize(task: TaskId, data: &Vec<CachedDataItem>) -> Result<SmallVec<[u8; 1\n                 if let Err(err) = serde_path_to_error::serialize(&item, &mut serializer) {\n                     if item.is_optional() {\n                         #[cfg(feature = \"verify_serialization\")]\n-                        println!(\"Skipping non-serializable optional item for {task}: {item:?}\");\n+                        println!(\n+                            \"Skipping non-serializable optional item for {task}: {item:?} due to \\\n+                             {err}\"\n+                        );\n                     } else {\n                         error = Err(err).context({\n                             anyhow!(\"Unable to serialize data item for {task}: {item:?}\")"
        }
    ],
    "stats": {
        "total": 55,
        "additions": 51,
        "deletions": 4
    }
}