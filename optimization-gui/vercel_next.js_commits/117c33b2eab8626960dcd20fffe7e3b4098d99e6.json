{
    "author": "sokra",
    "message": "Turbopack: report changed env vars in tracing (#88195)\n\n### What?\n\nAdd a list of changed defined env vars to the trace file",
    "sha": "117c33b2eab8626960dcd20fffe7e3b4098d99e6",
    "files": [
        {
            "sha": "1b4e996a54bdff0ad964f3e726c8f207dec9c4ec",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 113,
            "deletions": 21,
            "changes": 134,
            "blob_url": "https://github.com/vercel/next.js/blob/117c33b2eab8626960dcd20fffe7e3b4098d99e6/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/117c33b2eab8626960dcd20fffe7e3b4098d99e6/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=117c33b2eab8626960dcd20fffe7e3b4098d99e6",
            "patch": "@@ -25,8 +25,9 @@ use next_core::{\n     segment_config::ParseSegmentMode,\n     util::{NextRuntime, OptionEnvMap},\n };\n+use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n-use tracing::Instrument;\n+use tracing::{Instrument, field::Empty};\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n     Completion, Completions, FxIndexMap, IntoTraitRef, NonLocalValue, OperationValue, OperationVc,\n@@ -329,34 +330,125 @@ fn output_fs_operation(project: ResolvedVc<Project>) -> Vc<DiskFileSystem> {\n     project.project_fs()\n }\n \n+enum EnvDiffType {\n+    Added,\n+    Removed,\n+    Modified,\n+}\n+\n+fn env_diff(\n+    old: &[(RcStr, Option<RcStr>)],\n+    new: &[(RcStr, Option<RcStr>)],\n+) -> Vec<(RcStr, EnvDiffType)> {\n+    let mut diffs = Vec::new();\n+    let mut old_map: FxHashMap<_, _> = old.iter().cloned().collect();\n+\n+    for (key, new_value) in new.iter() {\n+        match old_map.remove(key) {\n+            Some(old_value) => {\n+                if &old_value != new_value {\n+                    diffs.push((key.clone(), EnvDiffType::Modified));\n+                }\n+            }\n+            None => {\n+                diffs.push((key.clone(), EnvDiffType::Added));\n+            }\n+        }\n+    }\n+\n+    for (key, _) in old.iter() {\n+        if old_map.contains_key(key) {\n+            diffs.push((key.clone(), EnvDiffType::Removed));\n+        }\n+    }\n+\n+    diffs\n+}\n+\n+fn env_diff_report(old: &[(RcStr, Option<RcStr>)], new: &[(RcStr, Option<RcStr>)]) -> String {\n+    use std::fmt::Write;\n+\n+    let diff = env_diff(old, new);\n+\n+    let mut report = String::new();\n+    for (key, diff_type) in diff {\n+        let symbol = match diff_type {\n+            EnvDiffType::Added => \"+\",\n+            EnvDiffType::Removed => \"-\",\n+            EnvDiffType::Modified => \"*\",\n+        };\n+        if !report.is_empty() {\n+            report.push_str(\", \");\n+        }\n+        write!(report, \"{}{}\", symbol, key).unwrap();\n+    }\n+    report\n+}\n+\n+fn define_env_diff_report(old: &DefineEnv, new: &DefineEnv) -> String {\n+    use std::fmt::Write;\n+\n+    let mut report = String::new();\n+    for (name, old, new) in [\n+        (\"client\", &old.client, &new.client),\n+        (\"edge\", &old.edge, &new.edge),\n+        (\"nodejs\", &old.nodejs, &new.nodejs),\n+    ] {\n+        let diff = env_diff_report(old, new);\n+        if !diff.is_empty() {\n+            if !report.is_empty() {\n+                report.push_str(\", \");\n+            }\n+            write!(report, \"{name}: {{ {diff} }}\").unwrap();\n+        }\n+    }\n+    report\n+}\n+\n impl ProjectContainer {\n-    #[tracing::instrument(level = \"info\", name = \"initialize project\", skip_all)]\n     pub async fn initialize(self: ResolvedVc<Self>, options: ProjectOptions) -> Result<()> {\n-        let watch = options.watch;\n+        let span = tracing::info_span!(\n+            \"initialize project\",\n+            project_name = %self.await?.name,\n+            env_diff = Empty\n+        );\n+        let span_clone = span.clone();\n+        async move {\n+            let watch = options.watch;\n \n-        self.await?.options_state.set(Some(options));\n+            let this = self.await?;\n+            if let Some(old_options) = &*this.options_state.get_untracked() {\n+                span.record(\n+                    \"env_diff\",\n+                    define_env_diff_report(&old_options.define_env, &options.define_env).as_str(),\n+                );\n+            }\n+            this.options_state.set(Some(options));\n \n-        let project = self.project().to_resolved().await?;\n-        let project_fs = project_fs_operation(project)\n-            .read_strongly_consistent()\n-            .await?;\n-        if watch.enable {\n-            project_fs\n-                .start_watching_with_invalidation_reason(watch.poll_interval)\n+            let project = self.project().to_resolved().await?;\n+            let project_fs = project_fs_operation(project)\n+                .read_strongly_consistent()\n                 .await?;\n-        } else {\n-            project_fs.invalidate_with_reason(|path| invalidation::Initialize {\n-                // this path is just used for display purposes\n+            if watch.enable {\n+                project_fs\n+                    .start_watching_with_invalidation_reason(watch.poll_interval)\n+                    .await?;\n+            } else {\n+                project_fs.invalidate_with_reason(|path| invalidation::Initialize {\n+                    // this path is just used for display purposes\n+                    path: RcStr::from(path.to_string_lossy()),\n+                });\n+            }\n+            let output_fs = output_fs_operation(project)\n+                .read_strongly_consistent()\n+                .await?;\n+            output_fs.invalidate_with_reason(|path| invalidation::Initialize {\n                 path: RcStr::from(path.to_string_lossy()),\n             });\n+            Ok(())\n         }\n-        let output_fs = output_fs_operation(project)\n-            .read_strongly_consistent()\n-            .await?;\n-        output_fs.invalidate_with_reason(|path| invalidation::Initialize {\n-            path: RcStr::from(path.to_string_lossy()),\n-        });\n-        Ok(())\n+        .instrument(span_clone)\n+        .await\n     }\n \n     #[tracing::instrument(level = \"info\", name = \"update project options\", skip_all)]"
        }
    ],
    "stats": {
        "total": 134,
        "additions": 113,
        "deletions": 21
    }
}