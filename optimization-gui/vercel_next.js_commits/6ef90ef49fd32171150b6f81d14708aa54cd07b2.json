{
    "author": "nextjs-bot",
    "message": "Upgrade React from `fd524fe0-20251121` to `7dc903cd-20251203` (#86771)",
    "sha": "6ef90ef49fd32171150b6f81d14708aa54cd07b2",
    "files": [
        {
            "sha": "acaa09b5d67852e7762610f3c2689db9bb945fe2",
            "filename": "examples/reproduction-template/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/examples%2Freproduction-template%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/examples%2Freproduction-template%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/examples%2Freproduction-template%2Fpackage.json?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -7,8 +7,8 @@\n   },\n   \"dependencies\": {\n     \"next\": \"canary\",\n-    \"react\": \"19.2.0\",\n-    \"react-dom\": \"19.2.0\"\n+    \"react\": \"19.2.1\",\n+    \"react-dom\": \"19.2.1\"\n   },\n   \"devDependencies\": {\n     \"@types/node\": \"^22\","
        },
        {
            "sha": "bed33258ed0c8126564894bfc28a55a4133df9d7",
            "filename": "package.json",
            "status": "modified",
            "additions": 16,
            "deletions": 16,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/package.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/package.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/package.json?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -197,7 +197,7 @@\n     \"eslint-plugin-jsdoc\": \"48.0.4\",\n     \"eslint-plugin-mdx\": \"3.1.5\",\n     \"eslint-plugin-react\": \"7.37.0\",\n-    \"eslint-plugin-react-hooks\": \"0.0.0-experimental-fd524fe0-20251121\",\n+    \"eslint-plugin-react-hooks\": \"0.0.0-experimental-7dc903cd-20251203\",\n     \"event-stream\": \"4.0.1\",\n     \"execa\": \"2.0.3\",\n     \"expect\": \"29.7.0\",\n@@ -257,16 +257,16 @@\n     \"pretty-ms\": \"7.0.0\",\n     \"random-seed\": \"0.3.0\",\n     \"react\": \"19.0.0\",\n-    \"react-builtin\": \"npm:react@19.3.0-canary-fd524fe0-20251121\",\n+    \"react-builtin\": \"npm:react@19.3.0-canary-7dc903cd-20251203\",\n     \"react-dom\": \"19.0.0\",\n-    \"react-dom-builtin\": \"npm:react-dom@19.3.0-canary-fd524fe0-20251121\",\n-    \"react-dom-experimental-builtin\": \"npm:react-dom@0.0.0-experimental-fd524fe0-20251121\",\n-    \"react-experimental-builtin\": \"npm:react@0.0.0-experimental-fd524fe0-20251121\",\n-    \"react-is-builtin\": \"npm:react-is@19.3.0-canary-fd524fe0-20251121\",\n-    \"react-server-dom-turbopack\": \"19.3.0-canary-fd524fe0-20251121\",\n-    \"react-server-dom-turbopack-experimental\": \"npm:react-server-dom-turbopack@0.0.0-experimental-fd524fe0-20251121\",\n-    \"react-server-dom-webpack\": \"19.3.0-canary-fd524fe0-20251121\",\n-    \"react-server-dom-webpack-experimental\": \"npm:react-server-dom-webpack@0.0.0-experimental-fd524fe0-20251121\",\n+    \"react-dom-builtin\": \"npm:react-dom@19.3.0-canary-7dc903cd-20251203\",\n+    \"react-dom-experimental-builtin\": \"npm:react-dom@0.0.0-experimental-7dc903cd-20251203\",\n+    \"react-experimental-builtin\": \"npm:react@0.0.0-experimental-7dc903cd-20251203\",\n+    \"react-is-builtin\": \"npm:react-is@19.3.0-canary-7dc903cd-20251203\",\n+    \"react-server-dom-turbopack\": \"19.3.0-canary-7dc903cd-20251203\",\n+    \"react-server-dom-turbopack-experimental\": \"npm:react-server-dom-turbopack@0.0.0-experimental-7dc903cd-20251203\",\n+    \"react-server-dom-webpack\": \"19.3.0-canary-7dc903cd-20251203\",\n+    \"react-server-dom-webpack-experimental\": \"npm:react-server-dom-webpack@0.0.0-experimental-7dc903cd-20251203\",\n     \"react-ssr-prepass\": \"1.0.8\",\n     \"react-virtualized\": \"9.22.3\",\n     \"relay-compiler\": \"13.0.2\",\n@@ -276,8 +276,8 @@\n     \"resolve-from\": \"5.0.0\",\n     \"sass\": \"1.54.0\",\n     \"satori\": \"0.15.2\",\n-    \"scheduler-builtin\": \"npm:scheduler@0.28.0-canary-fd524fe0-20251121\",\n-    \"scheduler-experimental-builtin\": \"npm:scheduler@0.0.0-experimental-fd524fe0-20251121\",\n+    \"scheduler-builtin\": \"npm:scheduler@0.28.0-canary-7dc903cd-20251203\",\n+    \"scheduler-experimental-builtin\": \"npm:scheduler@0.0.0-experimental-7dc903cd-20251203\",\n     \"seedrandom\": \"3.0.5\",\n     \"semver\": \"7.3.7\",\n     \"serve-handler\": \"6.1.6\",\n@@ -322,10 +322,10 @@\n       \"@types/react-dom\": \"19.2.1\",\n       \"@types/retry\": \"0.12.0\",\n       \"jest-snapshot\": \"30.0.0-alpha.6\",\n-      \"react\": \"19.3.0-canary-fd524fe0-20251121\",\n-      \"react-dom\": \"19.3.0-canary-fd524fe0-20251121\",\n-      \"react-is\": \"19.3.0-canary-fd524fe0-20251121\",\n-      \"scheduler\": \"0.28.0-canary-fd524fe0-20251121\"\n+      \"react\": \"19.3.0-canary-7dc903cd-20251203\",\n+      \"react-dom\": \"19.3.0-canary-7dc903cd-20251203\",\n+      \"react-is\": \"19.3.0-canary-7dc903cd-20251203\",\n+      \"scheduler\": \"0.28.0-canary-7dc903cd-20251203\"\n     },\n     \"packageExtensions\": {\n       \"eslint-plugin-react-hooks@0.0.0-experimental-6de32a5a-20250822\": {"
        },
        {
            "sha": "112c46f36a842e4bb9d8161af6c71a82098bb28c",
            "filename": "packages/create-next-app/templates/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fcreate-next-app%2Ftemplates%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fcreate-next-app%2Ftemplates%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fcreate-next-app%2Ftemplates%2Findex.ts?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -14,7 +14,7 @@ import { Bundler, GetTemplateFileArgs, InstallTemplateArgs } from \"./types\";\n \n // Do not rename or format. sync-react script relies on this line.\n // prettier-ignore\n-const nextjsReactPeerVersion = \"19.2.0\";\n+const nextjsReactPeerVersion = \"19.2.1\";\n function sorted(obj: Record<string, string>) {\n   return Object.keys(obj)\n     .sort()"
        },
        {
            "sha": "ba7d351ae708d96f68f782983fd1aa01619fe0c8",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-client.development.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-client.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-client.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-client.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -32446,11 +32446,11 @@\n     };\n     (function () {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.3.0-experimental-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+      if (\"19.3.0-experimental-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.3.0-experimental-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.3.0-experimental-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     })();\n     (\"function\" === typeof Map &&\n@@ -32487,10 +32487,10 @@\n       !(function () {\n         var internals = {\n           bundleType: 1,\n-          version: \"19.3.0-experimental-fd524fe0-20251121\",\n+          version: \"19.3.0-experimental-7dc903cd-20251203\",\n           rendererPackageName: \"react-dom\",\n           currentDispatcherRef: ReactSharedInternals,\n-          reconcilerVersion: \"19.3.0-experimental-fd524fe0-20251121\"\n+          reconcilerVersion: \"19.3.0-experimental-7dc903cd-20251203\"\n         };\n         internals.overrideHookState = overrideHookState;\n         internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n@@ -32638,7 +32638,7 @@\n       listenToAllSupportedEvents(container);\n       return new ReactDOMHydrationRoot(initialChildren);\n     };\n-    exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "58edb8dc12707194111169133a934d059378f955",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-client.production.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-client.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-client.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-client.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -19666,14 +19666,14 @@ ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n };\n var isomorphicReactPackageVersion$jscomp$inline_2213 = React.version;\n if (\n-  \"19.3.0-experimental-fd524fe0-20251121\" !==\n+  \"19.3.0-experimental-7dc903cd-20251203\" !==\n   isomorphicReactPackageVersion$jscomp$inline_2213\n )\n   throw Error(\n     formatProdErrorMessage(\n       527,\n       isomorphicReactPackageVersion$jscomp$inline_2213,\n-      \"19.3.0-experimental-fd524fe0-20251121\"\n+      \"19.3.0-experimental-7dc903cd-20251203\"\n     )\n   );\n ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n@@ -19695,10 +19695,10 @@ ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n };\n var internals$jscomp$inline_2916 = {\n   bundleType: 0,\n-  version: \"19.3.0-experimental-fd524fe0-20251121\",\n+  version: \"19.3.0-experimental-7dc903cd-20251203\",\n   rendererPackageName: \"react-dom\",\n   currentDispatcherRef: ReactSharedInternals,\n-  reconcilerVersion: \"19.3.0-experimental-fd524fe0-20251121\"\n+  reconcilerVersion: \"19.3.0-experimental-7dc903cd-20251203\"\n };\n if (\"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n   var hook$jscomp$inline_2917 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n@@ -19805,4 +19805,4 @@ exports.hydrateRoot = function (container, initialChildren, options) {\n   listenToAllSupportedEvents(container);\n   return new ReactDOMHydrationRoot(initialChildren);\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";"
        },
        {
            "sha": "ae61c1faf6734f2310ea0b66035f96c659f6e023",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-profiling.development.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-profiling.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-profiling.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-profiling.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -32503,11 +32503,11 @@\n     };\n     (function () {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.3.0-experimental-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+      if (\"19.3.0-experimental-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.3.0-experimental-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.3.0-experimental-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     })();\n     (\"function\" === typeof Map &&\n@@ -32544,10 +32544,10 @@\n       !(function () {\n         var internals = {\n           bundleType: 1,\n-          version: \"19.3.0-experimental-fd524fe0-20251121\",\n+          version: \"19.3.0-experimental-7dc903cd-20251203\",\n           rendererPackageName: \"react-dom\",\n           currentDispatcherRef: ReactSharedInternals,\n-          reconcilerVersion: \"19.3.0-experimental-fd524fe0-20251121\"\n+          reconcilerVersion: \"19.3.0-experimental-7dc903cd-20251203\"\n         };\n         internals.overrideHookState = overrideHookState;\n         internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n@@ -33025,7 +33025,7 @@\n     exports.useFormStatus = function () {\n       return resolveDispatcher().useHostTransitionStatus();\n     };\n-    exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "9806f6387a1c029f21972429ef64cf887a9a8b51",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-profiling.profiling.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-profiling.profiling.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-profiling.profiling.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-profiling.profiling.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -21726,14 +21726,14 @@ ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n };\n var isomorphicReactPackageVersion$jscomp$inline_2509 = React.version;\n if (\n-  \"19.3.0-experimental-fd524fe0-20251121\" !==\n+  \"19.3.0-experimental-7dc903cd-20251203\" !==\n   isomorphicReactPackageVersion$jscomp$inline_2509\n )\n   throw Error(\n     formatProdErrorMessage(\n       527,\n       isomorphicReactPackageVersion$jscomp$inline_2509,\n-      \"19.3.0-experimental-fd524fe0-20251121\"\n+      \"19.3.0-experimental-7dc903cd-20251203\"\n     )\n   );\n ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n@@ -21755,10 +21755,10 @@ ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n };\n var internals$jscomp$inline_3225 = {\n   bundleType: 0,\n-  version: \"19.3.0-experimental-fd524fe0-20251121\",\n+  version: \"19.3.0-experimental-7dc903cd-20251203\",\n   rendererPackageName: \"react-dom\",\n   currentDispatcherRef: ReactSharedInternals,\n-  reconcilerVersion: \"19.3.0-experimental-fd524fe0-20251121\"\n+  reconcilerVersion: \"19.3.0-experimental-7dc903cd-20251203\"\n };\n if (\"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n   var hook$jscomp$inline_3226 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n@@ -22026,7 +22026,7 @@ exports.useFormState = function (action, initialState, permalink) {\n exports.useFormStatus = function () {\n   return ReactSharedInternals.H.useHostTransitionStatus();\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n   \"function\" ===\n     typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "5e376d4db8c87e0111f6cbec0512e807ae4bccad",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server-legacy.browser.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.browser.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -10411,5 +10411,5 @@\n         'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n       );\n     };\n-    exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "fe9cd51be2037ae32bf13e4c233659bfa382bb20",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server-legacy.browser.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.browser.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -7035,4 +7035,4 @@ exports.renderToString = function (children, options) {\n     'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n   );\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";"
        },
        {
            "sha": "95d1140b72439035c11c252eefe2e0d236e13509",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server-legacy.node.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.node.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -10411,5 +10411,5 @@\n         'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server'\n       );\n     };\n-    exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "fc6e10e54774ffbb69d7f5d1c28b673abcc61e2c",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server-legacy.node.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.node.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -7138,4 +7138,4 @@ exports.renderToString = function (children, options) {\n     'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server'\n   );\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";"
        },
        {
            "sha": "c8d2b7e3676447f7e39b4fbd0afe0aa5a80c7da0",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.browser.development.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.browser.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -9390,11 +9390,11 @@\n     }\n     function ensureCorrectIsomorphicReactVersion() {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.3.0-experimental-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+      if (\"19.3.0-experimental-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.3.0-experimental-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.3.0-experimental-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     }\n     var React = require(\"next/dist/compiled/react-experimental\"),\n@@ -11214,5 +11214,5 @@\n         startWork(request);\n       });\n     };\n-    exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "da88ee91b6cd268e89117332f21098ec0eecb59a",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.browser.production.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.browser.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -7688,12 +7688,12 @@ function getPostponedState(request) {\n }\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.3.0-experimental-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+  if (\"19.3.0-experimental-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n     throw Error(\n       formatProdErrorMessage(\n         527,\n         isomorphicReactPackageVersion,\n-        \"19.3.0-experimental-fd524fe0-20251121\"\n+        \"19.3.0-experimental-7dc903cd-20251203\"\n       )\n     );\n }\n@@ -7944,4 +7944,4 @@ exports.resumeAndPrerender = function (children, postponedState, options) {\n     startWork(request);\n   });\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";"
        },
        {
            "sha": "392e0b656e86bbb6447f03805fc5ed23ca2426ce",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.bun.production.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.bun.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.bun.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.bun.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -7383,11 +7383,11 @@ function getPostponedState(request) {\n }\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.3.0-experimental-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+  if (\"19.3.0-experimental-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n     throw Error(\n       'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n         (isomorphicReactPackageVersion +\n-          \"\\n  - react-dom:  19.3.0-experimental-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+          \"\\n  - react-dom:  19.3.0-experimental-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n     );\n }\n ensureCorrectIsomorphicReactVersion();\n@@ -7932,4 +7932,4 @@ exports.resumeToPipeableStream = function (children, postponedState, options) {\n     }\n   };\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";"
        },
        {
            "sha": "52a9e484388eb8aa2ad3b86ec00343267eccfb77",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.edge.development.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.edge.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -9419,11 +9419,11 @@\n     }\n     function ensureCorrectIsomorphicReactVersion() {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.3.0-experimental-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+      if (\"19.3.0-experimental-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.3.0-experimental-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.3.0-experimental-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     }\n     var React = require(\"next/dist/compiled/react-experimental\"),\n@@ -11239,5 +11239,5 @@\n         startWork(request);\n       });\n     };\n-    exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "d28353d52b51dedb6d28b3058d4d424a38a134b3",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.edge.production.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.edge.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -7806,11 +7806,11 @@ function getPostponedState(request) {\n }\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.3.0-experimental-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+  if (\"19.3.0-experimental-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n     throw Error(\n       'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n         (isomorphicReactPackageVersion +\n-          \"\\n  - react-dom:  19.3.0-experimental-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+          \"\\n  - react-dom:  19.3.0-experimental-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n     );\n }\n ensureCorrectIsomorphicReactVersion();\n@@ -8060,4 +8060,4 @@ exports.resumeAndPrerender = function (children, postponedState, options) {\n     startWork(request);\n   });\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";"
        },
        {
            "sha": "93a2a8f5f89df52e9955f4e908abc26ffdc0cb29",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.node.development.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.node.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -9279,11 +9279,11 @@\n     }\n     function ensureCorrectIsomorphicReactVersion() {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.3.0-experimental-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+      if (\"19.3.0-experimental-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.3.0-experimental-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.3.0-experimental-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     }\n     function createDrainHandler(destination, request) {\n@@ -11405,5 +11405,5 @@\n         }\n       };\n     };\n-    exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "a03ea982be3ff42582a19b3d5e5589d9cc666851",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.node.production.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.node.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -7685,11 +7685,11 @@ function getPostponedState(request) {\n }\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.3.0-experimental-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+  if (\"19.3.0-experimental-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n     throw Error(\n       'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n         (isomorphicReactPackageVersion +\n-          \"\\n  - react-dom:  19.3.0-experimental-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+          \"\\n  - react-dom:  19.3.0-experimental-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n     );\n }\n ensureCorrectIsomorphicReactVersion();\n@@ -8239,4 +8239,4 @@ exports.resumeToPipeableStream = function (children, postponedState, options) {\n     }\n   };\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";"
        },
        {
            "sha": "f4b9f60f14f2aee8145715c297571d2bdf555119",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-unstable_testing.development.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-unstable_testing.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-unstable_testing.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-unstable_testing.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -32767,11 +32767,11 @@\n     };\n     (function () {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.3.0-experimental-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+      if (\"19.3.0-experimental-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.3.0-experimental-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.3.0-experimental-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     })();\n     (\"function\" === typeof Map &&\n@@ -32808,10 +32808,10 @@\n       !(function () {\n         var internals = {\n           bundleType: 1,\n-          version: \"19.3.0-experimental-fd524fe0-20251121\",\n+          version: \"19.3.0-experimental-7dc903cd-20251203\",\n           rendererPackageName: \"react-dom\",\n           currentDispatcherRef: ReactSharedInternals,\n-          reconcilerVersion: \"19.3.0-experimental-fd524fe0-20251121\"\n+          reconcilerVersion: \"19.3.0-experimental-7dc903cd-20251203\"\n         };\n         internals.overrideHookState = overrideHookState;\n         internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n@@ -33125,5 +33125,5 @@\n         }\n       };\n     };\n-    exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "a88548ccdf92d7f4acfaba1703da1359b0f2ed2d",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-unstable_testing.production.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-unstable_testing.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-unstable_testing.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-unstable_testing.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -19982,14 +19982,14 @@ ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n };\n var isomorphicReactPackageVersion$jscomp$inline_2242 = React.version;\n if (\n-  \"19.3.0-experimental-fd524fe0-20251121\" !==\n+  \"19.3.0-experimental-7dc903cd-20251203\" !==\n   isomorphicReactPackageVersion$jscomp$inline_2242\n )\n   throw Error(\n     formatProdErrorMessage(\n       527,\n       isomorphicReactPackageVersion$jscomp$inline_2242,\n-      \"19.3.0-experimental-fd524fe0-20251121\"\n+      \"19.3.0-experimental-7dc903cd-20251203\"\n     )\n   );\n ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n@@ -20011,10 +20011,10 @@ ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n };\n var internals$jscomp$inline_2950 = {\n   bundleType: 0,\n-  version: \"19.3.0-experimental-fd524fe0-20251121\",\n+  version: \"19.3.0-experimental-7dc903cd-20251203\",\n   rendererPackageName: \"react-dom\",\n   currentDispatcherRef: ReactSharedInternals,\n-  reconcilerVersion: \"19.3.0-experimental-fd524fe0-20251121\"\n+  reconcilerVersion: \"19.3.0-experimental-7dc903cd-20251203\"\n };\n if (\"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n   var hook$jscomp$inline_2951 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n@@ -20272,4 +20272,4 @@ exports.observeVisibleRects = function (\n     }\n   };\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";"
        },
        {
            "sha": "2a5a7cee892e01423f34415bf4bc28524c9bba65",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -422,7 +422,7 @@\n     exports.useFormStatus = function () {\n       return resolveDispatcher().useHostTransitionStatus();\n     };\n-    exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "fdb496da3028495dbda860aaf014a9164835bc39",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -213,4 +213,4 @@ exports.useFormState = function (action, initialState, permalink) {\n exports.useFormStatus = function () {\n   return ReactSharedInternals.H.useHostTransitionStatus();\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";"
        },
        {
            "sha": "c5ab2084a87bc3e8e6579903271ed1496428395d",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom.react-server.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.react-server.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.react-server.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.react-server.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -336,5 +336,5 @@\n             }))\n           : Internals.d.m(href));\n     };\n-    exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "643cfaff46034abec4f39936616719ee1c248e67",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom.react-server.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.react-server.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.react-server.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.react-server.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -149,4 +149,4 @@ exports.preloadModule = function (href, options) {\n       });\n     } else Internals.d.m(href);\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";"
        },
        {
            "sha": "53d08ad9a004cc0111840a2dc00ece6412556cb4",
            "filename": "packages/next/src/compiled/react-dom-experimental/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fpackage.json?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -72,10 +72,10 @@\n     \"./package.json\": \"./package.json\"\n   },\n   \"dependencies\": {\n-    \"scheduler\": \"0.0.0-experimental-fd524fe0-20251121\"\n+    \"scheduler\": \"0.0.0-experimental-7dc903cd-20251203\"\n   },\n   \"peerDependencies\": {\n-    \"react\": \"0.0.0-experimental-fd524fe0-20251121\"\n+    \"react\": \"0.0.0-experimental-7dc903cd-20251203\"\n   },\n   \"browser\": {\n     \"./server.js\": \"./server.browser.js\","
        },
        {
            "sha": "12576f918f7af4b5cc1880bb13df9af008bd542a",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-client.development.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-client.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-client.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-client.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -30396,11 +30396,11 @@\n     };\n     (function () {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.3.0-canary-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+      if (\"19.3.0-canary-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.3.0-canary-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.3.0-canary-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     })();\n     (\"function\" === typeof Map &&\n@@ -30437,10 +30437,10 @@\n       !(function () {\n         var internals = {\n           bundleType: 1,\n-          version: \"19.3.0-canary-fd524fe0-20251121\",\n+          version: \"19.3.0-canary-7dc903cd-20251203\",\n           rendererPackageName: \"react-dom\",\n           currentDispatcherRef: ReactSharedInternals,\n-          reconcilerVersion: \"19.3.0-canary-fd524fe0-20251121\"\n+          reconcilerVersion: \"19.3.0-canary-7dc903cd-20251203\"\n         };\n         internals.overrideHookState = overrideHookState;\n         internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n@@ -30578,7 +30578,7 @@\n       listenToAllSupportedEvents(container);\n       return new ReactDOMHydrationRoot(initialChildren);\n     };\n-    exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-canary-7dc903cd-20251203\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "2dc5424a1b0dad56f3d959fe6f92e82e4456a7b2",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-client.production.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-client.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-client.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-client.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -18013,14 +18013,14 @@ ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n };\n var isomorphicReactPackageVersion$jscomp$inline_2047 = React.version;\n if (\n-  \"19.3.0-canary-fd524fe0-20251121\" !==\n+  \"19.3.0-canary-7dc903cd-20251203\" !==\n   isomorphicReactPackageVersion$jscomp$inline_2047\n )\n   throw Error(\n     formatProdErrorMessage(\n       527,\n       isomorphicReactPackageVersion$jscomp$inline_2047,\n-      \"19.3.0-canary-fd524fe0-20251121\"\n+      \"19.3.0-canary-7dc903cd-20251203\"\n     )\n   );\n ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n@@ -18042,10 +18042,10 @@ ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n };\n var internals$jscomp$inline_2635 = {\n   bundleType: 0,\n-  version: \"19.3.0-canary-fd524fe0-20251121\",\n+  version: \"19.3.0-canary-7dc903cd-20251203\",\n   rendererPackageName: \"react-dom\",\n   currentDispatcherRef: ReactSharedInternals,\n-  reconcilerVersion: \"19.3.0-canary-fd524fe0-20251121\"\n+  reconcilerVersion: \"19.3.0-canary-7dc903cd-20251203\"\n };\n if (\"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n   var hook$jscomp$inline_2636 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n@@ -18143,4 +18143,4 @@ exports.hydrateRoot = function (container, initialChildren, options) {\n   listenToAllSupportedEvents(container);\n   return new ReactDOMHydrationRoot(initialChildren);\n };\n-exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+exports.version = \"19.3.0-canary-7dc903cd-20251203\";"
        },
        {
            "sha": "2be19d31f82b0000181af8b7f3837920537e1096",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-profiling.development.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-profiling.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-profiling.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-profiling.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -30454,11 +30454,11 @@\n     };\n     (function () {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.3.0-canary-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+      if (\"19.3.0-canary-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.3.0-canary-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.3.0-canary-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     })();\n     (\"function\" === typeof Map &&\n@@ -30495,10 +30495,10 @@\n       !(function () {\n         var internals = {\n           bundleType: 1,\n-          version: \"19.3.0-canary-fd524fe0-20251121\",\n+          version: \"19.3.0-canary-7dc903cd-20251203\",\n           rendererPackageName: \"react-dom\",\n           currentDispatcherRef: ReactSharedInternals,\n-          reconcilerVersion: \"19.3.0-canary-fd524fe0-20251121\"\n+          reconcilerVersion: \"19.3.0-canary-7dc903cd-20251203\"\n         };\n         internals.overrideHookState = overrideHookState;\n         internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n@@ -30966,7 +30966,7 @@\n     exports.useFormStatus = function () {\n       return resolveDispatcher().useHostTransitionStatus();\n     };\n-    exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-canary-7dc903cd-20251203\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "9d5a87e3ab528c6a8435d74031b29c989889f448",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-profiling.profiling.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-profiling.profiling.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-profiling.profiling.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-profiling.profiling.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -19941,14 +19941,14 @@ ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n };\n var isomorphicReactPackageVersion$jscomp$inline_2344 = React.version;\n if (\n-  \"19.3.0-canary-fd524fe0-20251121\" !==\n+  \"19.3.0-canary-7dc903cd-20251203\" !==\n   isomorphicReactPackageVersion$jscomp$inline_2344\n )\n   throw Error(\n     formatProdErrorMessage(\n       527,\n       isomorphicReactPackageVersion$jscomp$inline_2344,\n-      \"19.3.0-canary-fd524fe0-20251121\"\n+      \"19.3.0-canary-7dc903cd-20251203\"\n     )\n   );\n ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n@@ -19970,10 +19970,10 @@ ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n };\n var internals$jscomp$inline_2945 = {\n   bundleType: 0,\n-  version: \"19.3.0-canary-fd524fe0-20251121\",\n+  version: \"19.3.0-canary-7dc903cd-20251203\",\n   rendererPackageName: \"react-dom\",\n   currentDispatcherRef: ReactSharedInternals,\n-  reconcilerVersion: \"19.3.0-canary-fd524fe0-20251121\"\n+  reconcilerVersion: \"19.3.0-canary-7dc903cd-20251203\"\n };\n if (\"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n   var hook$jscomp$inline_2946 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n@@ -20232,7 +20232,7 @@ exports.useFormState = function (action, initialState, permalink) {\n exports.useFormStatus = function () {\n   return ReactSharedInternals.H.useHostTransitionStatus();\n };\n-exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+exports.version = \"19.3.0-canary-7dc903cd-20251203\";\n \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n   \"function\" ===\n     typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "f9ede91000ba6c023f3615463f549e1673998ca6",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server-legacy.browser.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.browser.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -10035,5 +10035,5 @@\n         'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n       );\n     };\n-    exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-canary-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "7fb1dc47c17126d25df23fef518f6223e70c7d09",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server-legacy.browser.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.browser.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -6763,4 +6763,4 @@ exports.renderToString = function (children, options) {\n     'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n   );\n };\n-exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+exports.version = \"19.3.0-canary-7dc903cd-20251203\";"
        },
        {
            "sha": "a8adc4e308fe7226542d166ac9c6140336c1b650",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.node.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -10035,5 +10035,5 @@\n         'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server'\n       );\n     };\n-    exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-canary-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "d3317bf4c1a5aab4e2b28f75eec60d9c55717a66",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server-legacy.node.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.node.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -6855,4 +6855,4 @@ exports.renderToString = function (children, options) {\n     'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server'\n   );\n };\n-exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+exports.version = \"19.3.0-canary-7dc903cd-20251203\";"
        },
        {
            "sha": "d57aa821b3d7fb96485414871890da04fc657bc2",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.browser.development.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.browser.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -9001,11 +9001,11 @@\n     }\n     function ensureCorrectIsomorphicReactVersion() {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.3.0-canary-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+      if (\"19.3.0-canary-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.3.0-canary-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.3.0-canary-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     }\n     var React = require(\"next/dist/compiled/react\"),\n@@ -10808,5 +10808,5 @@\n         startWork(request);\n       });\n     };\n-    exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-canary-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "9d786863f44e3c7875db415a70e13a26613d2b9d",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.browser.production.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.browser.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -7365,12 +7365,12 @@ function getPostponedState(request) {\n }\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.3.0-canary-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+  if (\"19.3.0-canary-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n     throw Error(\n       formatProdErrorMessage(\n         527,\n         isomorphicReactPackageVersion,\n-        \"19.3.0-canary-fd524fe0-20251121\"\n+        \"19.3.0-canary-7dc903cd-20251203\"\n       )\n     );\n }\n@@ -7621,4 +7621,4 @@ exports.resumeAndPrerender = function (children, postponedState, options) {\n     startWork(request);\n   });\n };\n-exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+exports.version = \"19.3.0-canary-7dc903cd-20251203\";"
        },
        {
            "sha": "f62f566541433550622f2a5dd1601a2a5e895bc9",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.bun.production.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.bun.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.bun.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.bun.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -7073,11 +7073,11 @@ function getPostponedState(request) {\n }\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.3.0-canary-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+  if (\"19.3.0-canary-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n     throw Error(\n       'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n         (isomorphicReactPackageVersion +\n-          \"\\n  - react-dom:  19.3.0-canary-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+          \"\\n  - react-dom:  19.3.0-canary-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n     );\n }\n ensureCorrectIsomorphicReactVersion();\n@@ -7622,4 +7622,4 @@ exports.resumeToPipeableStream = function (children, postponedState, options) {\n     }\n   };\n };\n-exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+exports.version = \"19.3.0-canary-7dc903cd-20251203\";"
        },
        {
            "sha": "bbd389fa77e0da58f3a2eb3f68aae88a8040bd86",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.edge.development.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.edge.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -9024,11 +9024,11 @@\n     }\n     function ensureCorrectIsomorphicReactVersion() {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.3.0-canary-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+      if (\"19.3.0-canary-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.3.0-canary-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.3.0-canary-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     }\n     var React = require(\"next/dist/compiled/react\"),\n@@ -10827,5 +10827,5 @@\n         startWork(request);\n       });\n     };\n-    exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-canary-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "99aa2e82175569c1384c785dac19fdf689c07b38",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.edge.production.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.edge.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -7472,11 +7472,11 @@ function getPostponedState(request) {\n }\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.3.0-canary-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+  if (\"19.3.0-canary-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n     throw Error(\n       'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n         (isomorphicReactPackageVersion +\n-          \"\\n  - react-dom:  19.3.0-canary-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+          \"\\n  - react-dom:  19.3.0-canary-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n     );\n }\n ensureCorrectIsomorphicReactVersion();\n@@ -7726,4 +7726,4 @@ exports.resumeAndPrerender = function (children, postponedState, options) {\n     startWork(request);\n   });\n };\n-exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+exports.version = \"19.3.0-canary-7dc903cd-20251203\";"
        },
        {
            "sha": "773a2c5c9fdc01a4a5a37b52a212ac163402961e",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.node.development.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.node.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -8898,11 +8898,11 @@\n     }\n     function ensureCorrectIsomorphicReactVersion() {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.3.0-canary-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+      if (\"19.3.0-canary-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.3.0-canary-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.3.0-canary-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     }\n     function createDrainHandler(destination, request) {\n@@ -11007,5 +11007,5 @@\n         }\n       };\n     };\n-    exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-canary-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "848124cb9793a73216d9d30d285c27b57c06d7d1",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.node.production.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.node.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -7363,11 +7363,11 @@ function getPostponedState(request) {\n }\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.3.0-canary-fd524fe0-20251121\" !== isomorphicReactPackageVersion)\n+  if (\"19.3.0-canary-7dc903cd-20251203\" !== isomorphicReactPackageVersion)\n     throw Error(\n       'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n         (isomorphicReactPackageVersion +\n-          \"\\n  - react-dom:  19.3.0-canary-fd524fe0-20251121\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+          \"\\n  - react-dom:  19.3.0-canary-7dc903cd-20251203\\nLearn more: https://react.dev/warnings/version-mismatch\")\n     );\n }\n ensureCorrectIsomorphicReactVersion();\n@@ -7917,4 +7917,4 @@ exports.resumeToPipeableStream = function (children, postponedState, options) {\n     }\n   };\n };\n-exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+exports.version = \"19.3.0-canary-7dc903cd-20251203\";"
        },
        {
            "sha": "00e4c794f94f2ed1100cdf5913aabf3936c09943",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -422,7 +422,7 @@\n     exports.useFormStatus = function () {\n       return resolveDispatcher().useHostTransitionStatus();\n     };\n-    exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-canary-7dc903cd-20251203\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "0a7252dd332c277a6fed21b5e47140e89ea22bbb",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -213,4 +213,4 @@ exports.useFormState = function (action, initialState, permalink) {\n exports.useFormStatus = function () {\n   return ReactSharedInternals.H.useHostTransitionStatus();\n };\n-exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+exports.version = \"19.3.0-canary-7dc903cd-20251203\";"
        },
        {
            "sha": "866f37c31842f93798ef43e7c8588ebb2fb7e048",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom.react-server.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.react-server.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.react-server.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.react-server.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -336,5 +336,5 @@\n             }))\n           : Internals.d.m(href));\n     };\n-    exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-canary-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "851a7d1e415738e6405986b903a71781de29eaf1",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom.react-server.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.react-server.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.react-server.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.react-server.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -149,4 +149,4 @@ exports.preloadModule = function (href, options) {\n       });\n     } else Internals.d.m(href);\n };\n-exports.version = \"19.3.0-canary-fd524fe0-20251121\";\n+exports.version = \"19.3.0-canary-7dc903cd-20251203\";"
        },
        {
            "sha": "5ee50d9866fd46a0f38638e280de522c6dfc87ca",
            "filename": "packages/next/src/compiled/react-dom/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fpackage.json?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -67,10 +67,10 @@\n     \"./package.json\": \"./package.json\"\n   },\n   \"dependencies\": {\n-    \"scheduler\": \"0.28.0-canary-fd524fe0-20251121\"\n+    \"scheduler\": \"0.28.0-canary-7dc903cd-20251203\"\n   },\n   \"peerDependencies\": {\n-    \"react\": \"19.3.0-canary-fd524fe0-20251121\"\n+    \"react\": \"19.3.0-canary-7dc903cd-20251203\"\n   },\n   \"browser\": {\n     \"./server.js\": \"./server.browser.js\","
        },
        {
            "sha": "02704f5a0ecd509312cd7d9a7c1a4412e46c8eb5",
            "filename": "packages/next/src/compiled/react-experimental/cjs/react.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -1391,7 +1391,7 @@\n     exports.useTransition = function () {\n       return resolveDispatcher().useTransition();\n     };\n-    exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "c892da1c854dd300a42725a30352eac992258169",
            "filename": "packages/next/src/compiled/react-experimental/cjs/react.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -605,4 +605,4 @@ exports.useSyncExternalStore = function (\n exports.useTransition = function () {\n   return ReactSharedInternals.H.useTransition();\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";"
        },
        {
            "sha": "0813e918fe487464e2bedf48657fddac1c58a1eb",
            "filename": "packages/next/src/compiled/react-experimental/cjs/react.react-server.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.react-server.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.react-server.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.react-server.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -1061,5 +1061,5 @@\n     exports.useMemo = function (create, deps) {\n       return resolveDispatcher().useMemo(create, deps);\n     };\n-    exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+    exports.version = \"19.3.0-experimental-7dc903cd-20251203\";\n   })();"
        },
        {
            "sha": "807539deb1d92de680308ef5ed4daf97bc24bfbc",
            "filename": "packages/next/src/compiled/react-experimental/cjs/react.react-server.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.react-server.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.react-server.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.react-server.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -571,4 +571,4 @@ exports.useId = function () {\n exports.useMemo = function (create, deps) {\n   return ReactSharedInternals.H.useMemo(create, deps);\n };\n-exports.version = \"19.3.0-experimental-fd524fe0-20251121\";\n+exports.version = \"19.3.0-experimental-7dc903cd-20251203\";"
        },
        {
            "sha": "7165944ea33a83949d970adee554c40b06fefc48",
            "filename": "packages/next/src/compiled/react-is/package.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-is%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-is%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-is%2Fpackage.json?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"react-is\",\n-  \"version\": \"19.3.0-canary-fd524fe0-20251121\",\n+  \"version\": \"19.3.0-canary-7dc903cd-20251203\",\n   \"description\": \"Brand checking of React Elements.\",\n   \"main\": \"index.js\",\n   \"sideEffects\": false,"
        },
        {
            "sha": "9c450817e11cf28100efed4a412ca46324132a8d",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-client.browser.development.js",
            "status": "modified",
            "additions": 8,
            "deletions": 10,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.browser.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -99,13 +99,11 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function getIteratorFn(maybeIterable) {\n       if (null === maybeIterable || \"object\" !== typeof maybeIterable)\n@@ -4759,6 +4757,7 @@\n       ReactDOM = require(\"react-dom\"),\n       decoderOptions = { stream: !0 },\n       bind = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       instrumentedChunks = new WeakSet(),\n       loadedChunks = new WeakSet(),\n       chunkIOInfoCache = new Map(),\n@@ -4791,7 +4790,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&\n@@ -4968,10 +4966,10 @@\n       return hook.checkDCE ? !0 : !1;\n     })({\n       bundleType: 1,\n-      version: \"19.3.0-experimental-fd524fe0-20251121\",\n+      version: \"19.3.0-experimental-7dc903cd-20251203\",\n       rendererPackageName: \"react-server-dom-turbopack\",\n       currentDispatcherRef: ReactSharedInternals,\n-      reconcilerVersion: \"19.3.0-experimental-fd524fe0-20251121\",\n+      reconcilerVersion: \"19.3.0-experimental-7dc903cd-20251203\",\n       getCurrentComponentInfo: function () {\n         return currentOwnerInDEV;\n       }"
        },
        {
            "sha": "0b3712107717f2e8d315ac522be0db6fddb51370",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-client.browser.production.js",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.browser.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -10,7 +10,8 @@\n \n \"use strict\";\n var ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   if (bundlerConfig) {\n     var moduleExports = bundlerConfig[metadata[0]];\n@@ -97,13 +98,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n var ReactDOMSharedInternals =\n     ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,"
        },
        {
            "sha": "ed4f6f4a4cc4fc69974da36cdd120422ac1c41ec",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-client.edge.development.js",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.edge.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -99,13 +99,11 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function prepareDestinationWithChunks(\n       moduleLoading,\n@@ -4798,6 +4796,7 @@\n       React = require(\"react\"),\n       decoderOptions = { stream: !0 },\n       bind$1 = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       instrumentedChunks = new WeakSet(),\n       loadedChunks = new WeakSet(),\n       ReactDOMSharedInternals =\n@@ -4832,7 +4831,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&"
        },
        {
            "sha": "32de853f569adc068dadbfcbf723273c74495c8c",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-client.edge.production.js",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.edge.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -10,7 +10,8 @@\n \n \"use strict\";\n var ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   if (bundlerConfig) {\n     var moduleExports = bundlerConfig[metadata[0]];\n@@ -97,13 +98,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n function prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n   if (null !== moduleLoading)"
        },
        {
            "sha": "76f3b6b34853eedefe854a32ceb07b58bc775e0e",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-client.node.development.js",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.node.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -99,13 +99,11 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function prepareDestinationWithChunks(\n       moduleLoading,\n@@ -4903,6 +4901,7 @@\n       React = require(\"react\"),\n       decoderOptions = { stream: !0 },\n       bind$1 = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       instrumentedChunks = new WeakSet(),\n       loadedChunks = new WeakSet(),\n       ReactDOMSharedInternals =\n@@ -4937,7 +4936,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&"
        },
        {
            "sha": "0a84fd7f5ff1f7d4d3552b10c12e3e5482ef9d8d",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-client.node.production.js",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.node.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -11,7 +11,8 @@\n \"use strict\";\n var util = require(\"util\"),\n   ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   if (bundlerConfig) {\n     var moduleExports = bundlerConfig[metadata[0]];\n@@ -98,13 +99,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n function prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n   if (null !== moduleLoading)"
        },
        {
            "sha": "94ffa7153b3dd7ea181ab7178866a6e7a0f7bab9",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-server.browser.development.js",
            "status": "modified",
            "additions": 432,
            "deletions": 199,
            "changes": 631,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.browser.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -3944,37 +3944,65 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n-    }\n-    function Chunk(status, value, reason, response) {\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n+    }\n+    function ReactPromise(status, value, reason) {\n       this.status = status;\n       this.value = value;\n       this.reason = reason;\n-      this._response = response;\n     }\n-    function createPendingChunk(response) {\n-      return new Chunk(\"pending\", null, null, response);\n+    function wakeChunk(response, listeners, value) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n     }\n-    function wakeChunk(listeners, value) {\n-      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+    function rejectChunk(response, listeners, error) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(error)\n+          : rejectReference(response, listener.handler, error);\n+      }\n     }\n-    function triggerErrorOnChunk(chunk, error) {\n+    function resolveBlockedCycle(resolvedChunk, reference) {\n+      var referencedChunk = reference.handler.chunk;\n+      if (null === referencedChunk) return null;\n+      if (referencedChunk === resolvedChunk) return reference.handler;\n+      reference = referencedChunk.value;\n+      if (null !== reference)\n+        for (\n+          referencedChunk = 0;\n+          referencedChunk < reference.length;\n+          referencedChunk++\n+        ) {\n+          var listener = reference[referencedChunk];\n+          if (\n+            \"function\" !== typeof listener &&\n+            ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+            null !== listener)\n+          )\n+            return listener;\n+        }\n+      return null;\n+    }\n+    function triggerErrorOnChunk(response, chunk, error) {\n       if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n         chunk.reason.error(error);\n       else {\n         var listeners = chunk.reason;\n         chunk.status = \"rejected\";\n         chunk.reason = error;\n-        null !== listeners && wakeChunk(listeners, error);\n+        null !== listeners && rejectChunk(response, listeners, error);\n       }\n     }\n-    function resolveModelChunk(chunk, value, id) {\n+    function resolveModelChunk(response, chunk, value, id) {\n       if (\"pending\" !== chunk.status)\n         (chunk = chunk.reason),\n           \"C\" === value[0]\n@@ -3985,81 +4013,142 @@\n           rejectListeners = chunk.reason;\n         chunk.status = \"resolved_model\";\n         chunk.value = value;\n-        chunk.reason = id;\n+        chunk.reason = _defineProperty({ id: id }, RESPONSE_SYMBOL, response);\n         if (null !== resolveListeners)\n-          switch ((initializeModelChunk(chunk), chunk.status)) {\n+          a: switch ((initializeModelChunk(chunk), chunk.status)) {\n             case \"fulfilled\":\n-              wakeChunk(resolveListeners, chunk.value);\n+              wakeChunk(response, resolveListeners, chunk.value);\n               break;\n-            case \"pending\":\n             case \"blocked\":\n-            case \"cyclic\":\n+              for (value = 0; value < resolveListeners.length; value++)\n+                if (\n+                  ((id = resolveListeners[value]), \"function\" !== typeof id)\n+                ) {\n+                  var cyclicHandler = resolveBlockedCycle(chunk, id);\n+                  if (null !== cyclicHandler)\n+                    switch (\n+                      (fulfillReference(response, id, cyclicHandler.value),\n+                      resolveListeners.splice(value, 1),\n+                      value--,\n+                      null !== rejectListeners &&\n+                        ((id = rejectListeners.indexOf(id)),\n+                        -1 !== id && rejectListeners.splice(id, 1)),\n+                      chunk.status)\n+                    ) {\n+                      case \"fulfilled\":\n+                        wakeChunk(response, resolveListeners, chunk.value);\n+                        break a;\n+                      case \"rejected\":\n+                        null !== rejectListeners &&\n+                          rejectChunk(response, rejectListeners, chunk.reason);\n+                        break a;\n+                    }\n+                }\n+            case \"pending\":\n               if (chunk.value)\n-                for (value = 0; value < resolveListeners.length; value++)\n-                  chunk.value.push(resolveListeners[value]);\n+                for (\n+                  response = 0;\n+                  response < resolveListeners.length;\n+                  response++\n+                )\n+                  chunk.value.push(resolveListeners[response]);\n               else chunk.value = resolveListeners;\n               if (chunk.reason) {\n                 if (rejectListeners)\n-                  for (value = 0; value < rejectListeners.length; value++)\n-                    chunk.reason.push(rejectListeners[value]);\n+                  for (\n+                    resolveListeners = 0;\n+                    resolveListeners < rejectListeners.length;\n+                    resolveListeners++\n+                  )\n+                    chunk.reason.push(rejectListeners[resolveListeners]);\n               } else chunk.reason = rejectListeners;\n               break;\n             case \"rejected\":\n-              rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+              rejectListeners &&\n+                wakeChunk(response, rejectListeners, chunk.reason);\n           }\n       }\n     }\n     function createResolvedIteratorResultChunk(response, value, done) {\n-      return new Chunk(\n+      return new ReactPromise(\n         \"resolved_model\",\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n-        -1,\n-        response\n+        _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n       );\n     }\n-    function resolveIteratorResultChunk(chunk, value, done) {\n+    function resolveIteratorResultChunk(response, chunk, value, done) {\n       resolveModelChunk(\n+        response,\n         chunk,\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n         -1\n       );\n     }\n-    function loadServerReference$1(\n-      response,\n-      id,\n-      bound,\n-      parentChunk,\n-      parentObject,\n-      key\n-    ) {\n+    function loadServerReference$1(response, metaData, parentObject, key) {\n+      var id = metaData.id;\n+      if (\"string\" !== typeof id) return null;\n       var serverReference = resolveServerReference(response._bundlerConfig, id);\n-      id = preloadModule(serverReference);\n-      if (bound)\n-        bound = Promise.all([bound, id]).then(function (_ref) {\n-          _ref = _ref[0];\n-          var fn = requireModule(serverReference);\n-          return fn.bind.apply(fn, [null].concat(_ref));\n-        });\n-      else if (id)\n-        bound = Promise.resolve(id).then(function () {\n-          return requireModule(serverReference);\n-        });\n+      id = metaData.bound;\n+      var promise = preloadModule(serverReference);\n+      if (promise)\n+        id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+      else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n       else return requireModule(serverReference);\n-      bound.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(parentChunk)\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n+      promise.then(\n+        function () {\n+          var resolvedValue = requireModule(serverReference);\n+          if (metaData.bound) {\n+            var promiseValue = metaData.bound.value;\n+            promiseValue = Array.isArray(promiseValue)\n+              ? promiseValue.slice(0)\n+              : [];\n+            promiseValue.unshift(null);\n+            resolvedValue = resolvedValue.bind.apply(\n+              resolvedValue,\n+              promiseValue\n+            );\n+          }\n+          parentObject[key] = resolvedValue;\n+          \"\" === key &&\n+            null === handler.value &&\n+            (handler.value = resolvedValue);\n+          handler.deps--;\n+          0 === handler.deps &&\n+            ((resolvedValue = handler.chunk),\n+            null !== resolvedValue &&\n+              \"blocked\" === resolvedValue.status &&\n+              ((promiseValue = resolvedValue.value),\n+              (resolvedValue.status = \"fulfilled\"),\n+              (resolvedValue.value = handler.value),\n+              null !== promiseValue &&\n+                wakeChunk(response, promiseValue, handler.value)));\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n@@ -4101,53 +4190,66 @@\n                 value[i],\n                 parentObj\n               )),\n-              void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+              void 0 !== parentObj || \"__proto__\" === i\n+                ? (value[i] = parentObj)\n+                : delete value[i]);\n       return value;\n     }\n     function initializeModelChunk(chunk) {\n-      var prevChunk = initializingChunk,\n-        prevBlocked = initializingChunkBlockedModel;\n-      initializingChunk = chunk;\n-      initializingChunkBlockedModel = null;\n-      var rootReference =\n-          -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-        resolvedModel = chunk.value;\n-      chunk.status = \"cyclic\";\n+      var prevHandler = initializingHandler;\n+      initializingHandler = null;\n+      var _chunk$reason = chunk.reason,\n+        response = _chunk$reason[RESPONSE_SYMBOL];\n+      _chunk$reason = _chunk$reason.id;\n+      _chunk$reason =\n+        -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+      var resolvedModel = chunk.value;\n+      chunk.status = \"blocked\";\n       chunk.value = null;\n       chunk.reason = null;\n       try {\n         var rawModel = JSON.parse(resolvedModel),\n           value = reviveModel(\n-            chunk._response,\n+            response,\n             { \"\": rawModel },\n             \"\",\n             rawModel,\n-            rootReference\n-          );\n-        if (\n-          null !== initializingChunkBlockedModel &&\n-          0 < initializingChunkBlockedModel.deps\n-        )\n-          (initializingChunkBlockedModel.value = value),\n-            (chunk.status = \"blocked\");\n-        else {\n-          var resolveListeners = chunk.value;\n-          chunk.status = \"fulfilled\";\n-          chunk.value = value;\n-          null !== resolveListeners && wakeChunk(resolveListeners, value);\n+            _chunk$reason\n+          ),\n+          resolveListeners = chunk.value;\n+        if (null !== resolveListeners)\n+          for (\n+            chunk.value = null, chunk.reason = null, rawModel = 0;\n+            rawModel < resolveListeners.length;\n+            rawModel++\n+          ) {\n+            var listener = resolveListeners[rawModel];\n+            \"function\" === typeof listener\n+              ? listener(value)\n+              : fulfillReference(response, listener, value);\n+          }\n+        if (null !== initializingHandler) {\n+          if (initializingHandler.errored) throw initializingHandler.reason;\n+          if (0 < initializingHandler.deps) {\n+            initializingHandler.value = value;\n+            initializingHandler.chunk = chunk;\n+            return;\n+          }\n         }\n+        chunk.status = \"fulfilled\";\n+        chunk.value = value;\n       } catch (error) {\n         (chunk.status = \"rejected\"), (chunk.reason = error);\n       } finally {\n-        (initializingChunk = prevChunk),\n-          (initializingChunkBlockedModel = prevBlocked);\n+        initializingHandler = prevHandler;\n       }\n     }\n     function reportGlobalError(response, error) {\n       response._closed = !0;\n       response._closedReason = error;\n       response._chunks.forEach(function (chunk) {\n-        \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+        \"pending\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n       });\n     }\n     function getChunk(response, id) {\n@@ -4156,50 +4258,108 @@\n       chunk ||\n         ((chunk = response._formData.get(response._prefix + id)),\n         (chunk =\n-          null != chunk\n-            ? new Chunk(\"resolved_model\", chunk, id, response)\n+          \"string\" === typeof chunk\n+            ? new ReactPromise(\n+                \"resolved_model\",\n+                chunk,\n+                _defineProperty({ id: id }, RESPONSE_SYMBOL, response)\n+              )\n             : response._closed\n-              ? new Chunk(\"rejected\", null, response._closedReason, response)\n-              : createPendingChunk(response)),\n+              ? new ReactPromise(\"rejected\", null, response._closedReason)\n+              : new ReactPromise(\"pending\", null, null)),\n         chunks.set(id, chunk));\n       return chunk;\n     }\n-    function createModelResolver(\n-      chunk,\n+    function fulfillReference(response, reference, value) {\n+      for (\n+        var handler = reference.handler,\n+          parentObject = reference.parentObject,\n+          key = reference.key,\n+          map = reference.map,\n+          path = reference.path,\n+          i = 1;\n+        i < path.length;\n+        i++\n+      ) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              continue;\n+            case \"blocked\":\n+            case \"pending\":\n+              path.splice(0, i - 1);\n+              null === value.value\n+                ? (value.value = [reference])\n+                : value.value.push(reference);\n+              null === value.reason\n+                ? (value.reason = [reference])\n+                : value.reason.push(reference);\n+              return;\n+            default:\n+              rejectReference(response, reference.handler, value.reason);\n+              return;\n+          }\n+        }\n+        var name = path[i];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      reference = map(response, value, parentObject, key);\n+      parentObject[key] = reference;\n+      \"\" === key && null === handler.value && (handler.value = reference);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((parentObject = handler.chunk),\n+        null !== parentObject &&\n+          \"blocked\" === parentObject.status &&\n+          ((key = parentObject.value),\n+          (parentObject.status = \"fulfilled\"),\n+          (parentObject.value = handler.value),\n+          (parentObject.reason = handler.reason),\n+          null !== key && wakeChunk(response, key, handler.value)));\n+    }\n+    function rejectReference(response, handler, error) {\n+      handler.errored ||\n+        ((handler.errored = !0),\n+        (handler.value = null),\n+        (handler.reason = error),\n+        (handler = handler.chunk),\n+        null !== handler &&\n+          \"blocked\" === handler.status &&\n+          triggerErrorOnChunk(response, handler, error));\n+    }\n+    function waitForReference(\n+      referencedChunk,\n       parentObject,\n       key,\n-      cyclic,\n       response,\n       map,\n       path\n     ) {\n-      if (initializingChunkBlockedModel) {\n-        var blocked = initializingChunkBlockedModel;\n-        cyclic || blocked.deps++;\n-      } else\n-        blocked = initializingChunkBlockedModel = {\n-          deps: cyclic ? 0 : 1,\n-          value: null\n-        };\n-      return function (value) {\n-        for (var i = 1; i < path.length; i++) value = value[path[i]];\n-        parentObject[key] = map(response, value);\n-        \"\" === key &&\n-          null === blocked.value &&\n-          (blocked.value = parentObject[key]);\n-        blocked.deps--;\n-        0 === blocked.deps &&\n-          \"blocked\" === chunk.status &&\n-          ((value = chunk.value),\n-          (chunk.status = \"fulfilled\"),\n-          (chunk.value = blocked.value),\n-          null !== value && wakeChunk(value, blocked.value));\n-      };\n-    }\n-    function createModelReject(chunk) {\n-      return function (error) {\n-        return triggerErrorOnChunk(chunk, error);\n+      initializingHandler\n+        ? ((response = initializingHandler), response.deps++)\n+        : (response = initializingHandler =\n+            { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+      parentObject = {\n+        handler: response,\n+        parentObject: parentObject,\n+        key: key,\n+        map: map,\n+        path: path\n       };\n+      null === referencedChunk.value\n+        ? (referencedChunk.value = [parentObject])\n+        : referencedChunk.value.push(parentObject);\n+      null === referencedChunk.reason\n+        ? (referencedChunk.reason = [parentObject])\n+        : referencedChunk.reason.push(parentObject);\n+      return null;\n     }\n     function getOutlinedModel(response, reference, parentObject, key, map) {\n       reference = reference.split(\":\");\n@@ -4211,29 +4371,75 @@\n       }\n       switch (id.status) {\n         case \"fulfilled\":\n-          parentObject = id.value;\n-          for (key = 1; key < reference.length; key++)\n-            parentObject = parentObject[reference[key]];\n-          return map(response, parentObject);\n+          var value = id.value;\n+          for (id = 1; id < reference.length; id++) {\n+            for (; value instanceof ReactPromise; ) {\n+              switch (value.status) {\n+                case \"resolved_model\":\n+                  initializeModelChunk(value);\n+              }\n+              switch (value.status) {\n+                case \"fulfilled\":\n+                  value = value.value;\n+                  break;\n+                case \"blocked\":\n+                case \"pending\":\n+                  return waitForReference(\n+                    value,\n+                    parentObject,\n+                    key,\n+                    response,\n+                    map,\n+                    reference.slice(id - 1)\n+                  );\n+                default:\n+                  return (\n+                    initializingHandler\n+                      ? ((initializingHandler.errored = !0),\n+                        (initializingHandler.value = null),\n+                        (initializingHandler.reason = value.reason))\n+                      : (initializingHandler = {\n+                          chunk: null,\n+                          value: null,\n+                          reason: value.reason,\n+                          deps: 0,\n+                          errored: !0\n+                        }),\n+                    null\n+                  );\n+              }\n+            }\n+            var name = reference[id];\n+            \"object\" === typeof value &&\n+              hasOwnProperty.call(value, name) &&\n+              (value = value[name]);\n+          }\n+          return map(response, value, parentObject, key);\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          var parentChunk = initializingChunk;\n-          id.then(\n-            createModelResolver(\n-              parentChunk,\n-              parentObject,\n-              key,\n-              \"cyclic\" === id.status,\n-              response,\n-              map,\n-              reference\n-            ),\n-            createModelReject(parentChunk)\n+          return waitForReference(\n+            id,\n+            parentObject,\n+            key,\n+            response,\n+            map,\n+            reference\n           );\n-          return null;\n         default:\n-          throw id.reason;\n+          return (\n+            initializingHandler\n+              ? ((initializingHandler.errored = !0),\n+                (initializingHandler.value = null),\n+                (initializingHandler.reason = id.reason))\n+              : (initializingHandler = {\n+                  chunk: null,\n+                  value: null,\n+                  reason: id.reason,\n+                  deps: 0,\n+                  errored: !0\n+                }),\n+            null\n+          );\n       }\n     }\n     function createMap(response, model) {\n@@ -4257,40 +4463,68 @@\n       parentKey\n     ) {\n       reference = parseInt(reference.slice(2), 16);\n-      reference = response._formData.get(response._prefix + reference);\n-      reference =\n-        constructor === ArrayBuffer\n-          ? reference.arrayBuffer()\n-          : reference.arrayBuffer().then(function (buffer) {\n-              return new constructor(buffer);\n-            });\n-      bytesPerElement = initializingChunk;\n+      reference = response._formData\n+        .get(response._prefix + reference)\n+        .arrayBuffer();\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n       reference.then(\n-        createModelResolver(\n-          bytesPerElement,\n-          parentObject,\n-          parentKey,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(bytesPerElement)\n+        function (buffer) {\n+          buffer =\n+            constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+          parentObject[parentKey] = buffer;\n+          \"\" === parentKey &&\n+            null === handler.value &&\n+            (handler.value = buffer);\n+          handler.deps--;\n+          if (\n+            0 === handler.deps &&\n+            ((buffer = handler.chunk),\n+            null !== buffer && \"blocked\" === buffer.status)\n+          ) {\n+            var resolveListeners = buffer.value;\n+            buffer.status = \"fulfilled\";\n+            buffer.value = handler.value;\n+            null !== resolveListeners &&\n+              wakeChunk(response, resolveListeners, handler.value);\n+          }\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n     function resolveStream(response, id, stream, controller) {\n       var chunks = response._chunks;\n-      stream = new Chunk(\"fulfilled\", stream, controller, response);\n+      stream = new ReactPromise(\"fulfilled\", stream, controller);\n       chunks.set(id, stream);\n       response = response._formData.getAll(response._prefix + id);\n       for (id = 0; id < response.length; id++)\n         (chunks = response[id]),\n-          \"C\" === chunks[0]\n-            ? controller.close(\n-                \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n-              )\n-            : controller.enqueueModel(chunks);\n+          \"string\" === typeof chunks &&\n+            (\"C\" === chunks[0]\n+              ? controller.close(\n+                  \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n+                )\n+              : controller.enqueueModel(chunks));\n     }\n     function parseReadableStream(response, reference, type) {\n       reference = parseInt(reference.slice(2), 16);\n@@ -4305,7 +4539,11 @@\n       resolveStream(response, reference, type, {\n         enqueueModel: function (json) {\n           if (null === previousBlockedChunk) {\n-            var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+            var chunk = new ReactPromise(\n+              \"resolved_model\",\n+              json,\n+              _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n+            );\n             initializeModelChunk(chunk);\n             \"fulfilled\" === chunk.status\n               ? controller.enqueue(chunk.value)\n@@ -4320,7 +4558,7 @@\n                 (previousBlockedChunk = chunk));\n           } else {\n             chunk = previousBlockedChunk;\n-            var _chunk = createPendingChunk(response);\n+            var _chunk = new ReactPromise(\"pending\", null, null);\n             _chunk.then(\n               function (v) {\n                 return controller.enqueue(v);\n@@ -4332,7 +4570,7 @@\n             previousBlockedChunk = _chunk;\n             chunk.then(function () {\n               previousBlockedChunk === _chunk && (previousBlockedChunk = null);\n-              resolveModelChunk(_chunk, json, -1);\n+              resolveModelChunk(response, _chunk, json, -1);\n             });\n           }\n         },\n@@ -4381,13 +4619,12 @@\n               );\n             if (nextReadIndex === buffer.length) {\n               if (closed)\n-                return new Chunk(\n+                return new ReactPromise(\n                   \"fulfilled\",\n                   { done: !0, value: void 0 },\n-                  null,\n-                  response\n+                  null\n                 );\n-              buffer[nextReadIndex] = createPendingChunk(response);\n+              buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n             }\n             return buffer[nextReadIndex++];\n           });\n@@ -4401,7 +4638,12 @@\n                 value,\n                 !1\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !1\n+              );\n           nextWriteIndex++;\n         },\n         close: function (value) {\n@@ -4412,9 +4654,15 @@\n                 value,\n                 !0\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !0\n+              );\n           for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n             resolveIteratorResultChunk(\n+              response,\n               buffer[nextWriteIndex++],\n               '\"$undefined\"',\n               !0\n@@ -4424,11 +4672,11 @@\n           closed = !0;\n           for (\n             nextWriteIndex === buffer.length &&\n-            (buffer[nextWriteIndex] = createPendingChunk(response));\n+            (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n             nextWriteIndex < buffer.length;\n \n           )\n-            triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n         }\n       });\n       return iterator;\n@@ -4445,21 +4693,7 @@\n           case \"F\":\n             return (\n               (value = value.slice(2)),\n-              (value = getOutlinedModel(\n-                response,\n-                value,\n-                obj,\n-                key,\n-                createModel\n-              )),\n-              loadServerReference$1(\n-                response,\n-                value.id,\n-                value.bound,\n-                initializingChunk,\n-                obj,\n-                key\n-              )\n+              getOutlinedModel(response, value, obj, key, loadServerReference$1)\n             );\n           case \"T\":\n             if (\n@@ -5136,33 +5370,32 @@\n       emptyRoot = {},\n       decoderOptions = { stream: !0 },\n       instrumentedChunks = new WeakSet(),\n-      loadedChunks = new WeakSet();\n-    Chunk.prototype = Object.create(Promise.prototype);\n-    Chunk.prototype.then = function (resolve, reject) {\n+      loadedChunks = new WeakSet(),\n+      RESPONSE_SYMBOL = Symbol();\n+    ReactPromise.prototype = Object.create(Promise.prototype);\n+    ReactPromise.prototype.then = function (resolve, reject) {\n       switch (this.status) {\n         case \"resolved_model\":\n           initializeModelChunk(this);\n       }\n       switch (this.status) {\n         case \"fulfilled\":\n-          resolve(this.value);\n+          \"function\" === typeof resolve && resolve(this.value);\n           break;\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          resolve &&\n+          \"function\" === typeof resolve &&\n             (null === this.value && (this.value = []),\n             this.value.push(resolve));\n-          reject &&\n+          \"function\" === typeof reject &&\n             (null === this.reason && (this.reason = []),\n             this.reason.push(reject));\n           break;\n         default:\n-          reject(this.reason);\n+          \"function\" === typeof reject && reject(this.reason);\n       }\n     };\n-    var initializingChunk = null,\n-      initializingChunkBlockedModel = null;\n+    var initializingHandler = null;\n     exports.createClientModuleProxy = function (moduleId) {\n       moduleId = registerClientReferenceImpl({}, moduleId, !1);\n       return new Proxy(moduleId, proxyHandlers$1);"
        },
        {
            "sha": "e37515cded7077ee43ac126eba31ed40485d79b1",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-server.browser.production.js",
            "status": "modified",
            "additions": 426,
            "deletions": 202,
            "changes": 628,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.browser.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -980,8 +980,8 @@ function serializeReadableStream(request, task, stream) {\n               : tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             reader.read().then(progress, error);\n-        } catch (x$8) {\n-          error(x$8);\n+        } catch (x$11) {\n+          error(x$11);\n         }\n   }\n   function error(reason) {\n@@ -1066,8 +1066,8 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n             tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             iterator.next().then(progress, error);\n-        } catch (x$9) {\n-          error(x$9);\n+        } catch (x$12) {\n+          error(x$12);\n         }\n   }\n   function error(reason) {\n@@ -2229,9 +2229,9 @@ function abort(request, reason) {\n         onAllReady();\n         flushCompletedChunks(request);\n       }\n-    } catch (error$26) {\n-      logRecoverableError(request, error$26, null),\n-        fatalError(request, error$26);\n+    } catch (error$29) {\n+      logRecoverableError(request, error$29, null),\n+        fatalError(request, error$29);\n     }\n }\n function resolveServerReference(bundlerConfig, id) {\n@@ -2299,59 +2299,97 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n-}\n-function Chunk(status, value, reason, response) {\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n+}\n+var RESPONSE_SYMBOL = Symbol();\n+function ReactPromise(status, value, reason) {\n   this.status = status;\n   this.value = value;\n   this.reason = reason;\n-  this._response = response;\n }\n-Chunk.prototype = Object.create(Promise.prototype);\n-Chunk.prototype.then = function (resolve, reject) {\n+ReactPromise.prototype = Object.create(Promise.prototype);\n+ReactPromise.prototype.then = function (resolve, reject) {\n   switch (this.status) {\n     case \"resolved_model\":\n       initializeModelChunk(this);\n   }\n   switch (this.status) {\n     case \"fulfilled\":\n-      resolve(this.value);\n+      \"function\" === typeof resolve && resolve(this.value);\n       break;\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      resolve &&\n+      \"function\" === typeof resolve &&\n         (null === this.value && (this.value = []), this.value.push(resolve));\n-      reject &&\n+      \"function\" === typeof reject &&\n         (null === this.reason && (this.reason = []), this.reason.push(reject));\n       break;\n     default:\n-      reject(this.reason);\n+      \"function\" === typeof reject && reject(this.reason);\n   }\n };\n-function createPendingChunk(response) {\n-  return new Chunk(\"pending\", null, null, response);\n+function wakeChunk(response, listeners, value) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(value)\n+      : fulfillReference(response, listener, value);\n+  }\n }\n-function wakeChunk(listeners, value) {\n-  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+function rejectChunk(response, listeners, error) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(error)\n+      : rejectReference(response, listener.handler, error);\n+  }\n }\n-function triggerErrorOnChunk(chunk, error) {\n+function resolveBlockedCycle(resolvedChunk, reference) {\n+  var referencedChunk = reference.handler.chunk;\n+  if (null === referencedChunk) return null;\n+  if (referencedChunk === resolvedChunk) return reference.handler;\n+  reference = referencedChunk.value;\n+  if (null !== reference)\n+    for (\n+      referencedChunk = 0;\n+      referencedChunk < reference.length;\n+      referencedChunk++\n+    ) {\n+      var listener = reference[referencedChunk];\n+      if (\n+        \"function\" !== typeof listener &&\n+        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+        null !== listener)\n+      )\n+        return listener;\n+    }\n+  return null;\n+}\n+function triggerErrorOnChunk(response, chunk, error) {\n   if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n     chunk.reason.error(error);\n   else {\n     var listeners = chunk.reason;\n     chunk.status = \"rejected\";\n     chunk.reason = error;\n-    null !== listeners && wakeChunk(listeners, error);\n+    null !== listeners && rejectChunk(response, listeners, error);\n   }\n }\n-function resolveModelChunk(chunk, value, id) {\n+function createResolvedModelChunk(response, value, id) {\n+  var $jscomp$compprop2 = {};\n+  return new ReactPromise(\n+    \"resolved_model\",\n+    value,\n+    (($jscomp$compprop2.id = id),\n+    ($jscomp$compprop2[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop2)\n+  );\n+}\n+function resolveModelChunk(response, chunk, value, id) {\n   if (\"pending\" !== chunk.status)\n     (chunk = chunk.reason),\n       \"C\" === value[0]\n@@ -2362,77 +2400,129 @@ function resolveModelChunk(chunk, value, id) {\n       rejectListeners = chunk.reason;\n     chunk.status = \"resolved_model\";\n     chunk.value = value;\n-    chunk.reason = id;\n+    value = {};\n+    chunk.reason =\n+      ((value.id = id), (value[RESPONSE_SYMBOL] = response), value);\n     if (null !== resolveListeners)\n-      switch ((initializeModelChunk(chunk), chunk.status)) {\n+      a: switch ((initializeModelChunk(chunk), chunk.status)) {\n         case \"fulfilled\":\n-          wakeChunk(resolveListeners, chunk.value);\n+          wakeChunk(response, resolveListeners, chunk.value);\n           break;\n-        case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n+          for (value = 0; value < resolveListeners.length; value++)\n+            if (((id = resolveListeners[value]), \"function\" !== typeof id)) {\n+              var cyclicHandler = resolveBlockedCycle(chunk, id);\n+              if (null !== cyclicHandler)\n+                switch (\n+                  (fulfillReference(response, id, cyclicHandler.value),\n+                  resolveListeners.splice(value, 1),\n+                  value--,\n+                  null !== rejectListeners &&\n+                    ((id = rejectListeners.indexOf(id)),\n+                    -1 !== id && rejectListeners.splice(id, 1)),\n+                  chunk.status)\n+                ) {\n+                  case \"fulfilled\":\n+                    wakeChunk(response, resolveListeners, chunk.value);\n+                    break a;\n+                  case \"rejected\":\n+                    null !== rejectListeners &&\n+                      rejectChunk(response, rejectListeners, chunk.reason);\n+                    break a;\n+                }\n+            }\n+        case \"pending\":\n           if (chunk.value)\n-            for (value = 0; value < resolveListeners.length; value++)\n-              chunk.value.push(resolveListeners[value]);\n+            for (response = 0; response < resolveListeners.length; response++)\n+              chunk.value.push(resolveListeners[response]);\n           else chunk.value = resolveListeners;\n           if (chunk.reason) {\n             if (rejectListeners)\n-              for (value = 0; value < rejectListeners.length; value++)\n-                chunk.reason.push(rejectListeners[value]);\n+              for (\n+                resolveListeners = 0;\n+                resolveListeners < rejectListeners.length;\n+                resolveListeners++\n+              )\n+                chunk.reason.push(rejectListeners[resolveListeners]);\n           } else chunk.reason = rejectListeners;\n           break;\n         case \"rejected\":\n-          rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+          rejectListeners && wakeChunk(response, rejectListeners, chunk.reason);\n       }\n   }\n }\n function createResolvedIteratorResultChunk(response, value, done) {\n-  return new Chunk(\n+  var $jscomp$compprop4 = {};\n+  return new ReactPromise(\n     \"resolved_model\",\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n-    -1,\n-    response\n+    (($jscomp$compprop4.id = -1),\n+    ($jscomp$compprop4[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop4)\n   );\n }\n-function resolveIteratorResultChunk(chunk, value, done) {\n+function resolveIteratorResultChunk(response, chunk, value, done) {\n   resolveModelChunk(\n+    response,\n     chunk,\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n     -1\n   );\n }\n-function loadServerReference$1(\n-  response,\n-  id,\n-  bound,\n-  parentChunk,\n-  parentObject,\n-  key\n-) {\n+function loadServerReference$1(response, metaData, parentObject, key) {\n+  var id = metaData.id;\n+  if (\"string\" !== typeof id) return null;\n   var serverReference = resolveServerReference(response._bundlerConfig, id);\n-  id = preloadModule(serverReference);\n-  if (bound)\n-    bound = Promise.all([bound, id]).then(function (_ref) {\n-      _ref = _ref[0];\n-      var fn = requireModule(serverReference);\n-      return fn.bind.apply(fn, [null].concat(_ref));\n-    });\n-  else if (id)\n-    bound = Promise.resolve(id).then(function () {\n-      return requireModule(serverReference);\n-    });\n+  id = metaData.bound;\n+  var promise = preloadModule(serverReference);\n+  if (promise)\n+    id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+  else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n   else return requireModule(serverReference);\n-  bound.then(\n-    createModelResolver(\n-      parentChunk,\n-      parentObject,\n-      key,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(parentChunk)\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n+  promise.then(\n+    function () {\n+      var resolvedValue = requireModule(serverReference);\n+      if (metaData.bound) {\n+        var promiseValue = metaData.bound.value;\n+        promiseValue = Array.isArray(promiseValue) ? promiseValue.slice(0) : [];\n+        promiseValue.unshift(null);\n+        resolvedValue = resolvedValue.bind.apply(resolvedValue, promiseValue);\n+      }\n+      parentObject[key] = resolvedValue;\n+      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((resolvedValue = handler.chunk),\n+        null !== resolvedValue &&\n+          \"blocked\" === resolvedValue.status &&\n+          ((promiseValue = resolvedValue.value),\n+          (resolvedValue.status = \"fulfilled\"),\n+          (resolvedValue.value = handler.value),\n+          null !== promiseValue &&\n+            wakeChunk(response, promiseValue, handler.value)));\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n@@ -2462,53 +2552,65 @@ function reviveModel(response, parentObj, parentKey, value, reference) {\n               ? reference + \":\" + i\n               : void 0),\n           (parentObj = reviveModel(response, value, i, value[i], parentObj)),\n-          void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+          void 0 !== parentObj || \"__proto__\" === i\n+            ? (value[i] = parentObj)\n+            : delete value[i]);\n   return value;\n }\n-var initializingChunk = null,\n-  initializingChunkBlockedModel = null;\n+var initializingHandler = null;\n function initializeModelChunk(chunk) {\n-  var prevChunk = initializingChunk,\n-    prevBlocked = initializingChunkBlockedModel;\n-  initializingChunk = chunk;\n-  initializingChunkBlockedModel = null;\n-  var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-    resolvedModel = chunk.value;\n-  chunk.status = \"cyclic\";\n+  var prevHandler = initializingHandler;\n+  initializingHandler = null;\n+  var _chunk$reason = chunk.reason,\n+    response = _chunk$reason[RESPONSE_SYMBOL];\n+  _chunk$reason = _chunk$reason.id;\n+  _chunk$reason = -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+  var resolvedModel = chunk.value;\n+  chunk.status = \"blocked\";\n   chunk.value = null;\n   chunk.reason = null;\n   try {\n     var rawModel = JSON.parse(resolvedModel),\n       value = reviveModel(\n-        chunk._response,\n+        response,\n         { \"\": rawModel },\n         \"\",\n         rawModel,\n-        rootReference\n-      );\n-    if (\n-      null !== initializingChunkBlockedModel &&\n-      0 < initializingChunkBlockedModel.deps\n-    )\n-      (initializingChunkBlockedModel.value = value), (chunk.status = \"blocked\");\n-    else {\n-      var resolveListeners = chunk.value;\n-      chunk.status = \"fulfilled\";\n-      chunk.value = value;\n-      null !== resolveListeners && wakeChunk(resolveListeners, value);\n+        _chunk$reason\n+      ),\n+      resolveListeners = chunk.value;\n+    if (null !== resolveListeners)\n+      for (\n+        chunk.value = null, chunk.reason = null, rawModel = 0;\n+        rawModel < resolveListeners.length;\n+        rawModel++\n+      ) {\n+        var listener = resolveListeners[rawModel];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n+    if (null !== initializingHandler) {\n+      if (initializingHandler.errored) throw initializingHandler.reason;\n+      if (0 < initializingHandler.deps) {\n+        initializingHandler.value = value;\n+        initializingHandler.chunk = chunk;\n+        return;\n+      }\n     }\n+    chunk.status = \"fulfilled\";\n+    chunk.value = value;\n   } catch (error) {\n     (chunk.status = \"rejected\"), (chunk.reason = error);\n   } finally {\n-    (initializingChunk = prevChunk),\n-      (initializingChunkBlockedModel = prevBlocked);\n+    initializingHandler = prevHandler;\n   }\n }\n function reportGlobalError(response, error) {\n   response._closed = !0;\n   response._closedReason = error;\n   response._chunks.forEach(function (chunk) {\n-    \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+    \"pending\" === chunk.status && triggerErrorOnChunk(response, chunk, error);\n   });\n }\n function getChunk(response, id) {\n@@ -2517,48 +2619,104 @@ function getChunk(response, id) {\n   chunk ||\n     ((chunk = response._formData.get(response._prefix + id)),\n     (chunk =\n-      null != chunk\n-        ? new Chunk(\"resolved_model\", chunk, id, response)\n+      \"string\" === typeof chunk\n+        ? createResolvedModelChunk(response, chunk, id)\n         : response._closed\n-          ? new Chunk(\"rejected\", null, response._closedReason, response)\n-          : createPendingChunk(response)),\n+          ? new ReactPromise(\"rejected\", null, response._closedReason)\n+          : new ReactPromise(\"pending\", null, null)),\n     chunks.set(id, chunk));\n   return chunk;\n }\n-function createModelResolver(\n-  chunk,\n+function fulfillReference(response, reference, value) {\n+  for (\n+    var handler = reference.handler,\n+      parentObject = reference.parentObject,\n+      key = reference.key,\n+      map = reference.map,\n+      path = reference.path,\n+      i = 1;\n+    i < path.length;\n+    i++\n+  ) {\n+    for (; value instanceof ReactPromise; ) {\n+      switch (value.status) {\n+        case \"resolved_model\":\n+          initializeModelChunk(value);\n+      }\n+      switch (value.status) {\n+        case \"fulfilled\":\n+          value = value.value;\n+          continue;\n+        case \"blocked\":\n+        case \"pending\":\n+          path.splice(0, i - 1);\n+          null === value.value\n+            ? (value.value = [reference])\n+            : value.value.push(reference);\n+          null === value.reason\n+            ? (value.reason = [reference])\n+            : value.reason.push(reference);\n+          return;\n+        default:\n+          rejectReference(response, reference.handler, value.reason);\n+          return;\n+      }\n+    }\n+    var name = path[i];\n+    \"object\" === typeof value &&\n+      hasOwnProperty.call(value, name) &&\n+      (value = value[name]);\n+  }\n+  reference = map(response, value, parentObject, key);\n+  parentObject[key] = reference;\n+  \"\" === key && null === handler.value && (handler.value = reference);\n+  handler.deps--;\n+  0 === handler.deps &&\n+    ((parentObject = handler.chunk),\n+    null !== parentObject &&\n+      \"blocked\" === parentObject.status &&\n+      ((key = parentObject.value),\n+      (parentObject.status = \"fulfilled\"),\n+      (parentObject.value = handler.value),\n+      (parentObject.reason = handler.reason),\n+      null !== key && wakeChunk(response, key, handler.value)));\n+}\n+function rejectReference(response, handler, error) {\n+  handler.errored ||\n+    ((handler.errored = !0),\n+    (handler.value = null),\n+    (handler.reason = error),\n+    (handler = handler.chunk),\n+    null !== handler &&\n+      \"blocked\" === handler.status &&\n+      triggerErrorOnChunk(response, handler, error));\n+}\n+function waitForReference(\n+  referencedChunk,\n   parentObject,\n   key,\n-  cyclic,\n   response,\n   map,\n   path\n ) {\n-  if (initializingChunkBlockedModel) {\n-    var blocked = initializingChunkBlockedModel;\n-    cyclic || blocked.deps++;\n-  } else\n-    blocked = initializingChunkBlockedModel = {\n-      deps: cyclic ? 0 : 1,\n-      value: null\n-    };\n-  return function (value) {\n-    for (var i = 1; i < path.length; i++) value = value[path[i]];\n-    parentObject[key] = map(response, value);\n-    \"\" === key && null === blocked.value && (blocked.value = parentObject[key]);\n-    blocked.deps--;\n-    0 === blocked.deps &&\n-      \"blocked\" === chunk.status &&\n-      ((value = chunk.value),\n-      (chunk.status = \"fulfilled\"),\n-      (chunk.value = blocked.value),\n-      null !== value && wakeChunk(value, blocked.value));\n-  };\n-}\n-function createModelReject(chunk) {\n-  return function (error) {\n-    return triggerErrorOnChunk(chunk, error);\n+  initializingHandler\n+    ? ((response = initializingHandler), response.deps++)\n+    : (response = initializingHandler =\n+        { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+  parentObject = {\n+    handler: response,\n+    parentObject: parentObject,\n+    key: key,\n+    map: map,\n+    path: path\n   };\n+  null === referencedChunk.value\n+    ? (referencedChunk.value = [parentObject])\n+    : referencedChunk.value.push(parentObject);\n+  null === referencedChunk.reason\n+    ? (referencedChunk.reason = [parentObject])\n+    : referencedChunk.reason.push(parentObject);\n+  return null;\n }\n function getOutlinedModel(response, reference, parentObject, key, map) {\n   reference = reference.split(\":\");\n@@ -2570,29 +2728,68 @@ function getOutlinedModel(response, reference, parentObject, key, map) {\n   }\n   switch (id.status) {\n     case \"fulfilled\":\n-      parentObject = id.value;\n-      for (key = 1; key < reference.length; key++)\n-        parentObject = parentObject[reference[key]];\n-      return map(response, parentObject);\n+      var value = id.value;\n+      for (id = 1; id < reference.length; id++) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              break;\n+            case \"blocked\":\n+            case \"pending\":\n+              return waitForReference(\n+                value,\n+                parentObject,\n+                key,\n+                response,\n+                map,\n+                reference.slice(id - 1)\n+              );\n+            default:\n+              return (\n+                initializingHandler\n+                  ? ((initializingHandler.errored = !0),\n+                    (initializingHandler.value = null),\n+                    (initializingHandler.reason = value.reason))\n+                  : (initializingHandler = {\n+                      chunk: null,\n+                      value: null,\n+                      reason: value.reason,\n+                      deps: 0,\n+                      errored: !0\n+                    }),\n+                null\n+              );\n+          }\n+        }\n+        var name = reference[id];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      return map(response, value, parentObject, key);\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      var parentChunk = initializingChunk;\n-      id.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          \"cyclic\" === id.status,\n-          response,\n-          map,\n-          reference\n-        ),\n-        createModelReject(parentChunk)\n-      );\n-      return null;\n+      return waitForReference(id, parentObject, key, response, map, reference);\n     default:\n-      throw id.reason;\n+      return (\n+        initializingHandler\n+          ? ((initializingHandler.errored = !0),\n+            (initializingHandler.value = null),\n+            (initializingHandler.reason = id.reason))\n+          : (initializingHandler = {\n+              chunk: null,\n+              value: null,\n+              reason: id.reason,\n+              deps: 0,\n+              errored: !0\n+            }),\n+        null\n+      );\n   }\n }\n function createMap(response, model) {\n@@ -2616,38 +2813,63 @@ function parseTypedArray(\n   parentKey\n ) {\n   reference = parseInt(reference.slice(2), 16);\n-  reference = response._formData.get(response._prefix + reference);\n-  reference =\n-    constructor === ArrayBuffer\n-      ? reference.arrayBuffer()\n-      : reference.arrayBuffer().then(function (buffer) {\n-          return new constructor(buffer);\n-        });\n-  bytesPerElement = initializingChunk;\n+  reference = response._formData\n+    .get(response._prefix + reference)\n+    .arrayBuffer();\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n   reference.then(\n-    createModelResolver(\n-      bytesPerElement,\n-      parentObject,\n-      parentKey,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(bytesPerElement)\n+    function (buffer) {\n+      buffer = constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+      parentObject[parentKey] = buffer;\n+      \"\" === parentKey && null === handler.value && (handler.value = buffer);\n+      handler.deps--;\n+      if (\n+        0 === handler.deps &&\n+        ((buffer = handler.chunk),\n+        null !== buffer && \"blocked\" === buffer.status)\n+      ) {\n+        var resolveListeners = buffer.value;\n+        buffer.status = \"fulfilled\";\n+        buffer.value = handler.value;\n+        null !== resolveListeners &&\n+          wakeChunk(response, resolveListeners, handler.value);\n+      }\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n function resolveStream(response, id, stream, controller) {\n   var chunks = response._chunks;\n-  stream = new Chunk(\"fulfilled\", stream, controller, response);\n+  stream = new ReactPromise(\"fulfilled\", stream, controller);\n   chunks.set(id, stream);\n   response = response._formData.getAll(response._prefix + id);\n   for (id = 0; id < response.length; id++)\n     (chunks = response[id]),\n-      \"C\" === chunks[0]\n-        ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n-        : controller.enqueueModel(chunks);\n+      \"string\" === typeof chunks &&\n+        (\"C\" === chunks[0]\n+          ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n+          : controller.enqueueModel(chunks));\n }\n function parseReadableStream(response, reference, type) {\n   reference = parseInt(reference.slice(2), 16);\n@@ -2662,7 +2884,7 @@ function parseReadableStream(response, reference, type) {\n   resolveStream(response, reference, type, {\n     enqueueModel: function (json) {\n       if (null === previousBlockedChunk) {\n-        var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+        var chunk = createResolvedModelChunk(response, json, -1);\n         initializeModelChunk(chunk);\n         \"fulfilled\" === chunk.status\n           ? controller.enqueue(chunk.value)\n@@ -2677,19 +2899,19 @@ function parseReadableStream(response, reference, type) {\n             (previousBlockedChunk = chunk));\n       } else {\n         chunk = previousBlockedChunk;\n-        var chunk$29 = createPendingChunk(response);\n-        chunk$29.then(\n+        var chunk$33 = new ReactPromise(\"pending\", null, null);\n+        chunk$33.then(\n           function (v) {\n             return controller.enqueue(v);\n           },\n           function (e) {\n             return controller.error(e);\n           }\n         );\n-        previousBlockedChunk = chunk$29;\n+        previousBlockedChunk = chunk$33;\n         chunk.then(function () {\n-          previousBlockedChunk === chunk$29 && (previousBlockedChunk = null);\n-          resolveModelChunk(chunk$29, json, -1);\n+          previousBlockedChunk === chunk$33 && (previousBlockedChunk = null);\n+          resolveModelChunk(response, chunk$33, json, -1);\n         });\n       }\n     },\n@@ -2729,9 +2951,9 @@ function parseAsyncIterable(response, reference, iterator) {\n   var buffer = [],\n     closed = !1,\n     nextWriteIndex = 0,\n-    $jscomp$compprop2 = {};\n-  $jscomp$compprop2 =\n-    (($jscomp$compprop2[ASYNC_ITERATOR] = function () {\n+    $jscomp$compprop5 = {};\n+  $jscomp$compprop5 =\n+    (($jscomp$compprop5[ASYNC_ITERATOR] = function () {\n       var nextReadIndex = 0;\n       return createIterator(function (arg) {\n         if (void 0 !== arg)\n@@ -2740,19 +2962,18 @@ function parseAsyncIterable(response, reference, iterator) {\n           );\n         if (nextReadIndex === buffer.length) {\n           if (closed)\n-            return new Chunk(\n+            return new ReactPromise(\n               \"fulfilled\",\n               { done: !0, value: void 0 },\n-              null,\n-              response\n+              null\n             );\n-          buffer[nextReadIndex] = createPendingChunk(response);\n+          buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n         }\n         return buffer[nextReadIndex++];\n       });\n     }),\n-    $jscomp$compprop2);\n-  iterator = iterator ? $jscomp$compprop2[ASYNC_ITERATOR]() : $jscomp$compprop2;\n+    $jscomp$compprop5);\n+  iterator = iterator ? $jscomp$compprop5[ASYNC_ITERATOR]() : $jscomp$compprop5;\n   resolveStream(response, reference, iterator, {\n     enqueueModel: function (value) {\n       nextWriteIndex === buffer.length\n@@ -2761,7 +2982,12 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !1\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !1\n+          );\n       nextWriteIndex++;\n     },\n     close: function (value) {\n@@ -2772,9 +2998,15 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !0\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !0\n+          );\n       for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n         resolveIteratorResultChunk(\n+          response,\n           buffer[nextWriteIndex++],\n           '\"$undefined\"',\n           !0\n@@ -2784,11 +3016,11 @@ function parseAsyncIterable(response, reference, iterator) {\n       closed = !0;\n       for (\n         nextWriteIndex === buffer.length &&\n-        (buffer[nextWriteIndex] = createPendingChunk(response));\n+        (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n         nextWriteIndex < buffer.length;\n \n       )\n-        triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+        triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n     }\n   });\n   return iterator;\n@@ -2803,15 +3035,7 @@ function parseModelString(response, obj, key, value, reference) {\n       case \"F\":\n         return (\n           (value = value.slice(2)),\n-          (value = getOutlinedModel(response, value, obj, key, createModel)),\n-          loadServerReference$1(\n-            response,\n-            value.id,\n-            value.bound,\n-            initializingChunk,\n-            obj,\n-            key\n-          )\n+          getOutlinedModel(response, value, obj, key, loadServerReference$1)\n         );\n       case \"T\":\n         if (void 0 === reference || void 0 === response._temporaryReferences)"
        },
        {
            "sha": "1fc11093287146f41bad27c937791172d0b8a2f4",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-server.edge.development.js",
            "status": "modified",
            "additions": 438,
            "deletions": 204,
            "changes": 642,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.edge.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -4018,37 +4018,65 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n-    }\n-    function Chunk(status, value, reason, response) {\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n+    }\n+    function ReactPromise(status, value, reason) {\n       this.status = status;\n       this.value = value;\n       this.reason = reason;\n-      this._response = response;\n     }\n-    function createPendingChunk(response) {\n-      return new Chunk(\"pending\", null, null, response);\n+    function wakeChunk(response, listeners, value) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n     }\n-    function wakeChunk(listeners, value) {\n-      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+    function rejectChunk(response, listeners, error) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(error)\n+          : rejectReference(response, listener.handler, error);\n+      }\n     }\n-    function triggerErrorOnChunk(chunk, error) {\n+    function resolveBlockedCycle(resolvedChunk, reference) {\n+      var referencedChunk = reference.handler.chunk;\n+      if (null === referencedChunk) return null;\n+      if (referencedChunk === resolvedChunk) return reference.handler;\n+      reference = referencedChunk.value;\n+      if (null !== reference)\n+        for (\n+          referencedChunk = 0;\n+          referencedChunk < reference.length;\n+          referencedChunk++\n+        ) {\n+          var listener = reference[referencedChunk];\n+          if (\n+            \"function\" !== typeof listener &&\n+            ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+            null !== listener)\n+          )\n+            return listener;\n+        }\n+      return null;\n+    }\n+    function triggerErrorOnChunk(response, chunk, error) {\n       if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n         chunk.reason.error(error);\n       else {\n         var listeners = chunk.reason;\n         chunk.status = \"rejected\";\n         chunk.reason = error;\n-        null !== listeners && wakeChunk(listeners, error);\n+        null !== listeners && rejectChunk(response, listeners, error);\n       }\n     }\n-    function resolveModelChunk(chunk, value, id) {\n+    function resolveModelChunk(response, chunk, value, id) {\n       if (\"pending\" !== chunk.status)\n         (chunk = chunk.reason),\n           \"C\" === value[0]\n@@ -4059,81 +4087,142 @@\n           rejectListeners = chunk.reason;\n         chunk.status = \"resolved_model\";\n         chunk.value = value;\n-        chunk.reason = id;\n+        chunk.reason = _defineProperty({ id: id }, RESPONSE_SYMBOL, response);\n         if (null !== resolveListeners)\n-          switch ((initializeModelChunk(chunk), chunk.status)) {\n+          a: switch ((initializeModelChunk(chunk), chunk.status)) {\n             case \"fulfilled\":\n-              wakeChunk(resolveListeners, chunk.value);\n+              wakeChunk(response, resolveListeners, chunk.value);\n               break;\n-            case \"pending\":\n             case \"blocked\":\n-            case \"cyclic\":\n+              for (value = 0; value < resolveListeners.length; value++)\n+                if (\n+                  ((id = resolveListeners[value]), \"function\" !== typeof id)\n+                ) {\n+                  var cyclicHandler = resolveBlockedCycle(chunk, id);\n+                  if (null !== cyclicHandler)\n+                    switch (\n+                      (fulfillReference(response, id, cyclicHandler.value),\n+                      resolveListeners.splice(value, 1),\n+                      value--,\n+                      null !== rejectListeners &&\n+                        ((id = rejectListeners.indexOf(id)),\n+                        -1 !== id && rejectListeners.splice(id, 1)),\n+                      chunk.status)\n+                    ) {\n+                      case \"fulfilled\":\n+                        wakeChunk(response, resolveListeners, chunk.value);\n+                        break a;\n+                      case \"rejected\":\n+                        null !== rejectListeners &&\n+                          rejectChunk(response, rejectListeners, chunk.reason);\n+                        break a;\n+                    }\n+                }\n+            case \"pending\":\n               if (chunk.value)\n-                for (value = 0; value < resolveListeners.length; value++)\n-                  chunk.value.push(resolveListeners[value]);\n+                for (\n+                  response = 0;\n+                  response < resolveListeners.length;\n+                  response++\n+                )\n+                  chunk.value.push(resolveListeners[response]);\n               else chunk.value = resolveListeners;\n               if (chunk.reason) {\n                 if (rejectListeners)\n-                  for (value = 0; value < rejectListeners.length; value++)\n-                    chunk.reason.push(rejectListeners[value]);\n+                  for (\n+                    resolveListeners = 0;\n+                    resolveListeners < rejectListeners.length;\n+                    resolveListeners++\n+                  )\n+                    chunk.reason.push(rejectListeners[resolveListeners]);\n               } else chunk.reason = rejectListeners;\n               break;\n             case \"rejected\":\n-              rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+              rejectListeners &&\n+                wakeChunk(response, rejectListeners, chunk.reason);\n           }\n       }\n     }\n     function createResolvedIteratorResultChunk(response, value, done) {\n-      return new Chunk(\n+      return new ReactPromise(\n         \"resolved_model\",\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n-        -1,\n-        response\n+        _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n       );\n     }\n-    function resolveIteratorResultChunk(chunk, value, done) {\n+    function resolveIteratorResultChunk(response, chunk, value, done) {\n       resolveModelChunk(\n+        response,\n         chunk,\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n         -1\n       );\n     }\n-    function loadServerReference$1(\n-      response,\n-      id,\n-      bound,\n-      parentChunk,\n-      parentObject,\n-      key\n-    ) {\n+    function loadServerReference$1(response, metaData, parentObject, key) {\n+      var id = metaData.id;\n+      if (\"string\" !== typeof id) return null;\n       var serverReference = resolveServerReference(response._bundlerConfig, id);\n-      id = preloadModule(serverReference);\n-      if (bound)\n-        bound = Promise.all([bound, id]).then(function (_ref) {\n-          _ref = _ref[0];\n-          var fn = requireModule(serverReference);\n-          return fn.bind.apply(fn, [null].concat(_ref));\n-        });\n-      else if (id)\n-        bound = Promise.resolve(id).then(function () {\n-          return requireModule(serverReference);\n-        });\n+      id = metaData.bound;\n+      var promise = preloadModule(serverReference);\n+      if (promise)\n+        id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+      else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n       else return requireModule(serverReference);\n-      bound.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(parentChunk)\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n+      promise.then(\n+        function () {\n+          var resolvedValue = requireModule(serverReference);\n+          if (metaData.bound) {\n+            var promiseValue = metaData.bound.value;\n+            promiseValue = Array.isArray(promiseValue)\n+              ? promiseValue.slice(0)\n+              : [];\n+            promiseValue.unshift(null);\n+            resolvedValue = resolvedValue.bind.apply(\n+              resolvedValue,\n+              promiseValue\n+            );\n+          }\n+          parentObject[key] = resolvedValue;\n+          \"\" === key &&\n+            null === handler.value &&\n+            (handler.value = resolvedValue);\n+          handler.deps--;\n+          0 === handler.deps &&\n+            ((resolvedValue = handler.chunk),\n+            null !== resolvedValue &&\n+              \"blocked\" === resolvedValue.status &&\n+              ((promiseValue = resolvedValue.value),\n+              (resolvedValue.status = \"fulfilled\"),\n+              (resolvedValue.value = handler.value),\n+              null !== promiseValue &&\n+                wakeChunk(response, promiseValue, handler.value)));\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n@@ -4175,53 +4264,66 @@\n                 value[i],\n                 parentObj\n               )),\n-              void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+              void 0 !== parentObj || \"__proto__\" === i\n+                ? (value[i] = parentObj)\n+                : delete value[i]);\n       return value;\n     }\n     function initializeModelChunk(chunk) {\n-      var prevChunk = initializingChunk,\n-        prevBlocked = initializingChunkBlockedModel;\n-      initializingChunk = chunk;\n-      initializingChunkBlockedModel = null;\n-      var rootReference =\n-          -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-        resolvedModel = chunk.value;\n-      chunk.status = \"cyclic\";\n+      var prevHandler = initializingHandler;\n+      initializingHandler = null;\n+      var _chunk$reason = chunk.reason,\n+        response = _chunk$reason[RESPONSE_SYMBOL];\n+      _chunk$reason = _chunk$reason.id;\n+      _chunk$reason =\n+        -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+      var resolvedModel = chunk.value;\n+      chunk.status = \"blocked\";\n       chunk.value = null;\n       chunk.reason = null;\n       try {\n         var rawModel = JSON.parse(resolvedModel),\n           value = reviveModel(\n-            chunk._response,\n+            response,\n             { \"\": rawModel },\n             \"\",\n             rawModel,\n-            rootReference\n-          );\n-        if (\n-          null !== initializingChunkBlockedModel &&\n-          0 < initializingChunkBlockedModel.deps\n-        )\n-          (initializingChunkBlockedModel.value = value),\n-            (chunk.status = \"blocked\");\n-        else {\n-          var resolveListeners = chunk.value;\n-          chunk.status = \"fulfilled\";\n-          chunk.value = value;\n-          null !== resolveListeners && wakeChunk(resolveListeners, value);\n+            _chunk$reason\n+          ),\n+          resolveListeners = chunk.value;\n+        if (null !== resolveListeners)\n+          for (\n+            chunk.value = null, chunk.reason = null, rawModel = 0;\n+            rawModel < resolveListeners.length;\n+            rawModel++\n+          ) {\n+            var listener = resolveListeners[rawModel];\n+            \"function\" === typeof listener\n+              ? listener(value)\n+              : fulfillReference(response, listener, value);\n+          }\n+        if (null !== initializingHandler) {\n+          if (initializingHandler.errored) throw initializingHandler.reason;\n+          if (0 < initializingHandler.deps) {\n+            initializingHandler.value = value;\n+            initializingHandler.chunk = chunk;\n+            return;\n+          }\n         }\n+        chunk.status = \"fulfilled\";\n+        chunk.value = value;\n       } catch (error) {\n         (chunk.status = \"rejected\"), (chunk.reason = error);\n       } finally {\n-        (initializingChunk = prevChunk),\n-          (initializingChunkBlockedModel = prevBlocked);\n+        initializingHandler = prevHandler;\n       }\n     }\n     function reportGlobalError(response, error) {\n       response._closed = !0;\n       response._closedReason = error;\n       response._chunks.forEach(function (chunk) {\n-        \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+        \"pending\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n       });\n     }\n     function getChunk(response, id) {\n@@ -4230,50 +4332,108 @@\n       chunk ||\n         ((chunk = response._formData.get(response._prefix + id)),\n         (chunk =\n-          null != chunk\n-            ? new Chunk(\"resolved_model\", chunk, id, response)\n+          \"string\" === typeof chunk\n+            ? new ReactPromise(\n+                \"resolved_model\",\n+                chunk,\n+                _defineProperty({ id: id }, RESPONSE_SYMBOL, response)\n+              )\n             : response._closed\n-              ? new Chunk(\"rejected\", null, response._closedReason, response)\n-              : createPendingChunk(response)),\n+              ? new ReactPromise(\"rejected\", null, response._closedReason)\n+              : new ReactPromise(\"pending\", null, null)),\n         chunks.set(id, chunk));\n       return chunk;\n     }\n-    function createModelResolver(\n-      chunk,\n+    function fulfillReference(response, reference, value) {\n+      for (\n+        var handler = reference.handler,\n+          parentObject = reference.parentObject,\n+          key = reference.key,\n+          map = reference.map,\n+          path = reference.path,\n+          i = 1;\n+        i < path.length;\n+        i++\n+      ) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              continue;\n+            case \"blocked\":\n+            case \"pending\":\n+              path.splice(0, i - 1);\n+              null === value.value\n+                ? (value.value = [reference])\n+                : value.value.push(reference);\n+              null === value.reason\n+                ? (value.reason = [reference])\n+                : value.reason.push(reference);\n+              return;\n+            default:\n+              rejectReference(response, reference.handler, value.reason);\n+              return;\n+          }\n+        }\n+        var name = path[i];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      reference = map(response, value, parentObject, key);\n+      parentObject[key] = reference;\n+      \"\" === key && null === handler.value && (handler.value = reference);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((parentObject = handler.chunk),\n+        null !== parentObject &&\n+          \"blocked\" === parentObject.status &&\n+          ((key = parentObject.value),\n+          (parentObject.status = \"fulfilled\"),\n+          (parentObject.value = handler.value),\n+          (parentObject.reason = handler.reason),\n+          null !== key && wakeChunk(response, key, handler.value)));\n+    }\n+    function rejectReference(response, handler, error) {\n+      handler.errored ||\n+        ((handler.errored = !0),\n+        (handler.value = null),\n+        (handler.reason = error),\n+        (handler = handler.chunk),\n+        null !== handler &&\n+          \"blocked\" === handler.status &&\n+          triggerErrorOnChunk(response, handler, error));\n+    }\n+    function waitForReference(\n+      referencedChunk,\n       parentObject,\n       key,\n-      cyclic,\n       response,\n       map,\n       path\n     ) {\n-      if (initializingChunkBlockedModel) {\n-        var blocked = initializingChunkBlockedModel;\n-        cyclic || blocked.deps++;\n-      } else\n-        blocked = initializingChunkBlockedModel = {\n-          deps: cyclic ? 0 : 1,\n-          value: null\n-        };\n-      return function (value) {\n-        for (var i = 1; i < path.length; i++) value = value[path[i]];\n-        parentObject[key] = map(response, value);\n-        \"\" === key &&\n-          null === blocked.value &&\n-          (blocked.value = parentObject[key]);\n-        blocked.deps--;\n-        0 === blocked.deps &&\n-          \"blocked\" === chunk.status &&\n-          ((value = chunk.value),\n-          (chunk.status = \"fulfilled\"),\n-          (chunk.value = blocked.value),\n-          null !== value && wakeChunk(value, blocked.value));\n-      };\n-    }\n-    function createModelReject(chunk) {\n-      return function (error) {\n-        return triggerErrorOnChunk(chunk, error);\n+      initializingHandler\n+        ? ((response = initializingHandler), response.deps++)\n+        : (response = initializingHandler =\n+            { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+      parentObject = {\n+        handler: response,\n+        parentObject: parentObject,\n+        key: key,\n+        map: map,\n+        path: path\n       };\n+      null === referencedChunk.value\n+        ? (referencedChunk.value = [parentObject])\n+        : referencedChunk.value.push(parentObject);\n+      null === referencedChunk.reason\n+        ? (referencedChunk.reason = [parentObject])\n+        : referencedChunk.reason.push(parentObject);\n+      return null;\n     }\n     function getOutlinedModel(response, reference, parentObject, key, map) {\n       reference = reference.split(\":\");\n@@ -4285,29 +4445,75 @@\n       }\n       switch (id.status) {\n         case \"fulfilled\":\n-          parentObject = id.value;\n-          for (key = 1; key < reference.length; key++)\n-            parentObject = parentObject[reference[key]];\n-          return map(response, parentObject);\n+          var value = id.value;\n+          for (id = 1; id < reference.length; id++) {\n+            for (; value instanceof ReactPromise; ) {\n+              switch (value.status) {\n+                case \"resolved_model\":\n+                  initializeModelChunk(value);\n+              }\n+              switch (value.status) {\n+                case \"fulfilled\":\n+                  value = value.value;\n+                  break;\n+                case \"blocked\":\n+                case \"pending\":\n+                  return waitForReference(\n+                    value,\n+                    parentObject,\n+                    key,\n+                    response,\n+                    map,\n+                    reference.slice(id - 1)\n+                  );\n+                default:\n+                  return (\n+                    initializingHandler\n+                      ? ((initializingHandler.errored = !0),\n+                        (initializingHandler.value = null),\n+                        (initializingHandler.reason = value.reason))\n+                      : (initializingHandler = {\n+                          chunk: null,\n+                          value: null,\n+                          reason: value.reason,\n+                          deps: 0,\n+                          errored: !0\n+                        }),\n+                    null\n+                  );\n+              }\n+            }\n+            var name = reference[id];\n+            \"object\" === typeof value &&\n+              hasOwnProperty.call(value, name) &&\n+              (value = value[name]);\n+          }\n+          return map(response, value, parentObject, key);\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          var parentChunk = initializingChunk;\n-          id.then(\n-            createModelResolver(\n-              parentChunk,\n-              parentObject,\n-              key,\n-              \"cyclic\" === id.status,\n-              response,\n-              map,\n-              reference\n-            ),\n-            createModelReject(parentChunk)\n+          return waitForReference(\n+            id,\n+            parentObject,\n+            key,\n+            response,\n+            map,\n+            reference\n           );\n-          return null;\n         default:\n-          throw id.reason;\n+          return (\n+            initializingHandler\n+              ? ((initializingHandler.errored = !0),\n+                (initializingHandler.value = null),\n+                (initializingHandler.reason = id.reason))\n+              : (initializingHandler = {\n+                  chunk: null,\n+                  value: null,\n+                  reason: id.reason,\n+                  deps: 0,\n+                  errored: !0\n+                }),\n+            null\n+          );\n       }\n     }\n     function createMap(response, model) {\n@@ -4331,40 +4537,68 @@\n       parentKey\n     ) {\n       reference = parseInt(reference.slice(2), 16);\n-      reference = response._formData.get(response._prefix + reference);\n-      reference =\n-        constructor === ArrayBuffer\n-          ? reference.arrayBuffer()\n-          : reference.arrayBuffer().then(function (buffer) {\n-              return new constructor(buffer);\n-            });\n-      bytesPerElement = initializingChunk;\n+      reference = response._formData\n+        .get(response._prefix + reference)\n+        .arrayBuffer();\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n       reference.then(\n-        createModelResolver(\n-          bytesPerElement,\n-          parentObject,\n-          parentKey,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(bytesPerElement)\n+        function (buffer) {\n+          buffer =\n+            constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+          parentObject[parentKey] = buffer;\n+          \"\" === parentKey &&\n+            null === handler.value &&\n+            (handler.value = buffer);\n+          handler.deps--;\n+          if (\n+            0 === handler.deps &&\n+            ((buffer = handler.chunk),\n+            null !== buffer && \"blocked\" === buffer.status)\n+          ) {\n+            var resolveListeners = buffer.value;\n+            buffer.status = \"fulfilled\";\n+            buffer.value = handler.value;\n+            null !== resolveListeners &&\n+              wakeChunk(response, resolveListeners, handler.value);\n+          }\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n     function resolveStream(response, id, stream, controller) {\n       var chunks = response._chunks;\n-      stream = new Chunk(\"fulfilled\", stream, controller, response);\n+      stream = new ReactPromise(\"fulfilled\", stream, controller);\n       chunks.set(id, stream);\n       response = response._formData.getAll(response._prefix + id);\n       for (id = 0; id < response.length; id++)\n         (chunks = response[id]),\n-          \"C\" === chunks[0]\n-            ? controller.close(\n-                \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n-              )\n-            : controller.enqueueModel(chunks);\n+          \"string\" === typeof chunks &&\n+            (\"C\" === chunks[0]\n+              ? controller.close(\n+                  \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n+                )\n+              : controller.enqueueModel(chunks));\n     }\n     function parseReadableStream(response, reference, type) {\n       reference = parseInt(reference.slice(2), 16);\n@@ -4379,7 +4613,11 @@\n       resolveStream(response, reference, type, {\n         enqueueModel: function (json) {\n           if (null === previousBlockedChunk) {\n-            var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+            var chunk = new ReactPromise(\n+              \"resolved_model\",\n+              json,\n+              _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n+            );\n             initializeModelChunk(chunk);\n             \"fulfilled\" === chunk.status\n               ? controller.enqueue(chunk.value)\n@@ -4394,7 +4632,7 @@\n                 (previousBlockedChunk = chunk));\n           } else {\n             chunk = previousBlockedChunk;\n-            var _chunk = createPendingChunk(response);\n+            var _chunk = new ReactPromise(\"pending\", null, null);\n             _chunk.then(\n               function (v) {\n                 return controller.enqueue(v);\n@@ -4406,7 +4644,7 @@\n             previousBlockedChunk = _chunk;\n             chunk.then(function () {\n               previousBlockedChunk === _chunk && (previousBlockedChunk = null);\n-              resolveModelChunk(_chunk, json, -1);\n+              resolveModelChunk(response, _chunk, json, -1);\n             });\n           }\n         },\n@@ -4455,13 +4693,12 @@\n               );\n             if (nextReadIndex === buffer.length) {\n               if (closed)\n-                return new Chunk(\n+                return new ReactPromise(\n                   \"fulfilled\",\n                   { done: !0, value: void 0 },\n-                  null,\n-                  response\n+                  null\n                 );\n-              buffer[nextReadIndex] = createPendingChunk(response);\n+              buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n             }\n             return buffer[nextReadIndex++];\n           });\n@@ -4475,7 +4712,12 @@\n                 value,\n                 !1\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !1\n+              );\n           nextWriteIndex++;\n         },\n         close: function (value) {\n@@ -4486,9 +4728,15 @@\n                 value,\n                 !0\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !0\n+              );\n           for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n             resolveIteratorResultChunk(\n+              response,\n               buffer[nextWriteIndex++],\n               '\"$undefined\"',\n               !0\n@@ -4498,11 +4746,11 @@\n           closed = !0;\n           for (\n             nextWriteIndex === buffer.length &&\n-            (buffer[nextWriteIndex] = createPendingChunk(response));\n+            (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n             nextWriteIndex < buffer.length;\n \n           )\n-            triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n         }\n       });\n       return iterator;\n@@ -4519,21 +4767,7 @@\n           case \"F\":\n             return (\n               (value = value.slice(2)),\n-              (value = getOutlinedModel(\n-                response,\n-                value,\n-                obj,\n-                key,\n-                createModel\n-              )),\n-              loadServerReference$1(\n-                response,\n-                value.id,\n-                value.bound,\n-                initializingChunk,\n-                obj,\n-                key\n-              )\n+              getOutlinedModel(response, value, obj, key, loadServerReference$1)\n             );\n           case \"T\":\n             if (\n@@ -5210,33 +5444,32 @@\n       emptyRoot = {},\n       decoderOptions = { stream: !0 },\n       instrumentedChunks = new WeakSet(),\n-      loadedChunks = new WeakSet();\n-    Chunk.prototype = Object.create(Promise.prototype);\n-    Chunk.prototype.then = function (resolve, reject) {\n+      loadedChunks = new WeakSet(),\n+      RESPONSE_SYMBOL = Symbol();\n+    ReactPromise.prototype = Object.create(Promise.prototype);\n+    ReactPromise.prototype.then = function (resolve, reject) {\n       switch (this.status) {\n         case \"resolved_model\":\n           initializeModelChunk(this);\n       }\n       switch (this.status) {\n         case \"fulfilled\":\n-          resolve(this.value);\n+          \"function\" === typeof resolve && resolve(this.value);\n           break;\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          resolve &&\n+          \"function\" === typeof resolve &&\n             (null === this.value && (this.value = []),\n             this.value.push(resolve));\n-          reject &&\n+          \"function\" === typeof reject &&\n             (null === this.reason && (this.reason = []),\n             this.reason.push(reject));\n           break;\n         default:\n-          reject(this.reason);\n+          \"function\" === typeof reject && reject(this.reason);\n       }\n     };\n-    var initializingChunk = null,\n-      initializingChunkBlockedModel = null;\n+    var initializingHandler = null;\n     exports.createClientModuleProxy = function (moduleId) {\n       moduleId = registerClientReferenceImpl({}, moduleId, !1);\n       return new Proxy(moduleId, proxyHandlers$1);\n@@ -5316,11 +5549,12 @@\n             var response = response$jscomp$0;\n             response._formData.append(name, entry);\n             var prefix = response._prefix;\n-            name.startsWith(prefix) &&\n-              ((response = response._chunks),\n-              (name = +name.slice(prefix.length)),\n-              (prefix = response.get(name)) &&\n-                resolveModelChunk(prefix, entry, name));\n+            if (name.startsWith(prefix)) {\n+              var chunks = response._chunks;\n+              name = +name.slice(prefix.length);\n+              (chunks = chunks.get(name)) &&\n+                resolveModelChunk(response, chunks, entry, name);\n+            }\n           } else response$jscomp$0._formData.append(name, entry);\n           iterator.next().then(progress, error);\n         }"
        },
        {
            "sha": "06242836fb29c43d5eb2f8620907e09fa0df6ecd",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-server.edge.production.js",
            "status": "modified",
            "additions": 428,
            "deletions": 203,
            "changes": 631,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.edge.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -979,8 +979,8 @@ function serializeReadableStream(request, task, stream) {\n               : tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             reader.read().then(progress, error);\n-        } catch (x$8) {\n-          error(x$8);\n+        } catch (x$11) {\n+          error(x$11);\n         }\n   }\n   function error(reason) {\n@@ -1065,8 +1065,8 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n             tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             iterator.next().then(progress, error);\n-        } catch (x$9) {\n-          error(x$9);\n+        } catch (x$12) {\n+          error(x$12);\n         }\n   }\n   function error(reason) {\n@@ -2233,9 +2233,9 @@ function abort(request, reason) {\n         onAllReady();\n         flushCompletedChunks(request);\n       }\n-    } catch (error$26) {\n-      logRecoverableError(request, error$26, null),\n-        fatalError(request, error$26);\n+    } catch (error$29) {\n+      logRecoverableError(request, error$29, null),\n+        fatalError(request, error$29);\n     }\n }\n function resolveServerReference(bundlerConfig, id) {\n@@ -2303,59 +2303,97 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n-}\n-function Chunk(status, value, reason, response) {\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n+}\n+var RESPONSE_SYMBOL = Symbol();\n+function ReactPromise(status, value, reason) {\n   this.status = status;\n   this.value = value;\n   this.reason = reason;\n-  this._response = response;\n }\n-Chunk.prototype = Object.create(Promise.prototype);\n-Chunk.prototype.then = function (resolve, reject) {\n+ReactPromise.prototype = Object.create(Promise.prototype);\n+ReactPromise.prototype.then = function (resolve, reject) {\n   switch (this.status) {\n     case \"resolved_model\":\n       initializeModelChunk(this);\n   }\n   switch (this.status) {\n     case \"fulfilled\":\n-      resolve(this.value);\n+      \"function\" === typeof resolve && resolve(this.value);\n       break;\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      resolve &&\n+      \"function\" === typeof resolve &&\n         (null === this.value && (this.value = []), this.value.push(resolve));\n-      reject &&\n+      \"function\" === typeof reject &&\n         (null === this.reason && (this.reason = []), this.reason.push(reject));\n       break;\n     default:\n-      reject(this.reason);\n+      \"function\" === typeof reject && reject(this.reason);\n   }\n };\n-function createPendingChunk(response) {\n-  return new Chunk(\"pending\", null, null, response);\n+function wakeChunk(response, listeners, value) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(value)\n+      : fulfillReference(response, listener, value);\n+  }\n }\n-function wakeChunk(listeners, value) {\n-  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+function rejectChunk(response, listeners, error) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(error)\n+      : rejectReference(response, listener.handler, error);\n+  }\n }\n-function triggerErrorOnChunk(chunk, error) {\n+function resolveBlockedCycle(resolvedChunk, reference) {\n+  var referencedChunk = reference.handler.chunk;\n+  if (null === referencedChunk) return null;\n+  if (referencedChunk === resolvedChunk) return reference.handler;\n+  reference = referencedChunk.value;\n+  if (null !== reference)\n+    for (\n+      referencedChunk = 0;\n+      referencedChunk < reference.length;\n+      referencedChunk++\n+    ) {\n+      var listener = reference[referencedChunk];\n+      if (\n+        \"function\" !== typeof listener &&\n+        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+        null !== listener)\n+      )\n+        return listener;\n+    }\n+  return null;\n+}\n+function triggerErrorOnChunk(response, chunk, error) {\n   if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n     chunk.reason.error(error);\n   else {\n     var listeners = chunk.reason;\n     chunk.status = \"rejected\";\n     chunk.reason = error;\n-    null !== listeners && wakeChunk(listeners, error);\n+    null !== listeners && rejectChunk(response, listeners, error);\n   }\n }\n-function resolveModelChunk(chunk, value, id) {\n+function createResolvedModelChunk(response, value, id) {\n+  var $jscomp$compprop2 = {};\n+  return new ReactPromise(\n+    \"resolved_model\",\n+    value,\n+    (($jscomp$compprop2.id = id),\n+    ($jscomp$compprop2[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop2)\n+  );\n+}\n+function resolveModelChunk(response, chunk, value, id) {\n   if (\"pending\" !== chunk.status)\n     (chunk = chunk.reason),\n       \"C\" === value[0]\n@@ -2366,77 +2404,129 @@ function resolveModelChunk(chunk, value, id) {\n       rejectListeners = chunk.reason;\n     chunk.status = \"resolved_model\";\n     chunk.value = value;\n-    chunk.reason = id;\n+    value = {};\n+    chunk.reason =\n+      ((value.id = id), (value[RESPONSE_SYMBOL] = response), value);\n     if (null !== resolveListeners)\n-      switch ((initializeModelChunk(chunk), chunk.status)) {\n+      a: switch ((initializeModelChunk(chunk), chunk.status)) {\n         case \"fulfilled\":\n-          wakeChunk(resolveListeners, chunk.value);\n+          wakeChunk(response, resolveListeners, chunk.value);\n           break;\n-        case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n+          for (value = 0; value < resolveListeners.length; value++)\n+            if (((id = resolveListeners[value]), \"function\" !== typeof id)) {\n+              var cyclicHandler = resolveBlockedCycle(chunk, id);\n+              if (null !== cyclicHandler)\n+                switch (\n+                  (fulfillReference(response, id, cyclicHandler.value),\n+                  resolveListeners.splice(value, 1),\n+                  value--,\n+                  null !== rejectListeners &&\n+                    ((id = rejectListeners.indexOf(id)),\n+                    -1 !== id && rejectListeners.splice(id, 1)),\n+                  chunk.status)\n+                ) {\n+                  case \"fulfilled\":\n+                    wakeChunk(response, resolveListeners, chunk.value);\n+                    break a;\n+                  case \"rejected\":\n+                    null !== rejectListeners &&\n+                      rejectChunk(response, rejectListeners, chunk.reason);\n+                    break a;\n+                }\n+            }\n+        case \"pending\":\n           if (chunk.value)\n-            for (value = 0; value < resolveListeners.length; value++)\n-              chunk.value.push(resolveListeners[value]);\n+            for (response = 0; response < resolveListeners.length; response++)\n+              chunk.value.push(resolveListeners[response]);\n           else chunk.value = resolveListeners;\n           if (chunk.reason) {\n             if (rejectListeners)\n-              for (value = 0; value < rejectListeners.length; value++)\n-                chunk.reason.push(rejectListeners[value]);\n+              for (\n+                resolveListeners = 0;\n+                resolveListeners < rejectListeners.length;\n+                resolveListeners++\n+              )\n+                chunk.reason.push(rejectListeners[resolveListeners]);\n           } else chunk.reason = rejectListeners;\n           break;\n         case \"rejected\":\n-          rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+          rejectListeners && wakeChunk(response, rejectListeners, chunk.reason);\n       }\n   }\n }\n function createResolvedIteratorResultChunk(response, value, done) {\n-  return new Chunk(\n+  var $jscomp$compprop4 = {};\n+  return new ReactPromise(\n     \"resolved_model\",\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n-    -1,\n-    response\n+    (($jscomp$compprop4.id = -1),\n+    ($jscomp$compprop4[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop4)\n   );\n }\n-function resolveIteratorResultChunk(chunk, value, done) {\n+function resolveIteratorResultChunk(response, chunk, value, done) {\n   resolveModelChunk(\n+    response,\n     chunk,\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n     -1\n   );\n }\n-function loadServerReference$1(\n-  response,\n-  id,\n-  bound,\n-  parentChunk,\n-  parentObject,\n-  key\n-) {\n+function loadServerReference$1(response, metaData, parentObject, key) {\n+  var id = metaData.id;\n+  if (\"string\" !== typeof id) return null;\n   var serverReference = resolveServerReference(response._bundlerConfig, id);\n-  id = preloadModule(serverReference);\n-  if (bound)\n-    bound = Promise.all([bound, id]).then(function (_ref) {\n-      _ref = _ref[0];\n-      var fn = requireModule(serverReference);\n-      return fn.bind.apply(fn, [null].concat(_ref));\n-    });\n-  else if (id)\n-    bound = Promise.resolve(id).then(function () {\n-      return requireModule(serverReference);\n-    });\n+  id = metaData.bound;\n+  var promise = preloadModule(serverReference);\n+  if (promise)\n+    id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+  else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n   else return requireModule(serverReference);\n-  bound.then(\n-    createModelResolver(\n-      parentChunk,\n-      parentObject,\n-      key,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(parentChunk)\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n+  promise.then(\n+    function () {\n+      var resolvedValue = requireModule(serverReference);\n+      if (metaData.bound) {\n+        var promiseValue = metaData.bound.value;\n+        promiseValue = Array.isArray(promiseValue) ? promiseValue.slice(0) : [];\n+        promiseValue.unshift(null);\n+        resolvedValue = resolvedValue.bind.apply(resolvedValue, promiseValue);\n+      }\n+      parentObject[key] = resolvedValue;\n+      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((resolvedValue = handler.chunk),\n+        null !== resolvedValue &&\n+          \"blocked\" === resolvedValue.status &&\n+          ((promiseValue = resolvedValue.value),\n+          (resolvedValue.status = \"fulfilled\"),\n+          (resolvedValue.value = handler.value),\n+          null !== promiseValue &&\n+            wakeChunk(response, promiseValue, handler.value)));\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n@@ -2466,53 +2556,65 @@ function reviveModel(response, parentObj, parentKey, value, reference) {\n               ? reference + \":\" + i\n               : void 0),\n           (parentObj = reviveModel(response, value, i, value[i], parentObj)),\n-          void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+          void 0 !== parentObj || \"__proto__\" === i\n+            ? (value[i] = parentObj)\n+            : delete value[i]);\n   return value;\n }\n-var initializingChunk = null,\n-  initializingChunkBlockedModel = null;\n+var initializingHandler = null;\n function initializeModelChunk(chunk) {\n-  var prevChunk = initializingChunk,\n-    prevBlocked = initializingChunkBlockedModel;\n-  initializingChunk = chunk;\n-  initializingChunkBlockedModel = null;\n-  var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-    resolvedModel = chunk.value;\n-  chunk.status = \"cyclic\";\n+  var prevHandler = initializingHandler;\n+  initializingHandler = null;\n+  var _chunk$reason = chunk.reason,\n+    response = _chunk$reason[RESPONSE_SYMBOL];\n+  _chunk$reason = _chunk$reason.id;\n+  _chunk$reason = -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+  var resolvedModel = chunk.value;\n+  chunk.status = \"blocked\";\n   chunk.value = null;\n   chunk.reason = null;\n   try {\n     var rawModel = JSON.parse(resolvedModel),\n       value = reviveModel(\n-        chunk._response,\n+        response,\n         { \"\": rawModel },\n         \"\",\n         rawModel,\n-        rootReference\n-      );\n-    if (\n-      null !== initializingChunkBlockedModel &&\n-      0 < initializingChunkBlockedModel.deps\n-    )\n-      (initializingChunkBlockedModel.value = value), (chunk.status = \"blocked\");\n-    else {\n-      var resolveListeners = chunk.value;\n-      chunk.status = \"fulfilled\";\n-      chunk.value = value;\n-      null !== resolveListeners && wakeChunk(resolveListeners, value);\n+        _chunk$reason\n+      ),\n+      resolveListeners = chunk.value;\n+    if (null !== resolveListeners)\n+      for (\n+        chunk.value = null, chunk.reason = null, rawModel = 0;\n+        rawModel < resolveListeners.length;\n+        rawModel++\n+      ) {\n+        var listener = resolveListeners[rawModel];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n+    if (null !== initializingHandler) {\n+      if (initializingHandler.errored) throw initializingHandler.reason;\n+      if (0 < initializingHandler.deps) {\n+        initializingHandler.value = value;\n+        initializingHandler.chunk = chunk;\n+        return;\n+      }\n     }\n+    chunk.status = \"fulfilled\";\n+    chunk.value = value;\n   } catch (error) {\n     (chunk.status = \"rejected\"), (chunk.reason = error);\n   } finally {\n-    (initializingChunk = prevChunk),\n-      (initializingChunkBlockedModel = prevBlocked);\n+    initializingHandler = prevHandler;\n   }\n }\n function reportGlobalError(response, error) {\n   response._closed = !0;\n   response._closedReason = error;\n   response._chunks.forEach(function (chunk) {\n-    \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+    \"pending\" === chunk.status && triggerErrorOnChunk(response, chunk, error);\n   });\n }\n function getChunk(response, id) {\n@@ -2521,48 +2623,104 @@ function getChunk(response, id) {\n   chunk ||\n     ((chunk = response._formData.get(response._prefix + id)),\n     (chunk =\n-      null != chunk\n-        ? new Chunk(\"resolved_model\", chunk, id, response)\n+      \"string\" === typeof chunk\n+        ? createResolvedModelChunk(response, chunk, id)\n         : response._closed\n-          ? new Chunk(\"rejected\", null, response._closedReason, response)\n-          : createPendingChunk(response)),\n+          ? new ReactPromise(\"rejected\", null, response._closedReason)\n+          : new ReactPromise(\"pending\", null, null)),\n     chunks.set(id, chunk));\n   return chunk;\n }\n-function createModelResolver(\n-  chunk,\n+function fulfillReference(response, reference, value) {\n+  for (\n+    var handler = reference.handler,\n+      parentObject = reference.parentObject,\n+      key = reference.key,\n+      map = reference.map,\n+      path = reference.path,\n+      i = 1;\n+    i < path.length;\n+    i++\n+  ) {\n+    for (; value instanceof ReactPromise; ) {\n+      switch (value.status) {\n+        case \"resolved_model\":\n+          initializeModelChunk(value);\n+      }\n+      switch (value.status) {\n+        case \"fulfilled\":\n+          value = value.value;\n+          continue;\n+        case \"blocked\":\n+        case \"pending\":\n+          path.splice(0, i - 1);\n+          null === value.value\n+            ? (value.value = [reference])\n+            : value.value.push(reference);\n+          null === value.reason\n+            ? (value.reason = [reference])\n+            : value.reason.push(reference);\n+          return;\n+        default:\n+          rejectReference(response, reference.handler, value.reason);\n+          return;\n+      }\n+    }\n+    var name = path[i];\n+    \"object\" === typeof value &&\n+      hasOwnProperty.call(value, name) &&\n+      (value = value[name]);\n+  }\n+  reference = map(response, value, parentObject, key);\n+  parentObject[key] = reference;\n+  \"\" === key && null === handler.value && (handler.value = reference);\n+  handler.deps--;\n+  0 === handler.deps &&\n+    ((parentObject = handler.chunk),\n+    null !== parentObject &&\n+      \"blocked\" === parentObject.status &&\n+      ((key = parentObject.value),\n+      (parentObject.status = \"fulfilled\"),\n+      (parentObject.value = handler.value),\n+      (parentObject.reason = handler.reason),\n+      null !== key && wakeChunk(response, key, handler.value)));\n+}\n+function rejectReference(response, handler, error) {\n+  handler.errored ||\n+    ((handler.errored = !0),\n+    (handler.value = null),\n+    (handler.reason = error),\n+    (handler = handler.chunk),\n+    null !== handler &&\n+      \"blocked\" === handler.status &&\n+      triggerErrorOnChunk(response, handler, error));\n+}\n+function waitForReference(\n+  referencedChunk,\n   parentObject,\n   key,\n-  cyclic,\n   response,\n   map,\n   path\n ) {\n-  if (initializingChunkBlockedModel) {\n-    var blocked = initializingChunkBlockedModel;\n-    cyclic || blocked.deps++;\n-  } else\n-    blocked = initializingChunkBlockedModel = {\n-      deps: cyclic ? 0 : 1,\n-      value: null\n-    };\n-  return function (value) {\n-    for (var i = 1; i < path.length; i++) value = value[path[i]];\n-    parentObject[key] = map(response, value);\n-    \"\" === key && null === blocked.value && (blocked.value = parentObject[key]);\n-    blocked.deps--;\n-    0 === blocked.deps &&\n-      \"blocked\" === chunk.status &&\n-      ((value = chunk.value),\n-      (chunk.status = \"fulfilled\"),\n-      (chunk.value = blocked.value),\n-      null !== value && wakeChunk(value, blocked.value));\n-  };\n-}\n-function createModelReject(chunk) {\n-  return function (error) {\n-    return triggerErrorOnChunk(chunk, error);\n+  initializingHandler\n+    ? ((response = initializingHandler), response.deps++)\n+    : (response = initializingHandler =\n+        { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+  parentObject = {\n+    handler: response,\n+    parentObject: parentObject,\n+    key: key,\n+    map: map,\n+    path: path\n   };\n+  null === referencedChunk.value\n+    ? (referencedChunk.value = [parentObject])\n+    : referencedChunk.value.push(parentObject);\n+  null === referencedChunk.reason\n+    ? (referencedChunk.reason = [parentObject])\n+    : referencedChunk.reason.push(parentObject);\n+  return null;\n }\n function getOutlinedModel(response, reference, parentObject, key, map) {\n   reference = reference.split(\":\");\n@@ -2574,29 +2732,68 @@ function getOutlinedModel(response, reference, parentObject, key, map) {\n   }\n   switch (id.status) {\n     case \"fulfilled\":\n-      parentObject = id.value;\n-      for (key = 1; key < reference.length; key++)\n-        parentObject = parentObject[reference[key]];\n-      return map(response, parentObject);\n+      var value = id.value;\n+      for (id = 1; id < reference.length; id++) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              break;\n+            case \"blocked\":\n+            case \"pending\":\n+              return waitForReference(\n+                value,\n+                parentObject,\n+                key,\n+                response,\n+                map,\n+                reference.slice(id - 1)\n+              );\n+            default:\n+              return (\n+                initializingHandler\n+                  ? ((initializingHandler.errored = !0),\n+                    (initializingHandler.value = null),\n+                    (initializingHandler.reason = value.reason))\n+                  : (initializingHandler = {\n+                      chunk: null,\n+                      value: null,\n+                      reason: value.reason,\n+                      deps: 0,\n+                      errored: !0\n+                    }),\n+                null\n+              );\n+          }\n+        }\n+        var name = reference[id];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      return map(response, value, parentObject, key);\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      var parentChunk = initializingChunk;\n-      id.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          \"cyclic\" === id.status,\n-          response,\n-          map,\n-          reference\n-        ),\n-        createModelReject(parentChunk)\n-      );\n-      return null;\n+      return waitForReference(id, parentObject, key, response, map, reference);\n     default:\n-      throw id.reason;\n+      return (\n+        initializingHandler\n+          ? ((initializingHandler.errored = !0),\n+            (initializingHandler.value = null),\n+            (initializingHandler.reason = id.reason))\n+          : (initializingHandler = {\n+              chunk: null,\n+              value: null,\n+              reason: id.reason,\n+              deps: 0,\n+              errored: !0\n+            }),\n+        null\n+      );\n   }\n }\n function createMap(response, model) {\n@@ -2620,38 +2817,63 @@ function parseTypedArray(\n   parentKey\n ) {\n   reference = parseInt(reference.slice(2), 16);\n-  reference = response._formData.get(response._prefix + reference);\n-  reference =\n-    constructor === ArrayBuffer\n-      ? reference.arrayBuffer()\n-      : reference.arrayBuffer().then(function (buffer) {\n-          return new constructor(buffer);\n-        });\n-  bytesPerElement = initializingChunk;\n+  reference = response._formData\n+    .get(response._prefix + reference)\n+    .arrayBuffer();\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n   reference.then(\n-    createModelResolver(\n-      bytesPerElement,\n-      parentObject,\n-      parentKey,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(bytesPerElement)\n+    function (buffer) {\n+      buffer = constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+      parentObject[parentKey] = buffer;\n+      \"\" === parentKey && null === handler.value && (handler.value = buffer);\n+      handler.deps--;\n+      if (\n+        0 === handler.deps &&\n+        ((buffer = handler.chunk),\n+        null !== buffer && \"blocked\" === buffer.status)\n+      ) {\n+        var resolveListeners = buffer.value;\n+        buffer.status = \"fulfilled\";\n+        buffer.value = handler.value;\n+        null !== resolveListeners &&\n+          wakeChunk(response, resolveListeners, handler.value);\n+      }\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n function resolveStream(response, id, stream, controller) {\n   var chunks = response._chunks;\n-  stream = new Chunk(\"fulfilled\", stream, controller, response);\n+  stream = new ReactPromise(\"fulfilled\", stream, controller);\n   chunks.set(id, stream);\n   response = response._formData.getAll(response._prefix + id);\n   for (id = 0; id < response.length; id++)\n     (chunks = response[id]),\n-      \"C\" === chunks[0]\n-        ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n-        : controller.enqueueModel(chunks);\n+      \"string\" === typeof chunks &&\n+        (\"C\" === chunks[0]\n+          ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n+          : controller.enqueueModel(chunks));\n }\n function parseReadableStream(response, reference, type) {\n   reference = parseInt(reference.slice(2), 16);\n@@ -2666,7 +2888,7 @@ function parseReadableStream(response, reference, type) {\n   resolveStream(response, reference, type, {\n     enqueueModel: function (json) {\n       if (null === previousBlockedChunk) {\n-        var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+        var chunk = createResolvedModelChunk(response, json, -1);\n         initializeModelChunk(chunk);\n         \"fulfilled\" === chunk.status\n           ? controller.enqueue(chunk.value)\n@@ -2681,19 +2903,19 @@ function parseReadableStream(response, reference, type) {\n             (previousBlockedChunk = chunk));\n       } else {\n         chunk = previousBlockedChunk;\n-        var chunk$29 = createPendingChunk(response);\n-        chunk$29.then(\n+        var chunk$33 = new ReactPromise(\"pending\", null, null);\n+        chunk$33.then(\n           function (v) {\n             return controller.enqueue(v);\n           },\n           function (e) {\n             return controller.error(e);\n           }\n         );\n-        previousBlockedChunk = chunk$29;\n+        previousBlockedChunk = chunk$33;\n         chunk.then(function () {\n-          previousBlockedChunk === chunk$29 && (previousBlockedChunk = null);\n-          resolveModelChunk(chunk$29, json, -1);\n+          previousBlockedChunk === chunk$33 && (previousBlockedChunk = null);\n+          resolveModelChunk(response, chunk$33, json, -1);\n         });\n       }\n     },\n@@ -2733,9 +2955,9 @@ function parseAsyncIterable(response, reference, iterator) {\n   var buffer = [],\n     closed = !1,\n     nextWriteIndex = 0,\n-    $jscomp$compprop2 = {};\n-  $jscomp$compprop2 =\n-    (($jscomp$compprop2[ASYNC_ITERATOR] = function () {\n+    $jscomp$compprop5 = {};\n+  $jscomp$compprop5 =\n+    (($jscomp$compprop5[ASYNC_ITERATOR] = function () {\n       var nextReadIndex = 0;\n       return createIterator(function (arg) {\n         if (void 0 !== arg)\n@@ -2744,19 +2966,18 @@ function parseAsyncIterable(response, reference, iterator) {\n           );\n         if (nextReadIndex === buffer.length) {\n           if (closed)\n-            return new Chunk(\n+            return new ReactPromise(\n               \"fulfilled\",\n               { done: !0, value: void 0 },\n-              null,\n-              response\n+              null\n             );\n-          buffer[nextReadIndex] = createPendingChunk(response);\n+          buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n         }\n         return buffer[nextReadIndex++];\n       });\n     }),\n-    $jscomp$compprop2);\n-  iterator = iterator ? $jscomp$compprop2[ASYNC_ITERATOR]() : $jscomp$compprop2;\n+    $jscomp$compprop5);\n+  iterator = iterator ? $jscomp$compprop5[ASYNC_ITERATOR]() : $jscomp$compprop5;\n   resolveStream(response, reference, iterator, {\n     enqueueModel: function (value) {\n       nextWriteIndex === buffer.length\n@@ -2765,7 +2986,12 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !1\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !1\n+          );\n       nextWriteIndex++;\n     },\n     close: function (value) {\n@@ -2776,9 +3002,15 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !0\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !0\n+          );\n       for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n         resolveIteratorResultChunk(\n+          response,\n           buffer[nextWriteIndex++],\n           '\"$undefined\"',\n           !0\n@@ -2788,11 +3020,11 @@ function parseAsyncIterable(response, reference, iterator) {\n       closed = !0;\n       for (\n         nextWriteIndex === buffer.length &&\n-        (buffer[nextWriteIndex] = createPendingChunk(response));\n+        (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n         nextWriteIndex < buffer.length;\n \n       )\n-        triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+        triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n     }\n   });\n   return iterator;\n@@ -2807,15 +3039,7 @@ function parseModelString(response, obj, key, value, reference) {\n       case \"F\":\n         return (\n           (value = value.slice(2)),\n-          (value = getOutlinedModel(response, value, obj, key, createModel)),\n-          loadServerReference$1(\n-            response,\n-            value.id,\n-            value.bound,\n-            initializingChunk,\n-            obj,\n-            key\n-          )\n+          getOutlinedModel(response, value, obj, key, loadServerReference$1)\n         );\n       case \"T\":\n         if (void 0 === reference || void 0 === response._temporaryReferences)\n@@ -3030,7 +3254,8 @@ exports.decodeReplyFromAsyncIterable = function (\n         if (name.startsWith(prefix)) {\n           var chunks = response._chunks;\n           name = +name.slice(prefix.length);\n-          (chunks = chunks.get(name)) && resolveModelChunk(chunks, entry, name);\n+          (chunks = chunks.get(name)) &&\n+            resolveModelChunk(response, chunks, entry, name);\n         }\n       } else response._formData.append(name, entry);\n       iterator.next().then(progress, error);"
        },
        {
            "sha": "3f1590f481028b677ca7336fafaebd7720f8ad51",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-server.node.development.js",
            "status": "modified",
            "additions": 475,
            "deletions": 228,
            "changes": 703,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.node.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -4465,37 +4465,65 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n-    }\n-    function Chunk(status, value, reason, response) {\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n+    }\n+    function ReactPromise(status, value, reason) {\n       this.status = status;\n       this.value = value;\n       this.reason = reason;\n-      this._response = response;\n     }\n-    function createPendingChunk(response) {\n-      return new Chunk(\"pending\", null, null, response);\n+    function wakeChunk(response, listeners, value) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n     }\n-    function wakeChunk(listeners, value) {\n-      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+    function rejectChunk(response, listeners, error) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(error)\n+          : rejectReference(response, listener.handler, error);\n+      }\n     }\n-    function triggerErrorOnChunk(chunk, error) {\n+    function resolveBlockedCycle(resolvedChunk, reference) {\n+      var referencedChunk = reference.handler.chunk;\n+      if (null === referencedChunk) return null;\n+      if (referencedChunk === resolvedChunk) return reference.handler;\n+      reference = referencedChunk.value;\n+      if (null !== reference)\n+        for (\n+          referencedChunk = 0;\n+          referencedChunk < reference.length;\n+          referencedChunk++\n+        ) {\n+          var listener = reference[referencedChunk];\n+          if (\n+            \"function\" !== typeof listener &&\n+            ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+            null !== listener)\n+          )\n+            return listener;\n+        }\n+      return null;\n+    }\n+    function triggerErrorOnChunk(response, chunk, error) {\n       if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n         chunk.reason.error(error);\n       else {\n         var listeners = chunk.reason;\n         chunk.status = \"rejected\";\n         chunk.reason = error;\n-        null !== listeners && wakeChunk(listeners, error);\n+        null !== listeners && rejectChunk(response, listeners, error);\n       }\n     }\n-    function resolveModelChunk(chunk, value, id) {\n+    function resolveModelChunk(response, chunk, value, id) {\n       if (\"pending\" !== chunk.status)\n         (chunk = chunk.reason),\n           \"C\" === value[0]\n@@ -4506,81 +4534,142 @@\n           rejectListeners = chunk.reason;\n         chunk.status = \"resolved_model\";\n         chunk.value = value;\n-        chunk.reason = id;\n+        chunk.reason = _defineProperty({ id: id }, RESPONSE_SYMBOL, response);\n         if (null !== resolveListeners)\n-          switch ((initializeModelChunk(chunk), chunk.status)) {\n+          a: switch ((initializeModelChunk(chunk), chunk.status)) {\n             case \"fulfilled\":\n-              wakeChunk(resolveListeners, chunk.value);\n+              wakeChunk(response, resolveListeners, chunk.value);\n               break;\n-            case \"pending\":\n             case \"blocked\":\n-            case \"cyclic\":\n+              for (value = 0; value < resolveListeners.length; value++)\n+                if (\n+                  ((id = resolveListeners[value]), \"function\" !== typeof id)\n+                ) {\n+                  var cyclicHandler = resolveBlockedCycle(chunk, id);\n+                  if (null !== cyclicHandler)\n+                    switch (\n+                      (fulfillReference(response, id, cyclicHandler.value),\n+                      resolveListeners.splice(value, 1),\n+                      value--,\n+                      null !== rejectListeners &&\n+                        ((id = rejectListeners.indexOf(id)),\n+                        -1 !== id && rejectListeners.splice(id, 1)),\n+                      chunk.status)\n+                    ) {\n+                      case \"fulfilled\":\n+                        wakeChunk(response, resolveListeners, chunk.value);\n+                        break a;\n+                      case \"rejected\":\n+                        null !== rejectListeners &&\n+                          rejectChunk(response, rejectListeners, chunk.reason);\n+                        break a;\n+                    }\n+                }\n+            case \"pending\":\n               if (chunk.value)\n-                for (value = 0; value < resolveListeners.length; value++)\n-                  chunk.value.push(resolveListeners[value]);\n+                for (\n+                  response = 0;\n+                  response < resolveListeners.length;\n+                  response++\n+                )\n+                  chunk.value.push(resolveListeners[response]);\n               else chunk.value = resolveListeners;\n               if (chunk.reason) {\n                 if (rejectListeners)\n-                  for (value = 0; value < rejectListeners.length; value++)\n-                    chunk.reason.push(rejectListeners[value]);\n+                  for (\n+                    resolveListeners = 0;\n+                    resolveListeners < rejectListeners.length;\n+                    resolveListeners++\n+                  )\n+                    chunk.reason.push(rejectListeners[resolveListeners]);\n               } else chunk.reason = rejectListeners;\n               break;\n             case \"rejected\":\n-              rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+              rejectListeners &&\n+                wakeChunk(response, rejectListeners, chunk.reason);\n           }\n       }\n     }\n     function createResolvedIteratorResultChunk(response, value, done) {\n-      return new Chunk(\n+      return new ReactPromise(\n         \"resolved_model\",\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n-        -1,\n-        response\n+        _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n       );\n     }\n-    function resolveIteratorResultChunk(chunk, value, done) {\n+    function resolveIteratorResultChunk(response, chunk, value, done) {\n       resolveModelChunk(\n+        response,\n         chunk,\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n         -1\n       );\n     }\n-    function loadServerReference$1(\n-      response,\n-      id,\n-      bound,\n-      parentChunk,\n-      parentObject,\n-      key\n-    ) {\n+    function loadServerReference$1(response, metaData, parentObject, key) {\n+      var id = metaData.id;\n+      if (\"string\" !== typeof id) return null;\n       var serverReference = resolveServerReference(response._bundlerConfig, id);\n-      id = preloadModule(serverReference);\n-      if (bound)\n-        bound = Promise.all([bound, id]).then(function (_ref) {\n-          _ref = _ref[0];\n-          var fn = requireModule(serverReference);\n-          return fn.bind.apply(fn, [null].concat(_ref));\n-        });\n-      else if (id)\n-        bound = Promise.resolve(id).then(function () {\n-          return requireModule(serverReference);\n-        });\n+      id = metaData.bound;\n+      var promise = preloadModule(serverReference);\n+      if (promise)\n+        id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+      else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n       else return requireModule(serverReference);\n-      bound.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(parentChunk)\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n+      promise.then(\n+        function () {\n+          var resolvedValue = requireModule(serverReference);\n+          if (metaData.bound) {\n+            var promiseValue = metaData.bound.value;\n+            promiseValue = Array.isArray(promiseValue)\n+              ? promiseValue.slice(0)\n+              : [];\n+            promiseValue.unshift(null);\n+            resolvedValue = resolvedValue.bind.apply(\n+              resolvedValue,\n+              promiseValue\n+            );\n+          }\n+          parentObject[key] = resolvedValue;\n+          \"\" === key &&\n+            null === handler.value &&\n+            (handler.value = resolvedValue);\n+          handler.deps--;\n+          0 === handler.deps &&\n+            ((resolvedValue = handler.chunk),\n+            null !== resolvedValue &&\n+              \"blocked\" === resolvedValue.status &&\n+              ((promiseValue = resolvedValue.value),\n+              (resolvedValue.status = \"fulfilled\"),\n+              (resolvedValue.value = handler.value),\n+              null !== promiseValue &&\n+                wakeChunk(response, promiseValue, handler.value)));\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n@@ -4622,53 +4711,66 @@\n                 value[i],\n                 parentObj\n               )),\n-              void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+              void 0 !== parentObj || \"__proto__\" === i\n+                ? (value[i] = parentObj)\n+                : delete value[i]);\n       return value;\n     }\n     function initializeModelChunk(chunk) {\n-      var prevChunk = initializingChunk,\n-        prevBlocked = initializingChunkBlockedModel;\n-      initializingChunk = chunk;\n-      initializingChunkBlockedModel = null;\n-      var rootReference =\n-          -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-        resolvedModel = chunk.value;\n-      chunk.status = \"cyclic\";\n+      var prevHandler = initializingHandler;\n+      initializingHandler = null;\n+      var _chunk$reason = chunk.reason,\n+        response = _chunk$reason[RESPONSE_SYMBOL];\n+      _chunk$reason = _chunk$reason.id;\n+      _chunk$reason =\n+        -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+      var resolvedModel = chunk.value;\n+      chunk.status = \"blocked\";\n       chunk.value = null;\n       chunk.reason = null;\n       try {\n         var rawModel = JSON.parse(resolvedModel),\n           value = reviveModel(\n-            chunk._response,\n+            response,\n             { \"\": rawModel },\n             \"\",\n             rawModel,\n-            rootReference\n-          );\n-        if (\n-          null !== initializingChunkBlockedModel &&\n-          0 < initializingChunkBlockedModel.deps\n-        )\n-          (initializingChunkBlockedModel.value = value),\n-            (chunk.status = \"blocked\");\n-        else {\n-          var resolveListeners = chunk.value;\n-          chunk.status = \"fulfilled\";\n-          chunk.value = value;\n-          null !== resolveListeners && wakeChunk(resolveListeners, value);\n+            _chunk$reason\n+          ),\n+          resolveListeners = chunk.value;\n+        if (null !== resolveListeners)\n+          for (\n+            chunk.value = null, chunk.reason = null, rawModel = 0;\n+            rawModel < resolveListeners.length;\n+            rawModel++\n+          ) {\n+            var listener = resolveListeners[rawModel];\n+            \"function\" === typeof listener\n+              ? listener(value)\n+              : fulfillReference(response, listener, value);\n+          }\n+        if (null !== initializingHandler) {\n+          if (initializingHandler.errored) throw initializingHandler.reason;\n+          if (0 < initializingHandler.deps) {\n+            initializingHandler.value = value;\n+            initializingHandler.chunk = chunk;\n+            return;\n+          }\n         }\n+        chunk.status = \"fulfilled\";\n+        chunk.value = value;\n       } catch (error) {\n         (chunk.status = \"rejected\"), (chunk.reason = error);\n       } finally {\n-        (initializingChunk = prevChunk),\n-          (initializingChunkBlockedModel = prevBlocked);\n+        initializingHandler = prevHandler;\n       }\n     }\n     function reportGlobalError(response, error) {\n       response._closed = !0;\n       response._closedReason = error;\n       response._chunks.forEach(function (chunk) {\n-        \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+        \"pending\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n       });\n     }\n     function getChunk(response, id) {\n@@ -4677,50 +4779,108 @@\n       chunk ||\n         ((chunk = response._formData.get(response._prefix + id)),\n         (chunk =\n-          null != chunk\n-            ? new Chunk(\"resolved_model\", chunk, id, response)\n+          \"string\" === typeof chunk\n+            ? new ReactPromise(\n+                \"resolved_model\",\n+                chunk,\n+                _defineProperty({ id: id }, RESPONSE_SYMBOL, response)\n+              )\n             : response._closed\n-              ? new Chunk(\"rejected\", null, response._closedReason, response)\n-              : createPendingChunk(response)),\n+              ? new ReactPromise(\"rejected\", null, response._closedReason)\n+              : new ReactPromise(\"pending\", null, null)),\n         chunks.set(id, chunk));\n       return chunk;\n     }\n-    function createModelResolver(\n-      chunk,\n+    function fulfillReference(response, reference, value) {\n+      for (\n+        var handler = reference.handler,\n+          parentObject = reference.parentObject,\n+          key = reference.key,\n+          map = reference.map,\n+          path = reference.path,\n+          i = 1;\n+        i < path.length;\n+        i++\n+      ) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              continue;\n+            case \"blocked\":\n+            case \"pending\":\n+              path.splice(0, i - 1);\n+              null === value.value\n+                ? (value.value = [reference])\n+                : value.value.push(reference);\n+              null === value.reason\n+                ? (value.reason = [reference])\n+                : value.reason.push(reference);\n+              return;\n+            default:\n+              rejectReference(response, reference.handler, value.reason);\n+              return;\n+          }\n+        }\n+        var name = path[i];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      reference = map(response, value, parentObject, key);\n+      parentObject[key] = reference;\n+      \"\" === key && null === handler.value && (handler.value = reference);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((parentObject = handler.chunk),\n+        null !== parentObject &&\n+          \"blocked\" === parentObject.status &&\n+          ((key = parentObject.value),\n+          (parentObject.status = \"fulfilled\"),\n+          (parentObject.value = handler.value),\n+          (parentObject.reason = handler.reason),\n+          null !== key && wakeChunk(response, key, handler.value)));\n+    }\n+    function rejectReference(response, handler, error) {\n+      handler.errored ||\n+        ((handler.errored = !0),\n+        (handler.value = null),\n+        (handler.reason = error),\n+        (handler = handler.chunk),\n+        null !== handler &&\n+          \"blocked\" === handler.status &&\n+          triggerErrorOnChunk(response, handler, error));\n+    }\n+    function waitForReference(\n+      referencedChunk,\n       parentObject,\n       key,\n-      cyclic,\n       response,\n       map,\n       path\n     ) {\n-      if (initializingChunkBlockedModel) {\n-        var blocked = initializingChunkBlockedModel;\n-        cyclic || blocked.deps++;\n-      } else\n-        blocked = initializingChunkBlockedModel = {\n-          deps: cyclic ? 0 : 1,\n-          value: null\n-        };\n-      return function (value) {\n-        for (var i = 1; i < path.length; i++) value = value[path[i]];\n-        parentObject[key] = map(response, value);\n-        \"\" === key &&\n-          null === blocked.value &&\n-          (blocked.value = parentObject[key]);\n-        blocked.deps--;\n-        0 === blocked.deps &&\n-          \"blocked\" === chunk.status &&\n-          ((value = chunk.value),\n-          (chunk.status = \"fulfilled\"),\n-          (chunk.value = blocked.value),\n-          null !== value && wakeChunk(value, blocked.value));\n-      };\n-    }\n-    function createModelReject(chunk) {\n-      return function (error) {\n-        return triggerErrorOnChunk(chunk, error);\n+      initializingHandler\n+        ? ((response = initializingHandler), response.deps++)\n+        : (response = initializingHandler =\n+            { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+      parentObject = {\n+        handler: response,\n+        parentObject: parentObject,\n+        key: key,\n+        map: map,\n+        path: path\n       };\n+      null === referencedChunk.value\n+        ? (referencedChunk.value = [parentObject])\n+        : referencedChunk.value.push(parentObject);\n+      null === referencedChunk.reason\n+        ? (referencedChunk.reason = [parentObject])\n+        : referencedChunk.reason.push(parentObject);\n+      return null;\n     }\n     function getOutlinedModel(response, reference, parentObject, key, map) {\n       reference = reference.split(\":\");\n@@ -4732,29 +4892,75 @@\n       }\n       switch (id.status) {\n         case \"fulfilled\":\n-          parentObject = id.value;\n-          for (key = 1; key < reference.length; key++)\n-            parentObject = parentObject[reference[key]];\n-          return map(response, parentObject);\n+          var value = id.value;\n+          for (id = 1; id < reference.length; id++) {\n+            for (; value instanceof ReactPromise; ) {\n+              switch (value.status) {\n+                case \"resolved_model\":\n+                  initializeModelChunk(value);\n+              }\n+              switch (value.status) {\n+                case \"fulfilled\":\n+                  value = value.value;\n+                  break;\n+                case \"blocked\":\n+                case \"pending\":\n+                  return waitForReference(\n+                    value,\n+                    parentObject,\n+                    key,\n+                    response,\n+                    map,\n+                    reference.slice(id - 1)\n+                  );\n+                default:\n+                  return (\n+                    initializingHandler\n+                      ? ((initializingHandler.errored = !0),\n+                        (initializingHandler.value = null),\n+                        (initializingHandler.reason = value.reason))\n+                      : (initializingHandler = {\n+                          chunk: null,\n+                          value: null,\n+                          reason: value.reason,\n+                          deps: 0,\n+                          errored: !0\n+                        }),\n+                    null\n+                  );\n+              }\n+            }\n+            var name = reference[id];\n+            \"object\" === typeof value &&\n+              hasOwnProperty.call(value, name) &&\n+              (value = value[name]);\n+          }\n+          return map(response, value, parentObject, key);\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          var parentChunk = initializingChunk;\n-          id.then(\n-            createModelResolver(\n-              parentChunk,\n-              parentObject,\n-              key,\n-              \"cyclic\" === id.status,\n-              response,\n-              map,\n-              reference\n-            ),\n-            createModelReject(parentChunk)\n+          return waitForReference(\n+            id,\n+            parentObject,\n+            key,\n+            response,\n+            map,\n+            reference\n           );\n-          return null;\n         default:\n-          throw id.reason;\n+          return (\n+            initializingHandler\n+              ? ((initializingHandler.errored = !0),\n+                (initializingHandler.value = null),\n+                (initializingHandler.reason = id.reason))\n+              : (initializingHandler = {\n+                  chunk: null,\n+                  value: null,\n+                  reason: id.reason,\n+                  deps: 0,\n+                  errored: !0\n+                }),\n+            null\n+          );\n       }\n     }\n     function createMap(response, model) {\n@@ -4778,40 +4984,68 @@\n       parentKey\n     ) {\n       reference = parseInt(reference.slice(2), 16);\n-      reference = response._formData.get(response._prefix + reference);\n-      reference =\n-        constructor === ArrayBuffer\n-          ? reference.arrayBuffer()\n-          : reference.arrayBuffer().then(function (buffer) {\n-              return new constructor(buffer);\n-            });\n-      bytesPerElement = initializingChunk;\n+      reference = response._formData\n+        .get(response._prefix + reference)\n+        .arrayBuffer();\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n       reference.then(\n-        createModelResolver(\n-          bytesPerElement,\n-          parentObject,\n-          parentKey,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(bytesPerElement)\n+        function (buffer) {\n+          buffer =\n+            constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+          parentObject[parentKey] = buffer;\n+          \"\" === parentKey &&\n+            null === handler.value &&\n+            (handler.value = buffer);\n+          handler.deps--;\n+          if (\n+            0 === handler.deps &&\n+            ((buffer = handler.chunk),\n+            null !== buffer && \"blocked\" === buffer.status)\n+          ) {\n+            var resolveListeners = buffer.value;\n+            buffer.status = \"fulfilled\";\n+            buffer.value = handler.value;\n+            null !== resolveListeners &&\n+              wakeChunk(response, resolveListeners, handler.value);\n+          }\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n     function resolveStream(response, id, stream, controller) {\n       var chunks = response._chunks;\n-      stream = new Chunk(\"fulfilled\", stream, controller, response);\n+      stream = new ReactPromise(\"fulfilled\", stream, controller);\n       chunks.set(id, stream);\n       response = response._formData.getAll(response._prefix + id);\n       for (id = 0; id < response.length; id++)\n         (chunks = response[id]),\n-          \"C\" === chunks[0]\n-            ? controller.close(\n-                \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n-              )\n-            : controller.enqueueModel(chunks);\n+          \"string\" === typeof chunks &&\n+            (\"C\" === chunks[0]\n+              ? controller.close(\n+                  \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n+                )\n+              : controller.enqueueModel(chunks));\n     }\n     function parseReadableStream(response, reference, type) {\n       reference = parseInt(reference.slice(2), 16);\n@@ -4826,7 +5060,11 @@\n       resolveStream(response, reference, type, {\n         enqueueModel: function (json) {\n           if (null === previousBlockedChunk) {\n-            var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+            var chunk = new ReactPromise(\n+              \"resolved_model\",\n+              json,\n+              _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n+            );\n             initializeModelChunk(chunk);\n             \"fulfilled\" === chunk.status\n               ? controller.enqueue(chunk.value)\n@@ -4841,7 +5079,7 @@\n                 (previousBlockedChunk = chunk));\n           } else {\n             chunk = previousBlockedChunk;\n-            var _chunk = createPendingChunk(response);\n+            var _chunk = new ReactPromise(\"pending\", null, null);\n             _chunk.then(\n               function (v) {\n                 return controller.enqueue(v);\n@@ -4853,7 +5091,7 @@\n             previousBlockedChunk = _chunk;\n             chunk.then(function () {\n               previousBlockedChunk === _chunk && (previousBlockedChunk = null);\n-              resolveModelChunk(_chunk, json, -1);\n+              resolveModelChunk(response, _chunk, json, -1);\n             });\n           }\n         },\n@@ -4902,13 +5140,12 @@\n               );\n             if (nextReadIndex === buffer.length) {\n               if (closed)\n-                return new Chunk(\n+                return new ReactPromise(\n                   \"fulfilled\",\n                   { done: !0, value: void 0 },\n-                  null,\n-                  response\n+                  null\n                 );\n-              buffer[nextReadIndex] = createPendingChunk(response);\n+              buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n             }\n             return buffer[nextReadIndex++];\n           });\n@@ -4922,7 +5159,12 @@\n                 value,\n                 !1\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !1\n+              );\n           nextWriteIndex++;\n         },\n         close: function (value) {\n@@ -4933,9 +5175,15 @@\n                 value,\n                 !0\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !0\n+              );\n           for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n             resolveIteratorResultChunk(\n+              response,\n               buffer[nextWriteIndex++],\n               '\"$undefined\"',\n               !0\n@@ -4945,11 +5193,11 @@\n           closed = !0;\n           for (\n             nextWriteIndex === buffer.length &&\n-            (buffer[nextWriteIndex] = createPendingChunk(response));\n+            (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n             nextWriteIndex < buffer.length;\n \n           )\n-            triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n         }\n       });\n       return iterator;\n@@ -4966,21 +5214,7 @@\n           case \"F\":\n             return (\n               (value = value.slice(2)),\n-              (value = getOutlinedModel(\n-                response,\n-                value,\n-                obj,\n-                key,\n-                createModel\n-              )),\n-              loadServerReference$1(\n-                response,\n-                value.id,\n-                value.bound,\n-                initializingChunk,\n-                obj,\n-                key\n-              )\n+              getOutlinedModel(response, value, obj, key, loadServerReference$1)\n             );\n           case \"T\":\n             if (\n@@ -5116,10 +5350,12 @@\n     function resolveField(response, key, value) {\n       response._formData.append(key, value);\n       var prefix = response._prefix;\n-      key.startsWith(prefix) &&\n-        ((response = response._chunks),\n-        (key = +key.slice(prefix.length)),\n-        (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));\n+      if (key.startsWith(prefix)) {\n+        var chunks = response._chunks;\n+        key = +key.slice(prefix.length);\n+        (chunks = chunks.get(key)) &&\n+          resolveModelChunk(response, chunks, value, key);\n+      }\n     }\n     function close(response) {\n       reportGlobalError(response, Error(\"Connection closed.\"));\n@@ -5887,33 +6123,32 @@\n       emptyRoot = {},\n       decoderOptions = { stream: !0 },\n       instrumentedChunks = new WeakSet(),\n-      loadedChunks = new WeakSet();\n-    Chunk.prototype = Object.create(Promise.prototype);\n-    Chunk.prototype.then = function (resolve, reject) {\n+      loadedChunks = new WeakSet(),\n+      RESPONSE_SYMBOL = Symbol();\n+    ReactPromise.prototype = Object.create(Promise.prototype);\n+    ReactPromise.prototype.then = function (resolve, reject) {\n       switch (this.status) {\n         case \"resolved_model\":\n           initializeModelChunk(this);\n       }\n       switch (this.status) {\n         case \"fulfilled\":\n-          resolve(this.value);\n+          \"function\" === typeof resolve && resolve(this.value);\n           break;\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          resolve &&\n+          \"function\" === typeof resolve &&\n             (null === this.value && (this.value = []),\n             this.value.push(resolve));\n-          reject &&\n+          \"function\" === typeof reject &&\n             (null === this.reason && (this.reason = []),\n             this.reason.push(reject));\n           break;\n         default:\n-          reject(this.reason);\n+          \"function\" === typeof reject && reject(this.reason);\n       }\n     };\n-    var initializingChunk = null,\n-      initializingChunkBlockedModel = null;\n+    var initializingHandler = null;\n     exports.createClientModuleProxy = function (moduleId) {\n       moduleId = registerClientReferenceImpl({}, moduleId, !1);\n       return new Proxy(moduleId, proxyHandlers$1);\n@@ -6022,38 +6257,50 @@\n         pendingFiles = 0,\n         queuedFields = [];\n       busboyStream.on(\"field\", function (name, value) {\n-        0 < pendingFiles\n-          ? queuedFields.push(name, value)\n-          : resolveField(response, name, value);\n+        if (0 < pendingFiles) queuedFields.push(name, value);\n+        else\n+          try {\n+            resolveField(response, name, value);\n+          } catch (error) {\n+            busboyStream.destroy(error);\n+          }\n       });\n       busboyStream.on(\"file\", function (name, value, _ref2) {\n         var filename = _ref2.filename,\n           mimeType = _ref2.mimeType;\n         if (\"base64\" === _ref2.encoding.toLowerCase())\n-          throw Error(\n-            \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+          busboyStream.destroy(\n+            Error(\n+              \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+            )\n           );\n-        pendingFiles++;\n-        var JSCompiler_object_inline_chunks_273 = [];\n-        value.on(\"data\", function (chunk) {\n-          JSCompiler_object_inline_chunks_273.push(chunk);\n-        });\n-        value.on(\"end\", function () {\n-          var blob = new Blob(JSCompiler_object_inline_chunks_273, {\n-            type: mimeType\n+        else {\n+          pendingFiles++;\n+          var JSCompiler_object_inline_chunks_276 = [];\n+          value.on(\"data\", function (chunk) {\n+            JSCompiler_object_inline_chunks_276.push(chunk);\n           });\n-          response._formData.append(name, blob, filename);\n-          pendingFiles--;\n-          if (0 === pendingFiles) {\n-            for (blob = 0; blob < queuedFields.length; blob += 2)\n-              resolveField(\n-                response,\n-                queuedFields[blob],\n-                queuedFields[blob + 1]\n-              );\n-            queuedFields.length = 0;\n-          }\n-        });\n+          value.on(\"end\", function () {\n+            try {\n+              var blob = new Blob(JSCompiler_object_inline_chunks_276, {\n+                type: mimeType\n+              });\n+              response._formData.append(name, blob, filename);\n+              pendingFiles--;\n+              if (0 === pendingFiles) {\n+                for (blob = 0; blob < queuedFields.length; blob += 2)\n+                  resolveField(\n+                    response,\n+                    queuedFields[blob],\n+                    queuedFields[blob + 1]\n+                  );\n+                queuedFields.length = 0;\n+              }\n+            } catch (error) {\n+              busboyStream.destroy(error);\n+            }\n+          });\n+        }\n       });\n       busboyStream.on(\"finish\", function () {\n         close(response);"
        },
        {
            "sha": "448bf32165c3ee060d26f09b504dd21622b0a6db",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-server.node.production.js",
            "status": "modified",
            "additions": 469,
            "deletions": 227,
            "changes": 696,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.node.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -1002,8 +1002,8 @@ function serializeReadableStream(request, task, stream) {\n               : tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             reader.read().then(progress, error);\n-        } catch (x$8) {\n-          error(x$8);\n+        } catch (x$11) {\n+          error(x$11);\n         }\n   }\n   function error(reason) {\n@@ -1088,8 +1088,8 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n             tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             iterator.next().then(progress, error);\n-        } catch (x$9) {\n-          error(x$9);\n+        } catch (x$12) {\n+          error(x$12);\n         }\n   }\n   function error(reason) {\n@@ -2263,9 +2263,9 @@ function abort(request, reason) {\n         onAllReady();\n         flushCompletedChunks(request);\n       }\n-    } catch (error$26) {\n-      logRecoverableError(request, error$26, null),\n-        fatalError(request, error$26);\n+    } catch (error$29) {\n+      logRecoverableError(request, error$29, null),\n+        fatalError(request, error$29);\n     }\n }\n function resolveServerReference(bundlerConfig, id) {\n@@ -2333,59 +2333,97 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n-}\n-function Chunk(status, value, reason, response) {\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n+}\n+var RESPONSE_SYMBOL = Symbol();\n+function ReactPromise(status, value, reason) {\n   this.status = status;\n   this.value = value;\n   this.reason = reason;\n-  this._response = response;\n }\n-Chunk.prototype = Object.create(Promise.prototype);\n-Chunk.prototype.then = function (resolve, reject) {\n+ReactPromise.prototype = Object.create(Promise.prototype);\n+ReactPromise.prototype.then = function (resolve, reject) {\n   switch (this.status) {\n     case \"resolved_model\":\n       initializeModelChunk(this);\n   }\n   switch (this.status) {\n     case \"fulfilled\":\n-      resolve(this.value);\n+      \"function\" === typeof resolve && resolve(this.value);\n       break;\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      resolve &&\n+      \"function\" === typeof resolve &&\n         (null === this.value && (this.value = []), this.value.push(resolve));\n-      reject &&\n+      \"function\" === typeof reject &&\n         (null === this.reason && (this.reason = []), this.reason.push(reject));\n       break;\n     default:\n-      reject(this.reason);\n+      \"function\" === typeof reject && reject(this.reason);\n   }\n };\n-function createPendingChunk(response) {\n-  return new Chunk(\"pending\", null, null, response);\n+function wakeChunk(response, listeners, value) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(value)\n+      : fulfillReference(response, listener, value);\n+  }\n }\n-function wakeChunk(listeners, value) {\n-  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+function rejectChunk(response, listeners, error) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(error)\n+      : rejectReference(response, listener.handler, error);\n+  }\n }\n-function triggerErrorOnChunk(chunk, error) {\n+function resolveBlockedCycle(resolvedChunk, reference) {\n+  var referencedChunk = reference.handler.chunk;\n+  if (null === referencedChunk) return null;\n+  if (referencedChunk === resolvedChunk) return reference.handler;\n+  reference = referencedChunk.value;\n+  if (null !== reference)\n+    for (\n+      referencedChunk = 0;\n+      referencedChunk < reference.length;\n+      referencedChunk++\n+    ) {\n+      var listener = reference[referencedChunk];\n+      if (\n+        \"function\" !== typeof listener &&\n+        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+        null !== listener)\n+      )\n+        return listener;\n+    }\n+  return null;\n+}\n+function triggerErrorOnChunk(response, chunk, error) {\n   if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n     chunk.reason.error(error);\n   else {\n     var listeners = chunk.reason;\n     chunk.status = \"rejected\";\n     chunk.reason = error;\n-    null !== listeners && wakeChunk(listeners, error);\n+    null !== listeners && rejectChunk(response, listeners, error);\n   }\n }\n-function resolveModelChunk(chunk, value, id) {\n+function createResolvedModelChunk(response, value, id) {\n+  var $jscomp$compprop2 = {};\n+  return new ReactPromise(\n+    \"resolved_model\",\n+    value,\n+    (($jscomp$compprop2.id = id),\n+    ($jscomp$compprop2[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop2)\n+  );\n+}\n+function resolveModelChunk(response, chunk, value, id) {\n   if (\"pending\" !== chunk.status)\n     (chunk = chunk.reason),\n       \"C\" === value[0]\n@@ -2396,77 +2434,129 @@ function resolveModelChunk(chunk, value, id) {\n       rejectListeners = chunk.reason;\n     chunk.status = \"resolved_model\";\n     chunk.value = value;\n-    chunk.reason = id;\n+    value = {};\n+    chunk.reason =\n+      ((value.id = id), (value[RESPONSE_SYMBOL] = response), value);\n     if (null !== resolveListeners)\n-      switch ((initializeModelChunk(chunk), chunk.status)) {\n+      a: switch ((initializeModelChunk(chunk), chunk.status)) {\n         case \"fulfilled\":\n-          wakeChunk(resolveListeners, chunk.value);\n+          wakeChunk(response, resolveListeners, chunk.value);\n           break;\n-        case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n+          for (value = 0; value < resolveListeners.length; value++)\n+            if (((id = resolveListeners[value]), \"function\" !== typeof id)) {\n+              var cyclicHandler = resolveBlockedCycle(chunk, id);\n+              if (null !== cyclicHandler)\n+                switch (\n+                  (fulfillReference(response, id, cyclicHandler.value),\n+                  resolveListeners.splice(value, 1),\n+                  value--,\n+                  null !== rejectListeners &&\n+                    ((id = rejectListeners.indexOf(id)),\n+                    -1 !== id && rejectListeners.splice(id, 1)),\n+                  chunk.status)\n+                ) {\n+                  case \"fulfilled\":\n+                    wakeChunk(response, resolveListeners, chunk.value);\n+                    break a;\n+                  case \"rejected\":\n+                    null !== rejectListeners &&\n+                      rejectChunk(response, rejectListeners, chunk.reason);\n+                    break a;\n+                }\n+            }\n+        case \"pending\":\n           if (chunk.value)\n-            for (value = 0; value < resolveListeners.length; value++)\n-              chunk.value.push(resolveListeners[value]);\n+            for (response = 0; response < resolveListeners.length; response++)\n+              chunk.value.push(resolveListeners[response]);\n           else chunk.value = resolveListeners;\n           if (chunk.reason) {\n             if (rejectListeners)\n-              for (value = 0; value < rejectListeners.length; value++)\n-                chunk.reason.push(rejectListeners[value]);\n+              for (\n+                resolveListeners = 0;\n+                resolveListeners < rejectListeners.length;\n+                resolveListeners++\n+              )\n+                chunk.reason.push(rejectListeners[resolveListeners]);\n           } else chunk.reason = rejectListeners;\n           break;\n         case \"rejected\":\n-          rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+          rejectListeners && wakeChunk(response, rejectListeners, chunk.reason);\n       }\n   }\n }\n function createResolvedIteratorResultChunk(response, value, done) {\n-  return new Chunk(\n+  var $jscomp$compprop4 = {};\n+  return new ReactPromise(\n     \"resolved_model\",\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n-    -1,\n-    response\n+    (($jscomp$compprop4.id = -1),\n+    ($jscomp$compprop4[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop4)\n   );\n }\n-function resolveIteratorResultChunk(chunk, value, done) {\n+function resolveIteratorResultChunk(response, chunk, value, done) {\n   resolveModelChunk(\n+    response,\n     chunk,\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n     -1\n   );\n }\n-function loadServerReference$1(\n-  response,\n-  id,\n-  bound,\n-  parentChunk,\n-  parentObject,\n-  key\n-) {\n+function loadServerReference$1(response, metaData, parentObject, key) {\n+  var id = metaData.id;\n+  if (\"string\" !== typeof id) return null;\n   var serverReference = resolveServerReference(response._bundlerConfig, id);\n-  id = preloadModule(serverReference);\n-  if (bound)\n-    bound = Promise.all([bound, id]).then(function (_ref) {\n-      _ref = _ref[0];\n-      var fn = requireModule(serverReference);\n-      return fn.bind.apply(fn, [null].concat(_ref));\n-    });\n-  else if (id)\n-    bound = Promise.resolve(id).then(function () {\n-      return requireModule(serverReference);\n-    });\n+  id = metaData.bound;\n+  var promise = preloadModule(serverReference);\n+  if (promise)\n+    id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+  else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n   else return requireModule(serverReference);\n-  bound.then(\n-    createModelResolver(\n-      parentChunk,\n-      parentObject,\n-      key,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(parentChunk)\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n+  promise.then(\n+    function () {\n+      var resolvedValue = requireModule(serverReference);\n+      if (metaData.bound) {\n+        var promiseValue = metaData.bound.value;\n+        promiseValue = Array.isArray(promiseValue) ? promiseValue.slice(0) : [];\n+        promiseValue.unshift(null);\n+        resolvedValue = resolvedValue.bind.apply(resolvedValue, promiseValue);\n+      }\n+      parentObject[key] = resolvedValue;\n+      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((resolvedValue = handler.chunk),\n+        null !== resolvedValue &&\n+          \"blocked\" === resolvedValue.status &&\n+          ((promiseValue = resolvedValue.value),\n+          (resolvedValue.status = \"fulfilled\"),\n+          (resolvedValue.value = handler.value),\n+          null !== promiseValue &&\n+            wakeChunk(response, promiseValue, handler.value)));\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n@@ -2496,53 +2586,65 @@ function reviveModel(response, parentObj, parentKey, value, reference) {\n               ? reference + \":\" + i\n               : void 0),\n           (parentObj = reviveModel(response, value, i, value[i], parentObj)),\n-          void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+          void 0 !== parentObj || \"__proto__\" === i\n+            ? (value[i] = parentObj)\n+            : delete value[i]);\n   return value;\n }\n-var initializingChunk = null,\n-  initializingChunkBlockedModel = null;\n+var initializingHandler = null;\n function initializeModelChunk(chunk) {\n-  var prevChunk = initializingChunk,\n-    prevBlocked = initializingChunkBlockedModel;\n-  initializingChunk = chunk;\n-  initializingChunkBlockedModel = null;\n-  var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-    resolvedModel = chunk.value;\n-  chunk.status = \"cyclic\";\n+  var prevHandler = initializingHandler;\n+  initializingHandler = null;\n+  var _chunk$reason = chunk.reason,\n+    response = _chunk$reason[RESPONSE_SYMBOL];\n+  _chunk$reason = _chunk$reason.id;\n+  _chunk$reason = -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+  var resolvedModel = chunk.value;\n+  chunk.status = \"blocked\";\n   chunk.value = null;\n   chunk.reason = null;\n   try {\n     var rawModel = JSON.parse(resolvedModel),\n       value = reviveModel(\n-        chunk._response,\n+        response,\n         { \"\": rawModel },\n         \"\",\n         rawModel,\n-        rootReference\n-      );\n-    if (\n-      null !== initializingChunkBlockedModel &&\n-      0 < initializingChunkBlockedModel.deps\n-    )\n-      (initializingChunkBlockedModel.value = value), (chunk.status = \"blocked\");\n-    else {\n-      var resolveListeners = chunk.value;\n-      chunk.status = \"fulfilled\";\n-      chunk.value = value;\n-      null !== resolveListeners && wakeChunk(resolveListeners, value);\n+        _chunk$reason\n+      ),\n+      resolveListeners = chunk.value;\n+    if (null !== resolveListeners)\n+      for (\n+        chunk.value = null, chunk.reason = null, rawModel = 0;\n+        rawModel < resolveListeners.length;\n+        rawModel++\n+      ) {\n+        var listener = resolveListeners[rawModel];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n+    if (null !== initializingHandler) {\n+      if (initializingHandler.errored) throw initializingHandler.reason;\n+      if (0 < initializingHandler.deps) {\n+        initializingHandler.value = value;\n+        initializingHandler.chunk = chunk;\n+        return;\n+      }\n     }\n+    chunk.status = \"fulfilled\";\n+    chunk.value = value;\n   } catch (error) {\n     (chunk.status = \"rejected\"), (chunk.reason = error);\n   } finally {\n-    (initializingChunk = prevChunk),\n-      (initializingChunkBlockedModel = prevBlocked);\n+    initializingHandler = prevHandler;\n   }\n }\n function reportGlobalError(response, error) {\n   response._closed = !0;\n   response._closedReason = error;\n   response._chunks.forEach(function (chunk) {\n-    \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+    \"pending\" === chunk.status && triggerErrorOnChunk(response, chunk, error);\n   });\n }\n function getChunk(response, id) {\n@@ -2551,48 +2653,104 @@ function getChunk(response, id) {\n   chunk ||\n     ((chunk = response._formData.get(response._prefix + id)),\n     (chunk =\n-      null != chunk\n-        ? new Chunk(\"resolved_model\", chunk, id, response)\n+      \"string\" === typeof chunk\n+        ? createResolvedModelChunk(response, chunk, id)\n         : response._closed\n-          ? new Chunk(\"rejected\", null, response._closedReason, response)\n-          : createPendingChunk(response)),\n+          ? new ReactPromise(\"rejected\", null, response._closedReason)\n+          : new ReactPromise(\"pending\", null, null)),\n     chunks.set(id, chunk));\n   return chunk;\n }\n-function createModelResolver(\n-  chunk,\n+function fulfillReference(response, reference, value) {\n+  for (\n+    var handler = reference.handler,\n+      parentObject = reference.parentObject,\n+      key = reference.key,\n+      map = reference.map,\n+      path = reference.path,\n+      i = 1;\n+    i < path.length;\n+    i++\n+  ) {\n+    for (; value instanceof ReactPromise; ) {\n+      switch (value.status) {\n+        case \"resolved_model\":\n+          initializeModelChunk(value);\n+      }\n+      switch (value.status) {\n+        case \"fulfilled\":\n+          value = value.value;\n+          continue;\n+        case \"blocked\":\n+        case \"pending\":\n+          path.splice(0, i - 1);\n+          null === value.value\n+            ? (value.value = [reference])\n+            : value.value.push(reference);\n+          null === value.reason\n+            ? (value.reason = [reference])\n+            : value.reason.push(reference);\n+          return;\n+        default:\n+          rejectReference(response, reference.handler, value.reason);\n+          return;\n+      }\n+    }\n+    var name = path[i];\n+    \"object\" === typeof value &&\n+      hasOwnProperty.call(value, name) &&\n+      (value = value[name]);\n+  }\n+  reference = map(response, value, parentObject, key);\n+  parentObject[key] = reference;\n+  \"\" === key && null === handler.value && (handler.value = reference);\n+  handler.deps--;\n+  0 === handler.deps &&\n+    ((parentObject = handler.chunk),\n+    null !== parentObject &&\n+      \"blocked\" === parentObject.status &&\n+      ((key = parentObject.value),\n+      (parentObject.status = \"fulfilled\"),\n+      (parentObject.value = handler.value),\n+      (parentObject.reason = handler.reason),\n+      null !== key && wakeChunk(response, key, handler.value)));\n+}\n+function rejectReference(response, handler, error) {\n+  handler.errored ||\n+    ((handler.errored = !0),\n+    (handler.value = null),\n+    (handler.reason = error),\n+    (handler = handler.chunk),\n+    null !== handler &&\n+      \"blocked\" === handler.status &&\n+      triggerErrorOnChunk(response, handler, error));\n+}\n+function waitForReference(\n+  referencedChunk,\n   parentObject,\n   key,\n-  cyclic,\n   response,\n   map,\n   path\n ) {\n-  if (initializingChunkBlockedModel) {\n-    var blocked = initializingChunkBlockedModel;\n-    cyclic || blocked.deps++;\n-  } else\n-    blocked = initializingChunkBlockedModel = {\n-      deps: cyclic ? 0 : 1,\n-      value: null\n-    };\n-  return function (value) {\n-    for (var i = 1; i < path.length; i++) value = value[path[i]];\n-    parentObject[key] = map(response, value);\n-    \"\" === key && null === blocked.value && (blocked.value = parentObject[key]);\n-    blocked.deps--;\n-    0 === blocked.deps &&\n-      \"blocked\" === chunk.status &&\n-      ((value = chunk.value),\n-      (chunk.status = \"fulfilled\"),\n-      (chunk.value = blocked.value),\n-      null !== value && wakeChunk(value, blocked.value));\n-  };\n-}\n-function createModelReject(chunk) {\n-  return function (error) {\n-    return triggerErrorOnChunk(chunk, error);\n+  initializingHandler\n+    ? ((response = initializingHandler), response.deps++)\n+    : (response = initializingHandler =\n+        { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+  parentObject = {\n+    handler: response,\n+    parentObject: parentObject,\n+    key: key,\n+    map: map,\n+    path: path\n   };\n+  null === referencedChunk.value\n+    ? (referencedChunk.value = [parentObject])\n+    : referencedChunk.value.push(parentObject);\n+  null === referencedChunk.reason\n+    ? (referencedChunk.reason = [parentObject])\n+    : referencedChunk.reason.push(parentObject);\n+  return null;\n }\n function getOutlinedModel(response, reference, parentObject, key, map) {\n   reference = reference.split(\":\");\n@@ -2604,29 +2762,68 @@ function getOutlinedModel(response, reference, parentObject, key, map) {\n   }\n   switch (id.status) {\n     case \"fulfilled\":\n-      parentObject = id.value;\n-      for (key = 1; key < reference.length; key++)\n-        parentObject = parentObject[reference[key]];\n-      return map(response, parentObject);\n+      var value = id.value;\n+      for (id = 1; id < reference.length; id++) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              break;\n+            case \"blocked\":\n+            case \"pending\":\n+              return waitForReference(\n+                value,\n+                parentObject,\n+                key,\n+                response,\n+                map,\n+                reference.slice(id - 1)\n+              );\n+            default:\n+              return (\n+                initializingHandler\n+                  ? ((initializingHandler.errored = !0),\n+                    (initializingHandler.value = null),\n+                    (initializingHandler.reason = value.reason))\n+                  : (initializingHandler = {\n+                      chunk: null,\n+                      value: null,\n+                      reason: value.reason,\n+                      deps: 0,\n+                      errored: !0\n+                    }),\n+                null\n+              );\n+          }\n+        }\n+        var name = reference[id];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      return map(response, value, parentObject, key);\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      var parentChunk = initializingChunk;\n-      id.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          \"cyclic\" === id.status,\n-          response,\n-          map,\n-          reference\n-        ),\n-        createModelReject(parentChunk)\n-      );\n-      return null;\n+      return waitForReference(id, parentObject, key, response, map, reference);\n     default:\n-      throw id.reason;\n+      return (\n+        initializingHandler\n+          ? ((initializingHandler.errored = !0),\n+            (initializingHandler.value = null),\n+            (initializingHandler.reason = id.reason))\n+          : (initializingHandler = {\n+              chunk: null,\n+              value: null,\n+              reason: id.reason,\n+              deps: 0,\n+              errored: !0\n+            }),\n+        null\n+      );\n   }\n }\n function createMap(response, model) {\n@@ -2650,38 +2847,63 @@ function parseTypedArray(\n   parentKey\n ) {\n   reference = parseInt(reference.slice(2), 16);\n-  reference = response._formData.get(response._prefix + reference);\n-  reference =\n-    constructor === ArrayBuffer\n-      ? reference.arrayBuffer()\n-      : reference.arrayBuffer().then(function (buffer) {\n-          return new constructor(buffer);\n-        });\n-  bytesPerElement = initializingChunk;\n+  reference = response._formData\n+    .get(response._prefix + reference)\n+    .arrayBuffer();\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n   reference.then(\n-    createModelResolver(\n-      bytesPerElement,\n-      parentObject,\n-      parentKey,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(bytesPerElement)\n+    function (buffer) {\n+      buffer = constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+      parentObject[parentKey] = buffer;\n+      \"\" === parentKey && null === handler.value && (handler.value = buffer);\n+      handler.deps--;\n+      if (\n+        0 === handler.deps &&\n+        ((buffer = handler.chunk),\n+        null !== buffer && \"blocked\" === buffer.status)\n+      ) {\n+        var resolveListeners = buffer.value;\n+        buffer.status = \"fulfilled\";\n+        buffer.value = handler.value;\n+        null !== resolveListeners &&\n+          wakeChunk(response, resolveListeners, handler.value);\n+      }\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n function resolveStream(response, id, stream, controller) {\n   var chunks = response._chunks;\n-  stream = new Chunk(\"fulfilled\", stream, controller, response);\n+  stream = new ReactPromise(\"fulfilled\", stream, controller);\n   chunks.set(id, stream);\n   response = response._formData.getAll(response._prefix + id);\n   for (id = 0; id < response.length; id++)\n     (chunks = response[id]),\n-      \"C\" === chunks[0]\n-        ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n-        : controller.enqueueModel(chunks);\n+      \"string\" === typeof chunks &&\n+        (\"C\" === chunks[0]\n+          ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n+          : controller.enqueueModel(chunks));\n }\n function parseReadableStream(response, reference, type) {\n   reference = parseInt(reference.slice(2), 16);\n@@ -2696,7 +2918,7 @@ function parseReadableStream(response, reference, type) {\n   resolveStream(response, reference, type, {\n     enqueueModel: function (json) {\n       if (null === previousBlockedChunk) {\n-        var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+        var chunk = createResolvedModelChunk(response, json, -1);\n         initializeModelChunk(chunk);\n         \"fulfilled\" === chunk.status\n           ? controller.enqueue(chunk.value)\n@@ -2711,19 +2933,19 @@ function parseReadableStream(response, reference, type) {\n             (previousBlockedChunk = chunk));\n       } else {\n         chunk = previousBlockedChunk;\n-        var chunk$29 = createPendingChunk(response);\n-        chunk$29.then(\n+        var chunk$33 = new ReactPromise(\"pending\", null, null);\n+        chunk$33.then(\n           function (v) {\n             return controller.enqueue(v);\n           },\n           function (e) {\n             return controller.error(e);\n           }\n         );\n-        previousBlockedChunk = chunk$29;\n+        previousBlockedChunk = chunk$33;\n         chunk.then(function () {\n-          previousBlockedChunk === chunk$29 && (previousBlockedChunk = null);\n-          resolveModelChunk(chunk$29, json, -1);\n+          previousBlockedChunk === chunk$33 && (previousBlockedChunk = null);\n+          resolveModelChunk(response, chunk$33, json, -1);\n         });\n       }\n     },\n@@ -2763,9 +2985,9 @@ function parseAsyncIterable(response, reference, iterator) {\n   var buffer = [],\n     closed = !1,\n     nextWriteIndex = 0,\n-    $jscomp$compprop2 = {};\n-  $jscomp$compprop2 =\n-    (($jscomp$compprop2[ASYNC_ITERATOR] = function () {\n+    $jscomp$compprop5 = {};\n+  $jscomp$compprop5 =\n+    (($jscomp$compprop5[ASYNC_ITERATOR] = function () {\n       var nextReadIndex = 0;\n       return createIterator(function (arg) {\n         if (void 0 !== arg)\n@@ -2774,19 +2996,18 @@ function parseAsyncIterable(response, reference, iterator) {\n           );\n         if (nextReadIndex === buffer.length) {\n           if (closed)\n-            return new Chunk(\n+            return new ReactPromise(\n               \"fulfilled\",\n               { done: !0, value: void 0 },\n-              null,\n-              response\n+              null\n             );\n-          buffer[nextReadIndex] = createPendingChunk(response);\n+          buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n         }\n         return buffer[nextReadIndex++];\n       });\n     }),\n-    $jscomp$compprop2);\n-  iterator = iterator ? $jscomp$compprop2[ASYNC_ITERATOR]() : $jscomp$compprop2;\n+    $jscomp$compprop5);\n+  iterator = iterator ? $jscomp$compprop5[ASYNC_ITERATOR]() : $jscomp$compprop5;\n   resolveStream(response, reference, iterator, {\n     enqueueModel: function (value) {\n       nextWriteIndex === buffer.length\n@@ -2795,7 +3016,12 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !1\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !1\n+          );\n       nextWriteIndex++;\n     },\n     close: function (value) {\n@@ -2806,9 +3032,15 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !0\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !0\n+          );\n       for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n         resolveIteratorResultChunk(\n+          response,\n           buffer[nextWriteIndex++],\n           '\"$undefined\"',\n           !0\n@@ -2818,11 +3050,11 @@ function parseAsyncIterable(response, reference, iterator) {\n       closed = !0;\n       for (\n         nextWriteIndex === buffer.length &&\n-        (buffer[nextWriteIndex] = createPendingChunk(response));\n+        (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n         nextWriteIndex < buffer.length;\n \n       )\n-        triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+        triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n     }\n   });\n   return iterator;\n@@ -2837,15 +3069,7 @@ function parseModelString(response, obj, key, value, reference) {\n       case \"F\":\n         return (\n           (value = value.slice(2)),\n-          (value = getOutlinedModel(response, value, obj, key, createModel)),\n-          loadServerReference$1(\n-            response,\n-            value.id,\n-            value.bound,\n-            initializingChunk,\n-            obj,\n-            key\n-          )\n+          getOutlinedModel(response, value, obj, key, loadServerReference$1)\n         );\n       case \"T\":\n         if (void 0 === reference || void 0 === response._temporaryReferences)\n@@ -2960,10 +3184,12 @@ function createResponse(bundlerConfig, formFieldPrefix, temporaryReferences) {\n function resolveField(response, key, value) {\n   response._formData.append(key, value);\n   var prefix = response._prefix;\n-  key.startsWith(prefix) &&\n-    ((response = response._chunks),\n-    (key = +key.slice(prefix.length)),\n-    (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));\n+  if (key.startsWith(prefix)) {\n+    var chunks = response._chunks;\n+    key = +key.slice(prefix.length);\n+    (chunks = chunks.get(key)) &&\n+      resolveModelChunk(response, chunks, value, key);\n+  }\n }\n function close(response) {\n   reportGlobalError(response, Error(\"Connection closed.\"));\n@@ -3132,34 +3358,50 @@ exports.decodeReplyFromBusboy = function (busboyStream, turbopackMap, options) {\n     pendingFiles = 0,\n     queuedFields = [];\n   busboyStream.on(\"field\", function (name, value) {\n-    0 < pendingFiles\n-      ? queuedFields.push(name, value)\n-      : resolveField(response, name, value);\n+    if (0 < pendingFiles) queuedFields.push(name, value);\n+    else\n+      try {\n+        resolveField(response, name, value);\n+      } catch (error) {\n+        busboyStream.destroy(error);\n+      }\n   });\n   busboyStream.on(\"file\", function (name, value, _ref2) {\n     var filename = _ref2.filename,\n       mimeType = _ref2.mimeType;\n     if (\"base64\" === _ref2.encoding.toLowerCase())\n-      throw Error(\n-        \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+      busboyStream.destroy(\n+        Error(\n+          \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+        )\n       );\n-    pendingFiles++;\n-    var JSCompiler_object_inline_chunks_277 = [];\n-    value.on(\"data\", function (chunk) {\n-      JSCompiler_object_inline_chunks_277.push(chunk);\n-    });\n-    value.on(\"end\", function () {\n-      var blob = new Blob(JSCompiler_object_inline_chunks_277, {\n-        type: mimeType\n+    else {\n+      pendingFiles++;\n+      var JSCompiler_object_inline_chunks_284 = [];\n+      value.on(\"data\", function (chunk) {\n+        JSCompiler_object_inline_chunks_284.push(chunk);\n       });\n-      response._formData.append(name, blob, filename);\n-      pendingFiles--;\n-      if (0 === pendingFiles) {\n-        for (blob = 0; blob < queuedFields.length; blob += 2)\n-          resolveField(response, queuedFields[blob], queuedFields[blob + 1]);\n-        queuedFields.length = 0;\n-      }\n-    });\n+      value.on(\"end\", function () {\n+        try {\n+          var blob = new Blob(JSCompiler_object_inline_chunks_284, {\n+            type: mimeType\n+          });\n+          response._formData.append(name, blob, filename);\n+          pendingFiles--;\n+          if (0 === pendingFiles) {\n+            for (blob = 0; blob < queuedFields.length; blob += 2)\n+              resolveField(\n+                response,\n+                queuedFields[blob],\n+                queuedFields[blob + 1]\n+              );\n+            queuedFields.length = 0;\n+          }\n+        } catch (error) {\n+          busboyStream.destroy(error);\n+        }\n+      });\n+    }\n   });\n   busboyStream.on(\"finish\", function () {\n     close(response);"
        },
        {
            "sha": "5fc212d3d056b9b46a4065f4c2af7bd180bf6e74",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fpackage.json?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -48,7 +48,7 @@\n     \"neo-async\": \"^2.6.1\"\n   },\n   \"peerDependencies\": {\n-    \"react\": \"0.0.0-experimental-fd524fe0-20251121\",\n-    \"react-dom\": \"0.0.0-experimental-fd524fe0-20251121\"\n+    \"react\": \"0.0.0-experimental-7dc903cd-20251203\",\n+    \"react-dom\": \"0.0.0-experimental-7dc903cd-20251203\"\n   }\n }\n\\ No newline at end of file"
        },
        {
            "sha": "aacca75d1df0f73cfdb77f79f8e79bd80597b0fe",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.browser.development.js",
            "status": "modified",
            "additions": 8,
            "deletions": 10,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.browser.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -99,13 +99,11 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function getIteratorFn(maybeIterable) {\n       if (null === maybeIterable || \"object\" !== typeof maybeIterable)\n@@ -4759,6 +4757,7 @@\n       ReactDOM = require(\"react-dom\"),\n       decoderOptions = { stream: !0 },\n       bind = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       instrumentedChunks = new WeakSet(),\n       loadedChunks = new WeakSet(),\n       chunkIOInfoCache = new Map(),\n@@ -4791,7 +4790,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&\n@@ -4968,10 +4966,10 @@\n       return hook.checkDCE ? !0 : !1;\n     })({\n       bundleType: 1,\n-      version: \"19.3.0-canary-fd524fe0-20251121\",\n+      version: \"19.3.0-canary-7dc903cd-20251203\",\n       rendererPackageName: \"react-server-dom-turbopack\",\n       currentDispatcherRef: ReactSharedInternals,\n-      reconcilerVersion: \"19.3.0-canary-fd524fe0-20251121\",\n+      reconcilerVersion: \"19.3.0-canary-7dc903cd-20251203\",\n       getCurrentComponentInfo: function () {\n         return currentOwnerInDEV;\n       }"
        },
        {
            "sha": "0b3712107717f2e8d315ac522be0db6fddb51370",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.browser.production.js",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.browser.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -10,7 +10,8 @@\n \n \"use strict\";\n var ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   if (bundlerConfig) {\n     var moduleExports = bundlerConfig[metadata[0]];\n@@ -97,13 +98,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n var ReactDOMSharedInternals =\n     ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,"
        },
        {
            "sha": "ed4f6f4a4cc4fc69974da36cdd120422ac1c41ec",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.edge.development.js",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.edge.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -99,13 +99,11 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function prepareDestinationWithChunks(\n       moduleLoading,\n@@ -4798,6 +4796,7 @@\n       React = require(\"react\"),\n       decoderOptions = { stream: !0 },\n       bind$1 = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       instrumentedChunks = new WeakSet(),\n       loadedChunks = new WeakSet(),\n       ReactDOMSharedInternals =\n@@ -4832,7 +4831,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&"
        },
        {
            "sha": "32de853f569adc068dadbfcbf723273c74495c8c",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.edge.production.js",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.edge.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -10,7 +10,8 @@\n \n \"use strict\";\n var ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   if (bundlerConfig) {\n     var moduleExports = bundlerConfig[metadata[0]];\n@@ -97,13 +98,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n function prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n   if (null !== moduleLoading)"
        },
        {
            "sha": "76f3b6b34853eedefe854a32ceb07b58bc775e0e",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.node.development.js",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.node.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -99,13 +99,11 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function prepareDestinationWithChunks(\n       moduleLoading,\n@@ -4903,6 +4901,7 @@\n       React = require(\"react\"),\n       decoderOptions = { stream: !0 },\n       bind$1 = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       instrumentedChunks = new WeakSet(),\n       loadedChunks = new WeakSet(),\n       ReactDOMSharedInternals =\n@@ -4937,7 +4936,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&"
        },
        {
            "sha": "0a84fd7f5ff1f7d4d3552b10c12e3e5482ef9d8d",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.node.production.js",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.node.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -11,7 +11,8 @@\n \"use strict\";\n var util = require(\"util\"),\n   ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   if (bundlerConfig) {\n     var moduleExports = bundlerConfig[metadata[0]];\n@@ -98,13 +99,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n function prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n   if (null !== moduleLoading)"
        },
        {
            "sha": "3bbd8371b67feef2ef59f3b4df9fdc2908f128b5",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.browser.development.js",
            "status": "modified",
            "additions": 432,
            "deletions": 199,
            "changes": 631,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.browser.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -3898,37 +3898,65 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n-    }\n-    function Chunk(status, value, reason, response) {\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n+    }\n+    function ReactPromise(status, value, reason) {\n       this.status = status;\n       this.value = value;\n       this.reason = reason;\n-      this._response = response;\n     }\n-    function createPendingChunk(response) {\n-      return new Chunk(\"pending\", null, null, response);\n+    function wakeChunk(response, listeners, value) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n     }\n-    function wakeChunk(listeners, value) {\n-      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+    function rejectChunk(response, listeners, error) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(error)\n+          : rejectReference(response, listener.handler, error);\n+      }\n     }\n-    function triggerErrorOnChunk(chunk, error) {\n+    function resolveBlockedCycle(resolvedChunk, reference) {\n+      var referencedChunk = reference.handler.chunk;\n+      if (null === referencedChunk) return null;\n+      if (referencedChunk === resolvedChunk) return reference.handler;\n+      reference = referencedChunk.value;\n+      if (null !== reference)\n+        for (\n+          referencedChunk = 0;\n+          referencedChunk < reference.length;\n+          referencedChunk++\n+        ) {\n+          var listener = reference[referencedChunk];\n+          if (\n+            \"function\" !== typeof listener &&\n+            ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+            null !== listener)\n+          )\n+            return listener;\n+        }\n+      return null;\n+    }\n+    function triggerErrorOnChunk(response, chunk, error) {\n       if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n         chunk.reason.error(error);\n       else {\n         var listeners = chunk.reason;\n         chunk.status = \"rejected\";\n         chunk.reason = error;\n-        null !== listeners && wakeChunk(listeners, error);\n+        null !== listeners && rejectChunk(response, listeners, error);\n       }\n     }\n-    function resolveModelChunk(chunk, value, id) {\n+    function resolveModelChunk(response, chunk, value, id) {\n       if (\"pending\" !== chunk.status)\n         (chunk = chunk.reason),\n           \"C\" === value[0]\n@@ -3939,81 +3967,142 @@\n           rejectListeners = chunk.reason;\n         chunk.status = \"resolved_model\";\n         chunk.value = value;\n-        chunk.reason = id;\n+        chunk.reason = _defineProperty({ id: id }, RESPONSE_SYMBOL, response);\n         if (null !== resolveListeners)\n-          switch ((initializeModelChunk(chunk), chunk.status)) {\n+          a: switch ((initializeModelChunk(chunk), chunk.status)) {\n             case \"fulfilled\":\n-              wakeChunk(resolveListeners, chunk.value);\n+              wakeChunk(response, resolveListeners, chunk.value);\n               break;\n-            case \"pending\":\n             case \"blocked\":\n-            case \"cyclic\":\n+              for (value = 0; value < resolveListeners.length; value++)\n+                if (\n+                  ((id = resolveListeners[value]), \"function\" !== typeof id)\n+                ) {\n+                  var cyclicHandler = resolveBlockedCycle(chunk, id);\n+                  if (null !== cyclicHandler)\n+                    switch (\n+                      (fulfillReference(response, id, cyclicHandler.value),\n+                      resolveListeners.splice(value, 1),\n+                      value--,\n+                      null !== rejectListeners &&\n+                        ((id = rejectListeners.indexOf(id)),\n+                        -1 !== id && rejectListeners.splice(id, 1)),\n+                      chunk.status)\n+                    ) {\n+                      case \"fulfilled\":\n+                        wakeChunk(response, resolveListeners, chunk.value);\n+                        break a;\n+                      case \"rejected\":\n+                        null !== rejectListeners &&\n+                          rejectChunk(response, rejectListeners, chunk.reason);\n+                        break a;\n+                    }\n+                }\n+            case \"pending\":\n               if (chunk.value)\n-                for (value = 0; value < resolveListeners.length; value++)\n-                  chunk.value.push(resolveListeners[value]);\n+                for (\n+                  response = 0;\n+                  response < resolveListeners.length;\n+                  response++\n+                )\n+                  chunk.value.push(resolveListeners[response]);\n               else chunk.value = resolveListeners;\n               if (chunk.reason) {\n                 if (rejectListeners)\n-                  for (value = 0; value < rejectListeners.length; value++)\n-                    chunk.reason.push(rejectListeners[value]);\n+                  for (\n+                    resolveListeners = 0;\n+                    resolveListeners < rejectListeners.length;\n+                    resolveListeners++\n+                  )\n+                    chunk.reason.push(rejectListeners[resolveListeners]);\n               } else chunk.reason = rejectListeners;\n               break;\n             case \"rejected\":\n-              rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+              rejectListeners &&\n+                wakeChunk(response, rejectListeners, chunk.reason);\n           }\n       }\n     }\n     function createResolvedIteratorResultChunk(response, value, done) {\n-      return new Chunk(\n+      return new ReactPromise(\n         \"resolved_model\",\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n-        -1,\n-        response\n+        _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n       );\n     }\n-    function resolveIteratorResultChunk(chunk, value, done) {\n+    function resolveIteratorResultChunk(response, chunk, value, done) {\n       resolveModelChunk(\n+        response,\n         chunk,\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n         -1\n       );\n     }\n-    function loadServerReference$1(\n-      response,\n-      id,\n-      bound,\n-      parentChunk,\n-      parentObject,\n-      key\n-    ) {\n+    function loadServerReference$1(response, metaData, parentObject, key) {\n+      var id = metaData.id;\n+      if (\"string\" !== typeof id) return null;\n       var serverReference = resolveServerReference(response._bundlerConfig, id);\n-      id = preloadModule(serverReference);\n-      if (bound)\n-        bound = Promise.all([bound, id]).then(function (_ref) {\n-          _ref = _ref[0];\n-          var fn = requireModule(serverReference);\n-          return fn.bind.apply(fn, [null].concat(_ref));\n-        });\n-      else if (id)\n-        bound = Promise.resolve(id).then(function () {\n-          return requireModule(serverReference);\n-        });\n+      id = metaData.bound;\n+      var promise = preloadModule(serverReference);\n+      if (promise)\n+        id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+      else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n       else return requireModule(serverReference);\n-      bound.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(parentChunk)\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n+      promise.then(\n+        function () {\n+          var resolvedValue = requireModule(serverReference);\n+          if (metaData.bound) {\n+            var promiseValue = metaData.bound.value;\n+            promiseValue = Array.isArray(promiseValue)\n+              ? promiseValue.slice(0)\n+              : [];\n+            promiseValue.unshift(null);\n+            resolvedValue = resolvedValue.bind.apply(\n+              resolvedValue,\n+              promiseValue\n+            );\n+          }\n+          parentObject[key] = resolvedValue;\n+          \"\" === key &&\n+            null === handler.value &&\n+            (handler.value = resolvedValue);\n+          handler.deps--;\n+          0 === handler.deps &&\n+            ((resolvedValue = handler.chunk),\n+            null !== resolvedValue &&\n+              \"blocked\" === resolvedValue.status &&\n+              ((promiseValue = resolvedValue.value),\n+              (resolvedValue.status = \"fulfilled\"),\n+              (resolvedValue.value = handler.value),\n+              null !== promiseValue &&\n+                wakeChunk(response, promiseValue, handler.value)));\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n@@ -4055,53 +4144,66 @@\n                 value[i],\n                 parentObj\n               )),\n-              void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+              void 0 !== parentObj || \"__proto__\" === i\n+                ? (value[i] = parentObj)\n+                : delete value[i]);\n       return value;\n     }\n     function initializeModelChunk(chunk) {\n-      var prevChunk = initializingChunk,\n-        prevBlocked = initializingChunkBlockedModel;\n-      initializingChunk = chunk;\n-      initializingChunkBlockedModel = null;\n-      var rootReference =\n-          -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-        resolvedModel = chunk.value;\n-      chunk.status = \"cyclic\";\n+      var prevHandler = initializingHandler;\n+      initializingHandler = null;\n+      var _chunk$reason = chunk.reason,\n+        response = _chunk$reason[RESPONSE_SYMBOL];\n+      _chunk$reason = _chunk$reason.id;\n+      _chunk$reason =\n+        -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+      var resolvedModel = chunk.value;\n+      chunk.status = \"blocked\";\n       chunk.value = null;\n       chunk.reason = null;\n       try {\n         var rawModel = JSON.parse(resolvedModel),\n           value = reviveModel(\n-            chunk._response,\n+            response,\n             { \"\": rawModel },\n             \"\",\n             rawModel,\n-            rootReference\n-          );\n-        if (\n-          null !== initializingChunkBlockedModel &&\n-          0 < initializingChunkBlockedModel.deps\n-        )\n-          (initializingChunkBlockedModel.value = value),\n-            (chunk.status = \"blocked\");\n-        else {\n-          var resolveListeners = chunk.value;\n-          chunk.status = \"fulfilled\";\n-          chunk.value = value;\n-          null !== resolveListeners && wakeChunk(resolveListeners, value);\n+            _chunk$reason\n+          ),\n+          resolveListeners = chunk.value;\n+        if (null !== resolveListeners)\n+          for (\n+            chunk.value = null, chunk.reason = null, rawModel = 0;\n+            rawModel < resolveListeners.length;\n+            rawModel++\n+          ) {\n+            var listener = resolveListeners[rawModel];\n+            \"function\" === typeof listener\n+              ? listener(value)\n+              : fulfillReference(response, listener, value);\n+          }\n+        if (null !== initializingHandler) {\n+          if (initializingHandler.errored) throw initializingHandler.reason;\n+          if (0 < initializingHandler.deps) {\n+            initializingHandler.value = value;\n+            initializingHandler.chunk = chunk;\n+            return;\n+          }\n         }\n+        chunk.status = \"fulfilled\";\n+        chunk.value = value;\n       } catch (error) {\n         (chunk.status = \"rejected\"), (chunk.reason = error);\n       } finally {\n-        (initializingChunk = prevChunk),\n-          (initializingChunkBlockedModel = prevBlocked);\n+        initializingHandler = prevHandler;\n       }\n     }\n     function reportGlobalError(response, error) {\n       response._closed = !0;\n       response._closedReason = error;\n       response._chunks.forEach(function (chunk) {\n-        \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+        \"pending\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n       });\n     }\n     function getChunk(response, id) {\n@@ -4110,50 +4212,108 @@\n       chunk ||\n         ((chunk = response._formData.get(response._prefix + id)),\n         (chunk =\n-          null != chunk\n-            ? new Chunk(\"resolved_model\", chunk, id, response)\n+          \"string\" === typeof chunk\n+            ? new ReactPromise(\n+                \"resolved_model\",\n+                chunk,\n+                _defineProperty({ id: id }, RESPONSE_SYMBOL, response)\n+              )\n             : response._closed\n-              ? new Chunk(\"rejected\", null, response._closedReason, response)\n-              : createPendingChunk(response)),\n+              ? new ReactPromise(\"rejected\", null, response._closedReason)\n+              : new ReactPromise(\"pending\", null, null)),\n         chunks.set(id, chunk));\n       return chunk;\n     }\n-    function createModelResolver(\n-      chunk,\n+    function fulfillReference(response, reference, value) {\n+      for (\n+        var handler = reference.handler,\n+          parentObject = reference.parentObject,\n+          key = reference.key,\n+          map = reference.map,\n+          path = reference.path,\n+          i = 1;\n+        i < path.length;\n+        i++\n+      ) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              continue;\n+            case \"blocked\":\n+            case \"pending\":\n+              path.splice(0, i - 1);\n+              null === value.value\n+                ? (value.value = [reference])\n+                : value.value.push(reference);\n+              null === value.reason\n+                ? (value.reason = [reference])\n+                : value.reason.push(reference);\n+              return;\n+            default:\n+              rejectReference(response, reference.handler, value.reason);\n+              return;\n+          }\n+        }\n+        var name = path[i];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      reference = map(response, value, parentObject, key);\n+      parentObject[key] = reference;\n+      \"\" === key && null === handler.value && (handler.value = reference);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((parentObject = handler.chunk),\n+        null !== parentObject &&\n+          \"blocked\" === parentObject.status &&\n+          ((key = parentObject.value),\n+          (parentObject.status = \"fulfilled\"),\n+          (parentObject.value = handler.value),\n+          (parentObject.reason = handler.reason),\n+          null !== key && wakeChunk(response, key, handler.value)));\n+    }\n+    function rejectReference(response, handler, error) {\n+      handler.errored ||\n+        ((handler.errored = !0),\n+        (handler.value = null),\n+        (handler.reason = error),\n+        (handler = handler.chunk),\n+        null !== handler &&\n+          \"blocked\" === handler.status &&\n+          triggerErrorOnChunk(response, handler, error));\n+    }\n+    function waitForReference(\n+      referencedChunk,\n       parentObject,\n       key,\n-      cyclic,\n       response,\n       map,\n       path\n     ) {\n-      if (initializingChunkBlockedModel) {\n-        var blocked = initializingChunkBlockedModel;\n-        cyclic || blocked.deps++;\n-      } else\n-        blocked = initializingChunkBlockedModel = {\n-          deps: cyclic ? 0 : 1,\n-          value: null\n-        };\n-      return function (value) {\n-        for (var i = 1; i < path.length; i++) value = value[path[i]];\n-        parentObject[key] = map(response, value);\n-        \"\" === key &&\n-          null === blocked.value &&\n-          (blocked.value = parentObject[key]);\n-        blocked.deps--;\n-        0 === blocked.deps &&\n-          \"blocked\" === chunk.status &&\n-          ((value = chunk.value),\n-          (chunk.status = \"fulfilled\"),\n-          (chunk.value = blocked.value),\n-          null !== value && wakeChunk(value, blocked.value));\n-      };\n-    }\n-    function createModelReject(chunk) {\n-      return function (error) {\n-        return triggerErrorOnChunk(chunk, error);\n+      initializingHandler\n+        ? ((response = initializingHandler), response.deps++)\n+        : (response = initializingHandler =\n+            { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+      parentObject = {\n+        handler: response,\n+        parentObject: parentObject,\n+        key: key,\n+        map: map,\n+        path: path\n       };\n+      null === referencedChunk.value\n+        ? (referencedChunk.value = [parentObject])\n+        : referencedChunk.value.push(parentObject);\n+      null === referencedChunk.reason\n+        ? (referencedChunk.reason = [parentObject])\n+        : referencedChunk.reason.push(parentObject);\n+      return null;\n     }\n     function getOutlinedModel(response, reference, parentObject, key, map) {\n       reference = reference.split(\":\");\n@@ -4165,29 +4325,75 @@\n       }\n       switch (id.status) {\n         case \"fulfilled\":\n-          parentObject = id.value;\n-          for (key = 1; key < reference.length; key++)\n-            parentObject = parentObject[reference[key]];\n-          return map(response, parentObject);\n+          var value = id.value;\n+          for (id = 1; id < reference.length; id++) {\n+            for (; value instanceof ReactPromise; ) {\n+              switch (value.status) {\n+                case \"resolved_model\":\n+                  initializeModelChunk(value);\n+              }\n+              switch (value.status) {\n+                case \"fulfilled\":\n+                  value = value.value;\n+                  break;\n+                case \"blocked\":\n+                case \"pending\":\n+                  return waitForReference(\n+                    value,\n+                    parentObject,\n+                    key,\n+                    response,\n+                    map,\n+                    reference.slice(id - 1)\n+                  );\n+                default:\n+                  return (\n+                    initializingHandler\n+                      ? ((initializingHandler.errored = !0),\n+                        (initializingHandler.value = null),\n+                        (initializingHandler.reason = value.reason))\n+                      : (initializingHandler = {\n+                          chunk: null,\n+                          value: null,\n+                          reason: value.reason,\n+                          deps: 0,\n+                          errored: !0\n+                        }),\n+                    null\n+                  );\n+              }\n+            }\n+            var name = reference[id];\n+            \"object\" === typeof value &&\n+              hasOwnProperty.call(value, name) &&\n+              (value = value[name]);\n+          }\n+          return map(response, value, parentObject, key);\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          var parentChunk = initializingChunk;\n-          id.then(\n-            createModelResolver(\n-              parentChunk,\n-              parentObject,\n-              key,\n-              \"cyclic\" === id.status,\n-              response,\n-              map,\n-              reference\n-            ),\n-            createModelReject(parentChunk)\n+          return waitForReference(\n+            id,\n+            parentObject,\n+            key,\n+            response,\n+            map,\n+            reference\n           );\n-          return null;\n         default:\n-          throw id.reason;\n+          return (\n+            initializingHandler\n+              ? ((initializingHandler.errored = !0),\n+                (initializingHandler.value = null),\n+                (initializingHandler.reason = id.reason))\n+              : (initializingHandler = {\n+                  chunk: null,\n+                  value: null,\n+                  reason: id.reason,\n+                  deps: 0,\n+                  errored: !0\n+                }),\n+            null\n+          );\n       }\n     }\n     function createMap(response, model) {\n@@ -4211,40 +4417,68 @@\n       parentKey\n     ) {\n       reference = parseInt(reference.slice(2), 16);\n-      reference = response._formData.get(response._prefix + reference);\n-      reference =\n-        constructor === ArrayBuffer\n-          ? reference.arrayBuffer()\n-          : reference.arrayBuffer().then(function (buffer) {\n-              return new constructor(buffer);\n-            });\n-      bytesPerElement = initializingChunk;\n+      reference = response._formData\n+        .get(response._prefix + reference)\n+        .arrayBuffer();\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n       reference.then(\n-        createModelResolver(\n-          bytesPerElement,\n-          parentObject,\n-          parentKey,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(bytesPerElement)\n+        function (buffer) {\n+          buffer =\n+            constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+          parentObject[parentKey] = buffer;\n+          \"\" === parentKey &&\n+            null === handler.value &&\n+            (handler.value = buffer);\n+          handler.deps--;\n+          if (\n+            0 === handler.deps &&\n+            ((buffer = handler.chunk),\n+            null !== buffer && \"blocked\" === buffer.status)\n+          ) {\n+            var resolveListeners = buffer.value;\n+            buffer.status = \"fulfilled\";\n+            buffer.value = handler.value;\n+            null !== resolveListeners &&\n+              wakeChunk(response, resolveListeners, handler.value);\n+          }\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n     function resolveStream(response, id, stream, controller) {\n       var chunks = response._chunks;\n-      stream = new Chunk(\"fulfilled\", stream, controller, response);\n+      stream = new ReactPromise(\"fulfilled\", stream, controller);\n       chunks.set(id, stream);\n       response = response._formData.getAll(response._prefix + id);\n       for (id = 0; id < response.length; id++)\n         (chunks = response[id]),\n-          \"C\" === chunks[0]\n-            ? controller.close(\n-                \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n-              )\n-            : controller.enqueueModel(chunks);\n+          \"string\" === typeof chunks &&\n+            (\"C\" === chunks[0]\n+              ? controller.close(\n+                  \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n+                )\n+              : controller.enqueueModel(chunks));\n     }\n     function parseReadableStream(response, reference, type) {\n       reference = parseInt(reference.slice(2), 16);\n@@ -4259,7 +4493,11 @@\n       resolveStream(response, reference, type, {\n         enqueueModel: function (json) {\n           if (null === previousBlockedChunk) {\n-            var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+            var chunk = new ReactPromise(\n+              \"resolved_model\",\n+              json,\n+              _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n+            );\n             initializeModelChunk(chunk);\n             \"fulfilled\" === chunk.status\n               ? controller.enqueue(chunk.value)\n@@ -4274,7 +4512,7 @@\n                 (previousBlockedChunk = chunk));\n           } else {\n             chunk = previousBlockedChunk;\n-            var _chunk = createPendingChunk(response);\n+            var _chunk = new ReactPromise(\"pending\", null, null);\n             _chunk.then(\n               function (v) {\n                 return controller.enqueue(v);\n@@ -4286,7 +4524,7 @@\n             previousBlockedChunk = _chunk;\n             chunk.then(function () {\n               previousBlockedChunk === _chunk && (previousBlockedChunk = null);\n-              resolveModelChunk(_chunk, json, -1);\n+              resolveModelChunk(response, _chunk, json, -1);\n             });\n           }\n         },\n@@ -4335,13 +4573,12 @@\n               );\n             if (nextReadIndex === buffer.length) {\n               if (closed)\n-                return new Chunk(\n+                return new ReactPromise(\n                   \"fulfilled\",\n                   { done: !0, value: void 0 },\n-                  null,\n-                  response\n+                  null\n                 );\n-              buffer[nextReadIndex] = createPendingChunk(response);\n+              buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n             }\n             return buffer[nextReadIndex++];\n           });\n@@ -4355,7 +4592,12 @@\n                 value,\n                 !1\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !1\n+              );\n           nextWriteIndex++;\n         },\n         close: function (value) {\n@@ -4366,9 +4608,15 @@\n                 value,\n                 !0\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !0\n+              );\n           for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n             resolveIteratorResultChunk(\n+              response,\n               buffer[nextWriteIndex++],\n               '\"$undefined\"',\n               !0\n@@ -4378,11 +4626,11 @@\n           closed = !0;\n           for (\n             nextWriteIndex === buffer.length &&\n-            (buffer[nextWriteIndex] = createPendingChunk(response));\n+            (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n             nextWriteIndex < buffer.length;\n \n           )\n-            triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n         }\n       });\n       return iterator;\n@@ -4399,21 +4647,7 @@\n           case \"F\":\n             return (\n               (value = value.slice(2)),\n-              (value = getOutlinedModel(\n-                response,\n-                value,\n-                obj,\n-                key,\n-                createModel\n-              )),\n-              loadServerReference$1(\n-                response,\n-                value.id,\n-                value.bound,\n-                initializingChunk,\n-                obj,\n-                key\n-              )\n+              getOutlinedModel(response, value, obj, key, loadServerReference$1)\n             );\n           case \"T\":\n             if (\n@@ -5084,33 +5318,32 @@\n       emptyRoot = {},\n       decoderOptions = { stream: !0 },\n       instrumentedChunks = new WeakSet(),\n-      loadedChunks = new WeakSet();\n-    Chunk.prototype = Object.create(Promise.prototype);\n-    Chunk.prototype.then = function (resolve, reject) {\n+      loadedChunks = new WeakSet(),\n+      RESPONSE_SYMBOL = Symbol();\n+    ReactPromise.prototype = Object.create(Promise.prototype);\n+    ReactPromise.prototype.then = function (resolve, reject) {\n       switch (this.status) {\n         case \"resolved_model\":\n           initializeModelChunk(this);\n       }\n       switch (this.status) {\n         case \"fulfilled\":\n-          resolve(this.value);\n+          \"function\" === typeof resolve && resolve(this.value);\n           break;\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          resolve &&\n+          \"function\" === typeof resolve &&\n             (null === this.value && (this.value = []),\n             this.value.push(resolve));\n-          reject &&\n+          \"function\" === typeof reject &&\n             (null === this.reason && (this.reason = []),\n             this.reason.push(reject));\n           break;\n         default:\n-          reject(this.reason);\n+          \"function\" === typeof reject && reject(this.reason);\n       }\n     };\n-    var initializingChunk = null,\n-      initializingChunkBlockedModel = null;\n+    var initializingHandler = null;\n     exports.createClientModuleProxy = function (moduleId) {\n       moduleId = registerClientReferenceImpl({}, moduleId, !1);\n       return new Proxy(moduleId, proxyHandlers$1);"
        },
        {
            "sha": "4fc958e92096a23b0d961c72226732edea1bbcb2",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.browser.production.js",
            "status": "modified",
            "additions": 426,
            "deletions": 202,
            "changes": 628,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.browser.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -956,8 +956,8 @@ function serializeReadableStream(request, task, stream) {\n               : tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             reader.read().then(progress, error);\n-        } catch (x$8) {\n-          error(x$8);\n+        } catch (x$11) {\n+          error(x$11);\n         }\n   }\n   function error(reason) {\n@@ -1042,8 +1042,8 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n             tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             iterator.next().then(progress, error);\n-        } catch (x$9) {\n-          error(x$9);\n+        } catch (x$12) {\n+          error(x$12);\n         }\n   }\n   function error(reason) {\n@@ -2177,9 +2177,9 @@ function abort(request, reason) {\n         onAllReady();\n         flushCompletedChunks(request);\n       }\n-    } catch (error$23) {\n-      logRecoverableError(request, error$23, null),\n-        fatalError(request, error$23);\n+    } catch (error$26) {\n+      logRecoverableError(request, error$26, null),\n+        fatalError(request, error$26);\n     }\n }\n function resolveServerReference(bundlerConfig, id) {\n@@ -2247,59 +2247,97 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n-}\n-function Chunk(status, value, reason, response) {\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n+}\n+var RESPONSE_SYMBOL = Symbol();\n+function ReactPromise(status, value, reason) {\n   this.status = status;\n   this.value = value;\n   this.reason = reason;\n-  this._response = response;\n }\n-Chunk.prototype = Object.create(Promise.prototype);\n-Chunk.prototype.then = function (resolve, reject) {\n+ReactPromise.prototype = Object.create(Promise.prototype);\n+ReactPromise.prototype.then = function (resolve, reject) {\n   switch (this.status) {\n     case \"resolved_model\":\n       initializeModelChunk(this);\n   }\n   switch (this.status) {\n     case \"fulfilled\":\n-      resolve(this.value);\n+      \"function\" === typeof resolve && resolve(this.value);\n       break;\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      resolve &&\n+      \"function\" === typeof resolve &&\n         (null === this.value && (this.value = []), this.value.push(resolve));\n-      reject &&\n+      \"function\" === typeof reject &&\n         (null === this.reason && (this.reason = []), this.reason.push(reject));\n       break;\n     default:\n-      reject(this.reason);\n+      \"function\" === typeof reject && reject(this.reason);\n   }\n };\n-function createPendingChunk(response) {\n-  return new Chunk(\"pending\", null, null, response);\n+function wakeChunk(response, listeners, value) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(value)\n+      : fulfillReference(response, listener, value);\n+  }\n }\n-function wakeChunk(listeners, value) {\n-  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+function rejectChunk(response, listeners, error) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(error)\n+      : rejectReference(response, listener.handler, error);\n+  }\n }\n-function triggerErrorOnChunk(chunk, error) {\n+function resolveBlockedCycle(resolvedChunk, reference) {\n+  var referencedChunk = reference.handler.chunk;\n+  if (null === referencedChunk) return null;\n+  if (referencedChunk === resolvedChunk) return reference.handler;\n+  reference = referencedChunk.value;\n+  if (null !== reference)\n+    for (\n+      referencedChunk = 0;\n+      referencedChunk < reference.length;\n+      referencedChunk++\n+    ) {\n+      var listener = reference[referencedChunk];\n+      if (\n+        \"function\" !== typeof listener &&\n+        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+        null !== listener)\n+      )\n+        return listener;\n+    }\n+  return null;\n+}\n+function triggerErrorOnChunk(response, chunk, error) {\n   if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n     chunk.reason.error(error);\n   else {\n     var listeners = chunk.reason;\n     chunk.status = \"rejected\";\n     chunk.reason = error;\n-    null !== listeners && wakeChunk(listeners, error);\n+    null !== listeners && rejectChunk(response, listeners, error);\n   }\n }\n-function resolveModelChunk(chunk, value, id) {\n+function createResolvedModelChunk(response, value, id) {\n+  var $jscomp$compprop2 = {};\n+  return new ReactPromise(\n+    \"resolved_model\",\n+    value,\n+    (($jscomp$compprop2.id = id),\n+    ($jscomp$compprop2[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop2)\n+  );\n+}\n+function resolveModelChunk(response, chunk, value, id) {\n   if (\"pending\" !== chunk.status)\n     (chunk = chunk.reason),\n       \"C\" === value[0]\n@@ -2310,77 +2348,129 @@ function resolveModelChunk(chunk, value, id) {\n       rejectListeners = chunk.reason;\n     chunk.status = \"resolved_model\";\n     chunk.value = value;\n-    chunk.reason = id;\n+    value = {};\n+    chunk.reason =\n+      ((value.id = id), (value[RESPONSE_SYMBOL] = response), value);\n     if (null !== resolveListeners)\n-      switch ((initializeModelChunk(chunk), chunk.status)) {\n+      a: switch ((initializeModelChunk(chunk), chunk.status)) {\n         case \"fulfilled\":\n-          wakeChunk(resolveListeners, chunk.value);\n+          wakeChunk(response, resolveListeners, chunk.value);\n           break;\n-        case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n+          for (value = 0; value < resolveListeners.length; value++)\n+            if (((id = resolveListeners[value]), \"function\" !== typeof id)) {\n+              var cyclicHandler = resolveBlockedCycle(chunk, id);\n+              if (null !== cyclicHandler)\n+                switch (\n+                  (fulfillReference(response, id, cyclicHandler.value),\n+                  resolveListeners.splice(value, 1),\n+                  value--,\n+                  null !== rejectListeners &&\n+                    ((id = rejectListeners.indexOf(id)),\n+                    -1 !== id && rejectListeners.splice(id, 1)),\n+                  chunk.status)\n+                ) {\n+                  case \"fulfilled\":\n+                    wakeChunk(response, resolveListeners, chunk.value);\n+                    break a;\n+                  case \"rejected\":\n+                    null !== rejectListeners &&\n+                      rejectChunk(response, rejectListeners, chunk.reason);\n+                    break a;\n+                }\n+            }\n+        case \"pending\":\n           if (chunk.value)\n-            for (value = 0; value < resolveListeners.length; value++)\n-              chunk.value.push(resolveListeners[value]);\n+            for (response = 0; response < resolveListeners.length; response++)\n+              chunk.value.push(resolveListeners[response]);\n           else chunk.value = resolveListeners;\n           if (chunk.reason) {\n             if (rejectListeners)\n-              for (value = 0; value < rejectListeners.length; value++)\n-                chunk.reason.push(rejectListeners[value]);\n+              for (\n+                resolveListeners = 0;\n+                resolveListeners < rejectListeners.length;\n+                resolveListeners++\n+              )\n+                chunk.reason.push(rejectListeners[resolveListeners]);\n           } else chunk.reason = rejectListeners;\n           break;\n         case \"rejected\":\n-          rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+          rejectListeners && wakeChunk(response, rejectListeners, chunk.reason);\n       }\n   }\n }\n function createResolvedIteratorResultChunk(response, value, done) {\n-  return new Chunk(\n+  var $jscomp$compprop4 = {};\n+  return new ReactPromise(\n     \"resolved_model\",\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n-    -1,\n-    response\n+    (($jscomp$compprop4.id = -1),\n+    ($jscomp$compprop4[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop4)\n   );\n }\n-function resolveIteratorResultChunk(chunk, value, done) {\n+function resolveIteratorResultChunk(response, chunk, value, done) {\n   resolveModelChunk(\n+    response,\n     chunk,\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n     -1\n   );\n }\n-function loadServerReference$1(\n-  response,\n-  id,\n-  bound,\n-  parentChunk,\n-  parentObject,\n-  key\n-) {\n+function loadServerReference$1(response, metaData, parentObject, key) {\n+  var id = metaData.id;\n+  if (\"string\" !== typeof id) return null;\n   var serverReference = resolveServerReference(response._bundlerConfig, id);\n-  id = preloadModule(serverReference);\n-  if (bound)\n-    bound = Promise.all([bound, id]).then(function (_ref) {\n-      _ref = _ref[0];\n-      var fn = requireModule(serverReference);\n-      return fn.bind.apply(fn, [null].concat(_ref));\n-    });\n-  else if (id)\n-    bound = Promise.resolve(id).then(function () {\n-      return requireModule(serverReference);\n-    });\n+  id = metaData.bound;\n+  var promise = preloadModule(serverReference);\n+  if (promise)\n+    id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+  else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n   else return requireModule(serverReference);\n-  bound.then(\n-    createModelResolver(\n-      parentChunk,\n-      parentObject,\n-      key,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(parentChunk)\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n+  promise.then(\n+    function () {\n+      var resolvedValue = requireModule(serverReference);\n+      if (metaData.bound) {\n+        var promiseValue = metaData.bound.value;\n+        promiseValue = Array.isArray(promiseValue) ? promiseValue.slice(0) : [];\n+        promiseValue.unshift(null);\n+        resolvedValue = resolvedValue.bind.apply(resolvedValue, promiseValue);\n+      }\n+      parentObject[key] = resolvedValue;\n+      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((resolvedValue = handler.chunk),\n+        null !== resolvedValue &&\n+          \"blocked\" === resolvedValue.status &&\n+          ((promiseValue = resolvedValue.value),\n+          (resolvedValue.status = \"fulfilled\"),\n+          (resolvedValue.value = handler.value),\n+          null !== promiseValue &&\n+            wakeChunk(response, promiseValue, handler.value)));\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n@@ -2410,53 +2500,65 @@ function reviveModel(response, parentObj, parentKey, value, reference) {\n               ? reference + \":\" + i\n               : void 0),\n           (parentObj = reviveModel(response, value, i, value[i], parentObj)),\n-          void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+          void 0 !== parentObj || \"__proto__\" === i\n+            ? (value[i] = parentObj)\n+            : delete value[i]);\n   return value;\n }\n-var initializingChunk = null,\n-  initializingChunkBlockedModel = null;\n+var initializingHandler = null;\n function initializeModelChunk(chunk) {\n-  var prevChunk = initializingChunk,\n-    prevBlocked = initializingChunkBlockedModel;\n-  initializingChunk = chunk;\n-  initializingChunkBlockedModel = null;\n-  var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-    resolvedModel = chunk.value;\n-  chunk.status = \"cyclic\";\n+  var prevHandler = initializingHandler;\n+  initializingHandler = null;\n+  var _chunk$reason = chunk.reason,\n+    response = _chunk$reason[RESPONSE_SYMBOL];\n+  _chunk$reason = _chunk$reason.id;\n+  _chunk$reason = -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+  var resolvedModel = chunk.value;\n+  chunk.status = \"blocked\";\n   chunk.value = null;\n   chunk.reason = null;\n   try {\n     var rawModel = JSON.parse(resolvedModel),\n       value = reviveModel(\n-        chunk._response,\n+        response,\n         { \"\": rawModel },\n         \"\",\n         rawModel,\n-        rootReference\n-      );\n-    if (\n-      null !== initializingChunkBlockedModel &&\n-      0 < initializingChunkBlockedModel.deps\n-    )\n-      (initializingChunkBlockedModel.value = value), (chunk.status = \"blocked\");\n-    else {\n-      var resolveListeners = chunk.value;\n-      chunk.status = \"fulfilled\";\n-      chunk.value = value;\n-      null !== resolveListeners && wakeChunk(resolveListeners, value);\n+        _chunk$reason\n+      ),\n+      resolveListeners = chunk.value;\n+    if (null !== resolveListeners)\n+      for (\n+        chunk.value = null, chunk.reason = null, rawModel = 0;\n+        rawModel < resolveListeners.length;\n+        rawModel++\n+      ) {\n+        var listener = resolveListeners[rawModel];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n+    if (null !== initializingHandler) {\n+      if (initializingHandler.errored) throw initializingHandler.reason;\n+      if (0 < initializingHandler.deps) {\n+        initializingHandler.value = value;\n+        initializingHandler.chunk = chunk;\n+        return;\n+      }\n     }\n+    chunk.status = \"fulfilled\";\n+    chunk.value = value;\n   } catch (error) {\n     (chunk.status = \"rejected\"), (chunk.reason = error);\n   } finally {\n-    (initializingChunk = prevChunk),\n-      (initializingChunkBlockedModel = prevBlocked);\n+    initializingHandler = prevHandler;\n   }\n }\n function reportGlobalError(response, error) {\n   response._closed = !0;\n   response._closedReason = error;\n   response._chunks.forEach(function (chunk) {\n-    \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+    \"pending\" === chunk.status && triggerErrorOnChunk(response, chunk, error);\n   });\n }\n function getChunk(response, id) {\n@@ -2465,48 +2567,104 @@ function getChunk(response, id) {\n   chunk ||\n     ((chunk = response._formData.get(response._prefix + id)),\n     (chunk =\n-      null != chunk\n-        ? new Chunk(\"resolved_model\", chunk, id, response)\n+      \"string\" === typeof chunk\n+        ? createResolvedModelChunk(response, chunk, id)\n         : response._closed\n-          ? new Chunk(\"rejected\", null, response._closedReason, response)\n-          : createPendingChunk(response)),\n+          ? new ReactPromise(\"rejected\", null, response._closedReason)\n+          : new ReactPromise(\"pending\", null, null)),\n     chunks.set(id, chunk));\n   return chunk;\n }\n-function createModelResolver(\n-  chunk,\n+function fulfillReference(response, reference, value) {\n+  for (\n+    var handler = reference.handler,\n+      parentObject = reference.parentObject,\n+      key = reference.key,\n+      map = reference.map,\n+      path = reference.path,\n+      i = 1;\n+    i < path.length;\n+    i++\n+  ) {\n+    for (; value instanceof ReactPromise; ) {\n+      switch (value.status) {\n+        case \"resolved_model\":\n+          initializeModelChunk(value);\n+      }\n+      switch (value.status) {\n+        case \"fulfilled\":\n+          value = value.value;\n+          continue;\n+        case \"blocked\":\n+        case \"pending\":\n+          path.splice(0, i - 1);\n+          null === value.value\n+            ? (value.value = [reference])\n+            : value.value.push(reference);\n+          null === value.reason\n+            ? (value.reason = [reference])\n+            : value.reason.push(reference);\n+          return;\n+        default:\n+          rejectReference(response, reference.handler, value.reason);\n+          return;\n+      }\n+    }\n+    var name = path[i];\n+    \"object\" === typeof value &&\n+      hasOwnProperty.call(value, name) &&\n+      (value = value[name]);\n+  }\n+  reference = map(response, value, parentObject, key);\n+  parentObject[key] = reference;\n+  \"\" === key && null === handler.value && (handler.value = reference);\n+  handler.deps--;\n+  0 === handler.deps &&\n+    ((parentObject = handler.chunk),\n+    null !== parentObject &&\n+      \"blocked\" === parentObject.status &&\n+      ((key = parentObject.value),\n+      (parentObject.status = \"fulfilled\"),\n+      (parentObject.value = handler.value),\n+      (parentObject.reason = handler.reason),\n+      null !== key && wakeChunk(response, key, handler.value)));\n+}\n+function rejectReference(response, handler, error) {\n+  handler.errored ||\n+    ((handler.errored = !0),\n+    (handler.value = null),\n+    (handler.reason = error),\n+    (handler = handler.chunk),\n+    null !== handler &&\n+      \"blocked\" === handler.status &&\n+      triggerErrorOnChunk(response, handler, error));\n+}\n+function waitForReference(\n+  referencedChunk,\n   parentObject,\n   key,\n-  cyclic,\n   response,\n   map,\n   path\n ) {\n-  if (initializingChunkBlockedModel) {\n-    var blocked = initializingChunkBlockedModel;\n-    cyclic || blocked.deps++;\n-  } else\n-    blocked = initializingChunkBlockedModel = {\n-      deps: cyclic ? 0 : 1,\n-      value: null\n-    };\n-  return function (value) {\n-    for (var i = 1; i < path.length; i++) value = value[path[i]];\n-    parentObject[key] = map(response, value);\n-    \"\" === key && null === blocked.value && (blocked.value = parentObject[key]);\n-    blocked.deps--;\n-    0 === blocked.deps &&\n-      \"blocked\" === chunk.status &&\n-      ((value = chunk.value),\n-      (chunk.status = \"fulfilled\"),\n-      (chunk.value = blocked.value),\n-      null !== value && wakeChunk(value, blocked.value));\n-  };\n-}\n-function createModelReject(chunk) {\n-  return function (error) {\n-    return triggerErrorOnChunk(chunk, error);\n+  initializingHandler\n+    ? ((response = initializingHandler), response.deps++)\n+    : (response = initializingHandler =\n+        { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+  parentObject = {\n+    handler: response,\n+    parentObject: parentObject,\n+    key: key,\n+    map: map,\n+    path: path\n   };\n+  null === referencedChunk.value\n+    ? (referencedChunk.value = [parentObject])\n+    : referencedChunk.value.push(parentObject);\n+  null === referencedChunk.reason\n+    ? (referencedChunk.reason = [parentObject])\n+    : referencedChunk.reason.push(parentObject);\n+  return null;\n }\n function getOutlinedModel(response, reference, parentObject, key, map) {\n   reference = reference.split(\":\");\n@@ -2518,29 +2676,68 @@ function getOutlinedModel(response, reference, parentObject, key, map) {\n   }\n   switch (id.status) {\n     case \"fulfilled\":\n-      parentObject = id.value;\n-      for (key = 1; key < reference.length; key++)\n-        parentObject = parentObject[reference[key]];\n-      return map(response, parentObject);\n+      var value = id.value;\n+      for (id = 1; id < reference.length; id++) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              break;\n+            case \"blocked\":\n+            case \"pending\":\n+              return waitForReference(\n+                value,\n+                parentObject,\n+                key,\n+                response,\n+                map,\n+                reference.slice(id - 1)\n+              );\n+            default:\n+              return (\n+                initializingHandler\n+                  ? ((initializingHandler.errored = !0),\n+                    (initializingHandler.value = null),\n+                    (initializingHandler.reason = value.reason))\n+                  : (initializingHandler = {\n+                      chunk: null,\n+                      value: null,\n+                      reason: value.reason,\n+                      deps: 0,\n+                      errored: !0\n+                    }),\n+                null\n+              );\n+          }\n+        }\n+        var name = reference[id];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      return map(response, value, parentObject, key);\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      var parentChunk = initializingChunk;\n-      id.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          \"cyclic\" === id.status,\n-          response,\n-          map,\n-          reference\n-        ),\n-        createModelReject(parentChunk)\n-      );\n-      return null;\n+      return waitForReference(id, parentObject, key, response, map, reference);\n     default:\n-      throw id.reason;\n+      return (\n+        initializingHandler\n+          ? ((initializingHandler.errored = !0),\n+            (initializingHandler.value = null),\n+            (initializingHandler.reason = id.reason))\n+          : (initializingHandler = {\n+              chunk: null,\n+              value: null,\n+              reason: id.reason,\n+              deps: 0,\n+              errored: !0\n+            }),\n+        null\n+      );\n   }\n }\n function createMap(response, model) {\n@@ -2564,38 +2761,63 @@ function parseTypedArray(\n   parentKey\n ) {\n   reference = parseInt(reference.slice(2), 16);\n-  reference = response._formData.get(response._prefix + reference);\n-  reference =\n-    constructor === ArrayBuffer\n-      ? reference.arrayBuffer()\n-      : reference.arrayBuffer().then(function (buffer) {\n-          return new constructor(buffer);\n-        });\n-  bytesPerElement = initializingChunk;\n+  reference = response._formData\n+    .get(response._prefix + reference)\n+    .arrayBuffer();\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n   reference.then(\n-    createModelResolver(\n-      bytesPerElement,\n-      parentObject,\n-      parentKey,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(bytesPerElement)\n+    function (buffer) {\n+      buffer = constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+      parentObject[parentKey] = buffer;\n+      \"\" === parentKey && null === handler.value && (handler.value = buffer);\n+      handler.deps--;\n+      if (\n+        0 === handler.deps &&\n+        ((buffer = handler.chunk),\n+        null !== buffer && \"blocked\" === buffer.status)\n+      ) {\n+        var resolveListeners = buffer.value;\n+        buffer.status = \"fulfilled\";\n+        buffer.value = handler.value;\n+        null !== resolveListeners &&\n+          wakeChunk(response, resolveListeners, handler.value);\n+      }\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n function resolveStream(response, id, stream, controller) {\n   var chunks = response._chunks;\n-  stream = new Chunk(\"fulfilled\", stream, controller, response);\n+  stream = new ReactPromise(\"fulfilled\", stream, controller);\n   chunks.set(id, stream);\n   response = response._formData.getAll(response._prefix + id);\n   for (id = 0; id < response.length; id++)\n     (chunks = response[id]),\n-      \"C\" === chunks[0]\n-        ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n-        : controller.enqueueModel(chunks);\n+      \"string\" === typeof chunks &&\n+        (\"C\" === chunks[0]\n+          ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n+          : controller.enqueueModel(chunks));\n }\n function parseReadableStream(response, reference, type) {\n   reference = parseInt(reference.slice(2), 16);\n@@ -2610,7 +2832,7 @@ function parseReadableStream(response, reference, type) {\n   resolveStream(response, reference, type, {\n     enqueueModel: function (json) {\n       if (null === previousBlockedChunk) {\n-        var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+        var chunk = createResolvedModelChunk(response, json, -1);\n         initializeModelChunk(chunk);\n         \"fulfilled\" === chunk.status\n           ? controller.enqueue(chunk.value)\n@@ -2625,19 +2847,19 @@ function parseReadableStream(response, reference, type) {\n             (previousBlockedChunk = chunk));\n       } else {\n         chunk = previousBlockedChunk;\n-        var chunk$26 = createPendingChunk(response);\n-        chunk$26.then(\n+        var chunk$30 = new ReactPromise(\"pending\", null, null);\n+        chunk$30.then(\n           function (v) {\n             return controller.enqueue(v);\n           },\n           function (e) {\n             return controller.error(e);\n           }\n         );\n-        previousBlockedChunk = chunk$26;\n+        previousBlockedChunk = chunk$30;\n         chunk.then(function () {\n-          previousBlockedChunk === chunk$26 && (previousBlockedChunk = null);\n-          resolveModelChunk(chunk$26, json, -1);\n+          previousBlockedChunk === chunk$30 && (previousBlockedChunk = null);\n+          resolveModelChunk(response, chunk$30, json, -1);\n         });\n       }\n     },\n@@ -2677,9 +2899,9 @@ function parseAsyncIterable(response, reference, iterator) {\n   var buffer = [],\n     closed = !1,\n     nextWriteIndex = 0,\n-    $jscomp$compprop2 = {};\n-  $jscomp$compprop2 =\n-    (($jscomp$compprop2[ASYNC_ITERATOR] = function () {\n+    $jscomp$compprop5 = {};\n+  $jscomp$compprop5 =\n+    (($jscomp$compprop5[ASYNC_ITERATOR] = function () {\n       var nextReadIndex = 0;\n       return createIterator(function (arg) {\n         if (void 0 !== arg)\n@@ -2688,19 +2910,18 @@ function parseAsyncIterable(response, reference, iterator) {\n           );\n         if (nextReadIndex === buffer.length) {\n           if (closed)\n-            return new Chunk(\n+            return new ReactPromise(\n               \"fulfilled\",\n               { done: !0, value: void 0 },\n-              null,\n-              response\n+              null\n             );\n-          buffer[nextReadIndex] = createPendingChunk(response);\n+          buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n         }\n         return buffer[nextReadIndex++];\n       });\n     }),\n-    $jscomp$compprop2);\n-  iterator = iterator ? $jscomp$compprop2[ASYNC_ITERATOR]() : $jscomp$compprop2;\n+    $jscomp$compprop5);\n+  iterator = iterator ? $jscomp$compprop5[ASYNC_ITERATOR]() : $jscomp$compprop5;\n   resolveStream(response, reference, iterator, {\n     enqueueModel: function (value) {\n       nextWriteIndex === buffer.length\n@@ -2709,7 +2930,12 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !1\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !1\n+          );\n       nextWriteIndex++;\n     },\n     close: function (value) {\n@@ -2720,9 +2946,15 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !0\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !0\n+          );\n       for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n         resolveIteratorResultChunk(\n+          response,\n           buffer[nextWriteIndex++],\n           '\"$undefined\"',\n           !0\n@@ -2732,11 +2964,11 @@ function parseAsyncIterable(response, reference, iterator) {\n       closed = !0;\n       for (\n         nextWriteIndex === buffer.length &&\n-        (buffer[nextWriteIndex] = createPendingChunk(response));\n+        (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n         nextWriteIndex < buffer.length;\n \n       )\n-        triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+        triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n     }\n   });\n   return iterator;\n@@ -2751,15 +2983,7 @@ function parseModelString(response, obj, key, value, reference) {\n       case \"F\":\n         return (\n           (value = value.slice(2)),\n-          (value = getOutlinedModel(response, value, obj, key, createModel)),\n-          loadServerReference$1(\n-            response,\n-            value.id,\n-            value.bound,\n-            initializingChunk,\n-            obj,\n-            key\n-          )\n+          getOutlinedModel(response, value, obj, key, loadServerReference$1)\n         );\n       case \"T\":\n         if (void 0 === reference || void 0 === response._temporaryReferences)"
        },
        {
            "sha": "4c0f55d61145dcd24df3f15038ea775fd72156d9",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.edge.development.js",
            "status": "modified",
            "additions": 438,
            "deletions": 204,
            "changes": 642,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.edge.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -3972,37 +3972,65 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n-    }\n-    function Chunk(status, value, reason, response) {\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n+    }\n+    function ReactPromise(status, value, reason) {\n       this.status = status;\n       this.value = value;\n       this.reason = reason;\n-      this._response = response;\n     }\n-    function createPendingChunk(response) {\n-      return new Chunk(\"pending\", null, null, response);\n+    function wakeChunk(response, listeners, value) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n     }\n-    function wakeChunk(listeners, value) {\n-      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+    function rejectChunk(response, listeners, error) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(error)\n+          : rejectReference(response, listener.handler, error);\n+      }\n     }\n-    function triggerErrorOnChunk(chunk, error) {\n+    function resolveBlockedCycle(resolvedChunk, reference) {\n+      var referencedChunk = reference.handler.chunk;\n+      if (null === referencedChunk) return null;\n+      if (referencedChunk === resolvedChunk) return reference.handler;\n+      reference = referencedChunk.value;\n+      if (null !== reference)\n+        for (\n+          referencedChunk = 0;\n+          referencedChunk < reference.length;\n+          referencedChunk++\n+        ) {\n+          var listener = reference[referencedChunk];\n+          if (\n+            \"function\" !== typeof listener &&\n+            ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+            null !== listener)\n+          )\n+            return listener;\n+        }\n+      return null;\n+    }\n+    function triggerErrorOnChunk(response, chunk, error) {\n       if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n         chunk.reason.error(error);\n       else {\n         var listeners = chunk.reason;\n         chunk.status = \"rejected\";\n         chunk.reason = error;\n-        null !== listeners && wakeChunk(listeners, error);\n+        null !== listeners && rejectChunk(response, listeners, error);\n       }\n     }\n-    function resolveModelChunk(chunk, value, id) {\n+    function resolveModelChunk(response, chunk, value, id) {\n       if (\"pending\" !== chunk.status)\n         (chunk = chunk.reason),\n           \"C\" === value[0]\n@@ -4013,81 +4041,142 @@\n           rejectListeners = chunk.reason;\n         chunk.status = \"resolved_model\";\n         chunk.value = value;\n-        chunk.reason = id;\n+        chunk.reason = _defineProperty({ id: id }, RESPONSE_SYMBOL, response);\n         if (null !== resolveListeners)\n-          switch ((initializeModelChunk(chunk), chunk.status)) {\n+          a: switch ((initializeModelChunk(chunk), chunk.status)) {\n             case \"fulfilled\":\n-              wakeChunk(resolveListeners, chunk.value);\n+              wakeChunk(response, resolveListeners, chunk.value);\n               break;\n-            case \"pending\":\n             case \"blocked\":\n-            case \"cyclic\":\n+              for (value = 0; value < resolveListeners.length; value++)\n+                if (\n+                  ((id = resolveListeners[value]), \"function\" !== typeof id)\n+                ) {\n+                  var cyclicHandler = resolveBlockedCycle(chunk, id);\n+                  if (null !== cyclicHandler)\n+                    switch (\n+                      (fulfillReference(response, id, cyclicHandler.value),\n+                      resolveListeners.splice(value, 1),\n+                      value--,\n+                      null !== rejectListeners &&\n+                        ((id = rejectListeners.indexOf(id)),\n+                        -1 !== id && rejectListeners.splice(id, 1)),\n+                      chunk.status)\n+                    ) {\n+                      case \"fulfilled\":\n+                        wakeChunk(response, resolveListeners, chunk.value);\n+                        break a;\n+                      case \"rejected\":\n+                        null !== rejectListeners &&\n+                          rejectChunk(response, rejectListeners, chunk.reason);\n+                        break a;\n+                    }\n+                }\n+            case \"pending\":\n               if (chunk.value)\n-                for (value = 0; value < resolveListeners.length; value++)\n-                  chunk.value.push(resolveListeners[value]);\n+                for (\n+                  response = 0;\n+                  response < resolveListeners.length;\n+                  response++\n+                )\n+                  chunk.value.push(resolveListeners[response]);\n               else chunk.value = resolveListeners;\n               if (chunk.reason) {\n                 if (rejectListeners)\n-                  for (value = 0; value < rejectListeners.length; value++)\n-                    chunk.reason.push(rejectListeners[value]);\n+                  for (\n+                    resolveListeners = 0;\n+                    resolveListeners < rejectListeners.length;\n+                    resolveListeners++\n+                  )\n+                    chunk.reason.push(rejectListeners[resolveListeners]);\n               } else chunk.reason = rejectListeners;\n               break;\n             case \"rejected\":\n-              rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+              rejectListeners &&\n+                wakeChunk(response, rejectListeners, chunk.reason);\n           }\n       }\n     }\n     function createResolvedIteratorResultChunk(response, value, done) {\n-      return new Chunk(\n+      return new ReactPromise(\n         \"resolved_model\",\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n-        -1,\n-        response\n+        _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n       );\n     }\n-    function resolveIteratorResultChunk(chunk, value, done) {\n+    function resolveIteratorResultChunk(response, chunk, value, done) {\n       resolveModelChunk(\n+        response,\n         chunk,\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n         -1\n       );\n     }\n-    function loadServerReference$1(\n-      response,\n-      id,\n-      bound,\n-      parentChunk,\n-      parentObject,\n-      key\n-    ) {\n+    function loadServerReference$1(response, metaData, parentObject, key) {\n+      var id = metaData.id;\n+      if (\"string\" !== typeof id) return null;\n       var serverReference = resolveServerReference(response._bundlerConfig, id);\n-      id = preloadModule(serverReference);\n-      if (bound)\n-        bound = Promise.all([bound, id]).then(function (_ref) {\n-          _ref = _ref[0];\n-          var fn = requireModule(serverReference);\n-          return fn.bind.apply(fn, [null].concat(_ref));\n-        });\n-      else if (id)\n-        bound = Promise.resolve(id).then(function () {\n-          return requireModule(serverReference);\n-        });\n+      id = metaData.bound;\n+      var promise = preloadModule(serverReference);\n+      if (promise)\n+        id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+      else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n       else return requireModule(serverReference);\n-      bound.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(parentChunk)\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n+      promise.then(\n+        function () {\n+          var resolvedValue = requireModule(serverReference);\n+          if (metaData.bound) {\n+            var promiseValue = metaData.bound.value;\n+            promiseValue = Array.isArray(promiseValue)\n+              ? promiseValue.slice(0)\n+              : [];\n+            promiseValue.unshift(null);\n+            resolvedValue = resolvedValue.bind.apply(\n+              resolvedValue,\n+              promiseValue\n+            );\n+          }\n+          parentObject[key] = resolvedValue;\n+          \"\" === key &&\n+            null === handler.value &&\n+            (handler.value = resolvedValue);\n+          handler.deps--;\n+          0 === handler.deps &&\n+            ((resolvedValue = handler.chunk),\n+            null !== resolvedValue &&\n+              \"blocked\" === resolvedValue.status &&\n+              ((promiseValue = resolvedValue.value),\n+              (resolvedValue.status = \"fulfilled\"),\n+              (resolvedValue.value = handler.value),\n+              null !== promiseValue &&\n+                wakeChunk(response, promiseValue, handler.value)));\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n@@ -4129,53 +4218,66 @@\n                 value[i],\n                 parentObj\n               )),\n-              void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+              void 0 !== parentObj || \"__proto__\" === i\n+                ? (value[i] = parentObj)\n+                : delete value[i]);\n       return value;\n     }\n     function initializeModelChunk(chunk) {\n-      var prevChunk = initializingChunk,\n-        prevBlocked = initializingChunkBlockedModel;\n-      initializingChunk = chunk;\n-      initializingChunkBlockedModel = null;\n-      var rootReference =\n-          -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-        resolvedModel = chunk.value;\n-      chunk.status = \"cyclic\";\n+      var prevHandler = initializingHandler;\n+      initializingHandler = null;\n+      var _chunk$reason = chunk.reason,\n+        response = _chunk$reason[RESPONSE_SYMBOL];\n+      _chunk$reason = _chunk$reason.id;\n+      _chunk$reason =\n+        -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+      var resolvedModel = chunk.value;\n+      chunk.status = \"blocked\";\n       chunk.value = null;\n       chunk.reason = null;\n       try {\n         var rawModel = JSON.parse(resolvedModel),\n           value = reviveModel(\n-            chunk._response,\n+            response,\n             { \"\": rawModel },\n             \"\",\n             rawModel,\n-            rootReference\n-          );\n-        if (\n-          null !== initializingChunkBlockedModel &&\n-          0 < initializingChunkBlockedModel.deps\n-        )\n-          (initializingChunkBlockedModel.value = value),\n-            (chunk.status = \"blocked\");\n-        else {\n-          var resolveListeners = chunk.value;\n-          chunk.status = \"fulfilled\";\n-          chunk.value = value;\n-          null !== resolveListeners && wakeChunk(resolveListeners, value);\n+            _chunk$reason\n+          ),\n+          resolveListeners = chunk.value;\n+        if (null !== resolveListeners)\n+          for (\n+            chunk.value = null, chunk.reason = null, rawModel = 0;\n+            rawModel < resolveListeners.length;\n+            rawModel++\n+          ) {\n+            var listener = resolveListeners[rawModel];\n+            \"function\" === typeof listener\n+              ? listener(value)\n+              : fulfillReference(response, listener, value);\n+          }\n+        if (null !== initializingHandler) {\n+          if (initializingHandler.errored) throw initializingHandler.reason;\n+          if (0 < initializingHandler.deps) {\n+            initializingHandler.value = value;\n+            initializingHandler.chunk = chunk;\n+            return;\n+          }\n         }\n+        chunk.status = \"fulfilled\";\n+        chunk.value = value;\n       } catch (error) {\n         (chunk.status = \"rejected\"), (chunk.reason = error);\n       } finally {\n-        (initializingChunk = prevChunk),\n-          (initializingChunkBlockedModel = prevBlocked);\n+        initializingHandler = prevHandler;\n       }\n     }\n     function reportGlobalError(response, error) {\n       response._closed = !0;\n       response._closedReason = error;\n       response._chunks.forEach(function (chunk) {\n-        \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+        \"pending\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n       });\n     }\n     function getChunk(response, id) {\n@@ -4184,50 +4286,108 @@\n       chunk ||\n         ((chunk = response._formData.get(response._prefix + id)),\n         (chunk =\n-          null != chunk\n-            ? new Chunk(\"resolved_model\", chunk, id, response)\n+          \"string\" === typeof chunk\n+            ? new ReactPromise(\n+                \"resolved_model\",\n+                chunk,\n+                _defineProperty({ id: id }, RESPONSE_SYMBOL, response)\n+              )\n             : response._closed\n-              ? new Chunk(\"rejected\", null, response._closedReason, response)\n-              : createPendingChunk(response)),\n+              ? new ReactPromise(\"rejected\", null, response._closedReason)\n+              : new ReactPromise(\"pending\", null, null)),\n         chunks.set(id, chunk));\n       return chunk;\n     }\n-    function createModelResolver(\n-      chunk,\n+    function fulfillReference(response, reference, value) {\n+      for (\n+        var handler = reference.handler,\n+          parentObject = reference.parentObject,\n+          key = reference.key,\n+          map = reference.map,\n+          path = reference.path,\n+          i = 1;\n+        i < path.length;\n+        i++\n+      ) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              continue;\n+            case \"blocked\":\n+            case \"pending\":\n+              path.splice(0, i - 1);\n+              null === value.value\n+                ? (value.value = [reference])\n+                : value.value.push(reference);\n+              null === value.reason\n+                ? (value.reason = [reference])\n+                : value.reason.push(reference);\n+              return;\n+            default:\n+              rejectReference(response, reference.handler, value.reason);\n+              return;\n+          }\n+        }\n+        var name = path[i];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      reference = map(response, value, parentObject, key);\n+      parentObject[key] = reference;\n+      \"\" === key && null === handler.value && (handler.value = reference);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((parentObject = handler.chunk),\n+        null !== parentObject &&\n+          \"blocked\" === parentObject.status &&\n+          ((key = parentObject.value),\n+          (parentObject.status = \"fulfilled\"),\n+          (parentObject.value = handler.value),\n+          (parentObject.reason = handler.reason),\n+          null !== key && wakeChunk(response, key, handler.value)));\n+    }\n+    function rejectReference(response, handler, error) {\n+      handler.errored ||\n+        ((handler.errored = !0),\n+        (handler.value = null),\n+        (handler.reason = error),\n+        (handler = handler.chunk),\n+        null !== handler &&\n+          \"blocked\" === handler.status &&\n+          triggerErrorOnChunk(response, handler, error));\n+    }\n+    function waitForReference(\n+      referencedChunk,\n       parentObject,\n       key,\n-      cyclic,\n       response,\n       map,\n       path\n     ) {\n-      if (initializingChunkBlockedModel) {\n-        var blocked = initializingChunkBlockedModel;\n-        cyclic || blocked.deps++;\n-      } else\n-        blocked = initializingChunkBlockedModel = {\n-          deps: cyclic ? 0 : 1,\n-          value: null\n-        };\n-      return function (value) {\n-        for (var i = 1; i < path.length; i++) value = value[path[i]];\n-        parentObject[key] = map(response, value);\n-        \"\" === key &&\n-          null === blocked.value &&\n-          (blocked.value = parentObject[key]);\n-        blocked.deps--;\n-        0 === blocked.deps &&\n-          \"blocked\" === chunk.status &&\n-          ((value = chunk.value),\n-          (chunk.status = \"fulfilled\"),\n-          (chunk.value = blocked.value),\n-          null !== value && wakeChunk(value, blocked.value));\n-      };\n-    }\n-    function createModelReject(chunk) {\n-      return function (error) {\n-        return triggerErrorOnChunk(chunk, error);\n+      initializingHandler\n+        ? ((response = initializingHandler), response.deps++)\n+        : (response = initializingHandler =\n+            { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+      parentObject = {\n+        handler: response,\n+        parentObject: parentObject,\n+        key: key,\n+        map: map,\n+        path: path\n       };\n+      null === referencedChunk.value\n+        ? (referencedChunk.value = [parentObject])\n+        : referencedChunk.value.push(parentObject);\n+      null === referencedChunk.reason\n+        ? (referencedChunk.reason = [parentObject])\n+        : referencedChunk.reason.push(parentObject);\n+      return null;\n     }\n     function getOutlinedModel(response, reference, parentObject, key, map) {\n       reference = reference.split(\":\");\n@@ -4239,29 +4399,75 @@\n       }\n       switch (id.status) {\n         case \"fulfilled\":\n-          parentObject = id.value;\n-          for (key = 1; key < reference.length; key++)\n-            parentObject = parentObject[reference[key]];\n-          return map(response, parentObject);\n+          var value = id.value;\n+          for (id = 1; id < reference.length; id++) {\n+            for (; value instanceof ReactPromise; ) {\n+              switch (value.status) {\n+                case \"resolved_model\":\n+                  initializeModelChunk(value);\n+              }\n+              switch (value.status) {\n+                case \"fulfilled\":\n+                  value = value.value;\n+                  break;\n+                case \"blocked\":\n+                case \"pending\":\n+                  return waitForReference(\n+                    value,\n+                    parentObject,\n+                    key,\n+                    response,\n+                    map,\n+                    reference.slice(id - 1)\n+                  );\n+                default:\n+                  return (\n+                    initializingHandler\n+                      ? ((initializingHandler.errored = !0),\n+                        (initializingHandler.value = null),\n+                        (initializingHandler.reason = value.reason))\n+                      : (initializingHandler = {\n+                          chunk: null,\n+                          value: null,\n+                          reason: value.reason,\n+                          deps: 0,\n+                          errored: !0\n+                        }),\n+                    null\n+                  );\n+              }\n+            }\n+            var name = reference[id];\n+            \"object\" === typeof value &&\n+              hasOwnProperty.call(value, name) &&\n+              (value = value[name]);\n+          }\n+          return map(response, value, parentObject, key);\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          var parentChunk = initializingChunk;\n-          id.then(\n-            createModelResolver(\n-              parentChunk,\n-              parentObject,\n-              key,\n-              \"cyclic\" === id.status,\n-              response,\n-              map,\n-              reference\n-            ),\n-            createModelReject(parentChunk)\n+          return waitForReference(\n+            id,\n+            parentObject,\n+            key,\n+            response,\n+            map,\n+            reference\n           );\n-          return null;\n         default:\n-          throw id.reason;\n+          return (\n+            initializingHandler\n+              ? ((initializingHandler.errored = !0),\n+                (initializingHandler.value = null),\n+                (initializingHandler.reason = id.reason))\n+              : (initializingHandler = {\n+                  chunk: null,\n+                  value: null,\n+                  reason: id.reason,\n+                  deps: 0,\n+                  errored: !0\n+                }),\n+            null\n+          );\n       }\n     }\n     function createMap(response, model) {\n@@ -4285,40 +4491,68 @@\n       parentKey\n     ) {\n       reference = parseInt(reference.slice(2), 16);\n-      reference = response._formData.get(response._prefix + reference);\n-      reference =\n-        constructor === ArrayBuffer\n-          ? reference.arrayBuffer()\n-          : reference.arrayBuffer().then(function (buffer) {\n-              return new constructor(buffer);\n-            });\n-      bytesPerElement = initializingChunk;\n+      reference = response._formData\n+        .get(response._prefix + reference)\n+        .arrayBuffer();\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n       reference.then(\n-        createModelResolver(\n-          bytesPerElement,\n-          parentObject,\n-          parentKey,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(bytesPerElement)\n+        function (buffer) {\n+          buffer =\n+            constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+          parentObject[parentKey] = buffer;\n+          \"\" === parentKey &&\n+            null === handler.value &&\n+            (handler.value = buffer);\n+          handler.deps--;\n+          if (\n+            0 === handler.deps &&\n+            ((buffer = handler.chunk),\n+            null !== buffer && \"blocked\" === buffer.status)\n+          ) {\n+            var resolveListeners = buffer.value;\n+            buffer.status = \"fulfilled\";\n+            buffer.value = handler.value;\n+            null !== resolveListeners &&\n+              wakeChunk(response, resolveListeners, handler.value);\n+          }\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n     function resolveStream(response, id, stream, controller) {\n       var chunks = response._chunks;\n-      stream = new Chunk(\"fulfilled\", stream, controller, response);\n+      stream = new ReactPromise(\"fulfilled\", stream, controller);\n       chunks.set(id, stream);\n       response = response._formData.getAll(response._prefix + id);\n       for (id = 0; id < response.length; id++)\n         (chunks = response[id]),\n-          \"C\" === chunks[0]\n-            ? controller.close(\n-                \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n-              )\n-            : controller.enqueueModel(chunks);\n+          \"string\" === typeof chunks &&\n+            (\"C\" === chunks[0]\n+              ? controller.close(\n+                  \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n+                )\n+              : controller.enqueueModel(chunks));\n     }\n     function parseReadableStream(response, reference, type) {\n       reference = parseInt(reference.slice(2), 16);\n@@ -4333,7 +4567,11 @@\n       resolveStream(response, reference, type, {\n         enqueueModel: function (json) {\n           if (null === previousBlockedChunk) {\n-            var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+            var chunk = new ReactPromise(\n+              \"resolved_model\",\n+              json,\n+              _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n+            );\n             initializeModelChunk(chunk);\n             \"fulfilled\" === chunk.status\n               ? controller.enqueue(chunk.value)\n@@ -4348,7 +4586,7 @@\n                 (previousBlockedChunk = chunk));\n           } else {\n             chunk = previousBlockedChunk;\n-            var _chunk = createPendingChunk(response);\n+            var _chunk = new ReactPromise(\"pending\", null, null);\n             _chunk.then(\n               function (v) {\n                 return controller.enqueue(v);\n@@ -4360,7 +4598,7 @@\n             previousBlockedChunk = _chunk;\n             chunk.then(function () {\n               previousBlockedChunk === _chunk && (previousBlockedChunk = null);\n-              resolveModelChunk(_chunk, json, -1);\n+              resolveModelChunk(response, _chunk, json, -1);\n             });\n           }\n         },\n@@ -4409,13 +4647,12 @@\n               );\n             if (nextReadIndex === buffer.length) {\n               if (closed)\n-                return new Chunk(\n+                return new ReactPromise(\n                   \"fulfilled\",\n                   { done: !0, value: void 0 },\n-                  null,\n-                  response\n+                  null\n                 );\n-              buffer[nextReadIndex] = createPendingChunk(response);\n+              buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n             }\n             return buffer[nextReadIndex++];\n           });\n@@ -4429,7 +4666,12 @@\n                 value,\n                 !1\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !1\n+              );\n           nextWriteIndex++;\n         },\n         close: function (value) {\n@@ -4440,9 +4682,15 @@\n                 value,\n                 !0\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !0\n+              );\n           for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n             resolveIteratorResultChunk(\n+              response,\n               buffer[nextWriteIndex++],\n               '\"$undefined\"',\n               !0\n@@ -4452,11 +4700,11 @@\n           closed = !0;\n           for (\n             nextWriteIndex === buffer.length &&\n-            (buffer[nextWriteIndex] = createPendingChunk(response));\n+            (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n             nextWriteIndex < buffer.length;\n \n           )\n-            triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n         }\n       });\n       return iterator;\n@@ -4473,21 +4721,7 @@\n           case \"F\":\n             return (\n               (value = value.slice(2)),\n-              (value = getOutlinedModel(\n-                response,\n-                value,\n-                obj,\n-                key,\n-                createModel\n-              )),\n-              loadServerReference$1(\n-                response,\n-                value.id,\n-                value.bound,\n-                initializingChunk,\n-                obj,\n-                key\n-              )\n+              getOutlinedModel(response, value, obj, key, loadServerReference$1)\n             );\n           case \"T\":\n             if (\n@@ -5158,33 +5392,32 @@\n       emptyRoot = {},\n       decoderOptions = { stream: !0 },\n       instrumentedChunks = new WeakSet(),\n-      loadedChunks = new WeakSet();\n-    Chunk.prototype = Object.create(Promise.prototype);\n-    Chunk.prototype.then = function (resolve, reject) {\n+      loadedChunks = new WeakSet(),\n+      RESPONSE_SYMBOL = Symbol();\n+    ReactPromise.prototype = Object.create(Promise.prototype);\n+    ReactPromise.prototype.then = function (resolve, reject) {\n       switch (this.status) {\n         case \"resolved_model\":\n           initializeModelChunk(this);\n       }\n       switch (this.status) {\n         case \"fulfilled\":\n-          resolve(this.value);\n+          \"function\" === typeof resolve && resolve(this.value);\n           break;\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          resolve &&\n+          \"function\" === typeof resolve &&\n             (null === this.value && (this.value = []),\n             this.value.push(resolve));\n-          reject &&\n+          \"function\" === typeof reject &&\n             (null === this.reason && (this.reason = []),\n             this.reason.push(reject));\n           break;\n         default:\n-          reject(this.reason);\n+          \"function\" === typeof reject && reject(this.reason);\n       }\n     };\n-    var initializingChunk = null,\n-      initializingChunkBlockedModel = null;\n+    var initializingHandler = null;\n     exports.createClientModuleProxy = function (moduleId) {\n       moduleId = registerClientReferenceImpl({}, moduleId, !1);\n       return new Proxy(moduleId, proxyHandlers$1);\n@@ -5264,11 +5497,12 @@\n             var response = response$jscomp$0;\n             response._formData.append(name, entry);\n             var prefix = response._prefix;\n-            name.startsWith(prefix) &&\n-              ((response = response._chunks),\n-              (name = +name.slice(prefix.length)),\n-              (prefix = response.get(name)) &&\n-                resolveModelChunk(prefix, entry, name));\n+            if (name.startsWith(prefix)) {\n+              var chunks = response._chunks;\n+              name = +name.slice(prefix.length);\n+              (chunks = chunks.get(name)) &&\n+                resolveModelChunk(response, chunks, entry, name);\n+            }\n           } else response$jscomp$0._formData.append(name, entry);\n           iterator.next().then(progress, error);\n         }"
        },
        {
            "sha": "f9f5ccc7633084f78ae71fc2fba87b4dc41f99ec",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.edge.production.js",
            "status": "modified",
            "additions": 428,
            "deletions": 203,
            "changes": 631,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.edge.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -955,8 +955,8 @@ function serializeReadableStream(request, task, stream) {\n               : tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             reader.read().then(progress, error);\n-        } catch (x$8) {\n-          error(x$8);\n+        } catch (x$11) {\n+          error(x$11);\n         }\n   }\n   function error(reason) {\n@@ -1041,8 +1041,8 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n             tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             iterator.next().then(progress, error);\n-        } catch (x$9) {\n-          error(x$9);\n+        } catch (x$12) {\n+          error(x$12);\n         }\n   }\n   function error(reason) {\n@@ -2181,9 +2181,9 @@ function abort(request, reason) {\n         onAllReady();\n         flushCompletedChunks(request);\n       }\n-    } catch (error$23) {\n-      logRecoverableError(request, error$23, null),\n-        fatalError(request, error$23);\n+    } catch (error$26) {\n+      logRecoverableError(request, error$26, null),\n+        fatalError(request, error$26);\n     }\n }\n function resolveServerReference(bundlerConfig, id) {\n@@ -2251,59 +2251,97 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n-}\n-function Chunk(status, value, reason, response) {\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n+}\n+var RESPONSE_SYMBOL = Symbol();\n+function ReactPromise(status, value, reason) {\n   this.status = status;\n   this.value = value;\n   this.reason = reason;\n-  this._response = response;\n }\n-Chunk.prototype = Object.create(Promise.prototype);\n-Chunk.prototype.then = function (resolve, reject) {\n+ReactPromise.prototype = Object.create(Promise.prototype);\n+ReactPromise.prototype.then = function (resolve, reject) {\n   switch (this.status) {\n     case \"resolved_model\":\n       initializeModelChunk(this);\n   }\n   switch (this.status) {\n     case \"fulfilled\":\n-      resolve(this.value);\n+      \"function\" === typeof resolve && resolve(this.value);\n       break;\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      resolve &&\n+      \"function\" === typeof resolve &&\n         (null === this.value && (this.value = []), this.value.push(resolve));\n-      reject &&\n+      \"function\" === typeof reject &&\n         (null === this.reason && (this.reason = []), this.reason.push(reject));\n       break;\n     default:\n-      reject(this.reason);\n+      \"function\" === typeof reject && reject(this.reason);\n   }\n };\n-function createPendingChunk(response) {\n-  return new Chunk(\"pending\", null, null, response);\n+function wakeChunk(response, listeners, value) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(value)\n+      : fulfillReference(response, listener, value);\n+  }\n }\n-function wakeChunk(listeners, value) {\n-  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+function rejectChunk(response, listeners, error) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(error)\n+      : rejectReference(response, listener.handler, error);\n+  }\n }\n-function triggerErrorOnChunk(chunk, error) {\n+function resolveBlockedCycle(resolvedChunk, reference) {\n+  var referencedChunk = reference.handler.chunk;\n+  if (null === referencedChunk) return null;\n+  if (referencedChunk === resolvedChunk) return reference.handler;\n+  reference = referencedChunk.value;\n+  if (null !== reference)\n+    for (\n+      referencedChunk = 0;\n+      referencedChunk < reference.length;\n+      referencedChunk++\n+    ) {\n+      var listener = reference[referencedChunk];\n+      if (\n+        \"function\" !== typeof listener &&\n+        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+        null !== listener)\n+      )\n+        return listener;\n+    }\n+  return null;\n+}\n+function triggerErrorOnChunk(response, chunk, error) {\n   if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n     chunk.reason.error(error);\n   else {\n     var listeners = chunk.reason;\n     chunk.status = \"rejected\";\n     chunk.reason = error;\n-    null !== listeners && wakeChunk(listeners, error);\n+    null !== listeners && rejectChunk(response, listeners, error);\n   }\n }\n-function resolveModelChunk(chunk, value, id) {\n+function createResolvedModelChunk(response, value, id) {\n+  var $jscomp$compprop2 = {};\n+  return new ReactPromise(\n+    \"resolved_model\",\n+    value,\n+    (($jscomp$compprop2.id = id),\n+    ($jscomp$compprop2[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop2)\n+  );\n+}\n+function resolveModelChunk(response, chunk, value, id) {\n   if (\"pending\" !== chunk.status)\n     (chunk = chunk.reason),\n       \"C\" === value[0]\n@@ -2314,77 +2352,129 @@ function resolveModelChunk(chunk, value, id) {\n       rejectListeners = chunk.reason;\n     chunk.status = \"resolved_model\";\n     chunk.value = value;\n-    chunk.reason = id;\n+    value = {};\n+    chunk.reason =\n+      ((value.id = id), (value[RESPONSE_SYMBOL] = response), value);\n     if (null !== resolveListeners)\n-      switch ((initializeModelChunk(chunk), chunk.status)) {\n+      a: switch ((initializeModelChunk(chunk), chunk.status)) {\n         case \"fulfilled\":\n-          wakeChunk(resolveListeners, chunk.value);\n+          wakeChunk(response, resolveListeners, chunk.value);\n           break;\n-        case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n+          for (value = 0; value < resolveListeners.length; value++)\n+            if (((id = resolveListeners[value]), \"function\" !== typeof id)) {\n+              var cyclicHandler = resolveBlockedCycle(chunk, id);\n+              if (null !== cyclicHandler)\n+                switch (\n+                  (fulfillReference(response, id, cyclicHandler.value),\n+                  resolveListeners.splice(value, 1),\n+                  value--,\n+                  null !== rejectListeners &&\n+                    ((id = rejectListeners.indexOf(id)),\n+                    -1 !== id && rejectListeners.splice(id, 1)),\n+                  chunk.status)\n+                ) {\n+                  case \"fulfilled\":\n+                    wakeChunk(response, resolveListeners, chunk.value);\n+                    break a;\n+                  case \"rejected\":\n+                    null !== rejectListeners &&\n+                      rejectChunk(response, rejectListeners, chunk.reason);\n+                    break a;\n+                }\n+            }\n+        case \"pending\":\n           if (chunk.value)\n-            for (value = 0; value < resolveListeners.length; value++)\n-              chunk.value.push(resolveListeners[value]);\n+            for (response = 0; response < resolveListeners.length; response++)\n+              chunk.value.push(resolveListeners[response]);\n           else chunk.value = resolveListeners;\n           if (chunk.reason) {\n             if (rejectListeners)\n-              for (value = 0; value < rejectListeners.length; value++)\n-                chunk.reason.push(rejectListeners[value]);\n+              for (\n+                resolveListeners = 0;\n+                resolveListeners < rejectListeners.length;\n+                resolveListeners++\n+              )\n+                chunk.reason.push(rejectListeners[resolveListeners]);\n           } else chunk.reason = rejectListeners;\n           break;\n         case \"rejected\":\n-          rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+          rejectListeners && wakeChunk(response, rejectListeners, chunk.reason);\n       }\n   }\n }\n function createResolvedIteratorResultChunk(response, value, done) {\n-  return new Chunk(\n+  var $jscomp$compprop4 = {};\n+  return new ReactPromise(\n     \"resolved_model\",\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n-    -1,\n-    response\n+    (($jscomp$compprop4.id = -1),\n+    ($jscomp$compprop4[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop4)\n   );\n }\n-function resolveIteratorResultChunk(chunk, value, done) {\n+function resolveIteratorResultChunk(response, chunk, value, done) {\n   resolveModelChunk(\n+    response,\n     chunk,\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n     -1\n   );\n }\n-function loadServerReference$1(\n-  response,\n-  id,\n-  bound,\n-  parentChunk,\n-  parentObject,\n-  key\n-) {\n+function loadServerReference$1(response, metaData, parentObject, key) {\n+  var id = metaData.id;\n+  if (\"string\" !== typeof id) return null;\n   var serverReference = resolveServerReference(response._bundlerConfig, id);\n-  id = preloadModule(serverReference);\n-  if (bound)\n-    bound = Promise.all([bound, id]).then(function (_ref) {\n-      _ref = _ref[0];\n-      var fn = requireModule(serverReference);\n-      return fn.bind.apply(fn, [null].concat(_ref));\n-    });\n-  else if (id)\n-    bound = Promise.resolve(id).then(function () {\n-      return requireModule(serverReference);\n-    });\n+  id = metaData.bound;\n+  var promise = preloadModule(serverReference);\n+  if (promise)\n+    id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+  else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n   else return requireModule(serverReference);\n-  bound.then(\n-    createModelResolver(\n-      parentChunk,\n-      parentObject,\n-      key,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(parentChunk)\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n+  promise.then(\n+    function () {\n+      var resolvedValue = requireModule(serverReference);\n+      if (metaData.bound) {\n+        var promiseValue = metaData.bound.value;\n+        promiseValue = Array.isArray(promiseValue) ? promiseValue.slice(0) : [];\n+        promiseValue.unshift(null);\n+        resolvedValue = resolvedValue.bind.apply(resolvedValue, promiseValue);\n+      }\n+      parentObject[key] = resolvedValue;\n+      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((resolvedValue = handler.chunk),\n+        null !== resolvedValue &&\n+          \"blocked\" === resolvedValue.status &&\n+          ((promiseValue = resolvedValue.value),\n+          (resolvedValue.status = \"fulfilled\"),\n+          (resolvedValue.value = handler.value),\n+          null !== promiseValue &&\n+            wakeChunk(response, promiseValue, handler.value)));\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n@@ -2414,53 +2504,65 @@ function reviveModel(response, parentObj, parentKey, value, reference) {\n               ? reference + \":\" + i\n               : void 0),\n           (parentObj = reviveModel(response, value, i, value[i], parentObj)),\n-          void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+          void 0 !== parentObj || \"__proto__\" === i\n+            ? (value[i] = parentObj)\n+            : delete value[i]);\n   return value;\n }\n-var initializingChunk = null,\n-  initializingChunkBlockedModel = null;\n+var initializingHandler = null;\n function initializeModelChunk(chunk) {\n-  var prevChunk = initializingChunk,\n-    prevBlocked = initializingChunkBlockedModel;\n-  initializingChunk = chunk;\n-  initializingChunkBlockedModel = null;\n-  var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-    resolvedModel = chunk.value;\n-  chunk.status = \"cyclic\";\n+  var prevHandler = initializingHandler;\n+  initializingHandler = null;\n+  var _chunk$reason = chunk.reason,\n+    response = _chunk$reason[RESPONSE_SYMBOL];\n+  _chunk$reason = _chunk$reason.id;\n+  _chunk$reason = -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+  var resolvedModel = chunk.value;\n+  chunk.status = \"blocked\";\n   chunk.value = null;\n   chunk.reason = null;\n   try {\n     var rawModel = JSON.parse(resolvedModel),\n       value = reviveModel(\n-        chunk._response,\n+        response,\n         { \"\": rawModel },\n         \"\",\n         rawModel,\n-        rootReference\n-      );\n-    if (\n-      null !== initializingChunkBlockedModel &&\n-      0 < initializingChunkBlockedModel.deps\n-    )\n-      (initializingChunkBlockedModel.value = value), (chunk.status = \"blocked\");\n-    else {\n-      var resolveListeners = chunk.value;\n-      chunk.status = \"fulfilled\";\n-      chunk.value = value;\n-      null !== resolveListeners && wakeChunk(resolveListeners, value);\n+        _chunk$reason\n+      ),\n+      resolveListeners = chunk.value;\n+    if (null !== resolveListeners)\n+      for (\n+        chunk.value = null, chunk.reason = null, rawModel = 0;\n+        rawModel < resolveListeners.length;\n+        rawModel++\n+      ) {\n+        var listener = resolveListeners[rawModel];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n+    if (null !== initializingHandler) {\n+      if (initializingHandler.errored) throw initializingHandler.reason;\n+      if (0 < initializingHandler.deps) {\n+        initializingHandler.value = value;\n+        initializingHandler.chunk = chunk;\n+        return;\n+      }\n     }\n+    chunk.status = \"fulfilled\";\n+    chunk.value = value;\n   } catch (error) {\n     (chunk.status = \"rejected\"), (chunk.reason = error);\n   } finally {\n-    (initializingChunk = prevChunk),\n-      (initializingChunkBlockedModel = prevBlocked);\n+    initializingHandler = prevHandler;\n   }\n }\n function reportGlobalError(response, error) {\n   response._closed = !0;\n   response._closedReason = error;\n   response._chunks.forEach(function (chunk) {\n-    \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+    \"pending\" === chunk.status && triggerErrorOnChunk(response, chunk, error);\n   });\n }\n function getChunk(response, id) {\n@@ -2469,48 +2571,104 @@ function getChunk(response, id) {\n   chunk ||\n     ((chunk = response._formData.get(response._prefix + id)),\n     (chunk =\n-      null != chunk\n-        ? new Chunk(\"resolved_model\", chunk, id, response)\n+      \"string\" === typeof chunk\n+        ? createResolvedModelChunk(response, chunk, id)\n         : response._closed\n-          ? new Chunk(\"rejected\", null, response._closedReason, response)\n-          : createPendingChunk(response)),\n+          ? new ReactPromise(\"rejected\", null, response._closedReason)\n+          : new ReactPromise(\"pending\", null, null)),\n     chunks.set(id, chunk));\n   return chunk;\n }\n-function createModelResolver(\n-  chunk,\n+function fulfillReference(response, reference, value) {\n+  for (\n+    var handler = reference.handler,\n+      parentObject = reference.parentObject,\n+      key = reference.key,\n+      map = reference.map,\n+      path = reference.path,\n+      i = 1;\n+    i < path.length;\n+    i++\n+  ) {\n+    for (; value instanceof ReactPromise; ) {\n+      switch (value.status) {\n+        case \"resolved_model\":\n+          initializeModelChunk(value);\n+      }\n+      switch (value.status) {\n+        case \"fulfilled\":\n+          value = value.value;\n+          continue;\n+        case \"blocked\":\n+        case \"pending\":\n+          path.splice(0, i - 1);\n+          null === value.value\n+            ? (value.value = [reference])\n+            : value.value.push(reference);\n+          null === value.reason\n+            ? (value.reason = [reference])\n+            : value.reason.push(reference);\n+          return;\n+        default:\n+          rejectReference(response, reference.handler, value.reason);\n+          return;\n+      }\n+    }\n+    var name = path[i];\n+    \"object\" === typeof value &&\n+      hasOwnProperty.call(value, name) &&\n+      (value = value[name]);\n+  }\n+  reference = map(response, value, parentObject, key);\n+  parentObject[key] = reference;\n+  \"\" === key && null === handler.value && (handler.value = reference);\n+  handler.deps--;\n+  0 === handler.deps &&\n+    ((parentObject = handler.chunk),\n+    null !== parentObject &&\n+      \"blocked\" === parentObject.status &&\n+      ((key = parentObject.value),\n+      (parentObject.status = \"fulfilled\"),\n+      (parentObject.value = handler.value),\n+      (parentObject.reason = handler.reason),\n+      null !== key && wakeChunk(response, key, handler.value)));\n+}\n+function rejectReference(response, handler, error) {\n+  handler.errored ||\n+    ((handler.errored = !0),\n+    (handler.value = null),\n+    (handler.reason = error),\n+    (handler = handler.chunk),\n+    null !== handler &&\n+      \"blocked\" === handler.status &&\n+      triggerErrorOnChunk(response, handler, error));\n+}\n+function waitForReference(\n+  referencedChunk,\n   parentObject,\n   key,\n-  cyclic,\n   response,\n   map,\n   path\n ) {\n-  if (initializingChunkBlockedModel) {\n-    var blocked = initializingChunkBlockedModel;\n-    cyclic || blocked.deps++;\n-  } else\n-    blocked = initializingChunkBlockedModel = {\n-      deps: cyclic ? 0 : 1,\n-      value: null\n-    };\n-  return function (value) {\n-    for (var i = 1; i < path.length; i++) value = value[path[i]];\n-    parentObject[key] = map(response, value);\n-    \"\" === key && null === blocked.value && (blocked.value = parentObject[key]);\n-    blocked.deps--;\n-    0 === blocked.deps &&\n-      \"blocked\" === chunk.status &&\n-      ((value = chunk.value),\n-      (chunk.status = \"fulfilled\"),\n-      (chunk.value = blocked.value),\n-      null !== value && wakeChunk(value, blocked.value));\n-  };\n-}\n-function createModelReject(chunk) {\n-  return function (error) {\n-    return triggerErrorOnChunk(chunk, error);\n+  initializingHandler\n+    ? ((response = initializingHandler), response.deps++)\n+    : (response = initializingHandler =\n+        { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+  parentObject = {\n+    handler: response,\n+    parentObject: parentObject,\n+    key: key,\n+    map: map,\n+    path: path\n   };\n+  null === referencedChunk.value\n+    ? (referencedChunk.value = [parentObject])\n+    : referencedChunk.value.push(parentObject);\n+  null === referencedChunk.reason\n+    ? (referencedChunk.reason = [parentObject])\n+    : referencedChunk.reason.push(parentObject);\n+  return null;\n }\n function getOutlinedModel(response, reference, parentObject, key, map) {\n   reference = reference.split(\":\");\n@@ -2522,29 +2680,68 @@ function getOutlinedModel(response, reference, parentObject, key, map) {\n   }\n   switch (id.status) {\n     case \"fulfilled\":\n-      parentObject = id.value;\n-      for (key = 1; key < reference.length; key++)\n-        parentObject = parentObject[reference[key]];\n-      return map(response, parentObject);\n+      var value = id.value;\n+      for (id = 1; id < reference.length; id++) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              break;\n+            case \"blocked\":\n+            case \"pending\":\n+              return waitForReference(\n+                value,\n+                parentObject,\n+                key,\n+                response,\n+                map,\n+                reference.slice(id - 1)\n+              );\n+            default:\n+              return (\n+                initializingHandler\n+                  ? ((initializingHandler.errored = !0),\n+                    (initializingHandler.value = null),\n+                    (initializingHandler.reason = value.reason))\n+                  : (initializingHandler = {\n+                      chunk: null,\n+                      value: null,\n+                      reason: value.reason,\n+                      deps: 0,\n+                      errored: !0\n+                    }),\n+                null\n+              );\n+          }\n+        }\n+        var name = reference[id];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      return map(response, value, parentObject, key);\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      var parentChunk = initializingChunk;\n-      id.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          \"cyclic\" === id.status,\n-          response,\n-          map,\n-          reference\n-        ),\n-        createModelReject(parentChunk)\n-      );\n-      return null;\n+      return waitForReference(id, parentObject, key, response, map, reference);\n     default:\n-      throw id.reason;\n+      return (\n+        initializingHandler\n+          ? ((initializingHandler.errored = !0),\n+            (initializingHandler.value = null),\n+            (initializingHandler.reason = id.reason))\n+          : (initializingHandler = {\n+              chunk: null,\n+              value: null,\n+              reason: id.reason,\n+              deps: 0,\n+              errored: !0\n+            }),\n+        null\n+      );\n   }\n }\n function createMap(response, model) {\n@@ -2568,38 +2765,63 @@ function parseTypedArray(\n   parentKey\n ) {\n   reference = parseInt(reference.slice(2), 16);\n-  reference = response._formData.get(response._prefix + reference);\n-  reference =\n-    constructor === ArrayBuffer\n-      ? reference.arrayBuffer()\n-      : reference.arrayBuffer().then(function (buffer) {\n-          return new constructor(buffer);\n-        });\n-  bytesPerElement = initializingChunk;\n+  reference = response._formData\n+    .get(response._prefix + reference)\n+    .arrayBuffer();\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n   reference.then(\n-    createModelResolver(\n-      bytesPerElement,\n-      parentObject,\n-      parentKey,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(bytesPerElement)\n+    function (buffer) {\n+      buffer = constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+      parentObject[parentKey] = buffer;\n+      \"\" === parentKey && null === handler.value && (handler.value = buffer);\n+      handler.deps--;\n+      if (\n+        0 === handler.deps &&\n+        ((buffer = handler.chunk),\n+        null !== buffer && \"blocked\" === buffer.status)\n+      ) {\n+        var resolveListeners = buffer.value;\n+        buffer.status = \"fulfilled\";\n+        buffer.value = handler.value;\n+        null !== resolveListeners &&\n+          wakeChunk(response, resolveListeners, handler.value);\n+      }\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n function resolveStream(response, id, stream, controller) {\n   var chunks = response._chunks;\n-  stream = new Chunk(\"fulfilled\", stream, controller, response);\n+  stream = new ReactPromise(\"fulfilled\", stream, controller);\n   chunks.set(id, stream);\n   response = response._formData.getAll(response._prefix + id);\n   for (id = 0; id < response.length; id++)\n     (chunks = response[id]),\n-      \"C\" === chunks[0]\n-        ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n-        : controller.enqueueModel(chunks);\n+      \"string\" === typeof chunks &&\n+        (\"C\" === chunks[0]\n+          ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n+          : controller.enqueueModel(chunks));\n }\n function parseReadableStream(response, reference, type) {\n   reference = parseInt(reference.slice(2), 16);\n@@ -2614,7 +2836,7 @@ function parseReadableStream(response, reference, type) {\n   resolveStream(response, reference, type, {\n     enqueueModel: function (json) {\n       if (null === previousBlockedChunk) {\n-        var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+        var chunk = createResolvedModelChunk(response, json, -1);\n         initializeModelChunk(chunk);\n         \"fulfilled\" === chunk.status\n           ? controller.enqueue(chunk.value)\n@@ -2629,19 +2851,19 @@ function parseReadableStream(response, reference, type) {\n             (previousBlockedChunk = chunk));\n       } else {\n         chunk = previousBlockedChunk;\n-        var chunk$26 = createPendingChunk(response);\n-        chunk$26.then(\n+        var chunk$30 = new ReactPromise(\"pending\", null, null);\n+        chunk$30.then(\n           function (v) {\n             return controller.enqueue(v);\n           },\n           function (e) {\n             return controller.error(e);\n           }\n         );\n-        previousBlockedChunk = chunk$26;\n+        previousBlockedChunk = chunk$30;\n         chunk.then(function () {\n-          previousBlockedChunk === chunk$26 && (previousBlockedChunk = null);\n-          resolveModelChunk(chunk$26, json, -1);\n+          previousBlockedChunk === chunk$30 && (previousBlockedChunk = null);\n+          resolveModelChunk(response, chunk$30, json, -1);\n         });\n       }\n     },\n@@ -2681,9 +2903,9 @@ function parseAsyncIterable(response, reference, iterator) {\n   var buffer = [],\n     closed = !1,\n     nextWriteIndex = 0,\n-    $jscomp$compprop2 = {};\n-  $jscomp$compprop2 =\n-    (($jscomp$compprop2[ASYNC_ITERATOR] = function () {\n+    $jscomp$compprop5 = {};\n+  $jscomp$compprop5 =\n+    (($jscomp$compprop5[ASYNC_ITERATOR] = function () {\n       var nextReadIndex = 0;\n       return createIterator(function (arg) {\n         if (void 0 !== arg)\n@@ -2692,19 +2914,18 @@ function parseAsyncIterable(response, reference, iterator) {\n           );\n         if (nextReadIndex === buffer.length) {\n           if (closed)\n-            return new Chunk(\n+            return new ReactPromise(\n               \"fulfilled\",\n               { done: !0, value: void 0 },\n-              null,\n-              response\n+              null\n             );\n-          buffer[nextReadIndex] = createPendingChunk(response);\n+          buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n         }\n         return buffer[nextReadIndex++];\n       });\n     }),\n-    $jscomp$compprop2);\n-  iterator = iterator ? $jscomp$compprop2[ASYNC_ITERATOR]() : $jscomp$compprop2;\n+    $jscomp$compprop5);\n+  iterator = iterator ? $jscomp$compprop5[ASYNC_ITERATOR]() : $jscomp$compprop5;\n   resolveStream(response, reference, iterator, {\n     enqueueModel: function (value) {\n       nextWriteIndex === buffer.length\n@@ -2713,7 +2934,12 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !1\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !1\n+          );\n       nextWriteIndex++;\n     },\n     close: function (value) {\n@@ -2724,9 +2950,15 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !0\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !0\n+          );\n       for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n         resolveIteratorResultChunk(\n+          response,\n           buffer[nextWriteIndex++],\n           '\"$undefined\"',\n           !0\n@@ -2736,11 +2968,11 @@ function parseAsyncIterable(response, reference, iterator) {\n       closed = !0;\n       for (\n         nextWriteIndex === buffer.length &&\n-        (buffer[nextWriteIndex] = createPendingChunk(response));\n+        (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n         nextWriteIndex < buffer.length;\n \n       )\n-        triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+        triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n     }\n   });\n   return iterator;\n@@ -2755,15 +2987,7 @@ function parseModelString(response, obj, key, value, reference) {\n       case \"F\":\n         return (\n           (value = value.slice(2)),\n-          (value = getOutlinedModel(response, value, obj, key, createModel)),\n-          loadServerReference$1(\n-            response,\n-            value.id,\n-            value.bound,\n-            initializingChunk,\n-            obj,\n-            key\n-          )\n+          getOutlinedModel(response, value, obj, key, loadServerReference$1)\n         );\n       case \"T\":\n         if (void 0 === reference || void 0 === response._temporaryReferences)\n@@ -2978,7 +3202,8 @@ exports.decodeReplyFromAsyncIterable = function (\n         if (name.startsWith(prefix)) {\n           var chunks = response._chunks;\n           name = +name.slice(prefix.length);\n-          (chunks = chunks.get(name)) && resolveModelChunk(chunks, entry, name);\n+          (chunks = chunks.get(name)) &&\n+            resolveModelChunk(response, chunks, entry, name);\n         }\n       } else response._formData.append(name, entry);\n       iterator.next().then(progress, error);"
        },
        {
            "sha": "9ab19f60beba3bc2c3fd75117d76e62f778cad8d",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.node.development.js",
            "status": "modified",
            "additions": 475,
            "deletions": 228,
            "changes": 703,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.node.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -4419,37 +4419,65 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n-    }\n-    function Chunk(status, value, reason, response) {\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n+    }\n+    function ReactPromise(status, value, reason) {\n       this.status = status;\n       this.value = value;\n       this.reason = reason;\n-      this._response = response;\n     }\n-    function createPendingChunk(response) {\n-      return new Chunk(\"pending\", null, null, response);\n+    function wakeChunk(response, listeners, value) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n     }\n-    function wakeChunk(listeners, value) {\n-      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+    function rejectChunk(response, listeners, error) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(error)\n+          : rejectReference(response, listener.handler, error);\n+      }\n     }\n-    function triggerErrorOnChunk(chunk, error) {\n+    function resolveBlockedCycle(resolvedChunk, reference) {\n+      var referencedChunk = reference.handler.chunk;\n+      if (null === referencedChunk) return null;\n+      if (referencedChunk === resolvedChunk) return reference.handler;\n+      reference = referencedChunk.value;\n+      if (null !== reference)\n+        for (\n+          referencedChunk = 0;\n+          referencedChunk < reference.length;\n+          referencedChunk++\n+        ) {\n+          var listener = reference[referencedChunk];\n+          if (\n+            \"function\" !== typeof listener &&\n+            ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+            null !== listener)\n+          )\n+            return listener;\n+        }\n+      return null;\n+    }\n+    function triggerErrorOnChunk(response, chunk, error) {\n       if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n         chunk.reason.error(error);\n       else {\n         var listeners = chunk.reason;\n         chunk.status = \"rejected\";\n         chunk.reason = error;\n-        null !== listeners && wakeChunk(listeners, error);\n+        null !== listeners && rejectChunk(response, listeners, error);\n       }\n     }\n-    function resolveModelChunk(chunk, value, id) {\n+    function resolveModelChunk(response, chunk, value, id) {\n       if (\"pending\" !== chunk.status)\n         (chunk = chunk.reason),\n           \"C\" === value[0]\n@@ -4460,81 +4488,142 @@\n           rejectListeners = chunk.reason;\n         chunk.status = \"resolved_model\";\n         chunk.value = value;\n-        chunk.reason = id;\n+        chunk.reason = _defineProperty({ id: id }, RESPONSE_SYMBOL, response);\n         if (null !== resolveListeners)\n-          switch ((initializeModelChunk(chunk), chunk.status)) {\n+          a: switch ((initializeModelChunk(chunk), chunk.status)) {\n             case \"fulfilled\":\n-              wakeChunk(resolveListeners, chunk.value);\n+              wakeChunk(response, resolveListeners, chunk.value);\n               break;\n-            case \"pending\":\n             case \"blocked\":\n-            case \"cyclic\":\n+              for (value = 0; value < resolveListeners.length; value++)\n+                if (\n+                  ((id = resolveListeners[value]), \"function\" !== typeof id)\n+                ) {\n+                  var cyclicHandler = resolveBlockedCycle(chunk, id);\n+                  if (null !== cyclicHandler)\n+                    switch (\n+                      (fulfillReference(response, id, cyclicHandler.value),\n+                      resolveListeners.splice(value, 1),\n+                      value--,\n+                      null !== rejectListeners &&\n+                        ((id = rejectListeners.indexOf(id)),\n+                        -1 !== id && rejectListeners.splice(id, 1)),\n+                      chunk.status)\n+                    ) {\n+                      case \"fulfilled\":\n+                        wakeChunk(response, resolveListeners, chunk.value);\n+                        break a;\n+                      case \"rejected\":\n+                        null !== rejectListeners &&\n+                          rejectChunk(response, rejectListeners, chunk.reason);\n+                        break a;\n+                    }\n+                }\n+            case \"pending\":\n               if (chunk.value)\n-                for (value = 0; value < resolveListeners.length; value++)\n-                  chunk.value.push(resolveListeners[value]);\n+                for (\n+                  response = 0;\n+                  response < resolveListeners.length;\n+                  response++\n+                )\n+                  chunk.value.push(resolveListeners[response]);\n               else chunk.value = resolveListeners;\n               if (chunk.reason) {\n                 if (rejectListeners)\n-                  for (value = 0; value < rejectListeners.length; value++)\n-                    chunk.reason.push(rejectListeners[value]);\n+                  for (\n+                    resolveListeners = 0;\n+                    resolveListeners < rejectListeners.length;\n+                    resolveListeners++\n+                  )\n+                    chunk.reason.push(rejectListeners[resolveListeners]);\n               } else chunk.reason = rejectListeners;\n               break;\n             case \"rejected\":\n-              rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+              rejectListeners &&\n+                wakeChunk(response, rejectListeners, chunk.reason);\n           }\n       }\n     }\n     function createResolvedIteratorResultChunk(response, value, done) {\n-      return new Chunk(\n+      return new ReactPromise(\n         \"resolved_model\",\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n-        -1,\n-        response\n+        _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n       );\n     }\n-    function resolveIteratorResultChunk(chunk, value, done) {\n+    function resolveIteratorResultChunk(response, chunk, value, done) {\n       resolveModelChunk(\n+        response,\n         chunk,\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n         -1\n       );\n     }\n-    function loadServerReference$1(\n-      response,\n-      id,\n-      bound,\n-      parentChunk,\n-      parentObject,\n-      key\n-    ) {\n+    function loadServerReference$1(response, metaData, parentObject, key) {\n+      var id = metaData.id;\n+      if (\"string\" !== typeof id) return null;\n       var serverReference = resolveServerReference(response._bundlerConfig, id);\n-      id = preloadModule(serverReference);\n-      if (bound)\n-        bound = Promise.all([bound, id]).then(function (_ref) {\n-          _ref = _ref[0];\n-          var fn = requireModule(serverReference);\n-          return fn.bind.apply(fn, [null].concat(_ref));\n-        });\n-      else if (id)\n-        bound = Promise.resolve(id).then(function () {\n-          return requireModule(serverReference);\n-        });\n+      id = metaData.bound;\n+      var promise = preloadModule(serverReference);\n+      if (promise)\n+        id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+      else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n       else return requireModule(serverReference);\n-      bound.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(parentChunk)\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n+      promise.then(\n+        function () {\n+          var resolvedValue = requireModule(serverReference);\n+          if (metaData.bound) {\n+            var promiseValue = metaData.bound.value;\n+            promiseValue = Array.isArray(promiseValue)\n+              ? promiseValue.slice(0)\n+              : [];\n+            promiseValue.unshift(null);\n+            resolvedValue = resolvedValue.bind.apply(\n+              resolvedValue,\n+              promiseValue\n+            );\n+          }\n+          parentObject[key] = resolvedValue;\n+          \"\" === key &&\n+            null === handler.value &&\n+            (handler.value = resolvedValue);\n+          handler.deps--;\n+          0 === handler.deps &&\n+            ((resolvedValue = handler.chunk),\n+            null !== resolvedValue &&\n+              \"blocked\" === resolvedValue.status &&\n+              ((promiseValue = resolvedValue.value),\n+              (resolvedValue.status = \"fulfilled\"),\n+              (resolvedValue.value = handler.value),\n+              null !== promiseValue &&\n+                wakeChunk(response, promiseValue, handler.value)));\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n@@ -4576,53 +4665,66 @@\n                 value[i],\n                 parentObj\n               )),\n-              void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+              void 0 !== parentObj || \"__proto__\" === i\n+                ? (value[i] = parentObj)\n+                : delete value[i]);\n       return value;\n     }\n     function initializeModelChunk(chunk) {\n-      var prevChunk = initializingChunk,\n-        prevBlocked = initializingChunkBlockedModel;\n-      initializingChunk = chunk;\n-      initializingChunkBlockedModel = null;\n-      var rootReference =\n-          -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-        resolvedModel = chunk.value;\n-      chunk.status = \"cyclic\";\n+      var prevHandler = initializingHandler;\n+      initializingHandler = null;\n+      var _chunk$reason = chunk.reason,\n+        response = _chunk$reason[RESPONSE_SYMBOL];\n+      _chunk$reason = _chunk$reason.id;\n+      _chunk$reason =\n+        -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+      var resolvedModel = chunk.value;\n+      chunk.status = \"blocked\";\n       chunk.value = null;\n       chunk.reason = null;\n       try {\n         var rawModel = JSON.parse(resolvedModel),\n           value = reviveModel(\n-            chunk._response,\n+            response,\n             { \"\": rawModel },\n             \"\",\n             rawModel,\n-            rootReference\n-          );\n-        if (\n-          null !== initializingChunkBlockedModel &&\n-          0 < initializingChunkBlockedModel.deps\n-        )\n-          (initializingChunkBlockedModel.value = value),\n-            (chunk.status = \"blocked\");\n-        else {\n-          var resolveListeners = chunk.value;\n-          chunk.status = \"fulfilled\";\n-          chunk.value = value;\n-          null !== resolveListeners && wakeChunk(resolveListeners, value);\n+            _chunk$reason\n+          ),\n+          resolveListeners = chunk.value;\n+        if (null !== resolveListeners)\n+          for (\n+            chunk.value = null, chunk.reason = null, rawModel = 0;\n+            rawModel < resolveListeners.length;\n+            rawModel++\n+          ) {\n+            var listener = resolveListeners[rawModel];\n+            \"function\" === typeof listener\n+              ? listener(value)\n+              : fulfillReference(response, listener, value);\n+          }\n+        if (null !== initializingHandler) {\n+          if (initializingHandler.errored) throw initializingHandler.reason;\n+          if (0 < initializingHandler.deps) {\n+            initializingHandler.value = value;\n+            initializingHandler.chunk = chunk;\n+            return;\n+          }\n         }\n+        chunk.status = \"fulfilled\";\n+        chunk.value = value;\n       } catch (error) {\n         (chunk.status = \"rejected\"), (chunk.reason = error);\n       } finally {\n-        (initializingChunk = prevChunk),\n-          (initializingChunkBlockedModel = prevBlocked);\n+        initializingHandler = prevHandler;\n       }\n     }\n     function reportGlobalError(response, error) {\n       response._closed = !0;\n       response._closedReason = error;\n       response._chunks.forEach(function (chunk) {\n-        \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+        \"pending\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n       });\n     }\n     function getChunk(response, id) {\n@@ -4631,50 +4733,108 @@\n       chunk ||\n         ((chunk = response._formData.get(response._prefix + id)),\n         (chunk =\n-          null != chunk\n-            ? new Chunk(\"resolved_model\", chunk, id, response)\n+          \"string\" === typeof chunk\n+            ? new ReactPromise(\n+                \"resolved_model\",\n+                chunk,\n+                _defineProperty({ id: id }, RESPONSE_SYMBOL, response)\n+              )\n             : response._closed\n-              ? new Chunk(\"rejected\", null, response._closedReason, response)\n-              : createPendingChunk(response)),\n+              ? new ReactPromise(\"rejected\", null, response._closedReason)\n+              : new ReactPromise(\"pending\", null, null)),\n         chunks.set(id, chunk));\n       return chunk;\n     }\n-    function createModelResolver(\n-      chunk,\n+    function fulfillReference(response, reference, value) {\n+      for (\n+        var handler = reference.handler,\n+          parentObject = reference.parentObject,\n+          key = reference.key,\n+          map = reference.map,\n+          path = reference.path,\n+          i = 1;\n+        i < path.length;\n+        i++\n+      ) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              continue;\n+            case \"blocked\":\n+            case \"pending\":\n+              path.splice(0, i - 1);\n+              null === value.value\n+                ? (value.value = [reference])\n+                : value.value.push(reference);\n+              null === value.reason\n+                ? (value.reason = [reference])\n+                : value.reason.push(reference);\n+              return;\n+            default:\n+              rejectReference(response, reference.handler, value.reason);\n+              return;\n+          }\n+        }\n+        var name = path[i];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      reference = map(response, value, parentObject, key);\n+      parentObject[key] = reference;\n+      \"\" === key && null === handler.value && (handler.value = reference);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((parentObject = handler.chunk),\n+        null !== parentObject &&\n+          \"blocked\" === parentObject.status &&\n+          ((key = parentObject.value),\n+          (parentObject.status = \"fulfilled\"),\n+          (parentObject.value = handler.value),\n+          (parentObject.reason = handler.reason),\n+          null !== key && wakeChunk(response, key, handler.value)));\n+    }\n+    function rejectReference(response, handler, error) {\n+      handler.errored ||\n+        ((handler.errored = !0),\n+        (handler.value = null),\n+        (handler.reason = error),\n+        (handler = handler.chunk),\n+        null !== handler &&\n+          \"blocked\" === handler.status &&\n+          triggerErrorOnChunk(response, handler, error));\n+    }\n+    function waitForReference(\n+      referencedChunk,\n       parentObject,\n       key,\n-      cyclic,\n       response,\n       map,\n       path\n     ) {\n-      if (initializingChunkBlockedModel) {\n-        var blocked = initializingChunkBlockedModel;\n-        cyclic || blocked.deps++;\n-      } else\n-        blocked = initializingChunkBlockedModel = {\n-          deps: cyclic ? 0 : 1,\n-          value: null\n-        };\n-      return function (value) {\n-        for (var i = 1; i < path.length; i++) value = value[path[i]];\n-        parentObject[key] = map(response, value);\n-        \"\" === key &&\n-          null === blocked.value &&\n-          (blocked.value = parentObject[key]);\n-        blocked.deps--;\n-        0 === blocked.deps &&\n-          \"blocked\" === chunk.status &&\n-          ((value = chunk.value),\n-          (chunk.status = \"fulfilled\"),\n-          (chunk.value = blocked.value),\n-          null !== value && wakeChunk(value, blocked.value));\n-      };\n-    }\n-    function createModelReject(chunk) {\n-      return function (error) {\n-        return triggerErrorOnChunk(chunk, error);\n+      initializingHandler\n+        ? ((response = initializingHandler), response.deps++)\n+        : (response = initializingHandler =\n+            { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+      parentObject = {\n+        handler: response,\n+        parentObject: parentObject,\n+        key: key,\n+        map: map,\n+        path: path\n       };\n+      null === referencedChunk.value\n+        ? (referencedChunk.value = [parentObject])\n+        : referencedChunk.value.push(parentObject);\n+      null === referencedChunk.reason\n+        ? (referencedChunk.reason = [parentObject])\n+        : referencedChunk.reason.push(parentObject);\n+      return null;\n     }\n     function getOutlinedModel(response, reference, parentObject, key, map) {\n       reference = reference.split(\":\");\n@@ -4686,29 +4846,75 @@\n       }\n       switch (id.status) {\n         case \"fulfilled\":\n-          parentObject = id.value;\n-          for (key = 1; key < reference.length; key++)\n-            parentObject = parentObject[reference[key]];\n-          return map(response, parentObject);\n+          var value = id.value;\n+          for (id = 1; id < reference.length; id++) {\n+            for (; value instanceof ReactPromise; ) {\n+              switch (value.status) {\n+                case \"resolved_model\":\n+                  initializeModelChunk(value);\n+              }\n+              switch (value.status) {\n+                case \"fulfilled\":\n+                  value = value.value;\n+                  break;\n+                case \"blocked\":\n+                case \"pending\":\n+                  return waitForReference(\n+                    value,\n+                    parentObject,\n+                    key,\n+                    response,\n+                    map,\n+                    reference.slice(id - 1)\n+                  );\n+                default:\n+                  return (\n+                    initializingHandler\n+                      ? ((initializingHandler.errored = !0),\n+                        (initializingHandler.value = null),\n+                        (initializingHandler.reason = value.reason))\n+                      : (initializingHandler = {\n+                          chunk: null,\n+                          value: null,\n+                          reason: value.reason,\n+                          deps: 0,\n+                          errored: !0\n+                        }),\n+                    null\n+                  );\n+              }\n+            }\n+            var name = reference[id];\n+            \"object\" === typeof value &&\n+              hasOwnProperty.call(value, name) &&\n+              (value = value[name]);\n+          }\n+          return map(response, value, parentObject, key);\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          var parentChunk = initializingChunk;\n-          id.then(\n-            createModelResolver(\n-              parentChunk,\n-              parentObject,\n-              key,\n-              \"cyclic\" === id.status,\n-              response,\n-              map,\n-              reference\n-            ),\n-            createModelReject(parentChunk)\n+          return waitForReference(\n+            id,\n+            parentObject,\n+            key,\n+            response,\n+            map,\n+            reference\n           );\n-          return null;\n         default:\n-          throw id.reason;\n+          return (\n+            initializingHandler\n+              ? ((initializingHandler.errored = !0),\n+                (initializingHandler.value = null),\n+                (initializingHandler.reason = id.reason))\n+              : (initializingHandler = {\n+                  chunk: null,\n+                  value: null,\n+                  reason: id.reason,\n+                  deps: 0,\n+                  errored: !0\n+                }),\n+            null\n+          );\n       }\n     }\n     function createMap(response, model) {\n@@ -4732,40 +4938,68 @@\n       parentKey\n     ) {\n       reference = parseInt(reference.slice(2), 16);\n-      reference = response._formData.get(response._prefix + reference);\n-      reference =\n-        constructor === ArrayBuffer\n-          ? reference.arrayBuffer()\n-          : reference.arrayBuffer().then(function (buffer) {\n-              return new constructor(buffer);\n-            });\n-      bytesPerElement = initializingChunk;\n+      reference = response._formData\n+        .get(response._prefix + reference)\n+        .arrayBuffer();\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n       reference.then(\n-        createModelResolver(\n-          bytesPerElement,\n-          parentObject,\n-          parentKey,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(bytesPerElement)\n+        function (buffer) {\n+          buffer =\n+            constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+          parentObject[parentKey] = buffer;\n+          \"\" === parentKey &&\n+            null === handler.value &&\n+            (handler.value = buffer);\n+          handler.deps--;\n+          if (\n+            0 === handler.deps &&\n+            ((buffer = handler.chunk),\n+            null !== buffer && \"blocked\" === buffer.status)\n+          ) {\n+            var resolveListeners = buffer.value;\n+            buffer.status = \"fulfilled\";\n+            buffer.value = handler.value;\n+            null !== resolveListeners &&\n+              wakeChunk(response, resolveListeners, handler.value);\n+          }\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n     function resolveStream(response, id, stream, controller) {\n       var chunks = response._chunks;\n-      stream = new Chunk(\"fulfilled\", stream, controller, response);\n+      stream = new ReactPromise(\"fulfilled\", stream, controller);\n       chunks.set(id, stream);\n       response = response._formData.getAll(response._prefix + id);\n       for (id = 0; id < response.length; id++)\n         (chunks = response[id]),\n-          \"C\" === chunks[0]\n-            ? controller.close(\n-                \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n-              )\n-            : controller.enqueueModel(chunks);\n+          \"string\" === typeof chunks &&\n+            (\"C\" === chunks[0]\n+              ? controller.close(\n+                  \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n+                )\n+              : controller.enqueueModel(chunks));\n     }\n     function parseReadableStream(response, reference, type) {\n       reference = parseInt(reference.slice(2), 16);\n@@ -4780,7 +5014,11 @@\n       resolveStream(response, reference, type, {\n         enqueueModel: function (json) {\n           if (null === previousBlockedChunk) {\n-            var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+            var chunk = new ReactPromise(\n+              \"resolved_model\",\n+              json,\n+              _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n+            );\n             initializeModelChunk(chunk);\n             \"fulfilled\" === chunk.status\n               ? controller.enqueue(chunk.value)\n@@ -4795,7 +5033,7 @@\n                 (previousBlockedChunk = chunk));\n           } else {\n             chunk = previousBlockedChunk;\n-            var _chunk = createPendingChunk(response);\n+            var _chunk = new ReactPromise(\"pending\", null, null);\n             _chunk.then(\n               function (v) {\n                 return controller.enqueue(v);\n@@ -4807,7 +5045,7 @@\n             previousBlockedChunk = _chunk;\n             chunk.then(function () {\n               previousBlockedChunk === _chunk && (previousBlockedChunk = null);\n-              resolveModelChunk(_chunk, json, -1);\n+              resolveModelChunk(response, _chunk, json, -1);\n             });\n           }\n         },\n@@ -4856,13 +5094,12 @@\n               );\n             if (nextReadIndex === buffer.length) {\n               if (closed)\n-                return new Chunk(\n+                return new ReactPromise(\n                   \"fulfilled\",\n                   { done: !0, value: void 0 },\n-                  null,\n-                  response\n+                  null\n                 );\n-              buffer[nextReadIndex] = createPendingChunk(response);\n+              buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n             }\n             return buffer[nextReadIndex++];\n           });\n@@ -4876,7 +5113,12 @@\n                 value,\n                 !1\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !1\n+              );\n           nextWriteIndex++;\n         },\n         close: function (value) {\n@@ -4887,9 +5129,15 @@\n                 value,\n                 !0\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !0\n+              );\n           for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n             resolveIteratorResultChunk(\n+              response,\n               buffer[nextWriteIndex++],\n               '\"$undefined\"',\n               !0\n@@ -4899,11 +5147,11 @@\n           closed = !0;\n           for (\n             nextWriteIndex === buffer.length &&\n-            (buffer[nextWriteIndex] = createPendingChunk(response));\n+            (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n             nextWriteIndex < buffer.length;\n \n           )\n-            triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n         }\n       });\n       return iterator;\n@@ -4920,21 +5168,7 @@\n           case \"F\":\n             return (\n               (value = value.slice(2)),\n-              (value = getOutlinedModel(\n-                response,\n-                value,\n-                obj,\n-                key,\n-                createModel\n-              )),\n-              loadServerReference$1(\n-                response,\n-                value.id,\n-                value.bound,\n-                initializingChunk,\n-                obj,\n-                key\n-              )\n+              getOutlinedModel(response, value, obj, key, loadServerReference$1)\n             );\n           case \"T\":\n             if (\n@@ -5070,10 +5304,12 @@\n     function resolveField(response, key, value) {\n       response._formData.append(key, value);\n       var prefix = response._prefix;\n-      key.startsWith(prefix) &&\n-        ((response = response._chunks),\n-        (key = +key.slice(prefix.length)),\n-        (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));\n+      if (key.startsWith(prefix)) {\n+        var chunks = response._chunks;\n+        key = +key.slice(prefix.length);\n+        (chunks = chunks.get(key)) &&\n+          resolveModelChunk(response, chunks, value, key);\n+      }\n     }\n     function close(response) {\n       reportGlobalError(response, Error(\"Connection closed.\"));\n@@ -5835,33 +6071,32 @@\n       emptyRoot = {},\n       decoderOptions = { stream: !0 },\n       instrumentedChunks = new WeakSet(),\n-      loadedChunks = new WeakSet();\n-    Chunk.prototype = Object.create(Promise.prototype);\n-    Chunk.prototype.then = function (resolve, reject) {\n+      loadedChunks = new WeakSet(),\n+      RESPONSE_SYMBOL = Symbol();\n+    ReactPromise.prototype = Object.create(Promise.prototype);\n+    ReactPromise.prototype.then = function (resolve, reject) {\n       switch (this.status) {\n         case \"resolved_model\":\n           initializeModelChunk(this);\n       }\n       switch (this.status) {\n         case \"fulfilled\":\n-          resolve(this.value);\n+          \"function\" === typeof resolve && resolve(this.value);\n           break;\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          resolve &&\n+          \"function\" === typeof resolve &&\n             (null === this.value && (this.value = []),\n             this.value.push(resolve));\n-          reject &&\n+          \"function\" === typeof reject &&\n             (null === this.reason && (this.reason = []),\n             this.reason.push(reject));\n           break;\n         default:\n-          reject(this.reason);\n+          \"function\" === typeof reject && reject(this.reason);\n       }\n     };\n-    var initializingChunk = null,\n-      initializingChunkBlockedModel = null;\n+    var initializingHandler = null;\n     exports.createClientModuleProxy = function (moduleId) {\n       moduleId = registerClientReferenceImpl({}, moduleId, !1);\n       return new Proxy(moduleId, proxyHandlers$1);\n@@ -5970,38 +6205,50 @@\n         pendingFiles = 0,\n         queuedFields = [];\n       busboyStream.on(\"field\", function (name, value) {\n-        0 < pendingFiles\n-          ? queuedFields.push(name, value)\n-          : resolveField(response, name, value);\n+        if (0 < pendingFiles) queuedFields.push(name, value);\n+        else\n+          try {\n+            resolveField(response, name, value);\n+          } catch (error) {\n+            busboyStream.destroy(error);\n+          }\n       });\n       busboyStream.on(\"file\", function (name, value, _ref2) {\n         var filename = _ref2.filename,\n           mimeType = _ref2.mimeType;\n         if (\"base64\" === _ref2.encoding.toLowerCase())\n-          throw Error(\n-            \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+          busboyStream.destroy(\n+            Error(\n+              \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+            )\n           );\n-        pendingFiles++;\n-        var JSCompiler_object_inline_chunks_273 = [];\n-        value.on(\"data\", function (chunk) {\n-          JSCompiler_object_inline_chunks_273.push(chunk);\n-        });\n-        value.on(\"end\", function () {\n-          var blob = new Blob(JSCompiler_object_inline_chunks_273, {\n-            type: mimeType\n+        else {\n+          pendingFiles++;\n+          var JSCompiler_object_inline_chunks_276 = [];\n+          value.on(\"data\", function (chunk) {\n+            JSCompiler_object_inline_chunks_276.push(chunk);\n           });\n-          response._formData.append(name, blob, filename);\n-          pendingFiles--;\n-          if (0 === pendingFiles) {\n-            for (blob = 0; blob < queuedFields.length; blob += 2)\n-              resolveField(\n-                response,\n-                queuedFields[blob],\n-                queuedFields[blob + 1]\n-              );\n-            queuedFields.length = 0;\n-          }\n-        });\n+          value.on(\"end\", function () {\n+            try {\n+              var blob = new Blob(JSCompiler_object_inline_chunks_276, {\n+                type: mimeType\n+              });\n+              response._formData.append(name, blob, filename);\n+              pendingFiles--;\n+              if (0 === pendingFiles) {\n+                for (blob = 0; blob < queuedFields.length; blob += 2)\n+                  resolveField(\n+                    response,\n+                    queuedFields[blob],\n+                    queuedFields[blob + 1]\n+                  );\n+                queuedFields.length = 0;\n+              }\n+            } catch (error) {\n+              busboyStream.destroy(error);\n+            }\n+          });\n+        }\n       });\n       busboyStream.on(\"finish\", function () {\n         close(response);"
        },
        {
            "sha": "1bda77e872476599873dc1a2248886b262fd509a",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.node.production.js",
            "status": "modified",
            "additions": 469,
            "deletions": 227,
            "changes": 696,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.node.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -978,8 +978,8 @@ function serializeReadableStream(request, task, stream) {\n               : tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             reader.read().then(progress, error);\n-        } catch (x$8) {\n-          error(x$8);\n+        } catch (x$11) {\n+          error(x$11);\n         }\n   }\n   function error(reason) {\n@@ -1064,8 +1064,8 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n             tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             iterator.next().then(progress, error);\n-        } catch (x$9) {\n-          error(x$9);\n+        } catch (x$12) {\n+          error(x$12);\n         }\n   }\n   function error(reason) {\n@@ -2211,9 +2211,9 @@ function abort(request, reason) {\n         onAllReady();\n         flushCompletedChunks(request);\n       }\n-    } catch (error$23) {\n-      logRecoverableError(request, error$23, null),\n-        fatalError(request, error$23);\n+    } catch (error$26) {\n+      logRecoverableError(request, error$26, null),\n+        fatalError(request, error$26);\n     }\n }\n function resolveServerReference(bundlerConfig, id) {\n@@ -2281,59 +2281,97 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n-}\n-function Chunk(status, value, reason, response) {\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n+}\n+var RESPONSE_SYMBOL = Symbol();\n+function ReactPromise(status, value, reason) {\n   this.status = status;\n   this.value = value;\n   this.reason = reason;\n-  this._response = response;\n }\n-Chunk.prototype = Object.create(Promise.prototype);\n-Chunk.prototype.then = function (resolve, reject) {\n+ReactPromise.prototype = Object.create(Promise.prototype);\n+ReactPromise.prototype.then = function (resolve, reject) {\n   switch (this.status) {\n     case \"resolved_model\":\n       initializeModelChunk(this);\n   }\n   switch (this.status) {\n     case \"fulfilled\":\n-      resolve(this.value);\n+      \"function\" === typeof resolve && resolve(this.value);\n       break;\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      resolve &&\n+      \"function\" === typeof resolve &&\n         (null === this.value && (this.value = []), this.value.push(resolve));\n-      reject &&\n+      \"function\" === typeof reject &&\n         (null === this.reason && (this.reason = []), this.reason.push(reject));\n       break;\n     default:\n-      reject(this.reason);\n+      \"function\" === typeof reject && reject(this.reason);\n   }\n };\n-function createPendingChunk(response) {\n-  return new Chunk(\"pending\", null, null, response);\n+function wakeChunk(response, listeners, value) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(value)\n+      : fulfillReference(response, listener, value);\n+  }\n }\n-function wakeChunk(listeners, value) {\n-  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+function rejectChunk(response, listeners, error) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(error)\n+      : rejectReference(response, listener.handler, error);\n+  }\n }\n-function triggerErrorOnChunk(chunk, error) {\n+function resolveBlockedCycle(resolvedChunk, reference) {\n+  var referencedChunk = reference.handler.chunk;\n+  if (null === referencedChunk) return null;\n+  if (referencedChunk === resolvedChunk) return reference.handler;\n+  reference = referencedChunk.value;\n+  if (null !== reference)\n+    for (\n+      referencedChunk = 0;\n+      referencedChunk < reference.length;\n+      referencedChunk++\n+    ) {\n+      var listener = reference[referencedChunk];\n+      if (\n+        \"function\" !== typeof listener &&\n+        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+        null !== listener)\n+      )\n+        return listener;\n+    }\n+  return null;\n+}\n+function triggerErrorOnChunk(response, chunk, error) {\n   if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n     chunk.reason.error(error);\n   else {\n     var listeners = chunk.reason;\n     chunk.status = \"rejected\";\n     chunk.reason = error;\n-    null !== listeners && wakeChunk(listeners, error);\n+    null !== listeners && rejectChunk(response, listeners, error);\n   }\n }\n-function resolveModelChunk(chunk, value, id) {\n+function createResolvedModelChunk(response, value, id) {\n+  var $jscomp$compprop2 = {};\n+  return new ReactPromise(\n+    \"resolved_model\",\n+    value,\n+    (($jscomp$compprop2.id = id),\n+    ($jscomp$compprop2[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop2)\n+  );\n+}\n+function resolveModelChunk(response, chunk, value, id) {\n   if (\"pending\" !== chunk.status)\n     (chunk = chunk.reason),\n       \"C\" === value[0]\n@@ -2344,77 +2382,129 @@ function resolveModelChunk(chunk, value, id) {\n       rejectListeners = chunk.reason;\n     chunk.status = \"resolved_model\";\n     chunk.value = value;\n-    chunk.reason = id;\n+    value = {};\n+    chunk.reason =\n+      ((value.id = id), (value[RESPONSE_SYMBOL] = response), value);\n     if (null !== resolveListeners)\n-      switch ((initializeModelChunk(chunk), chunk.status)) {\n+      a: switch ((initializeModelChunk(chunk), chunk.status)) {\n         case \"fulfilled\":\n-          wakeChunk(resolveListeners, chunk.value);\n+          wakeChunk(response, resolveListeners, chunk.value);\n           break;\n-        case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n+          for (value = 0; value < resolveListeners.length; value++)\n+            if (((id = resolveListeners[value]), \"function\" !== typeof id)) {\n+              var cyclicHandler = resolveBlockedCycle(chunk, id);\n+              if (null !== cyclicHandler)\n+                switch (\n+                  (fulfillReference(response, id, cyclicHandler.value),\n+                  resolveListeners.splice(value, 1),\n+                  value--,\n+                  null !== rejectListeners &&\n+                    ((id = rejectListeners.indexOf(id)),\n+                    -1 !== id && rejectListeners.splice(id, 1)),\n+                  chunk.status)\n+                ) {\n+                  case \"fulfilled\":\n+                    wakeChunk(response, resolveListeners, chunk.value);\n+                    break a;\n+                  case \"rejected\":\n+                    null !== rejectListeners &&\n+                      rejectChunk(response, rejectListeners, chunk.reason);\n+                    break a;\n+                }\n+            }\n+        case \"pending\":\n           if (chunk.value)\n-            for (value = 0; value < resolveListeners.length; value++)\n-              chunk.value.push(resolveListeners[value]);\n+            for (response = 0; response < resolveListeners.length; response++)\n+              chunk.value.push(resolveListeners[response]);\n           else chunk.value = resolveListeners;\n           if (chunk.reason) {\n             if (rejectListeners)\n-              for (value = 0; value < rejectListeners.length; value++)\n-                chunk.reason.push(rejectListeners[value]);\n+              for (\n+                resolveListeners = 0;\n+                resolveListeners < rejectListeners.length;\n+                resolveListeners++\n+              )\n+                chunk.reason.push(rejectListeners[resolveListeners]);\n           } else chunk.reason = rejectListeners;\n           break;\n         case \"rejected\":\n-          rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+          rejectListeners && wakeChunk(response, rejectListeners, chunk.reason);\n       }\n   }\n }\n function createResolvedIteratorResultChunk(response, value, done) {\n-  return new Chunk(\n+  var $jscomp$compprop4 = {};\n+  return new ReactPromise(\n     \"resolved_model\",\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n-    -1,\n-    response\n+    (($jscomp$compprop4.id = -1),\n+    ($jscomp$compprop4[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop4)\n   );\n }\n-function resolveIteratorResultChunk(chunk, value, done) {\n+function resolveIteratorResultChunk(response, chunk, value, done) {\n   resolveModelChunk(\n+    response,\n     chunk,\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n     -1\n   );\n }\n-function loadServerReference$1(\n-  response,\n-  id,\n-  bound,\n-  parentChunk,\n-  parentObject,\n-  key\n-) {\n+function loadServerReference$1(response, metaData, parentObject, key) {\n+  var id = metaData.id;\n+  if (\"string\" !== typeof id) return null;\n   var serverReference = resolveServerReference(response._bundlerConfig, id);\n-  id = preloadModule(serverReference);\n-  if (bound)\n-    bound = Promise.all([bound, id]).then(function (_ref) {\n-      _ref = _ref[0];\n-      var fn = requireModule(serverReference);\n-      return fn.bind.apply(fn, [null].concat(_ref));\n-    });\n-  else if (id)\n-    bound = Promise.resolve(id).then(function () {\n-      return requireModule(serverReference);\n-    });\n+  id = metaData.bound;\n+  var promise = preloadModule(serverReference);\n+  if (promise)\n+    id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+  else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n   else return requireModule(serverReference);\n-  bound.then(\n-    createModelResolver(\n-      parentChunk,\n-      parentObject,\n-      key,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(parentChunk)\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n+  promise.then(\n+    function () {\n+      var resolvedValue = requireModule(serverReference);\n+      if (metaData.bound) {\n+        var promiseValue = metaData.bound.value;\n+        promiseValue = Array.isArray(promiseValue) ? promiseValue.slice(0) : [];\n+        promiseValue.unshift(null);\n+        resolvedValue = resolvedValue.bind.apply(resolvedValue, promiseValue);\n+      }\n+      parentObject[key] = resolvedValue;\n+      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((resolvedValue = handler.chunk),\n+        null !== resolvedValue &&\n+          \"blocked\" === resolvedValue.status &&\n+          ((promiseValue = resolvedValue.value),\n+          (resolvedValue.status = \"fulfilled\"),\n+          (resolvedValue.value = handler.value),\n+          null !== promiseValue &&\n+            wakeChunk(response, promiseValue, handler.value)));\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n@@ -2444,53 +2534,65 @@ function reviveModel(response, parentObj, parentKey, value, reference) {\n               ? reference + \":\" + i\n               : void 0),\n           (parentObj = reviveModel(response, value, i, value[i], parentObj)),\n-          void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+          void 0 !== parentObj || \"__proto__\" === i\n+            ? (value[i] = parentObj)\n+            : delete value[i]);\n   return value;\n }\n-var initializingChunk = null,\n-  initializingChunkBlockedModel = null;\n+var initializingHandler = null;\n function initializeModelChunk(chunk) {\n-  var prevChunk = initializingChunk,\n-    prevBlocked = initializingChunkBlockedModel;\n-  initializingChunk = chunk;\n-  initializingChunkBlockedModel = null;\n-  var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-    resolvedModel = chunk.value;\n-  chunk.status = \"cyclic\";\n+  var prevHandler = initializingHandler;\n+  initializingHandler = null;\n+  var _chunk$reason = chunk.reason,\n+    response = _chunk$reason[RESPONSE_SYMBOL];\n+  _chunk$reason = _chunk$reason.id;\n+  _chunk$reason = -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+  var resolvedModel = chunk.value;\n+  chunk.status = \"blocked\";\n   chunk.value = null;\n   chunk.reason = null;\n   try {\n     var rawModel = JSON.parse(resolvedModel),\n       value = reviveModel(\n-        chunk._response,\n+        response,\n         { \"\": rawModel },\n         \"\",\n         rawModel,\n-        rootReference\n-      );\n-    if (\n-      null !== initializingChunkBlockedModel &&\n-      0 < initializingChunkBlockedModel.deps\n-    )\n-      (initializingChunkBlockedModel.value = value), (chunk.status = \"blocked\");\n-    else {\n-      var resolveListeners = chunk.value;\n-      chunk.status = \"fulfilled\";\n-      chunk.value = value;\n-      null !== resolveListeners && wakeChunk(resolveListeners, value);\n+        _chunk$reason\n+      ),\n+      resolveListeners = chunk.value;\n+    if (null !== resolveListeners)\n+      for (\n+        chunk.value = null, chunk.reason = null, rawModel = 0;\n+        rawModel < resolveListeners.length;\n+        rawModel++\n+      ) {\n+        var listener = resolveListeners[rawModel];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n+    if (null !== initializingHandler) {\n+      if (initializingHandler.errored) throw initializingHandler.reason;\n+      if (0 < initializingHandler.deps) {\n+        initializingHandler.value = value;\n+        initializingHandler.chunk = chunk;\n+        return;\n+      }\n     }\n+    chunk.status = \"fulfilled\";\n+    chunk.value = value;\n   } catch (error) {\n     (chunk.status = \"rejected\"), (chunk.reason = error);\n   } finally {\n-    (initializingChunk = prevChunk),\n-      (initializingChunkBlockedModel = prevBlocked);\n+    initializingHandler = prevHandler;\n   }\n }\n function reportGlobalError(response, error) {\n   response._closed = !0;\n   response._closedReason = error;\n   response._chunks.forEach(function (chunk) {\n-    \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+    \"pending\" === chunk.status && triggerErrorOnChunk(response, chunk, error);\n   });\n }\n function getChunk(response, id) {\n@@ -2499,48 +2601,104 @@ function getChunk(response, id) {\n   chunk ||\n     ((chunk = response._formData.get(response._prefix + id)),\n     (chunk =\n-      null != chunk\n-        ? new Chunk(\"resolved_model\", chunk, id, response)\n+      \"string\" === typeof chunk\n+        ? createResolvedModelChunk(response, chunk, id)\n         : response._closed\n-          ? new Chunk(\"rejected\", null, response._closedReason, response)\n-          : createPendingChunk(response)),\n+          ? new ReactPromise(\"rejected\", null, response._closedReason)\n+          : new ReactPromise(\"pending\", null, null)),\n     chunks.set(id, chunk));\n   return chunk;\n }\n-function createModelResolver(\n-  chunk,\n+function fulfillReference(response, reference, value) {\n+  for (\n+    var handler = reference.handler,\n+      parentObject = reference.parentObject,\n+      key = reference.key,\n+      map = reference.map,\n+      path = reference.path,\n+      i = 1;\n+    i < path.length;\n+    i++\n+  ) {\n+    for (; value instanceof ReactPromise; ) {\n+      switch (value.status) {\n+        case \"resolved_model\":\n+          initializeModelChunk(value);\n+      }\n+      switch (value.status) {\n+        case \"fulfilled\":\n+          value = value.value;\n+          continue;\n+        case \"blocked\":\n+        case \"pending\":\n+          path.splice(0, i - 1);\n+          null === value.value\n+            ? (value.value = [reference])\n+            : value.value.push(reference);\n+          null === value.reason\n+            ? (value.reason = [reference])\n+            : value.reason.push(reference);\n+          return;\n+        default:\n+          rejectReference(response, reference.handler, value.reason);\n+          return;\n+      }\n+    }\n+    var name = path[i];\n+    \"object\" === typeof value &&\n+      hasOwnProperty.call(value, name) &&\n+      (value = value[name]);\n+  }\n+  reference = map(response, value, parentObject, key);\n+  parentObject[key] = reference;\n+  \"\" === key && null === handler.value && (handler.value = reference);\n+  handler.deps--;\n+  0 === handler.deps &&\n+    ((parentObject = handler.chunk),\n+    null !== parentObject &&\n+      \"blocked\" === parentObject.status &&\n+      ((key = parentObject.value),\n+      (parentObject.status = \"fulfilled\"),\n+      (parentObject.value = handler.value),\n+      (parentObject.reason = handler.reason),\n+      null !== key && wakeChunk(response, key, handler.value)));\n+}\n+function rejectReference(response, handler, error) {\n+  handler.errored ||\n+    ((handler.errored = !0),\n+    (handler.value = null),\n+    (handler.reason = error),\n+    (handler = handler.chunk),\n+    null !== handler &&\n+      \"blocked\" === handler.status &&\n+      triggerErrorOnChunk(response, handler, error));\n+}\n+function waitForReference(\n+  referencedChunk,\n   parentObject,\n   key,\n-  cyclic,\n   response,\n   map,\n   path\n ) {\n-  if (initializingChunkBlockedModel) {\n-    var blocked = initializingChunkBlockedModel;\n-    cyclic || blocked.deps++;\n-  } else\n-    blocked = initializingChunkBlockedModel = {\n-      deps: cyclic ? 0 : 1,\n-      value: null\n-    };\n-  return function (value) {\n-    for (var i = 1; i < path.length; i++) value = value[path[i]];\n-    parentObject[key] = map(response, value);\n-    \"\" === key && null === blocked.value && (blocked.value = parentObject[key]);\n-    blocked.deps--;\n-    0 === blocked.deps &&\n-      \"blocked\" === chunk.status &&\n-      ((value = chunk.value),\n-      (chunk.status = \"fulfilled\"),\n-      (chunk.value = blocked.value),\n-      null !== value && wakeChunk(value, blocked.value));\n-  };\n-}\n-function createModelReject(chunk) {\n-  return function (error) {\n-    return triggerErrorOnChunk(chunk, error);\n+  initializingHandler\n+    ? ((response = initializingHandler), response.deps++)\n+    : (response = initializingHandler =\n+        { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+  parentObject = {\n+    handler: response,\n+    parentObject: parentObject,\n+    key: key,\n+    map: map,\n+    path: path\n   };\n+  null === referencedChunk.value\n+    ? (referencedChunk.value = [parentObject])\n+    : referencedChunk.value.push(parentObject);\n+  null === referencedChunk.reason\n+    ? (referencedChunk.reason = [parentObject])\n+    : referencedChunk.reason.push(parentObject);\n+  return null;\n }\n function getOutlinedModel(response, reference, parentObject, key, map) {\n   reference = reference.split(\":\");\n@@ -2552,29 +2710,68 @@ function getOutlinedModel(response, reference, parentObject, key, map) {\n   }\n   switch (id.status) {\n     case \"fulfilled\":\n-      parentObject = id.value;\n-      for (key = 1; key < reference.length; key++)\n-        parentObject = parentObject[reference[key]];\n-      return map(response, parentObject);\n+      var value = id.value;\n+      for (id = 1; id < reference.length; id++) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              break;\n+            case \"blocked\":\n+            case \"pending\":\n+              return waitForReference(\n+                value,\n+                parentObject,\n+                key,\n+                response,\n+                map,\n+                reference.slice(id - 1)\n+              );\n+            default:\n+              return (\n+                initializingHandler\n+                  ? ((initializingHandler.errored = !0),\n+                    (initializingHandler.value = null),\n+                    (initializingHandler.reason = value.reason))\n+                  : (initializingHandler = {\n+                      chunk: null,\n+                      value: null,\n+                      reason: value.reason,\n+                      deps: 0,\n+                      errored: !0\n+                    }),\n+                null\n+              );\n+          }\n+        }\n+        var name = reference[id];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      return map(response, value, parentObject, key);\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      var parentChunk = initializingChunk;\n-      id.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          \"cyclic\" === id.status,\n-          response,\n-          map,\n-          reference\n-        ),\n-        createModelReject(parentChunk)\n-      );\n-      return null;\n+      return waitForReference(id, parentObject, key, response, map, reference);\n     default:\n-      throw id.reason;\n+      return (\n+        initializingHandler\n+          ? ((initializingHandler.errored = !0),\n+            (initializingHandler.value = null),\n+            (initializingHandler.reason = id.reason))\n+          : (initializingHandler = {\n+              chunk: null,\n+              value: null,\n+              reason: id.reason,\n+              deps: 0,\n+              errored: !0\n+            }),\n+        null\n+      );\n   }\n }\n function createMap(response, model) {\n@@ -2598,38 +2795,63 @@ function parseTypedArray(\n   parentKey\n ) {\n   reference = parseInt(reference.slice(2), 16);\n-  reference = response._formData.get(response._prefix + reference);\n-  reference =\n-    constructor === ArrayBuffer\n-      ? reference.arrayBuffer()\n-      : reference.arrayBuffer().then(function (buffer) {\n-          return new constructor(buffer);\n-        });\n-  bytesPerElement = initializingChunk;\n+  reference = response._formData\n+    .get(response._prefix + reference)\n+    .arrayBuffer();\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n   reference.then(\n-    createModelResolver(\n-      bytesPerElement,\n-      parentObject,\n-      parentKey,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(bytesPerElement)\n+    function (buffer) {\n+      buffer = constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+      parentObject[parentKey] = buffer;\n+      \"\" === parentKey && null === handler.value && (handler.value = buffer);\n+      handler.deps--;\n+      if (\n+        0 === handler.deps &&\n+        ((buffer = handler.chunk),\n+        null !== buffer && \"blocked\" === buffer.status)\n+      ) {\n+        var resolveListeners = buffer.value;\n+        buffer.status = \"fulfilled\";\n+        buffer.value = handler.value;\n+        null !== resolveListeners &&\n+          wakeChunk(response, resolveListeners, handler.value);\n+      }\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n function resolveStream(response, id, stream, controller) {\n   var chunks = response._chunks;\n-  stream = new Chunk(\"fulfilled\", stream, controller, response);\n+  stream = new ReactPromise(\"fulfilled\", stream, controller);\n   chunks.set(id, stream);\n   response = response._formData.getAll(response._prefix + id);\n   for (id = 0; id < response.length; id++)\n     (chunks = response[id]),\n-      \"C\" === chunks[0]\n-        ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n-        : controller.enqueueModel(chunks);\n+      \"string\" === typeof chunks &&\n+        (\"C\" === chunks[0]\n+          ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n+          : controller.enqueueModel(chunks));\n }\n function parseReadableStream(response, reference, type) {\n   reference = parseInt(reference.slice(2), 16);\n@@ -2644,7 +2866,7 @@ function parseReadableStream(response, reference, type) {\n   resolveStream(response, reference, type, {\n     enqueueModel: function (json) {\n       if (null === previousBlockedChunk) {\n-        var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+        var chunk = createResolvedModelChunk(response, json, -1);\n         initializeModelChunk(chunk);\n         \"fulfilled\" === chunk.status\n           ? controller.enqueue(chunk.value)\n@@ -2659,19 +2881,19 @@ function parseReadableStream(response, reference, type) {\n             (previousBlockedChunk = chunk));\n       } else {\n         chunk = previousBlockedChunk;\n-        var chunk$26 = createPendingChunk(response);\n-        chunk$26.then(\n+        var chunk$30 = new ReactPromise(\"pending\", null, null);\n+        chunk$30.then(\n           function (v) {\n             return controller.enqueue(v);\n           },\n           function (e) {\n             return controller.error(e);\n           }\n         );\n-        previousBlockedChunk = chunk$26;\n+        previousBlockedChunk = chunk$30;\n         chunk.then(function () {\n-          previousBlockedChunk === chunk$26 && (previousBlockedChunk = null);\n-          resolveModelChunk(chunk$26, json, -1);\n+          previousBlockedChunk === chunk$30 && (previousBlockedChunk = null);\n+          resolveModelChunk(response, chunk$30, json, -1);\n         });\n       }\n     },\n@@ -2711,9 +2933,9 @@ function parseAsyncIterable(response, reference, iterator) {\n   var buffer = [],\n     closed = !1,\n     nextWriteIndex = 0,\n-    $jscomp$compprop2 = {};\n-  $jscomp$compprop2 =\n-    (($jscomp$compprop2[ASYNC_ITERATOR] = function () {\n+    $jscomp$compprop5 = {};\n+  $jscomp$compprop5 =\n+    (($jscomp$compprop5[ASYNC_ITERATOR] = function () {\n       var nextReadIndex = 0;\n       return createIterator(function (arg) {\n         if (void 0 !== arg)\n@@ -2722,19 +2944,18 @@ function parseAsyncIterable(response, reference, iterator) {\n           );\n         if (nextReadIndex === buffer.length) {\n           if (closed)\n-            return new Chunk(\n+            return new ReactPromise(\n               \"fulfilled\",\n               { done: !0, value: void 0 },\n-              null,\n-              response\n+              null\n             );\n-          buffer[nextReadIndex] = createPendingChunk(response);\n+          buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n         }\n         return buffer[nextReadIndex++];\n       });\n     }),\n-    $jscomp$compprop2);\n-  iterator = iterator ? $jscomp$compprop2[ASYNC_ITERATOR]() : $jscomp$compprop2;\n+    $jscomp$compprop5);\n+  iterator = iterator ? $jscomp$compprop5[ASYNC_ITERATOR]() : $jscomp$compprop5;\n   resolveStream(response, reference, iterator, {\n     enqueueModel: function (value) {\n       nextWriteIndex === buffer.length\n@@ -2743,7 +2964,12 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !1\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !1\n+          );\n       nextWriteIndex++;\n     },\n     close: function (value) {\n@@ -2754,9 +2980,15 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !0\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !0\n+          );\n       for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n         resolveIteratorResultChunk(\n+          response,\n           buffer[nextWriteIndex++],\n           '\"$undefined\"',\n           !0\n@@ -2766,11 +2998,11 @@ function parseAsyncIterable(response, reference, iterator) {\n       closed = !0;\n       for (\n         nextWriteIndex === buffer.length &&\n-        (buffer[nextWriteIndex] = createPendingChunk(response));\n+        (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n         nextWriteIndex < buffer.length;\n \n       )\n-        triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+        triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n     }\n   });\n   return iterator;\n@@ -2785,15 +3017,7 @@ function parseModelString(response, obj, key, value, reference) {\n       case \"F\":\n         return (\n           (value = value.slice(2)),\n-          (value = getOutlinedModel(response, value, obj, key, createModel)),\n-          loadServerReference$1(\n-            response,\n-            value.id,\n-            value.bound,\n-            initializingChunk,\n-            obj,\n-            key\n-          )\n+          getOutlinedModel(response, value, obj, key, loadServerReference$1)\n         );\n       case \"T\":\n         if (void 0 === reference || void 0 === response._temporaryReferences)\n@@ -2908,10 +3132,12 @@ function createResponse(bundlerConfig, formFieldPrefix, temporaryReferences) {\n function resolveField(response, key, value) {\n   response._formData.append(key, value);\n   var prefix = response._prefix;\n-  key.startsWith(prefix) &&\n-    ((response = response._chunks),\n-    (key = +key.slice(prefix.length)),\n-    (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));\n+  if (key.startsWith(prefix)) {\n+    var chunks = response._chunks;\n+    key = +key.slice(prefix.length);\n+    (chunks = chunks.get(key)) &&\n+      resolveModelChunk(response, chunks, value, key);\n+  }\n }\n function close(response) {\n   reportGlobalError(response, Error(\"Connection closed.\"));\n@@ -3080,34 +3306,50 @@ exports.decodeReplyFromBusboy = function (busboyStream, turbopackMap, options) {\n     pendingFiles = 0,\n     queuedFields = [];\n   busboyStream.on(\"field\", function (name, value) {\n-    0 < pendingFiles\n-      ? queuedFields.push(name, value)\n-      : resolveField(response, name, value);\n+    if (0 < pendingFiles) queuedFields.push(name, value);\n+    else\n+      try {\n+        resolveField(response, name, value);\n+      } catch (error) {\n+        busboyStream.destroy(error);\n+      }\n   });\n   busboyStream.on(\"file\", function (name, value, _ref2) {\n     var filename = _ref2.filename,\n       mimeType = _ref2.mimeType;\n     if (\"base64\" === _ref2.encoding.toLowerCase())\n-      throw Error(\n-        \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+      busboyStream.destroy(\n+        Error(\n+          \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+        )\n       );\n-    pendingFiles++;\n-    var JSCompiler_object_inline_chunks_274 = [];\n-    value.on(\"data\", function (chunk) {\n-      JSCompiler_object_inline_chunks_274.push(chunk);\n-    });\n-    value.on(\"end\", function () {\n-      var blob = new Blob(JSCompiler_object_inline_chunks_274, {\n-        type: mimeType\n+    else {\n+      pendingFiles++;\n+      var JSCompiler_object_inline_chunks_281 = [];\n+      value.on(\"data\", function (chunk) {\n+        JSCompiler_object_inline_chunks_281.push(chunk);\n       });\n-      response._formData.append(name, blob, filename);\n-      pendingFiles--;\n-      if (0 === pendingFiles) {\n-        for (blob = 0; blob < queuedFields.length; blob += 2)\n-          resolveField(response, queuedFields[blob], queuedFields[blob + 1]);\n-        queuedFields.length = 0;\n-      }\n-    });\n+      value.on(\"end\", function () {\n+        try {\n+          var blob = new Blob(JSCompiler_object_inline_chunks_281, {\n+            type: mimeType\n+          });\n+          response._formData.append(name, blob, filename);\n+          pendingFiles--;\n+          if (0 === pendingFiles) {\n+            for (blob = 0; blob < queuedFields.length; blob += 2)\n+              resolveField(\n+                response,\n+                queuedFields[blob],\n+                queuedFields[blob + 1]\n+              );\n+            queuedFields.length = 0;\n+          }\n+        } catch (error) {\n+          busboyStream.destroy(error);\n+        }\n+      });\n+    }\n   });\n   busboyStream.on(\"finish\", function () {\n     close(response);"
        },
        {
            "sha": "6a6a848024146e5b739f8e2178e73c553e851389",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fpackage.json?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -48,7 +48,7 @@\n     \"neo-async\": \"^2.6.1\"\n   },\n   \"peerDependencies\": {\n-    \"react\": \"19.3.0-canary-fd524fe0-20251121\",\n-    \"react-dom\": \"19.3.0-canary-fd524fe0-20251121\"\n+    \"react\": \"19.3.0-canary-7dc903cd-20251203\",\n+    \"react-dom\": \"19.3.0-canary-7dc903cd-20251203\"\n   }\n }\n\\ No newline at end of file"
        },
        {
            "sha": "388ee4bbb3bf6015f59bf9dfdc69e661ec4ebb81",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-client.browser.development.js",
            "status": "modified",
            "additions": 8,
            "deletions": 10,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.browser.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -102,13 +102,11 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function loadChunk(chunkId, filename) {\n       chunkMap.set(chunkId, filename);\n@@ -4768,6 +4766,7 @@\n       ReactDOM = require(\"react-dom\"),\n       decoderOptions = { stream: !0 },\n       bind = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       chunkCache = new Map(),\n       chunkMap = new Map(),\n       webpackGetChunkFilename = __webpack_require__.u;\n@@ -4807,7 +4806,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&\n@@ -4984,10 +4982,10 @@\n       return hook.checkDCE ? !0 : !1;\n     })({\n       bundleType: 1,\n-      version: \"19.3.0-experimental-fd524fe0-20251121\",\n+      version: \"19.3.0-experimental-7dc903cd-20251203\",\n       rendererPackageName: \"react-server-dom-webpack\",\n       currentDispatcherRef: ReactSharedInternals,\n-      reconcilerVersion: \"19.3.0-experimental-fd524fe0-20251121\",\n+      reconcilerVersion: \"19.3.0-experimental-7dc903cd-20251203\",\n       getCurrentComponentInfo: function () {\n         return currentOwnerInDEV;\n       }"
        },
        {
            "sha": "227adcd588dc0efe4dab39a991331bc1a7addaa9",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-client.browser.production.js",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.browser.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -10,7 +10,8 @@\n \n \"use strict\";\n var ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   if (bundlerConfig) {\n     var moduleExports = bundlerConfig[metadata[0]];\n@@ -100,13 +101,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n var chunkMap = new Map(),\n   webpackGetChunkFilename = __webpack_require__.u;"
        },
        {
            "sha": "36797863b2275e206fddc17f6d1496f4bf26bc7a",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-client.edge.development.js",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.edge.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -102,13 +102,11 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function prepareDestinationWithChunks(\n       moduleLoading,\n@@ -4801,6 +4799,7 @@\n       React = require(\"react\"),\n       decoderOptions = { stream: !0 },\n       bind$1 = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       chunkCache = new Map(),\n       ReactDOMSharedInternals =\n         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n@@ -4834,7 +4833,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&"
        },
        {
            "sha": "34cdddeccf10fff9d5450a946b32056b6a48def5",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-client.edge.production.js",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.edge.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -10,7 +10,8 @@\n \n \"use strict\";\n var ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   if (bundlerConfig) {\n     var moduleExports = bundlerConfig[metadata[0]];\n@@ -99,13 +100,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n function prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n   if (null !== moduleLoading)"
        },
        {
            "sha": "e63f6d2cf778d2c4aa880e8d1f7ee2b8bed4d6cd",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-client.node.development.js",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.node.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -102,13 +102,11 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function prepareDestinationWithChunks(\n       moduleLoading,\n@@ -4906,6 +4904,7 @@\n       React = require(\"react\"),\n       decoderOptions = { stream: !0 },\n       bind$1 = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       chunkCache = new Map(),\n       ReactDOMSharedInternals =\n         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n@@ -4939,7 +4938,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&"
        },
        {
            "sha": "487fd4ba84215e28a8f5882c8325b03ed19df3be",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-client.node.production.js",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.node.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -11,7 +11,8 @@\n \"use strict\";\n var util = require(\"util\"),\n   ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   if (bundlerConfig) {\n     var moduleExports = bundlerConfig[metadata[0]];\n@@ -100,13 +101,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n function prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n   if (null !== moduleLoading)"
        },
        {
            "sha": "5bc0cbb652f58fda8a1b93bc576fc0dceac0590c",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-client.node.unbundled.development.js",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.node.unbundled.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.node.unbundled.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.node.unbundled.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -66,11 +66,10 @@\n       if (\"fulfilled\" === moduleExports.status)\n         moduleExports = moduleExports.value;\n       else throw moduleExports.reason;\n-      return \"*\" === metadata.name\n-        ? moduleExports\n-        : \"\" === metadata.name\n-          ? moduleExports.default\n-          : moduleExports[metadata.name];\n+      if (\"*\" === metadata.name) return moduleExports;\n+      if (\"\" === metadata.name) return moduleExports.default;\n+      if (hasOwnProperty.call(moduleExports, metadata.name))\n+        return moduleExports[metadata.name];\n     }\n     function prepareDestinationWithChunks(\n       moduleLoading,\n@@ -4866,6 +4865,7 @@\n       React = require(\"react\"),\n       decoderOptions = { stream: !0 },\n       bind$1 = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       asyncModuleCache = new Map(),\n       ReactDOMSharedInternals =\n         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n@@ -4899,7 +4899,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&"
        },
        {
            "sha": "323f2b986f2516ea5bc8b716c6ae3de7f1e469d8",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-client.node.unbundled.production.js",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.node.unbundled.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.node.unbundled.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.node.unbundled.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -11,7 +11,8 @@\n \"use strict\";\n var util = require(\"util\"),\n   ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   var moduleExports = bundlerConfig[metadata[0]];\n   if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))\n@@ -67,11 +68,10 @@ function requireModule(metadata) {\n   var moduleExports = asyncModuleCache.get(metadata.specifier);\n   if (\"fulfilled\" === moduleExports.status) moduleExports = moduleExports.value;\n   else throw moduleExports.reason;\n-  return \"*\" === metadata.name\n-    ? moduleExports\n-    : \"\" === metadata.name\n-      ? moduleExports.default\n-      : moduleExports[metadata.name];\n+  if (\"*\" === metadata.name) return moduleExports;\n+  if (\"\" === metadata.name) return moduleExports.default;\n+  if (hasOwnProperty.call(moduleExports, metadata.name))\n+    return moduleExports[metadata.name];\n }\n function prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n   if (null !== moduleLoading)"
        },
        {
            "sha": "2798852a25e492b51199333d1cb6255c0c2afce1",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.browser.development.js",
            "status": "modified",
            "additions": 430,
            "deletions": 197,
            "changes": 627,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.browser.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -3947,41 +3947,69 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function loadChunk(chunkId, filename) {\n       chunkMap.set(chunkId, filename);\n       return __webpack_chunk_load__(chunkId);\n     }\n-    function Chunk(status, value, reason, response) {\n+    function ReactPromise(status, value, reason) {\n       this.status = status;\n       this.value = value;\n       this.reason = reason;\n-      this._response = response;\n     }\n-    function createPendingChunk(response) {\n-      return new Chunk(\"pending\", null, null, response);\n+    function wakeChunk(response, listeners, value) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n+    }\n+    function rejectChunk(response, listeners, error) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(error)\n+          : rejectReference(response, listener.handler, error);\n+      }\n     }\n-    function wakeChunk(listeners, value) {\n-      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+    function resolveBlockedCycle(resolvedChunk, reference) {\n+      var referencedChunk = reference.handler.chunk;\n+      if (null === referencedChunk) return null;\n+      if (referencedChunk === resolvedChunk) return reference.handler;\n+      reference = referencedChunk.value;\n+      if (null !== reference)\n+        for (\n+          referencedChunk = 0;\n+          referencedChunk < reference.length;\n+          referencedChunk++\n+        ) {\n+          var listener = reference[referencedChunk];\n+          if (\n+            \"function\" !== typeof listener &&\n+            ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+            null !== listener)\n+          )\n+            return listener;\n+        }\n+      return null;\n     }\n-    function triggerErrorOnChunk(chunk, error) {\n+    function triggerErrorOnChunk(response, chunk, error) {\n       if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n         chunk.reason.error(error);\n       else {\n         var listeners = chunk.reason;\n         chunk.status = \"rejected\";\n         chunk.reason = error;\n-        null !== listeners && wakeChunk(listeners, error);\n+        null !== listeners && rejectChunk(response, listeners, error);\n       }\n     }\n-    function resolveModelChunk(chunk, value, id) {\n+    function resolveModelChunk(response, chunk, value, id) {\n       if (\"pending\" !== chunk.status)\n         (chunk = chunk.reason),\n           \"C\" === value[0]\n@@ -3992,81 +4020,142 @@\n           rejectListeners = chunk.reason;\n         chunk.status = \"resolved_model\";\n         chunk.value = value;\n-        chunk.reason = id;\n+        chunk.reason = _defineProperty({ id: id }, RESPONSE_SYMBOL, response);\n         if (null !== resolveListeners)\n-          switch ((initializeModelChunk(chunk), chunk.status)) {\n+          a: switch ((initializeModelChunk(chunk), chunk.status)) {\n             case \"fulfilled\":\n-              wakeChunk(resolveListeners, chunk.value);\n+              wakeChunk(response, resolveListeners, chunk.value);\n               break;\n-            case \"pending\":\n             case \"blocked\":\n-            case \"cyclic\":\n+              for (value = 0; value < resolveListeners.length; value++)\n+                if (\n+                  ((id = resolveListeners[value]), \"function\" !== typeof id)\n+                ) {\n+                  var cyclicHandler = resolveBlockedCycle(chunk, id);\n+                  if (null !== cyclicHandler)\n+                    switch (\n+                      (fulfillReference(response, id, cyclicHandler.value),\n+                      resolveListeners.splice(value, 1),\n+                      value--,\n+                      null !== rejectListeners &&\n+                        ((id = rejectListeners.indexOf(id)),\n+                        -1 !== id && rejectListeners.splice(id, 1)),\n+                      chunk.status)\n+                    ) {\n+                      case \"fulfilled\":\n+                        wakeChunk(response, resolveListeners, chunk.value);\n+                        break a;\n+                      case \"rejected\":\n+                        null !== rejectListeners &&\n+                          rejectChunk(response, rejectListeners, chunk.reason);\n+                        break a;\n+                    }\n+                }\n+            case \"pending\":\n               if (chunk.value)\n-                for (value = 0; value < resolveListeners.length; value++)\n-                  chunk.value.push(resolveListeners[value]);\n+                for (\n+                  response = 0;\n+                  response < resolveListeners.length;\n+                  response++\n+                )\n+                  chunk.value.push(resolveListeners[response]);\n               else chunk.value = resolveListeners;\n               if (chunk.reason) {\n                 if (rejectListeners)\n-                  for (value = 0; value < rejectListeners.length; value++)\n-                    chunk.reason.push(rejectListeners[value]);\n+                  for (\n+                    resolveListeners = 0;\n+                    resolveListeners < rejectListeners.length;\n+                    resolveListeners++\n+                  )\n+                    chunk.reason.push(rejectListeners[resolveListeners]);\n               } else chunk.reason = rejectListeners;\n               break;\n             case \"rejected\":\n-              rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+              rejectListeners &&\n+                wakeChunk(response, rejectListeners, chunk.reason);\n           }\n       }\n     }\n     function createResolvedIteratorResultChunk(response, value, done) {\n-      return new Chunk(\n+      return new ReactPromise(\n         \"resolved_model\",\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n-        -1,\n-        response\n+        _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n       );\n     }\n-    function resolveIteratorResultChunk(chunk, value, done) {\n+    function resolveIteratorResultChunk(response, chunk, value, done) {\n       resolveModelChunk(\n+        response,\n         chunk,\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n         -1\n       );\n     }\n-    function loadServerReference$1(\n-      response,\n-      id,\n-      bound,\n-      parentChunk,\n-      parentObject,\n-      key\n-    ) {\n+    function loadServerReference$1(response, metaData, parentObject, key) {\n+      var id = metaData.id;\n+      if (\"string\" !== typeof id) return null;\n       var serverReference = resolveServerReference(response._bundlerConfig, id);\n-      id = preloadModule(serverReference);\n-      if (bound)\n-        bound = Promise.all([bound, id]).then(function (_ref) {\n-          _ref = _ref[0];\n-          var fn = requireModule(serverReference);\n-          return fn.bind.apply(fn, [null].concat(_ref));\n-        });\n-      else if (id)\n-        bound = Promise.resolve(id).then(function () {\n-          return requireModule(serverReference);\n-        });\n+      id = metaData.bound;\n+      var promise = preloadModule(serverReference);\n+      if (promise)\n+        id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+      else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n       else return requireModule(serverReference);\n-      bound.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(parentChunk)\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n+      promise.then(\n+        function () {\n+          var resolvedValue = requireModule(serverReference);\n+          if (metaData.bound) {\n+            var promiseValue = metaData.bound.value;\n+            promiseValue = Array.isArray(promiseValue)\n+              ? promiseValue.slice(0)\n+              : [];\n+            promiseValue.unshift(null);\n+            resolvedValue = resolvedValue.bind.apply(\n+              resolvedValue,\n+              promiseValue\n+            );\n+          }\n+          parentObject[key] = resolvedValue;\n+          \"\" === key &&\n+            null === handler.value &&\n+            (handler.value = resolvedValue);\n+          handler.deps--;\n+          0 === handler.deps &&\n+            ((resolvedValue = handler.chunk),\n+            null !== resolvedValue &&\n+              \"blocked\" === resolvedValue.status &&\n+              ((promiseValue = resolvedValue.value),\n+              (resolvedValue.status = \"fulfilled\"),\n+              (resolvedValue.value = handler.value),\n+              null !== promiseValue &&\n+                wakeChunk(response, promiseValue, handler.value)));\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n@@ -4108,53 +4197,66 @@\n                 value[i],\n                 parentObj\n               )),\n-              void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+              void 0 !== parentObj || \"__proto__\" === i\n+                ? (value[i] = parentObj)\n+                : delete value[i]);\n       return value;\n     }\n     function initializeModelChunk(chunk) {\n-      var prevChunk = initializingChunk,\n-        prevBlocked = initializingChunkBlockedModel;\n-      initializingChunk = chunk;\n-      initializingChunkBlockedModel = null;\n-      var rootReference =\n-          -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-        resolvedModel = chunk.value;\n-      chunk.status = \"cyclic\";\n+      var prevHandler = initializingHandler;\n+      initializingHandler = null;\n+      var _chunk$reason = chunk.reason,\n+        response = _chunk$reason[RESPONSE_SYMBOL];\n+      _chunk$reason = _chunk$reason.id;\n+      _chunk$reason =\n+        -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+      var resolvedModel = chunk.value;\n+      chunk.status = \"blocked\";\n       chunk.value = null;\n       chunk.reason = null;\n       try {\n         var rawModel = JSON.parse(resolvedModel),\n           value = reviveModel(\n-            chunk._response,\n+            response,\n             { \"\": rawModel },\n             \"\",\n             rawModel,\n-            rootReference\n-          );\n-        if (\n-          null !== initializingChunkBlockedModel &&\n-          0 < initializingChunkBlockedModel.deps\n-        )\n-          (initializingChunkBlockedModel.value = value),\n-            (chunk.status = \"blocked\");\n-        else {\n-          var resolveListeners = chunk.value;\n-          chunk.status = \"fulfilled\";\n-          chunk.value = value;\n-          null !== resolveListeners && wakeChunk(resolveListeners, value);\n+            _chunk$reason\n+          ),\n+          resolveListeners = chunk.value;\n+        if (null !== resolveListeners)\n+          for (\n+            chunk.value = null, chunk.reason = null, rawModel = 0;\n+            rawModel < resolveListeners.length;\n+            rawModel++\n+          ) {\n+            var listener = resolveListeners[rawModel];\n+            \"function\" === typeof listener\n+              ? listener(value)\n+              : fulfillReference(response, listener, value);\n+          }\n+        if (null !== initializingHandler) {\n+          if (initializingHandler.errored) throw initializingHandler.reason;\n+          if (0 < initializingHandler.deps) {\n+            initializingHandler.value = value;\n+            initializingHandler.chunk = chunk;\n+            return;\n+          }\n         }\n+        chunk.status = \"fulfilled\";\n+        chunk.value = value;\n       } catch (error) {\n         (chunk.status = \"rejected\"), (chunk.reason = error);\n       } finally {\n-        (initializingChunk = prevChunk),\n-          (initializingChunkBlockedModel = prevBlocked);\n+        initializingHandler = prevHandler;\n       }\n     }\n     function reportGlobalError(response, error) {\n       response._closed = !0;\n       response._closedReason = error;\n       response._chunks.forEach(function (chunk) {\n-        \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+        \"pending\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n       });\n     }\n     function getChunk(response, id) {\n@@ -4163,50 +4265,108 @@\n       chunk ||\n         ((chunk = response._formData.get(response._prefix + id)),\n         (chunk =\n-          null != chunk\n-            ? new Chunk(\"resolved_model\", chunk, id, response)\n+          \"string\" === typeof chunk\n+            ? new ReactPromise(\n+                \"resolved_model\",\n+                chunk,\n+                _defineProperty({ id: id }, RESPONSE_SYMBOL, response)\n+              )\n             : response._closed\n-              ? new Chunk(\"rejected\", null, response._closedReason, response)\n-              : createPendingChunk(response)),\n+              ? new ReactPromise(\"rejected\", null, response._closedReason)\n+              : new ReactPromise(\"pending\", null, null)),\n         chunks.set(id, chunk));\n       return chunk;\n     }\n-    function createModelResolver(\n-      chunk,\n+    function fulfillReference(response, reference, value) {\n+      for (\n+        var handler = reference.handler,\n+          parentObject = reference.parentObject,\n+          key = reference.key,\n+          map = reference.map,\n+          path = reference.path,\n+          i = 1;\n+        i < path.length;\n+        i++\n+      ) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              continue;\n+            case \"blocked\":\n+            case \"pending\":\n+              path.splice(0, i - 1);\n+              null === value.value\n+                ? (value.value = [reference])\n+                : value.value.push(reference);\n+              null === value.reason\n+                ? (value.reason = [reference])\n+                : value.reason.push(reference);\n+              return;\n+            default:\n+              rejectReference(response, reference.handler, value.reason);\n+              return;\n+          }\n+        }\n+        var name = path[i];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      reference = map(response, value, parentObject, key);\n+      parentObject[key] = reference;\n+      \"\" === key && null === handler.value && (handler.value = reference);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((parentObject = handler.chunk),\n+        null !== parentObject &&\n+          \"blocked\" === parentObject.status &&\n+          ((key = parentObject.value),\n+          (parentObject.status = \"fulfilled\"),\n+          (parentObject.value = handler.value),\n+          (parentObject.reason = handler.reason),\n+          null !== key && wakeChunk(response, key, handler.value)));\n+    }\n+    function rejectReference(response, handler, error) {\n+      handler.errored ||\n+        ((handler.errored = !0),\n+        (handler.value = null),\n+        (handler.reason = error),\n+        (handler = handler.chunk),\n+        null !== handler &&\n+          \"blocked\" === handler.status &&\n+          triggerErrorOnChunk(response, handler, error));\n+    }\n+    function waitForReference(\n+      referencedChunk,\n       parentObject,\n       key,\n-      cyclic,\n       response,\n       map,\n       path\n     ) {\n-      if (initializingChunkBlockedModel) {\n-        var blocked = initializingChunkBlockedModel;\n-        cyclic || blocked.deps++;\n-      } else\n-        blocked = initializingChunkBlockedModel = {\n-          deps: cyclic ? 0 : 1,\n-          value: null\n-        };\n-      return function (value) {\n-        for (var i = 1; i < path.length; i++) value = value[path[i]];\n-        parentObject[key] = map(response, value);\n-        \"\" === key &&\n-          null === blocked.value &&\n-          (blocked.value = parentObject[key]);\n-        blocked.deps--;\n-        0 === blocked.deps &&\n-          \"blocked\" === chunk.status &&\n-          ((value = chunk.value),\n-          (chunk.status = \"fulfilled\"),\n-          (chunk.value = blocked.value),\n-          null !== value && wakeChunk(value, blocked.value));\n-      };\n-    }\n-    function createModelReject(chunk) {\n-      return function (error) {\n-        return triggerErrorOnChunk(chunk, error);\n+      initializingHandler\n+        ? ((response = initializingHandler), response.deps++)\n+        : (response = initializingHandler =\n+            { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+      parentObject = {\n+        handler: response,\n+        parentObject: parentObject,\n+        key: key,\n+        map: map,\n+        path: path\n       };\n+      null === referencedChunk.value\n+        ? (referencedChunk.value = [parentObject])\n+        : referencedChunk.value.push(parentObject);\n+      null === referencedChunk.reason\n+        ? (referencedChunk.reason = [parentObject])\n+        : referencedChunk.reason.push(parentObject);\n+      return null;\n     }\n     function getOutlinedModel(response, reference, parentObject, key, map) {\n       reference = reference.split(\":\");\n@@ -4218,29 +4378,75 @@\n       }\n       switch (id.status) {\n         case \"fulfilled\":\n-          parentObject = id.value;\n-          for (key = 1; key < reference.length; key++)\n-            parentObject = parentObject[reference[key]];\n-          return map(response, parentObject);\n+          var value = id.value;\n+          for (id = 1; id < reference.length; id++) {\n+            for (; value instanceof ReactPromise; ) {\n+              switch (value.status) {\n+                case \"resolved_model\":\n+                  initializeModelChunk(value);\n+              }\n+              switch (value.status) {\n+                case \"fulfilled\":\n+                  value = value.value;\n+                  break;\n+                case \"blocked\":\n+                case \"pending\":\n+                  return waitForReference(\n+                    value,\n+                    parentObject,\n+                    key,\n+                    response,\n+                    map,\n+                    reference.slice(id - 1)\n+                  );\n+                default:\n+                  return (\n+                    initializingHandler\n+                      ? ((initializingHandler.errored = !0),\n+                        (initializingHandler.value = null),\n+                        (initializingHandler.reason = value.reason))\n+                      : (initializingHandler = {\n+                          chunk: null,\n+                          value: null,\n+                          reason: value.reason,\n+                          deps: 0,\n+                          errored: !0\n+                        }),\n+                    null\n+                  );\n+              }\n+            }\n+            var name = reference[id];\n+            \"object\" === typeof value &&\n+              hasOwnProperty.call(value, name) &&\n+              (value = value[name]);\n+          }\n+          return map(response, value, parentObject, key);\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          var parentChunk = initializingChunk;\n-          id.then(\n-            createModelResolver(\n-              parentChunk,\n-              parentObject,\n-              key,\n-              \"cyclic\" === id.status,\n-              response,\n-              map,\n-              reference\n-            ),\n-            createModelReject(parentChunk)\n+          return waitForReference(\n+            id,\n+            parentObject,\n+            key,\n+            response,\n+            map,\n+            reference\n           );\n-          return null;\n         default:\n-          throw id.reason;\n+          return (\n+            initializingHandler\n+              ? ((initializingHandler.errored = !0),\n+                (initializingHandler.value = null),\n+                (initializingHandler.reason = id.reason))\n+              : (initializingHandler = {\n+                  chunk: null,\n+                  value: null,\n+                  reason: id.reason,\n+                  deps: 0,\n+                  errored: !0\n+                }),\n+            null\n+          );\n       }\n     }\n     function createMap(response, model) {\n@@ -4264,40 +4470,68 @@\n       parentKey\n     ) {\n       reference = parseInt(reference.slice(2), 16);\n-      reference = response._formData.get(response._prefix + reference);\n-      reference =\n-        constructor === ArrayBuffer\n-          ? reference.arrayBuffer()\n-          : reference.arrayBuffer().then(function (buffer) {\n-              return new constructor(buffer);\n-            });\n-      bytesPerElement = initializingChunk;\n+      reference = response._formData\n+        .get(response._prefix + reference)\n+        .arrayBuffer();\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n       reference.then(\n-        createModelResolver(\n-          bytesPerElement,\n-          parentObject,\n-          parentKey,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(bytesPerElement)\n+        function (buffer) {\n+          buffer =\n+            constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+          parentObject[parentKey] = buffer;\n+          \"\" === parentKey &&\n+            null === handler.value &&\n+            (handler.value = buffer);\n+          handler.deps--;\n+          if (\n+            0 === handler.deps &&\n+            ((buffer = handler.chunk),\n+            null !== buffer && \"blocked\" === buffer.status)\n+          ) {\n+            var resolveListeners = buffer.value;\n+            buffer.status = \"fulfilled\";\n+            buffer.value = handler.value;\n+            null !== resolveListeners &&\n+              wakeChunk(response, resolveListeners, handler.value);\n+          }\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n     function resolveStream(response, id, stream, controller) {\n       var chunks = response._chunks;\n-      stream = new Chunk(\"fulfilled\", stream, controller, response);\n+      stream = new ReactPromise(\"fulfilled\", stream, controller);\n       chunks.set(id, stream);\n       response = response._formData.getAll(response._prefix + id);\n       for (id = 0; id < response.length; id++)\n         (chunks = response[id]),\n-          \"C\" === chunks[0]\n-            ? controller.close(\n-                \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n-              )\n-            : controller.enqueueModel(chunks);\n+          \"string\" === typeof chunks &&\n+            (\"C\" === chunks[0]\n+              ? controller.close(\n+                  \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n+                )\n+              : controller.enqueueModel(chunks));\n     }\n     function parseReadableStream(response, reference, type) {\n       reference = parseInt(reference.slice(2), 16);\n@@ -4312,7 +4546,11 @@\n       resolveStream(response, reference, type, {\n         enqueueModel: function (json) {\n           if (null === previousBlockedChunk) {\n-            var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+            var chunk = new ReactPromise(\n+              \"resolved_model\",\n+              json,\n+              _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n+            );\n             initializeModelChunk(chunk);\n             \"fulfilled\" === chunk.status\n               ? controller.enqueue(chunk.value)\n@@ -4327,7 +4565,7 @@\n                 (previousBlockedChunk = chunk));\n           } else {\n             chunk = previousBlockedChunk;\n-            var _chunk = createPendingChunk(response);\n+            var _chunk = new ReactPromise(\"pending\", null, null);\n             _chunk.then(\n               function (v) {\n                 return controller.enqueue(v);\n@@ -4339,7 +4577,7 @@\n             previousBlockedChunk = _chunk;\n             chunk.then(function () {\n               previousBlockedChunk === _chunk && (previousBlockedChunk = null);\n-              resolveModelChunk(_chunk, json, -1);\n+              resolveModelChunk(response, _chunk, json, -1);\n             });\n           }\n         },\n@@ -4388,13 +4626,12 @@\n               );\n             if (nextReadIndex === buffer.length) {\n               if (closed)\n-                return new Chunk(\n+                return new ReactPromise(\n                   \"fulfilled\",\n                   { done: !0, value: void 0 },\n-                  null,\n-                  response\n+                  null\n                 );\n-              buffer[nextReadIndex] = createPendingChunk(response);\n+              buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n             }\n             return buffer[nextReadIndex++];\n           });\n@@ -4408,7 +4645,12 @@\n                 value,\n                 !1\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !1\n+              );\n           nextWriteIndex++;\n         },\n         close: function (value) {\n@@ -4419,9 +4661,15 @@\n                 value,\n                 !0\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !0\n+              );\n           for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n             resolveIteratorResultChunk(\n+              response,\n               buffer[nextWriteIndex++],\n               '\"$undefined\"',\n               !0\n@@ -4431,11 +4679,11 @@\n           closed = !0;\n           for (\n             nextWriteIndex === buffer.length &&\n-            (buffer[nextWriteIndex] = createPendingChunk(response));\n+            (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n             nextWriteIndex < buffer.length;\n \n           )\n-            triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n         }\n       });\n       return iterator;\n@@ -4452,21 +4700,7 @@\n           case \"F\":\n             return (\n               (value = value.slice(2)),\n-              (value = getOutlinedModel(\n-                response,\n-                value,\n-                obj,\n-                key,\n-                createModel\n-              )),\n-              loadServerReference$1(\n-                response,\n-                value.id,\n-                value.bound,\n-                initializingChunk,\n-                obj,\n-                key\n-              )\n+              getOutlinedModel(response, value, obj, key, loadServerReference$1)\n             );\n           case \"T\":\n             if (\n@@ -5151,32 +5385,31 @@\n         ? flightChunk\n         : webpackGetChunkFilename(chunkId);\n     };\n-    Chunk.prototype = Object.create(Promise.prototype);\n-    Chunk.prototype.then = function (resolve, reject) {\n+    var RESPONSE_SYMBOL = Symbol();\n+    ReactPromise.prototype = Object.create(Promise.prototype);\n+    ReactPromise.prototype.then = function (resolve, reject) {\n       switch (this.status) {\n         case \"resolved_model\":\n           initializeModelChunk(this);\n       }\n       switch (this.status) {\n         case \"fulfilled\":\n-          resolve(this.value);\n+          \"function\" === typeof resolve && resolve(this.value);\n           break;\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          resolve &&\n+          \"function\" === typeof resolve &&\n             (null === this.value && (this.value = []),\n             this.value.push(resolve));\n-          reject &&\n+          \"function\" === typeof reject &&\n             (null === this.reason && (this.reason = []),\n             this.reason.push(reject));\n           break;\n         default:\n-          reject(this.reason);\n+          \"function\" === typeof reject && reject(this.reason);\n       }\n     };\n-    var initializingChunk = null,\n-      initializingChunkBlockedModel = null;\n+    var initializingHandler = null;\n     exports.createClientModuleProxy = function (moduleId) {\n       moduleId = registerClientReferenceImpl({}, moduleId, !1);\n       return new Proxy(moduleId, proxyHandlers$1);"
        },
        {
            "sha": "2157c8172fa921b6d66d4e024c818e980dd6e900",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.browser.production.js",
            "status": "modified",
            "additions": 425,
            "deletions": 201,
            "changes": 626,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.browser.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -980,8 +980,8 @@ function serializeReadableStream(request, task, stream) {\n               : tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             reader.read().then(progress, error);\n-        } catch (x$8) {\n-          error(x$8);\n+        } catch (x$11) {\n+          error(x$11);\n         }\n   }\n   function error(reason) {\n@@ -1066,8 +1066,8 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n             tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             iterator.next().then(progress, error);\n-        } catch (x$9) {\n-          error(x$9);\n+        } catch (x$12) {\n+          error(x$12);\n         }\n   }\n   function error(reason) {\n@@ -2229,9 +2229,9 @@ function abort(request, reason) {\n         onAllReady();\n         flushCompletedChunks(request);\n       }\n-    } catch (error$26) {\n-      logRecoverableError(request, error$26, null),\n-        fatalError(request, error$26);\n+    } catch (error$29) {\n+      logRecoverableError(request, error$29, null),\n+        fatalError(request, error$29);\n     }\n }\n function resolveServerReference(bundlerConfig, id) {\n@@ -2302,13 +2302,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n var chunkMap = new Map(),\n   webpackGetChunkFilename = __webpack_require__.u;\n@@ -2318,51 +2316,91 @@ __webpack_require__.u = function (chunkId) {\n     ? flightChunk\n     : webpackGetChunkFilename(chunkId);\n };\n-function Chunk(status, value, reason, response) {\n+var RESPONSE_SYMBOL = Symbol();\n+function ReactPromise(status, value, reason) {\n   this.status = status;\n   this.value = value;\n   this.reason = reason;\n-  this._response = response;\n }\n-Chunk.prototype = Object.create(Promise.prototype);\n-Chunk.prototype.then = function (resolve, reject) {\n+ReactPromise.prototype = Object.create(Promise.prototype);\n+ReactPromise.prototype.then = function (resolve, reject) {\n   switch (this.status) {\n     case \"resolved_model\":\n       initializeModelChunk(this);\n   }\n   switch (this.status) {\n     case \"fulfilled\":\n-      resolve(this.value);\n+      \"function\" === typeof resolve && resolve(this.value);\n       break;\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      resolve &&\n+      \"function\" === typeof resolve &&\n         (null === this.value && (this.value = []), this.value.push(resolve));\n-      reject &&\n+      \"function\" === typeof reject &&\n         (null === this.reason && (this.reason = []), this.reason.push(reject));\n       break;\n     default:\n-      reject(this.reason);\n+      \"function\" === typeof reject && reject(this.reason);\n   }\n };\n-function createPendingChunk(response) {\n-  return new Chunk(\"pending\", null, null, response);\n+function wakeChunk(response, listeners, value) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(value)\n+      : fulfillReference(response, listener, value);\n+  }\n }\n-function wakeChunk(listeners, value) {\n-  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+function rejectChunk(response, listeners, error) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(error)\n+      : rejectReference(response, listener.handler, error);\n+  }\n }\n-function triggerErrorOnChunk(chunk, error) {\n+function resolveBlockedCycle(resolvedChunk, reference) {\n+  var referencedChunk = reference.handler.chunk;\n+  if (null === referencedChunk) return null;\n+  if (referencedChunk === resolvedChunk) return reference.handler;\n+  reference = referencedChunk.value;\n+  if (null !== reference)\n+    for (\n+      referencedChunk = 0;\n+      referencedChunk < reference.length;\n+      referencedChunk++\n+    ) {\n+      var listener = reference[referencedChunk];\n+      if (\n+        \"function\" !== typeof listener &&\n+        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+        null !== listener)\n+      )\n+        return listener;\n+    }\n+  return null;\n+}\n+function triggerErrorOnChunk(response, chunk, error) {\n   if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n     chunk.reason.error(error);\n   else {\n     var listeners = chunk.reason;\n     chunk.status = \"rejected\";\n     chunk.reason = error;\n-    null !== listeners && wakeChunk(listeners, error);\n+    null !== listeners && rejectChunk(response, listeners, error);\n   }\n }\n-function resolveModelChunk(chunk, value, id) {\n+function createResolvedModelChunk(response, value, id) {\n+  var $jscomp$compprop2 = {};\n+  return new ReactPromise(\n+    \"resolved_model\",\n+    value,\n+    (($jscomp$compprop2.id = id),\n+    ($jscomp$compprop2[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop2)\n+  );\n+}\n+function resolveModelChunk(response, chunk, value, id) {\n   if (\"pending\" !== chunk.status)\n     (chunk = chunk.reason),\n       \"C\" === value[0]\n@@ -2373,77 +2411,129 @@ function resolveModelChunk(chunk, value, id) {\n       rejectListeners = chunk.reason;\n     chunk.status = \"resolved_model\";\n     chunk.value = value;\n-    chunk.reason = id;\n+    value = {};\n+    chunk.reason =\n+      ((value.id = id), (value[RESPONSE_SYMBOL] = response), value);\n     if (null !== resolveListeners)\n-      switch ((initializeModelChunk(chunk), chunk.status)) {\n+      a: switch ((initializeModelChunk(chunk), chunk.status)) {\n         case \"fulfilled\":\n-          wakeChunk(resolveListeners, chunk.value);\n+          wakeChunk(response, resolveListeners, chunk.value);\n           break;\n-        case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n+          for (value = 0; value < resolveListeners.length; value++)\n+            if (((id = resolveListeners[value]), \"function\" !== typeof id)) {\n+              var cyclicHandler = resolveBlockedCycle(chunk, id);\n+              if (null !== cyclicHandler)\n+                switch (\n+                  (fulfillReference(response, id, cyclicHandler.value),\n+                  resolveListeners.splice(value, 1),\n+                  value--,\n+                  null !== rejectListeners &&\n+                    ((id = rejectListeners.indexOf(id)),\n+                    -1 !== id && rejectListeners.splice(id, 1)),\n+                  chunk.status)\n+                ) {\n+                  case \"fulfilled\":\n+                    wakeChunk(response, resolveListeners, chunk.value);\n+                    break a;\n+                  case \"rejected\":\n+                    null !== rejectListeners &&\n+                      rejectChunk(response, rejectListeners, chunk.reason);\n+                    break a;\n+                }\n+            }\n+        case \"pending\":\n           if (chunk.value)\n-            for (value = 0; value < resolveListeners.length; value++)\n-              chunk.value.push(resolveListeners[value]);\n+            for (response = 0; response < resolveListeners.length; response++)\n+              chunk.value.push(resolveListeners[response]);\n           else chunk.value = resolveListeners;\n           if (chunk.reason) {\n             if (rejectListeners)\n-              for (value = 0; value < rejectListeners.length; value++)\n-                chunk.reason.push(rejectListeners[value]);\n+              for (\n+                resolveListeners = 0;\n+                resolveListeners < rejectListeners.length;\n+                resolveListeners++\n+              )\n+                chunk.reason.push(rejectListeners[resolveListeners]);\n           } else chunk.reason = rejectListeners;\n           break;\n         case \"rejected\":\n-          rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+          rejectListeners && wakeChunk(response, rejectListeners, chunk.reason);\n       }\n   }\n }\n function createResolvedIteratorResultChunk(response, value, done) {\n-  return new Chunk(\n+  var $jscomp$compprop4 = {};\n+  return new ReactPromise(\n     \"resolved_model\",\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n-    -1,\n-    response\n+    (($jscomp$compprop4.id = -1),\n+    ($jscomp$compprop4[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop4)\n   );\n }\n-function resolveIteratorResultChunk(chunk, value, done) {\n+function resolveIteratorResultChunk(response, chunk, value, done) {\n   resolveModelChunk(\n+    response,\n     chunk,\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n     -1\n   );\n }\n-function loadServerReference$1(\n-  response,\n-  id,\n-  bound,\n-  parentChunk,\n-  parentObject,\n-  key\n-) {\n+function loadServerReference$1(response, metaData, parentObject, key) {\n+  var id = metaData.id;\n+  if (\"string\" !== typeof id) return null;\n   var serverReference = resolveServerReference(response._bundlerConfig, id);\n-  id = preloadModule(serverReference);\n-  if (bound)\n-    bound = Promise.all([bound, id]).then(function (_ref) {\n-      _ref = _ref[0];\n-      var fn = requireModule(serverReference);\n-      return fn.bind.apply(fn, [null].concat(_ref));\n-    });\n-  else if (id)\n-    bound = Promise.resolve(id).then(function () {\n-      return requireModule(serverReference);\n-    });\n+  id = metaData.bound;\n+  var promise = preloadModule(serverReference);\n+  if (promise)\n+    id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+  else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n   else return requireModule(serverReference);\n-  bound.then(\n-    createModelResolver(\n-      parentChunk,\n-      parentObject,\n-      key,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(parentChunk)\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n+  promise.then(\n+    function () {\n+      var resolvedValue = requireModule(serverReference);\n+      if (metaData.bound) {\n+        var promiseValue = metaData.bound.value;\n+        promiseValue = Array.isArray(promiseValue) ? promiseValue.slice(0) : [];\n+        promiseValue.unshift(null);\n+        resolvedValue = resolvedValue.bind.apply(resolvedValue, promiseValue);\n+      }\n+      parentObject[key] = resolvedValue;\n+      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((resolvedValue = handler.chunk),\n+        null !== resolvedValue &&\n+          \"blocked\" === resolvedValue.status &&\n+          ((promiseValue = resolvedValue.value),\n+          (resolvedValue.status = \"fulfilled\"),\n+          (resolvedValue.value = handler.value),\n+          null !== promiseValue &&\n+            wakeChunk(response, promiseValue, handler.value)));\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n@@ -2473,53 +2563,65 @@ function reviveModel(response, parentObj, parentKey, value, reference) {\n               ? reference + \":\" + i\n               : void 0),\n           (parentObj = reviveModel(response, value, i, value[i], parentObj)),\n-          void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+          void 0 !== parentObj || \"__proto__\" === i\n+            ? (value[i] = parentObj)\n+            : delete value[i]);\n   return value;\n }\n-var initializingChunk = null,\n-  initializingChunkBlockedModel = null;\n+var initializingHandler = null;\n function initializeModelChunk(chunk) {\n-  var prevChunk = initializingChunk,\n-    prevBlocked = initializingChunkBlockedModel;\n-  initializingChunk = chunk;\n-  initializingChunkBlockedModel = null;\n-  var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-    resolvedModel = chunk.value;\n-  chunk.status = \"cyclic\";\n+  var prevHandler = initializingHandler;\n+  initializingHandler = null;\n+  var _chunk$reason = chunk.reason,\n+    response = _chunk$reason[RESPONSE_SYMBOL];\n+  _chunk$reason = _chunk$reason.id;\n+  _chunk$reason = -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+  var resolvedModel = chunk.value;\n+  chunk.status = \"blocked\";\n   chunk.value = null;\n   chunk.reason = null;\n   try {\n     var rawModel = JSON.parse(resolvedModel),\n       value = reviveModel(\n-        chunk._response,\n+        response,\n         { \"\": rawModel },\n         \"\",\n         rawModel,\n-        rootReference\n-      );\n-    if (\n-      null !== initializingChunkBlockedModel &&\n-      0 < initializingChunkBlockedModel.deps\n-    )\n-      (initializingChunkBlockedModel.value = value), (chunk.status = \"blocked\");\n-    else {\n-      var resolveListeners = chunk.value;\n-      chunk.status = \"fulfilled\";\n-      chunk.value = value;\n-      null !== resolveListeners && wakeChunk(resolveListeners, value);\n+        _chunk$reason\n+      ),\n+      resolveListeners = chunk.value;\n+    if (null !== resolveListeners)\n+      for (\n+        chunk.value = null, chunk.reason = null, rawModel = 0;\n+        rawModel < resolveListeners.length;\n+        rawModel++\n+      ) {\n+        var listener = resolveListeners[rawModel];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n+    if (null !== initializingHandler) {\n+      if (initializingHandler.errored) throw initializingHandler.reason;\n+      if (0 < initializingHandler.deps) {\n+        initializingHandler.value = value;\n+        initializingHandler.chunk = chunk;\n+        return;\n+      }\n     }\n+    chunk.status = \"fulfilled\";\n+    chunk.value = value;\n   } catch (error) {\n     (chunk.status = \"rejected\"), (chunk.reason = error);\n   } finally {\n-    (initializingChunk = prevChunk),\n-      (initializingChunkBlockedModel = prevBlocked);\n+    initializingHandler = prevHandler;\n   }\n }\n function reportGlobalError(response, error) {\n   response._closed = !0;\n   response._closedReason = error;\n   response._chunks.forEach(function (chunk) {\n-    \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+    \"pending\" === chunk.status && triggerErrorOnChunk(response, chunk, error);\n   });\n }\n function getChunk(response, id) {\n@@ -2528,48 +2630,104 @@ function getChunk(response, id) {\n   chunk ||\n     ((chunk = response._formData.get(response._prefix + id)),\n     (chunk =\n-      null != chunk\n-        ? new Chunk(\"resolved_model\", chunk, id, response)\n+      \"string\" === typeof chunk\n+        ? createResolvedModelChunk(response, chunk, id)\n         : response._closed\n-          ? new Chunk(\"rejected\", null, response._closedReason, response)\n-          : createPendingChunk(response)),\n+          ? new ReactPromise(\"rejected\", null, response._closedReason)\n+          : new ReactPromise(\"pending\", null, null)),\n     chunks.set(id, chunk));\n   return chunk;\n }\n-function createModelResolver(\n-  chunk,\n+function fulfillReference(response, reference, value) {\n+  for (\n+    var handler = reference.handler,\n+      parentObject = reference.parentObject,\n+      key = reference.key,\n+      map = reference.map,\n+      path = reference.path,\n+      i = 1;\n+    i < path.length;\n+    i++\n+  ) {\n+    for (; value instanceof ReactPromise; ) {\n+      switch (value.status) {\n+        case \"resolved_model\":\n+          initializeModelChunk(value);\n+      }\n+      switch (value.status) {\n+        case \"fulfilled\":\n+          value = value.value;\n+          continue;\n+        case \"blocked\":\n+        case \"pending\":\n+          path.splice(0, i - 1);\n+          null === value.value\n+            ? (value.value = [reference])\n+            : value.value.push(reference);\n+          null === value.reason\n+            ? (value.reason = [reference])\n+            : value.reason.push(reference);\n+          return;\n+        default:\n+          rejectReference(response, reference.handler, value.reason);\n+          return;\n+      }\n+    }\n+    var name = path[i];\n+    \"object\" === typeof value &&\n+      hasOwnProperty.call(value, name) &&\n+      (value = value[name]);\n+  }\n+  reference = map(response, value, parentObject, key);\n+  parentObject[key] = reference;\n+  \"\" === key && null === handler.value && (handler.value = reference);\n+  handler.deps--;\n+  0 === handler.deps &&\n+    ((parentObject = handler.chunk),\n+    null !== parentObject &&\n+      \"blocked\" === parentObject.status &&\n+      ((key = parentObject.value),\n+      (parentObject.status = \"fulfilled\"),\n+      (parentObject.value = handler.value),\n+      (parentObject.reason = handler.reason),\n+      null !== key && wakeChunk(response, key, handler.value)));\n+}\n+function rejectReference(response, handler, error) {\n+  handler.errored ||\n+    ((handler.errored = !0),\n+    (handler.value = null),\n+    (handler.reason = error),\n+    (handler = handler.chunk),\n+    null !== handler &&\n+      \"blocked\" === handler.status &&\n+      triggerErrorOnChunk(response, handler, error));\n+}\n+function waitForReference(\n+  referencedChunk,\n   parentObject,\n   key,\n-  cyclic,\n   response,\n   map,\n   path\n ) {\n-  if (initializingChunkBlockedModel) {\n-    var blocked = initializingChunkBlockedModel;\n-    cyclic || blocked.deps++;\n-  } else\n-    blocked = initializingChunkBlockedModel = {\n-      deps: cyclic ? 0 : 1,\n-      value: null\n-    };\n-  return function (value) {\n-    for (var i = 1; i < path.length; i++) value = value[path[i]];\n-    parentObject[key] = map(response, value);\n-    \"\" === key && null === blocked.value && (blocked.value = parentObject[key]);\n-    blocked.deps--;\n-    0 === blocked.deps &&\n-      \"blocked\" === chunk.status &&\n-      ((value = chunk.value),\n-      (chunk.status = \"fulfilled\"),\n-      (chunk.value = blocked.value),\n-      null !== value && wakeChunk(value, blocked.value));\n-  };\n-}\n-function createModelReject(chunk) {\n-  return function (error) {\n-    return triggerErrorOnChunk(chunk, error);\n+  initializingHandler\n+    ? ((response = initializingHandler), response.deps++)\n+    : (response = initializingHandler =\n+        { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+  parentObject = {\n+    handler: response,\n+    parentObject: parentObject,\n+    key: key,\n+    map: map,\n+    path: path\n   };\n+  null === referencedChunk.value\n+    ? (referencedChunk.value = [parentObject])\n+    : referencedChunk.value.push(parentObject);\n+  null === referencedChunk.reason\n+    ? (referencedChunk.reason = [parentObject])\n+    : referencedChunk.reason.push(parentObject);\n+  return null;\n }\n function getOutlinedModel(response, reference, parentObject, key, map) {\n   reference = reference.split(\":\");\n@@ -2581,29 +2739,68 @@ function getOutlinedModel(response, reference, parentObject, key, map) {\n   }\n   switch (id.status) {\n     case \"fulfilled\":\n-      parentObject = id.value;\n-      for (key = 1; key < reference.length; key++)\n-        parentObject = parentObject[reference[key]];\n-      return map(response, parentObject);\n+      var value = id.value;\n+      for (id = 1; id < reference.length; id++) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              break;\n+            case \"blocked\":\n+            case \"pending\":\n+              return waitForReference(\n+                value,\n+                parentObject,\n+                key,\n+                response,\n+                map,\n+                reference.slice(id - 1)\n+              );\n+            default:\n+              return (\n+                initializingHandler\n+                  ? ((initializingHandler.errored = !0),\n+                    (initializingHandler.value = null),\n+                    (initializingHandler.reason = value.reason))\n+                  : (initializingHandler = {\n+                      chunk: null,\n+                      value: null,\n+                      reason: value.reason,\n+                      deps: 0,\n+                      errored: !0\n+                    }),\n+                null\n+              );\n+          }\n+        }\n+        var name = reference[id];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      return map(response, value, parentObject, key);\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      var parentChunk = initializingChunk;\n-      id.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          \"cyclic\" === id.status,\n-          response,\n-          map,\n-          reference\n-        ),\n-        createModelReject(parentChunk)\n-      );\n-      return null;\n+      return waitForReference(id, parentObject, key, response, map, reference);\n     default:\n-      throw id.reason;\n+      return (\n+        initializingHandler\n+          ? ((initializingHandler.errored = !0),\n+            (initializingHandler.value = null),\n+            (initializingHandler.reason = id.reason))\n+          : (initializingHandler = {\n+              chunk: null,\n+              value: null,\n+              reason: id.reason,\n+              deps: 0,\n+              errored: !0\n+            }),\n+        null\n+      );\n   }\n }\n function createMap(response, model) {\n@@ -2627,38 +2824,63 @@ function parseTypedArray(\n   parentKey\n ) {\n   reference = parseInt(reference.slice(2), 16);\n-  reference = response._formData.get(response._prefix + reference);\n-  reference =\n-    constructor === ArrayBuffer\n-      ? reference.arrayBuffer()\n-      : reference.arrayBuffer().then(function (buffer) {\n-          return new constructor(buffer);\n-        });\n-  bytesPerElement = initializingChunk;\n+  reference = response._formData\n+    .get(response._prefix + reference)\n+    .arrayBuffer();\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n   reference.then(\n-    createModelResolver(\n-      bytesPerElement,\n-      parentObject,\n-      parentKey,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(bytesPerElement)\n+    function (buffer) {\n+      buffer = constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+      parentObject[parentKey] = buffer;\n+      \"\" === parentKey && null === handler.value && (handler.value = buffer);\n+      handler.deps--;\n+      if (\n+        0 === handler.deps &&\n+        ((buffer = handler.chunk),\n+        null !== buffer && \"blocked\" === buffer.status)\n+      ) {\n+        var resolveListeners = buffer.value;\n+        buffer.status = \"fulfilled\";\n+        buffer.value = handler.value;\n+        null !== resolveListeners &&\n+          wakeChunk(response, resolveListeners, handler.value);\n+      }\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n function resolveStream(response, id, stream, controller) {\n   var chunks = response._chunks;\n-  stream = new Chunk(\"fulfilled\", stream, controller, response);\n+  stream = new ReactPromise(\"fulfilled\", stream, controller);\n   chunks.set(id, stream);\n   response = response._formData.getAll(response._prefix + id);\n   for (id = 0; id < response.length; id++)\n     (chunks = response[id]),\n-      \"C\" === chunks[0]\n-        ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n-        : controller.enqueueModel(chunks);\n+      \"string\" === typeof chunks &&\n+        (\"C\" === chunks[0]\n+          ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n+          : controller.enqueueModel(chunks));\n }\n function parseReadableStream(response, reference, type) {\n   reference = parseInt(reference.slice(2), 16);\n@@ -2673,7 +2895,7 @@ function parseReadableStream(response, reference, type) {\n   resolveStream(response, reference, type, {\n     enqueueModel: function (json) {\n       if (null === previousBlockedChunk) {\n-        var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+        var chunk = createResolvedModelChunk(response, json, -1);\n         initializeModelChunk(chunk);\n         \"fulfilled\" === chunk.status\n           ? controller.enqueue(chunk.value)\n@@ -2688,19 +2910,19 @@ function parseReadableStream(response, reference, type) {\n             (previousBlockedChunk = chunk));\n       } else {\n         chunk = previousBlockedChunk;\n-        var chunk$29 = createPendingChunk(response);\n-        chunk$29.then(\n+        var chunk$33 = new ReactPromise(\"pending\", null, null);\n+        chunk$33.then(\n           function (v) {\n             return controller.enqueue(v);\n           },\n           function (e) {\n             return controller.error(e);\n           }\n         );\n-        previousBlockedChunk = chunk$29;\n+        previousBlockedChunk = chunk$33;\n         chunk.then(function () {\n-          previousBlockedChunk === chunk$29 && (previousBlockedChunk = null);\n-          resolveModelChunk(chunk$29, json, -1);\n+          previousBlockedChunk === chunk$33 && (previousBlockedChunk = null);\n+          resolveModelChunk(response, chunk$33, json, -1);\n         });\n       }\n     },\n@@ -2740,9 +2962,9 @@ function parseAsyncIterable(response, reference, iterator) {\n   var buffer = [],\n     closed = !1,\n     nextWriteIndex = 0,\n-    $jscomp$compprop2 = {};\n-  $jscomp$compprop2 =\n-    (($jscomp$compprop2[ASYNC_ITERATOR] = function () {\n+    $jscomp$compprop5 = {};\n+  $jscomp$compprop5 =\n+    (($jscomp$compprop5[ASYNC_ITERATOR] = function () {\n       var nextReadIndex = 0;\n       return createIterator(function (arg) {\n         if (void 0 !== arg)\n@@ -2751,19 +2973,18 @@ function parseAsyncIterable(response, reference, iterator) {\n           );\n         if (nextReadIndex === buffer.length) {\n           if (closed)\n-            return new Chunk(\n+            return new ReactPromise(\n               \"fulfilled\",\n               { done: !0, value: void 0 },\n-              null,\n-              response\n+              null\n             );\n-          buffer[nextReadIndex] = createPendingChunk(response);\n+          buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n         }\n         return buffer[nextReadIndex++];\n       });\n     }),\n-    $jscomp$compprop2);\n-  iterator = iterator ? $jscomp$compprop2[ASYNC_ITERATOR]() : $jscomp$compprop2;\n+    $jscomp$compprop5);\n+  iterator = iterator ? $jscomp$compprop5[ASYNC_ITERATOR]() : $jscomp$compprop5;\n   resolveStream(response, reference, iterator, {\n     enqueueModel: function (value) {\n       nextWriteIndex === buffer.length\n@@ -2772,7 +2993,12 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !1\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !1\n+          );\n       nextWriteIndex++;\n     },\n     close: function (value) {\n@@ -2783,9 +3009,15 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !0\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !0\n+          );\n       for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n         resolveIteratorResultChunk(\n+          response,\n           buffer[nextWriteIndex++],\n           '\"$undefined\"',\n           !0\n@@ -2795,11 +3027,11 @@ function parseAsyncIterable(response, reference, iterator) {\n       closed = !0;\n       for (\n         nextWriteIndex === buffer.length &&\n-        (buffer[nextWriteIndex] = createPendingChunk(response));\n+        (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n         nextWriteIndex < buffer.length;\n \n       )\n-        triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+        triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n     }\n   });\n   return iterator;\n@@ -2814,15 +3046,7 @@ function parseModelString(response, obj, key, value, reference) {\n       case \"F\":\n         return (\n           (value = value.slice(2)),\n-          (value = getOutlinedModel(response, value, obj, key, createModel)),\n-          loadServerReference$1(\n-            response,\n-            value.id,\n-            value.bound,\n-            initializingChunk,\n-            obj,\n-            key\n-          )\n+          getOutlinedModel(response, value, obj, key, loadServerReference$1)\n         );\n       case \"T\":\n         if (void 0 === reference || void 0 === response._temporaryReferences)"
        },
        {
            "sha": "cb2bc38eed5fd71e668d075b783e60127c452a8f",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.edge.development.js",
            "status": "modified",
            "additions": 438,
            "deletions": 204,
            "changes": 642,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.edge.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -4021,37 +4021,65 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n-    }\n-    function Chunk(status, value, reason, response) {\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n+    }\n+    function ReactPromise(status, value, reason) {\n       this.status = status;\n       this.value = value;\n       this.reason = reason;\n-      this._response = response;\n     }\n-    function createPendingChunk(response) {\n-      return new Chunk(\"pending\", null, null, response);\n+    function wakeChunk(response, listeners, value) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n     }\n-    function wakeChunk(listeners, value) {\n-      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+    function rejectChunk(response, listeners, error) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(error)\n+          : rejectReference(response, listener.handler, error);\n+      }\n     }\n-    function triggerErrorOnChunk(chunk, error) {\n+    function resolveBlockedCycle(resolvedChunk, reference) {\n+      var referencedChunk = reference.handler.chunk;\n+      if (null === referencedChunk) return null;\n+      if (referencedChunk === resolvedChunk) return reference.handler;\n+      reference = referencedChunk.value;\n+      if (null !== reference)\n+        for (\n+          referencedChunk = 0;\n+          referencedChunk < reference.length;\n+          referencedChunk++\n+        ) {\n+          var listener = reference[referencedChunk];\n+          if (\n+            \"function\" !== typeof listener &&\n+            ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+            null !== listener)\n+          )\n+            return listener;\n+        }\n+      return null;\n+    }\n+    function triggerErrorOnChunk(response, chunk, error) {\n       if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n         chunk.reason.error(error);\n       else {\n         var listeners = chunk.reason;\n         chunk.status = \"rejected\";\n         chunk.reason = error;\n-        null !== listeners && wakeChunk(listeners, error);\n+        null !== listeners && rejectChunk(response, listeners, error);\n       }\n     }\n-    function resolveModelChunk(chunk, value, id) {\n+    function resolveModelChunk(response, chunk, value, id) {\n       if (\"pending\" !== chunk.status)\n         (chunk = chunk.reason),\n           \"C\" === value[0]\n@@ -4062,81 +4090,142 @@\n           rejectListeners = chunk.reason;\n         chunk.status = \"resolved_model\";\n         chunk.value = value;\n-        chunk.reason = id;\n+        chunk.reason = _defineProperty({ id: id }, RESPONSE_SYMBOL, response);\n         if (null !== resolveListeners)\n-          switch ((initializeModelChunk(chunk), chunk.status)) {\n+          a: switch ((initializeModelChunk(chunk), chunk.status)) {\n             case \"fulfilled\":\n-              wakeChunk(resolveListeners, chunk.value);\n+              wakeChunk(response, resolveListeners, chunk.value);\n               break;\n-            case \"pending\":\n             case \"blocked\":\n-            case \"cyclic\":\n+              for (value = 0; value < resolveListeners.length; value++)\n+                if (\n+                  ((id = resolveListeners[value]), \"function\" !== typeof id)\n+                ) {\n+                  var cyclicHandler = resolveBlockedCycle(chunk, id);\n+                  if (null !== cyclicHandler)\n+                    switch (\n+                      (fulfillReference(response, id, cyclicHandler.value),\n+                      resolveListeners.splice(value, 1),\n+                      value--,\n+                      null !== rejectListeners &&\n+                        ((id = rejectListeners.indexOf(id)),\n+                        -1 !== id && rejectListeners.splice(id, 1)),\n+                      chunk.status)\n+                    ) {\n+                      case \"fulfilled\":\n+                        wakeChunk(response, resolveListeners, chunk.value);\n+                        break a;\n+                      case \"rejected\":\n+                        null !== rejectListeners &&\n+                          rejectChunk(response, rejectListeners, chunk.reason);\n+                        break a;\n+                    }\n+                }\n+            case \"pending\":\n               if (chunk.value)\n-                for (value = 0; value < resolveListeners.length; value++)\n-                  chunk.value.push(resolveListeners[value]);\n+                for (\n+                  response = 0;\n+                  response < resolveListeners.length;\n+                  response++\n+                )\n+                  chunk.value.push(resolveListeners[response]);\n               else chunk.value = resolveListeners;\n               if (chunk.reason) {\n                 if (rejectListeners)\n-                  for (value = 0; value < rejectListeners.length; value++)\n-                    chunk.reason.push(rejectListeners[value]);\n+                  for (\n+                    resolveListeners = 0;\n+                    resolveListeners < rejectListeners.length;\n+                    resolveListeners++\n+                  )\n+                    chunk.reason.push(rejectListeners[resolveListeners]);\n               } else chunk.reason = rejectListeners;\n               break;\n             case \"rejected\":\n-              rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+              rejectListeners &&\n+                wakeChunk(response, rejectListeners, chunk.reason);\n           }\n       }\n     }\n     function createResolvedIteratorResultChunk(response, value, done) {\n-      return new Chunk(\n+      return new ReactPromise(\n         \"resolved_model\",\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n-        -1,\n-        response\n+        _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n       );\n     }\n-    function resolveIteratorResultChunk(chunk, value, done) {\n+    function resolveIteratorResultChunk(response, chunk, value, done) {\n       resolveModelChunk(\n+        response,\n         chunk,\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n         -1\n       );\n     }\n-    function loadServerReference$1(\n-      response,\n-      id,\n-      bound,\n-      parentChunk,\n-      parentObject,\n-      key\n-    ) {\n+    function loadServerReference$1(response, metaData, parentObject, key) {\n+      var id = metaData.id;\n+      if (\"string\" !== typeof id) return null;\n       var serverReference = resolveServerReference(response._bundlerConfig, id);\n-      id = preloadModule(serverReference);\n-      if (bound)\n-        bound = Promise.all([bound, id]).then(function (_ref) {\n-          _ref = _ref[0];\n-          var fn = requireModule(serverReference);\n-          return fn.bind.apply(fn, [null].concat(_ref));\n-        });\n-      else if (id)\n-        bound = Promise.resolve(id).then(function () {\n-          return requireModule(serverReference);\n-        });\n+      id = metaData.bound;\n+      var promise = preloadModule(serverReference);\n+      if (promise)\n+        id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+      else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n       else return requireModule(serverReference);\n-      bound.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(parentChunk)\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n+      promise.then(\n+        function () {\n+          var resolvedValue = requireModule(serverReference);\n+          if (metaData.bound) {\n+            var promiseValue = metaData.bound.value;\n+            promiseValue = Array.isArray(promiseValue)\n+              ? promiseValue.slice(0)\n+              : [];\n+            promiseValue.unshift(null);\n+            resolvedValue = resolvedValue.bind.apply(\n+              resolvedValue,\n+              promiseValue\n+            );\n+          }\n+          parentObject[key] = resolvedValue;\n+          \"\" === key &&\n+            null === handler.value &&\n+            (handler.value = resolvedValue);\n+          handler.deps--;\n+          0 === handler.deps &&\n+            ((resolvedValue = handler.chunk),\n+            null !== resolvedValue &&\n+              \"blocked\" === resolvedValue.status &&\n+              ((promiseValue = resolvedValue.value),\n+              (resolvedValue.status = \"fulfilled\"),\n+              (resolvedValue.value = handler.value),\n+              null !== promiseValue &&\n+                wakeChunk(response, promiseValue, handler.value)));\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n@@ -4178,53 +4267,66 @@\n                 value[i],\n                 parentObj\n               )),\n-              void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+              void 0 !== parentObj || \"__proto__\" === i\n+                ? (value[i] = parentObj)\n+                : delete value[i]);\n       return value;\n     }\n     function initializeModelChunk(chunk) {\n-      var prevChunk = initializingChunk,\n-        prevBlocked = initializingChunkBlockedModel;\n-      initializingChunk = chunk;\n-      initializingChunkBlockedModel = null;\n-      var rootReference =\n-          -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-        resolvedModel = chunk.value;\n-      chunk.status = \"cyclic\";\n+      var prevHandler = initializingHandler;\n+      initializingHandler = null;\n+      var _chunk$reason = chunk.reason,\n+        response = _chunk$reason[RESPONSE_SYMBOL];\n+      _chunk$reason = _chunk$reason.id;\n+      _chunk$reason =\n+        -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+      var resolvedModel = chunk.value;\n+      chunk.status = \"blocked\";\n       chunk.value = null;\n       chunk.reason = null;\n       try {\n         var rawModel = JSON.parse(resolvedModel),\n           value = reviveModel(\n-            chunk._response,\n+            response,\n             { \"\": rawModel },\n             \"\",\n             rawModel,\n-            rootReference\n-          );\n-        if (\n-          null !== initializingChunkBlockedModel &&\n-          0 < initializingChunkBlockedModel.deps\n-        )\n-          (initializingChunkBlockedModel.value = value),\n-            (chunk.status = \"blocked\");\n-        else {\n-          var resolveListeners = chunk.value;\n-          chunk.status = \"fulfilled\";\n-          chunk.value = value;\n-          null !== resolveListeners && wakeChunk(resolveListeners, value);\n+            _chunk$reason\n+          ),\n+          resolveListeners = chunk.value;\n+        if (null !== resolveListeners)\n+          for (\n+            chunk.value = null, chunk.reason = null, rawModel = 0;\n+            rawModel < resolveListeners.length;\n+            rawModel++\n+          ) {\n+            var listener = resolveListeners[rawModel];\n+            \"function\" === typeof listener\n+              ? listener(value)\n+              : fulfillReference(response, listener, value);\n+          }\n+        if (null !== initializingHandler) {\n+          if (initializingHandler.errored) throw initializingHandler.reason;\n+          if (0 < initializingHandler.deps) {\n+            initializingHandler.value = value;\n+            initializingHandler.chunk = chunk;\n+            return;\n+          }\n         }\n+        chunk.status = \"fulfilled\";\n+        chunk.value = value;\n       } catch (error) {\n         (chunk.status = \"rejected\"), (chunk.reason = error);\n       } finally {\n-        (initializingChunk = prevChunk),\n-          (initializingChunkBlockedModel = prevBlocked);\n+        initializingHandler = prevHandler;\n       }\n     }\n     function reportGlobalError(response, error) {\n       response._closed = !0;\n       response._closedReason = error;\n       response._chunks.forEach(function (chunk) {\n-        \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+        \"pending\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n       });\n     }\n     function getChunk(response, id) {\n@@ -4233,50 +4335,108 @@\n       chunk ||\n         ((chunk = response._formData.get(response._prefix + id)),\n         (chunk =\n-          null != chunk\n-            ? new Chunk(\"resolved_model\", chunk, id, response)\n+          \"string\" === typeof chunk\n+            ? new ReactPromise(\n+                \"resolved_model\",\n+                chunk,\n+                _defineProperty({ id: id }, RESPONSE_SYMBOL, response)\n+              )\n             : response._closed\n-              ? new Chunk(\"rejected\", null, response._closedReason, response)\n-              : createPendingChunk(response)),\n+              ? new ReactPromise(\"rejected\", null, response._closedReason)\n+              : new ReactPromise(\"pending\", null, null)),\n         chunks.set(id, chunk));\n       return chunk;\n     }\n-    function createModelResolver(\n-      chunk,\n+    function fulfillReference(response, reference, value) {\n+      for (\n+        var handler = reference.handler,\n+          parentObject = reference.parentObject,\n+          key = reference.key,\n+          map = reference.map,\n+          path = reference.path,\n+          i = 1;\n+        i < path.length;\n+        i++\n+      ) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              continue;\n+            case \"blocked\":\n+            case \"pending\":\n+              path.splice(0, i - 1);\n+              null === value.value\n+                ? (value.value = [reference])\n+                : value.value.push(reference);\n+              null === value.reason\n+                ? (value.reason = [reference])\n+                : value.reason.push(reference);\n+              return;\n+            default:\n+              rejectReference(response, reference.handler, value.reason);\n+              return;\n+          }\n+        }\n+        var name = path[i];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      reference = map(response, value, parentObject, key);\n+      parentObject[key] = reference;\n+      \"\" === key && null === handler.value && (handler.value = reference);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((parentObject = handler.chunk),\n+        null !== parentObject &&\n+          \"blocked\" === parentObject.status &&\n+          ((key = parentObject.value),\n+          (parentObject.status = \"fulfilled\"),\n+          (parentObject.value = handler.value),\n+          (parentObject.reason = handler.reason),\n+          null !== key && wakeChunk(response, key, handler.value)));\n+    }\n+    function rejectReference(response, handler, error) {\n+      handler.errored ||\n+        ((handler.errored = !0),\n+        (handler.value = null),\n+        (handler.reason = error),\n+        (handler = handler.chunk),\n+        null !== handler &&\n+          \"blocked\" === handler.status &&\n+          triggerErrorOnChunk(response, handler, error));\n+    }\n+    function waitForReference(\n+      referencedChunk,\n       parentObject,\n       key,\n-      cyclic,\n       response,\n       map,\n       path\n     ) {\n-      if (initializingChunkBlockedModel) {\n-        var blocked = initializingChunkBlockedModel;\n-        cyclic || blocked.deps++;\n-      } else\n-        blocked = initializingChunkBlockedModel = {\n-          deps: cyclic ? 0 : 1,\n-          value: null\n-        };\n-      return function (value) {\n-        for (var i = 1; i < path.length; i++) value = value[path[i]];\n-        parentObject[key] = map(response, value);\n-        \"\" === key &&\n-          null === blocked.value &&\n-          (blocked.value = parentObject[key]);\n-        blocked.deps--;\n-        0 === blocked.deps &&\n-          \"blocked\" === chunk.status &&\n-          ((value = chunk.value),\n-          (chunk.status = \"fulfilled\"),\n-          (chunk.value = blocked.value),\n-          null !== value && wakeChunk(value, blocked.value));\n-      };\n-    }\n-    function createModelReject(chunk) {\n-      return function (error) {\n-        return triggerErrorOnChunk(chunk, error);\n+      initializingHandler\n+        ? ((response = initializingHandler), response.deps++)\n+        : (response = initializingHandler =\n+            { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+      parentObject = {\n+        handler: response,\n+        parentObject: parentObject,\n+        key: key,\n+        map: map,\n+        path: path\n       };\n+      null === referencedChunk.value\n+        ? (referencedChunk.value = [parentObject])\n+        : referencedChunk.value.push(parentObject);\n+      null === referencedChunk.reason\n+        ? (referencedChunk.reason = [parentObject])\n+        : referencedChunk.reason.push(parentObject);\n+      return null;\n     }\n     function getOutlinedModel(response, reference, parentObject, key, map) {\n       reference = reference.split(\":\");\n@@ -4288,29 +4448,75 @@\n       }\n       switch (id.status) {\n         case \"fulfilled\":\n-          parentObject = id.value;\n-          for (key = 1; key < reference.length; key++)\n-            parentObject = parentObject[reference[key]];\n-          return map(response, parentObject);\n+          var value = id.value;\n+          for (id = 1; id < reference.length; id++) {\n+            for (; value instanceof ReactPromise; ) {\n+              switch (value.status) {\n+                case \"resolved_model\":\n+                  initializeModelChunk(value);\n+              }\n+              switch (value.status) {\n+                case \"fulfilled\":\n+                  value = value.value;\n+                  break;\n+                case \"blocked\":\n+                case \"pending\":\n+                  return waitForReference(\n+                    value,\n+                    parentObject,\n+                    key,\n+                    response,\n+                    map,\n+                    reference.slice(id - 1)\n+                  );\n+                default:\n+                  return (\n+                    initializingHandler\n+                      ? ((initializingHandler.errored = !0),\n+                        (initializingHandler.value = null),\n+                        (initializingHandler.reason = value.reason))\n+                      : (initializingHandler = {\n+                          chunk: null,\n+                          value: null,\n+                          reason: value.reason,\n+                          deps: 0,\n+                          errored: !0\n+                        }),\n+                    null\n+                  );\n+              }\n+            }\n+            var name = reference[id];\n+            \"object\" === typeof value &&\n+              hasOwnProperty.call(value, name) &&\n+              (value = value[name]);\n+          }\n+          return map(response, value, parentObject, key);\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          var parentChunk = initializingChunk;\n-          id.then(\n-            createModelResolver(\n-              parentChunk,\n-              parentObject,\n-              key,\n-              \"cyclic\" === id.status,\n-              response,\n-              map,\n-              reference\n-            ),\n-            createModelReject(parentChunk)\n+          return waitForReference(\n+            id,\n+            parentObject,\n+            key,\n+            response,\n+            map,\n+            reference\n           );\n-          return null;\n         default:\n-          throw id.reason;\n+          return (\n+            initializingHandler\n+              ? ((initializingHandler.errored = !0),\n+                (initializingHandler.value = null),\n+                (initializingHandler.reason = id.reason))\n+              : (initializingHandler = {\n+                  chunk: null,\n+                  value: null,\n+                  reason: id.reason,\n+                  deps: 0,\n+                  errored: !0\n+                }),\n+            null\n+          );\n       }\n     }\n     function createMap(response, model) {\n@@ -4334,40 +4540,68 @@\n       parentKey\n     ) {\n       reference = parseInt(reference.slice(2), 16);\n-      reference = response._formData.get(response._prefix + reference);\n-      reference =\n-        constructor === ArrayBuffer\n-          ? reference.arrayBuffer()\n-          : reference.arrayBuffer().then(function (buffer) {\n-              return new constructor(buffer);\n-            });\n-      bytesPerElement = initializingChunk;\n+      reference = response._formData\n+        .get(response._prefix + reference)\n+        .arrayBuffer();\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n       reference.then(\n-        createModelResolver(\n-          bytesPerElement,\n-          parentObject,\n-          parentKey,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(bytesPerElement)\n+        function (buffer) {\n+          buffer =\n+            constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+          parentObject[parentKey] = buffer;\n+          \"\" === parentKey &&\n+            null === handler.value &&\n+            (handler.value = buffer);\n+          handler.deps--;\n+          if (\n+            0 === handler.deps &&\n+            ((buffer = handler.chunk),\n+            null !== buffer && \"blocked\" === buffer.status)\n+          ) {\n+            var resolveListeners = buffer.value;\n+            buffer.status = \"fulfilled\";\n+            buffer.value = handler.value;\n+            null !== resolveListeners &&\n+              wakeChunk(response, resolveListeners, handler.value);\n+          }\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n     function resolveStream(response, id, stream, controller) {\n       var chunks = response._chunks;\n-      stream = new Chunk(\"fulfilled\", stream, controller, response);\n+      stream = new ReactPromise(\"fulfilled\", stream, controller);\n       chunks.set(id, stream);\n       response = response._formData.getAll(response._prefix + id);\n       for (id = 0; id < response.length; id++)\n         (chunks = response[id]),\n-          \"C\" === chunks[0]\n-            ? controller.close(\n-                \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n-              )\n-            : controller.enqueueModel(chunks);\n+          \"string\" === typeof chunks &&\n+            (\"C\" === chunks[0]\n+              ? controller.close(\n+                  \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n+                )\n+              : controller.enqueueModel(chunks));\n     }\n     function parseReadableStream(response, reference, type) {\n       reference = parseInt(reference.slice(2), 16);\n@@ -4382,7 +4616,11 @@\n       resolveStream(response, reference, type, {\n         enqueueModel: function (json) {\n           if (null === previousBlockedChunk) {\n-            var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+            var chunk = new ReactPromise(\n+              \"resolved_model\",\n+              json,\n+              _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n+            );\n             initializeModelChunk(chunk);\n             \"fulfilled\" === chunk.status\n               ? controller.enqueue(chunk.value)\n@@ -4397,7 +4635,7 @@\n                 (previousBlockedChunk = chunk));\n           } else {\n             chunk = previousBlockedChunk;\n-            var _chunk = createPendingChunk(response);\n+            var _chunk = new ReactPromise(\"pending\", null, null);\n             _chunk.then(\n               function (v) {\n                 return controller.enqueue(v);\n@@ -4409,7 +4647,7 @@\n             previousBlockedChunk = _chunk;\n             chunk.then(function () {\n               previousBlockedChunk === _chunk && (previousBlockedChunk = null);\n-              resolveModelChunk(_chunk, json, -1);\n+              resolveModelChunk(response, _chunk, json, -1);\n             });\n           }\n         },\n@@ -4458,13 +4696,12 @@\n               );\n             if (nextReadIndex === buffer.length) {\n               if (closed)\n-                return new Chunk(\n+                return new ReactPromise(\n                   \"fulfilled\",\n                   { done: !0, value: void 0 },\n-                  null,\n-                  response\n+                  null\n                 );\n-              buffer[nextReadIndex] = createPendingChunk(response);\n+              buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n             }\n             return buffer[nextReadIndex++];\n           });\n@@ -4478,7 +4715,12 @@\n                 value,\n                 !1\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !1\n+              );\n           nextWriteIndex++;\n         },\n         close: function (value) {\n@@ -4489,9 +4731,15 @@\n                 value,\n                 !0\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !0\n+              );\n           for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n             resolveIteratorResultChunk(\n+              response,\n               buffer[nextWriteIndex++],\n               '\"$undefined\"',\n               !0\n@@ -4501,11 +4749,11 @@\n           closed = !0;\n           for (\n             nextWriteIndex === buffer.length &&\n-            (buffer[nextWriteIndex] = createPendingChunk(response));\n+            (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n             nextWriteIndex < buffer.length;\n \n           )\n-            triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n         }\n       });\n       return iterator;\n@@ -4522,21 +4770,7 @@\n           case \"F\":\n             return (\n               (value = value.slice(2)),\n-              (value = getOutlinedModel(\n-                response,\n-                value,\n-                obj,\n-                key,\n-                createModel\n-              )),\n-              loadServerReference$1(\n-                response,\n-                value.id,\n-                value.bound,\n-                initializingChunk,\n-                obj,\n-                key\n-              )\n+              getOutlinedModel(response, value, obj, key, loadServerReference$1)\n             );\n           case \"T\":\n             if (\n@@ -5212,33 +5446,32 @@\n       debugNoOutline = null,\n       emptyRoot = {},\n       decoderOptions = { stream: !0 },\n-      chunkCache = new Map();\n-    Chunk.prototype = Object.create(Promise.prototype);\n-    Chunk.prototype.then = function (resolve, reject) {\n+      chunkCache = new Map(),\n+      RESPONSE_SYMBOL = Symbol();\n+    ReactPromise.prototype = Object.create(Promise.prototype);\n+    ReactPromise.prototype.then = function (resolve, reject) {\n       switch (this.status) {\n         case \"resolved_model\":\n           initializeModelChunk(this);\n       }\n       switch (this.status) {\n         case \"fulfilled\":\n-          resolve(this.value);\n+          \"function\" === typeof resolve && resolve(this.value);\n           break;\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          resolve &&\n+          \"function\" === typeof resolve &&\n             (null === this.value && (this.value = []),\n             this.value.push(resolve));\n-          reject &&\n+          \"function\" === typeof reject &&\n             (null === this.reason && (this.reason = []),\n             this.reason.push(reject));\n           break;\n         default:\n-          reject(this.reason);\n+          \"function\" === typeof reject && reject(this.reason);\n       }\n     };\n-    var initializingChunk = null,\n-      initializingChunkBlockedModel = null;\n+    var initializingHandler = null;\n     exports.createClientModuleProxy = function (moduleId) {\n       moduleId = registerClientReferenceImpl({}, moduleId, !1);\n       return new Proxy(moduleId, proxyHandlers$1);\n@@ -5318,11 +5551,12 @@\n             var response = response$jscomp$0;\n             response._formData.append(name, entry);\n             var prefix = response._prefix;\n-            name.startsWith(prefix) &&\n-              ((response = response._chunks),\n-              (name = +name.slice(prefix.length)),\n-              (prefix = response.get(name)) &&\n-                resolveModelChunk(prefix, entry, name));\n+            if (name.startsWith(prefix)) {\n+              var chunks = response._chunks;\n+              name = +name.slice(prefix.length);\n+              (chunks = chunks.get(name)) &&\n+                resolveModelChunk(response, chunks, entry, name);\n+            }\n           } else response$jscomp$0._formData.append(name, entry);\n           iterator.next().then(progress, error);\n         }"
        },
        {
            "sha": "72575a26e1d4f71269ffc9a2209ea99e2ae73469",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.edge.production.js",
            "status": "modified",
            "additions": 428,
            "deletions": 203,
            "changes": 631,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.edge.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -979,8 +979,8 @@ function serializeReadableStream(request, task, stream) {\n               : tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             reader.read().then(progress, error);\n-        } catch (x$8) {\n-          error(x$8);\n+        } catch (x$11) {\n+          error(x$11);\n         }\n   }\n   function error(reason) {\n@@ -1065,8 +1065,8 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n             tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             iterator.next().then(progress, error);\n-        } catch (x$9) {\n-          error(x$9);\n+        } catch (x$12) {\n+          error(x$12);\n         }\n   }\n   function error(reason) {\n@@ -2233,9 +2233,9 @@ function abort(request, reason) {\n         onAllReady();\n         flushCompletedChunks(request);\n       }\n-    } catch (error$26) {\n-      logRecoverableError(request, error$26, null),\n-        fatalError(request, error$26);\n+    } catch (error$29) {\n+      logRecoverableError(request, error$29, null),\n+        fatalError(request, error$29);\n     }\n }\n function resolveServerReference(bundlerConfig, id) {\n@@ -2305,59 +2305,97 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n-}\n-function Chunk(status, value, reason, response) {\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n+}\n+var RESPONSE_SYMBOL = Symbol();\n+function ReactPromise(status, value, reason) {\n   this.status = status;\n   this.value = value;\n   this.reason = reason;\n-  this._response = response;\n }\n-Chunk.prototype = Object.create(Promise.prototype);\n-Chunk.prototype.then = function (resolve, reject) {\n+ReactPromise.prototype = Object.create(Promise.prototype);\n+ReactPromise.prototype.then = function (resolve, reject) {\n   switch (this.status) {\n     case \"resolved_model\":\n       initializeModelChunk(this);\n   }\n   switch (this.status) {\n     case \"fulfilled\":\n-      resolve(this.value);\n+      \"function\" === typeof resolve && resolve(this.value);\n       break;\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      resolve &&\n+      \"function\" === typeof resolve &&\n         (null === this.value && (this.value = []), this.value.push(resolve));\n-      reject &&\n+      \"function\" === typeof reject &&\n         (null === this.reason && (this.reason = []), this.reason.push(reject));\n       break;\n     default:\n-      reject(this.reason);\n+      \"function\" === typeof reject && reject(this.reason);\n   }\n };\n-function createPendingChunk(response) {\n-  return new Chunk(\"pending\", null, null, response);\n+function wakeChunk(response, listeners, value) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(value)\n+      : fulfillReference(response, listener, value);\n+  }\n }\n-function wakeChunk(listeners, value) {\n-  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+function rejectChunk(response, listeners, error) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(error)\n+      : rejectReference(response, listener.handler, error);\n+  }\n }\n-function triggerErrorOnChunk(chunk, error) {\n+function resolveBlockedCycle(resolvedChunk, reference) {\n+  var referencedChunk = reference.handler.chunk;\n+  if (null === referencedChunk) return null;\n+  if (referencedChunk === resolvedChunk) return reference.handler;\n+  reference = referencedChunk.value;\n+  if (null !== reference)\n+    for (\n+      referencedChunk = 0;\n+      referencedChunk < reference.length;\n+      referencedChunk++\n+    ) {\n+      var listener = reference[referencedChunk];\n+      if (\n+        \"function\" !== typeof listener &&\n+        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+        null !== listener)\n+      )\n+        return listener;\n+    }\n+  return null;\n+}\n+function triggerErrorOnChunk(response, chunk, error) {\n   if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n     chunk.reason.error(error);\n   else {\n     var listeners = chunk.reason;\n     chunk.status = \"rejected\";\n     chunk.reason = error;\n-    null !== listeners && wakeChunk(listeners, error);\n+    null !== listeners && rejectChunk(response, listeners, error);\n   }\n }\n-function resolveModelChunk(chunk, value, id) {\n+function createResolvedModelChunk(response, value, id) {\n+  var $jscomp$compprop2 = {};\n+  return new ReactPromise(\n+    \"resolved_model\",\n+    value,\n+    (($jscomp$compprop2.id = id),\n+    ($jscomp$compprop2[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop2)\n+  );\n+}\n+function resolveModelChunk(response, chunk, value, id) {\n   if (\"pending\" !== chunk.status)\n     (chunk = chunk.reason),\n       \"C\" === value[0]\n@@ -2368,77 +2406,129 @@ function resolveModelChunk(chunk, value, id) {\n       rejectListeners = chunk.reason;\n     chunk.status = \"resolved_model\";\n     chunk.value = value;\n-    chunk.reason = id;\n+    value = {};\n+    chunk.reason =\n+      ((value.id = id), (value[RESPONSE_SYMBOL] = response), value);\n     if (null !== resolveListeners)\n-      switch ((initializeModelChunk(chunk), chunk.status)) {\n+      a: switch ((initializeModelChunk(chunk), chunk.status)) {\n         case \"fulfilled\":\n-          wakeChunk(resolveListeners, chunk.value);\n+          wakeChunk(response, resolveListeners, chunk.value);\n           break;\n-        case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n+          for (value = 0; value < resolveListeners.length; value++)\n+            if (((id = resolveListeners[value]), \"function\" !== typeof id)) {\n+              var cyclicHandler = resolveBlockedCycle(chunk, id);\n+              if (null !== cyclicHandler)\n+                switch (\n+                  (fulfillReference(response, id, cyclicHandler.value),\n+                  resolveListeners.splice(value, 1),\n+                  value--,\n+                  null !== rejectListeners &&\n+                    ((id = rejectListeners.indexOf(id)),\n+                    -1 !== id && rejectListeners.splice(id, 1)),\n+                  chunk.status)\n+                ) {\n+                  case \"fulfilled\":\n+                    wakeChunk(response, resolveListeners, chunk.value);\n+                    break a;\n+                  case \"rejected\":\n+                    null !== rejectListeners &&\n+                      rejectChunk(response, rejectListeners, chunk.reason);\n+                    break a;\n+                }\n+            }\n+        case \"pending\":\n           if (chunk.value)\n-            for (value = 0; value < resolveListeners.length; value++)\n-              chunk.value.push(resolveListeners[value]);\n+            for (response = 0; response < resolveListeners.length; response++)\n+              chunk.value.push(resolveListeners[response]);\n           else chunk.value = resolveListeners;\n           if (chunk.reason) {\n             if (rejectListeners)\n-              for (value = 0; value < rejectListeners.length; value++)\n-                chunk.reason.push(rejectListeners[value]);\n+              for (\n+                resolveListeners = 0;\n+                resolveListeners < rejectListeners.length;\n+                resolveListeners++\n+              )\n+                chunk.reason.push(rejectListeners[resolveListeners]);\n           } else chunk.reason = rejectListeners;\n           break;\n         case \"rejected\":\n-          rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+          rejectListeners && wakeChunk(response, rejectListeners, chunk.reason);\n       }\n   }\n }\n function createResolvedIteratorResultChunk(response, value, done) {\n-  return new Chunk(\n+  var $jscomp$compprop4 = {};\n+  return new ReactPromise(\n     \"resolved_model\",\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n-    -1,\n-    response\n+    (($jscomp$compprop4.id = -1),\n+    ($jscomp$compprop4[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop4)\n   );\n }\n-function resolveIteratorResultChunk(chunk, value, done) {\n+function resolveIteratorResultChunk(response, chunk, value, done) {\n   resolveModelChunk(\n+    response,\n     chunk,\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n     -1\n   );\n }\n-function loadServerReference$1(\n-  response,\n-  id,\n-  bound,\n-  parentChunk,\n-  parentObject,\n-  key\n-) {\n+function loadServerReference$1(response, metaData, parentObject, key) {\n+  var id = metaData.id;\n+  if (\"string\" !== typeof id) return null;\n   var serverReference = resolveServerReference(response._bundlerConfig, id);\n-  id = preloadModule(serverReference);\n-  if (bound)\n-    bound = Promise.all([bound, id]).then(function (_ref) {\n-      _ref = _ref[0];\n-      var fn = requireModule(serverReference);\n-      return fn.bind.apply(fn, [null].concat(_ref));\n-    });\n-  else if (id)\n-    bound = Promise.resolve(id).then(function () {\n-      return requireModule(serverReference);\n-    });\n+  id = metaData.bound;\n+  var promise = preloadModule(serverReference);\n+  if (promise)\n+    id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+  else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n   else return requireModule(serverReference);\n-  bound.then(\n-    createModelResolver(\n-      parentChunk,\n-      parentObject,\n-      key,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(parentChunk)\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n+  promise.then(\n+    function () {\n+      var resolvedValue = requireModule(serverReference);\n+      if (metaData.bound) {\n+        var promiseValue = metaData.bound.value;\n+        promiseValue = Array.isArray(promiseValue) ? promiseValue.slice(0) : [];\n+        promiseValue.unshift(null);\n+        resolvedValue = resolvedValue.bind.apply(resolvedValue, promiseValue);\n+      }\n+      parentObject[key] = resolvedValue;\n+      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((resolvedValue = handler.chunk),\n+        null !== resolvedValue &&\n+          \"blocked\" === resolvedValue.status &&\n+          ((promiseValue = resolvedValue.value),\n+          (resolvedValue.status = \"fulfilled\"),\n+          (resolvedValue.value = handler.value),\n+          null !== promiseValue &&\n+            wakeChunk(response, promiseValue, handler.value)));\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n@@ -2468,53 +2558,65 @@ function reviveModel(response, parentObj, parentKey, value, reference) {\n               ? reference + \":\" + i\n               : void 0),\n           (parentObj = reviveModel(response, value, i, value[i], parentObj)),\n-          void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+          void 0 !== parentObj || \"__proto__\" === i\n+            ? (value[i] = parentObj)\n+            : delete value[i]);\n   return value;\n }\n-var initializingChunk = null,\n-  initializingChunkBlockedModel = null;\n+var initializingHandler = null;\n function initializeModelChunk(chunk) {\n-  var prevChunk = initializingChunk,\n-    prevBlocked = initializingChunkBlockedModel;\n-  initializingChunk = chunk;\n-  initializingChunkBlockedModel = null;\n-  var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-    resolvedModel = chunk.value;\n-  chunk.status = \"cyclic\";\n+  var prevHandler = initializingHandler;\n+  initializingHandler = null;\n+  var _chunk$reason = chunk.reason,\n+    response = _chunk$reason[RESPONSE_SYMBOL];\n+  _chunk$reason = _chunk$reason.id;\n+  _chunk$reason = -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+  var resolvedModel = chunk.value;\n+  chunk.status = \"blocked\";\n   chunk.value = null;\n   chunk.reason = null;\n   try {\n     var rawModel = JSON.parse(resolvedModel),\n       value = reviveModel(\n-        chunk._response,\n+        response,\n         { \"\": rawModel },\n         \"\",\n         rawModel,\n-        rootReference\n-      );\n-    if (\n-      null !== initializingChunkBlockedModel &&\n-      0 < initializingChunkBlockedModel.deps\n-    )\n-      (initializingChunkBlockedModel.value = value), (chunk.status = \"blocked\");\n-    else {\n-      var resolveListeners = chunk.value;\n-      chunk.status = \"fulfilled\";\n-      chunk.value = value;\n-      null !== resolveListeners && wakeChunk(resolveListeners, value);\n+        _chunk$reason\n+      ),\n+      resolveListeners = chunk.value;\n+    if (null !== resolveListeners)\n+      for (\n+        chunk.value = null, chunk.reason = null, rawModel = 0;\n+        rawModel < resolveListeners.length;\n+        rawModel++\n+      ) {\n+        var listener = resolveListeners[rawModel];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n+    if (null !== initializingHandler) {\n+      if (initializingHandler.errored) throw initializingHandler.reason;\n+      if (0 < initializingHandler.deps) {\n+        initializingHandler.value = value;\n+        initializingHandler.chunk = chunk;\n+        return;\n+      }\n     }\n+    chunk.status = \"fulfilled\";\n+    chunk.value = value;\n   } catch (error) {\n     (chunk.status = \"rejected\"), (chunk.reason = error);\n   } finally {\n-    (initializingChunk = prevChunk),\n-      (initializingChunkBlockedModel = prevBlocked);\n+    initializingHandler = prevHandler;\n   }\n }\n function reportGlobalError(response, error) {\n   response._closed = !0;\n   response._closedReason = error;\n   response._chunks.forEach(function (chunk) {\n-    \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+    \"pending\" === chunk.status && triggerErrorOnChunk(response, chunk, error);\n   });\n }\n function getChunk(response, id) {\n@@ -2523,48 +2625,104 @@ function getChunk(response, id) {\n   chunk ||\n     ((chunk = response._formData.get(response._prefix + id)),\n     (chunk =\n-      null != chunk\n-        ? new Chunk(\"resolved_model\", chunk, id, response)\n+      \"string\" === typeof chunk\n+        ? createResolvedModelChunk(response, chunk, id)\n         : response._closed\n-          ? new Chunk(\"rejected\", null, response._closedReason, response)\n-          : createPendingChunk(response)),\n+          ? new ReactPromise(\"rejected\", null, response._closedReason)\n+          : new ReactPromise(\"pending\", null, null)),\n     chunks.set(id, chunk));\n   return chunk;\n }\n-function createModelResolver(\n-  chunk,\n+function fulfillReference(response, reference, value) {\n+  for (\n+    var handler = reference.handler,\n+      parentObject = reference.parentObject,\n+      key = reference.key,\n+      map = reference.map,\n+      path = reference.path,\n+      i = 1;\n+    i < path.length;\n+    i++\n+  ) {\n+    for (; value instanceof ReactPromise; ) {\n+      switch (value.status) {\n+        case \"resolved_model\":\n+          initializeModelChunk(value);\n+      }\n+      switch (value.status) {\n+        case \"fulfilled\":\n+          value = value.value;\n+          continue;\n+        case \"blocked\":\n+        case \"pending\":\n+          path.splice(0, i - 1);\n+          null === value.value\n+            ? (value.value = [reference])\n+            : value.value.push(reference);\n+          null === value.reason\n+            ? (value.reason = [reference])\n+            : value.reason.push(reference);\n+          return;\n+        default:\n+          rejectReference(response, reference.handler, value.reason);\n+          return;\n+      }\n+    }\n+    var name = path[i];\n+    \"object\" === typeof value &&\n+      hasOwnProperty.call(value, name) &&\n+      (value = value[name]);\n+  }\n+  reference = map(response, value, parentObject, key);\n+  parentObject[key] = reference;\n+  \"\" === key && null === handler.value && (handler.value = reference);\n+  handler.deps--;\n+  0 === handler.deps &&\n+    ((parentObject = handler.chunk),\n+    null !== parentObject &&\n+      \"blocked\" === parentObject.status &&\n+      ((key = parentObject.value),\n+      (parentObject.status = \"fulfilled\"),\n+      (parentObject.value = handler.value),\n+      (parentObject.reason = handler.reason),\n+      null !== key && wakeChunk(response, key, handler.value)));\n+}\n+function rejectReference(response, handler, error) {\n+  handler.errored ||\n+    ((handler.errored = !0),\n+    (handler.value = null),\n+    (handler.reason = error),\n+    (handler = handler.chunk),\n+    null !== handler &&\n+      \"blocked\" === handler.status &&\n+      triggerErrorOnChunk(response, handler, error));\n+}\n+function waitForReference(\n+  referencedChunk,\n   parentObject,\n   key,\n-  cyclic,\n   response,\n   map,\n   path\n ) {\n-  if (initializingChunkBlockedModel) {\n-    var blocked = initializingChunkBlockedModel;\n-    cyclic || blocked.deps++;\n-  } else\n-    blocked = initializingChunkBlockedModel = {\n-      deps: cyclic ? 0 : 1,\n-      value: null\n-    };\n-  return function (value) {\n-    for (var i = 1; i < path.length; i++) value = value[path[i]];\n-    parentObject[key] = map(response, value);\n-    \"\" === key && null === blocked.value && (blocked.value = parentObject[key]);\n-    blocked.deps--;\n-    0 === blocked.deps &&\n-      \"blocked\" === chunk.status &&\n-      ((value = chunk.value),\n-      (chunk.status = \"fulfilled\"),\n-      (chunk.value = blocked.value),\n-      null !== value && wakeChunk(value, blocked.value));\n-  };\n-}\n-function createModelReject(chunk) {\n-  return function (error) {\n-    return triggerErrorOnChunk(chunk, error);\n+  initializingHandler\n+    ? ((response = initializingHandler), response.deps++)\n+    : (response = initializingHandler =\n+        { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+  parentObject = {\n+    handler: response,\n+    parentObject: parentObject,\n+    key: key,\n+    map: map,\n+    path: path\n   };\n+  null === referencedChunk.value\n+    ? (referencedChunk.value = [parentObject])\n+    : referencedChunk.value.push(parentObject);\n+  null === referencedChunk.reason\n+    ? (referencedChunk.reason = [parentObject])\n+    : referencedChunk.reason.push(parentObject);\n+  return null;\n }\n function getOutlinedModel(response, reference, parentObject, key, map) {\n   reference = reference.split(\":\");\n@@ -2576,29 +2734,68 @@ function getOutlinedModel(response, reference, parentObject, key, map) {\n   }\n   switch (id.status) {\n     case \"fulfilled\":\n-      parentObject = id.value;\n-      for (key = 1; key < reference.length; key++)\n-        parentObject = parentObject[reference[key]];\n-      return map(response, parentObject);\n+      var value = id.value;\n+      for (id = 1; id < reference.length; id++) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              break;\n+            case \"blocked\":\n+            case \"pending\":\n+              return waitForReference(\n+                value,\n+                parentObject,\n+                key,\n+                response,\n+                map,\n+                reference.slice(id - 1)\n+              );\n+            default:\n+              return (\n+                initializingHandler\n+                  ? ((initializingHandler.errored = !0),\n+                    (initializingHandler.value = null),\n+                    (initializingHandler.reason = value.reason))\n+                  : (initializingHandler = {\n+                      chunk: null,\n+                      value: null,\n+                      reason: value.reason,\n+                      deps: 0,\n+                      errored: !0\n+                    }),\n+                null\n+              );\n+          }\n+        }\n+        var name = reference[id];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      return map(response, value, parentObject, key);\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      var parentChunk = initializingChunk;\n-      id.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          \"cyclic\" === id.status,\n-          response,\n-          map,\n-          reference\n-        ),\n-        createModelReject(parentChunk)\n-      );\n-      return null;\n+      return waitForReference(id, parentObject, key, response, map, reference);\n     default:\n-      throw id.reason;\n+      return (\n+        initializingHandler\n+          ? ((initializingHandler.errored = !0),\n+            (initializingHandler.value = null),\n+            (initializingHandler.reason = id.reason))\n+          : (initializingHandler = {\n+              chunk: null,\n+              value: null,\n+              reason: id.reason,\n+              deps: 0,\n+              errored: !0\n+            }),\n+        null\n+      );\n   }\n }\n function createMap(response, model) {\n@@ -2622,38 +2819,63 @@ function parseTypedArray(\n   parentKey\n ) {\n   reference = parseInt(reference.slice(2), 16);\n-  reference = response._formData.get(response._prefix + reference);\n-  reference =\n-    constructor === ArrayBuffer\n-      ? reference.arrayBuffer()\n-      : reference.arrayBuffer().then(function (buffer) {\n-          return new constructor(buffer);\n-        });\n-  bytesPerElement = initializingChunk;\n+  reference = response._formData\n+    .get(response._prefix + reference)\n+    .arrayBuffer();\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n   reference.then(\n-    createModelResolver(\n-      bytesPerElement,\n-      parentObject,\n-      parentKey,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(bytesPerElement)\n+    function (buffer) {\n+      buffer = constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+      parentObject[parentKey] = buffer;\n+      \"\" === parentKey && null === handler.value && (handler.value = buffer);\n+      handler.deps--;\n+      if (\n+        0 === handler.deps &&\n+        ((buffer = handler.chunk),\n+        null !== buffer && \"blocked\" === buffer.status)\n+      ) {\n+        var resolveListeners = buffer.value;\n+        buffer.status = \"fulfilled\";\n+        buffer.value = handler.value;\n+        null !== resolveListeners &&\n+          wakeChunk(response, resolveListeners, handler.value);\n+      }\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n function resolveStream(response, id, stream, controller) {\n   var chunks = response._chunks;\n-  stream = new Chunk(\"fulfilled\", stream, controller, response);\n+  stream = new ReactPromise(\"fulfilled\", stream, controller);\n   chunks.set(id, stream);\n   response = response._formData.getAll(response._prefix + id);\n   for (id = 0; id < response.length; id++)\n     (chunks = response[id]),\n-      \"C\" === chunks[0]\n-        ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n-        : controller.enqueueModel(chunks);\n+      \"string\" === typeof chunks &&\n+        (\"C\" === chunks[0]\n+          ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n+          : controller.enqueueModel(chunks));\n }\n function parseReadableStream(response, reference, type) {\n   reference = parseInt(reference.slice(2), 16);\n@@ -2668,7 +2890,7 @@ function parseReadableStream(response, reference, type) {\n   resolveStream(response, reference, type, {\n     enqueueModel: function (json) {\n       if (null === previousBlockedChunk) {\n-        var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+        var chunk = createResolvedModelChunk(response, json, -1);\n         initializeModelChunk(chunk);\n         \"fulfilled\" === chunk.status\n           ? controller.enqueue(chunk.value)\n@@ -2683,19 +2905,19 @@ function parseReadableStream(response, reference, type) {\n             (previousBlockedChunk = chunk));\n       } else {\n         chunk = previousBlockedChunk;\n-        var chunk$29 = createPendingChunk(response);\n-        chunk$29.then(\n+        var chunk$33 = new ReactPromise(\"pending\", null, null);\n+        chunk$33.then(\n           function (v) {\n             return controller.enqueue(v);\n           },\n           function (e) {\n             return controller.error(e);\n           }\n         );\n-        previousBlockedChunk = chunk$29;\n+        previousBlockedChunk = chunk$33;\n         chunk.then(function () {\n-          previousBlockedChunk === chunk$29 && (previousBlockedChunk = null);\n-          resolveModelChunk(chunk$29, json, -1);\n+          previousBlockedChunk === chunk$33 && (previousBlockedChunk = null);\n+          resolveModelChunk(response, chunk$33, json, -1);\n         });\n       }\n     },\n@@ -2735,9 +2957,9 @@ function parseAsyncIterable(response, reference, iterator) {\n   var buffer = [],\n     closed = !1,\n     nextWriteIndex = 0,\n-    $jscomp$compprop2 = {};\n-  $jscomp$compprop2 =\n-    (($jscomp$compprop2[ASYNC_ITERATOR] = function () {\n+    $jscomp$compprop5 = {};\n+  $jscomp$compprop5 =\n+    (($jscomp$compprop5[ASYNC_ITERATOR] = function () {\n       var nextReadIndex = 0;\n       return createIterator(function (arg) {\n         if (void 0 !== arg)\n@@ -2746,19 +2968,18 @@ function parseAsyncIterable(response, reference, iterator) {\n           );\n         if (nextReadIndex === buffer.length) {\n           if (closed)\n-            return new Chunk(\n+            return new ReactPromise(\n               \"fulfilled\",\n               { done: !0, value: void 0 },\n-              null,\n-              response\n+              null\n             );\n-          buffer[nextReadIndex] = createPendingChunk(response);\n+          buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n         }\n         return buffer[nextReadIndex++];\n       });\n     }),\n-    $jscomp$compprop2);\n-  iterator = iterator ? $jscomp$compprop2[ASYNC_ITERATOR]() : $jscomp$compprop2;\n+    $jscomp$compprop5);\n+  iterator = iterator ? $jscomp$compprop5[ASYNC_ITERATOR]() : $jscomp$compprop5;\n   resolveStream(response, reference, iterator, {\n     enqueueModel: function (value) {\n       nextWriteIndex === buffer.length\n@@ -2767,7 +2988,12 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !1\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !1\n+          );\n       nextWriteIndex++;\n     },\n     close: function (value) {\n@@ -2778,9 +3004,15 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !0\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !0\n+          );\n       for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n         resolveIteratorResultChunk(\n+          response,\n           buffer[nextWriteIndex++],\n           '\"$undefined\"',\n           !0\n@@ -2790,11 +3022,11 @@ function parseAsyncIterable(response, reference, iterator) {\n       closed = !0;\n       for (\n         nextWriteIndex === buffer.length &&\n-        (buffer[nextWriteIndex] = createPendingChunk(response));\n+        (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n         nextWriteIndex < buffer.length;\n \n       )\n-        triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+        triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n     }\n   });\n   return iterator;\n@@ -2809,15 +3041,7 @@ function parseModelString(response, obj, key, value, reference) {\n       case \"F\":\n         return (\n           (value = value.slice(2)),\n-          (value = getOutlinedModel(response, value, obj, key, createModel)),\n-          loadServerReference$1(\n-            response,\n-            value.id,\n-            value.bound,\n-            initializingChunk,\n-            obj,\n-            key\n-          )\n+          getOutlinedModel(response, value, obj, key, loadServerReference$1)\n         );\n       case \"T\":\n         if (void 0 === reference || void 0 === response._temporaryReferences)\n@@ -3032,7 +3256,8 @@ exports.decodeReplyFromAsyncIterable = function (\n         if (name.startsWith(prefix)) {\n           var chunks = response._chunks;\n           name = +name.slice(prefix.length);\n-          (chunks = chunks.get(name)) && resolveModelChunk(chunks, entry, name);\n+          (chunks = chunks.get(name)) &&\n+            resolveModelChunk(response, chunks, entry, name);\n         }\n       } else response._formData.append(name, entry);\n       iterator.next().then(progress, error);"
        },
        {
            "sha": "142af8ee41b272de927adeafe866b20e89bdcc0a",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.node.development.js",
            "status": "modified",
            "additions": 475,
            "deletions": 228,
            "changes": 703,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -4468,37 +4468,65 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n-    }\n-    function Chunk(status, value, reason, response) {\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n+    }\n+    function ReactPromise(status, value, reason) {\n       this.status = status;\n       this.value = value;\n       this.reason = reason;\n-      this._response = response;\n     }\n-    function createPendingChunk(response) {\n-      return new Chunk(\"pending\", null, null, response);\n+    function wakeChunk(response, listeners, value) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n     }\n-    function wakeChunk(listeners, value) {\n-      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+    function rejectChunk(response, listeners, error) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(error)\n+          : rejectReference(response, listener.handler, error);\n+      }\n     }\n-    function triggerErrorOnChunk(chunk, error) {\n+    function resolveBlockedCycle(resolvedChunk, reference) {\n+      var referencedChunk = reference.handler.chunk;\n+      if (null === referencedChunk) return null;\n+      if (referencedChunk === resolvedChunk) return reference.handler;\n+      reference = referencedChunk.value;\n+      if (null !== reference)\n+        for (\n+          referencedChunk = 0;\n+          referencedChunk < reference.length;\n+          referencedChunk++\n+        ) {\n+          var listener = reference[referencedChunk];\n+          if (\n+            \"function\" !== typeof listener &&\n+            ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+            null !== listener)\n+          )\n+            return listener;\n+        }\n+      return null;\n+    }\n+    function triggerErrorOnChunk(response, chunk, error) {\n       if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n         chunk.reason.error(error);\n       else {\n         var listeners = chunk.reason;\n         chunk.status = \"rejected\";\n         chunk.reason = error;\n-        null !== listeners && wakeChunk(listeners, error);\n+        null !== listeners && rejectChunk(response, listeners, error);\n       }\n     }\n-    function resolveModelChunk(chunk, value, id) {\n+    function resolveModelChunk(response, chunk, value, id) {\n       if (\"pending\" !== chunk.status)\n         (chunk = chunk.reason),\n           \"C\" === value[0]\n@@ -4509,81 +4537,142 @@\n           rejectListeners = chunk.reason;\n         chunk.status = \"resolved_model\";\n         chunk.value = value;\n-        chunk.reason = id;\n+        chunk.reason = _defineProperty({ id: id }, RESPONSE_SYMBOL, response);\n         if (null !== resolveListeners)\n-          switch ((initializeModelChunk(chunk), chunk.status)) {\n+          a: switch ((initializeModelChunk(chunk), chunk.status)) {\n             case \"fulfilled\":\n-              wakeChunk(resolveListeners, chunk.value);\n+              wakeChunk(response, resolveListeners, chunk.value);\n               break;\n-            case \"pending\":\n             case \"blocked\":\n-            case \"cyclic\":\n+              for (value = 0; value < resolveListeners.length; value++)\n+                if (\n+                  ((id = resolveListeners[value]), \"function\" !== typeof id)\n+                ) {\n+                  var cyclicHandler = resolveBlockedCycle(chunk, id);\n+                  if (null !== cyclicHandler)\n+                    switch (\n+                      (fulfillReference(response, id, cyclicHandler.value),\n+                      resolveListeners.splice(value, 1),\n+                      value--,\n+                      null !== rejectListeners &&\n+                        ((id = rejectListeners.indexOf(id)),\n+                        -1 !== id && rejectListeners.splice(id, 1)),\n+                      chunk.status)\n+                    ) {\n+                      case \"fulfilled\":\n+                        wakeChunk(response, resolveListeners, chunk.value);\n+                        break a;\n+                      case \"rejected\":\n+                        null !== rejectListeners &&\n+                          rejectChunk(response, rejectListeners, chunk.reason);\n+                        break a;\n+                    }\n+                }\n+            case \"pending\":\n               if (chunk.value)\n-                for (value = 0; value < resolveListeners.length; value++)\n-                  chunk.value.push(resolveListeners[value]);\n+                for (\n+                  response = 0;\n+                  response < resolveListeners.length;\n+                  response++\n+                )\n+                  chunk.value.push(resolveListeners[response]);\n               else chunk.value = resolveListeners;\n               if (chunk.reason) {\n                 if (rejectListeners)\n-                  for (value = 0; value < rejectListeners.length; value++)\n-                    chunk.reason.push(rejectListeners[value]);\n+                  for (\n+                    resolveListeners = 0;\n+                    resolveListeners < rejectListeners.length;\n+                    resolveListeners++\n+                  )\n+                    chunk.reason.push(rejectListeners[resolveListeners]);\n               } else chunk.reason = rejectListeners;\n               break;\n             case \"rejected\":\n-              rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+              rejectListeners &&\n+                wakeChunk(response, rejectListeners, chunk.reason);\n           }\n       }\n     }\n     function createResolvedIteratorResultChunk(response, value, done) {\n-      return new Chunk(\n+      return new ReactPromise(\n         \"resolved_model\",\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n-        -1,\n-        response\n+        _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n       );\n     }\n-    function resolveIteratorResultChunk(chunk, value, done) {\n+    function resolveIteratorResultChunk(response, chunk, value, done) {\n       resolveModelChunk(\n+        response,\n         chunk,\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n         -1\n       );\n     }\n-    function loadServerReference$1(\n-      response,\n-      id,\n-      bound,\n-      parentChunk,\n-      parentObject,\n-      key\n-    ) {\n+    function loadServerReference$1(response, metaData, parentObject, key) {\n+      var id = metaData.id;\n+      if (\"string\" !== typeof id) return null;\n       var serverReference = resolveServerReference(response._bundlerConfig, id);\n-      id = preloadModule(serverReference);\n-      if (bound)\n-        bound = Promise.all([bound, id]).then(function (_ref) {\n-          _ref = _ref[0];\n-          var fn = requireModule(serverReference);\n-          return fn.bind.apply(fn, [null].concat(_ref));\n-        });\n-      else if (id)\n-        bound = Promise.resolve(id).then(function () {\n-          return requireModule(serverReference);\n-        });\n+      id = metaData.bound;\n+      var promise = preloadModule(serverReference);\n+      if (promise)\n+        id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+      else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n       else return requireModule(serverReference);\n-      bound.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(parentChunk)\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n+      promise.then(\n+        function () {\n+          var resolvedValue = requireModule(serverReference);\n+          if (metaData.bound) {\n+            var promiseValue = metaData.bound.value;\n+            promiseValue = Array.isArray(promiseValue)\n+              ? promiseValue.slice(0)\n+              : [];\n+            promiseValue.unshift(null);\n+            resolvedValue = resolvedValue.bind.apply(\n+              resolvedValue,\n+              promiseValue\n+            );\n+          }\n+          parentObject[key] = resolvedValue;\n+          \"\" === key &&\n+            null === handler.value &&\n+            (handler.value = resolvedValue);\n+          handler.deps--;\n+          0 === handler.deps &&\n+            ((resolvedValue = handler.chunk),\n+            null !== resolvedValue &&\n+              \"blocked\" === resolvedValue.status &&\n+              ((promiseValue = resolvedValue.value),\n+              (resolvedValue.status = \"fulfilled\"),\n+              (resolvedValue.value = handler.value),\n+              null !== promiseValue &&\n+                wakeChunk(response, promiseValue, handler.value)));\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n@@ -4625,53 +4714,66 @@\n                 value[i],\n                 parentObj\n               )),\n-              void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+              void 0 !== parentObj || \"__proto__\" === i\n+                ? (value[i] = parentObj)\n+                : delete value[i]);\n       return value;\n     }\n     function initializeModelChunk(chunk) {\n-      var prevChunk = initializingChunk,\n-        prevBlocked = initializingChunkBlockedModel;\n-      initializingChunk = chunk;\n-      initializingChunkBlockedModel = null;\n-      var rootReference =\n-          -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-        resolvedModel = chunk.value;\n-      chunk.status = \"cyclic\";\n+      var prevHandler = initializingHandler;\n+      initializingHandler = null;\n+      var _chunk$reason = chunk.reason,\n+        response = _chunk$reason[RESPONSE_SYMBOL];\n+      _chunk$reason = _chunk$reason.id;\n+      _chunk$reason =\n+        -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+      var resolvedModel = chunk.value;\n+      chunk.status = \"blocked\";\n       chunk.value = null;\n       chunk.reason = null;\n       try {\n         var rawModel = JSON.parse(resolvedModel),\n           value = reviveModel(\n-            chunk._response,\n+            response,\n             { \"\": rawModel },\n             \"\",\n             rawModel,\n-            rootReference\n-          );\n-        if (\n-          null !== initializingChunkBlockedModel &&\n-          0 < initializingChunkBlockedModel.deps\n-        )\n-          (initializingChunkBlockedModel.value = value),\n-            (chunk.status = \"blocked\");\n-        else {\n-          var resolveListeners = chunk.value;\n-          chunk.status = \"fulfilled\";\n-          chunk.value = value;\n-          null !== resolveListeners && wakeChunk(resolveListeners, value);\n+            _chunk$reason\n+          ),\n+          resolveListeners = chunk.value;\n+        if (null !== resolveListeners)\n+          for (\n+            chunk.value = null, chunk.reason = null, rawModel = 0;\n+            rawModel < resolveListeners.length;\n+            rawModel++\n+          ) {\n+            var listener = resolveListeners[rawModel];\n+            \"function\" === typeof listener\n+              ? listener(value)\n+              : fulfillReference(response, listener, value);\n+          }\n+        if (null !== initializingHandler) {\n+          if (initializingHandler.errored) throw initializingHandler.reason;\n+          if (0 < initializingHandler.deps) {\n+            initializingHandler.value = value;\n+            initializingHandler.chunk = chunk;\n+            return;\n+          }\n         }\n+        chunk.status = \"fulfilled\";\n+        chunk.value = value;\n       } catch (error) {\n         (chunk.status = \"rejected\"), (chunk.reason = error);\n       } finally {\n-        (initializingChunk = prevChunk),\n-          (initializingChunkBlockedModel = prevBlocked);\n+        initializingHandler = prevHandler;\n       }\n     }\n     function reportGlobalError(response, error) {\n       response._closed = !0;\n       response._closedReason = error;\n       response._chunks.forEach(function (chunk) {\n-        \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+        \"pending\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n       });\n     }\n     function getChunk(response, id) {\n@@ -4680,50 +4782,108 @@\n       chunk ||\n         ((chunk = response._formData.get(response._prefix + id)),\n         (chunk =\n-          null != chunk\n-            ? new Chunk(\"resolved_model\", chunk, id, response)\n+          \"string\" === typeof chunk\n+            ? new ReactPromise(\n+                \"resolved_model\",\n+                chunk,\n+                _defineProperty({ id: id }, RESPONSE_SYMBOL, response)\n+              )\n             : response._closed\n-              ? new Chunk(\"rejected\", null, response._closedReason, response)\n-              : createPendingChunk(response)),\n+              ? new ReactPromise(\"rejected\", null, response._closedReason)\n+              : new ReactPromise(\"pending\", null, null)),\n         chunks.set(id, chunk));\n       return chunk;\n     }\n-    function createModelResolver(\n-      chunk,\n+    function fulfillReference(response, reference, value) {\n+      for (\n+        var handler = reference.handler,\n+          parentObject = reference.parentObject,\n+          key = reference.key,\n+          map = reference.map,\n+          path = reference.path,\n+          i = 1;\n+        i < path.length;\n+        i++\n+      ) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              continue;\n+            case \"blocked\":\n+            case \"pending\":\n+              path.splice(0, i - 1);\n+              null === value.value\n+                ? (value.value = [reference])\n+                : value.value.push(reference);\n+              null === value.reason\n+                ? (value.reason = [reference])\n+                : value.reason.push(reference);\n+              return;\n+            default:\n+              rejectReference(response, reference.handler, value.reason);\n+              return;\n+          }\n+        }\n+        var name = path[i];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      reference = map(response, value, parentObject, key);\n+      parentObject[key] = reference;\n+      \"\" === key && null === handler.value && (handler.value = reference);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((parentObject = handler.chunk),\n+        null !== parentObject &&\n+          \"blocked\" === parentObject.status &&\n+          ((key = parentObject.value),\n+          (parentObject.status = \"fulfilled\"),\n+          (parentObject.value = handler.value),\n+          (parentObject.reason = handler.reason),\n+          null !== key && wakeChunk(response, key, handler.value)));\n+    }\n+    function rejectReference(response, handler, error) {\n+      handler.errored ||\n+        ((handler.errored = !0),\n+        (handler.value = null),\n+        (handler.reason = error),\n+        (handler = handler.chunk),\n+        null !== handler &&\n+          \"blocked\" === handler.status &&\n+          triggerErrorOnChunk(response, handler, error));\n+    }\n+    function waitForReference(\n+      referencedChunk,\n       parentObject,\n       key,\n-      cyclic,\n       response,\n       map,\n       path\n     ) {\n-      if (initializingChunkBlockedModel) {\n-        var blocked = initializingChunkBlockedModel;\n-        cyclic || blocked.deps++;\n-      } else\n-        blocked = initializingChunkBlockedModel = {\n-          deps: cyclic ? 0 : 1,\n-          value: null\n-        };\n-      return function (value) {\n-        for (var i = 1; i < path.length; i++) value = value[path[i]];\n-        parentObject[key] = map(response, value);\n-        \"\" === key &&\n-          null === blocked.value &&\n-          (blocked.value = parentObject[key]);\n-        blocked.deps--;\n-        0 === blocked.deps &&\n-          \"blocked\" === chunk.status &&\n-          ((value = chunk.value),\n-          (chunk.status = \"fulfilled\"),\n-          (chunk.value = blocked.value),\n-          null !== value && wakeChunk(value, blocked.value));\n-      };\n-    }\n-    function createModelReject(chunk) {\n-      return function (error) {\n-        return triggerErrorOnChunk(chunk, error);\n+      initializingHandler\n+        ? ((response = initializingHandler), response.deps++)\n+        : (response = initializingHandler =\n+            { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+      parentObject = {\n+        handler: response,\n+        parentObject: parentObject,\n+        key: key,\n+        map: map,\n+        path: path\n       };\n+      null === referencedChunk.value\n+        ? (referencedChunk.value = [parentObject])\n+        : referencedChunk.value.push(parentObject);\n+      null === referencedChunk.reason\n+        ? (referencedChunk.reason = [parentObject])\n+        : referencedChunk.reason.push(parentObject);\n+      return null;\n     }\n     function getOutlinedModel(response, reference, parentObject, key, map) {\n       reference = reference.split(\":\");\n@@ -4735,29 +4895,75 @@\n       }\n       switch (id.status) {\n         case \"fulfilled\":\n-          parentObject = id.value;\n-          for (key = 1; key < reference.length; key++)\n-            parentObject = parentObject[reference[key]];\n-          return map(response, parentObject);\n+          var value = id.value;\n+          for (id = 1; id < reference.length; id++) {\n+            for (; value instanceof ReactPromise; ) {\n+              switch (value.status) {\n+                case \"resolved_model\":\n+                  initializeModelChunk(value);\n+              }\n+              switch (value.status) {\n+                case \"fulfilled\":\n+                  value = value.value;\n+                  break;\n+                case \"blocked\":\n+                case \"pending\":\n+                  return waitForReference(\n+                    value,\n+                    parentObject,\n+                    key,\n+                    response,\n+                    map,\n+                    reference.slice(id - 1)\n+                  );\n+                default:\n+                  return (\n+                    initializingHandler\n+                      ? ((initializingHandler.errored = !0),\n+                        (initializingHandler.value = null),\n+                        (initializingHandler.reason = value.reason))\n+                      : (initializingHandler = {\n+                          chunk: null,\n+                          value: null,\n+                          reason: value.reason,\n+                          deps: 0,\n+                          errored: !0\n+                        }),\n+                    null\n+                  );\n+              }\n+            }\n+            var name = reference[id];\n+            \"object\" === typeof value &&\n+              hasOwnProperty.call(value, name) &&\n+              (value = value[name]);\n+          }\n+          return map(response, value, parentObject, key);\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          var parentChunk = initializingChunk;\n-          id.then(\n-            createModelResolver(\n-              parentChunk,\n-              parentObject,\n-              key,\n-              \"cyclic\" === id.status,\n-              response,\n-              map,\n-              reference\n-            ),\n-            createModelReject(parentChunk)\n+          return waitForReference(\n+            id,\n+            parentObject,\n+            key,\n+            response,\n+            map,\n+            reference\n           );\n-          return null;\n         default:\n-          throw id.reason;\n+          return (\n+            initializingHandler\n+              ? ((initializingHandler.errored = !0),\n+                (initializingHandler.value = null),\n+                (initializingHandler.reason = id.reason))\n+              : (initializingHandler = {\n+                  chunk: null,\n+                  value: null,\n+                  reason: id.reason,\n+                  deps: 0,\n+                  errored: !0\n+                }),\n+            null\n+          );\n       }\n     }\n     function createMap(response, model) {\n@@ -4781,40 +4987,68 @@\n       parentKey\n     ) {\n       reference = parseInt(reference.slice(2), 16);\n-      reference = response._formData.get(response._prefix + reference);\n-      reference =\n-        constructor === ArrayBuffer\n-          ? reference.arrayBuffer()\n-          : reference.arrayBuffer().then(function (buffer) {\n-              return new constructor(buffer);\n-            });\n-      bytesPerElement = initializingChunk;\n+      reference = response._formData\n+        .get(response._prefix + reference)\n+        .arrayBuffer();\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n       reference.then(\n-        createModelResolver(\n-          bytesPerElement,\n-          parentObject,\n-          parentKey,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(bytesPerElement)\n+        function (buffer) {\n+          buffer =\n+            constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+          parentObject[parentKey] = buffer;\n+          \"\" === parentKey &&\n+            null === handler.value &&\n+            (handler.value = buffer);\n+          handler.deps--;\n+          if (\n+            0 === handler.deps &&\n+            ((buffer = handler.chunk),\n+            null !== buffer && \"blocked\" === buffer.status)\n+          ) {\n+            var resolveListeners = buffer.value;\n+            buffer.status = \"fulfilled\";\n+            buffer.value = handler.value;\n+            null !== resolveListeners &&\n+              wakeChunk(response, resolveListeners, handler.value);\n+          }\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n     function resolveStream(response, id, stream, controller) {\n       var chunks = response._chunks;\n-      stream = new Chunk(\"fulfilled\", stream, controller, response);\n+      stream = new ReactPromise(\"fulfilled\", stream, controller);\n       chunks.set(id, stream);\n       response = response._formData.getAll(response._prefix + id);\n       for (id = 0; id < response.length; id++)\n         (chunks = response[id]),\n-          \"C\" === chunks[0]\n-            ? controller.close(\n-                \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n-              )\n-            : controller.enqueueModel(chunks);\n+          \"string\" === typeof chunks &&\n+            (\"C\" === chunks[0]\n+              ? controller.close(\n+                  \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n+                )\n+              : controller.enqueueModel(chunks));\n     }\n     function parseReadableStream(response, reference, type) {\n       reference = parseInt(reference.slice(2), 16);\n@@ -4829,7 +5063,11 @@\n       resolveStream(response, reference, type, {\n         enqueueModel: function (json) {\n           if (null === previousBlockedChunk) {\n-            var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+            var chunk = new ReactPromise(\n+              \"resolved_model\",\n+              json,\n+              _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n+            );\n             initializeModelChunk(chunk);\n             \"fulfilled\" === chunk.status\n               ? controller.enqueue(chunk.value)\n@@ -4844,7 +5082,7 @@\n                 (previousBlockedChunk = chunk));\n           } else {\n             chunk = previousBlockedChunk;\n-            var _chunk = createPendingChunk(response);\n+            var _chunk = new ReactPromise(\"pending\", null, null);\n             _chunk.then(\n               function (v) {\n                 return controller.enqueue(v);\n@@ -4856,7 +5094,7 @@\n             previousBlockedChunk = _chunk;\n             chunk.then(function () {\n               previousBlockedChunk === _chunk && (previousBlockedChunk = null);\n-              resolveModelChunk(_chunk, json, -1);\n+              resolveModelChunk(response, _chunk, json, -1);\n             });\n           }\n         },\n@@ -4905,13 +5143,12 @@\n               );\n             if (nextReadIndex === buffer.length) {\n               if (closed)\n-                return new Chunk(\n+                return new ReactPromise(\n                   \"fulfilled\",\n                   { done: !0, value: void 0 },\n-                  null,\n-                  response\n+                  null\n                 );\n-              buffer[nextReadIndex] = createPendingChunk(response);\n+              buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n             }\n             return buffer[nextReadIndex++];\n           });\n@@ -4925,7 +5162,12 @@\n                 value,\n                 !1\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !1\n+              );\n           nextWriteIndex++;\n         },\n         close: function (value) {\n@@ -4936,9 +5178,15 @@\n                 value,\n                 !0\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !0\n+              );\n           for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n             resolveIteratorResultChunk(\n+              response,\n               buffer[nextWriteIndex++],\n               '\"$undefined\"',\n               !0\n@@ -4948,11 +5196,11 @@\n           closed = !0;\n           for (\n             nextWriteIndex === buffer.length &&\n-            (buffer[nextWriteIndex] = createPendingChunk(response));\n+            (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n             nextWriteIndex < buffer.length;\n \n           )\n-            triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n         }\n       });\n       return iterator;\n@@ -4969,21 +5217,7 @@\n           case \"F\":\n             return (\n               (value = value.slice(2)),\n-              (value = getOutlinedModel(\n-                response,\n-                value,\n-                obj,\n-                key,\n-                createModel\n-              )),\n-              loadServerReference$1(\n-                response,\n-                value.id,\n-                value.bound,\n-                initializingChunk,\n-                obj,\n-                key\n-              )\n+              getOutlinedModel(response, value, obj, key, loadServerReference$1)\n             );\n           case \"T\":\n             if (\n@@ -5119,10 +5353,12 @@\n     function resolveField(response, key, value) {\n       response._formData.append(key, value);\n       var prefix = response._prefix;\n-      key.startsWith(prefix) &&\n-        ((response = response._chunks),\n-        (key = +key.slice(prefix.length)),\n-        (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));\n+      if (key.startsWith(prefix)) {\n+        var chunks = response._chunks;\n+        key = +key.slice(prefix.length);\n+        (chunks = chunks.get(key)) &&\n+          resolveModelChunk(response, chunks, value, key);\n+      }\n     }\n     function close(response) {\n       reportGlobalError(response, Error(\"Connection closed.\"));\n@@ -5889,33 +6125,32 @@\n       debugNoOutline = null,\n       emptyRoot = {},\n       decoderOptions = { stream: !0 },\n-      chunkCache = new Map();\n-    Chunk.prototype = Object.create(Promise.prototype);\n-    Chunk.prototype.then = function (resolve, reject) {\n+      chunkCache = new Map(),\n+      RESPONSE_SYMBOL = Symbol();\n+    ReactPromise.prototype = Object.create(Promise.prototype);\n+    ReactPromise.prototype.then = function (resolve, reject) {\n       switch (this.status) {\n         case \"resolved_model\":\n           initializeModelChunk(this);\n       }\n       switch (this.status) {\n         case \"fulfilled\":\n-          resolve(this.value);\n+          \"function\" === typeof resolve && resolve(this.value);\n           break;\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          resolve &&\n+          \"function\" === typeof resolve &&\n             (null === this.value && (this.value = []),\n             this.value.push(resolve));\n-          reject &&\n+          \"function\" === typeof reject &&\n             (null === this.reason && (this.reason = []),\n             this.reason.push(reject));\n           break;\n         default:\n-          reject(this.reason);\n+          \"function\" === typeof reject && reject(this.reason);\n       }\n     };\n-    var initializingChunk = null,\n-      initializingChunkBlockedModel = null;\n+    var initializingHandler = null;\n     exports.createClientModuleProxy = function (moduleId) {\n       moduleId = registerClientReferenceImpl({}, moduleId, !1);\n       return new Proxy(moduleId, proxyHandlers$1);\n@@ -6024,38 +6259,50 @@\n         pendingFiles = 0,\n         queuedFields = [];\n       busboyStream.on(\"field\", function (name, value) {\n-        0 < pendingFiles\n-          ? queuedFields.push(name, value)\n-          : resolveField(response, name, value);\n+        if (0 < pendingFiles) queuedFields.push(name, value);\n+        else\n+          try {\n+            resolveField(response, name, value);\n+          } catch (error) {\n+            busboyStream.destroy(error);\n+          }\n       });\n       busboyStream.on(\"file\", function (name, value, _ref2) {\n         var filename = _ref2.filename,\n           mimeType = _ref2.mimeType;\n         if (\"base64\" === _ref2.encoding.toLowerCase())\n-          throw Error(\n-            \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+          busboyStream.destroy(\n+            Error(\n+              \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+            )\n           );\n-        pendingFiles++;\n-        var JSCompiler_object_inline_chunks_273 = [];\n-        value.on(\"data\", function (chunk) {\n-          JSCompiler_object_inline_chunks_273.push(chunk);\n-        });\n-        value.on(\"end\", function () {\n-          var blob = new Blob(JSCompiler_object_inline_chunks_273, {\n-            type: mimeType\n+        else {\n+          pendingFiles++;\n+          var JSCompiler_object_inline_chunks_276 = [];\n+          value.on(\"data\", function (chunk) {\n+            JSCompiler_object_inline_chunks_276.push(chunk);\n           });\n-          response._formData.append(name, blob, filename);\n-          pendingFiles--;\n-          if (0 === pendingFiles) {\n-            for (blob = 0; blob < queuedFields.length; blob += 2)\n-              resolveField(\n-                response,\n-                queuedFields[blob],\n-                queuedFields[blob + 1]\n-              );\n-            queuedFields.length = 0;\n-          }\n-        });\n+          value.on(\"end\", function () {\n+            try {\n+              var blob = new Blob(JSCompiler_object_inline_chunks_276, {\n+                type: mimeType\n+              });\n+              response._formData.append(name, blob, filename);\n+              pendingFiles--;\n+              if (0 === pendingFiles) {\n+                for (blob = 0; blob < queuedFields.length; blob += 2)\n+                  resolveField(\n+                    response,\n+                    queuedFields[blob],\n+                    queuedFields[blob + 1]\n+                  );\n+                queuedFields.length = 0;\n+              }\n+            } catch (error) {\n+              busboyStream.destroy(error);\n+            }\n+          });\n+        }\n       });\n       busboyStream.on(\"finish\", function () {\n         close(response);"
        },
        {
            "sha": "c82cf94a5869123fae698e6bc7af88cb6097e2c8",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.node.production.js",
            "status": "modified",
            "additions": 469,
            "deletions": 227,
            "changes": 696,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -1002,8 +1002,8 @@ function serializeReadableStream(request, task, stream) {\n               : tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             reader.read().then(progress, error);\n-        } catch (x$8) {\n-          error(x$8);\n+        } catch (x$11) {\n+          error(x$11);\n         }\n   }\n   function error(reason) {\n@@ -1088,8 +1088,8 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n             tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             iterator.next().then(progress, error);\n-        } catch (x$9) {\n-          error(x$9);\n+        } catch (x$12) {\n+          error(x$12);\n         }\n   }\n   function error(reason) {\n@@ -2263,9 +2263,9 @@ function abort(request, reason) {\n         onAllReady();\n         flushCompletedChunks(request);\n       }\n-    } catch (error$26) {\n-      logRecoverableError(request, error$26, null),\n-        fatalError(request, error$26);\n+    } catch (error$29) {\n+      logRecoverableError(request, error$29, null),\n+        fatalError(request, error$29);\n     }\n }\n function resolveServerReference(bundlerConfig, id) {\n@@ -2335,59 +2335,97 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n-}\n-function Chunk(status, value, reason, response) {\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n+}\n+var RESPONSE_SYMBOL = Symbol();\n+function ReactPromise(status, value, reason) {\n   this.status = status;\n   this.value = value;\n   this.reason = reason;\n-  this._response = response;\n }\n-Chunk.prototype = Object.create(Promise.prototype);\n-Chunk.prototype.then = function (resolve, reject) {\n+ReactPromise.prototype = Object.create(Promise.prototype);\n+ReactPromise.prototype.then = function (resolve, reject) {\n   switch (this.status) {\n     case \"resolved_model\":\n       initializeModelChunk(this);\n   }\n   switch (this.status) {\n     case \"fulfilled\":\n-      resolve(this.value);\n+      \"function\" === typeof resolve && resolve(this.value);\n       break;\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      resolve &&\n+      \"function\" === typeof resolve &&\n         (null === this.value && (this.value = []), this.value.push(resolve));\n-      reject &&\n+      \"function\" === typeof reject &&\n         (null === this.reason && (this.reason = []), this.reason.push(reject));\n       break;\n     default:\n-      reject(this.reason);\n+      \"function\" === typeof reject && reject(this.reason);\n   }\n };\n-function createPendingChunk(response) {\n-  return new Chunk(\"pending\", null, null, response);\n+function wakeChunk(response, listeners, value) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(value)\n+      : fulfillReference(response, listener, value);\n+  }\n }\n-function wakeChunk(listeners, value) {\n-  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+function rejectChunk(response, listeners, error) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(error)\n+      : rejectReference(response, listener.handler, error);\n+  }\n }\n-function triggerErrorOnChunk(chunk, error) {\n+function resolveBlockedCycle(resolvedChunk, reference) {\n+  var referencedChunk = reference.handler.chunk;\n+  if (null === referencedChunk) return null;\n+  if (referencedChunk === resolvedChunk) return reference.handler;\n+  reference = referencedChunk.value;\n+  if (null !== reference)\n+    for (\n+      referencedChunk = 0;\n+      referencedChunk < reference.length;\n+      referencedChunk++\n+    ) {\n+      var listener = reference[referencedChunk];\n+      if (\n+        \"function\" !== typeof listener &&\n+        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+        null !== listener)\n+      )\n+        return listener;\n+    }\n+  return null;\n+}\n+function triggerErrorOnChunk(response, chunk, error) {\n   if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n     chunk.reason.error(error);\n   else {\n     var listeners = chunk.reason;\n     chunk.status = \"rejected\";\n     chunk.reason = error;\n-    null !== listeners && wakeChunk(listeners, error);\n+    null !== listeners && rejectChunk(response, listeners, error);\n   }\n }\n-function resolveModelChunk(chunk, value, id) {\n+function createResolvedModelChunk(response, value, id) {\n+  var $jscomp$compprop2 = {};\n+  return new ReactPromise(\n+    \"resolved_model\",\n+    value,\n+    (($jscomp$compprop2.id = id),\n+    ($jscomp$compprop2[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop2)\n+  );\n+}\n+function resolveModelChunk(response, chunk, value, id) {\n   if (\"pending\" !== chunk.status)\n     (chunk = chunk.reason),\n       \"C\" === value[0]\n@@ -2398,77 +2436,129 @@ function resolveModelChunk(chunk, value, id) {\n       rejectListeners = chunk.reason;\n     chunk.status = \"resolved_model\";\n     chunk.value = value;\n-    chunk.reason = id;\n+    value = {};\n+    chunk.reason =\n+      ((value.id = id), (value[RESPONSE_SYMBOL] = response), value);\n     if (null !== resolveListeners)\n-      switch ((initializeModelChunk(chunk), chunk.status)) {\n+      a: switch ((initializeModelChunk(chunk), chunk.status)) {\n         case \"fulfilled\":\n-          wakeChunk(resolveListeners, chunk.value);\n+          wakeChunk(response, resolveListeners, chunk.value);\n           break;\n-        case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n+          for (value = 0; value < resolveListeners.length; value++)\n+            if (((id = resolveListeners[value]), \"function\" !== typeof id)) {\n+              var cyclicHandler = resolveBlockedCycle(chunk, id);\n+              if (null !== cyclicHandler)\n+                switch (\n+                  (fulfillReference(response, id, cyclicHandler.value),\n+                  resolveListeners.splice(value, 1),\n+                  value--,\n+                  null !== rejectListeners &&\n+                    ((id = rejectListeners.indexOf(id)),\n+                    -1 !== id && rejectListeners.splice(id, 1)),\n+                  chunk.status)\n+                ) {\n+                  case \"fulfilled\":\n+                    wakeChunk(response, resolveListeners, chunk.value);\n+                    break a;\n+                  case \"rejected\":\n+                    null !== rejectListeners &&\n+                      rejectChunk(response, rejectListeners, chunk.reason);\n+                    break a;\n+                }\n+            }\n+        case \"pending\":\n           if (chunk.value)\n-            for (value = 0; value < resolveListeners.length; value++)\n-              chunk.value.push(resolveListeners[value]);\n+            for (response = 0; response < resolveListeners.length; response++)\n+              chunk.value.push(resolveListeners[response]);\n           else chunk.value = resolveListeners;\n           if (chunk.reason) {\n             if (rejectListeners)\n-              for (value = 0; value < rejectListeners.length; value++)\n-                chunk.reason.push(rejectListeners[value]);\n+              for (\n+                resolveListeners = 0;\n+                resolveListeners < rejectListeners.length;\n+                resolveListeners++\n+              )\n+                chunk.reason.push(rejectListeners[resolveListeners]);\n           } else chunk.reason = rejectListeners;\n           break;\n         case \"rejected\":\n-          rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+          rejectListeners && wakeChunk(response, rejectListeners, chunk.reason);\n       }\n   }\n }\n function createResolvedIteratorResultChunk(response, value, done) {\n-  return new Chunk(\n+  var $jscomp$compprop4 = {};\n+  return new ReactPromise(\n     \"resolved_model\",\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n-    -1,\n-    response\n+    (($jscomp$compprop4.id = -1),\n+    ($jscomp$compprop4[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop4)\n   );\n }\n-function resolveIteratorResultChunk(chunk, value, done) {\n+function resolveIteratorResultChunk(response, chunk, value, done) {\n   resolveModelChunk(\n+    response,\n     chunk,\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n     -1\n   );\n }\n-function loadServerReference$1(\n-  response,\n-  id,\n-  bound,\n-  parentChunk,\n-  parentObject,\n-  key\n-) {\n+function loadServerReference$1(response, metaData, parentObject, key) {\n+  var id = metaData.id;\n+  if (\"string\" !== typeof id) return null;\n   var serverReference = resolveServerReference(response._bundlerConfig, id);\n-  id = preloadModule(serverReference);\n-  if (bound)\n-    bound = Promise.all([bound, id]).then(function (_ref) {\n-      _ref = _ref[0];\n-      var fn = requireModule(serverReference);\n-      return fn.bind.apply(fn, [null].concat(_ref));\n-    });\n-  else if (id)\n-    bound = Promise.resolve(id).then(function () {\n-      return requireModule(serverReference);\n-    });\n+  id = metaData.bound;\n+  var promise = preloadModule(serverReference);\n+  if (promise)\n+    id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+  else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n   else return requireModule(serverReference);\n-  bound.then(\n-    createModelResolver(\n-      parentChunk,\n-      parentObject,\n-      key,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(parentChunk)\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n+  promise.then(\n+    function () {\n+      var resolvedValue = requireModule(serverReference);\n+      if (metaData.bound) {\n+        var promiseValue = metaData.bound.value;\n+        promiseValue = Array.isArray(promiseValue) ? promiseValue.slice(0) : [];\n+        promiseValue.unshift(null);\n+        resolvedValue = resolvedValue.bind.apply(resolvedValue, promiseValue);\n+      }\n+      parentObject[key] = resolvedValue;\n+      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((resolvedValue = handler.chunk),\n+        null !== resolvedValue &&\n+          \"blocked\" === resolvedValue.status &&\n+          ((promiseValue = resolvedValue.value),\n+          (resolvedValue.status = \"fulfilled\"),\n+          (resolvedValue.value = handler.value),\n+          null !== promiseValue &&\n+            wakeChunk(response, promiseValue, handler.value)));\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n@@ -2498,53 +2588,65 @@ function reviveModel(response, parentObj, parentKey, value, reference) {\n               ? reference + \":\" + i\n               : void 0),\n           (parentObj = reviveModel(response, value, i, value[i], parentObj)),\n-          void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+          void 0 !== parentObj || \"__proto__\" === i\n+            ? (value[i] = parentObj)\n+            : delete value[i]);\n   return value;\n }\n-var initializingChunk = null,\n-  initializingChunkBlockedModel = null;\n+var initializingHandler = null;\n function initializeModelChunk(chunk) {\n-  var prevChunk = initializingChunk,\n-    prevBlocked = initializingChunkBlockedModel;\n-  initializingChunk = chunk;\n-  initializingChunkBlockedModel = null;\n-  var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-    resolvedModel = chunk.value;\n-  chunk.status = \"cyclic\";\n+  var prevHandler = initializingHandler;\n+  initializingHandler = null;\n+  var _chunk$reason = chunk.reason,\n+    response = _chunk$reason[RESPONSE_SYMBOL];\n+  _chunk$reason = _chunk$reason.id;\n+  _chunk$reason = -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+  var resolvedModel = chunk.value;\n+  chunk.status = \"blocked\";\n   chunk.value = null;\n   chunk.reason = null;\n   try {\n     var rawModel = JSON.parse(resolvedModel),\n       value = reviveModel(\n-        chunk._response,\n+        response,\n         { \"\": rawModel },\n         \"\",\n         rawModel,\n-        rootReference\n-      );\n-    if (\n-      null !== initializingChunkBlockedModel &&\n-      0 < initializingChunkBlockedModel.deps\n-    )\n-      (initializingChunkBlockedModel.value = value), (chunk.status = \"blocked\");\n-    else {\n-      var resolveListeners = chunk.value;\n-      chunk.status = \"fulfilled\";\n-      chunk.value = value;\n-      null !== resolveListeners && wakeChunk(resolveListeners, value);\n+        _chunk$reason\n+      ),\n+      resolveListeners = chunk.value;\n+    if (null !== resolveListeners)\n+      for (\n+        chunk.value = null, chunk.reason = null, rawModel = 0;\n+        rawModel < resolveListeners.length;\n+        rawModel++\n+      ) {\n+        var listener = resolveListeners[rawModel];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n+    if (null !== initializingHandler) {\n+      if (initializingHandler.errored) throw initializingHandler.reason;\n+      if (0 < initializingHandler.deps) {\n+        initializingHandler.value = value;\n+        initializingHandler.chunk = chunk;\n+        return;\n+      }\n     }\n+    chunk.status = \"fulfilled\";\n+    chunk.value = value;\n   } catch (error) {\n     (chunk.status = \"rejected\"), (chunk.reason = error);\n   } finally {\n-    (initializingChunk = prevChunk),\n-      (initializingChunkBlockedModel = prevBlocked);\n+    initializingHandler = prevHandler;\n   }\n }\n function reportGlobalError(response, error) {\n   response._closed = !0;\n   response._closedReason = error;\n   response._chunks.forEach(function (chunk) {\n-    \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+    \"pending\" === chunk.status && triggerErrorOnChunk(response, chunk, error);\n   });\n }\n function getChunk(response, id) {\n@@ -2553,48 +2655,104 @@ function getChunk(response, id) {\n   chunk ||\n     ((chunk = response._formData.get(response._prefix + id)),\n     (chunk =\n-      null != chunk\n-        ? new Chunk(\"resolved_model\", chunk, id, response)\n+      \"string\" === typeof chunk\n+        ? createResolvedModelChunk(response, chunk, id)\n         : response._closed\n-          ? new Chunk(\"rejected\", null, response._closedReason, response)\n-          : createPendingChunk(response)),\n+          ? new ReactPromise(\"rejected\", null, response._closedReason)\n+          : new ReactPromise(\"pending\", null, null)),\n     chunks.set(id, chunk));\n   return chunk;\n }\n-function createModelResolver(\n-  chunk,\n+function fulfillReference(response, reference, value) {\n+  for (\n+    var handler = reference.handler,\n+      parentObject = reference.parentObject,\n+      key = reference.key,\n+      map = reference.map,\n+      path = reference.path,\n+      i = 1;\n+    i < path.length;\n+    i++\n+  ) {\n+    for (; value instanceof ReactPromise; ) {\n+      switch (value.status) {\n+        case \"resolved_model\":\n+          initializeModelChunk(value);\n+      }\n+      switch (value.status) {\n+        case \"fulfilled\":\n+          value = value.value;\n+          continue;\n+        case \"blocked\":\n+        case \"pending\":\n+          path.splice(0, i - 1);\n+          null === value.value\n+            ? (value.value = [reference])\n+            : value.value.push(reference);\n+          null === value.reason\n+            ? (value.reason = [reference])\n+            : value.reason.push(reference);\n+          return;\n+        default:\n+          rejectReference(response, reference.handler, value.reason);\n+          return;\n+      }\n+    }\n+    var name = path[i];\n+    \"object\" === typeof value &&\n+      hasOwnProperty.call(value, name) &&\n+      (value = value[name]);\n+  }\n+  reference = map(response, value, parentObject, key);\n+  parentObject[key] = reference;\n+  \"\" === key && null === handler.value && (handler.value = reference);\n+  handler.deps--;\n+  0 === handler.deps &&\n+    ((parentObject = handler.chunk),\n+    null !== parentObject &&\n+      \"blocked\" === parentObject.status &&\n+      ((key = parentObject.value),\n+      (parentObject.status = \"fulfilled\"),\n+      (parentObject.value = handler.value),\n+      (parentObject.reason = handler.reason),\n+      null !== key && wakeChunk(response, key, handler.value)));\n+}\n+function rejectReference(response, handler, error) {\n+  handler.errored ||\n+    ((handler.errored = !0),\n+    (handler.value = null),\n+    (handler.reason = error),\n+    (handler = handler.chunk),\n+    null !== handler &&\n+      \"blocked\" === handler.status &&\n+      triggerErrorOnChunk(response, handler, error));\n+}\n+function waitForReference(\n+  referencedChunk,\n   parentObject,\n   key,\n-  cyclic,\n   response,\n   map,\n   path\n ) {\n-  if (initializingChunkBlockedModel) {\n-    var blocked = initializingChunkBlockedModel;\n-    cyclic || blocked.deps++;\n-  } else\n-    blocked = initializingChunkBlockedModel = {\n-      deps: cyclic ? 0 : 1,\n-      value: null\n-    };\n-  return function (value) {\n-    for (var i = 1; i < path.length; i++) value = value[path[i]];\n-    parentObject[key] = map(response, value);\n-    \"\" === key && null === blocked.value && (blocked.value = parentObject[key]);\n-    blocked.deps--;\n-    0 === blocked.deps &&\n-      \"blocked\" === chunk.status &&\n-      ((value = chunk.value),\n-      (chunk.status = \"fulfilled\"),\n-      (chunk.value = blocked.value),\n-      null !== value && wakeChunk(value, blocked.value));\n-  };\n-}\n-function createModelReject(chunk) {\n-  return function (error) {\n-    return triggerErrorOnChunk(chunk, error);\n+  initializingHandler\n+    ? ((response = initializingHandler), response.deps++)\n+    : (response = initializingHandler =\n+        { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+  parentObject = {\n+    handler: response,\n+    parentObject: parentObject,\n+    key: key,\n+    map: map,\n+    path: path\n   };\n+  null === referencedChunk.value\n+    ? (referencedChunk.value = [parentObject])\n+    : referencedChunk.value.push(parentObject);\n+  null === referencedChunk.reason\n+    ? (referencedChunk.reason = [parentObject])\n+    : referencedChunk.reason.push(parentObject);\n+  return null;\n }\n function getOutlinedModel(response, reference, parentObject, key, map) {\n   reference = reference.split(\":\");\n@@ -2606,29 +2764,68 @@ function getOutlinedModel(response, reference, parentObject, key, map) {\n   }\n   switch (id.status) {\n     case \"fulfilled\":\n-      parentObject = id.value;\n-      for (key = 1; key < reference.length; key++)\n-        parentObject = parentObject[reference[key]];\n-      return map(response, parentObject);\n+      var value = id.value;\n+      for (id = 1; id < reference.length; id++) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              break;\n+            case \"blocked\":\n+            case \"pending\":\n+              return waitForReference(\n+                value,\n+                parentObject,\n+                key,\n+                response,\n+                map,\n+                reference.slice(id - 1)\n+              );\n+            default:\n+              return (\n+                initializingHandler\n+                  ? ((initializingHandler.errored = !0),\n+                    (initializingHandler.value = null),\n+                    (initializingHandler.reason = value.reason))\n+                  : (initializingHandler = {\n+                      chunk: null,\n+                      value: null,\n+                      reason: value.reason,\n+                      deps: 0,\n+                      errored: !0\n+                    }),\n+                null\n+              );\n+          }\n+        }\n+        var name = reference[id];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      return map(response, value, parentObject, key);\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      var parentChunk = initializingChunk;\n-      id.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          \"cyclic\" === id.status,\n-          response,\n-          map,\n-          reference\n-        ),\n-        createModelReject(parentChunk)\n-      );\n-      return null;\n+      return waitForReference(id, parentObject, key, response, map, reference);\n     default:\n-      throw id.reason;\n+      return (\n+        initializingHandler\n+          ? ((initializingHandler.errored = !0),\n+            (initializingHandler.value = null),\n+            (initializingHandler.reason = id.reason))\n+          : (initializingHandler = {\n+              chunk: null,\n+              value: null,\n+              reason: id.reason,\n+              deps: 0,\n+              errored: !0\n+            }),\n+        null\n+      );\n   }\n }\n function createMap(response, model) {\n@@ -2652,38 +2849,63 @@ function parseTypedArray(\n   parentKey\n ) {\n   reference = parseInt(reference.slice(2), 16);\n-  reference = response._formData.get(response._prefix + reference);\n-  reference =\n-    constructor === ArrayBuffer\n-      ? reference.arrayBuffer()\n-      : reference.arrayBuffer().then(function (buffer) {\n-          return new constructor(buffer);\n-        });\n-  bytesPerElement = initializingChunk;\n+  reference = response._formData\n+    .get(response._prefix + reference)\n+    .arrayBuffer();\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n   reference.then(\n-    createModelResolver(\n-      bytesPerElement,\n-      parentObject,\n-      parentKey,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(bytesPerElement)\n+    function (buffer) {\n+      buffer = constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+      parentObject[parentKey] = buffer;\n+      \"\" === parentKey && null === handler.value && (handler.value = buffer);\n+      handler.deps--;\n+      if (\n+        0 === handler.deps &&\n+        ((buffer = handler.chunk),\n+        null !== buffer && \"blocked\" === buffer.status)\n+      ) {\n+        var resolveListeners = buffer.value;\n+        buffer.status = \"fulfilled\";\n+        buffer.value = handler.value;\n+        null !== resolveListeners &&\n+          wakeChunk(response, resolveListeners, handler.value);\n+      }\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n function resolveStream(response, id, stream, controller) {\n   var chunks = response._chunks;\n-  stream = new Chunk(\"fulfilled\", stream, controller, response);\n+  stream = new ReactPromise(\"fulfilled\", stream, controller);\n   chunks.set(id, stream);\n   response = response._formData.getAll(response._prefix + id);\n   for (id = 0; id < response.length; id++)\n     (chunks = response[id]),\n-      \"C\" === chunks[0]\n-        ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n-        : controller.enqueueModel(chunks);\n+      \"string\" === typeof chunks &&\n+        (\"C\" === chunks[0]\n+          ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n+          : controller.enqueueModel(chunks));\n }\n function parseReadableStream(response, reference, type) {\n   reference = parseInt(reference.slice(2), 16);\n@@ -2698,7 +2920,7 @@ function parseReadableStream(response, reference, type) {\n   resolveStream(response, reference, type, {\n     enqueueModel: function (json) {\n       if (null === previousBlockedChunk) {\n-        var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+        var chunk = createResolvedModelChunk(response, json, -1);\n         initializeModelChunk(chunk);\n         \"fulfilled\" === chunk.status\n           ? controller.enqueue(chunk.value)\n@@ -2713,19 +2935,19 @@ function parseReadableStream(response, reference, type) {\n             (previousBlockedChunk = chunk));\n       } else {\n         chunk = previousBlockedChunk;\n-        var chunk$29 = createPendingChunk(response);\n-        chunk$29.then(\n+        var chunk$33 = new ReactPromise(\"pending\", null, null);\n+        chunk$33.then(\n           function (v) {\n             return controller.enqueue(v);\n           },\n           function (e) {\n             return controller.error(e);\n           }\n         );\n-        previousBlockedChunk = chunk$29;\n+        previousBlockedChunk = chunk$33;\n         chunk.then(function () {\n-          previousBlockedChunk === chunk$29 && (previousBlockedChunk = null);\n-          resolveModelChunk(chunk$29, json, -1);\n+          previousBlockedChunk === chunk$33 && (previousBlockedChunk = null);\n+          resolveModelChunk(response, chunk$33, json, -1);\n         });\n       }\n     },\n@@ -2765,9 +2987,9 @@ function parseAsyncIterable(response, reference, iterator) {\n   var buffer = [],\n     closed = !1,\n     nextWriteIndex = 0,\n-    $jscomp$compprop2 = {};\n-  $jscomp$compprop2 =\n-    (($jscomp$compprop2[ASYNC_ITERATOR] = function () {\n+    $jscomp$compprop5 = {};\n+  $jscomp$compprop5 =\n+    (($jscomp$compprop5[ASYNC_ITERATOR] = function () {\n       var nextReadIndex = 0;\n       return createIterator(function (arg) {\n         if (void 0 !== arg)\n@@ -2776,19 +2998,18 @@ function parseAsyncIterable(response, reference, iterator) {\n           );\n         if (nextReadIndex === buffer.length) {\n           if (closed)\n-            return new Chunk(\n+            return new ReactPromise(\n               \"fulfilled\",\n               { done: !0, value: void 0 },\n-              null,\n-              response\n+              null\n             );\n-          buffer[nextReadIndex] = createPendingChunk(response);\n+          buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n         }\n         return buffer[nextReadIndex++];\n       });\n     }),\n-    $jscomp$compprop2);\n-  iterator = iterator ? $jscomp$compprop2[ASYNC_ITERATOR]() : $jscomp$compprop2;\n+    $jscomp$compprop5);\n+  iterator = iterator ? $jscomp$compprop5[ASYNC_ITERATOR]() : $jscomp$compprop5;\n   resolveStream(response, reference, iterator, {\n     enqueueModel: function (value) {\n       nextWriteIndex === buffer.length\n@@ -2797,7 +3018,12 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !1\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !1\n+          );\n       nextWriteIndex++;\n     },\n     close: function (value) {\n@@ -2808,9 +3034,15 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !0\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !0\n+          );\n       for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n         resolveIteratorResultChunk(\n+          response,\n           buffer[nextWriteIndex++],\n           '\"$undefined\"',\n           !0\n@@ -2820,11 +3052,11 @@ function parseAsyncIterable(response, reference, iterator) {\n       closed = !0;\n       for (\n         nextWriteIndex === buffer.length &&\n-        (buffer[nextWriteIndex] = createPendingChunk(response));\n+        (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n         nextWriteIndex < buffer.length;\n \n       )\n-        triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+        triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n     }\n   });\n   return iterator;\n@@ -2839,15 +3071,7 @@ function parseModelString(response, obj, key, value, reference) {\n       case \"F\":\n         return (\n           (value = value.slice(2)),\n-          (value = getOutlinedModel(response, value, obj, key, createModel)),\n-          loadServerReference$1(\n-            response,\n-            value.id,\n-            value.bound,\n-            initializingChunk,\n-            obj,\n-            key\n-          )\n+          getOutlinedModel(response, value, obj, key, loadServerReference$1)\n         );\n       case \"T\":\n         if (void 0 === reference || void 0 === response._temporaryReferences)\n@@ -2962,10 +3186,12 @@ function createResponse(bundlerConfig, formFieldPrefix, temporaryReferences) {\n function resolveField(response, key, value) {\n   response._formData.append(key, value);\n   var prefix = response._prefix;\n-  key.startsWith(prefix) &&\n-    ((response = response._chunks),\n-    (key = +key.slice(prefix.length)),\n-    (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));\n+  if (key.startsWith(prefix)) {\n+    var chunks = response._chunks;\n+    key = +key.slice(prefix.length);\n+    (chunks = chunks.get(key)) &&\n+      resolveModelChunk(response, chunks, value, key);\n+  }\n }\n function close(response) {\n   reportGlobalError(response, Error(\"Connection closed.\"));\n@@ -3134,34 +3360,50 @@ exports.decodeReplyFromBusboy = function (busboyStream, webpackMap, options) {\n     pendingFiles = 0,\n     queuedFields = [];\n   busboyStream.on(\"field\", function (name, value) {\n-    0 < pendingFiles\n-      ? queuedFields.push(name, value)\n-      : resolveField(response, name, value);\n+    if (0 < pendingFiles) queuedFields.push(name, value);\n+    else\n+      try {\n+        resolveField(response, name, value);\n+      } catch (error) {\n+        busboyStream.destroy(error);\n+      }\n   });\n   busboyStream.on(\"file\", function (name, value, _ref2) {\n     var filename = _ref2.filename,\n       mimeType = _ref2.mimeType;\n     if (\"base64\" === _ref2.encoding.toLowerCase())\n-      throw Error(\n-        \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+      busboyStream.destroy(\n+        Error(\n+          \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+        )\n       );\n-    pendingFiles++;\n-    var JSCompiler_object_inline_chunks_277 = [];\n-    value.on(\"data\", function (chunk) {\n-      JSCompiler_object_inline_chunks_277.push(chunk);\n-    });\n-    value.on(\"end\", function () {\n-      var blob = new Blob(JSCompiler_object_inline_chunks_277, {\n-        type: mimeType\n+    else {\n+      pendingFiles++;\n+      var JSCompiler_object_inline_chunks_284 = [];\n+      value.on(\"data\", function (chunk) {\n+        JSCompiler_object_inline_chunks_284.push(chunk);\n       });\n-      response._formData.append(name, blob, filename);\n-      pendingFiles--;\n-      if (0 === pendingFiles) {\n-        for (blob = 0; blob < queuedFields.length; blob += 2)\n-          resolveField(response, queuedFields[blob], queuedFields[blob + 1]);\n-        queuedFields.length = 0;\n-      }\n-    });\n+      value.on(\"end\", function () {\n+        try {\n+          var blob = new Blob(JSCompiler_object_inline_chunks_284, {\n+            type: mimeType\n+          });\n+          response._formData.append(name, blob, filename);\n+          pendingFiles--;\n+          if (0 === pendingFiles) {\n+            for (blob = 0; blob < queuedFields.length; blob += 2)\n+              resolveField(\n+                response,\n+                queuedFields[blob],\n+                queuedFields[blob + 1]\n+              );\n+            queuedFields.length = 0;\n+          }\n+        } catch (error) {\n+          busboyStream.destroy(error);\n+        }\n+      });\n+    }\n   });\n   busboyStream.on(\"finish\", function () {\n     close(response);"
        },
        {
            "sha": "e690f6a14fdd00c142b4fa4f780047b95487f9a3",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.node.unbundled.development.js",
            "status": "modified",
            "additions": 473,
            "deletions": 225,
            "changes": 698,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -4433,35 +4433,64 @@\n       if (\"fulfilled\" === moduleExports.status)\n         moduleExports = moduleExports.value;\n       else throw moduleExports.reason;\n-      return \"*\" === metadata.name\n-        ? moduleExports\n-        : \"\" === metadata.name\n-          ? moduleExports.default\n-          : moduleExports[metadata.name];\n+      if (\"*\" === metadata.name) return moduleExports;\n+      if (\"\" === metadata.name) return moduleExports.default;\n+      if (hasOwnProperty.call(moduleExports, metadata.name))\n+        return moduleExports[metadata.name];\n     }\n-    function Chunk(status, value, reason, response) {\n+    function ReactPromise(status, value, reason) {\n       this.status = status;\n       this.value = value;\n       this.reason = reason;\n-      this._response = response;\n     }\n-    function createPendingChunk(response) {\n-      return new Chunk(\"pending\", null, null, response);\n+    function wakeChunk(response, listeners, value) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n+    }\n+    function rejectChunk(response, listeners, error) {\n+      for (var i = 0; i < listeners.length; i++) {\n+        var listener = listeners[i];\n+        \"function\" === typeof listener\n+          ? listener(error)\n+          : rejectReference(response, listener.handler, error);\n+      }\n     }\n-    function wakeChunk(listeners, value) {\n-      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+    function resolveBlockedCycle(resolvedChunk, reference) {\n+      var referencedChunk = reference.handler.chunk;\n+      if (null === referencedChunk) return null;\n+      if (referencedChunk === resolvedChunk) return reference.handler;\n+      reference = referencedChunk.value;\n+      if (null !== reference)\n+        for (\n+          referencedChunk = 0;\n+          referencedChunk < reference.length;\n+          referencedChunk++\n+        ) {\n+          var listener = reference[referencedChunk];\n+          if (\n+            \"function\" !== typeof listener &&\n+            ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+            null !== listener)\n+          )\n+            return listener;\n+        }\n+      return null;\n     }\n-    function triggerErrorOnChunk(chunk, error) {\n+    function triggerErrorOnChunk(response, chunk, error) {\n       if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n         chunk.reason.error(error);\n       else {\n         var listeners = chunk.reason;\n         chunk.status = \"rejected\";\n         chunk.reason = error;\n-        null !== listeners && wakeChunk(listeners, error);\n+        null !== listeners && rejectChunk(response, listeners, error);\n       }\n     }\n-    function resolveModelChunk(chunk, value, id) {\n+    function resolveModelChunk(response, chunk, value, id) {\n       if (\"pending\" !== chunk.status)\n         (chunk = chunk.reason),\n           \"C\" === value[0]\n@@ -4472,81 +4501,142 @@\n           rejectListeners = chunk.reason;\n         chunk.status = \"resolved_model\";\n         chunk.value = value;\n-        chunk.reason = id;\n+        chunk.reason = _defineProperty({ id: id }, RESPONSE_SYMBOL, response);\n         if (null !== resolveListeners)\n-          switch ((initializeModelChunk(chunk), chunk.status)) {\n+          a: switch ((initializeModelChunk(chunk), chunk.status)) {\n             case \"fulfilled\":\n-              wakeChunk(resolveListeners, chunk.value);\n+              wakeChunk(response, resolveListeners, chunk.value);\n               break;\n-            case \"pending\":\n             case \"blocked\":\n-            case \"cyclic\":\n+              for (value = 0; value < resolveListeners.length; value++)\n+                if (\n+                  ((id = resolveListeners[value]), \"function\" !== typeof id)\n+                ) {\n+                  var cyclicHandler = resolveBlockedCycle(chunk, id);\n+                  if (null !== cyclicHandler)\n+                    switch (\n+                      (fulfillReference(response, id, cyclicHandler.value),\n+                      resolveListeners.splice(value, 1),\n+                      value--,\n+                      null !== rejectListeners &&\n+                        ((id = rejectListeners.indexOf(id)),\n+                        -1 !== id && rejectListeners.splice(id, 1)),\n+                      chunk.status)\n+                    ) {\n+                      case \"fulfilled\":\n+                        wakeChunk(response, resolveListeners, chunk.value);\n+                        break a;\n+                      case \"rejected\":\n+                        null !== rejectListeners &&\n+                          rejectChunk(response, rejectListeners, chunk.reason);\n+                        break a;\n+                    }\n+                }\n+            case \"pending\":\n               if (chunk.value)\n-                for (value = 0; value < resolveListeners.length; value++)\n-                  chunk.value.push(resolveListeners[value]);\n+                for (\n+                  response = 0;\n+                  response < resolveListeners.length;\n+                  response++\n+                )\n+                  chunk.value.push(resolveListeners[response]);\n               else chunk.value = resolveListeners;\n               if (chunk.reason) {\n                 if (rejectListeners)\n-                  for (value = 0; value < rejectListeners.length; value++)\n-                    chunk.reason.push(rejectListeners[value]);\n+                  for (\n+                    resolveListeners = 0;\n+                    resolveListeners < rejectListeners.length;\n+                    resolveListeners++\n+                  )\n+                    chunk.reason.push(rejectListeners[resolveListeners]);\n               } else chunk.reason = rejectListeners;\n               break;\n             case \"rejected\":\n-              rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+              rejectListeners &&\n+                wakeChunk(response, rejectListeners, chunk.reason);\n           }\n       }\n     }\n     function createResolvedIteratorResultChunk(response, value, done) {\n-      return new Chunk(\n+      return new ReactPromise(\n         \"resolved_model\",\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n-        -1,\n-        response\n+        _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n       );\n     }\n-    function resolveIteratorResultChunk(chunk, value, done) {\n+    function resolveIteratorResultChunk(response, chunk, value, done) {\n       resolveModelChunk(\n+        response,\n         chunk,\n         (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') +\n           value +\n           \"}\",\n         -1\n       );\n     }\n-    function loadServerReference$1(\n-      response,\n-      id,\n-      bound,\n-      parentChunk,\n-      parentObject,\n-      key\n-    ) {\n+    function loadServerReference$1(response, metaData, parentObject, key) {\n+      var id = metaData.id;\n+      if (\"string\" !== typeof id) return null;\n       var serverReference = resolveServerReference(response._bundlerConfig, id);\n-      id = preloadModule(serverReference);\n-      if (bound)\n-        bound = Promise.all([bound, id]).then(function (_ref) {\n-          _ref = _ref[0];\n-          var fn = requireModule(serverReference);\n-          return fn.bind.apply(fn, [null].concat(_ref));\n-        });\n-      else if (id)\n-        bound = Promise.resolve(id).then(function () {\n-          return requireModule(serverReference);\n-        });\n+      id = metaData.bound;\n+      var promise = preloadModule(serverReference);\n+      if (promise)\n+        id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+      else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n       else return requireModule(serverReference);\n-      bound.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(parentChunk)\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n+      promise.then(\n+        function () {\n+          var resolvedValue = requireModule(serverReference);\n+          if (metaData.bound) {\n+            var promiseValue = metaData.bound.value;\n+            promiseValue = Array.isArray(promiseValue)\n+              ? promiseValue.slice(0)\n+              : [];\n+            promiseValue.unshift(null);\n+            resolvedValue = resolvedValue.bind.apply(\n+              resolvedValue,\n+              promiseValue\n+            );\n+          }\n+          parentObject[key] = resolvedValue;\n+          \"\" === key &&\n+            null === handler.value &&\n+            (handler.value = resolvedValue);\n+          handler.deps--;\n+          0 === handler.deps &&\n+            ((resolvedValue = handler.chunk),\n+            null !== resolvedValue &&\n+              \"blocked\" === resolvedValue.status &&\n+              ((promiseValue = resolvedValue.value),\n+              (resolvedValue.status = \"fulfilled\"),\n+              (resolvedValue.value = handler.value),\n+              null !== promiseValue &&\n+                wakeChunk(response, promiseValue, handler.value)));\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n@@ -4588,53 +4678,66 @@\n                 value[i],\n                 parentObj\n               )),\n-              void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+              void 0 !== parentObj || \"__proto__\" === i\n+                ? (value[i] = parentObj)\n+                : delete value[i]);\n       return value;\n     }\n     function initializeModelChunk(chunk) {\n-      var prevChunk = initializingChunk,\n-        prevBlocked = initializingChunkBlockedModel;\n-      initializingChunk = chunk;\n-      initializingChunkBlockedModel = null;\n-      var rootReference =\n-          -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-        resolvedModel = chunk.value;\n-      chunk.status = \"cyclic\";\n+      var prevHandler = initializingHandler;\n+      initializingHandler = null;\n+      var _chunk$reason = chunk.reason,\n+        response = _chunk$reason[RESPONSE_SYMBOL];\n+      _chunk$reason = _chunk$reason.id;\n+      _chunk$reason =\n+        -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+      var resolvedModel = chunk.value;\n+      chunk.status = \"blocked\";\n       chunk.value = null;\n       chunk.reason = null;\n       try {\n         var rawModel = JSON.parse(resolvedModel),\n           value = reviveModel(\n-            chunk._response,\n+            response,\n             { \"\": rawModel },\n             \"\",\n             rawModel,\n-            rootReference\n-          );\n-        if (\n-          null !== initializingChunkBlockedModel &&\n-          0 < initializingChunkBlockedModel.deps\n-        )\n-          (initializingChunkBlockedModel.value = value),\n-            (chunk.status = \"blocked\");\n-        else {\n-          var resolveListeners = chunk.value;\n-          chunk.status = \"fulfilled\";\n-          chunk.value = value;\n-          null !== resolveListeners && wakeChunk(resolveListeners, value);\n+            _chunk$reason\n+          ),\n+          resolveListeners = chunk.value;\n+        if (null !== resolveListeners)\n+          for (\n+            chunk.value = null, chunk.reason = null, rawModel = 0;\n+            rawModel < resolveListeners.length;\n+            rawModel++\n+          ) {\n+            var listener = resolveListeners[rawModel];\n+            \"function\" === typeof listener\n+              ? listener(value)\n+              : fulfillReference(response, listener, value);\n+          }\n+        if (null !== initializingHandler) {\n+          if (initializingHandler.errored) throw initializingHandler.reason;\n+          if (0 < initializingHandler.deps) {\n+            initializingHandler.value = value;\n+            initializingHandler.chunk = chunk;\n+            return;\n+          }\n         }\n+        chunk.status = \"fulfilled\";\n+        chunk.value = value;\n       } catch (error) {\n         (chunk.status = \"rejected\"), (chunk.reason = error);\n       } finally {\n-        (initializingChunk = prevChunk),\n-          (initializingChunkBlockedModel = prevBlocked);\n+        initializingHandler = prevHandler;\n       }\n     }\n     function reportGlobalError(response, error) {\n       response._closed = !0;\n       response._closedReason = error;\n       response._chunks.forEach(function (chunk) {\n-        \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+        \"pending\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n       });\n     }\n     function getChunk(response, id) {\n@@ -4643,50 +4746,108 @@\n       chunk ||\n         ((chunk = response._formData.get(response._prefix + id)),\n         (chunk =\n-          null != chunk\n-            ? new Chunk(\"resolved_model\", chunk, id, response)\n+          \"string\" === typeof chunk\n+            ? new ReactPromise(\n+                \"resolved_model\",\n+                chunk,\n+                _defineProperty({ id: id }, RESPONSE_SYMBOL, response)\n+              )\n             : response._closed\n-              ? new Chunk(\"rejected\", null, response._closedReason, response)\n-              : createPendingChunk(response)),\n+              ? new ReactPromise(\"rejected\", null, response._closedReason)\n+              : new ReactPromise(\"pending\", null, null)),\n         chunks.set(id, chunk));\n       return chunk;\n     }\n-    function createModelResolver(\n-      chunk,\n+    function fulfillReference(response, reference, value) {\n+      for (\n+        var handler = reference.handler,\n+          parentObject = reference.parentObject,\n+          key = reference.key,\n+          map = reference.map,\n+          path = reference.path,\n+          i = 1;\n+        i < path.length;\n+        i++\n+      ) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              continue;\n+            case \"blocked\":\n+            case \"pending\":\n+              path.splice(0, i - 1);\n+              null === value.value\n+                ? (value.value = [reference])\n+                : value.value.push(reference);\n+              null === value.reason\n+                ? (value.reason = [reference])\n+                : value.reason.push(reference);\n+              return;\n+            default:\n+              rejectReference(response, reference.handler, value.reason);\n+              return;\n+          }\n+        }\n+        var name = path[i];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      reference = map(response, value, parentObject, key);\n+      parentObject[key] = reference;\n+      \"\" === key && null === handler.value && (handler.value = reference);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((parentObject = handler.chunk),\n+        null !== parentObject &&\n+          \"blocked\" === parentObject.status &&\n+          ((key = parentObject.value),\n+          (parentObject.status = \"fulfilled\"),\n+          (parentObject.value = handler.value),\n+          (parentObject.reason = handler.reason),\n+          null !== key && wakeChunk(response, key, handler.value)));\n+    }\n+    function rejectReference(response, handler, error) {\n+      handler.errored ||\n+        ((handler.errored = !0),\n+        (handler.value = null),\n+        (handler.reason = error),\n+        (handler = handler.chunk),\n+        null !== handler &&\n+          \"blocked\" === handler.status &&\n+          triggerErrorOnChunk(response, handler, error));\n+    }\n+    function waitForReference(\n+      referencedChunk,\n       parentObject,\n       key,\n-      cyclic,\n       response,\n       map,\n       path\n     ) {\n-      if (initializingChunkBlockedModel) {\n-        var blocked = initializingChunkBlockedModel;\n-        cyclic || blocked.deps++;\n-      } else\n-        blocked = initializingChunkBlockedModel = {\n-          deps: cyclic ? 0 : 1,\n-          value: null\n-        };\n-      return function (value) {\n-        for (var i = 1; i < path.length; i++) value = value[path[i]];\n-        parentObject[key] = map(response, value);\n-        \"\" === key &&\n-          null === blocked.value &&\n-          (blocked.value = parentObject[key]);\n-        blocked.deps--;\n-        0 === blocked.deps &&\n-          \"blocked\" === chunk.status &&\n-          ((value = chunk.value),\n-          (chunk.status = \"fulfilled\"),\n-          (chunk.value = blocked.value),\n-          null !== value && wakeChunk(value, blocked.value));\n-      };\n-    }\n-    function createModelReject(chunk) {\n-      return function (error) {\n-        return triggerErrorOnChunk(chunk, error);\n+      initializingHandler\n+        ? ((response = initializingHandler), response.deps++)\n+        : (response = initializingHandler =\n+            { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+      parentObject = {\n+        handler: response,\n+        parentObject: parentObject,\n+        key: key,\n+        map: map,\n+        path: path\n       };\n+      null === referencedChunk.value\n+        ? (referencedChunk.value = [parentObject])\n+        : referencedChunk.value.push(parentObject);\n+      null === referencedChunk.reason\n+        ? (referencedChunk.reason = [parentObject])\n+        : referencedChunk.reason.push(parentObject);\n+      return null;\n     }\n     function getOutlinedModel(response, reference, parentObject, key, map) {\n       reference = reference.split(\":\");\n@@ -4698,29 +4859,75 @@\n       }\n       switch (id.status) {\n         case \"fulfilled\":\n-          parentObject = id.value;\n-          for (key = 1; key < reference.length; key++)\n-            parentObject = parentObject[reference[key]];\n-          return map(response, parentObject);\n+          var value = id.value;\n+          for (id = 1; id < reference.length; id++) {\n+            for (; value instanceof ReactPromise; ) {\n+              switch (value.status) {\n+                case \"resolved_model\":\n+                  initializeModelChunk(value);\n+              }\n+              switch (value.status) {\n+                case \"fulfilled\":\n+                  value = value.value;\n+                  break;\n+                case \"blocked\":\n+                case \"pending\":\n+                  return waitForReference(\n+                    value,\n+                    parentObject,\n+                    key,\n+                    response,\n+                    map,\n+                    reference.slice(id - 1)\n+                  );\n+                default:\n+                  return (\n+                    initializingHandler\n+                      ? ((initializingHandler.errored = !0),\n+                        (initializingHandler.value = null),\n+                        (initializingHandler.reason = value.reason))\n+                      : (initializingHandler = {\n+                          chunk: null,\n+                          value: null,\n+                          reason: value.reason,\n+                          deps: 0,\n+                          errored: !0\n+                        }),\n+                    null\n+                  );\n+              }\n+            }\n+            var name = reference[id];\n+            \"object\" === typeof value &&\n+              hasOwnProperty.call(value, name) &&\n+              (value = value[name]);\n+          }\n+          return map(response, value, parentObject, key);\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          var parentChunk = initializingChunk;\n-          id.then(\n-            createModelResolver(\n-              parentChunk,\n-              parentObject,\n-              key,\n-              \"cyclic\" === id.status,\n-              response,\n-              map,\n-              reference\n-            ),\n-            createModelReject(parentChunk)\n+          return waitForReference(\n+            id,\n+            parentObject,\n+            key,\n+            response,\n+            map,\n+            reference\n           );\n-          return null;\n         default:\n-          throw id.reason;\n+          return (\n+            initializingHandler\n+              ? ((initializingHandler.errored = !0),\n+                (initializingHandler.value = null),\n+                (initializingHandler.reason = id.reason))\n+              : (initializingHandler = {\n+                  chunk: null,\n+                  value: null,\n+                  reason: id.reason,\n+                  deps: 0,\n+                  errored: !0\n+                }),\n+            null\n+          );\n       }\n     }\n     function createMap(response, model) {\n@@ -4744,40 +4951,68 @@\n       parentKey\n     ) {\n       reference = parseInt(reference.slice(2), 16);\n-      reference = response._formData.get(response._prefix + reference);\n-      reference =\n-        constructor === ArrayBuffer\n-          ? reference.arrayBuffer()\n-          : reference.arrayBuffer().then(function (buffer) {\n-              return new constructor(buffer);\n-            });\n-      bytesPerElement = initializingChunk;\n+      reference = response._formData\n+        .get(response._prefix + reference)\n+        .arrayBuffer();\n+      if (initializingHandler) {\n+        var handler = initializingHandler;\n+        handler.deps++;\n+      } else\n+        handler = initializingHandler = {\n+          chunk: null,\n+          value: null,\n+          reason: null,\n+          deps: 1,\n+          errored: !1\n+        };\n       reference.then(\n-        createModelResolver(\n-          bytesPerElement,\n-          parentObject,\n-          parentKey,\n-          !1,\n-          response,\n-          createModel,\n-          []\n-        ),\n-        createModelReject(bytesPerElement)\n+        function (buffer) {\n+          buffer =\n+            constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+          parentObject[parentKey] = buffer;\n+          \"\" === parentKey &&\n+            null === handler.value &&\n+            (handler.value = buffer);\n+          handler.deps--;\n+          if (\n+            0 === handler.deps &&\n+            ((buffer = handler.chunk),\n+            null !== buffer && \"blocked\" === buffer.status)\n+          ) {\n+            var resolveListeners = buffer.value;\n+            buffer.status = \"fulfilled\";\n+            buffer.value = handler.value;\n+            null !== resolveListeners &&\n+              wakeChunk(response, resolveListeners, handler.value);\n+          }\n+        },\n+        function (error) {\n+          if (!handler.errored) {\n+            handler.errored = !0;\n+            handler.value = null;\n+            handler.reason = error;\n+            var chunk = handler.chunk;\n+            null !== chunk &&\n+              \"blocked\" === chunk.status &&\n+              triggerErrorOnChunk(response, chunk, error);\n+          }\n+        }\n       );\n       return null;\n     }\n     function resolveStream(response, id, stream, controller) {\n       var chunks = response._chunks;\n-      stream = new Chunk(\"fulfilled\", stream, controller, response);\n+      stream = new ReactPromise(\"fulfilled\", stream, controller);\n       chunks.set(id, stream);\n       response = response._formData.getAll(response._prefix + id);\n       for (id = 0; id < response.length; id++)\n         (chunks = response[id]),\n-          \"C\" === chunks[0]\n-            ? controller.close(\n-                \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n-              )\n-            : controller.enqueueModel(chunks);\n+          \"string\" === typeof chunks &&\n+            (\"C\" === chunks[0]\n+              ? controller.close(\n+                  \"C\" === chunks ? '\"$undefined\"' : chunks.slice(1)\n+                )\n+              : controller.enqueueModel(chunks));\n     }\n     function parseReadableStream(response, reference, type) {\n       reference = parseInt(reference.slice(2), 16);\n@@ -4792,7 +5027,11 @@\n       resolveStream(response, reference, type, {\n         enqueueModel: function (json) {\n           if (null === previousBlockedChunk) {\n-            var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+            var chunk = new ReactPromise(\n+              \"resolved_model\",\n+              json,\n+              _defineProperty({ id: -1 }, RESPONSE_SYMBOL, response)\n+            );\n             initializeModelChunk(chunk);\n             \"fulfilled\" === chunk.status\n               ? controller.enqueue(chunk.value)\n@@ -4807,7 +5046,7 @@\n                 (previousBlockedChunk = chunk));\n           } else {\n             chunk = previousBlockedChunk;\n-            var _chunk = createPendingChunk(response);\n+            var _chunk = new ReactPromise(\"pending\", null, null);\n             _chunk.then(\n               function (v) {\n                 return controller.enqueue(v);\n@@ -4819,7 +5058,7 @@\n             previousBlockedChunk = _chunk;\n             chunk.then(function () {\n               previousBlockedChunk === _chunk && (previousBlockedChunk = null);\n-              resolveModelChunk(_chunk, json, -1);\n+              resolveModelChunk(response, _chunk, json, -1);\n             });\n           }\n         },\n@@ -4868,13 +5107,12 @@\n               );\n             if (nextReadIndex === buffer.length) {\n               if (closed)\n-                return new Chunk(\n+                return new ReactPromise(\n                   \"fulfilled\",\n                   { done: !0, value: void 0 },\n-                  null,\n-                  response\n+                  null\n                 );\n-              buffer[nextReadIndex] = createPendingChunk(response);\n+              buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n             }\n             return buffer[nextReadIndex++];\n           });\n@@ -4888,7 +5126,12 @@\n                 value,\n                 !1\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !1\n+              );\n           nextWriteIndex++;\n         },\n         close: function (value) {\n@@ -4899,9 +5142,15 @@\n                 value,\n                 !0\n               ))\n-            : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+            : resolveIteratorResultChunk(\n+                response,\n+                buffer[nextWriteIndex],\n+                value,\n+                !0\n+              );\n           for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n             resolveIteratorResultChunk(\n+              response,\n               buffer[nextWriteIndex++],\n               '\"$undefined\"',\n               !0\n@@ -4911,11 +5160,11 @@\n           closed = !0;\n           for (\n             nextWriteIndex === buffer.length &&\n-            (buffer[nextWriteIndex] = createPendingChunk(response));\n+            (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n             nextWriteIndex < buffer.length;\n \n           )\n-            triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n         }\n       });\n       return iterator;\n@@ -4932,21 +5181,7 @@\n           case \"F\":\n             return (\n               (value = value.slice(2)),\n-              (value = getOutlinedModel(\n-                response,\n-                value,\n-                obj,\n-                key,\n-                createModel\n-              )),\n-              loadServerReference$1(\n-                response,\n-                value.id,\n-                value.bound,\n-                initializingChunk,\n-                obj,\n-                key\n-              )\n+              getOutlinedModel(response, value, obj, key, loadServerReference$1)\n             );\n           case \"T\":\n             if (\n@@ -5082,10 +5317,12 @@\n     function resolveField(response, key, value) {\n       response._formData.append(key, value);\n       var prefix = response._prefix;\n-      key.startsWith(prefix) &&\n-        ((response = response._chunks),\n-        (key = +key.slice(prefix.length)),\n-        (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));\n+      if (key.startsWith(prefix)) {\n+        var chunks = response._chunks;\n+        key = +key.slice(prefix.length);\n+        (chunks = chunks.get(key)) &&\n+          resolveModelChunk(response, chunks, value, key);\n+      }\n     }\n     function close(response) {\n       reportGlobalError(response, Error(\"Connection closed.\"));\n@@ -5852,33 +6089,32 @@\n       debugNoOutline = null,\n       emptyRoot = {},\n       decoderOptions = { stream: !0 },\n-      asyncModuleCache = new Map();\n-    Chunk.prototype = Object.create(Promise.prototype);\n-    Chunk.prototype.then = function (resolve, reject) {\n+      asyncModuleCache = new Map(),\n+      RESPONSE_SYMBOL = Symbol();\n+    ReactPromise.prototype = Object.create(Promise.prototype);\n+    ReactPromise.prototype.then = function (resolve, reject) {\n       switch (this.status) {\n         case \"resolved_model\":\n           initializeModelChunk(this);\n       }\n       switch (this.status) {\n         case \"fulfilled\":\n-          resolve(this.value);\n+          \"function\" === typeof resolve && resolve(this.value);\n           break;\n         case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n-          resolve &&\n+          \"function\" === typeof resolve &&\n             (null === this.value && (this.value = []),\n             this.value.push(resolve));\n-          reject &&\n+          \"function\" === typeof reject &&\n             (null === this.reason && (this.reason = []),\n             this.reason.push(reject));\n           break;\n         default:\n-          reject(this.reason);\n+          \"function\" === typeof reject && reject(this.reason);\n       }\n     };\n-    var initializingChunk = null,\n-      initializingChunkBlockedModel = null;\n+    var initializingHandler = null;\n     exports.createClientModuleProxy = function (moduleId) {\n       moduleId = registerClientReferenceImpl({}, moduleId, !1);\n       return new Proxy(moduleId, proxyHandlers$1);\n@@ -5987,38 +6223,50 @@\n         pendingFiles = 0,\n         queuedFields = [];\n       busboyStream.on(\"field\", function (name, value) {\n-        0 < pendingFiles\n-          ? queuedFields.push(name, value)\n-          : resolveField(response, name, value);\n+        if (0 < pendingFiles) queuedFields.push(name, value);\n+        else\n+          try {\n+            resolveField(response, name, value);\n+          } catch (error) {\n+            busboyStream.destroy(error);\n+          }\n       });\n       busboyStream.on(\"file\", function (name, value, _ref2) {\n         var filename = _ref2.filename,\n           mimeType = _ref2.mimeType;\n         if (\"base64\" === _ref2.encoding.toLowerCase())\n-          throw Error(\n-            \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+          busboyStream.destroy(\n+            Error(\n+              \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+            )\n           );\n-        pendingFiles++;\n-        var JSCompiler_object_inline_chunks_273 = [];\n-        value.on(\"data\", function (chunk) {\n-          JSCompiler_object_inline_chunks_273.push(chunk);\n-        });\n-        value.on(\"end\", function () {\n-          var blob = new Blob(JSCompiler_object_inline_chunks_273, {\n-            type: mimeType\n+        else {\n+          pendingFiles++;\n+          var JSCompiler_object_inline_chunks_276 = [];\n+          value.on(\"data\", function (chunk) {\n+            JSCompiler_object_inline_chunks_276.push(chunk);\n           });\n-          response._formData.append(name, blob, filename);\n-          pendingFiles--;\n-          if (0 === pendingFiles) {\n-            for (blob = 0; blob < queuedFields.length; blob += 2)\n-              resolveField(\n-                response,\n-                queuedFields[blob],\n-                queuedFields[blob + 1]\n-              );\n-            queuedFields.length = 0;\n-          }\n-        });\n+          value.on(\"end\", function () {\n+            try {\n+              var blob = new Blob(JSCompiler_object_inline_chunks_276, {\n+                type: mimeType\n+              });\n+              response._formData.append(name, blob, filename);\n+              pendingFiles--;\n+              if (0 === pendingFiles) {\n+                for (blob = 0; blob < queuedFields.length; blob += 2)\n+                  resolveField(\n+                    response,\n+                    queuedFields[blob],\n+                    queuedFields[blob + 1]\n+                  );\n+                queuedFields.length = 0;\n+              }\n+            } catch (error) {\n+              busboyStream.destroy(error);\n+            }\n+          });\n+        }\n       });\n       busboyStream.on(\"finish\", function () {\n         close(response);"
        },
        {
            "sha": "fa37f4663dff451daf05f2b81be3062a24f7848c",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.node.unbundled.production.js",
            "status": "modified",
            "additions": 467,
            "deletions": 224,
            "changes": 691,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -1002,8 +1002,8 @@ function serializeReadableStream(request, task, stream) {\n               : tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             reader.read().then(progress, error);\n-        } catch (x$8) {\n-          error(x$8);\n+        } catch (x$11) {\n+          error(x$11);\n         }\n   }\n   function error(reason) {\n@@ -1088,8 +1088,8 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n             tryStreamTask(request, streamTask),\n             enqueueFlush(request),\n             iterator.next().then(progress, error);\n-        } catch (x$9) {\n-          error(x$9);\n+        } catch (x$12) {\n+          error(x$12);\n         }\n   }\n   function error(reason) {\n@@ -2263,9 +2263,9 @@ function abort(request, reason) {\n         onAllReady();\n         flushCompletedChunks(request);\n       }\n-    } catch (error$26) {\n-      logRecoverableError(request, error$26, null),\n-        fatalError(request, error$26);\n+    } catch (error$29) {\n+      logRecoverableError(request, error$29, null),\n+        fatalError(request, error$29);\n     }\n }\n function resolveServerReference(bundlerConfig, id) {\n@@ -2303,57 +2303,96 @@ function requireModule(metadata) {\n   var moduleExports = asyncModuleCache.get(metadata.specifier);\n   if (\"fulfilled\" === moduleExports.status) moduleExports = moduleExports.value;\n   else throw moduleExports.reason;\n-  return \"*\" === metadata.name\n-    ? moduleExports\n-    : \"\" === metadata.name\n-      ? moduleExports.default\n-      : moduleExports[metadata.name];\n+  if (\"*\" === metadata.name) return moduleExports;\n+  if (\"\" === metadata.name) return moduleExports.default;\n+  if (hasOwnProperty.call(moduleExports, metadata.name))\n+    return moduleExports[metadata.name];\n }\n-function Chunk(status, value, reason, response) {\n+var RESPONSE_SYMBOL = Symbol();\n+function ReactPromise(status, value, reason) {\n   this.status = status;\n   this.value = value;\n   this.reason = reason;\n-  this._response = response;\n }\n-Chunk.prototype = Object.create(Promise.prototype);\n-Chunk.prototype.then = function (resolve, reject) {\n+ReactPromise.prototype = Object.create(Promise.prototype);\n+ReactPromise.prototype.then = function (resolve, reject) {\n   switch (this.status) {\n     case \"resolved_model\":\n       initializeModelChunk(this);\n   }\n   switch (this.status) {\n     case \"fulfilled\":\n-      resolve(this.value);\n+      \"function\" === typeof resolve && resolve(this.value);\n       break;\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      resolve &&\n+      \"function\" === typeof resolve &&\n         (null === this.value && (this.value = []), this.value.push(resolve));\n-      reject &&\n+      \"function\" === typeof reject &&\n         (null === this.reason && (this.reason = []), this.reason.push(reject));\n       break;\n     default:\n-      reject(this.reason);\n+      \"function\" === typeof reject && reject(this.reason);\n   }\n };\n-function createPendingChunk(response) {\n-  return new Chunk(\"pending\", null, null, response);\n+function wakeChunk(response, listeners, value) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(value)\n+      : fulfillReference(response, listener, value);\n+  }\n }\n-function wakeChunk(listeners, value) {\n-  for (var i = 0; i < listeners.length; i++) (0, listeners[i])(value);\n+function rejectChunk(response, listeners, error) {\n+  for (var i = 0; i < listeners.length; i++) {\n+    var listener = listeners[i];\n+    \"function\" === typeof listener\n+      ? listener(error)\n+      : rejectReference(response, listener.handler, error);\n+  }\n }\n-function triggerErrorOnChunk(chunk, error) {\n+function resolveBlockedCycle(resolvedChunk, reference) {\n+  var referencedChunk = reference.handler.chunk;\n+  if (null === referencedChunk) return null;\n+  if (referencedChunk === resolvedChunk) return reference.handler;\n+  reference = referencedChunk.value;\n+  if (null !== reference)\n+    for (\n+      referencedChunk = 0;\n+      referencedChunk < reference.length;\n+      referencedChunk++\n+    ) {\n+      var listener = reference[referencedChunk];\n+      if (\n+        \"function\" !== typeof listener &&\n+        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n+        null !== listener)\n+      )\n+        return listener;\n+    }\n+  return null;\n+}\n+function triggerErrorOnChunk(response, chunk, error) {\n   if (\"pending\" !== chunk.status && \"blocked\" !== chunk.status)\n     chunk.reason.error(error);\n   else {\n     var listeners = chunk.reason;\n     chunk.status = \"rejected\";\n     chunk.reason = error;\n-    null !== listeners && wakeChunk(listeners, error);\n+    null !== listeners && rejectChunk(response, listeners, error);\n   }\n }\n-function resolveModelChunk(chunk, value, id) {\n+function createResolvedModelChunk(response, value, id) {\n+  var $jscomp$compprop2 = {};\n+  return new ReactPromise(\n+    \"resolved_model\",\n+    value,\n+    (($jscomp$compprop2.id = id),\n+    ($jscomp$compprop2[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop2)\n+  );\n+}\n+function resolveModelChunk(response, chunk, value, id) {\n   if (\"pending\" !== chunk.status)\n     (chunk = chunk.reason),\n       \"C\" === value[0]\n@@ -2364,77 +2403,129 @@ function resolveModelChunk(chunk, value, id) {\n       rejectListeners = chunk.reason;\n     chunk.status = \"resolved_model\";\n     chunk.value = value;\n-    chunk.reason = id;\n+    value = {};\n+    chunk.reason =\n+      ((value.id = id), (value[RESPONSE_SYMBOL] = response), value);\n     if (null !== resolveListeners)\n-      switch ((initializeModelChunk(chunk), chunk.status)) {\n+      a: switch ((initializeModelChunk(chunk), chunk.status)) {\n         case \"fulfilled\":\n-          wakeChunk(resolveListeners, chunk.value);\n+          wakeChunk(response, resolveListeners, chunk.value);\n           break;\n-        case \"pending\":\n         case \"blocked\":\n-        case \"cyclic\":\n+          for (value = 0; value < resolveListeners.length; value++)\n+            if (((id = resolveListeners[value]), \"function\" !== typeof id)) {\n+              var cyclicHandler = resolveBlockedCycle(chunk, id);\n+              if (null !== cyclicHandler)\n+                switch (\n+                  (fulfillReference(response, id, cyclicHandler.value),\n+                  resolveListeners.splice(value, 1),\n+                  value--,\n+                  null !== rejectListeners &&\n+                    ((id = rejectListeners.indexOf(id)),\n+                    -1 !== id && rejectListeners.splice(id, 1)),\n+                  chunk.status)\n+                ) {\n+                  case \"fulfilled\":\n+                    wakeChunk(response, resolveListeners, chunk.value);\n+                    break a;\n+                  case \"rejected\":\n+                    null !== rejectListeners &&\n+                      rejectChunk(response, rejectListeners, chunk.reason);\n+                    break a;\n+                }\n+            }\n+        case \"pending\":\n           if (chunk.value)\n-            for (value = 0; value < resolveListeners.length; value++)\n-              chunk.value.push(resolveListeners[value]);\n+            for (response = 0; response < resolveListeners.length; response++)\n+              chunk.value.push(resolveListeners[response]);\n           else chunk.value = resolveListeners;\n           if (chunk.reason) {\n             if (rejectListeners)\n-              for (value = 0; value < rejectListeners.length; value++)\n-                chunk.reason.push(rejectListeners[value]);\n+              for (\n+                resolveListeners = 0;\n+                resolveListeners < rejectListeners.length;\n+                resolveListeners++\n+              )\n+                chunk.reason.push(rejectListeners[resolveListeners]);\n           } else chunk.reason = rejectListeners;\n           break;\n         case \"rejected\":\n-          rejectListeners && wakeChunk(rejectListeners, chunk.reason);\n+          rejectListeners && wakeChunk(response, rejectListeners, chunk.reason);\n       }\n   }\n }\n function createResolvedIteratorResultChunk(response, value, done) {\n-  return new Chunk(\n+  var $jscomp$compprop4 = {};\n+  return new ReactPromise(\n     \"resolved_model\",\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n-    -1,\n-    response\n+    (($jscomp$compprop4.id = -1),\n+    ($jscomp$compprop4[RESPONSE_SYMBOL] = response),\n+    $jscomp$compprop4)\n   );\n }\n-function resolveIteratorResultChunk(chunk, value, done) {\n+function resolveIteratorResultChunk(response, chunk, value, done) {\n   resolveModelChunk(\n+    response,\n     chunk,\n     (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n     -1\n   );\n }\n-function loadServerReference$1(\n-  response,\n-  id,\n-  bound,\n-  parentChunk,\n-  parentObject,\n-  key\n-) {\n+function loadServerReference$1(response, metaData, parentObject, key) {\n+  var id = metaData.id;\n+  if (\"string\" !== typeof id) return null;\n   var serverReference = resolveServerReference(response._bundlerConfig, id);\n-  id = preloadModule(serverReference);\n-  if (bound)\n-    bound = Promise.all([bound, id]).then(function (_ref) {\n-      _ref = _ref[0];\n-      var fn = requireModule(serverReference);\n-      return fn.bind.apply(fn, [null].concat(_ref));\n-    });\n-  else if (id)\n-    bound = Promise.resolve(id).then(function () {\n-      return requireModule(serverReference);\n-    });\n+  id = metaData.bound;\n+  var promise = preloadModule(serverReference);\n+  if (promise)\n+    id instanceof ReactPromise && (promise = Promise.all([promise, id]));\n+  else if (id instanceof ReactPromise) promise = Promise.resolve(id);\n   else return requireModule(serverReference);\n-  bound.then(\n-    createModelResolver(\n-      parentChunk,\n-      parentObject,\n-      key,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(parentChunk)\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n+  promise.then(\n+    function () {\n+      var resolvedValue = requireModule(serverReference);\n+      if (metaData.bound) {\n+        var promiseValue = metaData.bound.value;\n+        promiseValue = Array.isArray(promiseValue) ? promiseValue.slice(0) : [];\n+        promiseValue.unshift(null);\n+        resolvedValue = resolvedValue.bind.apply(resolvedValue, promiseValue);\n+      }\n+      parentObject[key] = resolvedValue;\n+      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n+      handler.deps--;\n+      0 === handler.deps &&\n+        ((resolvedValue = handler.chunk),\n+        null !== resolvedValue &&\n+          \"blocked\" === resolvedValue.status &&\n+          ((promiseValue = resolvedValue.value),\n+          (resolvedValue.status = \"fulfilled\"),\n+          (resolvedValue.value = handler.value),\n+          null !== promiseValue &&\n+            wakeChunk(response, promiseValue, handler.value)));\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n@@ -2464,53 +2555,65 @@ function reviveModel(response, parentObj, parentKey, value, reference) {\n               ? reference + \":\" + i\n               : void 0),\n           (parentObj = reviveModel(response, value, i, value[i], parentObj)),\n-          void 0 !== parentObj ? (value[i] = parentObj) : delete value[i]);\n+          void 0 !== parentObj || \"__proto__\" === i\n+            ? (value[i] = parentObj)\n+            : delete value[i]);\n   return value;\n }\n-var initializingChunk = null,\n-  initializingChunkBlockedModel = null;\n+var initializingHandler = null;\n function initializeModelChunk(chunk) {\n-  var prevChunk = initializingChunk,\n-    prevBlocked = initializingChunkBlockedModel;\n-  initializingChunk = chunk;\n-  initializingChunkBlockedModel = null;\n-  var rootReference = -1 === chunk.reason ? void 0 : chunk.reason.toString(16),\n-    resolvedModel = chunk.value;\n-  chunk.status = \"cyclic\";\n+  var prevHandler = initializingHandler;\n+  initializingHandler = null;\n+  var _chunk$reason = chunk.reason,\n+    response = _chunk$reason[RESPONSE_SYMBOL];\n+  _chunk$reason = _chunk$reason.id;\n+  _chunk$reason = -1 === _chunk$reason ? void 0 : _chunk$reason.toString(16);\n+  var resolvedModel = chunk.value;\n+  chunk.status = \"blocked\";\n   chunk.value = null;\n   chunk.reason = null;\n   try {\n     var rawModel = JSON.parse(resolvedModel),\n       value = reviveModel(\n-        chunk._response,\n+        response,\n         { \"\": rawModel },\n         \"\",\n         rawModel,\n-        rootReference\n-      );\n-    if (\n-      null !== initializingChunkBlockedModel &&\n-      0 < initializingChunkBlockedModel.deps\n-    )\n-      (initializingChunkBlockedModel.value = value), (chunk.status = \"blocked\");\n-    else {\n-      var resolveListeners = chunk.value;\n-      chunk.status = \"fulfilled\";\n-      chunk.value = value;\n-      null !== resolveListeners && wakeChunk(resolveListeners, value);\n+        _chunk$reason\n+      ),\n+      resolveListeners = chunk.value;\n+    if (null !== resolveListeners)\n+      for (\n+        chunk.value = null, chunk.reason = null, rawModel = 0;\n+        rawModel < resolveListeners.length;\n+        rawModel++\n+      ) {\n+        var listener = resolveListeners[rawModel];\n+        \"function\" === typeof listener\n+          ? listener(value)\n+          : fulfillReference(response, listener, value);\n+      }\n+    if (null !== initializingHandler) {\n+      if (initializingHandler.errored) throw initializingHandler.reason;\n+      if (0 < initializingHandler.deps) {\n+        initializingHandler.value = value;\n+        initializingHandler.chunk = chunk;\n+        return;\n+      }\n     }\n+    chunk.status = \"fulfilled\";\n+    chunk.value = value;\n   } catch (error) {\n     (chunk.status = \"rejected\"), (chunk.reason = error);\n   } finally {\n-    (initializingChunk = prevChunk),\n-      (initializingChunkBlockedModel = prevBlocked);\n+    initializingHandler = prevHandler;\n   }\n }\n function reportGlobalError(response, error) {\n   response._closed = !0;\n   response._closedReason = error;\n   response._chunks.forEach(function (chunk) {\n-    \"pending\" === chunk.status && triggerErrorOnChunk(chunk, error);\n+    \"pending\" === chunk.status && triggerErrorOnChunk(response, chunk, error);\n   });\n }\n function getChunk(response, id) {\n@@ -2519,48 +2622,104 @@ function getChunk(response, id) {\n   chunk ||\n     ((chunk = response._formData.get(response._prefix + id)),\n     (chunk =\n-      null != chunk\n-        ? new Chunk(\"resolved_model\", chunk, id, response)\n+      \"string\" === typeof chunk\n+        ? createResolvedModelChunk(response, chunk, id)\n         : response._closed\n-          ? new Chunk(\"rejected\", null, response._closedReason, response)\n-          : createPendingChunk(response)),\n+          ? new ReactPromise(\"rejected\", null, response._closedReason)\n+          : new ReactPromise(\"pending\", null, null)),\n     chunks.set(id, chunk));\n   return chunk;\n }\n-function createModelResolver(\n-  chunk,\n+function fulfillReference(response, reference, value) {\n+  for (\n+    var handler = reference.handler,\n+      parentObject = reference.parentObject,\n+      key = reference.key,\n+      map = reference.map,\n+      path = reference.path,\n+      i = 1;\n+    i < path.length;\n+    i++\n+  ) {\n+    for (; value instanceof ReactPromise; ) {\n+      switch (value.status) {\n+        case \"resolved_model\":\n+          initializeModelChunk(value);\n+      }\n+      switch (value.status) {\n+        case \"fulfilled\":\n+          value = value.value;\n+          continue;\n+        case \"blocked\":\n+        case \"pending\":\n+          path.splice(0, i - 1);\n+          null === value.value\n+            ? (value.value = [reference])\n+            : value.value.push(reference);\n+          null === value.reason\n+            ? (value.reason = [reference])\n+            : value.reason.push(reference);\n+          return;\n+        default:\n+          rejectReference(response, reference.handler, value.reason);\n+          return;\n+      }\n+    }\n+    var name = path[i];\n+    \"object\" === typeof value &&\n+      hasOwnProperty.call(value, name) &&\n+      (value = value[name]);\n+  }\n+  reference = map(response, value, parentObject, key);\n+  parentObject[key] = reference;\n+  \"\" === key && null === handler.value && (handler.value = reference);\n+  handler.deps--;\n+  0 === handler.deps &&\n+    ((parentObject = handler.chunk),\n+    null !== parentObject &&\n+      \"blocked\" === parentObject.status &&\n+      ((key = parentObject.value),\n+      (parentObject.status = \"fulfilled\"),\n+      (parentObject.value = handler.value),\n+      (parentObject.reason = handler.reason),\n+      null !== key && wakeChunk(response, key, handler.value)));\n+}\n+function rejectReference(response, handler, error) {\n+  handler.errored ||\n+    ((handler.errored = !0),\n+    (handler.value = null),\n+    (handler.reason = error),\n+    (handler = handler.chunk),\n+    null !== handler &&\n+      \"blocked\" === handler.status &&\n+      triggerErrorOnChunk(response, handler, error));\n+}\n+function waitForReference(\n+  referencedChunk,\n   parentObject,\n   key,\n-  cyclic,\n   response,\n   map,\n   path\n ) {\n-  if (initializingChunkBlockedModel) {\n-    var blocked = initializingChunkBlockedModel;\n-    cyclic || blocked.deps++;\n-  } else\n-    blocked = initializingChunkBlockedModel = {\n-      deps: cyclic ? 0 : 1,\n-      value: null\n-    };\n-  return function (value) {\n-    for (var i = 1; i < path.length; i++) value = value[path[i]];\n-    parentObject[key] = map(response, value);\n-    \"\" === key && null === blocked.value && (blocked.value = parentObject[key]);\n-    blocked.deps--;\n-    0 === blocked.deps &&\n-      \"blocked\" === chunk.status &&\n-      ((value = chunk.value),\n-      (chunk.status = \"fulfilled\"),\n-      (chunk.value = blocked.value),\n-      null !== value && wakeChunk(value, blocked.value));\n-  };\n-}\n-function createModelReject(chunk) {\n-  return function (error) {\n-    return triggerErrorOnChunk(chunk, error);\n+  initializingHandler\n+    ? ((response = initializingHandler), response.deps++)\n+    : (response = initializingHandler =\n+        { chunk: null, value: null, reason: null, deps: 1, errored: !1 });\n+  parentObject = {\n+    handler: response,\n+    parentObject: parentObject,\n+    key: key,\n+    map: map,\n+    path: path\n   };\n+  null === referencedChunk.value\n+    ? (referencedChunk.value = [parentObject])\n+    : referencedChunk.value.push(parentObject);\n+  null === referencedChunk.reason\n+    ? (referencedChunk.reason = [parentObject])\n+    : referencedChunk.reason.push(parentObject);\n+  return null;\n }\n function getOutlinedModel(response, reference, parentObject, key, map) {\n   reference = reference.split(\":\");\n@@ -2572,29 +2731,68 @@ function getOutlinedModel(response, reference, parentObject, key, map) {\n   }\n   switch (id.status) {\n     case \"fulfilled\":\n-      parentObject = id.value;\n-      for (key = 1; key < reference.length; key++)\n-        parentObject = parentObject[reference[key]];\n-      return map(response, parentObject);\n+      var value = id.value;\n+      for (id = 1; id < reference.length; id++) {\n+        for (; value instanceof ReactPromise; ) {\n+          switch (value.status) {\n+            case \"resolved_model\":\n+              initializeModelChunk(value);\n+          }\n+          switch (value.status) {\n+            case \"fulfilled\":\n+              value = value.value;\n+              break;\n+            case \"blocked\":\n+            case \"pending\":\n+              return waitForReference(\n+                value,\n+                parentObject,\n+                key,\n+                response,\n+                map,\n+                reference.slice(id - 1)\n+              );\n+            default:\n+              return (\n+                initializingHandler\n+                  ? ((initializingHandler.errored = !0),\n+                    (initializingHandler.value = null),\n+                    (initializingHandler.reason = value.reason))\n+                  : (initializingHandler = {\n+                      chunk: null,\n+                      value: null,\n+                      reason: value.reason,\n+                      deps: 0,\n+                      errored: !0\n+                    }),\n+                null\n+              );\n+          }\n+        }\n+        var name = reference[id];\n+        \"object\" === typeof value &&\n+          hasOwnProperty.call(value, name) &&\n+          (value = value[name]);\n+      }\n+      return map(response, value, parentObject, key);\n     case \"pending\":\n     case \"blocked\":\n-    case \"cyclic\":\n-      var parentChunk = initializingChunk;\n-      id.then(\n-        createModelResolver(\n-          parentChunk,\n-          parentObject,\n-          key,\n-          \"cyclic\" === id.status,\n-          response,\n-          map,\n-          reference\n-        ),\n-        createModelReject(parentChunk)\n-      );\n-      return null;\n+      return waitForReference(id, parentObject, key, response, map, reference);\n     default:\n-      throw id.reason;\n+      return (\n+        initializingHandler\n+          ? ((initializingHandler.errored = !0),\n+            (initializingHandler.value = null),\n+            (initializingHandler.reason = id.reason))\n+          : (initializingHandler = {\n+              chunk: null,\n+              value: null,\n+              reason: id.reason,\n+              deps: 0,\n+              errored: !0\n+            }),\n+        null\n+      );\n   }\n }\n function createMap(response, model) {\n@@ -2618,38 +2816,63 @@ function parseTypedArray(\n   parentKey\n ) {\n   reference = parseInt(reference.slice(2), 16);\n-  reference = response._formData.get(response._prefix + reference);\n-  reference =\n-    constructor === ArrayBuffer\n-      ? reference.arrayBuffer()\n-      : reference.arrayBuffer().then(function (buffer) {\n-          return new constructor(buffer);\n-        });\n-  bytesPerElement = initializingChunk;\n+  reference = response._formData\n+    .get(response._prefix + reference)\n+    .arrayBuffer();\n+  if (initializingHandler) {\n+    var handler = initializingHandler;\n+    handler.deps++;\n+  } else\n+    handler = initializingHandler = {\n+      chunk: null,\n+      value: null,\n+      reason: null,\n+      deps: 1,\n+      errored: !1\n+    };\n   reference.then(\n-    createModelResolver(\n-      bytesPerElement,\n-      parentObject,\n-      parentKey,\n-      !1,\n-      response,\n-      createModel,\n-      []\n-    ),\n-    createModelReject(bytesPerElement)\n+    function (buffer) {\n+      buffer = constructor === ArrayBuffer ? buffer : new constructor(buffer);\n+      parentObject[parentKey] = buffer;\n+      \"\" === parentKey && null === handler.value && (handler.value = buffer);\n+      handler.deps--;\n+      if (\n+        0 === handler.deps &&\n+        ((buffer = handler.chunk),\n+        null !== buffer && \"blocked\" === buffer.status)\n+      ) {\n+        var resolveListeners = buffer.value;\n+        buffer.status = \"fulfilled\";\n+        buffer.value = handler.value;\n+        null !== resolveListeners &&\n+          wakeChunk(response, resolveListeners, handler.value);\n+      }\n+    },\n+    function (error) {\n+      if (!handler.errored) {\n+        handler.errored = !0;\n+        handler.value = null;\n+        handler.reason = error;\n+        var chunk = handler.chunk;\n+        null !== chunk &&\n+          \"blocked\" === chunk.status &&\n+          triggerErrorOnChunk(response, chunk, error);\n+      }\n+    }\n   );\n   return null;\n }\n function resolveStream(response, id, stream, controller) {\n   var chunks = response._chunks;\n-  stream = new Chunk(\"fulfilled\", stream, controller, response);\n+  stream = new ReactPromise(\"fulfilled\", stream, controller);\n   chunks.set(id, stream);\n   response = response._formData.getAll(response._prefix + id);\n   for (id = 0; id < response.length; id++)\n     (chunks = response[id]),\n-      \"C\" === chunks[0]\n-        ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n-        : controller.enqueueModel(chunks);\n+      \"string\" === typeof chunks &&\n+        (\"C\" === chunks[0]\n+          ? controller.close(\"C\" === chunks ? '\"$undefined\"' : chunks.slice(1))\n+          : controller.enqueueModel(chunks));\n }\n function parseReadableStream(response, reference, type) {\n   reference = parseInt(reference.slice(2), 16);\n@@ -2664,7 +2887,7 @@ function parseReadableStream(response, reference, type) {\n   resolveStream(response, reference, type, {\n     enqueueModel: function (json) {\n       if (null === previousBlockedChunk) {\n-        var chunk = new Chunk(\"resolved_model\", json, -1, response);\n+        var chunk = createResolvedModelChunk(response, json, -1);\n         initializeModelChunk(chunk);\n         \"fulfilled\" === chunk.status\n           ? controller.enqueue(chunk.value)\n@@ -2679,19 +2902,19 @@ function parseReadableStream(response, reference, type) {\n             (previousBlockedChunk = chunk));\n       } else {\n         chunk = previousBlockedChunk;\n-        var chunk$29 = createPendingChunk(response);\n-        chunk$29.then(\n+        var chunk$33 = new ReactPromise(\"pending\", null, null);\n+        chunk$33.then(\n           function (v) {\n             return controller.enqueue(v);\n           },\n           function (e) {\n             return controller.error(e);\n           }\n         );\n-        previousBlockedChunk = chunk$29;\n+        previousBlockedChunk = chunk$33;\n         chunk.then(function () {\n-          previousBlockedChunk === chunk$29 && (previousBlockedChunk = null);\n-          resolveModelChunk(chunk$29, json, -1);\n+          previousBlockedChunk === chunk$33 && (previousBlockedChunk = null);\n+          resolveModelChunk(response, chunk$33, json, -1);\n         });\n       }\n     },\n@@ -2731,9 +2954,9 @@ function parseAsyncIterable(response, reference, iterator) {\n   var buffer = [],\n     closed = !1,\n     nextWriteIndex = 0,\n-    $jscomp$compprop2 = {};\n-  $jscomp$compprop2 =\n-    (($jscomp$compprop2[ASYNC_ITERATOR] = function () {\n+    $jscomp$compprop5 = {};\n+  $jscomp$compprop5 =\n+    (($jscomp$compprop5[ASYNC_ITERATOR] = function () {\n       var nextReadIndex = 0;\n       return createIterator(function (arg) {\n         if (void 0 !== arg)\n@@ -2742,19 +2965,18 @@ function parseAsyncIterable(response, reference, iterator) {\n           );\n         if (nextReadIndex === buffer.length) {\n           if (closed)\n-            return new Chunk(\n+            return new ReactPromise(\n               \"fulfilled\",\n               { done: !0, value: void 0 },\n-              null,\n-              response\n+              null\n             );\n-          buffer[nextReadIndex] = createPendingChunk(response);\n+          buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n         }\n         return buffer[nextReadIndex++];\n       });\n     }),\n-    $jscomp$compprop2);\n-  iterator = iterator ? $jscomp$compprop2[ASYNC_ITERATOR]() : $jscomp$compprop2;\n+    $jscomp$compprop5);\n+  iterator = iterator ? $jscomp$compprop5[ASYNC_ITERATOR]() : $jscomp$compprop5;\n   resolveStream(response, reference, iterator, {\n     enqueueModel: function (value) {\n       nextWriteIndex === buffer.length\n@@ -2763,7 +2985,12 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !1\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !1);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !1\n+          );\n       nextWriteIndex++;\n     },\n     close: function (value) {\n@@ -2774,9 +3001,15 @@ function parseAsyncIterable(response, reference, iterator) {\n             value,\n             !0\n           ))\n-        : resolveIteratorResultChunk(buffer[nextWriteIndex], value, !0);\n+        : resolveIteratorResultChunk(\n+            response,\n+            buffer[nextWriteIndex],\n+            value,\n+            !0\n+          );\n       for (nextWriteIndex++; nextWriteIndex < buffer.length; )\n         resolveIteratorResultChunk(\n+          response,\n           buffer[nextWriteIndex++],\n           '\"$undefined\"',\n           !0\n@@ -2786,11 +3019,11 @@ function parseAsyncIterable(response, reference, iterator) {\n       closed = !0;\n       for (\n         nextWriteIndex === buffer.length &&\n-        (buffer[nextWriteIndex] = createPendingChunk(response));\n+        (buffer[nextWriteIndex] = new ReactPromise(\"pending\", null, null));\n         nextWriteIndex < buffer.length;\n \n       )\n-        triggerErrorOnChunk(buffer[nextWriteIndex++], error);\n+        triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n     }\n   });\n   return iterator;\n@@ -2805,15 +3038,7 @@ function parseModelString(response, obj, key, value, reference) {\n       case \"F\":\n         return (\n           (value = value.slice(2)),\n-          (value = getOutlinedModel(response, value, obj, key, createModel)),\n-          loadServerReference$1(\n-            response,\n-            value.id,\n-            value.bound,\n-            initializingChunk,\n-            obj,\n-            key\n-          )\n+          getOutlinedModel(response, value, obj, key, loadServerReference$1)\n         );\n       case \"T\":\n         if (void 0 === reference || void 0 === response._temporaryReferences)\n@@ -2928,10 +3153,12 @@ function createResponse(bundlerConfig, formFieldPrefix, temporaryReferences) {\n function resolveField(response, key, value) {\n   response._formData.append(key, value);\n   var prefix = response._prefix;\n-  key.startsWith(prefix) &&\n-    ((response = response._chunks),\n-    (key = +key.slice(prefix.length)),\n-    (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));\n+  if (key.startsWith(prefix)) {\n+    var chunks = response._chunks;\n+    key = +key.slice(prefix.length);\n+    (chunks = chunks.get(key)) &&\n+      resolveModelChunk(response, chunks, value, key);\n+  }\n }\n function close(response) {\n   reportGlobalError(response, Error(\"Connection closed.\"));\n@@ -3100,34 +3327,50 @@ exports.decodeReplyFromBusboy = function (busboyStream, webpackMap, options) {\n     pendingFiles = 0,\n     queuedFields = [];\n   busboyStream.on(\"field\", function (name, value) {\n-    0 < pendingFiles\n-      ? queuedFields.push(name, value)\n-      : resolveField(response, name, value);\n+    if (0 < pendingFiles) queuedFields.push(name, value);\n+    else\n+      try {\n+        resolveField(response, name, value);\n+      } catch (error) {\n+        busboyStream.destroy(error);\n+      }\n   });\n   busboyStream.on(\"file\", function (name, value, _ref2) {\n     var filename = _ref2.filename,\n       mimeType = _ref2.mimeType;\n     if (\"base64\" === _ref2.encoding.toLowerCase())\n-      throw Error(\n-        \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+      busboyStream.destroy(\n+        Error(\n+          \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n+        )\n       );\n-    pendingFiles++;\n-    var JSCompiler_object_inline_chunks_277 = [];\n-    value.on(\"data\", function (chunk) {\n-      JSCompiler_object_inline_chunks_277.push(chunk);\n-    });\n-    value.on(\"end\", function () {\n-      var blob = new Blob(JSCompiler_object_inline_chunks_277, {\n-        type: mimeType\n+    else {\n+      pendingFiles++;\n+      var JSCompiler_object_inline_chunks_284 = [];\n+      value.on(\"data\", function (chunk) {\n+        JSCompiler_object_inline_chunks_284.push(chunk);\n       });\n-      response._formData.append(name, blob, filename);\n-      pendingFiles--;\n-      if (0 === pendingFiles) {\n-        for (blob = 0; blob < queuedFields.length; blob += 2)\n-          resolveField(response, queuedFields[blob], queuedFields[blob + 1]);\n-        queuedFields.length = 0;\n-      }\n-    });\n+      value.on(\"end\", function () {\n+        try {\n+          var blob = new Blob(JSCompiler_object_inline_chunks_284, {\n+            type: mimeType\n+          });\n+          response._formData.append(name, blob, filename);\n+          pendingFiles--;\n+          if (0 === pendingFiles) {\n+            for (blob = 0; blob < queuedFields.length; blob += 2)\n+              resolveField(\n+                response,\n+                queuedFields[blob],\n+                queuedFields[blob + 1]\n+              );\n+            queuedFields.length = 0;\n+          }\n+        } catch (error) {\n+          busboyStream.destroy(error);\n+        }\n+      });\n+    }\n   });\n   busboyStream.on(\"finish\", function () {\n     close(response);"
        },
        {
            "sha": "db60fdcbbcb950a862a9b5ef803ddd21a40827ed",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fpackage.json?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -64,8 +64,8 @@\n     \"webpack-sources\": \"^3.2.0\"\n   },\n   \"peerDependencies\": {\n-    \"react\": \"0.0.0-experimental-fd524fe0-20251121\",\n-    \"react-dom\": \"0.0.0-experimental-fd524fe0-20251121\",\n+    \"react\": \"0.0.0-experimental-7dc903cd-20251203\",\n+    \"react-dom\": \"0.0.0-experimental-7dc903cd-20251203\",\n     \"webpack\": \"^5.59.0\"\n   }\n }\n\\ No newline at end of file"
        },
        {
            "sha": "f538671e429382c170d5eceb9af08670ac83ac04",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js",
            "status": "modified",
            "additions": 8,
            "deletions": 10,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.browser.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -102,13 +102,11 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function loadChunk(chunkId, filename) {\n       chunkMap.set(chunkId, filename);\n@@ -4768,6 +4766,7 @@\n       ReactDOM = require(\"react-dom\"),\n       decoderOptions = { stream: !0 },\n       bind = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       chunkCache = new Map(),\n       chunkMap = new Map(),\n       webpackGetChunkFilename = __webpack_require__.u;\n@@ -4807,7 +4806,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&\n@@ -4984,10 +4982,10 @@\n       return hook.checkDCE ? !0 : !1;\n     })({\n       bundleType: 1,\n-      version: \"19.3.0-canary-fd524fe0-20251121\",\n+      version: \"19.3.0-canary-7dc903cd-20251203\",\n       rendererPackageName: \"react-server-dom-webpack\",\n       currentDispatcherRef: ReactSharedInternals,\n-      reconcilerVersion: \"19.3.0-canary-fd524fe0-20251121\",\n+      reconcilerVersion: \"19.3.0-canary-7dc903cd-20251203\",\n       getCurrentComponentInfo: function () {\n         return currentOwnerInDEV;\n       }"
        },
        {
            "sha": "227adcd588dc0efe4dab39a991331bc1a7addaa9",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.production.js",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.browser.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -10,7 +10,8 @@\n \n \"use strict\";\n var ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   if (bundlerConfig) {\n     var moduleExports = bundlerConfig[metadata[0]];\n@@ -100,13 +101,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n var chunkMap = new Map(),\n   webpackGetChunkFilename = __webpack_require__.u;"
        },
        {
            "sha": "36797863b2275e206fddc17f6d1496f4bf26bc7a",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.edge.development.js",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.edge.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -102,13 +102,11 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function prepareDestinationWithChunks(\n       moduleLoading,\n@@ -4801,6 +4799,7 @@\n       React = require(\"react\"),\n       decoderOptions = { stream: !0 },\n       bind$1 = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       chunkCache = new Map(),\n       ReactDOMSharedInternals =\n         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n@@ -4834,7 +4833,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&"
        },
        {
            "sha": "34cdddeccf10fff9d5450a946b32056b6a48def5",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.edge.production.js",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.edge.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -10,7 +10,8 @@\n \n \"use strict\";\n var ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   if (bundlerConfig) {\n     var moduleExports = bundlerConfig[metadata[0]];\n@@ -99,13 +100,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n function prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n   if (null !== moduleLoading)"
        },
        {
            "sha": "e63f6d2cf778d2c4aa880e8d1f7ee2b8bed4d6cd",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.development.js",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.node.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -102,13 +102,11 @@\n         if (\"fulfilled\" === moduleExports.status)\n           moduleExports = moduleExports.value;\n         else throw moduleExports.reason;\n-      return \"*\" === metadata[2]\n-        ? moduleExports\n-        : \"\" === metadata[2]\n-          ? moduleExports.__esModule\n-            ? moduleExports.default\n-            : moduleExports\n-          : moduleExports[metadata[2]];\n+      if (\"*\" === metadata[2]) return moduleExports;\n+      if (\"\" === metadata[2])\n+        return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+      if (hasOwnProperty.call(moduleExports, metadata[2]))\n+        return moduleExports[metadata[2]];\n     }\n     function prepareDestinationWithChunks(\n       moduleLoading,\n@@ -4906,6 +4904,7 @@\n       React = require(\"react\"),\n       decoderOptions = { stream: !0 },\n       bind$1 = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       chunkCache = new Map(),\n       ReactDOMSharedInternals =\n         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n@@ -4939,7 +4938,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&"
        },
        {
            "sha": "487fd4ba84215e28a8f5882c8325b03ed19df3be",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.production.js",
            "status": "modified",
            "additions": 7,
            "deletions": 8,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.node.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -11,7 +11,8 @@\n \"use strict\";\n var util = require(\"util\"),\n   ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   if (bundlerConfig) {\n     var moduleExports = bundlerConfig[metadata[0]];\n@@ -100,13 +101,11 @@ function requireModule(metadata) {\n     if (\"fulfilled\" === moduleExports.status)\n       moduleExports = moduleExports.value;\n     else throw moduleExports.reason;\n-  return \"*\" === metadata[2]\n-    ? moduleExports\n-    : \"\" === metadata[2]\n-      ? moduleExports.__esModule\n-        ? moduleExports.default\n-        : moduleExports\n-      : moduleExports[metadata[2]];\n+  if (\"*\" === metadata[2]) return moduleExports;\n+  if (\"\" === metadata[2])\n+    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n+  if (hasOwnProperty.call(moduleExports, metadata[2]))\n+    return moduleExports[metadata[2]];\n }\n function prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n   if (null !== moduleLoading)"
        },
        {
            "sha": "5bc0cbb652f58fda8a1b93bc576fc0dceac0590c",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.unbundled.development.js",
            "status": "modified",
            "additions": 5,
            "deletions": 6,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.node.unbundled.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.node.unbundled.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.node.unbundled.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -66,11 +66,10 @@\n       if (\"fulfilled\" === moduleExports.status)\n         moduleExports = moduleExports.value;\n       else throw moduleExports.reason;\n-      return \"*\" === metadata.name\n-        ? moduleExports\n-        : \"\" === metadata.name\n-          ? moduleExports.default\n-          : moduleExports[metadata.name];\n+      if (\"*\" === metadata.name) return moduleExports;\n+      if (\"\" === metadata.name) return moduleExports.default;\n+      if (hasOwnProperty.call(moduleExports, metadata.name))\n+        return moduleExports[metadata.name];\n     }\n     function prepareDestinationWithChunks(\n       moduleLoading,\n@@ -4866,6 +4865,7 @@\n       React = require(\"react\"),\n       decoderOptions = { stream: !0 },\n       bind$1 = Function.prototype.bind,\n+      hasOwnProperty = Object.prototype.hasOwnProperty,\n       asyncModuleCache = new Map(),\n       ReactDOMSharedInternals =\n         ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n@@ -4899,7 +4899,6 @@\n       v8FrameRegExp =\n         /^ {3} at (?:(.+) \\((.+):(\\d+):(\\d+)\\)|(?:async )?(.+):(\\d+):(\\d+))$/,\n       jscSpiderMonkeyFrameRegExp = /(?:(.*)@)?(.*):(\\d+):(\\d+)/,\n-      hasOwnProperty = Object.prototype.hasOwnProperty,\n       REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n       supportsUserTiming =\n         \"undefined\" !== typeof console &&"
        },
        {
            "sha": "323f2b986f2516ea5bc8b716c6ae3de7f1e469d8",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.node.unbundled.production.js",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.node.unbundled.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.node.unbundled.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.node.unbundled.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2",
            "patch": "@@ -11,7 +11,8 @@\n \"use strict\";\n var util = require(\"util\"),\n   ReactDOM = require(\"react-dom\"),\n-  decoderOptions = { stream: !0 };\n+  decoderOptions = { stream: !0 },\n+  hasOwnProperty = Object.prototype.hasOwnProperty;\n function resolveClientReference(bundlerConfig, metadata) {\n   var moduleExports = bundlerConfig[metadata[0]];\n   if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))\n@@ -67,11 +68,10 @@ function requireModule(metadata) {\n   var moduleExports = asyncModuleCache.get(metadata.specifier);\n   if (\"fulfilled\" === moduleExports.status) moduleExports = moduleExports.value;\n   else throw moduleExports.reason;\n-  return \"*\" === metadata.name\n-    ? moduleExports\n-    : \"\" === metadata.name\n-      ? moduleExports.default\n-      : moduleExports[metadata.name];\n+  if (\"*\" === metadata.name) return moduleExports;\n+  if (\"\" === metadata.name) return moduleExports.default;\n+  if (hasOwnProperty.call(moduleExports, metadata.name))\n+    return moduleExports[metadata.name];\n }\n function prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n   if (null !== moduleLoading)"
        },
        {
            "sha": "f790b18fb280d984bfad49230025d6845ec00788",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.browser.development.js",
            "status": "modified",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.browser.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "d797bede1e3e867756edb3c1167d38e8a739b996",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.browser.production.js",
            "status": "modified",
            "additions": 425,
            "deletions": 201,
            "changes": 626,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.browser.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "e55a33b4990ee77692fc9ff770d66d424b9e2987",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js",
            "status": "modified",
            "additions": 438,
            "deletions": 204,
            "changes": 642,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.edge.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "177f54aa2e6d068ba7e9e0d922b08ca434a60349",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.production.js",
            "status": "modified",
            "additions": 428,
            "deletions": 203,
            "changes": 631,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.edge.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "34ed9a8ae26ced8d200c9791b3dc0561be8a2f43",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.development.js",
            "status": "modified",
            "additions": 475,
            "deletions": 228,
            "changes": 703,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "fc6e94af112e20a2e012b45758b531d28079b28e",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.production.js",
            "status": "modified",
            "additions": 469,
            "deletions": 227,
            "changes": 696,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "905e40ac0749bab9ecd7caed8d8a2b3ad204ea92",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.development.js",
            "status": "modified",
            "additions": 473,
            "deletions": 225,
            "changes": 698,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "f8ba3ad2a7169dec36b6ef55353da6951998cb27",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.production.js",
            "status": "modified",
            "additions": 467,
            "deletions": 224,
            "changes": 691,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "b056481ab70bdbbe06922f512798d5c890a928be",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fpackage.json?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "a02eb64a4c65674d74613d4dcb10c16ca013f496",
            "filename": "packages/next/src/compiled/react/cjs/react.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "f3f98b4a3d96d8f2488be336e9687e88df3aeb72",
            "filename": "packages/next/src/compiled/react/cjs/react.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "8f6015398b673caba028f81dce19a927f9fe7611",
            "filename": "packages/next/src/compiled/react/cjs/react.react-server.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.react-server.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.react-server.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.react-server.development.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "1538563c17cd553e95c6c2326bf6c219a56af882",
            "filename": "packages/next/src/compiled/react/cjs/react.react-server.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.react-server.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.react-server.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.react-server.production.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "a592ee2c64425a4945ac527aa927bf9eef17eee9",
            "filename": "packages/next/src/compiled/unistore/unistore.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Funistore%2Funistore.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/packages%2Fnext%2Fsrc%2Fcompiled%2Funistore%2Funistore.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Funistore%2Funistore.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "40190cf0e0affc53b04beb96125f581635e2b183",
            "filename": "pnpm-lock.yaml",
            "status": "modified",
            "additions": 785,
            "deletions": 750,
            "changes": 1535,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/pnpm-lock.yaml",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/pnpm-lock.yaml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/pnpm-lock.yaml?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "15d6c2fb6fa6116a319426ee9a868e28ebb62a7b",
            "filename": "run-tests.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/run-tests.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/run-tests.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/run-tests.js?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "237350135e76fdda285d1a0af874a4c250cc8692",
            "filename": "test/.stats-app/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/test%2F.stats-app%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/test%2F.stats-app%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2F.stats-app%2Fpackage.json?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "fb4c9a08e00503fd5305e1c4c93908d54d138833",
            "filename": "test/e2e/next-test/first-time-setup-js/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/test%2Fe2e%2Fnext-test%2Ffirst-time-setup-js%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/test%2Fe2e%2Fnext-test%2Ffirst-time-setup-js%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fnext-test%2Ffirst-time-setup-js%2Fpackage.json?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "47f747d0f1066ea92e01c23c247d74698552acbf",
            "filename": "test/e2e/next-test/first-time-setup-ts/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/test%2Fe2e%2Fnext-test%2Ffirst-time-setup-ts%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/test%2Fe2e%2Fnext-test%2Ffirst-time-setup-ts%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fnext-test%2Ffirst-time-setup-ts%2Fpackage.json?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        },
        {
            "sha": "e85229180ecad062ffe0683851fb30cdd6c8fa2e",
            "filename": "test/lib/next-modes/base.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6ef90ef49fd32171150b6f81d14708aa54cd07b2/test%2Flib%2Fnext-modes%2Fbase.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6ef90ef49fd32171150b6f81d14708aa54cd07b2/test%2Flib%2Fnext-modes%2Fbase.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Flib%2Fnext-modes%2Fbase.ts?ref=6ef90ef49fd32171150b6f81d14708aa54cd07b2"
        }
    ],
    "stats": {
        "total": 20749,
        "additions": 13674,
        "deletions": 7075
    }
}