{
    "author": "eps1lon",
    "message": "Use correct JSX runtime for library-owned JSX in React Server (#84869)",
    "sha": "718141176db250839ae2f493d8cac7637f22290c",
    "files": [
        {
            "sha": "61f1ad529dcf03bbf22e3f426c671ea1cd54f384",
            "filename": "eslint.config.mjs",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/eslint.config.mjs",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/eslint.config.mjs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/eslint.config.mjs?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -398,6 +398,20 @@ export default defineConfig([\n       'jsdoc/no-undefined-types': 'error',\n     },\n   },\n+  {\n+    files: [\n+      'packages/next/src/server/**/*.js',\n+      'packages/next/src/server/**/*.jsx',\n+      'packages/next/src/server/**/*.ts',\n+      'packages/next/src/server/**/*.tsx',\n+    ],\n+    plugins: {\n+      '@next/internal': nextEslintPluginInternal,\n+    },\n+    rules: {\n+      '@next/internal/no-ambiguous-jsx': 'error',\n+    },\n+  },\n   {\n     files: ['examples/**/*'],\n     linterOptions: {"
        },
        {
            "sha": "ce8a318a381426641237f8769411d8048768ab50",
            "filename": "packages/eslint-plugin-internal/src/eslint-no-ambiguous-jsx.js",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Feslint-plugin-internal%2Fsrc%2Feslint-no-ambiguous-jsx.js",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Feslint-plugin-internal%2Fsrc%2Feslint-no-ambiguous-jsx.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Feslint-plugin-internal%2Fsrc%2Feslint-no-ambiguous-jsx.js?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -0,0 +1,34 @@\n+/**\n+ * @type {import('eslint').Rule.RuleModule}\n+ */\n+const plugin = {\n+  name: 'no-ambiguous-jsx',\n+  meta: {\n+    type: 'problem',\n+    docs: {\n+      description:\n+        'Unbundled JSX will default to React Client if it is not bundled in next-server. ' +\n+        \"If you're creating JSX for React Server, use createElement from componentMod instead.\",\n+      recommended: true,\n+    },\n+    fixable: 'code',\n+    schema: [],\n+    messages: {},\n+  },\n+\n+  create(context) {\n+    function reportJSX(node) {\n+      context.report({\n+        message: 'Ambiguous JSX usage.',\n+        node: node.openingFragment ?? node.name,\n+      })\n+    }\n+\n+    return {\n+      JSXOpeningElement: reportJSX,\n+      JSXFragment: reportJSX,\n+    }\n+  },\n+}\n+\n+module.exports = plugin"
        },
        {
            "sha": "a5c8151c2201780429ec2abfcfe3feead1c64c5d",
            "filename": "packages/eslint-plugin-internal/src/eslint-plugin-internal.js",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Feslint-plugin-internal%2Fsrc%2Feslint-plugin-internal.js",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Feslint-plugin-internal%2Fsrc%2Feslint-plugin-internal.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Feslint-plugin-internal%2Fsrc%2Feslint-plugin-internal.js?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -1,7 +1,9 @@\n const typecheckedRequire = require('./eslint-typechecked-require')\n+const noAmbiguousJSX = require('./eslint-no-ambiguous-jsx')\n \n module.exports = {\n   rules: {\n+    'no-ambiguous-jsx': noAmbiguousJSX,\n     'typechecked-require': typecheckedRequire,\n   },\n }"
        },
        {
            "sha": "4f057fc9b0eb0d4ba387ad6bfb397738a2ec636c",
            "filename": "packages/next/src/client/components/http-access-fallback/error-boundary.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fhttp-access-fallback%2Ferror-boundary.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fhttp-access-fallback%2Ferror-boundary.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fhttp-access-fallback%2Ferror-boundary.tsx?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -26,7 +26,8 @@ interface HTTPAccessFallbackBoundaryProps {\n   notFound?: React.ReactNode\n   forbidden?: React.ReactNode\n   unauthorized?: React.ReactNode\n-  children: React.ReactNode\n+  // TODO: Make this required once `React.createElement` understands that positional args go into children\n+  children?: React.ReactNode\n   missingSlots?: Set<string>\n }\n "
        },
        {
            "sha": "4eb2d4de5d4879a20acc49ee24ef3b60d0dd6b6e",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 146,
            "deletions": 88,
            "changes": 234,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -1,3 +1,4 @@\n+import type { ComponentType, ErrorInfo, JSX, ReactNode } from 'react'\n import type { RenderOpts, PreloadCallbacks } from './types'\n import type {\n   ActionResult,\n@@ -28,8 +29,7 @@ import type {\n import type { DeepReadonly } from '../../shared/lib/deep-readonly'\n import type { BaseNextRequest, BaseNextResponse } from '../base-http'\n import type { IncomingHttpHeaders } from 'http'\n-\n-import React, { type ErrorInfo, type JSX } from 'react'\n+import * as ReactClient from 'react'\n \n import RenderResult, {\n   type AppPageRenderResultMetadata,\n@@ -417,10 +417,12 @@ function makeGetDynamicParamFromSegment(\n }\n \n function NonIndex({\n+  createElement,\n   pagePath,\n   statusCode,\n   isPossibleServerAction,\n }: {\n+  createElement: typeof ReactClient.createElement\n   pagePath: string\n   statusCode: number | undefined\n   isPossibleServerAction: boolean\n@@ -431,7 +433,10 @@ function NonIndex({\n   // Only render noindex for page request, skip for server actions\n   // TODO: is this correct if `isPossibleServerAction` is a false positive?\n   if (!isPossibleServerAction && (is404Page || isInvalidStatusCode)) {\n-    return <meta name=\"robots\" content=\"noindex\" />\n+    return createElement('meta', {\n+      name: 'robots',\n+      content: 'noindex',\n+    })\n   }\n   return null\n }\n@@ -462,7 +467,9 @@ async function generateDynamicRSCPayload(\n       routeModule: {\n         userland: { loaderTree },\n       },\n+      createElement,\n       createMetadataComponents,\n+      Fragment,\n     },\n     getDynamicParamFromSegment,\n     query,\n@@ -494,18 +501,23 @@ async function generateDynamicRSCPayload(\n         parentParams: {},\n         flightRouterState,\n         // For flight, render metadata inside leaf page\n-        rscHead: (\n-          <React.Fragment key={flightDataPathHeadKey}>\n-            {/* noindex needs to be blocking */}\n-            <NonIndex\n-              pagePath={ctx.pagePath}\n-              statusCode={ctx.res.statusCode}\n-              isPossibleServerAction={ctx.isPossibleServerAction}\n-            />\n-            {/* Adding requestId as react key to make metadata remount for each render */}\n-            <Viewport key={getFlightViewportKey(requestId)} />\n-            <Metadata key={getFlightMetadataKey(requestId)} />\n-          </React.Fragment>\n+        rscHead: createElement(\n+          Fragment,\n+          {\n+            key: flightDataPathHeadKey,\n+          },\n+          createElement(NonIndex, {\n+            createElement,\n+            pagePath: ctx.pagePath,\n+            statusCode: ctx.res.statusCode,\n+            isPossibleServerAction: ctx.isPossibleServerAction,\n+          }),\n+          createElement(Viewport, {\n+            key: getFlightViewportKey(requestId),\n+          }),\n+          createElement(Metadata, {\n+            key: getFlightMetadataKey(requestId),\n+          })\n         ),\n         injectedCSS: new Set(),\n         injectedJS: new Set(),\n@@ -595,7 +607,7 @@ async function generateDynamicFlightRenderResult(\n \n   const RSCPayload: RSCPayload & {\n     /** Only available during cacheComponents development builds. Used for logging errors. */\n-    _validation?: Promise<React.ReactNode>\n+    _validation?: Promise<ReactNode>\n   } = await workUnitAsyncStorage.run(\n     requestStore,\n     generateDynamicRSCPayload,\n@@ -1037,7 +1049,7 @@ async function getRSCPayload(\n   tree: LoaderTree,\n   ctx: AppRenderContext,\n   is404: boolean\n-): Promise<InitialRSCPayload & { P: React.ReactNode }> {\n+): Promise<InitialRSCPayload & { P: ReactNode }> {\n   const injectedCSS = new Set<string>()\n   const injectedJS = new Set<string>()\n   const injectedFontPreloadTags = new Set<string>()\n@@ -1052,7 +1064,7 @@ async function getRSCPayload(\n     getDynamicParamFromSegment,\n     query,\n     appUsingSizeAdjustment,\n-    componentMod: { createMetadataComponents },\n+    componentMod: { createMetadataComponents, createElement, Fragment },\n     url,\n     workStore,\n   } = ctx\n@@ -1104,20 +1116,25 @@ async function getRSCPayload(\n   const couldBeIntercepted =\n     typeof varyHeader === 'string' && varyHeader.includes(NEXT_URL)\n \n-  const initialHead = (\n-    <React.Fragment key={flightDataPathHeadKey}>\n-      <NonIndex\n-        pagePath={ctx.pagePath}\n-        statusCode={ctx.res.statusCode}\n-        isPossibleServerAction={ctx.isPossibleServerAction}\n-      />\n-      <Viewport />\n-      <Metadata />\n-      {/* This meta tag is for next/font which is still required to be blocking. */}\n-      {appUsingSizeAdjustment ? (\n-        <meta name=\"next-size-adjust\" content=\"\" />\n-      ) : null}\n-    </React.Fragment>\n+  const initialHead = createElement(\n+    Fragment,\n+    {\n+      key: flightDataPathHeadKey,\n+    },\n+    createElement(NonIndex, {\n+      createElement,\n+      pagePath: ctx.pagePath,\n+      statusCode: ctx.res.statusCode,\n+      isPossibleServerAction: ctx.isPossibleServerAction,\n+    }),\n+    createElement(Viewport, null),\n+    createElement(Metadata, null),\n+    appUsingSizeAdjustment\n+      ? createElement('meta', {\n+          name: 'next-size-adjust',\n+          content: '',\n+        })\n+      : null\n   )\n \n   const { GlobalError, styles: globalErrorStyles } = await getGlobalErrorStyles(\n@@ -1137,7 +1154,9 @@ async function getRSCPayload(\n \n   return {\n     // See the comment above the `Preloads` component (below) for why this is part of the payload\n-    P: <Preloads preloadCallbacks={preloadCallbacks} />,\n+    P: createElement(Preloads, {\n+      preloadCallbacks: preloadCallbacks,\n+    }),\n     b: ctx.sharedContext.buildId,\n     c: prepareInitialCanonicalUrl(url),\n     i: !!couldBeIntercepted,\n@@ -1177,7 +1196,7 @@ async function getErrorRSCPayload(\n   const {\n     getDynamicParamFromSegment,\n     query,\n-    componentMod: { createMetadataComponents },\n+    componentMod: { createMetadataComponents, createElement, Fragment },\n     url,\n     workStore,\n   } = ctx\n@@ -1194,19 +1213,24 @@ async function getErrorRSCPayload(\n     serveStreamingMetadata: serveStreamingMetadata,\n   })\n \n-  const initialHead = (\n-    <React.Fragment key={flightDataPathHeadKey}>\n-      <NonIndex\n-        pagePath={ctx.pagePath}\n-        statusCode={ctx.res.statusCode}\n-        isPossibleServerAction={ctx.isPossibleServerAction}\n-      />\n-      <Viewport />\n-      {process.env.NODE_ENV === 'development' && (\n-        <meta name=\"next-error\" content=\"not-found\" />\n-      )}\n-      <Metadata />\n-    </React.Fragment>\n+  const initialHead = createElement(\n+    Fragment,\n+    {\n+      key: flightDataPathHeadKey,\n+    },\n+    createElement(NonIndex, {\n+      createElement,\n+      pagePath: ctx.pagePath,\n+      statusCode: ctx.res.statusCode,\n+      isPossibleServerAction: ctx.isPossibleServerAction,\n+    }),\n+    createElement(Viewport, null),\n+    process.env.NODE_ENV === 'development' &&\n+      createElement('meta', {\n+        name: 'next-error',\n+        content: 'not-found',\n+      }),\n+    createElement(Metadata, null)\n   )\n \n   const initialTree = createFlightRouterStateFromLoaderTree(\n@@ -1224,18 +1248,24 @@ async function getErrorRSCPayload(\n   // so we create a not found page with AppRouter\n   const seedData: CacheNodeSeedData = [\n     initialTree[0],\n-    <html id=\"__next_error__\">\n-      <head></head>\n-      <body>\n-        {process.env.NODE_ENV !== 'production' && err ? (\n-          <template\n-            data-next-error-message={err.message}\n-            data-next-error-digest={'digest' in err ? err.digest : ''}\n-            data-next-error-stack={err.stack}\n-          />\n-        ) : null}\n-      </body>\n-    </html>,\n+    createElement(\n+      'html',\n+      {\n+        id: '__next_error__',\n+      },\n+      createElement('head', null),\n+      createElement(\n+        'body',\n+        null,\n+        process.env.NODE_ENV !== 'production' && err\n+          ? createElement('template', {\n+              'data-next-error-message': err.message,\n+              'data-next-error-digest': 'digest' in err ? err.digest : '',\n+              'data-next-error-stack': err.stack,\n+            })\n+          : null\n+      )\n+    ),\n     {},\n     null,\n     false,\n@@ -1290,16 +1320,19 @@ function App<T>({\n   nonce,\n   images,\n }: {\n+  /* eslint-disable @next/internal/no-ambiguous-jsx -- React Client */\n   reactServerStream: BinaryStreamOf<T>\n   reactDebugStream: ReadableStream<Uint8Array> | undefined\n   preinitScripts: () => void\n   clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n-  ServerInsertedHTMLProvider: React.ComponentType<{ children: JSX.Element }>\n+  ServerInsertedHTMLProvider: ComponentType<{\n+    children: JSX.Element\n+  }>\n   images: RenderOpts['images']\n   nonce?: string\n }): JSX.Element {\n   preinitScripts()\n-  const response = React.use(\n+  const response = ReactClient.use(\n     useFlightStream<InitialRSCPayload>(\n       reactServerStream,\n       reactDebugStream,\n@@ -1342,6 +1375,7 @@ function App<T>({\n       </ImageConfigContext.Provider>\n     </HeadManagerContext.Provider>\n   )\n+  /* eslint-enable @next/internal/no-ambiguous-jsx -- React Client */\n }\n \n // @TODO our error stream should be probably just use the same root component. But it was previously\n@@ -1360,12 +1394,15 @@ function ErrorApp<T>({\n   reactDebugStream: ReadableStream<Uint8Array> | undefined\n   preinitScripts: () => void\n   clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>\n-  ServerInsertedHTMLProvider: React.ComponentType<{ children: JSX.Element }>\n+  ServerInsertedHTMLProvider: ComponentType<{\n+    children: JSX.Element\n+  }>\n   nonce?: string\n   images: RenderOpts['images']\n }): JSX.Element {\n+  /* eslint-disable @next/internal/no-ambiguous-jsx -- React Client */\n   preinitScripts()\n-  const response = React.use(\n+  const response = ReactClient.use(\n     useFlightStream<InitialRSCPayload>(\n       reactServerStream,\n       reactDebugStream,\n@@ -1398,6 +1435,7 @@ function ErrorApp<T>({\n       </ServerInsertedHTMLProvider>\n     </ImageConfigContext.Provider>\n   )\n+  /* eslint-enable @next/internal/no-ambiguous-jsx -- React Client */\n }\n \n // We use a trick with TS Generics to branch streams with a type so we can\n@@ -2117,6 +2155,7 @@ async function renderToStream(\n   createRequestStore: (() => RequestStore) | undefined,\n   devValidatingFallbackParams: OpaqueFallbackRouteParams | null\n ): Promise<ReadableStream<Uint8Array>> {\n+  /* eslint-disable @next/internal/no-ambiguous-jsx -- React Client */\n   const { assetPrefix, htmlRequestId, nonce, pagePath, renderOpts, requestId } =\n     ctx\n \n@@ -2242,7 +2281,7 @@ async function renderToStream(\n     ) {\n       type RSCPayloadWithValidation = InitialRSCPayload & {\n         /** Only available during cacheComponents development builds. Used for logging errors. */\n-        _validation?: Promise<React.ReactNode>\n+        _validation?: Promise<ReactNode>\n       }\n \n       const [resolveValidation, validationOutlet] = createValidationOutlet()\n@@ -2661,6 +2700,7 @@ async function renderToStream(\n       throw finalErr\n     }\n   }\n+  /* eslint-enable @next/internal/no-ambiguous-jsx */\n }\n \n async function renderWithRestartOnCacheMissInDev(\n@@ -2870,8 +2910,8 @@ function createDebugChannel(): DebugChannelPair | undefined {\n }\n \n function createValidationOutlet() {\n-  let resolveValidation: (value: React.ReactNode) => void\n-  let outlet = new Promise<React.ReactNode>((resolve) => {\n+  let resolveValidation: (value: ReactNode) => void\n+  let outlet = new Promise<ReactNode>((resolve) => {\n     resolveValidation = resolve\n   })\n   return [resolveValidation!, outlet] as const\n@@ -2884,7 +2924,7 @@ function createValidationOutlet() {\n  * in conjunction with any changes to that function.\n  */\n async function spawnDynamicValidationInDev(\n-  resolveValidation: (validatingElement: React.ReactNode) => void,\n+  resolveValidation: (validatingElement: ReactNode) => void,\n   tree: LoaderTree,\n   ctx: AppRenderContext,\n   isNotFound: boolean,\n@@ -2943,8 +2983,9 @@ async function spawnDynamicValidationInDev(\n   // ready to cut the render off.\n   const cacheSignal = new CacheSignal()\n \n-  const captureOwnerStackClient = React.captureOwnerStack\n-  const captureOwnerStackServer = ComponentMod.captureOwnerStack\n+  const captureOwnerStackClient = ReactClient.captureOwnerStack\n+  const { captureOwnerStack: captureOwnerStackServer, createElement } =\n+    ComponentMod\n \n   // The resume data cache here should use a fresh instance as it's\n   // performing a fresh prerender. If we get to implementing the\n@@ -3077,11 +3118,11 @@ async function spawnDynamicValidationInDev(\n   const { invalidDynamicUsageError } = workStore\n   if (invalidDynamicUsageError) {\n     resolveValidation(\n-      <LogSafely\n-        fn={() => {\n+      createElement(LogSafely, {\n+        fn: () => {\n           console.error(invalidDynamicUsageError)\n-        }}\n-      />\n+        },\n+      })\n     )\n     return\n   }\n@@ -3141,6 +3182,7 @@ async function spawnDynamicValidationInDev(\n     const pendingInitialClientResult = workUnitAsyncStorage.run(\n       initialClientPrerenderStore,\n       prerender,\n+      // eslint-disable-next-line @next/internal/no-ambiguous-jsx -- React Client\n       <App\n         reactServerStream={initialServerResult.asUnclosingStream()}\n         reactDebugStream={undefined}\n@@ -3371,6 +3413,7 @@ async function spawnDynamicValidationInDev(\n           const pendingFinalClientResult = workUnitAsyncStorage.run(\n             finalClientPrerenderStore,\n             prerender,\n+            // eslint-disable-next-line @next/internal/no-ambiguous-jsx -- React Client\n             <App\n               reactServerStream={reactServerResult.asUnclosingStream()}\n               reactDebugStream={undefined}\n@@ -3432,15 +3475,15 @@ async function spawnDynamicValidationInDev(\n \n     const { preludeIsEmpty } = await processPrelude(unprocessedPrelude)\n     resolveValidation(\n-      <LogSafely\n-        fn={throwIfDisallowedDynamic.bind(\n+      createElement(LogSafely, {\n+        fn: throwIfDisallowedDynamic.bind(\n           null,\n           workStore,\n           preludeIsEmpty ? PreludeState.Empty : PreludeState.Full,\n           dynamicValidation,\n           serverDynamicTracking\n-        )}\n-      />\n+        ),\n+      })\n     )\n   } catch (thrownValue) {\n     // Even if the root errors we still want to report any cache components errors\n@@ -3467,7 +3510,11 @@ async function spawnDynamicValidationInDev(\n       }\n     }\n \n-    resolveValidation(<LogSafely fn={loggingFunction} />)\n+    resolveValidation(\n+      createElement(LogSafely, {\n+        fn: loggingFunction,\n+      })\n+    )\n   }\n }\n \n@@ -3886,6 +3933,7 @@ async function prerenderToStream(\n         const pendingInitialClientResult = workUnitAsyncStorage.run(\n           initialClientPrerenderStore,\n           prerender,\n+          // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n           <App\n             reactServerStream={initialServerResult.asUnclosingStream()}\n             reactDebugStream={undefined}\n@@ -4121,6 +4169,7 @@ async function prerenderToStream(\n             const pendingFinalClientResult = workUnitAsyncStorage.run(\n               finalClientPrerenderStore,\n               prerender,\n+              // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n               <App\n                 reactServerStream={reactServerResult.asUnclosingStream()}\n                 reactDebugStream={undefined}\n@@ -4286,6 +4335,7 @@ async function prerenderToStream(\n           const foreverStream = new ReadableStream<Uint8Array>()\n \n           const resumeStream = await resume(\n+            // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n             <App\n               reactServerStream={foreverStream}\n               reactDebugStream={undefined}\n@@ -4394,6 +4444,7 @@ async function prerenderToStream(\n         await workUnitAsyncStorage.run(\n           ssrPrerenderStore,\n           prerender,\n+          // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n           <App\n             reactServerStream={reactServerResult.asUnclosingStream()}\n             reactDebugStream={undefined}\n@@ -4536,6 +4587,7 @@ async function prerenderToStream(\n           const foreverStream = new ReadableStream<Uint8Array>()\n \n           const resumeStream = await resume(\n+            // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n             <App\n               reactServerStream={foreverStream}\n               reactDebugStream={undefined}\n@@ -4621,6 +4673,7 @@ async function prerenderToStream(\n       const htmlStream = await workUnitAsyncStorage.run(\n         prerenderLegacyStore,\n         renderToReadableStream,\n+        // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n         <App\n           reactServerStream={reactServerResult.asUnclosingStream()}\n           reactDebugStream={undefined}\n@@ -4796,6 +4849,7 @@ async function prerenderToStream(\n           ReactDOMServer:\n             require('react-dom/server') as typeof import('react-dom/server'),\n           element: (\n+            // eslint-disable-next-line @next/internal/no-ambiguous-jsx\n             <ErrorApp\n               reactServerStream={errorServerStream}\n               reactDebugStream={undefined}\n@@ -4886,12 +4940,15 @@ const getGlobalErrorStyles = async (\n   ctx: AppRenderContext\n ): Promise<{\n   GlobalError: GlobalErrorComponent\n-  styles: React.ReactNode | undefined\n+  styles: ReactNode | undefined\n }> => {\n   const {\n     modules: { 'global-error': globalErrorModule },\n   } = parseLoaderTree(tree)\n \n+  const {\n+    componentMod: { createElement },\n+  } = ctx\n   const GlobalErrorComponent: GlobalErrorComponent =\n     ctx.componentMod.GlobalError\n   let globalErrorStyles\n@@ -4917,17 +4974,18 @@ const getGlobalErrorStyles = async (\n     )\n     if (globalErrorModulePath) {\n       const SegmentViewNode = ctx.componentMod.SegmentViewNode\n-      globalErrorStyles = (\n+      globalErrorStyles =\n         // This will be rendered next to GlobalError component under ErrorBoundary,\n         // it requires a key to avoid React warning about duplicate keys.\n-        <SegmentViewNode\n-          key=\"ge-svn\"\n-          type=\"global-error\"\n-          pagePath={globalErrorModulePath}\n-        >\n-          {globalErrorStyles}\n-        </SegmentViewNode>\n-      )\n+        createElement(\n+          SegmentViewNode,\n+          {\n+            key: 'ge-svn',\n+            type: 'global-error',\n+            pagePath: globalErrorModulePath,\n+          },\n+          globalErrorStyles\n+        )\n     }\n   }\n "
        },
        {
            "sha": "f0648d2b91672c8c8b9a1269d1bdde7bb03fda7e",
            "filename": "packages/next/src/server/app-render/collect-segment-data.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -1,3 +1,4 @@\n+/* eslint-disable @next/internal/no-ambiguous-jsx -- Bundled in entry-base so it gets the right JSX runtime. */\n import type {\n   CacheNodeSeedData,\n   FlightRouterState,"
        },
        {
            "sha": "61991b2f32832118a5344af6d8723903e4f01ef3",
            "filename": "packages/next/src/server/app-render/create-component-styles-and-scripts.tsx",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-styles-and-scripts.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-styles-and-scripts.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-styles-and-scripts.tsx?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -1,4 +1,3 @@\n-import React from 'react'\n import { interopDefault } from './interop-default'\n import { getLinkAndScriptTags } from './get-css-inlined-link-tags'\n import type { AppRenderContext } from './app-render'\n@@ -19,6 +18,9 @@ export async function createComponentStylesAndScripts({\n   injectedJS: Set<string>\n   ctx: AppRenderContext\n }): Promise<[React.ComponentType<any>, React.ReactNode, React.ReactNode]> {\n+  const {\n+    componentMod: { createElement },\n+  } = ctx\n   const { styles: entryCssFiles, scripts: jsHrefs } = getLinkAndScriptTags(\n     ctx.clientReferenceManifest,\n     filePath,\n@@ -29,15 +31,13 @@ export async function createComponentStylesAndScripts({\n   const styles = renderCssResource(entryCssFiles, ctx)\n \n   const scripts = jsHrefs\n-    ? jsHrefs.map((href, index) => (\n-        <script\n-          src={`${ctx.assetPrefix}/_next/${encodeURIPath(\n-            href\n-          )}${getAssetQueryString(ctx, true)}`}\n-          async={true}\n-          key={`script-${index}`}\n-        />\n-      ))\n+    ? jsHrefs.map((href, index) =>\n+        createElement('script', {\n+          src: `${ctx.assetPrefix}/_next/${encodeURIPath(href)}${getAssetQueryString(ctx, true)}`,\n+          async: true,\n+          key: `script-${index}`,\n+        })\n+      )\n     : null\n \n   const Comp = interopDefault(await getComponent())"
        },
        {
            "sha": "b71efe37ef672bd814e98f12d8d29c9ff96662b0",
            "filename": "packages/next/src/server/app-render/create-component-tree.tsx",
            "status": "modified",
            "additions": 281,
            "deletions": 238,
            "changes": 519,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -1,9 +1,9 @@\n+import type { ComponentType } from 'react'\n import type {\n   CacheNodeSeedData,\n   LoadingModuleData,\n } from '../../shared/lib/app-router-types'\n import type { PreloadCallbacks } from './types'\n-import React from 'react'\n import {\n   isClientReference,\n   isUseCacheFunction,\n@@ -51,7 +51,7 @@ export function createComponentTree(props: {\n   missingSlots?: Set<string>\n   preloadCallbacks: PreloadCallbacks\n   authInterrupts: boolean\n-  MetadataOutlet: React.ComponentType\n+  MetadataOutlet: ComponentType\n }): Promise<CacheNodeSeedData> {\n   return getTracer().trace(\n     NextNodeServerSpan.createComponentTree,\n@@ -98,14 +98,16 @@ async function createComponentTreeInternal(\n     missingSlots?: Set<string>\n     preloadCallbacks: PreloadCallbacks\n     authInterrupts: boolean\n-    MetadataOutlet: React.ComponentType | null\n+    MetadataOutlet: ComponentType | null\n   },\n   isRoot: boolean\n ): Promise<CacheNodeSeedData> {\n   const {\n     renderOpts: { nextConfigOutput, experimental },\n     workStore,\n     componentMod: {\n+      createElement,\n+      Fragment,\n       SegmentViewNode,\n       HTTPAccessFallbackBoundary,\n       LayoutRouter,\n@@ -161,7 +163,7 @@ async function createComponentTreeInternal(\n         injectedCSS: injectedCSSWithCurrentLayout,\n         injectedJS: injectedJSWithCurrentLayout,\n       })\n-    : [React.Fragment]\n+    : [Fragment]\n \n   const [ErrorComponent, errorStyles, errorScripts] = error\n     ? await createComponentStylesAndScripts({\n@@ -354,7 +356,7 @@ async function createComponentTreeInternal(\n   const isPossiblyPartialResponse =\n     isStaticGeneration && experimental.isRoutePPREnabled === true\n \n-  const LayoutOrPage: React.ComponentType<any> | undefined = layoutOrPageMod\n+  const LayoutOrPage: ComponentType<any> | undefined = layoutOrPageMod\n     ? interopDefault(layoutOrPageMod)\n     : undefined\n \n@@ -543,10 +545,10 @@ async function createComponentTreeInternal(\n           childCacheNodeSeedData = seedData\n         }\n \n-        const templateNode = (\n-          <Template>\n-            <RenderFromTemplateContext />\n-          </Template>\n+        const templateNode = createElement(\n+          Template,\n+          null,\n+          createElement(RenderFromTemplateContext, null)\n         )\n \n         const templateFilePath = getConventionPathByType(tree, dir, 'template')\n@@ -557,78 +559,77 @@ async function createComponentTreeInternal(\n           : undefined\n \n         const wrappedErrorStyles =\n-          isSegmentViewEnabled && errorFilePath ? (\n-            <SegmentViewNode type=\"error\" pagePath={errorFilePath}>\n-              {errorStyles}\n-            </SegmentViewNode>\n-          ) : (\n-            errorStyles\n-          )\n+          isSegmentViewEnabled && errorFilePath\n+            ? createElement(\n+                SegmentViewNode,\n+                {\n+                  type: 'error',\n+                  pagePath: errorFilePath,\n+                },\n+                errorStyles\n+              )\n+            : errorStyles\n \n         // Add a suffix to avoid conflict with the segment view node representing rendered file.\n         // existence: not-found.tsx@boundary\n         // rendered: not-found.tsx\n         const fileNameSuffix = BOUNDARY_SUFFIX\n-        const segmentViewBoundaries = isSegmentViewEnabled ? (\n-          <>\n-            {notFoundFilePath && (\n-              <SegmentViewNode\n-                type={`${BOUNDARY_PREFIX}not-found`}\n-                pagePath={notFoundFilePath + fileNameSuffix}\n-              />\n-            )}\n-            {loadingFilePath && (\n-              <SegmentViewNode\n-                type={`${BOUNDARY_PREFIX}loading`}\n-                pagePath={loadingFilePath + fileNameSuffix}\n-              />\n-            )}\n-            {errorFilePath && (\n-              <SegmentViewNode\n-                type={`${BOUNDARY_PREFIX}error`}\n-                pagePath={errorFilePath + fileNameSuffix}\n-              />\n-            )}\n-            {/* Only show global-error when it's the builtin one */}\n-            {globalErrorFilePath && (\n-              <SegmentViewNode\n-                type={`${BOUNDARY_PREFIX}global-error`}\n-                pagePath={\n-                  isNextjsBuiltinFilePath(globalErrorFilePath)\n+        const segmentViewBoundaries = isSegmentViewEnabled\n+          ? createElement(\n+              Fragment,\n+              null,\n+              notFoundFilePath &&\n+                createElement(SegmentViewNode, {\n+                  type: `${BOUNDARY_PREFIX}not-found`,\n+                  pagePath: notFoundFilePath + fileNameSuffix,\n+                }),\n+              loadingFilePath &&\n+                createElement(SegmentViewNode, {\n+                  type: `${BOUNDARY_PREFIX}loading`,\n+                  pagePath: loadingFilePath + fileNameSuffix,\n+                }),\n+              errorFilePath &&\n+                createElement(SegmentViewNode, {\n+                  type: `${BOUNDARY_PREFIX}error`,\n+                  pagePath: errorFilePath + fileNameSuffix,\n+                }),\n+              globalErrorFilePath &&\n+                createElement(SegmentViewNode, {\n+                  type: `${BOUNDARY_PREFIX}global-error`,\n+                  pagePath: isNextjsBuiltinFilePath(globalErrorFilePath)\n                     ? `${BUILTIN_PREFIX}global-error.js${fileNameSuffix}`\n-                    : globalErrorFilePath\n-                }\n-              />\n-            )}\n-            {/* do not surface forbidden and unauthorized boundaries yet as they're unstable */}\n-          </>\n-        ) : null\n+                    : globalErrorFilePath,\n+                })\n+            )\n+          : null\n \n         return [\n           parallelRouteKey,\n-          <LayoutRouter\n-            parallelRouterKey={parallelRouteKey}\n-            // TODO-APP: Add test for loading returning `undefined`. This currently can't be tested as the `webdriver()` tab will wait for the full page to load before returning.\n-            error={ErrorComponent}\n-            errorStyles={wrappedErrorStyles}\n-            errorScripts={errorScripts}\n-            template={\n-              // Only render SegmentViewNode when there's an actual template\n-              isSegmentViewEnabled && templateFilePath ? (\n-                <SegmentViewNode type=\"template\" pagePath={templateFilePath}>\n-                  {templateNode}\n-                </SegmentViewNode>\n-              ) : (\n-                templateNode\n-              )\n-            }\n-            templateStyles={templateStyles}\n-            templateScripts={templateScripts}\n-            notFound={notFoundComponent}\n-            forbidden={forbiddenComponent}\n-            unauthorized={unauthorizedComponent}\n-            {...(isSegmentViewEnabled && { segmentViewBoundaries })}\n-          />,\n+          createElement(LayoutRouter, {\n+            parallelRouterKey: parallelRouteKey,\n+            error: ErrorComponent,\n+            errorStyles: wrappedErrorStyles,\n+            errorScripts: errorScripts,\n+            template:\n+              isSegmentViewEnabled && templateFilePath\n+                ? createElement(\n+                    SegmentViewNode,\n+                    {\n+                      type: 'template',\n+                      pagePath: templateFilePath,\n+                    },\n+                    templateNode\n+                  )\n+                : templateNode,\n+            templateStyles: templateStyles,\n+            templateScripts: templateScripts,\n+            notFound: notFoundComponent,\n+            forbidden: forbiddenComponent,\n+            unauthorized: unauthorizedComponent,\n+            ...(isSegmentViewEnabled && {\n+              segmentViewBoundaries,\n+            }),\n+          }),\n           childCacheNodeSeedData,\n         ]\n       }\n@@ -646,18 +647,22 @@ async function createComponentTreeInternal(\n     parallelRouteCacheNodeSeedData[parallelRouteKey] = flightData\n   }\n \n-  let loadingElement = Loading ? <Loading key=\"l\" /> : null\n+  let loadingElement = Loading\n+    ? createElement(Loading, {\n+        key: 'l',\n+      })\n+    : null\n   const loadingFilePath = getConventionPathByType(tree, dir, 'loading')\n   if (isSegmentViewEnabled && loadingElement) {\n     if (loadingFilePath) {\n-      loadingElement = (\n-        <SegmentViewNode\n-          key={cacheNodeKey + '-loading'}\n-          type=\"loading\"\n-          pagePath={loadingFilePath}\n-        >\n-          {loadingElement}\n-        </SegmentViewNode>\n+      loadingElement = createElement(\n+        SegmentViewNode,\n+        {\n+          key: cacheNodeKey + '-loading',\n+          type: 'loading',\n+          pagePath: loadingFilePath,\n+        },\n+        loadingElement\n       )\n     }\n   }\n@@ -670,10 +675,14 @@ async function createComponentTreeInternal(\n   if (!MaybeComponent) {\n     return [\n       actualSegment,\n-      <React.Fragment key={cacheNodeKey}>\n-        {layerAssets}\n-        {parallelRouteProps.children}\n-      </React.Fragment>,\n+      createElement(\n+        Fragment,\n+        {\n+          key: cacheNodeKey,\n+        },\n+        layerAssets,\n+        parallelRouteProps.children\n+      ),\n       parallelRouteCacheNodeSeedData,\n       loadingData,\n       isPossiblyPartialResponse,\n@@ -700,13 +709,17 @@ async function createComponentTreeInternal(\n   ) {\n     return [\n       actualSegment,\n-      <React.Fragment key={cacheNodeKey}>\n-        <Postpone\n-          reason='dynamic = \"force-dynamic\" was used'\n-          route={workStore.route}\n-        />\n-        {layerAssets}\n-      </React.Fragment>,\n+      createElement(\n+        Fragment,\n+        {\n+          key: cacheNodeKey,\n+        },\n+        createElement(Postpone, {\n+          reason: 'dynamic = \"force-dynamic\" was used',\n+          route: workStore.route,\n+        }),\n+        layerAssets\n+      ),\n       parallelRouteCacheNodeSeedData,\n       loadingData,\n       true,\n@@ -737,22 +750,18 @@ async function createComponentTreeInternal(\n           createPrerenderParamsForClientSegment(currentParams)\n         const promiseOfSearchParams =\n           createPrerenderSearchParamsForClientPage(workStore)\n-        pageElement = (\n-          <ClientPageRoot\n-            Component={PageComponent}\n-            searchParams={query}\n-            params={currentParams}\n-            promises={[promiseOfSearchParams, promiseOfParams]}\n-          />\n-        )\n+        pageElement = createElement(ClientPageRoot, {\n+          Component: PageComponent,\n+          searchParams: query,\n+          params: currentParams,\n+          promises: [promiseOfSearchParams, promiseOfParams],\n+        })\n       } else {\n-        pageElement = (\n-          <ClientPageRoot\n-            Component={PageComponent}\n-            searchParams={query}\n-            params={currentParams}\n-          />\n-        )\n+        pageElement = createElement(ClientPageRoot, {\n+          Component: PageComponent,\n+          searchParams: query,\n+          params: currentParams,\n+        })\n       }\n     } else {\n       // If we are passing params to a server component Page we need to track\n@@ -768,20 +777,19 @@ async function createComponentTreeInternal(\n       let searchParams = createServerSearchParamsForServerPage(query, workStore)\n \n       if (isUseCacheFunction(PageComponent)) {\n-        const UseCachePageComponent: React.ComponentType<UseCachePageProps> =\n+        const UseCachePageComponent: ComponentType<UseCachePageProps> =\n           PageComponent\n \n-        pageElement = (\n-          <UseCachePageComponent\n-            params={params}\n-            searchParams={searchParams}\n-            $$isPage\n-          />\n-        )\n+        pageElement = createElement(UseCachePageComponent, {\n+          params: params,\n+          searchParams: searchParams,\n+          $$isPage: true,\n+        })\n       } else {\n-        pageElement = (\n-          <PageComponent params={params} searchParams={searchParams} />\n-        )\n+        pageElement = createElement(PageComponent, {\n+          params: params,\n+          searchParams: searchParams,\n+        })\n       }\n     }\n \n@@ -791,25 +799,29 @@ async function createComponentTreeInternal(\n       getConventionPathByType(tree, dir, 'defaultPage')\n     const segmentType = isDefaultSegment ? 'default' : 'page'\n     const wrappedPageElement =\n-      isSegmentViewEnabled && pageFilePath ? (\n-        <SegmentViewNode\n-          key={cacheNodeKey + '-' + segmentType}\n-          type={segmentType}\n-          pagePath={pageFilePath}\n-        >\n-          {pageElement}\n-        </SegmentViewNode>\n-      ) : (\n-        pageElement\n-      )\n+      isSegmentViewEnabled && pageFilePath\n+        ? createElement(\n+            SegmentViewNode,\n+            {\n+              key: cacheNodeKey + '-' + segmentType,\n+              type: segmentType,\n+              pagePath: pageFilePath,\n+            },\n+            pageElement\n+          )\n+        : pageElement\n \n     return [\n       actualSegment,\n-      <React.Fragment key={cacheNodeKey}>\n-        {wrappedPageElement}\n-        {layerAssets}\n-        {MetadataOutlet ? <MetadataOutlet /> : null}\n-      </React.Fragment>,\n+      createElement(\n+        Fragment,\n+        {\n+          key: cacheNodeKey,\n+        },\n+        wrappedPageElement,\n+        layerAssets,\n+        MetadataOutlet ? createElement(MetadataOutlet, null) : null\n+      ),\n       parallelRouteCacheNodeSeedData,\n       loadingData,\n       isPossiblyPartialResponse,\n@@ -831,22 +843,18 @@ async function createComponentTreeInternal(\n         const promiseOfParams =\n           createPrerenderParamsForClientSegment(currentParams)\n \n-        clientSegment = (\n-          <ClientSegmentRoot\n-            Component={SegmentComponent}\n-            slots={parallelRouteProps}\n-            params={currentParams}\n-            promise={promiseOfParams}\n-          />\n-        )\n+        clientSegment = createElement(ClientSegmentRoot, {\n+          Component: SegmentComponent,\n+          slots: parallelRouteProps,\n+          params: currentParams,\n+          promise: promiseOfParams,\n+        })\n       } else {\n-        clientSegment = (\n-          <ClientSegmentRoot\n-            Component={SegmentComponent}\n-            slots={parallelRouteProps}\n-            params={currentParams}\n-          />\n-        )\n+        clientSegment = createElement(ClientSegmentRoot, {\n+          Component: SegmentComponent,\n+          slots: parallelRouteProps,\n+          params: currentParams,\n+        })\n       }\n \n       if (isRootLayoutWithChildrenSlotAndAtLeastOneMoreSlot) {\n@@ -859,6 +867,7 @@ async function createComponentTreeInternal(\n         // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n         // rely on the `NotFound` behavior.\n         notfoundClientSegment = createErrorBoundaryClientSegmentRoot({\n+          ctx,\n           ErrorBoundaryComponent: NotFound,\n           errorElement: notFoundElement,\n           ClientSegmentRoot,\n@@ -867,6 +876,7 @@ async function createComponentTreeInternal(\n           currentParams,\n         })\n         forbiddenClientSegment = createErrorBoundaryClientSegmentRoot({\n+          ctx,\n           ErrorBoundaryComponent: Forbidden,\n           errorElement: forbiddenElement,\n           ClientSegmentRoot,\n@@ -875,6 +885,7 @@ async function createComponentTreeInternal(\n           currentParams,\n         })\n         unauthorizedClientSegment = createErrorBoundaryClientSegmentRoot({\n+          ctx,\n           ErrorBoundaryComponent: Unauthorized,\n           errorElement: unauthorizedElement,\n           ClientSegmentRoot,\n@@ -887,31 +898,35 @@ async function createComponentTreeInternal(\n           forbiddenClientSegment ||\n           unauthorizedClientSegment\n         ) {\n-          segmentNode = (\n-            <HTTPAccessFallbackBoundary\n-              key={cacheNodeKey}\n-              notFound={notfoundClientSegment}\n-              forbidden={forbiddenClientSegment}\n-              unauthorized={unauthorizedClientSegment}\n-            >\n-              {layerAssets}\n-              {clientSegment}\n-            </HTTPAccessFallbackBoundary>\n+          segmentNode = createElement(\n+            HTTPAccessFallbackBoundary,\n+            {\n+              key: cacheNodeKey,\n+              notFound: notfoundClientSegment,\n+              forbidden: forbiddenClientSegment,\n+              unauthorized: unauthorizedClientSegment,\n+            },\n+            layerAssets,\n+            clientSegment\n           )\n         } else {\n-          segmentNode = (\n-            <React.Fragment key={cacheNodeKey}>\n-              {layerAssets}\n-              {clientSegment}\n-            </React.Fragment>\n+          segmentNode = createElement(\n+            Fragment,\n+            {\n+              key: cacheNodeKey,\n+            },\n+            layerAssets,\n+            clientSegment\n           )\n         }\n       } else {\n-        segmentNode = (\n-          <React.Fragment key={cacheNodeKey}>\n-            {layerAssets}\n-            {clientSegment}\n-          </React.Fragment>\n+        segmentNode = createElement(\n+          Fragment,\n+          {\n+            key: cacheNodeKey,\n+          },\n+          layerAssets,\n+          clientSegment\n         )\n       }\n     } else {\n@@ -923,19 +938,30 @@ async function createComponentTreeInternal(\n       let serverSegment: React.ReactNode\n \n       if (isUseCacheFunction(SegmentComponent)) {\n-        const UseCacheLayoutComponent: React.ComponentType<UseCacheLayoutProps> =\n+        const UseCacheLayoutComponent: ComponentType<UseCacheLayoutProps> =\n           SegmentComponent\n \n-        serverSegment = (\n-          <UseCacheLayoutComponent\n-            {...parallelRouteProps}\n-            params={params}\n-            $$isLayout\n-          />\n+        serverSegment = createElement(\n+          UseCacheLayoutComponent,\n+          {\n+            ...parallelRouteProps,\n+            params: params,\n+            $$isLayout: true,\n+          },\n+          // Force static children here so that they're validated.\n+          // See https://github.com/facebook/react/pull/34846\n+          parallelRouteProps.children\n         )\n       } else {\n-        serverSegment = (\n-          <SegmentComponent {...parallelRouteProps} params={params} />\n+        serverSegment = createElement(\n+          SegmentComponent,\n+          {\n+            ...parallelRouteProps,\n+            params: params,\n+          },\n+          // Force static children here so that they're validated.\n+          // See https://github.com/facebook/react/pull/34846\n+          parallelRouteProps.children\n         )\n       }\n \n@@ -945,44 +971,54 @@ async function createComponentTreeInternal(\n         // but it's not ideal, as it needlessly invokes the `NotFound` component and renders the `RootLayout` twice.\n         // We should instead look into handling the fallback behavior differently in development mode so that it doesn't\n         // rely on the `NotFound` behavior.\n-        segmentNode = (\n-          <HTTPAccessFallbackBoundary\n-            key={cacheNodeKey}\n-            notFound={\n-              notFoundElement ? (\n-                <>\n-                  {layerAssets}\n-                  <SegmentComponent params={params}>\n-                    {notFoundStyles}\n-                    {notFoundElement}\n-                  </SegmentComponent>\n-                </>\n-              ) : undefined\n-            }\n-          >\n-            {layerAssets}\n-            {serverSegment}\n-          </HTTPAccessFallbackBoundary>\n+        segmentNode = createElement(\n+          HTTPAccessFallbackBoundary,\n+          {\n+            key: cacheNodeKey,\n+            notFound: notFoundElement\n+              ? createElement(\n+                  Fragment,\n+                  null,\n+                  layerAssets,\n+                  createElement(\n+                    SegmentComponent,\n+                    {\n+                      params: params,\n+                    },\n+                    notFoundStyles,\n+                    notFoundElement\n+                  )\n+                )\n+              : undefined,\n+          },\n+          layerAssets,\n+          serverSegment\n         )\n       } else {\n-        segmentNode = (\n-          <React.Fragment key={cacheNodeKey}>\n-            {layerAssets}\n-            {serverSegment}\n-          </React.Fragment>\n+        segmentNode = createElement(\n+          Fragment,\n+          {\n+            key: cacheNodeKey,\n+          },\n+          layerAssets,\n+          serverSegment\n         )\n       }\n     }\n \n     const layoutFilePath = getConventionPathByType(tree, dir, 'layout')\n     const wrappedSegmentNode =\n-      isSegmentViewEnabled && layoutFilePath ? (\n-        <SegmentViewNode key=\"layout\" type=\"layout\" pagePath={layoutFilePath}>\n-          {segmentNode}\n-        </SegmentViewNode>\n-      ) : (\n-        segmentNode\n-      )\n+      isSegmentViewEnabled && layoutFilePath\n+        ? createElement(\n+            SegmentViewNode,\n+            {\n+              key: 'layout',\n+              type: 'layout',\n+              pagePath: layoutFilePath,\n+            },\n+            segmentNode\n+          )\n+        : segmentNode\n \n     // For layouts we just render the component\n     return [\n@@ -997,33 +1033,38 @@ async function createComponentTreeInternal(\n }\n \n function createErrorBoundaryClientSegmentRoot({\n+  ctx,\n   ErrorBoundaryComponent,\n   errorElement,\n   ClientSegmentRoot,\n   layerAssets,\n   SegmentComponent,\n   currentParams,\n }: {\n-  ErrorBoundaryComponent: React.ComponentType<any> | undefined\n+  ctx: AppRenderContext\n+  ErrorBoundaryComponent: ComponentType<any> | undefined\n   errorElement: React.ReactNode\n-  ClientSegmentRoot: React.ComponentType<any>\n+  ClientSegmentRoot: ComponentType<any>\n   layerAssets: React.ReactNode\n-  SegmentComponent: React.ComponentType<any>\n+  SegmentComponent: ComponentType<any>\n   currentParams: Params\n }) {\n+  const {\n+    componentMod: { createElement, Fragment },\n+  } = ctx\n   if (ErrorBoundaryComponent) {\n     const notFoundParallelRouteProps = {\n       children: errorElement,\n     }\n-    return (\n-      <>\n-        {layerAssets}\n-        <ClientSegmentRoot\n-          Component={SegmentComponent}\n-          slots={notFoundParallelRouteProps}\n-          params={currentParams}\n-        />\n-      </>\n+    return createElement(\n+      Fragment,\n+      null,\n+      layerAssets,\n+      createElement(ClientSegmentRoot, {\n+        Component: SegmentComponent,\n+        slots: notFoundParallelRouteProps,\n+        params: currentParams,\n+      })\n     )\n   }\n   return null\n@@ -1095,37 +1136,39 @@ async function createBoundaryConventionElement({\n     | 'loading'\n     | 'forbidden'\n     | 'unauthorized'\n-  Component: React.ComponentType<any> | undefined\n+  Component: ComponentType<any> | undefined\n   styles: React.ReactNode | undefined\n   tree: LoaderTree\n }) {\n+  const {\n+    componentMod: { createElement, Fragment },\n+  } = ctx\n   const isSegmentViewEnabled = !!ctx.renderOpts.dev\n   const dir =\n     (process.env.NEXT_RUNTIME === 'edge'\n       ? process.env.__NEXT_EDGE_PROJECT_DIR\n       : ctx.renderOpts.dir) || ''\n   const { SegmentViewNode } = ctx.componentMod\n-  const element = Component ? (\n-    <>\n-      <Component />\n-      {styles}\n-    </>\n-  ) : undefined\n+  const element = Component\n+    ? createElement(Fragment, null, createElement(Component, null), styles)\n+    : undefined\n \n   const pagePath = getConventionPathByType(tree, dir, conventionName)\n \n   const wrappedElement =\n-    isSegmentViewEnabled && element ? (\n-      <SegmentViewNode\n-        key={cacheNodeKey + '-' + conventionName}\n-        type={conventionName}\n-        pagePath={pagePath!}\n-      >\n-        {element}\n-      </SegmentViewNode>\n-    ) : (\n-      element\n-    )\n+    isSegmentViewEnabled && element\n+      ? createElement(\n+          SegmentViewNode,\n+          {\n+            key: cacheNodeKey + '-' + conventionName,\n+            type: conventionName,\n+            // TODO: Discovered when moving to `createElement`.\n+            // `SegmentViewNode` doesn't support undefined `pagePath`\n+            pagePath: pagePath!,\n+          },\n+          element\n+        )\n+      : element\n \n   return [wrappedElement, pagePath] as const\n }"
        },
        {
            "sha": "eb6f089bcb614a9ad9e3bf8d1c978f19b50b766f",
            "filename": "packages/next/src/server/app-render/entry-base.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fentry-base.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fentry-base.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fentry-base.ts?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -10,7 +10,8 @@ export {\n // eslint-disable-next-line import/no-extraneous-dependencies\n export { prerender } from 'react-server-dom-webpack/static'\n \n-export { captureOwnerStack } from 'react'\n+// TODO: Just re-export `* as ReactServer`\n+export { captureOwnerStack, createElement, Fragment } from 'react'\n \n export { default as LayoutRouter } from '../../client/components/layout-router'\n export { default as RenderFromTemplateContext } from '../../client/components/render-from-template-context'"
        },
        {
            "sha": "2e0eb9c400ae8e7396a84491edd92459ae1a46eb",
            "filename": "packages/next/src/server/app-render/get-layer-assets.tsx",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fget-layer-assets.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fget-layer-assets.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fget-layer-assets.tsx?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -1,4 +1,3 @@\n-import React from 'react'\n import { getLinkAndScriptTags } from './get-css-inlined-link-tags'\n import { getPreloadableFonts } from './get-preloadable-fonts'\n import type { AppRenderContext } from './app-render'\n@@ -22,6 +21,9 @@ export function getLayerAssets({\n   ctx: AppRenderContext\n   preloadCallbacks: PreloadCallbacks\n }): React.ReactNode {\n+  const {\n+    componentMod: { createElement },\n+  } = ctx\n   const { styles: styleTags, scripts: scriptTags } = layoutOrPagePath\n     ? getLinkAndScriptTags(\n         ctx.clientReferenceManifest,\n@@ -81,14 +83,12 @@ export function getLayerAssets({\n           href\n         )}${getAssetQueryString(ctx, true)}`\n \n-        return (\n-          <script\n-            src={fullSrc}\n-            async={true}\n-            key={`script-${index}`}\n-            nonce={ctx.nonce}\n-          />\n-        )\n+        return createElement('script', {\n+          src: fullSrc,\n+          async: true,\n+          key: `script-${index}`,\n+          nonce: ctx.nonce,\n+        })\n       })\n     : []\n "
        },
        {
            "sha": "977157960bba846f46add79db49c326fc3dc7318",
            "filename": "packages/next/src/server/app-render/make-get-server-inserted-html.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fmake-get-server-inserted-html.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fmake-get-server-inserted-html.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fmake-get-server-inserted-html.tsx?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -1,3 +1,4 @@\n+/* eslint-disable @next/internal/no-ambiguous-jsx -- whole module is used in React Client */\n import React, { type JSX } from 'react'\n import { isHTTPAccessFallbackError } from '../../client/components/http-access-fallback/http-access-fallback'\n import {"
        },
        {
            "sha": "589bf23b9561b1fd37cab57ca6ffe8cb5fada082",
            "filename": "packages/next/src/server/app-render/render-css-resource.tsx",
            "status": "modified",
            "additions": 20,
            "deletions": 21,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Frender-css-resource.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Frender-css-resource.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Frender-css-resource.tsx?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -14,6 +14,9 @@ export function renderCssResource(\n   ctx: AppRenderContext,\n   preloadCallbacks?: PreloadCallbacks\n ) {\n+  const {\n+    componentMod: { createElement },\n+  } = ctx\n   return entryCssFiles.map((entryCssFile, index) => {\n     // `Precedence` is an opt-in signal for React to handle resource\n     // loading and deduplication, etc. It's also used as the key to sort\n@@ -37,16 +40,15 @@ export function renderCssResource(\n     )}${getAssetQueryString(ctx, true)}`\n \n     if (entryCssFile.inlined && !ctx.parsedRequestHeaders.isRSCRequest) {\n-      return (\n-        <style\n-          key={index}\n-          nonce={ctx.nonce}\n-          // @ts-ignore\n-          precedence={precedence}\n-          href={fullHref}\n-        >\n-          {entryCssFile.content}\n-        </style>\n+      return createElement(\n+        'style',\n+        {\n+          key: index,\n+          nonce: ctx.nonce,\n+          precedence: precedence,\n+          href: fullHref,\n+        },\n+        entryCssFile.content\n       )\n     }\n \n@@ -58,16 +60,13 @@ export function renderCssResource(\n       )\n     })\n \n-    return (\n-      <link\n-        key={index}\n-        rel=\"stylesheet\"\n-        href={fullHref}\n-        // @ts-ignore\n-        precedence={precedence}\n-        crossOrigin={ctx.renderOpts.crossOrigin}\n-        nonce={ctx.nonce}\n-      />\n-    )\n+    return createElement('link', {\n+      key: index,\n+      rel: 'stylesheet',\n+      href: fullHref,\n+      precedence: precedence,\n+      crossOrigin: ctx.renderOpts.crossOrigin,\n+      nonce: ctx.nonce,\n+    })\n   })\n }"
        },
        {
            "sha": "a2da00a909b5bcc065fb49d56d2e6e358a6b0297",
            "filename": "packages/next/src/server/app-render/server-inserted-html.tsx",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fserver-inserted-html.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fserver-inserted-html.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fserver-inserted-html.tsx?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -1,12 +1,14 @@\n+/* eslint-disable @next/internal/no-ambiguous-jsx -- whole module is used in React Client */\n // Provider for the `useServerInsertedHTML` API to register callbacks to insert\n // elements into the HTML stream.\n \n-import React, { type JSX } from 'react'\n+import type { JSX, ReactNode } from 'react'\n+import * as ReactClient from 'react'\n import { ServerInsertedHTMLContext } from '../../shared/lib/server-inserted-html.shared-runtime'\n \n export function createServerInsertedHTML() {\n-  const serverInsertedHTMLCallbacks: (() => React.ReactNode)[] = []\n-  const addInsertedHtml = (handler: () => React.ReactNode) => {\n+  const serverInsertedHTMLCallbacks: (() => ReactNode)[] = []\n+  const addInsertedHtml = (handler: () => ReactNode) => {\n     serverInsertedHTMLCallbacks.push(handler)\n   }\n \n@@ -20,9 +22,9 @@ export function createServerInsertedHTML() {\n     },\n     renderServerInsertedHTML() {\n       return serverInsertedHTMLCallbacks.map((callback, index) => (\n-        <React.Fragment key={'__next_server_inserted__' + index}>\n+        <ReactClient.Fragment key={'__next_server_inserted__' + index}>\n           {callback()}\n-        </React.Fragment>\n+        </ReactClient.Fragment>\n       ))\n     },\n   }"
        },
        {
            "sha": "f867c3dc63bb8416ef01dde6c82fe3f88574b9dc",
            "filename": "packages/next/src/server/render.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Frender.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/718141176db250839ae2f493d8cac7637f22290c/packages%2Fnext%2Fsrc%2Fserver%2Frender.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frender.tsx?ref=718141176db250839ae2f493d8cac7637f22290c",
            "patch": "@@ -1,3 +1,4 @@\n+/* eslint-disable @next/internal/no-ambiguous-jsx -- Pages router doesn't use react-server */\n import type { IncomingMessage, ServerResponse } from 'http'\n import type { ParsedUrlQuery } from 'querystring'\n import type { ReactDOMServerReadableStream } from 'react-dom/server'"
        }
    ],
    "stats": {
        "total": 903,
        "additions": 530,
        "deletions": 373
    }
}