{
    "author": "styfle",
    "message": "fix(next/image): handle empty buffer and experimental flag for `skipMetadata` (#82569)\n\nAs a follow up to PR https://github.com/vercel/next.js/pull/82538 this\nPR adds an experimental flag to optionally skip `sharp.metadata()` and\nrely only on the JS implementation for format detection.",
    "sha": "55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e",
    "files": [
        {
            "sha": "bdf39745317694a96ae72ffb51b13824f454d5fc",
            "filename": "packages/next/src/server/config-schema.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts?ref=55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e",
            "patch": "@@ -385,6 +385,7 @@ export const configSchema: zod.ZodType<NextConfig> = z.lazy(() =>\n         imgOptTimeoutInSeconds: z.number().int().optional(),\n         imgOptMaxInputPixels: z.number().int().optional(),\n         imgOptSequentialRead: z.boolean().optional().nullable(),\n+        imgOptSkipMetadata: z.boolean().optional().nullable(),\n         isrFlushToDisk: z.boolean().optional(),\n         largePageDataBytes: z.number().optional(),\n         linkNoTouchStart: z.boolean().optional(),"
        },
        {
            "sha": "c4d5acbf76987b177dd0b58deba363cfbe58bcfc",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e",
            "patch": "@@ -473,6 +473,7 @@ export interface ExperimentalConfig {\n   imgOptTimeoutInSeconds?: number\n   imgOptMaxInputPixels?: number\n   imgOptSequentialRead?: boolean | null\n+  imgOptSkipMetadata?: boolean | null\n   optimisticClientCache?: boolean\n   /**\n    * @deprecated use config.expireTime instead\n@@ -1526,6 +1527,7 @@ export const defaultConfig = Object.freeze({\n     imgOptTimeoutInSeconds: 7,\n     imgOptMaxInputPixels: 268_402_689, // https://sharp.pixelplumbing.com/api-constructor#:~:text=%5Boptions.limitInputPixels%5D\n     imgOptSequentialRead: null,\n+    imgOptSkipMetadata: null,\n     isrFlushToDisk: true,\n     workerThreads: false,\n     proxyTimeout: undefined,"
        },
        {
            "sha": "1d9f79b014a83df073ecb8fbe1e4337ee9c24ba6",
            "filename": "packages/next/src/server/image-optimizer.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 4,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e/packages%2Fnext%2Fsrc%2Fserver%2Fimage-optimizer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e/packages%2Fnext%2Fsrc%2Fserver%2Fimage-optimizer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fimage-optimizer.ts?ref=55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e",
            "patch": "@@ -158,8 +158,13 @@ async function writeToCacheDir(\n  * https://en.wikipedia.org/wiki/List_of_file_signatures\n  */\n export async function detectContentType(\n-  buffer: Buffer\n+  buffer: Buffer,\n+  skipMetadata: boolean | null | undefined,\n+  concurrency?: number | null | undefined\n ): Promise<string | null> {\n+  if (buffer.byteLength === 0) {\n+    return null\n+  }\n   if ([0xff, 0xd8, 0xff].every((b, i) => buffer[i] === b)) {\n     return JPEG\n   }\n@@ -239,8 +244,8 @@ export async function detectContentType(\n     | undefined\n   format = detector(buffer)\n \n-  if (!format) {\n-    const sharp = getSharp(null)\n+  if (!format && !skipMetadata) {\n+    const sharp = getSharp(concurrency)\n     const meta = await sharp(buffer)\n       .metadata()\n       .catch((_) => null)\n@@ -776,6 +781,7 @@ export async function imageOptimizer(\n       | 'imgOptConcurrency'\n       | 'imgOptMaxInputPixels'\n       | 'imgOptSequentialRead'\n+      | 'imgOptSkipMetadata'\n       | 'imgOptTimeoutInSeconds'\n     >\n     images: Pick<\n@@ -803,7 +809,11 @@ export async function imageOptimizer(\n     getMaxAge(imageUpstream.cacheControl)\n   )\n \n-  const upstreamType = await detectContentType(upstreamBuffer)\n+  const upstreamType = await detectContentType(\n+    upstreamBuffer,\n+    nextConfig.experimental.imgOptSkipMetadata,\n+    nextConfig.experimental.imgOptConcurrency\n+  )\n \n   if (\n     !upstreamType ||"
        },
        {
            "sha": "b2f935bddd310fb39ef659bbb0bb324b6a3f33f8",
            "filename": "test/unit/image-optimizer/detect-content-type.test.ts",
            "status": "modified",
            "additions": 126,
            "deletions": 76,
            "changes": 202,
            "blob_url": "https://github.com/vercel/next.js/blob/55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e/test%2Funit%2Fimage-optimizer%2Fdetect-content-type.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e/test%2Funit%2Fimage-optimizer%2Fdetect-content-type.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Funit%2Fimage-optimizer%2Fdetect-content-type.test.ts?ref=55f705f1ab8e50d9012a4e0b88b8277fbdc85d8e",
            "patch": "@@ -5,79 +5,129 @@ import { join } from 'path'\n \n const getImage = (filepath) => readFile(join(__dirname, filepath))\n \n-describe('detectContentType', () => {\n-  it('should return jpg', async () => {\n-    const buffer = await getImage('./images/test.jpg')\n-    expect(await detectContentType(buffer)).toBe('image/jpeg')\n-  })\n-  it('should return png', async () => {\n-    const buffer = await getImage('./images/test.png')\n-    expect(await detectContentType(buffer)).toBe('image/png')\n-  })\n-  it('should return webp', async () => {\n-    const buffer = await getImage('./images/animated.webp')\n-    expect(await detectContentType(buffer)).toBe('image/webp')\n-  })\n-  it('should return svg', async () => {\n-    const buffer = await getImage('./images/test.svg')\n-    expect(await detectContentType(buffer)).toBe('image/svg+xml')\n-  })\n-  it('should return svg for inline svg', async () => {\n-    const buffer = await getImage('./images/test-inline.svg')\n-    expect(await detectContentType(buffer)).toBe('image/svg+xml')\n-  })\n-  it('should return svg when starts with space', async () => {\n-    const buffer = Buffer.from(\n-      ' <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\"></svg>'\n-    )\n-    expect(await detectContentType(buffer)).toBe('image/svg+xml')\n-  })\n-  it('should return svg when starts with newline', async () => {\n-    const buffer = Buffer.from(\n-      '\\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\"></svg>'\n-    )\n-    expect(await detectContentType(buffer)).toBe('image/svg+xml')\n-  })\n-  it('should return svg when starts with tab', async () => {\n-    const buffer = Buffer.from(\n-      '\\t<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\"></svg>'\n-    )\n-    expect(await detectContentType(buffer)).toBe('image/svg+xml')\n-  })\n-  it('should return avif', async () => {\n-    const buffer = await getImage('./images/test.avif')\n-    expect(await detectContentType(buffer)).toBe('image/avif')\n-  })\n-  it('should return icon', async () => {\n-    const buffer = await getImage('./images/test.ico')\n-    expect(await detectContentType(buffer)).toBe('image/x-icon')\n-  })\n-  it('should return icns', async () => {\n-    const buffer = await getImage('./images/test.icns')\n-    expect(await detectContentType(buffer)).toBe('image/x-icns')\n-  })\n-  it('should return jxl', async () => {\n-    const buffer = await getImage('./images/test.jxl')\n-    expect(await detectContentType(buffer)).toBe('image/jxl')\n-  })\n-  it('should return jp2', async () => {\n-    const buffer = await getImage('./images/test.jp2')\n-    expect(await detectContentType(buffer)).toBe('image/jp2')\n-  })\n-  it('should return heic', async () => {\n-    const buffer = await getImage('./images/test.heic')\n-    expect(await detectContentType(buffer)).toBe('image/heic')\n-  })\n-  it('should return pdf', async () => {\n-    const buffer = await getImage('./images/test.pdf')\n-    expect(await detectContentType(buffer)).toBe('application/pdf')\n-  })\n-  it('should return tiff', async () => {\n-    const buffer = await getImage('./images/test.tiff')\n-    expect(await detectContentType(buffer)).toBe('image/tiff')\n-  })\n-  it('should return bmp', async () => {\n-    const buffer = await getImage('./images/test.bmp')\n-    expect(await detectContentType(buffer)).toBe('image/bmp')\n-  })\n-})\n+describe.each([false, true])(\n+  'detectContentType with imgOptSkipMetadata: %s',\n+  (imgOptSkipMetadata) => {\n+    it('should return null for empty buffer', async () => {\n+      expect(await detectContentType(Buffer.alloc(0), imgOptSkipMetadata)).toBe(\n+        null\n+      )\n+    })\n+    it('should return null for unrecognized buffer', async () => {\n+      expect(\n+        await detectContentType(\n+          Buffer.from([0xa, 0xb, 0xc]),\n+          imgOptSkipMetadata\n+        )\n+      ).toBe(null)\n+    })\n+    it('should return jpg', async () => {\n+      const buffer = await getImage('./images/test.jpg')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/jpeg'\n+      )\n+    })\n+    it('should return png', async () => {\n+      const buffer = await getImage('./images/test.png')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/png'\n+      )\n+    })\n+    it('should return webp', async () => {\n+      const buffer = await getImage('./images/animated.webp')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/webp'\n+      )\n+    })\n+    it('should return svg', async () => {\n+      const buffer = await getImage('./images/test.svg')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/svg+xml'\n+      )\n+    })\n+    it('should return svg for inline svg', async () => {\n+      const buffer = await getImage('./images/test-inline.svg')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/svg+xml'\n+      )\n+    })\n+    it('should return svg when starts with space', async () => {\n+      const buffer = Buffer.from(\n+        ' <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\"></svg>'\n+      )\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/svg+xml'\n+      )\n+    })\n+    it('should return svg when starts with newline', async () => {\n+      const buffer = Buffer.from(\n+        '\\n<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\"></svg>'\n+      )\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/svg+xml'\n+      )\n+    })\n+    it('should return svg when starts with tab', async () => {\n+      const buffer = Buffer.from(\n+        '\\t<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 1 1\"></svg>'\n+      )\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/svg+xml'\n+      )\n+    })\n+    it('should return avif', async () => {\n+      const buffer = await getImage('./images/test.avif')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/avif'\n+      )\n+    })\n+    it('should return icon', async () => {\n+      const buffer = await getImage('./images/test.ico')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/x-icon'\n+      )\n+    })\n+    it('should return icns', async () => {\n+      const buffer = await getImage('./images/test.icns')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/x-icns'\n+      )\n+    })\n+    it('should return jxl', async () => {\n+      const buffer = await getImage('./images/test.jxl')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/jxl'\n+      )\n+    })\n+    it('should return jp2', async () => {\n+      const buffer = await getImage('./images/test.jp2')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/jp2'\n+      )\n+    })\n+    it('should return heic', async () => {\n+      const buffer = await getImage('./images/test.heic')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/heic'\n+      )\n+    })\n+    it('should return pdf', async () => {\n+      const buffer = await getImage('./images/test.pdf')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'application/pdf'\n+      )\n+    })\n+    it('should return tiff', async () => {\n+      const buffer = await getImage('./images/test.tiff')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/tiff'\n+      )\n+    })\n+    it('should return bmp', async () => {\n+      const buffer = await getImage('./images/test.bmp')\n+      expect(await detectContentType(buffer, imgOptSkipMetadata)).toBe(\n+        'image/bmp'\n+      )\n+    })\n+  }\n+)"
        }
    ],
    "stats": {
        "total": 223,
        "additions": 143,
        "deletions": 80
    }
}