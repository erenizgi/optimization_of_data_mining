{
    "author": "nextjs-bot",
    "message": "Upgrade React from `548235db-20251001` to `1bd1f01f-20251001` (#84417)\n\n\n\nCo-authored-by: Sebastian Sebbie Silbermann <sebastian.silbermann@vercel.com>",
    "sha": "2386cb91d23d56afdd21f631824f8ccc8b1c0151",
    "files": [
        {
            "sha": "bd81ce24b693ac4e357b253ebd1cb855ddf38427",
            "filename": "package.json",
            "status": "modified",
            "additions": 20,
            "deletions": 20,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/package.json",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/package.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/package.json?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -142,8 +142,8 @@\n     \"@types/jest\": \"29.5.5\",\n     \"@types/node\": \"20.17.6\",\n     \"@types/node-fetch\": \"2.6.1\",\n-    \"@types/react\": \"19.1.14\",\n-    \"@types/react-dom\": \"19.1.7\",\n+    \"@types/react\": \"19.1.16\",\n+    \"@types/react-dom\": \"19.1.10\",\n     \"@types/relay-runtime\": \"14.1.13\",\n     \"@types/string-hash\": \"1.1.1\",\n     \"@types/trusted-types\": \"2.0.3\",\n@@ -178,7 +178,7 @@\n     \"eslint-plugin-jsdoc\": \"48.0.4\",\n     \"eslint-plugin-mdx\": \"3.1.5\",\n     \"eslint-plugin-react\": \"7.35.0\",\n-    \"eslint-plugin-react-hooks\": \"0.0.0-experimental-548235db-20251001\",\n+    \"eslint-plugin-react-hooks\": \"0.0.0-experimental-1bd1f01f-20251001\",\n     \"eslint-v8\": \"npm:eslint@^8.57.0\",\n     \"event-stream\": \"4.0.1\",\n     \"execa\": \"2.0.3\",\n@@ -238,16 +238,16 @@\n     \"pretty-ms\": \"7.0.0\",\n     \"random-seed\": \"0.3.0\",\n     \"react\": \"19.0.0\",\n-    \"react-builtin\": \"npm:react@19.2.0-canary-548235db-20251001\",\n+    \"react-builtin\": \"npm:react@19.2.0-canary-1bd1f01f-20251001\",\n     \"react-dom\": \"19.0.0\",\n-    \"react-dom-builtin\": \"npm:react-dom@19.2.0-canary-548235db-20251001\",\n-    \"react-dom-experimental-builtin\": \"npm:react-dom@0.0.0-experimental-548235db-20251001\",\n-    \"react-experimental-builtin\": \"npm:react@0.0.0-experimental-548235db-20251001\",\n-    \"react-is-builtin\": \"npm:react-is@19.2.0-canary-548235db-20251001\",\n-    \"react-server-dom-turbopack\": \"19.2.0-canary-548235db-20251001\",\n-    \"react-server-dom-turbopack-experimental\": \"npm:react-server-dom-turbopack@0.0.0-experimental-548235db-20251001\",\n-    \"react-server-dom-webpack\": \"19.2.0-canary-548235db-20251001\",\n-    \"react-server-dom-webpack-experimental\": \"npm:react-server-dom-webpack@0.0.0-experimental-548235db-20251001\",\n+    \"react-dom-builtin\": \"npm:react-dom@19.2.0-canary-1bd1f01f-20251001\",\n+    \"react-dom-experimental-builtin\": \"npm:react-dom@0.0.0-experimental-1bd1f01f-20251001\",\n+    \"react-experimental-builtin\": \"npm:react@0.0.0-experimental-1bd1f01f-20251001\",\n+    \"react-is-builtin\": \"npm:react-is@19.2.0-canary-1bd1f01f-20251001\",\n+    \"react-server-dom-turbopack\": \"19.2.0-canary-1bd1f01f-20251001\",\n+    \"react-server-dom-turbopack-experimental\": \"npm:react-server-dom-turbopack@0.0.0-experimental-1bd1f01f-20251001\",\n+    \"react-server-dom-webpack\": \"19.2.0-canary-1bd1f01f-20251001\",\n+    \"react-server-dom-webpack-experimental\": \"npm:react-server-dom-webpack@0.0.0-experimental-1bd1f01f-20251001\",\n     \"react-ssr-prepass\": \"1.0.8\",\n     \"react-virtualized\": \"9.22.3\",\n     \"relay-compiler\": \"13.0.2\",\n@@ -257,8 +257,8 @@\n     \"resolve-from\": \"5.0.0\",\n     \"sass\": \"1.54.0\",\n     \"satori\": \"0.15.2\",\n-    \"scheduler-builtin\": \"npm:scheduler@0.27.0-canary-548235db-20251001\",\n-    \"scheduler-experimental-builtin\": \"npm:scheduler@0.0.0-experimental-548235db-20251001\",\n+    \"scheduler-builtin\": \"npm:scheduler@0.27.0-canary-1bd1f01f-20251001\",\n+    \"scheduler-experimental-builtin\": \"npm:scheduler@0.0.0-experimental-1bd1f01f-20251001\",\n     \"seedrandom\": \"3.0.5\",\n     \"semver\": \"7.3.7\",\n     \"serve-handler\": \"6.1.6\",\n@@ -298,14 +298,14 @@\n       \"@babel/parser\": \"7.27.0\",\n       \"@babel/types\": \"7.27.0\",\n       \"@babel/traverse\": \"7.27.0\",\n-      \"@types/react\": \"19.1.14\",\n-      \"@types/react-dom\": \"19.1.7\",\n+      \"@types/react\": \"19.1.16\",\n+      \"@types/react-dom\": \"19.1.10\",\n       \"@types/retry\": \"0.12.0\",\n       \"jest-snapshot\": \"30.0.0-alpha.6\",\n-      \"react\": \"19.2.0-canary-548235db-20251001\",\n-      \"react-dom\": \"19.2.0-canary-548235db-20251001\",\n-      \"react-is\": \"19.2.0-canary-548235db-20251001\",\n-      \"scheduler\": \"0.27.0-canary-548235db-20251001\"\n+      \"react\": \"19.2.0-canary-1bd1f01f-20251001\",\n+      \"react-dom\": \"19.2.0-canary-1bd1f01f-20251001\",\n+      \"react-is\": \"19.2.0-canary-1bd1f01f-20251001\",\n+      \"scheduler\": \"0.27.0-canary-1bd1f01f-20251001\"\n     },\n     \"packageExtensions\": {\n       \"eslint-plugin-react-hooks@0.0.0-experimental-6de32a5a-20250822\": {"
        },
        {
            "sha": "87375b0fc9495c7f18d09cb2d6657738b50cbdc0",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-client.development.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-client.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-client.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-client.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -32260,11 +32260,11 @@\n     };\n     (function () {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.2.0-experimental-548235db-20251001\" !== isomorphicReactPackageVersion)\n+      if (\"19.2.0-experimental-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.2.0-experimental-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.2.0-experimental-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     })();\n     (\"function\" === typeof Map &&\n@@ -32301,10 +32301,10 @@\n       !(function () {\n         var internals = {\n           bundleType: 1,\n-          version: \"19.2.0-experimental-548235db-20251001\",\n+          version: \"19.2.0-experimental-1bd1f01f-20251001\",\n           rendererPackageName: \"react-dom\",\n           currentDispatcherRef: ReactSharedInternals,\n-          reconcilerVersion: \"19.2.0-experimental-548235db-20251001\"\n+          reconcilerVersion: \"19.2.0-experimental-1bd1f01f-20251001\"\n         };\n         internals.overrideHookState = overrideHookState;\n         internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n@@ -32452,7 +32452,7 @@\n       listenToAllSupportedEvents(container);\n       return new ReactDOMHydrationRoot(initialChildren);\n     };\n-    exports.version = \"19.2.0-experimental-548235db-20251001\";\n+    exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "2ed8934dcdfbf595752aba0f456669450e4f0d80",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-client.production.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-client.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-client.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-client.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -19566,14 +19566,14 @@ ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n };\n var isomorphicReactPackageVersion$jscomp$inline_2217 = React.version;\n if (\n-  \"19.2.0-experimental-548235db-20251001\" !==\n+  \"19.2.0-experimental-1bd1f01f-20251001\" !==\n   isomorphicReactPackageVersion$jscomp$inline_2217\n )\n   throw Error(\n     formatProdErrorMessage(\n       527,\n       isomorphicReactPackageVersion$jscomp$inline_2217,\n-      \"19.2.0-experimental-548235db-20251001\"\n+      \"19.2.0-experimental-1bd1f01f-20251001\"\n     )\n   );\n ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n@@ -19595,10 +19595,10 @@ ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n };\n var internals$jscomp$inline_2914 = {\n   bundleType: 0,\n-  version: \"19.2.0-experimental-548235db-20251001\",\n+  version: \"19.2.0-experimental-1bd1f01f-20251001\",\n   rendererPackageName: \"react-dom\",\n   currentDispatcherRef: ReactSharedInternals,\n-  reconcilerVersion: \"19.2.0-experimental-548235db-20251001\"\n+  reconcilerVersion: \"19.2.0-experimental-1bd1f01f-20251001\"\n };\n if (\"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n   var hook$jscomp$inline_2915 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n@@ -19705,4 +19705,4 @@ exports.hydrateRoot = function (container, initialChildren, options) {\n   listenToAllSupportedEvents(container);\n   return new ReactDOMHydrationRoot(initialChildren);\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";"
        },
        {
            "sha": "da9d370538a21847d48920bede765ad4953ce654",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-profiling.development.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-profiling.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-profiling.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-profiling.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -32312,11 +32312,11 @@\n     };\n     (function () {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.2.0-experimental-548235db-20251001\" !== isomorphicReactPackageVersion)\n+      if (\"19.2.0-experimental-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.2.0-experimental-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.2.0-experimental-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     })();\n     (\"function\" === typeof Map &&\n@@ -32353,10 +32353,10 @@\n       !(function () {\n         var internals = {\n           bundleType: 1,\n-          version: \"19.2.0-experimental-548235db-20251001\",\n+          version: \"19.2.0-experimental-1bd1f01f-20251001\",\n           rendererPackageName: \"react-dom\",\n           currentDispatcherRef: ReactSharedInternals,\n-          reconcilerVersion: \"19.2.0-experimental-548235db-20251001\"\n+          reconcilerVersion: \"19.2.0-experimental-1bd1f01f-20251001\"\n         };\n         internals.overrideHookState = overrideHookState;\n         internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n@@ -32834,7 +32834,7 @@\n     exports.useFormStatus = function () {\n       return resolveDispatcher().useHostTransitionStatus();\n     };\n-    exports.version = \"19.2.0-experimental-548235db-20251001\";\n+    exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "59c60ad25b27f5a2447b661e59578f2c0f740b7c",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-profiling.profiling.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-profiling.profiling.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-profiling.profiling.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-profiling.profiling.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -21606,14 +21606,14 @@ ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n };\n var isomorphicReactPackageVersion$jscomp$inline_2513 = React.version;\n if (\n-  \"19.2.0-experimental-548235db-20251001\" !==\n+  \"19.2.0-experimental-1bd1f01f-20251001\" !==\n   isomorphicReactPackageVersion$jscomp$inline_2513\n )\n   throw Error(\n     formatProdErrorMessage(\n       527,\n       isomorphicReactPackageVersion$jscomp$inline_2513,\n-      \"19.2.0-experimental-548235db-20251001\"\n+      \"19.2.0-experimental-1bd1f01f-20251001\"\n     )\n   );\n ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n@@ -21635,10 +21635,10 @@ ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n };\n var internals$jscomp$inline_3223 = {\n   bundleType: 0,\n-  version: \"19.2.0-experimental-548235db-20251001\",\n+  version: \"19.2.0-experimental-1bd1f01f-20251001\",\n   rendererPackageName: \"react-dom\",\n   currentDispatcherRef: ReactSharedInternals,\n-  reconcilerVersion: \"19.2.0-experimental-548235db-20251001\"\n+  reconcilerVersion: \"19.2.0-experimental-1bd1f01f-20251001\"\n };\n if (\"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n   var hook$jscomp$inline_3224 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n@@ -21906,7 +21906,7 @@ exports.useFormState = function (action, initialState, permalink) {\n exports.useFormStatus = function () {\n   return ReactSharedInternals.H.useHostTransitionStatus();\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n   \"function\" ===\n     typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "b234a34912caf72076b90000ec7f21cd9368ae96",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server-legacy.browser.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.browser.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -10543,5 +10543,5 @@\n         'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n       );\n     };\n-    exports.version = \"19.2.0-experimental-548235db-20251001\";\n+    exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "96dd14b51ff3beac58e8accaa34c45f7bd4e1461",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server-legacy.browser.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.browser.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7156,4 +7156,4 @@ exports.renderToString = function (children, options) {\n     'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n   );\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";"
        },
        {
            "sha": "bcfd7beec29d869c38c953e33616bbeb81ad704c",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server-legacy.node.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.node.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -10543,5 +10543,5 @@\n         'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server'\n       );\n     };\n-    exports.version = \"19.2.0-experimental-548235db-20251001\";\n+    exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "2578af6bc0e610716794697abb6748b0295c7313",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server-legacy.node.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server-legacy.node.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7259,4 +7259,4 @@ exports.renderToString = function (children, options) {\n     'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server'\n   );\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";"
        },
        {
            "sha": "bb69e36d30110ec0b51b176ccce6af4d3f0ba372",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.browser.development.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.browser.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -9536,11 +9536,11 @@\n     }\n     function ensureCorrectIsomorphicReactVersion() {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.2.0-experimental-548235db-20251001\" !== isomorphicReactPackageVersion)\n+      if (\"19.2.0-experimental-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.2.0-experimental-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.2.0-experimental-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     }\n     var React = require(\"next/dist/compiled/react-experimental\"),\n@@ -11364,5 +11364,5 @@\n         startWork(request);\n       });\n     };\n-    exports.version = \"19.2.0-experimental-548235db-20251001\";\n+    exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "59d12d12eaa9f205e22780757f1b0ce58b2fe802",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.browser.production.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.browser.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7827,12 +7827,12 @@ function getPostponedState(request) {\n }\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.2.0-experimental-548235db-20251001\" !== isomorphicReactPackageVersion)\n+  if (\"19.2.0-experimental-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n     throw Error(\n       formatProdErrorMessage(\n         527,\n         isomorphicReactPackageVersion,\n-        \"19.2.0-experimental-548235db-20251001\"\n+        \"19.2.0-experimental-1bd1f01f-20251001\"\n       )\n     );\n }\n@@ -8087,4 +8087,4 @@ exports.resumeAndPrerender = function (children, postponedState, options) {\n     startWork(request);\n   });\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";"
        },
        {
            "sha": "6fc50dc17f3a015f3b85658f4233cd5611e9e461",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.bun.production.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.bun.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.bun.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.bun.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7315,13 +7315,13 @@ function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n }\n var isomorphicReactPackageVersion$jscomp$inline_871 = React.version;\n if (\n-  \"19.2.0-experimental-548235db-20251001\" !==\n+  \"19.2.0-experimental-1bd1f01f-20251001\" !==\n   isomorphicReactPackageVersion$jscomp$inline_871\n )\n   throw Error(\n     'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n       (isomorphicReactPackageVersion$jscomp$inline_871 +\n-        \"\\n  - react-dom:  19.2.0-experimental-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+        \"\\n  - react-dom:  19.2.0-experimental-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n   );\n exports.renderToReadableStream = function (children, options) {\n   return new Promise(function (resolve, reject) {\n@@ -7412,4 +7412,4 @@ exports.renderToReadableStream = function (children, options) {\n     startWork(request);\n   });\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";"
        },
        {
            "sha": "e7f6572ccecb12ad87d666b22c8399a03bb09b81",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.edge.development.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.edge.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -9565,11 +9565,11 @@\n     }\n     function ensureCorrectIsomorphicReactVersion() {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.2.0-experimental-548235db-20251001\" !== isomorphicReactPackageVersion)\n+      if (\"19.2.0-experimental-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.2.0-experimental-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.2.0-experimental-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     }\n     var React = require(\"next/dist/compiled/react-experimental\"),\n@@ -11389,5 +11389,5 @@\n         startWork(request);\n       });\n     };\n-    exports.version = \"19.2.0-experimental-548235db-20251001\";\n+    exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "edb3ab74028e8e076b95c42ffd5c2d7ebd80ad7b",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.edge.production.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.edge.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7945,11 +7945,11 @@ function getPostponedState(request) {\n }\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.2.0-experimental-548235db-20251001\" !== isomorphicReactPackageVersion)\n+  if (\"19.2.0-experimental-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n     throw Error(\n       'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n         (isomorphicReactPackageVersion +\n-          \"\\n  - react-dom:  19.2.0-experimental-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+          \"\\n  - react-dom:  19.2.0-experimental-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n     );\n }\n ensureCorrectIsomorphicReactVersion();\n@@ -8203,4 +8203,4 @@ exports.resumeAndPrerender = function (children, postponedState, options) {\n     startWork(request);\n   });\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";"
        },
        {
            "sha": "4c8fd53e15b4d754179bc27d7f2d3db28ac4d3c3",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.node.development.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.node.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -9425,11 +9425,11 @@\n     }\n     function ensureCorrectIsomorphicReactVersion() {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.2.0-experimental-548235db-20251001\" !== isomorphicReactPackageVersion)\n+      if (\"19.2.0-experimental-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.2.0-experimental-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.2.0-experimental-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     }\n     function createDrainHandler(destination, request) {\n@@ -11559,5 +11559,5 @@\n         }\n       };\n     };\n-    exports.version = \"19.2.0-experimental-548235db-20251001\";\n+    exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "1bbb3931d3db0ed5180f149afee98fc346867b19",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-server.node.production.js",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-server.node.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7824,11 +7824,11 @@ function getPostponedState(request) {\n }\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.2.0-experimental-548235db-20251001\" !== isomorphicReactPackageVersion)\n+  if (\"19.2.0-experimental-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n     throw Error(\n       'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n         (isomorphicReactPackageVersion +\n-          \"\\n  - react-dom:  19.2.0-experimental-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+          \"\\n  - react-dom:  19.2.0-experimental-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n     );\n }\n ensureCorrectIsomorphicReactVersion();\n@@ -8386,4 +8386,4 @@ exports.resumeToPipeableStream = function (children, postponedState, options) {\n     }\n   };\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";"
        },
        {
            "sha": "ed1ce946dc0486f11360bccc683f11eb97a828b0",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-unstable_testing.development.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-unstable_testing.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-unstable_testing.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-unstable_testing.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -32581,11 +32581,11 @@\n     };\n     (function () {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.2.0-experimental-548235db-20251001\" !== isomorphicReactPackageVersion)\n+      if (\"19.2.0-experimental-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.2.0-experimental-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.2.0-experimental-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     })();\n     (\"function\" === typeof Map &&\n@@ -32622,10 +32622,10 @@\n       !(function () {\n         var internals = {\n           bundleType: 1,\n-          version: \"19.2.0-experimental-548235db-20251001\",\n+          version: \"19.2.0-experimental-1bd1f01f-20251001\",\n           rendererPackageName: \"react-dom\",\n           currentDispatcherRef: ReactSharedInternals,\n-          reconcilerVersion: \"19.2.0-experimental-548235db-20251001\"\n+          reconcilerVersion: \"19.2.0-experimental-1bd1f01f-20251001\"\n         };\n         internals.overrideHookState = overrideHookState;\n         internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n@@ -32939,5 +32939,5 @@\n         }\n       };\n     };\n-    exports.version = \"19.2.0-experimental-548235db-20251001\";\n+    exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "b79d3e914746d4bfd626bc53bb6c835f2a92a14d",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom-unstable_testing.production.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-unstable_testing.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-unstable_testing.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom-unstable_testing.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -19882,14 +19882,14 @@ ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n };\n var isomorphicReactPackageVersion$jscomp$inline_2246 = React.version;\n if (\n-  \"19.2.0-experimental-548235db-20251001\" !==\n+  \"19.2.0-experimental-1bd1f01f-20251001\" !==\n   isomorphicReactPackageVersion$jscomp$inline_2246\n )\n   throw Error(\n     formatProdErrorMessage(\n       527,\n       isomorphicReactPackageVersion$jscomp$inline_2246,\n-      \"19.2.0-experimental-548235db-20251001\"\n+      \"19.2.0-experimental-1bd1f01f-20251001\"\n     )\n   );\n ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n@@ -19911,10 +19911,10 @@ ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n };\n var internals$jscomp$inline_2948 = {\n   bundleType: 0,\n-  version: \"19.2.0-experimental-548235db-20251001\",\n+  version: \"19.2.0-experimental-1bd1f01f-20251001\",\n   rendererPackageName: \"react-dom\",\n   currentDispatcherRef: ReactSharedInternals,\n-  reconcilerVersion: \"19.2.0-experimental-548235db-20251001\"\n+  reconcilerVersion: \"19.2.0-experimental-1bd1f01f-20251001\"\n };\n if (\"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n   var hook$jscomp$inline_2949 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n@@ -20172,4 +20172,4 @@ exports.observeVisibleRects = function (\n     }\n   };\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";"
        },
        {
            "sha": "ca86388861870f1e7e4508e94e035049f6783157",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -416,7 +416,7 @@\n     exports.useFormStatus = function () {\n       return resolveDispatcher().useHostTransitionStatus();\n     };\n-    exports.version = \"19.2.0-experimental-548235db-20251001\";\n+    exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "c4f1c58105b2a55124a3d8d48a5924e851e08e54",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -207,4 +207,4 @@ exports.useFormState = function (action, initialState, permalink) {\n exports.useFormStatus = function () {\n   return ReactSharedInternals.H.useHostTransitionStatus();\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";"
        },
        {
            "sha": "7fec174616616d2ea478d22e2d32e487712e6920",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom.react-server.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.react-server.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.react-server.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.react-server.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -336,5 +336,5 @@\n             }))\n           : Internals.d.m(href));\n     };\n-    exports.version = \"19.2.0-experimental-548235db-20251001\";\n+    exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "94499219b511cd91a512e86d9709f470fe02cad5",
            "filename": "packages/next/src/compiled/react-dom-experimental/cjs/react-dom.react-server.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.react-server.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.react-server.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fcjs%2Freact-dom.react-server.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -149,4 +149,4 @@ exports.preloadModule = function (href, options) {\n       });\n     } else Internals.d.m(href);\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";"
        },
        {
            "sha": "f487b0c53e1dcd8b264ce20f2866a1e047f43099",
            "filename": "packages/next/src/compiled/react-dom-experimental/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fpackage.json?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -72,10 +72,10 @@\n     \"./package.json\": \"./package.json\"\n   },\n   \"dependencies\": {\n-    \"scheduler\": \"0.0.0-experimental-548235db-20251001\"\n+    \"scheduler\": \"0.0.0-experimental-1bd1f01f-20251001\"\n   },\n   \"peerDependencies\": {\n-    \"react\": \"0.0.0-experimental-548235db-20251001\"\n+    \"react\": \"0.0.0-experimental-1bd1f01f-20251001\"\n   },\n   \"browser\": {\n     \"./server.js\": \"./server.browser.js\","
        },
        {
            "sha": "4d8066527139f7e03489f03e473e54e0e5759094",
            "filename": "packages/next/src/compiled/react-dom-experimental/server.browser.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fserver.browser.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fserver.browser.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fserver.browser.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -13,6 +13,4 @@ exports.version = l.version;\n exports.renderToString = l.renderToString;\n exports.renderToStaticMarkup = l.renderToStaticMarkup;\n exports.renderToReadableStream = s.renderToReadableStream;\n-if (s.resume) {\n-  exports.resume = s.resume;\n-}\n+exports.resume = s.resume;"
        },
        {
            "sha": "cc05ed6120f4f4ba0fe8c43953b8436b44386117",
            "filename": "packages/next/src/compiled/react-dom-experimental/server.edge.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fserver.edge.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fserver.edge.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fserver.edge.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -14,6 +14,4 @@ exports.version = b.version;\n exports.renderToReadableStream = b.renderToReadableStream;\n exports.renderToString = l.renderToString;\n exports.renderToStaticMarkup = l.renderToStaticMarkup;\n-if (b.resume) {\n-  exports.resume = b.resume;\n-}\n+exports.resume = b.resume;"
        },
        {
            "sha": "3feeac208fe17bbfb6b84756b42388ca5caddcf3",
            "filename": "packages/next/src/compiled/react-dom-experimental/server.node.js",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fserver.node.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fserver.node.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom-experimental%2Fserver.node.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -14,9 +14,5 @@ exports.renderToString = l.renderToString;\n exports.renderToStaticMarkup = l.renderToStaticMarkup;\n exports.renderToPipeableStream = s.renderToPipeableStream;\n exports.renderToReadableStream = s.renderToReadableStream;\n-if (s.resumeToPipeableStream) {\n-  exports.resumeToPipeableStream = s.resumeToPipeableStream;\n-}\n-if (s.resume) {\n-  exports.resume = s.resume;\n-}\n+exports.resumeToPipeableStream = s.resumeToPipeableStream;\n+exports.resume = s.resume;"
        },
        {
            "sha": "d2b604bfc6dd90f4f06c4d224fbe8d227485045a",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-client.development.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-client.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-client.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-client.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -27921,11 +27921,11 @@\n     };\n     (function () {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.2.0-canary-548235db-20251001\" !== isomorphicReactPackageVersion)\n+      if (\"19.2.0-canary-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.2.0-canary-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.2.0-canary-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     })();\n     (\"function\" === typeof Map &&\n@@ -27962,10 +27962,10 @@\n       !(function () {\n         var internals = {\n           bundleType: 1,\n-          version: \"19.2.0-canary-548235db-20251001\",\n+          version: \"19.2.0-canary-1bd1f01f-20251001\",\n           rendererPackageName: \"react-dom\",\n           currentDispatcherRef: ReactSharedInternals,\n-          reconcilerVersion: \"19.2.0-canary-548235db-20251001\"\n+          reconcilerVersion: \"19.2.0-canary-1bd1f01f-20251001\"\n         };\n         internals.overrideHookState = overrideHookState;\n         internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n@@ -28103,7 +28103,7 @@\n       listenToAllSupportedEvents(container);\n       return new ReactDOMHydrationRoot(initialChildren);\n     };\n-    exports.version = \"19.2.0-canary-548235db-20251001\";\n+    exports.version = \"19.2.0-canary-1bd1f01f-20251001\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "6080ff1495be053e802a37b1b3f8989f53c7fba3",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-client.production.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-client.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-client.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-client.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -15916,14 +15916,14 @@ ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n };\n var isomorphicReactPackageVersion$jscomp$inline_1840 = React.version;\n if (\n-  \"19.2.0-canary-548235db-20251001\" !==\n+  \"19.2.0-canary-1bd1f01f-20251001\" !==\n   isomorphicReactPackageVersion$jscomp$inline_1840\n )\n   throw Error(\n     formatProdErrorMessage(\n       527,\n       isomorphicReactPackageVersion$jscomp$inline_1840,\n-      \"19.2.0-canary-548235db-20251001\"\n+      \"19.2.0-canary-1bd1f01f-20251001\"\n     )\n   );\n ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n@@ -15945,10 +15945,10 @@ ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n };\n var internals$jscomp$inline_2347 = {\n   bundleType: 0,\n-  version: \"19.2.0-canary-548235db-20251001\",\n+  version: \"19.2.0-canary-1bd1f01f-20251001\",\n   rendererPackageName: \"react-dom\",\n   currentDispatcherRef: ReactSharedInternals,\n-  reconcilerVersion: \"19.2.0-canary-548235db-20251001\"\n+  reconcilerVersion: \"19.2.0-canary-1bd1f01f-20251001\"\n };\n if (\"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n   var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n@@ -16046,4 +16046,4 @@ exports.hydrateRoot = function (container, initialChildren, options) {\n   listenToAllSupportedEvents(container);\n   return new ReactDOMHydrationRoot(initialChildren);\n };\n-exports.version = \"19.2.0-canary-548235db-20251001\";\n+exports.version = \"19.2.0-canary-1bd1f01f-20251001\";"
        },
        {
            "sha": "6cc6e97524bf591b6a7bfe88c019ef20cf281599",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-profiling.development.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-profiling.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-profiling.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-profiling.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -27973,11 +27973,11 @@\n     };\n     (function () {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.2.0-canary-548235db-20251001\" !== isomorphicReactPackageVersion)\n+      if (\"19.2.0-canary-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.2.0-canary-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.2.0-canary-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     })();\n     (\"function\" === typeof Map &&\n@@ -28014,10 +28014,10 @@\n       !(function () {\n         var internals = {\n           bundleType: 1,\n-          version: \"19.2.0-canary-548235db-20251001\",\n+          version: \"19.2.0-canary-1bd1f01f-20251001\",\n           rendererPackageName: \"react-dom\",\n           currentDispatcherRef: ReactSharedInternals,\n-          reconcilerVersion: \"19.2.0-canary-548235db-20251001\"\n+          reconcilerVersion: \"19.2.0-canary-1bd1f01f-20251001\"\n         };\n         internals.overrideHookState = overrideHookState;\n         internals.overrideHookStateDeletePath = overrideHookStateDeletePath;\n@@ -28485,7 +28485,7 @@\n     exports.useFormStatus = function () {\n       return resolveDispatcher().useHostTransitionStatus();\n     };\n-    exports.version = \"19.2.0-canary-548235db-20251001\";\n+    exports.version = \"19.2.0-canary-1bd1f01f-20251001\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "dc8de15e843a07ca5749d5310a4eff65fec23bfe",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-profiling.profiling.js",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-profiling.profiling.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-profiling.profiling.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-profiling.profiling.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -17759,14 +17759,14 @@ ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n };\n var isomorphicReactPackageVersion$jscomp$inline_2138 = React.version;\n if (\n-  \"19.2.0-canary-548235db-20251001\" !==\n+  \"19.2.0-canary-1bd1f01f-20251001\" !==\n   isomorphicReactPackageVersion$jscomp$inline_2138\n )\n   throw Error(\n     formatProdErrorMessage(\n       527,\n       isomorphicReactPackageVersion$jscomp$inline_2138,\n-      \"19.2.0-canary-548235db-20251001\"\n+      \"19.2.0-canary-1bd1f01f-20251001\"\n     )\n   );\n ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n@@ -17788,10 +17788,10 @@ ReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n };\n var internals$jscomp$inline_2658 = {\n   bundleType: 0,\n-  version: \"19.2.0-canary-548235db-20251001\",\n+  version: \"19.2.0-canary-1bd1f01f-20251001\",\n   rendererPackageName: \"react-dom\",\n   currentDispatcherRef: ReactSharedInternals,\n-  reconcilerVersion: \"19.2.0-canary-548235db-20251001\"\n+  reconcilerVersion: \"19.2.0-canary-1bd1f01f-20251001\"\n };\n if (\"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n   var hook$jscomp$inline_2659 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n@@ -18050,7 +18050,7 @@ exports.useFormState = function (action, initialState, permalink) {\n exports.useFormStatus = function () {\n   return ReactSharedInternals.H.useHostTransitionStatus();\n };\n-exports.version = \"19.2.0-canary-548235db-20251001\";\n+exports.version = \"19.2.0-canary-1bd1f01f-20251001\";\n \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n   \"function\" ===\n     typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "536088650efd79f57cdf10781981346c77cc60b9",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server-legacy.browser.development.js",
            "status": "modified",
            "additions": 216,
            "deletions": 109,
            "changes": 325,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.browser.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -6677,6 +6677,105 @@\n       task.componentStack = previousComponentStack;\n       task.debugTask = previousDebugTask;\n     }\n+    function trackPostponedBoundary(request, trackedPostpones, boundary) {\n+      boundary.status = POSTPONED;\n+      boundary.rootSegmentID = request.nextSegmentId++;\n+      request = boundary.trackedContentKeyPath;\n+      if (null === request)\n+        throw Error(\n+          \"It should not be possible to postpone at the root. This is a bug in React.\"\n+        );\n+      var fallbackReplayNode = boundary.trackedFallbackNode,\n+        children = [],\n+        boundaryNode = trackedPostpones.workingMap.get(request);\n+      if (void 0 === boundaryNode)\n+        return (\n+          (boundary = [\n+            request[1],\n+            request[2],\n+            children,\n+            null,\n+            fallbackReplayNode,\n+            boundary.rootSegmentID\n+          ]),\n+          trackedPostpones.workingMap.set(request, boundary),\n+          addToReplayParent(boundary, request[0], trackedPostpones),\n+          boundary\n+        );\n+      boundaryNode[4] = fallbackReplayNode;\n+      boundaryNode[5] = boundary.rootSegmentID;\n+      return boundaryNode;\n+    }\n+    function trackPostpone(request, trackedPostpones, task, segment) {\n+      segment.status = POSTPONED;\n+      var keyPath = task.keyPath,\n+        boundary = task.blockedBoundary;\n+      if (null === boundary)\n+        (segment.id = request.nextSegmentId++),\n+          (trackedPostpones.rootSlots = segment.id),\n+          null !== request.completedRootSegment &&\n+            (request.completedRootSegment.status = POSTPONED);\n+      else {\n+        if (null !== boundary && boundary.status === PENDING) {\n+          var boundaryNode = trackPostponedBoundary(\n+            request,\n+            trackedPostpones,\n+            boundary\n+          );\n+          if (\n+            boundary.trackedContentKeyPath === keyPath &&\n+            -1 === task.childIndex\n+          ) {\n+            -1 === segment.id &&\n+              (segment.id = segment.parentFlushed\n+                ? boundary.rootSegmentID\n+                : request.nextSegmentId++);\n+            boundaryNode[3] = segment.id;\n+            return;\n+          }\n+        }\n+        -1 === segment.id &&\n+          (segment.id =\n+            segment.parentFlushed && null !== boundary\n+              ? boundary.rootSegmentID\n+              : request.nextSegmentId++);\n+        if (-1 === task.childIndex)\n+          null === keyPath\n+            ? (trackedPostpones.rootSlots = segment.id)\n+            : ((task = trackedPostpones.workingMap.get(keyPath)),\n+              void 0 === task\n+                ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n+                  addToReplayParent(task, keyPath[0], trackedPostpones))\n+                : (task[3] = segment.id));\n+        else {\n+          if (null === keyPath)\n+            if (((request = trackedPostpones.rootSlots), null === request))\n+              request = trackedPostpones.rootSlots = {};\n+            else {\n+              if (\"number\" === typeof request)\n+                throw Error(\n+                  \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+                );\n+            }\n+          else if (\n+            ((boundary = trackedPostpones.workingMap),\n+            (boundaryNode = boundary.get(keyPath)),\n+            void 0 === boundaryNode)\n+          )\n+            (request = {}),\n+              (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n+              boundary.set(keyPath, boundaryNode),\n+              addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n+          else if (((request = boundaryNode[3]), null === request))\n+            request = boundaryNode[3] = {};\n+          else if (\"number\" === typeof request)\n+            throw Error(\n+              \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+            );\n+          request[task.childIndex] = segment.id;\n+        }\n+      }\n+    }\n     function untrackBoundary(request, boundary) {\n       request = request.trackedPostpones;\n       null !== request &&\n@@ -6944,54 +7043,77 @@\n         if (6 === segment.status) return;\n         segment.status = ABORTED;\n       }\n-      segment = getThrownInfo(task.componentStack);\n-      var node = task.node;\n+      var errorInfo = getThrownInfo(task.componentStack),\n+        node = task.node;\n       null !== node &&\n         \"object\" === typeof node &&\n         pushHaltedAwaitOnComponentStack(task, node._debugInfo);\n       if (null === boundary) {\n         if (13 !== request.status && request.status !== CLOSED) {\n           boundary = task.replay;\n           if (null === boundary) {\n-            logRecoverableError(request, error, segment, task.debugTask);\n-            fatalError(request, error, segment, task.debugTask);\n+            null !== request.trackedPostpones && null !== segment\n+              ? ((boundary = request.trackedPostpones),\n+                logRecoverableError(request, error, errorInfo, task.debugTask),\n+                trackPostpone(request, boundary, task, segment),\n+                finishedTask(request, null, task.row, segment))\n+              : (logRecoverableError(request, error, errorInfo, task.debugTask),\n+                fatalError(request, error, errorInfo, task.debugTask));\n             return;\n           }\n           boundary.pendingTasks--;\n           0 === boundary.pendingTasks &&\n             0 < boundary.nodes.length &&\n-            ((node = logRecoverableError(request, error, segment, null)),\n+            ((segment = logRecoverableError(request, error, errorInfo, null)),\n             abortRemainingReplayNodes(\n               request,\n               null,\n               boundary.nodes,\n               boundary.slots,\n               error,\n-              node,\n               segment,\n+              errorInfo,\n               !0\n             ));\n           request.pendingRootTasks--;\n           0 === request.pendingRootTasks && completeShell(request);\n         }\n-      } else\n-        boundary.status !== CLIENT_RENDERED &&\n-          ((boundary.status = CLIENT_RENDERED),\n-          (node = logRecoverableError(request, error, segment, task.debugTask)),\n-          (boundary.status = CLIENT_RENDERED),\n-          encodeErrorForBoundary(boundary, node, error, segment, !0),\n-          untrackBoundary(request, boundary),\n+      } else {\n+        node = request.trackedPostpones;\n+        if (boundary.status !== CLIENT_RENDERED) {\n+          if (null !== node && null !== segment)\n+            return (\n+              logRecoverableError(request, error, errorInfo, task.debugTask),\n+              trackPostpone(request, node, task, segment),\n+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+                return abortTask(fallbackTask, request, error);\n+              }),\n+              boundary.fallbackAbortableTasks.clear(),\n+              finishedTask(request, boundary, task.row, segment)\n+            );\n+          boundary.status = CLIENT_RENDERED;\n+          segment = logRecoverableError(\n+            request,\n+            error,\n+            errorInfo,\n+            task.debugTask\n+          );\n+          boundary.status = CLIENT_RENDERED;\n+          encodeErrorForBoundary(boundary, segment, error, errorInfo, !0);\n+          untrackBoundary(request, boundary);\n           boundary.parentFlushed &&\n-            request.clientRenderedBoundaries.push(boundary)),\n-          boundary.pendingTasks--,\n-          (segment = boundary.row),\n-          null !== segment &&\n-            0 === --segment.pendingTasks &&\n-            finishSuspenseListRow(request, segment),\n-          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n-            return abortTask(fallbackTask, request, error);\n-          }),\n-          boundary.fallbackAbortableTasks.clear();\n+            request.clientRenderedBoundaries.push(boundary);\n+        }\n+        boundary.pendingTasks--;\n+        errorInfo = boundary.row;\n+        null !== errorInfo &&\n+          0 === --errorInfo.pendingTasks &&\n+          finishSuspenseListRow(request, errorInfo);\n+        boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+          return abortTask(fallbackTask, request, error);\n+        });\n+        boundary.fallbackAbortableTasks.clear();\n+      }\n       task = task.row;\n       null !== task &&\n         0 === --task.pendingTasks &&\n@@ -7099,64 +7221,58 @@\n           queueCompletedSegment(boundary, childSegment);\n       } else boundary.completedSegments.push(segment);\n     }\n-    function finishedTask(request$jscomp$0, boundary$jscomp$0, row, segment) {\n+    function finishedTask(request, boundary, row, segment) {\n       null !== row &&\n         (0 === --row.pendingTasks\n-          ? finishSuspenseListRow(request$jscomp$0, row)\n-          : row.together && tryToResolveTogetherRow(request$jscomp$0, row));\n-      request$jscomp$0.allPendingTasks--;\n-      if (null === boundary$jscomp$0) {\n+          ? finishSuspenseListRow(request, row)\n+          : row.together && tryToResolveTogetherRow(request, row));\n+      request.allPendingTasks--;\n+      if (null === boundary) {\n         if (null !== segment && segment.parentFlushed) {\n-          if (null !== request$jscomp$0.completedRootSegment)\n+          if (null !== request.completedRootSegment)\n             throw Error(\n               \"There can only be one root segment. This is a bug in React.\"\n             );\n-          request$jscomp$0.completedRootSegment = segment;\n+          request.completedRootSegment = segment;\n         }\n-        request$jscomp$0.pendingRootTasks--;\n-        0 === request$jscomp$0.pendingRootTasks &&\n-          completeShell(request$jscomp$0);\n-      } else if (\n-        (boundary$jscomp$0.pendingTasks--,\n-        boundary$jscomp$0.status !== CLIENT_RENDERED)\n-      )\n-        if (0 === boundary$jscomp$0.pendingTasks)\n+        request.pendingRootTasks--;\n+        0 === request.pendingRootTasks && completeShell(request);\n+      } else if ((boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED))\n+        if (0 === boundary.pendingTasks)\n           if (\n-            (boundary$jscomp$0.status === PENDING &&\n-              (boundary$jscomp$0.status = COMPLETED),\n+            (boundary.status === PENDING && (boundary.status = COMPLETED),\n             null !== segment &&\n               segment.parentFlushed &&\n               (segment.status === COMPLETED || segment.status === ABORTED) &&\n-              queueCompletedSegment(boundary$jscomp$0, segment),\n-            boundary$jscomp$0.parentFlushed &&\n-              request$jscomp$0.completedBoundaries.push(boundary$jscomp$0),\n-            boundary$jscomp$0.status === COMPLETED)\n+              queueCompletedSegment(boundary, segment),\n+            boundary.parentFlushed &&\n+              request.completedBoundaries.push(boundary),\n+            boundary.status === COMPLETED)\n           )\n-            (row = boundary$jscomp$0.row),\n+            (row = boundary.row),\n               null !== row &&\n-                hoistHoistables(row.hoistables, boundary$jscomp$0.contentState),\n-              isEligibleForOutlining(request$jscomp$0, boundary$jscomp$0) ||\n-                (boundary$jscomp$0.fallbackAbortableTasks.forEach(\n+                hoistHoistables(row.hoistables, boundary.contentState),\n+              isEligibleForOutlining(request, boundary) ||\n+                (boundary.fallbackAbortableTasks.forEach(\n                   abortTaskSoft,\n-                  request$jscomp$0\n+                  request\n                 ),\n-                boundary$jscomp$0.fallbackAbortableTasks.clear(),\n+                boundary.fallbackAbortableTasks.clear(),\n                 null !== row &&\n                   0 === --row.pendingTasks &&\n-                  finishSuspenseListRow(request$jscomp$0, row)),\n-              0 === request$jscomp$0.pendingRootTasks &&\n-                null === request$jscomp$0.trackedPostpones &&\n-                null !== boundary$jscomp$0.contentPreamble &&\n-                preparePreamble(request$jscomp$0);\n+                  finishSuspenseListRow(request, row)),\n+              0 === request.pendingRootTasks &&\n+                null === request.trackedPostpones &&\n+                null !== boundary.contentPreamble &&\n+                preparePreamble(request);\n           else {\n             if (\n-              boundary$jscomp$0.status === POSTPONED &&\n-              ((boundary$jscomp$0 = boundary$jscomp$0.row),\n-              null !== boundary$jscomp$0)\n+              boundary.status === POSTPONED &&\n+              ((boundary = boundary.row), null !== boundary)\n             ) {\n-              if (null !== request$jscomp$0.trackedPostpones) {\n-                row = request$jscomp$0.trackedPostpones;\n-                var postponedRow = boundary$jscomp$0.next;\n+              if (null !== request.trackedPostpones) {\n+                row = request.trackedPostpones;\n+                var postponedRow = boundary.next;\n                 if (\n                   null !== postponedRow &&\n                   ((segment = postponedRow.boundaries), null !== segment)\n@@ -7167,61 +7283,27 @@\n                     postponedRow++\n                   ) {\n                     var postponedBoundary = segment[postponedRow];\n-                    var request = request$jscomp$0,\n-                      trackedPostpones = row,\n-                      boundary = postponedBoundary;\n-                    boundary.status = POSTPONED;\n-                    boundary.rootSegmentID = request.nextSegmentId++;\n-                    request = boundary.trackedContentKeyPath;\n-                    if (null === request)\n-                      throw Error(\n-                        \"It should not be possible to postpone at the root. This is a bug in React.\"\n-                      );\n-                    var fallbackReplayNode = boundary.trackedFallbackNode,\n-                      children = [],\n-                      boundaryNode = trackedPostpones.workingMap.get(request);\n-                    void 0 === boundaryNode\n-                      ? ((boundary = [\n-                          request[1],\n-                          request[2],\n-                          children,\n-                          null,\n-                          fallbackReplayNode,\n-                          boundary.rootSegmentID\n-                        ]),\n-                        trackedPostpones.workingMap.set(request, boundary),\n-                        addToReplayParent(\n-                          boundary,\n-                          request[0],\n-                          trackedPostpones\n-                        ))\n-                      : ((boundaryNode[4] = fallbackReplayNode),\n-                        (boundaryNode[5] = boundary.rootSegmentID));\n-                    finishedTask(\n-                      request$jscomp$0,\n-                      postponedBoundary,\n-                      null,\n-                      null\n-                    );\n+                    trackPostponedBoundary(request, row, postponedBoundary);\n+                    finishedTask(request, postponedBoundary, null, null);\n                   }\n               }\n-              0 === --boundary$jscomp$0.pendingTasks &&\n-                finishSuspenseListRow(request$jscomp$0, boundary$jscomp$0);\n+              0 === --boundary.pendingTasks &&\n+                finishSuspenseListRow(request, boundary);\n             }\n           }\n         else\n           null === segment ||\n             !segment.parentFlushed ||\n             (segment.status !== COMPLETED && segment.status !== ABORTED) ||\n-            (queueCompletedSegment(boundary$jscomp$0, segment),\n-            1 === boundary$jscomp$0.completedSegments.length &&\n-              boundary$jscomp$0.parentFlushed &&\n-              request$jscomp$0.partialBoundaries.push(boundary$jscomp$0)),\n-            (boundary$jscomp$0 = boundary$jscomp$0.row),\n-            null !== boundary$jscomp$0 &&\n-              boundary$jscomp$0.together &&\n-              tryToResolveTogetherRow(request$jscomp$0, boundary$jscomp$0);\n-      0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n+            (queueCompletedSegment(boundary, segment),\n+            1 === boundary.completedSegments.length &&\n+              boundary.parentFlushed &&\n+              request.partialBoundaries.push(boundary)),\n+            (boundary = boundary.row),\n+            null !== boundary &&\n+              boundary.together &&\n+              tryToResolveTogetherRow(request, boundary);\n+      0 === request.allPendingTasks && completeAll(request);\n     }\n     function performWork(request$jscomp$2) {\n       if (\n@@ -7376,6 +7458,31 @@\n                       ? request.fatalError\n                       : thrownValue;\n                 if (\n+                  12 === request.status &&\n+                  null !== request.trackedPostpones\n+                ) {\n+                  var trackedPostpones = request.trackedPostpones,\n+                    thrownInfo = getThrownInfo(errorDigest.componentStack);\n+                  errorDigest.abortSet.delete(errorDigest);\n+                  logRecoverableError(\n+                    request,\n+                    x$jscomp$0,\n+                    thrownInfo,\n+                    errorDigest.debugTask\n+                  );\n+                  trackPostpone(\n+                    request,\n+                    trackedPostpones,\n+                    errorDigest,\n+                    request$jscomp$1\n+                  );\n+                  finishedTask(\n+                    request,\n+                    errorDigest.blockedBoundary,\n+                    errorDigest.row,\n+                    request$jscomp$1\n+                  );\n+                } else if (\n                   \"object\" === typeof x$jscomp$0 &&\n                   null !== x$jscomp$0 &&\n                   \"function\" === typeof x$jscomp$0.then\n@@ -9766,5 +9873,5 @@\n         'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n       );\n     };\n-    exports.version = \"19.2.0-canary-548235db-20251001\";\n+    exports.version = \"19.2.0-canary-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "128e16464095b65a454790db7d1c203a4a121759",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server-legacy.browser.production.js",
            "status": "modified",
            "additions": 202,
            "deletions": 113,
            "changes": 315,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.browser.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -2733,16 +2733,16 @@ function createRenderState(resumableState, generateStaticMarkup) {\n       \"\\x3c/script>\"\n     ));\n   bootstrapScriptContent = idPrefix + \"P:\";\n-  var JSCompiler_object_inline_segmentPrefix_1677 = idPrefix + \"S:\";\n+  var JSCompiler_object_inline_segmentPrefix_1673 = idPrefix + \"S:\";\n   idPrefix += \"B:\";\n-  var JSCompiler_object_inline_preconnects_1691 = new Set(),\n-    JSCompiler_object_inline_fontPreloads_1692 = new Set(),\n-    JSCompiler_object_inline_highImagePreloads_1693 = new Set(),\n-    JSCompiler_object_inline_styles_1694 = new Map(),\n-    JSCompiler_object_inline_bootstrapScripts_1695 = new Set(),\n-    JSCompiler_object_inline_scripts_1696 = new Set(),\n-    JSCompiler_object_inline_bulkPreloads_1697 = new Set(),\n-    JSCompiler_object_inline_preloads_1698 = {\n+  var JSCompiler_object_inline_preconnects_1687 = new Set(),\n+    JSCompiler_object_inline_fontPreloads_1688 = new Set(),\n+    JSCompiler_object_inline_highImagePreloads_1689 = new Set(),\n+    JSCompiler_object_inline_styles_1690 = new Map(),\n+    JSCompiler_object_inline_bootstrapScripts_1691 = new Set(),\n+    JSCompiler_object_inline_scripts_1692 = new Set(),\n+    JSCompiler_object_inline_bulkPreloads_1693 = new Set(),\n+    JSCompiler_object_inline_preloads_1694 = {\n       images: new Map(),\n       stylesheets: new Map(),\n       scripts: new Map(),\n@@ -2779,7 +2779,7 @@ function createRenderState(resumableState, generateStaticMarkup) {\n       scriptConfig.moduleScriptResources[href] = null;\n       scriptConfig = [];\n       pushLinkImpl(scriptConfig, props);\n-      JSCompiler_object_inline_bootstrapScripts_1695.add(scriptConfig);\n+      JSCompiler_object_inline_bootstrapScripts_1691.add(scriptConfig);\n       bootstrapChunks.push('<script src=\"', escapeTextForBrowser(src), '\"');\n       \"string\" === typeof integrity &&\n         bootstrapChunks.push(\n@@ -2826,7 +2826,7 @@ function createRenderState(resumableState, generateStaticMarkup) {\n         (props.moduleScriptResources[scriptConfig] = null),\n         (props = []),\n         pushLinkImpl(props, integrity),\n-        JSCompiler_object_inline_bootstrapScripts_1695.add(props),\n+        JSCompiler_object_inline_bootstrapScripts_1691.add(props),\n         bootstrapChunks.push(\n           '<script type=\"module\" src=\"',\n           escapeTextForBrowser(i),\n@@ -2848,7 +2848,7 @@ function createRenderState(resumableState, generateStaticMarkup) {\n         bootstrapChunks.push(' async=\"\">\\x3c/script>');\n   return {\n     placeholderPrefix: bootstrapScriptContent,\n-    segmentPrefix: JSCompiler_object_inline_segmentPrefix_1677,\n+    segmentPrefix: JSCompiler_object_inline_segmentPrefix_1673,\n     boundaryPrefix: idPrefix,\n     startInlineScript: \"<script\",\n     startInlineStyle: \"<style\",\n@@ -2868,14 +2868,14 @@ function createRenderState(resumableState, generateStaticMarkup) {\n     charsetChunks: [],\n     viewportChunks: [],\n     hoistableChunks: [],\n-    preconnects: JSCompiler_object_inline_preconnects_1691,\n-    fontPreloads: JSCompiler_object_inline_fontPreloads_1692,\n-    highImagePreloads: JSCompiler_object_inline_highImagePreloads_1693,\n-    styles: JSCompiler_object_inline_styles_1694,\n-    bootstrapScripts: JSCompiler_object_inline_bootstrapScripts_1695,\n-    scripts: JSCompiler_object_inline_scripts_1696,\n-    bulkPreloads: JSCompiler_object_inline_bulkPreloads_1697,\n-    preloads: JSCompiler_object_inline_preloads_1698,\n+    preconnects: JSCompiler_object_inline_preconnects_1687,\n+    fontPreloads: JSCompiler_object_inline_fontPreloads_1688,\n+    highImagePreloads: JSCompiler_object_inline_highImagePreloads_1689,\n+    styles: JSCompiler_object_inline_styles_1690,\n+    bootstrapScripts: JSCompiler_object_inline_bootstrapScripts_1691,\n+    scripts: JSCompiler_object_inline_scripts_1692,\n+    bulkPreloads: JSCompiler_object_inline_bulkPreloads_1693,\n+    preloads: JSCompiler_object_inline_preloads_1694,\n     nonce: { script: void 0, style: void 0 },\n     stylesToHoist: !1,\n     generateStaticMarkup: generateStaticMarkup\n@@ -5122,6 +5122,98 @@ function renderChildrenArray(request, task, children, childIndex) {\n   task.treeContext = replay;\n   task.keyPath = prevKeyPath;\n }\n+function trackPostponedBoundary(request, trackedPostpones, boundary) {\n+  boundary.status = 5;\n+  boundary.rootSegmentID = request.nextSegmentId++;\n+  request = boundary.trackedContentKeyPath;\n+  if (null === request) throw Error(formatProdErrorMessage(486));\n+  var fallbackReplayNode = boundary.trackedFallbackNode,\n+    children = [],\n+    boundaryNode = trackedPostpones.workingMap.get(request);\n+  if (void 0 === boundaryNode)\n+    return (\n+      (boundary = [\n+        request[1],\n+        request[2],\n+        children,\n+        null,\n+        fallbackReplayNode,\n+        boundary.rootSegmentID\n+      ]),\n+      trackedPostpones.workingMap.set(request, boundary),\n+      addToReplayParent(boundary, request[0], trackedPostpones),\n+      boundary\n+    );\n+  boundaryNode[4] = fallbackReplayNode;\n+  boundaryNode[5] = boundary.rootSegmentID;\n+  return boundaryNode;\n+}\n+function trackPostpone(request, trackedPostpones, task, segment) {\n+  segment.status = 5;\n+  var keyPath = task.keyPath,\n+    boundary = task.blockedBoundary;\n+  if (null === boundary)\n+    (segment.id = request.nextSegmentId++),\n+      (trackedPostpones.rootSlots = segment.id),\n+      null !== request.completedRootSegment &&\n+        (request.completedRootSegment.status = 5);\n+  else {\n+    if (null !== boundary && 0 === boundary.status) {\n+      var boundaryNode = trackPostponedBoundary(\n+        request,\n+        trackedPostpones,\n+        boundary\n+      );\n+      if (\n+        boundary.trackedContentKeyPath === keyPath &&\n+        -1 === task.childIndex\n+      ) {\n+        -1 === segment.id &&\n+          (segment.id = segment.parentFlushed\n+            ? boundary.rootSegmentID\n+            : request.nextSegmentId++);\n+        boundaryNode[3] = segment.id;\n+        return;\n+      }\n+    }\n+    -1 === segment.id &&\n+      (segment.id =\n+        segment.parentFlushed && null !== boundary\n+          ? boundary.rootSegmentID\n+          : request.nextSegmentId++);\n+    if (-1 === task.childIndex)\n+      null === keyPath\n+        ? (trackedPostpones.rootSlots = segment.id)\n+        : ((task = trackedPostpones.workingMap.get(keyPath)),\n+          void 0 === task\n+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n+              addToReplayParent(task, keyPath[0], trackedPostpones))\n+            : (task[3] = segment.id));\n+    else {\n+      if (null === keyPath)\n+        if (((request = trackedPostpones.rootSlots), null === request))\n+          request = trackedPostpones.rootSlots = {};\n+        else {\n+          if (\"number\" === typeof request)\n+            throw Error(formatProdErrorMessage(491));\n+        }\n+      else if (\n+        ((boundary = trackedPostpones.workingMap),\n+        (boundaryNode = boundary.get(keyPath)),\n+        void 0 === boundaryNode)\n+      )\n+        (request = {}),\n+          (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n+          boundary.set(keyPath, boundaryNode),\n+          addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n+      else if (((request = boundaryNode[3]), null === request))\n+        request = boundaryNode[3] = {};\n+      else if (\"number\" === typeof request)\n+        throw Error(formatProdErrorMessage(491));\n+      request[task.childIndex] = segment.id;\n+    }\n+  }\n+}\n function untrackBoundary(request, boundary) {\n   request = request.trackedPostpones;\n   null !== request &&\n@@ -5238,21 +5330,21 @@ function renderNode(request, task, node, childIndex) {\n       chunkLength = segment.chunks.length;\n     try {\n       return renderNodeDestructive(request, task, node, childIndex);\n-    } catch (thrownValue$60) {\n+    } catch (thrownValue$62) {\n       if (\n         (resetHooksState(),\n         (segment.children.length = childrenLength),\n         (segment.chunks.length = chunkLength),\n         (node =\n-          thrownValue$60 === SuspenseException\n+          thrownValue$62 === SuspenseException\n             ? getSuspendedThenable()\n-            : thrownValue$60),\n+            : thrownValue$62),\n         12 !== request.status && \"object\" === typeof node && null !== node)\n       ) {\n         if (\"function\" === typeof node.then) {\n           segment = node;\n           node =\n-            thrownValue$60 === SuspenseException\n+            thrownValue$62 === SuspenseException\n               ? getThenableStateAfterSuspending()\n               : null;\n           request = spawnNewSuspendedRenderTask(request, task, node).ping;\n@@ -5267,7 +5359,7 @@ function renderNode(request, task, node, childIndex) {\n         }\n         if (\"Maximum call stack size exceeded\" === node.message) {\n           segment =\n-            thrownValue$60 === SuspenseException\n+            thrownValue$62 === SuspenseException\n               ? getThenableStateAfterSuspending()\n               : null;\n           segment = spawnNewSuspendedRenderTask(request, task, segment);\n@@ -5352,19 +5444,24 @@ function abortTask(task, request, error) {\n     if (6 === segment.status) return;\n     segment.status = 3;\n   }\n-  segment = getThrownInfo(task.componentStack);\n+  var errorInfo = getThrownInfo(task.componentStack);\n   if (null === boundary) {\n     if (13 !== request.status && 14 !== request.status) {\n       boundary = task.replay;\n       if (null === boundary) {\n-        logRecoverableError(request, error, segment);\n-        fatalError(request, error);\n+        null !== request.trackedPostpones && null !== segment\n+          ? ((boundary = request.trackedPostpones),\n+            logRecoverableError(request, error, errorInfo),\n+            trackPostpone(request, boundary, task, segment),\n+            finishedTask(request, null, task.row, segment))\n+          : (logRecoverableError(request, error, errorInfo),\n+            fatalError(request, error));\n         return;\n       }\n       boundary.pendingTasks--;\n       0 === boundary.pendingTasks &&\n         0 < boundary.nodes.length &&\n-        ((segment = logRecoverableError(request, error, segment)),\n+        ((segment = logRecoverableError(request, error, errorInfo)),\n         abortRemainingReplayNodes(\n           request,\n           null,\n@@ -5376,24 +5473,36 @@ function abortTask(task, request, error) {\n       request.pendingRootTasks--;\n       0 === request.pendingRootTasks && completeShell(request);\n     }\n-  } else\n-    4 !== boundary.status &&\n-      ((boundary.status = 4),\n-      (segment = logRecoverableError(request, error, segment)),\n-      (boundary.status = 4),\n-      (boundary.errorDigest = segment),\n-      untrackBoundary(request, boundary),\n-      boundary.parentFlushed &&\n-        request.clientRenderedBoundaries.push(boundary)),\n-      boundary.pendingTasks--,\n-      (segment = boundary.row),\n-      null !== segment &&\n-        0 === --segment.pendingTasks &&\n-        finishSuspenseListRow(request, segment),\n-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n-        return abortTask(fallbackTask, request, error);\n-      }),\n-      boundary.fallbackAbortableTasks.clear();\n+  } else {\n+    var trackedPostpones$63 = request.trackedPostpones;\n+    if (4 !== boundary.status) {\n+      if (null !== trackedPostpones$63 && null !== segment)\n+        return (\n+          logRecoverableError(request, error, errorInfo),\n+          trackPostpone(request, trackedPostpones$63, task, segment),\n+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+            return abortTask(fallbackTask, request, error);\n+          }),\n+          boundary.fallbackAbortableTasks.clear(),\n+          finishedTask(request, boundary, task.row, segment)\n+        );\n+      boundary.status = 4;\n+      segment = logRecoverableError(request, error, errorInfo);\n+      boundary.status = 4;\n+      boundary.errorDigest = segment;\n+      untrackBoundary(request, boundary);\n+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);\n+    }\n+    boundary.pendingTasks--;\n+    segment = boundary.row;\n+    null !== segment &&\n+      0 === --segment.pendingTasks &&\n+      finishSuspenseListRow(request, segment);\n+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+      return abortTask(fallbackTask, request, error);\n+    });\n+    boundary.fallbackAbortableTasks.clear();\n+  }\n   task = task.row;\n   null !== task &&\n     0 === --task.pendingTasks &&\n@@ -5497,20 +5606,20 @@ function queueCompletedSegment(boundary, segment) {\n       queueCompletedSegment(boundary, childSegment);\n   } else boundary.completedSegments.push(segment);\n }\n-function finishedTask(request$jscomp$0, boundary, row, segment) {\n+function finishedTask(request, boundary, row, segment) {\n   null !== row &&\n     (0 === --row.pendingTasks\n-      ? finishSuspenseListRow(request$jscomp$0, row)\n-      : row.together && tryToResolveTogetherRow(request$jscomp$0, row));\n-  request$jscomp$0.allPendingTasks--;\n+      ? finishSuspenseListRow(request, row)\n+      : row.together && tryToResolveTogetherRow(request, row));\n+  request.allPendingTasks--;\n   if (null === boundary) {\n     if (null !== segment && segment.parentFlushed) {\n-      if (null !== request$jscomp$0.completedRootSegment)\n+      if (null !== request.completedRootSegment)\n         throw Error(formatProdErrorMessage(389));\n-      request$jscomp$0.completedRootSegment = segment;\n+      request.completedRootSegment = segment;\n     }\n-    request$jscomp$0.pendingRootTasks--;\n-    0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);\n+    request.pendingRootTasks--;\n+    0 === request.pendingRootTasks && completeShell(request);\n   } else if ((boundary.pendingTasks--, 4 !== boundary.status))\n     if (0 === boundary.pendingTasks)\n       if (\n@@ -5519,33 +5628,29 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n           segment.parentFlushed &&\n           (1 === segment.status || 3 === segment.status) &&\n           queueCompletedSegment(boundary, segment),\n-        boundary.parentFlushed &&\n-          request$jscomp$0.completedBoundaries.push(boundary),\n+        boundary.parentFlushed && request.completedBoundaries.push(boundary),\n         1 === boundary.status)\n       )\n         (row = boundary.row),\n           null !== row &&\n             hoistHoistables(row.hoistables, boundary.contentState),\n-          isEligibleForOutlining(request$jscomp$0, boundary) ||\n-            (boundary.fallbackAbortableTasks.forEach(\n-              abortTaskSoft,\n-              request$jscomp$0\n-            ),\n+          isEligibleForOutlining(request, boundary) ||\n+            (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),\n             boundary.fallbackAbortableTasks.clear(),\n             null !== row &&\n               0 === --row.pendingTasks &&\n-              finishSuspenseListRow(request$jscomp$0, row)),\n-          0 === request$jscomp$0.pendingRootTasks &&\n-            null === request$jscomp$0.trackedPostpones &&\n+              finishSuspenseListRow(request, row)),\n+          0 === request.pendingRootTasks &&\n+            null === request.trackedPostpones &&\n             null !== boundary.contentPreamble &&\n-            preparePreamble(request$jscomp$0);\n+            preparePreamble(request);\n       else {\n         if (\n           5 === boundary.status &&\n           ((boundary = boundary.row), null !== boundary)\n         ) {\n-          if (null !== request$jscomp$0.trackedPostpones) {\n-            row = request$jscomp$0.trackedPostpones;\n+          if (null !== request.trackedPostpones) {\n+            row = request.trackedPostpones;\n             var postponedRow = boundary.next;\n             if (\n               null !== postponedRow &&\n@@ -5557,40 +5662,12 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n                 postponedRow++\n               ) {\n                 var postponedBoundary = segment[postponedRow];\n-                var request = request$jscomp$0,\n-                  trackedPostpones = row;\n-                postponedBoundary.status = 5;\n-                postponedBoundary.rootSegmentID = request.nextSegmentId++;\n-                request = postponedBoundary.trackedContentKeyPath;\n-                if (null === request) throw Error(formatProdErrorMessage(486));\n-                var fallbackReplayNode = postponedBoundary.trackedFallbackNode,\n-                  children = [],\n-                  boundaryNode = trackedPostpones.workingMap.get(request);\n-                void 0 === boundaryNode\n-                  ? ((fallbackReplayNode = [\n-                      request[1],\n-                      request[2],\n-                      children,\n-                      null,\n-                      fallbackReplayNode,\n-                      postponedBoundary.rootSegmentID\n-                    ]),\n-                    trackedPostpones.workingMap.set(\n-                      request,\n-                      fallbackReplayNode\n-                    ),\n-                    addToReplayParent(\n-                      fallbackReplayNode,\n-                      request[0],\n-                      trackedPostpones\n-                    ))\n-                  : ((boundaryNode[4] = fallbackReplayNode),\n-                    (boundaryNode[5] = postponedBoundary.rootSegmentID));\n-                finishedTask(request$jscomp$0, postponedBoundary, null, null);\n+                trackPostponedBoundary(request, row, postponedBoundary);\n+                finishedTask(request, postponedBoundary, null, null);\n               }\n           }\n           0 === --boundary.pendingTasks &&\n-            finishSuspenseListRow(request$jscomp$0, boundary);\n+            finishSuspenseListRow(request, boundary);\n         }\n       }\n     else\n@@ -5600,12 +5677,12 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n         (queueCompletedSegment(boundary, segment),\n         1 === boundary.completedSegments.length &&\n           boundary.parentFlushed &&\n-          request$jscomp$0.partialBoundaries.push(boundary)),\n+          request.partialBoundaries.push(boundary)),\n         (boundary = boundary.row),\n         null !== boundary &&\n           boundary.together &&\n-          tryToResolveTogetherRow(request$jscomp$0, boundary);\n-  0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n+          tryToResolveTogetherRow(request, boundary);\n+  0 === request.allPendingTasks && completeAll(request);\n }\n function performWork(request$jscomp$2) {\n   if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {\n@@ -5740,7 +5817,19 @@ function performWork(request$jscomp$2) {\n                 : 12 === request.status\n                   ? request.fatalError\n                   : thrownValue;\n-            if (\n+            if (12 === request.status && null !== request.trackedPostpones) {\n+              var trackedPostpones = request.trackedPostpones,\n+                thrownInfo = getThrownInfo(task.componentStack);\n+              task.abortSet.delete(task);\n+              logRecoverableError(request, x$jscomp$0, thrownInfo);\n+              trackPostpone(request, trackedPostpones, task, request$jscomp$1);\n+              finishedTask(\n+                request,\n+                task.blockedBoundary,\n+                task.row,\n+                request$jscomp$1\n+              );\n+            } else if (\n               \"object\" === typeof x$jscomp$0 &&\n               null !== x$jscomp$0 &&\n               \"function\" === typeof x$jscomp$0.then\n@@ -6309,12 +6398,12 @@ function flushCompletedQueues(request, destination) {\n       flushingPartialBoundaries = !0;\n       var partialBoundaries = request.partialBoundaries;\n       for (i = 0; i < partialBoundaries.length; i++) {\n-        var boundary$66 = partialBoundaries[i];\n+        var boundary$69 = partialBoundaries[i];\n         a: {\n           clientRenderedBoundaries = request;\n           boundary = destination;\n-          flushedByteSize = boundary$66.byteSize;\n-          var completedSegments = boundary$66.completedSegments;\n+          flushedByteSize = boundary$69.byteSize;\n+          var completedSegments = boundary$69.completedSegments;\n           for (\n             JSCompiler_inline_result = 0;\n             JSCompiler_inline_result < completedSegments.length;\n@@ -6324,7 +6413,7 @@ function flushCompletedQueues(request, destination) {\n               !flushPartiallyCompletedSegment(\n                 clientRenderedBoundaries,\n                 boundary,\n-                boundary$66,\n+                boundary$69,\n                 completedSegments[JSCompiler_inline_result]\n               )\n             ) {\n@@ -6334,10 +6423,10 @@ function flushCompletedQueues(request, destination) {\n               break a;\n             }\n           completedSegments.splice(0, JSCompiler_inline_result);\n-          var row = boundary$66.row;\n+          var row = boundary$69.row;\n           null !== row &&\n             row.together &&\n-            1 === boundary$66.pendingTasks &&\n+            1 === boundary$69.pendingTasks &&\n             (1 === row.pendingTasks\n               ? unblockSuspenseListRow(\n                   clientRenderedBoundaries,\n@@ -6347,7 +6436,7 @@ function flushCompletedQueues(request, destination) {\n               : row.pendingTasks--);\n           JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n             boundary,\n-            boundary$66.contentState,\n+            boundary$69.contentState,\n             clientRenderedBoundaries.renderState\n           );\n         }\n@@ -6432,8 +6521,8 @@ function abort(request, reason) {\n     }\n     null !== request.destination &&\n       flushCompletedQueues(request, request.destination);\n-  } catch (error$68) {\n-    logRecoverableError(request, error$68, {}), fatalError(request, error$68);\n+  } catch (error$71) {\n+    logRecoverableError(request, error$71, {}), fatalError(request, error$71);\n   }\n }\n function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n@@ -6511,4 +6600,4 @@ exports.renderToString = function (children, options) {\n     'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToReadableStream\" which supports Suspense on the server'\n   );\n };\n-exports.version = \"19.2.0-canary-548235db-20251001\";\n+exports.version = \"19.2.0-canary-1bd1f01f-20251001\";"
        },
        {
            "sha": "5f3f5b3a60e49750f01ae6b7a9c20464e09a3704",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server-legacy.node.development.js",
            "status": "modified",
            "additions": 216,
            "deletions": 109,
            "changes": 325,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.node.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -6677,6 +6677,105 @@\n       task.componentStack = previousComponentStack;\n       task.debugTask = previousDebugTask;\n     }\n+    function trackPostponedBoundary(request, trackedPostpones, boundary) {\n+      boundary.status = POSTPONED;\n+      boundary.rootSegmentID = request.nextSegmentId++;\n+      request = boundary.trackedContentKeyPath;\n+      if (null === request)\n+        throw Error(\n+          \"It should not be possible to postpone at the root. This is a bug in React.\"\n+        );\n+      var fallbackReplayNode = boundary.trackedFallbackNode,\n+        children = [],\n+        boundaryNode = trackedPostpones.workingMap.get(request);\n+      if (void 0 === boundaryNode)\n+        return (\n+          (boundary = [\n+            request[1],\n+            request[2],\n+            children,\n+            null,\n+            fallbackReplayNode,\n+            boundary.rootSegmentID\n+          ]),\n+          trackedPostpones.workingMap.set(request, boundary),\n+          addToReplayParent(boundary, request[0], trackedPostpones),\n+          boundary\n+        );\n+      boundaryNode[4] = fallbackReplayNode;\n+      boundaryNode[5] = boundary.rootSegmentID;\n+      return boundaryNode;\n+    }\n+    function trackPostpone(request, trackedPostpones, task, segment) {\n+      segment.status = POSTPONED;\n+      var keyPath = task.keyPath,\n+        boundary = task.blockedBoundary;\n+      if (null === boundary)\n+        (segment.id = request.nextSegmentId++),\n+          (trackedPostpones.rootSlots = segment.id),\n+          null !== request.completedRootSegment &&\n+            (request.completedRootSegment.status = POSTPONED);\n+      else {\n+        if (null !== boundary && boundary.status === PENDING) {\n+          var boundaryNode = trackPostponedBoundary(\n+            request,\n+            trackedPostpones,\n+            boundary\n+          );\n+          if (\n+            boundary.trackedContentKeyPath === keyPath &&\n+            -1 === task.childIndex\n+          ) {\n+            -1 === segment.id &&\n+              (segment.id = segment.parentFlushed\n+                ? boundary.rootSegmentID\n+                : request.nextSegmentId++);\n+            boundaryNode[3] = segment.id;\n+            return;\n+          }\n+        }\n+        -1 === segment.id &&\n+          (segment.id =\n+            segment.parentFlushed && null !== boundary\n+              ? boundary.rootSegmentID\n+              : request.nextSegmentId++);\n+        if (-1 === task.childIndex)\n+          null === keyPath\n+            ? (trackedPostpones.rootSlots = segment.id)\n+            : ((task = trackedPostpones.workingMap.get(keyPath)),\n+              void 0 === task\n+                ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n+                  addToReplayParent(task, keyPath[0], trackedPostpones))\n+                : (task[3] = segment.id));\n+        else {\n+          if (null === keyPath)\n+            if (((request = trackedPostpones.rootSlots), null === request))\n+              request = trackedPostpones.rootSlots = {};\n+            else {\n+              if (\"number\" === typeof request)\n+                throw Error(\n+                  \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+                );\n+            }\n+          else if (\n+            ((boundary = trackedPostpones.workingMap),\n+            (boundaryNode = boundary.get(keyPath)),\n+            void 0 === boundaryNode)\n+          )\n+            (request = {}),\n+              (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n+              boundary.set(keyPath, boundaryNode),\n+              addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n+          else if (((request = boundaryNode[3]), null === request))\n+            request = boundaryNode[3] = {};\n+          else if (\"number\" === typeof request)\n+            throw Error(\n+              \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+            );\n+          request[task.childIndex] = segment.id;\n+        }\n+      }\n+    }\n     function untrackBoundary(request, boundary) {\n       request = request.trackedPostpones;\n       null !== request &&\n@@ -6944,54 +7043,77 @@\n         if (6 === segment.status) return;\n         segment.status = ABORTED;\n       }\n-      segment = getThrownInfo(task.componentStack);\n-      var node = task.node;\n+      var errorInfo = getThrownInfo(task.componentStack),\n+        node = task.node;\n       null !== node &&\n         \"object\" === typeof node &&\n         pushHaltedAwaitOnComponentStack(task, node._debugInfo);\n       if (null === boundary) {\n         if (13 !== request.status && request.status !== CLOSED) {\n           boundary = task.replay;\n           if (null === boundary) {\n-            logRecoverableError(request, error, segment, task.debugTask);\n-            fatalError(request, error, segment, task.debugTask);\n+            null !== request.trackedPostpones && null !== segment\n+              ? ((boundary = request.trackedPostpones),\n+                logRecoverableError(request, error, errorInfo, task.debugTask),\n+                trackPostpone(request, boundary, task, segment),\n+                finishedTask(request, null, task.row, segment))\n+              : (logRecoverableError(request, error, errorInfo, task.debugTask),\n+                fatalError(request, error, errorInfo, task.debugTask));\n             return;\n           }\n           boundary.pendingTasks--;\n           0 === boundary.pendingTasks &&\n             0 < boundary.nodes.length &&\n-            ((node = logRecoverableError(request, error, segment, null)),\n+            ((segment = logRecoverableError(request, error, errorInfo, null)),\n             abortRemainingReplayNodes(\n               request,\n               null,\n               boundary.nodes,\n               boundary.slots,\n               error,\n-              node,\n               segment,\n+              errorInfo,\n               !0\n             ));\n           request.pendingRootTasks--;\n           0 === request.pendingRootTasks && completeShell(request);\n         }\n-      } else\n-        boundary.status !== CLIENT_RENDERED &&\n-          ((boundary.status = CLIENT_RENDERED),\n-          (node = logRecoverableError(request, error, segment, task.debugTask)),\n-          (boundary.status = CLIENT_RENDERED),\n-          encodeErrorForBoundary(boundary, node, error, segment, !0),\n-          untrackBoundary(request, boundary),\n+      } else {\n+        node = request.trackedPostpones;\n+        if (boundary.status !== CLIENT_RENDERED) {\n+          if (null !== node && null !== segment)\n+            return (\n+              logRecoverableError(request, error, errorInfo, task.debugTask),\n+              trackPostpone(request, node, task, segment),\n+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+                return abortTask(fallbackTask, request, error);\n+              }),\n+              boundary.fallbackAbortableTasks.clear(),\n+              finishedTask(request, boundary, task.row, segment)\n+            );\n+          boundary.status = CLIENT_RENDERED;\n+          segment = logRecoverableError(\n+            request,\n+            error,\n+            errorInfo,\n+            task.debugTask\n+          );\n+          boundary.status = CLIENT_RENDERED;\n+          encodeErrorForBoundary(boundary, segment, error, errorInfo, !0);\n+          untrackBoundary(request, boundary);\n           boundary.parentFlushed &&\n-            request.clientRenderedBoundaries.push(boundary)),\n-          boundary.pendingTasks--,\n-          (segment = boundary.row),\n-          null !== segment &&\n-            0 === --segment.pendingTasks &&\n-            finishSuspenseListRow(request, segment),\n-          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n-            return abortTask(fallbackTask, request, error);\n-          }),\n-          boundary.fallbackAbortableTasks.clear();\n+            request.clientRenderedBoundaries.push(boundary);\n+        }\n+        boundary.pendingTasks--;\n+        errorInfo = boundary.row;\n+        null !== errorInfo &&\n+          0 === --errorInfo.pendingTasks &&\n+          finishSuspenseListRow(request, errorInfo);\n+        boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+          return abortTask(fallbackTask, request, error);\n+        });\n+        boundary.fallbackAbortableTasks.clear();\n+      }\n       task = task.row;\n       null !== task &&\n         0 === --task.pendingTasks &&\n@@ -7099,64 +7221,58 @@\n           queueCompletedSegment(boundary, childSegment);\n       } else boundary.completedSegments.push(segment);\n     }\n-    function finishedTask(request$jscomp$0, boundary$jscomp$0, row, segment) {\n+    function finishedTask(request, boundary, row, segment) {\n       null !== row &&\n         (0 === --row.pendingTasks\n-          ? finishSuspenseListRow(request$jscomp$0, row)\n-          : row.together && tryToResolveTogetherRow(request$jscomp$0, row));\n-      request$jscomp$0.allPendingTasks--;\n-      if (null === boundary$jscomp$0) {\n+          ? finishSuspenseListRow(request, row)\n+          : row.together && tryToResolveTogetherRow(request, row));\n+      request.allPendingTasks--;\n+      if (null === boundary) {\n         if (null !== segment && segment.parentFlushed) {\n-          if (null !== request$jscomp$0.completedRootSegment)\n+          if (null !== request.completedRootSegment)\n             throw Error(\n               \"There can only be one root segment. This is a bug in React.\"\n             );\n-          request$jscomp$0.completedRootSegment = segment;\n+          request.completedRootSegment = segment;\n         }\n-        request$jscomp$0.pendingRootTasks--;\n-        0 === request$jscomp$0.pendingRootTasks &&\n-          completeShell(request$jscomp$0);\n-      } else if (\n-        (boundary$jscomp$0.pendingTasks--,\n-        boundary$jscomp$0.status !== CLIENT_RENDERED)\n-      )\n-        if (0 === boundary$jscomp$0.pendingTasks)\n+        request.pendingRootTasks--;\n+        0 === request.pendingRootTasks && completeShell(request);\n+      } else if ((boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED))\n+        if (0 === boundary.pendingTasks)\n           if (\n-            (boundary$jscomp$0.status === PENDING &&\n-              (boundary$jscomp$0.status = COMPLETED),\n+            (boundary.status === PENDING && (boundary.status = COMPLETED),\n             null !== segment &&\n               segment.parentFlushed &&\n               (segment.status === COMPLETED || segment.status === ABORTED) &&\n-              queueCompletedSegment(boundary$jscomp$0, segment),\n-            boundary$jscomp$0.parentFlushed &&\n-              request$jscomp$0.completedBoundaries.push(boundary$jscomp$0),\n-            boundary$jscomp$0.status === COMPLETED)\n+              queueCompletedSegment(boundary, segment),\n+            boundary.parentFlushed &&\n+              request.completedBoundaries.push(boundary),\n+            boundary.status === COMPLETED)\n           )\n-            (row = boundary$jscomp$0.row),\n+            (row = boundary.row),\n               null !== row &&\n-                hoistHoistables(row.hoistables, boundary$jscomp$0.contentState),\n-              isEligibleForOutlining(request$jscomp$0, boundary$jscomp$0) ||\n-                (boundary$jscomp$0.fallbackAbortableTasks.forEach(\n+                hoistHoistables(row.hoistables, boundary.contentState),\n+              isEligibleForOutlining(request, boundary) ||\n+                (boundary.fallbackAbortableTasks.forEach(\n                   abortTaskSoft,\n-                  request$jscomp$0\n+                  request\n                 ),\n-                boundary$jscomp$0.fallbackAbortableTasks.clear(),\n+                boundary.fallbackAbortableTasks.clear(),\n                 null !== row &&\n                   0 === --row.pendingTasks &&\n-                  finishSuspenseListRow(request$jscomp$0, row)),\n-              0 === request$jscomp$0.pendingRootTasks &&\n-                null === request$jscomp$0.trackedPostpones &&\n-                null !== boundary$jscomp$0.contentPreamble &&\n-                preparePreamble(request$jscomp$0);\n+                  finishSuspenseListRow(request, row)),\n+              0 === request.pendingRootTasks &&\n+                null === request.trackedPostpones &&\n+                null !== boundary.contentPreamble &&\n+                preparePreamble(request);\n           else {\n             if (\n-              boundary$jscomp$0.status === POSTPONED &&\n-              ((boundary$jscomp$0 = boundary$jscomp$0.row),\n-              null !== boundary$jscomp$0)\n+              boundary.status === POSTPONED &&\n+              ((boundary = boundary.row), null !== boundary)\n             ) {\n-              if (null !== request$jscomp$0.trackedPostpones) {\n-                row = request$jscomp$0.trackedPostpones;\n-                var postponedRow = boundary$jscomp$0.next;\n+              if (null !== request.trackedPostpones) {\n+                row = request.trackedPostpones;\n+                var postponedRow = boundary.next;\n                 if (\n                   null !== postponedRow &&\n                   ((segment = postponedRow.boundaries), null !== segment)\n@@ -7167,61 +7283,27 @@\n                     postponedRow++\n                   ) {\n                     var postponedBoundary = segment[postponedRow];\n-                    var request = request$jscomp$0,\n-                      trackedPostpones = row,\n-                      boundary = postponedBoundary;\n-                    boundary.status = POSTPONED;\n-                    boundary.rootSegmentID = request.nextSegmentId++;\n-                    request = boundary.trackedContentKeyPath;\n-                    if (null === request)\n-                      throw Error(\n-                        \"It should not be possible to postpone at the root. This is a bug in React.\"\n-                      );\n-                    var fallbackReplayNode = boundary.trackedFallbackNode,\n-                      children = [],\n-                      boundaryNode = trackedPostpones.workingMap.get(request);\n-                    void 0 === boundaryNode\n-                      ? ((boundary = [\n-                          request[1],\n-                          request[2],\n-                          children,\n-                          null,\n-                          fallbackReplayNode,\n-                          boundary.rootSegmentID\n-                        ]),\n-                        trackedPostpones.workingMap.set(request, boundary),\n-                        addToReplayParent(\n-                          boundary,\n-                          request[0],\n-                          trackedPostpones\n-                        ))\n-                      : ((boundaryNode[4] = fallbackReplayNode),\n-                        (boundaryNode[5] = boundary.rootSegmentID));\n-                    finishedTask(\n-                      request$jscomp$0,\n-                      postponedBoundary,\n-                      null,\n-                      null\n-                    );\n+                    trackPostponedBoundary(request, row, postponedBoundary);\n+                    finishedTask(request, postponedBoundary, null, null);\n                   }\n               }\n-              0 === --boundary$jscomp$0.pendingTasks &&\n-                finishSuspenseListRow(request$jscomp$0, boundary$jscomp$0);\n+              0 === --boundary.pendingTasks &&\n+                finishSuspenseListRow(request, boundary);\n             }\n           }\n         else\n           null === segment ||\n             !segment.parentFlushed ||\n             (segment.status !== COMPLETED && segment.status !== ABORTED) ||\n-            (queueCompletedSegment(boundary$jscomp$0, segment),\n-            1 === boundary$jscomp$0.completedSegments.length &&\n-              boundary$jscomp$0.parentFlushed &&\n-              request$jscomp$0.partialBoundaries.push(boundary$jscomp$0)),\n-            (boundary$jscomp$0 = boundary$jscomp$0.row),\n-            null !== boundary$jscomp$0 &&\n-              boundary$jscomp$0.together &&\n-              tryToResolveTogetherRow(request$jscomp$0, boundary$jscomp$0);\n-      0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n+            (queueCompletedSegment(boundary, segment),\n+            1 === boundary.completedSegments.length &&\n+              boundary.parentFlushed &&\n+              request.partialBoundaries.push(boundary)),\n+            (boundary = boundary.row),\n+            null !== boundary &&\n+              boundary.together &&\n+              tryToResolveTogetherRow(request, boundary);\n+      0 === request.allPendingTasks && completeAll(request);\n     }\n     function performWork(request$jscomp$2) {\n       if (\n@@ -7376,6 +7458,31 @@\n                       ? request.fatalError\n                       : thrownValue;\n                 if (\n+                  12 === request.status &&\n+                  null !== request.trackedPostpones\n+                ) {\n+                  var trackedPostpones = request.trackedPostpones,\n+                    thrownInfo = getThrownInfo(errorDigest.componentStack);\n+                  errorDigest.abortSet.delete(errorDigest);\n+                  logRecoverableError(\n+                    request,\n+                    x$jscomp$0,\n+                    thrownInfo,\n+                    errorDigest.debugTask\n+                  );\n+                  trackPostpone(\n+                    request,\n+                    trackedPostpones,\n+                    errorDigest,\n+                    request$jscomp$1\n+                  );\n+                  finishedTask(\n+                    request,\n+                    errorDigest.blockedBoundary,\n+                    errorDigest.row,\n+                    request$jscomp$1\n+                  );\n+                } else if (\n                   \"object\" === typeof x$jscomp$0 &&\n                   null !== x$jscomp$0 &&\n                   \"function\" === typeof x$jscomp$0.then\n@@ -9766,5 +9873,5 @@\n         'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server'\n       );\n     };\n-    exports.version = \"19.2.0-canary-548235db-20251001\";\n+    exports.version = \"19.2.0-canary-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "6e918589337ed4cb1ec6fad3e5f3edf24d866f98",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server-legacy.node.production.js",
            "status": "modified",
            "additions": 209,
            "deletions": 116,
            "changes": 325,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server-legacy.node.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -2752,16 +2752,16 @@ function createRenderState(resumableState, generateStaticMarkup) {\n       \"\\x3c/script>\"\n     ));\n   bootstrapScriptContent = idPrefix + \"P:\";\n-  var JSCompiler_object_inline_segmentPrefix_1677 = idPrefix + \"S:\";\n+  var JSCompiler_object_inline_segmentPrefix_1673 = idPrefix + \"S:\";\n   idPrefix += \"B:\";\n-  var JSCompiler_object_inline_preconnects_1691 = new Set(),\n-    JSCompiler_object_inline_fontPreloads_1692 = new Set(),\n-    JSCompiler_object_inline_highImagePreloads_1693 = new Set(),\n-    JSCompiler_object_inline_styles_1694 = new Map(),\n-    JSCompiler_object_inline_bootstrapScripts_1695 = new Set(),\n-    JSCompiler_object_inline_scripts_1696 = new Set(),\n-    JSCompiler_object_inline_bulkPreloads_1697 = new Set(),\n-    JSCompiler_object_inline_preloads_1698 = {\n+  var JSCompiler_object_inline_preconnects_1687 = new Set(),\n+    JSCompiler_object_inline_fontPreloads_1688 = new Set(),\n+    JSCompiler_object_inline_highImagePreloads_1689 = new Set(),\n+    JSCompiler_object_inline_styles_1690 = new Map(),\n+    JSCompiler_object_inline_bootstrapScripts_1691 = new Set(),\n+    JSCompiler_object_inline_scripts_1692 = new Set(),\n+    JSCompiler_object_inline_bulkPreloads_1693 = new Set(),\n+    JSCompiler_object_inline_preloads_1694 = {\n       images: new Map(),\n       stylesheets: new Map(),\n       scripts: new Map(),\n@@ -2798,7 +2798,7 @@ function createRenderState(resumableState, generateStaticMarkup) {\n       scriptConfig.moduleScriptResources[href] = null;\n       scriptConfig = [];\n       pushLinkImpl(scriptConfig, props);\n-      JSCompiler_object_inline_bootstrapScripts_1695.add(scriptConfig);\n+      JSCompiler_object_inline_bootstrapScripts_1691.add(scriptConfig);\n       bootstrapChunks.push('<script src=\"', escapeTextForBrowser(src), '\"');\n       \"string\" === typeof integrity &&\n         bootstrapChunks.push(\n@@ -2845,7 +2845,7 @@ function createRenderState(resumableState, generateStaticMarkup) {\n         (props.moduleScriptResources[scriptConfig] = null),\n         (props = []),\n         pushLinkImpl(props, integrity),\n-        JSCompiler_object_inline_bootstrapScripts_1695.add(props),\n+        JSCompiler_object_inline_bootstrapScripts_1691.add(props),\n         bootstrapChunks.push(\n           '<script type=\"module\" src=\"',\n           escapeTextForBrowser(i),\n@@ -2867,7 +2867,7 @@ function createRenderState(resumableState, generateStaticMarkup) {\n         bootstrapChunks.push(' async=\"\">\\x3c/script>');\n   return {\n     placeholderPrefix: bootstrapScriptContent,\n-    segmentPrefix: JSCompiler_object_inline_segmentPrefix_1677,\n+    segmentPrefix: JSCompiler_object_inline_segmentPrefix_1673,\n     boundaryPrefix: idPrefix,\n     startInlineScript: \"<script\",\n     startInlineStyle: \"<style\",\n@@ -2887,14 +2887,14 @@ function createRenderState(resumableState, generateStaticMarkup) {\n     charsetChunks: [],\n     viewportChunks: [],\n     hoistableChunks: [],\n-    preconnects: JSCompiler_object_inline_preconnects_1691,\n-    fontPreloads: JSCompiler_object_inline_fontPreloads_1692,\n-    highImagePreloads: JSCompiler_object_inline_highImagePreloads_1693,\n-    styles: JSCompiler_object_inline_styles_1694,\n-    bootstrapScripts: JSCompiler_object_inline_bootstrapScripts_1695,\n-    scripts: JSCompiler_object_inline_scripts_1696,\n-    bulkPreloads: JSCompiler_object_inline_bulkPreloads_1697,\n-    preloads: JSCompiler_object_inline_preloads_1698,\n+    preconnects: JSCompiler_object_inline_preconnects_1687,\n+    fontPreloads: JSCompiler_object_inline_fontPreloads_1688,\n+    highImagePreloads: JSCompiler_object_inline_highImagePreloads_1689,\n+    styles: JSCompiler_object_inline_styles_1690,\n+    bootstrapScripts: JSCompiler_object_inline_bootstrapScripts_1691,\n+    scripts: JSCompiler_object_inline_scripts_1692,\n+    bulkPreloads: JSCompiler_object_inline_bulkPreloads_1693,\n+    preloads: JSCompiler_object_inline_preloads_1694,\n     nonce: { script: void 0, style: void 0 },\n     stylesToHoist: !1,\n     generateStaticMarkup: generateStaticMarkup\n@@ -5184,6 +5184,105 @@ function renderChildrenArray(request, task, children, childIndex) {\n   task.treeContext = replay;\n   task.keyPath = prevKeyPath;\n }\n+function trackPostponedBoundary(request, trackedPostpones, boundary) {\n+  boundary.status = 5;\n+  boundary.rootSegmentID = request.nextSegmentId++;\n+  request = boundary.trackedContentKeyPath;\n+  if (null === request)\n+    throw Error(\n+      \"It should not be possible to postpone at the root. This is a bug in React.\"\n+    );\n+  var fallbackReplayNode = boundary.trackedFallbackNode,\n+    children = [],\n+    boundaryNode = trackedPostpones.workingMap.get(request);\n+  if (void 0 === boundaryNode)\n+    return (\n+      (boundary = [\n+        request[1],\n+        request[2],\n+        children,\n+        null,\n+        fallbackReplayNode,\n+        boundary.rootSegmentID\n+      ]),\n+      trackedPostpones.workingMap.set(request, boundary),\n+      addToReplayParent(boundary, request[0], trackedPostpones),\n+      boundary\n+    );\n+  boundaryNode[4] = fallbackReplayNode;\n+  boundaryNode[5] = boundary.rootSegmentID;\n+  return boundaryNode;\n+}\n+function trackPostpone(request, trackedPostpones, task, segment) {\n+  segment.status = 5;\n+  var keyPath = task.keyPath,\n+    boundary = task.blockedBoundary;\n+  if (null === boundary)\n+    (segment.id = request.nextSegmentId++),\n+      (trackedPostpones.rootSlots = segment.id),\n+      null !== request.completedRootSegment &&\n+        (request.completedRootSegment.status = 5);\n+  else {\n+    if (null !== boundary && 0 === boundary.status) {\n+      var boundaryNode = trackPostponedBoundary(\n+        request,\n+        trackedPostpones,\n+        boundary\n+      );\n+      if (\n+        boundary.trackedContentKeyPath === keyPath &&\n+        -1 === task.childIndex\n+      ) {\n+        -1 === segment.id &&\n+          (segment.id = segment.parentFlushed\n+            ? boundary.rootSegmentID\n+            : request.nextSegmentId++);\n+        boundaryNode[3] = segment.id;\n+        return;\n+      }\n+    }\n+    -1 === segment.id &&\n+      (segment.id =\n+        segment.parentFlushed && null !== boundary\n+          ? boundary.rootSegmentID\n+          : request.nextSegmentId++);\n+    if (-1 === task.childIndex)\n+      null === keyPath\n+        ? (trackedPostpones.rootSlots = segment.id)\n+        : ((task = trackedPostpones.workingMap.get(keyPath)),\n+          void 0 === task\n+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n+              addToReplayParent(task, keyPath[0], trackedPostpones))\n+            : (task[3] = segment.id));\n+    else {\n+      if (null === keyPath)\n+        if (((request = trackedPostpones.rootSlots), null === request))\n+          request = trackedPostpones.rootSlots = {};\n+        else {\n+          if (\"number\" === typeof request)\n+            throw Error(\n+              \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+            );\n+        }\n+      else if (\n+        ((boundary = trackedPostpones.workingMap),\n+        (boundaryNode = boundary.get(keyPath)),\n+        void 0 === boundaryNode)\n+      )\n+        (request = {}),\n+          (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n+          boundary.set(keyPath, boundaryNode),\n+          addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n+      else if (((request = boundaryNode[3]), null === request))\n+        request = boundaryNode[3] = {};\n+      else if (\"number\" === typeof request)\n+        throw Error(\n+          \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+        );\n+      request[task.childIndex] = segment.id;\n+    }\n+  }\n+}\n function untrackBoundary(request, boundary) {\n   request = request.trackedPostpones;\n   null !== request &&\n@@ -5300,21 +5399,21 @@ function renderNode(request, task, node, childIndex) {\n       chunkLength = segment.chunks.length;\n     try {\n       return renderNodeDestructive(request, task, node, childIndex);\n-    } catch (thrownValue$60) {\n+    } catch (thrownValue$62) {\n       if (\n         (resetHooksState(),\n         (segment.children.length = childrenLength),\n         (segment.chunks.length = chunkLength),\n         (node =\n-          thrownValue$60 === SuspenseException\n+          thrownValue$62 === SuspenseException\n             ? getSuspendedThenable()\n-            : thrownValue$60),\n+            : thrownValue$62),\n         12 !== request.status && \"object\" === typeof node && null !== node)\n       ) {\n         if (\"function\" === typeof node.then) {\n           segment = node;\n           node =\n-            thrownValue$60 === SuspenseException\n+            thrownValue$62 === SuspenseException\n               ? getThenableStateAfterSuspending()\n               : null;\n           request = spawnNewSuspendedRenderTask(request, task, node).ping;\n@@ -5329,7 +5428,7 @@ function renderNode(request, task, node, childIndex) {\n         }\n         if (\"Maximum call stack size exceeded\" === node.message) {\n           segment =\n-            thrownValue$60 === SuspenseException\n+            thrownValue$62 === SuspenseException\n               ? getThenableStateAfterSuspending()\n               : null;\n           segment = spawnNewSuspendedRenderTask(request, task, segment);\n@@ -5417,19 +5516,24 @@ function abortTask(task, request, error) {\n     if (6 === segment.status) return;\n     segment.status = 3;\n   }\n-  segment = getThrownInfo(task.componentStack);\n+  var errorInfo = getThrownInfo(task.componentStack);\n   if (null === boundary) {\n     if (13 !== request.status && 14 !== request.status) {\n       boundary = task.replay;\n       if (null === boundary) {\n-        logRecoverableError(request, error, segment);\n-        fatalError(request, error);\n+        null !== request.trackedPostpones && null !== segment\n+          ? ((boundary = request.trackedPostpones),\n+            logRecoverableError(request, error, errorInfo),\n+            trackPostpone(request, boundary, task, segment),\n+            finishedTask(request, null, task.row, segment))\n+          : (logRecoverableError(request, error, errorInfo),\n+            fatalError(request, error));\n         return;\n       }\n       boundary.pendingTasks--;\n       0 === boundary.pendingTasks &&\n         0 < boundary.nodes.length &&\n-        ((segment = logRecoverableError(request, error, segment)),\n+        ((segment = logRecoverableError(request, error, errorInfo)),\n         abortRemainingReplayNodes(\n           request,\n           null,\n@@ -5441,24 +5545,36 @@ function abortTask(task, request, error) {\n       request.pendingRootTasks--;\n       0 === request.pendingRootTasks && completeShell(request);\n     }\n-  } else\n-    4 !== boundary.status &&\n-      ((boundary.status = 4),\n-      (segment = logRecoverableError(request, error, segment)),\n-      (boundary.status = 4),\n-      (boundary.errorDigest = segment),\n-      untrackBoundary(request, boundary),\n-      boundary.parentFlushed &&\n-        request.clientRenderedBoundaries.push(boundary)),\n-      boundary.pendingTasks--,\n-      (segment = boundary.row),\n-      null !== segment &&\n-        0 === --segment.pendingTasks &&\n-        finishSuspenseListRow(request, segment),\n-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n-        return abortTask(fallbackTask, request, error);\n-      }),\n-      boundary.fallbackAbortableTasks.clear();\n+  } else {\n+    var trackedPostpones$63 = request.trackedPostpones;\n+    if (4 !== boundary.status) {\n+      if (null !== trackedPostpones$63 && null !== segment)\n+        return (\n+          logRecoverableError(request, error, errorInfo),\n+          trackPostpone(request, trackedPostpones$63, task, segment),\n+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+            return abortTask(fallbackTask, request, error);\n+          }),\n+          boundary.fallbackAbortableTasks.clear(),\n+          finishedTask(request, boundary, task.row, segment)\n+        );\n+      boundary.status = 4;\n+      segment = logRecoverableError(request, error, errorInfo);\n+      boundary.status = 4;\n+      boundary.errorDigest = segment;\n+      untrackBoundary(request, boundary);\n+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);\n+    }\n+    boundary.pendingTasks--;\n+    segment = boundary.row;\n+    null !== segment &&\n+      0 === --segment.pendingTasks &&\n+      finishSuspenseListRow(request, segment);\n+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+      return abortTask(fallbackTask, request, error);\n+    });\n+    boundary.fallbackAbortableTasks.clear();\n+  }\n   task = task.row;\n   null !== task &&\n     0 === --task.pendingTasks &&\n@@ -5562,22 +5678,22 @@ function queueCompletedSegment(boundary, segment) {\n       queueCompletedSegment(boundary, childSegment);\n   } else boundary.completedSegments.push(segment);\n }\n-function finishedTask(request$jscomp$0, boundary, row, segment) {\n+function finishedTask(request, boundary, row, segment) {\n   null !== row &&\n     (0 === --row.pendingTasks\n-      ? finishSuspenseListRow(request$jscomp$0, row)\n-      : row.together && tryToResolveTogetherRow(request$jscomp$0, row));\n-  request$jscomp$0.allPendingTasks--;\n+      ? finishSuspenseListRow(request, row)\n+      : row.together && tryToResolveTogetherRow(request, row));\n+  request.allPendingTasks--;\n   if (null === boundary) {\n     if (null !== segment && segment.parentFlushed) {\n-      if (null !== request$jscomp$0.completedRootSegment)\n+      if (null !== request.completedRootSegment)\n         throw Error(\n           \"There can only be one root segment. This is a bug in React.\"\n         );\n-      request$jscomp$0.completedRootSegment = segment;\n+      request.completedRootSegment = segment;\n     }\n-    request$jscomp$0.pendingRootTasks--;\n-    0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);\n+    request.pendingRootTasks--;\n+    0 === request.pendingRootTasks && completeShell(request);\n   } else if ((boundary.pendingTasks--, 4 !== boundary.status))\n     if (0 === boundary.pendingTasks)\n       if (\n@@ -5586,33 +5702,29 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n           segment.parentFlushed &&\n           (1 === segment.status || 3 === segment.status) &&\n           queueCompletedSegment(boundary, segment),\n-        boundary.parentFlushed &&\n-          request$jscomp$0.completedBoundaries.push(boundary),\n+        boundary.parentFlushed && request.completedBoundaries.push(boundary),\n         1 === boundary.status)\n       )\n         (row = boundary.row),\n           null !== row &&\n             hoistHoistables(row.hoistables, boundary.contentState),\n-          isEligibleForOutlining(request$jscomp$0, boundary) ||\n-            (boundary.fallbackAbortableTasks.forEach(\n-              abortTaskSoft,\n-              request$jscomp$0\n-            ),\n+          isEligibleForOutlining(request, boundary) ||\n+            (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),\n             boundary.fallbackAbortableTasks.clear(),\n             null !== row &&\n               0 === --row.pendingTasks &&\n-              finishSuspenseListRow(request$jscomp$0, row)),\n-          0 === request$jscomp$0.pendingRootTasks &&\n-            null === request$jscomp$0.trackedPostpones &&\n+              finishSuspenseListRow(request, row)),\n+          0 === request.pendingRootTasks &&\n+            null === request.trackedPostpones &&\n             null !== boundary.contentPreamble &&\n-            preparePreamble(request$jscomp$0);\n+            preparePreamble(request);\n       else {\n         if (\n           5 === boundary.status &&\n           ((boundary = boundary.row), null !== boundary)\n         ) {\n-          if (null !== request$jscomp$0.trackedPostpones) {\n-            row = request$jscomp$0.trackedPostpones;\n+          if (null !== request.trackedPostpones) {\n+            row = request.trackedPostpones;\n             var postponedRow = boundary.next;\n             if (\n               null !== postponedRow &&\n@@ -5624,43 +5736,12 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n                 postponedRow++\n               ) {\n                 var postponedBoundary = segment[postponedRow];\n-                var request = request$jscomp$0,\n-                  trackedPostpones = row;\n-                postponedBoundary.status = 5;\n-                postponedBoundary.rootSegmentID = request.nextSegmentId++;\n-                request = postponedBoundary.trackedContentKeyPath;\n-                if (null === request)\n-                  throw Error(\n-                    \"It should not be possible to postpone at the root. This is a bug in React.\"\n-                  );\n-                var fallbackReplayNode = postponedBoundary.trackedFallbackNode,\n-                  children = [],\n-                  boundaryNode = trackedPostpones.workingMap.get(request);\n-                void 0 === boundaryNode\n-                  ? ((fallbackReplayNode = [\n-                      request[1],\n-                      request[2],\n-                      children,\n-                      null,\n-                      fallbackReplayNode,\n-                      postponedBoundary.rootSegmentID\n-                    ]),\n-                    trackedPostpones.workingMap.set(\n-                      request,\n-                      fallbackReplayNode\n-                    ),\n-                    addToReplayParent(\n-                      fallbackReplayNode,\n-                      request[0],\n-                      trackedPostpones\n-                    ))\n-                  : ((boundaryNode[4] = fallbackReplayNode),\n-                    (boundaryNode[5] = postponedBoundary.rootSegmentID));\n-                finishedTask(request$jscomp$0, postponedBoundary, null, null);\n+                trackPostponedBoundary(request, row, postponedBoundary);\n+                finishedTask(request, postponedBoundary, null, null);\n               }\n           }\n           0 === --boundary.pendingTasks &&\n-            finishSuspenseListRow(request$jscomp$0, boundary);\n+            finishSuspenseListRow(request, boundary);\n         }\n       }\n     else\n@@ -5670,12 +5751,12 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n         (queueCompletedSegment(boundary, segment),\n         1 === boundary.completedSegments.length &&\n           boundary.parentFlushed &&\n-          request$jscomp$0.partialBoundaries.push(boundary)),\n+          request.partialBoundaries.push(boundary)),\n         (boundary = boundary.row),\n         null !== boundary &&\n           boundary.together &&\n-          tryToResolveTogetherRow(request$jscomp$0, boundary);\n-  0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n+          tryToResolveTogetherRow(request, boundary);\n+  0 === request.allPendingTasks && completeAll(request);\n }\n function performWork(request$jscomp$2) {\n   if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {\n@@ -5812,7 +5893,19 @@ function performWork(request$jscomp$2) {\n                 : 12 === request.status\n                   ? request.fatalError\n                   : thrownValue;\n-            if (\n+            if (12 === request.status && null !== request.trackedPostpones) {\n+              var trackedPostpones = request.trackedPostpones,\n+                thrownInfo = getThrownInfo(task.componentStack);\n+              task.abortSet.delete(task);\n+              logRecoverableError(request, x$jscomp$0, thrownInfo);\n+              trackPostpone(request, trackedPostpones, task, request$jscomp$1);\n+              finishedTask(\n+                request,\n+                task.blockedBoundary,\n+                task.row,\n+                request$jscomp$1\n+              );\n+            } else if (\n               \"object\" === typeof x$jscomp$0 &&\n               null !== x$jscomp$0 &&\n               \"function\" === typeof x$jscomp$0.then\n@@ -6391,12 +6484,12 @@ function flushCompletedQueues(request, destination) {\n       flushingPartialBoundaries = !0;\n       var partialBoundaries = request.partialBoundaries;\n       for (i = 0; i < partialBoundaries.length; i++) {\n-        var boundary$66 = partialBoundaries[i];\n+        var boundary$69 = partialBoundaries[i];\n         a: {\n           clientRenderedBoundaries = request;\n           boundary = destination;\n-          flushedByteSize = boundary$66.byteSize;\n-          var completedSegments = boundary$66.completedSegments;\n+          flushedByteSize = boundary$69.byteSize;\n+          var completedSegments = boundary$69.completedSegments;\n           for (\n             JSCompiler_inline_result = 0;\n             JSCompiler_inline_result < completedSegments.length;\n@@ -6406,7 +6499,7 @@ function flushCompletedQueues(request, destination) {\n               !flushPartiallyCompletedSegment(\n                 clientRenderedBoundaries,\n                 boundary,\n-                boundary$66,\n+                boundary$69,\n                 completedSegments[JSCompiler_inline_result]\n               )\n             ) {\n@@ -6416,10 +6509,10 @@ function flushCompletedQueues(request, destination) {\n               break a;\n             }\n           completedSegments.splice(0, JSCompiler_inline_result);\n-          var row = boundary$66.row;\n+          var row = boundary$69.row;\n           null !== row &&\n             row.together &&\n-            1 === boundary$66.pendingTasks &&\n+            1 === boundary$69.pendingTasks &&\n             (1 === row.pendingTasks\n               ? unblockSuspenseListRow(\n                   clientRenderedBoundaries,\n@@ -6429,7 +6522,7 @@ function flushCompletedQueues(request, destination) {\n               : row.pendingTasks--);\n           JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n             boundary,\n-            boundary$66.contentState,\n+            boundary$69.contentState,\n             clientRenderedBoundaries.renderState\n           );\n         }\n@@ -6514,8 +6607,8 @@ function abort(request, reason) {\n     }\n     null !== request.destination &&\n       flushCompletedQueues(request, request.destination);\n-  } catch (error$68) {\n-    logRecoverableError(request, error$68, {}), fatalError(request, error$68);\n+  } catch (error$71) {\n+    logRecoverableError(request, error$71, {}), fatalError(request, error$71);\n   }\n }\n function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n@@ -6596,4 +6689,4 @@ exports.renderToString = function (children, options) {\n     'The server used \"renderToString\" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to \"renderToPipeableStream\" which supports Suspense on the server'\n   );\n };\n-exports.version = \"19.2.0-canary-548235db-20251001\";\n+exports.version = \"19.2.0-canary-1bd1f01f-20251001\";"
        },
        {
            "sha": "0325a36993f514f650f57600706db72dc9f2bc84",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.browser.development.js",
            "status": "modified",
            "additions": 511,
            "deletions": 129,
            "changes": 640,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.browser.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -4526,6 +4526,12 @@\n       }\n       return \"\";\n     }\n+    function resetOwnerStackLimit() {\n+      var now = getCurrentTime();\n+      1e3 < now - lastResetTime &&\n+        ((ReactSharedInternals.recentlyCreatedOwnerStacks = 0),\n+        (lastResetTime = now));\n+    }\n     function isEligibleForOutlining(request, boundary) {\n       return (\n         (500 < boundary.byteSize ||\n@@ -4619,10 +4625,7 @@\n       onPostpone,\n       formState\n     ) {\n-      var now = getCurrentTime();\n-      1e3 < now - lastResetTime &&\n-        ((ReactSharedInternals.recentlyCreatedOwnerStacks = 0),\n-        (lastResetTime = now));\n+      resetOwnerStackLimit();\n       resumableState = new RequestInstance(\n         resumableState,\n         renderState,\n@@ -4702,6 +4705,121 @@\n       };\n       return children;\n     }\n+    function resumeRequest(\n+      children,\n+      postponedState,\n+      renderState,\n+      onError,\n+      onAllReady,\n+      onShellReady,\n+      onShellError,\n+      onFatalError,\n+      onPostpone\n+    ) {\n+      resetOwnerStackLimit();\n+      renderState = new RequestInstance(\n+        postponedState.resumableState,\n+        renderState,\n+        postponedState.rootFormatContext,\n+        postponedState.progressiveChunkSize,\n+        onError,\n+        onAllReady,\n+        onShellReady,\n+        onShellError,\n+        onFatalError,\n+        onPostpone,\n+        null\n+      );\n+      renderState.nextSegmentId = postponedState.nextSegmentId;\n+      if (\"number\" === typeof postponedState.replaySlots)\n+        return (\n+          (onError = createPendingSegment(\n+            renderState,\n+            0,\n+            null,\n+            postponedState.rootFormatContext,\n+            !1,\n+            !1\n+          )),\n+          (onError.parentFlushed = !0),\n+          (children = createRenderTask(\n+            renderState,\n+            null,\n+            children,\n+            -1,\n+            null,\n+            onError,\n+            null,\n+            null,\n+            renderState.abortableTasks,\n+            null,\n+            postponedState.rootFormatContext,\n+            null,\n+            emptyTreeContext,\n+            null,\n+            null,\n+            emptyContextObject,\n+            null\n+          )),\n+          pushComponentStack(children),\n+          renderState.pingedTasks.push(children),\n+          renderState\n+        );\n+      children = createReplayTask(\n+        renderState,\n+        null,\n+        {\n+          nodes: postponedState.replayNodes,\n+          slots: postponedState.replaySlots,\n+          pendingTasks: 0\n+        },\n+        children,\n+        -1,\n+        null,\n+        null,\n+        renderState.abortableTasks,\n+        null,\n+        postponedState.rootFormatContext,\n+        null,\n+        emptyTreeContext,\n+        null,\n+        null,\n+        emptyContextObject,\n+        null\n+      );\n+      pushComponentStack(children);\n+      renderState.pingedTasks.push(children);\n+      return renderState;\n+    }\n+    function resumeAndPrerenderRequest(\n+      children,\n+      postponedState,\n+      renderState,\n+      onError,\n+      onAllReady,\n+      onShellReady,\n+      onShellError,\n+      onFatalError,\n+      onPostpone\n+    ) {\n+      children = resumeRequest(\n+        children,\n+        postponedState,\n+        renderState,\n+        onError,\n+        onAllReady,\n+        onShellReady,\n+        onShellError,\n+        onFatalError,\n+        onPostpone\n+      );\n+      children.trackedPostpones = {\n+        workingMap: new Map(),\n+        rootNodes: [],\n+        rootSlots: null\n+      };\n+      return children;\n+    }\n     function pingTask(request, task) {\n       request.pingedTasks.push(task);\n       1 === request.pingedTasks.length &&\n@@ -6897,6 +7015,105 @@\n       task.componentStack = previousComponentStack;\n       task.debugTask = previousDebugTask;\n     }\n+    function trackPostponedBoundary(request, trackedPostpones, boundary) {\n+      boundary.status = POSTPONED;\n+      boundary.rootSegmentID = request.nextSegmentId++;\n+      request = boundary.trackedContentKeyPath;\n+      if (null === request)\n+        throw Error(\n+          \"It should not be possible to postpone at the root. This is a bug in React.\"\n+        );\n+      var fallbackReplayNode = boundary.trackedFallbackNode,\n+        children = [],\n+        boundaryNode = trackedPostpones.workingMap.get(request);\n+      if (void 0 === boundaryNode)\n+        return (\n+          (boundary = [\n+            request[1],\n+            request[2],\n+            children,\n+            null,\n+            fallbackReplayNode,\n+            boundary.rootSegmentID\n+          ]),\n+          trackedPostpones.workingMap.set(request, boundary),\n+          addToReplayParent(boundary, request[0], trackedPostpones),\n+          boundary\n+        );\n+      boundaryNode[4] = fallbackReplayNode;\n+      boundaryNode[5] = boundary.rootSegmentID;\n+      return boundaryNode;\n+    }\n+    function trackPostpone(request, trackedPostpones, task, segment) {\n+      segment.status = POSTPONED;\n+      var keyPath = task.keyPath,\n+        boundary = task.blockedBoundary;\n+      if (null === boundary)\n+        (segment.id = request.nextSegmentId++),\n+          (trackedPostpones.rootSlots = segment.id),\n+          null !== request.completedRootSegment &&\n+            (request.completedRootSegment.status = POSTPONED);\n+      else {\n+        if (null !== boundary && boundary.status === PENDING) {\n+          var boundaryNode = trackPostponedBoundary(\n+            request,\n+            trackedPostpones,\n+            boundary\n+          );\n+          if (\n+            boundary.trackedContentKeyPath === keyPath &&\n+            -1 === task.childIndex\n+          ) {\n+            -1 === segment.id &&\n+              (segment.id = segment.parentFlushed\n+                ? boundary.rootSegmentID\n+                : request.nextSegmentId++);\n+            boundaryNode[3] = segment.id;\n+            return;\n+          }\n+        }\n+        -1 === segment.id &&\n+          (segment.id =\n+            segment.parentFlushed && null !== boundary\n+              ? boundary.rootSegmentID\n+              : request.nextSegmentId++);\n+        if (-1 === task.childIndex)\n+          null === keyPath\n+            ? (trackedPostpones.rootSlots = segment.id)\n+            : ((task = trackedPostpones.workingMap.get(keyPath)),\n+              void 0 === task\n+                ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n+                  addToReplayParent(task, keyPath[0], trackedPostpones))\n+                : (task[3] = segment.id));\n+        else {\n+          if (null === keyPath)\n+            if (((request = trackedPostpones.rootSlots), null === request))\n+              request = trackedPostpones.rootSlots = {};\n+            else {\n+              if (\"number\" === typeof request)\n+                throw Error(\n+                  \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+                );\n+            }\n+          else if (\n+            ((boundary = trackedPostpones.workingMap),\n+            (boundaryNode = boundary.get(keyPath)),\n+            void 0 === boundaryNode)\n+          )\n+            (request = {}),\n+              (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n+              boundary.set(keyPath, boundaryNode),\n+              addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n+          else if (((request = boundaryNode[3]), null === request))\n+            request = boundaryNode[3] = {};\n+          else if (\"number\" === typeof request)\n+            throw Error(\n+              \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+            );\n+          request[task.childIndex] = segment.id;\n+        }\n+      }\n+    }\n     function untrackBoundary(request, boundary) {\n       request = request.trackedPostpones;\n       null !== request &&\n@@ -7164,54 +7381,77 @@\n         if (6 === segment.status) return;\n         segment.status = ABORTED;\n       }\n-      segment = getThrownInfo(task.componentStack);\n-      var node = task.node;\n+      var errorInfo = getThrownInfo(task.componentStack),\n+        node = task.node;\n       null !== node &&\n         \"object\" === typeof node &&\n         pushHaltedAwaitOnComponentStack(task, node._debugInfo);\n       if (null === boundary) {\n         if (13 !== request.status && request.status !== CLOSED) {\n           boundary = task.replay;\n           if (null === boundary) {\n-            logRecoverableError(request, error, segment, task.debugTask);\n-            fatalError(request, error, segment, task.debugTask);\n+            null !== request.trackedPostpones && null !== segment\n+              ? ((boundary = request.trackedPostpones),\n+                logRecoverableError(request, error, errorInfo, task.debugTask),\n+                trackPostpone(request, boundary, task, segment),\n+                finishedTask(request, null, task.row, segment))\n+              : (logRecoverableError(request, error, errorInfo, task.debugTask),\n+                fatalError(request, error, errorInfo, task.debugTask));\n             return;\n           }\n           boundary.pendingTasks--;\n           0 === boundary.pendingTasks &&\n             0 < boundary.nodes.length &&\n-            ((node = logRecoverableError(request, error, segment, null)),\n+            ((segment = logRecoverableError(request, error, errorInfo, null)),\n             abortRemainingReplayNodes(\n               request,\n               null,\n               boundary.nodes,\n               boundary.slots,\n               error,\n-              node,\n               segment,\n+              errorInfo,\n               !0\n             ));\n           request.pendingRootTasks--;\n           0 === request.pendingRootTasks && completeShell(request);\n         }\n-      } else\n-        boundary.status !== CLIENT_RENDERED &&\n-          ((boundary.status = CLIENT_RENDERED),\n-          (node = logRecoverableError(request, error, segment, task.debugTask)),\n-          (boundary.status = CLIENT_RENDERED),\n-          encodeErrorForBoundary(boundary, node, error, segment, !0),\n-          untrackBoundary(request, boundary),\n+      } else {\n+        node = request.trackedPostpones;\n+        if (boundary.status !== CLIENT_RENDERED) {\n+          if (null !== node && null !== segment)\n+            return (\n+              logRecoverableError(request, error, errorInfo, task.debugTask),\n+              trackPostpone(request, node, task, segment),\n+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+                return abortTask(fallbackTask, request, error);\n+              }),\n+              boundary.fallbackAbortableTasks.clear(),\n+              finishedTask(request, boundary, task.row, segment)\n+            );\n+          boundary.status = CLIENT_RENDERED;\n+          segment = logRecoverableError(\n+            request,\n+            error,\n+            errorInfo,\n+            task.debugTask\n+          );\n+          boundary.status = CLIENT_RENDERED;\n+          encodeErrorForBoundary(boundary, segment, error, errorInfo, !0);\n+          untrackBoundary(request, boundary);\n           boundary.parentFlushed &&\n-            request.clientRenderedBoundaries.push(boundary)),\n-          boundary.pendingTasks--,\n-          (segment = boundary.row),\n-          null !== segment &&\n-            0 === --segment.pendingTasks &&\n-            finishSuspenseListRow(request, segment),\n-          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n-            return abortTask(fallbackTask, request, error);\n-          }),\n-          boundary.fallbackAbortableTasks.clear();\n+            request.clientRenderedBoundaries.push(boundary);\n+        }\n+        boundary.pendingTasks--;\n+        errorInfo = boundary.row;\n+        null !== errorInfo &&\n+          0 === --errorInfo.pendingTasks &&\n+          finishSuspenseListRow(request, errorInfo);\n+        boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+          return abortTask(fallbackTask, request, error);\n+        });\n+        boundary.fallbackAbortableTasks.clear();\n+      }\n       task = task.row;\n       null !== task &&\n         0 === --task.pendingTasks &&\n@@ -7329,64 +7569,58 @@\n           : (boundary.byteSize += segmentByteSize);\n       }\n     }\n-    function finishedTask(request$jscomp$0, boundary$jscomp$0, row, segment) {\n+    function finishedTask(request, boundary, row, segment) {\n       null !== row &&\n         (0 === --row.pendingTasks\n-          ? finishSuspenseListRow(request$jscomp$0, row)\n-          : row.together && tryToResolveTogetherRow(request$jscomp$0, row));\n-      request$jscomp$0.allPendingTasks--;\n-      if (null === boundary$jscomp$0) {\n+          ? finishSuspenseListRow(request, row)\n+          : row.together && tryToResolveTogetherRow(request, row));\n+      request.allPendingTasks--;\n+      if (null === boundary) {\n         if (null !== segment && segment.parentFlushed) {\n-          if (null !== request$jscomp$0.completedRootSegment)\n+          if (null !== request.completedRootSegment)\n             throw Error(\n               \"There can only be one root segment. This is a bug in React.\"\n             );\n-          request$jscomp$0.completedRootSegment = segment;\n+          request.completedRootSegment = segment;\n         }\n-        request$jscomp$0.pendingRootTasks--;\n-        0 === request$jscomp$0.pendingRootTasks &&\n-          completeShell(request$jscomp$0);\n-      } else if (\n-        (boundary$jscomp$0.pendingTasks--,\n-        boundary$jscomp$0.status !== CLIENT_RENDERED)\n-      )\n-        if (0 === boundary$jscomp$0.pendingTasks)\n+        request.pendingRootTasks--;\n+        0 === request.pendingRootTasks && completeShell(request);\n+      } else if ((boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED))\n+        if (0 === boundary.pendingTasks)\n           if (\n-            (boundary$jscomp$0.status === PENDING &&\n-              (boundary$jscomp$0.status = COMPLETED),\n+            (boundary.status === PENDING && (boundary.status = COMPLETED),\n             null !== segment &&\n               segment.parentFlushed &&\n               (segment.status === COMPLETED || segment.status === ABORTED) &&\n-              queueCompletedSegment(boundary$jscomp$0, segment),\n-            boundary$jscomp$0.parentFlushed &&\n-              request$jscomp$0.completedBoundaries.push(boundary$jscomp$0),\n-            boundary$jscomp$0.status === COMPLETED)\n+              queueCompletedSegment(boundary, segment),\n+            boundary.parentFlushed &&\n+              request.completedBoundaries.push(boundary),\n+            boundary.status === COMPLETED)\n           )\n-            (row = boundary$jscomp$0.row),\n+            (row = boundary.row),\n               null !== row &&\n-                hoistHoistables(row.hoistables, boundary$jscomp$0.contentState),\n-              isEligibleForOutlining(request$jscomp$0, boundary$jscomp$0) ||\n-                (boundary$jscomp$0.fallbackAbortableTasks.forEach(\n+                hoistHoistables(row.hoistables, boundary.contentState),\n+              isEligibleForOutlining(request, boundary) ||\n+                (boundary.fallbackAbortableTasks.forEach(\n                   abortTaskSoft,\n-                  request$jscomp$0\n+                  request\n                 ),\n-                boundary$jscomp$0.fallbackAbortableTasks.clear(),\n+                boundary.fallbackAbortableTasks.clear(),\n                 null !== row &&\n                   0 === --row.pendingTasks &&\n-                  finishSuspenseListRow(request$jscomp$0, row)),\n-              0 === request$jscomp$0.pendingRootTasks &&\n-                null === request$jscomp$0.trackedPostpones &&\n-                null !== boundary$jscomp$0.contentPreamble &&\n-                preparePreamble(request$jscomp$0);\n+                  finishSuspenseListRow(request, row)),\n+              0 === request.pendingRootTasks &&\n+                null === request.trackedPostpones &&\n+                null !== boundary.contentPreamble &&\n+                preparePreamble(request);\n           else {\n             if (\n-              boundary$jscomp$0.status === POSTPONED &&\n-              ((boundary$jscomp$0 = boundary$jscomp$0.row),\n-              null !== boundary$jscomp$0)\n+              boundary.status === POSTPONED &&\n+              ((boundary = boundary.row), null !== boundary)\n             ) {\n-              if (null !== request$jscomp$0.trackedPostpones) {\n-                row = request$jscomp$0.trackedPostpones;\n-                var postponedRow = boundary$jscomp$0.next;\n+              if (null !== request.trackedPostpones) {\n+                row = request.trackedPostpones;\n+                var postponedRow = boundary.next;\n                 if (\n                   null !== postponedRow &&\n                   ((segment = postponedRow.boundaries), null !== segment)\n@@ -7397,61 +7631,27 @@\n                     postponedRow++\n                   ) {\n                     var postponedBoundary = segment[postponedRow];\n-                    var request = request$jscomp$0,\n-                      trackedPostpones = row,\n-                      boundary = postponedBoundary;\n-                    boundary.status = POSTPONED;\n-                    boundary.rootSegmentID = request.nextSegmentId++;\n-                    request = boundary.trackedContentKeyPath;\n-                    if (null === request)\n-                      throw Error(\n-                        \"It should not be possible to postpone at the root. This is a bug in React.\"\n-                      );\n-                    var fallbackReplayNode = boundary.trackedFallbackNode,\n-                      children = [],\n-                      boundaryNode = trackedPostpones.workingMap.get(request);\n-                    void 0 === boundaryNode\n-                      ? ((boundary = [\n-                          request[1],\n-                          request[2],\n-                          children,\n-                          null,\n-                          fallbackReplayNode,\n-                          boundary.rootSegmentID\n-                        ]),\n-                        trackedPostpones.workingMap.set(request, boundary),\n-                        addToReplayParent(\n-                          boundary,\n-                          request[0],\n-                          trackedPostpones\n-                        ))\n-                      : ((boundaryNode[4] = fallbackReplayNode),\n-                        (boundaryNode[5] = boundary.rootSegmentID));\n-                    finishedTask(\n-                      request$jscomp$0,\n-                      postponedBoundary,\n-                      null,\n-                      null\n-                    );\n+                    trackPostponedBoundary(request, row, postponedBoundary);\n+                    finishedTask(request, postponedBoundary, null, null);\n                   }\n               }\n-              0 === --boundary$jscomp$0.pendingTasks &&\n-                finishSuspenseListRow(request$jscomp$0, boundary$jscomp$0);\n+              0 === --boundary.pendingTasks &&\n+                finishSuspenseListRow(request, boundary);\n             }\n           }\n         else\n           null === segment ||\n             !segment.parentFlushed ||\n             (segment.status !== COMPLETED && segment.status !== ABORTED) ||\n-            (queueCompletedSegment(boundary$jscomp$0, segment),\n-            1 === boundary$jscomp$0.completedSegments.length &&\n-              boundary$jscomp$0.parentFlushed &&\n-              request$jscomp$0.partialBoundaries.push(boundary$jscomp$0)),\n-            (boundary$jscomp$0 = boundary$jscomp$0.row),\n-            null !== boundary$jscomp$0 &&\n-              boundary$jscomp$0.together &&\n-              tryToResolveTogetherRow(request$jscomp$0, boundary$jscomp$0);\n-      0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n+            (queueCompletedSegment(boundary, segment),\n+            1 === boundary.completedSegments.length &&\n+              boundary.parentFlushed &&\n+              request.partialBoundaries.push(boundary)),\n+            (boundary = boundary.row),\n+            null !== boundary &&\n+              boundary.together &&\n+              tryToResolveTogetherRow(request, boundary);\n+      0 === request.allPendingTasks && completeAll(request);\n     }\n     function performWork(request$jscomp$2) {\n       if (\n@@ -7608,6 +7808,31 @@\n                       ? request.fatalError\n                       : thrownValue;\n                 if (\n+                  12 === request.status &&\n+                  null !== request.trackedPostpones\n+                ) {\n+                  var trackedPostpones = request.trackedPostpones,\n+                    thrownInfo = getThrownInfo(errorDigest.componentStack);\n+                  errorDigest.abortSet.delete(errorDigest);\n+                  logRecoverableError(\n+                    request,\n+                    x$jscomp$0,\n+                    thrownInfo,\n+                    errorDigest.debugTask\n+                  );\n+                  trackPostpone(\n+                    request,\n+                    trackedPostpones,\n+                    errorDigest,\n+                    request$jscomp$1\n+                  );\n+                  finishedTask(\n+                    request,\n+                    errorDigest.blockedBoundary,\n+                    errorDigest.row,\n+                    request$jscomp$1\n+                  );\n+                } else if (\n                   \"object\" === typeof x$jscomp$0 &&\n                   null !== x$jscomp$0 &&\n                   \"function\" === typeof x$jscomp$0.then\n@@ -8511,13 +8736,59 @@\n         parentNode[2].push(node);\n       }\n     }\n+    function getPostponedState(request) {\n+      var trackedPostpones = request.trackedPostpones;\n+      if (\n+        null === trackedPostpones ||\n+        (0 === trackedPostpones.rootNodes.length &&\n+          null === trackedPostpones.rootSlots)\n+      )\n+        return (request.trackedPostpones = null);\n+      if (\n+        null === request.completedRootSegment ||\n+        (request.completedRootSegment.status !== POSTPONED &&\n+          null !== request.completedPreambleSegments)\n+      ) {\n+        var nextSegmentId = request.nextSegmentId;\n+        var replaySlots = trackedPostpones.rootSlots;\n+        var resumableState = request.resumableState;\n+        resumableState.bootstrapScriptContent = void 0;\n+        resumableState.bootstrapScripts = void 0;\n+        resumableState.bootstrapModules = void 0;\n+      } else {\n+        nextSegmentId = 0;\n+        replaySlots = -1;\n+        resumableState = request.resumableState;\n+        var renderState = request.renderState;\n+        resumableState.nextFormID = 0;\n+        resumableState.hasBody = !1;\n+        resumableState.hasHtml = !1;\n+        resumableState.unknownResources = { font: renderState.resets.font };\n+        resumableState.dnsResources = renderState.resets.dns;\n+        resumableState.connectResources = renderState.resets.connect;\n+        resumableState.imageResources = renderState.resets.image;\n+        resumableState.styleResources = renderState.resets.style;\n+        resumableState.scriptResources = {};\n+        resumableState.moduleUnknownResources = {};\n+        resumableState.moduleScriptResources = {};\n+        resumableState.instructions = NothingSent;\n+      }\n+      return {\n+        nextSegmentId: nextSegmentId,\n+        rootFormatContext: request.rootFormatContext,\n+        progressiveChunkSize: request.progressiveChunkSize,\n+        resumableState: request.resumableState,\n+        replayNodes: trackedPostpones.rootNodes,\n+        replaySlots: replaySlots\n+      };\n+    }\n     function ensureCorrectIsomorphicReactVersion() {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.2.0-canary-548235db-20251001\" !== isomorphicReactPackageVersion)\n+      if (\"19.2.0-canary-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.2.0-canary-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.2.0-canary-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     }\n     var React = require(\"next/dist/compiled/react\"),\n@@ -10104,22 +10375,24 @@\n             options ? options.progressiveChunkSize : void 0,\n             options ? options.onError : void 0,\n             function () {\n-              var result = {\n-                prelude: new ReadableStream(\n-                  {\n-                    type: \"bytes\",\n-                    pull: function (controller) {\n-                      startFlowing(request, controller);\n-                    },\n-                    cancel: function (reason) {\n-                      request.destination = null;\n-                      abort(request, reason);\n-                    }\n+              var stream = new ReadableStream(\n+                {\n+                  type: \"bytes\",\n+                  pull: function (controller) {\n+                    startFlowing(request, controller);\n                   },\n-                  { highWaterMark: 0 }\n-                )\n+                  cancel: function (reason) {\n+                    request.destination = null;\n+                    abort(request, reason);\n+                  }\n+                },\n+                { highWaterMark: 0 }\n+              );\n+              stream = {\n+                postponed: getPostponedState(request),\n+                prelude: stream\n               };\n-              resolve(result);\n+              resolve(stream);\n             },\n             void 0,\n             void 0,\n@@ -10215,5 +10488,114 @@\n         startWork(request);\n       });\n     };\n-    exports.version = \"19.2.0-canary-548235db-20251001\";\n+    exports.resume = function (children, postponedState, options) {\n+      return new Promise(function (resolve, reject) {\n+        var onFatalError,\n+          onAllReady,\n+          allReady = new Promise(function (res, rej) {\n+            onAllReady = res;\n+            onFatalError = rej;\n+          }),\n+          request = resumeRequest(\n+            children,\n+            postponedState,\n+            createRenderState(\n+              postponedState.resumableState,\n+              options ? options.nonce : void 0,\n+              void 0,\n+              void 0,\n+              void 0,\n+              void 0\n+            ),\n+            options ? options.onError : void 0,\n+            onAllReady,\n+            function () {\n+              var stream = new ReadableStream(\n+                {\n+                  type: \"bytes\",\n+                  pull: function (controller) {\n+                    startFlowing(request, controller);\n+                  },\n+                  cancel: function (reason) {\n+                    request.destination = null;\n+                    abort(request, reason);\n+                  }\n+                },\n+                { highWaterMark: 0 }\n+              );\n+              stream.allReady = allReady;\n+              resolve(stream);\n+            },\n+            function (error) {\n+              allReady.catch(function () {});\n+              reject(error);\n+            },\n+            onFatalError,\n+            options ? options.onPostpone : void 0\n+          );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.resumeAndPrerender = function (children, postponedState, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = resumeAndPrerenderRequest(\n+          children,\n+          postponedState,\n+          createRenderState(\n+            postponedState.resumableState,\n+            void 0,\n+            void 0,\n+            void 0,\n+            void 0,\n+            void 0\n+          ),\n+          options ? options.onError : void 0,\n+          function () {\n+            var stream = new ReadableStream(\n+              {\n+                type: \"bytes\",\n+                pull: function (controller) {\n+                  startFlowing(request, controller);\n+                },\n+                cancel: function (reason) {\n+                  request.destination = null;\n+                  abort(request, reason);\n+                }\n+              },\n+              { highWaterMark: 0 }\n+            );\n+            stream = { postponed: getPostponedState(request), prelude: stream };\n+            resolve(stream);\n+          },\n+          void 0,\n+          void 0,\n+          reject,\n+          options ? options.onPostpone : void 0\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.version = \"19.2.0-canary-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "1ba358cb2b418e68e736575cb45520ee98b4b833",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.browser.production.js",
            "status": "modified",
            "additions": 480,
            "deletions": 127,
            "changes": 607,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.browser.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -4188,6 +4188,116 @@ function createPrerenderRequest(\n   };\n   return children;\n }\n+function resumeRequest(\n+  children,\n+  postponedState,\n+  renderState,\n+  onError,\n+  onAllReady,\n+  onShellReady,\n+  onShellError,\n+  onFatalError,\n+  onPostpone\n+) {\n+  renderState = new RequestInstance(\n+    postponedState.resumableState,\n+    renderState,\n+    postponedState.rootFormatContext,\n+    postponedState.progressiveChunkSize,\n+    onError,\n+    onAllReady,\n+    onShellReady,\n+    onShellError,\n+    onFatalError,\n+    onPostpone,\n+    null\n+  );\n+  renderState.nextSegmentId = postponedState.nextSegmentId;\n+  if (\"number\" === typeof postponedState.replaySlots)\n+    return (\n+      (onError = createPendingSegment(\n+        renderState,\n+        0,\n+        null,\n+        postponedState.rootFormatContext,\n+        !1,\n+        !1\n+      )),\n+      (onError.parentFlushed = !0),\n+      (children = createRenderTask(\n+        renderState,\n+        null,\n+        children,\n+        -1,\n+        null,\n+        onError,\n+        null,\n+        null,\n+        renderState.abortableTasks,\n+        null,\n+        postponedState.rootFormatContext,\n+        null,\n+        emptyTreeContext,\n+        null,\n+        null\n+      )),\n+      pushComponentStack(children),\n+      renderState.pingedTasks.push(children),\n+      renderState\n+    );\n+  children = createReplayTask(\n+    renderState,\n+    null,\n+    {\n+      nodes: postponedState.replayNodes,\n+      slots: postponedState.replaySlots,\n+      pendingTasks: 0\n+    },\n+    children,\n+    -1,\n+    null,\n+    null,\n+    renderState.abortableTasks,\n+    null,\n+    postponedState.rootFormatContext,\n+    null,\n+    emptyTreeContext,\n+    null,\n+    null\n+  );\n+  pushComponentStack(children);\n+  renderState.pingedTasks.push(children);\n+  return renderState;\n+}\n+function resumeAndPrerenderRequest(\n+  children,\n+  postponedState,\n+  renderState,\n+  onError,\n+  onAllReady,\n+  onShellReady,\n+  onShellError,\n+  onFatalError,\n+  onPostpone\n+) {\n+  children = resumeRequest(\n+    children,\n+    postponedState,\n+    renderState,\n+    onError,\n+    onAllReady,\n+    onShellReady,\n+    onShellError,\n+    onFatalError,\n+    onPostpone\n+  );\n+  children.trackedPostpones = {\n+    workingMap: new Map(),\n+    rootNodes: [],\n+    rootSlots: null\n+  };\n+  return children;\n+}\n var currentRequest = null;\n function pingTask(request, task) {\n   request.pingedTasks.push(task);\n@@ -4636,9 +4746,9 @@ function renderElement(request, task, keyPath, type, props, ref) {\n       var defaultProps = type.defaultProps;\n       if (defaultProps) {\n         newProps === props && (newProps = assign({}, newProps, props));\n-        for (var propName$43 in defaultProps)\n-          void 0 === newProps[propName$43] &&\n-            (newProps[propName$43] = defaultProps[propName$43]);\n+        for (var propName$44 in defaultProps)\n+          void 0 === newProps[propName$44] &&\n+            (newProps[propName$44] = defaultProps[propName$44]);\n       }\n       props = newProps;\n       newProps = emptyContextObject;\n@@ -4698,16 +4808,16 @@ function renderElement(request, task, keyPath, type, props, ref) {\n             defaultProps = ref ? type[0] : newProps.state;\n             initialState = !0;\n             for (ref = ref ? 1 : 0; ref < type.length; ref++)\n-              (propName$43 = type[ref]),\n-                (propName$43 =\n-                  \"function\" === typeof propName$43\n-                    ? propName$43.call(newProps, defaultProps, props, void 0)\n-                    : propName$43),\n-                null != propName$43 &&\n+              (propName$44 = type[ref]),\n+                (propName$44 =\n+                  \"function\" === typeof propName$44\n+                    ? propName$44.call(newProps, defaultProps, props, void 0)\n+                    : propName$44),\n+                null != propName$44 &&\n                   (initialState\n                     ? ((initialState = !1),\n-                      (defaultProps = assign({}, defaultProps, propName$43)))\n-                    : assign(defaultProps, propName$43));\n+                      (defaultProps = assign({}, defaultProps, propName$44)))\n+                    : assign(defaultProps, propName$44));\n             newProps.state = defaultProps;\n           }\n         else defaultProps.queue = null;\n@@ -4927,7 +5037,7 @@ function renderElement(request, task, keyPath, type, props, ref) {\n           type = task.keyPath;\n           ref = task.formatContext;\n           var prevRow = task.row;\n-          propName$43 = task.blockedBoundary;\n+          propName$44 = task.blockedBoundary;\n           propName = task.blockedPreamble;\n           var parentHoistableState = task.hoistableState,\n             parentSegment = task.blockedSegment,\n@@ -4993,7 +5103,7 @@ function renderElement(request, task, keyPath, type, props, ref) {\n                   boundarySegment.textEmbedded &&\n                   boundarySegment.chunks.push(textSeparator),\n                 (boundarySegment.status = 1),\n-                finishedSegment(request, propName$43, boundarySegment);\n+                finishedSegment(request, propName$44, boundarySegment);\n             } catch (thrownValue) {\n               throw (\n                 ((boundarySegment.status = 12 === request.status ? 3 : 4),\n@@ -5066,13 +5176,13 @@ function renderElement(request, task, keyPath, type, props, ref) {\n                 null !== prevRow &&\n                   prevRow.together &&\n                   tryToResolveTogetherRow(request, prevRow);\n-            } catch (thrownValue$30) {\n+            } catch (thrownValue$31) {\n               (newBoundary.status = 4),\n                 12 === request.status\n                   ? ((contentRootSegment.status = 3),\n                     (newProps = request.fatalError))\n                   : ((contentRootSegment.status = 4),\n-                    (newProps = thrownValue$30)),\n+                    (newProps = thrownValue$31)),\n                 (defaultProps = getThrownInfo(task.componentStack)),\n                 (initialState = logRecoverableError(\n                   request,\n@@ -5082,7 +5192,7 @@ function renderElement(request, task, keyPath, type, props, ref) {\n                 (newBoundary.errorDigest = initialState),\n                 untrackBoundary(request, newBoundary);\n             } finally {\n-              (task.blockedBoundary = propName$43),\n+              (task.blockedBoundary = propName$44),\n                 (task.blockedPreamble = propName),\n                 (task.hoistableState = parentHoistableState),\n                 (task.blockedSegment = parentSegment),\n@@ -5095,7 +5205,7 @@ function renderElement(request, task, keyPath, type, props, ref) {\n               null,\n               fallback,\n               -1,\n-              propName$43,\n+              propName$44,\n               boundarySegment,\n               newBoundary.fallbackPreamble,\n               newBoundary.fallbackState,\n@@ -5570,6 +5680,98 @@ function renderChildrenArray(request, task, children, childIndex) {\n   task.treeContext = replay;\n   task.keyPath = prevKeyPath;\n }\n+function trackPostponedBoundary(request, trackedPostpones, boundary) {\n+  boundary.status = 5;\n+  boundary.rootSegmentID = request.nextSegmentId++;\n+  request = boundary.trackedContentKeyPath;\n+  if (null === request) throw Error(formatProdErrorMessage(486));\n+  var fallbackReplayNode = boundary.trackedFallbackNode,\n+    children = [],\n+    boundaryNode = trackedPostpones.workingMap.get(request);\n+  if (void 0 === boundaryNode)\n+    return (\n+      (boundary = [\n+        request[1],\n+        request[2],\n+        children,\n+        null,\n+        fallbackReplayNode,\n+        boundary.rootSegmentID\n+      ]),\n+      trackedPostpones.workingMap.set(request, boundary),\n+      addToReplayParent(boundary, request[0], trackedPostpones),\n+      boundary\n+    );\n+  boundaryNode[4] = fallbackReplayNode;\n+  boundaryNode[5] = boundary.rootSegmentID;\n+  return boundaryNode;\n+}\n+function trackPostpone(request, trackedPostpones, task, segment) {\n+  segment.status = 5;\n+  var keyPath = task.keyPath,\n+    boundary = task.blockedBoundary;\n+  if (null === boundary)\n+    (segment.id = request.nextSegmentId++),\n+      (trackedPostpones.rootSlots = segment.id),\n+      null !== request.completedRootSegment &&\n+        (request.completedRootSegment.status = 5);\n+  else {\n+    if (null !== boundary && 0 === boundary.status) {\n+      var boundaryNode = trackPostponedBoundary(\n+        request,\n+        trackedPostpones,\n+        boundary\n+      );\n+      if (\n+        boundary.trackedContentKeyPath === keyPath &&\n+        -1 === task.childIndex\n+      ) {\n+        -1 === segment.id &&\n+          (segment.id = segment.parentFlushed\n+            ? boundary.rootSegmentID\n+            : request.nextSegmentId++);\n+        boundaryNode[3] = segment.id;\n+        return;\n+      }\n+    }\n+    -1 === segment.id &&\n+      (segment.id =\n+        segment.parentFlushed && null !== boundary\n+          ? boundary.rootSegmentID\n+          : request.nextSegmentId++);\n+    if (-1 === task.childIndex)\n+      null === keyPath\n+        ? (trackedPostpones.rootSlots = segment.id)\n+        : ((task = trackedPostpones.workingMap.get(keyPath)),\n+          void 0 === task\n+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n+              addToReplayParent(task, keyPath[0], trackedPostpones))\n+            : (task[3] = segment.id));\n+    else {\n+      if (null === keyPath)\n+        if (((request = trackedPostpones.rootSlots), null === request))\n+          request = trackedPostpones.rootSlots = {};\n+        else {\n+          if (\"number\" === typeof request)\n+            throw Error(formatProdErrorMessage(491));\n+        }\n+      else if (\n+        ((boundary = trackedPostpones.workingMap),\n+        (boundaryNode = boundary.get(keyPath)),\n+        void 0 === boundaryNode)\n+      )\n+        (request = {}),\n+          (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n+          boundary.set(keyPath, boundaryNode),\n+          addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n+      else if (((request = boundaryNode[3]), null === request))\n+        request = boundaryNode[3] = {};\n+      else if (\"number\" === typeof request)\n+        throw Error(formatProdErrorMessage(491));\n+      request[task.childIndex] = segment.id;\n+    }\n+  }\n+}\n function untrackBoundary(request, boundary) {\n   request = request.trackedPostpones;\n   null !== request &&\n@@ -5686,21 +5888,21 @@ function renderNode(request, task, node, childIndex) {\n       chunkLength = segment.chunks.length;\n     try {\n       return renderNodeDestructive(request, task, node, childIndex);\n-    } catch (thrownValue$60) {\n+    } catch (thrownValue$63) {\n       if (\n         (resetHooksState(),\n         (segment.children.length = childrenLength),\n         (segment.chunks.length = chunkLength),\n         (node =\n-          thrownValue$60 === SuspenseException\n+          thrownValue$63 === SuspenseException\n             ? getSuspendedThenable()\n-            : thrownValue$60),\n+            : thrownValue$63),\n         12 !== request.status && \"object\" === typeof node && null !== node)\n       ) {\n         if (\"function\" === typeof node.then) {\n           segment = node;\n           node =\n-            thrownValue$60 === SuspenseException\n+            thrownValue$63 === SuspenseException\n               ? getThenableStateAfterSuspending()\n               : null;\n           request = spawnNewSuspendedRenderTask(request, task, node).ping;\n@@ -5715,7 +5917,7 @@ function renderNode(request, task, node, childIndex) {\n         }\n         if (\"Maximum call stack size exceeded\" === node.message) {\n           segment =\n-            thrownValue$60 === SuspenseException\n+            thrownValue$63 === SuspenseException\n               ? getThenableStateAfterSuspending()\n               : null;\n           segment = spawnNewSuspendedRenderTask(request, task, segment);\n@@ -5800,19 +6002,24 @@ function abortTask(task, request, error) {\n     if (6 === segment.status) return;\n     segment.status = 3;\n   }\n-  segment = getThrownInfo(task.componentStack);\n+  var errorInfo = getThrownInfo(task.componentStack);\n   if (null === boundary) {\n     if (13 !== request.status && 14 !== request.status) {\n       boundary = task.replay;\n       if (null === boundary) {\n-        logRecoverableError(request, error, segment);\n-        fatalError(request, error);\n+        null !== request.trackedPostpones && null !== segment\n+          ? ((boundary = request.trackedPostpones),\n+            logRecoverableError(request, error, errorInfo),\n+            trackPostpone(request, boundary, task, segment),\n+            finishedTask(request, null, task.row, segment))\n+          : (logRecoverableError(request, error, errorInfo),\n+            fatalError(request, error));\n         return;\n       }\n       boundary.pendingTasks--;\n       0 === boundary.pendingTasks &&\n         0 < boundary.nodes.length &&\n-        ((segment = logRecoverableError(request, error, segment)),\n+        ((segment = logRecoverableError(request, error, errorInfo)),\n         abortRemainingReplayNodes(\n           request,\n           null,\n@@ -5824,24 +6031,36 @@ function abortTask(task, request, error) {\n       request.pendingRootTasks--;\n       0 === request.pendingRootTasks && completeShell(request);\n     }\n-  } else\n-    4 !== boundary.status &&\n-      ((boundary.status = 4),\n-      (segment = logRecoverableError(request, error, segment)),\n-      (boundary.status = 4),\n-      (boundary.errorDigest = segment),\n-      untrackBoundary(request, boundary),\n-      boundary.parentFlushed &&\n-        request.clientRenderedBoundaries.push(boundary)),\n-      boundary.pendingTasks--,\n-      (segment = boundary.row),\n-      null !== segment &&\n-        0 === --segment.pendingTasks &&\n-        finishSuspenseListRow(request, segment),\n-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n-        return abortTask(fallbackTask, request, error);\n-      }),\n-      boundary.fallbackAbortableTasks.clear();\n+  } else {\n+    var trackedPostpones$64 = request.trackedPostpones;\n+    if (4 !== boundary.status) {\n+      if (null !== trackedPostpones$64 && null !== segment)\n+        return (\n+          logRecoverableError(request, error, errorInfo),\n+          trackPostpone(request, trackedPostpones$64, task, segment),\n+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+            return abortTask(fallbackTask, request, error);\n+          }),\n+          boundary.fallbackAbortableTasks.clear(),\n+          finishedTask(request, boundary, task.row, segment)\n+        );\n+      boundary.status = 4;\n+      segment = logRecoverableError(request, error, errorInfo);\n+      boundary.status = 4;\n+      boundary.errorDigest = segment;\n+      untrackBoundary(request, boundary);\n+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);\n+    }\n+    boundary.pendingTasks--;\n+    segment = boundary.row;\n+    null !== segment &&\n+      0 === --segment.pendingTasks &&\n+      finishSuspenseListRow(request, segment);\n+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+      return abortTask(fallbackTask, request, error);\n+    });\n+    boundary.fallbackAbortableTasks.clear();\n+  }\n   task = task.row;\n   null !== task &&\n     0 === --task.pendingTasks &&\n@@ -5955,20 +6174,20 @@ function finishedSegment(request, boundary, segment) {\n       : (boundary.byteSize += segmentByteSize);\n   }\n }\n-function finishedTask(request$jscomp$0, boundary, row, segment) {\n+function finishedTask(request, boundary, row, segment) {\n   null !== row &&\n     (0 === --row.pendingTasks\n-      ? finishSuspenseListRow(request$jscomp$0, row)\n-      : row.together && tryToResolveTogetherRow(request$jscomp$0, row));\n-  request$jscomp$0.allPendingTasks--;\n+      ? finishSuspenseListRow(request, row)\n+      : row.together && tryToResolveTogetherRow(request, row));\n+  request.allPendingTasks--;\n   if (null === boundary) {\n     if (null !== segment && segment.parentFlushed) {\n-      if (null !== request$jscomp$0.completedRootSegment)\n+      if (null !== request.completedRootSegment)\n         throw Error(formatProdErrorMessage(389));\n-      request$jscomp$0.completedRootSegment = segment;\n+      request.completedRootSegment = segment;\n     }\n-    request$jscomp$0.pendingRootTasks--;\n-    0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);\n+    request.pendingRootTasks--;\n+    0 === request.pendingRootTasks && completeShell(request);\n   } else if ((boundary.pendingTasks--, 4 !== boundary.status))\n     if (0 === boundary.pendingTasks)\n       if (\n@@ -5977,33 +6196,29 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n           segment.parentFlushed &&\n           (1 === segment.status || 3 === segment.status) &&\n           queueCompletedSegment(boundary, segment),\n-        boundary.parentFlushed &&\n-          request$jscomp$0.completedBoundaries.push(boundary),\n+        boundary.parentFlushed && request.completedBoundaries.push(boundary),\n         1 === boundary.status)\n       )\n         (row = boundary.row),\n           null !== row &&\n             hoistHoistables(row.hoistables, boundary.contentState),\n-          isEligibleForOutlining(request$jscomp$0, boundary) ||\n-            (boundary.fallbackAbortableTasks.forEach(\n-              abortTaskSoft,\n-              request$jscomp$0\n-            ),\n+          isEligibleForOutlining(request, boundary) ||\n+            (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),\n             boundary.fallbackAbortableTasks.clear(),\n             null !== row &&\n               0 === --row.pendingTasks &&\n-              finishSuspenseListRow(request$jscomp$0, row)),\n-          0 === request$jscomp$0.pendingRootTasks &&\n-            null === request$jscomp$0.trackedPostpones &&\n+              finishSuspenseListRow(request, row)),\n+          0 === request.pendingRootTasks &&\n+            null === request.trackedPostpones &&\n             null !== boundary.contentPreamble &&\n-            preparePreamble(request$jscomp$0);\n+            preparePreamble(request);\n       else {\n         if (\n           5 === boundary.status &&\n           ((boundary = boundary.row), null !== boundary)\n         ) {\n-          if (null !== request$jscomp$0.trackedPostpones) {\n-            row = request$jscomp$0.trackedPostpones;\n+          if (null !== request.trackedPostpones) {\n+            row = request.trackedPostpones;\n             var postponedRow = boundary.next;\n             if (\n               null !== postponedRow &&\n@@ -6015,40 +6230,12 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n                 postponedRow++\n               ) {\n                 var postponedBoundary = segment[postponedRow];\n-                var request = request$jscomp$0,\n-                  trackedPostpones = row;\n-                postponedBoundary.status = 5;\n-                postponedBoundary.rootSegmentID = request.nextSegmentId++;\n-                request = postponedBoundary.trackedContentKeyPath;\n-                if (null === request) throw Error(formatProdErrorMessage(486));\n-                var fallbackReplayNode = postponedBoundary.trackedFallbackNode,\n-                  children = [],\n-                  boundaryNode = trackedPostpones.workingMap.get(request);\n-                void 0 === boundaryNode\n-                  ? ((fallbackReplayNode = [\n-                      request[1],\n-                      request[2],\n-                      children,\n-                      null,\n-                      fallbackReplayNode,\n-                      postponedBoundary.rootSegmentID\n-                    ]),\n-                    trackedPostpones.workingMap.set(\n-                      request,\n-                      fallbackReplayNode\n-                    ),\n-                    addToReplayParent(\n-                      fallbackReplayNode,\n-                      request[0],\n-                      trackedPostpones\n-                    ))\n-                  : ((boundaryNode[4] = fallbackReplayNode),\n-                    (boundaryNode[5] = postponedBoundary.rootSegmentID));\n-                finishedTask(request$jscomp$0, postponedBoundary, null, null);\n+                trackPostponedBoundary(request, row, postponedBoundary);\n+                finishedTask(request, postponedBoundary, null, null);\n               }\n           }\n           0 === --boundary.pendingTasks &&\n-            finishSuspenseListRow(request$jscomp$0, boundary);\n+            finishSuspenseListRow(request, boundary);\n         }\n       }\n     else\n@@ -6058,12 +6245,12 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n         (queueCompletedSegment(boundary, segment),\n         1 === boundary.completedSegments.length &&\n           boundary.parentFlushed &&\n-          request$jscomp$0.partialBoundaries.push(boundary)),\n+          request.partialBoundaries.push(boundary)),\n         (boundary = boundary.row),\n         null !== boundary &&\n           boundary.together &&\n-          tryToResolveTogetherRow(request$jscomp$0, boundary);\n-  0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n+          tryToResolveTogetherRow(request, boundary);\n+  0 === request.allPendingTasks && completeAll(request);\n }\n function performWork(request$jscomp$2) {\n   if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {\n@@ -6196,7 +6383,19 @@ function performWork(request$jscomp$2) {\n                 : 12 === request.status\n                   ? request.fatalError\n                   : thrownValue;\n-            if (\n+            if (12 === request.status && null !== request.trackedPostpones) {\n+              var trackedPostpones = request.trackedPostpones,\n+                thrownInfo = getThrownInfo(task.componentStack);\n+              task.abortSet.delete(task);\n+              logRecoverableError(request, x$jscomp$0, thrownInfo);\n+              trackPostpone(request, trackedPostpones, task, request$jscomp$1);\n+              finishedTask(\n+                request,\n+                task.blockedBoundary,\n+                task.row,\n+                request$jscomp$1\n+              );\n+            } else if (\n               \"object\" === typeof x$jscomp$0 &&\n               null !== x$jscomp$0 &&\n               \"function\" === typeof x$jscomp$0.then\n@@ -6751,12 +6950,12 @@ function flushCompletedQueues(request, destination) {\n       flushingPartialBoundaries = !0;\n       var partialBoundaries = request.partialBoundaries;\n       for (i = 0; i < partialBoundaries.length; i++) {\n-        var boundary$66 = partialBoundaries[i];\n+        var boundary$70 = partialBoundaries[i];\n         a: {\n           clientRenderedBoundaries = request;\n           boundary = destination;\n-          flushedByteSize = boundary$66.byteSize;\n-          var completedSegments = boundary$66.completedSegments;\n+          flushedByteSize = boundary$70.byteSize;\n+          var completedSegments = boundary$70.completedSegments;\n           for (\n             JSCompiler_inline_result = 0;\n             JSCompiler_inline_result < completedSegments.length;\n@@ -6766,7 +6965,7 @@ function flushCompletedQueues(request, destination) {\n               !flushPartiallyCompletedSegment(\n                 clientRenderedBoundaries,\n                 boundary,\n-                boundary$66,\n+                boundary$70,\n                 completedSegments[JSCompiler_inline_result]\n               )\n             ) {\n@@ -6776,10 +6975,10 @@ function flushCompletedQueues(request, destination) {\n               break a;\n             }\n           completedSegments.splice(0, JSCompiler_inline_result);\n-          var row = boundary$66.row;\n+          var row = boundary$70.row;\n           null !== row &&\n             row.together &&\n-            1 === boundary$66.pendingTasks &&\n+            1 === boundary$70.pendingTasks &&\n             (1 === row.pendingTasks\n               ? unblockSuspenseListRow(\n                   clientRenderedBoundaries,\n@@ -6789,7 +6988,7 @@ function flushCompletedQueues(request, destination) {\n               : row.pendingTasks--);\n           JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n             boundary,\n-            boundary$66.contentState,\n+            boundary$70.contentState,\n             clientRenderedBoundaries.renderState\n           );\n         }\n@@ -6884,8 +7083,8 @@ function abort(request, reason) {\n     }\n     null !== request.destination &&\n       flushCompletedQueues(request, request.destination);\n-  } catch (error$68) {\n-    logRecoverableError(request, error$68, {}), fatalError(request, error$68);\n+  } catch (error$72) {\n+    logRecoverableError(request, error$72, {}), fatalError(request, error$72);\n   }\n }\n function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n@@ -6900,14 +7099,60 @@ function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n     parentNode[2].push(node);\n   }\n }\n+function getPostponedState(request) {\n+  var trackedPostpones = request.trackedPostpones;\n+  if (\n+    null === trackedPostpones ||\n+    (0 === trackedPostpones.rootNodes.length &&\n+      null === trackedPostpones.rootSlots)\n+  )\n+    return (request.trackedPostpones = null);\n+  if (\n+    null === request.completedRootSegment ||\n+    (5 !== request.completedRootSegment.status &&\n+      null !== request.completedPreambleSegments)\n+  ) {\n+    var nextSegmentId = request.nextSegmentId;\n+    var replaySlots = trackedPostpones.rootSlots;\n+    var resumableState = request.resumableState;\n+    resumableState.bootstrapScriptContent = void 0;\n+    resumableState.bootstrapScripts = void 0;\n+    resumableState.bootstrapModules = void 0;\n+  } else {\n+    nextSegmentId = 0;\n+    replaySlots = -1;\n+    resumableState = request.resumableState;\n+    var renderState = request.renderState;\n+    resumableState.nextFormID = 0;\n+    resumableState.hasBody = !1;\n+    resumableState.hasHtml = !1;\n+    resumableState.unknownResources = { font: renderState.resets.font };\n+    resumableState.dnsResources = renderState.resets.dns;\n+    resumableState.connectResources = renderState.resets.connect;\n+    resumableState.imageResources = renderState.resets.image;\n+    resumableState.styleResources = renderState.resets.style;\n+    resumableState.scriptResources = {};\n+    resumableState.moduleUnknownResources = {};\n+    resumableState.moduleScriptResources = {};\n+    resumableState.instructions = 0;\n+  }\n+  return {\n+    nextSegmentId: nextSegmentId,\n+    rootFormatContext: request.rootFormatContext,\n+    progressiveChunkSize: request.progressiveChunkSize,\n+    resumableState: request.resumableState,\n+    replayNodes: trackedPostpones.rootNodes,\n+    replaySlots: replaySlots\n+  };\n+}\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.2.0-canary-548235db-20251001\" !== isomorphicReactPackageVersion)\n+  if (\"19.2.0-canary-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n     throw Error(\n       formatProdErrorMessage(\n         527,\n         isomorphicReactPackageVersion,\n-        \"19.2.0-canary-548235db-20251001\"\n+        \"19.2.0-canary-1bd1f01f-20251001\"\n       )\n     );\n }\n@@ -6943,22 +7188,21 @@ exports.prerender = function (children, options) {\n         options ? options.progressiveChunkSize : void 0,\n         options ? options.onError : void 0,\n         function () {\n-          var result = {\n-            prelude: new ReadableStream(\n-              {\n-                type: \"bytes\",\n-                pull: function (controller) {\n-                  startFlowing(request, controller);\n-                },\n-                cancel: function (reason) {\n-                  request.destination = null;\n-                  abort(request, reason);\n-                }\n+          var stream = new ReadableStream(\n+            {\n+              type: \"bytes\",\n+              pull: function (controller) {\n+                startFlowing(request, controller);\n               },\n-              { highWaterMark: 0 }\n-            )\n-          };\n-          resolve(result);\n+              cancel: function (reason) {\n+                request.destination = null;\n+                abort(request, reason);\n+              }\n+            },\n+            { highWaterMark: 0 }\n+          );\n+          stream = { postponed: getPostponedState(request), prelude: stream };\n+          resolve(stream);\n         },\n         void 0,\n         void 0,\n@@ -7054,4 +7298,113 @@ exports.renderToReadableStream = function (children, options) {\n     startWork(request);\n   });\n };\n-exports.version = \"19.2.0-canary-548235db-20251001\";\n+exports.resume = function (children, postponedState, options) {\n+  return new Promise(function (resolve, reject) {\n+    var onFatalError,\n+      onAllReady,\n+      allReady = new Promise(function (res, rej) {\n+        onAllReady = res;\n+        onFatalError = rej;\n+      }),\n+      request = resumeRequest(\n+        children,\n+        postponedState,\n+        createRenderState(\n+          postponedState.resumableState,\n+          options ? options.nonce : void 0,\n+          void 0,\n+          void 0,\n+          void 0,\n+          void 0\n+        ),\n+        options ? options.onError : void 0,\n+        onAllReady,\n+        function () {\n+          var stream = new ReadableStream(\n+            {\n+              type: \"bytes\",\n+              pull: function (controller) {\n+                startFlowing(request, controller);\n+              },\n+              cancel: function (reason) {\n+                request.destination = null;\n+                abort(request, reason);\n+              }\n+            },\n+            { highWaterMark: 0 }\n+          );\n+          stream.allReady = allReady;\n+          resolve(stream);\n+        },\n+        function (error) {\n+          allReady.catch(function () {});\n+          reject(error);\n+        },\n+        onFatalError,\n+        options ? options.onPostpone : void 0\n+      );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.resumeAndPrerender = function (children, postponedState, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = resumeAndPrerenderRequest(\n+      children,\n+      postponedState,\n+      createRenderState(\n+        postponedState.resumableState,\n+        void 0,\n+        void 0,\n+        void 0,\n+        void 0,\n+        void 0\n+      ),\n+      options ? options.onError : void 0,\n+      function () {\n+        var stream = new ReadableStream(\n+          {\n+            type: \"bytes\",\n+            pull: function (controller) {\n+              startFlowing(request, controller);\n+            },\n+            cancel: function (reason) {\n+              request.destination = null;\n+              abort(request, reason);\n+            }\n+          },\n+          { highWaterMark: 0 }\n+        );\n+        stream = { postponed: getPostponedState(request), prelude: stream };\n+        resolve(stream);\n+      },\n+      void 0,\n+      void 0,\n+      reject,\n+      options ? options.onPostpone : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.version = \"19.2.0-canary-1bd1f01f-20251001\";"
        },
        {
            "sha": "376d726341093df9572b277e12fa2f6dc6930b42",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.bun.production.js",
            "status": "modified",
            "additions": 194,
            "deletions": 101,
            "changes": 295,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.bun.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.bun.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.bun.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -5207,6 +5207,105 @@ function renderChildrenArray(request, task, children, childIndex) {\n   task.treeContext = replay;\n   task.keyPath = prevKeyPath;\n }\n+function trackPostponedBoundary(request, trackedPostpones, boundary) {\n+  boundary.status = 5;\n+  boundary.rootSegmentID = request.nextSegmentId++;\n+  request = boundary.trackedContentKeyPath;\n+  if (null === request)\n+    throw Error(\n+      \"It should not be possible to postpone at the root. This is a bug in React.\"\n+    );\n+  var fallbackReplayNode = boundary.trackedFallbackNode,\n+    children = [],\n+    boundaryNode = trackedPostpones.workingMap.get(request);\n+  if (void 0 === boundaryNode)\n+    return (\n+      (boundary = [\n+        request[1],\n+        request[2],\n+        children,\n+        null,\n+        fallbackReplayNode,\n+        boundary.rootSegmentID\n+      ]),\n+      trackedPostpones.workingMap.set(request, boundary),\n+      addToReplayParent(boundary, request[0], trackedPostpones),\n+      boundary\n+    );\n+  boundaryNode[4] = fallbackReplayNode;\n+  boundaryNode[5] = boundary.rootSegmentID;\n+  return boundaryNode;\n+}\n+function trackPostpone(request, trackedPostpones, task, segment) {\n+  segment.status = 5;\n+  var keyPath = task.keyPath,\n+    boundary = task.blockedBoundary;\n+  if (null === boundary)\n+    (segment.id = request.nextSegmentId++),\n+      (trackedPostpones.rootSlots = segment.id),\n+      null !== request.completedRootSegment &&\n+        (request.completedRootSegment.status = 5);\n+  else {\n+    if (null !== boundary && 0 === boundary.status) {\n+      var boundaryNode = trackPostponedBoundary(\n+        request,\n+        trackedPostpones,\n+        boundary\n+      );\n+      if (\n+        boundary.trackedContentKeyPath === keyPath &&\n+        -1 === task.childIndex\n+      ) {\n+        -1 === segment.id &&\n+          (segment.id = segment.parentFlushed\n+            ? boundary.rootSegmentID\n+            : request.nextSegmentId++);\n+        boundaryNode[3] = segment.id;\n+        return;\n+      }\n+    }\n+    -1 === segment.id &&\n+      (segment.id =\n+        segment.parentFlushed && null !== boundary\n+          ? boundary.rootSegmentID\n+          : request.nextSegmentId++);\n+    if (-1 === task.childIndex)\n+      null === keyPath\n+        ? (trackedPostpones.rootSlots = segment.id)\n+        : ((task = trackedPostpones.workingMap.get(keyPath)),\n+          void 0 === task\n+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n+              addToReplayParent(task, keyPath[0], trackedPostpones))\n+            : (task[3] = segment.id));\n+    else {\n+      if (null === keyPath)\n+        if (((request = trackedPostpones.rootSlots), null === request))\n+          request = trackedPostpones.rootSlots = {};\n+        else {\n+          if (\"number\" === typeof request)\n+            throw Error(\n+              \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+            );\n+        }\n+      else if (\n+        ((boundary = trackedPostpones.workingMap),\n+        (boundaryNode = boundary.get(keyPath)),\n+        void 0 === boundaryNode)\n+      )\n+        (request = {}),\n+          (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n+          boundary.set(keyPath, boundaryNode),\n+          addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n+      else if (((request = boundaryNode[3]), null === request))\n+        request = boundaryNode[3] = {};\n+      else if (\"number\" === typeof request)\n+        throw Error(\n+          \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+        );\n+      request[task.childIndex] = segment.id;\n+    }\n+  }\n+}\n function untrackBoundary(request, boundary) {\n   request = request.trackedPostpones;\n   null !== request &&\n@@ -5323,21 +5422,21 @@ function renderNode(request, task, node, childIndex) {\n       chunkLength = segment.chunks.length;\n     try {\n       return renderNodeDestructive(request, task, node, childIndex);\n-    } catch (thrownValue$60) {\n+    } catch (thrownValue$62) {\n       if (\n         (resetHooksState(),\n         (segment.children.length = childrenLength),\n         (segment.chunks.length = chunkLength),\n         (node =\n-          thrownValue$60 === SuspenseException\n+          thrownValue$62 === SuspenseException\n             ? getSuspendedThenable()\n-            : thrownValue$60),\n+            : thrownValue$62),\n         12 !== request.status && \"object\" === typeof node && null !== node)\n       ) {\n         if (\"function\" === typeof node.then) {\n           segment = node;\n           node =\n-            thrownValue$60 === SuspenseException\n+            thrownValue$62 === SuspenseException\n               ? getThenableStateAfterSuspending()\n               : null;\n           request = spawnNewSuspendedRenderTask(request, task, node).ping;\n@@ -5352,7 +5451,7 @@ function renderNode(request, task, node, childIndex) {\n         }\n         if (\"Maximum call stack size exceeded\" === node.message) {\n           segment =\n-            thrownValue$60 === SuspenseException\n+            thrownValue$62 === SuspenseException\n               ? getThenableStateAfterSuspending()\n               : null;\n           segment = spawnNewSuspendedRenderTask(request, task, segment);\n@@ -5440,19 +5539,24 @@ function abortTask(task, request, error) {\n     if (6 === segment.status) return;\n     segment.status = 3;\n   }\n-  segment = getThrownInfo(task.componentStack);\n+  var errorInfo = getThrownInfo(task.componentStack);\n   if (null === boundary) {\n     if (13 !== request.status && 14 !== request.status) {\n       boundary = task.replay;\n       if (null === boundary) {\n-        logRecoverableError(request, error, segment);\n-        fatalError(request, error);\n+        null !== request.trackedPostpones && null !== segment\n+          ? ((boundary = request.trackedPostpones),\n+            logRecoverableError(request, error, errorInfo),\n+            trackPostpone(request, boundary, task, segment),\n+            finishedTask(request, null, task.row, segment))\n+          : (logRecoverableError(request, error, errorInfo),\n+            fatalError(request, error));\n         return;\n       }\n       boundary.pendingTasks--;\n       0 === boundary.pendingTasks &&\n         0 < boundary.nodes.length &&\n-        ((segment = logRecoverableError(request, error, segment)),\n+        ((segment = logRecoverableError(request, error, errorInfo)),\n         abortRemainingReplayNodes(\n           request,\n           null,\n@@ -5464,24 +5568,36 @@ function abortTask(task, request, error) {\n       request.pendingRootTasks--;\n       0 === request.pendingRootTasks && completeShell(request);\n     }\n-  } else\n-    4 !== boundary.status &&\n-      ((boundary.status = 4),\n-      (segment = logRecoverableError(request, error, segment)),\n-      (boundary.status = 4),\n-      (boundary.errorDigest = segment),\n-      untrackBoundary(request, boundary),\n-      boundary.parentFlushed &&\n-        request.clientRenderedBoundaries.push(boundary)),\n-      boundary.pendingTasks--,\n-      (segment = boundary.row),\n-      null !== segment &&\n-        0 === --segment.pendingTasks &&\n-        finishSuspenseListRow(request, segment),\n-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n-        return abortTask(fallbackTask, request, error);\n-      }),\n-      boundary.fallbackAbortableTasks.clear();\n+  } else {\n+    var trackedPostpones$63 = request.trackedPostpones;\n+    if (4 !== boundary.status) {\n+      if (null !== trackedPostpones$63 && null !== segment)\n+        return (\n+          logRecoverableError(request, error, errorInfo),\n+          trackPostpone(request, trackedPostpones$63, task, segment),\n+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+            return abortTask(fallbackTask, request, error);\n+          }),\n+          boundary.fallbackAbortableTasks.clear(),\n+          finishedTask(request, boundary, task.row, segment)\n+        );\n+      boundary.status = 4;\n+      segment = logRecoverableError(request, error, errorInfo);\n+      boundary.status = 4;\n+      boundary.errorDigest = segment;\n+      untrackBoundary(request, boundary);\n+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);\n+    }\n+    boundary.pendingTasks--;\n+    segment = boundary.row;\n+    null !== segment &&\n+      0 === --segment.pendingTasks &&\n+      finishSuspenseListRow(request, segment);\n+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+      return abortTask(fallbackTask, request, error);\n+    });\n+    boundary.fallbackAbortableTasks.clear();\n+  }\n   task = task.row;\n   null !== task &&\n     0 === --task.pendingTasks &&\n@@ -5595,22 +5711,22 @@ function finishedSegment(request, boundary, segment) {\n       : (boundary.byteSize += segmentByteSize);\n   }\n }\n-function finishedTask(request$jscomp$0, boundary, row, segment) {\n+function finishedTask(request, boundary, row, segment) {\n   null !== row &&\n     (0 === --row.pendingTasks\n-      ? finishSuspenseListRow(request$jscomp$0, row)\n-      : row.together && tryToResolveTogetherRow(request$jscomp$0, row));\n-  request$jscomp$0.allPendingTasks--;\n+      ? finishSuspenseListRow(request, row)\n+      : row.together && tryToResolveTogetherRow(request, row));\n+  request.allPendingTasks--;\n   if (null === boundary) {\n     if (null !== segment && segment.parentFlushed) {\n-      if (null !== request$jscomp$0.completedRootSegment)\n+      if (null !== request.completedRootSegment)\n         throw Error(\n           \"There can only be one root segment. This is a bug in React.\"\n         );\n-      request$jscomp$0.completedRootSegment = segment;\n+      request.completedRootSegment = segment;\n     }\n-    request$jscomp$0.pendingRootTasks--;\n-    0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);\n+    request.pendingRootTasks--;\n+    0 === request.pendingRootTasks && completeShell(request);\n   } else if ((boundary.pendingTasks--, 4 !== boundary.status))\n     if (0 === boundary.pendingTasks)\n       if (\n@@ -5619,33 +5735,29 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n           segment.parentFlushed &&\n           (1 === segment.status || 3 === segment.status) &&\n           queueCompletedSegment(boundary, segment),\n-        boundary.parentFlushed &&\n-          request$jscomp$0.completedBoundaries.push(boundary),\n+        boundary.parentFlushed && request.completedBoundaries.push(boundary),\n         1 === boundary.status)\n       )\n         (row = boundary.row),\n           null !== row &&\n             hoistHoistables(row.hoistables, boundary.contentState),\n-          isEligibleForOutlining(request$jscomp$0, boundary) ||\n-            (boundary.fallbackAbortableTasks.forEach(\n-              abortTaskSoft,\n-              request$jscomp$0\n-            ),\n+          isEligibleForOutlining(request, boundary) ||\n+            (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),\n             boundary.fallbackAbortableTasks.clear(),\n             null !== row &&\n               0 === --row.pendingTasks &&\n-              finishSuspenseListRow(request$jscomp$0, row)),\n-          0 === request$jscomp$0.pendingRootTasks &&\n-            null === request$jscomp$0.trackedPostpones &&\n+              finishSuspenseListRow(request, row)),\n+          0 === request.pendingRootTasks &&\n+            null === request.trackedPostpones &&\n             null !== boundary.contentPreamble &&\n-            preparePreamble(request$jscomp$0);\n+            preparePreamble(request);\n       else {\n         if (\n           5 === boundary.status &&\n           ((boundary = boundary.row), null !== boundary)\n         ) {\n-          if (null !== request$jscomp$0.trackedPostpones) {\n-            row = request$jscomp$0.trackedPostpones;\n+          if (null !== request.trackedPostpones) {\n+            row = request.trackedPostpones;\n             var postponedRow = boundary.next;\n             if (\n               null !== postponedRow &&\n@@ -5657,43 +5769,12 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n                 postponedRow++\n               ) {\n                 var postponedBoundary = segment[postponedRow];\n-                var request = request$jscomp$0,\n-                  trackedPostpones = row;\n-                postponedBoundary.status = 5;\n-                postponedBoundary.rootSegmentID = request.nextSegmentId++;\n-                request = postponedBoundary.trackedContentKeyPath;\n-                if (null === request)\n-                  throw Error(\n-                    \"It should not be possible to postpone at the root. This is a bug in React.\"\n-                  );\n-                var fallbackReplayNode = postponedBoundary.trackedFallbackNode,\n-                  children = [],\n-                  boundaryNode = trackedPostpones.workingMap.get(request);\n-                void 0 === boundaryNode\n-                  ? ((fallbackReplayNode = [\n-                      request[1],\n-                      request[2],\n-                      children,\n-                      null,\n-                      fallbackReplayNode,\n-                      postponedBoundary.rootSegmentID\n-                    ]),\n-                    trackedPostpones.workingMap.set(\n-                      request,\n-                      fallbackReplayNode\n-                    ),\n-                    addToReplayParent(\n-                      fallbackReplayNode,\n-                      request[0],\n-                      trackedPostpones\n-                    ))\n-                  : ((boundaryNode[4] = fallbackReplayNode),\n-                    (boundaryNode[5] = postponedBoundary.rootSegmentID));\n-                finishedTask(request$jscomp$0, postponedBoundary, null, null);\n+                trackPostponedBoundary(request, row, postponedBoundary);\n+                finishedTask(request, postponedBoundary, null, null);\n               }\n           }\n           0 === --boundary.pendingTasks &&\n-            finishSuspenseListRow(request$jscomp$0, boundary);\n+            finishSuspenseListRow(request, boundary);\n         }\n       }\n     else\n@@ -5703,12 +5784,12 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n         (queueCompletedSegment(boundary, segment),\n         1 === boundary.completedSegments.length &&\n           boundary.parentFlushed &&\n-          request$jscomp$0.partialBoundaries.push(boundary)),\n+          request.partialBoundaries.push(boundary)),\n         (boundary = boundary.row),\n         null !== boundary &&\n           boundary.together &&\n-          tryToResolveTogetherRow(request$jscomp$0, boundary);\n-  0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n+          tryToResolveTogetherRow(request, boundary);\n+  0 === request.allPendingTasks && completeAll(request);\n }\n function performWork(request$jscomp$2) {\n   if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {\n@@ -5846,7 +5927,19 @@ function performWork(request$jscomp$2) {\n                 : 12 === request.status\n                   ? request.fatalError\n                   : thrownValue;\n-            if (\n+            if (12 === request.status && null !== request.trackedPostpones) {\n+              var trackedPostpones = request.trackedPostpones,\n+                thrownInfo = getThrownInfo(task.componentStack);\n+              task.abortSet.delete(task);\n+              logRecoverableError(request, x$jscomp$0, thrownInfo);\n+              trackPostpone(request, trackedPostpones, task, request$jscomp$1);\n+              finishedTask(\n+                request,\n+                task.blockedBoundary,\n+                task.row,\n+                request$jscomp$1\n+              );\n+            } else if (\n               \"object\" === typeof x$jscomp$0 &&\n               null !== x$jscomp$0 &&\n               \"function\" === typeof x$jscomp$0.then\n@@ -6413,12 +6506,12 @@ function flushCompletedQueues(request, destination) {\n       flushingPartialBoundaries = !0;\n       var partialBoundaries = request.partialBoundaries;\n       for (i = 0; i < partialBoundaries.length; i++) {\n-        var boundary$66 = partialBoundaries[i];\n+        var boundary$69 = partialBoundaries[i];\n         a: {\n           clientRenderedBoundaries = request;\n           boundary = destination;\n-          flushedByteSize = boundary$66.byteSize;\n-          var completedSegments = boundary$66.completedSegments;\n+          flushedByteSize = boundary$69.byteSize;\n+          var completedSegments = boundary$69.completedSegments;\n           for (\n             JSCompiler_inline_result = 0;\n             JSCompiler_inline_result < completedSegments.length;\n@@ -6428,7 +6521,7 @@ function flushCompletedQueues(request, destination) {\n               !flushPartiallyCompletedSegment(\n                 clientRenderedBoundaries,\n                 boundary,\n-                boundary$66,\n+                boundary$69,\n                 completedSegments[JSCompiler_inline_result]\n               )\n             ) {\n@@ -6438,10 +6531,10 @@ function flushCompletedQueues(request, destination) {\n               break a;\n             }\n           completedSegments.splice(0, JSCompiler_inline_result);\n-          var row = boundary$66.row;\n+          var row = boundary$69.row;\n           null !== row &&\n             row.together &&\n-            1 === boundary$66.pendingTasks &&\n+            1 === boundary$69.pendingTasks &&\n             (1 === row.pendingTasks\n               ? unblockSuspenseListRow(\n                   clientRenderedBoundaries,\n@@ -6451,7 +6544,7 @@ function flushCompletedQueues(request, destination) {\n               : row.pendingTasks--);\n           JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n             boundary,\n-            boundary$66.contentState,\n+            boundary$69.contentState,\n             clientRenderedBoundaries.renderState\n           );\n         }\n@@ -6534,8 +6627,8 @@ function abort(request, reason) {\n     }\n     null !== request.destination &&\n       flushCompletedQueues(request, request.destination);\n-  } catch (error$68) {\n-    logRecoverableError(request, error$68, {}), fatalError(request, error$68);\n+  } catch (error$71) {\n+    logRecoverableError(request, error$71, {}), fatalError(request, error$71);\n   }\n }\n function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n@@ -6550,15 +6643,15 @@ function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n     parentNode[2].push(node);\n   }\n }\n-var isomorphicReactPackageVersion$jscomp$inline_818 = React.version;\n+var isomorphicReactPackageVersion$jscomp$inline_821 = React.version;\n if (\n-  \"19.2.0-canary-548235db-20251001\" !==\n-  isomorphicReactPackageVersion$jscomp$inline_818\n+  \"19.2.0-canary-1bd1f01f-20251001\" !==\n+  isomorphicReactPackageVersion$jscomp$inline_821\n )\n   throw Error(\n     'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n-      (isomorphicReactPackageVersion$jscomp$inline_818 +\n-        \"\\n  - react-dom:  19.2.0-canary-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+      (isomorphicReactPackageVersion$jscomp$inline_821 +\n+        \"\\n  - react-dom:  19.2.0-canary-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n   );\n exports.renderToReadableStream = function (children, options) {\n   return new Promise(function (resolve, reject) {\n@@ -6649,4 +6742,4 @@ exports.renderToReadableStream = function (children, options) {\n     startWork(request);\n   });\n };\n-exports.version = \"19.2.0-canary-548235db-20251001\";\n+exports.version = \"19.2.0-canary-1bd1f01f-20251001\";"
        },
        {
            "sha": "46f3329a6b7aa638de82b2359dc551c254220653",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.edge.development.js",
            "status": "modified",
            "additions": 511,
            "deletions": 129,
            "changes": 640,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.edge.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -4528,6 +4528,12 @@\n       }\n       return \"\";\n     }\n+    function resetOwnerStackLimit() {\n+      var now = getCurrentTime();\n+      1e3 < now - lastResetTime &&\n+        ((ReactSharedInternals.recentlyCreatedOwnerStacks = 0),\n+        (lastResetTime = now));\n+    }\n     function isEligibleForOutlining(request, boundary) {\n       return (\n         (500 < boundary.byteSize ||\n@@ -4621,10 +4627,7 @@\n       onPostpone,\n       formState\n     ) {\n-      var now = getCurrentTime();\n-      1e3 < now - lastResetTime &&\n-        ((ReactSharedInternals.recentlyCreatedOwnerStacks = 0),\n-        (lastResetTime = now));\n+      resetOwnerStackLimit();\n       resumableState = new RequestInstance(\n         resumableState,\n         renderState,\n@@ -4704,6 +4707,121 @@\n       };\n       return children;\n     }\n+    function resumeRequest(\n+      children,\n+      postponedState,\n+      renderState,\n+      onError,\n+      onAllReady,\n+      onShellReady,\n+      onShellError,\n+      onFatalError,\n+      onPostpone\n+    ) {\n+      resetOwnerStackLimit();\n+      renderState = new RequestInstance(\n+        postponedState.resumableState,\n+        renderState,\n+        postponedState.rootFormatContext,\n+        postponedState.progressiveChunkSize,\n+        onError,\n+        onAllReady,\n+        onShellReady,\n+        onShellError,\n+        onFatalError,\n+        onPostpone,\n+        null\n+      );\n+      renderState.nextSegmentId = postponedState.nextSegmentId;\n+      if (\"number\" === typeof postponedState.replaySlots)\n+        return (\n+          (onError = createPendingSegment(\n+            renderState,\n+            0,\n+            null,\n+            postponedState.rootFormatContext,\n+            !1,\n+            !1\n+          )),\n+          (onError.parentFlushed = !0),\n+          (children = createRenderTask(\n+            renderState,\n+            null,\n+            children,\n+            -1,\n+            null,\n+            onError,\n+            null,\n+            null,\n+            renderState.abortableTasks,\n+            null,\n+            postponedState.rootFormatContext,\n+            null,\n+            emptyTreeContext,\n+            null,\n+            null,\n+            emptyContextObject,\n+            null\n+          )),\n+          pushComponentStack(children),\n+          renderState.pingedTasks.push(children),\n+          renderState\n+        );\n+      children = createReplayTask(\n+        renderState,\n+        null,\n+        {\n+          nodes: postponedState.replayNodes,\n+          slots: postponedState.replaySlots,\n+          pendingTasks: 0\n+        },\n+        children,\n+        -1,\n+        null,\n+        null,\n+        renderState.abortableTasks,\n+        null,\n+        postponedState.rootFormatContext,\n+        null,\n+        emptyTreeContext,\n+        null,\n+        null,\n+        emptyContextObject,\n+        null\n+      );\n+      pushComponentStack(children);\n+      renderState.pingedTasks.push(children);\n+      return renderState;\n+    }\n+    function resumeAndPrerenderRequest(\n+      children,\n+      postponedState,\n+      renderState,\n+      onError,\n+      onAllReady,\n+      onShellReady,\n+      onShellError,\n+      onFatalError,\n+      onPostpone\n+    ) {\n+      children = resumeRequest(\n+        children,\n+        postponedState,\n+        renderState,\n+        onError,\n+        onAllReady,\n+        onShellReady,\n+        onShellError,\n+        onFatalError,\n+        onPostpone\n+      );\n+      children.trackedPostpones = {\n+        workingMap: new Map(),\n+        rootNodes: [],\n+        rootSlots: null\n+      };\n+      return children;\n+    }\n     function resolveRequest() {\n       if (currentRequest) return currentRequest;\n       if (supportsRequestStorage) {\n@@ -6907,6 +7025,105 @@\n       task.componentStack = previousComponentStack;\n       task.debugTask = previousDebugTask;\n     }\n+    function trackPostponedBoundary(request, trackedPostpones, boundary) {\n+      boundary.status = POSTPONED;\n+      boundary.rootSegmentID = request.nextSegmentId++;\n+      request = boundary.trackedContentKeyPath;\n+      if (null === request)\n+        throw Error(\n+          \"It should not be possible to postpone at the root. This is a bug in React.\"\n+        );\n+      var fallbackReplayNode = boundary.trackedFallbackNode,\n+        children = [],\n+        boundaryNode = trackedPostpones.workingMap.get(request);\n+      if (void 0 === boundaryNode)\n+        return (\n+          (boundary = [\n+            request[1],\n+            request[2],\n+            children,\n+            null,\n+            fallbackReplayNode,\n+            boundary.rootSegmentID\n+          ]),\n+          trackedPostpones.workingMap.set(request, boundary),\n+          addToReplayParent(boundary, request[0], trackedPostpones),\n+          boundary\n+        );\n+      boundaryNode[4] = fallbackReplayNode;\n+      boundaryNode[5] = boundary.rootSegmentID;\n+      return boundaryNode;\n+    }\n+    function trackPostpone(request, trackedPostpones, task, segment) {\n+      segment.status = POSTPONED;\n+      var keyPath = task.keyPath,\n+        boundary = task.blockedBoundary;\n+      if (null === boundary)\n+        (segment.id = request.nextSegmentId++),\n+          (trackedPostpones.rootSlots = segment.id),\n+          null !== request.completedRootSegment &&\n+            (request.completedRootSegment.status = POSTPONED);\n+      else {\n+        if (null !== boundary && boundary.status === PENDING) {\n+          var boundaryNode = trackPostponedBoundary(\n+            request,\n+            trackedPostpones,\n+            boundary\n+          );\n+          if (\n+            boundary.trackedContentKeyPath === keyPath &&\n+            -1 === task.childIndex\n+          ) {\n+            -1 === segment.id &&\n+              (segment.id = segment.parentFlushed\n+                ? boundary.rootSegmentID\n+                : request.nextSegmentId++);\n+            boundaryNode[3] = segment.id;\n+            return;\n+          }\n+        }\n+        -1 === segment.id &&\n+          (segment.id =\n+            segment.parentFlushed && null !== boundary\n+              ? boundary.rootSegmentID\n+              : request.nextSegmentId++);\n+        if (-1 === task.childIndex)\n+          null === keyPath\n+            ? (trackedPostpones.rootSlots = segment.id)\n+            : ((task = trackedPostpones.workingMap.get(keyPath)),\n+              void 0 === task\n+                ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n+                  addToReplayParent(task, keyPath[0], trackedPostpones))\n+                : (task[3] = segment.id));\n+        else {\n+          if (null === keyPath)\n+            if (((request = trackedPostpones.rootSlots), null === request))\n+              request = trackedPostpones.rootSlots = {};\n+            else {\n+              if (\"number\" === typeof request)\n+                throw Error(\n+                  \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+                );\n+            }\n+          else if (\n+            ((boundary = trackedPostpones.workingMap),\n+            (boundaryNode = boundary.get(keyPath)),\n+            void 0 === boundaryNode)\n+          )\n+            (request = {}),\n+              (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n+              boundary.set(keyPath, boundaryNode),\n+              addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n+          else if (((request = boundaryNode[3]), null === request))\n+            request = boundaryNode[3] = {};\n+          else if (\"number\" === typeof request)\n+            throw Error(\n+              \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+            );\n+          request[task.childIndex] = segment.id;\n+        }\n+      }\n+    }\n     function untrackBoundary(request, boundary) {\n       request = request.trackedPostpones;\n       null !== request &&\n@@ -7174,54 +7391,77 @@\n         if (6 === segment.status) return;\n         segment.status = ABORTED;\n       }\n-      segment = getThrownInfo(task.componentStack);\n-      var node = task.node;\n+      var errorInfo = getThrownInfo(task.componentStack),\n+        node = task.node;\n       null !== node &&\n         \"object\" === typeof node &&\n         pushHaltedAwaitOnComponentStack(task, node._debugInfo);\n       if (null === boundary) {\n         if (13 !== request.status && request.status !== CLOSED) {\n           boundary = task.replay;\n           if (null === boundary) {\n-            logRecoverableError(request, error, segment, task.debugTask);\n-            fatalError(request, error, segment, task.debugTask);\n+            null !== request.trackedPostpones && null !== segment\n+              ? ((boundary = request.trackedPostpones),\n+                logRecoverableError(request, error, errorInfo, task.debugTask),\n+                trackPostpone(request, boundary, task, segment),\n+                finishedTask(request, null, task.row, segment))\n+              : (logRecoverableError(request, error, errorInfo, task.debugTask),\n+                fatalError(request, error, errorInfo, task.debugTask));\n             return;\n           }\n           boundary.pendingTasks--;\n           0 === boundary.pendingTasks &&\n             0 < boundary.nodes.length &&\n-            ((node = logRecoverableError(request, error, segment, null)),\n+            ((segment = logRecoverableError(request, error, errorInfo, null)),\n             abortRemainingReplayNodes(\n               request,\n               null,\n               boundary.nodes,\n               boundary.slots,\n               error,\n-              node,\n               segment,\n+              errorInfo,\n               !0\n             ));\n           request.pendingRootTasks--;\n           0 === request.pendingRootTasks && completeShell(request);\n         }\n-      } else\n-        boundary.status !== CLIENT_RENDERED &&\n-          ((boundary.status = CLIENT_RENDERED),\n-          (node = logRecoverableError(request, error, segment, task.debugTask)),\n-          (boundary.status = CLIENT_RENDERED),\n-          encodeErrorForBoundary(boundary, node, error, segment, !0),\n-          untrackBoundary(request, boundary),\n+      } else {\n+        node = request.trackedPostpones;\n+        if (boundary.status !== CLIENT_RENDERED) {\n+          if (null !== node && null !== segment)\n+            return (\n+              logRecoverableError(request, error, errorInfo, task.debugTask),\n+              trackPostpone(request, node, task, segment),\n+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+                return abortTask(fallbackTask, request, error);\n+              }),\n+              boundary.fallbackAbortableTasks.clear(),\n+              finishedTask(request, boundary, task.row, segment)\n+            );\n+          boundary.status = CLIENT_RENDERED;\n+          segment = logRecoverableError(\n+            request,\n+            error,\n+            errorInfo,\n+            task.debugTask\n+          );\n+          boundary.status = CLIENT_RENDERED;\n+          encodeErrorForBoundary(boundary, segment, error, errorInfo, !0);\n+          untrackBoundary(request, boundary);\n           boundary.parentFlushed &&\n-            request.clientRenderedBoundaries.push(boundary)),\n-          boundary.pendingTasks--,\n-          (segment = boundary.row),\n-          null !== segment &&\n-            0 === --segment.pendingTasks &&\n-            finishSuspenseListRow(request, segment),\n-          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n-            return abortTask(fallbackTask, request, error);\n-          }),\n-          boundary.fallbackAbortableTasks.clear();\n+            request.clientRenderedBoundaries.push(boundary);\n+        }\n+        boundary.pendingTasks--;\n+        errorInfo = boundary.row;\n+        null !== errorInfo &&\n+          0 === --errorInfo.pendingTasks &&\n+          finishSuspenseListRow(request, errorInfo);\n+        boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+          return abortTask(fallbackTask, request, error);\n+        });\n+        boundary.fallbackAbortableTasks.clear();\n+      }\n       task = task.row;\n       null !== task &&\n         0 === --task.pendingTasks &&\n@@ -7339,64 +7579,58 @@\n           : (boundary.byteSize += segmentByteSize);\n       }\n     }\n-    function finishedTask(request$jscomp$0, boundary$jscomp$0, row, segment) {\n+    function finishedTask(request, boundary, row, segment) {\n       null !== row &&\n         (0 === --row.pendingTasks\n-          ? finishSuspenseListRow(request$jscomp$0, row)\n-          : row.together && tryToResolveTogetherRow(request$jscomp$0, row));\n-      request$jscomp$0.allPendingTasks--;\n-      if (null === boundary$jscomp$0) {\n+          ? finishSuspenseListRow(request, row)\n+          : row.together && tryToResolveTogetherRow(request, row));\n+      request.allPendingTasks--;\n+      if (null === boundary) {\n         if (null !== segment && segment.parentFlushed) {\n-          if (null !== request$jscomp$0.completedRootSegment)\n+          if (null !== request.completedRootSegment)\n             throw Error(\n               \"There can only be one root segment. This is a bug in React.\"\n             );\n-          request$jscomp$0.completedRootSegment = segment;\n+          request.completedRootSegment = segment;\n         }\n-        request$jscomp$0.pendingRootTasks--;\n-        0 === request$jscomp$0.pendingRootTasks &&\n-          completeShell(request$jscomp$0);\n-      } else if (\n-        (boundary$jscomp$0.pendingTasks--,\n-        boundary$jscomp$0.status !== CLIENT_RENDERED)\n-      )\n-        if (0 === boundary$jscomp$0.pendingTasks)\n+        request.pendingRootTasks--;\n+        0 === request.pendingRootTasks && completeShell(request);\n+      } else if ((boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED))\n+        if (0 === boundary.pendingTasks)\n           if (\n-            (boundary$jscomp$0.status === PENDING &&\n-              (boundary$jscomp$0.status = COMPLETED),\n+            (boundary.status === PENDING && (boundary.status = COMPLETED),\n             null !== segment &&\n               segment.parentFlushed &&\n               (segment.status === COMPLETED || segment.status === ABORTED) &&\n-              queueCompletedSegment(boundary$jscomp$0, segment),\n-            boundary$jscomp$0.parentFlushed &&\n-              request$jscomp$0.completedBoundaries.push(boundary$jscomp$0),\n-            boundary$jscomp$0.status === COMPLETED)\n+              queueCompletedSegment(boundary, segment),\n+            boundary.parentFlushed &&\n+              request.completedBoundaries.push(boundary),\n+            boundary.status === COMPLETED)\n           )\n-            (row = boundary$jscomp$0.row),\n+            (row = boundary.row),\n               null !== row &&\n-                hoistHoistables(row.hoistables, boundary$jscomp$0.contentState),\n-              isEligibleForOutlining(request$jscomp$0, boundary$jscomp$0) ||\n-                (boundary$jscomp$0.fallbackAbortableTasks.forEach(\n+                hoistHoistables(row.hoistables, boundary.contentState),\n+              isEligibleForOutlining(request, boundary) ||\n+                (boundary.fallbackAbortableTasks.forEach(\n                   abortTaskSoft,\n-                  request$jscomp$0\n+                  request\n                 ),\n-                boundary$jscomp$0.fallbackAbortableTasks.clear(),\n+                boundary.fallbackAbortableTasks.clear(),\n                 null !== row &&\n                   0 === --row.pendingTasks &&\n-                  finishSuspenseListRow(request$jscomp$0, row)),\n-              0 === request$jscomp$0.pendingRootTasks &&\n-                null === request$jscomp$0.trackedPostpones &&\n-                null !== boundary$jscomp$0.contentPreamble &&\n-                preparePreamble(request$jscomp$0);\n+                  finishSuspenseListRow(request, row)),\n+              0 === request.pendingRootTasks &&\n+                null === request.trackedPostpones &&\n+                null !== boundary.contentPreamble &&\n+                preparePreamble(request);\n           else {\n             if (\n-              boundary$jscomp$0.status === POSTPONED &&\n-              ((boundary$jscomp$0 = boundary$jscomp$0.row),\n-              null !== boundary$jscomp$0)\n+              boundary.status === POSTPONED &&\n+              ((boundary = boundary.row), null !== boundary)\n             ) {\n-              if (null !== request$jscomp$0.trackedPostpones) {\n-                row = request$jscomp$0.trackedPostpones;\n-                var postponedRow = boundary$jscomp$0.next;\n+              if (null !== request.trackedPostpones) {\n+                row = request.trackedPostpones;\n+                var postponedRow = boundary.next;\n                 if (\n                   null !== postponedRow &&\n                   ((segment = postponedRow.boundaries), null !== segment)\n@@ -7407,61 +7641,27 @@\n                     postponedRow++\n                   ) {\n                     var postponedBoundary = segment[postponedRow];\n-                    var request = request$jscomp$0,\n-                      trackedPostpones = row,\n-                      boundary = postponedBoundary;\n-                    boundary.status = POSTPONED;\n-                    boundary.rootSegmentID = request.nextSegmentId++;\n-                    request = boundary.trackedContentKeyPath;\n-                    if (null === request)\n-                      throw Error(\n-                        \"It should not be possible to postpone at the root. This is a bug in React.\"\n-                      );\n-                    var fallbackReplayNode = boundary.trackedFallbackNode,\n-                      children = [],\n-                      boundaryNode = trackedPostpones.workingMap.get(request);\n-                    void 0 === boundaryNode\n-                      ? ((boundary = [\n-                          request[1],\n-                          request[2],\n-                          children,\n-                          null,\n-                          fallbackReplayNode,\n-                          boundary.rootSegmentID\n-                        ]),\n-                        trackedPostpones.workingMap.set(request, boundary),\n-                        addToReplayParent(\n-                          boundary,\n-                          request[0],\n-                          trackedPostpones\n-                        ))\n-                      : ((boundaryNode[4] = fallbackReplayNode),\n-                        (boundaryNode[5] = boundary.rootSegmentID));\n-                    finishedTask(\n-                      request$jscomp$0,\n-                      postponedBoundary,\n-                      null,\n-                      null\n-                    );\n+                    trackPostponedBoundary(request, row, postponedBoundary);\n+                    finishedTask(request, postponedBoundary, null, null);\n                   }\n               }\n-              0 === --boundary$jscomp$0.pendingTasks &&\n-                finishSuspenseListRow(request$jscomp$0, boundary$jscomp$0);\n+              0 === --boundary.pendingTasks &&\n+                finishSuspenseListRow(request, boundary);\n             }\n           }\n         else\n           null === segment ||\n             !segment.parentFlushed ||\n             (segment.status !== COMPLETED && segment.status !== ABORTED) ||\n-            (queueCompletedSegment(boundary$jscomp$0, segment),\n-            1 === boundary$jscomp$0.completedSegments.length &&\n-              boundary$jscomp$0.parentFlushed &&\n-              request$jscomp$0.partialBoundaries.push(boundary$jscomp$0)),\n-            (boundary$jscomp$0 = boundary$jscomp$0.row),\n-            null !== boundary$jscomp$0 &&\n-              boundary$jscomp$0.together &&\n-              tryToResolveTogetherRow(request$jscomp$0, boundary$jscomp$0);\n-      0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n+            (queueCompletedSegment(boundary, segment),\n+            1 === boundary.completedSegments.length &&\n+              boundary.parentFlushed &&\n+              request.partialBoundaries.push(boundary)),\n+            (boundary = boundary.row),\n+            null !== boundary &&\n+              boundary.together &&\n+              tryToResolveTogetherRow(request, boundary);\n+      0 === request.allPendingTasks && completeAll(request);\n     }\n     function performWork(request$jscomp$2) {\n       if (\n@@ -7618,6 +7818,31 @@\n                       ? request.fatalError\n                       : thrownValue;\n                 if (\n+                  12 === request.status &&\n+                  null !== request.trackedPostpones\n+                ) {\n+                  var trackedPostpones = request.trackedPostpones,\n+                    thrownInfo = getThrownInfo(errorDigest.componentStack);\n+                  errorDigest.abortSet.delete(errorDigest);\n+                  logRecoverableError(\n+                    request,\n+                    x$jscomp$0,\n+                    thrownInfo,\n+                    errorDigest.debugTask\n+                  );\n+                  trackPostpone(\n+                    request,\n+                    trackedPostpones,\n+                    errorDigest,\n+                    request$jscomp$1\n+                  );\n+                  finishedTask(\n+                    request,\n+                    errorDigest.blockedBoundary,\n+                    errorDigest.row,\n+                    request$jscomp$1\n+                  );\n+                } else if (\n                   \"object\" === typeof x$jscomp$0 &&\n                   null !== x$jscomp$0 &&\n                   \"function\" === typeof x$jscomp$0.then\n@@ -8534,13 +8759,59 @@\n         parentNode[2].push(node);\n       }\n     }\n+    function getPostponedState(request) {\n+      var trackedPostpones = request.trackedPostpones;\n+      if (\n+        null === trackedPostpones ||\n+        (0 === trackedPostpones.rootNodes.length &&\n+          null === trackedPostpones.rootSlots)\n+      )\n+        return (request.trackedPostpones = null);\n+      if (\n+        null === request.completedRootSegment ||\n+        (request.completedRootSegment.status !== POSTPONED &&\n+          null !== request.completedPreambleSegments)\n+      ) {\n+        var nextSegmentId = request.nextSegmentId;\n+        var replaySlots = trackedPostpones.rootSlots;\n+        var resumableState = request.resumableState;\n+        resumableState.bootstrapScriptContent = void 0;\n+        resumableState.bootstrapScripts = void 0;\n+        resumableState.bootstrapModules = void 0;\n+      } else {\n+        nextSegmentId = 0;\n+        replaySlots = -1;\n+        resumableState = request.resumableState;\n+        var renderState = request.renderState;\n+        resumableState.nextFormID = 0;\n+        resumableState.hasBody = !1;\n+        resumableState.hasHtml = !1;\n+        resumableState.unknownResources = { font: renderState.resets.font };\n+        resumableState.dnsResources = renderState.resets.dns;\n+        resumableState.connectResources = renderState.resets.connect;\n+        resumableState.imageResources = renderState.resets.image;\n+        resumableState.styleResources = renderState.resets.style;\n+        resumableState.scriptResources = {};\n+        resumableState.moduleUnknownResources = {};\n+        resumableState.moduleScriptResources = {};\n+        resumableState.instructions = NothingSent;\n+      }\n+      return {\n+        nextSegmentId: nextSegmentId,\n+        rootFormatContext: request.rootFormatContext,\n+        progressiveChunkSize: request.progressiveChunkSize,\n+        resumableState: request.resumableState,\n+        replayNodes: trackedPostpones.rootNodes,\n+        replaySlots: replaySlots\n+      };\n+    }\n     function ensureCorrectIsomorphicReactVersion() {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.2.0-canary-548235db-20251001\" !== isomorphicReactPackageVersion)\n+      if (\"19.2.0-canary-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.2.0-canary-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.2.0-canary-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     }\n     var React = require(\"next/dist/compiled/react\"),\n@@ -10123,22 +10394,24 @@\n             options ? options.progressiveChunkSize : void 0,\n             options ? options.onError : void 0,\n             function () {\n-              var result = {\n-                prelude: new ReadableStream(\n-                  {\n-                    type: \"bytes\",\n-                    pull: function (controller) {\n-                      startFlowing(request, controller);\n-                    },\n-                    cancel: function (reason) {\n-                      request.destination = null;\n-                      abort(request, reason);\n-                    }\n+              var stream = new ReadableStream(\n+                {\n+                  type: \"bytes\",\n+                  pull: function (controller) {\n+                    startFlowing(request, controller);\n                   },\n-                  { highWaterMark: 0 }\n-                )\n+                  cancel: function (reason) {\n+                    request.destination = null;\n+                    abort(request, reason);\n+                  }\n+                },\n+                { highWaterMark: 0 }\n+              );\n+              stream = {\n+                postponed: getPostponedState(request),\n+                prelude: stream\n               };\n-              resolve(result);\n+              resolve(stream);\n             },\n             void 0,\n             void 0,\n@@ -10234,5 +10507,114 @@\n         startWork(request);\n       });\n     };\n-    exports.version = \"19.2.0-canary-548235db-20251001\";\n+    exports.resume = function (children, postponedState, options) {\n+      return new Promise(function (resolve, reject) {\n+        var onFatalError,\n+          onAllReady,\n+          allReady = new Promise(function (res, rej) {\n+            onAllReady = res;\n+            onFatalError = rej;\n+          }),\n+          request = resumeRequest(\n+            children,\n+            postponedState,\n+            createRenderState(\n+              postponedState.resumableState,\n+              options ? options.nonce : void 0,\n+              void 0,\n+              void 0,\n+              void 0,\n+              void 0\n+            ),\n+            options ? options.onError : void 0,\n+            onAllReady,\n+            function () {\n+              var stream = new ReadableStream(\n+                {\n+                  type: \"bytes\",\n+                  pull: function (controller) {\n+                    startFlowing(request, controller);\n+                  },\n+                  cancel: function (reason) {\n+                    request.destination = null;\n+                    abort(request, reason);\n+                  }\n+                },\n+                { highWaterMark: 0 }\n+              );\n+              stream.allReady = allReady;\n+              resolve(stream);\n+            },\n+            function (error) {\n+              allReady.catch(function () {});\n+              reject(error);\n+            },\n+            onFatalError,\n+            options ? options.onPostpone : void 0\n+          );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.resumeAndPrerender = function (children, postponedState, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = resumeAndPrerenderRequest(\n+          children,\n+          postponedState,\n+          createRenderState(\n+            postponedState.resumableState,\n+            void 0,\n+            void 0,\n+            void 0,\n+            void 0,\n+            void 0\n+          ),\n+          options ? options.onError : void 0,\n+          function () {\n+            var stream = new ReadableStream(\n+              {\n+                type: \"bytes\",\n+                pull: function (controller) {\n+                  startFlowing(request, controller);\n+                },\n+                cancel: function (reason) {\n+                  request.destination = null;\n+                  abort(request, reason);\n+                }\n+              },\n+              { highWaterMark: 0 }\n+            );\n+            stream = { postponed: getPostponedState(request), prelude: stream };\n+            resolve(stream);\n+          },\n+          void 0,\n+          void 0,\n+          reject,\n+          options ? options.onPostpone : void 0\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.version = \"19.2.0-canary-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "0c517a1f68c382f7f62d9395b0ba96df83544007",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.edge.production.js",
            "status": "modified",
            "additions": 487,
            "deletions": 130,
            "changes": 617,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.edge.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -4234,6 +4234,116 @@ function createPrerenderRequest(\n   };\n   return children;\n }\n+function resumeRequest(\n+  children,\n+  postponedState,\n+  renderState,\n+  onError,\n+  onAllReady,\n+  onShellReady,\n+  onShellError,\n+  onFatalError,\n+  onPostpone\n+) {\n+  renderState = new RequestInstance(\n+    postponedState.resumableState,\n+    renderState,\n+    postponedState.rootFormatContext,\n+    postponedState.progressiveChunkSize,\n+    onError,\n+    onAllReady,\n+    onShellReady,\n+    onShellError,\n+    onFatalError,\n+    onPostpone,\n+    null\n+  );\n+  renderState.nextSegmentId = postponedState.nextSegmentId;\n+  if (\"number\" === typeof postponedState.replaySlots)\n+    return (\n+      (onError = createPendingSegment(\n+        renderState,\n+        0,\n+        null,\n+        postponedState.rootFormatContext,\n+        !1,\n+        !1\n+      )),\n+      (onError.parentFlushed = !0),\n+      (children = createRenderTask(\n+        renderState,\n+        null,\n+        children,\n+        -1,\n+        null,\n+        onError,\n+        null,\n+        null,\n+        renderState.abortableTasks,\n+        null,\n+        postponedState.rootFormatContext,\n+        null,\n+        emptyTreeContext,\n+        null,\n+        null\n+      )),\n+      pushComponentStack(children),\n+      renderState.pingedTasks.push(children),\n+      renderState\n+    );\n+  children = createReplayTask(\n+    renderState,\n+    null,\n+    {\n+      nodes: postponedState.replayNodes,\n+      slots: postponedState.replaySlots,\n+      pendingTasks: 0\n+    },\n+    children,\n+    -1,\n+    null,\n+    null,\n+    renderState.abortableTasks,\n+    null,\n+    postponedState.rootFormatContext,\n+    null,\n+    emptyTreeContext,\n+    null,\n+    null\n+  );\n+  pushComponentStack(children);\n+  renderState.pingedTasks.push(children);\n+  return renderState;\n+}\n+function resumeAndPrerenderRequest(\n+  children,\n+  postponedState,\n+  renderState,\n+  onError,\n+  onAllReady,\n+  onShellReady,\n+  onShellError,\n+  onFatalError,\n+  onPostpone\n+) {\n+  children = resumeRequest(\n+    children,\n+    postponedState,\n+    renderState,\n+    onError,\n+    onAllReady,\n+    onShellReady,\n+    onShellError,\n+    onFatalError,\n+    onPostpone\n+  );\n+  children.trackedPostpones = {\n+    workingMap: new Map(),\n+    rootNodes: [],\n+    rootSlots: null\n+  };\n+  return children;\n+}\n var currentRequest = null;\n function resolveRequest() {\n   if (currentRequest) return currentRequest;\n@@ -4690,9 +4800,9 @@ function renderElement(request, task, keyPath, type, props, ref) {\n       var defaultProps = type.defaultProps;\n       if (defaultProps) {\n         newProps === props && (newProps = assign({}, newProps, props));\n-        for (var propName$43 in defaultProps)\n-          void 0 === newProps[propName$43] &&\n-            (newProps[propName$43] = defaultProps[propName$43]);\n+        for (var propName$44 in defaultProps)\n+          void 0 === newProps[propName$44] &&\n+            (newProps[propName$44] = defaultProps[propName$44]);\n       }\n       props = newProps;\n       newProps = emptyContextObject;\n@@ -4752,16 +4862,16 @@ function renderElement(request, task, keyPath, type, props, ref) {\n             defaultProps = ref ? type[0] : newProps.state;\n             initialState = !0;\n             for (ref = ref ? 1 : 0; ref < type.length; ref++)\n-              (propName$43 = type[ref]),\n-                (propName$43 =\n-                  \"function\" === typeof propName$43\n-                    ? propName$43.call(newProps, defaultProps, props, void 0)\n-                    : propName$43),\n-                null != propName$43 &&\n+              (propName$44 = type[ref]),\n+                (propName$44 =\n+                  \"function\" === typeof propName$44\n+                    ? propName$44.call(newProps, defaultProps, props, void 0)\n+                    : propName$44),\n+                null != propName$44 &&\n                   (initialState\n                     ? ((initialState = !1),\n-                      (defaultProps = assign({}, defaultProps, propName$43)))\n-                    : assign(defaultProps, propName$43));\n+                      (defaultProps = assign({}, defaultProps, propName$44)))\n+                    : assign(defaultProps, propName$44));\n             newProps.state = defaultProps;\n           }\n         else defaultProps.queue = null;\n@@ -4981,7 +5091,7 @@ function renderElement(request, task, keyPath, type, props, ref) {\n           type = task.keyPath;\n           ref = task.formatContext;\n           var prevRow = task.row;\n-          propName$43 = task.blockedBoundary;\n+          propName$44 = task.blockedBoundary;\n           propName = task.blockedPreamble;\n           var parentHoistableState = task.hoistableState,\n             parentSegment = task.blockedSegment,\n@@ -5047,7 +5157,7 @@ function renderElement(request, task, keyPath, type, props, ref) {\n                   boundarySegment.textEmbedded &&\n                   boundarySegment.chunks.push(textSeparator),\n                 (boundarySegment.status = 1),\n-                finishedSegment(request, propName$43, boundarySegment);\n+                finishedSegment(request, propName$44, boundarySegment);\n             } catch (thrownValue) {\n               throw (\n                 ((boundarySegment.status = 12 === request.status ? 3 : 4),\n@@ -5120,13 +5230,13 @@ function renderElement(request, task, keyPath, type, props, ref) {\n                 null !== prevRow &&\n                   prevRow.together &&\n                   tryToResolveTogetherRow(request, prevRow);\n-            } catch (thrownValue$30) {\n+            } catch (thrownValue$31) {\n               (newBoundary.status = 4),\n                 12 === request.status\n                   ? ((contentRootSegment.status = 3),\n                     (newProps = request.fatalError))\n                   : ((contentRootSegment.status = 4),\n-                    (newProps = thrownValue$30)),\n+                    (newProps = thrownValue$31)),\n                 (defaultProps = getThrownInfo(task.componentStack)),\n                 (initialState = logRecoverableError(\n                   request,\n@@ -5136,7 +5246,7 @@ function renderElement(request, task, keyPath, type, props, ref) {\n                 (newBoundary.errorDigest = initialState),\n                 untrackBoundary(request, newBoundary);\n             } finally {\n-              (task.blockedBoundary = propName$43),\n+              (task.blockedBoundary = propName$44),\n                 (task.blockedPreamble = propName),\n                 (task.hoistableState = parentHoistableState),\n                 (task.blockedSegment = parentSegment),\n@@ -5149,7 +5259,7 @@ function renderElement(request, task, keyPath, type, props, ref) {\n               null,\n               fallback,\n               -1,\n-              propName$43,\n+              propName$44,\n               boundarySegment,\n               newBoundary.fallbackPreamble,\n               newBoundary.fallbackState,\n@@ -5637,6 +5747,105 @@ function renderChildrenArray(request, task, children, childIndex) {\n   task.treeContext = replay;\n   task.keyPath = prevKeyPath;\n }\n+function trackPostponedBoundary(request, trackedPostpones, boundary) {\n+  boundary.status = 5;\n+  boundary.rootSegmentID = request.nextSegmentId++;\n+  request = boundary.trackedContentKeyPath;\n+  if (null === request)\n+    throw Error(\n+      \"It should not be possible to postpone at the root. This is a bug in React.\"\n+    );\n+  var fallbackReplayNode = boundary.trackedFallbackNode,\n+    children = [],\n+    boundaryNode = trackedPostpones.workingMap.get(request);\n+  if (void 0 === boundaryNode)\n+    return (\n+      (boundary = [\n+        request[1],\n+        request[2],\n+        children,\n+        null,\n+        fallbackReplayNode,\n+        boundary.rootSegmentID\n+      ]),\n+      trackedPostpones.workingMap.set(request, boundary),\n+      addToReplayParent(boundary, request[0], trackedPostpones),\n+      boundary\n+    );\n+  boundaryNode[4] = fallbackReplayNode;\n+  boundaryNode[5] = boundary.rootSegmentID;\n+  return boundaryNode;\n+}\n+function trackPostpone(request, trackedPostpones, task, segment) {\n+  segment.status = 5;\n+  var keyPath = task.keyPath,\n+    boundary = task.blockedBoundary;\n+  if (null === boundary)\n+    (segment.id = request.nextSegmentId++),\n+      (trackedPostpones.rootSlots = segment.id),\n+      null !== request.completedRootSegment &&\n+        (request.completedRootSegment.status = 5);\n+  else {\n+    if (null !== boundary && 0 === boundary.status) {\n+      var boundaryNode = trackPostponedBoundary(\n+        request,\n+        trackedPostpones,\n+        boundary\n+      );\n+      if (\n+        boundary.trackedContentKeyPath === keyPath &&\n+        -1 === task.childIndex\n+      ) {\n+        -1 === segment.id &&\n+          (segment.id = segment.parentFlushed\n+            ? boundary.rootSegmentID\n+            : request.nextSegmentId++);\n+        boundaryNode[3] = segment.id;\n+        return;\n+      }\n+    }\n+    -1 === segment.id &&\n+      (segment.id =\n+        segment.parentFlushed && null !== boundary\n+          ? boundary.rootSegmentID\n+          : request.nextSegmentId++);\n+    if (-1 === task.childIndex)\n+      null === keyPath\n+        ? (trackedPostpones.rootSlots = segment.id)\n+        : ((task = trackedPostpones.workingMap.get(keyPath)),\n+          void 0 === task\n+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n+              addToReplayParent(task, keyPath[0], trackedPostpones))\n+            : (task[3] = segment.id));\n+    else {\n+      if (null === keyPath)\n+        if (((request = trackedPostpones.rootSlots), null === request))\n+          request = trackedPostpones.rootSlots = {};\n+        else {\n+          if (\"number\" === typeof request)\n+            throw Error(\n+              \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+            );\n+        }\n+      else if (\n+        ((boundary = trackedPostpones.workingMap),\n+        (boundaryNode = boundary.get(keyPath)),\n+        void 0 === boundaryNode)\n+      )\n+        (request = {}),\n+          (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n+          boundary.set(keyPath, boundaryNode),\n+          addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n+      else if (((request = boundaryNode[3]), null === request))\n+        request = boundaryNode[3] = {};\n+      else if (\"number\" === typeof request)\n+        throw Error(\n+          \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+        );\n+      request[task.childIndex] = segment.id;\n+    }\n+  }\n+}\n function untrackBoundary(request, boundary) {\n   request = request.trackedPostpones;\n   null !== request &&\n@@ -5753,21 +5962,21 @@ function renderNode(request, task, node, childIndex) {\n       chunkLength = segment.chunks.length;\n     try {\n       return renderNodeDestructive(request, task, node, childIndex);\n-    } catch (thrownValue$60) {\n+    } catch (thrownValue$63) {\n       if (\n         (resetHooksState(),\n         (segment.children.length = childrenLength),\n         (segment.chunks.length = chunkLength),\n         (node =\n-          thrownValue$60 === SuspenseException\n+          thrownValue$63 === SuspenseException\n             ? getSuspendedThenable()\n-            : thrownValue$60),\n+            : thrownValue$63),\n         12 !== request.status && \"object\" === typeof node && null !== node)\n       ) {\n         if (\"function\" === typeof node.then) {\n           segment = node;\n           node =\n-            thrownValue$60 === SuspenseException\n+            thrownValue$63 === SuspenseException\n               ? getThenableStateAfterSuspending()\n               : null;\n           request = spawnNewSuspendedRenderTask(request, task, node).ping;\n@@ -5782,7 +5991,7 @@ function renderNode(request, task, node, childIndex) {\n         }\n         if (\"Maximum call stack size exceeded\" === node.message) {\n           segment =\n-            thrownValue$60 === SuspenseException\n+            thrownValue$63 === SuspenseException\n               ? getThenableStateAfterSuspending()\n               : null;\n           segment = spawnNewSuspendedRenderTask(request, task, segment);\n@@ -5870,19 +6079,24 @@ function abortTask(task, request, error) {\n     if (6 === segment.status) return;\n     segment.status = 3;\n   }\n-  segment = getThrownInfo(task.componentStack);\n+  var errorInfo = getThrownInfo(task.componentStack);\n   if (null === boundary) {\n     if (13 !== request.status && 14 !== request.status) {\n       boundary = task.replay;\n       if (null === boundary) {\n-        logRecoverableError(request, error, segment);\n-        fatalError(request, error);\n+        null !== request.trackedPostpones && null !== segment\n+          ? ((boundary = request.trackedPostpones),\n+            logRecoverableError(request, error, errorInfo),\n+            trackPostpone(request, boundary, task, segment),\n+            finishedTask(request, null, task.row, segment))\n+          : (logRecoverableError(request, error, errorInfo),\n+            fatalError(request, error));\n         return;\n       }\n       boundary.pendingTasks--;\n       0 === boundary.pendingTasks &&\n         0 < boundary.nodes.length &&\n-        ((segment = logRecoverableError(request, error, segment)),\n+        ((segment = logRecoverableError(request, error, errorInfo)),\n         abortRemainingReplayNodes(\n           request,\n           null,\n@@ -5894,24 +6108,36 @@ function abortTask(task, request, error) {\n       request.pendingRootTasks--;\n       0 === request.pendingRootTasks && completeShell(request);\n     }\n-  } else\n-    4 !== boundary.status &&\n-      ((boundary.status = 4),\n-      (segment = logRecoverableError(request, error, segment)),\n-      (boundary.status = 4),\n-      (boundary.errorDigest = segment),\n-      untrackBoundary(request, boundary),\n-      boundary.parentFlushed &&\n-        request.clientRenderedBoundaries.push(boundary)),\n-      boundary.pendingTasks--,\n-      (segment = boundary.row),\n-      null !== segment &&\n-        0 === --segment.pendingTasks &&\n-        finishSuspenseListRow(request, segment),\n-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n-        return abortTask(fallbackTask, request, error);\n-      }),\n-      boundary.fallbackAbortableTasks.clear();\n+  } else {\n+    var trackedPostpones$64 = request.trackedPostpones;\n+    if (4 !== boundary.status) {\n+      if (null !== trackedPostpones$64 && null !== segment)\n+        return (\n+          logRecoverableError(request, error, errorInfo),\n+          trackPostpone(request, trackedPostpones$64, task, segment),\n+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+            return abortTask(fallbackTask, request, error);\n+          }),\n+          boundary.fallbackAbortableTasks.clear(),\n+          finishedTask(request, boundary, task.row, segment)\n+        );\n+      boundary.status = 4;\n+      segment = logRecoverableError(request, error, errorInfo);\n+      boundary.status = 4;\n+      boundary.errorDigest = segment;\n+      untrackBoundary(request, boundary);\n+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);\n+    }\n+    boundary.pendingTasks--;\n+    segment = boundary.row;\n+    null !== segment &&\n+      0 === --segment.pendingTasks &&\n+      finishSuspenseListRow(request, segment);\n+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+      return abortTask(fallbackTask, request, error);\n+    });\n+    boundary.fallbackAbortableTasks.clear();\n+  }\n   task = task.row;\n   null !== task &&\n     0 === --task.pendingTasks &&\n@@ -6025,22 +6251,22 @@ function finishedSegment(request, boundary, segment) {\n       : (boundary.byteSize += segmentByteSize);\n   }\n }\n-function finishedTask(request$jscomp$0, boundary, row, segment) {\n+function finishedTask(request, boundary, row, segment) {\n   null !== row &&\n     (0 === --row.pendingTasks\n-      ? finishSuspenseListRow(request$jscomp$0, row)\n-      : row.together && tryToResolveTogetherRow(request$jscomp$0, row));\n-  request$jscomp$0.allPendingTasks--;\n+      ? finishSuspenseListRow(request, row)\n+      : row.together && tryToResolveTogetherRow(request, row));\n+  request.allPendingTasks--;\n   if (null === boundary) {\n     if (null !== segment && segment.parentFlushed) {\n-      if (null !== request$jscomp$0.completedRootSegment)\n+      if (null !== request.completedRootSegment)\n         throw Error(\n           \"There can only be one root segment. This is a bug in React.\"\n         );\n-      request$jscomp$0.completedRootSegment = segment;\n+      request.completedRootSegment = segment;\n     }\n-    request$jscomp$0.pendingRootTasks--;\n-    0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);\n+    request.pendingRootTasks--;\n+    0 === request.pendingRootTasks && completeShell(request);\n   } else if ((boundary.pendingTasks--, 4 !== boundary.status))\n     if (0 === boundary.pendingTasks)\n       if (\n@@ -6049,33 +6275,29 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n           segment.parentFlushed &&\n           (1 === segment.status || 3 === segment.status) &&\n           queueCompletedSegment(boundary, segment),\n-        boundary.parentFlushed &&\n-          request$jscomp$0.completedBoundaries.push(boundary),\n+        boundary.parentFlushed && request.completedBoundaries.push(boundary),\n         1 === boundary.status)\n       )\n         (row = boundary.row),\n           null !== row &&\n             hoistHoistables(row.hoistables, boundary.contentState),\n-          isEligibleForOutlining(request$jscomp$0, boundary) ||\n-            (boundary.fallbackAbortableTasks.forEach(\n-              abortTaskSoft,\n-              request$jscomp$0\n-            ),\n+          isEligibleForOutlining(request, boundary) ||\n+            (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),\n             boundary.fallbackAbortableTasks.clear(),\n             null !== row &&\n               0 === --row.pendingTasks &&\n-              finishSuspenseListRow(request$jscomp$0, row)),\n-          0 === request$jscomp$0.pendingRootTasks &&\n-            null === request$jscomp$0.trackedPostpones &&\n+              finishSuspenseListRow(request, row)),\n+          0 === request.pendingRootTasks &&\n+            null === request.trackedPostpones &&\n             null !== boundary.contentPreamble &&\n-            preparePreamble(request$jscomp$0);\n+            preparePreamble(request);\n       else {\n         if (\n           5 === boundary.status &&\n           ((boundary = boundary.row), null !== boundary)\n         ) {\n-          if (null !== request$jscomp$0.trackedPostpones) {\n-            row = request$jscomp$0.trackedPostpones;\n+          if (null !== request.trackedPostpones) {\n+            row = request.trackedPostpones;\n             var postponedRow = boundary.next;\n             if (\n               null !== postponedRow &&\n@@ -6087,43 +6309,12 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n                 postponedRow++\n               ) {\n                 var postponedBoundary = segment[postponedRow];\n-                var request = request$jscomp$0,\n-                  trackedPostpones = row;\n-                postponedBoundary.status = 5;\n-                postponedBoundary.rootSegmentID = request.nextSegmentId++;\n-                request = postponedBoundary.trackedContentKeyPath;\n-                if (null === request)\n-                  throw Error(\n-                    \"It should not be possible to postpone at the root. This is a bug in React.\"\n-                  );\n-                var fallbackReplayNode = postponedBoundary.trackedFallbackNode,\n-                  children = [],\n-                  boundaryNode = trackedPostpones.workingMap.get(request);\n-                void 0 === boundaryNode\n-                  ? ((fallbackReplayNode = [\n-                      request[1],\n-                      request[2],\n-                      children,\n-                      null,\n-                      fallbackReplayNode,\n-                      postponedBoundary.rootSegmentID\n-                    ]),\n-                    trackedPostpones.workingMap.set(\n-                      request,\n-                      fallbackReplayNode\n-                    ),\n-                    addToReplayParent(\n-                      fallbackReplayNode,\n-                      request[0],\n-                      trackedPostpones\n-                    ))\n-                  : ((boundaryNode[4] = fallbackReplayNode),\n-                    (boundaryNode[5] = postponedBoundary.rootSegmentID));\n-                finishedTask(request$jscomp$0, postponedBoundary, null, null);\n+                trackPostponedBoundary(request, row, postponedBoundary);\n+                finishedTask(request, postponedBoundary, null, null);\n               }\n           }\n           0 === --boundary.pendingTasks &&\n-            finishSuspenseListRow(request$jscomp$0, boundary);\n+            finishSuspenseListRow(request, boundary);\n         }\n       }\n     else\n@@ -6133,12 +6324,12 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n         (queueCompletedSegment(boundary, segment),\n         1 === boundary.completedSegments.length &&\n           boundary.parentFlushed &&\n-          request$jscomp$0.partialBoundaries.push(boundary)),\n+          request.partialBoundaries.push(boundary)),\n         (boundary = boundary.row),\n         null !== boundary &&\n           boundary.together &&\n-          tryToResolveTogetherRow(request$jscomp$0, boundary);\n-  0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n+          tryToResolveTogetherRow(request, boundary);\n+  0 === request.allPendingTasks && completeAll(request);\n }\n function performWork(request$jscomp$2) {\n   if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {\n@@ -6273,7 +6464,19 @@ function performWork(request$jscomp$2) {\n                 : 12 === request.status\n                   ? request.fatalError\n                   : thrownValue;\n-            if (\n+            if (12 === request.status && null !== request.trackedPostpones) {\n+              var trackedPostpones = request.trackedPostpones,\n+                thrownInfo = getThrownInfo(task.componentStack);\n+              task.abortSet.delete(task);\n+              logRecoverableError(request, x$jscomp$0, thrownInfo);\n+              trackPostpone(request, trackedPostpones, task, request$jscomp$1);\n+              finishedTask(\n+                request,\n+                task.blockedBoundary,\n+                task.row,\n+                request$jscomp$1\n+              );\n+            } else if (\n               \"object\" === typeof x$jscomp$0 &&\n               null !== x$jscomp$0 &&\n               \"function\" === typeof x$jscomp$0.then\n@@ -6838,12 +7041,12 @@ function flushCompletedQueues(request, destination) {\n       flushingPartialBoundaries = !0;\n       var partialBoundaries = request.partialBoundaries;\n       for (i = 0; i < partialBoundaries.length; i++) {\n-        var boundary$66 = partialBoundaries[i];\n+        var boundary$70 = partialBoundaries[i];\n         a: {\n           clientRenderedBoundaries = request;\n           boundary = destination;\n-          flushedByteSize = boundary$66.byteSize;\n-          var completedSegments = boundary$66.completedSegments;\n+          flushedByteSize = boundary$70.byteSize;\n+          var completedSegments = boundary$70.completedSegments;\n           for (\n             JSCompiler_inline_result = 0;\n             JSCompiler_inline_result < completedSegments.length;\n@@ -6853,7 +7056,7 @@ function flushCompletedQueues(request, destination) {\n               !flushPartiallyCompletedSegment(\n                 clientRenderedBoundaries,\n                 boundary,\n-                boundary$66,\n+                boundary$70,\n                 completedSegments[JSCompiler_inline_result]\n               )\n             ) {\n@@ -6863,10 +7066,10 @@ function flushCompletedQueues(request, destination) {\n               break a;\n             }\n           completedSegments.splice(0, JSCompiler_inline_result);\n-          var row = boundary$66.row;\n+          var row = boundary$70.row;\n           null !== row &&\n             row.together &&\n-            1 === boundary$66.pendingTasks &&\n+            1 === boundary$70.pendingTasks &&\n             (1 === row.pendingTasks\n               ? unblockSuspenseListRow(\n                   clientRenderedBoundaries,\n@@ -6876,7 +7079,7 @@ function flushCompletedQueues(request, destination) {\n               : row.pendingTasks--);\n           JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n             boundary,\n-            boundary$66.contentState,\n+            boundary$70.contentState,\n             clientRenderedBoundaries.renderState\n           );\n         }\n@@ -6984,8 +7187,8 @@ function abort(request, reason) {\n     }\n     null !== request.destination &&\n       flushCompletedQueues(request, request.destination);\n-  } catch (error$68) {\n-    logRecoverableError(request, error$68, {}), fatalError(request, error$68);\n+  } catch (error$72) {\n+    logRecoverableError(request, error$72, {}), fatalError(request, error$72);\n   }\n }\n function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n@@ -7000,13 +7203,59 @@ function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n     parentNode[2].push(node);\n   }\n }\n+function getPostponedState(request) {\n+  var trackedPostpones = request.trackedPostpones;\n+  if (\n+    null === trackedPostpones ||\n+    (0 === trackedPostpones.rootNodes.length &&\n+      null === trackedPostpones.rootSlots)\n+  )\n+    return (request.trackedPostpones = null);\n+  if (\n+    null === request.completedRootSegment ||\n+    (5 !== request.completedRootSegment.status &&\n+      null !== request.completedPreambleSegments)\n+  ) {\n+    var nextSegmentId = request.nextSegmentId;\n+    var replaySlots = trackedPostpones.rootSlots;\n+    var resumableState = request.resumableState;\n+    resumableState.bootstrapScriptContent = void 0;\n+    resumableState.bootstrapScripts = void 0;\n+    resumableState.bootstrapModules = void 0;\n+  } else {\n+    nextSegmentId = 0;\n+    replaySlots = -1;\n+    resumableState = request.resumableState;\n+    var renderState = request.renderState;\n+    resumableState.nextFormID = 0;\n+    resumableState.hasBody = !1;\n+    resumableState.hasHtml = !1;\n+    resumableState.unknownResources = { font: renderState.resets.font };\n+    resumableState.dnsResources = renderState.resets.dns;\n+    resumableState.connectResources = renderState.resets.connect;\n+    resumableState.imageResources = renderState.resets.image;\n+    resumableState.styleResources = renderState.resets.style;\n+    resumableState.scriptResources = {};\n+    resumableState.moduleUnknownResources = {};\n+    resumableState.moduleScriptResources = {};\n+    resumableState.instructions = 0;\n+  }\n+  return {\n+    nextSegmentId: nextSegmentId,\n+    rootFormatContext: request.rootFormatContext,\n+    progressiveChunkSize: request.progressiveChunkSize,\n+    resumableState: request.resumableState,\n+    replayNodes: trackedPostpones.rootNodes,\n+    replaySlots: replaySlots\n+  };\n+}\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.2.0-canary-548235db-20251001\" !== isomorphicReactPackageVersion)\n+  if (\"19.2.0-canary-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n     throw Error(\n       'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n         (isomorphicReactPackageVersion +\n-          \"\\n  - react-dom:  19.2.0-canary-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+          \"\\n  - react-dom:  19.2.0-canary-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n     );\n }\n ensureCorrectIsomorphicReactVersion();\n@@ -7041,22 +7290,21 @@ exports.prerender = function (children, options) {\n         options ? options.progressiveChunkSize : void 0,\n         options ? options.onError : void 0,\n         function () {\n-          var result = {\n-            prelude: new ReadableStream(\n-              {\n-                type: \"bytes\",\n-                pull: function (controller) {\n-                  startFlowing(request, controller);\n-                },\n-                cancel: function (reason) {\n-                  request.destination = null;\n-                  abort(request, reason);\n-                }\n+          var stream = new ReadableStream(\n+            {\n+              type: \"bytes\",\n+              pull: function (controller) {\n+                startFlowing(request, controller);\n               },\n-              { highWaterMark: 0 }\n-            )\n-          };\n-          resolve(result);\n+              cancel: function (reason) {\n+                request.destination = null;\n+                abort(request, reason);\n+              }\n+            },\n+            { highWaterMark: 0 }\n+          );\n+          stream = { postponed: getPostponedState(request), prelude: stream };\n+          resolve(stream);\n         },\n         void 0,\n         void 0,\n@@ -7152,4 +7400,113 @@ exports.renderToReadableStream = function (children, options) {\n     startWork(request);\n   });\n };\n-exports.version = \"19.2.0-canary-548235db-20251001\";\n+exports.resume = function (children, postponedState, options) {\n+  return new Promise(function (resolve, reject) {\n+    var onFatalError,\n+      onAllReady,\n+      allReady = new Promise(function (res, rej) {\n+        onAllReady = res;\n+        onFatalError = rej;\n+      }),\n+      request = resumeRequest(\n+        children,\n+        postponedState,\n+        createRenderState(\n+          postponedState.resumableState,\n+          options ? options.nonce : void 0,\n+          void 0,\n+          void 0,\n+          void 0,\n+          void 0\n+        ),\n+        options ? options.onError : void 0,\n+        onAllReady,\n+        function () {\n+          var stream = new ReadableStream(\n+            {\n+              type: \"bytes\",\n+              pull: function (controller) {\n+                startFlowing(request, controller);\n+              },\n+              cancel: function (reason) {\n+                request.destination = null;\n+                abort(request, reason);\n+              }\n+            },\n+            { highWaterMark: 0 }\n+          );\n+          stream.allReady = allReady;\n+          resolve(stream);\n+        },\n+        function (error) {\n+          allReady.catch(function () {});\n+          reject(error);\n+        },\n+        onFatalError,\n+        options ? options.onPostpone : void 0\n+      );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.resumeAndPrerender = function (children, postponedState, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = resumeAndPrerenderRequest(\n+      children,\n+      postponedState,\n+      createRenderState(\n+        postponedState.resumableState,\n+        void 0,\n+        void 0,\n+        void 0,\n+        void 0,\n+        void 0\n+      ),\n+      options ? options.onError : void 0,\n+      function () {\n+        var stream = new ReadableStream(\n+          {\n+            type: \"bytes\",\n+            pull: function (controller) {\n+              startFlowing(request, controller);\n+            },\n+            cancel: function (reason) {\n+              request.destination = null;\n+              abort(request, reason);\n+            }\n+          },\n+          { highWaterMark: 0 }\n+        );\n+        stream = { postponed: getPostponedState(request), prelude: stream };\n+        resolve(stream);\n+      },\n+      void 0,\n+      void 0,\n+      reject,\n+      options ? options.onPostpone : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.version = \"19.2.0-canary-1bd1f01f-20251001\";"
        },
        {
            "sha": "4e5f64f95b887611ab8fd6f3b91eb2370042fc0a",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.node.development.js",
            "status": "modified",
            "additions": 642,
            "deletions": 137,
            "changes": 779,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.node.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -4431,6 +4431,12 @@\n       }\n       return \"\";\n     }\n+    function resetOwnerStackLimit() {\n+      var now = getCurrentTime();\n+      1e3 < now - lastResetTime &&\n+        ((ReactSharedInternals.recentlyCreatedOwnerStacks = 0),\n+        (lastResetTime = now));\n+    }\n     function isEligibleForOutlining(request, boundary) {\n       return (\n         (500 < boundary.byteSize ||\n@@ -4524,10 +4530,7 @@\n       onPostpone,\n       formState\n     ) {\n-      var now = getCurrentTime();\n-      1e3 < now - lastResetTime &&\n-        ((ReactSharedInternals.recentlyCreatedOwnerStacks = 0),\n-        (lastResetTime = now));\n+      resetOwnerStackLimit();\n       resumableState = new RequestInstance(\n         resumableState,\n         renderState,\n@@ -4607,6 +4610,121 @@\n       };\n       return children;\n     }\n+    function resumeRequest(\n+      children,\n+      postponedState,\n+      renderState,\n+      onError,\n+      onAllReady,\n+      onShellReady,\n+      onShellError,\n+      onFatalError,\n+      onPostpone\n+    ) {\n+      resetOwnerStackLimit();\n+      renderState = new RequestInstance(\n+        postponedState.resumableState,\n+        renderState,\n+        postponedState.rootFormatContext,\n+        postponedState.progressiveChunkSize,\n+        onError,\n+        onAllReady,\n+        onShellReady,\n+        onShellError,\n+        onFatalError,\n+        onPostpone,\n+        null\n+      );\n+      renderState.nextSegmentId = postponedState.nextSegmentId;\n+      if (\"number\" === typeof postponedState.replaySlots)\n+        return (\n+          (onError = createPendingSegment(\n+            renderState,\n+            0,\n+            null,\n+            postponedState.rootFormatContext,\n+            !1,\n+            !1\n+          )),\n+          (onError.parentFlushed = !0),\n+          (children = createRenderTask(\n+            renderState,\n+            null,\n+            children,\n+            -1,\n+            null,\n+            onError,\n+            null,\n+            null,\n+            renderState.abortableTasks,\n+            null,\n+            postponedState.rootFormatContext,\n+            null,\n+            emptyTreeContext,\n+            null,\n+            null,\n+            emptyContextObject,\n+            null\n+          )),\n+          pushComponentStack(children),\n+          renderState.pingedTasks.push(children),\n+          renderState\n+        );\n+      children = createReplayTask(\n+        renderState,\n+        null,\n+        {\n+          nodes: postponedState.replayNodes,\n+          slots: postponedState.replaySlots,\n+          pendingTasks: 0\n+        },\n+        children,\n+        -1,\n+        null,\n+        null,\n+        renderState.abortableTasks,\n+        null,\n+        postponedState.rootFormatContext,\n+        null,\n+        emptyTreeContext,\n+        null,\n+        null,\n+        emptyContextObject,\n+        null\n+      );\n+      pushComponentStack(children);\n+      renderState.pingedTasks.push(children);\n+      return renderState;\n+    }\n+    function resumeAndPrerenderRequest(\n+      children,\n+      postponedState,\n+      renderState,\n+      onError,\n+      onAllReady,\n+      onShellReady,\n+      onShellError,\n+      onFatalError,\n+      onPostpone\n+    ) {\n+      children = resumeRequest(\n+        children,\n+        postponedState,\n+        renderState,\n+        onError,\n+        onAllReady,\n+        onShellReady,\n+        onShellError,\n+        onFatalError,\n+        onPostpone\n+      );\n+      children.trackedPostpones = {\n+        workingMap: new Map(),\n+        rootNodes: [],\n+        rootSlots: null\n+      };\n+      return children;\n+    }\n     function resolveRequest() {\n       if (currentRequest) return currentRequest;\n       var store = requestStorage.getStore();\n@@ -6806,6 +6924,105 @@\n       task.componentStack = previousComponentStack;\n       task.debugTask = previousDebugTask;\n     }\n+    function trackPostponedBoundary(request, trackedPostpones, boundary) {\n+      boundary.status = POSTPONED;\n+      boundary.rootSegmentID = request.nextSegmentId++;\n+      request = boundary.trackedContentKeyPath;\n+      if (null === request)\n+        throw Error(\n+          \"It should not be possible to postpone at the root. This is a bug in React.\"\n+        );\n+      var fallbackReplayNode = boundary.trackedFallbackNode,\n+        children = [],\n+        boundaryNode = trackedPostpones.workingMap.get(request);\n+      if (void 0 === boundaryNode)\n+        return (\n+          (boundary = [\n+            request[1],\n+            request[2],\n+            children,\n+            null,\n+            fallbackReplayNode,\n+            boundary.rootSegmentID\n+          ]),\n+          trackedPostpones.workingMap.set(request, boundary),\n+          addToReplayParent(boundary, request[0], trackedPostpones),\n+          boundary\n+        );\n+      boundaryNode[4] = fallbackReplayNode;\n+      boundaryNode[5] = boundary.rootSegmentID;\n+      return boundaryNode;\n+    }\n+    function trackPostpone(request, trackedPostpones, task, segment) {\n+      segment.status = POSTPONED;\n+      var keyPath = task.keyPath,\n+        boundary = task.blockedBoundary;\n+      if (null === boundary)\n+        (segment.id = request.nextSegmentId++),\n+          (trackedPostpones.rootSlots = segment.id),\n+          null !== request.completedRootSegment &&\n+            (request.completedRootSegment.status = POSTPONED);\n+      else {\n+        if (null !== boundary && boundary.status === PENDING) {\n+          var boundaryNode = trackPostponedBoundary(\n+            request,\n+            trackedPostpones,\n+            boundary\n+          );\n+          if (\n+            boundary.trackedContentKeyPath === keyPath &&\n+            -1 === task.childIndex\n+          ) {\n+            -1 === segment.id &&\n+              (segment.id = segment.parentFlushed\n+                ? boundary.rootSegmentID\n+                : request.nextSegmentId++);\n+            boundaryNode[3] = segment.id;\n+            return;\n+          }\n+        }\n+        -1 === segment.id &&\n+          (segment.id =\n+            segment.parentFlushed && null !== boundary\n+              ? boundary.rootSegmentID\n+              : request.nextSegmentId++);\n+        if (-1 === task.childIndex)\n+          null === keyPath\n+            ? (trackedPostpones.rootSlots = segment.id)\n+            : ((task = trackedPostpones.workingMap.get(keyPath)),\n+              void 0 === task\n+                ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n+                  addToReplayParent(task, keyPath[0], trackedPostpones))\n+                : (task[3] = segment.id));\n+        else {\n+          if (null === keyPath)\n+            if (((request = trackedPostpones.rootSlots), null === request))\n+              request = trackedPostpones.rootSlots = {};\n+            else {\n+              if (\"number\" === typeof request)\n+                throw Error(\n+                  \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+                );\n+            }\n+          else if (\n+            ((boundary = trackedPostpones.workingMap),\n+            (boundaryNode = boundary.get(keyPath)),\n+            void 0 === boundaryNode)\n+          )\n+            (request = {}),\n+              (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n+              boundary.set(keyPath, boundaryNode),\n+              addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n+          else if (((request = boundaryNode[3]), null === request))\n+            request = boundaryNode[3] = {};\n+          else if (\"number\" === typeof request)\n+            throw Error(\n+              \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+            );\n+          request[task.childIndex] = segment.id;\n+        }\n+      }\n+    }\n     function untrackBoundary(request, boundary) {\n       request = request.trackedPostpones;\n       null !== request &&\n@@ -7073,54 +7290,77 @@\n         if (6 === segment.status) return;\n         segment.status = ABORTED;\n       }\n-      segment = getThrownInfo(task.componentStack);\n-      var node = task.node;\n+      var errorInfo = getThrownInfo(task.componentStack),\n+        node = task.node;\n       null !== node &&\n         \"object\" === typeof node &&\n         pushHaltedAwaitOnComponentStack(task, node._debugInfo);\n       if (null === boundary) {\n         if (13 !== request.status && request.status !== CLOSED) {\n           boundary = task.replay;\n           if (null === boundary) {\n-            logRecoverableError(request, error, segment, task.debugTask);\n-            fatalError(request, error, segment, task.debugTask);\n+            null !== request.trackedPostpones && null !== segment\n+              ? ((boundary = request.trackedPostpones),\n+                logRecoverableError(request, error, errorInfo, task.debugTask),\n+                trackPostpone(request, boundary, task, segment),\n+                finishedTask(request, null, task.row, segment))\n+              : (logRecoverableError(request, error, errorInfo, task.debugTask),\n+                fatalError(request, error, errorInfo, task.debugTask));\n             return;\n           }\n           boundary.pendingTasks--;\n           0 === boundary.pendingTasks &&\n             0 < boundary.nodes.length &&\n-            ((node = logRecoverableError(request, error, segment, null)),\n+            ((segment = logRecoverableError(request, error, errorInfo, null)),\n             abortRemainingReplayNodes(\n               request,\n               null,\n               boundary.nodes,\n               boundary.slots,\n               error,\n-              node,\n               segment,\n+              errorInfo,\n               !0\n             ));\n           request.pendingRootTasks--;\n           0 === request.pendingRootTasks && completeShell(request);\n         }\n-      } else\n-        boundary.status !== CLIENT_RENDERED &&\n-          ((boundary.status = CLIENT_RENDERED),\n-          (node = logRecoverableError(request, error, segment, task.debugTask)),\n-          (boundary.status = CLIENT_RENDERED),\n-          encodeErrorForBoundary(boundary, node, error, segment, !0),\n-          untrackBoundary(request, boundary),\n+      } else {\n+        node = request.trackedPostpones;\n+        if (boundary.status !== CLIENT_RENDERED) {\n+          if (null !== node && null !== segment)\n+            return (\n+              logRecoverableError(request, error, errorInfo, task.debugTask),\n+              trackPostpone(request, node, task, segment),\n+              boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+                return abortTask(fallbackTask, request, error);\n+              }),\n+              boundary.fallbackAbortableTasks.clear(),\n+              finishedTask(request, boundary, task.row, segment)\n+            );\n+          boundary.status = CLIENT_RENDERED;\n+          segment = logRecoverableError(\n+            request,\n+            error,\n+            errorInfo,\n+            task.debugTask\n+          );\n+          boundary.status = CLIENT_RENDERED;\n+          encodeErrorForBoundary(boundary, segment, error, errorInfo, !0);\n+          untrackBoundary(request, boundary);\n           boundary.parentFlushed &&\n-            request.clientRenderedBoundaries.push(boundary)),\n-          boundary.pendingTasks--,\n-          (segment = boundary.row),\n-          null !== segment &&\n-            0 === --segment.pendingTasks &&\n-            finishSuspenseListRow(request, segment),\n-          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n-            return abortTask(fallbackTask, request, error);\n-          }),\n-          boundary.fallbackAbortableTasks.clear();\n+            request.clientRenderedBoundaries.push(boundary);\n+        }\n+        boundary.pendingTasks--;\n+        errorInfo = boundary.row;\n+        null !== errorInfo &&\n+          0 === --errorInfo.pendingTasks &&\n+          finishSuspenseListRow(request, errorInfo);\n+        boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+          return abortTask(fallbackTask, request, error);\n+        });\n+        boundary.fallbackAbortableTasks.clear();\n+      }\n       task = task.row;\n       null !== task &&\n         0 === --task.pendingTasks &&\n@@ -7238,64 +7478,58 @@\n           : (boundary.byteSize += segmentByteSize);\n       }\n     }\n-    function finishedTask(request$jscomp$0, boundary$jscomp$0, row, segment) {\n+    function finishedTask(request, boundary, row, segment) {\n       null !== row &&\n         (0 === --row.pendingTasks\n-          ? finishSuspenseListRow(request$jscomp$0, row)\n-          : row.together && tryToResolveTogetherRow(request$jscomp$0, row));\n-      request$jscomp$0.allPendingTasks--;\n-      if (null === boundary$jscomp$0) {\n+          ? finishSuspenseListRow(request, row)\n+          : row.together && tryToResolveTogetherRow(request, row));\n+      request.allPendingTasks--;\n+      if (null === boundary) {\n         if (null !== segment && segment.parentFlushed) {\n-          if (null !== request$jscomp$0.completedRootSegment)\n+          if (null !== request.completedRootSegment)\n             throw Error(\n               \"There can only be one root segment. This is a bug in React.\"\n             );\n-          request$jscomp$0.completedRootSegment = segment;\n+          request.completedRootSegment = segment;\n         }\n-        request$jscomp$0.pendingRootTasks--;\n-        0 === request$jscomp$0.pendingRootTasks &&\n-          completeShell(request$jscomp$0);\n-      } else if (\n-        (boundary$jscomp$0.pendingTasks--,\n-        boundary$jscomp$0.status !== CLIENT_RENDERED)\n-      )\n-        if (0 === boundary$jscomp$0.pendingTasks)\n+        request.pendingRootTasks--;\n+        0 === request.pendingRootTasks && completeShell(request);\n+      } else if ((boundary.pendingTasks--, boundary.status !== CLIENT_RENDERED))\n+        if (0 === boundary.pendingTasks)\n           if (\n-            (boundary$jscomp$0.status === PENDING &&\n-              (boundary$jscomp$0.status = COMPLETED),\n+            (boundary.status === PENDING && (boundary.status = COMPLETED),\n             null !== segment &&\n               segment.parentFlushed &&\n               (segment.status === COMPLETED || segment.status === ABORTED) &&\n-              queueCompletedSegment(boundary$jscomp$0, segment),\n-            boundary$jscomp$0.parentFlushed &&\n-              request$jscomp$0.completedBoundaries.push(boundary$jscomp$0),\n-            boundary$jscomp$0.status === COMPLETED)\n+              queueCompletedSegment(boundary, segment),\n+            boundary.parentFlushed &&\n+              request.completedBoundaries.push(boundary),\n+            boundary.status === COMPLETED)\n           )\n-            (row = boundary$jscomp$0.row),\n+            (row = boundary.row),\n               null !== row &&\n-                hoistHoistables(row.hoistables, boundary$jscomp$0.contentState),\n-              isEligibleForOutlining(request$jscomp$0, boundary$jscomp$0) ||\n-                (boundary$jscomp$0.fallbackAbortableTasks.forEach(\n+                hoistHoistables(row.hoistables, boundary.contentState),\n+              isEligibleForOutlining(request, boundary) ||\n+                (boundary.fallbackAbortableTasks.forEach(\n                   abortTaskSoft,\n-                  request$jscomp$0\n+                  request\n                 ),\n-                boundary$jscomp$0.fallbackAbortableTasks.clear(),\n+                boundary.fallbackAbortableTasks.clear(),\n                 null !== row &&\n                   0 === --row.pendingTasks &&\n-                  finishSuspenseListRow(request$jscomp$0, row)),\n-              0 === request$jscomp$0.pendingRootTasks &&\n-                null === request$jscomp$0.trackedPostpones &&\n-                null !== boundary$jscomp$0.contentPreamble &&\n-                preparePreamble(request$jscomp$0);\n+                  finishSuspenseListRow(request, row)),\n+              0 === request.pendingRootTasks &&\n+                null === request.trackedPostpones &&\n+                null !== boundary.contentPreamble &&\n+                preparePreamble(request);\n           else {\n             if (\n-              boundary$jscomp$0.status === POSTPONED &&\n-              ((boundary$jscomp$0 = boundary$jscomp$0.row),\n-              null !== boundary$jscomp$0)\n+              boundary.status === POSTPONED &&\n+              ((boundary = boundary.row), null !== boundary)\n             ) {\n-              if (null !== request$jscomp$0.trackedPostpones) {\n-                row = request$jscomp$0.trackedPostpones;\n-                var postponedRow = boundary$jscomp$0.next;\n+              if (null !== request.trackedPostpones) {\n+                row = request.trackedPostpones;\n+                var postponedRow = boundary.next;\n                 if (\n                   null !== postponedRow &&\n                   ((segment = postponedRow.boundaries), null !== segment)\n@@ -7306,61 +7540,27 @@\n                     postponedRow++\n                   ) {\n                     var postponedBoundary = segment[postponedRow];\n-                    var request = request$jscomp$0,\n-                      trackedPostpones = row,\n-                      boundary = postponedBoundary;\n-                    boundary.status = POSTPONED;\n-                    boundary.rootSegmentID = request.nextSegmentId++;\n-                    request = boundary.trackedContentKeyPath;\n-                    if (null === request)\n-                      throw Error(\n-                        \"It should not be possible to postpone at the root. This is a bug in React.\"\n-                      );\n-                    var fallbackReplayNode = boundary.trackedFallbackNode,\n-                      children = [],\n-                      boundaryNode = trackedPostpones.workingMap.get(request);\n-                    void 0 === boundaryNode\n-                      ? ((boundary = [\n-                          request[1],\n-                          request[2],\n-                          children,\n-                          null,\n-                          fallbackReplayNode,\n-                          boundary.rootSegmentID\n-                        ]),\n-                        trackedPostpones.workingMap.set(request, boundary),\n-                        addToReplayParent(\n-                          boundary,\n-                          request[0],\n-                          trackedPostpones\n-                        ))\n-                      : ((boundaryNode[4] = fallbackReplayNode),\n-                        (boundaryNode[5] = boundary.rootSegmentID));\n-                    finishedTask(\n-                      request$jscomp$0,\n-                      postponedBoundary,\n-                      null,\n-                      null\n-                    );\n+                    trackPostponedBoundary(request, row, postponedBoundary);\n+                    finishedTask(request, postponedBoundary, null, null);\n                   }\n               }\n-              0 === --boundary$jscomp$0.pendingTasks &&\n-                finishSuspenseListRow(request$jscomp$0, boundary$jscomp$0);\n+              0 === --boundary.pendingTasks &&\n+                finishSuspenseListRow(request, boundary);\n             }\n           }\n         else\n           null === segment ||\n             !segment.parentFlushed ||\n             (segment.status !== COMPLETED && segment.status !== ABORTED) ||\n-            (queueCompletedSegment(boundary$jscomp$0, segment),\n-            1 === boundary$jscomp$0.completedSegments.length &&\n-              boundary$jscomp$0.parentFlushed &&\n-              request$jscomp$0.partialBoundaries.push(boundary$jscomp$0)),\n-            (boundary$jscomp$0 = boundary$jscomp$0.row),\n-            null !== boundary$jscomp$0 &&\n-              boundary$jscomp$0.together &&\n-              tryToResolveTogetherRow(request$jscomp$0, boundary$jscomp$0);\n-      0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n+            (queueCompletedSegment(boundary, segment),\n+            1 === boundary.completedSegments.length &&\n+              boundary.parentFlushed &&\n+              request.partialBoundaries.push(boundary)),\n+            (boundary = boundary.row),\n+            null !== boundary &&\n+              boundary.together &&\n+              tryToResolveTogetherRow(request, boundary);\n+      0 === request.allPendingTasks && completeAll(request);\n     }\n     function performWork(request$jscomp$2) {\n       if (\n@@ -7517,6 +7717,31 @@\n                       ? request.fatalError\n                       : thrownValue;\n                 if (\n+                  12 === request.status &&\n+                  null !== request.trackedPostpones\n+                ) {\n+                  var trackedPostpones = request.trackedPostpones,\n+                    thrownInfo = getThrownInfo(errorDigest.componentStack);\n+                  errorDigest.abortSet.delete(errorDigest);\n+                  logRecoverableError(\n+                    request,\n+                    x$jscomp$0,\n+                    thrownInfo,\n+                    errorDigest.debugTask\n+                  );\n+                  trackPostpone(\n+                    request,\n+                    trackedPostpones,\n+                    errorDigest,\n+                    request$jscomp$1\n+                  );\n+                  finishedTask(\n+                    request,\n+                    errorDigest.blockedBoundary,\n+                    errorDigest.row,\n+                    request$jscomp$1\n+                  );\n+                } else if (\n                   \"object\" === typeof x$jscomp$0 &&\n                   null !== x$jscomp$0 &&\n                   \"function\" === typeof x$jscomp$0.then\n@@ -8408,13 +8633,59 @@\n         parentNode[2].push(node);\n       }\n     }\n+    function getPostponedState(request) {\n+      var trackedPostpones = request.trackedPostpones;\n+      if (\n+        null === trackedPostpones ||\n+        (0 === trackedPostpones.rootNodes.length &&\n+          null === trackedPostpones.rootSlots)\n+      )\n+        return (request.trackedPostpones = null);\n+      if (\n+        null === request.completedRootSegment ||\n+        (request.completedRootSegment.status !== POSTPONED &&\n+          null !== request.completedPreambleSegments)\n+      ) {\n+        var nextSegmentId = request.nextSegmentId;\n+        var replaySlots = trackedPostpones.rootSlots;\n+        var resumableState = request.resumableState;\n+        resumableState.bootstrapScriptContent = void 0;\n+        resumableState.bootstrapScripts = void 0;\n+        resumableState.bootstrapModules = void 0;\n+      } else {\n+        nextSegmentId = 0;\n+        replaySlots = -1;\n+        resumableState = request.resumableState;\n+        var renderState = request.renderState;\n+        resumableState.nextFormID = 0;\n+        resumableState.hasBody = !1;\n+        resumableState.hasHtml = !1;\n+        resumableState.unknownResources = { font: renderState.resets.font };\n+        resumableState.dnsResources = renderState.resets.dns;\n+        resumableState.connectResources = renderState.resets.connect;\n+        resumableState.imageResources = renderState.resets.image;\n+        resumableState.styleResources = renderState.resets.style;\n+        resumableState.scriptResources = {};\n+        resumableState.moduleUnknownResources = {};\n+        resumableState.moduleScriptResources = {};\n+        resumableState.instructions = NothingSent;\n+      }\n+      return {\n+        nextSegmentId: nextSegmentId,\n+        rootFormatContext: request.rootFormatContext,\n+        progressiveChunkSize: request.progressiveChunkSize,\n+        resumableState: request.resumableState,\n+        replayNodes: trackedPostpones.rootNodes,\n+        replaySlots: replaySlots\n+      };\n+    }\n     function ensureCorrectIsomorphicReactVersion() {\n       var isomorphicReactPackageVersion = React.version;\n-      if (\"19.2.0-canary-548235db-20251001\" !== isomorphicReactPackageVersion)\n+      if (\"19.2.0-canary-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n         throw Error(\n           'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n             (isomorphicReactPackageVersion +\n-              \"\\n  - react-dom:  19.2.0-canary-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+              \"\\n  - react-dom:  19.2.0-canary-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n         );\n     }\n     function createDrainHandler(destination, request) {\n@@ -8475,6 +8746,26 @@\n         }\n       };\n     }\n+    function resumeRequestImpl(children, postponedState, options) {\n+      return resumeRequest(\n+        children,\n+        postponedState,\n+        createRenderState(\n+          postponedState.resumableState,\n+          options ? options.nonce : void 0,\n+          void 0,\n+          void 0,\n+          void 0,\n+          void 0\n+        ),\n+        options ? options.onError : void 0,\n+        options ? options.onAllReady : void 0,\n+        options ? options.onShellReady : void 0,\n+        options ? options.onShellError : void 0,\n+        void 0,\n+        options ? options.onPostpone : void 0\n+      );\n+    }\n     function createFakeWritableFromReadableStreamController(controller) {\n       return {\n         write: function (chunk) {\n@@ -10079,28 +10370,30 @@\n             options ? options.onError : void 0,\n             function () {\n               var writable,\n-                result = {\n-                  prelude: new ReadableStream(\n-                    {\n-                      type: \"bytes\",\n-                      start: function (controller) {\n-                        writable =\n-                          createFakeWritableFromReadableStreamController(\n-                            controller\n-                          );\n-                      },\n-                      pull: function () {\n-                        startFlowing(request, writable);\n-                      },\n-                      cancel: function (reason) {\n-                        request.destination = null;\n-                        abort(request, reason);\n-                      }\n+                stream = new ReadableStream(\n+                  {\n+                    type: \"bytes\",\n+                    start: function (controller) {\n+                      writable =\n+                        createFakeWritableFromReadableStreamController(\n+                          controller\n+                        );\n                     },\n-                    { highWaterMark: 0 }\n-                  )\n-                };\n-              resolve(result);\n+                    pull: function () {\n+                      startFlowing(request, writable);\n+                    },\n+                    cancel: function (reason) {\n+                      request.destination = null;\n+                      abort(request, reason);\n+                    }\n+                  },\n+                  { highWaterMark: 0 }\n+                );\n+              stream = {\n+                postponed: getPostponedState(request),\n+                prelude: stream\n+              };\n+              resolve(stream);\n             },\n             void 0,\n             void 0,\n@@ -10151,7 +10444,11 @@\n                   }\n                 }),\n                 writable = createFakeWritableFromReadable(readable);\n-              resolve({ prelude: readable });\n+              readable = {\n+                postponed: getPostponedState(request),\n+                prelude: readable\n+              };\n+              resolve(readable);\n             },\n             void 0,\n             void 0,\n@@ -10293,5 +10590,213 @@\n         startWork(request);\n       });\n     };\n-    exports.version = \"19.2.0-canary-548235db-20251001\";\n+    exports.resume = function (children, postponedState, options) {\n+      return new Promise(function (resolve, reject) {\n+        var onFatalError,\n+          onAllReady,\n+          allReady = new Promise(function (res, rej) {\n+            onAllReady = res;\n+            onFatalError = rej;\n+          }),\n+          request = resumeRequest(\n+            children,\n+            postponedState,\n+            createRenderState(\n+              postponedState.resumableState,\n+              options ? options.nonce : void 0,\n+              void 0,\n+              void 0,\n+              void 0,\n+              void 0\n+            ),\n+            options ? options.onError : void 0,\n+            onAllReady,\n+            function () {\n+              var writable,\n+                stream = new ReadableStream(\n+                  {\n+                    type: \"bytes\",\n+                    start: function (controller) {\n+                      writable =\n+                        createFakeWritableFromReadableStreamController$1(\n+                          controller\n+                        );\n+                    },\n+                    pull: function () {\n+                      startFlowing(request, writable);\n+                    },\n+                    cancel: function (reason) {\n+                      request.destination = null;\n+                      abort(request, reason);\n+                    }\n+                  },\n+                  { highWaterMark: 0 }\n+                );\n+              stream.allReady = allReady;\n+              resolve(stream);\n+            },\n+            function (error) {\n+              allReady.catch(function () {});\n+              reject(error);\n+            },\n+            onFatalError,\n+            options ? options.onPostpone : void 0\n+          );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.resumeAndPrerender = function (children, postponedState, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = resumeAndPrerenderRequest(\n+          children,\n+          postponedState,\n+          createRenderState(\n+            postponedState.resumableState,\n+            void 0,\n+            void 0,\n+            void 0,\n+            void 0,\n+            void 0\n+          ),\n+          options ? options.onError : void 0,\n+          function () {\n+            var writable,\n+              stream = new ReadableStream(\n+                {\n+                  type: \"bytes\",\n+                  start: function (controller) {\n+                    writable =\n+                      createFakeWritableFromReadableStreamController(\n+                        controller\n+                      );\n+                  },\n+                  pull: function () {\n+                    startFlowing(request, writable);\n+                  },\n+                  cancel: function (reason) {\n+                    request.destination = null;\n+                    abort(request, reason);\n+                  }\n+                },\n+                { highWaterMark: 0 }\n+              );\n+            stream = { postponed: getPostponedState(request), prelude: stream };\n+            resolve(stream);\n+          },\n+          void 0,\n+          void 0,\n+          reject,\n+          options ? options.onPostpone : void 0\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.resumeAndPrerenderToNodeStream = function (\n+      children,\n+      postponedState,\n+      options\n+    ) {\n+      return new Promise(function (resolve, reject) {\n+        var request = resumeAndPrerenderRequest(\n+          children,\n+          postponedState,\n+          createRenderState(\n+            postponedState.resumableState,\n+            void 0,\n+            void 0,\n+            void 0,\n+            void 0,\n+            void 0\n+          ),\n+          options ? options.onError : void 0,\n+          function () {\n+            var readable = new stream.Readable({\n+                read: function () {\n+                  startFlowing(request, writable);\n+                }\n+              }),\n+              writable = createFakeWritableFromReadable(readable);\n+            readable = {\n+              postponed: getPostponedState(request),\n+              prelude: readable\n+            };\n+            resolve(readable);\n+          },\n+          void 0,\n+          void 0,\n+          reject,\n+          options ? options.onPostpone : void 0\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.resumeToPipeableStream = function (\n+      children,\n+      postponedState,\n+      options\n+    ) {\n+      var request = resumeRequestImpl(children, postponedState, options),\n+        hasStartedFlowing = !1;\n+      startWork(request);\n+      return {\n+        pipe: function (destination) {\n+          if (hasStartedFlowing)\n+            throw Error(\n+              \"React currently only supports piping to one writable stream.\"\n+            );\n+          hasStartedFlowing = !0;\n+          startFlowing(request, destination);\n+          destination.on(\"drain\", createDrainHandler(destination, request));\n+          destination.on(\n+            \"error\",\n+            createCancelHandler(\n+              request,\n+              \"The destination stream errored while writing data.\"\n+            )\n+          );\n+          destination.on(\n+            \"close\",\n+            createCancelHandler(request, \"The destination stream closed early.\")\n+          );\n+          return destination;\n+        },\n+        abort: function (reason) {\n+          abort(request, reason);\n+        }\n+      };\n+    };\n+    exports.version = \"19.2.0-canary-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "c9a1ccb685872bbc91caaa7bbc50b97881412f9e",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom-server.node.production.js",
            "status": "modified",
            "additions": 606,
            "deletions": 137,
            "changes": 743,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom-server.node.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -4137,6 +4137,116 @@ function createPrerenderRequest(\n   };\n   return children;\n }\n+function resumeRequest(\n+  children,\n+  postponedState,\n+  renderState,\n+  onError,\n+  onAllReady,\n+  onShellReady,\n+  onShellError,\n+  onFatalError,\n+  onPostpone\n+) {\n+  renderState = new RequestInstance(\n+    postponedState.resumableState,\n+    renderState,\n+    postponedState.rootFormatContext,\n+    postponedState.progressiveChunkSize,\n+    onError,\n+    onAllReady,\n+    onShellReady,\n+    onShellError,\n+    onFatalError,\n+    onPostpone,\n+    null\n+  );\n+  renderState.nextSegmentId = postponedState.nextSegmentId;\n+  if (\"number\" === typeof postponedState.replaySlots)\n+    return (\n+      (onError = createPendingSegment(\n+        renderState,\n+        0,\n+        null,\n+        postponedState.rootFormatContext,\n+        !1,\n+        !1\n+      )),\n+      (onError.parentFlushed = !0),\n+      (children = createRenderTask(\n+        renderState,\n+        null,\n+        children,\n+        -1,\n+        null,\n+        onError,\n+        null,\n+        null,\n+        renderState.abortableTasks,\n+        null,\n+        postponedState.rootFormatContext,\n+        null,\n+        emptyTreeContext,\n+        null,\n+        null\n+      )),\n+      pushComponentStack(children),\n+      renderState.pingedTasks.push(children),\n+      renderState\n+    );\n+  children = createReplayTask(\n+    renderState,\n+    null,\n+    {\n+      nodes: postponedState.replayNodes,\n+      slots: postponedState.replaySlots,\n+      pendingTasks: 0\n+    },\n+    children,\n+    -1,\n+    null,\n+    null,\n+    renderState.abortableTasks,\n+    null,\n+    postponedState.rootFormatContext,\n+    null,\n+    emptyTreeContext,\n+    null,\n+    null\n+  );\n+  pushComponentStack(children);\n+  renderState.pingedTasks.push(children);\n+  return renderState;\n+}\n+function resumeAndPrerenderRequest(\n+  children,\n+  postponedState,\n+  renderState,\n+  onError,\n+  onAllReady,\n+  onShellReady,\n+  onShellError,\n+  onFatalError,\n+  onPostpone\n+) {\n+  children = resumeRequest(\n+    children,\n+    postponedState,\n+    renderState,\n+    onError,\n+    onAllReady,\n+    onShellReady,\n+    onShellError,\n+    onFatalError,\n+    onPostpone\n+  );\n+  children.trackedPostpones = {\n+    workingMap: new Map(),\n+    rootNodes: [],\n+    rootSlots: null\n+  };\n+  return children;\n+}\n var currentRequest = null;\n function resolveRequest() {\n   if (currentRequest) return currentRequest;\n@@ -4590,9 +4700,9 @@ function renderElement(request, task, keyPath, type, props, ref) {\n       var defaultProps = type.defaultProps;\n       if (defaultProps) {\n         newProps === props && (newProps = assign({}, newProps, props));\n-        for (var propName$43 in defaultProps)\n-          void 0 === newProps[propName$43] &&\n-            (newProps[propName$43] = defaultProps[propName$43]);\n+        for (var propName$44 in defaultProps)\n+          void 0 === newProps[propName$44] &&\n+            (newProps[propName$44] = defaultProps[propName$44]);\n       }\n       props = newProps;\n       newProps = emptyContextObject;\n@@ -4652,16 +4762,16 @@ function renderElement(request, task, keyPath, type, props, ref) {\n             defaultProps = ref ? type[0] : newProps.state;\n             initialState = !0;\n             for (ref = ref ? 1 : 0; ref < type.length; ref++)\n-              (propName$43 = type[ref]),\n-                (propName$43 =\n-                  \"function\" === typeof propName$43\n-                    ? propName$43.call(newProps, defaultProps, props, void 0)\n-                    : propName$43),\n-                null != propName$43 &&\n+              (propName$44 = type[ref]),\n+                (propName$44 =\n+                  \"function\" === typeof propName$44\n+                    ? propName$44.call(newProps, defaultProps, props, void 0)\n+                    : propName$44),\n+                null != propName$44 &&\n                   (initialState\n                     ? ((initialState = !1),\n-                      (defaultProps = assign({}, defaultProps, propName$43)))\n-                    : assign(defaultProps, propName$43));\n+                      (defaultProps = assign({}, defaultProps, propName$44)))\n+                    : assign(defaultProps, propName$44));\n             newProps.state = defaultProps;\n           }\n         else defaultProps.queue = null;\n@@ -4881,7 +4991,7 @@ function renderElement(request, task, keyPath, type, props, ref) {\n           type = task.keyPath;\n           ref = task.formatContext;\n           var prevRow = task.row;\n-          propName$43 = task.blockedBoundary;\n+          propName$44 = task.blockedBoundary;\n           propName = task.blockedPreamble;\n           var parentHoistableState = task.hoistableState,\n             parentSegment = task.blockedSegment,\n@@ -4947,7 +5057,7 @@ function renderElement(request, task, keyPath, type, props, ref) {\n                   boundarySegment.textEmbedded &&\n                   boundarySegment.chunks.push(textSeparator),\n                 (boundarySegment.status = 1),\n-                finishedSegment(request, propName$43, boundarySegment);\n+                finishedSegment(request, propName$44, boundarySegment);\n             } catch (thrownValue) {\n               throw (\n                 ((boundarySegment.status = 12 === request.status ? 3 : 4),\n@@ -5020,13 +5130,13 @@ function renderElement(request, task, keyPath, type, props, ref) {\n                 null !== prevRow &&\n                   prevRow.together &&\n                   tryToResolveTogetherRow(request, prevRow);\n-            } catch (thrownValue$30) {\n+            } catch (thrownValue$31) {\n               (newBoundary.status = 4),\n                 12 === request.status\n                   ? ((contentRootSegment.status = 3),\n                     (newProps = request.fatalError))\n                   : ((contentRootSegment.status = 4),\n-                    (newProps = thrownValue$30)),\n+                    (newProps = thrownValue$31)),\n                 (defaultProps = getThrownInfo(task.componentStack)),\n                 (initialState = logRecoverableError(\n                   request,\n@@ -5036,7 +5146,7 @@ function renderElement(request, task, keyPath, type, props, ref) {\n                 (newBoundary.errorDigest = initialState),\n                 untrackBoundary(request, newBoundary);\n             } finally {\n-              (task.blockedBoundary = propName$43),\n+              (task.blockedBoundary = propName$44),\n                 (task.blockedPreamble = propName),\n                 (task.hoistableState = parentHoistableState),\n                 (task.blockedSegment = parentSegment),\n@@ -5049,7 +5159,7 @@ function renderElement(request, task, keyPath, type, props, ref) {\n               null,\n               fallback,\n               -1,\n-              propName$43,\n+              propName$44,\n               boundarySegment,\n               newBoundary.fallbackPreamble,\n               newBoundary.fallbackState,\n@@ -5537,6 +5647,105 @@ function renderChildrenArray(request, task, children, childIndex) {\n   task.treeContext = replay;\n   task.keyPath = prevKeyPath;\n }\n+function trackPostponedBoundary(request, trackedPostpones, boundary) {\n+  boundary.status = 5;\n+  boundary.rootSegmentID = request.nextSegmentId++;\n+  request = boundary.trackedContentKeyPath;\n+  if (null === request)\n+    throw Error(\n+      \"It should not be possible to postpone at the root. This is a bug in React.\"\n+    );\n+  var fallbackReplayNode = boundary.trackedFallbackNode,\n+    children = [],\n+    boundaryNode = trackedPostpones.workingMap.get(request);\n+  if (void 0 === boundaryNode)\n+    return (\n+      (boundary = [\n+        request[1],\n+        request[2],\n+        children,\n+        null,\n+        fallbackReplayNode,\n+        boundary.rootSegmentID\n+      ]),\n+      trackedPostpones.workingMap.set(request, boundary),\n+      addToReplayParent(boundary, request[0], trackedPostpones),\n+      boundary\n+    );\n+  boundaryNode[4] = fallbackReplayNode;\n+  boundaryNode[5] = boundary.rootSegmentID;\n+  return boundaryNode;\n+}\n+function trackPostpone(request, trackedPostpones, task, segment) {\n+  segment.status = 5;\n+  var keyPath = task.keyPath,\n+    boundary = task.blockedBoundary;\n+  if (null === boundary)\n+    (segment.id = request.nextSegmentId++),\n+      (trackedPostpones.rootSlots = segment.id),\n+      null !== request.completedRootSegment &&\n+        (request.completedRootSegment.status = 5);\n+  else {\n+    if (null !== boundary && 0 === boundary.status) {\n+      var boundaryNode = trackPostponedBoundary(\n+        request,\n+        trackedPostpones,\n+        boundary\n+      );\n+      if (\n+        boundary.trackedContentKeyPath === keyPath &&\n+        -1 === task.childIndex\n+      ) {\n+        -1 === segment.id &&\n+          (segment.id = segment.parentFlushed\n+            ? boundary.rootSegmentID\n+            : request.nextSegmentId++);\n+        boundaryNode[3] = segment.id;\n+        return;\n+      }\n+    }\n+    -1 === segment.id &&\n+      (segment.id =\n+        segment.parentFlushed && null !== boundary\n+          ? boundary.rootSegmentID\n+          : request.nextSegmentId++);\n+    if (-1 === task.childIndex)\n+      null === keyPath\n+        ? (trackedPostpones.rootSlots = segment.id)\n+        : ((task = trackedPostpones.workingMap.get(keyPath)),\n+          void 0 === task\n+            ? ((task = [keyPath[1], keyPath[2], [], segment.id]),\n+              addToReplayParent(task, keyPath[0], trackedPostpones))\n+            : (task[3] = segment.id));\n+    else {\n+      if (null === keyPath)\n+        if (((request = trackedPostpones.rootSlots), null === request))\n+          request = trackedPostpones.rootSlots = {};\n+        else {\n+          if (\"number\" === typeof request)\n+            throw Error(\n+              \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+            );\n+        }\n+      else if (\n+        ((boundary = trackedPostpones.workingMap),\n+        (boundaryNode = boundary.get(keyPath)),\n+        void 0 === boundaryNode)\n+      )\n+        (request = {}),\n+          (boundaryNode = [keyPath[1], keyPath[2], [], request]),\n+          boundary.set(keyPath, boundaryNode),\n+          addToReplayParent(boundaryNode, keyPath[0], trackedPostpones);\n+      else if (((request = boundaryNode[3]), null === request))\n+        request = boundaryNode[3] = {};\n+      else if (\"number\" === typeof request)\n+        throw Error(\n+          \"It should not be possible to postpone both at the root of an element as well as a slot below. This is a bug in React.\"\n+        );\n+      request[task.childIndex] = segment.id;\n+    }\n+  }\n+}\n function untrackBoundary(request, boundary) {\n   request = request.trackedPostpones;\n   null !== request &&\n@@ -5653,21 +5862,21 @@ function renderNode(request, task, node, childIndex) {\n       chunkLength = segment.chunks.length;\n     try {\n       return renderNodeDestructive(request, task, node, childIndex);\n-    } catch (thrownValue$60) {\n+    } catch (thrownValue$63) {\n       if (\n         (resetHooksState(),\n         (segment.children.length = childrenLength),\n         (segment.chunks.length = chunkLength),\n         (node =\n-          thrownValue$60 === SuspenseException\n+          thrownValue$63 === SuspenseException\n             ? getSuspendedThenable()\n-            : thrownValue$60),\n+            : thrownValue$63),\n         12 !== request.status && \"object\" === typeof node && null !== node)\n       ) {\n         if (\"function\" === typeof node.then) {\n           segment = node;\n           node =\n-            thrownValue$60 === SuspenseException\n+            thrownValue$63 === SuspenseException\n               ? getThenableStateAfterSuspending()\n               : null;\n           request = spawnNewSuspendedRenderTask(request, task, node).ping;\n@@ -5682,7 +5891,7 @@ function renderNode(request, task, node, childIndex) {\n         }\n         if (\"Maximum call stack size exceeded\" === node.message) {\n           segment =\n-            thrownValue$60 === SuspenseException\n+            thrownValue$63 === SuspenseException\n               ? getThenableStateAfterSuspending()\n               : null;\n           segment = spawnNewSuspendedRenderTask(request, task, segment);\n@@ -5770,19 +5979,24 @@ function abortTask(task, request, error) {\n     if (6 === segment.status) return;\n     segment.status = 3;\n   }\n-  segment = getThrownInfo(task.componentStack);\n+  var errorInfo = getThrownInfo(task.componentStack);\n   if (null === boundary) {\n     if (13 !== request.status && 14 !== request.status) {\n       boundary = task.replay;\n       if (null === boundary) {\n-        logRecoverableError(request, error, segment);\n-        fatalError(request, error);\n+        null !== request.trackedPostpones && null !== segment\n+          ? ((boundary = request.trackedPostpones),\n+            logRecoverableError(request, error, errorInfo),\n+            trackPostpone(request, boundary, task, segment),\n+            finishedTask(request, null, task.row, segment))\n+          : (logRecoverableError(request, error, errorInfo),\n+            fatalError(request, error));\n         return;\n       }\n       boundary.pendingTasks--;\n       0 === boundary.pendingTasks &&\n         0 < boundary.nodes.length &&\n-        ((segment = logRecoverableError(request, error, segment)),\n+        ((segment = logRecoverableError(request, error, errorInfo)),\n         abortRemainingReplayNodes(\n           request,\n           null,\n@@ -5794,24 +6008,36 @@ function abortTask(task, request, error) {\n       request.pendingRootTasks--;\n       0 === request.pendingRootTasks && completeShell(request);\n     }\n-  } else\n-    4 !== boundary.status &&\n-      ((boundary.status = 4),\n-      (segment = logRecoverableError(request, error, segment)),\n-      (boundary.status = 4),\n-      (boundary.errorDigest = segment),\n-      untrackBoundary(request, boundary),\n-      boundary.parentFlushed &&\n-        request.clientRenderedBoundaries.push(boundary)),\n-      boundary.pendingTasks--,\n-      (segment = boundary.row),\n-      null !== segment &&\n-        0 === --segment.pendingTasks &&\n-        finishSuspenseListRow(request, segment),\n-      boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n-        return abortTask(fallbackTask, request, error);\n-      }),\n-      boundary.fallbackAbortableTasks.clear();\n+  } else {\n+    var trackedPostpones$64 = request.trackedPostpones;\n+    if (4 !== boundary.status) {\n+      if (null !== trackedPostpones$64 && null !== segment)\n+        return (\n+          logRecoverableError(request, error, errorInfo),\n+          trackPostpone(request, trackedPostpones$64, task, segment),\n+          boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+            return abortTask(fallbackTask, request, error);\n+          }),\n+          boundary.fallbackAbortableTasks.clear(),\n+          finishedTask(request, boundary, task.row, segment)\n+        );\n+      boundary.status = 4;\n+      segment = logRecoverableError(request, error, errorInfo);\n+      boundary.status = 4;\n+      boundary.errorDigest = segment;\n+      untrackBoundary(request, boundary);\n+      boundary.parentFlushed && request.clientRenderedBoundaries.push(boundary);\n+    }\n+    boundary.pendingTasks--;\n+    segment = boundary.row;\n+    null !== segment &&\n+      0 === --segment.pendingTasks &&\n+      finishSuspenseListRow(request, segment);\n+    boundary.fallbackAbortableTasks.forEach(function (fallbackTask) {\n+      return abortTask(fallbackTask, request, error);\n+    });\n+    boundary.fallbackAbortableTasks.clear();\n+  }\n   task = task.row;\n   null !== task &&\n     0 === --task.pendingTasks &&\n@@ -5925,22 +6151,22 @@ function finishedSegment(request, boundary, segment) {\n       : (boundary.byteSize += segmentByteSize);\n   }\n }\n-function finishedTask(request$jscomp$0, boundary, row, segment) {\n+function finishedTask(request, boundary, row, segment) {\n   null !== row &&\n     (0 === --row.pendingTasks\n-      ? finishSuspenseListRow(request$jscomp$0, row)\n-      : row.together && tryToResolveTogetherRow(request$jscomp$0, row));\n-  request$jscomp$0.allPendingTasks--;\n+      ? finishSuspenseListRow(request, row)\n+      : row.together && tryToResolveTogetherRow(request, row));\n+  request.allPendingTasks--;\n   if (null === boundary) {\n     if (null !== segment && segment.parentFlushed) {\n-      if (null !== request$jscomp$0.completedRootSegment)\n+      if (null !== request.completedRootSegment)\n         throw Error(\n           \"There can only be one root segment. This is a bug in React.\"\n         );\n-      request$jscomp$0.completedRootSegment = segment;\n+      request.completedRootSegment = segment;\n     }\n-    request$jscomp$0.pendingRootTasks--;\n-    0 === request$jscomp$0.pendingRootTasks && completeShell(request$jscomp$0);\n+    request.pendingRootTasks--;\n+    0 === request.pendingRootTasks && completeShell(request);\n   } else if ((boundary.pendingTasks--, 4 !== boundary.status))\n     if (0 === boundary.pendingTasks)\n       if (\n@@ -5949,33 +6175,29 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n           segment.parentFlushed &&\n           (1 === segment.status || 3 === segment.status) &&\n           queueCompletedSegment(boundary, segment),\n-        boundary.parentFlushed &&\n-          request$jscomp$0.completedBoundaries.push(boundary),\n+        boundary.parentFlushed && request.completedBoundaries.push(boundary),\n         1 === boundary.status)\n       )\n         (row = boundary.row),\n           null !== row &&\n             hoistHoistables(row.hoistables, boundary.contentState),\n-          isEligibleForOutlining(request$jscomp$0, boundary) ||\n-            (boundary.fallbackAbortableTasks.forEach(\n-              abortTaskSoft,\n-              request$jscomp$0\n-            ),\n+          isEligibleForOutlining(request, boundary) ||\n+            (boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request),\n             boundary.fallbackAbortableTasks.clear(),\n             null !== row &&\n               0 === --row.pendingTasks &&\n-              finishSuspenseListRow(request$jscomp$0, row)),\n-          0 === request$jscomp$0.pendingRootTasks &&\n-            null === request$jscomp$0.trackedPostpones &&\n+              finishSuspenseListRow(request, row)),\n+          0 === request.pendingRootTasks &&\n+            null === request.trackedPostpones &&\n             null !== boundary.contentPreamble &&\n-            preparePreamble(request$jscomp$0);\n+            preparePreamble(request);\n       else {\n         if (\n           5 === boundary.status &&\n           ((boundary = boundary.row), null !== boundary)\n         ) {\n-          if (null !== request$jscomp$0.trackedPostpones) {\n-            row = request$jscomp$0.trackedPostpones;\n+          if (null !== request.trackedPostpones) {\n+            row = request.trackedPostpones;\n             var postponedRow = boundary.next;\n             if (\n               null !== postponedRow &&\n@@ -5987,43 +6209,12 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n                 postponedRow++\n               ) {\n                 var postponedBoundary = segment[postponedRow];\n-                var request = request$jscomp$0,\n-                  trackedPostpones = row;\n-                postponedBoundary.status = 5;\n-                postponedBoundary.rootSegmentID = request.nextSegmentId++;\n-                request = postponedBoundary.trackedContentKeyPath;\n-                if (null === request)\n-                  throw Error(\n-                    \"It should not be possible to postpone at the root. This is a bug in React.\"\n-                  );\n-                var fallbackReplayNode = postponedBoundary.trackedFallbackNode,\n-                  children = [],\n-                  boundaryNode = trackedPostpones.workingMap.get(request);\n-                void 0 === boundaryNode\n-                  ? ((fallbackReplayNode = [\n-                      request[1],\n-                      request[2],\n-                      children,\n-                      null,\n-                      fallbackReplayNode,\n-                      postponedBoundary.rootSegmentID\n-                    ]),\n-                    trackedPostpones.workingMap.set(\n-                      request,\n-                      fallbackReplayNode\n-                    ),\n-                    addToReplayParent(\n-                      fallbackReplayNode,\n-                      request[0],\n-                      trackedPostpones\n-                    ))\n-                  : ((boundaryNode[4] = fallbackReplayNode),\n-                    (boundaryNode[5] = postponedBoundary.rootSegmentID));\n-                finishedTask(request$jscomp$0, postponedBoundary, null, null);\n+                trackPostponedBoundary(request, row, postponedBoundary);\n+                finishedTask(request, postponedBoundary, null, null);\n               }\n           }\n           0 === --boundary.pendingTasks &&\n-            finishSuspenseListRow(request$jscomp$0, boundary);\n+            finishSuspenseListRow(request, boundary);\n         }\n       }\n     else\n@@ -6033,12 +6224,12 @@ function finishedTask(request$jscomp$0, boundary, row, segment) {\n         (queueCompletedSegment(boundary, segment),\n         1 === boundary.completedSegments.length &&\n           boundary.parentFlushed &&\n-          request$jscomp$0.partialBoundaries.push(boundary)),\n+          request.partialBoundaries.push(boundary)),\n         (boundary = boundary.row),\n         null !== boundary &&\n           boundary.together &&\n-          tryToResolveTogetherRow(request$jscomp$0, boundary);\n-  0 === request$jscomp$0.allPendingTasks && completeAll(request$jscomp$0);\n+          tryToResolveTogetherRow(request, boundary);\n+  0 === request.allPendingTasks && completeAll(request);\n }\n function performWork(request$jscomp$2) {\n   if (14 !== request$jscomp$2.status && 13 !== request$jscomp$2.status) {\n@@ -6173,7 +6364,19 @@ function performWork(request$jscomp$2) {\n                 : 12 === request.status\n                   ? request.fatalError\n                   : thrownValue;\n-            if (\n+            if (12 === request.status && null !== request.trackedPostpones) {\n+              var trackedPostpones = request.trackedPostpones,\n+                thrownInfo = getThrownInfo(task.componentStack);\n+              task.abortSet.delete(task);\n+              logRecoverableError(request, x$jscomp$0, thrownInfo);\n+              trackPostpone(request, trackedPostpones, task, request$jscomp$1);\n+              finishedTask(\n+                request,\n+                task.blockedBoundary,\n+                task.row,\n+                request$jscomp$1\n+              );\n+            } else if (\n               \"object\" === typeof x$jscomp$0 &&\n               null !== x$jscomp$0 &&\n               \"function\" === typeof x$jscomp$0.then\n@@ -6734,12 +6937,12 @@ function flushCompletedQueues(request, destination) {\n       flushingPartialBoundaries = destinationHasCapacity$1 = !0;\n       var partialBoundaries = request.partialBoundaries;\n       for (i = 0; i < partialBoundaries.length; i++) {\n-        var boundary$66 = partialBoundaries[i];\n+        var boundary$70 = partialBoundaries[i];\n         a: {\n           clientRenderedBoundaries = request;\n           boundary = destination;\n-          flushedByteSize = boundary$66.byteSize;\n-          var completedSegments = boundary$66.completedSegments;\n+          flushedByteSize = boundary$70.byteSize;\n+          var completedSegments = boundary$70.completedSegments;\n           for (\n             JSCompiler_inline_result = 0;\n             JSCompiler_inline_result < completedSegments.length;\n@@ -6749,7 +6952,7 @@ function flushCompletedQueues(request, destination) {\n               !flushPartiallyCompletedSegment(\n                 clientRenderedBoundaries,\n                 boundary,\n-                boundary$66,\n+                boundary$70,\n                 completedSegments[JSCompiler_inline_result]\n               )\n             ) {\n@@ -6759,10 +6962,10 @@ function flushCompletedQueues(request, destination) {\n               break a;\n             }\n           completedSegments.splice(0, JSCompiler_inline_result);\n-          var row = boundary$66.row;\n+          var row = boundary$70.row;\n           null !== row &&\n             row.together &&\n-            1 === boundary$66.pendingTasks &&\n+            1 === boundary$70.pendingTasks &&\n             (1 === row.pendingTasks\n               ? unblockSuspenseListRow(\n                   clientRenderedBoundaries,\n@@ -6772,7 +6975,7 @@ function flushCompletedQueues(request, destination) {\n               : row.pendingTasks--);\n           JSCompiler_inline_result$jscomp$0 = writeHoistablesForBoundary(\n             boundary,\n-            boundary$66.contentState,\n+            boundary$70.contentState,\n             clientRenderedBoundaries.renderState\n           );\n         }\n@@ -6875,8 +7078,8 @@ function abort(request, reason) {\n     }\n     null !== request.destination &&\n       flushCompletedQueues(request, request.destination);\n-  } catch (error$68) {\n-    logRecoverableError(request, error$68, {}), fatalError(request, error$68);\n+  } catch (error$72) {\n+    logRecoverableError(request, error$72, {}), fatalError(request, error$72);\n   }\n }\n function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n@@ -6891,13 +7094,59 @@ function addToReplayParent(node, parentKeyPath, trackedPostpones) {\n     parentNode[2].push(node);\n   }\n }\n+function getPostponedState(request) {\n+  var trackedPostpones = request.trackedPostpones;\n+  if (\n+    null === trackedPostpones ||\n+    (0 === trackedPostpones.rootNodes.length &&\n+      null === trackedPostpones.rootSlots)\n+  )\n+    return (request.trackedPostpones = null);\n+  if (\n+    null === request.completedRootSegment ||\n+    (5 !== request.completedRootSegment.status &&\n+      null !== request.completedPreambleSegments)\n+  ) {\n+    var nextSegmentId = request.nextSegmentId;\n+    var replaySlots = trackedPostpones.rootSlots;\n+    var resumableState = request.resumableState;\n+    resumableState.bootstrapScriptContent = void 0;\n+    resumableState.bootstrapScripts = void 0;\n+    resumableState.bootstrapModules = void 0;\n+  } else {\n+    nextSegmentId = 0;\n+    replaySlots = -1;\n+    resumableState = request.resumableState;\n+    var renderState = request.renderState;\n+    resumableState.nextFormID = 0;\n+    resumableState.hasBody = !1;\n+    resumableState.hasHtml = !1;\n+    resumableState.unknownResources = { font: renderState.resets.font };\n+    resumableState.dnsResources = renderState.resets.dns;\n+    resumableState.connectResources = renderState.resets.connect;\n+    resumableState.imageResources = renderState.resets.image;\n+    resumableState.styleResources = renderState.resets.style;\n+    resumableState.scriptResources = {};\n+    resumableState.moduleUnknownResources = {};\n+    resumableState.moduleScriptResources = {};\n+    resumableState.instructions = 0;\n+  }\n+  return {\n+    nextSegmentId: nextSegmentId,\n+    rootFormatContext: request.rootFormatContext,\n+    progressiveChunkSize: request.progressiveChunkSize,\n+    resumableState: request.resumableState,\n+    replayNodes: trackedPostpones.rootNodes,\n+    replaySlots: replaySlots\n+  };\n+}\n function ensureCorrectIsomorphicReactVersion() {\n   var isomorphicReactPackageVersion = React.version;\n-  if (\"19.2.0-canary-548235db-20251001\" !== isomorphicReactPackageVersion)\n+  if (\"19.2.0-canary-1bd1f01f-20251001\" !== isomorphicReactPackageVersion)\n     throw Error(\n       'Incompatible React versions: The \"react\" and \"react-dom\" packages must have the exact same version. Instead got:\\n  - react:      ' +\n         (isomorphicReactPackageVersion +\n-          \"\\n  - react-dom:  19.2.0-canary-548235db-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n+          \"\\n  - react-dom:  19.2.0-canary-1bd1f01f-20251001\\nLearn more: https://react.dev/warnings/version-mismatch\")\n     );\n }\n ensureCorrectIsomorphicReactVersion();\n@@ -6959,6 +7208,26 @@ function createFakeWritableFromReadableStreamController$1(controller) {\n     }\n   };\n }\n+function resumeRequestImpl(children, postponedState, options) {\n+  return resumeRequest(\n+    children,\n+    postponedState,\n+    createRenderState(\n+      postponedState.resumableState,\n+      options ? options.nonce : void 0,\n+      void 0,\n+      void 0,\n+      void 0,\n+      void 0\n+    ),\n+    options ? options.onError : void 0,\n+    options ? options.onAllReady : void 0,\n+    options ? options.onShellReady : void 0,\n+    options ? options.onShellError : void 0,\n+    void 0,\n+    options ? options.onPostpone : void 0\n+  );\n+}\n ensureCorrectIsomorphicReactVersion();\n function createFakeWritableFromReadableStreamController(controller) {\n   return {\n@@ -7021,28 +7290,25 @@ exports.prerender = function (children, options) {\n         options ? options.onError : void 0,\n         function () {\n           var writable,\n-            result = {\n-              prelude: new ReadableStream(\n-                {\n-                  type: \"bytes\",\n-                  start: function (controller) {\n-                    writable =\n-                      createFakeWritableFromReadableStreamController(\n-                        controller\n-                      );\n-                  },\n-                  pull: function () {\n-                    startFlowing(request, writable);\n-                  },\n-                  cancel: function (reason) {\n-                    request.destination = null;\n-                    abort(request, reason);\n-                  }\n+            stream = new ReadableStream(\n+              {\n+                type: \"bytes\",\n+                start: function (controller) {\n+                  writable =\n+                    createFakeWritableFromReadableStreamController(controller);\n                 },\n-                { highWaterMark: 0 }\n-              )\n-            };\n-          resolve(result);\n+                pull: function () {\n+                  startFlowing(request, writable);\n+                },\n+                cancel: function (reason) {\n+                  request.destination = null;\n+                  abort(request, reason);\n+                }\n+              },\n+              { highWaterMark: 0 }\n+            );\n+          stream = { postponed: getPostponedState(request), prelude: stream };\n+          resolve(stream);\n         },\n         void 0,\n         void 0,\n@@ -7093,7 +7359,11 @@ exports.prerenderToNodeStream = function (children, options) {\n               }\n             }),\n             writable = createFakeWritableFromReadable(readable);\n-          resolve({ prelude: readable });\n+          readable = {\n+            postponed: getPostponedState(request),\n+            prelude: readable\n+          };\n+          resolve(readable);\n         },\n         void 0,\n         void 0,\n@@ -7235,4 +7505,203 @@ exports.renderToReadableStream = function (children, options) {\n     startWork(request);\n   });\n };\n-exports.version = \"19.2.0-canary-548235db-20251001\";\n+exports.resume = function (children, postponedState, options) {\n+  return new Promise(function (resolve, reject) {\n+    var onFatalError,\n+      onAllReady,\n+      allReady = new Promise(function (res, rej) {\n+        onAllReady = res;\n+        onFatalError = rej;\n+      }),\n+      request = resumeRequest(\n+        children,\n+        postponedState,\n+        createRenderState(\n+          postponedState.resumableState,\n+          options ? options.nonce : void 0,\n+          void 0,\n+          void 0,\n+          void 0,\n+          void 0\n+        ),\n+        options ? options.onError : void 0,\n+        onAllReady,\n+        function () {\n+          var writable,\n+            stream = new ReadableStream(\n+              {\n+                type: \"bytes\",\n+                start: function (controller) {\n+                  writable =\n+                    createFakeWritableFromReadableStreamController$1(\n+                      controller\n+                    );\n+                },\n+                pull: function () {\n+                  startFlowing(request, writable);\n+                },\n+                cancel: function (reason) {\n+                  request.destination = null;\n+                  abort(request, reason);\n+                }\n+              },\n+              { highWaterMark: 0 }\n+            );\n+          stream.allReady = allReady;\n+          resolve(stream);\n+        },\n+        function (error) {\n+          allReady.catch(function () {});\n+          reject(error);\n+        },\n+        onFatalError,\n+        options ? options.onPostpone : void 0\n+      );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.resumeAndPrerender = function (children, postponedState, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = resumeAndPrerenderRequest(\n+      children,\n+      postponedState,\n+      createRenderState(\n+        postponedState.resumableState,\n+        void 0,\n+        void 0,\n+        void 0,\n+        void 0,\n+        void 0\n+      ),\n+      options ? options.onError : void 0,\n+      function () {\n+        var writable,\n+          stream = new ReadableStream(\n+            {\n+              type: \"bytes\",\n+              start: function (controller) {\n+                writable =\n+                  createFakeWritableFromReadableStreamController(controller);\n+              },\n+              pull: function () {\n+                startFlowing(request, writable);\n+              },\n+              cancel: function (reason) {\n+                request.destination = null;\n+                abort(request, reason);\n+              }\n+            },\n+            { highWaterMark: 0 }\n+          );\n+        stream = { postponed: getPostponedState(request), prelude: stream };\n+        resolve(stream);\n+      },\n+      void 0,\n+      void 0,\n+      reject,\n+      options ? options.onPostpone : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.resumeAndPrerenderToNodeStream = function (\n+  children,\n+  postponedState,\n+  options\n+) {\n+  return new Promise(function (resolve, reject) {\n+    var request = resumeAndPrerenderRequest(\n+      children,\n+      postponedState,\n+      createRenderState(\n+        postponedState.resumableState,\n+        void 0,\n+        void 0,\n+        void 0,\n+        void 0,\n+        void 0\n+      ),\n+      options ? options.onError : void 0,\n+      function () {\n+        var readable = new stream.Readable({\n+            read: function () {\n+              startFlowing(request, writable);\n+            }\n+          }),\n+          writable = createFakeWritableFromReadable(readable);\n+        readable = { postponed: getPostponedState(request), prelude: readable };\n+        resolve(readable);\n+      },\n+      void 0,\n+      void 0,\n+      reject,\n+      options ? options.onPostpone : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.resumeToPipeableStream = function (children, postponedState, options) {\n+  var request = resumeRequestImpl(children, postponedState, options),\n+    hasStartedFlowing = !1;\n+  startWork(request);\n+  return {\n+    pipe: function (destination) {\n+      if (hasStartedFlowing)\n+        throw Error(\n+          \"React currently only supports piping to one writable stream.\"\n+        );\n+      hasStartedFlowing = !0;\n+      startFlowing(request, destination);\n+      destination.on(\"drain\", createDrainHandler(destination, request));\n+      destination.on(\n+        \"error\",\n+        createCancelHandler(\n+          request,\n+          \"The destination stream errored while writing data.\"\n+        )\n+      );\n+      destination.on(\n+        \"close\",\n+        createCancelHandler(request, \"The destination stream closed early.\")\n+      );\n+      return destination;\n+    },\n+    abort: function (reason) {\n+      abort(request, reason);\n+    }\n+  };\n+};\n+exports.version = \"19.2.0-canary-1bd1f01f-20251001\";"
        },
        {
            "sha": "546dae7b38224038ceafbe76f589d357c1db7a96",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -416,7 +416,7 @@\n     exports.useFormStatus = function () {\n       return resolveDispatcher().useHostTransitionStatus();\n     };\n-    exports.version = \"19.2.0-canary-548235db-20251001\";\n+    exports.version = \"19.2.0-canary-1bd1f01f-20251001\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "eeb199603c513423cba44aa532f3da056a19755d",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -207,4 +207,4 @@ exports.useFormState = function (action, initialState, permalink) {\n exports.useFormStatus = function () {\n   return ReactSharedInternals.H.useHostTransitionStatus();\n };\n-exports.version = \"19.2.0-canary-548235db-20251001\";\n+exports.version = \"19.2.0-canary-1bd1f01f-20251001\";"
        },
        {
            "sha": "9d61b2f3024b2c9fa6a9438ad91ddf00e36cb238",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom.react-server.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.react-server.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.react-server.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.react-server.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -336,5 +336,5 @@\n             }))\n           : Internals.d.m(href));\n     };\n-    exports.version = \"19.2.0-canary-548235db-20251001\";\n+    exports.version = \"19.2.0-canary-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "39fd426b3b6fb666812f32de12bf71e1cf843400",
            "filename": "packages/next/src/compiled/react-dom/cjs/react-dom.react-server.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.react-server.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.react-server.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fcjs%2Freact-dom.react-server.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -149,4 +149,4 @@ exports.preloadModule = function (href, options) {\n       });\n     } else Internals.d.m(href);\n };\n-exports.version = \"19.2.0-canary-548235db-20251001\";\n+exports.version = \"19.2.0-canary-1bd1f01f-20251001\";"
        },
        {
            "sha": "6c9c8abd355489c5590fdb5cb8df6f10dad71ef0",
            "filename": "packages/next/src/compiled/react-dom/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fpackage.json?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -67,10 +67,10 @@\n     \"./package.json\": \"./package.json\"\n   },\n   \"dependencies\": {\n-    \"scheduler\": \"0.27.0-canary-548235db-20251001\"\n+    \"scheduler\": \"0.27.0-canary-1bd1f01f-20251001\"\n   },\n   \"peerDependencies\": {\n-    \"react\": \"19.2.0-canary-548235db-20251001\"\n+    \"react\": \"19.2.0-canary-1bd1f01f-20251001\"\n   },\n   \"browser\": {\n     \"./server.js\": \"./server.browser.js\","
        },
        {
            "sha": "4d8066527139f7e03489f03e473e54e0e5759094",
            "filename": "packages/next/src/compiled/react-dom/server.browser.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fserver.browser.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fserver.browser.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fserver.browser.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -13,6 +13,4 @@ exports.version = l.version;\n exports.renderToString = l.renderToString;\n exports.renderToStaticMarkup = l.renderToStaticMarkup;\n exports.renderToReadableStream = s.renderToReadableStream;\n-if (s.resume) {\n-  exports.resume = s.resume;\n-}\n+exports.resume = s.resume;"
        },
        {
            "sha": "cc05ed6120f4f4ba0fe8c43953b8436b44386117",
            "filename": "packages/next/src/compiled/react-dom/server.edge.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fserver.edge.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fserver.edge.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fserver.edge.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -14,6 +14,4 @@ exports.version = b.version;\n exports.renderToReadableStream = b.renderToReadableStream;\n exports.renderToString = l.renderToString;\n exports.renderToStaticMarkup = l.renderToStaticMarkup;\n-if (b.resume) {\n-  exports.resume = b.resume;\n-}\n+exports.resume = b.resume;"
        },
        {
            "sha": "3feeac208fe17bbfb6b84756b42388ca5caddcf3",
            "filename": "packages/next/src/compiled/react-dom/server.node.js",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fserver.node.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fserver.node.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-dom%2Fserver.node.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -14,9 +14,5 @@ exports.renderToString = l.renderToString;\n exports.renderToStaticMarkup = l.renderToStaticMarkup;\n exports.renderToPipeableStream = s.renderToPipeableStream;\n exports.renderToReadableStream = s.renderToReadableStream;\n-if (s.resumeToPipeableStream) {\n-  exports.resumeToPipeableStream = s.resumeToPipeableStream;\n-}\n-if (s.resume) {\n-  exports.resume = s.resume;\n-}\n+exports.resumeToPipeableStream = s.resumeToPipeableStream;\n+exports.resume = s.resume;"
        },
        {
            "sha": "f8b203e8b99e2bab6dd6bca27a16368d70ed89f1",
            "filename": "packages/next/src/compiled/react-experimental/cjs/react.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1356,7 +1356,7 @@\n     exports.useTransition = function () {\n       return resolveDispatcher().useTransition();\n     };\n-    exports.version = \"19.2.0-experimental-548235db-20251001\";\n+    exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "a78cb65228e6a9dbb1eb58f6ee9867a73ee9558b",
            "filename": "packages/next/src/compiled/react-experimental/cjs/react.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -597,4 +597,4 @@ exports.useSyncExternalStore = function (\n exports.useTransition = function () {\n   return ReactSharedInternals.H.useTransition();\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";"
        },
        {
            "sha": "57907a3d2bf477e311afe838c15fcbe5d79cd55e",
            "filename": "packages/next/src/compiled/react-experimental/cjs/react.react-server.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.react-server.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.react-server.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.react-server.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1025,5 +1025,5 @@\n     exports.useMemo = function (create, deps) {\n       return resolveDispatcher().useMemo(create, deps);\n     };\n-    exports.version = \"19.2.0-experimental-548235db-20251001\";\n+    exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "6cc057d3b86472ca3612964bd7b4510cebe55bf6",
            "filename": "packages/next/src/compiled/react-experimental/cjs/react.react-server.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.react-server.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.react-server.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-experimental%2Fcjs%2Freact.react-server.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -563,4 +563,4 @@ exports.useId = function () {\n exports.useMemo = function (create, deps) {\n   return ReactSharedInternals.H.useMemo(create, deps);\n };\n-exports.version = \"19.2.0-experimental-548235db-20251001\";\n+exports.version = \"19.2.0-experimental-1bd1f01f-20251001\";"
        },
        {
            "sha": "17b079b433830eb7a5dd9216f7ec857a539e7a41",
            "filename": "packages/next/src/compiled/react-is/package.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-is%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-is%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-is%2Fpackage.json?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1,6 +1,6 @@\n {\n   \"name\": \"react-is\",\n-  \"version\": \"19.2.0-canary-548235db-20251001\",\n+  \"version\": \"19.2.0-canary-1bd1f01f-20251001\",\n   \"description\": \"Brand checking of React Elements.\",\n   \"main\": \"index.js\",\n   \"sideEffects\": false,"
        },
        {
            "sha": "6d168af5ec542cb90cf63c730e31f18a2d33a652",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-client.browser.development.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-client.browser.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -4856,10 +4856,10 @@\n       return hook.checkDCE ? !0 : !1;\n     })({\n       bundleType: 1,\n-      version: \"19.2.0-experimental-548235db-20251001\",\n+      version: \"19.2.0-experimental-1bd1f01f-20251001\",\n       rendererPackageName: \"react-server-dom-turbopack\",\n       currentDispatcherRef: ReactSharedInternals,\n-      reconcilerVersion: \"19.2.0-experimental-548235db-20251001\",\n+      reconcilerVersion: \"19.2.0-experimental-1bd1f01f-20251001\",\n       getCurrentComponentInfo: function () {\n         return currentOwnerInDEV;\n       }"
        },
        {
            "sha": "f7ac83ed867caf16fa99f16d04a65820e01db0ac",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-server.browser.development.js",
            "status": "modified",
            "additions": 44,
            "deletions": 44,
            "changes": 88,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.browser.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -5253,6 +5253,50 @@\n       close(body);\n       return turbopackMap;\n     };\n+    exports.prerender = function (model, turbopackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          turbopackMap,\n+          function () {\n+            var stream = new ReadableStream(\n+              {\n+                type: \"bytes\",\n+                pull: function (controller) {\n+                  startFlowing(request, controller);\n+                },\n+                cancel: function (reason) {\n+                  request.destination = null;\n+                  abort(request, reason);\n+                }\n+              },\n+              { highWaterMark: 0 }\n+            );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -5353,48 +5397,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, turbopackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          turbopackMap,\n-          function () {\n-            var stream = new ReadableStream(\n-              {\n-                type: \"bytes\",\n-                pull: function (controller) {\n-                  startFlowing(request, controller);\n-                },\n-                cancel: function (reason) {\n-                  request.destination = null;\n-                  abort(request, reason);\n-                }\n-              },\n-              { highWaterMark: 0 }\n-            );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "6260c80756bb853d28e20781b164756ed8e475b2",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-server.browser.production.js",
            "status": "modified",
            "additions": 42,
            "deletions": 42,
            "changes": 84,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.browser.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -3034,6 +3034,48 @@ exports.decodeReply = function (body, turbopackMap, options) {\n   close(body);\n   return turbopackMap;\n };\n+exports.prerender = function (model, turbopackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      turbopackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var stream = new ReadableStream(\n+          {\n+            type: \"bytes\",\n+            pull: function (controller) {\n+              startFlowing(request, controller);\n+            },\n+            cancel: function (reason) {\n+              request.destination = null;\n+              abort(request, reason);\n+            }\n+          },\n+          { highWaterMark: 0 }\n+        );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -3096,45 +3138,3 @@ exports.renderToReadableStream = function (model, turbopackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, turbopackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      turbopackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var stream = new ReadableStream(\n-          {\n-            type: \"bytes\",\n-            pull: function (controller) {\n-              startFlowing(request, controller);\n-            },\n-            cancel: function (reason) {\n-              request.destination = null;\n-              abort(request, reason);\n-            }\n-          },\n-          { highWaterMark: 0 }\n-        );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "6e61c85043effda57a1886b1a1e1368bb3c894ea",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-server.edge.development.js",
            "status": "modified",
            "additions": 44,
            "deletions": 44,
            "changes": 88,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.edge.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -5377,6 +5377,50 @@\n       iterator.next().then(progress, error);\n       return getChunk(response$jscomp$0, 0);\n     };\n+    exports.prerender = function (model, turbopackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          turbopackMap,\n+          function () {\n+            var stream = new ReadableStream(\n+              {\n+                type: \"bytes\",\n+                pull: function (controller) {\n+                  startFlowing(request, controller);\n+                },\n+                cancel: function (reason) {\n+                  request.destination = null;\n+                  abort(request, reason);\n+                }\n+              },\n+              { highWaterMark: 0 }\n+            );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -5477,48 +5521,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, turbopackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          turbopackMap,\n-          function () {\n-            var stream = new ReadableStream(\n-              {\n-                type: \"bytes\",\n-                pull: function (controller) {\n-                  startFlowing(request, controller);\n-                },\n-                cancel: function (reason) {\n-                  request.destination = null;\n-                  abort(request, reason);\n-                }\n-              },\n-              { highWaterMark: 0 }\n-            );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "bc94628dafa7e4d329c2eb522d039918c36364c7",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-server.edge.production.js",
            "status": "modified",
            "additions": 42,
            "deletions": 42,
            "changes": 84,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.edge.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -3078,6 +3078,48 @@ exports.decodeReplyFromAsyncIterable = function (\n   iterator.next().then(progress, error);\n   return getChunk(response, 0);\n };\n+exports.prerender = function (model, turbopackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      turbopackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var stream = new ReadableStream(\n+          {\n+            type: \"bytes\",\n+            pull: function (controller) {\n+              startFlowing(request, controller);\n+            },\n+            cancel: function (reason) {\n+              request.destination = null;\n+              abort(request, reason);\n+            }\n+          },\n+          { highWaterMark: 0 }\n+        );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -3140,45 +3182,3 @@ exports.renderToReadableStream = function (model, turbopackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, turbopackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      turbopackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var stream = new ReadableStream(\n-          {\n-            type: \"bytes\",\n-            pull: function (controller) {\n-              startFlowing(request, controller);\n-            },\n-            cancel: function (reason) {\n-              request.destination = null;\n-              abort(request, reason);\n-            }\n-          },\n-          { highWaterMark: 0 }\n-        );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "239c1f82472fb470d320a1007a0e17f8377f02c3",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-server.node.development.js",
            "status": "modified",
            "additions": 88,
            "deletions": 92,
            "changes": 180,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.node.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -6043,6 +6043,94 @@\n       });\n       return getChunk(response, 0);\n     };\n+    exports.prerender = function (model, turbopackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          turbopackMap,\n+          function () {\n+            var writable,\n+              stream = new ReadableStream(\n+                {\n+                  type: \"bytes\",\n+                  start: function (controller) {\n+                    writable =\n+                      createFakeWritableFromReadableStreamController(\n+                        controller\n+                      );\n+                  },\n+                  pull: function () {\n+                    startFlowing(request, writable);\n+                  },\n+                  cancel: function (reason) {\n+                    request.destination = null;\n+                    abort(request, reason);\n+                  }\n+                },\n+                { highWaterMark: 0 }\n+              );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.prerenderToNodeStream = function (model, turbopackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          turbopackMap,\n+          function () {\n+            var readable = new stream.Readable({\n+                read: function () {\n+                  startFlowing(request, writable);\n+                }\n+              }),\n+              writable = createFakeWritableFromNodeReadable(readable);\n+            resolve({ prelude: readable });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -6202,96 +6290,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, turbopackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          turbopackMap,\n-          function () {\n-            var writable,\n-              stream = new ReadableStream(\n-                {\n-                  type: \"bytes\",\n-                  start: function (controller) {\n-                    writable =\n-                      createFakeWritableFromReadableStreamController(\n-                        controller\n-                      );\n-                  },\n-                  pull: function () {\n-                    startFlowing(request, writable);\n-                  },\n-                  cancel: function (reason) {\n-                    request.destination = null;\n-                    abort(request, reason);\n-                  }\n-                },\n-                { highWaterMark: 0 }\n-              );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n-    exports.unstable_prerenderToNodeStream = function (\n-      model,\n-      turbopackMap,\n-      options\n-    ) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          turbopackMap,\n-          function () {\n-            var readable = new stream.Readable({\n-                read: function () {\n-                  startFlowing(request, writable);\n-                }\n-              }),\n-              writable = createFakeWritableFromNodeReadable(readable);\n-            resolve({ prelude: readable });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "4c21e3826a4de6b7e8f6997db2d301b28406e141",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-server.node.production.js",
            "status": "modified",
            "additions": 82,
            "deletions": 86,
            "changes": 168,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fcjs%2Freact-server-dom-turbopack-server.node.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -3192,6 +3192,88 @@ exports.decodeReplyFromBusboy = function (busboyStream, turbopackMap, options) {\n   });\n   return getChunk(response, 0);\n };\n+exports.prerender = function (model, turbopackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      turbopackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var writable,\n+          stream = new ReadableStream(\n+            {\n+              type: \"bytes\",\n+              start: function (controller) {\n+                writable =\n+                  createFakeWritableFromReadableStreamController(controller);\n+              },\n+              pull: function () {\n+                startFlowing(request, writable);\n+              },\n+              cancel: function (reason) {\n+                request.destination = null;\n+                abort(request, reason);\n+              }\n+            },\n+            { highWaterMark: 0 }\n+          );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.prerenderToNodeStream = function (model, turbopackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      turbopackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var readable = new stream.Readable({\n+            read: function () {\n+              startFlowing(request, writable);\n+            }\n+          }),\n+          writable = createFakeWritableFromNodeReadable(readable);\n+        resolve({ prelude: readable });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -3297,89 +3379,3 @@ exports.renderToReadableStream = function (model, turbopackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, turbopackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      turbopackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var writable,\n-          stream = new ReadableStream(\n-            {\n-              type: \"bytes\",\n-              start: function (controller) {\n-                writable =\n-                  createFakeWritableFromReadableStreamController(controller);\n-              },\n-              pull: function () {\n-                startFlowing(request, writable);\n-              },\n-              cancel: function (reason) {\n-                request.destination = null;\n-                abort(request, reason);\n-              }\n-            },\n-            { highWaterMark: 0 }\n-          );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};\n-exports.unstable_prerenderToNodeStream = function (\n-  model,\n-  turbopackMap,\n-  options\n-) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      turbopackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var readable = new stream.Readable({\n-            read: function () {\n-              startFlowing(request, writable);\n-            }\n-          }),\n-          writable = createFakeWritableFromNodeReadable(readable);\n-        resolve({ prelude: readable });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "562e61f3353aacfdc823c74e5b94f619165337ad",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fpackage.json?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -48,7 +48,7 @@\n     \"neo-async\": \"^2.6.1\"\n   },\n   \"peerDependencies\": {\n-    \"react\": \"0.0.0-experimental-548235db-20251001\",\n-    \"react-dom\": \"0.0.0-experimental-548235db-20251001\"\n+    \"react\": \"0.0.0-experimental-1bd1f01f-20251001\",\n+    \"react-dom\": \"0.0.0-experimental-1bd1f01f-20251001\"\n   }\n }\n\\ No newline at end of file"
        },
        {
            "sha": "d6acca4d6ec5d4fdb07fde8d9b71dc5840207c07",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/static.browser.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fstatic.browser.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fstatic.browser.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fstatic.browser.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,6 +7,4 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-turbopack-server.browser.development.js');\n }\n \n-if (s.unstable_prerender) {\n-  exports.unstable_prerender = s.unstable_prerender;\n-}\n+exports.prerender = s.prerender;"
        },
        {
            "sha": "acd8ad68d74e74171700b167031c109232568acb",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/static.edge.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fstatic.edge.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fstatic.edge.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fstatic.edge.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,6 +7,4 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-turbopack-server.edge.development.js');\n }\n \n-if (s.unstable_prerender) {\n-  exports.unstable_prerender = s.unstable_prerender;\n-}\n+exports.prerender = s.prerender;"
        },
        {
            "sha": "f082e275e0120204a89dbe3c0ca11b122880929f",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack-experimental/static.node.js",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fstatic.node.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fstatic.node.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack-experimental%2Fstatic.node.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,9 +7,5 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-turbopack-server.node.development.js');\n }\n \n-if (s.unstable_prerender) {\n-  exports.unstable_prerender = s.unstable_prerender;\n-}\n-if (s.unstable_prerenderToNodeStream) {\n-  exports.unstable_prerenderToNodeStream = s.unstable_prerenderToNodeStream;\n-}\n+exports.prerender = s.prerender;\n+exports.prerenderToNodeStream = s.prerenderToNodeStream;"
        },
        {
            "sha": "ff5d7e02aeeb3754131e4c52dcdc9fa8b036562f",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-client.browser.development.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-client.browser.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -4827,10 +4827,10 @@\n       return hook.checkDCE ? !0 : !1;\n     })({\n       bundleType: 1,\n-      version: \"19.2.0-canary-548235db-20251001\",\n+      version: \"19.2.0-canary-1bd1f01f-20251001\",\n       rendererPackageName: \"react-server-dom-turbopack\",\n       currentDispatcherRef: ReactSharedInternals,\n-      reconcilerVersion: \"19.2.0-canary-548235db-20251001\",\n+      reconcilerVersion: \"19.2.0-canary-1bd1f01f-20251001\",\n       getCurrentComponentInfo: function () {\n         return currentOwnerInDEV;\n       }"
        },
        {
            "sha": "edd29d056a4f32f328b4d7bc6eac7f50e1f0b6e0",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.browser.development.js",
            "status": "modified",
            "additions": 156,
            "deletions": 100,
            "changes": 256,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.browser.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1236,9 +1236,11 @@\n           if (request.status === ABORTING)\n             return (\n               request.abortableTasks.delete(newTask),\n-              (task = request.fatalError),\n-              abortTask(newTask),\n-              finishAbortedTask(newTask, request, task),\n+              21 === request.type\n+                ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+                : ((task = request.fatalError),\n+                  abortTask(newTask),\n+                  finishAbortedTask(newTask, request, task)),\n               newTask.id\n             );\n           \"string\" !== typeof thenable.status &&\n@@ -1310,8 +1312,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortStream);\n           signal = signal.reason;\n-          erroredTask(request, streamTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -1397,8 +1402,12 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortIterable);\n           var reason = signal.reason;\n-          erroredTask(request, streamTask, signal.reason);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal.reason),\n+              enqueueFlush(request));\n           \"function\" === typeof iterator.throw &&\n             iterator.throw(reason).then(error, error);\n         }\n@@ -2206,8 +2215,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortBlob);\n           signal = signal.reason;\n-          erroredTask(request, newTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(newTask),\n+              haltTask(newTask),\n+              finishHaltedTask(newTask, request))\n+            : (erroredTask(request, newTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -2242,12 +2254,19 @@\n           null !== parent &&\n           (parent.$$typeof === REACT_ELEMENT_TYPE ||\n             parent.$$typeof === REACT_LAZY_TYPE);\n-        if (request.status === ABORTING)\n-          return (\n-            (task.status = 3),\n-            (task = request.fatalError),\n-            parent ? serializeLazyID(task) : serializeByValueID(task)\n-          );\n+        if (request.status === ABORTING) {\n+          task.status = 3;\n+          if (21 === request.type)\n+            return (\n+              (task = request.nextChunkId++),\n+              (task = parent\n+                ? serializeLazyID(task)\n+                : serializeByValueID(task)),\n+              task\n+            );\n+          task = request.fatalError;\n+          return parent ? serializeLazyID(task) : serializeByValueID(task);\n+        }\n         key =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -3318,6 +3337,13 @@\n       (thenable = thenable._debugInfo) &&\n         forwardDebugInfo(request, task, thenable);\n     }\n+    function forwardDebugInfoFromAbortedTask(request, task) {\n+      var model = task.model;\n+      \"object\" === typeof model &&\n+        null !== model &&\n+        (model = model._debugInfo) &&\n+        forwardDebugInfo(request, task, model);\n+    }\n     function emitTimingChunk(request, id, timestamp) {\n       request.pendingChunks++;\n       var json = '{\"time\":' + (timestamp - request.timeOrigin) + \"}\";\n@@ -3429,13 +3455,19 @@\n           request.abortableTasks.delete(task);\n           callOnAllReadyIfReady(request);\n         } catch (thrownValue) {\n-          if (request.status === ABORTING) {\n-            request.abortableTasks.delete(task);\n-            task.status = 0;\n-            var errorId = request.fatalError;\n-            abortTask(task);\n-            finishAbortedTask(task, request, errorId);\n-          } else {\n+          if (request.status === ABORTING)\n+            if (\n+              (request.abortableTasks.delete(task),\n+              (task.status = 0),\n+              21 === request.type)\n+            )\n+              haltTask(task), finishHaltedTask(task, request);\n+            else {\n+              var errorId = request.fatalError;\n+              abortTask(task);\n+              finishAbortedTask(task, request, errorId);\n+            }\n+          else {\n             var x =\n               thrownValue === SuspenseException\n                 ? getSuspendedThenable()\n@@ -3491,17 +3523,20 @@\n       0 === task.status && (task.status = 3);\n     }\n     function finishAbortedTask(task, request, errorId) {\n-      if (3 === task.status) {\n-        var model = task.model;\n-        \"object\" === typeof model &&\n-          null !== model &&\n-          (model = model._debugInfo) &&\n-          forwardDebugInfo(request, task, model);\n-        task.timed && markOperationEndTime(request, task, request.abortTime);\n-        errorId = serializeByValueID(errorId);\n-        task = encodeReferenceChunk(request, task.id, errorId);\n-        request.completedErrorChunks.push(task);\n-      }\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        task.timed && markOperationEndTime(request, task, request.abortTime),\n+        (errorId = serializeByValueID(errorId)),\n+        (task = encodeReferenceChunk(request, task.id, errorId)),\n+        request.completedErrorChunks.push(task));\n+    }\n+    function haltTask(task) {\n+      0 === task.status && (task.status = 3);\n+    }\n+    function finishHaltedTask(task, request) {\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        request.pendingChunks--);\n     }\n     function flushCompletedChunks(request) {\n       if (null !== request.debugDestination) {\n@@ -3667,6 +3702,18 @@\n         }\n       }\n     }\n+    function finishHalt(request, abortedTasks) {\n+      try {\n+        abortedTasks.forEach(function (task) {\n+          return finishHaltedTask(task, request);\n+        });\n+        var onAllReady = request.onAllReady;\n+        onAllReady();\n+        flushCompletedChunks(request);\n+      } catch (error) {\n+        logRecoverableError(request, error, null), fatalError(request, error);\n+      }\n+    }\n     function finishAbort(request, abortedTasks, errorId) {\n       try {\n         abortedTasks.forEach(function (task) {\n@@ -3686,31 +3733,40 @@\n           request.abortTime = performance.now();\n           request.cacheController.abort(reason);\n           var abortableTasks = request.abortableTasks;\n-          if (0 < abortableTasks.size) {\n-            var error =\n-                void 0 === reason\n-                  ? Error(\n-                      \"The render was aborted by the server without a reason.\"\n-                    )\n-                  : \"object\" === typeof reason &&\n-                      null !== reason &&\n-                      \"function\" === typeof reason.then\n+          if (0 < abortableTasks.size)\n+            if (21 === request.type)\n+              abortableTasks.forEach(function (task) {\n+                return haltTask(task, request);\n+              }),\n+                scheduleWork(function () {\n+                  return finishHalt(request, abortableTasks);\n+                });\n+            else {\n+              var error =\n+                  void 0 === reason\n                     ? Error(\n-                        \"The render was aborted by the server with a promise.\"\n+                        \"The render was aborted by the server without a reason.\"\n                       )\n-                    : reason,\n-              digest = logRecoverableError(request, error, null),\n-              _errorId2 = request.nextChunkId++;\n-            request.fatalError = _errorId2;\n-            request.pendingChunks++;\n-            emitErrorChunk(request, _errorId2, digest, error, !1, null);\n-            abortableTasks.forEach(function (task) {\n-              return abortTask(task, request, _errorId2);\n-            });\n-            scheduleWork(function () {\n-              return finishAbort(request, abortableTasks, _errorId2);\n-            });\n-          } else {\n+                    : \"object\" === typeof reason &&\n+                        null !== reason &&\n+                        \"function\" === typeof reason.then\n+                      ? Error(\n+                          \"The render was aborted by the server with a promise.\"\n+                        )\n+                      : reason,\n+                digest = logRecoverableError(request, error, null),\n+                _errorId2 = request.nextChunkId++;\n+              request.fatalError = _errorId2;\n+              request.pendingChunks++;\n+              emitErrorChunk(request, _errorId2, digest, error, !1, null);\n+              abortableTasks.forEach(function (task) {\n+                return abortTask(task, request, _errorId2);\n+              });\n+              scheduleWork(function () {\n+                return finishAbort(request, abortableTasks, _errorId2);\n+              });\n+            }\n+          else {\n             var onAllReady = request.onAllReady;\n             onAllReady();\n             flushCompletedChunks(request);\n@@ -5080,6 +5136,50 @@\n       close(body);\n       return turbopackMap;\n     };\n+    exports.prerender = function (model, turbopackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          turbopackMap,\n+          function () {\n+            var stream = new ReadableStream(\n+              {\n+                type: \"bytes\",\n+                pull: function (controller) {\n+                  startFlowing(request, controller);\n+                },\n+                cancel: function (reason) {\n+                  request.destination = null;\n+                  abort(request, reason);\n+                }\n+              },\n+              { highWaterMark: 0 }\n+            );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -5180,48 +5280,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, turbopackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          turbopackMap,\n-          function () {\n-            var stream = new ReadableStream(\n-              {\n-                type: \"bytes\",\n-                pull: function (controller) {\n-                  startFlowing(request, controller);\n-                },\n-                cancel: function (reason) {\n-                  request.destination = null;\n-                  abort(request, reason);\n-                }\n-              },\n-              { highWaterMark: 0 }\n-            );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "590ff0e445b77b62efd858aa0cb0f1a13271f794",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.browser.production.js",
            "status": "modified",
            "additions": 146,
            "deletions": 88,
            "changes": 234,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.browser.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -893,9 +893,11 @@ function serializeThenable(request, task, thenable) {\n       if (12 === request.status)\n         return (\n           request.abortableTasks.delete(newTask),\n-          (task = request.fatalError),\n-          abortTask(newTask),\n-          finishAbortedTask(newTask, request, task),\n+          21 === request.type\n+            ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+            : ((task = request.fatalError),\n+              abortTask(newTask),\n+              finishAbortedTask(newTask, request, task)),\n           newTask.id\n         );\n       \"string\" !== typeof thenable.status &&\n@@ -961,8 +963,11 @@ function serializeReadableStream(request, task, stream) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortStream);\n       signal = signal.reason;\n-      erroredTask(request, streamTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1047,8 +1052,12 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortIterable);\n       var reason = signal.reason;\n-      erroredTask(request, streamTask, signal.reason);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal.reason),\n+          enqueueFlush(request));\n       \"function\" === typeof iterator.throw &&\n         iterator.throw(reason).then(error, error);\n     }\n@@ -1178,7 +1187,7 @@ function deferTask(request, task) {\n     request.abortableTasks\n   );\n   pingTask(request, task);\n-  return \"$L\" + task.id.toString(16);\n+  return serializeLazyID(task.id);\n }\n function renderElement(request, task, type, key, ref, props) {\n   if (null !== ref && void 0 !== ref)\n@@ -1298,10 +1307,16 @@ function createTask(\n           12 === request.status)\n         )\n           (task.status = 3),\n-            (prevKeyPath = request.fatalError),\n-            (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n-              : serializeByValueID(prevKeyPath));\n+            21 === request.type\n+              ? ((prevKeyPath = request.nextChunkId++),\n+                (prevKeyPath = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)),\n+                (JSCompiler_inline_result = prevKeyPath))\n+              : ((prevKeyPath = request.fatalError),\n+                (JSCompiler_inline_result = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)));\n         else if (\n           ((value =\n             thrownValue === SuspenseException\n@@ -1326,7 +1341,7 @@ function createTask(\n           task.keyPath = prevKeyPath;\n           task.implicitSlot = prevImplicitSlot;\n           JSCompiler_inline_result = parentPropertyName\n-            ? \"$L\" + JSCompiler_inline_result.id.toString(16)\n+            ? serializeLazyID(JSCompiler_inline_result.id)\n             : serializeByValueID(JSCompiler_inline_result.id);\n         } else\n           (task.keyPath = prevKeyPath),\n@@ -1336,7 +1351,7 @@ function createTask(\n             (prevImplicitSlot = logRecoverableError(request, value, task)),\n             emitErrorChunk(request, prevKeyPath, prevImplicitSlot),\n             (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n+              ? serializeLazyID(prevKeyPath)\n               : serializeByValueID(prevKeyPath));\n       }\n       return JSCompiler_inline_result;\n@@ -1349,6 +1364,9 @@ function createTask(\n function serializeByValueID(id) {\n   return \"$\" + id.toString(16);\n }\n+function serializeLazyID(id) {\n+  return \"$L\" + id.toString(16);\n+}\n function encodeReferenceChunk(request, id, reference) {\n   request = stringify(reference);\n   id = id.toString(16) + \":\" + request + \"\\n\";\n@@ -1367,7 +1385,7 @@ function serializeClientReference(\n     existingId = writtenClientReferences.get(clientReferenceKey);\n   if (void 0 !== existingId)\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + existingId.toString(16)\n+      ? serializeLazyID(existingId)\n       : serializeByValueID(existingId);\n   try {\n     var config = request.bundlerConfig,\n@@ -1405,7 +1423,7 @@ function serializeClientReference(\n     request.completedImportChunks.push(processedChunk);\n     writtenClientReferences.set(clientReferenceKey, importId);\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + importId.toString(16)\n+      ? serializeLazyID(importId)\n       : serializeByValueID(importId);\n   } catch (x) {\n     return (\n@@ -1458,8 +1476,11 @@ function serializeBlob(request, blob) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortBlob);\n       signal = signal.reason;\n-      erroredTask(request, newTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(newTask),\n+          haltTask(newTask),\n+          finishHaltedTask(newTask, request))\n+        : (erroredTask(request, newTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1908,13 +1929,19 @@ function retryTask(request, task) {\n       request.abortableTasks.delete(task);\n       callOnAllReadyIfReady(request);\n     } catch (thrownValue) {\n-      if (12 === request.status) {\n-        request.abortableTasks.delete(task);\n-        task.status = 0;\n-        var errorId = request.fatalError;\n-        abortTask(task);\n-        finishAbortedTask(task, request, errorId);\n-      } else {\n+      if (12 === request.status)\n+        if (\n+          (request.abortableTasks.delete(task),\n+          (task.status = 0),\n+          21 === request.type)\n+        )\n+          haltTask(task), finishHaltedTask(task, request);\n+        else {\n+          var errorId = request.fatalError;\n+          abortTask(task);\n+          finishAbortedTask(task, request, errorId);\n+        }\n+      else {\n         var x =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -1971,6 +1998,12 @@ function finishAbortedTask(task, request, errorId) {\n     (task = encodeReferenceChunk(request, task.id, errorId)),\n     request.completedErrorChunks.push(task));\n }\n+function haltTask(task) {\n+  0 === task.status && (task.status = 3);\n+}\n+function finishHaltedTask(task, request) {\n+  3 === task.status && request.pendingChunks--;\n+}\n function flushCompletedChunks(request) {\n   var destination = request.destination;\n   if (null !== destination) {\n@@ -2057,6 +2090,18 @@ function startFlowing(request, destination) {\n     }\n   }\n }\n+function finishHalt(request, abortedTasks) {\n+  try {\n+    abortedTasks.forEach(function (task) {\n+      return finishHaltedTask(task, request);\n+    });\n+    var onAllReady = request.onAllReady;\n+    onAllReady();\n+    flushCompletedChunks(request);\n+  } catch (error) {\n+    logRecoverableError(request, error, null), fatalError(request, error);\n+  }\n+}\n function finishAbort(request, abortedTasks, errorId) {\n   try {\n     abortedTasks.forEach(function (task) {\n@@ -2075,27 +2120,40 @@ function abort(request, reason) {\n       request.status = 12;\n       request.cacheController.abort(reason);\n       var abortableTasks = request.abortableTasks;\n-      if (0 < abortableTasks.size) {\n-        var error =\n-            void 0 === reason\n-              ? Error(\"The render was aborted by the server without a reason.\")\n-              : \"object\" === typeof reason &&\n-                  null !== reason &&\n-                  \"function\" === typeof reason.then\n-                ? Error(\"The render was aborted by the server with a promise.\")\n-                : reason,\n-          digest = logRecoverableError(request, error, null),\n-          errorId = request.nextChunkId++;\n-        request.fatalError = errorId;\n-        request.pendingChunks++;\n-        emitErrorChunk(request, errorId, digest, error, !1, null);\n-        abortableTasks.forEach(function (task) {\n-          return abortTask(task, request, errorId);\n-        });\n-        scheduleWork(function () {\n-          return finishAbort(request, abortableTasks, errorId);\n-        });\n-      } else {\n+      if (0 < abortableTasks.size)\n+        if (21 === request.type)\n+          abortableTasks.forEach(function (task) {\n+            return haltTask(task, request);\n+          }),\n+            scheduleWork(function () {\n+              return finishHalt(request, abortableTasks);\n+            });\n+        else {\n+          var error =\n+              void 0 === reason\n+                ? Error(\n+                    \"The render was aborted by the server without a reason.\"\n+                  )\n+                : \"object\" === typeof reason &&\n+                    null !== reason &&\n+                    \"function\" === typeof reason.then\n+                  ? Error(\n+                      \"The render was aborted by the server with a promise.\"\n+                    )\n+                  : reason,\n+            digest = logRecoverableError(request, error, null),\n+            errorId = request.nextChunkId++;\n+          request.fatalError = errorId;\n+          request.pendingChunks++;\n+          emitErrorChunk(request, errorId, digest, error, !1, null);\n+          abortableTasks.forEach(function (task) {\n+            return abortTask(task, request, errorId);\n+          });\n+          scheduleWork(function () {\n+            return finishAbort(request, abortableTasks, errorId);\n+          });\n+        }\n+      else {\n         var onAllReady = request.onAllReady;\n         onAllReady();\n         flushCompletedChunks(request);\n@@ -2880,6 +2938,48 @@ exports.decodeReply = function (body, turbopackMap, options) {\n   close(body);\n   return turbopackMap;\n };\n+exports.prerender = function (model, turbopackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      turbopackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var stream = new ReadableStream(\n+          {\n+            type: \"bytes\",\n+            pull: function (controller) {\n+              startFlowing(request, controller);\n+            },\n+            cancel: function (reason) {\n+              request.destination = null;\n+              abort(request, reason);\n+            }\n+          },\n+          { highWaterMark: 0 }\n+        );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -2942,45 +3042,3 @@ exports.renderToReadableStream = function (model, turbopackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, turbopackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      turbopackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var stream = new ReadableStream(\n-          {\n-            type: \"bytes\",\n-            pull: function (controller) {\n-              startFlowing(request, controller);\n-            },\n-            cancel: function (reason) {\n-              request.destination = null;\n-              abort(request, reason);\n-            }\n-          },\n-          { highWaterMark: 0 }\n-        );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "2d5b63889d07aaccf5b590f7da4aa14710e6a12a",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.edge.development.js",
            "status": "modified",
            "additions": 156,
            "deletions": 100,
            "changes": 256,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.edge.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1248,9 +1248,11 @@\n           if (request.status === ABORTING)\n             return (\n               request.abortableTasks.delete(newTask),\n-              (task = request.fatalError),\n-              abortTask(newTask),\n-              finishAbortedTask(newTask, request, task),\n+              21 === request.type\n+                ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+                : ((task = request.fatalError),\n+                  abortTask(newTask),\n+                  finishAbortedTask(newTask, request, task)),\n               newTask.id\n             );\n           \"string\" !== typeof thenable.status &&\n@@ -1322,8 +1324,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortStream);\n           signal = signal.reason;\n-          erroredTask(request, streamTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -1409,8 +1414,12 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortIterable);\n           var reason = signal.reason;\n-          erroredTask(request, streamTask, signal.reason);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal.reason),\n+              enqueueFlush(request));\n           \"function\" === typeof iterator.throw &&\n             iterator.throw(reason).then(error, error);\n         }\n@@ -2266,8 +2275,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortBlob);\n           signal = signal.reason;\n-          erroredTask(request, newTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(newTask),\n+              haltTask(newTask),\n+              finishHaltedTask(newTask, request))\n+            : (erroredTask(request, newTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -2302,12 +2314,19 @@\n           null !== parent &&\n           (parent.$$typeof === REACT_ELEMENT_TYPE ||\n             parent.$$typeof === REACT_LAZY_TYPE);\n-        if (request.status === ABORTING)\n-          return (\n-            (task.status = 3),\n-            (task = request.fatalError),\n-            parent ? serializeLazyID(task) : serializeByValueID(task)\n-          );\n+        if (request.status === ABORTING) {\n+          task.status = 3;\n+          if (21 === request.type)\n+            return (\n+              (task = request.nextChunkId++),\n+              (task = parent\n+                ? serializeLazyID(task)\n+                : serializeByValueID(task)),\n+              task\n+            );\n+          task = request.fatalError;\n+          return parent ? serializeLazyID(task) : serializeByValueID(task);\n+        }\n         key =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -3389,6 +3408,13 @@\n       (thenable = thenable._debugInfo) &&\n         forwardDebugInfo(request, task, thenable);\n     }\n+    function forwardDebugInfoFromAbortedTask(request, task) {\n+      var model = task.model;\n+      \"object\" === typeof model &&\n+        null !== model &&\n+        (model = model._debugInfo) &&\n+        forwardDebugInfo(request, task, model);\n+    }\n     function emitTimingChunk(request, id, timestamp) {\n       request.pendingChunks++;\n       var json = '{\"time\":' + (timestamp - request.timeOrigin) + \"}\";\n@@ -3500,13 +3526,19 @@\n           request.abortableTasks.delete(task);\n           callOnAllReadyIfReady(request);\n         } catch (thrownValue) {\n-          if (request.status === ABORTING) {\n-            request.abortableTasks.delete(task);\n-            task.status = 0;\n-            var errorId = request.fatalError;\n-            abortTask(task);\n-            finishAbortedTask(task, request, errorId);\n-          } else {\n+          if (request.status === ABORTING)\n+            if (\n+              (request.abortableTasks.delete(task),\n+              (task.status = 0),\n+              21 === request.type)\n+            )\n+              haltTask(task), finishHaltedTask(task, request);\n+            else {\n+              var errorId = request.fatalError;\n+              abortTask(task);\n+              finishAbortedTask(task, request, errorId);\n+            }\n+          else {\n             var x =\n               thrownValue === SuspenseException\n                 ? getSuspendedThenable()\n@@ -3562,17 +3594,20 @@\n       0 === task.status && (task.status = 3);\n     }\n     function finishAbortedTask(task, request, errorId) {\n-      if (3 === task.status) {\n-        var model = task.model;\n-        \"object\" === typeof model &&\n-          null !== model &&\n-          (model = model._debugInfo) &&\n-          forwardDebugInfo(request, task, model);\n-        task.timed && markOperationEndTime(request, task, request.abortTime);\n-        errorId = serializeByValueID(errorId);\n-        task = encodeReferenceChunk(request, task.id, errorId);\n-        request.completedErrorChunks.push(task);\n-      }\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        task.timed && markOperationEndTime(request, task, request.abortTime),\n+        (errorId = serializeByValueID(errorId)),\n+        (task = encodeReferenceChunk(request, task.id, errorId)),\n+        request.completedErrorChunks.push(task));\n+    }\n+    function haltTask(task) {\n+      0 === task.status && (task.status = 3);\n+    }\n+    function finishHaltedTask(task, request) {\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        request.pendingChunks--);\n     }\n     function flushCompletedChunks(request) {\n       if (null !== request.debugDestination) {\n@@ -3742,6 +3777,18 @@\n         }\n       }\n     }\n+    function finishHalt(request, abortedTasks) {\n+      try {\n+        abortedTasks.forEach(function (task) {\n+          return finishHaltedTask(task, request);\n+        });\n+        var onAllReady = request.onAllReady;\n+        onAllReady();\n+        flushCompletedChunks(request);\n+      } catch (error) {\n+        logRecoverableError(request, error, null), fatalError(request, error);\n+      }\n+    }\n     function finishAbort(request, abortedTasks, errorId) {\n       try {\n         abortedTasks.forEach(function (task) {\n@@ -3761,31 +3808,40 @@\n           request.abortTime = performance.now();\n           request.cacheController.abort(reason);\n           var abortableTasks = request.abortableTasks;\n-          if (0 < abortableTasks.size) {\n-            var error =\n-                void 0 === reason\n-                  ? Error(\n-                      \"The render was aborted by the server without a reason.\"\n-                    )\n-                  : \"object\" === typeof reason &&\n-                      null !== reason &&\n-                      \"function\" === typeof reason.then\n+          if (0 < abortableTasks.size)\n+            if (21 === request.type)\n+              abortableTasks.forEach(function (task) {\n+                return haltTask(task, request);\n+              }),\n+                setTimeout(function () {\n+                  return finishHalt(request, abortableTasks);\n+                }, 0);\n+            else {\n+              var error =\n+                  void 0 === reason\n                     ? Error(\n-                        \"The render was aborted by the server with a promise.\"\n+                        \"The render was aborted by the server without a reason.\"\n                       )\n-                    : reason,\n-              digest = logRecoverableError(request, error, null),\n-              _errorId2 = request.nextChunkId++;\n-            request.fatalError = _errorId2;\n-            request.pendingChunks++;\n-            emitErrorChunk(request, _errorId2, digest, error, !1, null);\n-            abortableTasks.forEach(function (task) {\n-              return abortTask(task, request, _errorId2);\n-            });\n-            setTimeout(function () {\n-              return finishAbort(request, abortableTasks, _errorId2);\n-            }, 0);\n-          } else {\n+                    : \"object\" === typeof reason &&\n+                        null !== reason &&\n+                        \"function\" === typeof reason.then\n+                      ? Error(\n+                          \"The render was aborted by the server with a promise.\"\n+                        )\n+                      : reason,\n+                digest = logRecoverableError(request, error, null),\n+                _errorId2 = request.nextChunkId++;\n+              request.fatalError = _errorId2;\n+              request.pendingChunks++;\n+              emitErrorChunk(request, _errorId2, digest, error, !1, null);\n+              abortableTasks.forEach(function (task) {\n+                return abortTask(task, request, _errorId2);\n+              });\n+              setTimeout(function () {\n+                return finishAbort(request, abortableTasks, _errorId2);\n+              }, 0);\n+            }\n+          else {\n             var onAllReady = request.onAllReady;\n             onAllReady();\n             flushCompletedChunks(request);\n@@ -5193,6 +5249,50 @@\n       iterator.next().then(progress, error);\n       return getChunk(response$jscomp$0, 0);\n     };\n+    exports.prerender = function (model, turbopackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          turbopackMap,\n+          function () {\n+            var stream = new ReadableStream(\n+              {\n+                type: \"bytes\",\n+                pull: function (controller) {\n+                  startFlowing(request, controller);\n+                },\n+                cancel: function (reason) {\n+                  request.destination = null;\n+                  abort(request, reason);\n+                }\n+              },\n+              { highWaterMark: 0 }\n+            );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -5293,48 +5393,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, turbopackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          turbopackMap,\n-          function () {\n-            var stream = new ReadableStream(\n-              {\n-                type: \"bytes\",\n-                pull: function (controller) {\n-                  startFlowing(request, controller);\n-                },\n-                cancel: function (reason) {\n-                  request.destination = null;\n-                  abort(request, reason);\n-                }\n-              },\n-              { highWaterMark: 0 }\n-            );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "95cf2d86f35830c586352bf36e0091c12e62e0f7",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.edge.production.js",
            "status": "modified",
            "additions": 146,
            "deletions": 88,
            "changes": 234,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.edge.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -892,9 +892,11 @@ function serializeThenable(request, task, thenable) {\n       if (12 === request.status)\n         return (\n           request.abortableTasks.delete(newTask),\n-          (task = request.fatalError),\n-          abortTask(newTask),\n-          finishAbortedTask(newTask, request, task),\n+          21 === request.type\n+            ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+            : ((task = request.fatalError),\n+              abortTask(newTask),\n+              finishAbortedTask(newTask, request, task)),\n           newTask.id\n         );\n       \"string\" !== typeof thenable.status &&\n@@ -960,8 +962,11 @@ function serializeReadableStream(request, task, stream) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortStream);\n       signal = signal.reason;\n-      erroredTask(request, streamTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1046,8 +1051,12 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortIterable);\n       var reason = signal.reason;\n-      erroredTask(request, streamTask, signal.reason);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal.reason),\n+          enqueueFlush(request));\n       \"function\" === typeof iterator.throw &&\n         iterator.throw(reason).then(error, error);\n     }\n@@ -1177,7 +1186,7 @@ function deferTask(request, task) {\n     request.abortableTasks\n   );\n   pingTask(request, task);\n-  return \"$L\" + task.id.toString(16);\n+  return serializeLazyID(task.id);\n }\n function renderElement(request, task, type, key, ref, props) {\n   if (null !== ref && void 0 !== ref)\n@@ -1297,10 +1306,16 @@ function createTask(\n           12 === request.status)\n         )\n           (task.status = 3),\n-            (prevKeyPath = request.fatalError),\n-            (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n-              : serializeByValueID(prevKeyPath));\n+            21 === request.type\n+              ? ((prevKeyPath = request.nextChunkId++),\n+                (prevKeyPath = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)),\n+                (JSCompiler_inline_result = prevKeyPath))\n+              : ((prevKeyPath = request.fatalError),\n+                (JSCompiler_inline_result = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)));\n         else if (\n           ((value =\n             thrownValue === SuspenseException\n@@ -1325,7 +1340,7 @@ function createTask(\n           task.keyPath = prevKeyPath;\n           task.implicitSlot = prevImplicitSlot;\n           JSCompiler_inline_result = parentPropertyName\n-            ? \"$L\" + JSCompiler_inline_result.id.toString(16)\n+            ? serializeLazyID(JSCompiler_inline_result.id)\n             : serializeByValueID(JSCompiler_inline_result.id);\n         } else\n           (task.keyPath = prevKeyPath),\n@@ -1335,7 +1350,7 @@ function createTask(\n             (prevImplicitSlot = logRecoverableError(request, value, task)),\n             emitErrorChunk(request, prevKeyPath, prevImplicitSlot),\n             (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n+              ? serializeLazyID(prevKeyPath)\n               : serializeByValueID(prevKeyPath));\n       }\n       return JSCompiler_inline_result;\n@@ -1348,6 +1363,9 @@ function createTask(\n function serializeByValueID(id) {\n   return \"$\" + id.toString(16);\n }\n+function serializeLazyID(id) {\n+  return \"$L\" + id.toString(16);\n+}\n function encodeReferenceChunk(request, id, reference) {\n   request = stringify(reference);\n   id = id.toString(16) + \":\" + request + \"\\n\";\n@@ -1366,7 +1384,7 @@ function serializeClientReference(\n     existingId = writtenClientReferences.get(clientReferenceKey);\n   if (void 0 !== existingId)\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + existingId.toString(16)\n+      ? serializeLazyID(existingId)\n       : serializeByValueID(existingId);\n   try {\n     var config = request.bundlerConfig,\n@@ -1404,7 +1422,7 @@ function serializeClientReference(\n     request.completedImportChunks.push(processedChunk);\n     writtenClientReferences.set(clientReferenceKey, importId);\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + importId.toString(16)\n+      ? serializeLazyID(importId)\n       : serializeByValueID(importId);\n   } catch (x) {\n     return (\n@@ -1457,8 +1475,11 @@ function serializeBlob(request, blob) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortBlob);\n       signal = signal.reason;\n-      erroredTask(request, newTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(newTask),\n+          haltTask(newTask),\n+          finishHaltedTask(newTask, request))\n+        : (erroredTask(request, newTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1909,13 +1930,19 @@ function retryTask(request, task) {\n       request.abortableTasks.delete(task);\n       callOnAllReadyIfReady(request);\n     } catch (thrownValue) {\n-      if (12 === request.status) {\n-        request.abortableTasks.delete(task);\n-        task.status = 0;\n-        var errorId = request.fatalError;\n-        abortTask(task);\n-        finishAbortedTask(task, request, errorId);\n-      } else {\n+      if (12 === request.status)\n+        if (\n+          (request.abortableTasks.delete(task),\n+          (task.status = 0),\n+          21 === request.type)\n+        )\n+          haltTask(task), finishHaltedTask(task, request);\n+        else {\n+          var errorId = request.fatalError;\n+          abortTask(task);\n+          finishAbortedTask(task, request, errorId);\n+        }\n+      else {\n         var x =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -1972,6 +1999,12 @@ function finishAbortedTask(task, request, errorId) {\n     (task = encodeReferenceChunk(request, task.id, errorId)),\n     request.completedErrorChunks.push(task));\n }\n+function haltTask(task) {\n+  0 === task.status && (task.status = 3);\n+}\n+function finishHaltedTask(task, request) {\n+  3 === task.status && request.pendingChunks--;\n+}\n function flushCompletedChunks(request) {\n   var destination = request.destination;\n   if (null !== destination) {\n@@ -2062,6 +2095,18 @@ function startFlowing(request, destination) {\n     }\n   }\n }\n+function finishHalt(request, abortedTasks) {\n+  try {\n+    abortedTasks.forEach(function (task) {\n+      return finishHaltedTask(task, request);\n+    });\n+    var onAllReady = request.onAllReady;\n+    onAllReady();\n+    flushCompletedChunks(request);\n+  } catch (error) {\n+    logRecoverableError(request, error, null), fatalError(request, error);\n+  }\n+}\n function finishAbort(request, abortedTasks, errorId) {\n   try {\n     abortedTasks.forEach(function (task) {\n@@ -2080,27 +2125,40 @@ function abort(request, reason) {\n       request.status = 12;\n       request.cacheController.abort(reason);\n       var abortableTasks = request.abortableTasks;\n-      if (0 < abortableTasks.size) {\n-        var error =\n-            void 0 === reason\n-              ? Error(\"The render was aborted by the server without a reason.\")\n-              : \"object\" === typeof reason &&\n-                  null !== reason &&\n-                  \"function\" === typeof reason.then\n-                ? Error(\"The render was aborted by the server with a promise.\")\n-                : reason,\n-          digest = logRecoverableError(request, error, null),\n-          errorId = request.nextChunkId++;\n-        request.fatalError = errorId;\n-        request.pendingChunks++;\n-        emitErrorChunk(request, errorId, digest, error, !1, null);\n-        abortableTasks.forEach(function (task) {\n-          return abortTask(task, request, errorId);\n-        });\n-        setTimeout(function () {\n-          return finishAbort(request, abortableTasks, errorId);\n-        }, 0);\n-      } else {\n+      if (0 < abortableTasks.size)\n+        if (21 === request.type)\n+          abortableTasks.forEach(function (task) {\n+            return haltTask(task, request);\n+          }),\n+            setTimeout(function () {\n+              return finishHalt(request, abortableTasks);\n+            }, 0);\n+        else {\n+          var error =\n+              void 0 === reason\n+                ? Error(\n+                    \"The render was aborted by the server without a reason.\"\n+                  )\n+                : \"object\" === typeof reason &&\n+                    null !== reason &&\n+                    \"function\" === typeof reason.then\n+                  ? Error(\n+                      \"The render was aborted by the server with a promise.\"\n+                    )\n+                  : reason,\n+            digest = logRecoverableError(request, error, null),\n+            errorId = request.nextChunkId++;\n+          request.fatalError = errorId;\n+          request.pendingChunks++;\n+          emitErrorChunk(request, errorId, digest, error, !1, null);\n+          abortableTasks.forEach(function (task) {\n+            return abortTask(task, request, errorId);\n+          });\n+          setTimeout(function () {\n+            return finishAbort(request, abortableTasks, errorId);\n+          }, 0);\n+        }\n+      else {\n         var onAllReady = request.onAllReady;\n         onAllReady();\n         flushCompletedChunks(request);\n@@ -2922,6 +2980,48 @@ exports.decodeReplyFromAsyncIterable = function (\n   iterator.next().then(progress, error);\n   return getChunk(response, 0);\n };\n+exports.prerender = function (model, turbopackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      turbopackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var stream = new ReadableStream(\n+          {\n+            type: \"bytes\",\n+            pull: function (controller) {\n+              startFlowing(request, controller);\n+            },\n+            cancel: function (reason) {\n+              request.destination = null;\n+              abort(request, reason);\n+            }\n+          },\n+          { highWaterMark: 0 }\n+        );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -2984,45 +3084,3 @@ exports.renderToReadableStream = function (model, turbopackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, turbopackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      turbopackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var stream = new ReadableStream(\n-          {\n-            type: \"bytes\",\n-            pull: function (controller) {\n-              startFlowing(request, controller);\n-            },\n-            cancel: function (reason) {\n-              request.destination = null;\n-              abort(request, reason);\n-            }\n-          },\n-          { highWaterMark: 0 }\n-        );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "9b7a52fa841929cda3f409cccc812cadde7b8bb4",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.node.development.js",
            "status": "modified",
            "additions": 229,
            "deletions": 177,
            "changes": 406,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.node.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1342,9 +1342,11 @@\n           if (request.status === ABORTING)\n             return (\n               request.abortableTasks.delete(newTask),\n-              (task = request.fatalError),\n-              abortTask(newTask),\n-              finishAbortedTask(newTask, request, task),\n+              21 === request.type\n+                ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+                : ((task = request.fatalError),\n+                  abortTask(newTask),\n+                  finishAbortedTask(newTask, request, task)),\n               newTask.id\n             );\n           \"string\" !== typeof thenable.status &&\n@@ -1416,8 +1418,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortStream);\n           signal = signal.reason;\n-          erroredTask(request, streamTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -1503,8 +1508,12 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortIterable);\n           var reason = signal.reason;\n-          erroredTask(request, streamTask, signal.reason);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal.reason),\n+              enqueueFlush(request));\n           \"function\" === typeof iterator.throw &&\n             iterator.throw(reason).then(error, error);\n         }\n@@ -2479,8 +2488,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortBlob);\n           signal = signal.reason;\n-          erroredTask(request, newTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(newTask),\n+              haltTask(newTask),\n+              finishHaltedTask(newTask, request))\n+            : (erroredTask(request, newTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -2515,12 +2527,19 @@\n           null !== parent &&\n           (parent.$$typeof === REACT_ELEMENT_TYPE ||\n             parent.$$typeof === REACT_LAZY_TYPE);\n-        if (request.status === ABORTING)\n-          return (\n-            (task.status = 3),\n-            (task = request.fatalError),\n-            parent ? serializeLazyID(task) : serializeByValueID(task)\n-          );\n+        if (request.status === ABORTING) {\n+          task.status = 3;\n+          if (21 === request.type)\n+            return (\n+              (task = request.nextChunkId++),\n+              (task = parent\n+                ? serializeLazyID(task)\n+                : serializeByValueID(task)),\n+              task\n+            );\n+          task = request.fatalError;\n+          return parent ? serializeLazyID(task) : serializeByValueID(task);\n+        }\n         key =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -3684,6 +3703,39 @@\n       null !== sequence &&\n         emitAsyncSequence(request, task, sequence, thenable, null, null);\n     }\n+    function forwardDebugInfoFromAbortedTask(request, task) {\n+      var model = task.model;\n+      if (\"object\" === typeof model && null !== model) {\n+        var debugInfo;\n+        (debugInfo = model._debugInfo) &&\n+          forwardDebugInfo(request, task, debugInfo);\n+        var thenable = null;\n+        \"function\" === typeof model.then\n+          ? (thenable = model)\n+          : model.$$typeof === REACT_LAZY_TYPE &&\n+            ((model = model._payload),\n+            \"function\" === typeof model.then && (thenable = model));\n+        if (\n+          null !== thenable &&\n+          ((model = getAsyncSequenceFromPromise(thenable)), null !== model)\n+        ) {\n+          for (\n+            thenable = model;\n+            4 === thenable.tag && null !== thenable.awaited;\n+\n+          )\n+            thenable = thenable.awaited;\n+          3 === thenable.tag\n+            ? (serializeIONode(request, thenable, null),\n+              request.pendingChunks++,\n+              (debugInfo = (0, request.environmentName)()),\n+              (debugInfo = { awaited: thenable, env: debugInfo }),\n+              advanceTaskTime(request, task, task.time),\n+              emitDebugChunk(request, task.id, debugInfo))\n+            : emitAsyncSequence(request, task, model, debugInfo, null, null);\n+        }\n+      }\n+    }\n     function emitTimingChunk(request, id, timestamp) {\n       request.pendingChunks++;\n       var json = '{\"time\":' + (timestamp - request.timeOrigin) + \"}\";\n@@ -3808,13 +3860,19 @@\n           request.abortableTasks.delete(task);\n           callOnAllReadyIfReady(request);\n         } catch (thrownValue) {\n-          if (request.status === ABORTING) {\n-            request.abortableTasks.delete(task);\n-            task.status = 0;\n-            var errorId = request.fatalError;\n-            abortTask(task);\n-            finishAbortedTask(task, request, errorId);\n-          } else {\n+          if (request.status === ABORTING)\n+            if (\n+              (request.abortableTasks.delete(task),\n+              (task.status = 0),\n+              21 === request.type)\n+            )\n+              haltTask(task), finishHaltedTask(task, request);\n+            else {\n+              var errorId = request.fatalError;\n+              abortTask(task);\n+              finishAbortedTask(task, request, errorId);\n+            }\n+          else {\n             var x =\n               thrownValue === SuspenseException\n                 ? getSuspendedThenable()\n@@ -3871,43 +3929,20 @@\n       0 === task.status && (task.status = 3);\n     }\n     function finishAbortedTask(task, request, errorId) {\n-      if (3 === task.status) {\n-        var model = task.model;\n-        if (\"object\" === typeof model && null !== model) {\n-          var debugInfo;\n-          (debugInfo = model._debugInfo) &&\n-            forwardDebugInfo(request, task, debugInfo);\n-          var thenable = null;\n-          \"function\" === typeof model.then\n-            ? (thenable = model)\n-            : model.$$typeof === REACT_LAZY_TYPE &&\n-              ((model = model._payload),\n-              \"function\" === typeof model.then && (thenable = model));\n-          if (\n-            null !== thenable &&\n-            ((model = getAsyncSequenceFromPromise(thenable)), null !== model)\n-          ) {\n-            for (\n-              thenable = model;\n-              4 === thenable.tag && null !== thenable.awaited;\n-\n-            )\n-              thenable = thenable.awaited;\n-            3 === thenable.tag\n-              ? (serializeIONode(request, thenable, null),\n-                request.pendingChunks++,\n-                (debugInfo = (0, request.environmentName)()),\n-                (debugInfo = { awaited: thenable, env: debugInfo }),\n-                advanceTaskTime(request, task, task.time),\n-                emitDebugChunk(request, task.id, debugInfo))\n-              : emitAsyncSequence(request, task, model, debugInfo, null, null);\n-          }\n-        }\n-        task.timed && markOperationEndTime(request, task, request.abortTime);\n-        errorId = serializeByValueID(errorId);\n-        task = encodeReferenceChunk(request, task.id, errorId);\n-        request.completedErrorChunks.push(task);\n-      }\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        task.timed && markOperationEndTime(request, task, request.abortTime),\n+        (errorId = serializeByValueID(errorId)),\n+        (task = encodeReferenceChunk(request, task.id, errorId)),\n+        request.completedErrorChunks.push(task));\n+    }\n+    function haltTask(task) {\n+      0 === task.status && (task.status = 3);\n+    }\n+    function finishHaltedTask(task, request) {\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        request.pendingChunks--);\n     }\n     function flushCompletedChunks(request) {\n       if (null !== request.debugDestination) {\n@@ -4088,6 +4123,18 @@\n         }\n       }\n     }\n+    function finishHalt(request, abortedTasks) {\n+      try {\n+        abortedTasks.forEach(function (task) {\n+          return finishHaltedTask(task, request);\n+        });\n+        var onAllReady = request.onAllReady;\n+        onAllReady();\n+        flushCompletedChunks(request);\n+      } catch (error) {\n+        logRecoverableError(request, error, null), fatalError(request, error);\n+      }\n+    }\n     function finishAbort(request, abortedTasks, errorId) {\n       try {\n         abortedTasks.forEach(function (task) {\n@@ -4107,31 +4154,40 @@\n           request.abortTime = performance.now();\n           request.cacheController.abort(reason);\n           var abortableTasks = request.abortableTasks;\n-          if (0 < abortableTasks.size) {\n-            var error =\n-                void 0 === reason\n-                  ? Error(\n-                      \"The render was aborted by the server without a reason.\"\n-                    )\n-                  : \"object\" === typeof reason &&\n-                      null !== reason &&\n-                      \"function\" === typeof reason.then\n+          if (0 < abortableTasks.size)\n+            if (21 === request.type)\n+              abortableTasks.forEach(function (task) {\n+                return haltTask(task, request);\n+              }),\n+                setImmediate(function () {\n+                  return finishHalt(request, abortableTasks);\n+                });\n+            else {\n+              var error =\n+                  void 0 === reason\n                     ? Error(\n-                        \"The render was aborted by the server with a promise.\"\n+                        \"The render was aborted by the server without a reason.\"\n                       )\n-                    : reason,\n-              digest = logRecoverableError(request, error, null),\n-              _errorId2 = request.nextChunkId++;\n-            request.fatalError = _errorId2;\n-            request.pendingChunks++;\n-            emitErrorChunk(request, _errorId2, digest, error, !1, null);\n-            abortableTasks.forEach(function (task) {\n-              return abortTask(task, request, _errorId2);\n-            });\n-            setImmediate(function () {\n-              return finishAbort(request, abortableTasks, _errorId2);\n-            });\n-          } else {\n+                    : \"object\" === typeof reason &&\n+                        null !== reason &&\n+                        \"function\" === typeof reason.then\n+                      ? Error(\n+                          \"The render was aborted by the server with a promise.\"\n+                        )\n+                      : reason,\n+                digest = logRecoverableError(request, error, null),\n+                _errorId2 = request.nextChunkId++;\n+              request.fatalError = _errorId2;\n+              request.pendingChunks++;\n+              emitErrorChunk(request, _errorId2, digest, error, !1, null);\n+              abortableTasks.forEach(function (task) {\n+                return abortTask(task, request, _errorId2);\n+              });\n+              setImmediate(function () {\n+                return finishAbort(request, abortableTasks, _errorId2);\n+              });\n+            }\n+          else {\n             var onAllReady = request.onAllReady;\n             onAllReady();\n             flushCompletedChunks(request);\n@@ -5835,12 +5891,12 @@\n             \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n           );\n         pendingFiles++;\n-        var JSCompiler_object_inline_chunks_246 = [];\n+        var JSCompiler_object_inline_chunks_250 = [];\n         value.on(\"data\", function (chunk) {\n-          JSCompiler_object_inline_chunks_246.push(chunk);\n+          JSCompiler_object_inline_chunks_250.push(chunk);\n         });\n         value.on(\"end\", function () {\n-          var blob = new Blob(JSCompiler_object_inline_chunks_246, {\n+          var blob = new Blob(JSCompiler_object_inline_chunks_250, {\n             type: mimeType\n           });\n           response._formData.append(name, blob, filename);\n@@ -5864,6 +5920,94 @@\n       });\n       return getChunk(response, 0);\n     };\n+    exports.prerender = function (model, turbopackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          turbopackMap,\n+          function () {\n+            var writable,\n+              stream = new ReadableStream(\n+                {\n+                  type: \"bytes\",\n+                  start: function (controller) {\n+                    writable =\n+                      createFakeWritableFromReadableStreamController(\n+                        controller\n+                      );\n+                  },\n+                  pull: function () {\n+                    startFlowing(request, writable);\n+                  },\n+                  cancel: function (reason) {\n+                    request.destination = null;\n+                    abort(request, reason);\n+                  }\n+                },\n+                { highWaterMark: 0 }\n+              );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.prerenderToNodeStream = function (model, turbopackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          turbopackMap,\n+          function () {\n+            var readable = new stream.Readable({\n+                read: function () {\n+                  startFlowing(request, writable);\n+                }\n+              }),\n+              writable = createFakeWritableFromNodeReadable(readable);\n+            resolve({ prelude: readable });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -6023,96 +6167,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, turbopackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          turbopackMap,\n-          function () {\n-            var writable,\n-              stream = new ReadableStream(\n-                {\n-                  type: \"bytes\",\n-                  start: function (controller) {\n-                    writable =\n-                      createFakeWritableFromReadableStreamController(\n-                        controller\n-                      );\n-                  },\n-                  pull: function () {\n-                    startFlowing(request, writable);\n-                  },\n-                  cancel: function (reason) {\n-                    request.destination = null;\n-                    abort(request, reason);\n-                  }\n-                },\n-                { highWaterMark: 0 }\n-              );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n-    exports.unstable_prerenderToNodeStream = function (\n-      model,\n-      turbopackMap,\n-      options\n-    ) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          turbopackMap,\n-          function () {\n-            var readable = new stream.Readable({\n-                read: function () {\n-                  startFlowing(request, writable);\n-                }\n-              }),\n-              writable = createFakeWritableFromNodeReadable(readable);\n-            resolve({ prelude: readable });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "3ab91f0f9ef3de6d3bdd3b54def77364e40a696f",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.node.production.js",
            "status": "modified",
            "additions": 189,
            "deletions": 135,
            "changes": 324,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fcjs%2Freact-server-dom-turbopack-server.node.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -915,9 +915,11 @@ function serializeThenable(request, task, thenable) {\n       if (12 === request.status)\n         return (\n           request.abortableTasks.delete(newTask),\n-          (task = request.fatalError),\n-          abortTask(newTask),\n-          finishAbortedTask(newTask, request, task),\n+          21 === request.type\n+            ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+            : ((task = request.fatalError),\n+              abortTask(newTask),\n+              finishAbortedTask(newTask, request, task)),\n           newTask.id\n         );\n       \"string\" !== typeof thenable.status &&\n@@ -983,8 +985,11 @@ function serializeReadableStream(request, task, stream) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortStream);\n       signal = signal.reason;\n-      erroredTask(request, streamTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1069,8 +1074,12 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortIterable);\n       var reason = signal.reason;\n-      erroredTask(request, streamTask, signal.reason);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal.reason),\n+          enqueueFlush(request));\n       \"function\" === typeof iterator.throw &&\n         iterator.throw(reason).then(error, error);\n     }\n@@ -1199,7 +1208,7 @@ function deferTask(request, task) {\n     request.abortableTasks\n   );\n   pingTask(request, task);\n-  return \"$L\" + task.id.toString(16);\n+  return serializeLazyID(task.id);\n }\n function renderElement(request, task, type, key, ref, props) {\n   if (null !== ref && void 0 !== ref)\n@@ -1319,10 +1328,16 @@ function createTask(\n           12 === request.status)\n         )\n           (task.status = 3),\n-            (prevKeyPath = request.fatalError),\n-            (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n-              : serializeByValueID(prevKeyPath));\n+            21 === request.type\n+              ? ((prevKeyPath = request.nextChunkId++),\n+                (prevKeyPath = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)),\n+                (JSCompiler_inline_result = prevKeyPath))\n+              : ((prevKeyPath = request.fatalError),\n+                (JSCompiler_inline_result = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)));\n         else if (\n           ((value =\n             thrownValue === SuspenseException\n@@ -1347,7 +1362,7 @@ function createTask(\n           task.keyPath = prevKeyPath;\n           task.implicitSlot = prevImplicitSlot;\n           JSCompiler_inline_result = parentPropertyName\n-            ? \"$L\" + JSCompiler_inline_result.id.toString(16)\n+            ? serializeLazyID(JSCompiler_inline_result.id)\n             : serializeByValueID(JSCompiler_inline_result.id);\n         } else\n           (task.keyPath = prevKeyPath),\n@@ -1357,7 +1372,7 @@ function createTask(\n             (prevImplicitSlot = logRecoverableError(request, value, task)),\n             emitErrorChunk(request, prevKeyPath, prevImplicitSlot),\n             (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n+              ? serializeLazyID(prevKeyPath)\n               : serializeByValueID(prevKeyPath));\n       }\n       return JSCompiler_inline_result;\n@@ -1370,6 +1385,9 @@ function createTask(\n function serializeByValueID(id) {\n   return \"$\" + id.toString(16);\n }\n+function serializeLazyID(id) {\n+  return \"$L\" + id.toString(16);\n+}\n function encodeReferenceChunk(request, id, reference) {\n   request = stringify(reference);\n   return id.toString(16) + \":\" + request + \"\\n\";\n@@ -1387,7 +1405,7 @@ function serializeClientReference(\n     existingId = writtenClientReferences.get(clientReferenceKey);\n   if (void 0 !== existingId)\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + existingId.toString(16)\n+      ? serializeLazyID(existingId)\n       : serializeByValueID(existingId);\n   try {\n     var config = request.bundlerConfig,\n@@ -1424,7 +1442,7 @@ function serializeClientReference(\n     request.completedImportChunks.push(processedChunk);\n     writtenClientReferences.set(clientReferenceKey, importId);\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + importId.toString(16)\n+      ? serializeLazyID(importId)\n       : serializeByValueID(importId);\n   } catch (x) {\n     return (\n@@ -1477,8 +1495,11 @@ function serializeBlob(request, blob) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortBlob);\n       signal = signal.reason;\n-      erroredTask(request, newTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(newTask),\n+          haltTask(newTask),\n+          finishHaltedTask(newTask, request))\n+        : (erroredTask(request, newTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1919,13 +1940,19 @@ function retryTask(request, task) {\n       request.abortableTasks.delete(task);\n       callOnAllReadyIfReady(request);\n     } catch (thrownValue) {\n-      if (12 === request.status) {\n-        request.abortableTasks.delete(task);\n-        task.status = 0;\n-        var errorId = request.fatalError;\n-        abortTask(task);\n-        finishAbortedTask(task, request, errorId);\n-      } else {\n+      if (12 === request.status)\n+        if (\n+          (request.abortableTasks.delete(task),\n+          (task.status = 0),\n+          21 === request.type)\n+        )\n+          haltTask(task), finishHaltedTask(task, request);\n+        else {\n+          var errorId = request.fatalError;\n+          abortTask(task);\n+          finishAbortedTask(task, request, errorId);\n+        }\n+      else {\n         var x =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -1982,6 +2009,12 @@ function finishAbortedTask(task, request, errorId) {\n     (task = encodeReferenceChunk(request, task.id, errorId)),\n     request.completedErrorChunks.push(task));\n }\n+function haltTask(task) {\n+  0 === task.status && (task.status = 3);\n+}\n+function finishHaltedTask(task, request) {\n+  3 === task.status && request.pendingChunks--;\n+}\n function flushCompletedChunks(request) {\n   var destination = request.destination;\n   if (null !== destination) {\n@@ -2091,6 +2124,18 @@ function startFlowing(request, destination) {\n     }\n   }\n }\n+function finishHalt(request, abortedTasks) {\n+  try {\n+    abortedTasks.forEach(function (task) {\n+      return finishHaltedTask(task, request);\n+    });\n+    var onAllReady = request.onAllReady;\n+    onAllReady();\n+    flushCompletedChunks(request);\n+  } catch (error) {\n+    logRecoverableError(request, error, null), fatalError(request, error);\n+  }\n+}\n function finishAbort(request, abortedTasks, errorId) {\n   try {\n     abortedTasks.forEach(function (task) {\n@@ -2109,27 +2154,40 @@ function abort(request, reason) {\n       request.status = 12;\n       request.cacheController.abort(reason);\n       var abortableTasks = request.abortableTasks;\n-      if (0 < abortableTasks.size) {\n-        var error =\n-            void 0 === reason\n-              ? Error(\"The render was aborted by the server without a reason.\")\n-              : \"object\" === typeof reason &&\n-                  null !== reason &&\n-                  \"function\" === typeof reason.then\n-                ? Error(\"The render was aborted by the server with a promise.\")\n-                : reason,\n-          digest = logRecoverableError(request, error, null),\n-          errorId = request.nextChunkId++;\n-        request.fatalError = errorId;\n-        request.pendingChunks++;\n-        emitErrorChunk(request, errorId, digest, error, !1, null);\n-        abortableTasks.forEach(function (task) {\n-          return abortTask(task, request, errorId);\n-        });\n-        setImmediate(function () {\n-          return finishAbort(request, abortableTasks, errorId);\n-        });\n-      } else {\n+      if (0 < abortableTasks.size)\n+        if (21 === request.type)\n+          abortableTasks.forEach(function (task) {\n+            return haltTask(task, request);\n+          }),\n+            setImmediate(function () {\n+              return finishHalt(request, abortableTasks);\n+            });\n+        else {\n+          var error =\n+              void 0 === reason\n+                ? Error(\n+                    \"The render was aborted by the server without a reason.\"\n+                  )\n+                : \"object\" === typeof reason &&\n+                    null !== reason &&\n+                    \"function\" === typeof reason.then\n+                  ? Error(\n+                      \"The render was aborted by the server with a promise.\"\n+                    )\n+                  : reason,\n+            digest = logRecoverableError(request, error, null),\n+            errorId = request.nextChunkId++;\n+          request.fatalError = errorId;\n+          request.pendingChunks++;\n+          emitErrorChunk(request, errorId, digest, error, !1, null);\n+          abortableTasks.forEach(function (task) {\n+            return abortTask(task, request, errorId);\n+          });\n+          setImmediate(function () {\n+            return finishAbort(request, abortableTasks, errorId);\n+          });\n+        }\n+      else {\n         var onAllReady = request.onAllReady;\n         onAllReady();\n         flushCompletedChunks(request);\n@@ -3015,12 +3073,12 @@ exports.decodeReplyFromBusboy = function (busboyStream, turbopackMap, options) {\n         \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n       );\n     pendingFiles++;\n-    var JSCompiler_object_inline_chunks_270 = [];\n+    var JSCompiler_object_inline_chunks_274 = [];\n     value.on(\"data\", function (chunk) {\n-      JSCompiler_object_inline_chunks_270.push(chunk);\n+      JSCompiler_object_inline_chunks_274.push(chunk);\n     });\n     value.on(\"end\", function () {\n-      var blob = new Blob(JSCompiler_object_inline_chunks_270, {\n+      var blob = new Blob(JSCompiler_object_inline_chunks_274, {\n         type: mimeType\n       });\n       response._formData.append(name, blob, filename);\n@@ -3040,6 +3098,88 @@ exports.decodeReplyFromBusboy = function (busboyStream, turbopackMap, options) {\n   });\n   return getChunk(response, 0);\n };\n+exports.prerender = function (model, turbopackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      turbopackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var writable,\n+          stream = new ReadableStream(\n+            {\n+              type: \"bytes\",\n+              start: function (controller) {\n+                writable =\n+                  createFakeWritableFromReadableStreamController(controller);\n+              },\n+              pull: function () {\n+                startFlowing(request, writable);\n+              },\n+              cancel: function (reason) {\n+                request.destination = null;\n+                abort(request, reason);\n+              }\n+            },\n+            { highWaterMark: 0 }\n+          );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.prerenderToNodeStream = function (model, turbopackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      turbopackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var readable = new stream.Readable({\n+            read: function () {\n+              startFlowing(request, writable);\n+            }\n+          }),\n+          writable = createFakeWritableFromNodeReadable(readable);\n+        resolve({ prelude: readable });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -3145,89 +3285,3 @@ exports.renderToReadableStream = function (model, turbopackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, turbopackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      turbopackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var writable,\n-          stream = new ReadableStream(\n-            {\n-              type: \"bytes\",\n-              start: function (controller) {\n-                writable =\n-                  createFakeWritableFromReadableStreamController(controller);\n-              },\n-              pull: function () {\n-                startFlowing(request, writable);\n-              },\n-              cancel: function (reason) {\n-                request.destination = null;\n-                abort(request, reason);\n-              }\n-            },\n-            { highWaterMark: 0 }\n-          );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};\n-exports.unstable_prerenderToNodeStream = function (\n-  model,\n-  turbopackMap,\n-  options\n-) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      turbopackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var readable = new stream.Readable({\n-            read: function () {\n-              startFlowing(request, writable);\n-            }\n-          }),\n-          writable = createFakeWritableFromNodeReadable(readable);\n-        resolve({ prelude: readable });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "597c920f96cbb04659c46bd5f36311163ae23bdb",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fpackage.json?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -48,7 +48,7 @@\n     \"neo-async\": \"^2.6.1\"\n   },\n   \"peerDependencies\": {\n-    \"react\": \"19.2.0-canary-548235db-20251001\",\n-    \"react-dom\": \"19.2.0-canary-548235db-20251001\"\n+    \"react\": \"19.2.0-canary-1bd1f01f-20251001\",\n+    \"react-dom\": \"19.2.0-canary-1bd1f01f-20251001\"\n   }\n }\n\\ No newline at end of file"
        },
        {
            "sha": "d6acca4d6ec5d4fdb07fde8d9b71dc5840207c07",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/static.browser.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fstatic.browser.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fstatic.browser.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fstatic.browser.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,6 +7,4 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-turbopack-server.browser.development.js');\n }\n \n-if (s.unstable_prerender) {\n-  exports.unstable_prerender = s.unstable_prerender;\n-}\n+exports.prerender = s.prerender;"
        },
        {
            "sha": "acd8ad68d74e74171700b167031c109232568acb",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/static.edge.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fstatic.edge.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fstatic.edge.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fstatic.edge.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,6 +7,4 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-turbopack-server.edge.development.js');\n }\n \n-if (s.unstable_prerender) {\n-  exports.unstable_prerender = s.unstable_prerender;\n-}\n+exports.prerender = s.prerender;"
        },
        {
            "sha": "f082e275e0120204a89dbe3c0ca11b122880929f",
            "filename": "packages/next/src/compiled/react-server-dom-turbopack/static.node.js",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fstatic.node.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fstatic.node.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-turbopack%2Fstatic.node.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,9 +7,5 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-turbopack-server.node.development.js');\n }\n \n-if (s.unstable_prerender) {\n-  exports.unstable_prerender = s.unstable_prerender;\n-}\n-if (s.unstable_prerenderToNodeStream) {\n-  exports.unstable_prerenderToNodeStream = s.unstable_prerenderToNodeStream;\n-}\n+exports.prerender = s.prerender;\n+exports.prerenderToNodeStream = s.prerenderToNodeStream;"
        },
        {
            "sha": "0a0cc765546ea1f9577aafcf0b1b55d2015f8b2a",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-client.browser.development.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-client.browser.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -4872,10 +4872,10 @@\n       return hook.checkDCE ? !0 : !1;\n     })({\n       bundleType: 1,\n-      version: \"19.2.0-experimental-548235db-20251001\",\n+      version: \"19.2.0-experimental-1bd1f01f-20251001\",\n       rendererPackageName: \"react-server-dom-webpack\",\n       currentDispatcherRef: ReactSharedInternals,\n-      reconcilerVersion: \"19.2.0-experimental-548235db-20251001\",\n+      reconcilerVersion: \"19.2.0-experimental-1bd1f01f-20251001\",\n       getCurrentComponentInfo: function () {\n         return currentOwnerInDEV;\n       }"
        },
        {
            "sha": "f4341b6f42a75c474bf86fb261887a4e92922f93",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.browser.development.js",
            "status": "modified",
            "additions": 44,
            "deletions": 44,
            "changes": 88,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.browser.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -5267,6 +5267,50 @@\n       close(body);\n       return webpackMap;\n     };\n+    exports.prerender = function (model, webpackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          webpackMap,\n+          function () {\n+            var stream = new ReadableStream(\n+              {\n+                type: \"bytes\",\n+                pull: function (controller) {\n+                  startFlowing(request, controller);\n+                },\n+                cancel: function (reason) {\n+                  request.destination = null;\n+                  abort(request, reason);\n+                }\n+              },\n+              { highWaterMark: 0 }\n+            );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -5367,48 +5411,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, webpackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          webpackMap,\n-          function () {\n-            var stream = new ReadableStream(\n-              {\n-                type: \"bytes\",\n-                pull: function (controller) {\n-                  startFlowing(request, controller);\n-                },\n-                cancel: function (reason) {\n-                  request.destination = null;\n-                  abort(request, reason);\n-                }\n-              },\n-              { highWaterMark: 0 }\n-            );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "eda8aad02a258087ce4db600e9122132b1188b13",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.browser.production.js",
            "status": "modified",
            "additions": 42,
            "deletions": 42,
            "changes": 84,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.browser.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -3045,6 +3045,48 @@ exports.decodeReply = function (body, webpackMap, options) {\n   close(body);\n   return webpackMap;\n };\n+exports.prerender = function (model, webpackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      webpackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var stream = new ReadableStream(\n+          {\n+            type: \"bytes\",\n+            pull: function (controller) {\n+              startFlowing(request, controller);\n+            },\n+            cancel: function (reason) {\n+              request.destination = null;\n+              abort(request, reason);\n+            }\n+          },\n+          { highWaterMark: 0 }\n+        );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -3107,45 +3149,3 @@ exports.renderToReadableStream = function (model, webpackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, webpackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      webpackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var stream = new ReadableStream(\n-          {\n-            type: \"bytes\",\n-            pull: function (controller) {\n-              startFlowing(request, controller);\n-            },\n-            cancel: function (reason) {\n-              request.destination = null;\n-              abort(request, reason);\n-            }\n-          },\n-          { highWaterMark: 0 }\n-        );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "5630aed77cc54936cc2d2911a5869964fcc4bee2",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.edge.development.js",
            "status": "modified",
            "additions": 44,
            "deletions": 44,
            "changes": 88,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.edge.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -5379,6 +5379,50 @@\n       iterator.next().then(progress, error);\n       return getChunk(response$jscomp$0, 0);\n     };\n+    exports.prerender = function (model, webpackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          webpackMap,\n+          function () {\n+            var stream = new ReadableStream(\n+              {\n+                type: \"bytes\",\n+                pull: function (controller) {\n+                  startFlowing(request, controller);\n+                },\n+                cancel: function (reason) {\n+                  request.destination = null;\n+                  abort(request, reason);\n+                }\n+              },\n+              { highWaterMark: 0 }\n+            );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -5479,48 +5523,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, webpackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          webpackMap,\n-          function () {\n-            var stream = new ReadableStream(\n-              {\n-                type: \"bytes\",\n-                pull: function (controller) {\n-                  startFlowing(request, controller);\n-                },\n-                cancel: function (reason) {\n-                  request.destination = null;\n-                  abort(request, reason);\n-                }\n-              },\n-              { highWaterMark: 0 }\n-            );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "c7dc86994f350ea117b92e3306f426608cb616cf",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.edge.production.js",
            "status": "modified",
            "additions": 42,
            "deletions": 42,
            "changes": 84,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.edge.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -3080,6 +3080,48 @@ exports.decodeReplyFromAsyncIterable = function (\n   iterator.next().then(progress, error);\n   return getChunk(response, 0);\n };\n+exports.prerender = function (model, webpackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      webpackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var stream = new ReadableStream(\n+          {\n+            type: \"bytes\",\n+            pull: function (controller) {\n+              startFlowing(request, controller);\n+            },\n+            cancel: function (reason) {\n+              request.destination = null;\n+              abort(request, reason);\n+            }\n+          },\n+          { highWaterMark: 0 }\n+        );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -3142,45 +3184,3 @@ exports.renderToReadableStream = function (model, webpackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, webpackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      webpackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var stream = new ReadableStream(\n-          {\n-            type: \"bytes\",\n-            pull: function (controller) {\n-              startFlowing(request, controller);\n-            },\n-            cancel: function (reason) {\n-              request.destination = null;\n-              abort(request, reason);\n-            }\n-          },\n-          { highWaterMark: 0 }\n-        );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "f97b6f0647ab22a4dadf552ab72c633292c45672",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.node.development.js",
            "status": "modified",
            "additions": 88,
            "deletions": 92,
            "changes": 180,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -6045,6 +6045,94 @@\n       });\n       return getChunk(response, 0);\n     };\n+    exports.prerender = function (model, webpackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          webpackMap,\n+          function () {\n+            var writable,\n+              stream = new ReadableStream(\n+                {\n+                  type: \"bytes\",\n+                  start: function (controller) {\n+                    writable =\n+                      createFakeWritableFromReadableStreamController(\n+                        controller\n+                      );\n+                  },\n+                  pull: function () {\n+                    startFlowing(request, writable);\n+                  },\n+                  cancel: function (reason) {\n+                    request.destination = null;\n+                    abort(request, reason);\n+                  }\n+                },\n+                { highWaterMark: 0 }\n+              );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.prerenderToNodeStream = function (model, webpackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          webpackMap,\n+          function () {\n+            var readable = new stream.Readable({\n+                read: function () {\n+                  startFlowing(request, writable);\n+                }\n+              }),\n+              writable = createFakeWritableFromNodeReadable(readable);\n+            resolve({ prelude: readable });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -6203,96 +6291,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, webpackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          webpackMap,\n-          function () {\n-            var writable,\n-              stream = new ReadableStream(\n-                {\n-                  type: \"bytes\",\n-                  start: function (controller) {\n-                    writable =\n-                      createFakeWritableFromReadableStreamController(\n-                        controller\n-                      );\n-                  },\n-                  pull: function () {\n-                    startFlowing(request, writable);\n-                  },\n-                  cancel: function (reason) {\n-                    request.destination = null;\n-                    abort(request, reason);\n-                  }\n-                },\n-                { highWaterMark: 0 }\n-              );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n-    exports.unstable_prerenderToNodeStream = function (\n-      model,\n-      webpackMap,\n-      options\n-    ) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          webpackMap,\n-          function () {\n-            var readable = new stream.Readable({\n-                read: function () {\n-                  startFlowing(request, writable);\n-                }\n-              }),\n-              writable = createFakeWritableFromNodeReadable(readable);\n-            resolve({ prelude: readable });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "0261711da996d38cc23302f70754a885cb19ccb9",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.node.production.js",
            "status": "modified",
            "additions": 82,
            "deletions": 82,
            "changes": 164,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -3194,6 +3194,88 @@ exports.decodeReplyFromBusboy = function (busboyStream, webpackMap, options) {\n   });\n   return getChunk(response, 0);\n };\n+exports.prerender = function (model, webpackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      webpackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var writable,\n+          stream = new ReadableStream(\n+            {\n+              type: \"bytes\",\n+              start: function (controller) {\n+                writable =\n+                  createFakeWritableFromReadableStreamController(controller);\n+              },\n+              pull: function () {\n+                startFlowing(request, writable);\n+              },\n+              cancel: function (reason) {\n+                request.destination = null;\n+                abort(request, reason);\n+              }\n+            },\n+            { highWaterMark: 0 }\n+          );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.prerenderToNodeStream = function (model, webpackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      webpackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var readable = new stream.Readable({\n+            read: function () {\n+              startFlowing(request, writable);\n+            }\n+          }),\n+          writable = createFakeWritableFromNodeReadable(readable);\n+        resolve({ prelude: readable });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -3299,85 +3381,3 @@ exports.renderToReadableStream = function (model, webpackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, webpackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      webpackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var writable,\n-          stream = new ReadableStream(\n-            {\n-              type: \"bytes\",\n-              start: function (controller) {\n-                writable =\n-                  createFakeWritableFromReadableStreamController(controller);\n-              },\n-              pull: function () {\n-                startFlowing(request, writable);\n-              },\n-              cancel: function (reason) {\n-                request.destination = null;\n-                abort(request, reason);\n-              }\n-            },\n-            { highWaterMark: 0 }\n-          );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};\n-exports.unstable_prerenderToNodeStream = function (model, webpackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      webpackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var readable = new stream.Readable({\n-            read: function () {\n-              startFlowing(request, writable);\n-            }\n-          }),\n-          writable = createFakeWritableFromNodeReadable(readable);\n-        resolve({ prelude: readable });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "bdcb349a815068a6b3141440196e436a332978c2",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.node.unbundled.development.js",
            "status": "modified",
            "additions": 88,
            "deletions": 92,
            "changes": 180,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -6008,6 +6008,94 @@\n       });\n       return getChunk(response, 0);\n     };\n+    exports.prerender = function (model, webpackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          webpackMap,\n+          function () {\n+            var writable,\n+              stream = new ReadableStream(\n+                {\n+                  type: \"bytes\",\n+                  start: function (controller) {\n+                    writable =\n+                      createFakeWritableFromReadableStreamController(\n+                        controller\n+                      );\n+                  },\n+                  pull: function () {\n+                    startFlowing(request, writable);\n+                  },\n+                  cancel: function (reason) {\n+                    request.destination = null;\n+                    abort(request, reason);\n+                  }\n+                },\n+                { highWaterMark: 0 }\n+              );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.prerenderToNodeStream = function (model, webpackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          webpackMap,\n+          function () {\n+            var readable = new stream.Readable({\n+                read: function () {\n+                  startFlowing(request, writable);\n+                }\n+              }),\n+              writable = createFakeWritableFromNodeReadable(readable);\n+            resolve({ prelude: readable });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -6166,96 +6254,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, webpackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          webpackMap,\n-          function () {\n-            var writable,\n-              stream = new ReadableStream(\n-                {\n-                  type: \"bytes\",\n-                  start: function (controller) {\n-                    writable =\n-                      createFakeWritableFromReadableStreamController(\n-                        controller\n-                      );\n-                  },\n-                  pull: function () {\n-                    startFlowing(request, writable);\n-                  },\n-                  cancel: function (reason) {\n-                    request.destination = null;\n-                    abort(request, reason);\n-                  }\n-                },\n-                { highWaterMark: 0 }\n-              );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n-    exports.unstable_prerenderToNodeStream = function (\n-      model,\n-      webpackMap,\n-      options\n-    ) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          webpackMap,\n-          function () {\n-            var readable = new stream.Readable({\n-                read: function () {\n-                  startFlowing(request, writable);\n-                }\n-              }),\n-              writable = createFakeWritableFromNodeReadable(readable);\n-            resolve({ prelude: readable });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "e0f4176294fd50cccd540ab62256bb6d81f35f81",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/cjs/react-server-dom-webpack-server.node.unbundled.production.js",
            "status": "modified",
            "additions": 82,
            "deletions": 82,
            "changes": 164,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -3160,6 +3160,88 @@ exports.decodeReplyFromBusboy = function (busboyStream, webpackMap, options) {\n   });\n   return getChunk(response, 0);\n };\n+exports.prerender = function (model, webpackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      webpackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var writable,\n+          stream = new ReadableStream(\n+            {\n+              type: \"bytes\",\n+              start: function (controller) {\n+                writable =\n+                  createFakeWritableFromReadableStreamController(controller);\n+              },\n+              pull: function () {\n+                startFlowing(request, writable);\n+              },\n+              cancel: function (reason) {\n+                request.destination = null;\n+                abort(request, reason);\n+              }\n+            },\n+            { highWaterMark: 0 }\n+          );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.prerenderToNodeStream = function (model, webpackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      webpackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var readable = new stream.Readable({\n+            read: function () {\n+              startFlowing(request, writable);\n+            }\n+          }),\n+          writable = createFakeWritableFromNodeReadable(readable);\n+        resolve({ prelude: readable });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -3265,85 +3347,3 @@ exports.renderToReadableStream = function (model, webpackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, webpackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      webpackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var writable,\n-          stream = new ReadableStream(\n-            {\n-              type: \"bytes\",\n-              start: function (controller) {\n-                writable =\n-                  createFakeWritableFromReadableStreamController(controller);\n-              },\n-              pull: function () {\n-                startFlowing(request, writable);\n-              },\n-              cancel: function (reason) {\n-                request.destination = null;\n-                abort(request, reason);\n-              }\n-            },\n-            { highWaterMark: 0 }\n-          );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};\n-exports.unstable_prerenderToNodeStream = function (model, webpackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      webpackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var readable = new stream.Readable({\n-            read: function () {\n-              startFlowing(request, writable);\n-            }\n-          }),\n-          writable = createFakeWritableFromNodeReadable(readable);\n-        resolve({ prelude: readable });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "b1229a46c2ea4e3b3b381b27a116aefee92ebd2f",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fpackage.json?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -64,8 +64,8 @@\n     \"webpack-sources\": \"^3.2.0\"\n   },\n   \"peerDependencies\": {\n-    \"react\": \"0.0.0-experimental-548235db-20251001\",\n-    \"react-dom\": \"0.0.0-experimental-548235db-20251001\",\n+    \"react\": \"0.0.0-experimental-1bd1f01f-20251001\",\n+    \"react-dom\": \"0.0.0-experimental-1bd1f01f-20251001\",\n     \"webpack\": \"^5.59.0\"\n   }\n }\n\\ No newline at end of file"
        },
        {
            "sha": "06218aec3d4376a88b796de0007277671c4bb2b8",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/static.browser.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fstatic.browser.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fstatic.browser.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fstatic.browser.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,6 +7,4 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-webpack-server.browser.development.js');\n }\n \n-if (s.unstable_prerender) {\n-  exports.unstable_prerender = s.unstable_prerender;\n-}\n+exports.prerender = s.prerender;"
        },
        {
            "sha": "df9085690aaf69b7f1e069f9c39a245e856e72ec",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/static.edge.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fstatic.edge.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fstatic.edge.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fstatic.edge.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,6 +7,4 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-webpack-server.edge.development.js');\n }\n \n-if (s.unstable_prerender) {\n-  exports.unstable_prerender = s.unstable_prerender;\n-}\n+exports.prerender = s.prerender;"
        },
        {
            "sha": "2f649d1fc514e05bce78a7f26974ff9b81f171c4",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/static.node.js",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fstatic.node.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fstatic.node.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fstatic.node.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,9 +7,5 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-webpack-server.node.development.js');\n }\n \n-if (s.unstable_prerender) {\n-  exports.unstable_prerender = s.unstable_prerender;\n-}\n-if (s.unstable_prerenderToNodeStream) {\n-  exports.unstable_prerenderToNodeStream = s.unstable_prerenderToNodeStream;\n-}\n+exports.prerender = s.prerender;\n+exports.prerenderToNodeStream = s.prerenderToNodeStream;"
        },
        {
            "sha": "850886dcd9e78fb4e424bd464dbea01fe941d502",
            "filename": "packages/next/src/compiled/react-server-dom-webpack-experimental/static.node.unbundled.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fstatic.node.unbundled.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fstatic.node.unbundled.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack-experimental%2Fstatic.node.unbundled.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,6 +7,4 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-webpack-server.node.unbundled.development.js');\n }\n \n-if (s.unstable_prerenderToNodeStream) {\n-  exports.unstable_prerenderToNodeStream = s.unstable_prerenderToNodeStream;\n-}\n+exports.prerenderToNodeStream = s.prerenderToNodeStream;"
        },
        {
            "sha": "2ebbb9ae67305225e5f7ad61b62798ee1c096b5f",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-client.browser.development.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-client.browser.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -4843,10 +4843,10 @@\n       return hook.checkDCE ? !0 : !1;\n     })({\n       bundleType: 1,\n-      version: \"19.2.0-canary-548235db-20251001\",\n+      version: \"19.2.0-canary-1bd1f01f-20251001\",\n       rendererPackageName: \"react-server-dom-webpack\",\n       currentDispatcherRef: ReactSharedInternals,\n-      reconcilerVersion: \"19.2.0-canary-548235db-20251001\",\n+      reconcilerVersion: \"19.2.0-canary-1bd1f01f-20251001\",\n       getCurrentComponentInfo: function () {\n         return currentOwnerInDEV;\n       }"
        },
        {
            "sha": "edd2388aaebf3f7a9e43fbaf1a69b80576a33b20",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.browser.development.js",
            "status": "modified",
            "additions": 156,
            "deletions": 100,
            "changes": 256,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.browser.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.browser.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.browser.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1236,9 +1236,11 @@\n           if (request.status === ABORTING)\n             return (\n               request.abortableTasks.delete(newTask),\n-              (task = request.fatalError),\n-              abortTask(newTask),\n-              finishAbortedTask(newTask, request, task),\n+              21 === request.type\n+                ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+                : ((task = request.fatalError),\n+                  abortTask(newTask),\n+                  finishAbortedTask(newTask, request, task)),\n               newTask.id\n             );\n           \"string\" !== typeof thenable.status &&\n@@ -1310,8 +1312,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortStream);\n           signal = signal.reason;\n-          erroredTask(request, streamTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -1397,8 +1402,12 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortIterable);\n           var reason = signal.reason;\n-          erroredTask(request, streamTask, signal.reason);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal.reason),\n+              enqueueFlush(request));\n           \"function\" === typeof iterator.throw &&\n             iterator.throw(reason).then(error, error);\n         }\n@@ -2206,8 +2215,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortBlob);\n           signal = signal.reason;\n-          erroredTask(request, newTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(newTask),\n+              haltTask(newTask),\n+              finishHaltedTask(newTask, request))\n+            : (erroredTask(request, newTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -2242,12 +2254,19 @@\n           null !== parent &&\n           (parent.$$typeof === REACT_ELEMENT_TYPE ||\n             parent.$$typeof === REACT_LAZY_TYPE);\n-        if (request.status === ABORTING)\n-          return (\n-            (task.status = 3),\n-            (task = request.fatalError),\n-            parent ? serializeLazyID(task) : serializeByValueID(task)\n-          );\n+        if (request.status === ABORTING) {\n+          task.status = 3;\n+          if (21 === request.type)\n+            return (\n+              (task = request.nextChunkId++),\n+              (task = parent\n+                ? serializeLazyID(task)\n+                : serializeByValueID(task)),\n+              task\n+            );\n+          task = request.fatalError;\n+          return parent ? serializeLazyID(task) : serializeByValueID(task);\n+        }\n         key =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -3318,6 +3337,13 @@\n       (thenable = thenable._debugInfo) &&\n         forwardDebugInfo(request, task, thenable);\n     }\n+    function forwardDebugInfoFromAbortedTask(request, task) {\n+      var model = task.model;\n+      \"object\" === typeof model &&\n+        null !== model &&\n+        (model = model._debugInfo) &&\n+        forwardDebugInfo(request, task, model);\n+    }\n     function emitTimingChunk(request, id, timestamp) {\n       request.pendingChunks++;\n       var json = '{\"time\":' + (timestamp - request.timeOrigin) + \"}\";\n@@ -3429,13 +3455,19 @@\n           request.abortableTasks.delete(task);\n           callOnAllReadyIfReady(request);\n         } catch (thrownValue) {\n-          if (request.status === ABORTING) {\n-            request.abortableTasks.delete(task);\n-            task.status = 0;\n-            var errorId = request.fatalError;\n-            abortTask(task);\n-            finishAbortedTask(task, request, errorId);\n-          } else {\n+          if (request.status === ABORTING)\n+            if (\n+              (request.abortableTasks.delete(task),\n+              (task.status = 0),\n+              21 === request.type)\n+            )\n+              haltTask(task), finishHaltedTask(task, request);\n+            else {\n+              var errorId = request.fatalError;\n+              abortTask(task);\n+              finishAbortedTask(task, request, errorId);\n+            }\n+          else {\n             var x =\n               thrownValue === SuspenseException\n                 ? getSuspendedThenable()\n@@ -3491,17 +3523,20 @@\n       0 === task.status && (task.status = 3);\n     }\n     function finishAbortedTask(task, request, errorId) {\n-      if (3 === task.status) {\n-        var model = task.model;\n-        \"object\" === typeof model &&\n-          null !== model &&\n-          (model = model._debugInfo) &&\n-          forwardDebugInfo(request, task, model);\n-        task.timed && markOperationEndTime(request, task, request.abortTime);\n-        errorId = serializeByValueID(errorId);\n-        task = encodeReferenceChunk(request, task.id, errorId);\n-        request.completedErrorChunks.push(task);\n-      }\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        task.timed && markOperationEndTime(request, task, request.abortTime),\n+        (errorId = serializeByValueID(errorId)),\n+        (task = encodeReferenceChunk(request, task.id, errorId)),\n+        request.completedErrorChunks.push(task));\n+    }\n+    function haltTask(task) {\n+      0 === task.status && (task.status = 3);\n+    }\n+    function finishHaltedTask(task, request) {\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        request.pendingChunks--);\n     }\n     function flushCompletedChunks(request) {\n       if (null !== request.debugDestination) {\n@@ -3667,6 +3702,18 @@\n         }\n       }\n     }\n+    function finishHalt(request, abortedTasks) {\n+      try {\n+        abortedTasks.forEach(function (task) {\n+          return finishHaltedTask(task, request);\n+        });\n+        var onAllReady = request.onAllReady;\n+        onAllReady();\n+        flushCompletedChunks(request);\n+      } catch (error) {\n+        logRecoverableError(request, error, null), fatalError(request, error);\n+      }\n+    }\n     function finishAbort(request, abortedTasks, errorId) {\n       try {\n         abortedTasks.forEach(function (task) {\n@@ -3686,31 +3733,40 @@\n           request.abortTime = performance.now();\n           request.cacheController.abort(reason);\n           var abortableTasks = request.abortableTasks;\n-          if (0 < abortableTasks.size) {\n-            var error =\n-                void 0 === reason\n-                  ? Error(\n-                      \"The render was aborted by the server without a reason.\"\n-                    )\n-                  : \"object\" === typeof reason &&\n-                      null !== reason &&\n-                      \"function\" === typeof reason.then\n+          if (0 < abortableTasks.size)\n+            if (21 === request.type)\n+              abortableTasks.forEach(function (task) {\n+                return haltTask(task, request);\n+              }),\n+                scheduleWork(function () {\n+                  return finishHalt(request, abortableTasks);\n+                });\n+            else {\n+              var error =\n+                  void 0 === reason\n                     ? Error(\n-                        \"The render was aborted by the server with a promise.\"\n+                        \"The render was aborted by the server without a reason.\"\n                       )\n-                    : reason,\n-              digest = logRecoverableError(request, error, null),\n-              _errorId2 = request.nextChunkId++;\n-            request.fatalError = _errorId2;\n-            request.pendingChunks++;\n-            emitErrorChunk(request, _errorId2, digest, error, !1, null);\n-            abortableTasks.forEach(function (task) {\n-              return abortTask(task, request, _errorId2);\n-            });\n-            scheduleWork(function () {\n-              return finishAbort(request, abortableTasks, _errorId2);\n-            });\n-          } else {\n+                    : \"object\" === typeof reason &&\n+                        null !== reason &&\n+                        \"function\" === typeof reason.then\n+                      ? Error(\n+                          \"The render was aborted by the server with a promise.\"\n+                        )\n+                      : reason,\n+                digest = logRecoverableError(request, error, null),\n+                _errorId2 = request.nextChunkId++;\n+              request.fatalError = _errorId2;\n+              request.pendingChunks++;\n+              emitErrorChunk(request, _errorId2, digest, error, !1, null);\n+              abortableTasks.forEach(function (task) {\n+                return abortTask(task, request, _errorId2);\n+              });\n+              scheduleWork(function () {\n+                return finishAbort(request, abortableTasks, _errorId2);\n+              });\n+            }\n+          else {\n             var onAllReady = request.onAllReady;\n             onAllReady();\n             flushCompletedChunks(request);\n@@ -5094,6 +5150,50 @@\n       close(body);\n       return webpackMap;\n     };\n+    exports.prerender = function (model, webpackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          webpackMap,\n+          function () {\n+            var stream = new ReadableStream(\n+              {\n+                type: \"bytes\",\n+                pull: function (controller) {\n+                  startFlowing(request, controller);\n+                },\n+                cancel: function (reason) {\n+                  request.destination = null;\n+                  abort(request, reason);\n+                }\n+              },\n+              { highWaterMark: 0 }\n+            );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -5194,48 +5294,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, webpackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          webpackMap,\n-          function () {\n-            var stream = new ReadableStream(\n-              {\n-                type: \"bytes\",\n-                pull: function (controller) {\n-                  startFlowing(request, controller);\n-                },\n-                cancel: function (reason) {\n-                  request.destination = null;\n-                  abort(request, reason);\n-                }\n-              },\n-              { highWaterMark: 0 }\n-            );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "948d399e8a1c8992180ec60209ca7c9aca4fe8ca",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.browser.production.js",
            "status": "modified",
            "additions": 146,
            "deletions": 88,
            "changes": 234,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.browser.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.browser.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.browser.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -893,9 +893,11 @@ function serializeThenable(request, task, thenable) {\n       if (12 === request.status)\n         return (\n           request.abortableTasks.delete(newTask),\n-          (task = request.fatalError),\n-          abortTask(newTask),\n-          finishAbortedTask(newTask, request, task),\n+          21 === request.type\n+            ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+            : ((task = request.fatalError),\n+              abortTask(newTask),\n+              finishAbortedTask(newTask, request, task)),\n           newTask.id\n         );\n       \"string\" !== typeof thenable.status &&\n@@ -961,8 +963,11 @@ function serializeReadableStream(request, task, stream) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortStream);\n       signal = signal.reason;\n-      erroredTask(request, streamTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1047,8 +1052,12 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortIterable);\n       var reason = signal.reason;\n-      erroredTask(request, streamTask, signal.reason);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal.reason),\n+          enqueueFlush(request));\n       \"function\" === typeof iterator.throw &&\n         iterator.throw(reason).then(error, error);\n     }\n@@ -1178,7 +1187,7 @@ function deferTask(request, task) {\n     request.abortableTasks\n   );\n   pingTask(request, task);\n-  return \"$L\" + task.id.toString(16);\n+  return serializeLazyID(task.id);\n }\n function renderElement(request, task, type, key, ref, props) {\n   if (null !== ref && void 0 !== ref)\n@@ -1298,10 +1307,16 @@ function createTask(\n           12 === request.status)\n         )\n           (task.status = 3),\n-            (prevKeyPath = request.fatalError),\n-            (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n-              : serializeByValueID(prevKeyPath));\n+            21 === request.type\n+              ? ((prevKeyPath = request.nextChunkId++),\n+                (prevKeyPath = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)),\n+                (JSCompiler_inline_result = prevKeyPath))\n+              : ((prevKeyPath = request.fatalError),\n+                (JSCompiler_inline_result = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)));\n         else if (\n           ((value =\n             thrownValue === SuspenseException\n@@ -1326,7 +1341,7 @@ function createTask(\n           task.keyPath = prevKeyPath;\n           task.implicitSlot = prevImplicitSlot;\n           JSCompiler_inline_result = parentPropertyName\n-            ? \"$L\" + JSCompiler_inline_result.id.toString(16)\n+            ? serializeLazyID(JSCompiler_inline_result.id)\n             : serializeByValueID(JSCompiler_inline_result.id);\n         } else\n           (task.keyPath = prevKeyPath),\n@@ -1336,7 +1351,7 @@ function createTask(\n             (prevImplicitSlot = logRecoverableError(request, value, task)),\n             emitErrorChunk(request, prevKeyPath, prevImplicitSlot),\n             (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n+              ? serializeLazyID(prevKeyPath)\n               : serializeByValueID(prevKeyPath));\n       }\n       return JSCompiler_inline_result;\n@@ -1349,6 +1364,9 @@ function createTask(\n function serializeByValueID(id) {\n   return \"$\" + id.toString(16);\n }\n+function serializeLazyID(id) {\n+  return \"$L\" + id.toString(16);\n+}\n function encodeReferenceChunk(request, id, reference) {\n   request = stringify(reference);\n   id = id.toString(16) + \":\" + request + \"\\n\";\n@@ -1367,7 +1385,7 @@ function serializeClientReference(\n     existingId = writtenClientReferences.get(clientReferenceKey);\n   if (void 0 !== existingId)\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + existingId.toString(16)\n+      ? serializeLazyID(existingId)\n       : serializeByValueID(existingId);\n   try {\n     var config = request.bundlerConfig,\n@@ -1405,7 +1423,7 @@ function serializeClientReference(\n     request.completedImportChunks.push(processedChunk);\n     writtenClientReferences.set(clientReferenceKey, importId);\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + importId.toString(16)\n+      ? serializeLazyID(importId)\n       : serializeByValueID(importId);\n   } catch (x) {\n     return (\n@@ -1458,8 +1476,11 @@ function serializeBlob(request, blob) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortBlob);\n       signal = signal.reason;\n-      erroredTask(request, newTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(newTask),\n+          haltTask(newTask),\n+          finishHaltedTask(newTask, request))\n+        : (erroredTask(request, newTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1908,13 +1929,19 @@ function retryTask(request, task) {\n       request.abortableTasks.delete(task);\n       callOnAllReadyIfReady(request);\n     } catch (thrownValue) {\n-      if (12 === request.status) {\n-        request.abortableTasks.delete(task);\n-        task.status = 0;\n-        var errorId = request.fatalError;\n-        abortTask(task);\n-        finishAbortedTask(task, request, errorId);\n-      } else {\n+      if (12 === request.status)\n+        if (\n+          (request.abortableTasks.delete(task),\n+          (task.status = 0),\n+          21 === request.type)\n+        )\n+          haltTask(task), finishHaltedTask(task, request);\n+        else {\n+          var errorId = request.fatalError;\n+          abortTask(task);\n+          finishAbortedTask(task, request, errorId);\n+        }\n+      else {\n         var x =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -1971,6 +1998,12 @@ function finishAbortedTask(task, request, errorId) {\n     (task = encodeReferenceChunk(request, task.id, errorId)),\n     request.completedErrorChunks.push(task));\n }\n+function haltTask(task) {\n+  0 === task.status && (task.status = 3);\n+}\n+function finishHaltedTask(task, request) {\n+  3 === task.status && request.pendingChunks--;\n+}\n function flushCompletedChunks(request) {\n   var destination = request.destination;\n   if (null !== destination) {\n@@ -2057,6 +2090,18 @@ function startFlowing(request, destination) {\n     }\n   }\n }\n+function finishHalt(request, abortedTasks) {\n+  try {\n+    abortedTasks.forEach(function (task) {\n+      return finishHaltedTask(task, request);\n+    });\n+    var onAllReady = request.onAllReady;\n+    onAllReady();\n+    flushCompletedChunks(request);\n+  } catch (error) {\n+    logRecoverableError(request, error, null), fatalError(request, error);\n+  }\n+}\n function finishAbort(request, abortedTasks, errorId) {\n   try {\n     abortedTasks.forEach(function (task) {\n@@ -2075,27 +2120,40 @@ function abort(request, reason) {\n       request.status = 12;\n       request.cacheController.abort(reason);\n       var abortableTasks = request.abortableTasks;\n-      if (0 < abortableTasks.size) {\n-        var error =\n-            void 0 === reason\n-              ? Error(\"The render was aborted by the server without a reason.\")\n-              : \"object\" === typeof reason &&\n-                  null !== reason &&\n-                  \"function\" === typeof reason.then\n-                ? Error(\"The render was aborted by the server with a promise.\")\n-                : reason,\n-          digest = logRecoverableError(request, error, null),\n-          errorId = request.nextChunkId++;\n-        request.fatalError = errorId;\n-        request.pendingChunks++;\n-        emitErrorChunk(request, errorId, digest, error, !1, null);\n-        abortableTasks.forEach(function (task) {\n-          return abortTask(task, request, errorId);\n-        });\n-        scheduleWork(function () {\n-          return finishAbort(request, abortableTasks, errorId);\n-        });\n-      } else {\n+      if (0 < abortableTasks.size)\n+        if (21 === request.type)\n+          abortableTasks.forEach(function (task) {\n+            return haltTask(task, request);\n+          }),\n+            scheduleWork(function () {\n+              return finishHalt(request, abortableTasks);\n+            });\n+        else {\n+          var error =\n+              void 0 === reason\n+                ? Error(\n+                    \"The render was aborted by the server without a reason.\"\n+                  )\n+                : \"object\" === typeof reason &&\n+                    null !== reason &&\n+                    \"function\" === typeof reason.then\n+                  ? Error(\n+                      \"The render was aborted by the server with a promise.\"\n+                    )\n+                  : reason,\n+            digest = logRecoverableError(request, error, null),\n+            errorId = request.nextChunkId++;\n+          request.fatalError = errorId;\n+          request.pendingChunks++;\n+          emitErrorChunk(request, errorId, digest, error, !1, null);\n+          abortableTasks.forEach(function (task) {\n+            return abortTask(task, request, errorId);\n+          });\n+          scheduleWork(function () {\n+            return finishAbort(request, abortableTasks, errorId);\n+          });\n+        }\n+      else {\n         var onAllReady = request.onAllReady;\n         onAllReady();\n         flushCompletedChunks(request);\n@@ -2891,6 +2949,48 @@ exports.decodeReply = function (body, webpackMap, options) {\n   close(body);\n   return webpackMap;\n };\n+exports.prerender = function (model, webpackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      webpackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var stream = new ReadableStream(\n+          {\n+            type: \"bytes\",\n+            pull: function (controller) {\n+              startFlowing(request, controller);\n+            },\n+            cancel: function (reason) {\n+              request.destination = null;\n+              abort(request, reason);\n+            }\n+          },\n+          { highWaterMark: 0 }\n+        );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -2953,45 +3053,3 @@ exports.renderToReadableStream = function (model, webpackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, webpackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      webpackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var stream = new ReadableStream(\n-          {\n-            type: \"bytes\",\n-            pull: function (controller) {\n-              startFlowing(request, controller);\n-            },\n-            cancel: function (reason) {\n-              request.destination = null;\n-              abort(request, reason);\n-            }\n-          },\n-          { highWaterMark: 0 }\n-        );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "097e1db01e81331ad3247b4aa5b27e1e1695df8c",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.development.js",
            "status": "modified",
            "additions": 156,
            "deletions": 100,
            "changes": 256,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.edge.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.edge.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.edge.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1248,9 +1248,11 @@\n           if (request.status === ABORTING)\n             return (\n               request.abortableTasks.delete(newTask),\n-              (task = request.fatalError),\n-              abortTask(newTask),\n-              finishAbortedTask(newTask, request, task),\n+              21 === request.type\n+                ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+                : ((task = request.fatalError),\n+                  abortTask(newTask),\n+                  finishAbortedTask(newTask, request, task)),\n               newTask.id\n             );\n           \"string\" !== typeof thenable.status &&\n@@ -1322,8 +1324,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortStream);\n           signal = signal.reason;\n-          erroredTask(request, streamTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -1409,8 +1414,12 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortIterable);\n           var reason = signal.reason;\n-          erroredTask(request, streamTask, signal.reason);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal.reason),\n+              enqueueFlush(request));\n           \"function\" === typeof iterator.throw &&\n             iterator.throw(reason).then(error, error);\n         }\n@@ -2266,8 +2275,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortBlob);\n           signal = signal.reason;\n-          erroredTask(request, newTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(newTask),\n+              haltTask(newTask),\n+              finishHaltedTask(newTask, request))\n+            : (erroredTask(request, newTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -2302,12 +2314,19 @@\n           null !== parent &&\n           (parent.$$typeof === REACT_ELEMENT_TYPE ||\n             parent.$$typeof === REACT_LAZY_TYPE);\n-        if (request.status === ABORTING)\n-          return (\n-            (task.status = 3),\n-            (task = request.fatalError),\n-            parent ? serializeLazyID(task) : serializeByValueID(task)\n-          );\n+        if (request.status === ABORTING) {\n+          task.status = 3;\n+          if (21 === request.type)\n+            return (\n+              (task = request.nextChunkId++),\n+              (task = parent\n+                ? serializeLazyID(task)\n+                : serializeByValueID(task)),\n+              task\n+            );\n+          task = request.fatalError;\n+          return parent ? serializeLazyID(task) : serializeByValueID(task);\n+        }\n         key =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -3389,6 +3408,13 @@\n       (thenable = thenable._debugInfo) &&\n         forwardDebugInfo(request, task, thenable);\n     }\n+    function forwardDebugInfoFromAbortedTask(request, task) {\n+      var model = task.model;\n+      \"object\" === typeof model &&\n+        null !== model &&\n+        (model = model._debugInfo) &&\n+        forwardDebugInfo(request, task, model);\n+    }\n     function emitTimingChunk(request, id, timestamp) {\n       request.pendingChunks++;\n       var json = '{\"time\":' + (timestamp - request.timeOrigin) + \"}\";\n@@ -3500,13 +3526,19 @@\n           request.abortableTasks.delete(task);\n           callOnAllReadyIfReady(request);\n         } catch (thrownValue) {\n-          if (request.status === ABORTING) {\n-            request.abortableTasks.delete(task);\n-            task.status = 0;\n-            var errorId = request.fatalError;\n-            abortTask(task);\n-            finishAbortedTask(task, request, errorId);\n-          } else {\n+          if (request.status === ABORTING)\n+            if (\n+              (request.abortableTasks.delete(task),\n+              (task.status = 0),\n+              21 === request.type)\n+            )\n+              haltTask(task), finishHaltedTask(task, request);\n+            else {\n+              var errorId = request.fatalError;\n+              abortTask(task);\n+              finishAbortedTask(task, request, errorId);\n+            }\n+          else {\n             var x =\n               thrownValue === SuspenseException\n                 ? getSuspendedThenable()\n@@ -3562,17 +3594,20 @@\n       0 === task.status && (task.status = 3);\n     }\n     function finishAbortedTask(task, request, errorId) {\n-      if (3 === task.status) {\n-        var model = task.model;\n-        \"object\" === typeof model &&\n-          null !== model &&\n-          (model = model._debugInfo) &&\n-          forwardDebugInfo(request, task, model);\n-        task.timed && markOperationEndTime(request, task, request.abortTime);\n-        errorId = serializeByValueID(errorId);\n-        task = encodeReferenceChunk(request, task.id, errorId);\n-        request.completedErrorChunks.push(task);\n-      }\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        task.timed && markOperationEndTime(request, task, request.abortTime),\n+        (errorId = serializeByValueID(errorId)),\n+        (task = encodeReferenceChunk(request, task.id, errorId)),\n+        request.completedErrorChunks.push(task));\n+    }\n+    function haltTask(task) {\n+      0 === task.status && (task.status = 3);\n+    }\n+    function finishHaltedTask(task, request) {\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        request.pendingChunks--);\n     }\n     function flushCompletedChunks(request) {\n       if (null !== request.debugDestination) {\n@@ -3742,6 +3777,18 @@\n         }\n       }\n     }\n+    function finishHalt(request, abortedTasks) {\n+      try {\n+        abortedTasks.forEach(function (task) {\n+          return finishHaltedTask(task, request);\n+        });\n+        var onAllReady = request.onAllReady;\n+        onAllReady();\n+        flushCompletedChunks(request);\n+      } catch (error) {\n+        logRecoverableError(request, error, null), fatalError(request, error);\n+      }\n+    }\n     function finishAbort(request, abortedTasks, errorId) {\n       try {\n         abortedTasks.forEach(function (task) {\n@@ -3761,31 +3808,40 @@\n           request.abortTime = performance.now();\n           request.cacheController.abort(reason);\n           var abortableTasks = request.abortableTasks;\n-          if (0 < abortableTasks.size) {\n-            var error =\n-                void 0 === reason\n-                  ? Error(\n-                      \"The render was aborted by the server without a reason.\"\n-                    )\n-                  : \"object\" === typeof reason &&\n-                      null !== reason &&\n-                      \"function\" === typeof reason.then\n+          if (0 < abortableTasks.size)\n+            if (21 === request.type)\n+              abortableTasks.forEach(function (task) {\n+                return haltTask(task, request);\n+              }),\n+                setTimeout(function () {\n+                  return finishHalt(request, abortableTasks);\n+                }, 0);\n+            else {\n+              var error =\n+                  void 0 === reason\n                     ? Error(\n-                        \"The render was aborted by the server with a promise.\"\n+                        \"The render was aborted by the server without a reason.\"\n                       )\n-                    : reason,\n-              digest = logRecoverableError(request, error, null),\n-              _errorId2 = request.nextChunkId++;\n-            request.fatalError = _errorId2;\n-            request.pendingChunks++;\n-            emitErrorChunk(request, _errorId2, digest, error, !1, null);\n-            abortableTasks.forEach(function (task) {\n-              return abortTask(task, request, _errorId2);\n-            });\n-            setTimeout(function () {\n-              return finishAbort(request, abortableTasks, _errorId2);\n-            }, 0);\n-          } else {\n+                    : \"object\" === typeof reason &&\n+                        null !== reason &&\n+                        \"function\" === typeof reason.then\n+                      ? Error(\n+                          \"The render was aborted by the server with a promise.\"\n+                        )\n+                      : reason,\n+                digest = logRecoverableError(request, error, null),\n+                _errorId2 = request.nextChunkId++;\n+              request.fatalError = _errorId2;\n+              request.pendingChunks++;\n+              emitErrorChunk(request, _errorId2, digest, error, !1, null);\n+              abortableTasks.forEach(function (task) {\n+                return abortTask(task, request, _errorId2);\n+              });\n+              setTimeout(function () {\n+                return finishAbort(request, abortableTasks, _errorId2);\n+              }, 0);\n+            }\n+          else {\n             var onAllReady = request.onAllReady;\n             onAllReady();\n             flushCompletedChunks(request);\n@@ -5195,6 +5251,50 @@\n       iterator.next().then(progress, error);\n       return getChunk(response$jscomp$0, 0);\n     };\n+    exports.prerender = function (model, webpackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          webpackMap,\n+          function () {\n+            var stream = new ReadableStream(\n+              {\n+                type: \"bytes\",\n+                pull: function (controller) {\n+                  startFlowing(request, controller);\n+                },\n+                cancel: function (reason) {\n+                  request.destination = null;\n+                  abort(request, reason);\n+                }\n+              },\n+              { highWaterMark: 0 }\n+            );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -5295,48 +5395,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, webpackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          webpackMap,\n-          function () {\n-            var stream = new ReadableStream(\n-              {\n-                type: \"bytes\",\n-                pull: function (controller) {\n-                  startFlowing(request, controller);\n-                },\n-                cancel: function (reason) {\n-                  request.destination = null;\n-                  abort(request, reason);\n-                }\n-              },\n-              { highWaterMark: 0 }\n-            );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "837d15982040cbea5f33d2d682edbda7732ce89d",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.edge.production.js",
            "status": "modified",
            "additions": 146,
            "deletions": 88,
            "changes": 234,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.edge.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.edge.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.edge.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -892,9 +892,11 @@ function serializeThenable(request, task, thenable) {\n       if (12 === request.status)\n         return (\n           request.abortableTasks.delete(newTask),\n-          (task = request.fatalError),\n-          abortTask(newTask),\n-          finishAbortedTask(newTask, request, task),\n+          21 === request.type\n+            ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+            : ((task = request.fatalError),\n+              abortTask(newTask),\n+              finishAbortedTask(newTask, request, task)),\n           newTask.id\n         );\n       \"string\" !== typeof thenable.status &&\n@@ -960,8 +962,11 @@ function serializeReadableStream(request, task, stream) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortStream);\n       signal = signal.reason;\n-      erroredTask(request, streamTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1046,8 +1051,12 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortIterable);\n       var reason = signal.reason;\n-      erroredTask(request, streamTask, signal.reason);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal.reason),\n+          enqueueFlush(request));\n       \"function\" === typeof iterator.throw &&\n         iterator.throw(reason).then(error, error);\n     }\n@@ -1177,7 +1186,7 @@ function deferTask(request, task) {\n     request.abortableTasks\n   );\n   pingTask(request, task);\n-  return \"$L\" + task.id.toString(16);\n+  return serializeLazyID(task.id);\n }\n function renderElement(request, task, type, key, ref, props) {\n   if (null !== ref && void 0 !== ref)\n@@ -1297,10 +1306,16 @@ function createTask(\n           12 === request.status)\n         )\n           (task.status = 3),\n-            (prevKeyPath = request.fatalError),\n-            (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n-              : serializeByValueID(prevKeyPath));\n+            21 === request.type\n+              ? ((prevKeyPath = request.nextChunkId++),\n+                (prevKeyPath = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)),\n+                (JSCompiler_inline_result = prevKeyPath))\n+              : ((prevKeyPath = request.fatalError),\n+                (JSCompiler_inline_result = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)));\n         else if (\n           ((value =\n             thrownValue === SuspenseException\n@@ -1325,7 +1340,7 @@ function createTask(\n           task.keyPath = prevKeyPath;\n           task.implicitSlot = prevImplicitSlot;\n           JSCompiler_inline_result = parentPropertyName\n-            ? \"$L\" + JSCompiler_inline_result.id.toString(16)\n+            ? serializeLazyID(JSCompiler_inline_result.id)\n             : serializeByValueID(JSCompiler_inline_result.id);\n         } else\n           (task.keyPath = prevKeyPath),\n@@ -1335,7 +1350,7 @@ function createTask(\n             (prevImplicitSlot = logRecoverableError(request, value, task)),\n             emitErrorChunk(request, prevKeyPath, prevImplicitSlot),\n             (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n+              ? serializeLazyID(prevKeyPath)\n               : serializeByValueID(prevKeyPath));\n       }\n       return JSCompiler_inline_result;\n@@ -1348,6 +1363,9 @@ function createTask(\n function serializeByValueID(id) {\n   return \"$\" + id.toString(16);\n }\n+function serializeLazyID(id) {\n+  return \"$L\" + id.toString(16);\n+}\n function encodeReferenceChunk(request, id, reference) {\n   request = stringify(reference);\n   id = id.toString(16) + \":\" + request + \"\\n\";\n@@ -1366,7 +1384,7 @@ function serializeClientReference(\n     existingId = writtenClientReferences.get(clientReferenceKey);\n   if (void 0 !== existingId)\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + existingId.toString(16)\n+      ? serializeLazyID(existingId)\n       : serializeByValueID(existingId);\n   try {\n     var config = request.bundlerConfig,\n@@ -1404,7 +1422,7 @@ function serializeClientReference(\n     request.completedImportChunks.push(processedChunk);\n     writtenClientReferences.set(clientReferenceKey, importId);\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + importId.toString(16)\n+      ? serializeLazyID(importId)\n       : serializeByValueID(importId);\n   } catch (x) {\n     return (\n@@ -1457,8 +1475,11 @@ function serializeBlob(request, blob) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortBlob);\n       signal = signal.reason;\n-      erroredTask(request, newTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(newTask),\n+          haltTask(newTask),\n+          finishHaltedTask(newTask, request))\n+        : (erroredTask(request, newTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1909,13 +1930,19 @@ function retryTask(request, task) {\n       request.abortableTasks.delete(task);\n       callOnAllReadyIfReady(request);\n     } catch (thrownValue) {\n-      if (12 === request.status) {\n-        request.abortableTasks.delete(task);\n-        task.status = 0;\n-        var errorId = request.fatalError;\n-        abortTask(task);\n-        finishAbortedTask(task, request, errorId);\n-      } else {\n+      if (12 === request.status)\n+        if (\n+          (request.abortableTasks.delete(task),\n+          (task.status = 0),\n+          21 === request.type)\n+        )\n+          haltTask(task), finishHaltedTask(task, request);\n+        else {\n+          var errorId = request.fatalError;\n+          abortTask(task);\n+          finishAbortedTask(task, request, errorId);\n+        }\n+      else {\n         var x =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -1972,6 +1999,12 @@ function finishAbortedTask(task, request, errorId) {\n     (task = encodeReferenceChunk(request, task.id, errorId)),\n     request.completedErrorChunks.push(task));\n }\n+function haltTask(task) {\n+  0 === task.status && (task.status = 3);\n+}\n+function finishHaltedTask(task, request) {\n+  3 === task.status && request.pendingChunks--;\n+}\n function flushCompletedChunks(request) {\n   var destination = request.destination;\n   if (null !== destination) {\n@@ -2062,6 +2095,18 @@ function startFlowing(request, destination) {\n     }\n   }\n }\n+function finishHalt(request, abortedTasks) {\n+  try {\n+    abortedTasks.forEach(function (task) {\n+      return finishHaltedTask(task, request);\n+    });\n+    var onAllReady = request.onAllReady;\n+    onAllReady();\n+    flushCompletedChunks(request);\n+  } catch (error) {\n+    logRecoverableError(request, error, null), fatalError(request, error);\n+  }\n+}\n function finishAbort(request, abortedTasks, errorId) {\n   try {\n     abortedTasks.forEach(function (task) {\n@@ -2080,27 +2125,40 @@ function abort(request, reason) {\n       request.status = 12;\n       request.cacheController.abort(reason);\n       var abortableTasks = request.abortableTasks;\n-      if (0 < abortableTasks.size) {\n-        var error =\n-            void 0 === reason\n-              ? Error(\"The render was aborted by the server without a reason.\")\n-              : \"object\" === typeof reason &&\n-                  null !== reason &&\n-                  \"function\" === typeof reason.then\n-                ? Error(\"The render was aborted by the server with a promise.\")\n-                : reason,\n-          digest = logRecoverableError(request, error, null),\n-          errorId = request.nextChunkId++;\n-        request.fatalError = errorId;\n-        request.pendingChunks++;\n-        emitErrorChunk(request, errorId, digest, error, !1, null);\n-        abortableTasks.forEach(function (task) {\n-          return abortTask(task, request, errorId);\n-        });\n-        setTimeout(function () {\n-          return finishAbort(request, abortableTasks, errorId);\n-        }, 0);\n-      } else {\n+      if (0 < abortableTasks.size)\n+        if (21 === request.type)\n+          abortableTasks.forEach(function (task) {\n+            return haltTask(task, request);\n+          }),\n+            setTimeout(function () {\n+              return finishHalt(request, abortableTasks);\n+            }, 0);\n+        else {\n+          var error =\n+              void 0 === reason\n+                ? Error(\n+                    \"The render was aborted by the server without a reason.\"\n+                  )\n+                : \"object\" === typeof reason &&\n+                    null !== reason &&\n+                    \"function\" === typeof reason.then\n+                  ? Error(\n+                      \"The render was aborted by the server with a promise.\"\n+                    )\n+                  : reason,\n+            digest = logRecoverableError(request, error, null),\n+            errorId = request.nextChunkId++;\n+          request.fatalError = errorId;\n+          request.pendingChunks++;\n+          emitErrorChunk(request, errorId, digest, error, !1, null);\n+          abortableTasks.forEach(function (task) {\n+            return abortTask(task, request, errorId);\n+          });\n+          setTimeout(function () {\n+            return finishAbort(request, abortableTasks, errorId);\n+          }, 0);\n+        }\n+      else {\n         var onAllReady = request.onAllReady;\n         onAllReady();\n         flushCompletedChunks(request);\n@@ -2924,6 +2982,48 @@ exports.decodeReplyFromAsyncIterable = function (\n   iterator.next().then(progress, error);\n   return getChunk(response, 0);\n };\n+exports.prerender = function (model, webpackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      webpackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var stream = new ReadableStream(\n+          {\n+            type: \"bytes\",\n+            pull: function (controller) {\n+              startFlowing(request, controller);\n+            },\n+            cancel: function (reason) {\n+              request.destination = null;\n+              abort(request, reason);\n+            }\n+          },\n+          { highWaterMark: 0 }\n+        );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -2986,45 +3086,3 @@ exports.renderToReadableStream = function (model, webpackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, webpackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      webpackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var stream = new ReadableStream(\n-          {\n-            type: \"bytes\",\n-            pull: function (controller) {\n-              startFlowing(request, controller);\n-            },\n-            cancel: function (reason) {\n-              request.destination = null;\n-              abort(request, reason);\n-            }\n-          },\n-          { highWaterMark: 0 }\n-        );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "deb786022da00776c1bdfb6ba4ecaafcb12a3f03",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.development.js",
            "status": "modified",
            "additions": 229,
            "deletions": 177,
            "changes": 406,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1342,9 +1342,11 @@\n           if (request.status === ABORTING)\n             return (\n               request.abortableTasks.delete(newTask),\n-              (task = request.fatalError),\n-              abortTask(newTask),\n-              finishAbortedTask(newTask, request, task),\n+              21 === request.type\n+                ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+                : ((task = request.fatalError),\n+                  abortTask(newTask),\n+                  finishAbortedTask(newTask, request, task)),\n               newTask.id\n             );\n           \"string\" !== typeof thenable.status &&\n@@ -1416,8 +1418,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortStream);\n           signal = signal.reason;\n-          erroredTask(request, streamTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -1503,8 +1508,12 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortIterable);\n           var reason = signal.reason;\n-          erroredTask(request, streamTask, signal.reason);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal.reason),\n+              enqueueFlush(request));\n           \"function\" === typeof iterator.throw &&\n             iterator.throw(reason).then(error, error);\n         }\n@@ -2479,8 +2488,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortBlob);\n           signal = signal.reason;\n-          erroredTask(request, newTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(newTask),\n+              haltTask(newTask),\n+              finishHaltedTask(newTask, request))\n+            : (erroredTask(request, newTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -2515,12 +2527,19 @@\n           null !== parent &&\n           (parent.$$typeof === REACT_ELEMENT_TYPE ||\n             parent.$$typeof === REACT_LAZY_TYPE);\n-        if (request.status === ABORTING)\n-          return (\n-            (task.status = 3),\n-            (task = request.fatalError),\n-            parent ? serializeLazyID(task) : serializeByValueID(task)\n-          );\n+        if (request.status === ABORTING) {\n+          task.status = 3;\n+          if (21 === request.type)\n+            return (\n+              (task = request.nextChunkId++),\n+              (task = parent\n+                ? serializeLazyID(task)\n+                : serializeByValueID(task)),\n+              task\n+            );\n+          task = request.fatalError;\n+          return parent ? serializeLazyID(task) : serializeByValueID(task);\n+        }\n         key =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -3684,6 +3703,39 @@\n       null !== sequence &&\n         emitAsyncSequence(request, task, sequence, thenable, null, null);\n     }\n+    function forwardDebugInfoFromAbortedTask(request, task) {\n+      var model = task.model;\n+      if (\"object\" === typeof model && null !== model) {\n+        var debugInfo;\n+        (debugInfo = model._debugInfo) &&\n+          forwardDebugInfo(request, task, debugInfo);\n+        var thenable = null;\n+        \"function\" === typeof model.then\n+          ? (thenable = model)\n+          : model.$$typeof === REACT_LAZY_TYPE &&\n+            ((model = model._payload),\n+            \"function\" === typeof model.then && (thenable = model));\n+        if (\n+          null !== thenable &&\n+          ((model = getAsyncSequenceFromPromise(thenable)), null !== model)\n+        ) {\n+          for (\n+            thenable = model;\n+            4 === thenable.tag && null !== thenable.awaited;\n+\n+          )\n+            thenable = thenable.awaited;\n+          3 === thenable.tag\n+            ? (serializeIONode(request, thenable, null),\n+              request.pendingChunks++,\n+              (debugInfo = (0, request.environmentName)()),\n+              (debugInfo = { awaited: thenable, env: debugInfo }),\n+              advanceTaskTime(request, task, task.time),\n+              emitDebugChunk(request, task.id, debugInfo))\n+            : emitAsyncSequence(request, task, model, debugInfo, null, null);\n+        }\n+      }\n+    }\n     function emitTimingChunk(request, id, timestamp) {\n       request.pendingChunks++;\n       var json = '{\"time\":' + (timestamp - request.timeOrigin) + \"}\";\n@@ -3808,13 +3860,19 @@\n           request.abortableTasks.delete(task);\n           callOnAllReadyIfReady(request);\n         } catch (thrownValue) {\n-          if (request.status === ABORTING) {\n-            request.abortableTasks.delete(task);\n-            task.status = 0;\n-            var errorId = request.fatalError;\n-            abortTask(task);\n-            finishAbortedTask(task, request, errorId);\n-          } else {\n+          if (request.status === ABORTING)\n+            if (\n+              (request.abortableTasks.delete(task),\n+              (task.status = 0),\n+              21 === request.type)\n+            )\n+              haltTask(task), finishHaltedTask(task, request);\n+            else {\n+              var errorId = request.fatalError;\n+              abortTask(task);\n+              finishAbortedTask(task, request, errorId);\n+            }\n+          else {\n             var x =\n               thrownValue === SuspenseException\n                 ? getSuspendedThenable()\n@@ -3871,43 +3929,20 @@\n       0 === task.status && (task.status = 3);\n     }\n     function finishAbortedTask(task, request, errorId) {\n-      if (3 === task.status) {\n-        var model = task.model;\n-        if (\"object\" === typeof model && null !== model) {\n-          var debugInfo;\n-          (debugInfo = model._debugInfo) &&\n-            forwardDebugInfo(request, task, debugInfo);\n-          var thenable = null;\n-          \"function\" === typeof model.then\n-            ? (thenable = model)\n-            : model.$$typeof === REACT_LAZY_TYPE &&\n-              ((model = model._payload),\n-              \"function\" === typeof model.then && (thenable = model));\n-          if (\n-            null !== thenable &&\n-            ((model = getAsyncSequenceFromPromise(thenable)), null !== model)\n-          ) {\n-            for (\n-              thenable = model;\n-              4 === thenable.tag && null !== thenable.awaited;\n-\n-            )\n-              thenable = thenable.awaited;\n-            3 === thenable.tag\n-              ? (serializeIONode(request, thenable, null),\n-                request.pendingChunks++,\n-                (debugInfo = (0, request.environmentName)()),\n-                (debugInfo = { awaited: thenable, env: debugInfo }),\n-                advanceTaskTime(request, task, task.time),\n-                emitDebugChunk(request, task.id, debugInfo))\n-              : emitAsyncSequence(request, task, model, debugInfo, null, null);\n-          }\n-        }\n-        task.timed && markOperationEndTime(request, task, request.abortTime);\n-        errorId = serializeByValueID(errorId);\n-        task = encodeReferenceChunk(request, task.id, errorId);\n-        request.completedErrorChunks.push(task);\n-      }\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        task.timed && markOperationEndTime(request, task, request.abortTime),\n+        (errorId = serializeByValueID(errorId)),\n+        (task = encodeReferenceChunk(request, task.id, errorId)),\n+        request.completedErrorChunks.push(task));\n+    }\n+    function haltTask(task) {\n+      0 === task.status && (task.status = 3);\n+    }\n+    function finishHaltedTask(task, request) {\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        request.pendingChunks--);\n     }\n     function flushCompletedChunks(request) {\n       if (null !== request.debugDestination) {\n@@ -4088,6 +4123,18 @@\n         }\n       }\n     }\n+    function finishHalt(request, abortedTasks) {\n+      try {\n+        abortedTasks.forEach(function (task) {\n+          return finishHaltedTask(task, request);\n+        });\n+        var onAllReady = request.onAllReady;\n+        onAllReady();\n+        flushCompletedChunks(request);\n+      } catch (error) {\n+        logRecoverableError(request, error, null), fatalError(request, error);\n+      }\n+    }\n     function finishAbort(request, abortedTasks, errorId) {\n       try {\n         abortedTasks.forEach(function (task) {\n@@ -4107,31 +4154,40 @@\n           request.abortTime = performance.now();\n           request.cacheController.abort(reason);\n           var abortableTasks = request.abortableTasks;\n-          if (0 < abortableTasks.size) {\n-            var error =\n-                void 0 === reason\n-                  ? Error(\n-                      \"The render was aborted by the server without a reason.\"\n-                    )\n-                  : \"object\" === typeof reason &&\n-                      null !== reason &&\n-                      \"function\" === typeof reason.then\n+          if (0 < abortableTasks.size)\n+            if (21 === request.type)\n+              abortableTasks.forEach(function (task) {\n+                return haltTask(task, request);\n+              }),\n+                setImmediate(function () {\n+                  return finishHalt(request, abortableTasks);\n+                });\n+            else {\n+              var error =\n+                  void 0 === reason\n                     ? Error(\n-                        \"The render was aborted by the server with a promise.\"\n+                        \"The render was aborted by the server without a reason.\"\n                       )\n-                    : reason,\n-              digest = logRecoverableError(request, error, null),\n-              _errorId2 = request.nextChunkId++;\n-            request.fatalError = _errorId2;\n-            request.pendingChunks++;\n-            emitErrorChunk(request, _errorId2, digest, error, !1, null);\n-            abortableTasks.forEach(function (task) {\n-              return abortTask(task, request, _errorId2);\n-            });\n-            setImmediate(function () {\n-              return finishAbort(request, abortableTasks, _errorId2);\n-            });\n-          } else {\n+                    : \"object\" === typeof reason &&\n+                        null !== reason &&\n+                        \"function\" === typeof reason.then\n+                      ? Error(\n+                          \"The render was aborted by the server with a promise.\"\n+                        )\n+                      : reason,\n+                digest = logRecoverableError(request, error, null),\n+                _errorId2 = request.nextChunkId++;\n+              request.fatalError = _errorId2;\n+              request.pendingChunks++;\n+              emitErrorChunk(request, _errorId2, digest, error, !1, null);\n+              abortableTasks.forEach(function (task) {\n+                return abortTask(task, request, _errorId2);\n+              });\n+              setImmediate(function () {\n+                return finishAbort(request, abortableTasks, _errorId2);\n+              });\n+            }\n+          else {\n             var onAllReady = request.onAllReady;\n             onAllReady();\n             flushCompletedChunks(request);\n@@ -5837,12 +5893,12 @@\n             \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n           );\n         pendingFiles++;\n-        var JSCompiler_object_inline_chunks_246 = [];\n+        var JSCompiler_object_inline_chunks_250 = [];\n         value.on(\"data\", function (chunk) {\n-          JSCompiler_object_inline_chunks_246.push(chunk);\n+          JSCompiler_object_inline_chunks_250.push(chunk);\n         });\n         value.on(\"end\", function () {\n-          var blob = new Blob(JSCompiler_object_inline_chunks_246, {\n+          var blob = new Blob(JSCompiler_object_inline_chunks_250, {\n             type: mimeType\n           });\n           response._formData.append(name, blob, filename);\n@@ -5866,6 +5922,94 @@\n       });\n       return getChunk(response, 0);\n     };\n+    exports.prerender = function (model, webpackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          webpackMap,\n+          function () {\n+            var writable,\n+              stream = new ReadableStream(\n+                {\n+                  type: \"bytes\",\n+                  start: function (controller) {\n+                    writable =\n+                      createFakeWritableFromReadableStreamController(\n+                        controller\n+                      );\n+                  },\n+                  pull: function () {\n+                    startFlowing(request, writable);\n+                  },\n+                  cancel: function (reason) {\n+                    request.destination = null;\n+                    abort(request, reason);\n+                  }\n+                },\n+                { highWaterMark: 0 }\n+              );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.prerenderToNodeStream = function (model, webpackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          webpackMap,\n+          function () {\n+            var readable = new stream.Readable({\n+                read: function () {\n+                  startFlowing(request, writable);\n+                }\n+              }),\n+              writable = createFakeWritableFromNodeReadable(readable);\n+            resolve({ prelude: readable });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -6024,96 +6168,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, webpackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          webpackMap,\n-          function () {\n-            var writable,\n-              stream = new ReadableStream(\n-                {\n-                  type: \"bytes\",\n-                  start: function (controller) {\n-                    writable =\n-                      createFakeWritableFromReadableStreamController(\n-                        controller\n-                      );\n-                  },\n-                  pull: function () {\n-                    startFlowing(request, writable);\n-                  },\n-                  cancel: function (reason) {\n-                    request.destination = null;\n-                    abort(request, reason);\n-                  }\n-                },\n-                { highWaterMark: 0 }\n-              );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n-    exports.unstable_prerenderToNodeStream = function (\n-      model,\n-      webpackMap,\n-      options\n-    ) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          webpackMap,\n-          function () {\n-            var readable = new stream.Readable({\n-                read: function () {\n-                  startFlowing(request, writable);\n-                }\n-              }),\n-              writable = createFakeWritableFromNodeReadable(readable);\n-            resolve({ prelude: readable });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "270d7d0fdd4cb4b724af37a143613a2e00d61b45",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.production.js",
            "status": "modified",
            "additions": 189,
            "deletions": 131,
            "changes": 320,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -915,9 +915,11 @@ function serializeThenable(request, task, thenable) {\n       if (12 === request.status)\n         return (\n           request.abortableTasks.delete(newTask),\n-          (task = request.fatalError),\n-          abortTask(newTask),\n-          finishAbortedTask(newTask, request, task),\n+          21 === request.type\n+            ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+            : ((task = request.fatalError),\n+              abortTask(newTask),\n+              finishAbortedTask(newTask, request, task)),\n           newTask.id\n         );\n       \"string\" !== typeof thenable.status &&\n@@ -983,8 +985,11 @@ function serializeReadableStream(request, task, stream) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortStream);\n       signal = signal.reason;\n-      erroredTask(request, streamTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1069,8 +1074,12 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortIterable);\n       var reason = signal.reason;\n-      erroredTask(request, streamTask, signal.reason);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal.reason),\n+          enqueueFlush(request));\n       \"function\" === typeof iterator.throw &&\n         iterator.throw(reason).then(error, error);\n     }\n@@ -1199,7 +1208,7 @@ function deferTask(request, task) {\n     request.abortableTasks\n   );\n   pingTask(request, task);\n-  return \"$L\" + task.id.toString(16);\n+  return serializeLazyID(task.id);\n }\n function renderElement(request, task, type, key, ref, props) {\n   if (null !== ref && void 0 !== ref)\n@@ -1319,10 +1328,16 @@ function createTask(\n           12 === request.status)\n         )\n           (task.status = 3),\n-            (prevKeyPath = request.fatalError),\n-            (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n-              : serializeByValueID(prevKeyPath));\n+            21 === request.type\n+              ? ((prevKeyPath = request.nextChunkId++),\n+                (prevKeyPath = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)),\n+                (JSCompiler_inline_result = prevKeyPath))\n+              : ((prevKeyPath = request.fatalError),\n+                (JSCompiler_inline_result = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)));\n         else if (\n           ((value =\n             thrownValue === SuspenseException\n@@ -1347,7 +1362,7 @@ function createTask(\n           task.keyPath = prevKeyPath;\n           task.implicitSlot = prevImplicitSlot;\n           JSCompiler_inline_result = parentPropertyName\n-            ? \"$L\" + JSCompiler_inline_result.id.toString(16)\n+            ? serializeLazyID(JSCompiler_inline_result.id)\n             : serializeByValueID(JSCompiler_inline_result.id);\n         } else\n           (task.keyPath = prevKeyPath),\n@@ -1357,7 +1372,7 @@ function createTask(\n             (prevImplicitSlot = logRecoverableError(request, value, task)),\n             emitErrorChunk(request, prevKeyPath, prevImplicitSlot),\n             (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n+              ? serializeLazyID(prevKeyPath)\n               : serializeByValueID(prevKeyPath));\n       }\n       return JSCompiler_inline_result;\n@@ -1370,6 +1385,9 @@ function createTask(\n function serializeByValueID(id) {\n   return \"$\" + id.toString(16);\n }\n+function serializeLazyID(id) {\n+  return \"$L\" + id.toString(16);\n+}\n function encodeReferenceChunk(request, id, reference) {\n   request = stringify(reference);\n   return id.toString(16) + \":\" + request + \"\\n\";\n@@ -1387,7 +1405,7 @@ function serializeClientReference(\n     existingId = writtenClientReferences.get(clientReferenceKey);\n   if (void 0 !== existingId)\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + existingId.toString(16)\n+      ? serializeLazyID(existingId)\n       : serializeByValueID(existingId);\n   try {\n     var config = request.bundlerConfig,\n@@ -1424,7 +1442,7 @@ function serializeClientReference(\n     request.completedImportChunks.push(processedChunk);\n     writtenClientReferences.set(clientReferenceKey, importId);\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + importId.toString(16)\n+      ? serializeLazyID(importId)\n       : serializeByValueID(importId);\n   } catch (x) {\n     return (\n@@ -1477,8 +1495,11 @@ function serializeBlob(request, blob) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortBlob);\n       signal = signal.reason;\n-      erroredTask(request, newTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(newTask),\n+          haltTask(newTask),\n+          finishHaltedTask(newTask, request))\n+        : (erroredTask(request, newTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1919,13 +1940,19 @@ function retryTask(request, task) {\n       request.abortableTasks.delete(task);\n       callOnAllReadyIfReady(request);\n     } catch (thrownValue) {\n-      if (12 === request.status) {\n-        request.abortableTasks.delete(task);\n-        task.status = 0;\n-        var errorId = request.fatalError;\n-        abortTask(task);\n-        finishAbortedTask(task, request, errorId);\n-      } else {\n+      if (12 === request.status)\n+        if (\n+          (request.abortableTasks.delete(task),\n+          (task.status = 0),\n+          21 === request.type)\n+        )\n+          haltTask(task), finishHaltedTask(task, request);\n+        else {\n+          var errorId = request.fatalError;\n+          abortTask(task);\n+          finishAbortedTask(task, request, errorId);\n+        }\n+      else {\n         var x =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -1982,6 +2009,12 @@ function finishAbortedTask(task, request, errorId) {\n     (task = encodeReferenceChunk(request, task.id, errorId)),\n     request.completedErrorChunks.push(task));\n }\n+function haltTask(task) {\n+  0 === task.status && (task.status = 3);\n+}\n+function finishHaltedTask(task, request) {\n+  3 === task.status && request.pendingChunks--;\n+}\n function flushCompletedChunks(request) {\n   var destination = request.destination;\n   if (null !== destination) {\n@@ -2091,6 +2124,18 @@ function startFlowing(request, destination) {\n     }\n   }\n }\n+function finishHalt(request, abortedTasks) {\n+  try {\n+    abortedTasks.forEach(function (task) {\n+      return finishHaltedTask(task, request);\n+    });\n+    var onAllReady = request.onAllReady;\n+    onAllReady();\n+    flushCompletedChunks(request);\n+  } catch (error) {\n+    logRecoverableError(request, error, null), fatalError(request, error);\n+  }\n+}\n function finishAbort(request, abortedTasks, errorId) {\n   try {\n     abortedTasks.forEach(function (task) {\n@@ -2109,27 +2154,40 @@ function abort(request, reason) {\n       request.status = 12;\n       request.cacheController.abort(reason);\n       var abortableTasks = request.abortableTasks;\n-      if (0 < abortableTasks.size) {\n-        var error =\n-            void 0 === reason\n-              ? Error(\"The render was aborted by the server without a reason.\")\n-              : \"object\" === typeof reason &&\n-                  null !== reason &&\n-                  \"function\" === typeof reason.then\n-                ? Error(\"The render was aborted by the server with a promise.\")\n-                : reason,\n-          digest = logRecoverableError(request, error, null),\n-          errorId = request.nextChunkId++;\n-        request.fatalError = errorId;\n-        request.pendingChunks++;\n-        emitErrorChunk(request, errorId, digest, error, !1, null);\n-        abortableTasks.forEach(function (task) {\n-          return abortTask(task, request, errorId);\n-        });\n-        setImmediate(function () {\n-          return finishAbort(request, abortableTasks, errorId);\n-        });\n-      } else {\n+      if (0 < abortableTasks.size)\n+        if (21 === request.type)\n+          abortableTasks.forEach(function (task) {\n+            return haltTask(task, request);\n+          }),\n+            setImmediate(function () {\n+              return finishHalt(request, abortableTasks);\n+            });\n+        else {\n+          var error =\n+              void 0 === reason\n+                ? Error(\n+                    \"The render was aborted by the server without a reason.\"\n+                  )\n+                : \"object\" === typeof reason &&\n+                    null !== reason &&\n+                    \"function\" === typeof reason.then\n+                  ? Error(\n+                      \"The render was aborted by the server with a promise.\"\n+                    )\n+                  : reason,\n+            digest = logRecoverableError(request, error, null),\n+            errorId = request.nextChunkId++;\n+          request.fatalError = errorId;\n+          request.pendingChunks++;\n+          emitErrorChunk(request, errorId, digest, error, !1, null);\n+          abortableTasks.forEach(function (task) {\n+            return abortTask(task, request, errorId);\n+          });\n+          setImmediate(function () {\n+            return finishAbort(request, abortableTasks, errorId);\n+          });\n+        }\n+      else {\n         var onAllReady = request.onAllReady;\n         onAllReady();\n         flushCompletedChunks(request);\n@@ -3017,12 +3075,12 @@ exports.decodeReplyFromBusboy = function (busboyStream, webpackMap, options) {\n         \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n       );\n     pendingFiles++;\n-    var JSCompiler_object_inline_chunks_270 = [];\n+    var JSCompiler_object_inline_chunks_274 = [];\n     value.on(\"data\", function (chunk) {\n-      JSCompiler_object_inline_chunks_270.push(chunk);\n+      JSCompiler_object_inline_chunks_274.push(chunk);\n     });\n     value.on(\"end\", function () {\n-      var blob = new Blob(JSCompiler_object_inline_chunks_270, {\n+      var blob = new Blob(JSCompiler_object_inline_chunks_274, {\n         type: mimeType\n       });\n       response._formData.append(name, blob, filename);\n@@ -3042,6 +3100,88 @@ exports.decodeReplyFromBusboy = function (busboyStream, webpackMap, options) {\n   });\n   return getChunk(response, 0);\n };\n+exports.prerender = function (model, webpackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      webpackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var writable,\n+          stream = new ReadableStream(\n+            {\n+              type: \"bytes\",\n+              start: function (controller) {\n+                writable =\n+                  createFakeWritableFromReadableStreamController(controller);\n+              },\n+              pull: function () {\n+                startFlowing(request, writable);\n+              },\n+              cancel: function (reason) {\n+                request.destination = null;\n+                abort(request, reason);\n+              }\n+            },\n+            { highWaterMark: 0 }\n+          );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.prerenderToNodeStream = function (model, webpackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      webpackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var readable = new stream.Readable({\n+            read: function () {\n+              startFlowing(request, writable);\n+            }\n+          }),\n+          writable = createFakeWritableFromNodeReadable(readable);\n+        resolve({ prelude: readable });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -3147,85 +3287,3 @@ exports.renderToReadableStream = function (model, webpackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, webpackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      webpackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var writable,\n-          stream = new ReadableStream(\n-            {\n-              type: \"bytes\",\n-              start: function (controller) {\n-                writable =\n-                  createFakeWritableFromReadableStreamController(controller);\n-              },\n-              pull: function () {\n-                startFlowing(request, writable);\n-              },\n-              cancel: function (reason) {\n-                request.destination = null;\n-                abort(request, reason);\n-              }\n-            },\n-            { highWaterMark: 0 }\n-          );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};\n-exports.unstable_prerenderToNodeStream = function (model, webpackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      webpackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var readable = new stream.Readable({\n-            read: function () {\n-              startFlowing(request, writable);\n-            }\n-          }),\n-          writable = createFakeWritableFromNodeReadable(readable);\n-        resolve({ prelude: readable });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "e61e079dba6c9696509378edab3cb471c29db266",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.development.js",
            "status": "modified",
            "additions": 229,
            "deletions": 177,
            "changes": 406,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1342,9 +1342,11 @@\n           if (request.status === ABORTING)\n             return (\n               request.abortableTasks.delete(newTask),\n-              (task = request.fatalError),\n-              abortTask(newTask),\n-              finishAbortedTask(newTask, request, task),\n+              21 === request.type\n+                ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+                : ((task = request.fatalError),\n+                  abortTask(newTask),\n+                  finishAbortedTask(newTask, request, task)),\n               newTask.id\n             );\n           \"string\" !== typeof thenable.status &&\n@@ -1416,8 +1418,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortStream);\n           signal = signal.reason;\n-          erroredTask(request, streamTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -1503,8 +1508,12 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortIterable);\n           var reason = signal.reason;\n-          erroredTask(request, streamTask, signal.reason);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(streamTask),\n+              haltTask(streamTask),\n+              finishHaltedTask(streamTask, request))\n+            : (erroredTask(request, streamTask, signal.reason),\n+              enqueueFlush(request));\n           \"function\" === typeof iterator.throw &&\n             iterator.throw(reason).then(error, error);\n         }\n@@ -2479,8 +2488,11 @@\n           var signal = request.cacheController.signal;\n           signal.removeEventListener(\"abort\", abortBlob);\n           signal = signal.reason;\n-          erroredTask(request, newTask, signal);\n-          enqueueFlush(request);\n+          21 === request.type\n+            ? (request.abortableTasks.delete(newTask),\n+              haltTask(newTask),\n+              finishHaltedTask(newTask, request))\n+            : (erroredTask(request, newTask, signal), enqueueFlush(request));\n           reader.cancel(signal).then(error, error);\n         }\n       }\n@@ -2515,12 +2527,19 @@\n           null !== parent &&\n           (parent.$$typeof === REACT_ELEMENT_TYPE ||\n             parent.$$typeof === REACT_LAZY_TYPE);\n-        if (request.status === ABORTING)\n-          return (\n-            (task.status = 3),\n-            (task = request.fatalError),\n-            parent ? serializeLazyID(task) : serializeByValueID(task)\n-          );\n+        if (request.status === ABORTING) {\n+          task.status = 3;\n+          if (21 === request.type)\n+            return (\n+              (task = request.nextChunkId++),\n+              (task = parent\n+                ? serializeLazyID(task)\n+                : serializeByValueID(task)),\n+              task\n+            );\n+          task = request.fatalError;\n+          return parent ? serializeLazyID(task) : serializeByValueID(task);\n+        }\n         key =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -3684,6 +3703,39 @@\n       null !== sequence &&\n         emitAsyncSequence(request, task, sequence, thenable, null, null);\n     }\n+    function forwardDebugInfoFromAbortedTask(request, task) {\n+      var model = task.model;\n+      if (\"object\" === typeof model && null !== model) {\n+        var debugInfo;\n+        (debugInfo = model._debugInfo) &&\n+          forwardDebugInfo(request, task, debugInfo);\n+        var thenable = null;\n+        \"function\" === typeof model.then\n+          ? (thenable = model)\n+          : model.$$typeof === REACT_LAZY_TYPE &&\n+            ((model = model._payload),\n+            \"function\" === typeof model.then && (thenable = model));\n+        if (\n+          null !== thenable &&\n+          ((model = getAsyncSequenceFromPromise(thenable)), null !== model)\n+        ) {\n+          for (\n+            thenable = model;\n+            4 === thenable.tag && null !== thenable.awaited;\n+\n+          )\n+            thenable = thenable.awaited;\n+          3 === thenable.tag\n+            ? (serializeIONode(request, thenable, null),\n+              request.pendingChunks++,\n+              (debugInfo = (0, request.environmentName)()),\n+              (debugInfo = { awaited: thenable, env: debugInfo }),\n+              advanceTaskTime(request, task, task.time),\n+              emitDebugChunk(request, task.id, debugInfo))\n+            : emitAsyncSequence(request, task, model, debugInfo, null, null);\n+        }\n+      }\n+    }\n     function emitTimingChunk(request, id, timestamp) {\n       request.pendingChunks++;\n       var json = '{\"time\":' + (timestamp - request.timeOrigin) + \"}\";\n@@ -3808,13 +3860,19 @@\n           request.abortableTasks.delete(task);\n           callOnAllReadyIfReady(request);\n         } catch (thrownValue) {\n-          if (request.status === ABORTING) {\n-            request.abortableTasks.delete(task);\n-            task.status = 0;\n-            var errorId = request.fatalError;\n-            abortTask(task);\n-            finishAbortedTask(task, request, errorId);\n-          } else {\n+          if (request.status === ABORTING)\n+            if (\n+              (request.abortableTasks.delete(task),\n+              (task.status = 0),\n+              21 === request.type)\n+            )\n+              haltTask(task), finishHaltedTask(task, request);\n+            else {\n+              var errorId = request.fatalError;\n+              abortTask(task);\n+              finishAbortedTask(task, request, errorId);\n+            }\n+          else {\n             var x =\n               thrownValue === SuspenseException\n                 ? getSuspendedThenable()\n@@ -3871,43 +3929,20 @@\n       0 === task.status && (task.status = 3);\n     }\n     function finishAbortedTask(task, request, errorId) {\n-      if (3 === task.status) {\n-        var model = task.model;\n-        if (\"object\" === typeof model && null !== model) {\n-          var debugInfo;\n-          (debugInfo = model._debugInfo) &&\n-            forwardDebugInfo(request, task, debugInfo);\n-          var thenable = null;\n-          \"function\" === typeof model.then\n-            ? (thenable = model)\n-            : model.$$typeof === REACT_LAZY_TYPE &&\n-              ((model = model._payload),\n-              \"function\" === typeof model.then && (thenable = model));\n-          if (\n-            null !== thenable &&\n-            ((model = getAsyncSequenceFromPromise(thenable)), null !== model)\n-          ) {\n-            for (\n-              thenable = model;\n-              4 === thenable.tag && null !== thenable.awaited;\n-\n-            )\n-              thenable = thenable.awaited;\n-            3 === thenable.tag\n-              ? (serializeIONode(request, thenable, null),\n-                request.pendingChunks++,\n-                (debugInfo = (0, request.environmentName)()),\n-                (debugInfo = { awaited: thenable, env: debugInfo }),\n-                advanceTaskTime(request, task, task.time),\n-                emitDebugChunk(request, task.id, debugInfo))\n-              : emitAsyncSequence(request, task, model, debugInfo, null, null);\n-          }\n-        }\n-        task.timed && markOperationEndTime(request, task, request.abortTime);\n-        errorId = serializeByValueID(errorId);\n-        task = encodeReferenceChunk(request, task.id, errorId);\n-        request.completedErrorChunks.push(task);\n-      }\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        task.timed && markOperationEndTime(request, task, request.abortTime),\n+        (errorId = serializeByValueID(errorId)),\n+        (task = encodeReferenceChunk(request, task.id, errorId)),\n+        request.completedErrorChunks.push(task));\n+    }\n+    function haltTask(task) {\n+      0 === task.status && (task.status = 3);\n+    }\n+    function finishHaltedTask(task, request) {\n+      3 === task.status &&\n+        (forwardDebugInfoFromAbortedTask(request, task),\n+        request.pendingChunks--);\n     }\n     function flushCompletedChunks(request) {\n       if (null !== request.debugDestination) {\n@@ -4088,6 +4123,18 @@\n         }\n       }\n     }\n+    function finishHalt(request, abortedTasks) {\n+      try {\n+        abortedTasks.forEach(function (task) {\n+          return finishHaltedTask(task, request);\n+        });\n+        var onAllReady = request.onAllReady;\n+        onAllReady();\n+        flushCompletedChunks(request);\n+      } catch (error) {\n+        logRecoverableError(request, error, null), fatalError(request, error);\n+      }\n+    }\n     function finishAbort(request, abortedTasks, errorId) {\n       try {\n         abortedTasks.forEach(function (task) {\n@@ -4107,31 +4154,40 @@\n           request.abortTime = performance.now();\n           request.cacheController.abort(reason);\n           var abortableTasks = request.abortableTasks;\n-          if (0 < abortableTasks.size) {\n-            var error =\n-                void 0 === reason\n-                  ? Error(\n-                      \"The render was aborted by the server without a reason.\"\n-                    )\n-                  : \"object\" === typeof reason &&\n-                      null !== reason &&\n-                      \"function\" === typeof reason.then\n+          if (0 < abortableTasks.size)\n+            if (21 === request.type)\n+              abortableTasks.forEach(function (task) {\n+                return haltTask(task, request);\n+              }),\n+                setImmediate(function () {\n+                  return finishHalt(request, abortableTasks);\n+                });\n+            else {\n+              var error =\n+                  void 0 === reason\n                     ? Error(\n-                        \"The render was aborted by the server with a promise.\"\n+                        \"The render was aborted by the server without a reason.\"\n                       )\n-                    : reason,\n-              digest = logRecoverableError(request, error, null),\n-              _errorId2 = request.nextChunkId++;\n-            request.fatalError = _errorId2;\n-            request.pendingChunks++;\n-            emitErrorChunk(request, _errorId2, digest, error, !1, null);\n-            abortableTasks.forEach(function (task) {\n-              return abortTask(task, request, _errorId2);\n-            });\n-            setImmediate(function () {\n-              return finishAbort(request, abortableTasks, _errorId2);\n-            });\n-          } else {\n+                    : \"object\" === typeof reason &&\n+                        null !== reason &&\n+                        \"function\" === typeof reason.then\n+                      ? Error(\n+                          \"The render was aborted by the server with a promise.\"\n+                        )\n+                      : reason,\n+                digest = logRecoverableError(request, error, null),\n+                _errorId2 = request.nextChunkId++;\n+              request.fatalError = _errorId2;\n+              request.pendingChunks++;\n+              emitErrorChunk(request, _errorId2, digest, error, !1, null);\n+              abortableTasks.forEach(function (task) {\n+                return abortTask(task, request, _errorId2);\n+              });\n+              setImmediate(function () {\n+                return finishAbort(request, abortableTasks, _errorId2);\n+              });\n+            }\n+          else {\n             var onAllReady = request.onAllReady;\n             onAllReady();\n             flushCompletedChunks(request);\n@@ -5800,12 +5856,12 @@\n             \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n           );\n         pendingFiles++;\n-        var JSCompiler_object_inline_chunks_246 = [];\n+        var JSCompiler_object_inline_chunks_250 = [];\n         value.on(\"data\", function (chunk) {\n-          JSCompiler_object_inline_chunks_246.push(chunk);\n+          JSCompiler_object_inline_chunks_250.push(chunk);\n         });\n         value.on(\"end\", function () {\n-          var blob = new Blob(JSCompiler_object_inline_chunks_246, {\n+          var blob = new Blob(JSCompiler_object_inline_chunks_250, {\n             type: mimeType\n           });\n           response._formData.append(name, blob, filename);\n@@ -5829,6 +5885,94 @@\n       });\n       return getChunk(response, 0);\n     };\n+    exports.prerender = function (model, webpackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          webpackMap,\n+          function () {\n+            var writable,\n+              stream = new ReadableStream(\n+                {\n+                  type: \"bytes\",\n+                  start: function (controller) {\n+                    writable =\n+                      createFakeWritableFromReadableStreamController(\n+                        controller\n+                      );\n+                  },\n+                  pull: function () {\n+                    startFlowing(request, writable);\n+                  },\n+                  cancel: function (reason) {\n+                    request.destination = null;\n+                    abort(request, reason);\n+                  }\n+                },\n+                { highWaterMark: 0 }\n+              );\n+            resolve({ prelude: stream });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n+    exports.prerenderToNodeStream = function (model, webpackMap, options) {\n+      return new Promise(function (resolve, reject) {\n+        var request = createPrerenderRequest(\n+          model,\n+          webpackMap,\n+          function () {\n+            var readable = new stream.Readable({\n+                read: function () {\n+                  startFlowing(request, writable);\n+                }\n+              }),\n+              writable = createFakeWritableFromNodeReadable(readable);\n+            resolve({ prelude: readable });\n+          },\n+          reject,\n+          options ? options.onError : void 0,\n+          options ? options.identifierPrefix : void 0,\n+          options ? options.onPostpone : void 0,\n+          options ? options.temporaryReferences : void 0,\n+          options ? options.environmentName : void 0,\n+          options ? options.filterStackFrame : void 0,\n+          !1\n+        );\n+        if (options && options.signal) {\n+          var signal = options.signal;\n+          if (signal.aborted) abort(request, signal.reason);\n+          else {\n+            var listener = function () {\n+              abort(request, signal.reason);\n+              signal.removeEventListener(\"abort\", listener);\n+            };\n+            signal.addEventListener(\"abort\", listener);\n+          }\n+        }\n+        startWork(request);\n+      });\n+    };\n     exports.registerClientReference = function (\n       proxyImplementation,\n       id,\n@@ -5987,96 +6131,4 @@\n         { highWaterMark: 0 }\n       );\n     };\n-    exports.unstable_prerender = function (model, webpackMap, options) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          webpackMap,\n-          function () {\n-            var writable,\n-              stream = new ReadableStream(\n-                {\n-                  type: \"bytes\",\n-                  start: function (controller) {\n-                    writable =\n-                      createFakeWritableFromReadableStreamController(\n-                        controller\n-                      );\n-                  },\n-                  pull: function () {\n-                    startFlowing(request, writable);\n-                  },\n-                  cancel: function (reason) {\n-                    request.destination = null;\n-                    abort(request, reason);\n-                  }\n-                },\n-                { highWaterMark: 0 }\n-              );\n-            resolve({ prelude: stream });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n-    exports.unstable_prerenderToNodeStream = function (\n-      model,\n-      webpackMap,\n-      options\n-    ) {\n-      return new Promise(function (resolve, reject) {\n-        var request = createPrerenderRequest(\n-          model,\n-          webpackMap,\n-          function () {\n-            var readable = new stream.Readable({\n-                read: function () {\n-                  startFlowing(request, writable);\n-                }\n-              }),\n-              writable = createFakeWritableFromNodeReadable(readable);\n-            resolve({ prelude: readable });\n-          },\n-          reject,\n-          options ? options.onError : void 0,\n-          options ? options.identifierPrefix : void 0,\n-          options ? options.onPostpone : void 0,\n-          options ? options.temporaryReferences : void 0,\n-          options ? options.environmentName : void 0,\n-          options ? options.filterStackFrame : void 0,\n-          !1\n-        );\n-        if (options && options.signal) {\n-          var signal = options.signal;\n-          if (signal.aborted) abort(request, signal.reason);\n-          else {\n-            var listener = function () {\n-              abort(request, signal.reason);\n-              signal.removeEventListener(\"abort\", listener);\n-            };\n-            signal.addEventListener(\"abort\", listener);\n-          }\n-        }\n-        startWork(request);\n-      });\n-    };\n   })();"
        },
        {
            "sha": "296efe04d726137bb5d89294575dba93168b076b",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/cjs/react-server-dom-webpack-server.node.unbundled.production.js",
            "status": "modified",
            "additions": 189,
            "deletions": 131,
            "changes": 320,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fcjs%2Freact-server-dom-webpack-server.node.unbundled.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -915,9 +915,11 @@ function serializeThenable(request, task, thenable) {\n       if (12 === request.status)\n         return (\n           request.abortableTasks.delete(newTask),\n-          (task = request.fatalError),\n-          abortTask(newTask),\n-          finishAbortedTask(newTask, request, task),\n+          21 === request.type\n+            ? (haltTask(newTask), finishHaltedTask(newTask, request))\n+            : ((task = request.fatalError),\n+              abortTask(newTask),\n+              finishAbortedTask(newTask, request, task)),\n           newTask.id\n         );\n       \"string\" !== typeof thenable.status &&\n@@ -983,8 +985,11 @@ function serializeReadableStream(request, task, stream) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortStream);\n       signal = signal.reason;\n-      erroredTask(request, streamTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1069,8 +1074,12 @@ function serializeAsyncIterable(request, task, iterable, iterator) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortIterable);\n       var reason = signal.reason;\n-      erroredTask(request, streamTask, signal.reason);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(streamTask),\n+          haltTask(streamTask),\n+          finishHaltedTask(streamTask, request))\n+        : (erroredTask(request, streamTask, signal.reason),\n+          enqueueFlush(request));\n       \"function\" === typeof iterator.throw &&\n         iterator.throw(reason).then(error, error);\n     }\n@@ -1199,7 +1208,7 @@ function deferTask(request, task) {\n     request.abortableTasks\n   );\n   pingTask(request, task);\n-  return \"$L\" + task.id.toString(16);\n+  return serializeLazyID(task.id);\n }\n function renderElement(request, task, type, key, ref, props) {\n   if (null !== ref && void 0 !== ref)\n@@ -1319,10 +1328,16 @@ function createTask(\n           12 === request.status)\n         )\n           (task.status = 3),\n-            (prevKeyPath = request.fatalError),\n-            (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n-              : serializeByValueID(prevKeyPath));\n+            21 === request.type\n+              ? ((prevKeyPath = request.nextChunkId++),\n+                (prevKeyPath = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)),\n+                (JSCompiler_inline_result = prevKeyPath))\n+              : ((prevKeyPath = request.fatalError),\n+                (JSCompiler_inline_result = parentPropertyName\n+                  ? serializeLazyID(prevKeyPath)\n+                  : serializeByValueID(prevKeyPath)));\n         else if (\n           ((value =\n             thrownValue === SuspenseException\n@@ -1347,7 +1362,7 @@ function createTask(\n           task.keyPath = prevKeyPath;\n           task.implicitSlot = prevImplicitSlot;\n           JSCompiler_inline_result = parentPropertyName\n-            ? \"$L\" + JSCompiler_inline_result.id.toString(16)\n+            ? serializeLazyID(JSCompiler_inline_result.id)\n             : serializeByValueID(JSCompiler_inline_result.id);\n         } else\n           (task.keyPath = prevKeyPath),\n@@ -1357,7 +1372,7 @@ function createTask(\n             (prevImplicitSlot = logRecoverableError(request, value, task)),\n             emitErrorChunk(request, prevKeyPath, prevImplicitSlot),\n             (JSCompiler_inline_result = parentPropertyName\n-              ? \"$L\" + prevKeyPath.toString(16)\n+              ? serializeLazyID(prevKeyPath)\n               : serializeByValueID(prevKeyPath));\n       }\n       return JSCompiler_inline_result;\n@@ -1370,6 +1385,9 @@ function createTask(\n function serializeByValueID(id) {\n   return \"$\" + id.toString(16);\n }\n+function serializeLazyID(id) {\n+  return \"$L\" + id.toString(16);\n+}\n function encodeReferenceChunk(request, id, reference) {\n   request = stringify(reference);\n   return id.toString(16) + \":\" + request + \"\\n\";\n@@ -1387,7 +1405,7 @@ function serializeClientReference(\n     existingId = writtenClientReferences.get(clientReferenceKey);\n   if (void 0 !== existingId)\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + existingId.toString(16)\n+      ? serializeLazyID(existingId)\n       : serializeByValueID(existingId);\n   try {\n     var config = request.bundlerConfig,\n@@ -1424,7 +1442,7 @@ function serializeClientReference(\n     request.completedImportChunks.push(processedChunk);\n     writtenClientReferences.set(clientReferenceKey, importId);\n     return parent[0] === REACT_ELEMENT_TYPE && \"1\" === parentPropertyName\n-      ? \"$L\" + importId.toString(16)\n+      ? serializeLazyID(importId)\n       : serializeByValueID(importId);\n   } catch (x) {\n     return (\n@@ -1477,8 +1495,11 @@ function serializeBlob(request, blob) {\n       var signal = request.cacheController.signal;\n       signal.removeEventListener(\"abort\", abortBlob);\n       signal = signal.reason;\n-      erroredTask(request, newTask, signal);\n-      enqueueFlush(request);\n+      21 === request.type\n+        ? (request.abortableTasks.delete(newTask),\n+          haltTask(newTask),\n+          finishHaltedTask(newTask, request))\n+        : (erroredTask(request, newTask, signal), enqueueFlush(request));\n       reader.cancel(signal).then(error, error);\n     }\n   }\n@@ -1919,13 +1940,19 @@ function retryTask(request, task) {\n       request.abortableTasks.delete(task);\n       callOnAllReadyIfReady(request);\n     } catch (thrownValue) {\n-      if (12 === request.status) {\n-        request.abortableTasks.delete(task);\n-        task.status = 0;\n-        var errorId = request.fatalError;\n-        abortTask(task);\n-        finishAbortedTask(task, request, errorId);\n-      } else {\n+      if (12 === request.status)\n+        if (\n+          (request.abortableTasks.delete(task),\n+          (task.status = 0),\n+          21 === request.type)\n+        )\n+          haltTask(task), finishHaltedTask(task, request);\n+        else {\n+          var errorId = request.fatalError;\n+          abortTask(task);\n+          finishAbortedTask(task, request, errorId);\n+        }\n+      else {\n         var x =\n           thrownValue === SuspenseException\n             ? getSuspendedThenable()\n@@ -1982,6 +2009,12 @@ function finishAbortedTask(task, request, errorId) {\n     (task = encodeReferenceChunk(request, task.id, errorId)),\n     request.completedErrorChunks.push(task));\n }\n+function haltTask(task) {\n+  0 === task.status && (task.status = 3);\n+}\n+function finishHaltedTask(task, request) {\n+  3 === task.status && request.pendingChunks--;\n+}\n function flushCompletedChunks(request) {\n   var destination = request.destination;\n   if (null !== destination) {\n@@ -2091,6 +2124,18 @@ function startFlowing(request, destination) {\n     }\n   }\n }\n+function finishHalt(request, abortedTasks) {\n+  try {\n+    abortedTasks.forEach(function (task) {\n+      return finishHaltedTask(task, request);\n+    });\n+    var onAllReady = request.onAllReady;\n+    onAllReady();\n+    flushCompletedChunks(request);\n+  } catch (error) {\n+    logRecoverableError(request, error, null), fatalError(request, error);\n+  }\n+}\n function finishAbort(request, abortedTasks, errorId) {\n   try {\n     abortedTasks.forEach(function (task) {\n@@ -2109,27 +2154,40 @@ function abort(request, reason) {\n       request.status = 12;\n       request.cacheController.abort(reason);\n       var abortableTasks = request.abortableTasks;\n-      if (0 < abortableTasks.size) {\n-        var error =\n-            void 0 === reason\n-              ? Error(\"The render was aborted by the server without a reason.\")\n-              : \"object\" === typeof reason &&\n-                  null !== reason &&\n-                  \"function\" === typeof reason.then\n-                ? Error(\"The render was aborted by the server with a promise.\")\n-                : reason,\n-          digest = logRecoverableError(request, error, null),\n-          errorId = request.nextChunkId++;\n-        request.fatalError = errorId;\n-        request.pendingChunks++;\n-        emitErrorChunk(request, errorId, digest, error, !1, null);\n-        abortableTasks.forEach(function (task) {\n-          return abortTask(task, request, errorId);\n-        });\n-        setImmediate(function () {\n-          return finishAbort(request, abortableTasks, errorId);\n-        });\n-      } else {\n+      if (0 < abortableTasks.size)\n+        if (21 === request.type)\n+          abortableTasks.forEach(function (task) {\n+            return haltTask(task, request);\n+          }),\n+            setImmediate(function () {\n+              return finishHalt(request, abortableTasks);\n+            });\n+        else {\n+          var error =\n+              void 0 === reason\n+                ? Error(\n+                    \"The render was aborted by the server without a reason.\"\n+                  )\n+                : \"object\" === typeof reason &&\n+                    null !== reason &&\n+                    \"function\" === typeof reason.then\n+                  ? Error(\n+                      \"The render was aborted by the server with a promise.\"\n+                    )\n+                  : reason,\n+            digest = logRecoverableError(request, error, null),\n+            errorId = request.nextChunkId++;\n+          request.fatalError = errorId;\n+          request.pendingChunks++;\n+          emitErrorChunk(request, errorId, digest, error, !1, null);\n+          abortableTasks.forEach(function (task) {\n+            return abortTask(task, request, errorId);\n+          });\n+          setImmediate(function () {\n+            return finishAbort(request, abortableTasks, errorId);\n+          });\n+        }\n+      else {\n         var onAllReady = request.onAllReady;\n         onAllReady();\n         flushCompletedChunks(request);\n@@ -2983,12 +3041,12 @@ exports.decodeReplyFromBusboy = function (busboyStream, webpackMap, options) {\n         \"React doesn't accept base64 encoded file uploads because we don't expect form data passed from a browser to ever encode data that way. If that's the wrong assumption, we can easily fix it.\"\n       );\n     pendingFiles++;\n-    var JSCompiler_object_inline_chunks_270 = [];\n+    var JSCompiler_object_inline_chunks_274 = [];\n     value.on(\"data\", function (chunk) {\n-      JSCompiler_object_inline_chunks_270.push(chunk);\n+      JSCompiler_object_inline_chunks_274.push(chunk);\n     });\n     value.on(\"end\", function () {\n-      var blob = new Blob(JSCompiler_object_inline_chunks_270, {\n+      var blob = new Blob(JSCompiler_object_inline_chunks_274, {\n         type: mimeType\n       });\n       response._formData.append(name, blob, filename);\n@@ -3008,6 +3066,88 @@ exports.decodeReplyFromBusboy = function (busboyStream, webpackMap, options) {\n   });\n   return getChunk(response, 0);\n };\n+exports.prerender = function (model, webpackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      webpackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var writable,\n+          stream = new ReadableStream(\n+            {\n+              type: \"bytes\",\n+              start: function (controller) {\n+                writable =\n+                  createFakeWritableFromReadableStreamController(controller);\n+              },\n+              pull: function () {\n+                startFlowing(request, writable);\n+              },\n+              cancel: function (reason) {\n+                request.destination = null;\n+                abort(request, reason);\n+              }\n+            },\n+            { highWaterMark: 0 }\n+          );\n+        resolve({ prelude: stream });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n+exports.prerenderToNodeStream = function (model, webpackMap, options) {\n+  return new Promise(function (resolve, reject) {\n+    var request = new RequestInstance(\n+      21,\n+      model,\n+      webpackMap,\n+      options ? options.onError : void 0,\n+      options ? options.onPostpone : void 0,\n+      function () {\n+        var readable = new stream.Readable({\n+            read: function () {\n+              startFlowing(request, writable);\n+            }\n+          }),\n+          writable = createFakeWritableFromNodeReadable(readable);\n+        resolve({ prelude: readable });\n+      },\n+      reject,\n+      options ? options.identifierPrefix : void 0,\n+      options ? options.temporaryReferences : void 0\n+    );\n+    if (options && options.signal) {\n+      var signal = options.signal;\n+      if (signal.aborted) abort(request, signal.reason);\n+      else {\n+        var listener = function () {\n+          abort(request, signal.reason);\n+          signal.removeEventListener(\"abort\", listener);\n+        };\n+        signal.addEventListener(\"abort\", listener);\n+      }\n+    }\n+    startWork(request);\n+  });\n+};\n exports.registerClientReference = function (\n   proxyImplementation,\n   id,\n@@ -3113,85 +3253,3 @@ exports.renderToReadableStream = function (model, webpackMap, options) {\n     { highWaterMark: 0 }\n   );\n };\n-exports.unstable_prerender = function (model, webpackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      webpackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var writable,\n-          stream = new ReadableStream(\n-            {\n-              type: \"bytes\",\n-              start: function (controller) {\n-                writable =\n-                  createFakeWritableFromReadableStreamController(controller);\n-              },\n-              pull: function () {\n-                startFlowing(request, writable);\n-              },\n-              cancel: function (reason) {\n-                request.destination = null;\n-                abort(request, reason);\n-              }\n-            },\n-            { highWaterMark: 0 }\n-          );\n-        resolve({ prelude: stream });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};\n-exports.unstable_prerenderToNodeStream = function (model, webpackMap, options) {\n-  return new Promise(function (resolve, reject) {\n-    var request = new RequestInstance(\n-      21,\n-      model,\n-      webpackMap,\n-      options ? options.onError : void 0,\n-      options ? options.onPostpone : void 0,\n-      function () {\n-        var readable = new stream.Readable({\n-            read: function () {\n-              startFlowing(request, writable);\n-            }\n-          }),\n-          writable = createFakeWritableFromNodeReadable(readable);\n-        resolve({ prelude: readable });\n-      },\n-      reject,\n-      options ? options.identifierPrefix : void 0,\n-      options ? options.temporaryReferences : void 0\n-    );\n-    if (options && options.signal) {\n-      var signal = options.signal;\n-      if (signal.aborted) abort(request, signal.reason);\n-      else {\n-        var listener = function () {\n-          abort(request, signal.reason);\n-          signal.removeEventListener(\"abort\", listener);\n-        };\n-        signal.addEventListener(\"abort\", listener);\n-      }\n-    }\n-    startWork(request);\n-  });\n-};"
        },
        {
            "sha": "e2f1e5c7d05d3d6eef9183e7dfa3b44561318ac4",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/package.json",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fpackage.json?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -64,8 +64,8 @@\n     \"webpack-sources\": \"^3.2.0\"\n   },\n   \"peerDependencies\": {\n-    \"react\": \"19.2.0-canary-548235db-20251001\",\n-    \"react-dom\": \"19.2.0-canary-548235db-20251001\",\n+    \"react\": \"19.2.0-canary-1bd1f01f-20251001\",\n+    \"react-dom\": \"19.2.0-canary-1bd1f01f-20251001\",\n     \"webpack\": \"^5.59.0\"\n   }\n }\n\\ No newline at end of file"
        },
        {
            "sha": "06218aec3d4376a88b796de0007277671c4bb2b8",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/static.browser.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fstatic.browser.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fstatic.browser.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fstatic.browser.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,6 +7,4 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-webpack-server.browser.development.js');\n }\n \n-if (s.unstable_prerender) {\n-  exports.unstable_prerender = s.unstable_prerender;\n-}\n+exports.prerender = s.prerender;"
        },
        {
            "sha": "df9085690aaf69b7f1e069f9c39a245e856e72ec",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/static.edge.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fstatic.edge.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fstatic.edge.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fstatic.edge.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,6 +7,4 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-webpack-server.edge.development.js');\n }\n \n-if (s.unstable_prerender) {\n-  exports.unstable_prerender = s.unstable_prerender;\n-}\n+exports.prerender = s.prerender;"
        },
        {
            "sha": "2f649d1fc514e05bce78a7f26974ff9b81f171c4",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/static.node.js",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fstatic.node.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fstatic.node.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fstatic.node.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,9 +7,5 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-webpack-server.node.development.js');\n }\n \n-if (s.unstable_prerender) {\n-  exports.unstable_prerender = s.unstable_prerender;\n-}\n-if (s.unstable_prerenderToNodeStream) {\n-  exports.unstable_prerenderToNodeStream = s.unstable_prerenderToNodeStream;\n-}\n+exports.prerender = s.prerender;\n+exports.prerenderToNodeStream = s.prerenderToNodeStream;"
        },
        {
            "sha": "850886dcd9e78fb4e424bd464dbea01fe941d502",
            "filename": "packages/next/src/compiled/react-server-dom-webpack/static.node.unbundled.js",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fstatic.node.unbundled.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fstatic.node.unbundled.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact-server-dom-webpack%2Fstatic.node.unbundled.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,6 +7,4 @@ if (process.env.NODE_ENV === 'production') {\n   s = require('./cjs/react-server-dom-webpack-server.node.unbundled.development.js');\n }\n \n-if (s.unstable_prerenderToNodeStream) {\n-  exports.unstable_prerenderToNodeStream = s.unstable_prerenderToNodeStream;\n-}\n+exports.prerenderToNodeStream = s.prerenderToNodeStream;"
        },
        {
            "sha": "7161c91ee7764665fbd2d3f2bde28a146ff5b23d",
            "filename": "packages/next/src/compiled/react/cjs/react.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1276,7 +1276,7 @@\n     exports.useTransition = function () {\n       return resolveDispatcher().useTransition();\n     };\n-    exports.version = \"19.2.0-canary-548235db-20251001\";\n+    exports.version = \"19.2.0-canary-1bd1f01f-20251001\";\n     \"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ &&\n       \"function\" ===\n         typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop &&"
        },
        {
            "sha": "b1a371c686f6d2310456f6e342ac48219880f129",
            "filename": "packages/next/src/compiled/react/cjs/react.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -539,4 +539,4 @@ exports.useSyncExternalStore = function (\n exports.useTransition = function () {\n   return ReactSharedInternals.H.useTransition();\n };\n-exports.version = \"19.2.0-canary-548235db-20251001\";\n+exports.version = \"19.2.0-canary-1bd1f01f-20251001\";"
        },
        {
            "sha": "1a92ff88d0d42067948ded8e8cd1e1d3bc5a3571",
            "filename": "packages/next/src/compiled/react/cjs/react.react-server.development.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.react-server.development.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.react-server.development.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.react-server.development.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -844,5 +844,5 @@\n     exports.useMemo = function (create, deps) {\n       return resolveDispatcher().useMemo(create, deps);\n     };\n-    exports.version = \"19.2.0-canary-548235db-20251001\";\n+    exports.version = \"19.2.0-canary-1bd1f01f-20251001\";\n   })();"
        },
        {
            "sha": "8acc874408b969e2e2b834cfdad865e94f01192e",
            "filename": "packages/next/src/compiled/react/cjs/react.react-server.production.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.react-server.production.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.react-server.production.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Freact%2Fcjs%2Freact.react-server.production.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -420,4 +420,4 @@ exports.useId = function () {\n exports.useMemo = function (create, deps) {\n   return ReactSharedInternals.H.useMemo(create, deps);\n };\n-exports.version = \"19.2.0-canary-548235db-20251001\";\n+exports.version = \"19.2.0-canary-1bd1f01f-20251001\";"
        },
        {
            "sha": "d4c4ee7a446926e978f39c100d6cb0befc0d9d24",
            "filename": "packages/next/src/compiled/unistore/unistore.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Funistore%2Funistore.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fcompiled%2Funistore%2Funistore.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Funistore%2Funistore.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1 +1 @@\n-(()=>{var t={249:t=>{function n(t,i){for(var _ in i)t[_]=i[_];return t}t.exports=function(t){var i=[];function u(t){for(var _=[],a=0;a<i.length;a++)i[a]===t?t=null:_.push(i[a]);i=_}function e(_,a,f){t=a?_:n(n({},t),_);for(var o=i,c=0;c<o.length;c++)o[c](t,f)}return t=t||{},{action:function(i){function r(t){e(t,!1,i)}return function(){for(var _=arguments,a=[t],f=0;f<arguments.length;f++)a.push(_[f]);var o=i.apply(this,a);if(null!=o)return o.then?o.then(r):r(o)}},setState:e,subscribe:function(t){return i.push(t),function(){u(t)}},unsubscribe:u,getState:function(){return t}}}}};var i={};function __nccwpck_require__(_){var a=i[_];if(a!==undefined){return a.exports}var f=i[_]={exports:{}};var o=true;try{t[_](f,f.exports,__nccwpck_require__);o=false}finally{if(o)delete i[_]}return f.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var _=__nccwpck_require__(249);module.exports=_})();\n\\ No newline at end of file\n+(()=>{var t={518:t=>{function n(t,i){for(var _ in i)t[_]=i[_];return t}t.exports=function(t){var i=[];function u(t){for(var _=[],a=0;a<i.length;a++)i[a]===t?t=null:_.push(i[a]);i=_}function e(_,a,f){t=a?_:n(n({},t),_);for(var o=i,c=0;c<o.length;c++)o[c](t,f)}return t=t||{},{action:function(i){function r(t){e(t,!1,i)}return function(){for(var _=arguments,a=[t],f=0;f<arguments.length;f++)a.push(_[f]);var o=i.apply(this,a);if(null!=o)return o.then?o.then(r):r(o)}},setState:e,subscribe:function(t){return i.push(t),function(){u(t)}},unsubscribe:u,getState:function(){return t}}}}};var i={};function __nccwpck_require__(_){var a=i[_];if(a!==undefined){return a.exports}var f=i[_]={exports:{}};var o=true;try{t[_](f,f.exports,__nccwpck_require__);o=false}finally{if(o)delete i[_]}return f.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var _=__nccwpck_require__(518);module.exports=_})();\n\\ No newline at end of file"
        },
        {
            "sha": "54b65b7bedb29c1bbe04459a31e66c5e41ee7b10",
            "filename": "packages/next/src/server/app-render/collect-segment-data.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -11,7 +11,7 @@ import type { ManifestNode } from '../../build/webpack/plugins/flight-manifest-p\n // eslint-disable-next-line import/no-extraneous-dependencies\n import { createFromReadableStream } from 'react-server-dom-webpack/client'\n // eslint-disable-next-line import/no-extraneous-dependencies\n-import { unstable_prerender as prerender } from 'react-server-dom-webpack/static'\n+import { prerender } from 'react-server-dom-webpack/static'\n \n import {\n   streamFromBuffer,"
        },
        {
            "sha": "f1d76982726839abe65ea4748f1209ecefb76ad7",
            "filename": "packages/next/src/server/app-render/entry-base.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fentry-base.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fentry-base.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fentry-base.ts?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -8,7 +8,7 @@ export {\n } from 'react-server-dom-webpack/server'\n \n // eslint-disable-next-line import/no-extraneous-dependencies\n-export { unstable_prerender as prerender } from 'react-server-dom-webpack/static'\n+export { prerender } from 'react-server-dom-webpack/static'\n \n // eslint-disable-next-line import/no-extraneous-dependencies\n export { captureOwnerStack } from 'react'"
        },
        {
            "sha": "0b7a81cba86f5275ced2a4aa328234bcb1d63ff1",
            "filename": "packages/next/src/server/app-render/postponed-state.test.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.test.ts?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -45,7 +45,7 @@ describe('getDynamicHTMLPostponedState', () => {\n     )\n \n     const state = await getDynamicHTMLPostponedState(\n-      { [key]: key, nested: { [key]: key } },\n+      { [key]: key, nested: { [key]: key } } as any,\n       DynamicHTMLPreludeState.Full,\n       fallbackRouteParams,\n       prerenderResumeDataCache,\n@@ -86,7 +86,7 @@ describe('getDynamicHTMLPostponedState', () => {\n \n   it('serializes a HTML postponed state without fallback params', async () => {\n     const state = await getDynamicHTMLPostponedState(\n-      { key: 'value' },\n+      { key: 'value' } as any,\n       DynamicHTMLPreludeState.Full,\n       null,\n       createPrerenderResumeDataCache(),\n@@ -101,7 +101,7 @@ describe('getDynamicHTMLPostponedState', () => {\n       slug: [key, 'd'],\n     })\n     const state = await getDynamicHTMLPostponedState(\n-      { [key]: key },\n+      { [key]: key } as any,\n       DynamicHTMLPreludeState.Full,\n       fallbackRouteParams,\n       createPrerenderResumeDataCache(),"
        },
        {
            "sha": "18e3c0cee1255e879846856c0e58a30e907c3686",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -11,7 +11,7 @@ import {\n   encodeReply,\n   createTemporaryReferenceSet as createClientTemporaryReferenceSet,\n } from 'react-server-dom-webpack/client'\n-import { unstable_prerender as prerender } from 'react-server-dom-webpack/static'\n+import { prerender } from 'react-server-dom-webpack/static'\n /* eslint-enable import/no-extraneous-dependencies */\n \n import type { WorkStore } from '../app-render/work-async-storage.external'"
        },
        {
            "sha": "b9c97707374227a8a0335c02fcd8484c2326f5e4",
            "filename": "packages/next/types/$$compiled.internal.d.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Ftypes%2F%24%24compiled.internal.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Ftypes%2F%24%24compiled.internal.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ftypes%2F%24%24compiled.internal.d.ts?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -264,7 +264,7 @@ declare module 'react-server-dom-webpack/server.node' {\n declare module 'react-server-dom-webpack/static' {\n   export type TemporaryReferenceSet = WeakMap<any, string>\n \n-  export function unstable_prerender(\n+  export function prerender(\n     children: any,\n     webpackMap: {\n       readonly [id: string]: {"
        },
        {
            "sha": "c89afe20988030ee1e8a3da51df163b6b8662e27",
            "filename": "packages/next/types/react-dom.d.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 51,
            "changes": 58,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Ftypes%2Freact-dom.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/packages%2Fnext%2Ftypes%2Freact-dom.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ftypes%2Freact-dom.d.ts?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -1,46 +1,16 @@\n-import type { JSX } from 'react'\n+export {}\n \n declare module 'react-dom/server' {\n-  /**\n-   * Options for `resume`.\n-   *\n-   * https://github.com/facebook/react/blob/aec521a96d3f1bebc2ba38553d14f4989c6e88e0/packages/react-dom/src/server/ReactDOMFizzServerEdge.js#L54-L60\n-   */\n-  export type ResumeOptions = {\n-    nonce?: string\n-    signal?: AbortSignal\n-    onError?: (error: unknown) => string | undefined | void\n-    onPostpone?: (reason: string) => void\n-    unstable_externalRuntimeSrc?: string | BootstrapScriptDescriptor\n-  }\n-\n-  export function resume(\n-    children: JSX.Element,\n-    postponedState: object,\n-    options?: ResumeOptions\n-  ): Promise<ReadableStream<Uint8Array>>\n-\n   /**\n    * Options for `renderToReadableStream`.\n    *\n    * https://github.com/facebook/react/blob/aec521a96d3f1bebc2ba38553d14f4989c6e88e0/packages/react-dom/src/server/ReactDOMFizzServerEdge.js#L36-L52\n    */\n   export interface RenderToReadableStreamOptions {\n     onPostpone?: (reason: string) => void\n-    unstable_externalRuntimeSrc?: string | BootstrapScriptDescriptor\n-    importMap?: {\n-      imports?: {\n-        [specifier: string]: string\n-      }\n-      scopes?: {\n-        [scope: string]: {\n-          [specifier: string]: string\n-        }\n-      }\n-    }\n-    formState?: unknown\n-    onHeaders?: (headers: Headers) => void\n-    maxHeadersLength?: number\n+    unstable_externalRuntimeSrc?:\n+      | string\n+      | import('react-dom/server').BootstrapScriptDescriptor\n   }\n }\n \n@@ -52,22 +22,8 @@ declare module 'react-dom/static' {\n    */\n   export interface PrerenderOptions {\n     onPostpone?: (reason: string) => void\n-    unstable_externalRuntimeSrc?: string | BootstrapScriptDescriptor\n-    importMap?: {\n-      imports?: {\n-        [specifier: string]: string\n-      }\n-      scopes?: {\n-        [scope: string]: {\n-          [specifier: string]: string\n-        }\n-      }\n-    }\n-    onHeaders?: (headers: Headers) => void\n-    maxHeadersLength?: number\n-  }\n-\n-  interface PrerenderResult {\n-    postponed: object | null\n+    unstable_externalRuntimeSrc?:\n+      | string\n+      | import('react-dom/server').BootstrapScriptDescriptor\n   }\n }"
        },
        {
            "sha": "f1c44b0fc36d509d0b829d552365a09ab4a4311b",
            "filename": "pnpm-lock.yaml",
            "status": "modified",
            "additions": 747,
            "deletions": 747,
            "changes": 1494,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/pnpm-lock.yaml",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/pnpm-lock.yaml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/pnpm-lock.yaml?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151"
        },
        {
            "sha": "8db23990e58699e060dc886433a4b608051a6679",
            "filename": "test/development/app-dir/ssr-in-rsc/ssr-in-rsc.test.ts",
            "status": "modified",
            "additions": 160,
            "deletions": 346,
            "changes": 506,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/test%2Fdevelopment%2Fapp-dir%2Fssr-in-rsc%2Fssr-in-rsc.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/test%2Fdevelopment%2Fapp-dir%2Fssr-in-rsc%2Fssr-in-rsc.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fssr-in-rsc%2Fssr-in-rsc.test.ts?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -7,7 +7,6 @@ import {\n   getRedboxSource,\n } from 'next-test-utils'\n \n-const isReactExperimental = process.env.__NEXT_EXPERIMENTAL_PPR === 'true'\n const isReact18 = parseInt(process.env.NEXT_TEST_REACT_VERSION) === 18\n \n const isRspack = process.env.NEXT_RSPACK !== undefined\n@@ -44,89 +43,45 @@ describe('react-dom/server in React Server environment', () => {\n \n     await assertNoRedbox(browser)\n     if (isTurbopack) {\n-      if (isReactExperimental) {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-          \"{\n-            \"default\": [\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"resume\",\n-              \"version\"\n-            ],\n-            \"named\": [\n-              \"default\",\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"resume\",\n-              \"version\"\n-            ]\n-          }\"\n-        `)\n-      } else {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-          \"{\n-            \"default\": [\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"version\"\n-            ],\n-            \"named\": [\n-              \"default\",\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"version\"\n-            ]\n-          }\"\n-        `)\n-      }\n+      expect(await browser.elementByCss('main').text()).toMatchInlineSnapshot(`\n+        \"{\n+          \"default\": [\n+            \"renderToReadableStream\",\n+            \"renderToStaticMarkup\",\n+            \"renderToString\",\n+            \"resume\",\n+            \"version\"\n+          ],\n+          \"named\": [\n+            \"default\",\n+            \"renderToReadableStream\",\n+            \"renderToStaticMarkup\",\n+            \"renderToString\",\n+            \"resume\",\n+            \"version\"\n+          ]\n+        }\"\n+      `)\n     } else {\n-      if (isReactExperimental) {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-          \"{\n-            \"default\": [\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"resume\",\n-              \"version\"\n-            ],\n-            \"named\": [\n-              \"default\",\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"resume\",\n-              \"version\"\n-            ]\n-          }\"\n-        `)\n-      } else {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-          \"{\n-            \"default\": [\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"version\"\n-            ],\n-            \"named\": [\n-              \"default\",\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"version\"\n-            ]\n-          }\"\n-        `)\n-      }\n+      expect(await browser.elementByCss('main').text()).toMatchInlineSnapshot(`\n+        \"{\n+          \"default\": [\n+            \"renderToReadableStream\",\n+            \"renderToStaticMarkup\",\n+            \"renderToString\",\n+            \"resume\",\n+            \"version\"\n+          ],\n+          \"named\": [\n+            \"default\",\n+            \"renderToReadableStream\",\n+            \"renderToStaticMarkup\",\n+            \"renderToString\",\n+            \"resume\",\n+            \"version\"\n+          ]\n+        }\"\n+      `)\n     }\n     const redbox = {\n       description: await getRedboxDescription(browser),\n@@ -156,89 +111,45 @@ describe('react-dom/server in React Server environment', () => {\n \n     await assertNoRedbox(browser)\n     if (isTurbopack) {\n-      if (isReactExperimental) {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-          \"{\n-            \"default\": [\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"resume\",\n-              \"version\"\n-            ],\n-            \"named\": [\n-              \"default\",\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"resume\",\n-              \"version\"\n-            ]\n-          }\"\n-        `)\n-      } else {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-                  \"{\n-                    \"default\": [\n-                      \"renderToReadableStream\",\n-                      \"renderToStaticMarkup\",\n-                      \"renderToString\",\n-                      \"version\"\n-                    ],\n-                    \"named\": [\n-                      \"default\",\n-                      \"renderToReadableStream\",\n-                      \"renderToStaticMarkup\",\n-                      \"renderToString\",\n-                      \"version\"\n-                    ]\n-                  }\"\n-              `)\n-      }\n+      expect(await browser.elementByCss('main').text()).toMatchInlineSnapshot(`\n+        \"{\n+          \"default\": [\n+            \"renderToReadableStream\",\n+            \"renderToStaticMarkup\",\n+            \"renderToString\",\n+            \"resume\",\n+            \"version\"\n+          ],\n+          \"named\": [\n+            \"default\",\n+            \"renderToReadableStream\",\n+            \"renderToStaticMarkup\",\n+            \"renderToString\",\n+            \"resume\",\n+            \"version\"\n+          ]\n+        }\"\n+      `)\n     } else {\n-      if (isReactExperimental) {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-          \"{\n-            \"default\": [\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"resume\",\n-              \"version\"\n-            ],\n-            \"named\": [\n-              \"default\",\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"resume\",\n-              \"version\"\n-            ]\n-          }\"\n-        `)\n-      } else {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-          \"{\n-            \"default\": [\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"version\"\n-            ],\n-            \"named\": [\n-              \"default\",\n-              \"renderToReadableStream\",\n-              \"renderToStaticMarkup\",\n-              \"renderToString\",\n-              \"version\"\n-            ]\n-          }\"\n-        `)\n-      }\n+      expect(await browser.elementByCss('main').text()).toMatchInlineSnapshot(`\n+        \"{\n+          \"default\": [\n+            \"renderToReadableStream\",\n+            \"renderToStaticMarkup\",\n+            \"renderToString\",\n+            \"resume\",\n+            \"version\"\n+          ],\n+          \"named\": [\n+            \"default\",\n+            \"renderToReadableStream\",\n+            \"renderToStaticMarkup\",\n+            \"renderToString\",\n+            \"resume\",\n+            \"version\"\n+          ]\n+        }\"\n+      `)\n     }\n     const redbox = {\n       description: await getRedboxDescription(browser),\n@@ -547,98 +458,49 @@ describe('react-dom/server in React Server environment', () => {\n \n     await assertNoRedbox(browser)\n     if (isTurbopack) {\n-      if (isReactExperimental) {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-          \"{\n-            \"default\": {\n-              \"default\": [\n-                \"renderToReadableStream\",\n-                \"renderToStaticMarkup\",\n-                \"renderToString\",\n-                \"resume\",\n-                \"version\"\n-              ],\n-              \"named\": [\n-                \"default\",\n-                \"renderToReadableStream\",\n-                \"renderToStaticMarkup\",\n-                \"renderToString\",\n-                \"resume\",\n-                \"version\"\n-              ]\n-            }\n-          }\"\n-        `)\n-      } else {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-                  \"{\n-                    \"default\": {\n-                      \"default\": [\n-                        \"renderToReadableStream\",\n-                        \"renderToStaticMarkup\",\n-                        \"renderToString\",\n-                        \"version\"\n-                      ],\n-                      \"named\": [\n-                        \"default\",\n-                        \"renderToReadableStream\",\n-                        \"renderToStaticMarkup\",\n-                        \"renderToString\",\n-                        \"version\"\n-                      ]\n-                    }\n-                  }\"\n-              `)\n-      }\n+      expect(await browser.elementByCss('main').text()).toMatchInlineSnapshot(`\n+        \"{\n+          \"default\": {\n+            \"default\": [\n+              \"renderToReadableStream\",\n+              \"renderToStaticMarkup\",\n+              \"renderToString\",\n+              \"resume\",\n+              \"version\"\n+            ],\n+            \"named\": [\n+              \"default\",\n+              \"renderToReadableStream\",\n+              \"renderToStaticMarkup\",\n+              \"renderToString\",\n+              \"resume\",\n+              \"version\"\n+            ]\n+          }\n+        }\"\n+      `)\n     } else {\n-      if (isReactExperimental) {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-          \"{\n-            \"default\": {\n-              \"default\": [\n-                \"renderToReadableStream\",\n-                \"renderToStaticMarkup\",\n-                \"renderToString\",\n-                \"resume\",\n-                \"version\"\n-              ],\n-              \"named\": [\n-                \"default\",\n-                \"renderToReadableStream\",\n-                \"renderToStaticMarkup\",\n-                \"renderToString\",\n-                \"resume\",\n-                \"version\"\n-              ]\n-            }\n-          }\"\n-        `)\n-      } else {\n-        await assertNoRedbox(browser)\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-            \"{\n-              \"default\": {\n-                \"default\": [\n-                  \"renderToReadableStream\",\n-                  \"renderToStaticMarkup\",\n-                  \"renderToString\",\n-                  \"version\"\n-                ],\n-                \"named\": [\n-                  \"default\",\n-                  \"renderToReadableStream\",\n-                  \"renderToStaticMarkup\",\n-                  \"renderToString\",\n-                  \"version\"\n-                ]\n-              }\n-            }\"\n-          `)\n-      }\n+      expect(await browser.elementByCss('main').text()).toMatchInlineSnapshot(`\n+        \"{\n+          \"default\": {\n+            \"default\": [\n+              \"renderToReadableStream\",\n+              \"renderToStaticMarkup\",\n+              \"renderToString\",\n+              \"resume\",\n+              \"version\"\n+            ],\n+            \"named\": [\n+              \"default\",\n+              \"renderToReadableStream\",\n+              \"renderToStaticMarkup\",\n+              \"renderToString\",\n+              \"resume\",\n+              \"version\"\n+            ]\n+          }\n+        }\"\n+      `)\n     }\n     const redbox = {\n       description: await getRedboxDescription(browser),\n@@ -668,97 +530,49 @@ describe('react-dom/server in React Server environment', () => {\n \n     await assertNoRedbox(browser)\n     if (isTurbopack) {\n-      if (isReactExperimental) {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-          \"{\n-            \"default\": {\n-              \"default\": [\n-                \"renderToReadableStream\",\n-                \"renderToStaticMarkup\",\n-                \"renderToString\",\n-                \"resume\",\n-                \"version\"\n-              ],\n-              \"named\": [\n-                \"default\",\n-                \"renderToReadableStream\",\n-                \"renderToStaticMarkup\",\n-                \"renderToString\",\n-                \"resume\",\n-                \"version\"\n-              ]\n-            }\n-          }\"\n-        `)\n-      } else {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-                  \"{\n-                    \"default\": {\n-                      \"default\": [\n-                        \"renderToReadableStream\",\n-                        \"renderToStaticMarkup\",\n-                        \"renderToString\",\n-                        \"version\"\n-                      ],\n-                      \"named\": [\n-                        \"default\",\n-                        \"renderToReadableStream\",\n-                        \"renderToStaticMarkup\",\n-                        \"renderToString\",\n-                        \"version\"\n-                      ]\n-                    }\n-                  }\"\n-              `)\n-      }\n+      expect(await browser.elementByCss('main').text()).toMatchInlineSnapshot(`\n+        \"{\n+          \"default\": {\n+            \"default\": [\n+              \"renderToReadableStream\",\n+              \"renderToStaticMarkup\",\n+              \"renderToString\",\n+              \"resume\",\n+              \"version\"\n+            ],\n+            \"named\": [\n+              \"default\",\n+              \"renderToReadableStream\",\n+              \"renderToStaticMarkup\",\n+              \"renderToString\",\n+              \"resume\",\n+              \"version\"\n+            ]\n+          }\n+        }\"\n+      `)\n     } else {\n-      if (isReactExperimental) {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-          \"{\n-            \"default\": {\n-              \"default\": [\n-                \"renderToReadableStream\",\n-                \"renderToStaticMarkup\",\n-                \"renderToString\",\n-                \"resume\",\n-                \"version\"\n-              ],\n-              \"named\": [\n-                \"default\",\n-                \"renderToReadableStream\",\n-                \"renderToStaticMarkup\",\n-                \"renderToString\",\n-                \"resume\",\n-                \"version\"\n-              ]\n-            }\n-          }\"\n-        `)\n-      } else {\n-        expect(await browser.elementByCss('main').text())\n-          .toMatchInlineSnapshot(`\n-          \"{\n-            \"default\": {\n-              \"default\": [\n-                \"renderToReadableStream\",\n-                \"renderToStaticMarkup\",\n-                \"renderToString\",\n-                \"version\"\n-              ],\n-              \"named\": [\n-                \"default\",\n-                \"renderToReadableStream\",\n-                \"renderToStaticMarkup\",\n-                \"renderToString\",\n-                \"version\"\n-              ]\n-            }\n-          }\"\n-        `)\n-      }\n+      expect(await browser.elementByCss('main').text()).toMatchInlineSnapshot(`\n+        \"{\n+          \"default\": {\n+            \"default\": [\n+              \"renderToReadableStream\",\n+              \"renderToStaticMarkup\",\n+              \"renderToString\",\n+              \"resume\",\n+              \"version\"\n+            ],\n+            \"named\": [\n+              \"default\",\n+              \"renderToReadableStream\",\n+              \"renderToStaticMarkup\",\n+              \"renderToString\",\n+              \"resume\",\n+              \"version\"\n+            ]\n+          }\n+        }\"\n+      `)\n     }\n     const redbox = {\n       description: await getRedboxDescription(browser),"
        },
        {
            "sha": "1df75532eab0e04ff8c254c041fbe3cca114af95",
            "filename": "test/lib/next-modes/base.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/test%2Flib%2Fnext-modes%2Fbase.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/test%2Flib%2Fnext-modes%2Fbase.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Flib%2Fnext-modes%2Fbase.ts?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -217,8 +217,8 @@ export class NextInstance {\n         const finalDependencies = {\n           react: reactVersion,\n           'react-dom': reactVersion,\n-          '@types/react': '19.1.14',\n-          '@types/react-dom': '19.1.7',\n+          '@types/react': '19.1.16',\n+          '@types/react-dom': '19.1.10',\n           typescript: 'latest',\n           '@types/node': 'latest',\n           ...this.dependencies,"
        },
        {
            "sha": "58a900f77bf1824e595d93882029bdcaab7076b5",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/source_maps/merged-unicode/input/collect-segment-data.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fsource_maps%2Fmerged-unicode%2Finput%2Fcollect-segment-data.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fsource_maps%2Fmerged-unicode%2Finput%2Fcollect-segment-data.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fsource_maps%2Fmerged-unicode%2Finput%2Fcollect-segment-data.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -2,7 +2,7 @@ import { jsx as _jsx } from \"./jsx-runtime\";\n // eslint-disable-next-line import/no-extraneous-dependencies\n const createFromReadableStream = 123; //import { createFromReadableStream } from 'react-server-dom-webpack/client.edge';\n // eslint-disable-next-line import/no-extraneous-dependencies\n-const prerender = 123; // import { unstable_prerender as prerender } from 'react-server-dom-webpack/static.edge';\n+const prerender = 123; // import { prerender } from 'react-server-dom-webpack/static.edge';\n const streamFromBuffer=1,streamToBuffer=1; // import { streamFromBuffer, streamToBuffer } from '../stream-utils/node-web-streams-helper';\n const waitAtLeastOneReactRenderTask=1; //import { waitAtLeastOneReactRenderTask } from '../../lib/scheduler';\n // import  './segment-value-encoding';"
        },
        {
            "sha": "5b804961b1a86fd4ce26b6b7d1ba37b7846b7125",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/source_maps/merged-unicode/output/aaf3a_crates_turbopack-tests_tests_snapshot_source_maps_merged-unicode_input_2490dad7._.js",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fsource_maps%2Fmerged-unicode%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_source_maps_merged-unicode_input_2490dad7._.js",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fsource_maps%2Fmerged-unicode%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_source_maps_merged-unicode_input_2490dad7._.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fsource_maps%2Fmerged-unicode%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_source_maps_merged-unicode_input_2490dad7._.js?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -30,7 +30,7 @@ var __TURBOPACK__imported__module__$5b$project$5d2f$turbopack$2f$crates$2f$turbo\n // eslint-disable-next-line import/no-extraneous-dependencies\n const createFromReadableStream = 123; //import { createFromReadableStream } from 'react-server-dom-webpack/client.edge';\n // eslint-disable-next-line import/no-extraneous-dependencies\n-const prerender = 123; // import { unstable_prerender as prerender } from 'react-server-dom-webpack/static.edge';\n+const prerender = 123; // import { prerender } from 'react-server-dom-webpack/static.edge';\n const streamFromBuffer = 1, streamToBuffer = 1; // import { streamFromBuffer, streamToBuffer } from '../stream-utils/node-web-streams-helper';\n const waitAtLeastOneReactRenderTask = 1; //import { waitAtLeastOneReactRenderTask } from '../../lib/scheduler';\n  // import  './segment-value-encoding';\n@@ -74,4 +74,4 @@ if (Date.now() > 0) {\n }),\n ]);\n \n-//# sourceMappingURL=aaf3a_crates_turbopack-tests_tests_snapshot_source_maps_merged-unicode_input_2490dad7._.js.map\n\\ No newline at end of file\n+//# sourceMappingURL=aaf3a_crates_turbopack-tests_tests_snapshot_source_maps_merged-unicode_input_2490dad7._.js.map"
        },
        {
            "sha": "f09853c671d23df89c32e366be7ebeea38ca6b7a",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/source_maps/merged-unicode/output/aaf3a_crates_turbopack-tests_tests_snapshot_source_maps_merged-unicode_input_2490dad7._.js.map",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2386cb91d23d56afdd21f631824f8ccc8b1c0151/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fsource_maps%2Fmerged-unicode%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_source_maps_merged-unicode_input_2490dad7._.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/2386cb91d23d56afdd21f631824f8ccc8b1c0151/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fsource_maps%2Fmerged-unicode%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_source_maps_merged-unicode_input_2490dad7._.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fsource_maps%2Fmerged-unicode%2Foutput%2Faaf3a_crates_turbopack-tests_tests_snapshot_source_maps_merged-unicode_input_2490dad7._.js.map?ref=2386cb91d23d56afdd21f631824f8ccc8b1c0151",
            "patch": "@@ -3,7 +3,7 @@\n   \"sources\": [],\n   \"sections\": [\n     {\"offset\": {\"line\": 3, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/source_maps/merged-unicode/input/jsx-runtime.js\"],\"sourcesContent\":[\"module.exports = {};\\n\"],\"names\":[],\"mappings\":\"AAAA,OAAO,OAAO,GAAG,CAAC\"}},\n-    {\"offset\": {\"line\": 8, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/source_maps/merged-unicode/input/reflect-utils.js\",\"turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/source_maps/merged-unicode/input/collect-segment-data.js\"],\"sourcesContent\":[\"// This regex will have fast negatives meaning valid identifiers may not pass\\n// this test. However this is only used during static generation to provide hints\\n// about why a page bailed out of some or all prerendering and we can use bracket notation\\n// for example while `_` is a valid identifier it's ok to print `searchParams['_']`\\n// even if this would have been fine too `searchParams._`\\nconst isDefinitelyAValidIdentifier = /s/;\\nexport function describeStringPropertyAccess(target, prop) {}\\nexport function describeHasCheckingStringProperty(target, prop) {}\\nexport const wellKnownProperties = new Set([])\\n\",\"import { jsx as _jsx } from \\\"./jsx-runtime\\\";\\n// eslint-disable-next-line import/no-extraneous-dependencies\\nconst createFromReadableStream = 123; //import { createFromReadableStream } from 'react-server-dom-webpack/client.edge';\\n// eslint-disable-next-line import/no-extraneous-dependencies\\nconst prerender = 123; // import { unstable_prerender as prerender } from 'react-server-dom-webpack/static.edge';\\nconst streamFromBuffer=1,streamToBuffer=1; // import { streamFromBuffer, streamToBuffer } from '../stream-utils/node-web-streams-helper';\\nconst waitAtLeastOneReactRenderTask=1; //import { waitAtLeastOneReactRenderTask } from '../../lib/scheduler';\\n// import  './segment-value-encoding';\\n\"],\"names\":[],\"mappings\":\";;;;;;;AAAA,6EAA6E;AAC7E,iFAAiF;AACjF,0FAA0F;AAC1F,uFAAuF;AACvF,2DAA2D;AAC3D,MAAM,+BAA+B;AAC9B,SAAS,6BAA6B,MAAM,EAAE,IAAI,GAAG;AACrD,SAAS,kCAAkC,MAAM,EAAE,IAAI,GAAG;AAC1D,MAAM,sBAAsB,IAAI,IAAI,EAAE;;;;ACR7C;;AACA,6DAA6D;AAC7D,MAAM,2BAA2B,KAAK,kFAAkF;AACxH,6DAA6D;AAC7D,MAAM,YAAY,KAAK,0FAA0F;AACjH,MAAM,mBAAiB,GAAE,iBAAe,GAAG,8FAA8F;AACzI,MAAM,gCAA8B,GAAG,sEAAsE;CAC7G,sCAAsC\"}},\n+    {\"offset\": {\"line\": 8, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/source_maps/merged-unicode/input/reflect-utils.js\",\"turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/source_maps/merged-unicode/input/collect-segment-data.js\"],\"sourcesContent\":[\"// This regex will have fast negatives meaning valid identifiers may not pass\\n// this test. However this is only used during static generation to provide hints\\n// about why a page bailed out of some or all prerendering and we can use bracket notation\\n// for example while `_` is a valid identifier it's ok to print `searchParams['_']`\\n// even if this would have been fine too `searchParams._`\\nconst isDefinitelyAValidIdentifier = /s/;\\nexport function describeStringPropertyAccess(target, prop) {}\\nexport function describeHasCheckingStringProperty(target, prop) {}\\nexport const wellKnownProperties = new Set([])\\n\",\"import { jsx as _jsx } from \\\"./jsx-runtime\\\";\\n// eslint-disable-next-line import/no-extraneous-dependencies\\nconst createFromReadableStream = 123; //import { createFromReadableStream } from 'react-server-dom-webpack/client.edge';\\n// eslint-disable-next-line import/no-extraneous-dependencies\\nconst prerender = 123; // import { prerender } from 'react-server-dom-webpack/static.edge';\\nconst streamFromBuffer=1,streamToBuffer=1; // import { streamFromBuffer, streamToBuffer } from '../stream-utils/node-web-streams-helper';\\nconst waitAtLeastOneReactRenderTask=1; //import { waitAtLeastOneReactRenderTask } from '../../lib/scheduler';\\n// import  './segment-value-encoding';\\n\"],\"names\":[],\"mappings\":\";;;;;;;AAAA,6EAA6E;AAC7E,iFAAiF;AACjF,0FAA0F;AAC1F,uFAAuF;AACvF,2DAA2D;AAC3D,MAAM,+BAA+B;AAC9B,SAAS,6BAA6B,MAAM,EAAE,IAAI,GAAG;AACrD,SAAS,kCAAkC,MAAM,EAAE,IAAI,GAAG;AAC1D,MAAM,sBAAsB,IAAI,IAAI,EAAE;;;;ACR7C;;AACA,6DAA6D;AAC7D,MAAM,2BAA2B,KAAK,kFAAkF;AACxH,6DAA6D;AAC7D,MAAM,YAAY,KAAK,oEAAoE;AAC3F,MAAM,mBAAiB,GAAE,iBAAe,GAAG,8FAA8F;AACzI,MAAM,gCAA8B,GAAG,sEAAsE;CAC7G,sCAAsC\"}},\n     {\"offset\": {\"line\": 42, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/source_maps/merged-unicode/input/index1.js\"],\"sourcesContent\":[\"import \\\"./entry-base.js\\\";\\n\"],\"names\":[],\"mappings\":\";AAAA\"}},\n     {\"offset\": {\"line\": 49, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/source_maps/merged-unicode/input/index2.js\"],\"sourcesContent\":[\"import \\\"./entry-base.js\\\";\\n\"],\"names\":[],\"mappings\":\";AAAA\"}},\n     {\"offset\": {\"line\": 55, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/source_maps/merged-unicode/input/index.js\"],\"sourcesContent\":[\"// \\\"entry-base.js [app-rsc] (ecmascript) <module evaluation>\\\" with\\n// [\\\"reflect-utils.js [app-rsc] (ecmascript)\\\",\\n// \\\"params.js [app-rsc] (ecmascript)\\\",\\n// \\\"segment-value-encoding.js [app-rsc] (ecmascript)\\\",\\n// \\\"collect-segment-data.js [app-rsc] (ecmascript)\\\",\\n// \\\"entry-base.js [app-rsc] (ecmascript) <locals>\\\"]\\n\\n// \\\"entry-base.js [test] (ecmascript) <module evaluation>\\\" with\\n// [\\\"reflect-utils.js [test] (ecmascript)\\\",\\n// \\\"params.js [test] (ecmascript)\\\",\\n// \\\"segment-value-encoding.js [test] (ecmascript)\\\",\\n//  \\\"collect-segment-data.js [test] (ecmascript)\\\",\\n//  \\\"entry-base.js [test] (ecmascript) <locals>\\\"]\\n\\nif (Date.now() > 0) {\\n  require('./index1.js')\\n}\\nif (Date.now() > 0) {\\n  require('./index2.js')\\n}\\n\\n\"],\"names\":[],\"mappings\":\"AAAA,kEAAkE;AAClE,8CAA8C;AAC9C,sCAAsC;AACtC,sDAAsD;AACtD,oDAAoD;AACpD,mDAAmD;AAEnD,+DAA+D;AAC/D,2CAA2C;AAC3C,mCAAmC;AACnC,mDAAmD;AACnD,kDAAkD;AAClD,iDAAiD;AAEjD,IAAI,KAAK,GAAG,KAAK,GAAG;;AAEpB;AACA,IAAI,KAAK,GAAG,KAAK,GAAG;;AAEpB\"}}]"
        }
    ],
    "stats": {
        "total": 13931,
        "additions": 8676,
        "deletions": 5255
    }
}