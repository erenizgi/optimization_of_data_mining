{
    "author": "kdy1",
    "message": "refactor(turbopack): Remove needless code (#78331)\n\n### What?\n\n- Use `analyze.references()` beacuse we need imports to be in `esm_references`.\n\n### Why?\n\nIt's identical but cleaner.\n\n\nCloses PACK-4397",
    "sha": "a0696f228f46c6b4dd74fd1487d59602eeda9349",
    "files": [
        {
            "sha": "b2e604aa67b6c36da973633d1b34b8af875ca277",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/asset.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 50,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/a0696f228f46c6b4dd74fd1487d59602eeda9349/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a0696f228f46c6b4dd74fd1487d59602eeda9349/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs?ref=a0696f228f46c6b4dd74fd1487d59602eeda9349",
            "patch": "@@ -1,6 +1,6 @@\n-use anyhow::{Context, Result};\n+use anyhow::Result;\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, TryJoinIterExt, Vc};\n+use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::glob::Glob;\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n@@ -9,13 +9,13 @@ use turbopack_core::{\n     ident::AssetIdent,\n     module::Module,\n     module_graph::ModuleGraph,\n-    reference::{ModuleReference, ModuleReferences},\n+    reference::{ModuleReference, ModuleReferences, SingleChunkableModuleReference},\n     resolve::{origin::ResolveOrigin, ModulePart},\n };\n \n use super::{\n     chunk_item::EcmascriptModulePartChunkItem, get_part_id, part_of_module, split, split_module,\n-    PartId, SplitResult,\n+    SplitResult,\n };\n use crate::{\n     chunk::{EcmascriptChunkPlaceable, EcmascriptExports},\n@@ -24,9 +24,7 @@ use crate::{\n         analyse_ecmascript_module, esm::FoundExportType, follow_reexports, FollowExportsResult,\n     },\n     side_effect_optimization::facade::module::EcmascriptModuleFacadeModule,\n-    tree_shake::{\n-        reference::EcmascriptModulePartReference, side_effect_module::SideEffectsModule, Key,\n-    },\n+    tree_shake::{side_effect_module::SideEffectsModule, Key},\n     AnalyzeEcmascriptModuleResult, EcmascriptAnalyzable, EcmascriptModuleAsset,\n     EcmascriptModuleAssetType, EcmascriptModuleContent, EcmascriptParsable,\n };\n@@ -293,7 +291,13 @@ impl Module for EcmascriptModulePartAsset {\n     #[turbo_tasks::function]\n     async fn references(&self) -> Result<Vc<ModuleReferences>> {\n         let part_dep = |part: ModulePart| -> Vc<Box<dyn ModuleReference>> {\n-            Vc::upcast(EcmascriptModulePartReference::new(*self.full_module, part))\n+            Vc::upcast(SingleChunkableModuleReference::new(\n+                Vc::upcast(EcmascriptModulePartAsset::new_with_resolved_part(\n+                    *self.full_module,\n+                    part,\n+                )),\n+                Vc::cell(\"part reference\".into()),\n+            ))\n         };\n \n         if let ModulePart::Facade = self.part {\n@@ -304,50 +308,9 @@ impl Module for EcmascriptModulePartAsset {\n             return Ok(Vc::cell(references));\n         }\n \n-        let split_data = split_module(*self.full_module).await?;\n-\n-        let SplitResult::Ok { deps, .. } = &*split_data else {\n-            // If the module is not split, we don't need to add any references\n-            return Ok(Vc::cell(vec![]));\n-        };\n-\n-        let mut references = vec![];\n-\n-        let part_id = get_part_id(&split_data, &self.part)\n-            .await\n-            .with_context(|| format!(\"part {:?} is not found in the module\", self.part))?;\n-\n-        let deps = match deps.get(&part_id) {\n-            Some(v) => &**v,\n-            None => &[],\n-        };\n-\n-        references.extend(\n-            deps.iter()\n-                .filter_map(|part_id| {\n-                    Some(part_dep(match part_id {\n-                        // This is an internal part that is not for evaluation, so we don't need to\n-                        // force-add it.\n-                        PartId::Internal(.., false) => return None,\n-                        // Because of this we still need `PartId::Internal` to have `is_for_eval`\n-                        // flag.\n-                        PartId::Internal(part_id, true) => ModulePart::internal(*part_id),\n-                        PartId::Export(name) => ModulePart::export(name.clone()),\n-                        _ => unreachable!(\n-                            \"PartId other than Internal and Export should not be used here\"\n-                        ),\n-                    }))\n-                })\n-                .map(|v| async move { v.to_resolved().await })\n-                .try_join()\n-                .await?,\n-        );\n-\n         let analyze = analyze(*self.full_module, self.part.clone());\n \n-        references.extend(analyze.references().owned().await?);\n-\n-        Ok(Vc::cell(references))\n+        Ok(analyze.references())\n     }\n }\n "
        },
        {
            "sha": "c3b52006e64de5ef95daaea725b71dd1a3fac2ba",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/mod.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/a0696f228f46c6b4dd74fd1487d59602eeda9349/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a0696f228f46c6b4dd74fd1487d59602eeda9349/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fmod.rs?ref=a0696f228f46c6b4dd74fd1487d59602eeda9349",
            "patch": "@@ -27,7 +27,6 @@ pub mod chunk_item;\n mod graph;\n pub mod merge;\n mod optimizations;\n-pub mod reference;\n pub mod side_effect_module;\n #[cfg(test)]\n mod tests;"
        },
        {
            "sha": "f6b2ca833cfefa1cae286a20471e342ffbfd23bd",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/reference.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 55,
            "changes": 55,
            "blob_url": "https://github.com/vercel/next.js/blob/b867561199b73a1799be597ef88c6319fd42544f/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Freference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b867561199b73a1799be597ef88c6319fd42544f/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Freference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Freference.rs?ref=b867561199b73a1799be597ef88c6319fd42544f",
            "patch": "@@ -1,55 +0,0 @@\n-use anyhow::Result;\n-use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n-use turbopack_core::{\n-    chunk::{ChunkableModuleReference, ChunkingType, ChunkingTypeOption},\n-    reference::ModuleReference,\n-    resolve::{ModulePart, ModuleResolveResult},\n-};\n-\n-use crate::{tree_shake::asset::EcmascriptModulePartAsset, EcmascriptModuleAsset};\n-\n-/// A reference to the [EcmascriptModuleLocalsModule] variant of an original\n-/// module.\n-#[turbo_tasks::value]\n-pub struct EcmascriptModulePartReference {\n-    pub module: ResolvedVc<EcmascriptModuleAsset>,\n-    pub part: ModulePart,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl EcmascriptModulePartReference {\n-    #[turbo_tasks::function]\n-    pub fn new(module: ResolvedVc<EcmascriptModuleAsset>, part: ModulePart) -> Vc<Self> {\n-        EcmascriptModulePartReference { module, part }.cell()\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ValueToString for EcmascriptModulePartReference {\n-    #[turbo_tasks::function]\n-    async fn to_string(&self) -> Result<Vc<RcStr>> {\n-        Ok(Vc::cell(self.part.to_string().into()))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ModuleReference for EcmascriptModulePartReference {\n-    #[turbo_tasks::function]\n-    async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n-        let module =\n-            EcmascriptModulePartAsset::new_with_resolved_part(*self.module, self.part.clone())\n-                .to_resolved()\n-                .await?;\n-\n-        Ok(*ModuleResolveResult::module(ResolvedVc::upcast(module)))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ChunkableModuleReference for EcmascriptModulePartReference {\n-    #[turbo_tasks::function]\n-    fn chunking_type(self: Vc<Self>) -> Vc<ChunkingTypeOption> {\n-        Vc::cell(Some(ChunkingType::ParallelInheritAsync))\n-    }\n-}"
        }
    ],
    "stats": {
        "total": 119,
        "additions": 13,
        "deletions": 106
    }
}