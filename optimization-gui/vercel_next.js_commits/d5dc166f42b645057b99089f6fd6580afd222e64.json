{
    "author": "gnoff",
    "message": "[Cache Components] Allow span creation while prerendering (#82350)\n\nWhen creating spans with OTel random values must be created to follow\nthe OTel spec and is expected in practical implementations. While it is\na loose concession Next.js will allow spans to be created while\nprerendering that have ids generated with random values. and by reading\nthe current time from the system clock.\n\nThis is pragmatic but potentially risky because if you are not careful\nand for instance wrap a \"use cache\" function in a span it is possible\nyou will accidentally pass the span into the cache function causing it\nto miss on every invocation due to the random nature of one of it's\narguments.\n\nTo defend against this we do check whether `startActiveSpan` is being\npassed a Cache Function. However it is easy to circumvent by wrapping it\nin an intermediate function or by using startSpan and context.with\nyourself.\n\nIn the long run we should consider tainting the Span objects created in\nthese scopes so they cannot be sent through to a cache. I will consider\na follow up PR to land this if we determine taint is likely to be\nstabilized in React.\n\nThe pratical implementation of this change is to patch the tracer\nprovider so that it always provides a patched tracer which exits the\nworkUnitStorage on span start/creation and re-enters the scope on inner\nfunction exectuion.",
    "sha": "d5dc166f42b645057b99089f6fd6580afd222e64",
    "files": [
        {
            "sha": "78db258e2ef5defbfe109c8b0d35d15962241518",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -772,5 +772,6 @@\n   \"771\": \"\\\\`%s\\\\` was called during a runtime prerender. Next.js should be preventing %s from being included in server components statically, but did not in this case.\",\n   \"772\": \"FetchStrategy.PPRRuntime should never be used when `experimental.clientSegmentCache` is disabled\",\n   \"773\": \"Missing workStore in createPrerenderParamsForClientSegment\",\n-  \"774\": \"Route %s used %s outside of a Server Component. This is not allowed.\"\n+  \"774\": \"Route %s used %s outside of a Server Component. This is not allowed.\",\n+  \"775\": \"Node.js instrumentation extensions should not be loaded in the Edge runtime.\"\n }"
        },
        {
            "sha": "9af0ab0dd73dc18a1d9a3d637878b041394ad2c4",
            "filename": "packages/next/src/server/lib/router-utils/instrumentation-globals.external.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Finstrumentation-globals.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Finstrumentation-globals.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Finstrumentation-globals.external.ts?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -6,6 +6,7 @@ import type {\n   InstrumentationOnRequestError,\n } from '../../instrumentation/types'\n import { interopDefault } from '../../../lib/interop-default'\n+import { afterRegistration as extendInstrumentationAfterRegistration } from './instrumentation-node-extensions'\n \n let cachedInstrumentationModule: InstrumentationModule\n \n@@ -55,6 +56,7 @@ async function registerInstrumentation(projectDir: string, distDir: string) {\n   if (instrumentation?.register) {\n     try {\n       await instrumentation.register()\n+      extendInstrumentationAfterRegistration()\n     } catch (err: any) {\n       err.message = `An error occurred while loading instrumentation hook: ${err.message}`\n       throw err"
        },
        {
            "sha": "af7b0b400d6583d344b98857ab1b3fe7394a61a7",
            "filename": "packages/next/src/server/lib/router-utils/instrumentation-node-extensions.ts",
            "status": "added",
            "additions": 122,
            "deletions": 0,
            "changes": 122,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Finstrumentation-node-extensions.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Finstrumentation-node-extensions.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Frouter-utils%2Finstrumentation-node-extensions.ts?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,122 @@\n+/**\n+ * This extension augments opentelemetry after registration if applicable.\n+ * This extension must only be loaded in Node environments.\n+ */\n+\n+import type { Tracer } from '@opentelemetry/api'\n+import {\n+  type WorkUnitStore,\n+  workUnitAsyncStorage,\n+} from '../../app-render/work-unit-async-storage.external'\n+import { InvariantError } from '../../../shared/lib/invariant-error'\n+import { isUseCacheFunction } from '../../../lib/client-and-server-references'\n+\n+export function afterRegistration(): void {\n+  if (process.env.NEXT_RUNTIME === 'edge') {\n+    throw new InvariantError(\n+      'Node.js instrumentation extensions should not be loaded in the Edge runtime.'\n+    )\n+  }\n+\n+  extendTracerProviderForCacheComponents()\n+}\n+\n+// In theory we only want to enable this extension when cacheComponents is enabled\n+// however there are certain servers that might load instrumentation before nextConfig is available\n+// and so gating it on the config might lead to skipping this extension even when it is necessary.\n+// When cacheComponents is disabled this extension should be a no-op so we enable it universally.\n+// Additionally, soon, cacheComponents will be enabled always so this just pulls the extension forward in time\n+function extendTracerProviderForCacheComponents(): void {\n+  let api: typeof import('next/dist/compiled/@opentelemetry/api')\n+\n+  // we want to allow users to use their own version of @opentelemetry/api if they\n+  // want to, so we try to require it first, and if it fails we fall back to the\n+  // version that is bundled with Next.js\n+  // this is because @opentelemetry/api has to be synced with the version of\n+  // @opentelemetry/tracing that is used, and we don't want to force users to use\n+  // the version that is bundled with Next.js.\n+  // the API is ~stable, so this should be fine\n+  try {\n+    api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')\n+  } catch (err) {\n+    api =\n+      require('next/dist/compiled/@opentelemetry/api') as typeof import('next/dist/compiled/@opentelemetry/api')\n+  }\n+\n+  const provider = api.trace.getTracerProvider()\n+\n+  // When Cache Components is enabled we need to instrument the tracer\n+  // to exit the workUnitAsyncStorage context when generating spans.\n+  const originalGetTracer = provider.getTracer.bind(provider)\n+  provider.getTracer = (...args) => {\n+    const tracer = originalGetTracer.apply(provider, args)\n+    if (WeakTracers.has(tracer)) {\n+      return tracer\n+    }\n+    const originalStartSpan = tracer.startSpan\n+    tracer.startSpan = (...startSpanArgs) => {\n+      return workUnitAsyncStorage.exit(() =>\n+        originalStartSpan.apply(tracer, startSpanArgs)\n+      )\n+    }\n+\n+    const originalStartActiveSpan = tracer.startActiveSpan\n+    // @ts-ignore TS doesn't recognize the overloads correctly\n+    tracer.startActiveSpan = (...startActiveSpanArgs: any[]) => {\n+      const workUnitStore = workUnitAsyncStorage.getStore()\n+      if (!workUnitStore) {\n+        // @ts-ignore TS doesn't recognize the overloads correctly\n+        return originalStartActiveSpan.apply(tracer, startActiveSpanArgs)\n+      }\n+\n+      let fnIdx: number = 0\n+      if (\n+        startActiveSpanArgs.length === 2 &&\n+        typeof startActiveSpanArgs[1] === 'function'\n+      ) {\n+        fnIdx = 1\n+      } else if (\n+        startActiveSpanArgs.length === 3 &&\n+        typeof startActiveSpanArgs[2] === 'function'\n+      ) {\n+        fnIdx = 2\n+      } else if (\n+        startActiveSpanArgs.length > 3 &&\n+        typeof startActiveSpanArgs[3] === 'function'\n+      ) {\n+        fnIdx = 3\n+      }\n+\n+      if (fnIdx) {\n+        const originalFn = startActiveSpanArgs[fnIdx]\n+        if (isUseCacheFunction(originalFn)) {\n+          console.error(\n+            'A Cache Function (`use cache`) was passed to startActiveSpan which means it will receive a Span argument with a possibly random ID on every invocation leading to cache misses. Provide a wrapping function around the Cache Function that does not forward the Span argument to avoid this issue.'\n+          )\n+        }\n+        startActiveSpanArgs[fnIdx] = withWorkUnitContext(\n+          workUnitStore,\n+          originalFn\n+        )\n+      }\n+\n+      return workUnitAsyncStorage.exit(() => {\n+        // @ts-ignore TS doesn't recognize the overloads correctly\n+        return originalStartActiveSpan.apply(tracer, startActiveSpanArgs)\n+      })\n+    }\n+\n+    WeakTracers.add(tracer)\n+    return tracer\n+  }\n+}\n+\n+const WeakTracers = new WeakSet<Tracer>()\n+\n+function withWorkUnitContext(\n+  workUnitStore: WorkUnitStore,\n+  fn: (...args: any[]) => any\n+) {\n+  return (...args: any[]) =>\n+    workUnitAsyncStorage.run(workUnitStore, fn, ...args)\n+}"
        },
        {
            "sha": "f52e6f5771410110082f7902be8597399c638f87",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/.gitignore",
            "status": "added",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2F.gitignore",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2F.gitignore",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2F.gitignore?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,2 @@\n+node_modules\n+pnpm-lock.yaml\n\\ No newline at end of file"
        },
        {
            "sha": "4157b958a81f8135c82f493d34daf81ec46be9c3",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/app/[slug]/cache/page.tsx",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2F%5Bslug%5D%2Fcache%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2F%5Bslug%5D%2Fcache%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2F%5Bslug%5D%2Fcache%2Fpage.tsx?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,36 @@\n+import {\n+  CachedInnerTraceManualSpan,\n+  InnerTraceManualSpan,\n+  CachedTracedComponentManualSpan,\n+  TracedComponentManualSpan,\n+  CachedInnerTraceActiveSpan,\n+  InnerTraceActiveSpan,\n+  CachedTracedComponentActiveSpan,\n+  TracedComponentActiveSpan,\n+} from '../../traced-work'\n+\n+export function generateStaticParams() {\n+  return [{ slug: 'prerendered' }]\n+}\n+\n+export default async function Page({\n+  params,\n+}: {\n+  params: Promise<{ slug: string }>\n+}) {\n+  'use cache'\n+  return (\n+    <>\n+      <h1>{(await params).slug}</h1>\n+      <div>We are inside a \"use cache\" scope</div>\n+      <CachedInnerTraceManualSpan />\n+      <InnerTraceManualSpan />\n+      <CachedTracedComponentManualSpan />\n+      <TracedComponentManualSpan />\n+      <CachedInnerTraceActiveSpan />\n+      <InnerTraceActiveSpan />\n+      <CachedTracedComponentActiveSpan />\n+      <TracedComponentActiveSpan />\n+    </>\n+  )\n+}"
        },
        {
            "sha": "3abd29ba1fcecd9e6915276eb774c0a1e82a0976",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/app/[slug]/fallback/layout.tsx",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2F%5Bslug%5D%2Ffallback%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2F%5Bslug%5D%2Ffallback%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2F%5Bslug%5D%2Ffallback%2Flayout.tsx?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,9 @@\n+import { Suspense } from 'react'\n+\n+export default async function Layout({\n+  children,\n+}: {\n+  children: React.ReactNode\n+}) {\n+  return <Suspense fallback={<div>Loading...</div>}>{children}</Suspense>\n+}"
        },
        {
            "sha": "78c4e9fa0c756cc5042a1a3d77fcdd03e5309e10",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/app/[slug]/fallback/page.tsx",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2F%5Bslug%5D%2Ffallback%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2F%5Bslug%5D%2Ffallback%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2F%5Bslug%5D%2Ffallback%2Fpage.tsx?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,35 @@\n+import {\n+  CachedInnerTraceManualSpan,\n+  InnerTraceManualSpan,\n+  CachedTracedComponentManualSpan,\n+  TracedComponentManualSpan,\n+  CachedInnerTraceActiveSpan,\n+  InnerTraceActiveSpan,\n+  CachedTracedComponentActiveSpan,\n+  TracedComponentActiveSpan,\n+} from '../../traced-work'\n+\n+export function generateStaticParams() {\n+  return [{ slug: 'prerendered' }]\n+}\n+\n+export default async function Page({\n+  params,\n+}: {\n+  params: Promise<{ slug: string }>\n+}) {\n+  return (\n+    <>\n+      <h1>{(await params).slug}</h1>\n+      <div>We are inside a \"use server\" scope</div>\n+      <CachedInnerTraceManualSpan />\n+      <InnerTraceManualSpan />\n+      <CachedTracedComponentManualSpan />\n+      <TracedComponentManualSpan />\n+      <CachedInnerTraceActiveSpan />\n+      <InnerTraceActiveSpan />\n+      <CachedTracedComponentActiveSpan />\n+      <TracedComponentActiveSpan />\n+    </>\n+  )\n+}"
        },
        {
            "sha": "78c4e9fa0c756cc5042a1a3d77fcdd03e5309e10",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/app/[slug]/server/page.tsx",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2F%5Bslug%5D%2Fserver%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2F%5Bslug%5D%2Fserver%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2F%5Bslug%5D%2Fserver%2Fpage.tsx?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,35 @@\n+import {\n+  CachedInnerTraceManualSpan,\n+  InnerTraceManualSpan,\n+  CachedTracedComponentManualSpan,\n+  TracedComponentManualSpan,\n+  CachedInnerTraceActiveSpan,\n+  InnerTraceActiveSpan,\n+  CachedTracedComponentActiveSpan,\n+  TracedComponentActiveSpan,\n+} from '../../traced-work'\n+\n+export function generateStaticParams() {\n+  return [{ slug: 'prerendered' }]\n+}\n+\n+export default async function Page({\n+  params,\n+}: {\n+  params: Promise<{ slug: string }>\n+}) {\n+  return (\n+    <>\n+      <h1>{(await params).slug}</h1>\n+      <div>We are inside a \"use server\" scope</div>\n+      <CachedInnerTraceManualSpan />\n+      <InnerTraceManualSpan />\n+      <CachedTracedComponentManualSpan />\n+      <TracedComponentManualSpan />\n+      <CachedInnerTraceActiveSpan />\n+      <InnerTraceActiveSpan />\n+      <CachedTracedComponentActiveSpan />\n+      <TracedComponentActiveSpan />\n+    </>\n+  )\n+}"
        },
        {
            "sha": "4965832f2c9b0605eaa189b7c7fb11124d24e48a",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/app/favicon.ico",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2Ffavicon.ico",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2Ffavicon.ico",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2Ffavicon.ico?ref=d5dc166f42b645057b99089f6fd6580afd222e64"
        },
        {
            "sha": "e7077399c03ce1479a655dc647c0545b64531628",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/app/layout.tsx",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2Flayout.tsx?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,7 @@\n+export default function Root({ children }: { children: React.ReactNode }) {\n+  return (\n+    <html>\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "edf2c6ebd594d2df2e43080fec6de1d8c140a6b5",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/app/page.tsx",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2Fpage.tsx?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,41 @@\n+export default function Page() {\n+  return (\n+    <main>\n+      <h1>OTel Cache Components Compat Test</h1>\n+      <p>\n+        Span generation causes random IDs to be created. There is a tradeoff\n+        with this while prerendering since sync IO like Math.random() should be\n+        excluded from static prerenders but spans are so widely used for\n+        providing telemetry for rendering and they would ideally be side effect\n+        free. Next.js now allows random id generation and current time reading\n+        while OTel spans are constructed. However it is possible for the span\n+        object to be passed to a Cache Component where the random ID will cause\n+        cache misses while prerendering. It is important that Span objects not\n+        be passed into Cache Functions for proper functioning of Cache\n+        Components.\n+      </p>\n+      <ul>\n+        <li>\n+          <a href=\"/novel/cache\">\n+            \"use cache\" Page without build-time prerendering\n+          </a>\n+        </li>\n+        <li>\n+          <a href=\"/prerendered/cache\">\n+            \"use cache\" Page with build-time prerendering\n+          </a>\n+        </li>\n+        <li>\n+          <a href=\"/novel/server\">\n+            Server Page without build-time prerendering\n+          </a>\n+        </li>\n+        <li>\n+          <a href=\"/prerendered/server\">\n+            Server Page with build-time prerendering\n+          </a>\n+        </li>\n+      </ul>\n+    </main>\n+  )\n+}"
        },
        {
            "sha": "067d6cf484eaeff6a1cae39b4c4283dafdf50483",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/app/traced-work.tsx",
            "status": "added",
            "additions": 182,
            "deletions": 0,
            "changes": 182,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2Ftraced-work.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2Ftraced-work.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fapp%2Ftraced-work.tsx?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,182 @@\n+import { type Span, trace, context } from '@opentelemetry/api'\n+import { Suspense } from 'react'\n+\n+async function asyncWork() {\n+  await new Promise((resolve) => setTimeout(resolve, 1000))\n+  return 42\n+}\n+\n+async function cachedAsyncWork() {\n+  'use cache'\n+  return asyncWork()\n+}\n+\n+function withSpan(fn) {\n+  return function () {\n+    const tracer = trace.getTracer('tracer-manual-span')\n+    const span = tracer.startSpan('span-manual-span')\n+    const ctx = trace.setSpan(context.active(), span)\n+    return context.with(ctx, fn)\n+  }\n+}\n+\n+function withActiveSpan(fn) {\n+  return function () {\n+    const tracer = trace.getTracer('tracer-active-span')\n+    return tracer.startActiveSpan('span-active-span', fn)\n+  }\n+}\n+\n+const asyncWorkWithManualSpan = withSpan(asyncWork)\n+const asyncWorkWithActiveSpan = withActiveSpan(asyncWork)\n+const cachedAsyncWorkWithManualSpan = withSpan(cachedAsyncWork)\n+const cachedAsyncWorkWithActiveSpan = withActiveSpan(cachedAsyncWork)\n+\n+export function CachedInnerTraceManualSpan() {\n+  async function Inner() {\n+    const result = await cachedAsyncWorkWithManualSpan()\n+    return <p className=\"result\">{result}</p>\n+  }\n+  return (\n+    <section id=\"t1\">\n+      <h2>(Manual Span) Cached Async Work</h2>\n+      <Suspense fallback={<Loading />}>\n+        <Inner />\n+      </Suspense>\n+    </section>\n+  )\n+}\n+\n+export function InnerTraceManualSpan() {\n+  async function Inner() {\n+    const result = await asyncWorkWithManualSpan()\n+    return <p className=\"result\">{result}</p>\n+  }\n+  return (\n+    <section id=\"t2\">\n+      <h2>(Manual Span) Async Work</h2>\n+      <Suspense fallback={<Loading />}>\n+        <Inner />\n+      </Suspense>\n+    </section>\n+  )\n+}\n+\n+export const CachedTracedComponentManualSpan = withSpan(async function () {\n+  async function Inner() {\n+    const result = await cachedAsyncWork()\n+    return <Result>{result}</Result>\n+  }\n+  return (\n+    <section id=\"t3\">\n+      <h2>(Manual Span) Inner Traced \"use cache\" Function</h2>\n+      <Suspense fallback={<Loading />}>\n+        <Inner />\n+      </Suspense>\n+    </section>\n+  )\n+})\n+\n+export const TracedComponentManualSpan = withSpan(async function () {\n+  async function Inner() {\n+    const result = await asyncWork()\n+    return <Result>{result}</Result>\n+  }\n+  return (\n+    <section id=\"t4\">\n+      <h2>(Manual Span) Inner Traced Function</h2>\n+      <Suspense fallback={<Loading />}>\n+        <Inner />\n+      </Suspense>\n+    </section>\n+  )\n+})\n+\n+export function CachedInnerTraceActiveSpan() {\n+  async function Inner() {\n+    const result = await cachedAsyncWorkWithActiveSpan()\n+    return <Result>{result}</Result>\n+  }\n+  return (\n+    <section id=\"t5\">\n+      <h2>(Active Span) Cached Async Work</h2>\n+      <Suspense fallback={<Loading />}>\n+        <Inner />\n+      </Suspense>\n+    </section>\n+  )\n+}\n+\n+export function InnerTraceActiveSpan() {\n+  async function Inner() {\n+    const result = await asyncWorkWithActiveSpan()\n+    return <Result>{result}</Result>\n+  }\n+  return (\n+    <section id=\"t6\">\n+      <h2>(Active Span) Async Work</h2>\n+      <Suspense fallback={<Loading />}>\n+        <Inner />\n+      </Suspense>\n+    </section>\n+  )\n+}\n+\n+export const CachedTracedComponentActiveSpan = withActiveSpan(async function (\n+  span: Span\n+) {\n+  async function Inner() {\n+    const result = await cachedAsyncWork()\n+    return <Result>{result}</Result>\n+  }\n+\n+  return (\n+    <section id=\"t7\">\n+      <h2>(Active Span) Inner Traced \"use cache\" Function</h2>\n+      <div>\n+        <p>\n+          Span Representative{' '}\n+          <span className=\"span\" suppressHydrationWarning>\n+            {parseInt(span.spanContext().spanId.slice(10), 16)}\n+          </span>\n+        </p>\n+        <Suspense fallback={<Loading />}>\n+          <Inner />\n+        </Suspense>\n+      </div>\n+    </section>\n+  )\n+})\n+\n+export const TracedComponentActiveSpan = withActiveSpan(async function (\n+  span: Span\n+) {\n+  async function Inner() {\n+    const result = await asyncWork()\n+    return <Result>{result}</Result>\n+  }\n+  return (\n+    <section id=\"t8\">\n+      <h2>(Active Span) Inner Traced Function</h2>\n+      <div>\n+        <p>\n+          Span Representative{' '}\n+          <span className=\"span\" suppressHydrationWarning>\n+            {parseInt(span.spanContext().spanId.slice(10), 16)}\n+          </span>\n+        </p>\n+        <Suspense fallback={<Loading />}>\n+          <Inner />\n+        </Suspense>\n+      </div>\n+    </section>\n+  )\n+})\n+\n+function Loading() {\n+  return <span className=\"fallback\">loading...</span>\n+}\n+\n+function Result({ children }: { children: React.ReactNode }) {\n+  return <p className=\"result\">{children}</p>\n+}"
        },
        {
            "sha": "017cf4ac74faff674b7df9b295068fe81770545a",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/cache-components-allow-otel-spans.test.ts",
            "status": "added",
            "additions": 340,
            "deletions": 0,
            "changes": 340,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fcache-components-allow-otel-spans.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fcache-components-allow-otel-spans.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fcache-components-allow-otel-spans.test.ts?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,340 @@\n+import { isNextDev, nextTestSetup } from 'e2e-utils'\n+\n+describe('hello-world', () => {\n+  const { next, isTurbopack } = nextTestSetup({\n+    files: __dirname,\n+    dependencies: require('./package.json').dependencies,\n+  })\n+\n+  if (isNextDev) {\n+    it('should allow creating spans during cache component validation without triggering sync IO bailouts - inside a Cache Component - without prerendering the page', async () => {\n+      const browser = await next.browser('/novel/cache')\n+      if (isTurbopack) {\n+        await expect(browser).toDisplayCollapsedRedbox(`\n+         {\n+           \"description\": \"A Cache Function (\\`use cache\\`) was passed to startActiveSpan which means it will receive a Span argument with a possibly random ID on every invocation leading to cache misses. Provide a wrapping function around the Cache Function that does not forward the Span argument to avoid this issue.\",\n+           \"environmentLabel\": \"Cache\",\n+           \"label\": \"Console Error\",\n+           \"source\": \"app/traced-work.tsx (26:19) @ <anonymous>\n+         > 26 |     return tracer.startActiveSpan('span-active-span', fn)\n+              |                   ^\",\n+           \"stack\": [\n+             \"<anonymous> app/traced-work.tsx (26:19)\",\n+             \"Inner app/traced-work.tsx (97:26)\",\n+             \"Page <anonymous>\",\n+           ],\n+         }\n+        `)\n+      } else {\n+        await expect(browser).toDisplayCollapsedRedbox(`\n+                {\n+                  \"description\": \"A Cache Function (\\`use cache\\`) was passed to startActiveSpan which means it will receive a Span argument with a possibly random ID on every invocation leading to cache misses. Provide a wrapping function around the Cache Function that does not forward the Span argument to avoid this issue.\",\n+                  \"environmentLabel\": \"Cache\",\n+                  \"label\": \"Console Error\",\n+                  \"source\": \"app/traced-work.tsx (26:19) @ eval\n+                > 26 |     return tracer.startActiveSpan('span-active-span', fn)\n+                     |                   ^\",\n+                  \"stack\": [\n+                    \"eval app/traced-work.tsx (26:19)\",\n+                    \"Inner app/traced-work.tsx (97:26)\",\n+                    \"Page <anonymous>\",\n+                  ],\n+                }\n+              `)\n+      }\n+\n+      // Ideally we would assert the cached/loading status of each test case in dev but there are bugs with warmup renders that make this racey\n+      // For now we just assert that we actually get the non-zero span ids.\n+      const t7 = await browser.elementByCss('#t7 .span')\n+      expect(parseInt(await t7.textContent())).not.toEqual(0)\n+\n+      const t8 = await browser.elementByCss('#t8 .span')\n+      expect(parseInt(await t8.textContent())).not.toEqual(0)\n+\n+      console.log('t7', await t7.textContent())\n+      console.log('t8', await t8.textContent())\n+    })\n+    it('should allow creating spans during cache component validation without triggering sync IO bailouts - inside a Cache Component - with prerendering the page', async () => {\n+      // In dev there really isn't any prerendering but since this test case exists for prod testing I want to keep it exercised in the dev pathway too\n+      const browser = await next.browser('/prerendered/cache')\n+      if (isTurbopack) {\n+        await expect(browser).toDisplayCollapsedRedbox(`\n+         {\n+           \"description\": \"A Cache Function (\\`use cache\\`) was passed to startActiveSpan which means it will receive a Span argument with a possibly random ID on every invocation leading to cache misses. Provide a wrapping function around the Cache Function that does not forward the Span argument to avoid this issue.\",\n+           \"environmentLabel\": \"Cache\",\n+           \"label\": \"Console Error\",\n+           \"source\": \"app/traced-work.tsx (26:19) @ <anonymous>\n+         > 26 |     return tracer.startActiveSpan('span-active-span', fn)\n+              |                   ^\",\n+           \"stack\": [\n+             \"<anonymous> app/traced-work.tsx (26:19)\",\n+             \"Inner app/traced-work.tsx (97:26)\",\n+             \"Page <anonymous>\",\n+           ],\n+         }\n+        `)\n+      } else {\n+        await expect(browser).toDisplayCollapsedRedbox(`\n+                {\n+                  \"description\": \"A Cache Function (\\`use cache\\`) was passed to startActiveSpan which means it will receive a Span argument with a possibly random ID on every invocation leading to cache misses. Provide a wrapping function around the Cache Function that does not forward the Span argument to avoid this issue.\",\n+                  \"environmentLabel\": \"Cache\",\n+                  \"label\": \"Console Error\",\n+                  \"source\": \"app/traced-work.tsx (26:19) @ eval\n+                > 26 |     return tracer.startActiveSpan('span-active-span', fn)\n+                     |                   ^\",\n+                  \"stack\": [\n+                    \"eval app/traced-work.tsx (26:19)\",\n+                    \"Inner app/traced-work.tsx (97:26)\",\n+                    \"Page <anonymous>\",\n+                  ],\n+                }\n+              `)\n+      }\n+\n+      // Ideally we would assert the cached/loading status of each test case in dev but there are bugs with warmup renders that make this racey\n+      // For now we just assert that we actually get the non-zero span ids.\n+      const t7 = await browser.elementByCss('#t7 .span')\n+      expect(parseInt(await t7.textContent())).not.toEqual(0)\n+\n+      const t8 = await browser.elementByCss('#t8 .span')\n+      expect(parseInt(await t8.textContent())).not.toEqual(0)\n+\n+      console.log('t7', await t7.textContent())\n+      console.log('t8', await t8.textContent())\n+    })\n+    it('should allow creating spans during cache component validation without triggering sync IO bailouts - inside a Server Component - without prerendering the page', async () => {\n+      const browser = await next.browser('/novel/server')\n+      if (isTurbopack) {\n+        await expect(browser).toDisplayCollapsedRedbox(`\n+         {\n+           \"description\": \"A Cache Function (\\`use cache\\`) was passed to startActiveSpan which means it will receive a Span argument with a possibly random ID on every invocation leading to cache misses. Provide a wrapping function around the Cache Function that does not forward the Span argument to avoid this issue.\",\n+           \"environmentLabel\": \"Prerender\",\n+           \"label\": \"Console Error\",\n+           \"source\": \"app/traced-work.tsx (26:19) @ <anonymous>\n+         > 26 |     return tracer.startActiveSpan('span-active-span', fn)\n+              |                   ^\",\n+           \"stack\": [\n+             \"<anonymous> app/traced-work.tsx (26:19)\",\n+             \"Inner app/traced-work.tsx (97:26)\",\n+             \"CachedInnerTraceActiveSpan app/traced-work.tsx (104:9)\",\n+             \"Page app/[slug]/server/page.tsx (29:7)\",\n+           ],\n+         }\n+        `)\n+      } else {\n+        await expect(browser).toDisplayCollapsedRedbox(`\n+                {\n+                  \"description\": \"A Cache Function (\\`use cache\\`) was passed to startActiveSpan which means it will receive a Span argument with a possibly random ID on every invocation leading to cache misses. Provide a wrapping function around the Cache Function that does not forward the Span argument to avoid this issue.\",\n+                  \"environmentLabel\": \"Prerender\",\n+                  \"label\": \"Console Error\",\n+                  \"source\": \"app/traced-work.tsx (26:19) @ eval\n+                > 26 |     return tracer.startActiveSpan('span-active-span', fn)\n+                     |                   ^\",\n+                  \"stack\": [\n+                    \"eval app/traced-work.tsx (26:19)\",\n+                    \"Inner app/traced-work.tsx (97:26)\",\n+                    \"CachedInnerTraceActiveSpan app/traced-work.tsx (104:9)\",\n+                    \"Page app/[slug]/server/page.tsx (29:7)\",\n+                  ],\n+                }\n+              `)\n+      }\n+\n+      // Ideally we would assert the cached/loading status of each test case in dev but there are bugs with warmup renders that make this racey\n+      // For now we just assert that we actually get the non-zero span ids.\n+      const t7 = await browser.elementByCss('#t7 .span')\n+      expect(parseInt(await t7.textContent())).not.toEqual(0)\n+\n+      const t8 = await browser.elementByCss('#t8 .span')\n+      expect(parseInt(await t8.textContent())).not.toEqual(0)\n+\n+      console.log('t7', await t7.textContent())\n+      console.log('t8', await t8.textContent())\n+    })\n+    it('should allow creating spans during cache component validation without triggering sync IO bailouts - inside a Server Component - with prerendering the page', async () => {\n+      // In dev there really isn't any prerendering but since this test case exists for prod testing I want to keep it exercised in the dev pathway too\n+      const browser = await next.browser('/prerendered/server')\n+      if (isTurbopack) {\n+        await expect(browser).toDisplayCollapsedRedbox(`\n+         {\n+           \"description\": \"A Cache Function (\\`use cache\\`) was passed to startActiveSpan which means it will receive a Span argument with a possibly random ID on every invocation leading to cache misses. Provide a wrapping function around the Cache Function that does not forward the Span argument to avoid this issue.\",\n+           \"environmentLabel\": \"Prerender\",\n+           \"label\": \"Console Error\",\n+           \"source\": \"app/traced-work.tsx (26:19) @ <anonymous>\n+         > 26 |     return tracer.startActiveSpan('span-active-span', fn)\n+              |                   ^\",\n+           \"stack\": [\n+             \"<anonymous> app/traced-work.tsx (26:19)\",\n+             \"Inner app/traced-work.tsx (97:26)\",\n+             \"CachedInnerTraceActiveSpan app/traced-work.tsx (104:9)\",\n+             \"Page app/[slug]/server/page.tsx (29:7)\",\n+           ],\n+         }\n+        `)\n+      } else {\n+        await expect(browser).toDisplayCollapsedRedbox(`\n+                {\n+                  \"description\": \"A Cache Function (\\`use cache\\`) was passed to startActiveSpan which means it will receive a Span argument with a possibly random ID on every invocation leading to cache misses. Provide a wrapping function around the Cache Function that does not forward the Span argument to avoid this issue.\",\n+                  \"environmentLabel\": \"Prerender\",\n+                  \"label\": \"Console Error\",\n+                  \"source\": \"app/traced-work.tsx (26:19) @ eval\n+                > 26 |     return tracer.startActiveSpan('span-active-span', fn)\n+                     |                   ^\",\n+                  \"stack\": [\n+                    \"eval app/traced-work.tsx (26:19)\",\n+                    \"Inner app/traced-work.tsx (97:26)\",\n+                    \"CachedInnerTraceActiveSpan app/traced-work.tsx (104:9)\",\n+                    \"Page app/[slug]/server/page.tsx (29:7)\",\n+                  ],\n+                }\n+              `)\n+      }\n+\n+      // Ideally we would assert the cached/loading status of each test case in dev but there are bugs with warmup renders that make this racey\n+      // For now we just assert that we actually get the non-zero span ids.\n+      const t7 = await browser.elementByCss('#t7 .span')\n+      expect(parseInt(await t7.textContent())).not.toEqual(0)\n+\n+      const t8 = await browser.elementByCss('#t8 .span')\n+      expect(parseInt(await t8.textContent())).not.toEqual(0)\n+\n+      console.log('t7', await t7.textContent())\n+      console.log('t8', await t8.textContent())\n+    })\n+  } else {\n+    it('should allow creating Spans during prerendering during the build - inside a Cache Components', async () => {\n+      const browser = await next.browser('/prerendered/cache')\n+      {\n+        const t7 = await browser.elementByCss('#t7 .span')\n+        // the span was prerendered during the build\n+        expect(parseInt(await t7.textContent())).toEqual(0)\n+        const t8 = await browser.elementByCss('#t8 .span')\n+        // the span was prerendered during the build\n+        expect(parseInt(await t8.textContent())).toEqual(0)\n+\n+        // load again\n+        await browser.loadPage(`${next.url}/prerendered/cache`)\n+        const t7again = await browser.elementByCss('#t7 .span')\n+        // the span was prerendered during the build\n+        expect(parseInt(await t7again.textContent())).toEqual(0)\n+        const t8again = await browser.elementByCss('#t8 .span')\n+        // the span was prerendered during the build\n+        expect(parseInt(await t8again.textContent())).toEqual(0)\n+      }\n+\n+      {\n+        await browser.loadPage(`${next.url}/prerendered/server`)\n+        const t7 = await browser.elementByCss('#t7 .span')\n+        // the span was prerendered during the build\n+        expect(parseInt(await t7.textContent())).toEqual(0)\n+        const t8 = await browser.elementByCss('#t8 .span')\n+        // the span was prerendered during the build\n+        expect(parseInt(await t8.textContent())).toEqual(0)\n+\n+        // load again\n+        await browser.loadPage(`${next.url}/prerendered/server`)\n+        const t7again = await browser.elementByCss('#t7 .span')\n+        // the span was prerendered during the build\n+        expect(parseInt(await t7again.textContent())).toEqual(0)\n+        const t8again = await browser.elementByCss('#t8 .span')\n+        // the span was prerendered during the build\n+        expect(parseInt(await t8again.textContent())).toEqual(0)\n+      }\n+\n+      {\n+        await browser.loadPage(`${next.url}/prerendered/fallback`)\n+        const t7 = await browser.elementByCss('#t7 .span')\n+        // the span was prerendered during the build\n+        expect(parseInt(await t7.textContent())).toEqual(0)\n+        const t8 = await browser.elementByCss('#t8 .span')\n+        // the span was prerendered during the build\n+        expect(parseInt(await t8.textContent())).toEqual(0)\n+\n+        // load again\n+        await browser.loadPage(`${next.url}/prerendered/fallback`)\n+        const t7again = await browser.elementByCss('#t7 .span')\n+        // the span was prerendered during the build\n+        expect(parseInt(await t7again.textContent())).toEqual(0)\n+        const t8again = await browser.elementByCss('#t8 .span')\n+        // the span was prerendered during the build\n+        expect(parseInt(await t8again.textContent())).toEqual(0)\n+      }\n+    })\n+    it('should allow creating Spans during prerendering at runtime - inside a Cache Components', async () => {\n+      const browser = await next.browser('/novel/cache')\n+      {\n+        const t7 = await browser.elementByCss('#t7 .span')\n+        const t7value = parseInt(await t7.textContent())\n+        // the span was prerendered at runtime\n+        expect(t7value).not.toEqual(0)\n+\n+        const t8 = await browser.elementByCss('#t8 .span')\n+        const t8value = parseInt(await t8.textContent())\n+        // the span was prerendered at runtime\n+        expect(t8value).not.toEqual(0)\n+\n+        // load again\n+        await browser.loadPage(`${next.url}/novel/cache`)\n+        const t7again = await browser.elementByCss('#t7 .span')\n+        const t7againValue = parseInt(await t7again.textContent())\n+        // this page was cached so the span should be cached too\n+        expect(t7againValue).toEqual(t7value)\n+\n+        const t8again = await browser.elementByCss('#t8 .span')\n+        const t8againValue = parseInt(await t8again.textContent())\n+        // this page was cached so the span should be cached too\n+        expect(t8againValue).toEqual(t8value)\n+      }\n+\n+      {\n+        await browser.loadPage(`${next.url}/novel/server`)\n+        const t7 = await browser.elementByCss('#t7 .span')\n+        const t7value = parseInt(await t7.textContent())\n+        // the span was prerendered at runtime\n+        expect(t7value).not.toEqual(0)\n+        const t8 = await browser.elementByCss('#t8 .span')\n+        const t8value = parseInt(await t8.textContent())\n+        // the span was prerendered at runtime\n+        expect(t8value).not.toEqual(0)\n+\n+        // load again\n+        await browser.loadPage(`${next.url}/novel/server`)\n+        const t7again = await browser.elementByCss('#t7 .span')\n+        const t7againValue = parseInt(await t7again.textContent())\n+        // this page was cached so the span should be cached too\n+        expect(t7againValue).toEqual(t7value)\n+        const t8again = await browser.elementByCss('#t8 .span')\n+        const t8againValue = parseInt(await t8again.textContent())\n+        // this page was cached so the span should be cached too\n+        expect(t8againValue).toEqual(t8value)\n+      }\n+    })\n+    it('should allow creating Spans during resuming a fallback - inside a Cache Component', async () => {\n+      const browser = await next.browser('/novel/fallback')\n+      {\n+        const t7 = await browser.elementByCss('#t7 .span')\n+        const t7value = parseInt(await t7.textContent())\n+        // the span was prerendered at runtime\n+        expect(t7value).not.toEqual(0)\n+        const t8 = await browser.elementByCss('#t8 .span')\n+        const t8value = parseInt(await t8.textContent())\n+        // the span was prerendered at runtime\n+        expect(t8value).not.toEqual(0)\n+\n+        // load again\n+        await browser.loadPage(`${next.url}/novel/fallback`)\n+        const t7again = await browser.elementByCss('#t7 .span')\n+        const t7againValue = parseInt(await t7again.textContent())\n+        // this page renders the spans in the resume on each request\n+        expect(t7againValue).not.toEqual(t7value)\n+        expect(t7againValue).not.toEqual(0)\n+\n+        const t8again = await browser.elementByCss('#t8 .span')\n+        const t8againValue = parseInt(await t8again.textContent())\n+        // this page renders the spans in the resume on each request\n+        expect(t8againValue).not.toEqual(t8value)\n+        expect(t8againValue).not.toEqual(0)\n+      }\n+    })\n+  }\n+})"
        },
        {
            "sha": "ca202f0d79ead81317fd0fad8b55b04c42819380",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/instrumentation.node.ts",
            "status": "added",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Finstrumentation.node.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Finstrumentation.node.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Finstrumentation.node.ts?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,16 @@\n+import { NodeSDK } from '@opentelemetry/sdk-node'\n+import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'\n+import { HttpInstrumentation } from '@opentelemetry/instrumentation-http'\n+import { ExpressInstrumentation } from '@opentelemetry/instrumentation-express'\n+\n+const sdk = new NodeSDK({\n+  serviceName: 'nextjs-otel-app',\n+  traceExporter: new OTLPTraceExporter({\n+    url:\n+      process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT ||\n+      'http://localhost:4318/v1/traces',\n+  }),\n+  instrumentations: [new HttpInstrumentation(), new ExpressInstrumentation()],\n+})\n+\n+sdk.start()"
        },
        {
            "sha": "52e34bd80f33125a0e3cae584edfbd28bd8558b0",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/instrumentation.ts",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Finstrumentation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Finstrumentation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Finstrumentation.ts?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,5 @@\n+export async function register() {\n+  if (process.env.NEXT_RUNTIME !== 'edge') {\n+    await import('./instrumentation.node')\n+  }\n+}"
        },
        {
            "sha": "30a826fdacc568ffb8cd6641fe15330a3c9d618d",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/next.config.js",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fnext.config.js?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,10 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  experimental: {\n+    cacheComponents: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "ff5e809b1cc305532ace4db998c3992eae674c71",
            "filename": "test/e2e/app-dir/cache-components-allow-otel-spans/package.json",
            "status": "added",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/d5dc166f42b645057b99089f6fd6580afd222e64/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-allow-otel-spans%2Fpackage.json?ref=d5dc166f42b645057b99089f6fd6580afd222e64",
            "patch": "@@ -0,0 +1,14 @@\n+{\n+  \"dependencies\": {\n+    \"@opentelemetry/api\": \"^1.9.0\",\n+    \"@opentelemetry/auto-instrumentations-node\": \"^0.62.0\",\n+    \"@opentelemetry/exporter-jaeger\": \"^2.0.1\",\n+    \"@opentelemetry/exporter-trace-otlp-http\": \"^0.203.0\",\n+    \"@opentelemetry/instrumentation-express\": \"^0.52.0\",\n+    \"@opentelemetry/instrumentation-http\": \"^0.203.0\",\n+    \"@opentelemetry/resources\": \"^2.0.1\",\n+    \"@opentelemetry/sdk-node\": \"^0.203.0\",\n+    \"@opentelemetry/semantic-conventions\": \"^1.36.0\",\n+    \"@opentelemetry/winston-transport\": \"^0.14.0\"\n+  }\n+}"
        }
    ],
    "stats": {
        "total": 859,
        "additions": 858,
        "deletions": 1
    }
}