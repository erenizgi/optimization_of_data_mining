{
    "author": "gnoff",
    "message": "[dynamicIO] model pathname access in metadata as async  (#79136)\n\nreading the pathname is akin to reading params and it should be an async\nfunction so metadata can postpone during prerendering just like usercode\ncan.\n\nUnforutnately the current metadata merging implementation was\nsynchronous. It might be tempting to just await the pathname high up and\nlet the merge continue to be sync but this might trigger dynamic\nmetadata when not necessary since only certain metadata properties\nrequire the pathname. In an effort to maximize which metadata can be\nprerendered I converted the necessary merging functions to be async and\npassed a promise in that will exhibit the correct semantics when\naccessed when dynamicIO is enabled.",
    "sha": "6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
    "files": [
        {
            "sha": "7f65e6ac8cfaedea7f47f5e27aa5e85e7458a3ab",
            "filename": "packages/next/src/lib/metadata/metadata-context.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 32,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fmetadata-context.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fmetadata-context.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fmetadata-context.tsx?ref=6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
            "patch": "@@ -1,43 +1,11 @@\n import type { AppRenderContext } from '../../server/app-render/app-render'\n import type { MetadataContext } from './types/resolvers'\n-import type { WorkStore } from '../../server/app-render/work-async-storage.external'\n-import { trackFallbackParamAccessed } from '../../server/app-render/dynamic-rendering'\n \n export function createMetadataContext(\n-  pathname: string,\n   renderOpts: AppRenderContext['renderOpts']\n ): MetadataContext {\n   return {\n-    pathname,\n     trailingSlash: renderOpts.trailingSlash,\n     isStaticMetadataRouteFile: false,\n   }\n }\n-\n-export function createTrackedMetadataContext(\n-  pathname: string,\n-  renderOpts: AppRenderContext['renderOpts'],\n-  workStore: WorkStore | null\n-): MetadataContext {\n-  return {\n-    // Use the regular metadata context, but we trap the pathname access.\n-    ...createMetadataContext(pathname, renderOpts),\n-\n-    // Setup the trap around the pathname access so we can track when the\n-    // pathname is accessed while resolving metadata which would indicate it's\n-    // being used to resolve a relative URL. If that's the case, we don't want\n-    // to provide it, and instead we should error.\n-    get pathname() {\n-      if (\n-        workStore &&\n-        workStore.isStaticGeneration &&\n-        workStore.fallbackRouteParams &&\n-        workStore.fallbackRouteParams.size > 0\n-      ) {\n-        trackFallbackParamAccessed(workStore, 'metadata relative url resolving')\n-      }\n-\n-      return pathname\n-    },\n-  }\n-}"
        },
        {
            "sha": "70bedae728f09d14d1c9deee90f1864ae7e84d2d",
            "filename": "packages/next/src/lib/metadata/metadata.tsx",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fmetadata.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fmetadata.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fmetadata.tsx?ref=6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
            "patch": "@@ -44,6 +44,7 @@ import {\n } from '../../client/components/metadata/async-metadata'\n import { isPostpone } from '../../server/lib/router-utils/is-postpone'\n import { createServerSearchParamsForMetadata } from '../../server/request/search-params'\n+import { createServerPathnameForMetadata } from '../../server/request/pathname'\n \n // Use a promise to share the status of the metadata resolving,\n // returning two components `MetadataTree` and `MetadataOutlet`\n@@ -53,6 +54,7 @@ import { createServerSearchParamsForMetadata } from '../../server/request/search\n // and the error will be caught by the error boundary and trigger fallbacks.\n export function createMetadataComponents({\n   tree,\n+  pathname,\n   parsedQuery,\n   metadataContext,\n   getDynamicParamFromSegment,\n@@ -64,6 +66,7 @@ export function createMetadataComponents({\n   serveStreamingMetadata,\n }: {\n   tree: LoaderTree\n+  pathname: string\n   parsedQuery: SearchParams\n   metadataContext: MetadataContext\n   getDynamicParamFromSegment: GetDynamicParamFromSegment\n@@ -84,6 +87,10 @@ export function createMetadataComponents({\n     parsedQuery,\n     workStore\n   )\n+  const pathnameForMetadata = createServerPathnameForMetadata(\n+    pathname,\n+    workStore\n+  )\n \n   function ViewportTree() {\n     return (\n@@ -143,6 +150,7 @@ export function createMetadataComponents({\n   function metadata() {\n     return getResolvedMetadata(\n       tree,\n+      pathnameForMetadata,\n       searchParams,\n       getDynamicParamFromSegment,\n       metadataContext,\n@@ -167,6 +175,7 @@ export function createMetadataComponents({\n         try {\n           result = await getNotFoundMetadata(\n             tree,\n+            pathnameForMetadata,\n             searchParams,\n             getDynamicParamFromSegment,\n             metadataContext,\n@@ -252,6 +261,7 @@ export function createMetadataComponents({\n const getResolvedMetadata = cache(getResolvedMetadataImpl)\n async function getResolvedMetadataImpl(\n   tree: LoaderTree,\n+  pathname: Promise<string>,\n   searchParams: Promise<ParsedUrlQuery>,\n   getDynamicParamFromSegment: GetDynamicParamFromSegment,\n   metadataContext: MetadataContext,\n@@ -261,6 +271,7 @@ async function getResolvedMetadataImpl(\n   const errorConvention = errorType === 'redirect' ? undefined : errorType\n   return renderMetadata(\n     tree,\n+    pathname,\n     searchParams,\n     getDynamicParamFromSegment,\n     metadataContext,\n@@ -272,6 +283,7 @@ async function getResolvedMetadataImpl(\n const getNotFoundMetadata = cache(getNotFoundMetadataImpl)\n async function getNotFoundMetadataImpl(\n   tree: LoaderTree,\n+  pathname: Promise<string>,\n   searchParams: Promise<ParsedUrlQuery>,\n   getDynamicParamFromSegment: GetDynamicParamFromSegment,\n   metadataContext: MetadataContext,\n@@ -280,6 +292,7 @@ async function getNotFoundMetadataImpl(\n   const notFoundErrorConvention = 'not-found'\n   return renderMetadata(\n     tree,\n+    pathname,\n     searchParams,\n     getDynamicParamFromSegment,\n     metadataContext,\n@@ -325,6 +338,7 @@ async function getNotFoundViewportImpl(\n \n async function renderMetadata(\n   tree: LoaderTree,\n+  pathname: Promise<string>,\n   searchParams: Promise<ParsedUrlQuery>,\n   getDynamicParamFromSegment: GetDynamicParamFromSegment,\n   metadataContext: MetadataContext,\n@@ -333,6 +347,7 @@ async function renderMetadata(\n ) {\n   const resolvedMetadata = await resolveMetadata(\n     tree,\n+    pathname,\n     searchParams,\n     errorConvention,\n     getDynamicParamFromSegment,"
        },
        {
            "sha": "56d9bc3a740c2eeffe00dace3c0f9e9913e76a6c",
            "filename": "packages/next/src/lib/metadata/resolve-metadata.test.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.test.ts?ref=6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
            "patch": "@@ -13,8 +13,9 @@ function accumulateMetadata(metadataItems: MetadataItems) {\n     item[0],\n     item[1],\n   ])\n-  return originAccumulateMetadata(fullMetadataItems, {\n-    pathname: '/test',\n+  const route = '/test'\n+  const pathname = Promise.resolve('/test')\n+  return originAccumulateMetadata(route, fullMetadataItems, pathname, {\n     trailingSlash: false,\n     isStaticMetadataRouteFile: false,\n   })"
        },
        {
            "sha": "3f211468b3c4766f861fc38d010c73816e533050",
            "filename": "packages/next/src/lib/metadata/resolve-metadata.ts",
            "status": "modified",
            "additions": 51,
            "deletions": 32,
            "changes": 83,
            "blob_url": "https://github.com/vercel/next.js/blob/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolve-metadata.ts?ref=6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
            "patch": "@@ -105,15 +105,16 @@ function isFavicon(icon: IconDescriptor | undefined): boolean {\n   )\n }\n \n-function mergeStaticMetadata(\n+async function mergeStaticMetadata(\n   source: Metadata | null,\n   target: ResolvedMetadata,\n   staticFilesMetadata: StaticMetadata,\n   metadataContext: MetadataContext,\n   titleTemplates: TitleTemplates,\n-  leafSegmentStaticIcons: StaticIcons\n-) {\n-  if (!staticFilesMetadata) return\n+  leafSegmentStaticIcons: StaticIcons,\n+  pathname: Promise<string>\n+): Promise<ResolvedMetadata> {\n+  if (!staticFilesMetadata) return target\n   const { icon, apple, openGraph, twitter, manifest } = staticFilesMetadata\n \n   // Keep updating the static icons in the most leaf node\n@@ -138,9 +139,10 @@ function mergeStaticMetadata(\n \n   // file based metadata is specified and current level metadata openGraph.images is not specified\n   if (openGraph && !source?.openGraph?.hasOwnProperty('images')) {\n-    const resolvedOpenGraph = resolveOpenGraph(\n+    const resolvedOpenGraph = await resolveOpenGraph(\n       { ...target.openGraph, images: openGraph } as OpenGraph,\n       target.metadataBase,\n+      pathname,\n       { ...metadataContext, isStaticMetadataRouteFile: true },\n       titleTemplates.openGraph\n     )\n@@ -154,23 +156,27 @@ function mergeStaticMetadata(\n }\n \n // Merge the source metadata into the resolved target metadata.\n-function mergeMetadata({\n-  source,\n-  target,\n-  staticFilesMetadata,\n-  titleTemplates,\n-  metadataContext,\n-  buildState,\n-  leafSegmentStaticIcons,\n-}: {\n-  source: Metadata | null\n-  target: ResolvedMetadata\n-  staticFilesMetadata: StaticMetadata\n-  titleTemplates: TitleTemplates\n-  metadataContext: MetadataContext\n-  buildState: BuildState\n-  leafSegmentStaticIcons: StaticIcons\n-}): void {\n+async function mergeMetadata(\n+  route: string,\n+  pathname: Promise<string>,\n+  {\n+    source,\n+    target,\n+    staticFilesMetadata,\n+    titleTemplates,\n+    metadataContext,\n+    buildState,\n+    leafSegmentStaticIcons,\n+  }: {\n+    source: Metadata | null\n+    target: ResolvedMetadata\n+    staticFilesMetadata: StaticMetadata\n+    titleTemplates: TitleTemplates\n+    metadataContext: MetadataContext\n+    buildState: BuildState\n+    leafSegmentStaticIcons: StaticIcons\n+  }\n+): Promise<ResolvedMetadata> {\n   // If there's override metadata, prefer it otherwise fallback to the default metadata.\n   const metadataBase =\n     typeof source?.metadataBase !== 'undefined'\n@@ -185,17 +191,19 @@ function mergeMetadata({\n         break\n       }\n       case 'alternates': {\n-        target.alternates = resolveAlternates(\n+        target.alternates = await resolveAlternates(\n           source.alternates,\n           metadataBase,\n+          pathname,\n           metadataContext\n         )\n         break\n       }\n       case 'openGraph': {\n-        target.openGraph = resolveOpenGraph(\n+        target.openGraph = await resolveOpenGraph(\n           source.openGraph,\n           metadataBase,\n+          pathname,\n           metadataContext,\n           titleTemplates.openGraph\n         )\n@@ -243,17 +251,19 @@ function mergeMetadata({\n         break\n       }\n       case 'itunes': {\n-        target[key] = resolveItunes(\n+        target[key] = await resolveItunes(\n           source.itunes,\n           metadataBase,\n+          pathname,\n           metadataContext\n         )\n         break\n       }\n       case 'pagination': {\n-        target.pagination = resolvePagination(\n+        target.pagination = await resolvePagination(\n           source.pagination,\n           metadataBase,\n+          pathname,\n           metadataContext\n         )\n         break\n@@ -288,20 +298,21 @@ function mergeMetadata({\n           source[key] != null\n         ) {\n           buildState.warnings.add(\n-            `Unsupported metadata ${key} is configured in metadata export in ${metadataContext.pathname}. Please move it to viewport export instead.\\nRead more: https://nextjs.org/docs/app/api-reference/functions/generate-viewport`\n+            `Unsupported metadata ${key} is configured in metadata export in ${route}. Please move it to viewport export instead.\\nRead more: https://nextjs.org/docs/app/api-reference/functions/generate-viewport`\n           )\n         }\n         break\n       }\n     }\n   }\n-  mergeStaticMetadata(\n+  return mergeStaticMetadata(\n     source,\n     target,\n     staticFilesMetadata,\n     metadataContext,\n     titleTemplates,\n-    leafSegmentStaticIcons\n+    leafSegmentStaticIcons,\n+    pathname\n   )\n }\n \n@@ -903,10 +914,12 @@ function resolvePendingResult<\n }\n \n export async function accumulateMetadata(\n+  route: string,\n   metadataItems: MetadataItems,\n+  pathname: Promise<string>,\n   metadataContext: MetadataContext\n ): Promise<ResolvedMetadata> {\n-  const resolvedMetadata = createDefaultMetadata()\n+  let resolvedMetadata = createDefaultMetadata()\n \n   let titleTemplates: TitleTemplates = {\n     title: null,\n@@ -960,7 +973,7 @@ export async function accumulateMetadata(\n       metadata = pendingMetadata\n     }\n \n-    mergeMetadata({\n+    resolvedMetadata = await mergeMetadata(route, pathname, {\n       target: resolvedMetadata,\n       source: metadata,\n       metadataContext,\n@@ -1055,6 +1068,7 @@ export async function accumulateViewport(\n // Exposed API for metadata component, that directly resolve the loader tree and related context as resolved metadata.\n export async function resolveMetadata(\n   tree: LoaderTree,\n+  pathname: Promise<string>,\n   searchParams: Promise<ParsedUrlQuery>,\n   errorConvention: MetadataErrorType | undefined,\n   getDynamicParamFromSegment: GetDynamicParamFromSegment,\n@@ -1068,7 +1082,12 @@ export async function resolveMetadata(\n     getDynamicParamFromSegment,\n     workStore\n   )\n-  return accumulateMetadata(metadataItems, metadataContext)\n+  return accumulateMetadata(\n+    workStore.route,\n+    metadataItems,\n+    pathname,\n+    metadataContext\n+  )\n }\n \n // Exposed API for viewport component, that directly resolve the loader tree and related context as resolved viewport."
        },
        {
            "sha": "b5f7789aae5289ecc511ec4a138fc24f728dd29c",
            "filename": "packages/next/src/lib/metadata/resolvers/resolve-basics.ts",
            "status": "modified",
            "additions": 74,
            "deletions": 28,
            "changes": 102,
            "blob_url": "https://github.com/vercel/next.js/blob/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-basics.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-basics.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-basics.ts?ref=6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
            "patch": "@@ -10,7 +10,7 @@ import type {\n import type { ResolvedVerification } from '../types/metadata-types'\n import type {\n   FieldResolver,\n-  FieldResolverExtraArgs,\n+  AsyncFieldResolverExtraArgs,\n   MetadataContext,\n } from '../types/resolvers'\n import { resolveAsArrayOrUndefined } from '../generate/utils'\n@@ -19,18 +19,24 @@ import { resolveAbsoluteUrlWithPathname } from './resolve-url'\n function resolveAlternateUrl(\n   url: string | URL,\n   metadataBase: URL | null,\n+  pathname: string,\n   metadataContext: MetadataContext\n ) {\n   // If alter native url is an URL instance,\n   // we treat it as a URL base and resolve with current pathname\n   if (url instanceof URL) {\n-    const newUrl = new URL(metadataContext.pathname, url)\n+    const newUrl = new URL(pathname, url)\n     url.searchParams.forEach((value, key) =>\n       newUrl.searchParams.set(key, value)\n     )\n     url = newUrl\n   }\n-  return resolveAbsoluteUrlWithPathname(url, metadataBase, metadataContext)\n+  return resolveAbsoluteUrlWithPathname(\n+    url,\n+    metadataBase,\n+    pathname,\n+    metadataContext\n+  )\n }\n \n export const resolveThemeColor: FieldResolver<'themeColor', Viewport> = (\n@@ -52,7 +58,7 @@ export const resolveThemeColor: FieldResolver<'themeColor', Viewport> = (\n   return themeColorDescriptors\n }\n \n-function resolveUrlValuesOfObject(\n+async function resolveUrlValuesOfObject(\n   obj:\n     | Record<\n         string,\n@@ -61,22 +67,35 @@ function resolveUrlValuesOfObject(\n     | null\n     | undefined,\n   metadataBase: ResolvedMetadata['metadataBase'],\n+  pathname: Promise<string>,\n   metadataContext: MetadataContext\n-): null | Record<string, AlternateLinkDescriptor[]> {\n+): Promise<null | Record<string, AlternateLinkDescriptor[]>> {\n   if (!obj) return null\n \n   const result: Record<string, AlternateLinkDescriptor[]> = {}\n   for (const [key, value] of Object.entries(obj)) {\n     if (typeof value === 'string' || value instanceof URL) {\n+      const pathnameForUrl = await pathname\n       result[key] = [\n         {\n-          url: resolveAlternateUrl(value, metadataBase, metadataContext),\n+          url: resolveAlternateUrl(\n+            value,\n+            metadataBase,\n+            pathnameForUrl,\n+            metadataContext\n+          ),\n         },\n       ]\n-    } else {\n+    } else if (value && value.length) {\n       result[key] = []\n-      value?.forEach((item, index) => {\n-        const url = resolveAlternateUrl(item.url, metadataBase, metadataContext)\n+      const pathnameForUrl = await pathname\n+      value.forEach((item, index) => {\n+        const url = resolveAlternateUrl(\n+          item.url,\n+          metadataBase,\n+          pathnameForUrl,\n+          metadataContext\n+        )\n         result[key][index] = {\n           url,\n           title: item.title,\n@@ -87,48 +106,60 @@ function resolveUrlValuesOfObject(\n   return result\n }\n \n-function resolveCanonicalUrl(\n+async function resolveCanonicalUrl(\n   urlOrDescriptor: string | URL | null | AlternateLinkDescriptor | undefined,\n   metadataBase: URL | null,\n+  pathname: Promise<string>,\n   metadataContext: MetadataContext\n-): null | AlternateLinkDescriptor {\n+): Promise<null | AlternateLinkDescriptor> {\n   if (!urlOrDescriptor) return null\n \n   const url =\n     typeof urlOrDescriptor === 'string' || urlOrDescriptor instanceof URL\n       ? urlOrDescriptor\n       : urlOrDescriptor.url\n \n+  const pathnameForUrl = await pathname\n+\n   // Return string url because structureClone can't handle URL instance\n   return {\n-    url: resolveAlternateUrl(url, metadataBase, metadataContext),\n+    url: resolveAlternateUrl(\n+      url,\n+      metadataBase,\n+      pathnameForUrl,\n+      metadataContext\n+    ),\n   }\n }\n \n-export const resolveAlternates: FieldResolverExtraArgs<\n+export const resolveAlternates: AsyncFieldResolverExtraArgs<\n   'alternates',\n-  [ResolvedMetadata['metadataBase'], MetadataContext]\n-> = (alternates, metadataBase, context) => {\n+  [ResolvedMetadata['metadataBase'], Promise<string>, MetadataContext]\n+> = async (alternates, metadataBase, pathname, context) => {\n   if (!alternates) return null\n \n-  const canonical = resolveCanonicalUrl(\n+  const canonical = await resolveCanonicalUrl(\n     alternates.canonical,\n     metadataBase,\n+    pathname,\n     context\n   )\n-  const languages = resolveUrlValuesOfObject(\n+  const languages = await resolveUrlValuesOfObject(\n     alternates.languages,\n     metadataBase,\n+    pathname,\n     context\n   )\n-  const media = resolveUrlValuesOfObject(\n+  const media = await resolveUrlValuesOfObject(\n     alternates.media,\n     metadataBase,\n+    pathname,\n     context\n   )\n-  const types = resolveUrlValuesOfObject(\n+  const types = await resolveUrlValuesOfObject(\n     alternates.types,\n     metadataBase,\n+    pathname,\n     context\n   )\n \n@@ -243,15 +274,20 @@ export const resolveAppLinks: FieldResolver<'appLinks'> = (appLinks) => {\n   return appLinks as ResolvedMetadata['appLinks']\n }\n \n-export const resolveItunes: FieldResolverExtraArgs<\n+export const resolveItunes: AsyncFieldResolverExtraArgs<\n   'itunes',\n-  [ResolvedMetadata['metadataBase'], MetadataContext]\n-> = (itunes, metadataBase, context) => {\n+  [ResolvedMetadata['metadataBase'], Promise<string>, MetadataContext]\n+> = async (itunes, metadataBase, pathname, context) => {\n   if (!itunes) return null\n   return {\n     appId: itunes.appId,\n     appArgument: itunes.appArgument\n-      ? resolveAlternateUrl(itunes.appArgument, metadataBase, context)\n+      ? resolveAlternateUrl(\n+          itunes.appArgument,\n+          metadataBase,\n+          await pathname,\n+          context\n+        )\n       : undefined,\n   }\n }\n@@ -264,16 +300,26 @@ export const resolveFacebook: FieldResolver<'facebook'> = (facebook) => {\n   }\n }\n \n-export const resolvePagination: FieldResolverExtraArgs<\n+export const resolvePagination: AsyncFieldResolverExtraArgs<\n   'pagination',\n-  [ResolvedMetadata['metadataBase'], MetadataContext]\n-> = (pagination, metadataBase, context) => {\n+  [ResolvedMetadata['metadataBase'], Promise<string>, MetadataContext]\n+> = async (pagination, metadataBase, pathname, context) => {\n   return {\n     previous: pagination?.previous\n-      ? resolveAlternateUrl(pagination.previous, metadataBase, context)\n+      ? resolveAlternateUrl(\n+          pagination.previous,\n+          metadataBase,\n+          await pathname,\n+          context\n+        )\n       : null,\n     next: pagination?.next\n-      ? resolveAlternateUrl(pagination.next, metadataBase, context)\n+      ? resolveAlternateUrl(\n+          pagination.next,\n+          metadataBase,\n+          await pathname,\n+          context\n+        )\n       : null,\n   }\n }"
        },
        {
            "sha": "7639ebbb652ad2401ce8214257dab03e6c5e440b",
            "filename": "packages/next/src/lib/metadata/resolvers/resolve-opengraph.test.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-opengraph.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-opengraph.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-opengraph.test.ts?ref=6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
            "patch": "@@ -38,15 +38,16 @@ describe('resolveImages', () => {\n })\n \n describe('resolveOpenGraph', () => {\n-  it('should return null if the value is an empty string', () => {\n+  it('should return null if the value is an empty string', async () => {\n+    const pathname = Promise.resolve('')\n     expect(\n-      resolveOpenGraph(\n+      await resolveOpenGraph(\n         // pass authors as empty string\n         { type: 'article', authors: '' },\n         null,\n+        pathname,\n         {\n           trailingSlash: false,\n-          pathname: '',\n           isStaticMetadataRouteFile: false,\n         },\n         ''\n@@ -62,14 +63,15 @@ describe('resolveOpenGraph', () => {\n     })\n   })\n \n-  it('should return null if the value is null', () => {\n+  it('should return null if the value is null', async () => {\n+    const pathname = Promise.resolve('')\n     expect(\n-      resolveOpenGraph(\n+      await resolveOpenGraph(\n         { type: 'article', authors: null },\n         null,\n+        pathname,\n         {\n           trailingSlash: false,\n-          pathname: '',\n           isStaticMetadataRouteFile: false,\n         },\n         ''"
        },
        {
            "sha": "83a033a0c91d88c0e1982ff3ec7cd16feffe632e",
            "filename": "packages/next/src/lib/metadata/resolvers/resolve-opengraph.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-opengraph.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-opengraph.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-opengraph.ts?ref=6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
            "patch": "@@ -6,6 +6,7 @@ import type {\n } from '../types/opengraph-types'\n import type {\n   FieldResolverExtraArgs,\n+  AsyncFieldResolverExtraArgs,\n   MetadataContext,\n } from '../types/resolvers'\n import type { ResolvedTwitterMetadata, Twitter } from '../types/twitter-types'\n@@ -157,10 +158,16 @@ function getFieldsByOgType(ogType: OpenGraphType | undefined) {\n   return ogTypeToFields[ogType].concat(OgTypeFields.basic)\n }\n \n-export const resolveOpenGraph: FieldResolverExtraArgs<\n+export const resolveOpenGraph: AsyncFieldResolverExtraArgs<\n   'openGraph',\n-  [ResolvedMetadataBase, MetadataContext, string | null]\n-> = (openGraph, metadataBase, metadataContext, titleTemplate) => {\n+  [ResolvedMetadataBase, Promise<string>, MetadataContext, string | null]\n+> = async (\n+  openGraph,\n+  metadataBase,\n+  pathname,\n+  metadataContext,\n+  titleTemplate\n+) => {\n   if (!openGraph) return null\n \n   function resolveProps(target: ResolvedOpenGraph, og: OpenGraph) {\n@@ -191,6 +198,7 @@ export const resolveOpenGraph: FieldResolverExtraArgs<\n     ? resolveAbsoluteUrlWithPathname(\n         openGraph.url,\n         metadataBase,\n+        await pathname,\n         metadataContext\n       )\n     : null"
        },
        {
            "sha": "f216439dfd3e475f7c728f459cb681fce5349c03",
            "filename": "packages/next/src/lib/metadata/resolvers/resolve-url.test.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-url.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-url.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-url.test.ts?ref=6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
            "patch": "@@ -50,13 +50,13 @@ describe('metadata: resolveUrl', () => {\n describe('resolveAbsoluteUrlWithPathname', () => {\n   describe('trailingSlash is false', () => {\n     const metadataBase = new URL('https://example.com/')\n+    const pathname = '/'\n     const opts = {\n       trailingSlash: false,\n-      pathname: '/',\n       isStaticMetadataRouteFile: false,\n     }\n     const resolver = (url: string | URL) =>\n-      resolveAbsoluteUrlWithPathname(url, metadataBase, opts)\n+      resolveAbsoluteUrlWithPathname(url, metadataBase, pathname, opts)\n     it('should resolve absolute internal url', () => {\n       expect(resolver('https://example.com/foo')).toBe(\n         'https://example.com/foo'\n@@ -66,13 +66,13 @@ describe('resolveAbsoluteUrlWithPathname', () => {\n \n   describe('trailingSlash is true', () => {\n     const metadataBase = new URL('https://example.com/')\n+    const pathname = '/'\n     const opts = {\n       trailingSlash: true,\n-      pathname: '/',\n       isStaticMetadataRouteFile: false,\n     }\n     const resolver = (url: string | URL) =>\n-      resolveAbsoluteUrlWithPathname(url, metadataBase, opts)\n+      resolveAbsoluteUrlWithPathname(url, metadataBase, pathname, opts)\n     it('should add trailing slash to relative url', () => {\n       expect(resolver('/foo')).toBe('https://example.com/foo/')\n     })"
        },
        {
            "sha": "c95e54ad5b4aa3d14b096cebd5f4962106ed24e0",
            "filename": "packages/next/src/lib/metadata/resolvers/resolve-url.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-url.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-url.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fresolvers%2Fresolve-url.ts?ref=6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
            "patch": "@@ -98,7 +98,8 @@ function isFilePattern(pathname: string): boolean {\n function resolveAbsoluteUrlWithPathname(\n   url: string | URL,\n   metadataBase: URL | null,\n-  { trailingSlash, pathname }: MetadataContext\n+  pathname: string,\n+  { trailingSlash }: MetadataContext\n ): string {\n   // Resolve url with pathname that always starts with `/`\n   url = resolveRelativeUrl(url, pathname)"
        },
        {
            "sha": "e6178b6d353bffd35a2bc698298631de9585cafe",
            "filename": "packages/next/src/lib/metadata/types/resolvers.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Ftypes%2Fresolvers.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Ftypes%2Fresolvers.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Ftypes%2Fresolvers.ts?ref=6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
            "patch": "@@ -13,8 +13,14 @@ export type FieldResolverExtraArgs<\n   ResolvedData = ResolvedMetadata,\n > = (T: Data[Key], ...args: ExtraArgs) => ResolvedData[Key]\n \n+export type AsyncFieldResolverExtraArgs<\n+  Key extends keyof Data & keyof ResolvedData,\n+  ExtraArgs extends unknown[] = any[],\n+  Data = Metadata,\n+  ResolvedData = ResolvedMetadata,\n+> = (T: Data[Key], ...args: ExtraArgs) => Promise<ResolvedData[Key]>\n+\n export type MetadataContext = {\n-  pathname: string\n   trailingSlash: boolean\n   isStaticMetadataRouteFile: boolean\n }"
        },
        {
            "sha": "4b2a98aa852334f9a120a6b137c8f95198532daf",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 7,
            "deletions": 17,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
            "patch": "@@ -55,10 +55,7 @@ import {\n   NEXT_ROUTER_SEGMENT_PREFETCH_HEADER,\n   NEXT_HMR_REFRESH_HASH_COOKIE,\n } from '../../client/components/app-router-headers'\n-import {\n-  createTrackedMetadataContext,\n-  createMetadataContext,\n-} from '../../lib/metadata/metadata-context'\n+import { createMetadataContext } from '../../lib/metadata/metadata-context'\n import { createRequestStoreForRender } from '../async-storage/request-store'\n import { createWorkStore } from '../async-storage/work-store'\n import {\n@@ -496,11 +493,8 @@ async function generateDynamicRSCPayload(\n     } = createMetadataComponents({\n       tree: loaderTree,\n       parsedQuery: query,\n-      metadataContext: createTrackedMetadataContext(\n-        url.pathname,\n-        ctx.renderOpts,\n-        workStore\n-      ),\n+      pathname: url.pathname,\n+      metadataContext: createMetadataContext(ctx.renderOpts),\n       getDynamicParamFromSegment,\n       appUsingSizeAdjustment,\n       workStore,\n@@ -823,11 +817,8 @@ async function getRSCPayload(\n     // TODO: remove this condition and keep it undefined when global-not-found is stabilized.\n     errorType: is404 && !hasGlobalNotFound ? 'not-found' : undefined,\n     parsedQuery: query,\n-    metadataContext: createTrackedMetadataContext(\n-      url.pathname,\n-      ctx.renderOpts,\n-      workStore\n-    ),\n+    pathname: url.pathname,\n+    metadataContext: createMetadataContext(ctx.renderOpts),\n     getDynamicParamFromSegment,\n     appUsingSizeAdjustment,\n     workStore,\n@@ -945,9 +936,8 @@ async function getErrorRSCPayload(\n   const { MetadataTree, ViewportTree } = createMetadataComponents({\n     tree,\n     parsedQuery: query,\n-    // We create an untracked metadata context here because we can't postpone\n-    // again during the error render.\n-    metadataContext: createMetadataContext(url.pathname, ctx.renderOpts),\n+    pathname: url.pathname,\n+    metadataContext: createMetadataContext(ctx.renderOpts),\n     errorType,\n     getDynamicParamFromSegment,\n     appUsingSizeAdjustment,"
        },
        {
            "sha": "3e01ecb937b109ae1da53efd19761c27185361f2",
            "filename": "packages/next/src/server/request/pathname.ts",
            "status": "added",
            "additions": 99,
            "deletions": 0,
            "changes": 99,
            "blob_url": "https://github.com/vercel/next.js/blob/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fpathname.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6519ac4f5f6bad4de619b3d6e8c04b3f90196d91/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fpathname.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fpathname.ts?ref=6519ac4f5f6bad4de619b3d6e8c04b3f90196d91",
            "patch": "@@ -0,0 +1,99 @@\n+import type { WorkStore } from '../app-render/work-async-storage.external'\n+\n+import {\n+  postponeWithTracking,\n+  type DynamicTrackingState,\n+} from '../app-render/dynamic-rendering'\n+\n+import {\n+  workUnitAsyncStorage,\n+  type PrerenderStore,\n+} from '../app-render/work-unit-async-storage.external'\n+import { makeHangingPromise } from '../dynamic-rendering-utils'\n+\n+export function createServerPathnameForMetadata(\n+  underlyingPathname: string,\n+  workStore: WorkStore\n+): Promise<string> {\n+  const workUnitStore = workUnitAsyncStorage.getStore()\n+  if (workUnitStore) {\n+    switch (workUnitStore.type) {\n+      case 'prerender':\n+      case 'prerender-ppr':\n+      case 'prerender-legacy': {\n+        return createPrerenderPathname(\n+          underlyingPathname,\n+          workStore,\n+          workUnitStore\n+        )\n+      }\n+      default:\n+      // fallthrough\n+    }\n+  }\n+  return createRenderPathname(underlyingPathname)\n+}\n+\n+function createPrerenderPathname(\n+  underlyingPathname: string,\n+  workStore: WorkStore,\n+  prerenderStore: PrerenderStore\n+): Promise<string> {\n+  const fallbackParams = workStore.fallbackRouteParams\n+  if (fallbackParams && fallbackParams.size > 0) {\n+    switch (prerenderStore.type) {\n+      case 'prerender':\n+        return makeHangingPromise<string>(\n+          prerenderStore.renderSignal,\n+          '`pathname`'\n+        )\n+      case 'prerender-ppr':\n+        return makeErroringPathname(workStore, prerenderStore.dynamicTracking)\n+        break\n+      default:\n+        return makeErroringPathname(workStore, null)\n+    }\n+  }\n+\n+  // We don't have any fallback params so we have an entirely static safe params object\n+  return Promise.resolve(underlyingPathname)\n+}\n+\n+function makeErroringPathname<T>(\n+  workStore: WorkStore,\n+  dynamicTracking: null | DynamicTrackingState\n+): Promise<T> {\n+  let reject: null | ((reason: unknown) => void) = null\n+  const promise = new Promise<T>((_, re) => {\n+    reject = re\n+  })\n+\n+  const originalThen = promise.then.bind(promise)\n+\n+  // We instrument .then so that we can generate a tracking event only if you actually\n+  // await this promise, not just that it is created.\n+  promise.then = (onfulfilled, onrejected) => {\n+    if (reject) {\n+      try {\n+        postponeWithTracking(\n+          workStore.route,\n+          'metadata relative url resolving',\n+          dynamicTracking\n+        )\n+      } catch (error) {\n+        reject(error)\n+        reject = null\n+      }\n+    }\n+    return originalThen(onfulfilled, onrejected)\n+  }\n+\n+  // We wrap in a noop proxy to trick the runtime into thinking it\n+  // isn't a native promise (it's not really). This is so that awaiting\n+  // the promise will call the `then` property triggering the lazy postpone\n+  return new Proxy(promise, {})\n+}\n+\n+function createRenderPathname(underlyingPathname: string): Promise<string> {\n+  return Promise.resolve(underlyingPathname)\n+}"
        }
    ],
    "stats": {
        "total": 407,
        "additions": 281,
        "deletions": 126
    }
}