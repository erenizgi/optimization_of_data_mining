{
    "author": "agadzik",
    "message": "Exclude `traceparent` and `tracestate` headers from fetch deduplication cache keys (#83852)\n\n<!-- Thanks for opening a PR! Your contribution is much appreciated.\nTo make sure your PR is handled as smoothly as possible we request that\nyou follow the checklist sections below.\nChoose the right checklist for the change(s) that you're making:\n\n## For Contributors\n\n### Improving Documentation\n\n- Run `pnpm prettier-fix` to fix formatting issues before opening the\nPR.\n- Read the Docs Contribution Guide to ensure your contribution follows\nthe docs guidelines:\nhttps://nextjs.org/docs/community/contribution-guide\n\n### Fixing a bug\n\n- Related issues linked using `fixes #number`\n- Tests added. See:\nhttps://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs\n- Errors have a helpful link attached, see\nhttps://github.com/vercel/next.js/blob/canary/contributing.md\n\n### Adding a feature\n\n- Implements an existing feature request or RFC. Make sure the feature\nrequest has been accepted for implementation before opening a PR. (A\ndiscussion must be opened, see\nhttps://github.com/vercel/next.js/discussions/new?category=ideas)\n- Related issues/discussions are linked using `fixes #number`\n- e2e tests added\n(https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs)\n- Documentation added\n- Telemetry added. In case of a feature if it's used or not.\n- Errors have a helpful link attached, see\nhttps://github.com/vercel/next.js/blob/canary/contributing.md\n\n\n## For Maintainers\n\n- Minimal description (aim for explaining to someone not on the team to\nunderstand the PR)\n- When linking to a Slack thread, you might want to share details of the\nconclusion\n- Link both the Linear (Fixes NEXT-xxx) and the GitHub issues\n- Add review comments if necessary to explain to the reviewer the logic\nbehind a change\n\n### What?\n\n### Why?\n\n### How?\n\nCloses NEXT-\nFixes #\n\n-->\n\n### Problem\n\nAnyone using `@vercel/otel` or `@opentelemetry/sdk-node` or any other\no11y library that instruments `fetch` and adds distributed tracing\ncontext to every request **breaks fetch memoization**\n\n### Solution\n\nSpecify headers to exclude from the `fetch` cache key that don't matter\nfor memoization purposes.",
    "sha": "ef4308e0c408e95017fd30f87fb9a988545f806b",
    "files": [
        {
            "sha": "66d3f43c3cbfee4ca70ecfcc27e1c2bc4518a58a",
            "filename": "packages/next/src/server/lib/dedupe-fetch.test.ts",
            "status": "added",
            "additions": 699,
            "deletions": 0,
            "changes": 699,
            "blob_url": "https://github.com/vercel/next.js/blob/ef4308e0c408e95017fd30f87fb9a988545f806b/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fdedupe-fetch.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ef4308e0c408e95017fd30f87fb9a988545f806b/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fdedupe-fetch.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fdedupe-fetch.test.ts?ref=ef4308e0c408e95017fd30f87fb9a988545f806b",
            "patch": "@@ -0,0 +1,699 @@\n+/**\n+ * @jest-environment node\n+ */\n+\n+// Mock the React module first\n+jest.mock('react', () => ({\n+  cache: <T extends (...args: any[]) => any>(fn: T): T => {\n+    const cache = new Map<string, ReturnType<T>>()\n+    return ((...args: Parameters<T>) => {\n+      const key = JSON.stringify(args)\n+      if (!cache.has(key)) {\n+        cache.set(key, fn(...args))\n+      }\n+      return cache.get(key)!\n+    }) as T\n+  },\n+}))\n+\n+// Mock the clone-response module\n+jest.mock('./clone-response', () => ({\n+  cloneResponse: (response: Response) => {\n+    // Create two independent clones of the response\n+    const clone1 = response.clone()\n+    const clone2 = response.clone()\n+    return [clone1, clone2]\n+  },\n+}))\n+\n+import { createDedupeFetch } from './dedupe-fetch'\n+\n+describe('dedupe-fetch', () => {\n+  let originalFetch: jest.MockedFunction<typeof fetch>\n+  let dedupeFetch: ReturnType<typeof createDedupeFetch>\n+\n+  beforeEach(() => {\n+    // Create a fresh mock for each test\n+    originalFetch = jest.fn()\n+    dedupeFetch = createDedupeFetch(originalFetch)\n+\n+    // Clear all mocks between tests\n+    jest.clearAllMocks()\n+  })\n+\n+  describe('deduplication behavior', () => {\n+    it('should dedupe identical GET requests', async () => {\n+      const mockResponse = new Response('test response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      // Make two identical requests\n+      const promise1 = dedupeFetch('https://example.com/api')\n+      const promise2 = dedupeFetch('https://example.com/api')\n+\n+      const [response1, response2] = await Promise.all([promise1, promise2])\n+\n+      // Should only call original fetch once\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+      expect(originalFetch).toHaveBeenCalledWith(\n+        'https://example.com/api',\n+        undefined\n+      )\n+\n+      // Both responses should be valid\n+      expect(await response1.text()).toBe('test response')\n+      expect(await response2.text()).toBe('test response')\n+    })\n+\n+    it('should dedupe identical HEAD requests', async () => {\n+      const mockResponse = new Response(null, { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      // Make two identical HEAD requests\n+      const promise1 = dedupeFetch('https://example.com/api', {\n+        method: 'HEAD',\n+      })\n+      const promise2 = dedupeFetch('https://example.com/api', {\n+        method: 'HEAD',\n+      })\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should only call original fetch once\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+    })\n+\n+    it('should not dedupe requests with different URLs', async () => {\n+      const mockResponse1 = new Response('response 1', { status: 200 })\n+      const mockResponse2 = new Response('response 2', { status: 200 })\n+\n+      originalFetch\n+        .mockResolvedValueOnce(mockResponse1)\n+        .mockResolvedValueOnce(mockResponse2)\n+\n+      // Make requests to different URLs\n+      const promise1 = dedupeFetch('https://example.com/api1')\n+      const promise2 = dedupeFetch('https://example.com/api2')\n+\n+      const [response1, response2] = await Promise.all([promise1, promise2])\n+\n+      // Should call original fetch twice\n+      expect(originalFetch).toHaveBeenCalledTimes(2)\n+      expect(await response1.text()).toBe('response 1')\n+      expect(await response2.text()).toBe('response 2')\n+    })\n+\n+    it('should not dedupe requests with different headers', async () => {\n+      const mockResponse1 = new Response('response 1', { status: 200 })\n+      const mockResponse2 = new Response('response 2', { status: 200 })\n+\n+      originalFetch\n+        .mockResolvedValueOnce(mockResponse1)\n+        .mockResolvedValueOnce(mockResponse2)\n+\n+      // Make requests with different headers\n+      const promise1 = dedupeFetch('https://example.com/api', {\n+        headers: { 'X-Custom': 'value1' },\n+      })\n+      const promise2 = dedupeFetch('https://example.com/api', {\n+        headers: { 'X-Custom': 'value2' },\n+      })\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should call original fetch twice\n+      expect(originalFetch).toHaveBeenCalledTimes(2)\n+    })\n+\n+    it('should dedupe requests with different traceparent headers', async () => {\n+      const mockResponse1 = new Response('response 1', { status: 200 })\n+      const mockResponse2 = new Response('response 2', { status: 200 })\n+\n+      originalFetch\n+        .mockResolvedValueOnce(mockResponse1)\n+        .mockResolvedValueOnce(mockResponse2)\n+\n+      // Make requests with different traceparent headers (W3C Trace Context)\n+      // Each traceparent represents a different distributed trace\n+      const promise1 = dedupeFetch('https://example.com/api', {\n+        headers: {\n+          traceparent:\n+            '00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01',\n+        },\n+      })\n+      const promise2 = dedupeFetch('https://example.com/api', {\n+        headers: {\n+          traceparent:\n+            '00-0af7651916cd43dd8448eb211c80319c-b9c7c989f97918e1-01',\n+        },\n+      })\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should call original fetch once (different trace contexts are ok to be deduped)\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+      expect(originalFetch).toHaveBeenNthCalledWith(\n+        1,\n+        'https://example.com/api',\n+        expect.objectContaining({\n+          headers: {\n+            traceparent:\n+              '00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01',\n+          },\n+        })\n+      )\n+    })\n+\n+    it('should dedupe requests with different tracestate headers', async () => {\n+      const mockResponse1 = new Response('response 1', { status: 200 })\n+      const mockResponse2 = new Response('response 2', { status: 200 })\n+\n+      originalFetch\n+        .mockResolvedValueOnce(mockResponse1)\n+        .mockResolvedValueOnce(mockResponse2)\n+\n+      // Make requests with different tracestate headers (W3C Trace Context)\n+      // tracestate is vendor-specific trace data\n+      const promise1 = dedupeFetch('https://example.com/api', {\n+        headers: {\n+          traceparent:\n+            '00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01',\n+          tracestate: 'vendor1=value1,vendor2=value2',\n+        },\n+      })\n+      const promise2 = dedupeFetch('https://example.com/api', {\n+        headers: {\n+          traceparent:\n+            '00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01',\n+          tracestate: 'vendor1=value3,vendor2=value4',\n+        },\n+      })\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should call original fetch once (different tracestate values are ok to be deduped)\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+      expect(originalFetch).toHaveBeenNthCalledWith(\n+        1,\n+        'https://example.com/api',\n+        expect.objectContaining({\n+          headers: {\n+            traceparent:\n+              '00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01',\n+            tracestate: 'vendor1=value1,vendor2=value2',\n+          },\n+        })\n+      )\n+    })\n+\n+    it('should not dedupe requests with different request modes', async () => {\n+      const mockResponse1 = new Response('response 1', { status: 200 })\n+      const mockResponse2 = new Response('response 2', { status: 200 })\n+\n+      originalFetch\n+        .mockResolvedValueOnce(mockResponse1)\n+        .mockResolvedValueOnce(mockResponse2)\n+\n+      // Make requests with different modes\n+      const promise1 = dedupeFetch('https://example.com/api', {\n+        mode: 'cors',\n+      })\n+      const promise2 = dedupeFetch('https://example.com/api', {\n+        mode: 'no-cors',\n+      })\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should call original fetch twice\n+      expect(originalFetch).toHaveBeenCalledTimes(2)\n+    })\n+\n+    it('should handle multiple sequential duplicate requests', async () => {\n+      const mockResponse = new Response('test response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      // Make three identical requests\n+      const promise1 = dedupeFetch('https://example.com/api')\n+      const promise2 = dedupeFetch('https://example.com/api')\n+      const promise3 = dedupeFetch('https://example.com/api')\n+\n+      const [response1, response2, response3] = await Promise.all([\n+        promise1,\n+        promise2,\n+        promise3,\n+      ])\n+\n+      // Should only call original fetch once\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+\n+      // All responses should be valid\n+      expect(await response1.text()).toBe('test response')\n+      expect(await response2.text()).toBe('test response')\n+      expect(await response3.text()).toBe('test response')\n+    })\n+  })\n+\n+  describe('signal handling', () => {\n+    it('should not dedupe requests with signals', async () => {\n+      const mockResponse1 = new Response('response 1', { status: 200 })\n+      const mockResponse2 = new Response('response 2', { status: 200 })\n+\n+      originalFetch\n+        .mockResolvedValueOnce(mockResponse1)\n+        .mockResolvedValueOnce(mockResponse2)\n+\n+      const controller1 = new AbortController()\n+      const controller2 = new AbortController()\n+\n+      // Make requests with signals\n+      const promise1 = dedupeFetch('https://example.com/api', {\n+        signal: controller1.signal,\n+      })\n+      const promise2 = dedupeFetch('https://example.com/api', {\n+        signal: controller2.signal,\n+      })\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should call original fetch twice (signals opt out of deduplication)\n+      expect(originalFetch).toHaveBeenCalledTimes(2)\n+    })\n+\n+    it('should pass signal through to original fetch', async () => {\n+      const mockResponse = new Response('response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      const controller = new AbortController()\n+\n+      await dedupeFetch('https://example.com/api', {\n+        signal: controller.signal,\n+      })\n+\n+      expect(originalFetch).toHaveBeenCalledWith(\n+        'https://example.com/api',\n+        expect.objectContaining({ signal: controller.signal })\n+      )\n+    })\n+  })\n+\n+  describe('method handling', () => {\n+    it('should not dedupe POST requests', async () => {\n+      const mockResponse1 = new Response('response 1', { status: 200 })\n+      const mockResponse2 = new Response('response 2', { status: 200 })\n+\n+      originalFetch\n+        .mockResolvedValueOnce(mockResponse1)\n+        .mockResolvedValueOnce(mockResponse2)\n+\n+      // Make two POST requests\n+      const promise1 = dedupeFetch('https://example.com/api', {\n+        method: 'POST',\n+        body: JSON.stringify({ data: 'test' }),\n+      })\n+      const promise2 = dedupeFetch('https://example.com/api', {\n+        method: 'POST',\n+        body: JSON.stringify({ data: 'test' }),\n+      })\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should call original fetch twice (POST requests are not deduped)\n+      expect(originalFetch).toHaveBeenCalledTimes(2)\n+    })\n+\n+    it('should not dedupe PUT requests', async () => {\n+      const mockResponse1 = new Response('response 1', { status: 200 })\n+      const mockResponse2 = new Response('response 2', { status: 200 })\n+\n+      originalFetch\n+        .mockResolvedValueOnce(mockResponse1)\n+        .mockResolvedValueOnce(mockResponse2)\n+\n+      // Make two PUT requests\n+      const promise1 = dedupeFetch('https://example.com/api', {\n+        method: 'PUT',\n+        body: JSON.stringify({ data: 'test' }),\n+      })\n+      const promise2 = dedupeFetch('https://example.com/api', {\n+        method: 'PUT',\n+        body: JSON.stringify({ data: 'test' }),\n+      })\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should call original fetch twice\n+      expect(originalFetch).toHaveBeenCalledTimes(2)\n+    })\n+\n+    it('should not dedupe DELETE requests', async () => {\n+      const mockResponse1 = new Response('response 1', { status: 200 })\n+      const mockResponse2 = new Response('response 2', { status: 200 })\n+\n+      originalFetch\n+        .mockResolvedValueOnce(mockResponse1)\n+        .mockResolvedValueOnce(mockResponse2)\n+\n+      // Make two DELETE requests\n+      const promise1 = dedupeFetch('https://example.com/api', {\n+        method: 'DELETE',\n+      })\n+      const promise2 = dedupeFetch('https://example.com/api', {\n+        method: 'DELETE',\n+      })\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should call original fetch twice\n+      expect(originalFetch).toHaveBeenCalledTimes(2)\n+    })\n+\n+    it('should not dedupe PATCH requests', async () => {\n+      const mockResponse1 = new Response('response 1', { status: 200 })\n+      const mockResponse2 = new Response('response 2', { status: 200 })\n+\n+      originalFetch\n+        .mockResolvedValueOnce(mockResponse1)\n+        .mockResolvedValueOnce(mockResponse2)\n+\n+      // Make two PATCH requests\n+      const promise1 = dedupeFetch('https://example.com/api', {\n+        method: 'PATCH',\n+        body: JSON.stringify({ data: 'test' }),\n+      })\n+      const promise2 = dedupeFetch('https://example.com/api', {\n+        method: 'PATCH',\n+        body: JSON.stringify({ data: 'test' }),\n+      })\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should call original fetch twice\n+      expect(originalFetch).toHaveBeenCalledTimes(2)\n+    })\n+  })\n+\n+  describe('keepalive handling', () => {\n+    it('should not dedupe requests with keepalive', async () => {\n+      const mockResponse1 = new Response('response 1', { status: 200 })\n+      const mockResponse2 = new Response('response 2', { status: 200 })\n+\n+      originalFetch\n+        .mockResolvedValueOnce(mockResponse1)\n+        .mockResolvedValueOnce(mockResponse2)\n+\n+      // Make requests with keepalive\n+      const promise1 = dedupeFetch('https://example.com/api', {\n+        keepalive: true,\n+      })\n+      const promise2 = dedupeFetch('https://example.com/api', {\n+        keepalive: true,\n+      })\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should call original fetch twice (keepalive opts out of deduplication)\n+      expect(originalFetch).toHaveBeenCalledTimes(2)\n+    })\n+  })\n+\n+  describe('Request object handling', () => {\n+    it('should handle Request objects as input', async () => {\n+      const mockResponse = new Response('test response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      const request = new Request('https://example.com/api', {\n+        method: 'GET',\n+        headers: { 'X-Custom': 'value' },\n+      })\n+\n+      const response = await dedupeFetch(request)\n+\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+      expect(await response.text()).toBe('test response')\n+    })\n+\n+    it('should dedupe identical Request objects', async () => {\n+      const mockResponse = new Response('test response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      const request1 = new Request('https://example.com/api')\n+      const request2 = new Request('https://example.com/api')\n+\n+      const promise1 = dedupeFetch(request1)\n+      const promise2 = dedupeFetch(request2)\n+\n+      const [response1, response2] = await Promise.all([promise1, promise2])\n+\n+      // Should only call original fetch once\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+      expect(await response1.text()).toBe('test response')\n+      expect(await response2.text()).toBe('test response')\n+    })\n+\n+    it('should not dedupe Request objects with different properties', async () => {\n+      const mockResponse1 = new Response('response 1', { status: 200 })\n+      const mockResponse2 = new Response('response 2', { status: 200 })\n+\n+      originalFetch\n+        .mockResolvedValueOnce(mockResponse1)\n+        .mockResolvedValueOnce(mockResponse2)\n+\n+      const request1 = new Request('https://example.com/api', {\n+        headers: { 'X-Custom': 'value1' },\n+      })\n+      const request2 = new Request('https://example.com/api', {\n+        headers: { 'X-Custom': 'value2' },\n+      })\n+\n+      const promise1 = dedupeFetch(request1)\n+      const promise2 = dedupeFetch(request2)\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should call original fetch twice\n+      expect(originalFetch).toHaveBeenCalledTimes(2)\n+    })\n+\n+    it('should preserve the Request object body when it is a ReadableStream', async () => {\n+      const mockResponse = new Response('test response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      const stream = new ReadableStream({\n+        start(controller) {\n+          controller.enqueue(new TextEncoder().encode('stream data'))\n+          controller.close()\n+        },\n+      })\n+\n+      const request = new Request('https://example.com/api', {\n+        method: 'POST',\n+        body: stream,\n+        // @ts-ignore - duplex is required for streaming bodies in Node.js\n+        duplex: 'half',\n+      })\n+\n+      await dedupeFetch(request)\n+\n+      // Should pass the request as-is without creating a new Request\n+      expect(originalFetch).toHaveBeenCalledWith(request, undefined)\n+    })\n+  })\n+\n+  describe('URL handling', () => {\n+    it('should handle URL objects as input', async () => {\n+      const mockResponse = new Response('test response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      const url = new URL('https://example.com/api')\n+      const response = await dedupeFetch(url)\n+\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+      expect(await response.text()).toBe('test response')\n+    })\n+\n+    it('should dedupe identical URL objects', async () => {\n+      const mockResponse = new Response('test response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      const url1 = new URL('https://example.com/api')\n+      const url2 = new URL('https://example.com/api')\n+\n+      const promise1 = dedupeFetch(url1)\n+      const promise2 = dedupeFetch(url2)\n+\n+      const [response1, response2] = await Promise.all([promise1, promise2])\n+\n+      // Should only call original fetch once\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+      expect(await response1.text()).toBe('test response')\n+      expect(await response2.text()).toBe('test response')\n+    })\n+  })\n+\n+  describe('cache key generation', () => {\n+    it('should generate consistent cache keys for identical requests', async () => {\n+      const mockResponse = new Response('test response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      // Make requests with identical options but in different order\n+      const promise1 = dedupeFetch('https://example.com/api', {\n+        headers: {\n+          'X-Header-A': 'value-a',\n+          'X-Header-B': 'value-b',\n+        },\n+        mode: 'cors',\n+        credentials: 'include',\n+      })\n+\n+      const promise2 = dedupeFetch('https://example.com/api', {\n+        credentials: 'include',\n+        mode: 'cors',\n+        headers: {\n+          'X-Header-A': 'value-a',\n+          'X-Header-B': 'value-b',\n+        },\n+      })\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should only call original fetch once (same cache key)\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+    })\n+\n+    it('should use simple cache key for string URL without options', async () => {\n+      const mockResponse = new Response('test response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      // Multiple simple GET requests\n+      const promise1 = dedupeFetch('https://example.com/api')\n+      const promise2 = dedupeFetch('https://example.com/api')\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should only call original fetch once (using simple cache key)\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+    })\n+  })\n+\n+  describe('error handling', () => {\n+    it('should propagate fetch errors', async () => {\n+      const error = new Error('Network error')\n+      originalFetch.mockRejectedValue(error)\n+\n+      await expect(dedupeFetch('https://example.com/api')).rejects.toThrow(\n+        'Network error'\n+      )\n+    })\n+\n+    it('should share errors between deduped requests', async () => {\n+      const error = new Error('Network error')\n+      originalFetch.mockRejectedValue(error)\n+\n+      const promise1 = dedupeFetch('https://example.com/api')\n+      const promise2 = dedupeFetch('https://example.com/api')\n+\n+      await expect(promise1).rejects.toThrow('Network error')\n+      await expect(promise2).rejects.toThrow('Network error')\n+\n+      // Should only call original fetch once\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+    })\n+  })\n+\n+  describe('response cloning', () => {\n+    it('should allow multiple consumers to read the response body', async () => {\n+      const mockResponse = new Response('test response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      const promise1 = dedupeFetch('https://example.com/api')\n+      const promise2 = dedupeFetch('https://example.com/api')\n+\n+      const [response1, response2] = await Promise.all([promise1, promise2])\n+\n+      // Both responses should be able to read the body independently\n+      const text1 = await response1.text()\n+      const text2 = await response2.text()\n+\n+      expect(text1).toBe('test response')\n+      expect(text2).toBe('test response')\n+    })\n+\n+    it('should preserve response properties when cloning', async () => {\n+      const headers = new Headers({\n+        'Content-Type': 'application/json',\n+        'X-Custom': 'value',\n+      })\n+\n+      const mockResponse = new Response('{\"data\": \"test\"}', {\n+        status: 201,\n+        statusText: 'Created',\n+        headers,\n+      })\n+\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      const promise1 = dedupeFetch('https://example.com/api')\n+      const promise2 = dedupeFetch('https://example.com/api')\n+\n+      const [response1, response2] = await Promise.all([promise1, promise2])\n+\n+      // Check that both responses have the correct properties\n+      expect(response1.status).toBe(201)\n+      expect(response1.statusText).toBe('Created')\n+      expect(response1.headers.get('Content-Type')).toBe('application/json')\n+      expect(response1.headers.get('X-Custom')).toBe('value')\n+\n+      expect(response2.status).toBe(201)\n+      expect(response2.statusText).toBe('Created')\n+      expect(response2.headers.get('Content-Type')).toBe('application/json')\n+      expect(response2.headers.get('X-Custom')).toBe('value')\n+    })\n+  })\n+\n+  describe('request options', () => {\n+    it('should handle various request options', async () => {\n+      const mockResponse = new Response('test response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      const options: RequestInit = {\n+        method: 'GET',\n+        headers: { 'X-Custom': 'value' },\n+        mode: 'cors',\n+        credentials: 'include',\n+        redirect: 'follow',\n+        referrer: 'https://referrer.com',\n+        referrerPolicy: 'no-referrer',\n+        integrity: 'sha256-abc123',\n+      }\n+\n+      await dedupeFetch('https://example.com/api', options)\n+\n+      expect(originalFetch).toHaveBeenCalledWith(\n+        'https://example.com/api',\n+        options\n+      )\n+    })\n+\n+    it('should dedupe requests with identical complex options', async () => {\n+      const mockResponse = new Response('test response', { status: 200 })\n+      originalFetch.mockResolvedValue(mockResponse)\n+\n+      const options: RequestInit = {\n+        headers: { 'X-Custom': 'value', Authorization: 'Bearer token' },\n+        mode: 'cors',\n+        credentials: 'include',\n+        redirect: 'manual',\n+        referrer: 'https://referrer.com',\n+        referrerPolicy: 'strict-origin',\n+        integrity: 'sha256-abc123',\n+      }\n+\n+      const promise1 = dedupeFetch('https://example.com/api', options)\n+      const promise2 = dedupeFetch('https://example.com/api', options)\n+\n+      await Promise.all([promise1, promise2])\n+\n+      // Should only call original fetch once\n+      expect(originalFetch).toHaveBeenCalledTimes(1)\n+    })\n+  })\n+})"
        },
        {
            "sha": "a2625b596b056a54ba0d022cbcfb64cc511338e1",
            "filename": "packages/next/src/server/lib/dedupe-fetch.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/ef4308e0c408e95017fd30f87fb9a988545f806b/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fdedupe-fetch.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ef4308e0c408e95017fd30f87fb9a988545f806b/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fdedupe-fetch.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fdedupe-fetch.ts?ref=ef4308e0c408e95017fd30f87fb9a988545f806b",
            "patch": "@@ -7,16 +7,25 @@ import { InvariantError } from '../../shared/lib/invariant-error'\n \n const simpleCacheKey = '[\"GET\",[],null,\"follow\",null,null,null,null]' // generateCacheKey(new Request('https://blank'));\n \n+// Headers that should not affect deduplication\n+// traceparent and tracestate are used for distributed tracing and should not affect cache keys\n+const headersToExcludeInCacheKey = new Set(['traceparent', 'tracestate'])\n+\n function generateCacheKey(request: Request): string {\n   // We pick the fields that goes into the key used to dedupe requests.\n   // We don't include the `cache` field, because we end up using whatever\n   // caching resulted from the first request.\n   // Notably we currently don't consider non-standard (or future) options.\n   // This might not be safe. TODO: warn for non-standard extensions differing.\n   // IF YOU CHANGE THIS UPDATE THE simpleCacheKey ABOVE.\n+\n+  const filteredHeaders = Array.from(request.headers.entries()).filter(\n+    ([key]) => !headersToExcludeInCacheKey.has(key.toLowerCase())\n+  )\n+\n   return JSON.stringify([\n     request.method,\n-    Array.from(request.headers.entries()),\n+    filteredHeaders,\n     request.mode,\n     request.redirect,\n     request.credentials,"
        },
        {
            "sha": "d4dbdc8eef4d2c45de511a5f858edf6f4ab1621c",
            "filename": "test/e2e/app-dir/app-fetch-deduping/app-fetch-deduping.test.ts",
            "status": "modified",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/ef4308e0c408e95017fd30f87fb9a988545f806b/test%2Fe2e%2Fapp-dir%2Fapp-fetch-deduping%2Fapp-fetch-deduping.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ef4308e0c408e95017fd30f87fb9a988545f806b/test%2Fe2e%2Fapp-dir%2Fapp-fetch-deduping%2Fapp-fetch-deduping.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-fetch-deduping%2Fapp-fetch-deduping.test.ts?ref=ef4308e0c408e95017fd30f87fb9a988545f806b",
            "patch": "@@ -120,8 +120,39 @@ describe('app-fetch-deduping', () => {\n         await retry(async () => {\n           await next.render('/test')\n           expect(invocation(next.cliOutput)).toBe(2)\n+          await next.stop()\n         }, 10_000)\n       })\n+\n+      it('dedupes requests with different trace headers', async () => {\n+        await next.start()\n+        await next.patchFile(\n+          'app/test/page.tsx',\n+          outdent`\n+          async function getTime(traceId: string) {\n+            const res = await fetch(\"http://localhost:${next.appPort}/api/time\", {\n+              headers: {\n+                'traceparent': '00-\\${traceId}-b7ad6b7169203331-01',\n+                'tracestate': 'vendor1=value1'\n+              }\n+            })\n+            return res.text()\n+          }\n+          \n+          export default async function Home() {\n+            await getTime('b7ad6b7169203331')\n+            await getTime('c7ad6b7169203332')\n+            const time = await getTime('d7ad6b7169203333')\n+          \n+            return <h1>{time}</h1>\n+          }`\n+        )\n+\n+        await next.render('/test')\n+\n+        expect(invocation(next.cliOutput)).toBe(1)\n+        await next.stop()\n+      })\n     })\n   } else {\n     it('should skip other scenarios', () => {})"
        },
        {
            "sha": "e40dd5b4123097a00b1d6d0fb22bb950ae3fe01e",
            "filename": "test/e2e/app-dir/app-fetch-deduping/app/trace-headers/page.js",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/ef4308e0c408e95017fd30f87fb9a988545f806b/test%2Fe2e%2Fapp-dir%2Fapp-fetch-deduping%2Fapp%2Ftrace-headers%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/ef4308e0c408e95017fd30f87fb9a988545f806b/test%2Fe2e%2Fapp-dir%2Fapp-fetch-deduping%2Fapp%2Ftrace-headers%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-fetch-deduping%2Fapp%2Ftrace-headers%2Fpage.js?ref=ef4308e0c408e95017fd30f87fb9a988545f806b",
            "patch": "@@ -0,0 +1,36 @@\n+async function getData() {\n+  const responses = await Promise.all([\n+    fetch(`http://localhost:${process.env.TEST_SERVER_PORT}`, {\n+      headers: {\n+        traceparent: '00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01',\n+        tracestate: 'vendor1=value1',\n+      },\n+    }).then((res) => res.text()),\n+    fetch(`http://localhost:${process.env.TEST_SERVER_PORT}`, {\n+      headers: {\n+        traceparent: '00-1af7651916cd43dd8448eb211c80319c-c7ad6b7169203332-01',\n+        tracestate: 'vendor2=value2',\n+      },\n+    }).then((res) => res.text()),\n+    fetch(`http://localhost:${process.env.TEST_SERVER_PORT}`, {\n+      headers: {\n+        traceparent: '00-2af7651916cd43dd8448eb211c80319c-d7ad6b7169203333-01',\n+        tracestate: 'vendor3=value3',\n+      },\n+    }).then((res) => res.text()),\n+  ])\n+\n+  return responses\n+}\n+\n+export default async function StaticTracePage() {\n+  const data = await getData()\n+\n+  return (\n+    <div>\n+      <h1>Static Page with Trace Headers</h1>\n+      <p>All responses should have the same data due to deduplication:</p>\n+      <pre>{JSON.stringify(data, null, 2)}</pre>\n+    </div>\n+  )\n+}"
        }
    ],
    "stats": {
        "total": 777,
        "additions": 776,
        "deletions": 1
    }
}