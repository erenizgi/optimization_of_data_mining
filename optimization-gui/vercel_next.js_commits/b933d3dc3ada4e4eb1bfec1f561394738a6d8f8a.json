{
    "author": "bgw",
    "message": "Turbopack: Remove tokio and turbo-task handles from Invalidator (#88242)\n\nWe may have many `Invalidator`s, and we're often looping over collections of them. Instead of storing a weak reference to `TurboTasksApi` and tokio's `Handle` inside of `Invalidator`, it's better for the callsite to track this.\n\n`Weak<dyn TurboTasksApi>` and `Handle` are both 16-byte fat pointers, and there's some alignment overhead, so **this reduces the size of Invalidator from 40 bytes to 4 bytes** (according to RA), and reduces the number of refcount increment/decrements we have to do when using invalidators.  \n  \nThese changes were LLM-generated, with careful manual review and cleanup.",
    "sha": "b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a",
    "files": [
        {
            "sha": "5e3dddb9dc215f28b673e883a8756dbe466db72d",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/read_ref_cell.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs?ref=b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a",
            "patch": "@@ -5,7 +5,7 @@\n use std::{collections::HashSet, mem::take, sync::Mutex};\n \n use anyhow::Result;\n-use turbo_tasks::{Invalidator, ReadRef, Vc, get_invalidator};\n+use turbo_tasks::{Invalidator, ReadRef, Vc, get_invalidator, with_turbo_tasks};\n use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n@@ -60,11 +60,14 @@ struct Counter {\n \n impl Counter {\n     fn incr(&self) {\n-        let mut lock = self.value.lock().unwrap();\n-        lock.0 += 1;\n-        for i in take(&mut lock.1) {\n-            i.invalidate();\n-        }\n+        with_turbo_tasks(|tt| {\n+            let mut lock = self.value.lock().unwrap();\n+            lock.0 += 1;\n+            let invalidators = take(&mut lock.1);\n+            for i in invalidators {\n+                i.invalidate(&**tt);\n+            }\n+        });\n     }\n }\n "
        },
        {
            "sha": "870f166e9964bc3c77997956c06d5f4b0e8990bf",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trait_ref_cell.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs?ref=b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a",
            "patch": "@@ -5,7 +5,7 @@\n use std::{collections::HashSet, mem::take, sync::Mutex};\n \n use anyhow::Result;\n-use turbo_tasks::{IntoTraitRef, Invalidator, TraitRef, Vc, get_invalidator};\n+use turbo_tasks::{IntoTraitRef, Invalidator, TraitRef, Vc, get_invalidator, with_turbo_tasks};\n use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n@@ -69,11 +69,14 @@ struct Counter {\n \n impl Counter {\n     fn incr(&self) {\n-        let mut lock = self.value.lock().unwrap();\n-        lock.0 += 1;\n-        for i in take(&mut lock.1) {\n-            i.invalidate();\n-        }\n+        with_turbo_tasks(|tt| {\n+            let mut lock = self.value.lock().unwrap();\n+            lock.0 += 1;\n+            let invalidators = take(&mut lock.1);\n+            for i in invalidators {\n+                i.invalidate(&**tt);\n+            }\n+        });\n     }\n }\n "
        },
        {
            "sha": "c576efc5f9c4fb7dc82805dac6722eaea025321c",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 41,
            "deletions": 9,
            "changes": 50,
            "blob_url": "https://github.com/vercel/next.js/blob/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a",
            "patch": "@@ -41,7 +41,7 @@ use std::{\n     io::{self, BufRead, BufReader, ErrorKind, Read},\n     mem::take,\n     path::{MAIN_SEPARATOR, Path, PathBuf},\n-    sync::{Arc, LazyLock},\n+    sync::{Arc, LazyLock, Weak},\n     time::Duration,\n };\n \n@@ -55,13 +55,16 @@ use jsonc_parser::{ParseOptions, parse_to_serde_value};\n use mime::Mime;\n use rustc_hash::FxHashSet;\n use serde_json::Value;\n-use tokio::sync::{RwLock, RwLockReadGuard};\n+use tokio::{\n+    runtime::Handle,\n+    sync::{RwLock, RwLockReadGuard},\n+};\n use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n     ApplyEffectsContext, Completion, InvalidationReason, Invalidator, NonLocalValue, ReadRef,\n-    ResolvedVc, TaskInput, ValueToString, Vc, debug::ValueDebugFormat, effect,\n-    mark_session_dependent, mark_stateful, parallel, trace::TraceRawVcs,\n+    ResolvedVc, TaskInput, TurboTasksApi, ValueToString, Vc, debug::ValueDebugFormat, effect,\n+    mark_session_dependent, mark_stateful, parallel, trace::TraceRawVcs, turbo_tasks_weak,\n };\n use turbo_tasks_hash::{DeterministicHash, DeterministicHasher, hash_xxh3_hash64};\n use turbo_unix_path::{\n@@ -288,6 +291,15 @@ struct DiskFileSystemInner {\n     /// Root paths that we do not allow access to from this filesystem.\n     /// Useful for things like output directories to prevent accidental ouroboros situations.\n     denied_paths: Vec<RcStr>,\n+    /// Used by invalidators when called from a non-turbo-tasks thread, specifically in the fs\n+    /// watcher.\n+    #[turbo_tasks(debug_ignore, trace_ignore)]\n+    #[bincode(skip, default = \"turbo_tasks_weak\")]\n+    turbo_tasks: Weak<dyn TurboTasksApi>,\n+    /// Used by invalidators when called from a non-tokio thread, specifically in the fs watcher.\n+    #[turbo_tasks(debug_ignore, trace_ignore)]\n+    #[bincode(skip, default = \"Handle::current\")]\n+    tokio_handle: Handle,\n }\n \n impl DiskFileSystemInner {\n@@ -371,14 +383,21 @@ impl DiskFileSystemInner {\n \n     fn invalidate(&self) {\n         let _span = tracing::info_span!(\"invalidate filesystem\", name = &*self.root).entered();\n+        let Some(turbo_tasks) = self.turbo_tasks.upgrade() else {\n+            return;\n+        };\n+        let _guard = self.tokio_handle.enter();\n+\n         let invalidator_map = take(&mut *self.invalidator_map.lock().unwrap());\n         let dir_invalidator_map = take(&mut *self.dir_invalidator_map.lock().unwrap());\n         let invalidators = invalidator_map\n             .into_iter()\n             .chain(dir_invalidator_map)\n             .flat_map(|(_, invalidators)| invalidators.into_keys())\n             .collect::<Vec<_>>();\n-        parallel::for_each_owned(invalidators, |invalidator| invalidator.invalidate());\n+        parallel::for_each_owned(invalidators, |invalidator| {\n+            invalidator.invalidate(&*turbo_tasks)\n+        });\n     }\n \n     /// Invalidates every tracked file in the filesystem.\n@@ -389,6 +408,11 @@ impl DiskFileSystemInner {\n         reason: impl Fn(&Path) -> R + Sync,\n     ) {\n         let _span = tracing::info_span!(\"invalidate filesystem\", name = &*self.root).entered();\n+        let Some(turbo_tasks) = self.turbo_tasks.upgrade() else {\n+            return;\n+        };\n+        let _guard = self.tokio_handle.enter();\n+\n         let invalidator_map = take(&mut *self.invalidator_map.lock().unwrap());\n         let dir_invalidator_map = take(&mut *self.dir_invalidator_map.lock().unwrap());\n         let invalidators = invalidator_map\n@@ -402,7 +426,7 @@ impl DiskFileSystemInner {\n             })\n             .collect::<Vec<_>>();\n         parallel::for_each_owned(invalidators, |(reason, invalidator)| {\n-            invalidator.invalidate_with_reason(reason)\n+            invalidator.invalidate_with_reason(&*turbo_tasks, reason)\n         });\n     }\n \n@@ -412,18 +436,24 @@ impl DiskFileSystemInner {\n         invalidators: Vec<(Invalidator, Option<WriteContent>)>,\n     ) {\n         if !invalidators.is_empty() {\n+            let Some(turbo_tasks) = self.turbo_tasks.upgrade() else {\n+                return;\n+            };\n+            let _guard = self.tokio_handle.enter();\n+\n             if let Some(path) = format_absolute_fs_path(full_path, &self.name, self.root_path()) {\n                 if invalidators.len() == 1 {\n                     let (invalidator, _) = invalidators.into_iter().next().unwrap();\n-                    invalidator.invalidate_with_reason(Write { path });\n+                    invalidator.invalidate_with_reason(&*turbo_tasks, Write { path });\n                 } else {\n                     invalidators.into_iter().for_each(|(invalidator, _)| {\n-                        invalidator.invalidate_with_reason(Write { path: path.clone() });\n+                        invalidator\n+                            .invalidate_with_reason(&*turbo_tasks, Write { path: path.clone() });\n                     });\n                 }\n             } else {\n                 invalidators.into_iter().for_each(|(invalidator, _)| {\n-                    invalidator.invalidate();\n+                    invalidator.invalidate(&*turbo_tasks);\n                 });\n             }\n         }\n@@ -648,6 +678,8 @@ impl DiskFileSystem {\n                 write_semaphore: create_write_semaphore(),\n                 watcher: DiskWatcher::new(),\n                 denied_paths,\n+                turbo_tasks: turbo_tasks_weak(),\n+                tokio_handle: Handle::current(),\n             }),\n         };\n "
        },
        {
            "sha": "c82c7d3113f58c1c64e0454bd820c35de24ba384",
            "filename": "turbopack/crates/turbo-tasks-fs/src/watcher.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 13,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs?ref=b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a",
            "patch": "@@ -21,8 +21,8 @@ use rustc_hash::FxHashSet;\n use tracing::instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    FxIndexSet, InvalidationReason, InvalidationReasonKind, Invalidator, parallel, spawn_thread,\n-    util::StaticOrArc,\n+    FxIndexSet, InvalidationReason, InvalidationReasonKind, Invalidator, TurboTasksApi, parallel,\n+    spawn_thread, util::StaticOrArc,\n };\n \n use crate::{\n@@ -401,8 +401,9 @@ impl DiskWatcher {\n         // side-effect, this will call `ensure_watched` again, setting up any watchers needed.\n         //\n         // Best is to start_watching before starting to read\n-        {\n+        if let Some(turbo_tasks) = fs_inner.turbo_tasks.upgrade() {\n             let _span = tracing::info_span!(\"invalidate filesystem\").entered();\n+            let _guard = fs_inner.tokio_handle.enter();\n             let invalidator_map = take(&mut *fs_inner.invalidator_map.lock().unwrap());\n             let dir_invalidator_map = take(&mut *fs_inner.dir_invalidator_map.lock().unwrap());\n             let iter = invalidator_map.into_iter().chain(dir_invalidator_map);\n@@ -418,14 +419,14 @@ impl DiskWatcher {\n                     })\n                     .collect::<Vec<_>>();\n                 parallel::for_each_owned(invalidators, |(reason, (invalidator, _))| {\n-                    invalidator.invalidate_with_reason(reason);\n+                    invalidator.invalidate_with_reason(&*turbo_tasks, reason);\n                 });\n             } else {\n                 let invalidators = iter\n                     .flat_map(|(_, invalidators)| invalidators.into_keys())\n                     .collect::<Vec<_>>();\n                 parallel::for_each_owned(invalidators, |invalidator| {\n-                    invalidator.invalidate();\n+                    invalidator.invalidate(&*turbo_tasks);\n                 });\n             }\n         }\n@@ -688,17 +689,25 @@ impl DiskWatcher {\n                 }\n             }\n \n+            let Some(turbo_tasks) = fs_inner.turbo_tasks.upgrade() else {\n+                // TurboTasks was dropped, stop watching\n+                break 'outer;\n+            };\n+            let _guard = fs_inner.tokio_handle.enter();\n+\n             let _lock = fs_inner.invalidation_lock.blocking_write();\n             {\n                 let mut invalidator_map = fs_inner.invalidator_map.lock().unwrap();\n                 invalidate_path(\n                     &fs_inner,\n+                    &*turbo_tasks,\n                     report_invalidation_reason,\n                     &mut invalidator_map,\n                     batched_invalidate_path.drain(),\n                 );\n                 invalidate_path_and_children_execute(\n                     &fs_inner,\n+                    &*turbo_tasks,\n                     report_invalidation_reason,\n                     &mut invalidator_map,\n                     batched_invalidate_path_and_children.drain(),\n@@ -708,12 +717,14 @@ impl DiskWatcher {\n                 let mut dir_invalidator_map = fs_inner.dir_invalidator_map.lock().unwrap();\n                 invalidate_path(\n                     &fs_inner,\n+                    &*turbo_tasks,\n                     report_invalidation_reason,\n                     &mut dir_invalidator_map,\n                     batched_invalidate_path_dir.drain(),\n                 );\n                 invalidate_path_and_children_execute(\n                     &fs_inner,\n+                    &*turbo_tasks,\n                     report_invalidation_reason,\n                     &mut dir_invalidator_map,\n                     batched_invalidate_path_and_children_dir.drain(),\n@@ -751,45 +762,48 @@ impl DiskWatcher {\n )]\n fn invalidate(\n     inner: &DiskFileSystemInner,\n+    turbo_tasks: &dyn TurboTasksApi,\n     report_invalidation_reason: bool,\n     path: &Path,\n     invalidator: Invalidator,\n ) {\n     if report_invalidation_reason\n         && let Some(path) = format_absolute_fs_path(path, &inner.name, inner.root_path())\n     {\n-        invalidator.invalidate_with_reason(WatchChange { path });\n+        invalidator.invalidate_with_reason(turbo_tasks, WatchChange { path });\n         return;\n     }\n-    invalidator.invalidate();\n+    invalidator.invalidate(turbo_tasks);\n }\n \n fn invalidate_path(\n     inner: &DiskFileSystemInner,\n+    turbo_tasks: &dyn TurboTasksApi,\n     report_invalidation_reason: bool,\n     invalidator_map: &mut LockedInvalidatorMap,\n     paths: impl Iterator<Item = PathBuf>,\n ) {\n     for path in paths {\n         if let Some(invalidators) = invalidator_map.remove(&path) {\n-            invalidators\n-                .into_iter()\n-                .for_each(|(i, _)| invalidate(inner, report_invalidation_reason, &path, i));\n+            invalidators.into_iter().for_each(|(i, _)| {\n+                invalidate(inner, turbo_tasks, report_invalidation_reason, &path, i)\n+            });\n         }\n     }\n }\n \n fn invalidate_path_and_children_execute(\n     inner: &DiskFileSystemInner,\n+    turbo_tasks: &dyn TurboTasksApi,\n     report_invalidation_reason: bool,\n     invalidator_map: &mut LockedInvalidatorMap,\n     paths: impl Iterator<Item = PathBuf>,\n ) {\n     for path in paths {\n         for (_, invalidators) in invalidator_map.extract_path_with_children(&path) {\n-            invalidators\n-                .into_iter()\n-                .for_each(|(i, _)| invalidate(inner, report_invalidation_reason, &path, i));\n+            invalidators.into_iter().for_each(|(i, _)| {\n+                invalidate(inner, turbo_tasks, report_invalidation_reason, &path, i)\n+            });\n         }\n     }\n }"
        },
        {
            "sha": "4a685556ad1cdcff392ea0a425ea76ca3da76032",
            "filename": "turbopack/crates/turbo-tasks/src/invalidation.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 91,
            "changes": 118,
            "blob_url": "https://github.com/vercel/next.js/blob/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Finvalidation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Finvalidation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Finvalidation.rs?ref=b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a",
            "patch": "@@ -1,27 +1,14 @@\n-use std::{\n-    fmt::Display,\n-    hash::Hash,\n-    mem::replace,\n-    sync::{Arc, Weak},\n-};\n+use std::{fmt::Display, mem::replace, sync::Arc};\n \n-use anyhow::Result;\n-use bincode::{\n-    Decode, Encode,\n-    de::Decoder,\n-    enc::Encoder,\n-    error::{DecodeError, EncodeError},\n-    impl_borrow_decode,\n-};\n+use bincode::{Decode, Encode};\n use indexmap::map::Entry;\n-use tokio::runtime::Handle;\n use turbo_dyn_eq_hash::{\n     DynEq, DynHash, impl_eq_for_dyn, impl_hash_for_dyn, impl_partial_eq_for_dyn,\n };\n \n use crate::{\n     FxIndexMap, FxIndexSet, TaskId, TurboTasksApi,\n-    manager::{current_task_if_available, mark_invalidator, with_turbo_tasks},\n+    manager::{current_task_if_available, mark_invalidator},\n     trace::TraceRawVcs,\n     util::StaticOrArc,\n };\n@@ -32,104 +19,53 @@ use crate::{\n pub fn get_invalidator() -> Option<Invalidator> {\n     if let Some(task) = current_task_if_available(\"turbo_tasks::get_invalidator()\") {\n         mark_invalidator();\n-\n-        let handle = Handle::current();\n-        Some(Invalidator {\n-            task,\n-            turbo_tasks: with_turbo_tasks(Arc::downgrade),\n-            handle,\n-        })\n+        Some(Invalidator { task })\n     } else {\n         None\n     }\n }\n \n+/// A lightweight handle to invalidate a task. Only stores the task ID.\n+/// The caller must provide the `TurboTasksApi` when calling invalidation methods.\n+#[derive(Clone, Copy, Hash, PartialEq, Eq, Encode, Decode)]\n pub struct Invalidator {\n     task: TaskId,\n-    turbo_tasks: Weak<dyn TurboTasksApi>,\n-    handle: Handle,\n }\n \n impl Invalidator {\n-    pub fn invalidate(self) {\n-        let Invalidator {\n-            task,\n-            turbo_tasks,\n-            handle,\n-        } = self;\n-        let _guard = handle.enter();\n-        if let Some(turbo_tasks) = turbo_tasks.upgrade() {\n-            turbo_tasks.invalidate(task);\n-        }\n-    }\n-\n-    pub fn invalidate_with_reason<T: InvalidationReason>(self, reason: T) {\n-        let Invalidator {\n-            task,\n-            turbo_tasks,\n-            handle,\n-        } = self;\n-        let _guard = handle.enter();\n-        if let Some(turbo_tasks) = turbo_tasks.upgrade() {\n-            turbo_tasks.invalidate_with_reason(\n-                task,\n-                (Arc::new(reason) as Arc<dyn InvalidationReason>).into(),\n-            );\n-        }\n-    }\n-\n-    pub fn invalidate_with_static_reason<T: InvalidationReason>(self, reason: &'static T) {\n-        let Invalidator {\n-            task,\n-            turbo_tasks,\n-            handle,\n-        } = self;\n-        let _guard = handle.enter();\n-        if let Some(turbo_tasks) = turbo_tasks.upgrade() {\n-            turbo_tasks\n-                .invalidate_with_reason(task, (reason as &'static dyn InvalidationReason).into());\n-        }\n+    pub fn invalidate(self, turbo_tasks: &dyn TurboTasksApi) {\n+        turbo_tasks.invalidate(self.task);\n     }\n-}\n \n-impl Hash for Invalidator {\n-    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n-        self.task.hash(state);\n+    pub fn invalidate_with_reason<T: InvalidationReason>(\n+        self,\n+        turbo_tasks: &dyn TurboTasksApi,\n+        reason: T,\n+    ) {\n+        turbo_tasks.invalidate_with_reason(\n+            self.task,\n+            (Arc::new(reason) as Arc<dyn InvalidationReason>).into(),\n+        );\n     }\n-}\n \n-impl PartialEq for Invalidator {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.task == other.task\n+    pub fn invalidate_with_static_reason<T: InvalidationReason>(\n+        self,\n+        turbo_tasks: &dyn TurboTasksApi,\n+        reason: &'static T,\n+    ) {\n+        turbo_tasks.invalidate_with_reason(\n+            self.task,\n+            (reason as &'static dyn InvalidationReason).into(),\n+        );\n     }\n }\n \n-impl Eq for Invalidator {}\n-\n impl TraceRawVcs for Invalidator {\n     fn trace_raw_vcs(&self, _context: &mut crate::trace::TraceRawVcsContext) {\n         // nothing here\n     }\n }\n \n-impl Encode for Invalidator {\n-    fn encode<E: Encoder>(&self, encoder: &mut E) -> Result<(), EncodeError> {\n-        Encode::encode(&self.task, encoder)\n-    }\n-}\n-\n-impl<Context> Decode<Context> for Invalidator {\n-    fn decode<D: Decoder<Context = Context>>(decoder: &mut D) -> Result<Self, DecodeError> {\n-        Ok(Invalidator {\n-            task: Decode::decode(decoder)?,\n-            turbo_tasks: with_turbo_tasks(Arc::downgrade),\n-            handle: tokio::runtime::Handle::current(),\n-        })\n-    }\n-}\n-\n-impl_borrow_decode!(Invalidator);\n-\n /// A user-facing reason why a task was invalidated. This should only be used\n /// for invalidation that were triggered by the user.\n ///"
        },
        {
            "sha": "c72bd763e184601aab78eff47ed5892794e711b1",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a",
            "patch": "@@ -113,7 +113,8 @@ pub use crate::{\n         CurrentCellRef, ReadConsistency, ReadTracking, TaskPersistence, TurboTasks, TurboTasksApi,\n         TurboTasksBackendApi, TurboTasksCallApi, Unused, UpdateInfo, dynamic_call, emit,\n         mark_finished, mark_root, mark_session_dependent, mark_stateful, prevent_gc, run, run_once,\n-        run_once_with_reason, trait_call, turbo_tasks, turbo_tasks_scope,\n+        run_once_with_reason, trait_call, turbo_tasks, turbo_tasks_scope, turbo_tasks_weak,\n+        with_turbo_tasks,\n     },\n     output::OutputContent,\n     raw_vc::{CellId, RawVc, ReadRawVcFuture, ResolveTypeError},"
        },
        {
            "sha": "804fa3598182e979a88ad33b938b5daf8f9c858d",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a",
            "patch": "@@ -1593,6 +1593,10 @@ pub fn turbo_tasks() -> Arc<dyn TurboTasksApi> {\n     TURBO_TASKS.with(|arc| arc.clone())\n }\n \n+pub fn turbo_tasks_weak() -> Weak<dyn TurboTasksApi> {\n+    TURBO_TASKS.with(Arc::downgrade)\n+}\n+\n pub fn try_turbo_tasks() -> Option<Arc<dyn TurboTasksApi>> {\n     TURBO_TASKS.try_with(|arc| arc.clone()).ok()\n }"
        },
        {
            "sha": "3b5551995adf0c1bd0c37186ee32d14d243b059e",
            "filename": "turbopack/crates/turbo-tasks/src/state.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 10,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fstate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fstate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fstate.rs?ref=b933d3dc3ada4e4eb1bfec1f561394738a6d8f8a",
            "patch": "@@ -11,8 +11,8 @@ use parking_lot::{Mutex, MutexGuard};\n use tracing::trace_span;\n \n use crate::{\n-    Invalidator, OperationValue, SerializationInvalidator, get_invalidator, mark_session_dependent,\n-    mark_stateful, trace::TraceRawVcs,\n+    Invalidator, OperationValue, SerializationInvalidator, get_invalidator,\n+    manager::with_turbo_tasks, mark_session_dependent, mark_stateful, trace::TraceRawVcs,\n };\n \n #[derive(Encode, Decode)]\n@@ -36,8 +36,13 @@ impl<T> StateInner<T> {\n     pub fn set_unconditionally(&mut self, value: T) {\n         self.value = value;\n         let _span = trace_span!(\"state value changed\", value_type = type_name::<T>()).entered();\n-        for invalidator in take(&mut self.invalidators) {\n-            invalidator.invalidate();\n+        let invalidators = take(&mut self.invalidators);\n+        if !invalidators.is_empty() {\n+            with_turbo_tasks(|tt| {\n+                for invalidator in invalidators {\n+                    invalidator.invalidate(&**tt);\n+                }\n+            });\n         }\n     }\n \n@@ -46,8 +51,13 @@ impl<T> StateInner<T> {\n             return false;\n         }\n         let _span = trace_span!(\"state value changed\", value_type = type_name::<T>()).entered();\n-        for invalidator in take(&mut self.invalidators) {\n-            invalidator.invalidate();\n+        let invalidators = take(&mut self.invalidators);\n+        if !invalidators.is_empty() {\n+            with_turbo_tasks(|tt| {\n+                for invalidator in invalidators {\n+                    invalidator.invalidate(&**tt);\n+                }\n+            });\n         }\n         true\n     }\n@@ -60,8 +70,13 @@ impl<T: PartialEq> StateInner<T> {\n         }\n         let _span = trace_span!(\"state value changed\", value_type = type_name::<T>()).entered();\n         self.value = value;\n-        for invalidator in take(&mut self.invalidators) {\n-            invalidator.invalidate();\n+        let invalidators = take(&mut self.invalidators);\n+        if !invalidators.is_empty() {\n+            with_turbo_tasks(|tt| {\n+                for invalidator in invalidators {\n+                    invalidator.invalidate(&**tt);\n+                }\n+            });\n         }\n         true\n     }\n@@ -92,8 +107,13 @@ impl<T> Drop for StateRef<'_, T> {\n     fn drop(&mut self) {\n         if self.mutated {\n             let _span = trace_span!(\"state value changed\", value_type = type_name::<T>()).entered();\n-            for invalidator in take(&mut self.inner.invalidators) {\n-                invalidator.invalidate();\n+            let invalidators = take(&mut self.inner.invalidators);\n+            if !invalidators.is_empty() {\n+                with_turbo_tasks(|tt| {\n+                    for invalidator in invalidators {\n+                        invalidator.invalidate(&**tt);\n+                    }\n+                });\n             }\n             if let Some(serialization_invalidator) = self.serialization_invalidator {\n                 serialization_invalidator.invalidate();"
        }
    ],
    "stats": {
        "total": 285,
        "additions": 149,
        "deletions": 136
    }
}