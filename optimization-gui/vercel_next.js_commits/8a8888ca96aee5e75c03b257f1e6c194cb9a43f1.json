{
    "author": "lukesandberg",
    "message": "[turbopack] use `require` to load chunks in our node runtime (#81738)\n\n## Use `require` to load chunks in node instead of readFile+eval\n\nThe benefit of this is that we can slightly simplify chunk loading and make it easier for hosting services to cache bytecode.\n\nMuch like [browsers](https://v8.dev/blog/code-caching-for-devs), server environments often leverage VM features to cache parsed javascript as bytecode (or maybe binary ast?) to accelerate cold starts ([example](https://vercel.com/blog/introducing-bytecode-caching-for-vercel-functions)), however, these systems generally avoid caching highly dynamic content like inline scripts and `eval` parameters.  \n\nSo just use `require` which is what platforms expect!  This should help platforms achieve code caching, is generally simpler, and by not adding a prefix we fix some subtle off-by-one issue with source maps. \n\nA slightly better solution imho would be `import()` since it would enable node to do some file reading parsing async with the main thread which could be important if there are multiple `preloadModules`, however this breaks dev mode hot reloading.\n\nFixes #PACK-5062",
    "sha": "8a8888ca96aee5e75c03b257f1e6c194cb9a43f1",
    "files": [
        {
            "sha": "f69782858754660d7257b7f6a85d2872ce5678b3",
            "filename": "test/e2e/app-dir/cache-components-errors/cache-components-errors.test.ts",
            "status": "modified",
            "additions": 22,
            "deletions": 20,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/8a8888ca96aee5e75c03b257f1e6c194cb9a43f1/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-errors.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/8a8888ca96aee5e75c03b257f1e6c194cb9a43f1/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-errors.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fcache-components-errors%2Fcache-components-errors.test.ts?ref=8a8888ca96aee5e75c03b257f1e6c194cb9a43f1",
            "patch": "@@ -657,14 +657,16 @@ describe('Cache Components Errors', () => {\n             } else {\n               expect(output).toMatchInlineSnapshot(`\n                \"Error: Route \"/dynamic-root\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense\n-                   at c (turbopack:///[project]/app/dynamic-root/indirection.tsx:9:1)\n+                   at c (turbopack:///[project]/app/dynamic-root/indirection.tsx:7:34)\n                    at main (<anonymous>)\n                    at body (<anonymous>)\n                    at html (<anonymous>)\n-                  7 | export function IndirectionTwo({ children }) {\n+                  5 | }\n+                  6 |\n+               >  7 | export function IndirectionTwo({ children }) {\n+                    |                                  ^\n                   8 |   return children\n-               >  9 | }\n-                    | ^\n+                  9 | }\n                  10 |\n                To get a more detailed stack trace and pinpoint the issue, try one of the following:\n                  - Start the app in development mode by running \\`next dev\\`, then open \"/dynamic-root\" in your browser to investigate the error.\n@@ -1680,14 +1682,14 @@ describe('Cache Components Errors', () => {\n               } else {\n                 expect(output).toMatchInlineSnapshot(`\n                  \"Error: Route \"/sync-attribution/guarded-async-unguarded-clientsync\" used \\`new Date()\\` inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time-client\n-                     at c (turbopack:///[project]/app/sync-attribution/guarded-async-unguarded-clientsync/client.tsx:9:7)\n-                    7 |   return (\n-                    8 |     <main>\n-                 >  9 |       <h1>Sync IO Access</h1>\n-                      |       ^\n-                   10 |       <p suppressHydrationWarning>Current date and time: {data}</p>\n-                   11 |     </main>\n-                   12 |   )\n+                     at c (turbopack:///[project]/app/sync-attribution/guarded-async-unguarded-clientsync/client.tsx:5:16)\n+                   3 | export function SyncIO() {\n+                   4 |   // This is a sync IO access that should not cause an error\n+                 > 5 |   const data = new Date().toISOString()\n+                     |                ^\n+                   6 |\n+                   7 |   return (\n+                   8 |     <main>\n                  To get a more detailed stack trace and pinpoint the issue, try one of the following:\n                    - Start the app in development mode by running \\`next dev\\`, then open \"/sync-attribution/guarded-async-unguarded-clientsync\" in your browser to investigate the error.\n                    - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces.\n@@ -1989,14 +1991,14 @@ describe('Cache Components Errors', () => {\n               } else {\n                 expect(output).toMatchInlineSnapshot(`\n                  \"Error: Route \"/sync-attribution/unguarded-async-unguarded-clientsync\" used \\`new Date()\\` inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time-client\n-                     at c (turbopack:///[project]/app/sync-attribution/unguarded-async-unguarded-clientsync/client.tsx:9:7)\n-                    7 |   return (\n-                    8 |     <main>\n-                 >  9 |       <h1>Sync IO Access</h1>\n-                      |       ^\n-                   10 |       <p suppressHydrationWarning>Current date and time: {data}</p>\n-                   11 |     </main>\n-                   12 |   )\n+                     at c (turbopack:///[project]/app/sync-attribution/unguarded-async-unguarded-clientsync/client.tsx:5:16)\n+                   3 | export function SyncIO() {\n+                   4 |   // This is a sync IO access that should not cause an error\n+                 > 5 |   const data = new Date().toISOString()\n+                     |                ^\n+                   6 |\n+                   7 |   return (\n+                   8 |     <main>\n                  To get a more detailed stack trace and pinpoint the issue, try one of the following:\n                    - Start the app in development mode by running \\`next dev\\`, then open \"/sync-attribution/unguarded-async-unguarded-clientsync\" in your browser to investigate the error.\n                    - Rerun the production build with \\`next build --debug-prerender\\` to generate better stack traces."
        },
        {
            "sha": "11966499bcbaac26cb7e700aebd2efe4b134d7c0",
            "filename": "test/e2e/app-dir/server-source-maps/server-source-maps.test.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/8a8888ca96aee5e75c03b257f1e6c194cb9a43f1/test%2Fe2e%2Fapp-dir%2Fserver-source-maps%2Fserver-source-maps.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/8a8888ca96aee5e75c03b257f1e6c194cb9a43f1/test%2Fe2e%2Fapp-dir%2Fserver-source-maps%2Fserver-source-maps.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fserver-source-maps%2Fserver-source-maps.test.ts?ref=8a8888ca96aee5e75c03b257f1e6c194cb9a43f1",
            "patch": "@@ -230,14 +230,15 @@ describe('app-dir - server source maps', () => {\n       }\n     } else {\n       if (isTurbopack) {\n-        // TODO(veil): Sourcemapping line off\n         // TODO(veil): Sourcemap names\n         // TODO(veil): relative paths\n         expect(normalizeCliOutput(next.cliOutput)).toContain(\n-          '(bundler:///app/ssr-error-log-ignore-listed/page.js:23:5)'\n+          '(bundler:///app/ssr-error-log-ignore-listed/page.js:9:17)'\n         )\n         expect(normalizeCliOutput(next.cliOutput)).toContain(\n-          '\\n> 23 |     })\\n     |     ^'\n+          '\\n' +\n+            \">  9 |   const error = new Error('ssr-error-log-ignore-listed')\\n\" +\n+            '     |                 ^\\n'\n         )\n       } else {\n         // TODO(veil): line/column numbers are flaky in Webpack"
        },
        {
            "sha": "b9776f8fee6c46fe051682a3d0e6064c018c31a7",
            "filename": "test/production/app-dir/build-output-prerender/build-output-prerender.test.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/8a8888ca96aee5e75c03b257f1e6c194cb9a43f1/test%2Fproduction%2Fapp-dir%2Fbuild-output-prerender%2Fbuild-output-prerender.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/8a8888ca96aee5e75c03b257f1e6c194cb9a43f1/test%2Fproduction%2Fapp-dir%2Fbuild-output-prerender%2Fbuild-output-prerender.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fbuild-output-prerender%2Fbuild-output-prerender.test.ts?ref=8a8888ca96aee5e75c03b257f1e6c194cb9a43f1",
            "patch": "@@ -82,11 +82,12 @@ describe('build-output-prerender', () => {\n           // TODO(veil): Why is the location incomplete unless we enable --no-mangling?\n           expect(getPrerenderOutput(next.cliOutput)).toMatchInlineSnapshot(`\n            \"Error: Route \"/client\" used \\`new Date()\\` inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time-client\n-               at c (bundler:///app/client/page.tsx:5:1)\n+               at c (bundler:///app/client/page.tsx:4:28)\n+             2 |\n              3 | export default function Page() {\n-             4 |   return <p>Current time: {new Date().toISOString()}</p>\n-           > 5 | }\n-               | ^\n+           > 4 |   return <p>Current time: {new Date().toISOString()}</p>\n+               |                            ^\n+             5 | }\n              6 |\n            To get a more detailed stack trace and pinpoint the issue, try one of the following:\n              - Start the app in development mode by running \\`next dev\\`, then open \"/client\" in your browser to investigate the error."
        },
        {
            "sha": "512db06dc17a7f0a139cbba4951c802d63c90514",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/nodejs/runtime.ts",
            "status": "modified",
            "additions": 37,
            "deletions": 55,
            "changes": 92,
            "blob_url": "https://github.com/vercel/next.js/blob/8a8888ca96aee5e75c03b257f1e6c194cb9a43f1/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fnodejs%2Fruntime.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/8a8888ca96aee5e75c03b257f1e6c194cb9a43f1/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fnodejs%2Fruntime.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fnodejs%2Fruntime.ts?ref=8a8888ca96aee5e75c03b257f1e6c194cb9a43f1",
            "patch": "@@ -86,16 +86,16 @@ function createResolvePathFromModule(\n \n function loadChunk(chunkData: ChunkData, source?: SourceInfo): void {\n   if (typeof chunkData === 'string') {\n-    return loadChunkPath(chunkData, source)\n+    loadChunkPath(chunkData, source)\n   } else {\n-    return loadChunkPath(chunkData.path, source)\n+    loadChunkPath(chunkData.path, source)\n   }\n }\n \n const loadedChunks = new Set<ChunkPath>()\n const unsupportedLoadChunk = Promise.resolve(undefined)\n-const loadedChunk = Promise.resolve(undefined)\n-const chunkCache = new Map<ChunkPath, Promise<any> | typeof loadedChunk>()\n+const loadedChunk: Promise<void> = Promise.resolve(undefined)\n+const chunkCache = new Map<ChunkPath, Promise<void>>()\n \n function clearChunkCache() {\n   chunkCache.clear()\n@@ -119,7 +119,7 @@ function loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\n     for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\n       if (!moduleFactories[moduleId]) {\n         if (Array.isArray(moduleFactory)) {\n-          let [moduleFactoryFn, otherIds] = moduleFactory\n+          const [moduleFactoryFn, otherIds] = moduleFactory\n           moduleFactories[moduleId] = moduleFactoryFn\n           for (const otherModuleId of otherIds) {\n             moduleFactories[otherModuleId] = moduleFactoryFn\n@@ -143,63 +143,32 @@ function loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\n   }\n }\n \n-async function loadChunkAsyncUncached(\n-  source: SourceInfo,\n-  chunkPath: ChunkPath\n-): Promise<void> {\n+function loadChunkUncached(chunkPath: ChunkPath) {\n+  // resolve to an absolute path to simplify `require` handling\n   const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\n \n-  try {\n-    const contents = await fs.readFile(resolved, 'utf-8')\n-\n-    const localRequire = (id: string) => {\n-      let resolvedId = require.resolve(id, { paths: [path.dirname(resolved)] })\n-      return require(resolvedId)\n-    }\n-    const module = {\n-      exports: {},\n-    }\n-    // TODO: Use vm.runInThisContext once our minimal supported Node.js version includes https://github.com/nodejs/node/pull/52153\n-    // eslint-disable-next-line no-eval -- Can't use vm.runInThisContext due to https://github.com/nodejs/node/issues/52102\n-    ;(0, eval)(\n-      '(function(module, exports, require, __dirname, __filename) {' +\n-        contents +\n-        '\\n})' +\n-        '\\n//# sourceURL=' +\n-        url.pathToFileURL(resolved)\n-    )(module, module.exports, localRequire, path.dirname(resolved), resolved)\n-\n-    const chunkModules: CompressedModuleFactories = module.exports\n-    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\n-      if (!moduleFactories[moduleId]) {\n-        if (Array.isArray(moduleFactory)) {\n-          let [moduleFactoryFn, otherIds] = moduleFactory\n-          moduleFactories[moduleId] = moduleFactoryFn\n-          for (const otherModuleId of otherIds) {\n-            moduleFactories[otherModuleId] = moduleFactoryFn\n-          }\n-        } else {\n-          moduleFactories[moduleId] = moduleFactory\n+  // TODO: consider switching to `import()` to enable concurrent chunk loading and async file io\n+  // However this is incompatible with hot reloading (since `import` doesn't use the require cache)\n+  const chunkModules: CompressedModuleFactories = require(resolved)\n+  for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\n+    if (!moduleFactories[moduleId]) {\n+      if (Array.isArray(moduleFactory)) {\n+        const [moduleFactoryFn, otherIds] = moduleFactory\n+        moduleFactories[moduleId] = moduleFactoryFn\n+        for (const otherModuleId of otherIds) {\n+          moduleFactories[otherModuleId] = moduleFactoryFn\n         }\n+      } else {\n+        moduleFactories[moduleId] = moduleFactory\n       }\n     }\n-  } catch (e) {\n-    let errorMessage = `Failed to load chunk ${chunkPath}`\n-\n-    if (source) {\n-      errorMessage += ` from ${stringifySourceInfo(source)}`\n-    }\n-\n-    throw new Error(errorMessage, {\n-      cause: e,\n-    })\n   }\n }\n \n function loadChunkAsync(\n   source: SourceInfo,\n   chunkData: ChunkData\n-): Promise<any> {\n+): Promise<void> {\n   const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\n   if (!isJs(chunkPath)) {\n     // We only support loading JS chunks in Node.js.\n@@ -209,10 +178,23 @@ function loadChunkAsync(\n \n   let entry = chunkCache.get(chunkPath)\n   if (entry === undefined) {\n-    const resolve = chunkCache.set.bind(chunkCache, chunkPath, loadedChunk)\n-    // A new Promise ensures callers that don't handle rejection will still trigger one unhandled rejection.\n-    // Handling the rejection will not trigger unhandled rejections.\n-    entry = loadChunkAsyncUncached(source, chunkPath).then(resolve)\n+    try {\n+      // Load the chunk synchronously\n+      loadChunkUncached(chunkPath)\n+      entry = loadedChunk\n+    } catch (e) {\n+      let errorMessage = `Failed to load chunk ${chunkPath}`\n+      if (source) {\n+        errorMessage += ` from ${stringifySourceInfo(source)}`\n+      }\n+\n+      // Cache the failure promise, future requests will also get this same rejection\n+      entry = Promise.reject(\n+        new Error(errorMessage, {\n+          cause: e,\n+        })\n+      )\n+    }\n     chunkCache.set(chunkPath, entry)\n   }\n   // TODO: Return an instrumented Promise that React can use instead of relying on referential equality."
        },
        {
            "sha": "70523406cb670aacebad65937ed30d0f732d9bb1",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/output/[turbopack]_runtime.js",
            "status": "modified",
            "additions": 31,
            "deletions": 41,
            "changes": 72,
            "blob_url": "https://github.com/vercel/next.js/blob/8a8888ca96aee5e75c03b257f1e6c194cb9a43f1/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js",
            "raw_url": "https://github.com/vercel/next.js/raw/8a8888ca96aee5e75c03b257f1e6c194cb9a43f1/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js?ref=8a8888ca96aee5e75c03b257f1e6c194cb9a43f1",
            "patch": "@@ -490,9 +490,9 @@ const moduleCache = Object.create(null);\n }\n function loadChunk(chunkData, source) {\n     if (typeof chunkData === 'string') {\n-        return loadChunkPath(chunkData, source);\n+        loadChunkPath(chunkData, source);\n     } else {\n-        return loadChunkPath(chunkData.path, source);\n+        loadChunkPath(chunkData.path, source);\n     }\n }\n const loadedChunks = new Set();\n@@ -517,7 +517,7 @@ function loadChunkPath(chunkPath, source) {\n         for (const [moduleId, moduleFactory] of Object.entries(chunkModules)){\n             if (!moduleFactories[moduleId]) {\n                 if (Array.isArray(moduleFactory)) {\n-                    let [moduleFactoryFn, otherIds] = moduleFactory;\n+                    const [moduleFactoryFn, otherIds] = moduleFactory;\n                     moduleFactories[moduleId] = moduleFactoryFn;\n                     for (const otherModuleId of otherIds){\n                         moduleFactories[otherModuleId] = moduleFactoryFn;\n@@ -538,44 +538,24 @@ function loadChunkPath(chunkPath, source) {\n         });\n     }\n }\n-async function loadChunkAsyncUncached(source, chunkPath) {\n+function loadChunkUncached(chunkPath) {\n+    // resolve to an absolute path to simplify `require` handling\n     const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n-    try {\n-        const contents = await fs.readFile(resolved, 'utf-8');\n-        const localRequire = (id)=>{\n-            let resolvedId = require.resolve(id, {\n-                paths: [\n-                    path.dirname(resolved)\n-                ]\n-            });\n-            return require(resolvedId);\n-        };\n-        const module1 = {\n-            exports: {}\n-        };\n-        (0, eval)('(function(module, exports, require, __dirname, __filename) {' + contents + '\\n})' + '\\n//# sourceURL=' + url.pathToFileURL(resolved))(module1, module1.exports, localRequire, path.dirname(resolved), resolved);\n-        const chunkModules = module1.exports;\n-        for (const [moduleId, moduleFactory] of Object.entries(chunkModules)){\n-            if (!moduleFactories[moduleId]) {\n-                if (Array.isArray(moduleFactory)) {\n-                    let [moduleFactoryFn, otherIds] = moduleFactory;\n-                    moduleFactories[moduleId] = moduleFactoryFn;\n-                    for (const otherModuleId of otherIds){\n-                        moduleFactories[otherModuleId] = moduleFactoryFn;\n-                    }\n-                } else {\n-                    moduleFactories[moduleId] = moduleFactory;\n+    // TODO: consider switching to `import()` to enable concurrent chunk loading and async file io\n+    // However this is incompatible with hot reloading (since `import` doesn't use the require cache)\n+    const chunkModules = require(resolved);\n+    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)){\n+        if (!moduleFactories[moduleId]) {\n+            if (Array.isArray(moduleFactory)) {\n+                const [moduleFactoryFn, otherIds] = moduleFactory;\n+                moduleFactories[moduleId] = moduleFactoryFn;\n+                for (const otherModuleId of otherIds){\n+                    moduleFactories[otherModuleId] = moduleFactoryFn;\n                 }\n+            } else {\n+                moduleFactories[moduleId] = moduleFactory;\n             }\n         }\n-    } catch (e) {\n-        let errorMessage = `Failed to load chunk ${chunkPath}`;\n-        if (source) {\n-            errorMessage += ` from ${stringifySourceInfo(source)}`;\n-        }\n-        throw new Error(errorMessage, {\n-            cause: e\n-        });\n     }\n }\n function loadChunkAsync(source, chunkData) {\n@@ -587,10 +567,20 @@ function loadChunkAsync(source, chunkData) {\n     }\n     let entry = chunkCache.get(chunkPath);\n     if (entry === undefined) {\n-        const resolve = chunkCache.set.bind(chunkCache, chunkPath, loadedChunk);\n-        // A new Promise ensures callers that don't handle rejection will still trigger one unhandled rejection.\n-        // Handling the rejection will not trigger unhandled rejections.\n-        entry = loadChunkAsyncUncached(source, chunkPath).then(resolve);\n+        try {\n+            // Load the chunk synchronously\n+            loadChunkUncached(chunkPath);\n+            entry = loadedChunk;\n+        } catch (e) {\n+            let errorMessage = `Failed to load chunk ${chunkPath}`;\n+            if (source) {\n+                errorMessage += ` from ${stringifySourceInfo(source)}`;\n+            }\n+            // Cache the failure promise, future requests will also get this same rejection\n+            entry = Promise.reject(new Error(errorMessage, {\n+                cause: e\n+            }));\n+        }\n         chunkCache.set(chunkPath, entry);\n     }\n     // TODO: Return an instrumented Promise that React can use instead of relying on referential equality."
        },
        {
            "sha": "d59f7c2e3deb876139c1f5cb93855a47fa80fc76",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/output/[turbopack]_runtime.js.map",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/8a8888ca96aee5e75c03b257f1e6c194cb9a43f1/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/8a8888ca96aee5e75c03b257f1e6c194cb9a43f1/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js.map?ref=8a8888ca96aee5e75c03b257f1e6c194cb9a43f1",
            "patch": "@@ -6,5 +6,5 @@\n     {\"offset\": {\"line\": 367, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/base-externals-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n\\n/// A 'base' utilities to support runtime can have externals.\\n/// Currently this is for node.js / edge runtime both.\\n/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\\n\\nasync function externalImport(id: DependencySpecifier) {\\n  let raw\\n  try {\\n    raw = await import(id)\\n  } catch (err) {\\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\\n    // an external module we don't provide a shim for (e.g. querystring, url).\\n    // For now, we fail semi-silently, but in the future this should be a\\n    // compilation error.\\n    throw new Error(`Failed to load external module ${id}: ${err}`)\\n  }\\n\\n  if (raw && raw.__esModule && raw.default && 'default' in raw.default) {\\n    return interopEsm(raw.default, createNS(raw), true)\\n  }\\n\\n  return raw\\n}\\n\\nfunction externalRequire(\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm: boolean = false\\n): Exports | EsmNamespaceObject {\\n  let raw\\n  try {\\n    raw = thunk()\\n  } catch (err) {\\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\\n    // an external module we don't provide a shim for (e.g. querystring, url).\\n    // For now, we fail semi-silently, but in the future this should be a\\n    // compilation error.\\n    throw new Error(`Failed to load external module ${id}: ${err}`)\\n  }\\n\\n  if (!esm || raw.__esModule) {\\n    return raw\\n  }\\n\\n  return interopEsm(raw, createNS(raw), true)\\n}\\n\\nexternalRequire.resolve = (\\n  id: string,\\n  options?: {\\n    paths?: string[]\\n  }\\n) => {\\n  return require.resolve(id, options)\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,6DAA6D;AAC7D,sDAAsD;AACtD,qGAAqG;AAErG,eAAe,eAAe,EAAuB;IACnD,IAAI;IACJ,IAAI;QACF,MAAM,MAAM,MAAM,CAAC;IACrB,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,OAAO,IAAI,UAAU,IAAI,IAAI,OAAO,IAAI,aAAa,IAAI,OAAO,EAAE;QACpE,OAAO,WAAW,IAAI,OAAO,EAAE,SAAS,MAAM;IAChD;IAEA,OAAO;AACT;AAEA,SAAS,gBACP,EAAY,EACZ,KAAgB,EAChB,MAAe,KAAK;IAEpB,IAAI;IACJ,IAAI;QACF,MAAM;IACR,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,CAAC,OAAO,IAAI,UAAU,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO,WAAW,KAAK,SAAS,MAAM;AACxC;AAEA,gBAAgB,OAAO,GAAG,CACxB,IACA;IAIA,OAAO,QAAQ,OAAO,CAAC,IAAI;AAC7B\",\"ignoreList\":[0]}},\n     {\"offset\": {\"line\": 406, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/node-externals-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\ndeclare var RUNTIME_PUBLIC_PATH: string\\ndeclare var RELATIVE_ROOT_PATH: string\\ndeclare var ASSET_PREFIX: string\\n\\nconst path = require('path')\\n\\nconst relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, '.')\\n// Compute the relative path to the `distDir`.\\nconst relativePathToDistRoot = path.join(\\n  relativePathToRuntimeRoot,\\n  RELATIVE_ROOT_PATH\\n)\\nconst RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot)\\n// Compute the absolute path to the root, by stripping distDir from the absolute path to this file.\\nconst ABSOLUTE_ROOT = path.resolve(__filename, relativePathToDistRoot)\\n\\n/**\\n * Returns an absolute path to the given module path.\\n * Module path should be relative, either path to a file or a directory.\\n *\\n * This fn allows to calculate an absolute path for some global static values, such as\\n * `__dirname` or `import.meta.url` that Turbopack will not embeds in compile time.\\n * See ImportMetaBinding::code_generation for the usage.\\n */\\nfunction resolveAbsolutePath(modulePath?: string): string {\\n  if (modulePath) {\\n    return path.join(ABSOLUTE_ROOT, modulePath)\\n  }\\n  return ABSOLUTE_ROOT\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAMpD,MAAM,OAAO,QAAQ;AAErB,MAAM,4BAA4B,KAAK,QAAQ,CAAC,qBAAqB;AACrE,8CAA8C;AAC9C,MAAM,yBAAyB,KAAK,IAAI,CACtC,2BACA;AAEF,MAAM,eAAe,KAAK,OAAO,CAAC,YAAY;AAC9C,mGAAmG;AACnG,MAAM,gBAAgB,KAAK,OAAO,CAAC,YAAY;AAE/C;;;;;;;CAOC,GACD,SAAS,oBAAoB,UAAmB;IAC9C,IAAI,YAAY;QACd,OAAO,KAAK,IAAI,CAAC,eAAe;IAClC;IACA,OAAO;AACT\",\"ignoreList\":[0]}},\n     {\"offset\": {\"line\": 426, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/node-wasm-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n\\nfunction readWebAssemblyAsResponse(path: string) {\\n  const { createReadStream } = require('fs') as typeof import('fs')\\n  const { Readable } = require('stream') as typeof import('stream')\\n\\n  const stream = createReadStream(path)\\n\\n  // @ts-ignore unfortunately there's a slight type mismatch with the stream.\\n  return new Response(Readable.toWeb(stream), {\\n    headers: {\\n      'content-type': 'application/wasm',\\n    },\\n  })\\n}\\n\\nasync function compileWebAssemblyFromPath(\\n  path: string\\n): Promise<WebAssembly.Module> {\\n  const response = readWebAssemblyAsResponse(path)\\n\\n  return await WebAssembly.compileStreaming(response)\\n}\\n\\nasync function instantiateWebAssemblyFromPath(\\n  path: string,\\n  importsObj: WebAssembly.Imports\\n): Promise<Exports> {\\n  const response = readWebAssemblyAsResponse(path)\\n\\n  const { instance } = await WebAssembly.instantiateStreaming(\\n    response,\\n    importsObj\\n  )\\n\\n  return instance.exports\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,SAAS,0BAA0B,IAAY;IAC7C,MAAM,EAAE,gBAAgB,EAAE,GAAG,QAAQ;IACrC,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ;IAE7B,MAAM,SAAS,iBAAiB;IAEhC,2EAA2E;IAC3E,OAAO,IAAI,SAAS,SAAS,KAAK,CAAC,SAAS;QAC1C,SAAS;YACP,gBAAgB;QAClB;IACF;AACF;AAEA,eAAe,2BACb,IAAY;IAEZ,MAAM,WAAW,0BAA0B;IAE3C,OAAO,MAAM,YAAY,gBAAgB,CAAC;AAC5C;AAEA,eAAe,+BACb,IAAY,EACZ,UAA+B;IAE/B,MAAM,WAAW,0BAA0B;IAE3C,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,YAAY,oBAAoB,CACzD,UACA;IAGF,OAAO,SAAS,OAAO;AACzB\",\"ignoreList\":[0]}},\n-    {\"offset\": {\"line\": 447, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/nodejs/runtime.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/base-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-wasm-utils.ts\\\" />\\n\\nenum SourceType {\\n  /**\\n   * The module was instantiated because it was included in an evaluated chunk's\\n   * runtime.\\n   */\\n  Runtime = 0,\\n  /**\\n   * The module was instantiated because a parent module imported it.\\n   */\\n  Parent = 1,\\n}\\n\\ntype SourceInfo =\\n  | {\\n      type: SourceType.Runtime\\n      chunkPath: ChunkPath\\n    }\\n  | {\\n      type: SourceType.Parent\\n      parentId: ModuleId\\n    }\\n\\nprocess.env.TURBOPACK = '1'\\n\\nfunction stringifySourceInfo(source: SourceInfo): string {\\n  switch (source.type) {\\n    case SourceType.Runtime:\\n      return `runtime for chunk ${source.chunkPath}`\\n    case SourceType.Parent:\\n      return `parent module ${source.parentId}`\\n    default:\\n      invariant(source, (source) => `Unknown source type: ${source?.type}`)\\n  }\\n}\\n\\ntype ExternalRequire = (\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm?: boolean\\n) => Exports | EsmNamespaceObject\\ntype ExternalImport = (id: ModuleId) => Promise<Exports | EsmNamespaceObject>\\n\\ninterface TurbopackNodeBuildContext extends TurbopackBaseContext<Module> {\\n  R: ResolvePathFromModule\\n  x: ExternalRequire\\n  y: ExternalImport\\n}\\n\\ntype ModuleFactory = (\\n  this: Module['exports'],\\n  context: TurbopackNodeBuildContext\\n) => unknown\\n\\nconst url = require('url') as typeof import('url')\\nconst fs = require('fs/promises') as typeof import('fs/promises')\\n\\nconst moduleFactories: ModuleFactories = Object.create(null)\\nconst moduleCache: ModuleCache<Module> = Object.create(null)\\n\\n/**\\n * Returns an absolute path to the given module's id.\\n */\\nfunction createResolvePathFromModule(\\n  resolver: (moduleId: string) => Exports\\n): (moduleId: string) => string {\\n  return function resolvePathFromModule(moduleId: string): string {\\n    const exported = resolver(moduleId)\\n    const exportedPath = exported?.default ?? exported\\n    if (typeof exportedPath !== 'string') {\\n      return exported as any\\n    }\\n\\n    const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length)\\n    const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix)\\n\\n    return url.pathToFileURL(resolved).href\\n  }\\n}\\n\\nfunction loadChunk(chunkData: ChunkData, source?: SourceInfo): void {\\n  if (typeof chunkData === 'string') {\\n    return loadChunkPath(chunkData, source)\\n  } else {\\n    return loadChunkPath(chunkData.path, source)\\n  }\\n}\\n\\nconst loadedChunks = new Set<ChunkPath>()\\nconst unsupportedLoadChunk = Promise.resolve(undefined)\\nconst loadedChunk = Promise.resolve(undefined)\\nconst chunkCache = new Map<ChunkPath, Promise<any> | typeof loadedChunk>()\\n\\nfunction clearChunkCache() {\\n  chunkCache.clear()\\n}\\n\\nfunction loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return\\n  }\\n\\n  if (loadedChunks.has(chunkPath)) {\\n    return\\n  }\\n\\n  try {\\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n    const chunkModules: CompressedModuleFactories = require(resolved)\\n\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        if (Array.isArray(moduleFactory)) {\\n          let [moduleFactoryFn, otherIds] = moduleFactory\\n          moduleFactories[moduleId] = moduleFactoryFn\\n          for (const otherModuleId of otherIds) {\\n            moduleFactories[otherModuleId] = moduleFactoryFn\\n          }\\n        } else {\\n          moduleFactories[moduleId] = moduleFactory\\n        }\\n      }\\n    }\\n    loadedChunks.add(chunkPath)\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`\\n\\n    if (source) {\\n      errorMessage += ` from ${stringifySourceInfo(source)}`\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    })\\n  }\\n}\\n\\nasync function loadChunkAsyncUncached(\\n  source: SourceInfo,\\n  chunkPath: ChunkPath\\n): Promise<void> {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  try {\\n    const contents = await fs.readFile(resolved, 'utf-8')\\n\\n    const localRequire = (id: string) => {\\n      let resolvedId = require.resolve(id, { paths: [path.dirname(resolved)] })\\n      return require(resolvedId)\\n    }\\n    const module = {\\n      exports: {},\\n    }\\n    // TODO: Use vm.runInThisContext once our minimal supported Node.js version includes https://github.com/nodejs/node/pull/52153\\n    // eslint-disable-next-line no-eval -- Can't use vm.runInThisContext due to https://github.com/nodejs/node/issues/52102\\n    ;(0, eval)(\\n      '(function(module, exports, require, __dirname, __filename) {' +\\n        contents +\\n        '\\\\n})' +\\n        '\\\\n//# sourceURL=' +\\n        url.pathToFileURL(resolved)\\n    )(module, module.exports, localRequire, path.dirname(resolved), resolved)\\n\\n    const chunkModules: CompressedModuleFactories = module.exports\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        if (Array.isArray(moduleFactory)) {\\n          let [moduleFactoryFn, otherIds] = moduleFactory\\n          moduleFactories[moduleId] = moduleFactoryFn\\n          for (const otherModuleId of otherIds) {\\n            moduleFactories[otherModuleId] = moduleFactoryFn\\n          }\\n        } else {\\n          moduleFactories[moduleId] = moduleFactory\\n        }\\n      }\\n    }\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`\\n\\n    if (source) {\\n      errorMessage += ` from ${stringifySourceInfo(source)}`\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    })\\n  }\\n}\\n\\nfunction loadChunkAsync(\\n  source: SourceInfo,\\n  chunkData: ChunkData\\n): Promise<any> {\\n  const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return unsupportedLoadChunk\\n  }\\n\\n  let entry = chunkCache.get(chunkPath)\\n  if (entry === undefined) {\\n    const resolve = chunkCache.set.bind(chunkCache, chunkPath, loadedChunk)\\n    // A new Promise ensures callers that don't handle rejection will still trigger one unhandled rejection.\\n    // Handling the rejection will not trigger unhandled rejections.\\n    entry = loadChunkAsyncUncached(source, chunkPath).then(resolve)\\n    chunkCache.set(chunkPath, entry)\\n  }\\n  // TODO: Return an instrumented Promise that React can use instead of relying on referential equality.\\n  return entry\\n}\\n\\nfunction loadChunkAsyncByUrl(source: SourceInfo, chunkUrl: string) {\\n  const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath\\n  return loadChunkAsync(source, path)\\n}\\n\\nfunction loadWebAssembly(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module,\\n  imports: WebAssembly.Imports\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return instantiateWebAssemblyFromPath(resolved, imports)\\n}\\n\\nfunction loadWebAssemblyModule(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return compileWebAssemblyFromPath(resolved)\\n}\\n\\nfunction getWorkerBlobURL(_chunks: ChunkPath[]): string {\\n  throw new Error('Worker blobs are not implemented yet for Node.js')\\n}\\n\\nfunction instantiateModule(id: ModuleId, source: SourceInfo): Module {\\n  const moduleFactory = moduleFactories[id]\\n  if (typeof moduleFactory !== 'function') {\\n    // This can happen if modules incorrectly handle HMR disposes/updates,\\n    // e.g. when they keep a `setTimeout` around which still executes old code\\n    // and contains e.g. a `require(\\\"something\\\")` call.\\n    let instantiationReason\\n    switch (source.type) {\\n      case SourceType.Runtime:\\n        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`\\n        break\\n      case SourceType.Parent:\\n        instantiationReason = `because it was required from module ${source.parentId}`\\n        break\\n      default:\\n        invariant(source, (source) => `Unknown source type: ${source?.type}`)\\n    }\\n    throw new Error(\\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\\n    )\\n  }\\n\\n  const module: Module = {\\n    exports: {},\\n    error: undefined,\\n    loaded: false,\\n    id,\\n    namespaceObject: undefined,\\n  }\\n  moduleCache[id] = module\\n\\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\\n  try {\\n    const r = commonJsRequire.bind(null, module)\\n    moduleFactory.call(module.exports, {\\n      a: asyncModule.bind(null, module),\\n      e: module.exports,\\n      r,\\n      t: runtimeRequire,\\n      x: externalRequire,\\n      y: externalImport,\\n      f: moduleContext,\\n      i: esmImport.bind(null, module),\\n      s: esmExport.bind(null, module, module.exports, moduleCache),\\n      j: dynamicExport.bind(null, module, module.exports, moduleCache),\\n      v: exportValue.bind(null, module, moduleCache),\\n      n: exportNamespace.bind(null, module, moduleCache),\\n      m: module,\\n      c: moduleCache,\\n      M: moduleFactories,\\n      l: loadChunkAsync.bind(null, { type: SourceType.Parent, parentId: id }),\\n      L: loadChunkAsyncByUrl.bind(null, {\\n        type: SourceType.Parent,\\n        parentId: id,\\n      }),\\n      C: clearChunkCache,\\n      w: loadWebAssembly,\\n      u: loadWebAssemblyModule,\\n      P: resolveAbsolutePath,\\n      U: relativeURL,\\n      R: createResolvePathFromModule(r),\\n      b: getWorkerBlobURL,\\n      z: requireStub,\\n    })\\n  } catch (error) {\\n    module.error = error as any\\n    throw error\\n  }\\n\\n  module.loaded = true\\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\\n    interopEsm(module.exports, module.namespaceObject)\\n  }\\n\\n  return module\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it if it is not cached.\\n */\\n// @ts-ignore\\nfunction getOrInstantiateModuleFromParent(\\n  id: ModuleId,\\n  sourceModule: Module\\n): Module {\\n  const module = moduleCache[id]\\n\\n  if (module) {\\n    return module\\n  }\\n\\n  return instantiateModule(id, {\\n    type: SourceType.Parent,\\n    parentId: sourceModule.id,\\n  })\\n}\\n\\n/**\\n * Instantiates a runtime module.\\n */\\nfunction instantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath })\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\\n */\\n// @ts-ignore TypeScript doesn't separate this module space from the browser runtime\\nfunction getOrInstantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  const module = moduleCache[moduleId]\\n  if (module) {\\n    if (module.error) {\\n      throw module.error\\n    }\\n    return module\\n  }\\n\\n  return instantiateRuntimeModule(moduleId, chunkPath)\\n}\\n\\nconst regexJsUrl = /\\\\.js(?:\\\\?[^#]*)?(?:#.*)?$/\\n/**\\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\\n */\\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\\n  return regexJsUrl.test(chunkUrlOrPath)\\n}\\n\\nmodule.exports = {\\n  getOrInstantiateRuntimeModule,\\n  loadChunk,\\n}\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}}]\n+    {\"offset\": {\"line\": 447, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/nodejs/runtime.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/base-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-wasm-utils.ts\\\" />\\n\\nenum SourceType {\\n  /**\\n   * The module was instantiated because it was included in an evaluated chunk's\\n   * runtime.\\n   */\\n  Runtime = 0,\\n  /**\\n   * The module was instantiated because a parent module imported it.\\n   */\\n  Parent = 1,\\n}\\n\\ntype SourceInfo =\\n  | {\\n      type: SourceType.Runtime\\n      chunkPath: ChunkPath\\n    }\\n  | {\\n      type: SourceType.Parent\\n      parentId: ModuleId\\n    }\\n\\nprocess.env.TURBOPACK = '1'\\n\\nfunction stringifySourceInfo(source: SourceInfo): string {\\n  switch (source.type) {\\n    case SourceType.Runtime:\\n      return `runtime for chunk ${source.chunkPath}`\\n    case SourceType.Parent:\\n      return `parent module ${source.parentId}`\\n    default:\\n      invariant(source, (source) => `Unknown source type: ${source?.type}`)\\n  }\\n}\\n\\ntype ExternalRequire = (\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm?: boolean\\n) => Exports | EsmNamespaceObject\\ntype ExternalImport = (id: ModuleId) => Promise<Exports | EsmNamespaceObject>\\n\\ninterface TurbopackNodeBuildContext extends TurbopackBaseContext<Module> {\\n  R: ResolvePathFromModule\\n  x: ExternalRequire\\n  y: ExternalImport\\n}\\n\\ntype ModuleFactory = (\\n  this: Module['exports'],\\n  context: TurbopackNodeBuildContext\\n) => unknown\\n\\nconst url = require('url') as typeof import('url')\\nconst fs = require('fs/promises') as typeof import('fs/promises')\\n\\nconst moduleFactories: ModuleFactories = Object.create(null)\\nconst moduleCache: ModuleCache<Module> = Object.create(null)\\n\\n/**\\n * Returns an absolute path to the given module's id.\\n */\\nfunction createResolvePathFromModule(\\n  resolver: (moduleId: string) => Exports\\n): (moduleId: string) => string {\\n  return function resolvePathFromModule(moduleId: string): string {\\n    const exported = resolver(moduleId)\\n    const exportedPath = exported?.default ?? exported\\n    if (typeof exportedPath !== 'string') {\\n      return exported as any\\n    }\\n\\n    const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length)\\n    const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix)\\n\\n    return url.pathToFileURL(resolved).href\\n  }\\n}\\n\\nfunction loadChunk(chunkData: ChunkData, source?: SourceInfo): void {\\n  if (typeof chunkData === 'string') {\\n    loadChunkPath(chunkData, source)\\n  } else {\\n    loadChunkPath(chunkData.path, source)\\n  }\\n}\\n\\nconst loadedChunks = new Set<ChunkPath>()\\nconst unsupportedLoadChunk = Promise.resolve(undefined)\\nconst loadedChunk: Promise<void> = Promise.resolve(undefined)\\nconst chunkCache = new Map<ChunkPath, Promise<void>>()\\n\\nfunction clearChunkCache() {\\n  chunkCache.clear()\\n}\\n\\nfunction loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return\\n  }\\n\\n  if (loadedChunks.has(chunkPath)) {\\n    return\\n  }\\n\\n  try {\\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n    const chunkModules: CompressedModuleFactories = require(resolved)\\n\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        if (Array.isArray(moduleFactory)) {\\n          const [moduleFactoryFn, otherIds] = moduleFactory\\n          moduleFactories[moduleId] = moduleFactoryFn\\n          for (const otherModuleId of otherIds) {\\n            moduleFactories[otherModuleId] = moduleFactoryFn\\n          }\\n        } else {\\n          moduleFactories[moduleId] = moduleFactory\\n        }\\n      }\\n    }\\n    loadedChunks.add(chunkPath)\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`\\n\\n    if (source) {\\n      errorMessage += ` from ${stringifySourceInfo(source)}`\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    })\\n  }\\n}\\n\\nfunction loadChunkUncached(chunkPath: ChunkPath) {\\n  // resolve to an absolute path to simplify `require` handling\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  // TODO: consider switching to `import()` to enable concurrent chunk loading and async file io\\n  // However this is incompatible with hot reloading (since `import` doesn't use the require cache)\\n  const chunkModules: CompressedModuleFactories = require(resolved)\\n  for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n    if (!moduleFactories[moduleId]) {\\n      if (Array.isArray(moduleFactory)) {\\n        const [moduleFactoryFn, otherIds] = moduleFactory\\n        moduleFactories[moduleId] = moduleFactoryFn\\n        for (const otherModuleId of otherIds) {\\n          moduleFactories[otherModuleId] = moduleFactoryFn\\n        }\\n      } else {\\n        moduleFactories[moduleId] = moduleFactory\\n      }\\n    }\\n  }\\n}\\n\\nfunction loadChunkAsync(\\n  source: SourceInfo,\\n  chunkData: ChunkData\\n): Promise<void> {\\n  const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return unsupportedLoadChunk\\n  }\\n\\n  let entry = chunkCache.get(chunkPath)\\n  if (entry === undefined) {\\n    try {\\n      // Load the chunk synchronously\\n      loadChunkUncached(chunkPath)\\n      entry = loadedChunk\\n    } catch (e) {\\n      let errorMessage = `Failed to load chunk ${chunkPath}`\\n      if (source) {\\n        errorMessage += ` from ${stringifySourceInfo(source)}`\\n      }\\n\\n      // Cache the failure promise, future requests will also get this same rejection\\n      entry = Promise.reject(\\n        new Error(errorMessage, {\\n          cause: e,\\n        })\\n      )\\n    }\\n    chunkCache.set(chunkPath, entry)\\n  }\\n  // TODO: Return an instrumented Promise that React can use instead of relying on referential equality.\\n  return entry\\n}\\n\\nfunction loadChunkAsyncByUrl(source: SourceInfo, chunkUrl: string) {\\n  const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath\\n  return loadChunkAsync(source, path)\\n}\\n\\nfunction loadWebAssembly(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module,\\n  imports: WebAssembly.Imports\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return instantiateWebAssemblyFromPath(resolved, imports)\\n}\\n\\nfunction loadWebAssemblyModule(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return compileWebAssemblyFromPath(resolved)\\n}\\n\\nfunction getWorkerBlobURL(_chunks: ChunkPath[]): string {\\n  throw new Error('Worker blobs are not implemented yet for Node.js')\\n}\\n\\nfunction instantiateModule(id: ModuleId, source: SourceInfo): Module {\\n  const moduleFactory = moduleFactories[id]\\n  if (typeof moduleFactory !== 'function') {\\n    // This can happen if modules incorrectly handle HMR disposes/updates,\\n    // e.g. when they keep a `setTimeout` around which still executes old code\\n    // and contains e.g. a `require(\\\"something\\\")` call.\\n    let instantiationReason\\n    switch (source.type) {\\n      case SourceType.Runtime:\\n        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`\\n        break\\n      case SourceType.Parent:\\n        instantiationReason = `because it was required from module ${source.parentId}`\\n        break\\n      default:\\n        invariant(source, (source) => `Unknown source type: ${source?.type}`)\\n    }\\n    throw new Error(\\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\\n    )\\n  }\\n\\n  const module: Module = {\\n    exports: {},\\n    error: undefined,\\n    loaded: false,\\n    id,\\n    namespaceObject: undefined,\\n  }\\n  moduleCache[id] = module\\n\\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\\n  try {\\n    const r = commonJsRequire.bind(null, module)\\n    moduleFactory.call(module.exports, {\\n      a: asyncModule.bind(null, module),\\n      e: module.exports,\\n      r,\\n      t: runtimeRequire,\\n      x: externalRequire,\\n      y: externalImport,\\n      f: moduleContext,\\n      i: esmImport.bind(null, module),\\n      s: esmExport.bind(null, module, module.exports, moduleCache),\\n      j: dynamicExport.bind(null, module, module.exports, moduleCache),\\n      v: exportValue.bind(null, module, moduleCache),\\n      n: exportNamespace.bind(null, module, moduleCache),\\n      m: module,\\n      c: moduleCache,\\n      M: moduleFactories,\\n      l: loadChunkAsync.bind(null, { type: SourceType.Parent, parentId: id }),\\n      L: loadChunkAsyncByUrl.bind(null, {\\n        type: SourceType.Parent,\\n        parentId: id,\\n      }),\\n      C: clearChunkCache,\\n      w: loadWebAssembly,\\n      u: loadWebAssemblyModule,\\n      P: resolveAbsolutePath,\\n      U: relativeURL,\\n      R: createResolvePathFromModule(r),\\n      b: getWorkerBlobURL,\\n      z: requireStub,\\n    })\\n  } catch (error) {\\n    module.error = error as any\\n    throw error\\n  }\\n\\n  module.loaded = true\\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\\n    interopEsm(module.exports, module.namespaceObject)\\n  }\\n\\n  return module\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it if it is not cached.\\n */\\n// @ts-ignore\\nfunction getOrInstantiateModuleFromParent(\\n  id: ModuleId,\\n  sourceModule: Module\\n): Module {\\n  const module = moduleCache[id]\\n\\n  if (module) {\\n    return module\\n  }\\n\\n  return instantiateModule(id, {\\n    type: SourceType.Parent,\\n    parentId: sourceModule.id,\\n  })\\n}\\n\\n/**\\n * Instantiates a runtime module.\\n */\\nfunction instantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath })\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\\n */\\n// @ts-ignore TypeScript doesn't separate this module space from the browser runtime\\nfunction getOrInstantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  const module = moduleCache[moduleId]\\n  if (module) {\\n    if (module.error) {\\n      throw module.error\\n    }\\n    return module\\n  }\\n\\n  return instantiateRuntimeModule(moduleId, chunkPath)\\n}\\n\\nconst regexJsUrl = /\\\\.js(?:\\\\?[^#]*)?(?:#.*)?$/\\n/**\\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\\n */\\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\\n  return regexJsUrl.test(chunkUrlOrPath)\\n}\\n\\nmodule.exports = {\\n  getOrInstantiateRuntimeModule,\\n  loadChunk,\\n}\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}}]\n }\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 224,
        "additions": 100,
        "deletions": 124
    }
}