{
    "author": "sokra",
    "message": "Turbopack: Split Dirty into Dirtyness and CleanInSession (#86070)\n\n### What?\n\nSplit Dirty into Dirtyness and CleanInSession\n\nThis is in preparation to make CleanInSession transient and only for the current session.",
    "sha": "6923b26ab0378454b67f195d32fc39d930dcb45f",
    "files": [
        {
            "sha": "8ba9726704ba9ef9eb4927d24bfbd144a5eb1d88",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 47,
            "deletions": 46,
            "changes": 93,
            "blob_url": "https://github.com/vercel/next.js/blob/6923b26ab0378454b67f195d32fc39d930dcb45f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6923b26ab0378454b67f195d32fc39d930dcb45f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=6923b26ab0378454b67f195d32fc39d930dcb45f",
            "patch": "@@ -61,7 +61,7 @@ use crate::{\n     backing_storage::BackingStorage,\n     data::{\n         ActivenessState, AggregationNumber, CachedDataItem, CachedDataItemKey, CachedDataItemType,\n-        CachedDataItemValueRef, CellRef, CollectibleRef, CollectiblesRef, DirtyState,\n+        CachedDataItemValueRef, CellRef, CollectibleRef, CollectiblesRef, Dirtyness,\n         InProgressCellState, InProgressState, InProgressStateInner, OutputValue, RootType,\n     },\n     utils::{\n@@ -567,8 +567,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 }\n             }\n \n-            let is_dirty =\n-                get!(task, Dirty).map_or(false, |dirty_state| dirty_state.get(self.session_id));\n+            let is_dirty = task.is_dirty(self.session_id);\n \n             // Check the dirty count of the root node\n             let dirty_tasks = get!(task, AggregatedDirtyContainerCount)\n@@ -624,8 +623,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                             visited: &mut FxHashSet<TaskId>,\n                         ) -> String {\n                             let task = ctx.task(task_id, TaskDataCategory::Data);\n-                            let is_dirty = get!(task, Dirty)\n-                                .map_or(false, |dirty_state| dirty_state.get(ctx.session_id()));\n+                            let is_dirty = task.is_dirty(ctx.session_id());\n                             let in_progress =\n                                 get!(task, InProgress).map_or(\"not in progress\", |p| match p {\n                                     InProgressState::InProgress(_) => \"in progress\",\n@@ -2381,57 +2379,60 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         ));\n \n         // Update the dirty state\n-        let old_dirty_state = get!(task, Dirty).copied();\n+        let old_dirtyness = task.dirtyness_and_session();\n \n-        let new_dirty_state = if session_dependent {\n-            Some(DirtyState {\n-                clean_in_session: Some(self.session_id),\n-            })\n+        let new_dirtyness = if session_dependent {\n+            Some((Dirtyness::SessionDependent, Some(self.session_id)))\n         } else {\n             None\n         };\n \n-        let dirty_changed = old_dirty_state != new_dirty_state;\n+        let dirty_changed = old_dirtyness != new_dirtyness;\n         let data_update = if dirty_changed {\n-            if let Some(new_dirty_state) = new_dirty_state {\n-                task.insert(CachedDataItem::Dirty {\n-                    value: new_dirty_state,\n-                });\n-            } else {\n+            if let Some((value, _)) = new_dirtyness {\n+                task.insert(CachedDataItem::Dirty { value });\n+            } else if old_dirtyness.is_some() {\n                 task.remove(&CachedDataItemKey::Dirty {});\n             }\n+            if let Some(session_id) = new_dirtyness.and_then(|t| t.1) {\n+                task.insert(CachedDataItem::CleanInSession { value: session_id });\n+            } else if old_dirtyness.is_some_and(|t| t.1.is_some()) {\n+                task.remove(&CachedDataItemKey::CleanInSession {});\n+            }\n \n-            if old_dirty_state.is_some() || new_dirty_state.is_some() {\n-                let mut dirty_containers = get!(task, AggregatedDirtyContainerCount)\n-                    .cloned()\n-                    .unwrap_or_default();\n-                if let Some(old_dirty_state) = old_dirty_state {\n-                    dirty_containers.update_with_dirty_state(&old_dirty_state);\n+            let mut dirty_containers = get!(task, AggregatedDirtyContainerCount)\n+                .cloned()\n+                .unwrap_or_default();\n+            if let Some((old_dirtyness, old_clean_in_session)) = old_dirtyness {\n+                dirty_containers\n+                    .update_with_dirtyness_and_session(old_dirtyness, old_clean_in_session);\n+            }\n+            let aggregated_update = match (old_dirtyness, new_dirtyness) {\n+                (None, None) => unreachable!(),\n+                (Some(old), None) => {\n+                    dirty_containers.undo_update_with_dirtyness_and_session(old.0, old.1)\n                 }\n-                let aggregated_update = match (old_dirty_state, new_dirty_state) {\n-                    (None, None) => unreachable!(),\n-                    (Some(old), None) => dirty_containers.undo_update_with_dirty_state(&old),\n-                    (None, Some(new)) => dirty_containers.update_with_dirty_state(&new),\n-                    (Some(old), Some(new)) => dirty_containers.replace_dirty_state(&old, &new),\n-                };\n-                if !aggregated_update.is_zero() {\n-                    if aggregated_update.get(self.session_id) < 0\n-                        && let Some(activeness_state) = get_mut!(task, Activeness)\n-                    {\n-                        activeness_state.all_clean_event.notify(usize::MAX);\n-                        activeness_state.unset_active_until_clean();\n-                        if activeness_state.is_empty() {\n-                            task.remove(&CachedDataItemKey::Activeness {});\n-                        }\n+                (None, Some(new)) => {\n+                    dirty_containers.update_with_dirtyness_and_session(new.0, new.1)\n+                }\n+                (Some(old), Some(new)) => {\n+                    dirty_containers.replace_dirtyness_and_session(old.0, old.1, new.0, new.1)\n+                }\n+            };\n+            if !aggregated_update.is_zero() {\n+                if aggregated_update.get(self.session_id) < 0\n+                    && let Some(activeness_state) = get_mut!(task, Activeness)\n+                {\n+                    activeness_state.all_clean_event.notify(usize::MAX);\n+                    activeness_state.unset_active_until_clean();\n+                    if activeness_state.is_empty() {\n+                        task.remove(&CachedDataItemKey::Activeness {});\n                     }\n-                    AggregationUpdateJob::data_update(\n-                        &mut task,\n-                        AggregatedDataUpdate::new()\n-                            .dirty_container_update(task_id, aggregated_update),\n-                    )\n-                } else {\n-                    None\n                 }\n+                AggregationUpdateJob::data_update(\n+                    &mut task,\n+                    AggregatedDataUpdate::new().dirty_container_update(task_id, aggregated_update),\n+                )\n             } else {\n                 None\n             }\n@@ -2900,7 +2901,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         let mut ctx = self.execute_context(turbo_tasks);\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n-        let is_dirty = get!(task, Dirty).map_or(false, |dirty| dirty.get(self.session_id));\n+        let is_dirty = task.is_dirty(self.session_id);\n         let has_dirty_containers = get!(task, AggregatedDirtyContainerCount)\n             .map_or(false, |dirty_containers| {\n                 dirty_containers.get(self.session_id) > 0\n@@ -2993,7 +2994,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     }\n                 }\n \n-                let is_dirty = get!(task, Dirty).is_some_and(|dirty| dirty.get(self.session_id));\n+                let is_dirty = task.is_dirty(self.session_id);\n                 let has_dirty_container = get!(task, AggregatedDirtyContainerCount)\n                     .is_some_and(|count| count.get(self.session_id) > 0);\n                 let should_be_in_upper = is_dirty || has_dirty_container;"
        },
        {
            "sha": "c7fc49b3c100e53d728154a6f931ca526f14fd2e",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/aggregation_update.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/6923b26ab0378454b67f195d32fc39d930dcb45f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6923b26ab0378454b67f195d32fc39d930dcb45f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs?ref=6923b26ab0378454b67f195d32fc39d930dcb45f",
            "patch": "@@ -249,8 +249,8 @@ impl AggregatedDataUpdate {\n                 collectibles_update.push((collectible, 1));\n             }\n         }\n-        if let Some(dirty) = get!(task, Dirty) {\n-            dirty_container_count.update_with_dirty_state(dirty);\n+        if let Some((dirtyness, clean_in_session)) = task.dirtyness_and_session() {\n+            dirty_container_count.update_with_dirtyness_and_session(dirtyness, clean_in_session);\n         }\n \n         let mut result = Self::new().collectibles_update(collectibles_update);\n@@ -323,18 +323,18 @@ impl AggregatedDataUpdate {\n             );\n \n             if !aggregated_update.is_zero() {\n-                let dirty_state = get!(task, Dirty).copied();\n+                let dirtyness_and_session = task.dirtyness_and_session();\n                 let task_id = task.id();\n                 update!(task, AggregatedDirtyContainerCount, |old: Option<\n                     DirtyContainerCount,\n                 >| {\n                     let mut new = old.unwrap_or_default();\n-                    if let Some(dirty_state) = dirty_state {\n-                        new.update_with_dirty_state(&dirty_state);\n+                    if let Some((dirtyness, clean_in_session)) = dirtyness_and_session {\n+                        new.update_with_dirtyness_and_session(dirtyness, clean_in_session);\n                     }\n                     let aggregated_update = new.update_count(&aggregated_update);\n-                    if let Some(dirty_state) = dirty_state {\n-                        new.undo_update_with_dirty_state(&dirty_state);\n+                    if let Some((dirtyness, clean_in_session)) = dirtyness_and_session {\n+                        new.undo_update_with_dirtyness_and_session(dirtyness, clean_in_session);\n                     }\n                     if !aggregated_update.is_zero() {\n                         result.dirty_container_update = Some((task_id, aggregated_update));\n@@ -1209,7 +1209,7 @@ impl AggregationUpdateQueue {\n     ) {\n         let session_id = ctx.session_id();\n         // Task need to be scheduled if it's dirty or doesn't have output\n-        let dirty = get!(task, Dirty).map_or(false, |d| d.get(session_id));\n+        let dirty = task.is_dirty(session_id);\n         let should_schedule = if dirty {\n             Some(TaskExecutionReason::ActivateDirty)\n         } else if !task.has_key(&CachedDataItemKey::Output {}) {"
        },
        {
            "sha": "1e7961e9c44a5d80c9e382dd72ff501017904242",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/invalidate.rs",
            "status": "modified",
            "additions": 29,
            "deletions": 20,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/6923b26ab0378454b67f195d32fc39d930dcb45f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6923b26ab0378454b67f195d32fc39d930dcb45f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs?ref=6923b26ab0378454b67f195d32fc39d930dcb45f",
            "patch": "@@ -11,10 +11,10 @@ use crate::{\n                 AggregatedDataUpdate, AggregationUpdateJob, AggregationUpdateQueue,\n             },\n         },\n-        storage::{get, get_mut},\n+        storage::{get, get_mut, remove},\n     },\n     data::{\n-        CachedDataItem, CachedDataItemKey, CachedDataItemValue, DirtyState, InProgressState,\n+        CachedDataItem, CachedDataItemKey, CachedDataItemValue, Dirtyness, InProgressState,\n         InProgressStateInner,\n     },\n };\n@@ -232,15 +232,11 @@ pub fn make_task_dirty_internal(\n         *stale = true;\n     }\n     let old = task.insert(CachedDataItem::Dirty {\n-        value: DirtyState {\n-            clean_in_session: None,\n-        },\n+        value: Dirtyness::Dirty,\n     });\n     let mut dirty_container = match old {\n         Some(CachedDataItemValue::Dirty {\n-            value: DirtyState {\n-                clean_in_session: None,\n-            },\n+            value: Dirtyness::Dirty,\n         }) => {\n             #[cfg(feature = \"trace_task_dirty\")]\n             let _span = tracing::trace_span!(\n@@ -254,16 +250,30 @@ pub fn make_task_dirty_internal(\n             return;\n         }\n         Some(CachedDataItemValue::Dirty {\n-            value: DirtyState {\n-                clean_in_session: Some(session_id),\n-            },\n+            value: Dirtyness::SessionDependent,\n         }) => {\n-            // Got dirty in that one session only\n-            let mut dirty_container = get!(task, AggregatedDirtyContainerCount)\n-                .cloned()\n-                .unwrap_or_default();\n-            dirty_container.update_session_dependent(session_id, 1);\n-            dirty_container\n+            let old = remove!(task, CleanInSession);\n+            match old {\n+                None => {\n+                    #[cfg(feature = \"trace_task_dirty\")]\n+                    let _span = tracing::trace_span!(\n+                        \"session-dependent task already dirty\",\n+                        name = ctx.get_task_description(task_id),\n+                        cause = %TaskDirtyCauseInContext::new(&cause, ctx)\n+                    )\n+                    .entered();\n+                    // already dirty\n+                    return;\n+                }\n+                Some(session_id) => {\n+                    // Got dirty in that one session only\n+                    let mut dirty_container = get!(task, AggregatedDirtyContainerCount)\n+                        .cloned()\n+                        .unwrap_or_default();\n+                    dirty_container.update_session_dependent(session_id, 1);\n+                    dirty_container\n+                }\n+            }\n         }\n         None => {\n             // Get dirty for all sessions\n@@ -284,9 +294,8 @@ pub fn make_task_dirty_internal(\n     .entered();\n \n     let should_schedule = {\n-        let aggregated_update = dirty_container.update_with_dirty_state(&DirtyState {\n-            clean_in_session: None,\n-        });\n+        let aggregated_update =\n+            dirty_container.update_with_dirtyness_and_session(Dirtyness::Dirty, None);\n         if !aggregated_update.is_zero() {\n             queue.extend(AggregationUpdateJob::data_update(\n                 &mut task,"
        },
        {
            "sha": "443ee182e5df2f067b3bf697868711ce7966fb37",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 2,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/6923b26ab0378454b67f195d32fc39d930dcb45f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6923b26ab0378454b67f195d32fc39d930dcb45f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=6923b26ab0378454b67f195d32fc39d930dcb45f",
            "patch": "@@ -20,12 +20,12 @@ use crate::{\n     backend::{\n         OperationGuard, TaskDataCategory, TransientTask, TurboTasksBackend, TurboTasksBackendInner,\n         TurboTasksBackendJob,\n-        storage::{SpecificTaskDataCategory, StorageWriteGuard, iter_many},\n+        storage::{SpecificTaskDataCategory, StorageWriteGuard, get, iter_many},\n     },\n     backing_storage::BackingStorage,\n     data::{\n         CachedDataItem, CachedDataItemKey, CachedDataItemType, CachedDataItemValue,\n-        CachedDataItemValueRef, CachedDataItemValueRefMut,\n+        CachedDataItemValueRef, CachedDataItemValueRefMut, Dirtyness,\n     },\n };\n \n@@ -415,6 +415,21 @@ pub trait TaskGuard: Debug {\n     fn invalidate_serialization(&mut self);\n     fn prefetch(&mut self) -> Option<FxIndexMap<TaskId, bool>>;\n     fn is_immutable(&self) -> bool;\n+    fn is_dirty(&self, session_id: SessionId) -> bool {\n+        get!(self, Dirty).is_some_and(|dirtyness| match dirtyness {\n+            Dirtyness::Dirty => true,\n+            Dirtyness::SessionDependent => get!(self, CleanInSession).copied() != Some(session_id),\n+        })\n+    }\n+    fn dirtyness_and_session(&self) -> Option<(Dirtyness, Option<SessionId>)> {\n+        match get!(self, Dirty)? {\n+            Dirtyness::Dirty => Some((Dirtyness::Dirty, None)),\n+            Dirtyness::SessionDependent => Some((\n+                Dirtyness::SessionDependent,\n+                get!(self, CleanInSession).copied(),\n+            )),\n+        }\n+    }\n }\n \n pub struct TaskGuardImpl<'a, B: BackingStorage> {"
        },
        {
            "sha": "2bdb13f41619cef495d43a126e1d5d454a04d4cd",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data.rs",
            "status": "modified",
            "additions": 61,
            "deletions": 51,
            "changes": 112,
            "blob_url": "https://github.com/vercel/next.js/blob/6923b26ab0378454b67f195d32fc39d930dcb45f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6923b26ab0378454b67f195d32fc39d930dcb45f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs?ref=6923b26ab0378454b67f195d32fc39d930dcb45f",
            "patch": "@@ -144,14 +144,9 @@ transient_traits!(ActivenessState);\n impl Eq for ActivenessState {}\n \n #[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]\n-pub struct DirtyState {\n-    pub clean_in_session: Option<SessionId>,\n-}\n-\n-impl DirtyState {\n-    pub fn get(&self, session: SessionId) -> bool {\n-        self.clean_in_session != Some(session)\n-    }\n+pub enum Dirtyness {\n+    Dirty,\n+    SessionDependent,\n }\n \n fn add_with_diff(v: &mut i32, u: i32) -> i32 {\n@@ -251,34 +246,47 @@ impl DirtyContainerCount {\n         diff\n     }\n \n-    /// Applies a dirty state to the count. Returns an aggregated count that represents the change.\n-    pub fn update_with_dirty_state(&mut self, dirty: &DirtyState) -> DirtyContainerCount {\n-        if let Some(clean_in_session) = dirty.clean_in_session {\n-            self.update_session_dependent(clean_in_session, 1)\n+    /// Applies a dirtyness to the count. Returns an aggregated count that represents the change.\n+    pub fn update_with_dirtyness_and_session(\n+        &mut self,\n+        dirtyness: Dirtyness,\n+        clean_in_session: Option<SessionId>,\n+    ) -> DirtyContainerCount {\n+        if let (Dirtyness::SessionDependent, Some(session_id)) = (dirtyness, clean_in_session) {\n+            self.update_session_dependent(session_id, 1)\n         } else {\n             self.update(1)\n         }\n     }\n \n-    /// Undoes the effect of a dirty state on the count. Returns an aggregated count that represents\n+    /// Undoes the effect of a dirtyness on the count. Returns an aggregated count that represents\n     /// the change.\n-    pub fn undo_update_with_dirty_state(&mut self, dirty: &DirtyState) -> DirtyContainerCount {\n-        if let Some(clean_in_session) = dirty.clean_in_session {\n-            self.update_session_dependent(clean_in_session, -1)\n+    pub fn undo_update_with_dirtyness_and_session(\n+        &mut self,\n+        dirtyness: Dirtyness,\n+        clean_in_session: Option<SessionId>,\n+    ) -> DirtyContainerCount {\n+        if let (Dirtyness::SessionDependent, Some(session_id)) = (dirtyness, clean_in_session) {\n+            self.update_session_dependent(session_id, -1)\n         } else {\n             self.update(-1)\n         }\n     }\n \n-    /// Replaces the old dirty state with the new one. Returns an aggregated count that represents\n+    /// Replaces the old dirtyness with the new one. Returns an aggregated count that represents\n     /// the change.\n-    pub fn replace_dirty_state(\n+    pub fn replace_dirtyness_and_session(\n         &mut self,\n-        old: &DirtyState,\n-        new: &DirtyState,\n+        old_dirtyness: Dirtyness,\n+        old_clean_in_session: Option<SessionId>,\n+        new_dirtyness: Dirtyness,\n+        new_clean_in_session: Option<SessionId>,\n     ) -> DirtyContainerCount {\n-        let mut diff = self.undo_update_with_dirty_state(old);\n-        diff.update_count(&self.update_with_dirty_state(new));\n+        let mut diff =\n+            self.undo_update_with_dirtyness_and_session(old_dirtyness, old_clean_in_session);\n+        diff.update_count(\n+            &self.update_with_dirtyness_and_session(new_dirtyness, new_clean_in_session),\n+        );\n         diff\n     }\n \n@@ -412,37 +420,33 @@ mod dirty_container_count_tests {\n     }\n \n     #[test]\n-    fn test_update_with_dirty_state() {\n+    fn test_update_with_dirtyness_and_session() {\n         let mut count = DirtyContainerCount::default();\n-        let dirty = DirtyState {\n-            clean_in_session: None,\n-        };\n-        let diff = count.update_with_dirty_state(&dirty);\n+        let diff = count.update_with_dirtyness_and_session(Dirtyness::Dirty, None);\n         assert!(!count.is_zero());\n         assert_eq!(count.get(SESSION_1), 1);\n         assert_eq!(diff.get(SESSION_1), 1);\n         assert_eq!(count.get(SESSION_2), 1);\n         assert_eq!(diff.get(SESSION_2), 1);\n \n-        let diff = count.undo_update_with_dirty_state(&dirty);\n+        let diff = count.undo_update_with_dirtyness_and_session(Dirtyness::Dirty, None);\n         assert!(count.is_zero());\n         assert_eq!(count.get(SESSION_1), 0);\n         assert_eq!(diff.get(SESSION_1), -1);\n         assert_eq!(count.get(SESSION_2), 0);\n         assert_eq!(diff.get(SESSION_2), -1);\n \n         let mut count = DirtyContainerCount::default();\n-        let dirty = DirtyState {\n-            clean_in_session: Some(SESSION_1),\n-        };\n-        let diff = count.update_with_dirty_state(&dirty);\n+        let diff =\n+            count.update_with_dirtyness_and_session(Dirtyness::SessionDependent, Some(SESSION_1));\n         assert!(!count.is_zero());\n         assert_eq!(count.get(SESSION_1), 0);\n         assert_eq!(diff.get(SESSION_1), 0);\n         assert_eq!(count.get(SESSION_2), 1);\n         assert_eq!(diff.get(SESSION_2), 1);\n \n-        let diff = count.undo_update_with_dirty_state(&dirty);\n+        let diff = count\n+            .undo_update_with_dirtyness_and_session(Dirtyness::SessionDependent, Some(SESSION_1));\n         assert!(count.is_zero());\n         assert_eq!(count.get(SESSION_1), 0);\n         assert_eq!(diff.get(SESSION_1), 0);\n@@ -451,31 +455,29 @@ mod dirty_container_count_tests {\n     }\n \n     #[test]\n-    fn test_replace_dirty_state() {\n+    fn test_replace_dirtyness_and_session() {\n         let mut count = DirtyContainerCount::default();\n-        let old = DirtyState {\n-            clean_in_session: None,\n-        };\n-        let new = DirtyState {\n-            clean_in_session: Some(SESSION_1),\n-        };\n-        count.update_with_dirty_state(&old);\n-        let diff = count.replace_dirty_state(&old, &new);\n+        count.update_with_dirtyness_and_session(Dirtyness::Dirty, None);\n+        let diff = count.replace_dirtyness_and_session(\n+            Dirtyness::Dirty,\n+            None,\n+            Dirtyness::SessionDependent,\n+            Some(SESSION_1),\n+        );\n         assert!(!count.is_zero());\n         assert_eq!(count.get(SESSION_1), 0);\n         assert_eq!(diff.get(SESSION_1), -1);\n         assert_eq!(count.get(SESSION_2), 1);\n         assert_eq!(diff.get(SESSION_2), 0);\n \n         let mut count = DirtyContainerCount::default();\n-        let old = DirtyState {\n-            clean_in_session: Some(SESSION_1),\n-        };\n-        let new = DirtyState {\n-            clean_in_session: None,\n-        };\n-        count.update_with_dirty_state(&old);\n-        let diff = count.replace_dirty_state(&old, &new);\n+        count.update_with_dirtyness_and_session(Dirtyness::SessionDependent, Some(SESSION_1));\n+        let diff = count.replace_dirtyness_and_session(\n+            Dirtyness::SessionDependent,\n+            Some(SESSION_1),\n+            Dirtyness::Dirty,\n+            None,\n+        );\n         assert!(!count.is_zero());\n         assert_eq!(count.get(SESSION_1), 1);\n         assert_eq!(diff.get(SESSION_1), 1);\n@@ -563,7 +565,10 @@ pub enum CachedDataItem {\n \n     // State\n     Dirty {\n-        value: DirtyState,\n+        value: Dirtyness,\n+    },\n+    CleanInSession {\n+        value: SessionId,\n     },\n \n     // Children\n@@ -695,6 +700,7 @@ impl CachedDataItem {\n                 !collectible.cell.task.is_transient()\n             }\n             CachedDataItem::Dirty { .. } => true,\n+            CachedDataItem::CleanInSession { .. } => true,\n             CachedDataItem::Child { task, .. } => !task.is_transient(),\n             CachedDataItem::CellData { .. } => true,\n             CachedDataItem::CellTypeMaxIndex { .. } => true,\n@@ -777,6 +783,7 @@ impl CachedDataItem {\n             | Self::Output { .. }\n             | Self::AggregationNumber { .. }\n             | Self::Dirty { .. }\n+            | Self::CleanInSession { .. }\n             | Self::Follower { .. }\n             | Self::Child { .. }\n             | Self::Upper { .. }\n@@ -811,6 +818,7 @@ impl CachedDataItemKey {\n                 !collectible.cell.task.is_transient()\n             }\n             CachedDataItemKey::Dirty { .. } => true,\n+            CachedDataItemKey::CleanInSession { .. } => true,\n             CachedDataItemKey::Child { task, .. } => !task.is_transient(),\n             CachedDataItemKey::CellData { .. } => true,\n             CachedDataItemKey::CellTypeMaxIndex { .. } => true,\n@@ -861,6 +869,7 @@ impl CachedDataItemType {\n             | Self::Output { .. }\n             | Self::AggregationNumber { .. }\n             | Self::Dirty { .. }\n+            | Self::CleanInSession { .. }\n             | Self::Follower { .. }\n             | Self::Child { .. }\n             | Self::Upper { .. }\n@@ -887,6 +896,7 @@ impl CachedDataItemType {\n             Self::Output\n             | Self::Collectible\n             | Self::Dirty\n+            | Self::CleanInSession\n             | Self::Child\n             | Self::CellData\n             | Self::CellTypeMaxIndex"
        }
    ],
    "stats": {
        "total": 289,
        "additions": 162,
        "deletions": 127
    }
}