{
    "author": "lubieowoce",
    "message": "[Cache Components] separate runtime stage in dev render (#84644)\n\nThis PR extends dev rendering with an extra stage - Runtime, where we\nresolve Runtime APIs (`cookies()`, `params`, etc), but not dynamic APIs\n(e.g. `connection()`, uncached fetches). This separation requires some\nchanges to `makeDevtoolsIOPromise` and other tasky delay code that we've\nhad in place before.|\n\nI've implemented this as `StagedRenderingController` (generally accessed\nvia `requestStore.stagedRendering`), which allows creating promises that\nresolve in the correct stage.\n```ts\nstagedRendering.delayUntilStage(RenderStage.Runtime, cookiesObject) // resolves in the runtime stage\nstagedRendering.delayUntilStage(RenderStage.Dynamic, somethingDynamic)  // resolves in the dynamic stage\n```\n\nNotably, in the case where the initial render has cache misses and we\nonly use it as a cache warmup, we can also use this to _not_ resolve\ndynamic promises, which saves us from doing some unncecessary (uncached)\nwork. This means that, if the render ends up being a warmup, dynamic\npromises can be left hanging (and later aborted), similar to how\n`makeHangingPromise` works in a prerender.\n\nFor simplicity and compatibility with other codepaths, most callsites\nthat need a staged promise still use `makeDevtoolsIOAwarePromise`, but\nnow they pass in a stage argument to control the timing if we are\nrendering with stages.\n\n---\n\nBased on the stage, we now add a third environment label -- \"Prefetch\",\nto correspond with runtime prefetches. This label is currently applied\neven if there's no prefetch config in place, which is a bit confusing,\nand will be addressed in a follow-up (if there's no runtime prefetch\nconfig, we want to label runtime logs as \"Server\" even if they run in a\nseparate stage).",
    "sha": "66376415ab585f25d753258452f7014ba4927793",
    "files": [
        {
            "sha": "a4173710af5fedd71d91afc97b41912bbfbc545d",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -878,5 +878,6 @@\n   \"877\": \"Config options `experimental.externalProxyRewritesResolve` and `experimental.externalMiddlewareRewritesResolve` cannot be set at the same time. Please use `experimental.externalProxyRewritesResolve` instead.\",\n   \"878\": \"Config options `skipProxyUrlNormalize` and `skipMiddlewareUrlNormalize` cannot be set at the same time. Please use `skipProxyUrlNormalize` instead.\",\n   \"879\": \"Config options `experimental.proxyClientMaxBodySize` and `experimental.middlewareClientMaxBodySize` cannot be set at the same time. Please use `experimental.proxyClientMaxBodySize` instead.\",\n-  \"880\": \"Config options `experimental.proxyPrefetch` and `experimental.middlewarePrefetch` cannot be set at the same time. Please use `experimental.proxyPrefetch` instead.\"\n+  \"880\": \"Config options `experimental.proxyPrefetch` and `experimental.middlewarePrefetch` cannot be set at the same time. Please use `experimental.proxyPrefetch` instead.\",\n+  \"881\": \"Invalid render stage: %s\"\n }"
        },
        {
            "sha": "ef1801cd359f0d2b1cf71579b8bdb591f40b75b4",
            "filename": "packages/next/src/server/app-render/app-render-render-utils.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 11,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-render-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-render-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-render-utils.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -35,30 +35,45 @@ export function scheduleInSequentialTasks<R>(\n  * We schedule on the same queue (setTimeout) at the same time to ensure no other events can sneak in between.\n  * The function that runs in the second task gets access to the first tasks's result.\n  */\n-export function pipelineInSequentialTasks<A, B>(\n-  render: () => A,\n-  followup: (a: A) => B | Promise<B>\n-): Promise<B> {\n+export function pipelineInSequentialTasks<A, B, C>(\n+  one: () => A,\n+  two: (a: A) => B,\n+  three: (b: B) => C | Promise<C>\n+): Promise<C> {\n   if (process.env.NEXT_RUNTIME === 'edge') {\n     throw new InvariantError(\n       '`pipelineInSequentialTasks` should not be called in edge runtime.'\n     )\n   } else {\n     return new Promise((resolve, reject) => {\n-      let renderResult: A | undefined = undefined\n+      let oneResult: A | undefined = undefined\n       setTimeout(() => {\n         try {\n-          renderResult = render()\n+          oneResult = one()\n         } catch (err) {\n-          clearTimeout(followupId)\n+          clearTimeout(twoId)\n+          clearTimeout(threeId)\n           reject(err)\n         }\n       }, 0)\n-      const followupId = setTimeout(() => {\n-        // if `render` threw, then the `followup` timeout would've been cleared,\n-        // so if we got here, we're guaranteed to have a `renderResult`.\n+\n+      let twoResult: B | undefined = undefined\n+      const twoId = setTimeout(() => {\n+        // if `one` threw, then this timeout would've been cleared,\n+        // so if we got here, we're guaranteed to have a value.\n+        try {\n+          twoResult = two(oneResult!)\n+        } catch (err) {\n+          clearTimeout(threeId)\n+          reject(err)\n+        }\n+      }, 0)\n+\n+      const threeId = setTimeout(() => {\n+        // if `two` threw, then this timeout would've been cleared,\n+        // so if we got here, we're guaranteed to have a value.\n         try {\n-          resolve(followup(renderResult!))\n+          resolve(three(twoResult!))\n         } catch (err) {\n           reject(err)\n         }"
        },
        {
            "sha": "6f73535707a757c660227fca85d8614f8621dbb8",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 86,
            "deletions": 46,
            "changes": 132,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -168,10 +168,7 @@ import {\n   prerenderAndAbortInSequentialTasks,\n } from './app-render-prerender-utils'\n import { printDebugThrownValueForProspectiveRender } from './prospective-render-utils'\n-import {\n-  pipelineInSequentialTasks,\n-  scheduleInSequentialTasks,\n-} from './app-render-render-utils'\n+import { pipelineInSequentialTasks } from './app-render-render-utils'\n import { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\n import {\n   workUnitAsyncStorage,\n@@ -214,6 +211,7 @@ import type { Params } from '../request/params'\n import { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\n import { ImageConfigContext } from '../../shared/lib/image-config-context.shared-runtime'\n import { imageConfigDefault } from '../../shared/lib/image-config'\n+import { RenderStage, StagedRenderingController } from './staged-rendering'\n \n export type GetDynamicParamFromSegment = (\n   // [slug] / [[slug]] / [...slug]\n@@ -2718,8 +2716,21 @@ async function renderWithRestartOnCacheMissInDev(\n   // If the render is restarted, we'll recreate a fresh request store\n   let requestStore: RequestStore = initialRequestStore\n \n-  const environmentName = () =>\n-    requestStore.prerenderPhase === true ? 'Prerender' : 'Server'\n+  const environmentName = () => {\n+    const currentStage = requestStore.stagedRendering!.currentStage\n+    switch (currentStage) {\n+      case RenderStage.Static:\n+        return 'Prerender'\n+      case RenderStage.Runtime:\n+        // TODO: only label as \"Prefetch\" if the page has a `prefetch` config.\n+        return 'Prefetch'\n+      case RenderStage.Dynamic:\n+        return 'Server'\n+      default:\n+        currentStage satisfies never\n+        throw new InvariantError(`Invalid render stage: ${currentStage}`)\n+    }\n+  }\n \n   //===============================================\n   // Initial render\n@@ -2739,14 +2750,19 @@ async function renderWithRestartOnCacheMissInDev(\n \n   const prerenderResumeDataCache = createPrerenderResumeDataCache()\n \n+  const initialReactController = new AbortController()\n+  const initialDataController = new AbortController() // Controls hanging promises we create\n+  const initialStageController = new StagedRenderingController(\n+    initialDataController.signal\n+  )\n+\n   requestStore.prerenderResumeDataCache = prerenderResumeDataCache\n   // `getRenderResumeDataCache` will fall back to using `prerenderResumeDataCache` as `renderResumeDataCache`,\n   // so not having a resume data cache won't break any expectations in case we don't need to restart.\n   requestStore.renderResumeDataCache = null\n+  requestStore.stagedRendering = initialStageController\n   requestStore.cacheSignal = cacheSignal\n \n-  const initialReactController = new AbortController()\n-\n   let debugChannel = setReactDebugChannel && createDebugChannel()\n \n   const initialRscPayload = await getPayload(requestStore)\n@@ -2756,8 +2772,7 @@ async function renderWithRestartOnCacheMissInDev(\n       pipelineInSequentialTasks(\n         () => {\n           // Static stage\n-          requestStore.prerenderPhase = true\n-          return ComponentMod.renderToReadableStream(\n+          const stream = ComponentMod.renderToReadableStream(\n             initialRscPayload,\n             clientReferenceManifest.clientModules,\n             {\n@@ -2768,25 +2783,42 @@ async function renderWithRestartOnCacheMissInDev(\n               signal: initialReactController.signal,\n             }\n           )\n+          // If we abort the render, we want to reject the stage-dependent promises as well.\n+          // Note that we want to install this listener after the render is started\n+          // so that it runs after react is finished running its abort code.\n+          initialReactController.signal.addEventListener('abort', () => {\n+            initialDataController.abort(initialReactController.signal.reason)\n+          })\n+          return stream\n+        },\n+        (stream) => {\n+          // Runtime stage\n+          initialStageController.advanceStage(RenderStage.Runtime)\n+\n+          // If we had a cache miss in the static stage, we'll have to disard this stream\n+          // and render again once the caches are warm.\n+          if (cacheSignal.hasPendingReads()) {\n+            return null\n+          }\n+\n+          // If there's no cache misses, we'll continue rendering,\n+          // and see if there's any cache misses in the runtime stage.\n+          return stream\n         },\n-        async (stream) => {\n+        async (maybeStream) => {\n           // Dynamic stage\n-          // Note: if we had cache misses, things that would've happened statically otherwise\n-          // may be marked as dynamic instead.\n-          requestStore.prerenderPhase = false\n-\n-          // If all cache reads initiated in the static stage have completed,\n-          // then all of the necessary caches have to be warm (or there's no caches on the page).\n-          // On the other hand, if we still have pending cache reads, then we had a cache miss,\n-          // and the static stage didn't render all the content that it normally would have.\n-          const hadCacheMiss = cacheSignal.hasPendingReads()\n-          if (!hadCacheMiss) {\n-            // No cache misses. We can use the stream as is.\n-            return stream\n-          } else {\n-            // Cache miss. We'll discard this stream, and render again.\n+\n+          // If we had cache misses in either of the previous stages,\n+          // then we'll only use this render for filling caches.\n+          // We won't advance the stage, and thus leave dynamic APIs hanging,\n+          // because they won't be cached anyway, so it'd be wasted work.\n+          if (maybeStream === null || cacheSignal.hasPendingReads()) {\n             return null\n           }\n+\n+          // If there's no cache misses, we'll use this render, so let it advance to the dynamic stage.\n+          initialStageController.advanceStage(RenderStage.Dynamic)\n+          return maybeStream\n         }\n       )\n   )\n@@ -2819,40 +2851,48 @@ async function renderWithRestartOnCacheMissInDev(\n   // The initial render acted as a prospective render to warm the caches.\n   requestStore = createRequestStore()\n \n+  const finalStageController = new StagedRenderingController()\n+\n   // We've filled the caches, so now we can render as usual,\n   // without any cache-filling mechanics.\n   requestStore.prerenderResumeDataCache = null\n   requestStore.renderResumeDataCache = createRenderResumeDataCache(\n     prerenderResumeDataCache\n   )\n+  requestStore.stagedRendering = finalStageController\n   requestStore.cacheSignal = null\n \n   // The initial render already wrote to its debug channel.\n   // We're not using it, so we need to create a new one.\n   debugChannel = setReactDebugChannel && createDebugChannel()\n \n   const finalRscPayload = await getPayload(requestStore)\n-  const finalServerStream = await workUnitAsyncStorage.run(\n-    requestStore,\n-    scheduleInSequentialTasks,\n-    () => {\n-      // Static stage\n-      requestStore.prerenderPhase = true\n-      return ComponentMod.renderToReadableStream(\n-        finalRscPayload,\n-        clientReferenceManifest.clientModules,\n-        {\n-          onError,\n-          environmentName,\n-          filterStackFrame,\n-          debugChannel: debugChannel?.serverSide,\n-        }\n-      )\n-    },\n-    () => {\n-      // Dynamic stage\n-      requestStore.prerenderPhase = false\n-    }\n+  const finalServerStream = await workUnitAsyncStorage.run(requestStore, () =>\n+    pipelineInSequentialTasks(\n+      () => {\n+        // Static stage\n+        return ComponentMod.renderToReadableStream(\n+          finalRscPayload,\n+          clientReferenceManifest.clientModules,\n+          {\n+            onError,\n+            environmentName,\n+            filterStackFrame,\n+            debugChannel: debugChannel?.serverSide,\n+          }\n+        )\n+      },\n+      (stream) => {\n+        // Runtime stage\n+        finalStageController.advanceStage(RenderStage.Runtime)\n+        return stream\n+      },\n+      (stream) => {\n+        // Dynamic stage\n+        finalStageController.advanceStage(RenderStage.Dynamic)\n+        return stream\n+      }\n+    )\n   )\n \n   return {"
        },
        {
            "sha": "ebb0a89f1909072204b91ceb305ab4a1ac71455a",
            "filename": "packages/next/src/server/app-render/dynamic-rendering.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -50,6 +50,7 @@ import {\n import { scheduleOnNextTick } from '../../lib/scheduler'\n import { BailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\n import { InvariantError } from '../../shared/lib/invariant-error'\n+import { RenderStage } from './staged-rendering'\n \n const hasPostpone = typeof React.unstable_postpone === 'function'\n \n@@ -298,8 +299,12 @@ export function trackSynchronousPlatformIOAccessInDev(\n   requestStore: RequestStore\n ): void {\n   // We don't actually have a controller to abort but we do the semantic equivalent by\n-  // advancing the request store out of prerender mode\n-  requestStore.prerenderPhase = false\n+  // advancing the request store out of the prerender stage\n+  if (requestStore.stagedRendering) {\n+    // TODO: error for sync IO in the runtime stage\n+    // (which is not currently covered by the validation render in `spawnDynamicValidationInDev`)\n+    requestStore.stagedRendering.advanceStage(RenderStage.Dynamic)\n+  }\n }\n \n /**"
        },
        {
            "sha": "aca46526d80eda081c0753a0befe3b64ed17d7f5",
            "filename": "packages/next/src/server/app-render/staged-rendering.ts",
            "status": "added",
            "additions": 90,
            "deletions": 0,
            "changes": 90,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fstaged-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fstaged-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fstaged-rendering.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -0,0 +1,90 @@\n+import { InvariantError } from '../../shared/lib/invariant-error'\n+import { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\n+\n+export enum RenderStage {\n+  Static = 1,\n+  Runtime = 2,\n+  Dynamic = 3,\n+}\n+\n+export type NonStaticRenderStage = RenderStage.Runtime | RenderStage.Dynamic\n+\n+export class StagedRenderingController {\n+  currentStage: RenderStage = RenderStage.Static\n+\n+  private runtimeStagePromise = createPromiseWithResolvers<void>()\n+  private dynamicStagePromise = createPromiseWithResolvers<void>()\n+\n+  constructor(private abortSignal: AbortSignal | null = null) {\n+    if (abortSignal) {\n+      abortSignal.addEventListener(\n+        'abort',\n+        () => {\n+          const { reason } = abortSignal\n+          if (this.currentStage < RenderStage.Runtime) {\n+            this.runtimeStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n+            this.runtimeStagePromise.reject(reason)\n+          }\n+          if (this.currentStage < RenderStage.Dynamic) {\n+            this.dynamicStagePromise.promise.catch(ignoreReject) // avoid unhandled rejections\n+            this.dynamicStagePromise.reject(reason)\n+          }\n+        },\n+        { once: true }\n+      )\n+    }\n+  }\n+\n+  advanceStage(stage: NonStaticRenderStage) {\n+    // If we're already at the target stage or beyond, do nothing.\n+    // (this can happen e.g. if sync IO advanced us to the dynamic stage)\n+    if (this.currentStage >= stage) {\n+      return\n+    }\n+    this.currentStage = stage\n+    // Note that we might be going directly from Static to Dynamic,\n+    // so we need to resolve the runtime stage as well.\n+    if (stage >= RenderStage.Runtime) {\n+      this.runtimeStagePromise.resolve()\n+    }\n+    if (stage >= RenderStage.Dynamic) {\n+      this.dynamicStagePromise.resolve()\n+    }\n+  }\n+\n+  delayUntilStage<T>(stage: NonStaticRenderStage, resolvedValue: T) {\n+    let stagePromise: Promise<void>\n+    switch (stage) {\n+      case RenderStage.Runtime: {\n+        stagePromise = this.runtimeStagePromise.promise\n+        break\n+      }\n+      case RenderStage.Dynamic: {\n+        stagePromise = this.dynamicStagePromise.promise\n+        break\n+      }\n+      default: {\n+        stage satisfies never\n+        throw new InvariantError(`Invalid render stage: ${stage}`)\n+      }\n+    }\n+\n+    // FIXME: this seems to be the only form that leads to correct API names\n+    // being displayed in React Devtools (in the \"suspended by\" section).\n+    // If we use `promise.then(() => resolvedValue)`, the names are lost.\n+    // It's a bit strange that only one of those works right.\n+    const promise = new Promise<T>((resolve, reject) => {\n+      stagePromise.then(resolve.bind(null, resolvedValue), reject)\n+    })\n+\n+    // Analogously to `makeHangingPromise`, we might reject this promise if the signal is invoked.\n+    // (e.g. in the case where we don't want want the render to proceed to the dynamic stage and abort it).\n+    // We shouldn't consider this an unhandled rejection, so we attach a noop catch handler here to suppress this warning.\n+    if (this.abortSignal) {\n+      promise.catch(ignoreReject)\n+    }\n+    return promise\n+  }\n+}\n+\n+function ignoreReject() {}"
        },
        {
            "sha": "8cc66c2cf07f180dcead4c48db245137e5b63141",
            "filename": "packages/next/src/server/app-render/work-unit-async-storage.external.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -19,6 +19,7 @@ import type { ImplicitTags } from '../lib/implicit-tags'\n import type { WorkStore } from './work-async-storage.external'\n import { NEXT_HMR_REFRESH_HASH_COOKIE } from '../../client/components/app-router-headers'\n import { InvariantError } from '../../shared/lib/invariant-error'\n+import type { StagedRenderingController } from './staged-rendering'\n \n export type WorkUnitPhase = 'action' | 'render' | 'after'\n \n@@ -67,8 +68,8 @@ export interface RequestStore extends CommonWorkUnitStore {\n \n   // DEV-only\n   usedDynamic?: boolean\n-  prerenderPhase?: boolean\n   devFallbackParams?: OpaqueFallbackRouteParams | null\n+  stagedRendering?: StagedRenderingController | null\n   cacheSignal?: CacheSignal | null\n   prerenderResumeDataCache?: PrerenderResumeDataCache | null\n }"
        },
        {
            "sha": "e46076de3f28b3473d71fa37a41c661c034fb9eb",
            "filename": "packages/next/src/server/dynamic-rendering-utils.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 1,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fdynamic-rendering-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fdynamic-rendering-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdynamic-rendering-utils.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -1,3 +1,6 @@\n+import type { NonStaticRenderStage } from './app-render/staged-rendering'\n+import type { RequestStore } from './app-render/work-unit-async-storage.external'\n+\n export function isHangingPromiseRejectionError(\n   err: unknown\n ): err is HangingPromiseRejectionError {\n@@ -73,7 +76,15 @@ export function makeHangingPromise<T>(\n \n function ignoreReject() {}\n \n-export function makeDevtoolsIOAwarePromise<T>(underlying: T): Promise<T> {\n+export function makeDevtoolsIOAwarePromise<T>(\n+  underlying: T,\n+  requestStore: RequestStore,\n+  stage: NonStaticRenderStage\n+): Promise<T> {\n+  if (requestStore.stagedRendering) {\n+    // We resolve each stage in a timeout, so React DevTools will pick this up as IO.\n+    return requestStore.stagedRendering.delayUntilStage(stage, underlying)\n+  }\n   // in React DevTools if we resolve in a setTimeout we will observe\n   // the promise resolution as something that can suspend a boundary or root.\n   return new Promise<T>((resolve) => {"
        },
        {
            "sha": "fe8dec9e81fd32b4a2f641560e5f4dc7968389cc",
            "filename": "packages/next/src/server/lib/patch-fetch.ts",
            "status": "modified",
            "additions": 34,
            "deletions": 24,
            "changes": 58,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -29,6 +29,7 @@ import {\n } from '../response-cache'\n import { cloneResponse } from './clone-response'\n import type { IncrementalCache } from './incremental-cache'\n+import { RenderStage } from '../app-render/staged-rendering'\n \n const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n \n@@ -288,14 +289,6 @@ export function createPatchedFetcher(\n       cacheSignal.beginRead()\n     }\n \n-    const isStagedRenderingInDev = !!(\n-      process.env.NODE_ENV === 'development' &&\n-      process.env.__NEXT_CACHE_COMPONENTS &&\n-      workUnitStore &&\n-      // eslint-disable-next-line no-restricted-syntax\n-      workUnitStore.type === 'request'\n-    )\n-\n     const result = getTracer().trace(\n       isInternal ? NextNodeServerSpan.internalFetch : AppRenderSpan.fetch,\n       {\n@@ -563,14 +556,16 @@ export function createPatchedFetcher(\n             case 'request':\n               if (\n                 process.env.NODE_ENV === 'development' &&\n-                isStagedRenderingInDev\n+                workUnitStore.stagedRendering\n               ) {\n                 if (cacheSignal) {\n                   cacheSignal.endRead()\n                   cacheSignal = null\n                 }\n-                // TODO(restart-on-cache-miss): block dynamic when filling caches\n-                await getTimeoutBoundary()\n+                await workUnitStore.stagedRendering.delayUntilStage(\n+                  RenderStage.Dynamic,\n+                  undefined\n+                )\n               }\n               break\n             case 'prerender-ppr':\n@@ -688,14 +683,16 @@ export function createPatchedFetcher(\n                 case 'request':\n                   if (\n                     process.env.NODE_ENV === 'development' &&\n-                    isStagedRenderingInDev\n+                    workUnitStore.stagedRendering\n                   ) {\n                     if (cacheSignal) {\n                       cacheSignal.endRead()\n                       cacheSignal = null\n                     }\n-                    // TODO(restart-on-cache-miss): block dynamic when filling caches\n-                    await getTimeoutBoundary()\n+                    await workUnitStore.stagedRendering.delayUntilStage(\n+                      RenderStage.Dynamic,\n+                      undefined\n+                    )\n                   }\n                   break\n                 case 'prerender-ppr':\n@@ -874,7 +871,7 @@ export function createPatchedFetcher(\n                   case 'request':\n                     if (\n                       process.env.NODE_ENV === 'development' &&\n-                      isStagedRenderingInDev &&\n+                      workUnitStore.stagedRendering &&\n                       workUnitStore.cacheSignal\n                     ) {\n                       // We're filling caches for a staged render,\n@@ -963,9 +960,12 @@ export function createPatchedFetcher(\n                 case 'request':\n                   if (\n                     process.env.NODE_ENV === 'development' &&\n-                    isStagedRenderingInDev\n+                    workUnitStore.stagedRendering\n                   ) {\n-                    await getTimeoutBoundary()\n+                    await workUnitStore.stagedRendering.delayUntilStage(\n+                      RenderStage.Dynamic,\n+                      undefined\n+                    )\n                   }\n                   break\n                 case 'prerender-ppr':\n@@ -1051,7 +1051,13 @@ export function createPatchedFetcher(\n         }\n \n         if (\n-          (workStore.isStaticGeneration || isStagedRenderingInDev) &&\n+          (workStore.isStaticGeneration ||\n+            (process.env.NODE_ENV === 'development' &&\n+              process.env.__NEXT_CACHE_COMPONENTS &&\n+              workUnitStore &&\n+              // eslint-disable-next-line no-restricted-syntax\n+              workUnitStore.type === 'request' &&\n+              workUnitStore.stagedRendering)) &&\n           init &&\n           typeof init === 'object'\n         ) {\n@@ -1079,14 +1085,16 @@ export function createPatchedFetcher(\n                 case 'request':\n                   if (\n                     process.env.NODE_ENV === 'development' &&\n-                    isStagedRenderingInDev\n+                    workUnitStore.stagedRendering\n                   ) {\n                     if (cacheSignal) {\n                       cacheSignal.endRead()\n                       cacheSignal = null\n                     }\n-                    // TODO(restart-on-cache-miss): block dynamic when filling caches\n-                    await getTimeoutBoundary()\n+                    await workUnitStore.stagedRendering.delayUntilStage(\n+                      RenderStage.Dynamic,\n+                      undefined\n+                    )\n                   }\n                   break\n                 case 'prerender-ppr':\n@@ -1128,10 +1136,12 @@ export function createPatchedFetcher(\n                   case 'request':\n                     if (\n                       process.env.NODE_ENV === 'development' &&\n-                      isStagedRenderingInDev\n+                      workUnitStore.stagedRendering\n                     ) {\n-                      // TODO(restart-on-cache-miss): block dynamic when filling caches\n-                      await getTimeoutBoundary()\n+                      await workUnitStore.stagedRendering.delayUntilStage(\n+                        RenderStage.Dynamic,\n+                        undefined\n+                      )\n                     }\n                     break\n                   case 'cache':"
        },
        {
            "sha": "3b7840bd186cb2139681136221481dc8d5dd2489",
            "filename": "packages/next/src/server/node-environment-extensions/utils.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -86,7 +86,7 @@ export function io(expression: string, type: ApiType) {\n       break\n     }\n     case 'request':\n-      if (workUnitStore.prerenderPhase === true) {\n+      if (process.env.NODE_ENV === 'development') {\n         trackSynchronousPlatformIOAccessInDev(workUnitStore)\n       }\n       break"
        },
        {
            "sha": "78920f8bcd94ba8f2815f081da314dee0d411f3a",
            "filename": "packages/next/src/server/request/connection.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -14,6 +14,7 @@ import {\n   makeDevtoolsIOAwarePromise,\n } from '../dynamic-rendering-utils'\n import { isRequestAPICallableInsideAfter } from './utils'\n+import { RenderStage } from '../app-render/staged-rendering'\n \n /**\n  * This function allows you to indicate that you require an actual user Request before continuing.\n@@ -105,7 +106,11 @@ export function connection(): Promise<void> {\n             // Semantically we only need the dev tracking when running in `next dev`\n             // but since you would never use next dev with production NODE_ENV we use this\n             // as a proxy so we can statically exclude this code from production builds.\n-            return makeDevtoolsIOAwarePromise(undefined)\n+            return makeDevtoolsIOAwarePromise(\n+              undefined,\n+              workUnitStore,\n+              RenderStage.Dynamic\n+            )\n           } else {\n             return Promise.resolve(undefined)\n           }"
        },
        {
            "sha": "477ac5cd050032377b21b3fe2f12d7a75b447fe7",
            "filename": "packages/next/src/server/request/cookies.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -12,6 +12,7 @@ import {\n   throwForMissingRequestStore,\n   workUnitAsyncStorage,\n   type PrerenderStoreModern,\n+  type RequestStore,\n } from '../app-render/work-unit-async-storage.external'\n import {\n   delayUntilRuntimeStage,\n@@ -28,6 +29,7 @@ import { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-b\n import { isRequestAPICallableInsideAfter } from './utils'\n import { InvariantError } from '../../shared/lib/invariant-error'\n import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n+import { RenderStage } from '../app-render/staged-rendering'\n \n export function cookies(): Promise<ReadonlyRequestCookies> {\n   const callingExpression = 'cookies'\n@@ -123,6 +125,7 @@ export function cookies(): Promise<ReadonlyRequestCookies> {\n             // but since you would never use next dev with production NODE_ENV we use this\n             // as a proxy so we can statically exclude this code from production builds.\n             return makeUntrackedCookiesWithDevWarnings(\n+              workUnitStore,\n               underlyingCookies,\n               workStore?.route\n             )\n@@ -183,6 +186,7 @@ function makeUntrackedCookies(\n }\n \n function makeUntrackedCookiesWithDevWarnings(\n+  requestStore: RequestStore,\n   underlyingCookies: ReadonlyRequestCookies,\n   route?: string\n ): Promise<ReadonlyRequestCookies> {\n@@ -191,7 +195,11 @@ function makeUntrackedCookiesWithDevWarnings(\n     return cachedCookies\n   }\n \n-  const promise = makeDevtoolsIOAwarePromise(underlyingCookies)\n+  const promise = makeDevtoolsIOAwarePromise(\n+    underlyingCookies,\n+    requestStore,\n+    RenderStage.Runtime\n+  )\n \n   const proxiedPromise = new Proxy(promise, {\n     get(target, prop, receiver) {"
        },
        {
            "sha": "842cd23a88b6741775df6fe43d3e36f335674920",
            "filename": "packages/next/src/server/request/headers.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -10,6 +10,7 @@ import {\n   throwForMissingRequestStore,\n   workUnitAsyncStorage,\n   type PrerenderStoreModern,\n+  type RequestStore,\n } from '../app-render/work-unit-async-storage.external'\n import {\n   delayUntilRuntimeStage,\n@@ -26,6 +27,7 @@ import { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-b\n import { isRequestAPICallableInsideAfter } from './utils'\n import { InvariantError } from '../../shared/lib/invariant-error'\n import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n+import { RenderStage } from '../app-render/staged-rendering'\n \n /**\n  * This function allows you to read the HTTP incoming request headers in\n@@ -139,7 +141,8 @@ export function headers(): Promise<ReadonlyHeaders> {\n             // as a proxy so we can statically exclude this code from production builds.\n             return makeUntrackedHeadersWithDevWarnings(\n               workUnitStore.headers,\n-              workStore?.route\n+              workStore?.route,\n+              workUnitStore\n             )\n           } else {\n             return makeUntrackedHeaders(workUnitStore.headers)\n@@ -193,14 +196,19 @@ function makeUntrackedHeaders(\n \n function makeUntrackedHeadersWithDevWarnings(\n   underlyingHeaders: ReadonlyHeaders,\n-  route?: string\n+  route: string | undefined,\n+  requestStore: RequestStore\n ): Promise<ReadonlyHeaders> {\n   const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n   if (cachedHeaders) {\n     return cachedHeaders\n   }\n \n-  const promise = makeDevtoolsIOAwarePromise(underlyingHeaders)\n+  const promise = makeDevtoolsIOAwarePromise(\n+    underlyingHeaders,\n+    requestStore,\n+    RenderStage.Runtime\n+  )\n \n   const proxiedPromise = new Proxy(promise, {\n     get(target, prop, receiver) {"
        },
        {
            "sha": "a66b714e97a92817c7ea9959a383fb9f658a301f",
            "filename": "packages/next/src/server/request/params.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 9,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -19,6 +19,7 @@ import {\n   type StaticPrerenderStore,\n   throwInvariantForMissingStore,\n   type PrerenderStoreModernRuntime,\n+  type RequestStore,\n } from '../app-render/work-unit-async-storage.external'\n import { InvariantError } from '../../shared/lib/invariant-error'\n import {\n@@ -31,6 +32,7 @@ import {\n } from '../dynamic-rendering-utils'\n import { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\n import { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\n+import { RenderStage } from '../app-render/staged-rendering'\n \n export type ParamValue = string | Array<string> | undefined\n export type Params = Record<string, ParamValue>\n@@ -70,7 +72,8 @@ export function createParamsFromClient(\n           return createRenderParamsInDev(\n             underlyingParams,\n             devFallbackParams,\n-            workStore\n+            workStore,\n+            workUnitStore\n           )\n         } else {\n           return createRenderParamsInProd(underlyingParams)\n@@ -120,7 +123,8 @@ export function createServerParamsForRoute(\n           return createRenderParamsInDev(\n             underlyingParams,\n             devFallbackParams,\n-            workStore\n+            workStore,\n+            workUnitStore\n           )\n         } else {\n           return createRenderParamsInProd(underlyingParams)\n@@ -165,7 +169,8 @@ export function createServerParamsForServerSegment(\n           return createRenderParamsInDev(\n             underlyingParams,\n             devFallbackParams,\n-            workStore\n+            workStore,\n+            workUnitStore\n           )\n         } else {\n           return createRenderParamsInProd(underlyingParams)\n@@ -298,7 +303,8 @@ function createRenderParamsInProd(underlyingParams: Params): Promise<Params> {\n function createRenderParamsInDev(\n   underlyingParams: Params,\n   devFallbackParams: OpaqueFallbackRouteParams | null | undefined,\n-  workStore: WorkStore\n+  workStore: WorkStore,\n+  requestStore: RequestStore\n ): Promise<Params> {\n   let hasFallbackParams = false\n   if (devFallbackParams) {\n@@ -313,7 +319,8 @@ function createRenderParamsInDev(\n   return makeDynamicallyTrackedParamsWithDevWarnings(\n     underlyingParams,\n     hasFallbackParams,\n-    workStore\n+    workStore,\n+    requestStore\n   )\n }\n \n@@ -445,7 +452,8 @@ function makeUntrackedParams(underlyingParams: Params): Promise<Params> {\n function makeDynamicallyTrackedParamsWithDevWarnings(\n   underlyingParams: Params,\n   hasFallbackParams: boolean,\n-  store: WorkStore\n+  workStore: WorkStore,\n+  requestStore: RequestStore\n ): Promise<Params> {\n   const cachedParams = CachedParams.get(underlyingParams)\n   if (cachedParams) {\n@@ -456,7 +464,11 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n   // supports copying with spread and we don't want to unnecessarily\n   // instrument the promise with spreadable properties of ReactPromise.\n   const promise = hasFallbackParams\n-    ? makeDevtoolsIOAwarePromise(underlyingParams)\n+    ? makeDevtoolsIOAwarePromise(\n+        underlyingParams,\n+        requestStore,\n+        RenderStage.Runtime\n+      )\n     : // We don't want to force an environment transition when this params is not part of the fallback params set\n       Promise.resolve(underlyingParams)\n \n@@ -480,7 +492,7 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n           proxiedProperties.has(prop)\n         ) {\n           const expression = describeStringPropertyAccess('params', prop)\n-          warnForSyncAccess(store.route, expression)\n+          warnForSyncAccess(workStore.route, expression)\n         }\n       }\n       return ReflectAdapter.get(target, prop, receiver)\n@@ -493,7 +505,7 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n     },\n     ownKeys(target) {\n       const expression = '`...params` or similar expression'\n-      warnForSyncAccess(store.route, expression)\n+      warnForSyncAccess(workStore.route, expression)\n       return Reflect.ownKeys(target)\n     },\n   })"
        },
        {
            "sha": "efe36aeb23f87127477a27fb88979600d6570bfe",
            "filename": "packages/next/src/server/request/search-params.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 19,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -16,6 +16,7 @@ import {\n   type PrerenderStoreModernRuntime,\n   type StaticPrerenderStore,\n   throwInvariantForMissingStore,\n+  type RequestStore,\n } from '../app-render/work-unit-async-storage.external'\n import { InvariantError } from '../../shared/lib/invariant-error'\n import {\n@@ -32,6 +33,7 @@ import {\n   throwWithStaticGenerationBailoutErrorWithDynamicError,\n   throwForSearchParamsAccessInUseCache,\n } from './utils'\n+import { RenderStage } from '../app-render/staged-rendering'\n \n export type SearchParams = { [key: string]: string | string[] | undefined }\n \n@@ -58,7 +60,11 @@ export function createSearchParamsFromClient(\n           'createSearchParamsFromClient should not be called in cache contexts.'\n         )\n       case 'request':\n-        return createRenderSearchParams(underlyingSearchParams, workStore)\n+        return createRenderSearchParams(\n+          underlyingSearchParams,\n+          workStore,\n+          workUnitStore\n+        )\n       default:\n         workUnitStore satisfies never\n     }\n@@ -94,7 +100,11 @@ export function createServerSearchParamsForServerPage(\n           workUnitStore\n         )\n       case 'request':\n-        return createRenderSearchParams(underlyingSearchParams, workStore)\n+        return createRenderSearchParams(\n+          underlyingSearchParams,\n+          workStore,\n+          workUnitStore\n+        )\n       default:\n         workUnitStore satisfies never\n     }\n@@ -181,7 +191,8 @@ function createRuntimePrerenderSearchParams(\n \n function createRenderSearchParams(\n   underlyingSearchParams: SearchParams,\n-  workStore: WorkStore\n+  workStore: WorkStore,\n+  requestStore: RequestStore\n ): Promise<SearchParams> {\n   if (workStore.forceStatic) {\n     // When using forceStatic we override all other logic and always just return an empty\n@@ -194,7 +205,8 @@ function createRenderSearchParams(\n       // as a proxy so we can statically exclude this code from production builds.\n       return makeUntrackedSearchParamsWithDevWarnings(\n         underlyingSearchParams,\n-        workStore\n+        workStore,\n+        requestStore\n       )\n     } else {\n       return makeUntrackedSearchParams(underlyingSearchParams)\n@@ -371,9 +383,14 @@ function makeUntrackedSearchParams(\n \n function makeUntrackedSearchParamsWithDevWarnings(\n   underlyingSearchParams: SearchParams,\n-  store: WorkStore\n+  workStore: WorkStore,\n+  requestStore: RequestStore\n ): Promise<SearchParams> {\n-  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n+  // Note: unlike some of the other functions here, we tie the lifetime of the cached search params\n+  // to the request store, not `underlyingSearchParams`.\n+  // If we didn't do that we'd end up re-using the same object across both renders in the restart-on-cache-miss flow,\n+  // meaning that the `searchParams` promise would (incorrectly) be already resolved in the restarted render.\n+  const cachedSearchParams = CachedSearchParams.get(requestStore)\n   if (cachedSearchParams) {\n     return cachedSearchParams\n   }\n@@ -391,10 +408,10 @@ function makeUntrackedSearchParamsWithDevWarnings(\n   const proxiedUnderlying = new Proxy(underlyingSearchParams, {\n     get(target, prop, receiver) {\n       if (typeof prop === 'string' && promiseInitialized) {\n-        if (store.dynamicShouldError) {\n+        if (workStore.dynamicShouldError) {\n           const expression = describeStringPropertyAccess('searchParams', prop)\n           throwWithStaticGenerationBailoutErrorWithDynamicError(\n-            store.route,\n+            workStore.route,\n             expression\n           )\n         }\n@@ -403,25 +420,25 @@ function makeUntrackedSearchParamsWithDevWarnings(\n     },\n     has(target, prop) {\n       if (typeof prop === 'string') {\n-        if (store.dynamicShouldError) {\n+        if (workStore.dynamicShouldError) {\n           const expression = describeHasCheckingStringProperty(\n             'searchParams',\n             prop\n           )\n           throwWithStaticGenerationBailoutErrorWithDynamicError(\n-            store.route,\n+            workStore.route,\n             expression\n           )\n         }\n       }\n       return Reflect.has(target, prop)\n     },\n     ownKeys(target) {\n-      if (store.dynamicShouldError) {\n+      if (workStore.dynamicShouldError) {\n         const expression =\n           '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n         throwWithStaticGenerationBailoutErrorWithDynamicError(\n-          store.route,\n+          workStore.route,\n           expression\n         )\n       }\n@@ -432,7 +449,11 @@ function makeUntrackedSearchParamsWithDevWarnings(\n   // We don't use makeResolvedReactPromise here because searchParams\n   // supports copying with spread and we don't want to unnecessarily\n   // instrument the promise with spreadable properties of ReactPromise.\n-  const promise = makeDevtoolsIOAwarePromise(proxiedUnderlying)\n+  const promise = makeDevtoolsIOAwarePromise(\n+    proxiedUnderlying,\n+    requestStore,\n+    RenderStage.Runtime\n+  )\n   promise.then(() => {\n     promiseInitialized = true\n   })\n@@ -448,10 +469,10 @@ function makeUntrackedSearchParamsWithDevWarnings(\n \n   const proxiedPromise = new Proxy(promise, {\n     get(target, prop, receiver) {\n-      if (prop === 'then' && store.dynamicShouldError) {\n+      if (prop === 'then' && workStore.dynamicShouldError) {\n         const expression = '`searchParams.then`'\n         throwWithStaticGenerationBailoutErrorWithDynamicError(\n-          store.route,\n+          workStore.route,\n           expression\n         )\n       }\n@@ -464,7 +485,7 @@ function makeUntrackedSearchParamsWithDevWarnings(\n             Reflect.has(target, prop) === false)\n         ) {\n           const expression = describeStringPropertyAccess('searchParams', prop)\n-          warnForSyncAccess(store.route, expression)\n+          warnForSyncAccess(workStore.route, expression)\n         }\n       }\n       return ReflectAdapter.get(target, prop, receiver)\n@@ -488,19 +509,19 @@ function makeUntrackedSearchParamsWithDevWarnings(\n             'searchParams',\n             prop\n           )\n-          warnForSyncAccess(store.route, expression)\n+          warnForSyncAccess(workStore.route, expression)\n         }\n       }\n       return Reflect.has(target, prop)\n     },\n     ownKeys(target) {\n       const expression = '`Object.keys(searchParams)` or similar'\n-      warnForSyncAccess(store.route, expression)\n+      warnForSyncAccess(workStore.route, expression)\n       return Reflect.ownKeys(target)\n     },\n   })\n \n-  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n+  CachedSearchParams.set(requestStore, proxiedPromise)\n   return proxiedPromise\n }\n "
        },
        {
            "sha": "a48ad96a9858092520eb9ad83b68a6a3019dce5c",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 6,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -71,6 +71,7 @@ import { createLazyResult, isResolvedLazyResult } from '../lib/lazy-result'\n import { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\n import { isReactLargeShellError } from '../app-render/react-large-shell-error'\n import type { CacheLife } from './cache-life'\n+import { RenderStage } from '../app-render/staged-rendering'\n \n interface PrivateCacheContext {\n   readonly kind: 'private'\n@@ -1014,9 +1015,11 @@ export function cache(\n             if (process.env.NODE_ENV === 'development') {\n               // Similar to runtime prerenders, private caches should not resolve in the static stage\n               // of a dev request, so we delay them.\n-              // When we implement the 3-task render, this will change to match the codepath above.\n-              // (to resolve them in the runtime stage, and not later)\n-              await makeDevtoolsIOAwarePromise(undefined)\n+              await makeDevtoolsIOAwarePromise(\n+                undefined,\n+                outerWorkUnitStore,\n+                RenderStage.Runtime\n+              )\n             }\n             break\n           }\n@@ -1280,7 +1283,11 @@ export function cache(\n                     // TODO(restart-on-cache-miss): Optimize this to avoid unnecessary restarts.\n                     // We don't end the cache read here, so this will always appear as a cache miss in the static stage,\n                     // and thus will cause a restart even if all caches are filled.\n-                    await makeDevtoolsIOAwarePromise(undefined)\n+                    await makeDevtoolsIOAwarePromise(\n+                      undefined,\n+                      workUnitStore,\n+                      RenderStage.Runtime\n+                    )\n                   }\n                   break\n                 }\n@@ -1310,10 +1317,25 @@ export function cache(\n                     workStore.route,\n                     'dynamic \"use cache\"'\n                   )\n+                case 'request': {\n+                  if (process.env.NODE_ENV === 'development') {\n+                    // We delay the cache here so that it doesn't resolve in the runtime phase --\n+                    // in a regular runtime prerender, it'd be a hanging promise, and we need to reflect that,\n+                    // so it has to resolve later.\n+                    // TODO(restart-on-cache-miss): Optimize this to avoid unnecessary restarts.\n+                    // We don't end the cache read here, so this will always appear as a cache miss in the runtime stage,\n+                    // and thus will cause a restart even if all caches are filled.\n+                    await makeDevtoolsIOAwarePromise(\n+                      undefined,\n+                      workUnitStore,\n+                      RenderStage.Dynamic\n+                    )\n+                  }\n+                  break\n+                }\n                 case 'prerender':\n                 case 'prerender-ppr':\n                 case 'prerender-legacy':\n-                case 'request':\n                 case 'cache':\n                 case 'private-cache':\n                 case 'unstable-cache':\n@@ -1477,7 +1499,11 @@ export function cache(\n                 // TODO(restart-on-cache-miss): Optimize this to avoid unnecessary restarts.\n                 // We don't end the cache read here, so this will always appear as a cache miss in the static stage,\n                 // and thus will cause a restart even if all caches are filled.\n-                await makeDevtoolsIOAwarePromise(undefined)\n+                await makeDevtoolsIOAwarePromise(\n+                  undefined,\n+                  workUnitStore,\n+                  RenderStage.Runtime\n+                )\n               }\n               break\n             }"
        },
        {
            "sha": "117533ce2e7ae9e78c9a40e37f4af0a6888a5f62",
            "filename": "test/development/app-dir/cache-components-dev-warmup/app/apis/[param]/page.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/test%2Fdevelopment%2Fapp-dir%2Fcache-components-dev-warmup%2Fapp%2Fapis%2F%5Bparam%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/test%2Fdevelopment%2Fapp-dir%2Fcache-components-dev-warmup%2Fapp%2Fapis%2F%5Bparam%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-dev-warmup%2Fapp%2Fapis%2F%5Bparam%5D%2Fpage.tsx?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -28,7 +28,7 @@ export default function Page({ params, searchParams }) {\n \n function LogAfter({ label, api }: { label: string; api: () => Promise<any> }) {\n   return (\n-    <Suspense fallback={`Waiting for ${label}...`}>\n+    <Suspense fallback={<div>Waiting for {label}...</div>}>\n       <LogAfterInner label={label} api={api} />\n     </Suspense>\n   )\n@@ -43,5 +43,5 @@ async function LogAfterInner({\n }) {\n   await api()\n   console.log(`after ${label}`)\n-  return null\n+  return <div>Finished {label}</div>\n }"
        },
        {
            "sha": "92e8cd292dfa1ab844ab72226ecaa30574779277",
            "filename": "test/development/app-dir/cache-components-dev-warmup/cache-components.dev-warmup.test.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 19,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/66376415ab585f25d753258452f7014ba4927793/test%2Fdevelopment%2Fapp-dir%2Fcache-components-dev-warmup%2Fcache-components.dev-warmup.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/66376415ab585f25d753258452f7014ba4927793/test%2Fdevelopment%2Fapp-dir%2Fcache-components-dev-warmup%2Fcache-components.dev-warmup.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-dev-warmup%2Fcache-components.dev-warmup.test.ts?ref=66376415ab585f25d753258452f7014ba4927793",
            "patch": "@@ -29,7 +29,7 @@ describe('cache-components-dev-warmup', () => {\n   ) {\n     // Match logs that contain the message, with any environment.\n     const logPattern = new RegExp(\n-      `^(?=.*\\\\b${message}\\\\b)(?=.*\\\\b(Cache|Prerender|Server)\\\\b).*`\n+      `^(?=.*\\\\b${message}\\\\b)(?=.*\\\\b(Cache|Prerender|Prefetch|Server)\\\\b).*`\n     )\n     const logMessages = logs.map((log) => log.message)\n     const messages = logMessages.filter((message) => logPattern.test(message))\n@@ -175,13 +175,13 @@ describe('cache-components-dev-warmup', () => {\n \n           // Private caches are dynamic holes in static prerenders,\n           // so they shouldn't resolve in the static stage.\n-          assertLog(logs, 'after private cache read - page', 'Server') // TODO: 'Runtime Prerender'\n-          assertLog(logs, 'after private cache read - layout', 'Server') // TODO: 'Runtime Prerender'\n+          assertLog(logs, 'after private cache read - page', 'Prefetch')\n+          assertLog(logs, 'after private cache read - layout', 'Prefetch')\n           assertLog(\n             logs,\n             'after successive private cache reads - page',\n-            'Server'\n-          ) // TODO: 'Runtime Prerender'\n+            'Prefetch'\n+          )\n \n           assertLog(logs, 'after uncached fetch - layout', 'Server')\n           assertLog(logs, 'after uncached fetch - page', 'Server')\n@@ -204,8 +204,8 @@ describe('cache-components-dev-warmup', () => {\n \n           // Short lived caches are dynamic holes in static prerenders,\n           // so they shouldn't resolve in the static stage.\n-          assertLog(logs, 'after short-lived cache read - page', 'Server')\n-          assertLog(logs, 'after short-lived cache read - layout', 'Server')\n+          assertLog(logs, 'after short-lived cache read - page', 'Prefetch')\n+          assertLog(logs, 'after short-lived cache read - layout', 'Prefetch')\n \n           assertLog(logs, 'after uncached fetch - layout', 'Server')\n           assertLog(logs, 'after uncached fetch - page', 'Server')\n@@ -246,18 +246,13 @@ describe('cache-components-dev-warmup', () => {\n         const logs = await browser.log()\n         assertLog(logs, 'after cache read - page', 'Prerender')\n \n-        for (const apiName of [\n-          'cookies',\n-          'headers',\n-          // TODO(restart-on-cache-miss): these two are currently broken/flaky,\n-          // because they're created outside of render and can resolve too early.\n-          // This will be fixed in a follow-up.\n-          // 'params',\n-          // 'searchParams',\n-          'connection',\n-        ]) {\n-          assertLog(logs, `after ${apiName}`, 'Server')\n-        }\n+        // TODO: we should only label this as \"Prefetch\" if there's a prefetch config.\n+        assertLog(logs, `after cookies`, 'Prefetch')\n+        assertLog(logs, `after headers`, 'Prefetch')\n+        assertLog(logs, `after params`, 'Prefetch')\n+        assertLog(logs, `after searchParams`, 'Prefetch')\n+\n+        assertLog(logs, 'after connection', 'Server')\n       }\n \n       if (isInitialLoad) {"
        }
    ],
    "stats": {
        "total": 542,
        "additions": 395,
        "deletions": 147
    }
}