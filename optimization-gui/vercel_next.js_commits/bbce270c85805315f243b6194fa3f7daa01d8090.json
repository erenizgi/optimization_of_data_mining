{
    "author": "acdlite",
    "message": "[Segment Cache] Fix: canonicalURL omits origin (#76444)\n\nThe canonical URL is the href without the origin. I think historically\nthe reason for this is because the initial canonical URL gets passed as\na prop to the top-level React component, which means it needs to be\ncomputed during SSR. If it were to include the origin, it would need to\nalways be same as location.origin on the client, to prevent a hydration\nmismatch. To sidestep this complexity, we omit the origin.\n\nHowever, since this is neither a native URL object nor a fully qualified\nURL string, we need to be careful about how we use it. To prevent subtle\nmistakes, we should create a special type for it, instead of just\nstring. Or, we should just use a (readonly) URL object instead. The type\nof the prop that we pass to seed the initial state does not need to be\nthe same type as the state itself.\n\nFor now, I've left the type as-is and fixed its handling in the Segment\nCache. This fixes a test that was failing because the origin was not\nbeing removed from the canonicalURL field. I'll refactor the type as a\nfollow-up.",
    "sha": "bbce270c85805315f243b6194fa3f7daa01d8090",
    "files": [
        {
            "sha": "d23f2379b2501e2d2f82371ae55400c3bdf6ba94",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 38,
            "changes": 78,
            "blob_url": "https://github.com/vercel/next.js/blob/bbce270c85805315f243b6194fa3f7daa01d8090/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bbce270c85805315f243b6194fa3f7daa01d8090/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=bbce270c85805315f243b6194fa3f7daa01d8090",
            "patch": "@@ -912,9 +912,10 @@ export async function fetchRouteOnCacheMiss(\n   }\n \n   // In output: \"export\" mode, we need to add the segment path to the URL.\n+  const url = new URL(href)\n   const requestUrl = isOutputExportMode\n-    ? addSegmentPathToUrlInOutputExportMode(href, segmentPath)\n-    : href\n+    ? addSegmentPathToUrlInOutputExportMode(url, segmentPath)\n+    : url\n \n   try {\n     const response = await fetchPrefetchResponse(requestUrl, headers)\n@@ -933,19 +934,30 @@ export async function fetchRouteOnCacheMiss(\n       return null\n     }\n \n-    // This is a bit convoluted but it's taken from router-reducer and\n-    // fetch-server-response\n-    const canonicalUrl = response.redirected\n-      ? createHrefFromUrl(\n-          new URL(\n-            removeSegmentPathFromURLInOutputExportMode(\n+    // TODO: The canonical URL is the href without the origin. I think\n+    // historically the reason for this is because the initial canonical URL\n+    // gets passed as a prop to the top-level React component, which means it\n+    // needs to be computed during SSR. If it were to include the origin, it\n+    // would need to always be same as location.origin on the client, to prevent\n+    // a hydration mismatch. To sidestep this complexity, we omit the origin.\n+    //\n+    // However, since this is neither a native URL object nor a fully qualified\n+    // URL string, we need to be careful about how we use it. To prevent subtle\n+    // mistakes, we should create a special type for it, instead of just string.\n+    // Or, we should just use a (readonly) URL object instead. The type of the\n+    // prop that we pass to seed the initial state does not need to be the same\n+    // type as the state itself.\n+    const canonicalUrl = createHrefFromUrl(\n+      new URL(\n+        response.redirected\n+          ? removeSegmentPathFromURLInOutputExportMode(\n               href,\n-              requestUrl,\n+              requestUrl.href,\n               response.url\n             )\n-          )\n-        )\n-      : href\n+          : href\n+      )\n+    )\n \n     // Check whether the response varies based on the Next-Url header.\n     const varyHeader = response.headers.get('vary')\n@@ -1072,21 +1084,12 @@ export async function fetchSegmentOnCacheMiss(\n   //\n   // Segment fetches are non-blocking so we don't need to ping the scheduler\n   // on completion.\n-  const href =\n-    route.canonicalUrl !== routeKey.href\n-      ? // The route was redirected. If we request the segment data using the\n-        // same URL, that request will be redirected, too. To avoid an extra\n-        // waterfall on every segment request, pass the redirected URL instead\n-        // of the original one.\n-        //\n-        // Since the redirected URL might be a relative path, we need to resolve\n-        // it against the original href, which is a fully qualified URL.\n-        //\n-        // TODO: We should just store the fully qualified URL as canonical URL.\n-        // There are other parts of the router that currently expect a relative\n-        // path, so need to update those, too.\n-        new URL(route.canonicalUrl, routeKey.href).href\n-      : routeKey.href\n+\n+  // Use the canonical URL to request the segment, not the original URL. These\n+  // are usually the same, but the canonical URL will be different if the route\n+  // tree response was redirected. To avoid an extra waterfall on every segment\n+  // request, we pass the redirected URL instead of the original one.\n+  const url = new URL(route.canonicalUrl, routeKey.href)\n   const nextUrl = routeKey.nextUrl\n \n   const normalizedSegmentPath =\n@@ -1109,11 +1112,10 @@ export async function fetchSegmentOnCacheMiss(\n     headers[NEXT_URL] = nextUrl\n   }\n \n-  // In output: \"export\" mode, we need to add the segment path to the URL.\n   const requestUrl = isOutputExportMode\n-    ? addSegmentPathToUrlInOutputExportMode(href, normalizedSegmentPath)\n-    : href\n-\n+    ? // In output: \"export\" mode, we need to add the segment path to the URL.\n+      addSegmentPathToUrlInOutputExportMode(url, normalizedSegmentPath)\n+    : url\n   try {\n     const response = await fetchPrefetchResponse(requestUrl, headers)\n     if (\n@@ -1191,7 +1193,7 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n   dynamicRequestTree: FlightRouterState,\n   spawnedEntries: Map<string, PendingSegmentCacheEntry>\n ): Promise<PrefetchSubtaskResult<null> | null> {\n-  const href = task.key.href\n+  const url = new URL(route.canonicalUrl, task.key.href)\n   const nextUrl = task.key.nextUrl\n   const headers: RequestHeaders = {\n     [RSC_HEADER]: '1',\n@@ -1210,7 +1212,7 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n     headers[NEXT_ROUTER_PREFETCH_HEADER] = '1'\n   }\n   try {\n-    const response = await fetchPrefetchResponse(href, headers)\n+    const response = await fetchPrefetchResponse(url, headers)\n     if (!response || !response.ok || !response.body) {\n       // Server responded with an error, or with a miss. We should still cache\n       // the response, but we can try again after 10 seconds.\n@@ -1492,11 +1494,11 @@ function writeSeedDataIntoCache(\n }\n \n async function fetchPrefetchResponse(\n-  href: string,\n+  url: URL,\n   headers: RequestHeaders\n ): Promise<Response | null> {\n   const fetchPriority = 'low'\n-  const response = await createFetch(new URL(href), headers, fetchPriority)\n+  const response = await createFetch(url, headers, fetchPriority)\n   if (!response.ok) {\n     return null\n   }\n@@ -1566,9 +1568,9 @@ function createPrefetchResponseStream(\n }\n \n function addSegmentPathToUrlInOutputExportMode(\n-  url: string,\n+  url: URL,\n   segmentPath: string\n-) {\n+): URL {\n   if (isOutputExportMode) {\n     // In output: \"export\" mode, we cannot use a header to encode the segment\n     // path. Instead, we append it to the end of the pathname.\n@@ -1579,7 +1581,7 @@ function addSegmentPathToUrlInOutputExportMode(\n     const staticExportFilename =\n       convertSegmentPathToStaticExportFilename(segmentPath)\n     staticUrl.pathname = `${routeDir}/${staticExportFilename}`\n-    return staticUrl.href\n+    return staticUrl\n   }\n   return url\n }"
        }
    ],
    "stats": {
        "total": 78,
        "additions": 40,
        "deletions": 38
    }
}