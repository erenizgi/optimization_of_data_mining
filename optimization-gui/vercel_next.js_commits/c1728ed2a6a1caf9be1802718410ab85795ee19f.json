{
    "author": "gnoff",
    "message": "Simplify Metadata components (#84527)\n\nMetadata and Viewport litter the component tree with a number of Next.js\ninternal implementation details. We can't yet get rid of all of these\nbut we can simplify by consolidating these components or eliminating\nthem altogether.\n\nOne change is to render the metadata as a promise that resolves direclty\nto the client tags that must be in the head. Another is to render a\npromise that will directly reject with the error reason rather than\nreconstructing a digest manually.\n\nIn the process I removed a bunch of module indirection too",
    "sha": "c1728ed2a6a1caf9be1802718410ab85795ee19f",
    "files": [
        {
            "sha": "c1dde1dc2426545528a50e896fd928d92b3f7b57",
            "filename": "packages/next/src/client/components/metadata/async-metadata.tsx",
            "status": "removed",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/e974ca937b2ca0e5cacaa118027765d5a23c605c/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fmetadata%2Fasync-metadata.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/e974ca937b2ca0e5cacaa118027765d5a23c605c/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fmetadata%2Fasync-metadata.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fmetadata%2Fasync-metadata.tsx?ref=e974ca937b2ca0e5cacaa118027765d5a23c605c",
            "patch": "@@ -1,33 +0,0 @@\n-'use client'\n-\n-import { Suspense, use } from 'react'\n-import type { StreamingMetadataResolvedState } from './types'\n-\n-function MetadataOutlet({\n-  promise,\n-}: {\n-  promise: Promise<StreamingMetadataResolvedState>\n-}) {\n-  const { error, digest } = use(promise)\n-  if (error) {\n-    if (digest) {\n-      // The error will lose its original digest after passing from server layer to client layerï¼›\n-      // We recover the digest property here to override the React created one if original digest exists.\n-      ;(error as any).digest = digest\n-    }\n-    throw error\n-  }\n-  return null\n-}\n-\n-export function AsyncMetadataOutlet({\n-  promise,\n-}: {\n-  promise: Promise<StreamingMetadataResolvedState>\n-}) {\n-  return (\n-    <Suspense fallback={null}>\n-      <MetadataOutlet promise={promise} />\n-    </Suspense>\n-  )\n-}"
        },
        {
            "sha": "0a45b6a13960e7e19de4e371fbb41c1ddb516507",
            "filename": "packages/next/src/client/components/metadata/types.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/e974ca937b2ca0e5cacaa118027765d5a23c605c/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fmetadata%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e974ca937b2ca0e5cacaa118027765d5a23c605c/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fmetadata%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fmetadata%2Ftypes.ts?ref=e974ca937b2ca0e5cacaa118027765d5a23c605c",
            "patch": "@@ -1,5 +0,0 @@\n-export type StreamingMetadataResolvedState = {\n-  metadata: React.ReactNode\n-  error: unknown | null\n-  digest: string | undefined\n-}"
        },
        {
            "sha": "475ecd480d35401d2fdc59da3c530f9b26c9dafc",
            "filename": "packages/next/src/lib/metadata/metadata.tsx",
            "status": "modified",
            "additions": 103,
            "deletions": 152,
            "changes": 255,
            "blob_url": "https://github.com/vercel/next.js/blob/c1728ed2a6a1caf9be1802718410ab85795ee19f/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fmetadata.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c1728ed2a6a1caf9be1802718410ab85795ee19f/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fmetadata.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fmetadata%2Fmetadata.tsx?ref=c1728ed2a6a1caf9be1802718410ab85795ee19f",
            "patch": "@@ -2,7 +2,6 @@ import React, { Suspense, cache, cloneElement } from 'react'\n import type { ParsedUrlQuery } from 'querystring'\n import type { GetDynamicParamFromSegment } from '../../server/app-render/app-render'\n import type { LoaderTree } from '../../server/lib/app-dir-module'\n-import type { StreamingMetadataResolvedState } from '../../client/components/metadata/types'\n import type { SearchParams } from '../../server/request/search-params'\n import {\n   AppleWebAppMeta,\n@@ -34,14 +33,15 @@ import type {\n import { isHTTPAccessFallbackError } from '../../client/components/http-access-fallback/http-access-fallback'\n import type { MetadataContext } from './types/resolvers'\n import type { WorkStore } from '../../server/app-render/work-async-storage.external'\n-import {\n-  METADATA_BOUNDARY_NAME,\n-  VIEWPORT_BOUNDARY_NAME,\n-} from '../framework/boundary-constants'\n-import { AsyncMetadataOutlet } from '../../client/components/metadata/async-metadata'\n-import { isPostpone } from '../../server/lib/router-utils/is-postpone'\n import { createServerSearchParamsForMetadata } from '../../server/request/search-params'\n import { createServerPathnameForMetadata } from '../../server/request/pathname'\n+import { isPostpone } from '../../server/lib/router-utils/is-postpone'\n+\n+import {\n+  MetadataBoundary,\n+  ViewportBoundary,\n+  OutletBoundary,\n+} from '../framework/boundary-components'\n \n // Use a promise to share the status of the metadata resolving,\n // returning two components `MetadataTree` and `MetadataOutlet`\n@@ -55,30 +55,22 @@ export function createMetadataComponents({\n   parsedQuery,\n   metadataContext,\n   getDynamicParamFromSegment,\n-  appUsingSizeAdjustment,\n   errorType,\n   workStore,\n-  MetadataBoundary,\n-  ViewportBoundary,\n   serveStreamingMetadata,\n }: {\n   tree: LoaderTree\n   pathname: string\n   parsedQuery: SearchParams\n   metadataContext: MetadataContext\n   getDynamicParamFromSegment: GetDynamicParamFromSegment\n-  appUsingSizeAdjustment: boolean\n   errorType?: MetadataErrorType | 'redirect'\n   workStore: WorkStore\n-  MetadataBoundary: (props: { children: React.ReactNode }) => React.ReactNode\n-  ViewportBoundary: (props: { children: React.ReactNode }) => React.ReactNode\n   serveStreamingMetadata: boolean\n }): {\n-  MetadataTree: React.ComponentType\n-  ViewportTree: React.ComponentType\n-  getMetadataReady: () => Promise<void>\n-  getViewportReady: () => Promise<void>\n-  StreamingMetadataOutlet: React.ComponentType | null\n+  Viewport: React.ComponentType\n+  Metadata: React.ComponentType\n+  MetadataOutlet: React.ComponentType\n } {\n   const searchParams = createServerSearchParamsForMetadata(\n     parsedQuery,\n@@ -89,174 +81,133 @@ export function createMetadataComponents({\n     workStore\n   )\n \n-  function ViewportTree() {\n-    return (\n-      <>\n-        <ViewportBoundary>\n-          <Viewport />\n-        </ViewportBoundary>\n-        {/* This meta tag is for next/font which is still required to be blocking. */}\n-        {appUsingSizeAdjustment ? (\n-          <meta name=\"next-size-adjust\" content=\"\" />\n-        ) : null}\n-      </>\n-    )\n-  }\n-\n-  function MetadataTree() {\n-    return (\n-      <MetadataBoundary>\n-        <Metadata />\n-      </MetadataBoundary>\n-    )\n-  }\n-\n-  function viewport() {\n-    return getResolvedViewport(\n+  function Viewport() {\n+    const pendingViewportTags = getResolvedViewport(\n       tree,\n       searchParams,\n       getDynamicParamFromSegment,\n       workStore,\n       errorType\n-    )\n-  }\n-\n-  async function Viewport() {\n-    try {\n-      return await viewport()\n-    } catch (error) {\n-      if (!errorType && isHTTPAccessFallbackError(error)) {\n-        try {\n-          return await getNotFoundViewport(\n-            tree,\n-            searchParams,\n-            getDynamicParamFromSegment,\n-            workStore\n-          )\n-        } catch {}\n+    ).catch((viewportErr) => {\n+      // When Legacy PPR is enabled viewport can reject with a Postpone type\n+      // This will go away once Legacy PPR is removed and dynamic metadata will\n+      // stay pending until after the prerender is complete when it is dynamic\n+      if (isPostpone(viewportErr)) {\n+        throw viewportErr\n+      }\n+      if (!errorType && isHTTPAccessFallbackError(viewportErr)) {\n+        return getNotFoundViewport(\n+          tree,\n+          searchParams,\n+          getDynamicParamFromSegment,\n+          workStore\n+        ).catch(() => null)\n       }\n-      // We don't actually want to error in this component. We will\n-      // also error in the MetadataOutlet which causes the error to\n-      // bubble from the right position in the page to be caught by the\n-      // appropriate boundaries\n+      // We're going to throw the error from the metadata outlet so we just render null here instead\n       return null\n-    }\n+    })\n+\n+    return (\n+      <ViewportBoundary>\n+        {/* @ts-expect-error -- Promise<ReactNode> not considered a valid child even though it is */}\n+        {pendingViewportTags}\n+      </ViewportBoundary>\n+    )\n   }\n-  Viewport.displayName = VIEWPORT_BOUNDARY_NAME\n+  Viewport.displayName = 'Next.Viewport'\n \n-  function metadata() {\n-    return getResolvedMetadata(\n+  function Metadata() {\n+    const pendingMetadataTags = getResolvedMetadata(\n       tree,\n       pathnameForMetadata,\n       searchParams,\n       getDynamicParamFromSegment,\n       metadataContext,\n       workStore,\n       errorType\n-    )\n-  }\n-\n-  async function resolveFinalMetadata(): Promise<StreamingMetadataResolvedState> {\n-    let result: React.ReactNode\n-    let error = null\n-    try {\n-      result = await metadata()\n-      return {\n-        metadata: result,\n-        error: null,\n-        digest: undefined,\n-      }\n-    } catch (metadataErr) {\n-      error = metadataErr\n-      if (!errorType && isHTTPAccessFallbackError(metadataErr)) {\n-        try {\n-          result = await getNotFoundMetadata(\n-            tree,\n-            pathnameForMetadata,\n-            searchParams,\n-            getDynamicParamFromSegment,\n-            metadataContext,\n-            workStore\n-          )\n-          return {\n-            metadata: result,\n-            error,\n-            digest: (error as any)?.digest,\n-          }\n-        } catch (notFoundMetadataErr) {\n-          error = notFoundMetadataErr\n-          // In PPR rendering we still need to throw the postpone error.\n-          // If metadata is postponed, React needs to be aware of the location of error.\n-          if (serveStreamingMetadata && isPostpone(notFoundMetadataErr)) {\n-            throw notFoundMetadataErr\n-          }\n-        }\n-      }\n-      // In PPR rendering we still need to throw the postpone error.\n-      // If metadata is postponed, React needs to be aware of the location of error.\n-      if (serveStreamingMetadata && isPostpone(metadataErr)) {\n+    ).catch((metadataErr) => {\n+      // When Legacy PPR is enabled metadata can reject with a Postpone type\n+      // This will go away once Legacy PPR is removed and dynamic metadata will\n+      // stay pending until after the prerender is complete when it is dynamic\n+      if (isPostpone(metadataErr)) {\n         throw metadataErr\n       }\n-      // We don't actually want to error in this component. We will\n-      // also error in the MetadataOutlet which causes the error to\n-      // bubble from the right position in the page to be caught by the\n-      // appropriate boundaries\n-      return {\n-        metadata: result,\n-        error,\n-        digest: (error as any)?.digest,\n+      if (!errorType && isHTTPAccessFallbackError(metadataErr)) {\n+        return getNotFoundMetadata(\n+          tree,\n+          pathnameForMetadata,\n+          searchParams,\n+          getDynamicParamFromSegment,\n+          metadataContext,\n+          workStore\n+        ).catch(() => null)\n       }\n-    }\n-  }\n+      // We're going to throw the error from the metadata outlet so we just render null here instead\n+      return null\n+    })\n \n-  function Metadata() {\n+    // TODO: We shouldn't change what we render based on whether we are streaming or not.\n+    // If we aren't streaming we should just block the response until we have resolved the\n+    // metadata.\n     if (!serveStreamingMetadata) {\n-      return <MetadataResolver />\n+      return (\n+        <MetadataBoundary>\n+          {/* @ts-expect-error -- Promise<ReactNode> not considered a valid child even though it is */}\n+          {pendingMetadataTags}\n+        </MetadataBoundary>\n+      )\n     }\n     return (\n       <div hidden>\n-        <Suspense fallback={null}>\n-          <MetadataResolver />\n-        </Suspense>\n+        <MetadataBoundary>\n+          <Suspense name=\"Next.Metadata\">\n+            {/* @ts-expect-error -- Promise<ReactNode> not considered a valid child even though it is */}\n+            {pendingMetadataTags}\n+          </Suspense>\n+        </MetadataBoundary>\n       </div>\n     )\n   }\n+  Metadata.displayName = 'Next.Metadata'\n \n-  async function MetadataResolver() {\n-    const metadataState = await resolveFinalMetadata()\n-    return metadataState.metadata\n-  }\n-\n-  Metadata.displayName = METADATA_BOUNDARY_NAME\n+  function MetadataOutlet() {\n+    const pendingOutlet = Promise.all([\n+      getResolvedMetadata(\n+        tree,\n+        pathnameForMetadata,\n+        searchParams,\n+        getDynamicParamFromSegment,\n+        metadataContext,\n+        workStore,\n+        errorType\n+      ),\n+      getResolvedViewport(\n+        tree,\n+        searchParams,\n+        getDynamicParamFromSegment,\n+        workStore,\n+        errorType\n+      ),\n+    ]).then(() => null)\n \n-  async function getMetadataReady(): Promise<void> {\n-    // Only warm up metadata() call when it's blocking metadata,\n-    // otherwise it will be fully managed by AsyncMetadata component.\n+    // TODO: We shouldn't change what we render based on whether we are streaming or not.\n+    // If we aren't streaming we should just block the response until we have resolved the\n+    // metadata.\n     if (!serveStreamingMetadata) {\n-      await metadata()\n+      return <OutletBoundary>{pendingOutlet}</OutletBoundary>\n     }\n-    return undefined\n-  }\n-\n-  async function getViewportReady(): Promise<void> {\n-    await viewport()\n-    return undefined\n-  }\n-\n-  function StreamingMetadataOutletImpl() {\n-    return <AsyncMetadataOutlet promise={resolveFinalMetadata()} />\n+    return (\n+      <OutletBoundary>\n+        <Suspense name=\"Next.MetadataOutlet\">{pendingOutlet}</Suspense>\n+      </OutletBoundary>\n+    )\n   }\n-\n-  const StreamingMetadataOutlet = serveStreamingMetadata\n-    ? StreamingMetadataOutletImpl\n-    : null\n+  MetadataOutlet.displayName = 'Next.MetadataOutlet'\n \n   return {\n-    ViewportTree,\n-    MetadataTree,\n-    getViewportReady,\n-    getMetadataReady,\n-    StreamingMetadataOutlet,\n+    Viewport,\n+    Metadata,\n+    MetadataOutlet,\n   }\n }\n "
        },
        {
            "sha": "7192fac42c29d2ac833828f141c7f5d441c565da",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 17,
            "deletions": 50,
            "changes": 67,
            "blob_url": "https://github.com/vercel/next.js/blob/c1728ed2a6a1caf9be1802718410ab85795ee19f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c1728ed2a6a1caf9be1802718410ab85795ee19f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=c1728ed2a6a1caf9be1802718410ab85795ee19f",
            "patch": "@@ -448,11 +448,8 @@ async function generateDynamicRSCPayload(\n         userland: { loaderTree },\n       },\n       createMetadataComponents,\n-      MetadataBoundary,\n-      ViewportBoundary,\n     },\n     getDynamicParamFromSegment,\n-    appUsingSizeAdjustment,\n     query,\n     requestId,\n     flightRouterState,\n@@ -465,22 +462,13 @@ async function generateDynamicRSCPayload(\n   if (!options?.skipFlight) {\n     const preloadCallbacks: PreloadCallbacks = []\n \n-    const {\n-      ViewportTree,\n-      MetadataTree,\n-      getViewportReady,\n-      getMetadataReady,\n-      StreamingMetadataOutlet,\n-    } = createMetadataComponents({\n+    const { Viewport, Metadata, MetadataOutlet } = createMetadataComponents({\n       tree: loaderTree,\n       parsedQuery: query,\n       pathname: url.pathname,\n       metadataContext: createMetadataContext(ctx.renderOpts),\n       getDynamicParamFromSegment,\n-      appUsingSizeAdjustment,\n       workStore,\n-      MetadataBoundary,\n-      ViewportBoundary,\n       serveStreamingMetadata,\n     })\n \n@@ -500,18 +488,16 @@ async function generateDynamicRSCPayload(\n               isPossibleServerAction={ctx.isPossibleServerAction}\n             />\n             {/* Adding requestId as react key to make metadata remount for each render */}\n-            <ViewportTree key={getFlightViewportKey(requestId)} />\n-            <MetadataTree key={getFlightMetadataKey(requestId)} />\n+            <Viewport key={getFlightViewportKey(requestId)} />\n+            <Metadata key={getFlightMetadataKey(requestId)} />\n           </React.Fragment>\n         ),\n         injectedCSS: new Set(),\n         injectedJS: new Set(),\n         injectedFontPreloadTags: new Set(),\n         rootLayoutIncluded: false,\n-        getViewportReady,\n-        getMetadataReady,\n         preloadCallbacks,\n-        StreamingMetadataOutlet,\n+        MetadataOutlet,\n       })\n     ).map((path) => path.slice(1)) // remove the '' (root) segment\n   }\n@@ -1119,11 +1105,7 @@ async function getRSCPayload(\n     getDynamicParamFromSegment,\n     query,\n     appUsingSizeAdjustment,\n-    componentMod: {\n-      createMetadataComponents,\n-      MetadataBoundary,\n-      ViewportBoundary,\n-    },\n+    componentMod: { createMetadataComponents },\n     url,\n     workStore,\n   } = ctx\n@@ -1136,13 +1118,7 @@ async function getRSCPayload(\n   const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n   const hasGlobalNotFound = !!tree[2]['global-not-found']\n \n-  const {\n-    ViewportTree,\n-    MetadataTree,\n-    getViewportReady,\n-    getMetadataReady,\n-    StreamingMetadataOutlet,\n-  } = createMetadataComponents({\n+  const { Viewport, Metadata, MetadataOutlet } = createMetadataComponents({\n     tree,\n     // When it's using global-not-found, metadata errorType is undefined, which will retrieve the\n     // metadata from the page.\n@@ -1154,10 +1130,7 @@ async function getRSCPayload(\n     pathname: url.pathname,\n     metadataContext: createMetadataContext(ctx.renderOpts),\n     getDynamicParamFromSegment,\n-    appUsingSizeAdjustment,\n     workStore,\n-    MetadataBoundary,\n-    ViewportBoundary,\n     serveStreamingMetadata,\n   })\n \n@@ -1171,12 +1144,10 @@ async function getRSCPayload(\n     injectedJS,\n     injectedFontPreloadTags,\n     rootLayoutIncluded: false,\n-    getViewportReady,\n-    getMetadataReady,\n     missingSlots,\n     preloadCallbacks,\n     authInterrupts: ctx.renderOpts.experimental.authInterrupts,\n-    StreamingMetadataOutlet,\n+    MetadataOutlet,\n   })\n \n   // When the `vary` response header is present with `Next-URL`, that means there's a chance\n@@ -1193,8 +1164,12 @@ async function getRSCPayload(\n         statusCode={ctx.res.statusCode}\n         isPossibleServerAction={ctx.isPossibleServerAction}\n       />\n-      <ViewportTree />\n-      <MetadataTree />\n+      <Viewport />\n+      <Metadata />\n+      {/* This meta tag is for next/font which is still required to be blocking. */}\n+      {appUsingSizeAdjustment ? (\n+        <meta name=\"next-size-adjust\" content=\"\" />\n+      ) : null}\n     </React.Fragment>\n   )\n \n@@ -1255,28 +1230,20 @@ async function getErrorRSCPayload(\n   const {\n     getDynamicParamFromSegment,\n     query,\n-    appUsingSizeAdjustment,\n-    componentMod: {\n-      createMetadataComponents,\n-      MetadataBoundary,\n-      ViewportBoundary,\n-    },\n+    componentMod: { createMetadataComponents },\n     url,\n     workStore,\n   } = ctx\n \n   const serveStreamingMetadata = !!ctx.renderOpts.serveStreamingMetadata\n-  const { MetadataTree, ViewportTree } = createMetadataComponents({\n+  const { Viewport, Metadata } = createMetadataComponents({\n     tree,\n     parsedQuery: query,\n     pathname: url.pathname,\n     metadataContext: createMetadataContext(ctx.renderOpts),\n     errorType,\n     getDynamicParamFromSegment,\n-    appUsingSizeAdjustment,\n     workStore,\n-    MetadataBoundary,\n-    ViewportBoundary,\n     serveStreamingMetadata: serveStreamingMetadata,\n   })\n \n@@ -1287,11 +1254,11 @@ async function getErrorRSCPayload(\n         statusCode={ctx.res.statusCode}\n         isPossibleServerAction={ctx.isPossibleServerAction}\n       />\n-      <ViewportTree />\n+      <Viewport />\n       {process.env.NODE_ENV === 'development' && (\n         <meta name=\"next-error\" content=\"not-found\" />\n       )}\n-      <MetadataTree />\n+      <Metadata />\n     </React.Fragment>\n   )\n "
        },
        {
            "sha": "0d323fe571a5007f9bfc0244f52df5f5de19351b",
            "filename": "packages/next/src/server/app-render/create-component-tree.tsx",
            "status": "modified",
            "additions": 5,
            "deletions": 49,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/c1728ed2a6a1caf9be1802718410ab85795ee19f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c1728ed2a6a1caf9be1802718410ab85795ee19f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx?ref=c1728ed2a6a1caf9be1802718410ab85795ee19f",
            "patch": "@@ -23,7 +23,6 @@ import { NextNodeServerSpan } from '../lib/trace/constants'\n import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\n import type { Params } from '../request/params'\n import { workUnitAsyncStorage } from './work-unit-async-storage.external'\n-import { OUTLET_BOUNDARY_NAME } from '../../lib/framework/boundary-constants'\n import type {\n   UseCacheLayoutProps,\n   UseCachePageProps,\n@@ -48,13 +47,11 @@ export function createComponentTree(props: {\n   injectedCSS: Set<string>\n   injectedJS: Set<string>\n   injectedFontPreloadTags: Set<string>\n-  getMetadataReady: () => Promise<void>\n-  getViewportReady: () => Promise<void>\n   ctx: AppRenderContext\n   missingSlots?: Set<string>\n   preloadCallbacks: PreloadCallbacks\n   authInterrupts: boolean\n-  StreamingMetadataOutlet: React.ComponentType | null\n+  MetadataOutlet: React.ComponentType\n }): Promise<CacheNodeSeedData> {\n   return getTracer().trace(\n     NextNodeServerSpan.createComponentTree,\n@@ -85,27 +82,23 @@ async function createComponentTreeInternal(\n     injectedCSS,\n     injectedJS,\n     injectedFontPreloadTags,\n-    getViewportReady,\n-    getMetadataReady,\n     ctx,\n     missingSlots,\n     preloadCallbacks,\n     authInterrupts,\n-    StreamingMetadataOutlet,\n+    MetadataOutlet,\n   }: {\n     loaderTree: LoaderTree\n     parentParams: Params\n     rootLayoutIncluded: boolean\n     injectedCSS: Set<string>\n     injectedJS: Set<string>\n     injectedFontPreloadTags: Set<string>\n-    getViewportReady: () => Promise<void>\n-    getMetadataReady: () => Promise<void>\n     ctx: AppRenderContext\n     missingSlots?: Set<string>\n     preloadCallbacks: PreloadCallbacks\n     authInterrupts: boolean\n-    StreamingMetadataOutlet: React.ComponentType | null\n+    MetadataOutlet: React.ComponentType | null\n   },\n   isRoot: boolean\n ): Promise<CacheNodeSeedData> {\n@@ -117,7 +110,6 @@ async function createComponentTreeInternal(\n       HTTPAccessFallbackBoundary,\n       LayoutRouter,\n       RenderFromTemplateContext,\n-      OutletBoundary,\n       ClientPageRoot,\n       ClientSegmentRoot,\n       createServerSearchParamsForServerPage,\n@@ -428,13 +420,6 @@ async function createComponentTreeInternal(\n       ? process.env.__NEXT_EDGE_PROJECT_DIR\n       : ctx.renderOpts.dir) || ''\n \n-  // Use the same condition to render metadataOutlet as metadata\n-  const metadataOutlet = StreamingMetadataOutlet ? (\n-    <StreamingMetadataOutlet />\n-  ) : (\n-    <MetadataOutlet ready={getMetadataReady} />\n-  )\n-\n   const [notFoundElement, notFoundFilePath] =\n     await createBoundaryConventionElement({\n       ctx,\n@@ -544,23 +529,13 @@ async function createComponentTreeInternal(\n               injectedCSS: injectedCSSWithCurrentLayout,\n               injectedJS: injectedJSWithCurrentLayout,\n               injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n-              // `getMetadataReady` and `getViewportReady` are used to conditionally throw. In the case of parallel routes we will have more than one page\n-              // but we only want to throw on the first one.\n-              getMetadataReady: isChildrenRouteKey\n-                ? getMetadataReady\n-                : () => Promise.resolve(),\n-              getViewportReady: isChildrenRouteKey\n-                ? getViewportReady\n-                : () => Promise.resolve(),\n               ctx,\n               missingSlots,\n               preloadCallbacks,\n               authInterrupts,\n               // `StreamingMetadataOutlet` is used to conditionally throw. In the case of parallel routes we will have more than one page\n               // but we only want to throw on the first one.\n-              StreamingMetadataOutlet: isChildrenRouteKey\n-                ? StreamingMetadataOutlet\n-                : null,\n+              MetadataOutlet: isChildrenRouteKey ? MetadataOutlet : null,\n             },\n             false\n           )\n@@ -833,10 +808,7 @@ async function createComponentTreeInternal(\n       <React.Fragment key={cacheNodeKey}>\n         {wrappedPageElement}\n         {layerAssets}\n-        <OutletBoundary>\n-          <MetadataOutlet ready={getViewportReady} />\n-          {metadataOutlet}\n-        </OutletBoundary>\n+        {MetadataOutlet ? <MetadataOutlet /> : null}\n       </React.Fragment>,\n       parallelRouteCacheNodeSeedData,\n       loadingData,\n@@ -1024,22 +996,6 @@ async function createComponentTreeInternal(\n   }\n }\n \n-async function MetadataOutlet({\n-  ready,\n-}: {\n-  ready: () => Promise<void> & { status?: string; value?: unknown }\n-}) {\n-  const r = ready()\n-  // We can avoid a extra microtask by unwrapping the instrumented promise directly if available.\n-  if (r.status === 'rejected') {\n-    throw r.value\n-  } else if (r.status !== 'fulfilled') {\n-    await r\n-  }\n-  return null\n-}\n-MetadataOutlet.displayName = OUTLET_BOUNDARY_NAME\n-\n function createErrorBoundaryClientSegmentRoot({\n   ErrorBoundaryComponent,\n   errorElement,"
        },
        {
            "sha": "e5a787ab4d86afc5527424d0bad413b2e6982565",
            "filename": "packages/next/src/server/app-render/entry-base.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 6,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/c1728ed2a6a1caf9be1802718410ab85795ee19f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fentry-base.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c1728ed2a6a1caf9be1802718410ab85795ee19f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fentry-base.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fentry-base.ts?ref=c1728ed2a6a1caf9be1802718410ab85795ee19f",
            "patch": "@@ -32,12 +32,7 @@ export {\n export * as serverHooks from '../../client/components/hooks-server-context'\n export { HTTPAccessFallbackBoundary } from '../../client/components/http-access-fallback/error-boundary'\n export { createMetadataComponents } from '../../lib/metadata/metadata'\n-export {\n-  MetadataBoundary,\n-  ViewportBoundary,\n-  OutletBoundary,\n-  RootLayoutBoundary,\n-} from '../../lib/framework/boundary-components'\n+export { RootLayoutBoundary } from '../../lib/framework/boundary-components'\n \n export { preloadStyle, preloadFont, preconnect } from './rsc/preloads'\n export { Postpone } from './rsc/postpone'"
        },
        {
            "sha": "ee1d57854d281fe5f044297baf04ddcec28c0c9e",
            "filename": "packages/next/src/server/app-render/walk-tree-with-flight-router-state.tsx",
            "status": "modified",
            "additions": 4,
            "deletions": 12,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/c1728ed2a6a1caf9be1802718410ab85795ee19f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwalk-tree-with-flight-router-state.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c1728ed2a6a1caf9be1802718410ab85795ee19f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwalk-tree-with-flight-router-state.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwalk-tree-with-flight-router-state.tsx?ref=c1728ed2a6a1caf9be1802718410ab85795ee19f",
            "patch": "@@ -34,11 +34,9 @@ export async function walkTreeWithFlightRouterState({\n   injectedJS,\n   injectedFontPreloadTags,\n   rootLayoutIncluded,\n-  getViewportReady,\n-  getMetadataReady,\n   ctx,\n   preloadCallbacks,\n-  StreamingMetadataOutlet,\n+  MetadataOutlet,\n }: {\n   loaderTreeToFilter: LoaderTree\n   parentParams: { [key: string]: string | string[] }\n@@ -49,11 +47,9 @@ export async function walkTreeWithFlightRouterState({\n   injectedJS: Set<string>\n   injectedFontPreloadTags: Set<string>\n   rootLayoutIncluded: boolean\n-  getMetadataReady: () => Promise<void>\n-  getViewportReady: () => Promise<void>\n   ctx: AppRenderContext\n   preloadCallbacks: PreloadCallbacks\n-  StreamingMetadataOutlet: React.ComponentType | null\n+  MetadataOutlet: React.ComponentType\n }): Promise<FlightDataPath[]> {\n   const {\n     renderOpts: { nextFontManifest, experimental },\n@@ -228,11 +224,9 @@ export async function walkTreeWithFlightRouterState({\n         injectedFontPreloadTags,\n         // This is intentionally not \"rootLayoutIncludedAtThisLevelOrAbove\" as createComponentTree starts at the current level and does a check for \"rootLayoutAtThisLevel\" too.\n         rootLayoutIncluded,\n-        getViewportReady,\n-        getMetadataReady,\n         preloadCallbacks,\n         authInterrupts: experimental.authInterrupts,\n-        StreamingMetadataOutlet,\n+        MetadataOutlet,\n       }\n     )\n \n@@ -289,10 +283,8 @@ export async function walkTreeWithFlightRouterState({\n       injectedJS: injectedJSWithCurrentLayout,\n       injectedFontPreloadTags: injectedFontPreloadTagsWithCurrentLayout,\n       rootLayoutIncluded: rootLayoutIncludedAtThisLevelOrAbove,\n-      getViewportReady,\n-      getMetadataReady,\n       preloadCallbacks,\n-      StreamingMetadataOutlet,\n+      MetadataOutlet,\n     })\n \n     for (const subPath of subPaths) {"
        },
        {
            "sha": "5cf2ee50f3b22be8e4467e07ee9bc89ecd93393d",
            "filename": "test/e2e/opentelemetry/instrumentation/opentelemetry.test.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/c1728ed2a6a1caf9be1802718410ab85795ee19f/test%2Fe2e%2Fopentelemetry%2Finstrumentation%2Fopentelemetry.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c1728ed2a6a1caf9be1802718410ab85795ee19f/test%2Fe2e%2Fopentelemetry%2Finstrumentation%2Fopentelemetry.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fopentelemetry%2Finstrumentation%2Fopentelemetry.test.ts?ref=c1728ed2a6a1caf9be1802718410ab85795ee19f",
            "patch": "@@ -170,7 +170,7 @@ describe('opentelemetry', () => {\n                       },\n                       {\n                         attributes: {\n-                          'next.clientComponentLoadCount': isNextDev ? 8 : 7,\n+                          'next.clientComponentLoadCount': isNextDev ? 7 : 6,\n                           'next.span_type':\n                             'NextNodeServer.clientComponentLoading',\n                         },\n@@ -578,7 +578,7 @@ describe('opentelemetry', () => {\n                       },\n                       {\n                         attributes: {\n-                          'next.clientComponentLoadCount': isNextDev ? 11 : 8,\n+                          'next.clientComponentLoadCount': isNextDev ? 10 : 8,\n                           'next.span_type':\n                             'NextNodeServer.clientComponentLoading',\n                         },\n@@ -1063,6 +1063,7 @@ describe('opentelemetry with disabled fetch tracing', () => {\n \n   afterEach(async () => {\n     await collector.shutdown()\n+    await new Promise((r) => setTimeout(r, 1000))\n   })\n   ;(process.env.__NEXT_EXPERIMENTAL_PPR ? describe.skip : describe)(\n     'root context',"
        }
    ],
    "stats": {
        "total": 442,
        "additions": 133,
        "deletions": 309
    }
}