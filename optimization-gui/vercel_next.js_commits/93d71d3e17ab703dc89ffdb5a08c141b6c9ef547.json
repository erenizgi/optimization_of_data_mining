{
    "author": "mischnic",
    "message": "Turbopack: fix duplicate module from internal ref (#78194)\n\nA module that was referenced using a `ReferenceType::Internal` and some other non-internal reference type would lead to a duplicated module, because the internal reference always got its own module.\r\n\r\n\r\nThere are various places where we could do the check I added, but this is one of the sources:\r\n\r\nhttps://github.com/vercel/next.js/blob/4509bf240a3327be168ae0035bd578752676b3ec/turbopack/crates/turbopack/src/lib.rs#L501-L504\r\n\r\nThe bug occured because of these two factors:\r\n\r\n- `Option<Vc<Vec<...>>` is just bad at uniquely modelling state (because `None` and `Some(vec![])` really are the same thing but not according to turbo-tasks).\r\n\r\n- And then having different two `new` constructors that aren't completely disjoint (with the None vs empty vector case above).",
    "sha": "93d71d3e17ab703dc89ffdb5a08c141b6c9ef547",
    "files": [
        {
            "sha": "49be4852b6e587fbb3ef01721946f531f20923fd",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 12,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/93d71d3e17ab703dc89ffdb5a08c141b6c9ef547/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/93d71d3e17ab703dc89ffdb5a08c141b6c9ef547/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=93d71d3e17ab703dc89ffdb5a08c141b6c9ef547",
            "patch": "@@ -503,25 +503,36 @@ impl EcmascriptModuleAsset {\n     }\n \n     #[turbo_tasks::function]\n-    pub fn new_with_inner_assets(\n+    pub async fn new_with_inner_assets(\n         source: ResolvedVc<Box<dyn Source>>,\n         asset_context: ResolvedVc<Box<dyn AssetContext>>,\n         ty: Value<EcmascriptModuleAssetType>,\n         transforms: ResolvedVc<EcmascriptInputTransforms>,\n         options: ResolvedVc<EcmascriptOptions>,\n         compile_time_info: ResolvedVc<CompileTimeInfo>,\n         inner_assets: ResolvedVc<InnerAssets>,\n-    ) -> Vc<Self> {\n-        Self::cell(EcmascriptModuleAsset {\n-            source,\n-            asset_context,\n-            ty: ty.into_value(),\n-            transforms,\n-            options,\n-            compile_time_info,\n-            inner_assets: Some(inner_assets),\n-            last_successful_parse: Default::default(),\n-        })\n+    ) -> Result<Vc<Self>> {\n+        if inner_assets.await?.is_empty() {\n+            Ok(Self::new(\n+                *source,\n+                *asset_context,\n+                ty,\n+                *transforms,\n+                *options,\n+                *compile_time_info,\n+            ))\n+        } else {\n+            Ok(Self::cell(EcmascriptModuleAsset {\n+                source,\n+                asset_context,\n+                ty: ty.into_value(),\n+                transforms,\n+                options,\n+                compile_time_info,\n+                inner_assets: Some(inner_assets),\n+                last_successful_parse: Default::default(),\n+            }))\n+        }\n     }\n \n     #[turbo_tasks::function]"
        }
    ],
    "stats": {
        "total": 35,
        "additions": 23,
        "deletions": 12
    }
}