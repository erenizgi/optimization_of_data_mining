{
    "author": "lubieowoce",
    "message": "fix: respond with 404 for unrecognized action ids (#77012)\n\n> [!IMPORTANT]  \n> view this diff with \"hide whitespace changes\", it's unreadable\notherwise.\n\nThis is an alternative approach to #80613. We touch a lot of same areas\nbut do different changes there, and i also have a bunch more changes\nstacked on top, so the plan is to just revert that and do this instead.\n\n---\n\nserver action calls with an unrecognized action id (i.e. one not found\nin `serverModuleMap`) have been returning a 200 instead of a 404 for\nquite some time. and also rendering the page they were called on.\n\n### The problem\n\nthis happened due to an unfortunate mistake. `handleAction` has a\nsection like this:\n```ts\nawait actionAsyncStorage.run(\n  { isAction: true },\n  // \"the callback\"\n  async () => {\n    ...\n  }\n);\n\nreturn {\n  type: 'done',\n  result: actionResult,\n  formState,\n}\n```\n\ninside that callback, we have many places that validate the action id\nand try to bail out if it's not recognized:\n\n```ts\ntry {\n  actionModId = getActionModIdOrError(actionId);\n} catch (err) {\n  console.error(err);\n  return { type: 'not-found '}\n}\n```\n\nthis was clearly intended to be an early return from `handleAction`. but\nit didn't work, because outside the callback we're doing\n```ts\nawait actionAsyncStorage.run(...)\n```\ni.e. **discarding the callback's return value**. So instead of returning\n`'not-found'` as intended, we end up falling through to the `'done'`\nreturn right after, and returning `{ type: 'done', result: undefined,\nformState: undefined }`.\n\nthen, our caller,`renderToHTMLToFlightImpl` looks at that what we\nreturned, and sees a 'done'\n\nhttps://github.com/vercel/next.js/blob/768183c5ddbaa94c1f6004816a1fae282fa0ab04/packages/next/src/server/app-render/app-render.tsx#L1522-L1547\nbut because if there's no `result` or `formState`, it'll fall through\nthe conditionals and do the same thing it'd do if we returned\n`null/undefined` (i.e. if `!actionRequestResult`). so we end up on the\nrendering path, render a page, and finally respond with a 200.\n\n### The fix, part 1\n\nThis PR fixes this. we're now directly returning the value from the\ncallback (`return await actionAsyncStorage.run(...)`) . i got rid of all\nthe weird fallthroughs and made each of the branches return something\nexplicitly. I've also changed `handleAction`'s return type to have a\n`... | null` instead of `... | undefined` (which is interpreted as \"this\nwas not an action request\") so that it's not possible to fall off the\nend of the function without an explicit return.\n\n### The fix, part 2\n\nTo make this more complicated, returning `'not-found'` for fetch actions\nwas actually also incorrect! that value makes `renderToHTMLToFlightImpl`\nrender an HTML 404 page, which is pretty useless as a (fetch) action\nresponse -- it's got the wrong content type! (#80613 relied on this to\nmake the action fail on the client-side, which isn't ideal, because the\nerror message doesn't indicate what the problem is).\n\nTo solve this, `handleAction` now returns a custom 404 response tagged\nwith a `x-nextjs-action-not-found` header (and uses `{ type: 'done' }`\ninstead of `{ type: 'not-found' }` to bypass the aformentioned 404\nhandling). Then, on the client, `fetchServerAction` checks for this\nheader, and throw a corresponding error. Other 404s will still throw a\n`An unexpected response was received from the server.` error instead,\nbecause they had to come from something else, like a bad proxy rewrite.",
    "sha": "ad27ddab27001ba14f6d833bde4d189f534d43b3",
    "files": [
        {
            "sha": "0018b5633efe4eb685393a0efe640759bbc5cdd4",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/ad27ddab27001ba14f6d833bde4d189f534d43b3/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/ad27ddab27001ba14f6d833bde4d189f534d43b3/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=ad27ddab27001ba14f6d833bde4d189f534d43b3",
            "patch": "@@ -712,5 +712,6 @@\n   \"711\": \"Can't resolve %s\",\n   \"712\": \"`rspack.warnForEdgeRuntime` is not supported by the wasm bindings.\",\n   \"713\": \"Unexpected error during process lookup\",\n-  \"714\": \"cannot run loadNative when `NEXT_TEST_WASM` is set\"\n+  \"714\": \"cannot run loadNative when `NEXT_TEST_WASM` is set\",\n+  \"715\": \"Server Action \\\"%s\\\" was not found on the server. \\\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action\"\n }"
        },
        {
            "sha": "569afa97045db09f44e15a2f8133cc1d76ae2744",
            "filename": "packages/next/src/client/components/app-router-headers.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/ad27ddab27001ba14f6d833bde4d189f534d43b3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-headers.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ad27ddab27001ba14f6d833bde4d189f534d43b3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-headers.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router-headers.ts?ref=ad27ddab27001ba14f6d833bde4d189f534d43b3",
            "patch": "@@ -31,3 +31,4 @@ export const NEXT_DID_POSTPONE_HEADER = 'x-nextjs-postponed' as const\n export const NEXT_REWRITTEN_PATH_HEADER = 'x-nextjs-rewritten-path' as const\n export const NEXT_REWRITTEN_QUERY_HEADER = 'x-nextjs-rewritten-query' as const\n export const NEXT_IS_PRERENDER_HEADER = 'x-nextjs-prerender' as const\n+export const NEXT_ACTION_NOT_FOUND_HEADER = 'x-nextjs-action-not-found' as const"
        },
        {
            "sha": "1209b7d041359deba77bb9931b45ca6210ed6909",
            "filename": "packages/next/src/client/components/router-reducer/reducers/server-action-reducer.ts",
            "status": "modified",
            "additions": 46,
            "deletions": 39,
            "changes": 85,
            "blob_url": "https://github.com/vercel/next.js/blob/ad27ddab27001ba14f6d833bde4d189f534d43b3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ad27ddab27001ba14f6d833bde4d189f534d43b3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts?ref=ad27ddab27001ba14f6d833bde4d189f534d43b3",
            "patch": "@@ -6,6 +6,7 @@ import { callServer } from '../../../app-call-server'\n import { findSourceMapURL } from '../../../app-find-source-map-url'\n import {\n   ACTION_HEADER,\n+  NEXT_ACTION_NOT_FOUND_HEADER,\n   NEXT_IS_PRERENDER_HEADER,\n   NEXT_ROUTER_STATE_TREE_HEADER,\n   NEXT_URL,\n@@ -62,8 +63,8 @@ import { revalidateEntireCache } from '../../segment-cache'\n type FetchServerActionResult = {\n   redirectLocation: URL | undefined\n   redirectType: RedirectType | undefined\n-  actionResult?: ActionResult\n-  actionFlightData?: NormalizedFlightData[] | string\n+  actionResult: ActionResult | undefined\n+  actionFlightData: NormalizedFlightData[] | string | undefined\n   isPrerender: boolean\n   revalidatedParts: {\n     tag: boolean\n@@ -110,6 +111,14 @@ async function fetchServerAction(\n     body,\n   })\n \n+  // Handle server actions that the server didn't recognize.\n+  const unrecognizedActionHeader = res.headers.get(NEXT_ACTION_NOT_FOUND_HEADER)\n+  if (unrecognizedActionHeader === '1') {\n+    throw new Error(\n+      `Server Action \"${actionId}\" was not found on the server. \\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action`\n+    )\n+  }\n+\n   const redirectHeader = res.headers.get('x-action-redirect')\n   const [location, _redirectType] = redirectHeader?.split(';') || []\n   let redirectType: RedirectType | undefined\n@@ -136,11 +145,7 @@ async function fetchServerAction(\n       cookie: revalidatedHeader[2],\n     }\n   } catch (e) {\n-    revalidatedParts = {\n-      paths: [],\n-      tag: false,\n-      cookie: false,\n-    }\n+    revalidatedParts = NO_REVALIDATED_PARTS\n   }\n \n   const redirectLocation = location\n@@ -151,54 +156,56 @@ async function fetchServerAction(\n     : undefined\n \n   const contentType = res.headers.get('content-type')\n+  const isRscResponse = !!(\n+    contentType && contentType.startsWith(RSC_CONTENT_TYPE_HEADER)\n+  )\n \n-  if (contentType?.startsWith(RSC_CONTENT_TYPE_HEADER)) {\n-    const response: ActionFlightResponse = await createFromFetch(\n-      Promise.resolve(res),\n-      { callServer, findSourceMapURL, temporaryReferences }\n-    )\n-\n-    if (location) {\n-      // if it was a redirection, then result is just a regular RSC payload\n-      return {\n-        actionFlightData: normalizeFlightData(response.f),\n-        redirectLocation,\n-        redirectType,\n-        revalidatedParts,\n-        isPrerender,\n-      }\n-    }\n-\n-    return {\n-      actionResult: response.a,\n-      actionFlightData: normalizeFlightData(response.f),\n-      redirectLocation,\n-      redirectType,\n-      revalidatedParts,\n-      isPrerender,\n-    }\n-  }\n-\n-  // Handle invalid server action responses\n-  if (res.status >= 400) {\n+  // Handle invalid server action responses.\n+  // A valid response must have `content-type: text/x-component`, unless it's an external redirect.\n+  // (external redirects have an 'x-action-redirect' header, but the body is an empty 'text/plain')\n+  if (!isRscResponse && !redirectLocation) {\n     // The server can respond with a text/plain error message, but we'll fallback to something generic\n     // if there isn't one.\n-    const error =\n-      contentType === 'text/plain'\n+    const message =\n+      res.status >= 400 && contentType === 'text/plain'\n         ? await res.text()\n         : 'An unexpected response was received from the server.'\n \n-    throw new Error(error)\n+    throw new Error(message)\n+  }\n+\n+  let actionResult: FetchServerActionResult['actionResult']\n+  let actionFlightData: FetchServerActionResult['actionFlightData']\n+  if (isRscResponse) {\n+    const response: ActionFlightResponse = await createFromFetch(\n+      Promise.resolve(res),\n+      { callServer, findSourceMapURL, temporaryReferences }\n+    )\n+    // An internal redirect can send an RSC response, but does not have a useful `actionResult`.\n+    actionResult = redirectLocation ? undefined : response.a\n+    actionFlightData = normalizeFlightData(response.f)\n+  } else {\n+    // An external redirect doesn't contain RSC data.\n+    actionResult = undefined\n+    actionFlightData = undefined\n   }\n \n   return {\n+    actionResult,\n+    actionFlightData,\n     redirectLocation,\n     redirectType,\n     revalidatedParts,\n     isPrerender,\n   }\n }\n \n+const NO_REVALIDATED_PARTS = {\n+  paths: [],\n+  tag: false,\n+  cookie: false,\n+}\n+\n /*\n  * This reducer is responsible for calling the server action and processing any side-effects from the server action.\n  * It does not mutate the state by itself but rather delegates to other reducers to do the actual mutation."
        },
        {
            "sha": "ecc16b7c1b8edb656620c0f62836796970665ec2",
            "filename": "packages/next/src/server/app-render/action-handler.ts",
            "status": "modified",
            "additions": 378,
            "deletions": 307,
            "changes": 685,
            "blob_url": "https://github.com/vercel/next.js/blob/ad27ddab27001ba14f6d833bde4d189f534d43b3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ad27ddab27001ba14f6d833bde4d189f534d43b3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts?ref=ad27ddab27001ba14f6d833bde4d189f534d43b3",
            "patch": "@@ -10,6 +10,7 @@ import {\n   RSC_CONTENT_TYPE_HEADER,\n   NEXT_ROUTER_STATE_TREE_HEADER,\n   ACTION_HEADER,\n+  NEXT_ACTION_NOT_FOUND_HEADER,\n } from '../../client/components/app-router-headers'\n import {\n   getAccessFallbackHTTPStatus,\n@@ -370,7 +371,7 @@ async function createRedirectRenderResult(\n     }\n   }\n \n-  return RenderResult.fromStatic('{}')\n+  return RenderResult.fromStatic('')\n }\n \n // Used to compare Host header and Origin header.\n@@ -448,6 +449,19 @@ type ServerActionsConfig = {\n   allowedOrigins?: string[]\n }\n \n+type HandleActionResult =\n+  | {\n+      /** An MPA action threw notFound(), and we need to render the appropriate HTML */\n+      type: 'not-found'\n+    }\n+  | {\n+      type: 'done'\n+      result: RenderResult | undefined\n+      formState?: any\n+    }\n+  /** The request turned out not to be a server action. */\n+  | null\n+\n export async function handleAction({\n   req,\n   res,\n@@ -470,17 +484,7 @@ export async function handleAction({\n   serverActions?: ServerActionsConfig\n   ctx: AppRenderContext\n   metadata: AppPageRenderResultMetadata\n-}): Promise<\n-  | undefined\n-  | {\n-      type: 'not-found'\n-    }\n-  | {\n-      type: 'done'\n-      result: RenderResult | undefined\n-      formState?: any\n-    }\n-> {\n+}): Promise<HandleActionResult> {\n   const contentType = req.headers['content-type']\n   const { serverActionsManifest, page } = ctx.renderOpts\n \n@@ -496,7 +500,7 @@ export async function handleAction({\n   // Note that this can be a false positive -- any multipart/urlencoded POST can get us here,\n   // But won't know if it's an MPA action or not until we call `decodeAction` below.\n   if (!isPossibleServerAction) {\n-    return\n+    return null\n   }\n \n   if (workStore.isStaticGeneration) {\n@@ -592,13 +596,8 @@ export async function handleAction({\n     'no-cache, no-store, max-age=0, must-revalidate'\n   )\n \n-  let boundActionArguments: unknown[] = []\n-\n   const { actionAsyncStorage } = ComponentMod\n \n-  let actionResult: RenderResult | undefined\n-  let formState: any | undefined\n-  let actionModId: string | undefined\n   const actionWasForwarded = Boolean(req.headers['x-action-forwarded'])\n \n   if (actionId) {\n@@ -624,331 +623,396 @@ export async function handleAction({\n     }\n   }\n \n+  const handleUnrecognizedFetchAction = (err: unknown): HandleActionResult => {\n+    // If the deployment doesn't have skew protection, this is expected to occasionally happen,\n+    // so we use a warning instead of an error.\n+    console.warn(err)\n+\n+    // Return an empty response with a header that the client router will interpret.\n+    // We don't need to waste time encoding a flight response, and using a blank body + header\n+    // means that unrecognized actions can also be handled at the infra level\n+    // (i.e. without needing to invoke a lambda)\n+    res.setHeader(NEXT_ACTION_NOT_FOUND_HEADER, '1')\n+    res.setHeader('content-type', 'text/plain')\n+    res.statusCode = 404\n+    return {\n+      type: 'done',\n+      result: RenderResult.fromStatic('Server action not found.'),\n+    }\n+  }\n+\n   try {\n-    await actionAsyncStorage.run({ isAction: true }, async () => {\n-      if (\n-        // The type check here ensures that `req` is correctly typed, and the\n-        // environment variable check provides dead code elimination.\n-        process.env.NEXT_RUNTIME === 'edge' &&\n-        isWebNextRequest(req)\n-      ) {\n-        if (!req.body) {\n-          throw new Error('invariant: Missing request body.')\n-        }\n+    return await actionAsyncStorage.run(\n+      { isAction: true },\n+      async (): Promise<HandleActionResult> => {\n+        // We only use these for fetch actions -- MPA actions handle them inside `decodeAction`.\n+        let actionModId: string | undefined\n+        let boundActionArguments: unknown[] = []\n+\n+        if (\n+          // The type check here ensures that `req` is correctly typed, and the\n+          // environment variable check provides dead code elimination.\n+          process.env.NEXT_RUNTIME === 'edge' &&\n+          isWebNextRequest(req)\n+        ) {\n+          if (!req.body) {\n+            throw new Error('invariant: Missing request body.')\n+          }\n \n-        // TODO: add body limit\n-\n-        // Use react-server-dom-webpack/server.edge\n-        const {\n-          createTemporaryReferenceSet,\n-          decodeReply,\n-          decodeAction,\n-          decodeFormState,\n-        } = ComponentMod\n-\n-        temporaryReferences = createTemporaryReferenceSet()\n-\n-        if (isMultipartAction) {\n-          // TODO-APP: Add streaming support\n-          const formData = await req.request.formData()\n-          if (isFetchAction) {\n-            boundActionArguments = await decodeReply(\n-              formData,\n-              serverModuleMap,\n-              { temporaryReferences }\n-            )\n-          } else {\n-            const action = await decodeAction(formData, serverModuleMap)\n-            if (typeof action === 'function') {\n-              // Only warn if it's a server action, otherwise skip for other post requests\n-              warnBadServerActionRequest()\n-\n-              const actionReturnedState =\n-                await executeActionAndPrepareForRender(\n-                  action as () => Promise<unknown>,\n-                  [],\n-                  workStore,\n-                  requestStore\n-                )\n+          // TODO: add body limit\n+\n+          // Use react-server-dom-webpack/server.edge\n+          const {\n+            createTemporaryReferenceSet,\n+            decodeReply,\n+            decodeAction,\n+            decodeFormState,\n+          } = ComponentMod\n \n-              formState = await decodeFormState(\n-                actionReturnedState,\n+          temporaryReferences = createTemporaryReferenceSet()\n+\n+          if (isMultipartAction) {\n+            // TODO-APP: Add streaming support\n+            const formData = await req.request.formData()\n+            if (isFetchAction) {\n+              // A fetch action with a multipart body.\n+              boundActionArguments = await decodeReply(\n                 formData,\n-                serverModuleMap\n+                serverModuleMap,\n+                { temporaryReferences }\n               )\n-            }\n+            } else {\n+              // Multipart POST, but not a fetch action.\n+              // Potentially an MPA action, we have to try decoding it to check.\n+              const action = await decodeAction(formData, serverModuleMap)\n+              if (typeof action === 'function') {\n+                // an MPA action.\n+\n+                // Only warn if it's a server action, otherwise skip for other post requests\n+                warnBadServerActionRequest()\n+\n+                const actionReturnedState =\n+                  await executeActionAndPrepareForRender(\n+                    action as () => Promise<unknown>,\n+                    [],\n+                    workStore,\n+                    requestStore\n+                  )\n+\n+                const formState = await decodeFormState(\n+                  actionReturnedState,\n+                  formData,\n+                  serverModuleMap\n+                )\n \n-            // Skip the fetch path\n-            return\n-          }\n-        } else {\n-          try {\n-            actionModId = getActionModIdOrError(actionId, serverModuleMap)\n-          } catch (err) {\n-            if (actionId !== null) {\n-              console.error(err)\n+                // Skip the fetch path.\n+                // We need to render a full HTML version of the page for the response, we'll handle that in app-render.\n+                return {\n+                  type: 'done',\n+                  result: undefined,\n+                  formState,\n+                }\n+              } else {\n+                // We couldn't decode an action, so this POST request turned out not to be a server action request.\n+                return null\n+              }\n             }\n-            return {\n-              type: 'not-found',\n+          } else {\n+            // POST with non-multipart body.\n+\n+            // If it's not multipart AND not a fetch action,\n+            // then it can't be an action request.\n+            if (!isFetchAction) {\n+              return null\n             }\n-          }\n \n-          const chunks: Buffer[] = []\n-          const reader = req.body.getReader()\n-          while (true) {\n-            const { done, value } = await reader.read()\n-            if (done) {\n-              break\n+            try {\n+              actionModId = getActionModIdOrError(actionId, serverModuleMap)\n+            } catch (err) {\n+              return handleUnrecognizedFetchAction(err)\n             }\n \n-            chunks.push(value)\n-          }\n+            // A fetch action with a non-multipart body.\n+            // In practice, this happens if `encodeReply` returned a string instead of FormData,\n+            // which can happen for very simple JSON-like values that don't need multiple flight rows.\n \n-          const actionData = Buffer.concat(chunks).toString('utf-8')\n+            const chunks: Buffer[] = []\n+            const reader = req.body.getReader()\n+            while (true) {\n+              const { done, value } = await reader.read()\n+              if (done) {\n+                break\n+              }\n \n-          if (isURLEncodedAction) {\n-            const formData = formDataFromSearchQueryString(actionData)\n-            boundActionArguments = await decodeReply(\n-              formData,\n-              serverModuleMap,\n-              { temporaryReferences }\n-            )\n-          } else {\n-            boundActionArguments = await decodeReply(\n-              actionData,\n-              serverModuleMap,\n-              { temporaryReferences }\n-            )\n-          }\n-        }\n-      } else if (\n-        // The type check here ensures that `req` is correctly typed, and the\n-        // environment variable check provides dead code elimination.\n-        process.env.NEXT_RUNTIME !== 'edge' &&\n-        isNodeNextRequest(req)\n-      ) {\n-        // Use react-server-dom-webpack/server.node which supports streaming\n-        const {\n-          createTemporaryReferenceSet,\n-          decodeReply,\n-          decodeReplyFromBusboy,\n-          decodeAction,\n-          decodeFormState,\n-        } = require(\n-          `./react-server.node`\n-        ) as typeof import('./react-server.node')\n-\n-        temporaryReferences = createTemporaryReferenceSet()\n-\n-        const { Transform, pipeline } =\n-          require('node:stream') as typeof import('node:stream')\n-\n-        const defaultBodySizeLimit = '1 MB'\n-        const bodySizeLimit =\n-          serverActions?.bodySizeLimit ?? defaultBodySizeLimit\n-        const bodySizeLimitBytes =\n-          bodySizeLimit !== defaultBodySizeLimit\n-            ? (\n-                require('next/dist/compiled/bytes') as typeof import('next/dist/compiled/bytes')\n-              ).parse(bodySizeLimit)\n-            : 1024 * 1024 // 1 MB\n-\n-        let size = 0\n-        const sizeLimitTransform = new Transform({\n-          transform(chunk, encoding, callback) {\n-            size += Buffer.byteLength(chunk, encoding)\n-            if (size > bodySizeLimitBytes) {\n-              const { ApiError } =\n-                require('../api-utils') as typeof import('../api-utils')\n-\n-              callback(\n-                new ApiError(\n-                  413,\n-                  `Body exceeded ${bodySizeLimit} limit.\\n` +\n-                    `To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`\n-                )\n-              )\n-              return\n+              chunks.push(value)\n             }\n \n-            callback(null, chunk)\n-          },\n-        })\n-\n-        const sizeLimitedBody = pipeline(\n-          req.body,\n-          sizeLimitTransform,\n-          // Avoid unhandled errors from `pipeline()` by passing an empty completion callback.\n-          // We'll propagate the errors properly when consuming the stream.\n-          () => {}\n-        )\n+            const actionData = Buffer.concat(chunks).toString('utf-8')\n \n-        if (isMultipartAction) {\n-          if (isFetchAction) {\n-            const busboy = (\n-              require('next/dist/compiled/busboy') as typeof import('next/dist/compiled/busboy')\n-            )({\n-              defParamCharset: 'utf8',\n-              headers: req.headers,\n-              limits: { fieldSize: bodySizeLimitBytes },\n-            })\n-\n-            // We need to use `pipeline(one, two)` instead of `one.pipe(two)` to propagate size limit errors correctly.\n-            pipeline(\n-              sizeLimitedBody,\n-              busboy,\n-              // Avoid unhandled errors from `pipeline()` by passing an empty completion callback.\n-              // We'll propagate the errors properly when consuming the stream.\n-              () => {}\n-            )\n-\n-            boundActionArguments = await decodeReplyFromBusboy(\n-              busboy,\n-              serverModuleMap,\n-              { temporaryReferences }\n-            )\n-          } else {\n-            // React doesn't yet publish a busboy version of decodeAction\n-            // so we polyfill the parsing of FormData.\n-            const fakeRequest = new Request('http://localhost', {\n-              method: 'POST',\n-              // @ts-expect-error\n-              headers: { 'Content-Type': contentType },\n-              body: new ReadableStream({\n-                start: (controller) => {\n-                  sizeLimitedBody.on('data', (chunk) => {\n-                    controller.enqueue(new Uint8Array(chunk))\n-                  })\n-                  sizeLimitedBody.on('end', () => {\n-                    controller.close()\n-                  })\n-                  sizeLimitedBody.on('error', (err) => {\n-                    controller.error(err)\n-                  })\n-                },\n-              }),\n-              duplex: 'half',\n-            })\n-            const formData = await fakeRequest.formData()\n-            const action = await decodeAction(formData, serverModuleMap)\n-            if (typeof action === 'function') {\n-              // Only warn if it's a server action, otherwise skip for other post requests\n-              warnBadServerActionRequest()\n-\n-              const actionReturnedState =\n-                await executeActionAndPrepareForRender(\n-                  action as () => Promise<unknown>,\n-                  [],\n-                  workStore,\n-                  requestStore\n+            if (isURLEncodedAction) {\n+              const formData = formDataFromSearchQueryString(actionData)\n+              boundActionArguments = await decodeReply(\n+                formData,\n+                serverModuleMap,\n+                { temporaryReferences }\n+              )\n+            } else {\n+              boundActionArguments = await decodeReply(\n+                actionData,\n+                serverModuleMap,\n+                { temporaryReferences }\n+              )\n+            }\n+          }\n+        } else if (\n+          // The type check here ensures that `req` is correctly typed, and the\n+          // environment variable check provides dead code elimination.\n+          process.env.NEXT_RUNTIME !== 'edge' &&\n+          isNodeNextRequest(req)\n+        ) {\n+          // Use react-server-dom-webpack/server.node which supports streaming\n+          const {\n+            createTemporaryReferenceSet,\n+            decodeReply,\n+            decodeReplyFromBusboy,\n+            decodeAction,\n+            decodeFormState,\n+          } = require(\n+            `./react-server.node`\n+          ) as typeof import('./react-server.node')\n+\n+          temporaryReferences = createTemporaryReferenceSet()\n+\n+          const { Transform, pipeline } =\n+            require('node:stream') as typeof import('node:stream')\n+\n+          const defaultBodySizeLimit = '1 MB'\n+          const bodySizeLimit =\n+            serverActions?.bodySizeLimit ?? defaultBodySizeLimit\n+          const bodySizeLimitBytes =\n+            bodySizeLimit !== defaultBodySizeLimit\n+              ? (\n+                  require('next/dist/compiled/bytes') as typeof import('next/dist/compiled/bytes')\n+                ).parse(bodySizeLimit)\n+              : 1024 * 1024 // 1 MB\n+\n+          let size = 0\n+          const sizeLimitTransform = new Transform({\n+            transform(chunk, encoding, callback) {\n+              size += Buffer.byteLength(chunk, encoding)\n+              if (size > bodySizeLimitBytes) {\n+                const { ApiError } =\n+                  require('../api-utils') as typeof import('../api-utils')\n+\n+                callback(\n+                  new ApiError(\n+                    413,\n+                    `Body exceeded ${bodySizeLimit} limit.\\n` +\n+                      `To configure the body size limit for Server Actions, see: https://nextjs.org/docs/app/api-reference/next-config-js/serverActions#bodysizelimit`\n+                  )\n                 )\n+                return\n+              }\n+\n+              callback(null, chunk)\n+            },\n+          })\n+\n+          const sizeLimitedBody = pipeline(\n+            req.body,\n+            sizeLimitTransform,\n+            // Avoid unhandled errors from `pipeline()` by passing an empty completion callback.\n+            // We'll propagate the errors properly when consuming the stream.\n+            () => {}\n+          )\n+\n+          if (isMultipartAction) {\n+            if (isFetchAction) {\n+              // A fetch action with a multipart body.\n+\n+              const busboy = (\n+                require('next/dist/compiled/busboy') as typeof import('next/dist/compiled/busboy')\n+              )({\n+                defParamCharset: 'utf8',\n+                headers: req.headers,\n+                limits: { fieldSize: bodySizeLimitBytes },\n+              })\n+\n+              // We need to use `pipeline(one, two)` instead of `one.pipe(two)` to propagate size limit errors correctly.\n+              pipeline(\n+                sizeLimitedBody,\n+                busboy,\n+                // Avoid unhandled errors from `pipeline()` by passing an empty completion callback.\n+                // We'll propagate the errors properly when consuming the stream.\n+                () => {}\n+              )\n \n-              formState = await decodeFormState(\n-                actionReturnedState,\n-                formData,\n-                serverModuleMap\n+              boundActionArguments = await decodeReplyFromBusboy(\n+                busboy,\n+                serverModuleMap,\n+                { temporaryReferences }\n               )\n+            } else {\n+              // Multipart POST, but not a fetch action.\n+              // Potentially an MPA action, we have to try decoding it to check.\n+\n+              // React doesn't yet publish a busboy version of decodeAction\n+              // so we polyfill the parsing of FormData.\n+              const fakeRequest = new Request('http://localhost', {\n+                method: 'POST',\n+                // @ts-expect-error\n+                headers: { 'Content-Type': contentType },\n+                body: new ReadableStream({\n+                  start: (controller) => {\n+                    sizeLimitedBody.on('data', (chunk) => {\n+                      controller.enqueue(new Uint8Array(chunk))\n+                    })\n+                    sizeLimitedBody.on('end', () => {\n+                      controller.close()\n+                    })\n+                    sizeLimitedBody.on('error', (err) => {\n+                      controller.error(err)\n+                    })\n+                  },\n+                }),\n+                duplex: 'half',\n+              })\n+              const formData = await fakeRequest.formData()\n+              const action = await decodeAction(formData, serverModuleMap)\n+              if (typeof action === 'function') {\n+                // an MPA action.\n+\n+                // Only warn if it's a server action, otherwise skip for other post requests\n+                warnBadServerActionRequest()\n+\n+                const actionReturnedState =\n+                  await executeActionAndPrepareForRender(\n+                    action as () => Promise<unknown>,\n+                    [],\n+                    workStore,\n+                    requestStore\n+                  )\n+\n+                const formState = await decodeFormState(\n+                  actionReturnedState,\n+                  formData,\n+                  serverModuleMap\n+                )\n+\n+                // Skip the fetch path.\n+                // We need to render a full HTML version of the page for the response, we'll handle that in app-render.\n+                return {\n+                  type: 'done',\n+                  result: undefined,\n+                  formState,\n+                }\n+              } else {\n+                // We couldn't decode an action, so this POST request turned out not to be a server action request.\n+                return null\n+              }\n             }\n+          } else {\n+            // POST with non-multipart body.\n \n-            // Skip the fetch path\n-            return\n-          }\n-        } else {\n-          try {\n-            actionModId = getActionModIdOrError(actionId, serverModuleMap)\n-          } catch (err) {\n-            if (actionId !== null) {\n-              console.error(err)\n+            // If it's not multipart AND not a fetch action,\n+            // then it can't be an action request.\n+            if (!isFetchAction) {\n+              return null\n             }\n-            return {\n-              type: 'not-found',\n+\n+            try {\n+              actionModId = getActionModIdOrError(actionId, serverModuleMap)\n+            } catch (err) {\n+              return handleUnrecognizedFetchAction(err)\n             }\n-          }\n \n-          const chunks: Buffer[] = []\n-          for await (const chunk of sizeLimitedBody) {\n-            chunks.push(Buffer.from(chunk))\n-          }\n+            // A fetch action with a non-multipart body.\n+            // In practice, this happens if `encodeReply` returned a string instead of FormData,\n+            // which can happen for very simple JSON-like values that don't need multiple flight rows.\n \n-          const actionData = Buffer.concat(chunks).toString('utf-8')\n+            const chunks: Buffer[] = []\n+            for await (const chunk of sizeLimitedBody) {\n+              chunks.push(Buffer.from(chunk))\n+            }\n \n-          if (isURLEncodedAction) {\n-            const formData = formDataFromSearchQueryString(actionData)\n-            boundActionArguments = await decodeReply(\n-              formData,\n-              serverModuleMap,\n-              { temporaryReferences }\n-            )\n-          } else {\n-            boundActionArguments = await decodeReply(\n-              actionData,\n-              serverModuleMap,\n-              { temporaryReferences }\n-            )\n+            const actionData = Buffer.concat(chunks).toString('utf-8')\n+\n+            if (isURLEncodedAction) {\n+              const formData = formDataFromSearchQueryString(actionData)\n+              boundActionArguments = await decodeReply(\n+                formData,\n+                serverModuleMap,\n+                { temporaryReferences }\n+              )\n+            } else {\n+              boundActionArguments = await decodeReply(\n+                actionData,\n+                serverModuleMap,\n+                { temporaryReferences }\n+              )\n+            }\n           }\n+        } else {\n+          throw new Error('Invariant: Unknown request type.')\n         }\n-      } else {\n-        throw new Error('Invariant: Unknown request type.')\n-      }\n \n-      // actions.js\n-      // app/page.js\n-      //   action worker1\n-      //     appRender1\n+        // actions.js\n+        // app/page.js\n+        //   action worker1\n+        //     appRender1\n \n-      // app/foo/page.js\n-      //   action worker2\n-      //     appRender\n+        // app/foo/page.js\n+        //   action worker2\n+        //     appRender\n \n-      // / -> fire action -> POST / -> appRender1 -> modId for the action file\n-      // /foo -> fire action -> POST /foo -> appRender2 -> modId for the action file\n+        // / -> fire action -> POST / -> appRender1 -> modId for the action file\n+        // /foo -> fire action -> POST /foo -> appRender2 -> modId for the action file\n \n-      try {\n-        actionModId =\n-          actionModId ?? getActionModIdOrError(actionId, serverModuleMap)\n-      } catch (err) {\n-        if (actionId !== null) {\n-          console.error(err)\n-        }\n-        return {\n-          type: 'not-found',\n+        try {\n+          actionModId =\n+            actionModId ?? getActionModIdOrError(actionId, serverModuleMap)\n+        } catch (err) {\n+          return handleUnrecognizedFetchAction(err)\n         }\n-      }\n-\n-      const actionMod = (await ComponentMod.__next_app__.require(\n-        actionModId\n-      )) as Record<string, (...args: unknown[]) => Promise<unknown>>\n-      const actionHandler =\n-        actionMod[\n-          // `actionId` must exist if we got here, as otherwise we would have thrown an error above\n-          actionId!\n-        ]\n-\n-      const returnVal = await executeActionAndPrepareForRender(\n-        actionHandler,\n-        boundActionArguments,\n-        workStore,\n-        requestStore\n-      ).finally(() => {\n-        addRevalidationHeader(res, { workStore, requestStore })\n-      })\n \n-      // For form actions, we need to continue rendering the page.\n-      if (isFetchAction) {\n-        actionResult = await generateFlight(req, ctx, requestStore, {\n-          actionResult: Promise.resolve(returnVal),\n-          // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n-          skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n-          temporaryReferences,\n+        const actionMod = (await ComponentMod.__next_app__.require(\n+          actionModId\n+        )) as Record<string, (...args: unknown[]) => Promise<unknown>>\n+        const actionHandler =\n+          actionMod[\n+            // `actionId` must exist if we got here, as otherwise we would have thrown an error above\n+            actionId!\n+          ]\n+\n+        const returnVal = await executeActionAndPrepareForRender(\n+          actionHandler,\n+          boundActionArguments,\n+          workStore,\n+          requestStore\n+        ).finally(() => {\n+          addRevalidationHeader(res, { workStore, requestStore })\n         })\n-      }\n-    })\n \n-    return {\n-      type: 'done',\n-      result: actionResult,\n-      formState,\n-    }\n+        // For form actions, we need to continue rendering the page.\n+        if (isFetchAction) {\n+          const actionResult = await generateFlight(req, ctx, requestStore, {\n+            actionResult: Promise.resolve(returnVal),\n+            // if the page was not revalidated, or if the action was forwarded from another worker, we can skip the rendering the flight tree\n+            skipFlight: !workStore.pathWasRevalidated || actionWasForwarded,\n+            temporaryReferences,\n+          })\n+\n+          return {\n+            type: 'done',\n+            result: actionResult,\n+          }\n+        } else {\n+          // TODO: this shouldn't be reachable, because all non-fetch codepaths return early.\n+          // this will be handled in a follow-up refactor PR.\n+          return null\n+        }\n+      }\n+    )\n   } catch (err) {\n     if (isRedirectError(err)) {\n       const redirectUrl = getURLFromRedirectError(err)\n@@ -974,6 +1038,7 @@ export async function handleAction({\n         }\n       }\n \n+      // For an MPA action, the redirect doesn't need a body, just a Location header.\n       res.setHeader('Location', redirectUrl)\n       return {\n         type: 'done',\n@@ -1003,11 +1068,16 @@ export async function handleAction({\n           }),\n         }\n       }\n+\n+      // For an MPA action, we need to render a HTML response. We'll handle that in app-render.\n       return {\n         type: 'not-found',\n       }\n     }\n \n+    // An error that didn't come from `redirect()` or `notFound()`, likely thrown from user code\n+    // (but it could also be a bug in our code!)\n+\n     if (isFetchAction) {\n       // TODO: consider checking if the error is an `ApiError` and change status code\n       // so that we can respond with a 413 to requests that break the body size limit\n@@ -1036,6 +1106,7 @@ export async function handleAction({\n       }\n     }\n \n+    // For an MPA action, we need to render a HTML response. We'll rethrow the error and let it be handled above.\n     throw err\n   }\n }"
        },
        {
            "sha": "cd4f0f30784abf61dc854c3160f7329977cf4f93",
            "filename": "test/e2e/app-dir/actions-unrecognized/actions-unrecognized.test.ts",
            "status": "added",
            "additions": 220,
            "deletions": 0,
            "changes": 220,
            "blob_url": "https://github.com/vercel/next.js/blob/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Factions-unrecognized.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Factions-unrecognized.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Factions-unrecognized.test.ts?ref=ad27ddab27001ba14f6d833bde4d189f534d43b3",
            "patch": "@@ -0,0 +1,220 @@\n+/* eslint-disable jest/no-standalone-expect */\n+import { nextTestSetup } from 'e2e-utils'\n+import { createRequestTracker } from 'e2e-utils/request-tracker'\n+import { retry } from 'next-test-utils'\n+import { outdent } from 'outdent'\n+\n+describe('unrecognized server actions', () => {\n+  const { next, isNextDeploy, isNextDev } = nextTestSetup({\n+    files: __dirname,\n+  })\n+\n+  let cliOutputPosition: number = 0\n+  beforeEach(() => {\n+    cliOutputPosition = next.cliOutput.length\n+  })\n+  const getLogs = () => {\n+    return next.cliOutput.slice(cliOutputPosition)\n+  }\n+\n+  // This is disabled when deployed because the 404 page will be served as a static route\n+  // which will not support POST requests, and will return a 405 instead.\n+  if (!isNextDeploy) {\n+    it('should 404 when POSTing a non-server-action request to a nonexistent page', async () => {\n+      const res = await next.fetch('/non-existent-route', {\n+        method: 'POST',\n+        headers: {\n+          'content-type': 'application/x-www-form-urlencoded',\n+        },\n+        body: 'foo=bar',\n+      })\n+\n+      const cliOutput = getLogs()\n+      expect(cliOutput).not.toContain('TypeError')\n+      expect(cliOutput).not.toContain(\n+        'Missing `origin` header from a forwarded Server Actions request'\n+      )\n+      expect(res.status).toBe(404)\n+    })\n+\n+    it.each([\n+      {\n+        // encodeReply encodes simple args as plaintext.\n+        name: 'plaintext',\n+        request: {\n+          contentType: 'text/plain;charset=UTF-8',\n+          body: '{}',\n+        },\n+      },\n+      {\n+        // encodeReply encodes complex args as FormData.\n+        // this body is empty and wouldn't match how react encodes an action, but it should be rejected\n+        // before we even get to parsing the FormData, so it doesn't really matter.\n+        name: 'form-data/multipart',\n+        request: {\n+          body: new FormData(),\n+        },\n+      },\n+      {\n+        // we never use urlencoded actions, but we currently have codepaths for it in `handleAction`,\n+        // so might as well test them.\n+        name: 'urlencoded',\n+        request: {\n+          contentType: 'application/x-www-form-urlencoded',\n+          body: 'foo=bar',\n+        },\n+      },\n+    ])(\n+      'should 404 when POSTing a server action with an unrecognized id to a nonexistent page: $name',\n+      async ({ request: { contentType, body } }) => {\n+        const res = await next.fetch('/non-existent-route', {\n+          method: 'POST',\n+          headers: {\n+            'next-action': '123',\n+            ...(contentType ? { 'content-type': contentType } : undefined),\n+          },\n+          // @ts-expect-error: node-fetch types don't seem to like FormData\n+          body,\n+        })\n+\n+        expect(res.status).toBe(404)\n+\n+        const cliOutput = getLogs()\n+        expect(cliOutput).not.toContain('TypeError')\n+        expect(cliOutput).not.toContain(\n+          'Missing `origin` header from a forwarded Server Actions request'\n+        )\n+        expect(cliOutput).toInclude(outdent`\n+          Failed to find Server Action \"123\". This request might be from an older or newer deployment.\n+          Read more: https://nextjs.org/docs/messages/failed-to-find-server-action\n+        `)\n+      }\n+    )\n+  }\n+\n+  describe.each(['nodejs', 'edge'])(\n+    'should error and log a warning when submitting a server action with an unrecognized ID - %s',\n+    (runtime) => {\n+      const testUnrecognizedActionSubmission = async ({\n+        formId,\n+        disableJavaScript,\n+      }: {\n+        formId: string\n+        disableJavaScript: boolean\n+      }) => {\n+        const browser = await next.browser(`/${runtime}/unrecognized-action`, {\n+          disableJavaScript,\n+        })\n+        const requestTracker = createRequestTracker(browser)\n+\n+        const [_, response] = await requestTracker.captureResponse(\n+          async () =>\n+            await browser\n+              .elementByCss(`form#${formId} button[type=\"submit\"]`)\n+              .click(),\n+          {\n+            request: {\n+              method: 'POST',\n+              pathname: `/${runtime}/unrecognized-action`,\n+            },\n+          }\n+        )\n+\n+        if (!disableJavaScript) {\n+          // A fetch action, sent via the router.\n+          expect(response.status()).toBe(404)\n+          // NOTE: we cannot validate the response text, because playwright hangs on `response.text()` for some reason.\n+          expect(response.headers()['content-type']).toStartWith('text/plain')\n+\n+          // The submission should throw and trigger our error boundary.\n+          expect(await browser.elementByCss(`#error-boundary`).text()).toMatch(\n+            /Error boundary: Server Action \".+?\" was not found on the server\\./\n+          )\n+\n+          // We responded with a 404, but we shouldn't trigger a not-found (either a custom or a default one)\n+          expect(await browser.elementByCss('body').text()).not.toContain(\n+            'Not found'\n+          )\n+          expect(await browser.elementByCss('body').text()).not.toContain(\n+            'my-not-found'\n+          )\n+\n+          if (!isNextDeploy) {\n+            await retry(async () =>\n+              expect(getLogs()).toInclude(outdent`\n+              Failed to find Server Action \"decafc0ffeebad01\". This request might be from an older or newer deployment.\n+              Read more: https://nextjs.org/docs/messages/failed-to-find-server-action\n+            `)\n+            )\n+          }\n+        } else {\n+          // An MPA action, sent without JS.\n+\n+          if (isNextDeploy) {\n+            // FIXME: When deployed to vercel, the request is logged as a 500, but returns a 405.\n+            // We also don't seem to display the error page correctly,\n+            // and the response is inconsistent between nodejs and edge.\n+            expect(response.status()).toBe(runtime === 'nodejs' ? 405 : 500)\n+            expect(response.headers()['content-type']).toStartWith('text/html')\n+          } else {\n+            // FIXME: Currently, an unrecognized id in an MPA action results in a 500.\n+            // This is not ideal, and ignores all nested `error.js` files, only showing the topmost one.\n+            expect(response.status()).toBe(500)\n+            expect(response.headers()['content-type']).toStartWith('text/html')\n+            // In dev, the 500 page doesn't have any SSR'd html, so it won't show anything without JS.\n+            if (!isNextDev) {\n+              expect(await browser.elementByCss('body').text()).toContain(\n+                'Internal Server Error'\n+              )\n+            }\n+\n+            if (!isNextDeploy) {\n+              // FIXME: For an MPA action, the logs currently show the error thrown by React instead of our custom message with a link to a docs page.\n+              await retry(async () =>\n+                expect(getLogs()).toInclude(\n+                  `Error: Could not find the module \"decafc0ffeebad01\" in the React Server Manifest. This is probably a bug in the React Server Components bundler`\n+                )\n+              )\n+            }\n+          }\n+        }\n+      }\n+\n+      it.each([\n+        {\n+          description: 'js enabled',\n+          disableJavaScript: false,\n+        },\n+        {\n+          description: 'js disabled',\n+          disableJavaScript: true,\n+        },\n+      ])(\n+        'server action invoked via form - $description',\n+        async ({ disableJavaScript }) => {\n+          await testUnrecognizedActionSubmission({\n+            formId: 'form-direct',\n+            disableJavaScript,\n+          })\n+        }\n+      )\n+\n+      // these forms rely on client-side JS, so we can't test them with JS disabled\n+      it.each([\n+        {\n+          description: 'with simple argument',\n+          formId: 'form-simple-argument',\n+        },\n+        {\n+          description: 'with complex argument',\n+          formId: 'form-complex-argument',\n+        },\n+      ])('server action invoked from JS - $description', async ({ formId }) => {\n+        await testUnrecognizedActionSubmission({\n+          formId,\n+          disableJavaScript: false,\n+        })\n+      })\n+    }\n+  )\n+})"
        },
        {
            "sha": "778b2cbe2f1171e02739fcb395ab27dbe1eb5b14",
            "filename": "test/e2e/app-dir/actions-unrecognized/app/edge/unrecognized-action/page.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Fedge%2Funrecognized-action%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Fedge%2Funrecognized-action%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Fedge%2Funrecognized-action%2Fpage.tsx?ref=ad27ddab27001ba14f6d833bde4d189f534d43b3",
            "patch": "@@ -0,0 +1,3 @@\n+export const runtime = 'edge'\n+\n+export { default } from '../../nodejs/unrecognized-action/page'"
        },
        {
            "sha": "6d7e1ed585862084bbcead3642e23690d53bd1fd",
            "filename": "test/e2e/app-dir/actions-unrecognized/app/layout.tsx",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Flayout.tsx?ref=ad27ddab27001ba14f6d833bde4d189f534d43b3",
            "patch": "@@ -0,0 +1,8 @@\n+export default function RootLayout({ children }) {\n+  return (\n+    <html>\n+      <head />\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "fd8e36b5bb4a2e813f8c991e1c0bc5d06a92919f",
            "filename": "test/e2e/app-dir/actions-unrecognized/app/nodejs/unrecognized-action/client.tsx",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Fnodejs%2Funrecognized-action%2Fclient.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Fnodejs%2Funrecognized-action%2Fclient.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Fnodejs%2Funrecognized-action%2Fclient.tsx?ref=ad27ddab27001ba14f6d833bde4d189f534d43b3",
            "patch": "@@ -0,0 +1,61 @@\n+'use client'\n+import * as React from 'react'\n+import { useActionState } from 'react'\n+\n+export function FormWithArg<T>({\n+  action,\n+  argument,\n+  id,\n+  children,\n+}: {\n+  action: (state: string, argument: T) => Promise<string>\n+  argument: T\n+  id: string\n+  children?: React.ReactNode\n+}) {\n+  const [state, dispatch] = useActionState(\n+    // don't use `bind()`, we want to explicitly avoid getting a FormData argument\n+    // because that always results in a FormData request\n+    (state) => action(state, argument),\n+    'initial-state'\n+  )\n+  return (\n+    <form id={id} action={dispatch}>\n+      <button type=\"submit\">{children}</button>\n+      <span className=\"form-state\">{`${state}`}</span>\n+    </form>\n+  )\n+}\n+\n+export function Form({\n+  action,\n+}: {\n+  action: (state: string, formData: FormData) => Promise<string>\n+}) {\n+  const [state, dispatch] = useActionState(action, 'initial-state')\n+  return (\n+    <form action={dispatch} id=\"form-direct\">\n+      <button type=\"submit\">Submit server form</button>\n+      <span className=\"form-state\">{`${state}`}</span>\n+    </form>\n+  )\n+}\n+\n+export class ErrorBoundary extends React.Component<{\n+  children: React.ReactNode\n+}> {\n+  state = { error: null }\n+  static getDerivedStateFromError(error) {\n+    return { error }\n+  }\n+  render() {\n+    if (this.state.error) {\n+      return (\n+        <div id=\"error-boundary\">\n+          Error boundary: {this.state.error.message}\n+        </div>\n+      )\n+    }\n+    return this.props.children\n+  }\n+}"
        },
        {
            "sha": "9cfd034043b454701ea70c2abe5819e8a89db044",
            "filename": "test/e2e/app-dir/actions-unrecognized/app/nodejs/unrecognized-action/page.tsx",
            "status": "added",
            "additions": 59,
            "deletions": 0,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Fnodejs%2Funrecognized-action%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Fnodejs%2Funrecognized-action%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Fnodejs%2Funrecognized-action%2Fpage.tsx?ref=ad27ddab27001ba14f6d833bde4d189f534d43b3",
            "patch": "@@ -0,0 +1,59 @@\n+import * as React from 'react'\n+import { FormWithArg, Form, ErrorBoundary } from './client'\n+\n+const action = async (...args: any[]) => {\n+  'use server'\n+  console.log('hello from server', ...args)\n+  return 'state-from-server'\n+}\n+\n+// simulate client-side version skew by changing the action ID to something the server won't recognize\n+setServerActionId(action, 'decafc0ffeebad01')\n+\n+export default function Page() {\n+  return (\n+    <div>\n+      <div>\n+        <ErrorBoundary>\n+          <Form action={action} />\n+        </ErrorBoundary>\n+      </div>\n+      <div>\n+        <ErrorBoundary>\n+          <FormWithArg\n+            action={action}\n+            id=\"form-simple-argument\"\n+            argument={{ foo: 'bar' }}\n+          >\n+            Submit client form with simple argument\n+          </FormWithArg>\n+        </ErrorBoundary>\n+      </div>\n+      <div>\n+        <ErrorBoundary>\n+          <FormWithArg\n+            action={action}\n+            id=\"form-complex-argument\"\n+            argument={new Map([['foo', Promise.resolve('bar')]])}\n+          >\n+            Submit client form with complex argument\n+          </FormWithArg>\n+        </ErrorBoundary>\n+      </div>\n+    </div>\n+  )\n+}\n+\n+function setServerActionId(action: (...args: any[]) => any, id: string) {\n+  // React implementation detail: `registerServerReference(func, id)` sets `func.$$id = id`.\n+  const actionWithMetadata = action as typeof action & { $$id?: string }\n+  if (!actionWithMetadata.$$id) {\n+    throw new Error(\n+      `Expected to find server action metadata properties on ${action}`\n+    )\n+  }\n+  Object.defineProperty(actionWithMetadata, '$$id', {\n+    value: id,\n+    configurable: true,\n+  })\n+}"
        },
        {
            "sha": "c0ceb032eb88da696b2f1f8be403b1a78e326eee",
            "filename": "test/e2e/app-dir/actions-unrecognized/app/not-found.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Fnot-found.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Fnot-found.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fapp%2Fnot-found.tsx?ref=ad27ddab27001ba14f6d833bde4d189f534d43b3",
            "patch": "@@ -0,0 +1,3 @@\n+export default function NotFound() {\n+  return <h1>my-not-found</h1>\n+}"
        },
        {
            "sha": "c97e1a0e95d3ee20deb6500153083f1d139d83e0",
            "filename": "test/e2e/app-dir/actions-unrecognized/next.config.ts",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fnext.config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fnext.config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions-unrecognized%2Fnext.config.ts?ref=ad27ddab27001ba14f6d833bde4d189f534d43b3",
            "patch": "@@ -0,0 +1,10 @@\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  productionBrowserSourceMaps: true,\n+  experimental: {\n+    serverSourceMaps: true,\n+  },\n+}\n+\n+export default nextConfig"
        },
        {
            "sha": "f14371aca6d13fb83c604fc10eab4c5ee4c4e8cb",
            "filename": "test/e2e/app-dir/actions/app-action.test.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 52,
            "changes": 58,
            "blob_url": "https://github.com/vercel/next.js/blob/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions%2Fapp-action.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ad27ddab27001ba14f6d833bde4d189f534d43b3/test%2Fe2e%2Fapp-dir%2Factions%2Fapp-action.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Factions%2Fapp-action.test.ts?ref=ad27ddab27001ba14f6d833bde4d189f534d43b3",
            "patch": "@@ -10,7 +10,6 @@ import {\n import type { Request, Response } from 'playwright'\n import fs from 'node:fs/promises'\n import { join } from 'node:path'\n-import { outdent } from 'outdent'\n import { setTimeout } from 'node:timers/promises'\n \n const GENERIC_RSC_ERROR =\n@@ -778,51 +777,6 @@ describe('app-dir action handling', () => {\n     }\n   })\n \n-  // This is disabled when deployed because the 404 page will be served as a static route\n-  // which will not support POST requests, and will return a 405 instead.\n-  if (!isNextDeploy) {\n-    it('should 404 when POSTing an invalid server action', async () => {\n-      const cliOutputPosition = next.cliOutput.length\n-      const res = await next.fetch('/non-existent-route', {\n-        method: 'POST',\n-        headers: {\n-          'content-type': 'application/x-www-form-urlencoded',\n-        },\n-        body: 'foo=bar',\n-      })\n-\n-      const cliOutput = next.cliOutput.slice(cliOutputPosition)\n-\n-      expect(cliOutput).not.toContain('TypeError')\n-      expect(cliOutput).not.toContain(\n-        'Missing `origin` header from a forwarded Server Actions request'\n-      )\n-      expect(res.status).toBe(404)\n-    })\n-  }\n-\n-  // This is disabled when deployed because it relies on checking runtime logs,\n-  // and only build time logs will be available.\n-  if (!isNextDeploy) {\n-    it('should log a warning when a server action is not found but an id is provided', async () => {\n-      await next.fetch('/server', {\n-        method: 'POST',\n-        headers: {\n-          'content-type': 'application/x-www-form-urlencoded',\n-          'next-action': 'abc123',\n-        },\n-        body: 'foo=bar',\n-      })\n-\n-      await retry(async () =>\n-        expect(next.cliOutput).toInclude(outdent`\n-          Failed to find Server Action \"abc123\". This request might be from an older or newer deployment.\n-          Read more: https://nextjs.org/docs/messages/failed-to-find-server-action\n-        `)\n-      )\n-    })\n-  }\n-\n   it('should be possible to catch network errors', async () => {\n     const browser = await next.browser('/catching-error', {\n       beforePageLoad(page) {\n@@ -1656,7 +1610,7 @@ describe('app-dir action handling', () => {\n   })\n \n   describe('redirects', () => {\n-    it('redirects properly when server action handler uses `redirect`', async () => {\n+    it('redirects properly when route handler uses `redirect`', async () => {\n       const postRequests = []\n       const responseCodes = []\n \n@@ -1685,12 +1639,12 @@ describe('app-dir action handling', () => {\n         expect(await browser.url()).toContain('success=true')\n       })\n \n-      // verify that the POST request was only made to the action handler\n+      // verify that the POST request was only made to the route handler\n       expect(postRequests).toEqual(['/redirects/api-redirect'])\n       expect(responseCodes).toEqual([303])\n     })\n \n-    it('redirects properly when server action handler uses `permanentRedirect`', async () => {\n+    it('redirects properly when route handler uses `permanentRedirect`', async () => {\n       const postRequests = []\n       const responseCodes = []\n \n@@ -1718,7 +1672,7 @@ describe('app-dir action handling', () => {\n       await retry(async () => {\n         expect(await browser.url()).toContain('success=true')\n       })\n-      // verify that the POST request was only made to the action handler\n+      // verify that the POST request was only made to the route handler\n       expect(postRequests).toEqual(['/redirects/api-redirect-permanent'])\n       expect(responseCodes).toEqual([303])\n     })\n@@ -1783,7 +1737,7 @@ describe('app-dir action handling', () => {\n     })\n \n     it.each(['307', '308'])(\n-      `redirects properly when server action handler redirects with a %s status code`,\n+      `redirects properly when route handler redirects with a %s status code`,\n       async (statusCode) => {\n         const postRequests = []\n         const responseCodes = []\n@@ -1814,7 +1768,7 @@ describe('app-dir action handling', () => {\n         })\n         expect(await browser.elementById('redirect-page')).toBeTruthy()\n \n-        // since a 307/308 status code follows the redirect, the POST request should be made to both the action handler and the redirect target\n+        // since a 307/308 status code follows the redirect, the POST request should be made to both the route handler and the redirect target\n         expect(postRequests).toEqual([\n           `/redirects/api-redirect-${statusCode}`,\n           `/redirects?success=true`,"
        }
    ],
    "stats": {
        "total": 1196,
        "additions": 797,
        "deletions": 399
    }
}