{
    "author": "unstubbable",
    "message": "Use new `browserWithResponse()` method in `empty-fallback-shells` tests (#80406)\n\nIn e2e tests, we sometimes want to assert on the response headers and on\nthe rendered HTML within the same test. For the former, we usually use\n`next.fetch()`, but this doesn't allow us to use the Playwright browser\nAPI to assert on the rendered HTML, which is available through\n`next.browser()`. This is especially tricky when a PPR shell is resumed,\nwhere asserting on the response text is error-prone, as the streamed-in\nHTML may change the elements that we want to assert on.\n\nTo avoid the maintenance and runtime overhead of splitting the test into\ntwo separate tests, we introduce a new `next.browserWithResponse()`\nmethod that allows us to use the Playwright browser API while also\nexposing the response to check the headers and other properties.\n\n---------\n\nCo-authored-by: Zack Tanner <1939140+ztanner@users.noreply.github.com>",
    "sha": "614329711ea861001e905b3c5f97d8a2ab9b3379",
    "files": [
        {
            "sha": "f7f04899d6465572aa109215c3c9739dee3ba030",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/last-modified.jsx",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/614329711ea861001e905b3c5f97d8a2ab9b3379/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Flast-modified.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/614329711ea861001e905b3c5f97d8a2ab9b3379/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Flast-modified.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Flast-modified.jsx?ref=614329711ea861001e905b3c5f97d8a2ab9b3379",
            "patch": "@@ -1,9 +1,12 @@\n+import { getSentinelValue } from './sentinel'\n+\n export async function LastModified({ params }) {\n   const { slug } = await params\n \n   return (\n-    <p data-testid={`page-${slug}`}>\n-      Page /{slug} last modified: {new Date().toISOString()}\n+    <p id=\"last-modified\">\n+      Page /{slug} last modified: {new Date().toISOString()} (\n+      {getSentinelValue()})\n     </p>\n   )\n }"
        },
        {
            "sha": "b742a76f981e97fb9dce31bf7e82d41b7879dcc7",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/with-suspense/layout.jsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/614329711ea861001e905b3c5f97d8a2ab9b3379/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Flayout.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/614329711ea861001e905b3c5f97d8a2ab9b3379/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Flayout.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwith-suspense%2Flayout.jsx?ref=614329711ea861001e905b3c5f97d8a2ab9b3379",
            "patch": "@@ -7,8 +7,8 @@ export default async function Layout({ children }) {\n   return (\n     <html>\n       <body>\n-        <div data-testid={`layout-${getSentinelValue()}`}>\n-          Layout: {new Date().toISOString()}\n+        <div id=\"layout\">\n+          Layout: {new Date().toISOString()} ({getSentinelValue()})\n         </div>\n         <Suspense fallback={<p>Loading...</p>}>{children}</Suspense>\n       </body>"
        },
        {
            "sha": "ad3ada30c1daf34788dadde682dd2edc5dabfe9c",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/with-cached-io/without-suspense/layout.jsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/614329711ea861001e905b3c5f97d8a2ab9b3379/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Flayout.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/614329711ea861001e905b3c5f97d8a2ab9b3379/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Flayout.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwith-cached-io%2Fwithout-suspense%2Flayout.jsx?ref=614329711ea861001e905b3c5f97d8a2ab9b3379",
            "patch": "@@ -6,8 +6,8 @@ export default async function Layout({ children }) {\n   return (\n     <html>\n       <body>\n-        <div data-testid={`layout-${getSentinelValue()}`}>\n-          Layout: {new Date().toISOString()}\n+        <div id=\"layout\">\n+          Layout: {new Date().toISOString()} ({getSentinelValue()})\n         </div>\n         {children}\n       </body>"
        },
        {
            "sha": "1d7464925457357a11cb1b008b2cf46a2f81effd",
            "filename": "test/e2e/app-dir/empty-fallback-shells/app/without-io/[slug]/page.jsx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/614329711ea861001e905b3c5f97d8a2ab9b3379/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwithout-io%2F%5Bslug%5D%2Fpage.jsx",
            "raw_url": "https://github.com/vercel/next.js/raw/614329711ea861001e905b3c5f97d8a2ab9b3379/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwithout-io%2F%5Bslug%5D%2Fpage.jsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fapp%2Fwithout-io%2F%5Bslug%5D%2Fpage.jsx?ref=614329711ea861001e905b3c5f97d8a2ab9b3379",
            "patch": "@@ -1,6 +1,6 @@\n export default async function Page({ params }) {\n   const { slug } = await params\n-  return <div data-testid={`hello-${slug}`}>Hello /{slug}</div>\n+  return <div id=\"slug\">Hello /{slug}</div>\n }\n \n export async function generateStaticParams() {"
        },
        {
            "sha": "b2082f93ba4a353771ff009bff83de4d4b7b39c2",
            "filename": "test/e2e/app-dir/empty-fallback-shells/empty-fallback-shells.test.ts",
            "status": "modified",
            "additions": 78,
            "deletions": 61,
            "changes": 139,
            "blob_url": "https://github.com/vercel/next.js/blob/614329711ea861001e905b3c5f97d8a2ab9b3379/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fempty-fallback-shells.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/614329711ea861001e905b3c5f97d8a2ab9b3379/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fempty-fallback-shells.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fempty-fallback-shells%2Fempty-fallback-shells.test.ts?ref=614329711ea861001e905b3c5f97d8a2ab9b3379",
            "patch": "@@ -7,93 +7,95 @@ describe('empty-fallback-shells', () => {\n \n   describe('without IO', () => {\n     it('should start and not postpone the response', async () => {\n-      const res = await next.fetch('/without-io/world')\n-      const html = await res.text()\n-      expect(html).toContain('hello-world')\n+      const { browser, response } =\n+        await next.browserWithResponse('/without-io/world')\n+\n+      expect(await browser.elementById('slug').text()).toBe('Hello /world')\n+      const headers = response.headers()\n \n       if (isNextDeploy) {\n-        expect(res.headers.get('x-matched-path')).toBe('/without-io/[slug]')\n+        expect(headers['x-matched-path']).toBe('/without-io/[slug]')\n       }\n \n       // If we didn't use the fallback shell, then we didn't postpone the\n       // response and therefore shouldn't have sent the postponed header.\n-      expect(res.headers.get('x-nextjs-postponed')).not.toBe('1')\n+      expect(headers['x-nextjs-postponed']).not.toBe('1')\n     })\n   })\n \n   describe('with cached IO', () => {\n     describe('and the page wrapped in Suspense', () => {\n       describe('and the params accessed in the cached page', () => {\n         it('resumes a postponed fallback shell', async () => {\n-          const res = await next.fetch(\n+          const { browser, response } = await next.browserWithResponse(\n             '/with-cached-io/with-suspense/params-in-page/bar'\n           )\n \n-          const html = await res.text()\n-          expect(html).toContain('page-bar')\n+          const lastModified = await browser.elementById('last-modified').text()\n+          expect(lastModified).toInclude('Page /bar')\n+          expect(lastModified).toInclude('runtime')\n \n-          if (isNextDev) {\n-            expect(html).toContain('layout-runtime')\n-          } else {\n-            expect(html).toContain('layout-buildtime')\n-          }\n+          const layout = await browser.elementById('layout').text()\n+          expect(layout).toInclude(isNextDev ? 'runtime' : 'buildtime')\n+\n+          const headers = response.headers()\n \n           if (isNextDeploy) {\n-            expect(res.headers.get('x-matched-path')).toBe(\n+            expect(headers['x-matched-path']).toBe(\n               '/with-cached-io/with-suspense/params-in-page/[slug]'\n             )\n           } else if (isNextStart) {\n-            expect(res.headers.get('x-nextjs-postponed')).toBe('1')\n+            expect(headers['x-nextjs-postponed']).toBe('1')\n           }\n         })\n       })\n \n       describe('and the params accessed in cached non-page function', () => {\n         it('resumes a postponed fallback shell', async () => {\n-          const res = await next.fetch(\n+          const { browser, response } = await next.browserWithResponse(\n             '/with-cached-io/with-suspense/params-not-in-page/bar'\n           )\n \n-          const html = await res.text()\n-          expect(html).toContain('page-bar')\n+          const lastModified = await browser.elementById('last-modified').text()\n+          expect(lastModified).toInclude('Page /bar')\n+          expect(lastModified).toInclude('runtime')\n \n-          if (isNextDev) {\n-            expect(html).toContain('layout-runtime')\n-          } else {\n-            expect(html).toContain('layout-buildtime')\n-          }\n+          const layout = await browser.elementById('layout').text()\n+          expect(layout).toInclude(isNextDev ? 'runtime' : 'buildtime')\n+\n+          const headers = response.headers()\n \n           if (isNextDeploy) {\n-            expect(res.headers.get('x-matched-path')).toBe(\n+            expect(headers['x-matched-path']).toBe(\n               '/with-cached-io/with-suspense/params-not-in-page/[slug]'\n             )\n           } else if (isNextStart) {\n-            expect(res.headers.get('x-nextjs-postponed')).toBe('1')\n+            expect(headers['x-nextjs-postponed']).toBe('1')\n           }\n         })\n       })\n \n       describe('and params.then/catch/finally passed to a cached function', () => {\n         it('resumes a postponed fallback shell', async () => {\n-          const res = await next.fetch(\n+          const { browser, response } = await next.browserWithResponse(\n             '/with-cached-io/with-suspense/params-then-in-page/bar'\n           )\n \n-          const html = await res.text()\n-          expect(html).toIncludeRepeated('data-testid=\"page-bar\"', 4)\n+          const lastModified = await browser.elementById('last-modified').text()\n+          expect(lastModified).toInclude('Page /bar')\n+          expect(lastModified).toInclude('runtime')\n \n-          if (isNextDev) {\n-            expect(html).toContain('layout-runtime')\n-          } else {\n-            expect(html).toContain('layout-buildtime')\n-          }\n+          const layout = await browser.elementById('layout').text()\n+          expect(layout).toInclude(isNextDev ? 'runtime' : 'buildtime')\n+\n+          const headers = response.headers()\n \n           if (isNextDeploy) {\n-            expect(res.headers.get('x-matched-path')).toBe(\n+            expect(headers['x-matched-path']).toBe(\n               '/with-cached-io/with-suspense/params-then-in-page/[slug]'\n             )\n           } else if (isNextStart) {\n-            expect(res.headers.get('x-nextjs-postponed')).toBe('1')\n+            expect(headers['x-nextjs-postponed']).toBe('1')\n           }\n         })\n       })\n@@ -102,77 +104,92 @@ describe('empty-fallback-shells', () => {\n     describe('and the page not wrapped in Suspense', () => {\n       describe('and the params accessed in the cached page', () => {\n         it('does not resume a postponed fallback shell', async () => {\n-          const res = await next.fetch(\n+          const { browser, response } = await next.browserWithResponse(\n             '/with-cached-io/without-suspense/params-in-page/bar'\n           )\n \n-          const html = await res.text()\n-          expect(html).toContain('page-bar')\n-          expect(html).toContain('layout-runtime')\n+          const lastModified = await browser.elementById('last-modified').text()\n+          expect(lastModified).toInclude('Page /bar')\n+          expect(lastModified).toInclude('runtime')\n+\n+          const layout = await browser.elementById('layout').text()\n+          expect(layout).toInclude('runtime')\n+\n+          const headers = response.headers()\n \n           if (isNextDeploy) {\n-            expect(res.headers.get('x-matched-path')).toBe(\n+            expect(headers['x-matched-path']).toBe(\n               '/with-cached-io/without-suspense/params-in-page/[slug]'\n             )\n-          } else {\n-            expect(res.headers.get('x-nextjs-postponed')).not.toBe('1')\n+          } else if (isNextStart) {\n+            expect(headers['x-nextjs-postponed']).not.toBe('1')\n           }\n         })\n \n         it('does not render a fallback shell when using a params placeholder', async () => {\n           // This should trigger a blocking prerender of the route shell.\n-          const res = await next.fetch(\n+          const { browser, response } = await next.browserWithResponse(\n             '/with-cached-io/without-suspense/params-in-page/[slug]'\n           )\n \n-          expect(res.status).toBe(200)\n-\n-          const html = await res.text()\n+          expect(response.status()).toBe(200)\n \n           // This should render the encoded param in the route shell, and not\n           // interpret the param as a fallback param, and subsequently try to\n           // render the fallback shell instead, which would fail because of the\n           // missing parent suspense boundary.\n-          expect(html).toContain('page-%5Bslug%5D')\n+          const lastModified = await browser.elementById('last-modified').text()\n+          expect(lastModified).toInclude('Page /%5Bslug%5D')\n+          expect(lastModified).toInclude('runtime')\n         })\n       })\n \n       describe('and the params accessed in a cached non-page function', () => {\n         it('does not resume a postponed fallback shell', async () => {\n-          const res = await next.fetch(\n+          const { browser, response } = await next.browserWithResponse(\n             '/with-cached-io/without-suspense/params-not-in-page/bar'\n           )\n \n-          const html = await res.text()\n-          expect(html).toContain('page-bar')\n-          expect(html).toContain('layout-runtime')\n+          const lastModified = await browser.elementById('last-modified').text()\n+          expect(lastModified).toInclude('Page /bar')\n+          expect(lastModified).toInclude('runtime')\n+\n+          const layout = await browser.elementById('layout').text()\n+          expect(layout).toInclude('runtime')\n+\n+          const headers = response.headers()\n \n           if (isNextDeploy) {\n-            expect(res.headers.get('x-matched-path')).toBe(\n+            expect(headers['x-matched-path']).toBe(\n               '/with-cached-io/without-suspense/params-not-in-page/[slug]'\n             )\n-          } else {\n-            expect(res.headers.get('x-nextjs-postponed')).not.toBe('1')\n+          } else if (isNextStart) {\n+            expect(headers['x-nextjs-postponed']).not.toBe('1')\n           }\n         })\n       })\n \n       describe('and params.then/catch/finally passed to a cached function', () => {\n         it('does not resume a postponed fallback shell', async () => {\n-          const res = await next.fetch(\n+          const { browser, response } = await next.browserWithResponse(\n             '/with-cached-io/without-suspense/params-then-in-page/bar'\n           )\n \n-          const html = await res.text()\n-          expect(html).toIncludeRepeated('data-testid=\"page-bar\"', 4)\n-          expect(html).toContain('layout-runtime')\n+          const lastModified = await browser.elementById('last-modified').text()\n+          expect(lastModified).toInclude('Page /bar')\n+          expect(lastModified).toInclude('runtime')\n+\n+          const layout = await browser.elementById('layout').text()\n+          expect(layout).toInclude('runtime')\n+\n+          const headers = response.headers()\n \n           if (isNextDeploy) {\n-            expect(res.headers.get('x-matched-path')).toBe(\n+            expect(headers['x-matched-path']).toBe(\n               '/with-cached-io/without-suspense/params-then-in-page/[slug]'\n             )\n-          } else {\n-            expect(res.headers.get('x-nextjs-postponed')).not.toBe('1')\n+          } else if (isNextStart) {\n+            expect(headers['x-nextjs-postponed']).not.toBe('1')\n           }\n         })\n       })"
        },
        {
            "sha": "19aaafc47039497ec274970ced24482d524a16f6",
            "filename": "test/lib/next-modes/base.ts",
            "status": "modified",
            "additions": 45,
            "deletions": 1,
            "changes": 46,
            "blob_url": "https://github.com/vercel/next.js/blob/614329711ea861001e905b3c5f97d8a2ab9b3379/test%2Flib%2Fnext-modes%2Fbase.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/614329711ea861001e905b3c5f97d8a2ab9b3379/test%2Flib%2Fnext-modes%2Fbase.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Flib%2Fnext-modes%2Fbase.ts?ref=614329711ea861001e905b3c5f97d8a2ab9b3379",
            "patch": "@@ -13,6 +13,7 @@ import cheerio from 'cheerio'\n import { once } from 'events'\n import { Playwright } from 'next-webdriver'\n import escapeStringRegexp from 'escape-string-regexp'\n+import { Page, Response } from 'playwright'\n \n type Event = 'stdout' | 'stderr' | 'error' | 'destroy'\n export type InstallCommand =\n@@ -664,14 +665,57 @@ export class NextInstance {\n   }\n \n   /**\n-   * Create new browser window for the Next.js app.\n+   * Create a new browser window for the Next.js app.\n    */\n   public async browser(\n     ...args: Parameters<OmitFirstArgument<typeof webdriver>>\n   ): Promise<Playwright> {\n     return webdriver(this.url, ...args)\n   }\n \n+  /**\n+   * Create a new browser window for the Next.js app, and also return the page's\n+   * response.\n+   */\n+  public async browserWithResponse(\n+    ...args: Parameters<OmitFirstArgument<typeof webdriver>>\n+  ): Promise<{ browser: Playwright; response: Response }> {\n+    const [url, options = {}] = args\n+\n+    let resolveResponse: (response: Response) => void\n+\n+    const responsePromise = new Promise<Response>((resolve, reject) => {\n+      const timer = setTimeout(() => {\n+        reject(`Timed out waiting for the response of ${url}`)\n+      }, 10_000)\n+\n+      resolveResponse = (response: Response) => {\n+        clearTimeout(timer)\n+        resolve(response)\n+      }\n+    })\n+\n+    const absoluteUrl = new URL(url, this.url).href\n+\n+    const [browser, response] = await Promise.all([\n+      webdriver(this.url, url, {\n+        ...options,\n+        beforePageLoad(page: Page) {\n+          options.beforePageLoad?.(page)\n+\n+          page.on('response', async (response) => {\n+            if (response.url() === absoluteUrl) {\n+              resolveResponse(response)\n+            }\n+          })\n+        },\n+      }),\n+      responsePromise,\n+    ])\n+\n+    return { browser, response }\n+  }\n+\n   /**\n    * Fetch the HTML for the provided page. This is a shortcut for `renderViaHTTP().then(html => cheerio.load(html))`.\n    */"
        }
    ],
    "stats": {
        "total": 202,
        "additions": 133,
        "deletions": 69
    }
}