{
    "author": "bgw",
    "message": "Turbopack: Merge babel-loader and react-compiler configuration logic to avoid running babel twice (#83502)\n\nPort the logic for configuring react-compiler from JS to Rust.\n\nThis fixes two issues:\n- Babel could run twice if you had both react compiler enabled and a babel config file.\n- We can now emit a warning if we detect you manually configured babel. Previously, this wasn't safe because we could erroneously warn if react compiler was enabled.",
    "sha": "b853167072928d0d7bc281a278a518ff489b6223",
    "files": [
        {
            "sha": "e835a79953a230e2289ab3d18b3d5c95b7c0377d",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -1314,9 +1314,7 @@ impl AppEndpoint {\n \n         // polyfill-nomodule.js is a pre-compiled asset distributed as part of next,\n         // load it as a RawModule.\n-        let next_package = get_next_package(project.project_path().owned().await?)\n-            .owned()\n-            .await?;\n+        let next_package = get_next_package(project.project_path().owned().await?).await?;\n         let polyfill_source =\n             FileSource::new(next_package.join(\"dist/build/polyfills/polyfill-nomodule.js\")?);\n         let polyfill_output_path = client_chunking_context"
        },
        {
            "sha": "2bbe822463cd025d9c6c9012a9d8b8801110f433",
            "filename": "crates/next-core/src/next_build.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Fnext_build.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Fnext_build.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_build.rs?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -16,7 +16,7 @@ pub async fn get_postcss_package_mapping(\n             .resolved_cell(),\n         ImportMapping::PrimaryAlternative(\n             rcstr!(\"postcss\"),\n-            Some(get_next_package(project_path.clone()).owned().await?),\n+            Some(get_next_package(project_path.clone()).await?),\n         )\n         .resolved_cell(),\n     ])"
        },
        {
            "sha": "4571a65794484252ee9eb157f1243d7967a307a4",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 51,
            "deletions": 19,
            "changes": 70,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -736,21 +736,42 @@ pub enum MdxRsOptions {\n #[turbo_tasks::value(shared, operation)]\n #[derive(Clone, Debug)]\n #[serde(rename_all = \"camelCase\")]\n-pub enum ReactCompilerMode {\n+pub enum ReactCompilerCompilationMode {\n     Infer,\n     Annotation,\n     All,\n }\n \n-/// Subset of react compiler options\n+impl Default for ReactCompilerCompilationMode {\n+    fn default() -> Self {\n+        Self::Infer\n+    }\n+}\n+\n #[turbo_tasks::value(shared, operation)]\n #[derive(Clone, Debug)]\n+#[serde(rename_all = \"snake_case\")]\n+pub enum ReactCompilerPanicThreshold {\n+    None,\n+    CriticalErrors,\n+    AllErrors,\n+}\n+\n+impl Default for ReactCompilerPanicThreshold {\n+    fn default() -> Self {\n+        Self::None\n+    }\n+}\n+\n+/// Subset of react compiler options\n+#[turbo_tasks::value(shared, operation)]\n+#[derive(Clone, Debug, Default)]\n #[serde(rename_all = \"camelCase\")]\n pub struct ReactCompilerOptions {\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub compilation_mode: Option<ReactCompilerMode>,\n-    #[serde(skip_serializing_if = \"Option::is_none\")]\n-    pub panic_threshold: Option<RcStr>,\n+    #[serde(default)]\n+    pub compilation_mode: ReactCompilerCompilationMode,\n+    #[serde(default)]\n+    pub panic_threshold: ReactCompilerPanicThreshold,\n }\n \n #[derive(\n@@ -1304,6 +1325,14 @@ impl NextConfig {\n         Ok(config.cell())\n     }\n \n+    #[turbo_tasks::function]\n+    pub async fn config_file_path(\n+        &self,\n+        project_path: FileSystemPath,\n+    ) -> Result<Vc<FileSystemPath>> {\n+        Ok(project_path.join(&self.config_file_name)?.cell())\n+    }\n+\n     #[turbo_tasks::function]\n     pub fn bundle_pages_router_dependencies(&self) -> Vc<bool> {\n         Vc::cell(self.bundle_pages_router_dependencies.unwrap_or_default())\n@@ -1388,8 +1417,12 @@ impl NextConfig {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn webpack_rules(&self, project_path: FileSystemPath) -> Result<Vc<WebpackRules>> {\n-        let Some(turbo_rules) = self.turbopack.as_ref().and_then(|t| t.rules.as_ref()) else {\n+    pub async fn webpack_rules(\n+        self: Vc<Self>,\n+        project_path: FileSystemPath,\n+    ) -> Result<Vc<WebpackRules>> {\n+        let this = self.await?;\n+        let Some(turbo_rules) = this.turbopack.as_ref().and_then(|t| t.rules.as_ref()) else {\n             return Ok(Vc::cell(Vec::new()));\n         };\n         if turbo_rules.is_empty() {\n@@ -1412,7 +1445,6 @@ impl NextConfig {\n                         .collect(),\n                 )\n             }\n-            let config_file_path = || project_path.join(&self.config_file_name);\n             for item in &rule_collection.0 {\n                 match item {\n                     RuleConfigCollectionItem::Shorthand(loaders) => {\n@@ -1439,7 +1471,10 @@ impl NextConfig {\n                         {\n                             InvalidLoaderRuleRenameAsIssue {\n                                 glob: glob.clone(),\n-                                config_file_path: config_file_path()?,\n+                                config_file_path: self\n+                                    .config_file_path(project_path.clone())\n+                                    .owned()\n+                                    .await?,\n                                 rename_as: rename_as.clone(),\n                             }\n                             .resolved_cell()\n@@ -1454,7 +1489,10 @@ impl NextConfig {\n                             } else {\n                                 InvalidLoaderRuleConditionIssue {\n                                     condition: condition.clone(),\n-                                    config_file_path: config_file_path()?,\n+                                    config_file_path: self\n+                                        .config_file_path(project_path.clone())\n+                                        .owned()\n+                                        .await?,\n                                 }\n                                 .resolved_cell()\n                                 .emit();\n@@ -1605,18 +1643,12 @@ impl NextConfig {\n     }\n \n     #[turbo_tasks::function]\n-    pub fn react_compiler(&self) -> Vc<OptionalReactCompilerOptions> {\n+    pub fn react_compiler_options(&self) -> Vc<OptionalReactCompilerOptions> {\n         let options = &self.experimental.react_compiler;\n \n         let options = match options {\n             Some(ReactCompilerOptionsOrBoolean::Boolean(true)) => {\n-                OptionalReactCompilerOptions(Some(\n-                    ReactCompilerOptions {\n-                        compilation_mode: None,\n-                        panic_threshold: None,\n-                    }\n-                    .resolved_cell(),\n-                ))\n+                OptionalReactCompilerOptions(Some(ReactCompilerOptions::default().resolved_cell()))\n             }\n             Some(ReactCompilerOptionsOrBoolean::Option(options)) => OptionalReactCompilerOptions(\n                 Some(ReactCompilerOptions { ..options.clone() }.resolved_cell()),"
        },
        {
            "sha": "39cd4ae2616cf53b6f96389c7abb7b858a37e810",
            "filename": "crates/next-core/src/next_import_map.rs",
            "status": "modified",
            "additions": 18,
            "deletions": 9,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Fnext_import_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Fnext_import_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_import_map.rs?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -25,7 +25,7 @@ use crate::{\n     embed_js::{VIRTUAL_PACKAGE_NAME, next_js_fs},\n     mode::NextMode,\n     next_client::context::ClientContextType,\n-    next_config::NextConfig,\n+    next_config::{NextConfig, OptionFileSystemPath},\n     next_edge::unsupported::NextEdgeUnsupportedModuleReplacer,\n     next_font::google::{\n         GOOGLE_FONTS_INTERNAL_PREFIX, NextFontGoogleCssModuleReplacer,\n@@ -704,7 +704,7 @@ async fn insert_next_server_special_aliases(\n         ServerContextType::AppSSR { app_dir }\n         | ServerContextType::AppRSC { app_dir, .. }\n         | ServerContextType::AppRoute { app_dir, .. } => {\n-            let next_package = get_next_package(app_dir.clone()).owned().await?;\n+            let next_package = get_next_package(app_dir.clone()).await?;\n             import_map.insert_exact_alias(\n                 rcstr!(\"styled-jsx\"),\n                 request_to_import_mapping(next_package.clone(), rcstr!(\"styled-jsx\")),\n@@ -1134,7 +1134,7 @@ async fn insert_next_shared_aliases(\n         .resolved_cell(),\n     );\n \n-    let next_package = get_next_package(project_path.clone()).owned().await?;\n+    let next_package = get_next_package(project_path.clone()).await?;\n     import_map.insert_singleton_alias(rcstr!(\"@swc/helpers\"), next_package.clone());\n     import_map.insert_singleton_alias(rcstr!(\"styled-jsx\"), next_package.clone());\n     import_map.insert_singleton_alias(rcstr!(\"next\"), project_path.clone());\n@@ -1233,20 +1233,29 @@ async fn insert_next_shared_aliases(\n     Ok(())\n }\n \n+pub async fn get_next_package(context_directory: FileSystemPath) -> Result<FileSystemPath> {\n+    try_get_next_package(context_directory)\n+        .owned()\n+        .await?\n+        .context(\"Next.js package not found\")\n+}\n+\n #[turbo_tasks::function]\n-pub async fn get_next_package(context_directory: FileSystemPath) -> Result<Vc<FileSystemPath>> {\n+pub async fn try_get_next_package(\n+    context_directory: FileSystemPath,\n+) -> Result<Vc<OptionFileSystemPath>> {\n     let root = context_directory.root().owned().await?;\n     let result = resolve(\n         context_directory,\n         ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined),\n         Request::parse(Pattern::Constant(rcstr!(\"next/package.json\"))),\n         node_cjs_resolve_options(root),\n     );\n-    let source = result\n-        .first_source()\n-        .await?\n-        .context(\"Next.js package not found\")?;\n-    Ok(source.ident().path().await?.parent().cell())\n+    if let Some(source) = &*result.first_source().await? {\n+        Ok(Vc::cell(Some(source.ident().path().await?.parent())))\n+    } else {\n+        Ok(Vc::cell(None))\n+    }\n }\n \n pub async fn insert_alias_option<const N: usize>("
        },
        {
            "sha": "ba7f676678dd51f5f2f130c1da6239c33cc47bac",
            "filename": "crates/next-core/src/next_shared/webpack_rules/babel.rs",
            "status": "modified",
            "additions": 236,
            "deletions": 19,
            "changes": 255,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fbabel.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fbabel.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fbabel.rs?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -1,14 +1,27 @@\n-use std::sync::LazyLock;\n+use std::{collections::BTreeSet, sync::LazyLock};\n \n use anyhow::{Context, Result};\n use regex::Regex;\n+use turbo_esregex::EsRegex;\n use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::ResolvedVc;\n+use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::{self, FileSystemEntryType, FileSystemPath, to_sys_path};\n use turbopack::module_options::{ConditionItem, LoaderRuleItem};\n+use turbopack_core::{\n+    issue::{Issue, IssueExt, IssueSeverity, IssueStage, OptionStyledString, StyledString},\n+    reference_type::{CommonJsReferenceSubType, ReferenceType},\n+    resolve::{node::node_cjs_resolve_options, parse::Request, pattern::Pattern, resolve},\n+    source::Source,\n+};\n use turbopack_node::transforms::webpack::WebpackLoaderItem;\n \n-use crate::next_shared::webpack_rules::WebpackLoaderBuiltinCondition;\n+use crate::{\n+    next_config::{NextConfig, ReactCompilerCompilationMode},\n+    next_import_map::try_get_next_package,\n+    next_shared::webpack_rules::{\n+        ManuallyConfiguredBuiltinLoaderIssue, WebpackLoaderBuiltinCondition,\n+    },\n+};\n \n // https://babeljs.io/docs/config-files\n // TODO: Also support a `babel` key in a package.json file\n@@ -31,7 +44,12 @@ static BABEL_LOADER_RE: LazyLock<Regex> =\n /// is always available, as it's installed as part of next.js.\n const NEXT_JS_BABEL_LOADER: &str = \"next/dist/build/babel/loader\";\n \n-pub async fn detect_likely_babel_loader(\n+const BABEL_PLUGIN_REACT_COMPILER: &str = \"babel-plugin-react-compiler\";\n+const BABEL_PLUGIN_REACT_COMPILER_PACKAGE_JSON: &str = \"babel-plugin-react-compiler/package.json\";\n+\n+/// Detect manually-configured babel loaders. This is used to generate a warning, suggesting using\n+/// the built-in babel support.\n+async fn detect_likely_babel_loader(\n     webpack_rules: &[(RcStr, LoaderRuleItem)],\n ) -> Result<Option<RcStr>> {\n     for (glob, rule) in webpack_rules {\n@@ -51,35 +69,130 @@ pub async fn detect_likely_babel_loader(\n /// configuration, automatically add `babel-loader` as a webpack loader for each eligible file type\n /// if it doesn't already exist.\n pub async fn get_babel_loader_rules(\n-    project_root: FileSystemPath,\n+    project_path: &FileSystemPath,\n+    next_config: Vc<NextConfig>,\n+    builtin_conditions: &BTreeSet<WebpackLoaderBuiltinCondition>,\n+    user_webpack_rules: &[(RcStr, LoaderRuleItem)],\n ) -> Result<Vec<(RcStr, LoaderRuleItem)>> {\n+    // We never run babel over foreign code, under the assumption that `node_modules` code should\n+    // not require any transforms that SWC does not provide. If somebody really needs this, they can\n+    // manually configure a babel loader.\n+    if builtin_conditions.contains(&WebpackLoaderBuiltinCondition::Foreign) {\n+        return Ok(Vec::new());\n+    }\n+\n+    let use_builtin_babel = next_config\n+        .experimental_turbopack_use_builtin_babel()\n+        .await?;\n+\n+    if use_builtin_babel.is_none()\n+        && let Some(glob) = detect_likely_babel_loader(user_webpack_rules).await?\n+    {\n+        ManuallyConfiguredBuiltinLoaderIssue {\n+            glob,\n+            loader: rcstr!(\"babel-loader\"),\n+            config_key: rcstr!(\"experimental.turbopackUseBuiltinBabel\"),\n+            config_file_path: next_config\n+                .config_file_path(project_path.clone())\n+                .owned()\n+                .await?,\n+        }\n+        .resolved_cell()\n+        .emit()\n+    }\n+\n     let mut babel_config_path = None;\n-    for &filename in BABEL_CONFIG_FILES {\n-        let path = project_root.join(filename)?;\n-        let filetype = *path.get_type().await?;\n-        if matches!(filetype, FileSystemEntryType::File) {\n-            babel_config_path = Some(path);\n-            break;\n+    if use_builtin_babel.unwrap_or(true) {\n+        for &filename in BABEL_CONFIG_FILES {\n+            let path = project_path.join(filename)?;\n+            let filetype = *path.get_type().await?;\n+            if matches!(filetype, FileSystemEntryType::File) {\n+                babel_config_path = Some(path);\n+                break;\n+            }\n         }\n     }\n-    let Some(babel_config_path) = babel_config_path else {\n+\n+    let react_compiler_options = next_config.react_compiler_options().await?;\n+\n+    // if there's no babel config and react-compiler shouldn't be enabled, bail out early\n+    if babel_config_path.is_none()\n+        && (react_compiler_options.is_none()\n+            || !builtin_conditions.contains(&WebpackLoaderBuiltinCondition::Browser))\n+    {\n         return Ok(Vec::new());\n-    };\n+    }\n \n     // - See `packages/next/src/build/babel/loader/types.d.ts` for all the configuration options.\n     // - See `packages/next/src/build/get-babel-loader-config.ts` for how we use this in webpack.\n-    let serde_json::Value::Object(loader_options) = serde_json::json!({\n+    let serde_json::Value::Object(mut loader_options) = serde_json::json!({\n         // `transformMode: default` (what the webpack implementation does) would run all of the\n         // Next.js-specific transforms as babel transforms. Because we always have to pay the cost\n         // of parsing with SWC after the webpack loader runs, we want to keep running those\n         // transforms using SWC, so use `standalone` instead.\n         \"transformMode\": \"standalone\",\n-        \"cwd\": to_sys_path_str(project_root).await?,\n-        \"configFile\": to_sys_path_str(babel_config_path).await?,\n+        \"cwd\": to_sys_path_str(project_path.clone()).await?,\n+        \"isServer\": !builtin_conditions.contains(&WebpackLoaderBuiltinCondition::Browser),\n     }) else {\n         unreachable!(\"is an object\")\n     };\n \n+    if let Some(babel_config_path) = &babel_config_path {\n+        loader_options.insert(\n+            \"configFile\".to_owned(),\n+            to_sys_path_str(babel_config_path.clone()).await?.into(),\n+        );\n+    }\n+\n+    let mut loader_conditions = Vec::new();\n+    if let Some(react_compiler_options) = &*react_compiler_options\n+        && let Some(babel_plugin_path) =\n+            resolve_babel_plugin_react_compiler(next_config, project_path).await?\n+    {\n+        let react_compiler_options = react_compiler_options.await?;\n+        let react_compiler_plugins =\n+            serde_json::Value::Array(vec![serde_json::Value::Array(vec![\n+                serde_json::Value::String(babel_plugin_path.into_owned()),\n+                serde_json::to_value(&*react_compiler_options)\n+                    .expect(\"react compiler options JSON serialization should never fail\"),\n+            ])]);\n+\n+        loader_options.insert(\"reactCompilerPlugins\".to_owned(), react_compiler_plugins);\n+\n+        if babel_config_path.is_none() {\n+            // We're only running react-compiler, so add some extra conditions to limit when babel\n+            // runs for performance reasons\n+            //\n+            // NOTE: we already bail out at the earlier if `foreign` condition is set or if\n+            // `browser` is not set.\n+            match react_compiler_options.compilation_mode {\n+                ReactCompilerCompilationMode::Annotation => {\n+                    loader_conditions.push(ConditionItem::Base {\n+                        path: None,\n+                        content: Some(\n+                            EsRegex::new(r#\"['\"]use memo['\"]\"#, \"\")\n+                                .expect(\"valid const regex\")\n+                                .resolved_cell(),\n+                        ),\n+                    });\n+                }\n+                ReactCompilerCompilationMode::Infer => {\n+                    loader_conditions.push(ConditionItem::Base {\n+                        path: None,\n+                        // Matches declaration or useXXX or </ (closing jsx) or /> (self closing\n+                        // jsx)\n+                        content: Some(\n+                            EsRegex::new(r#\"['\"]use memo['\"]|\\Wuse[A-Z]|<\\/|\\/>\"#, \"\")\n+                                .expect(\"valid const regex\")\n+                                .resolved_cell(),\n+                        ),\n+                    });\n+                }\n+                ReactCompilerCompilationMode::All => {}\n+            }\n+        }\n+    }\n+\n     Ok(vec![(\n         rcstr!(\"*.{js,jsx,ts,tsx,cjs,mjs,mts,cts}\"),\n         LoaderRuleItem {\n@@ -88,9 +201,7 @@ pub async fn get_babel_loader_rules(\n                 options: loader_options,\n             }]),\n             rename_as: Some(rcstr!(\"*\")),\n-            condition: Some(ConditionItem::Not(Box::new(ConditionItem::Builtin(\n-                RcStr::from(WebpackLoaderBuiltinCondition::Foreign.as_str()),\n-            )))),\n+            condition: Some(ConditionItem::All(loader_conditions.into())),\n         },\n     )])\n }\n@@ -105,3 +216,109 @@ async fn to_sys_path_str(path: FileSystemPath) -> Result<String> {\n         .with_context(|| format!(\"{sys_path:?} is not valid utf-8\"))?\n         .to_owned())\n }\n+\n+/// Resolve `babel-plugin-react-compiler` relative to `next`. This matches the behavior of the\n+/// webpack implementation, which resolves the Babel plugin from within `next`. The Babel plugin is\n+/// an optional peer dependency of `next`.\n+///\n+/// The returned path is relative to `project_path`. `project_path` should be the value given to\n+/// `babel-loader` using the `cwd` option.\n+pub async fn resolve_babel_plugin_react_compiler(\n+    next_config: Vc<NextConfig>,\n+    project_path: &FileSystemPath,\n+) -> Result<Option<RcStr>> {\n+    let Some(next_package) = &*try_get_next_package(project_path.clone()).await? else {\n+        BabelPluginReactCompilerResolutionIssue {\n+            failed_resolution: rcstr!(\"next\"),\n+            config_file_path: next_config\n+                .config_file_path(project_path.clone())\n+                .owned()\n+                .await?,\n+        }\n+        .resolved_cell()\n+        .emit();\n+        return Ok(None);\n+    };\n+\n+    let babel_plugin_result = resolve(\n+        next_package.clone(),\n+        ReferenceType::CommonJs(CommonJsReferenceSubType::Undefined),\n+        Request::parse(Pattern::Constant(rcstr!(\n+            BABEL_PLUGIN_REACT_COMPILER_PACKAGE_JSON\n+        ))),\n+        node_cjs_resolve_options(project_path.root().owned().await?),\n+    );\n+    let Some(source) = &*babel_plugin_result.first_source().await? else {\n+        BabelPluginReactCompilerResolutionIssue {\n+            failed_resolution: rcstr!(BABEL_PLUGIN_REACT_COMPILER),\n+            config_file_path: next_config\n+                .config_file_path(project_path.clone())\n+                .owned()\n+                .await?,\n+        }\n+        .resolved_cell()\n+        .emit();\n+        return Ok(None);\n+    };\n+\n+    Ok(Some(\n+        // the relative path should only ever fail to resolve when the `fs` is different, which\n+        // should only happen due to eventual consistency.\n+        project_path\n+            .get_relative_path_to(&source.ident().path().await?.parent())\n+            .context(\"failed to resolve relative path for react compiler plugin\")?,\n+    ))\n+}\n+\n+#[turbo_tasks::value]\n+struct BabelPluginReactCompilerResolutionIssue {\n+    failed_resolution: RcStr,\n+    config_file_path: FileSystemPath,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Issue for BabelPluginReactCompilerResolutionIssue {\n+    #[turbo_tasks::function]\n+    fn stage(&self) -> Vc<IssueStage> {\n+        IssueStage::Transform.into()\n+    }\n+\n+    fn severity(&self) -> IssueSeverity {\n+        IssueSeverity::Error\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn file_path(&self) -> Vc<FileSystemPath> {\n+        self.config_file_path.clone().cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn title(&self) -> Vc<StyledString> {\n+        StyledString::Line(vec![\n+            StyledString::Text(rcstr!(\"Failed to resolve package \")),\n+            StyledString::Code(self.failed_resolution.clone()),\n+            StyledString::Text(rcstr!(\" while attempting to resolve React Compiler\")),\n+        ])\n+        .cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn description(&self) -> Vc<OptionStyledString> {\n+        Vc::cell(Some(\n+            StyledString::Line(vec![\n+                StyledString::Text(rcstr!(\"React compiler is enabled in \")),\n+                StyledString::Code(self.config_file_path.path.clone()),\n+                StyledString::Text(rcstr!(\n+                    \". We attempted to resolve React Compiler relative to the \"\n+                )),\n+                StyledString::Code(rcstr!(\"next\")),\n+                StyledString::Text(rcstr!(\" package. Is \")),\n+                StyledString::Code(rcstr!(BABEL_PLUGIN_REACT_COMPILER)),\n+                StyledString::Text(rcstr!(\" installed in your \")),\n+                StyledString::Code(rcstr!(\"node_modules\")),\n+                StyledString::Text(rcstr!(\" directory?\")),\n+            ])\n+            .resolved_cell(),\n+        ))\n+    }\n+}"
        },
        {
            "sha": "c608521982b6cf2a64944cadbba450348958b0b1",
            "filename": "crates/next-core/src/next_shared/webpack_rules/mod.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 62,
            "changes": 72,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fmod.rs?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -9,16 +9,13 @@ use turbopack::module_options::{\n     WebpackLoaderBuiltinConditionSet, WebpackLoaderBuiltinConditionSetMatch, WebpackLoadersOptions,\n };\n use turbopack_core::{\n-    issue::{Issue, IssueExt, IssueSeverity, IssueStage, OptionStyledString, StyledString},\n+    issue::{Issue, IssueSeverity, IssueStage, OptionStyledString, StyledString},\n     resolve::{ExternalTraced, ExternalType, options::ImportMapping},\n };\n \n use crate::{\n     next_config::NextConfig,\n-    next_shared::webpack_rules::{\n-        babel::{detect_likely_babel_loader, get_babel_loader_rules},\n-        sass::{detect_likely_sass_loader, get_sass_loader_rules},\n-    },\n+    next_shared::webpack_rules::{babel::get_babel_loader_rules, sass::get_sass_loader_rules},\n };\n \n pub(crate) mod babel;\n@@ -147,63 +144,14 @@ pub async fn webpack_loader_options(\n     next_config: Vc<NextConfig>,\n     builtin_conditions: BTreeSet<WebpackLoaderBuiltinCondition>,\n ) -> Result<Vc<OptionWebpackLoadersOptions>> {\n-    let mut rules = next_config\n-        .webpack_rules(project_path.clone())\n-        .owned()\n-        .await?;\n+    let user_rules = next_config.webpack_rules(project_path.clone()).await?;\n+    let mut rules = (*user_rules).clone();\n \n-    let config_file_path = async || project_path.join(&next_config.await?.config_file_name);\n-\n-    let use_builtin_sass = next_config\n-        .experimental_turbopack_use_builtin_sass()\n-        .await?;\n-    if use_builtin_sass.unwrap_or(true) {\n-        if use_builtin_sass.is_none()\n-            && let Some(glob) = detect_likely_sass_loader(&rules).await?\n-        {\n-            ManuallyConfiguredBuiltinLoaderIssue {\n-                glob,\n-                loader: rcstr!(\"sass-loader\"),\n-                config_key: rcstr!(\"experimental.turbopackUseBuiltinSass\"),\n-                config_file_path: config_file_path().await?,\n-            }\n-            .resolved_cell()\n-            .emit()\n-        }\n-        rules.append(&mut get_sass_loader_rules(next_config.sass_config()).await?);\n-    }\n-\n-    // TODO: Enable this warning after babel configuration is fixed\n-    // (https://github.com/vercel/next.js/pull/82676) and the react-compiler logic is moved into\n-    // here. React-compiler is currently configured in JS before it gets to us, which could trigger\n-    // false-positives.\n-    let use_builtin_babel = next_config\n-        .experimental_turbopack_use_builtin_babel()\n-        .await?;\n-    if !builtin_conditions.contains(&WebpackLoaderBuiltinCondition::Foreign)\n-        && use_builtin_babel.unwrap_or(true)\n-    {\n-        if use_builtin_babel.is_none()\n-            && let Some(glob) = detect_likely_babel_loader(&rules).await?\n-        {\n-            let _ = glob;\n-            // TODO: Enable this warning after babel configuration is fixed\n-            // (https://github.com/vercel/next.js/pull/82676) and the react-compiler logic is moved into\n-            // here. React-compiler is currently configured in JS before it gets to us, which could\n-            // trigger false-positives.\n-            /*\n-            ManuallyConfiguredBuiltinLoaderIssue {\n-                glob,\n-                loader: rcstr!(\"babel-loader\"),\n-                disable_builtin_config_key: rcstr!(\"experimental.turbopackUseBuiltinBabel\"),\n-                config_file_path: config_file_path().await?,\n-            }\n-            .resolved_cell()\n-            .emit()\n-            */\n-        }\n-        rules.append(&mut get_babel_loader_rules(project_path.clone()).await?);\n-    }\n+    rules.append(&mut get_sass_loader_rules(&project_path, next_config, &user_rules).await?);\n+    rules.append(\n+        &mut get_babel_loader_rules(&project_path, next_config, &builtin_conditions, &user_rules)\n+            .await?,\n+    );\n \n     if rules.is_empty() {\n         return Ok(Vc::cell(None));\n@@ -235,7 +183,7 @@ fn loader_runner_package_mapping() -> Result<Vc<ImportMapping>> {\n }\n \n #[turbo_tasks::value]\n-struct ManuallyConfiguredBuiltinLoaderIssue {\n+pub struct ManuallyConfiguredBuiltinLoaderIssue {\n     glob: RcStr,\n     loader: RcStr,\n     config_key: RcStr,"
        },
        {
            "sha": "0d394f3493f04f049c6ab09e7b90fa96c3fac9c9",
            "filename": "crates/next-core/src/next_shared/webpack_rules/sass.rs",
            "status": "modified",
            "additions": 37,
            "deletions": 4,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fsass.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fsass.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fwebpack_rules%2Fsass.rs?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -2,12 +2,17 @@ use std::{mem::take, sync::LazyLock};\n \n use anyhow::{Result, bail};\n use regex::Regex;\n-use serde_json::Value as JsonValue;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks_fs::FileSystemPath;\n use turbopack::module_options::LoaderRuleItem;\n+use turbopack_core::issue::IssueExt;\n use turbopack_node::transforms::webpack::WebpackLoaderItem;\n \n+use crate::{\n+    next_config::NextConfig, next_shared::webpack_rules::ManuallyConfiguredBuiltinLoaderIssue,\n+};\n+\n // Try to match any reasonably-written glob pattern that might be intended to match `*.sass` or\n // `*.scss` (e.g. isn't just a full wildcard match with no extension)\n static SASS_GLOB_RE: LazyLock<Regex> = LazyLock::new(|| {\n@@ -17,7 +22,9 @@ static SASS_GLOB_RE: LazyLock<Regex> = LazyLock::new(|| {\n static SASS_LOADER_RE: LazyLock<Regex> =\n     LazyLock::new(|| Regex::new(r\"(^|/)@?sass[-/]loader($|/|\\.)\").unwrap());\n \n-pub async fn detect_likely_sass_loader(\n+/// Detect manually-configured sass loaders. This is used to generate a warning, suggesting using\n+/// the built-in sass support.\n+async fn detect_likely_sass_loader(\n     webpack_rules: &[(RcStr, LoaderRuleItem)],\n ) -> Result<Option<RcStr>> {\n     for (glob, rule) in webpack_rules {\n@@ -35,9 +42,35 @@ pub async fn detect_likely_sass_loader(\n }\n \n pub async fn get_sass_loader_rules(\n-    sass_options: Vc<JsonValue>,\n+    project_path: &FileSystemPath,\n+    next_config: Vc<NextConfig>,\n+    user_webpack_rules: &[(RcStr, LoaderRuleItem)],\n ) -> Result<Vec<(RcStr, LoaderRuleItem)>> {\n-    let sass_options = sass_options.await?;\n+    let use_builtin_sass = next_config\n+        .experimental_turbopack_use_builtin_sass()\n+        .await?;\n+\n+    match *use_builtin_sass {\n+        Some(true) => {}\n+        Some(false) => return Ok(Vec::new()),\n+        None => {\n+            if let Some(glob) = detect_likely_sass_loader(user_webpack_rules).await? {\n+                ManuallyConfiguredBuiltinLoaderIssue {\n+                    glob,\n+                    loader: rcstr!(\"sass-loader\"),\n+                    config_key: rcstr!(\"experimental.turbopackUseBuiltinSass\"),\n+                    config_file_path: next_config\n+                        .config_file_path(project_path.clone())\n+                        .owned()\n+                        .await?,\n+                }\n+                .resolved_cell()\n+                .emit();\n+            }\n+        }\n+    }\n+\n+    let sass_options = next_config.sass_config().await?;\n     let Some(mut sass_options) = sass_options.as_object().cloned() else {\n         bail!(\"sass_options must be an object\");\n     };"
        },
        {
            "sha": "b6f0e323231e53d40f950f7a5c99c346921bf318",
            "filename": "crates/next-core/src/util.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/crates%2Fnext-core%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Futil.rs?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -249,7 +249,7 @@ pub async fn load_next_js_template(\n     let content = file_content_rope(template_path.read()).await?;\n     let content = content.to_str()?;\n \n-    let package_root = &*get_next_package(project_path).await?;\n+    let package_root = get_next_package(project_path).await?;\n \n     let content = expand_next_js_template(\n         &content,"
        },
        {
            "sha": "838c2d54f2a83ab589ebe4ef86892b2ef76b7d79",
            "filename": "packages/next/src/build/babel/loader/get-config.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/packages%2Fnext%2Fsrc%2Fbuild%2Fbabel%2Floader%2Fget-config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/packages%2Fnext%2Fsrc%2Fbuild%2Fbabel%2Floader%2Fget-config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fbabel%2Floader%2Fget-config.ts?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -100,6 +100,7 @@ async function getCacheCharacteristics(\n   reactCompilerPlugins ??= []\n   const hasReactCompiler =\n     reactCompilerPlugins.length !== 0 &&\n+    !loaderOptions.isServer &&\n     !/[/\\\\]node_modules[/\\\\]/.test(filename) &&\n     !reactCompilerExclude?.(filename) &&\n     (await isReactCompilerRequired(filename))\n@@ -484,7 +485,7 @@ function getCacheKey(cacheCharacteristics: CharacteristicsGermaneToCaching) {\n     (hasModuleExports ? 0b010000 : 0) |\n     (hasReactCompiler ? 0b100000 : 0)\n \n-  // separate strings will null bytes, assuming null bytes are not valid in file\n+  // separate strings with null bytes, assuming null bytes are not valid in file\n   // paths\n   return `${configFilePath || ''}\\x00${fileExt}\\x00${flags}`\n }"
        },
        {
            "sha": "2289142cd15479325932fafeb4aa57bd829924fd",
            "filename": "packages/next/src/build/babel/loader/types.d.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/packages%2Fnext%2Fsrc%2Fbuild%2Fbabel%2Floader%2Ftypes.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/packages%2Fnext%2Fsrc%2Fbuild%2Fbabel%2Floader%2Ftypes.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fbabel%2Floader%2Ftypes.d.ts?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -68,6 +68,7 @@ export type NextBabelLoaderOptionDefaultPresets = NextBabelLoaderBaseOptions & {\n  */\n export type NextBabelLoaderOptionStandalone = NextBabelLoaderBaseOptions & {\n   transformMode: 'standalone'\n+  isServer: boolean\n }\n \n export type NextBabelLoaderOptions ="
        },
        {
            "sha": "5f0c057446c38a53635c75cd2ee69fe6add4496d",
            "filename": "packages/next/src/build/get-babel-loader-config.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 5,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/packages%2Fnext%2Fsrc%2Fbuild%2Fget-babel-loader-config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/packages%2Fnext%2Fsrc%2Fbuild%2Fget-babel-loader-config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fget-babel-loader-config.ts?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -1,8 +1,5 @@\n import path from 'path'\n-import type {\n-  ReactCompilerOptions,\n-  TurbopackLoaderOptions,\n-} from '../server/config-shared'\n+import type { ReactCompilerOptions } from '../server/config-shared'\n import type { NextBabelLoaderOptions } from './babel/loader/types'\n \n function getReactCompiler() {\n@@ -103,10 +100,11 @@ const getReactCompilerLoader = (\n     return undefined\n   }\n \n-  const babelLoaderOptions: NextBabelLoaderOptions & TurbopackLoaderOptions = {\n+  const babelLoaderOptions: NextBabelLoaderOptions = {\n     transformMode: 'standalone',\n     cwd,\n     reactCompilerPlugins,\n+    isServer,\n   }\n   if (reactCompilerExclude) {\n     babelLoaderOptions.reactCompilerExclude = reactCompilerExclude"
        },
        {
            "sha": "79be824e07bb105193aafc77686bd9ee55a533e8",
            "filename": "packages/next/src/build/swc/index.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 59,
            "changes": 61,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Findex.ts?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -10,7 +10,6 @@ import { patchIncorrectLockfile } from '../../lib/patch-incorrect-lockfile'\n import { downloadNativeNextSwc, downloadWasmSwc } from '../../lib/download-swc'\n import type {\n   NextConfigComplete,\n-  ReactCompilerOptions,\n   TurbopackLoaderBuiltinCondition,\n   TurbopackLoaderItem,\n   TurbopackRuleCondition,\n@@ -19,7 +18,6 @@ import type {\n } from '../../server/config-shared'\n import { isDeepStrictEqual } from 'util'\n import { type DefineEnvOptions, getDefineEnv } from '../define-env'\n-import { getReactCompilerLoader } from '../get-babel-loader-config'\n import type {\n   NapiPartialProjectOptions,\n   NapiProjectOptions,\n@@ -795,67 +793,12 @@ function bindingToApi(\n     }\n   }\n \n-  /**\n-   * Returns a new copy of next.js config object to avoid mutating the original.\n-   *\n-   * Also it does some augmentation to the configuration as well, for example set the\n-   * turbopack's rules if `experimental.reactCompilerOptions` is set.\n-   */\n-  function augmentNextConfig(\n-    originalNextConfig: NextConfigComplete,\n-    projectPath: string\n-  ): Record<string, any> {\n-    let nextConfig = { ...originalNextConfig }\n-\n-    // TODO: Merge this with `crates/next-core/src/next_shared/webpack_rules/babel.rs` so that we're\n-    // not configuring babel in two different places (potentially causing it to run twice)\n-    const reactCompilerOptions = nextConfig.experimental?.reactCompiler\n-    const reactCompilerLoader = getReactCompilerLoader(\n-      nextConfig.experimental?.reactCompiler,\n-      projectPath,\n-      /* isServer */ false,\n-      /* reactCompilerExclude */ undefined\n-    )\n-    if (reactCompilerLoader != null) {\n-      const options: ReactCompilerOptions =\n-        typeof reactCompilerOptions === 'object' ? reactCompilerOptions : {}\n-      nextConfig.turbopack = {\n-        ...originalNextConfig.turbopack,\n-        rules: {\n-          ...originalNextConfig.turbopack.rules,\n-          // assumption: there is no collision with this glob key\n-          '{*.{js,jsx,ts,tsx,cjs,mjs,mts,cts},react-compiler-builtin-rule}': {\n-            loaders: [reactCompilerLoader],\n-            condition: {\n-              all: [\n-                'browser',\n-                { not: 'foreign' },\n-                {\n-                  content:\n-                    options.compilationMode === 'annotation'\n-                      ? /['\"]use memo['\"]/\n-                      : !options.compilationMode ||\n-                          options.compilationMode === 'infer'\n-                        ? // Matches declaration or useXXX or </ (closing jsx) or /> (self closing jsx)\n-                          /['\"]use memo['\"]|\\Wuse[A-Z]|<\\/|\\/>/\n-                        : undefined,\n-                },\n-              ],\n-            },\n-          },\n-        },\n-      }\n-    }\n-\n-    return nextConfig\n-  }\n-\n   async function serializeNextConfig(\n     nextConfig: NextConfigComplete,\n     projectPath: string\n   ): Promise<string> {\n-    // Avoid mutating the existing `nextConfig` object. NOTE: This does a shallow clone.\n-    let nextConfigSerializable = augmentNextConfig(nextConfig, projectPath)\n+    // Avoid mutating the existing `nextConfig` object. NOTE: This is only a shallow clone.\n+    let nextConfigSerializable: Record<string, any> = { ...nextConfig }\n \n     nextConfigSerializable.generateBuildId =\n       await nextConfigSerializable.generateBuildId?.()"
        },
        {
            "sha": "ddd18f86cd8349db94373f42d6b376943704250e",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 2,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/b853167072928d0d7bc281a278a518ff489b6223/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/b853167072928d0d7bc281a278a518ff489b6223/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=b853167072928d0d7bc281a278a518ff489b6223",
            "patch": "@@ -517,8 +517,13 @@ export interface ExperimentalConfig {\n   turbopackUseSystemTlsCerts?: boolean\n \n   /**\n-   * Set this to `false` to disable the automatic configuration of the babel loader when a babel\n-   * configuration file is present. The babel loader configuration is enabled by default.\n+   * Set this to `false` to disable the automatic configuration of the babel loader when a Babel\n+   * configuration file is present. This option is enabled by default.\n+   *\n+   * If this is set to `false`, but `experimental.reactCompiler` is `true`, the built-in Babel will\n+   * still be configured, but any Babel configuration files on disk will be ignored. If you wish to\n+   * use React Compiler with a different manually-configured `babel-loader`, you should disable both\n+   * this and `experimental.reactCompiler`.\n    */\n   turbopackUseBuiltinBabel?: boolean\n "
        }
    ],
    "stats": {
        "total": 555,
        "additions": 370,
        "deletions": 185
    }
}