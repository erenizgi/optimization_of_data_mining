{
    "author": "mischnic",
    "message": "Turbopack: fix invalid NFT entry with file behind symlink (#82887)",
    "sha": "a21618480e90be6f067835d69f12824d0acfbd86",
    "files": [
        {
            "sha": "8e987bc0cda25ad4f3f1f270784ea4c66493aed2",
            "filename": "crates/next-api/src/nft_json.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/a21618480e90be6f067835d69f12824d0acfbd86/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a21618480e90be6f067835d69f12824d0acfbd86/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fnft_json.rs?ref=a21618480e90be6f067835d69f12824d0acfbd86",
            "patch": "@@ -231,6 +231,38 @@ impl Asset for NftJsonAsset {\n                 continue;\n             }\n \n+            #[cfg(debug_assertions)]\n+            {\n+                // Verify that we there are no entries where a file is created inside of a symlink,\n+                // as this can result in invalid ZIP files and deployment failures.\n+                // For example\n+                // node_modules/.pnpm/node_modules/@libsql/client/package.json\n+                // where\n+                // node_modules/.pnpm/node_modules/@libsql/client is a symlink\n+                let mut current_path = referenced_chunk_path.parent();\n+                loop {\n+                    use turbo_tasks_fs::FileSystemEntryType;\n+\n+                    if current_path.is_root() {\n+                        break;\n+                    }\n+\n+                    if matches!(\n+                        &*current_path.get_type().await?,\n+                        FileSystemEntryType::Symlink\n+                    ) {\n+                        bail!(\n+                            \"Encountered file inside of symlink in NFT list: {} is a symlink, but \\\n+                             {} was created inside of it\",\n+                            current_path.value_to_string().await?,\n+                            referenced_chunk_path.value_to_string().await?\n+                        );\n+                    }\n+\n+                    current_path = current_path.parent();\n+                }\n+            }\n+\n             let Some(specifier) = get_output_specifier(\n                 &referenced_chunk_path,\n                 &ident_folder,\n@@ -241,6 +273,7 @@ impl Asset for NftJsonAsset {\n             else {\n                 continue;\n             };\n+\n             result.insert(specifier);\n         }\n "
        },
        {
            "sha": "5c2036bed0019324b3f00e4c1541a5c6254cd662",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 53,
            "deletions": 40,
            "changes": 93,
            "blob_url": "https://github.com/vercel/next.js/blob/a21618480e90be6f067835d69f12824d0acfbd86/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/a21618480e90be6f067835d69f12824d0acfbd86/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=a21618480e90be6f067835d69f12824d0acfbd86",
            "patch": "@@ -2133,58 +2133,70 @@ async fn resolve_into_folder(\n     package_path: FileSystemPath,\n     options: Vc<ResolveOptions>,\n ) -> Result<Vc<ResolveResult>> {\n-    let package_json_path = package_path.join(\"package.json\")?;\n     let options_value = options.await?;\n \n-    for resolve_into_package in options_value.into_package.iter() {\n-        match resolve_into_package {\n-            ResolveIntoPackage::MainField { field: name } => {\n-                if let Some(package_json) =\n-                    &*read_package_json(Vc::upcast(FileSource::new(package_json_path.clone())))\n-                        .await?\n-                    && let Some(field_value) = package_json[name.as_str()].as_str()\n-                {\n-                    let normalized_request = RcStr::from(normalize_request(field_value));\n-                    if normalized_request.is_empty()\n-                        || &*normalized_request == \".\"\n-                        || &*normalized_request == \"./\"\n+    let mut affecting_sources = vec![];\n+    if let Some(package_json_path) =\n+        exists(&package_path.join(\"package.json\")?, &mut affecting_sources).await?\n+    {\n+        for resolve_into_package in options_value.into_package.iter() {\n+            match resolve_into_package {\n+                ResolveIntoPackage::MainField { field: name } => {\n+                    if let Some(package_json) =\n+                        &*read_package_json(Vc::upcast(FileSource::new(package_json_path.clone())))\n+                            .await?\n+                        && let Some(field_value) = package_json[name.as_str()].as_str()\n                     {\n-                        continue;\n-                    }\n-                    let request = Request::parse_string(normalized_request);\n-\n-                    // main field will always resolve not fully specified\n-                    let options = if options_value.fully_specified {\n-                        options.with_fully_specified(false).resolve().await?\n-                    } else {\n-                        options\n+                        let normalized_request = RcStr::from(normalize_request(field_value));\n+                        if normalized_request.is_empty()\n+                            || &*normalized_request == \".\"\n+                            || &*normalized_request == \"./\"\n+                        {\n+                            continue;\n+                        }\n+                        let request = Request::parse_string(normalized_request);\n+\n+                        // main field will always resolve not fully specified\n+                        let options = if options_value.fully_specified {\n+                            options.with_fully_specified(false).resolve().await?\n+                        } else {\n+                            options\n+                        };\n+                        let result =\n+                            &*resolve_internal_inline(package_path.clone(), request, options)\n+                                .await?\n+                                .await?;\n+                        // we are not that strict when a main field fails to resolve\n+                        // we continue to try other alternatives\n+                        if !result.is_unresolvable_ref() {\n+                            let mut result: ResolveResultBuilder =\n+                                result.with_request_ref(rcstr!(\".\")).into();\n+                            result.affecting_sources.push(ResolvedVc::upcast(\n+                                FileSource::new(package_json_path).to_resolved().await?,\n+                            ));\n+                            result.affecting_sources.extend(affecting_sources);\n+                            return Ok(ResolveResult::from(result).cell());\n+                        }\n                     };\n-                    let result = &*resolve_internal_inline(package_path.clone(), request, options)\n-                        .await?\n-                        .await?;\n-                    // we are not that strict when a main field fails to resolve\n-                    // we continue to try other alternatives\n-                    if !result.is_unresolvable_ref() {\n-                        let mut result: ResolveResultBuilder =\n-                            result.with_request_ref(rcstr!(\".\")).into();\n-                        result.affecting_sources.push(ResolvedVc::upcast(\n-                            FileSource::new(package_json_path).to_resolved().await?,\n-                        ));\n-                        return Ok(ResolveResult::from(result).cell());\n-                    }\n-                };\n+                }\n+                ResolveIntoPackage::ExportsField { .. } => {}\n             }\n-            ResolveIntoPackage::ExportsField { .. } => {}\n         }\n     }\n \n     if options_value.fully_specified {\n-        return Ok(*ResolveResult::unresolvable());\n+        return Ok(*ResolveResult::unresolvable_with_affecting_sources(\n+            affecting_sources,\n+        ));\n     }\n \n     // fall back to dir/index.[js,ts,...]\n     let pattern = match &options_value.default_files[..] {\n-        [] => return Ok(*ResolveResult::unresolvable()),\n+        [] => {\n+            return Ok(*ResolveResult::unresolvable_with_affecting_sources(\n+                affecting_sources,\n+            ));\n+        }\n         [file] => Pattern::Constant(format!(\"./{file}\").into()),\n         files => Pattern::Alternatives(\n             files\n@@ -2199,7 +2211,8 @@ async fn resolve_into_folder(\n     Ok(\n         resolve_internal_inline(package_path.clone(), request, options)\n             .await?\n-            .with_request(rcstr!(\".\")),\n+            .with_request(rcstr!(\".\"))\n+            .with_affecting_sources(ResolvedVc::deref_vec(affecting_sources)),\n     )\n }\n "
        }
    ],
    "stats": {
        "total": 126,
        "additions": 86,
        "deletions": 40
    }
}