{
    "author": "kdy1",
    "message": "test(turbopack): Configure HMR benchmark (#80219)\n\n### What?\n\nConfigure HMR benchmark. I'm not sure if this benchmark would be stable enough, but let's try.\n\nI'll remove this from the automated benchmark later this week if it turns out to be flaky.\n\n### Why?\n\nx-ref: https://vercel.slack.com/archives/C06PPGZ0FD3/p1748943158878159\n\n\n### How?\n\nCloses PACK-4758",
    "sha": "51092ee3c1d4a8d43c979b07517494f6fa0d19ff",
    "files": [
        {
            "sha": "da2ce4d2e44fcbfa62946064fc84e6fbf9374fa6",
            "filename": ".github/workflows/turbopack-benchmark.yml",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/51092ee3c1d4a8d43c979b07517494f6fa0d19ff/.github%2Fworkflows%2Fturbopack-benchmark.yml",
            "raw_url": "https://github.com/vercel/next.js/raw/51092ee3c1d4a8d43c979b07517494f6fa0d19ff/.github%2Fworkflows%2Fturbopack-benchmark.yml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.github%2Fworkflows%2Fturbopack-benchmark.yml?ref=51092ee3c1d4a8d43c979b07517494f6fa0d19ff",
            "patch": "@@ -26,6 +26,29 @@ env:\n   TURBO_TOKEN: ${{ secrets.HOSTED_TURBO_TOKEN }}\n \n jobs:\n+  benchmark-tiny:\n+    name: Benchmark Rust Crates (tiny)\n+    runs-on: ['self-hosted', 'linux', 'x64', 'metal']\n+    steps:\n+      - uses: actions/checkout@v4\n+\n+      - name: Setup Rust toolchain\n+        uses: ./.github/actions/setup-rust\n+\n+      - name: Install cargo-codspeed\n+        uses: taiki-e/install-action@v2\n+        with:\n+          tool: cargo-codspeed@2.10.1\n+\n+      - name: Build the benchmark target(s)\n+        run: cargo codspeed build -p next-api\n+\n+      - name: Run the benchmarks\n+        uses: CodSpeedHQ/action@v3\n+        with:\n+          run: cargo codspeed run\n+          token: ${{ secrets.CODSPEED_TOKEN }}\n+\n   benchmark-small-apps:\n     name: Benchmark Rust Crates (small apps)\n     runs-on: ['self-hosted', 'linux', 'x64', 'metal']"
        },
        {
            "sha": "955da55ed66b424c3357db0496d434f91fb48705",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 114,
            "deletions": 16,
            "changes": 130,
            "blob_url": "https://github.com/vercel/next.js/blob/51092ee3c1d4a8d43c979b07517494f6fa0d19ff/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/51092ee3c1d4a8d43c979b07517494f6fa0d19ff/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=51092ee3c1d4a8d43c979b07517494f6fa0d19ff",
            "patch": "@@ -1083,6 +1083,7 @@ dependencies = [\n  \"anstyle\",\n  \"clap_lex\",\n  \"strsim 0.11.1\",\n+ \"terminal_size\",\n ]\n \n [[package]]\n@@ -1173,6 +1174,46 @@ dependencies = [\n  \"walkdir\",\n ]\n \n+[[package]]\n+name = \"codspeed-divan-compat\"\n+version = \"2.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8620a09dfaf37b3c45f982c4b65bd8f9b0203944da3ffa705c0fcae6b84655ff\"\n+dependencies = [\n+ \"codspeed\",\n+ \"codspeed-divan-compat-macros\",\n+ \"codspeed-divan-compat-walltime\",\n+]\n+\n+[[package]]\n+name = \"codspeed-divan-compat-macros\"\n+version = \"2.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"30fe872bc4214626b35d3a1706a905d0243503bb6ba3bb7be2fc59083d5d680c\"\n+dependencies = [\n+ \"divan-macros\",\n+ \"itertools 0.14.0\",\n+ \"proc-macro-crate 3.3.0\",\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 2.0.100\",\n+]\n+\n+[[package]]\n+name = \"codspeed-divan-compat-walltime\"\n+version = \"2.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"104caa97b36d4092d89e24e4b103b40ede1edab03c0372d19e14a33f9393132b\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"clap\",\n+ \"codspeed\",\n+ \"condtype\",\n+ \"divan-macros\",\n+ \"libc\",\n+ \"regex-lite\",\n+]\n+\n [[package]]\n name = \"color_quant\"\n version = \"1.1.0\"\n@@ -1227,6 +1268,12 @@ dependencies = [\n  \"crossbeam-utils\",\n ]\n \n+[[package]]\n+name = \"condtype\"\n+version = \"1.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"baf0a07a401f374238ab8e2f11a104d2851bf9ce711ec69804834de8af45c7af\"\n+\n [[package]]\n name = \"console\"\n version = \"0.15.10\"\n@@ -1937,6 +1984,17 @@ dependencies = [\n  \"syn 2.0.100\",\n ]\n \n+[[package]]\n+name = \"divan-macros\"\n+version = \"0.1.17\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8dc51d98e636f5e3b0759a39257458b22619cac7e96d932da6eeb052891bb67c\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn 2.0.100\",\n+]\n+\n [[package]]\n name = \"document-features\"\n version = \"0.2.10\"\n@@ -2693,7 +2751,7 @@ dependencies = [\n  \"httpdate\",\n  \"itoa\",\n  \"pin-project-lite\",\n- \"socket2 0.4.9\",\n+ \"socket2 0.5.10\",\n  \"tokio\",\n  \"tower-service\",\n  \"tracing\",\n@@ -3232,6 +3290,15 @@ dependencies = [\n  \"either\",\n ]\n \n+[[package]]\n+name = \"itertools\"\n+version = \"0.14.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2b192c782037fadd9cfa75548310488aabdbf3d2da73885b31bd0abd03351285\"\n+dependencies = [\n+ \"either\",\n+]\n+\n [[package]]\n name = \"itoa\"\n version = \"1.0.9\"\n@@ -4144,6 +4211,7 @@ name = \"next-api\"\n version = \"0.1.0\"\n dependencies = [\n  \"anyhow\",\n+ \"codspeed-divan-compat\",\n  \"either\",\n  \"futures\",\n  \"indexmap 2.7.1\",\n@@ -4153,12 +4221,16 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"swc_core\",\n+ \"tempfile\",\n+ \"tokio\",\n  \"tracing\",\n  \"turbo-rcstr\",\n  \"turbo-tasks\",\n+ \"turbo-tasks-backend\",\n  \"turbo-tasks-build\",\n  \"turbo-tasks-env\",\n  \"turbo-tasks-fs\",\n+ \"turbo-tasks-malloc\",\n  \"turbopack\",\n  \"turbopack-browser\",\n  \"turbopack-core\",\n@@ -4527,7 +4599,7 @@ version = \"0.5.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dcbff9bc912032c62bf65ef1d5aea88983b420f4f839db1e9b0c281a25c9c799\"\n dependencies = [\n- \"proc-macro-crate\",\n+ \"proc-macro-crate 1.3.1\",\n  \"proc-macro2\",\n  \"quote\",\n  \"syn 1.0.109\",\n@@ -5139,6 +5211,15 @@ dependencies = [\n  \"toml_edit 0.19.15\",\n ]\n \n+[[package]]\n+name = \"proc-macro-crate\"\n+version = \"3.3.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"edce586971a4dfaa28950c6f18ed55e0406c1ab88bbce2c6f6293a7aaba73d35\"\n+dependencies = [\n+ \"toml_edit 0.22.27\",\n+]\n+\n [[package]]\n name = \"proc-macro-error\"\n version = \"1.0.4\"\n@@ -5657,6 +5738,12 @@ dependencies = [\n  \"regex-syntax 0.8.5\",\n ]\n \n+[[package]]\n+name = \"regex-lite\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"53a49587ad06b26609c52e423de037e7f57f20d53535d66e08c695f347df952a\"\n+\n [[package]]\n name = \"regex-syntax\"\n version = \"0.6.29\"\n@@ -8720,22 +8807,22 @@ dependencies = [\n \n [[package]]\n name = \"toml\"\n-version = \"0.8.19\"\n+version = \"0.8.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a1ed1f98e3fdc28d6d910e6737ae6ab1a93bf1985935a1193e68f93eeb68d24e\"\n+checksum = \"c6a4b9e8023eb94392d3dca65d717c53abc5dad49c07cb65bb8fcd87115fa325\"\n dependencies = [\n  \"indexmap 2.7.1\",\n  \"serde\",\n  \"serde_spanned\",\n  \"toml_datetime\",\n- \"toml_edit 0.22.20\",\n+ \"toml_edit 0.21.1\",\n ]\n \n [[package]]\n name = \"toml_datetime\"\n-version = \"0.6.8\"\n+version = \"0.6.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0dd7358ecb8fc2f8d014bf86f6f638ce72ba252a2c3a2572f2a795f1d23efb41\"\n+checksum = \"22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c\"\n dependencies = [\n  \"serde\",\n ]\n@@ -8755,15 +8842,26 @@ dependencies = [\n \n [[package]]\n name = \"toml_edit\"\n-version = \"0.22.20\"\n+version = \"0.21.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"583c44c02ad26b0c3f3066fe629275e50627026c51ac2e595cca4c230ce1ce1d\"\n+checksum = \"6a8534fd7f78b5405e860340ad6575217ce99f38d4d5c8f2442cb5ecb50090e1\"\n dependencies = [\n  \"indexmap 2.7.1\",\n  \"serde\",\n  \"serde_spanned\",\n  \"toml_datetime\",\n- \"winnow 0.6.18\",\n+ \"winnow 0.5.15\",\n+]\n+\n+[[package]]\n+name = \"toml_edit\"\n+version = \"0.22.27\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a\"\n+dependencies = [\n+ \"indexmap 2.7.1\",\n+ \"toml_datetime\",\n+ \"winnow 0.7.11\",\n ]\n \n [[package]]\n@@ -8952,7 +9050,7 @@ dependencies = [\n  \"serde_json\",\n  \"target-triple\",\n  \"termcolor\",\n- \"toml 0.8.19\",\n+ \"toml 0.8.9\",\n ]\n \n [[package]]\n@@ -10704,7 +10802,7 @@ dependencies = [\n  \"serde_json\",\n  \"serde_yml\",\n  \"thiserror 1.0.69\",\n- \"toml 0.8.19\",\n+ \"toml 0.8.9\",\n  \"url\",\n ]\n \n@@ -10769,7 +10867,7 @@ dependencies = [\n  \"tar\",\n  \"tempfile\",\n  \"thiserror 1.0.69\",\n- \"toml 0.8.19\",\n+ \"toml 0.8.9\",\n  \"url\",\n  \"wasmer-config\",\n  \"wasmer-types\",\n@@ -10874,7 +10972,7 @@ dependencies = [\n  \"thiserror 1.0.69\",\n  \"tokio\",\n  \"tokio-stream\",\n- \"toml 0.8.19\",\n+ \"toml 0.8.9\",\n  \"tracing\",\n  \"url\",\n  \"urlencoding\",\n@@ -11389,9 +11487,9 @@ dependencies = [\n \n [[package]]\n name = \"winnow\"\n-version = \"0.6.18\"\n+version = \"0.7.11\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"68a9bda4691f099d435ad181000724da8e5899daa10713c2d432552b9ccd3a6f\"\n+checksum = \"74c7b26e3480b707944fc872477815d29a8e429d2f93a1ce000f5fa84a15cbcd\"\n dependencies = [\n  \"memchr\",\n ]"
        },
        {
            "sha": "ba038e079dd5ae6f6669ee39ad2edaaed116c426",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/51092ee3c1d4a8d43c979b07517494f6fa0d19ff/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/51092ee3c1d4a8d43c979b07517494f6fa0d19ff/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=51092ee3c1d4a8d43c979b07517494f6fa0d19ff",
            "patch": "@@ -336,6 +336,7 @@ criterion = { package = \"codspeed-criterion-compat\", version = \"2.10.1\" }\n crossbeam-channel = \"0.5.8\"\n dashmap = \"6.1.0\"\n data-encoding = \"2.3.3\"\n+divan = { version = \"2.10.1\", package = \"codspeed-divan-compat\" }\n dhat = { version = \"0.3.2\" }\n dunce = \"1.0.3\"\n either = \"1.9.0\""
        },
        {
            "sha": "95eed8fc6c2eea5f7785d584b13f05e84bb1799c",
            "filename": "crates/next-api/Cargo.toml",
            "status": "modified",
            "additions": 13,
            "deletions": 1,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/51092ee3c1d4a8d43c979b07517494f6fa0d19ff/crates%2Fnext-api%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/51092ee3c1d4a8d43c979b07517494f6fa0d19ff/crates%2Fnext-api%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2FCargo.toml?ref=51092ee3c1d4a8d43c979b07517494f6fa0d19ff",
            "patch": "@@ -9,6 +9,10 @@ autobenches = false\n [lib]\n bench = false\n \n+[[bench]]\n+name = \"hmr\"\n+harness = false\n+\n [lints]\n workspace = true\n \n@@ -25,7 +29,7 @@ serde_json = { workspace = true }\n swc_core = { workspace = true }\n tracing = { workspace = true }\n turbo-rcstr = { workspace = true }\n-turbo-tasks = { workspace = true }\n+turbo-tasks = { workspace = true, features = [\"non_operation_vc_strongly_consistent\"] }\n turbo-tasks-env = { workspace = true }\n turbo-tasks-fs = { workspace = true }\n turbopack = { workspace = true }\n@@ -36,6 +40,14 @@ turbopack-node = { workspace = true }\n turbopack-nodejs = { workspace = true }\n turbopack-wasm = { workspace = true }\n \n+[dev-dependencies]\n+turbo-tasks-malloc = { workspace = true }\n+divan = { workspace = true }\n+tokio = { workspace = true }\n+tempfile = { workspace = true }\n+turbo-tasks-backend = { workspace = true }\n+\n+\n [build-dependencies]\n anyhow = { workspace = true }\n turbo-tasks-build = { workspace = true }"
        },
        {
            "sha": "b3715053072d9eb28ef31cb718571d358df5346a",
            "filename": "crates/next-api/benches/hmr.rs",
            "status": "added",
            "additions": 524,
            "deletions": 0,
            "changes": 524,
            "blob_url": "https://github.com/vercel/next.js/blob/51092ee3c1d4a8d43c979b07517494f6fa0d19ff/crates%2Fnext-api%2Fbenches%2Fhmr.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/51092ee3c1d4a8d43c979b07517494f6fa0d19ff/crates%2Fnext-api%2Fbenches%2Fhmr.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fbenches%2Fhmr.rs?ref=51092ee3c1d4a8d43c979b07517494f6fa0d19ff",
            "patch": "@@ -0,0 +1,524 @@\n+extern crate turbo_tasks_malloc;\n+\n+use std::{\n+    fs::{create_dir_all, write},\n+    mem::forget,\n+    path::{Path, PathBuf},\n+    process::Command,\n+    sync::Arc,\n+    time::{Duration, Instant},\n+};\n+\n+use anyhow::{Context, Result};\n+use next_api::{\n+    project::{DefineEnv, DraftModeOptions, ProjectContainer, ProjectOptions, WatchOptions},\n+    register,\n+    route::endpoint_write_to_disk,\n+};\n+use serde_json::json;\n+use tempfile::TempDir;\n+use tokio::runtime::Runtime;\n+use turbo_rcstr::RcStr;\n+use turbo_tasks::{\n+    TransientInstance, TurboTasks, TurboTasksApi, Vc, backend::Backend, trace::TraceRawVcs,\n+};\n+use turbo_tasks_backend::noop_backing_storage;\n+\n+pub struct HmrBenchmark {\n+    test_app: TestApp,\n+    project_container: Vc<ProjectContainer>,\n+}\n+\n+#[derive(Debug)]\n+pub struct TestApp {\n+    _path: PathBuf,\n+    /// Prevent temp directory from being dropped\n+    _dir: TempDir,\n+    modules: Vec<(PathBuf, usize)>,\n+}\n+\n+impl TestApp {\n+    pub fn path(&self) -> &Path {\n+        &self._path\n+    }\n+\n+    pub fn modules(&self) -> &[(PathBuf, usize)] {\n+        &self.modules\n+    }\n+}\n+\n+fn create_test_app(module_count: usize) -> Result<TestApp> {\n+    let temp_dir = tempfile::tempdir().context(\"Failed to create temp directory\")?;\n+    let base_path = temp_dir.path().to_path_buf();\n+\n+    // Create basic Next.js structure\n+    let pages_dir = base_path.join(\"pages\");\n+    let app_dir = base_path.join(\"app\");\n+    let src_dir = base_path.join(\"src\");\n+\n+    create_dir_all(&pages_dir)?;\n+    create_dir_all(&app_dir)?;\n+    create_dir_all(&src_dir)?;\n+\n+    let mut modules = Vec::new();\n+\n+    // Create index page\n+    let index_content = r#\"import React from 'react';\n+\n+export default function Home() {\n+    return <div>Hello World</div>;\n+}\n+\"#;\n+    let index_path = pages_dir.join(\"index.js\");\n+    write(&index_path, index_content)?;\n+    modules.push((index_path, 0));\n+\n+    // Create app layout\n+    let layout_content = r#\"export default function RootLayout({ children }) {\n+    return (\n+        <html>\n+            <body>{children}</body>\n+        </html>\n+    );\n+}\n+\"#;\n+    let layout_path = app_dir.join(\"layout.js\");\n+    write(&layout_path, layout_content)?;\n+    modules.push((layout_path, 0));\n+\n+    // Create app page\n+    let app_page_content = r#\"export default function Page() {\n+    return <div>App Router Page</div>;\n+}\n+\"#;\n+    let app_page_path = app_dir.join(\"page.js\");\n+    write(&app_page_path, app_page_content)?;\n+    modules.push((app_page_path, 0));\n+\n+    // Create additional modules based on module_count\n+    for i in 3..module_count {\n+        let component_content = format!(\n+            r#\"import React from 'react';\n+\n+export default function Component{i}() {{\n+    return <div>Component {i}</div>;\n+}}\n+\"#\n+        );\n+\n+        let component_path = src_dir.join(format!(\"component{i}.js\"));\n+        write(&component_path, component_content)?;\n+        modules.push((component_path, 1));\n+    }\n+\n+    // Create package.json\n+    let package_json = r#\"{\n+    \"name\": \"hmr-test-app\",\n+    \"version\": \"1.0.0\",\n+    \"dependencies\": {\n+        \"react\": \"^19.0.0\",\n+        \"react-dom\": \"^19.0.0\",\n+        \"next\": \"^15.0.0\"\n+    }\n+}\n+\"#;\n+    write(base_path.join(\"package.json\"), package_json)?;\n+\n+    // Create next.config.js\n+    let next_config = \"module.exports = {}\";\n+    write(base_path.join(\"next.config.js\"), next_config)?;\n+\n+    // Run `npm install`\n+    let output = Command::new(\"npm\")\n+        .current_dir(&base_path)\n+        .args([\"install\"])\n+        .output()?;\n+\n+    if !output.status.success() {\n+        return Err(anyhow::anyhow!(\"Failed to run `npm install`\"));\n+    }\n+\n+    Ok(TestApp {\n+        _path: base_path,\n+        _dir: temp_dir,\n+        modules,\n+    })\n+}\n+\n+fn load_next_config() -> RcStr {\n+    serde_json::to_string(&json!({\n+        \"sassOptions\": {\n+\n+        },\n+    }))\n+    .unwrap()\n+    .into()\n+}\n+\n+fn runtime() -> Runtime {\n+    tokio::runtime::Builder::new_multi_thread()\n+        .enable_all()\n+        .on_thread_stop(|| {\n+            turbo_tasks_malloc::TurboMalloc::thread_stop();\n+        })\n+        .build()\n+        .context(\"Failed to build tokio runtime\")\n+        .unwrap()\n+}\n+\n+impl HmrBenchmark {\n+    pub async fn new(module_count: usize) -> Result<Self> {\n+        let test_app = create_test_app(module_count)?;\n+\n+        let project_container = {\n+            let container = ProjectContainer::new(RcStr::from(\"hmr-benchmark\"), true)\n+                .to_resolved()\n+                .await?;\n+\n+            let project_path = test_app.path().to_string_lossy().to_string();\n+            let root_path = test_app.path().to_string_lossy().to_string();\n+\n+            let options = ProjectOptions {\n+                root_path: RcStr::from(root_path),\n+                project_path: RcStr::from(project_path.clone()),\n+                next_config: load_next_config(),\n+                js_config: RcStr::from(\"{}\"),\n+                env: vec![],\n+                define_env: DefineEnv {\n+                    client: vec![],\n+                    edge: vec![],\n+                    nodejs: vec![],\n+                },\n+                watch: WatchOptions {\n+                    enable: true,\n+                    poll_interval: None,\n+                },\n+                dev: true,\n+                encryption_key: RcStr::from(\"test-key\"),\n+                build_id: RcStr::from(\"development\"),\n+                preview_props: DraftModeOptions {\n+                    preview_mode_id: RcStr::from(\"development\"),\n+                    preview_mode_encryption_key: RcStr::from(\"test-key\"),\n+                    preview_mode_signing_key: RcStr::from(\"test-key\"),\n+                },\n+                browserslist_query: RcStr::from(\"last 2 versions\"),\n+                no_mangling: false,\n+            };\n+\n+            container.initialize(options).await?;\n+            Ok::<_, anyhow::Error>(container)\n+        }?;\n+\n+        Ok(Self {\n+            test_app,\n+            project_container: *project_container,\n+        })\n+    }\n+\n+    /// Simulate file changes for HMR testing\n+    pub fn make_file_change(&self, file_path: &Path, change_id: usize) -> Result<()> {\n+        let mut content =\n+            std::fs::read_to_string(file_path).context(\"Failed to read file content\")?;\n+\n+        // Add a comment with a unique identifier to trigger HMR\n+        let change_marker = format!(\"// HMR_CHANGE_{change_id}\\n\");\n+        content.push_str(&change_marker);\n+\n+        std::fs::write(file_path, content).context(\"Failed to write modified content\")?;\n+\n+        Ok(())\n+    }\n+\n+    /// Benchmark HMR update detection and processing\n+    pub async fn benchmark_hmr_update(&self, num_updates: usize) -> Result<Duration> {\n+        let start_time = Instant::now();\n+\n+        // Get entrypoints to trigger initial compilation\n+        let entrypoints = self.project_container.entrypoints();\n+        let initial_result = entrypoints.await?;\n+\n+        // Check if we have routes available\n+        if initial_result.routes.is_empty() {\n+            return Err(anyhow::anyhow!(\"No routes found in entrypoints\"));\n+        }\n+\n+        // Get HMR identifiers\n+        let hmr_identifiers = self.project_container.hmr_identifiers();\n+        let identifiers = hmr_identifiers.await?;\n+\n+        if identifiers.is_empty() {\n+            return Err(anyhow::anyhow!(\"No HMR identifiers found\"));\n+        }\n+\n+        // Get project to access HMR methods\n+        let project = self.project_container.project();\n+\n+        // Create multiple sessions to simulate real HMR usage\n+        let mut update_durations = Vec::new();\n+\n+        for i in 0..num_updates {\n+            let update_start = Instant::now();\n+\n+            // Use different identifiers for each update\n+            let identifier = &identifiers[i % identifiers.len()];\n+\n+            // Get version state for this update\n+            let session = TransientInstance::new(());\n+            let version_state = project.hmr_version_state(identifier.clone(), session);\n+\n+            // Pick a module file to change\n+            let module_index = i % self.test_app.modules().len();\n+            let (module_path, _) = &self.test_app.modules()[module_index];\n+\n+            // Make a file change\n+            self.make_file_change(module_path, i)?;\n+\n+            // Wait for HMR update and measure time\n+            let _update_result = project\n+                .hmr_update(identifier.clone(), version_state)\n+                .await?;\n+\n+            update_durations.push(update_start.elapsed());\n+        }\n+\n+        // // Log individual update times for analysis\n+        // for (i, duration) in update_durations.iter().enumerate() {\n+        //     println!(\"HMR update {} took: {:?}\", i + 1, duration);\n+        // }\n+\n+        Ok(start_time.elapsed())\n+    }\n+\n+    /// Benchmark HMR subscription and event handling\n+    pub async fn benchmark_hmr_subscription(&self) -> Result<Duration> {\n+        let start_time = Instant::now();\n+\n+        // Get entrypoints first\n+        let entrypoints = self.project_container.entrypoints();\n+        let _initial_result = entrypoints.await?;\n+\n+        // Get HMR identifiers\n+        let hmr_identifiers = self.project_container.hmr_identifiers();\n+        let identifiers = hmr_identifiers.await?;\n+\n+        if identifiers.is_empty() {\n+            return Err(anyhow::anyhow!(\"No HMR identifiers found\"));\n+        }\n+\n+        let project = self.project_container.project();\n+\n+        // Test subscription to multiple identifiers\n+        let mut version_states = Vec::new();\n+        for identifier in identifiers.iter().take(5) {\n+            // Test with first 5 identifiers\n+            let session = TransientInstance::new(());\n+            let version_state = project.hmr_version_state(identifier.clone(), session);\n+            version_states.push((identifier.clone(), version_state));\n+        }\n+\n+        // Simulate multiple rapid updates\n+        for (i, (identifier, version_state)) in version_states.iter().enumerate() {\n+            // Make a file change\n+            if let Some((module_path, _)) = self.test_app.modules().get(i) {\n+                self.make_file_change(module_path, i * 100)?;\n+\n+                // Check for update\n+                let _update_result = project\n+                    .hmr_update(identifier.clone(), *version_state)\n+                    .await?;\n+            }\n+        }\n+\n+        Ok(start_time.elapsed())\n+    }\n+\n+    /// Benchmark initial project setup and entrypoint detection\n+    pub async fn benchmark_initial_compilation(&self) -> Result<Duration> {\n+        let start_time = Instant::now();\n+\n+        let entrypoints = self.project_container.entrypoints();\n+        let result = entrypoints.await?;\n+\n+        for route in result.routes.values() {\n+            match route {\n+                next_api::route::Route::Page {\n+                    html_endpoint,\n+                    data_endpoint,\n+                } => {\n+                    let _ = endpoint_write_to_disk(**html_endpoint).await?;\n+                    let _ = endpoint_write_to_disk(**data_endpoint).await?;\n+                }\n+                next_api::route::Route::PageApi { endpoint } => {\n+                    let _ = endpoint_write_to_disk(**endpoint).await?;\n+                }\n+                next_api::route::Route::AppPage(app_page_routes) => {\n+                    for route in app_page_routes.iter() {\n+                        let _ = endpoint_write_to_disk(*route.html_endpoint).await?;\n+                        let _ = endpoint_write_to_disk(*route.rsc_endpoint).await?;\n+                    }\n+                }\n+                next_api::route::Route::AppRoute { endpoint, .. } => {\n+                    let _ = endpoint_write_to_disk(**endpoint).await?;\n+                }\n+                next_api::route::Route::Conflict => {}\n+            }\n+        }\n+\n+        Ok(start_time.elapsed())\n+    }\n+\n+    /// Get the number of modules in the test app\n+    pub fn module_count(&self) -> usize {\n+        self.test_app.modules().len()\n+    }\n+}\n+\n+async fn setup_benchmark(module_count: usize) -> HmrBenchmark {\n+    register();\n+    HmrBenchmark::new(module_count).await.unwrap()\n+}\n+\n+fn setup_runtime() -> Runtime {\n+    runtime()\n+}\n+\n+fn setup_turbo_tasks() -> Arc<TurboTasks<impl Backend>> {\n+    TurboTasks::new(turbo_tasks_backend::TurboTasksBackend::new(\n+        turbo_tasks_backend::BackendOptions {\n+            storage_mode: None,\n+            dependency_tracking: true,\n+            ..Default::default()\n+        },\n+        noop_backing_storage(),\n+    ))\n+}\n+\n+#[derive(TraceRawVcs)]\n+struct Setup {\n+    #[turbo_tasks(trace_ignore)]\n+    rt: Arc<Runtime>,\n+    #[turbo_tasks(trace_ignore)]\n+    tt: Arc<dyn TurboTasksApi>,\n+    #[turbo_tasks(trace_ignore)]\n+    benchmark: HmrBenchmark,\n+}\n+\n+fn setup_everything(module_count: usize) -> Arc<Setup> {\n+    let rt = Arc::new(setup_runtime());\n+    let tt = setup_turbo_tasks();\n+\n+    let arc = rt.clone().block_on(async move {\n+        tt.clone()\n+            .run_once(async move {\n+                let benchmark = setup_benchmark(module_count).await;\n+                benchmark.benchmark_initial_compilation().await.unwrap();\n+\n+                Ok(Arc::new(Setup { rt, tt, benchmark }))\n+            })\n+            .await\n+            .unwrap()\n+    });\n+\n+    // I don't know why this is needed, but it is required to avoid dropping tokio runtime from\n+    // async scope\n+    forget(arc.clone());\n+    arc\n+}\n+\n+#[divan::bench]\n+fn hmr_initial_compilation(bencher: divan::Bencher) {\n+    let setup = setup_everything(100);\n+\n+    bencher.with_inputs(|| setup.clone()).bench_values(|setup| {\n+        setup.clone().rt.block_on(async move {\n+            setup.clone().tt.run_once(Box::pin(async move {\n+                setup\n+                    .benchmark\n+                    .benchmark_initial_compilation()\n+                    .await\n+                    .unwrap();\n+                Ok(())\n+            }));\n+        })\n+    });\n+}\n+\n+#[divan::bench(sample_size = 10)]\n+fn hmr_updates_small_5(bencher: divan::Bencher) {\n+    let setup = setup_everything(100);\n+\n+    bencher.with_inputs(|| setup.clone()).bench_values(|setup| {\n+        setup.clone().rt.block_on(async move {\n+            setup.clone().tt.run_once(Box::pin(async move {\n+                let _ = setup\n+                    .benchmark\n+                    .benchmark_initial_compilation()\n+                    .await\n+                    .unwrap();\n+                setup.benchmark.benchmark_hmr_update(5).await.unwrap();\n+                Ok(())\n+            }));\n+        })\n+    });\n+}\n+\n+#[divan::bench(sample_size = 10)]\n+fn hmr_updates_medium_10(bencher: divan::Bencher) {\n+    let setup = setup_everything(200);\n+\n+    bencher.with_inputs(|| setup.clone()).bench_values(|setup| {\n+        setup.clone().rt.block_on(async move {\n+            setup.clone().tt.run_once(Box::pin(async move {\n+                let _ = setup\n+                    .benchmark\n+                    .benchmark_initial_compilation()\n+                    .await\n+                    .unwrap();\n+                setup.benchmark.benchmark_hmr_update(10).await.unwrap();\n+                Ok(())\n+            }));\n+        })\n+    });\n+}\n+\n+#[divan::bench(sample_size = 10)]\n+fn hmr_updates_large_20(bencher: divan::Bencher) {\n+    let setup = setup_everything(500);\n+\n+    bencher.with_inputs(|| setup.clone()).bench_values(|setup| {\n+        setup.clone().rt.block_on(async move {\n+            setup.clone().tt.run_once(Box::pin(async move {\n+                let _ = setup\n+                    .benchmark\n+                    .benchmark_initial_compilation()\n+                    .await\n+                    .unwrap();\n+                setup.benchmark.benchmark_hmr_update(20).await.unwrap();\n+                Ok(())\n+            }));\n+        })\n+    });\n+}\n+\n+#[divan::bench(sample_size = 10)]\n+fn hmr_subscription(bencher: divan::Bencher) {\n+    let setup = setup_everything(100);\n+\n+    bencher.with_inputs(|| setup.clone()).bench_values(|setup| {\n+        setup.clone().rt.block_on(async move {\n+            setup.clone().tt.run_once(Box::pin(async move {\n+                let _ = setup\n+                    .benchmark\n+                    .benchmark_initial_compilation()\n+                    .await\n+                    .unwrap();\n+                setup.benchmark.benchmark_hmr_subscription().await.unwrap();\n+                Ok(())\n+            }));\n+        })\n+    });\n+}\n+\n+fn main() {\n+    divan::main();\n+}"
        },
        {
            "sha": "ba551cd53ef43faa5a4349e9328c82eb183db303",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/51092ee3c1d4a8d43c979b07517494f6fa0d19ff/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/51092ee3c1d4a8d43c979b07517494f6fa0d19ff/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=51092ee3c1d4a8d43c979b07517494f6fa0d19ff",
            "patch": "@@ -62,7 +62,7 @@ impl Default for CacheKinds {\n \n #[turbo_tasks::value(serialization = \"custom\", eq = \"manual\")]\n #[derive(Clone, Debug, Default, PartialEq, Serialize, Deserialize, OperationValue)]\n-#[serde(rename_all = \"camelCase\")]\n+#[serde(default, rename_all = \"camelCase\")]\n pub struct NextConfig {\n     // TODO all fields should be private and access should be wrapped within a turbo-tasks function\n     // Otherwise changing NextConfig will lead to invalidating all tasks accessing it."
        }
    ],
    "stats": {
        "total": 694,
        "additions": 676,
        "deletions": 18
    }
}