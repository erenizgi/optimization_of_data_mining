{
    "author": "unstubbable",
    "message": "Prevent `\"use cache\"` timeout errors from being caught in userland code (#78998)\n\nWhen `dynamicIO` is enabled and a `\"use cache\"` function accesses\ndynamic request APIs, we fail the prerendering with a timeout error\nafter 50 seconds.\n\nThis error could be swallowed in userland code however, when the cached\nfunction is wrapped in a try/catch block. That's not the intended\nbehavior, so we now fail the prerendering (or dynamic validation in dev\nmode) with the timeout error in this case as well, using the same\napproach as in #77838.\n\nThis also works around a bug that led to the timeout errors not being\nsource-mapped correctly with Turbopack.\n\nIn a future PR, we will adapt the behaviour for prerendering of fallback\nshells that are allowed to be empty, in which case the timeout must not\nfail the build.",
    "sha": "d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db",
    "files": [
        {
            "sha": "9efa44f585dcfeda54412d0ae19ff2d3e65db861",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 26,
            "deletions": 32,
            "changes": 58,
            "blob_url": "https://github.com/vercel/next.js/blob/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db",
            "patch": "@@ -187,7 +187,6 @@ import {\n } from '../resume-data-cache/resume-data-cache'\n import type { MetadataErrorType } from '../../lib/metadata/resolve-metadata'\n import isError from '../../lib/is-error'\n-import { isUseCacheTimeoutError } from '../use-cache/use-cache-errors'\n import { createServerInsertedMetadata } from './metadata-insertion/create-server-inserted-metadata'\n import { getPreviouslyRevalidatedTags } from '../server-utils'\n import { executeRevalidates } from '../revalidation-utils'\n@@ -632,7 +631,6 @@ async function generateDynamicFlightRenderResult(\n       ctx,\n       false,\n       ctx.clientReferenceManifest,\n-      ctx.workStore.route,\n       requestStore\n     )\n   }\n@@ -1390,7 +1388,6 @@ async function renderToHTMLOrFlightImpl(\n       res,\n       ctx,\n       metadata,\n-      workStore,\n       loaderTree\n     )\n \n@@ -1410,8 +1407,8 @@ async function renderToHTMLOrFlightImpl(\n \n     // If we encountered any unexpected errors during build we fail the\n     // prerendering phase and the build.\n-    if (workStore.invalidUsageError) {\n-      throw workStore.invalidUsageError\n+    if (workStore.invalidDynamicUsageError) {\n+      throw workStore.invalidDynamicUsageError\n     }\n     if (response.digestErrorsMap.size) {\n       const buildFailingError = response.digestErrorsMap.values().next().value\n@@ -1564,7 +1561,6 @@ async function renderToHTMLOrFlightImpl(\n             req,\n             res,\n             ctx,\n-            workStore,\n             notFoundLoaderTree,\n             formState,\n             postponedState\n@@ -1591,14 +1587,13 @@ async function renderToHTMLOrFlightImpl(\n       req,\n       res,\n       ctx,\n-      workStore,\n       loaderTree,\n       formState,\n       postponedState\n     )\n \n-    if (workStore.invalidUsageError) {\n-      throw workStore.invalidUsageError\n+    if (workStore.invalidDynamicUsageError) {\n+      throw workStore.invalidDynamicUsageError\n     }\n \n     // If we have pending revalidates, wait until they are all resolved.\n@@ -1727,7 +1722,6 @@ async function renderToStream(\n   req: BaseNextRequest,\n   res: BaseNextResponse,\n   ctx: AppRenderContext,\n-  workStore: WorkStore,\n   tree: LoaderTree,\n   formState: any,\n   postponedState: PostponedState | null\n@@ -1873,7 +1867,6 @@ async function renderToStream(\n         ctx,\n         res.statusCode === 404,\n         clientReferenceManifest,\n-        workStore.route,\n         requestStore\n       )\n \n@@ -2220,10 +2213,9 @@ async function spawnDynamicValidationInDev(\n   ctx: AppRenderContext,\n   isNotFound: boolean,\n   clientReferenceManifest: NonNullable<RenderOpts['clientReferenceManifest']>,\n-  route: string,\n   requestStore: RequestStore\n ): Promise<void> {\n-  const { componentMod: ComponentMod, implicitTags } = ctx\n+  const { componentMod: ComponentMod, implicitTags, workStore } = ctx\n   const rootParams = getRootParams(\n     ComponentMod.tree,\n     ctx.getDynamicParamFromSegment\n@@ -2317,7 +2309,7 @@ async function spawnDynamicValidationInDev(\n             process.env.NEXT_DEBUG_BUILD ||\n             process.env.__NEXT_VERBOSE_LOGGING\n           ) {\n-            printDebugThrownValueForProspectiveRender(err, route)\n+            printDebugThrownValueForProspectiveRender(err, workStore.route)\n           }\n         },\n         signal: initialServerRenderController.signal,\n@@ -2335,7 +2327,7 @@ async function spawnDynamicValidationInDev(\n     ) {\n       // We don't normally log these errors because we are going to retry anyway but\n       // it can be useful for debugging Next.js itself to get visibility here when needed\n-      printDebugThrownValueForProspectiveRender(err, route)\n+      printDebugThrownValueForProspectiveRender(err, workStore.route)\n     }\n   }\n \n@@ -2375,7 +2367,7 @@ async function spawnDynamicValidationInDev(\n           ) {\n             // We don't normally log these errors because we are going to retry anyway but\n             // it can be useful for debugging Next.js itself to get visibility here when needed\n-            printDebugThrownValueForProspectiveRender(err, route)\n+            printDebugThrownValueForProspectiveRender(err, workStore.route)\n           }\n         },\n       }\n@@ -2387,7 +2379,7 @@ async function spawnDynamicValidationInDev(\n         // We're going to retry to so we normally would suppress this error but\n         // when verbose logging is on we print it\n         if (process.env.__NEXT_VERBOSE_LOGGING) {\n-          printDebugThrownValueForProspectiveRender(err, route)\n+          printDebugThrownValueForProspectiveRender(err, workStore.route)\n         }\n       }\n     })\n@@ -2467,10 +2459,6 @@ async function spawnDynamicValidationInDev(\n         clientReferenceManifest.clientModules,\n         {\n           onError: (err) => {\n-            if (isUseCacheTimeoutError(err)) {\n-              return err.digest\n-            }\n-\n             if (\n               finalServerController.signal.aborted &&\n               isPrerenderInterruptedError(err)\n@@ -2511,12 +2499,6 @@ async function spawnDynamicValidationInDev(\n           {\n             signal: finalClientController.signal,\n             onError: (err, errorInfo) => {\n-              if (isUseCacheTimeoutError(err)) {\n-                dynamicValidation.dynamicErrors.push(err)\n-\n-                return\n-              }\n-\n               if (\n                 isPrerenderInterruptedError(err) ||\n                 finalClientController.signal.aborted\n@@ -2531,7 +2513,7 @@ async function spawnDynamicValidationInDev(\n                 const componentStack = errorInfo.componentStack\n                 if (typeof componentStack === 'string') {\n                   trackAllowedDynamicAccess(\n-                    route,\n+                    workStore.route,\n                     componentStack,\n                     dynamicValidation\n                   )\n@@ -2572,7 +2554,7 @@ async function spawnDynamicValidationInDev(\n       // track any dynamic access that occurs above the suspense boundary because\n       // we'll do so in the route shell.\n       throwIfDisallowedDynamic(\n-        route,\n+        workStore,\n         preludeIsEmpty,\n         dynamicValidation,\n         serverDynamicTracking,\n@@ -2611,7 +2593,6 @@ async function prerenderToStream(\n   res: BaseNextResponse,\n   ctx: AppRenderContext,\n   metadata: AppPageRenderResultMetadata,\n-  workStore: WorkStore,\n   tree: LoaderTree\n ): Promise<PrerenderToStreamResult> {\n   // When prerendering formState is always null. We still include it\n@@ -2626,6 +2607,7 @@ async function prerenderToStream(\n     nonce,\n     pagePath,\n     renderOpts,\n+    workStore,\n   } = ctx\n \n   const rootParams = getRootParams(tree, getDynamicParamFromSegment)\n@@ -2840,6 +2822,12 @@ async function prerenderToStream(\n         initialServerRenderController.abort()\n         initialServerPrerenderController.abort()\n \n+        // We don't need to continue the prerender process if we already\n+        // detected invalid dynamic usage in the initial prerender phase.\n+        if (workStore.invalidDynamicUsageError) {\n+          throw workStore.invalidDynamicUsageError\n+        }\n+\n         let initialServerResult\n         try {\n           initialServerResult = await createReactServerPrerenderResult(\n@@ -3106,7 +3094,7 @@ async function prerenderToStream(\n         // we'll do so in the route shell.\n         if (!ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n           throwIfDisallowedDynamic(\n-            workStore.route,\n+            workStore,\n             preludeIsEmpty,\n             dynamicValidation,\n             serverDynamicTracking,\n@@ -3428,6 +3416,12 @@ async function prerenderToStream(\n         initialServerRenderController.abort()\n         initialServerPrerenderController.abort()\n \n+        // We don't need to continue the prerender process if we already\n+        // detected invalid dynamic usage in the initial prerender phase.\n+        if (workStore.invalidDynamicUsageError) {\n+          throw workStore.invalidDynamicUsageError\n+        }\n+\n         // We've now filled caches and triggered any inadvertant sync bailouts\n         // due to lazy module initialization. We can restart our render to capture results\n \n@@ -3591,7 +3585,7 @@ async function prerenderToStream(\n         if (!ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n           // We don't have a shell because the root errored when we aborted.\n           throwIfDisallowedDynamic(\n-            workStore.route,\n+            workStore,\n             preludeIsEmpty,\n             dynamicValidation,\n             serverDynamicTracking,"
        },
        {
            "sha": "0d5cd67cf00ec4cdb1bc58318a5008daa54fde9f",
            "filename": "packages/next/src/server/app-render/dynamic-rendering.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 3,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fdynamic-rendering.ts?ref=d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db",
            "patch": "@@ -651,12 +651,17 @@ function createErrorWithComponentStack(\n }\n \n export function throwIfDisallowedDynamic(\n-  route: string,\n+  workStore: WorkStore,\n   hasEmptyShell: boolean,\n   dynamicValidation: DynamicValidationState,\n   serverDynamic: DynamicTrackingState,\n   clientDynamic: DynamicTrackingState\n ): void {\n+  if (workStore.invalidDynamicUsageError) {\n+    console.error(workStore.invalidDynamicUsageError)\n+    throw new StaticGenBailoutError()\n+  }\n+\n   if (hasEmptyShell) {\n     if (dynamicValidation.hasSuspenseAboveBody) {\n       // This route has opted into allowing fully dynamic rendering\n@@ -698,7 +703,7 @@ export function throwIfDisallowedDynamic(\n     // to indicate your are ok with fully dynamic rendering.\n     if (dynamicValidation.hasDynamicViewport) {\n       console.error(\n-        `Route \"${route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n+        `Route \"${workStore.route}\" has a \\`generateViewport\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) without explicitly allowing fully dynamic rendering. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-viewport`\n       )\n       throw new StaticGenBailoutError()\n     }\n@@ -708,7 +713,7 @@ export function throwIfDisallowedDynamic(\n       dynamicValidation.hasDynamicMetadata\n     ) {\n       console.error(\n-        `Route \"${route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n+        `Route \"${workStore.route}\" has a \\`generateMetadata\\` that depends on Request data (\\`cookies()\\`, etc...) or uncached external data (\\`fetch(...)\\`, etc...) when the rest of the route does not. See more info here: https://nextjs.org/docs/messages/next-prerender-dynamic-metadata`\n       )\n       throw new StaticGenBailoutError()\n     }"
        },
        {
            "sha": "7e7380e39e8dcf986f4968ee86d2ab77e9a20490",
            "filename": "packages/next/src/server/app-render/work-async-storage.external.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-async-storage.external.ts?ref=d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db",
            "patch": "@@ -51,12 +51,13 @@ export interface WorkStore {\n   dynamicUsageStack?: string\n \n   /**\n-   * Invalid usage errors might be caught in userland. We attach them to the\n-   * work store to ensure we can still fail the build or dev render.\n+   * Invalid dynamic usage errors might be caught in userland. We attach them to\n+   * the work store to ensure we can still fail the build, or show en error in\n+   * dev mode.\n    */\n   // TODO: Collect an array of errors, and throw as AggregateError when\n   // `serializeError` and the Dev Overlay support it.\n-  invalidUsageError?: Error\n+  invalidDynamicUsageError?: Error\n \n   nextFetchId?: number\n   pathWasRevalidated?: boolean"
        },
        {
            "sha": "4c9b2b6a3c22f1df8a3dfbd13f455c26c49d6965",
            "filename": "packages/next/src/server/request/utils.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Futils.ts?ref=d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db",
            "patch": "@@ -29,7 +29,7 @@ export function throwForSearchParamsAccessInUseCache(\n   )\n \n   Error.captureStackTrace(error, constructorOpt)\n-  workStore.invalidUsageError ??= error\n+  workStore.invalidDynamicUsageError ??= error\n \n   throw error\n }"
        },
        {
            "sha": "6f7c21d519542bf283f9f0b7b5b5bcb136a34a0c",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 16,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db",
            "patch": "@@ -253,8 +253,8 @@ async function collectResult(\n   let idx = 0\n   const bufferStream = new ReadableStream({\n     pull(controller) {\n-      if (workStore.invalidUsageError) {\n-        controller.error(workStore.invalidUsageError)\n+      if (workStore.invalidDynamicUsageError) {\n+        controller.error(workStore.invalidDynamicUsageError)\n       } else if (idx < buffer.length) {\n         controller.enqueue(buffer[idx++])\n       } else if (errors.length > 0) {\n@@ -365,7 +365,6 @@ async function generateCacheEntryImpl(\n   const resultPromise = createLazyResult(() => fn.apply(null, args))\n \n   let errors: Array<unknown> = []\n-  let timeoutErrorHandled = false\n \n   // In the \"Cache\" environment, we only need to make sure that the error\n   // digests are handled correctly. Error formatting and reporting is not\n@@ -385,13 +384,6 @@ async function generateCacheEntryImpl(\n       console.error(error)\n     }\n \n-    if (error === timeoutError) {\n-      timeoutErrorHandled = true\n-      // The timeout error already aborted the whole stream. We don't need\n-      // to also push this error into the `errors` array.\n-      return timeoutError.digest\n-    }\n-\n     errors.push(error)\n   }\n \n@@ -404,6 +396,7 @@ async function generateCacheEntryImpl(\n     // Otherwise we assume you stalled on hanging input and de-opt. This needs\n     // to be lower than just the general timeout of 60 seconds.\n     const timer = setTimeout(() => {\n+      workStore.invalidDynamicUsageError = timeoutError\n       timeoutAbortController.abort(timeoutError)\n     }, 50000)\n \n@@ -422,7 +415,7 @@ async function generateCacheEntryImpl(\n         signal: abortSignal,\n         temporaryReferences,\n         onError(error) {\n-          if (renderSignal.aborted && renderSignal.reason === error) {\n+          if (abortSignal.aborted && abortSignal.reason === error) {\n             return undefined\n           }\n \n@@ -433,11 +426,7 @@ async function generateCacheEntryImpl(\n \n     clearTimeout(timer)\n \n-    if (timeoutAbortController.signal.aborted && !timeoutErrorHandled) {\n-      // When halting is enabled, the prerender will not call `onError` when\n-      // it's aborted with the timeout abort signal, and hanging promises will\n-      // also not be rejected. In this case, we're creating an erroring stream\n-      // here, to ensure that the error is propagated to the server environment.\n+    if (timeoutAbortController.signal.aborted) {\n       stream = new ReadableStream({\n         start(controller) {\n           controller.error(timeoutError)"
        },
        {
            "sha": "1f77b26ac270b188eff2675eae2fe49e0ef60943",
            "filename": "test/e2e/app-dir/use-cache-hanging-inputs/app/fallback-params/[slug]/page.tsx",
            "status": "added",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Ffallback-params%2F%5Bslug%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Ffallback-params%2F%5Bslug%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Ffallback-params%2F%5Bslug%5D%2Fpage.tsx?ref=d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db",
            "patch": "@@ -0,0 +1,14 @@\n+'use cache'\n+\n+export default async function Page({\n+  params,\n+}: {\n+  params: Promise<{ slug: string }>\n+}) {\n+  const { slug } = await params\n+\n+  return <p>slug: {slug}</p>\n+}\n+\n+// If generateStaticParams would be used here to define at least one set of\n+// complete params, we would not yield a timeout error."
        },
        {
            "sha": "4eac0fe1a4148f938d423935d52ac5b8939e501e",
            "filename": "test/e2e/app-dir/use-cache-hanging-inputs/app/search-params-caught/page.tsx",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Fsearch-params-caught%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Fsearch-params-caught%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Fsearch-params-caught%2Fpage.tsx?ref=d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db",
            "patch": "@@ -0,0 +1,28 @@\n+async function getSearchParam({\n+  searchParams,\n+}: {\n+  searchParams: Promise<{ n: string }>\n+}): Promise<string> {\n+  'use cache'\n+\n+  return (await searchParams).n\n+}\n+\n+export default async function Page({\n+  searchParams,\n+}: {\n+  searchParams: Promise<{ n: string }>\n+}) {\n+  let searchParam: string | undefined\n+\n+  try {\n+    searchParam = await getSearchParam({ searchParams })\n+  } catch {\n+    // Ignore not having access to searchParams. This is still an invalid\n+    // dynamic access though that we need to detect.\n+  }\n+\n+  return (\n+    <p>{searchParam ? `search param: ${searchParam}` : 'no search param'}</p>\n+  )\n+}"
        },
        {
            "sha": "f97f8158ec16399afac201f04ce13579268695a5",
            "filename": "test/e2e/app-dir/use-cache-hanging-inputs/app/uncached-promise-nested/page.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Funcached-promise-nested%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Funcached-promise-nested%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Funcached-promise-nested%2Fpage.tsx?ref=d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db",
            "patch": "@@ -2,7 +2,7 @@ import React from 'react'\n import { setTimeout } from 'timers/promises'\n \n async function getUncachedData() {\n-  await setTimeout(0)\n+  await setTimeout(100)\n \n   return Math.random()\n }"
        },
        {
            "sha": "da6ee6f8ebdadd0681171bbf1d2b02b0f3071d4c",
            "filename": "test/e2e/app-dir/use-cache-hanging-inputs/app/uncached-promise/page.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Funcached-promise%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Funcached-promise%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fapp%2Funcached-promise%2Fpage.tsx?ref=d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db",
            "patch": "@@ -2,7 +2,7 @@ import React from 'react'\n import { setTimeout } from 'timers/promises'\n \n async function fetchUncachedData() {\n-  await setTimeout(0)\n+  await setTimeout(100)\n \n   return Math.random()\n }"
        },
        {
            "sha": "1962195345258650b9679e44ad9a63190abda87b",
            "filename": "test/e2e/app-dir/use-cache-hanging-inputs/use-cache-hanging-inputs.test.ts",
            "status": "modified",
            "additions": 150,
            "deletions": 68,
            "changes": 218,
            "blob_url": "https://github.com/vercel/next.js/blob/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fuse-cache-hanging-inputs.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fuse-cache-hanging-inputs.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-hanging-inputs%2Fuse-cache-hanging-inputs.test.ts?ref=d1ee0f0cd7568318fa2cb5c23356f1a01fcd21db",
            "patch": "@@ -10,9 +10,7 @@ import {\n } from 'next-test-utils'\n import stripAnsi from 'strip-ansi'\n \n-const isExperimentalReact = process.env.__NEXT_EXPERIMENTAL_PPR\n-\n-const expectedErrorMessage =\n+const expectedTimeoutErrorMessage =\n   'Filling a cache during prerender timed out, likely because request-specific arguments such as params, searchParams, cookies() or dynamic data were used inside \"use cache\".'\n \n describe('use-cache-hanging-inputs', () => {\n@@ -38,21 +36,29 @@ describe('use-cache-hanging-inputs', () => {\n \n         await openRedbox(browser)\n \n+        const errorCount = await getRedboxTotalErrorCount(browser)\n         const errorDescription = await getRedboxDescription(browser)\n         const errorSource = await getRedboxSource(browser)\n \n-        expect(errorDescription).toBe(expectedErrorMessage)\n+        expect(errorCount).toBe(1)\n+        expect(errorDescription).toBe(expectedTimeoutErrorMessage)\n \n         const cliOutput = stripAnsi(next.cliOutput.slice(outputIndex))\n \n         if (isTurbopack) {\n-          // TODO(veil): For Turbopack, a fix in the React Flight Client, where\n-          // sourceURL is encoded, is needed for the error source and stack\n-          // frames to be source mapped.\n+          expect(errorSource).toMatchInlineSnapshot(`\n+           \"app/search-params/page.tsx (3:16) @ [project]/app/search-params/page.tsx [app-rsc] (ecmascript)\n \n-          expect(errorSource).toBe(null)\n+             1 | 'use cache'\n+             2 |\n+           > 3 | export default async function Page({\n+               |                ^\n+             4 |   searchParams,\n+             5 | }: {\n+             6 |   searchParams: Promise<{ n: string }>\"\n+          `)\n \n-          expect(cliOutput).toContain(`Error: ${expectedErrorMessage}\n+          expect(cliOutput).toContain(`Error: ${expectedTimeoutErrorMessage}\n     at [project]/app/search-params/page.tsx [app-rsc] (ecmascript)`)\n         } else {\n           expect(errorSource).toMatchInlineSnapshot(`\n@@ -67,12 +73,62 @@ describe('use-cache-hanging-inputs', () => {\n              6 |   searchParams: Promise<{ n: string }>\"\n           `)\n \n-          expect(cliOutput).toContain(`Error: ${expectedErrorMessage}\n+          expect(cliOutput).toContain(`Error: ${expectedTimeoutErrorMessage}\n     at eval (app/search-params/page.tsx:3:15)`)\n         }\n       }, 180_000)\n     })\n \n+    describe('when searchParams are used inside of \"use cache\", wrapped in try/catch', () => {\n+      it('should show an error toast after a timeout', async () => {\n+        const outputIndex = next.cliOutput.length\n+        const browser = await next.browser('/search-params-caught?n=1')\n+\n+        // The request is pending while we stall on the hanging inputs, and\n+        // playwright will wait for the load event before continuing. So we\n+        // don't need to wait for the \"use cache\" timeout of 50 seconds here.\n+\n+        await openRedbox(browser)\n+\n+        const errorCount = await getRedboxTotalErrorCount(browser)\n+        const errorDescription = await getRedboxDescription(browser)\n+        const errorSource = await getRedboxSource(browser)\n+\n+        expect(errorCount).toBe(1)\n+        expect(errorDescription).toBe(expectedTimeoutErrorMessage)\n+\n+        const cliOutput = stripAnsi(next.cliOutput.slice(outputIndex))\n+\n+        if (isTurbopack) {\n+          expect(errorSource).toMatchInlineSnapshot(`\n+           \"app/search-params-caught/page.tsx (1:1) @ [project]/app/search-params-caught/page.tsx [app-rsc] (ecmascript)\n+\n+           > 1 | async function getSearchParam({\n+               | ^\n+             2 |   searchParams,\n+             3 | }: {\n+             4 |   searchParams: Promise<{ n: string }>\"\n+          `)\n+\n+          expect(cliOutput).toContain(`Error: ${expectedTimeoutErrorMessage}\n+    at [project]/app/search-params-caught/page.tsx [app-rsc] (ecmascript)`)\n+        } else {\n+          expect(errorSource).toMatchInlineSnapshot(`\n+           \"app/search-params-caught/page.tsx (1:1) @ eval\n+\n+           > 1 | async function getSearchParam({\n+               | ^\n+             2 |   searchParams,\n+             3 | }: {\n+             4 |   searchParams: Promise<{ n: string }>\"\n+          `)\n+\n+          expect(cliOutput).toContain(`Error: ${expectedTimeoutErrorMessage}\n+    at eval (app/search-params-caught/page.tsx:1:0)`)\n+        }\n+      }, 180_000)\n+    })\n+\n     describe('when searchParams are unused inside of \"use cache\"', () => {\n       it('should not show an error', async () => {\n         const outputIndex = next.cliOutput.length\n@@ -82,7 +138,7 @@ describe('use-cache-hanging-inputs', () => {\n \n         const cliOutput = stripAnsi(next.cliOutput.slice(outputIndex))\n \n-        expect(cliOutput).not.toContain(`Error: ${expectedErrorMessage}`)\n+        expect(cliOutput).not.toContain(`Error: ${expectedTimeoutErrorMessage}`)\n       })\n     })\n \n@@ -97,21 +153,29 @@ describe('use-cache-hanging-inputs', () => {\n \n         await openRedbox(browser)\n \n+        const errorCount = await getRedboxTotalErrorCount(browser)\n         const errorDescription = await getRedboxDescription(browser)\n         const errorSource = await getRedboxSource(browser)\n \n-        expect(errorDescription).toBe(expectedErrorMessage)\n+        expect(errorCount).toBe(1)\n+        expect(errorDescription).toBe(expectedTimeoutErrorMessage)\n \n         const cliOutput = stripAnsi(next.cliOutput.slice(outputIndex))\n \n         if (isTurbopack) {\n-          // TODO(veil): For Turbopack, a fix in the React Flight Client, where\n-          // sourceURL is encoded, is needed for the error source and stack\n-          // frames to be source mapped.\n+          expect(errorSource).toMatchInlineSnapshot(`\n+           \"app/uncached-promise/page.tsx (10:13) @ [project]/app/uncached-promise/page.tsx [app-rsc] (ecmascript)\n \n-          expect(errorSource).toBe(null)\n+              8 | }\n+              9 |\n+           > 10 | const Foo = async ({ promise }) => {\n+                |             ^\n+             11 |   'use cache'\n+             12 |\n+             13 |   return (\"\n+          `)\n \n-          expect(cliOutput).toContain(`Error: ${expectedErrorMessage}\n+          expect(cliOutput).toContain(`Error: ${expectedTimeoutErrorMessage}\n     at [project]/app/uncached-promise/page.tsx [app-rsc] (ecmascript)`)\n         } else {\n           expect(errorSource).toMatchInlineSnapshot(`\n@@ -126,7 +190,7 @@ describe('use-cache-hanging-inputs', () => {\n              13 |   return (\"\n           `)\n \n-          expect(cliOutput).toContain(`Error: ${expectedErrorMessage}\n+          expect(cliOutput).toContain(`Error: ${expectedTimeoutErrorMessage}\n     at eval (app/uncached-promise/page.tsx:10:12)`)\n         }\n       }, 180_000)\n@@ -143,21 +207,29 @@ describe('use-cache-hanging-inputs', () => {\n \n         await openRedbox(browser)\n \n+        const errorCount = await getRedboxTotalErrorCount(browser)\n         const errorDescription = await getRedboxDescription(browser)\n         const errorSource = await getRedboxSource(browser)\n \n-        expect(errorDescription).toBe(expectedErrorMessage)\n+        expect(errorCount).toBe(1)\n+        expect(errorDescription).toBe(expectedTimeoutErrorMessage)\n \n         const cliOutput = stripAnsi(next.cliOutput.slice(outputIndex))\n \n         if (isTurbopack) {\n-          // TODO(veil): For Turbopack, a fix in the React Flight Client, where\n-          // sourceURL is encoded, is needed for the error source and stack\n-          // frames to be source mapped.\n+          expect(errorSource).toMatchInlineSnapshot(`\n+           \"app/uncached-promise-nested/page.tsx (16:1) @ [project]/app/uncached-promise-nested/page.tsx [app-rsc] (ecmascript)\n \n-          expect(errorSource).toBe(null)\n+             14 | }\n+             15 |\n+           > 16 | async function indirection(promise: Promise<number>) {\n+                | ^\n+             17 |   'use cache'\n+             18 |\n+             19 |   return getCachedData(promise)\"\n+          `)\n \n-          expect(cliOutput).toContain(`Error: ${expectedErrorMessage}\n+          expect(cliOutput).toContain(`Error: ${expectedTimeoutErrorMessage}\n     at [project]/app/uncached-promise-nested/page.tsx [app-rsc] (ecmascript)`)\n         } else {\n           expect(errorSource).toMatchInlineSnapshot(`\n@@ -172,7 +244,7 @@ describe('use-cache-hanging-inputs', () => {\n              19 |   return getCachedData(promise)\"\n           `)\n \n-          expect(cliOutput).toContain(`Error: ${expectedErrorMessage}\n+          expect(cliOutput).toContain(`Error: ${expectedTimeoutErrorMessage}\n     at eval (app/uncached-promise-nested/page.tsx:16:0)`)\n         }\n       }, 180_000)\n@@ -189,54 +261,46 @@ describe('use-cache-hanging-inputs', () => {\n \n         await openRedbox(browser)\n \n+        const errorCount = await getRedboxTotalErrorCount(browser)\n         const errorDescription = await getRedboxDescription(browser)\n         const errorSource = await getRedboxSource(browser)\n \n-        const cliOutput = stripAnsi(next.cliOutput.slice(outputIndex))\n+        expect(errorCount).toBe(1)\n \n-        if (isExperimentalReact) {\n-          // TODO(react-time-info): Remove this branch for experimental React when the issue is\n-          // resolved where the inclusion of server timings in the RSC payload\n-          // makes the serialized bound args not suitable to be used as a cache\n-          // key.\n+        const cliOutput = stripAnsi(next.cliOutput.slice(outputIndex))\n \n-          const expectedErrorMessagePpr =\n-            'Route \"/bound-args\": A component accessed data, headers, params, searchParams, or a short-lived cache without a Suspense boundary nor a \"use cache\" above it. We don\\'t have the exact line number added to error messages yet but you can see which component in the stack below. See more info: https://nextjs.org/docs/messages/next-prerender-missing-suspense'\n+        expect(errorDescription).toBe(expectedTimeoutErrorMessage)\n \n-          expect(errorDescription).toBe(expectedErrorMessagePpr)\n+        if (isTurbopack) {\n+          expect(errorSource).toMatchInlineSnapshot(`\n+            \"app/bound-args/page.tsx (13:15) @ [project]/app/bound-args/page.tsx [app-rsc] (ecmascript)\n+\n+              11 |   const uncachedDataPromise = fetchUncachedData()\n+              12 |\n+            > 13 |   const Foo = async () => {\n+                 |               ^\n+              14 |     'use cache'\n+              15 |\n+              16 |     return (\"\n+          `)\n \n-          expect(cliOutput).toContain(\n-            `${expectedErrorMessagePpr}\n-    at Page [Server] (<anonymous>)`\n-          )\n+          expect(cliOutput).toContain(`Error: ${expectedTimeoutErrorMessage}\n+    at [project]/app/bound-args/page.tsx [app-rsc] (ecmascript)`)\n         } else {\n-          expect(errorDescription).toBe(expectedErrorMessage)\n-\n-          if (isTurbopack) {\n-            // TODO(veil): For Turbopack, a fix in the React Flight Client, where\n-            // sourceURL is encoded, is needed for the error source and stack\n-            // frames to be source mapped.\n-\n-            expect(errorSource).toBe(null)\n+          expect(errorSource).toMatchInlineSnapshot(`\n+            \"app/bound-args/page.tsx (13:15) @ eval\n+\n+              11 |   const uncachedDataPromise = fetchUncachedData()\n+              12 |\n+            > 13 |   const Foo = async () => {\n+                 |               ^\n+              14 |     'use cache'\n+              15 |\n+              16 |     return (\"\n+          `)\n \n-            expect(cliOutput).toContain(`Error: ${expectedErrorMessage}\n-    at [project]/app/bound-args/page.tsx [app-rsc] (ecmascript)`)\n-          } else {\n-            expect(errorSource).toMatchInlineSnapshot(`\n-             \"app/bound-args/page.tsx (13:15) @ eval\n-\n-               11 |   const uncachedDataPromise = fetchUncachedData()\n-               12 |\n-             > 13 |   const Foo = async () => {\n-                  |               ^\n-               14 |     'use cache'\n-               15 |\n-               16 |     return (\"\n-            `)\n-\n-            expect(cliOutput).toContain(`Error: ${expectedErrorMessage}\n+          expect(cliOutput).toContain(`Error: ${expectedTimeoutErrorMessage}\n     at eval (app/bound-args/page.tsx:13:14)`)\n-          }\n         }\n       }, 180_000)\n     })\n@@ -262,23 +326,41 @@ describe('use-cache-hanging-inputs', () => {\n     it('should fail the build with errors after a timeout', async () => {\n       const { cliOutput } = await next.build()\n \n-      expect(cliOutput).toInclude(`Error: ${expectedErrorMessage}`)\n+      expect(cliOutput).toInclude(\n+        createExpectedBuildErrorMessage('/error', 'kaputt!')\n+      )\n+\n+      expect(cliOutput).toInclude(\n+        createExpectedBuildErrorMessage('/bound-args')\n+      )\n \n       expect(cliOutput).toInclude(\n-        'Error occurred prerendering page \"/bound-args\"'\n+        createExpectedBuildErrorMessage('/fallback-params/[slug]')\n       )\n \n       expect(cliOutput).toInclude(\n-        'Error occurred prerendering page \"/search-params\"'\n+        createExpectedBuildErrorMessage('/search-params')\n       )\n \n       expect(cliOutput).toInclude(\n-        'Error occurred prerendering page \"/uncached-promise\"'\n+        createExpectedBuildErrorMessage('/search-params-caught')\n       )\n \n       expect(cliOutput).toInclude(\n-        'Error occurred prerendering page \"/uncached-promise-nested\"'\n+        createExpectedBuildErrorMessage('/uncached-promise')\n+      )\n+\n+      expect(cliOutput).toInclude(\n+        createExpectedBuildErrorMessage('/uncached-promise-nested')\n       )\n     }, 180_000)\n   }\n })\n+\n+function createExpectedBuildErrorMessage(\n+  pathname: string,\n+  errorMessage: string = expectedTimeoutErrorMessage\n+) {\n+  return `Error occurred prerendering page \"${pathname}\". Read more: https://nextjs.org/docs/messages/prerender-error\n+Error: ${errorMessage}`\n+}"
        }
    ],
    "stats": {
        "total": 363,
        "additions": 238,
        "deletions": 125
    }
}