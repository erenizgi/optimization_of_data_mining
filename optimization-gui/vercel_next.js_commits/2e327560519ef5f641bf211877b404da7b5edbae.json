{
    "author": "acdlite",
    "message": "Include server latency in debug info (#84580)\n\nThe debug info of the promise created by the Flight client represents\nthe latency between when the navigation starts and when it's passed to\nReact. Most importantly, it should include the time it takes for the\nclient to start receiving data from the server.\n\nBefore this PR, the timing was too late because we did not call into the\nFlight client until after we started receiving data.\n\nTo fix this, we switch from using `createFromReadableStream` to\n`createFromFetch`. This allows us to call into the Flight client\nimmediately without waiting for the `fetch` promise to resolve.\n\nThe `_debugInfo` field contains the profiling information. Promises that\nare created by Flight already have this info added by React; for any\nderived promise created by the router, we need to transfer the Flight\ndebug info onto the derived promise.\n\nConcretely, we create a derived promise for each route segment contained\nin a response. Any nested promises contained with that segment are\npassed directly from Flight to React and don't require special\nprocessing.",
    "sha": "2e327560519ef5f641bf211877b404da7b5edbae",
    "files": [
        {
            "sha": "3456ada6e396d87b9ad6e547e7769bda5061e4e7",
            "filename": "packages/next/src/client/components/router-reducer/create-initial-router-state.test.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.test.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.test.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.test.tsx?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -139,6 +139,7 @@ describe('createInitialRouterState', () => {\n       cache: expectedCache,\n       nextUrl: '/linking',\n       previousNextUrl: null,\n+      debugInfo: null,\n     }\n \n     expect(state).toMatchObject(expected)"
        },
        {
            "sha": "9feeb6bd9111887d9842f74cc86886eb0bc50545",
            "filename": "packages/next/src/client/components/router-reducer/create-initial-router-state.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -111,6 +111,7 @@ export function createInitialRouterState({\n       (extractPathFromFlightRouterState(initialTree) || location?.pathname) ??\n       null,\n     previousNextUrl: null,\n+    debugInfo: null,\n   }\n \n   if (process.env.NODE_ENV !== 'development' && location) {\n@@ -146,6 +147,7 @@ export function createInitialRouterState({\n           prerendered && !process.env.__NEXT_CLIENT_SEGMENT_CACHE\n             ? STATIC_STALETIME_MS\n             : -1,\n+        debugInfo: null,\n       },\n       tree: initialState.tree,\n       prefetchCache: initialState.prefetchCache,"
        },
        {
            "sha": "34c2cf47131fcb6e8ef20406f3abfc0499c52e3a",
            "filename": "packages/next/src/client/components/router-reducer/fetch-server-response.ts",
            "status": "modified",
            "additions": 84,
            "deletions": 21,
            "changes": 105,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Ffetch-server-response.ts?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -2,7 +2,10 @@\n \n // TODO: Explicitly import from client.browser\n // eslint-disable-next-line import/no-extraneous-dependencies\n-import { createFromReadableStream as createFromReadableStreamBrowser } from 'react-server-dom-webpack/client'\n+import {\n+  createFromReadableStream as createFromReadableStreamBrowser,\n+  createFromFetch as createFromFetchBrowser,\n+} from 'react-server-dom-webpack/client'\n \n import type {\n   FlightRouterState,\n@@ -37,6 +40,8 @@ import { urlToUrlWithoutFlightMarker } from '../../route-params'\n \n const createFromReadableStream =\n   createFromReadableStreamBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromReadableStream']\n+const createFromFetch =\n+  createFromFetchBrowser as (typeof import('react-server-dom-webpack/client.browser'))['createFromFetch']\n \n let createDebugChannel:\n   | typeof import('../../dev/debug-channel').createDebugChannel\n@@ -65,6 +70,7 @@ export type FetchServerResponseResult = {\n   prerendered: boolean\n   postponed: boolean\n   staleTime: number\n+  debugInfo: Array<any> | null\n }\n \n export type RequestHeaders = {\n@@ -91,6 +97,7 @@ function doMpaNavigation(url: string): FetchServerResponseResult {\n     prerendered: false,\n     postponed: false,\n     staleTime: -1,\n+    debugInfo: null,\n   }\n }\n \n@@ -175,10 +182,17 @@ export async function fetchServerResponse(\n       }\n     }\n \n-    const res = await createFetch(\n+    // Typically, during a navigation, we decode the response using Flight's\n+    // `createFromFetch` API, which accepts a `fetch` promise.\n+    // TODO: Remove this check once the old PPR flag is removed\n+    const isLegacyPPR =\n+      process.env.__NEXT_PPR && !process.env.__NEXT_CACHE_COMPONENTS\n+    const shouldImmediatelyDecode = !isLegacyPPR\n+    const res = await createFetch<NavigationFlightResponse>(\n       url,\n       headers,\n       fetchPriority,\n+      shouldImmediatelyDecode,\n       abortController.signal\n     )\n \n@@ -226,26 +240,37 @@ export async function fetchServerResponse(\n       ).waitForWebpackRuntimeHotUpdate()\n     }\n \n-    // Handle the `fetch` readable stream that can be unwrapped by `React.use`.\n-    const flightStream = postponed\n-      ? createUnclosingPrefetchStream(res.body)\n-      : res.body\n-    const response = await (createFromNextReadableStream(\n-      flightStream,\n-      headers\n-    ) as Promise<NavigationFlightResponse>)\n+    let flightResponsePromise = res.flightResponse\n+    if (flightResponsePromise === null) {\n+      // Typically, `createFetch` would have already started decoding the\n+      // Flight response. If it hasn't, though, we need to decode it now.\n+      // TODO: This should only be reachable if legacy PPR is enabled (i.e. PPR\n+      // without Cache Components). Remove this branch once legacy PPR\n+      // is deleted.\n+      const flightStream = postponed\n+        ? createUnclosingPrefetchStream(res.body)\n+        : res.body\n+      flightResponsePromise =\n+        createFromNextReadableStream<NavigationFlightResponse>(\n+          flightStream,\n+          headers\n+        )\n+    }\n+\n+    const flightResponse = await flightResponsePromise\n \n-    if (getAppBuildId() !== response.b) {\n+    if (getAppBuildId() !== flightResponse.b) {\n       return doMpaNavigation(res.url)\n     }\n \n     return {\n-      flightData: normalizeFlightData(response.f),\n+      flightData: normalizeFlightData(flightResponse.f),\n       canonicalUrl: canonicalUrl,\n       couldBeIntercepted: interception,\n-      prerendered: response.S,\n+      prerendered: flightResponse.S,\n       postponed,\n       staleTime,\n+      debugInfo: flightResponsePromise._debugInfo ?? null,\n     }\n   } catch (err) {\n     if (!abortController.signal.aborted) {\n@@ -265,6 +290,7 @@ export async function fetchServerResponse(\n       prerendered: false,\n       postponed: false,\n       staleTime: -1,\n+      debugInfo: null,\n     }\n   }\n }\n@@ -274,21 +300,23 @@ export async function fetchServerResponse(\n // the codebase. For example, there's some custom logic for manually following\n // redirects, so \"redirected\" in this type could be a composite of multiple\n // browser fetch calls; however, this fact should not leak to the caller.\n-export type RSCResponse = {\n+export type RSCResponse<T> = {\n   ok: boolean\n   redirected: boolean\n   headers: Headers\n   body: ReadableStream<Uint8Array> | null\n   status: number\n   url: string\n+  flightResponse: (Promise<T> & { _debugInfo?: Array<any> }) | null\n }\n \n-export async function createFetch(\n+export async function createFetch<T>(\n   url: URL,\n   headers: RequestHeaders,\n   fetchPriority: 'auto' | 'high' | 'low' | null,\n+  shouldImmediatelyDecode: boolean,\n   signal?: AbortSignal\n-): Promise<RSCResponse> {\n+): Promise<RSCResponse<T>> {\n   // TODO: In output: \"export\" mode, the headers do nothing. Omit them (and the\n   // cache busting search param) from the request so they're\n   // maximally cacheable.\n@@ -326,7 +354,21 @@ export async function createFetch(\n   // track them separately.\n   let fetchUrl = new URL(url)\n   setCacheBustingSearchParam(fetchUrl, headers)\n-  let browserResponse = await fetch(fetchUrl, fetchOptions)\n+  let fetchPromise = fetch(fetchUrl, fetchOptions)\n+  // Immediately pass the fetch promise to the Flight client so that the debug\n+  // info includes the latency from the client to the server. The internal timer\n+  // in React starts as soon as `createFromFetch` is called.\n+  //\n+  // The only case where we don't do this is during a prefetch, because we have\n+  // to do some extra processing of the response stream (see\n+  // `createUnclosingPrefetchStream`). But this is fine, because a top-level\n+  // prefetch response never blocks a navigation; if it hasn't already been\n+  // written into the cache by the time the navigation happens, the router will\n+  // go straight to a dynamic request.\n+  let flightResponsePromise = shouldImmediatelyDecode\n+    ? createFromNextFetch<T>(fetchPromise, headers)\n+    : null\n+  let browserResponse = await fetchPromise\n \n   // If the server responds with a redirect (e.g. 307), and the redirected\n   // location does not contain the cache busting search param set in the\n@@ -379,9 +421,14 @@ export async function createFetch(\n       //\n       // Append the cache busting search param to the redirected URL and\n       // fetch again.\n+      // TODO: We should abort the previous request.\n       fetchUrl = new URL(responseUrl)\n       setCacheBustingSearchParam(fetchUrl, headers)\n-      browserResponse = await fetch(fetchUrl, fetchOptions)\n+      fetchPromise = fetch(fetchUrl, fetchOptions)\n+      flightResponsePromise = shouldImmediatelyDecode\n+        ? createFromNextFetch<T>(fetchPromise, headers)\n+        : null\n+      browserResponse = await fetchPromise\n       // We just performed a manual redirect, so this is now true.\n       redirected = true\n     }\n@@ -392,7 +439,7 @@ export async function createFetch(\n   const responseUrl = new URL(browserResponse.url, fetchUrl)\n   responseUrl.searchParams.delete(NEXT_RSC_UNION_QUERY)\n \n-  const rscResponse: RSCResponse = {\n+  const rscResponse: RSCResponse<T> = {\n     url: responseUrl.href,\n \n     // This is true if any redirects occurred, either automatically by the\n@@ -408,22 +455,38 @@ export async function createFetch(\n     headers: browserResponse.headers,\n     body: browserResponse.body,\n     status: browserResponse.status,\n+\n+    // This is the exact promise returned by `createFromFetch`. It contains\n+    // debug information that we need to transfer to any derived promises that\n+    // are later rendered by React.\n+    flightResponse: flightResponsePromise,\n   }\n \n   return rscResponse\n }\n \n-export function createFromNextReadableStream(\n+export function createFromNextReadableStream<T>(\n   flightStream: ReadableStream<Uint8Array>,\n   requestHeaders: RequestHeaders\n-): Promise<unknown> {\n+): Promise<T> {\n   return createFromReadableStream(flightStream, {\n     callServer,\n     findSourceMapURL,\n     debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n   })\n }\n \n+function createFromNextFetch<T>(\n+  promiseForResponse: Promise<Response>,\n+  requestHeaders: RequestHeaders\n+): Promise<T> & { _debugInfo?: Array<any> } {\n+  return createFromFetch(promiseForResponse, {\n+    callServer,\n+    findSourceMapURL,\n+    debugChannel: createDebugChannel && createDebugChannel(requestHeaders),\n+  })\n+}\n+\n function createUnclosingPrefetchStream(\n   originalFlightStream: ReadableStream<Uint8Array>\n ): ReadableStream<Uint8Array> {"
        },
        {
            "sha": "be2d2c6abb5e9343432ccc2e0f98fa38746b64b5",
            "filename": "packages/next/src/client/components/router-reducer/handle-mutable.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fhandle-mutable.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fhandle-mutable.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fhandle-mutable.ts?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -87,5 +87,6 @@ export function handleMutable(\n       : state.tree,\n     nextUrl,\n     previousNextUrl: previousNextUrl,\n+    debugInfo: mutable.collectedDebugInfo ?? null,\n   }\n }"
        },
        {
            "sha": "2e752c9a35ef5a1f9ad6ecd8045fb9b3f6b088ef",
            "filename": "packages/next/src/client/components/router-reducer/ppr-navigations.ts",
            "status": "modified",
            "additions": 74,
            "deletions": 33,
            "changes": 107,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -790,7 +790,7 @@ export function listenForDynamicRequest(\n   responsePromise: Promise<FetchServerResponseResult>\n ) {\n   responsePromise.then(\n-    ({ flightData }: FetchServerResponseResult) => {\n+    ({ flightData, debugInfo }: FetchServerResponseResult) => {\n       if (typeof flightData === 'string') {\n         // Happens when navigating to page in `pages` from `app`. We shouldn't\n         // get here because should have already handled this during\n@@ -817,18 +817,19 @@ export function listenForDynamicRequest(\n           segmentPath,\n           serverRouterState,\n           dynamicData,\n-          dynamicHead\n+          dynamicHead,\n+          debugInfo\n         )\n       }\n \n       // Now that we've exhausted all the data we received from the server, if\n       // there are any remaining pending tasks in the tree, abort them now.\n       // If there's any missing data, it will trigger a lazy fetch.\n-      abortTask(task, null)\n+      abortTask(task, null, debugInfo)\n     },\n     (error: any) => {\n       // This will trigger an error during render\n-      abortTask(task, error)\n+      abortTask(task, error, null)\n     }\n   )\n }\n@@ -838,7 +839,8 @@ function writeDynamicDataIntoPendingTask(\n   segmentPath: FlightSegmentPath,\n   serverRouterState: FlightRouterState,\n   dynamicData: CacheNodeSeedData,\n-  dynamicHead: HeadData\n+  dynamicHead: HeadData,\n+  debugInfo: Array<any> | null\n ) {\n   // The data sent by the server represents only a subtree of the app. We need\n   // to find the part of the task tree that matches the server response, and\n@@ -877,15 +879,17 @@ function writeDynamicDataIntoPendingTask(\n     task,\n     serverRouterState,\n     dynamicData,\n-    dynamicHead\n+    dynamicHead,\n+    debugInfo\n   )\n }\n \n function finishTaskUsingDynamicDataPayload(\n   task: SPANavigationTask,\n   serverRouterState: FlightRouterState,\n   dynamicData: CacheNodeSeedData,\n-  dynamicHead: HeadData\n+  dynamicHead: HeadData,\n+  debugInfo: Array<any> | null\n ) {\n   if (task.dynamicRequestTree === null) {\n     // Everything in this subtree is already complete. Bail out.\n@@ -906,7 +910,8 @@ function finishTaskUsingDynamicDataPayload(\n         task.route,\n         serverRouterState,\n         dynamicData,\n-        dynamicHead\n+        dynamicHead,\n+        debugInfo\n       )\n       // Set this to null to indicate that this task is now complete.\n       task.dynamicRequestTree = null\n@@ -937,7 +942,8 @@ function finishTaskUsingDynamicDataPayload(\n           taskChild,\n           serverRouterStateChild,\n           dynamicDataChild,\n-          dynamicHead\n+          dynamicHead,\n+          debugInfo\n         )\n       }\n     }\n@@ -1037,7 +1043,8 @@ function finishPendingCacheNode(\n   taskState: FlightRouterState,\n   serverState: FlightRouterState,\n   dynamicData: CacheNodeSeedData,\n-  dynamicHead: HeadData\n+  dynamicHead: HeadData,\n+  debugInfo: Array<any> | null\n ): void {\n   // Writes a dynamic response into an existing Cache Node tree. This does _not_\n   // create a new tree, it updates the existing tree in-place. So it must follow\n@@ -1086,19 +1093,20 @@ function finishPendingCacheNode(\n             taskStateChild,\n             serverStateChild,\n             dataChild,\n-            dynamicHead\n+            dynamicHead,\n+            debugInfo\n           )\n         } else {\n           // The server never returned data for this segment. Trigger a lazy\n           // fetch during render. This shouldn't happen because the Route Tree\n           // and the Seed Data tree sent by the server should always be the same\n           // shape when part of the same server response.\n-          abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n+          abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n         }\n       } else {\n         // The server never returned data for this segment. Trigger a lazy\n         // fetch during render.\n-        abortPendingCacheNode(taskStateChild, cacheNodeChild, null)\n+        abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n       }\n     } else {\n       // The server response matches what was expected to receive, but there's\n@@ -1120,7 +1128,7 @@ function finishPendingCacheNode(\n     // This is a deferred RSC promise. We can fulfill it with the data we just\n     // received from the server. If it was already resolved by a different\n     // navigation, then this does nothing because we can't overwrite data.\n-    rsc.resolve(dynamicSegmentData)\n+    rsc.resolve(dynamicSegmentData, debugInfo)\n   } else {\n     // This is not a deferred RSC promise, nor is it empty, so it must have\n     // been populated by a different navigation. We must not overwrite it.\n@@ -1131,19 +1139,23 @@ function finishPendingCacheNode(\n   const loading = cacheNode.loading\n   if (isDeferredRsc(loading)) {\n     const dynamicLoading = dynamicData[3]\n-    loading.resolve(dynamicLoading)\n+    loading.resolve(dynamicLoading, debugInfo)\n   }\n \n   // Check if this is a leaf segment. If so, it will have a `head` property with\n   // a pending promise that needs to be resolved with the dynamic head from\n   // the server.\n   const head = cacheNode.head\n   if (isDeferredRsc(head)) {\n-    head.resolve(dynamicHead)\n+    head.resolve(dynamicHead, debugInfo)\n   }\n }\n \n-export function abortTask(task: SPANavigationTask, error: any): void {\n+export function abortTask(\n+  task: SPANavigationTask,\n+  error: any,\n+  debugInfo: Array<any> | null\n+): void {\n   const cacheNode = task.node\n   if (cacheNode === null) {\n     // This indicates the task is already complete.\n@@ -1154,13 +1166,13 @@ export function abortTask(task: SPANavigationTask, error: any): void {\n   if (taskChildren === null) {\n     // Reached the leaf task node. This is the root of a pending cache\n     // node tree.\n-    abortPendingCacheNode(task.route, cacheNode, error)\n+    abortPendingCacheNode(task.route, cacheNode, error, debugInfo)\n   } else {\n     // This is an intermediate task node. Keep traversing until we reach a\n     // task node with no children. That will be the root of the cache node tree\n     // that needs to be resolved.\n     for (const taskChild of taskChildren.values()) {\n-      abortTask(taskChild, error)\n+      abortTask(taskChild, error, debugInfo)\n     }\n   }\n \n@@ -1171,7 +1183,8 @@ export function abortTask(task: SPANavigationTask, error: any): void {\n function abortPendingCacheNode(\n   routerState: FlightRouterState,\n   cacheNode: CacheNode,\n-  error: any\n+  error: any,\n+  debugInfo: Array<any> | null\n ): void {\n   // For every pending segment in the tree, resolve its `rsc` promise to `null`\n   // to trigger a lazy fetch during render.\n@@ -1192,7 +1205,7 @@ function abortPendingCacheNode(\n     const segmentKeyChild = createRouterCacheKey(segmentChild)\n     const cacheNodeChild = segmentMapChild.get(segmentKeyChild)\n     if (cacheNodeChild !== undefined) {\n-      abortPendingCacheNode(routerStateChild, cacheNodeChild, error)\n+      abortPendingCacheNode(routerStateChild, cacheNodeChild, error, debugInfo)\n     } else {\n       // This shouldn't happen because we're traversing the same tree that was\n       // used to construct the cache nodes in the first place.\n@@ -1203,16 +1216,16 @@ function abortPendingCacheNode(\n   if (isDeferredRsc(rsc)) {\n     if (error === null) {\n       // This will trigger a lazy fetch during render.\n-      rsc.resolve(null)\n+      rsc.resolve(null, debugInfo)\n     } else {\n       // This will trigger an error during rendering.\n-      rsc.reject(error)\n+      rsc.reject(error, debugInfo)\n     }\n   }\n \n   const loading = cacheNode.loading\n   if (isDeferredRsc(loading)) {\n-    loading.resolve(null)\n+    loading.resolve(null, debugInfo)\n   }\n \n   // Check if this is a leaf segment. If so, it will have a `head` property with\n@@ -1221,7 +1234,7 @@ function abortPendingCacheNode(\n   // the app. We want the segment to error, not the entire app.\n   const head = cacheNode.head\n   if (isDeferredRsc(head)) {\n-    head.resolve(null)\n+    head.resolve(null, debugInfo)\n   }\n }\n \n@@ -1293,25 +1306,28 @@ const DEFERRED = Symbol()\n \n type PendingDeferredRsc<T> = Promise<T> & {\n   status: 'pending'\n-  resolve: (value: T) => void\n-  reject: (error: any) => void\n+  resolve: (value: T, debugInfo: Array<any> | null) => void\n+  reject: (error: any, debugInfo: Array<any> | null) => void\n   tag: Symbol\n+  _debugInfo: Array<any>\n }\n \n type FulfilledDeferredRsc<T> = Promise<T> & {\n   status: 'fulfilled'\n   value: T\n-  resolve: (value: T) => void\n-  reject: (error: any) => void\n+  resolve: (value: T, debugInfo: Array<any> | null) => void\n+  reject: (error: any, debugInfo: Array<any> | null) => void\n   tag: Symbol\n+  _debugInfo: Array<any>\n }\n \n type RejectedDeferredRsc<T> = Promise<T> & {\n   status: 'rejected'\n   reason: any\n-  resolve: (value: T) => void\n-  reject: (error: any) => void\n+  resolve: (value: T, debugInfo: Array<any> | null) => void\n+  reject: (error: any, debugInfo: Array<any> | null) => void\n   tag: Symbol\n+  _debugInfo: Array<any>\n }\n \n type DeferredRsc<T extends React.ReactNode = React.ReactNode> =\n@@ -1330,29 +1346,54 @@ function isDeferredRsc(value: any): value is DeferredRsc {\n function createDeferredRsc<\n   T extends React.ReactNode = React.ReactNode,\n >(): PendingDeferredRsc<T> {\n+  // Create an unresolved promise that represents data derived from a Flight\n+  // response. The promise will be resolved later as soon as we start receiving\n+  // data from the server, i.e. as soon as the Flight client decodes and returns\n+  // the top-level response object.\n+\n+  // The `_debugInfo` field contains profiling information. Promises that are\n+  // created by Flight already have this info added by React; for any derived\n+  // promise created by the router, we need to transfer the Flight debug info\n+  // onto the derived promise.\n+  //\n+  // The debug info represents the latency between the start of the navigation\n+  // and the start of rendering. (It does not represent the time it takes for\n+  // whole stream to finish.)\n+  const debugInfo: Array<any> = []\n+\n   let resolve: any\n   let reject: any\n   const pendingRsc = new Promise<T>((res, rej) => {\n     resolve = res\n     reject = rej\n   }) as PendingDeferredRsc<T>\n   pendingRsc.status = 'pending'\n-  pendingRsc.resolve = (value: T) => {\n+  pendingRsc.resolve = (value: T, responseDebugInfo: Array<any> | null) => {\n     if (pendingRsc.status === 'pending') {\n       const fulfilledRsc: FulfilledDeferredRsc<T> = pendingRsc as any\n       fulfilledRsc.status = 'fulfilled'\n       fulfilledRsc.value = value\n+      if (responseDebugInfo !== null) {\n+        // Transfer the debug info to the derived promise.\n+        debugInfo.push.apply(debugInfo, responseDebugInfo)\n+      }\n       resolve(value)\n     }\n   }\n-  pendingRsc.reject = (error: any) => {\n+  pendingRsc.reject = (error: any, responseDebugInfo: Array<any> | null) => {\n     if (pendingRsc.status === 'pending') {\n       const rejectedRsc: RejectedDeferredRsc<T> = pendingRsc as any\n       rejectedRsc.status = 'rejected'\n       rejectedRsc.reason = error\n+      if (responseDebugInfo !== null) {\n+        // Transfer the debug info to the derived promise.\n+        debugInfo.push.apply(debugInfo, responseDebugInfo)\n+      }\n       reject(error)\n     }\n   }\n   pendingRsc.tag = DEFERRED\n+  pendingRsc._debugInfo = debugInfo\n+\n   return pendingRsc\n }"
        },
        {
            "sha": "edd2102740422f71b1485e2e5a19c7b74ab3bdd2",
            "filename": "packages/next/src/client/components/router-reducer/reducers/navigate-reducer.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -210,7 +210,8 @@ export function navigateReducer(\n       state.cache,\n       state.tree,\n       state.nextUrl,\n-      shouldScroll\n+      shouldScroll,\n+      mutable\n     )\n     return handleNavigationResult(url, state, mutable, pendingPush, result)\n   }"
        },
        {
            "sha": "19ed2fde8b7384a1caa89ae1ad4dc72134866717",
            "filename": "packages/next/src/client/components/router-reducer/reducers/restore-reducer.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frestore-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frestore-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frestore-reducer.ts?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -46,5 +46,6 @@ export function restoreReducer(\n     tree: treeToRestore,\n     nextUrl: extractPathFromFlightRouterState(treeToRestore) ?? url.pathname,\n     previousNextUrl: null,\n+    debugInfo: null,\n   }\n }"
        },
        {
            "sha": "98499e6555d7e8d711b80b89f2dd1f4db90281d0",
            "filename": "packages/next/src/client/components/router-reducer/reducers/server-action-reducer.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -439,6 +439,7 @@ export function serverActionReducer(\n               // TODO: We should be able to set this if the server action\n               // returned a fully static response.\n               staleTime: -1,\n+              debugInfo: null,\n             },\n             tree: state.tree,\n             prefetchCache: state.prefetchCache,"
        },
        {
            "sha": "7b9bc6da10d389bc9f9e990c5e5edf0c862bab28",
            "filename": "packages/next/src/client/components/router-reducer/router-reducer-types.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer-types.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer-types.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Frouter-reducer-types.ts?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -35,6 +35,7 @@ export interface Mutable {\n   shouldScroll?: boolean\n   preserveCustomHistoryState?: boolean\n   onlyHashChange?: boolean\n+  collectedDebugInfo?: Array<unknown>\n }\n \n export interface ServerActionMutable extends Mutable {\n@@ -259,10 +260,14 @@ export type AppRouterState = {\n    * The previous next-url that was used previous to a dynamic navigation.\n    */\n   previousNextUrl: string | null\n+\n+  debugInfo: Array<unknown> | null\n }\n \n export type ReadonlyReducerState = Readonly<AppRouterState>\n-export type ReducerState = Promise<AppRouterState> | AppRouterState\n+export type ReducerState =\n+  | (Promise<AppRouterState> & { _debugInfo?: Array<unknown> })\n+  | AppRouterState\n export type ReducerActions = Readonly<\n   | RefreshAction\n   | NavigateAction"
        },
        {
            "sha": "8ec33470760098908b94cf8078a1a63ab13b6097",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 13,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -1450,10 +1450,10 @@ export async function fetchRouteOnCacheMiss(\n           routeCacheLru.updateSize(entry, size)\n         }\n       )\n-      const serverData = await (createFromNextReadableStream(\n+      const serverData = await createFromNextReadableStream<RootTreePrefetch>(\n         prefetchStream,\n         headers\n-      ) as Promise<RootTreePrefetch>)\n+      )\n       if (serverData.buildId !== getAppBuildId()) {\n         // The server build does not match the client. Treat as a 404. During\n         // an actual navigation, the router will trigger an MPA navigation.\n@@ -1502,10 +1502,11 @@ export async function fetchRouteOnCacheMiss(\n           routeCacheLru.updateSize(entry, size)\n         }\n       )\n-      const serverData = await (createFromNextReadableStream(\n-        prefetchStream,\n-        headers\n-      ) as Promise<NavigationFlightResponse>)\n+      const serverData =\n+        await createFromNextReadableStream<NavigationFlightResponse>(\n+          prefetchStream,\n+          headers\n+        )\n       if (serverData.b !== getAppBuildId()) {\n         // The server build does not match the client. Treat as a 404. During\n         // an actual navigation, the router will trigger an MPA navigation.\n@@ -1523,7 +1524,7 @@ export async function fetchRouteOnCacheMiss(\n         // The non-PPR response format is what we'd get if we prefetched these segments\n         // using the LoadingBoundary fetch strategy, so mark their cache entries accordingly.\n         FetchStrategy.LoadingBoundary,\n-        response,\n+        response as RSCResponse<NavigationFlightResponse>,\n         serverData,\n         entry,\n         couldBeIntercepted,\n@@ -1787,7 +1788,7 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n       Date.now(),\n       task,\n       fetchStrategy,\n-      response,\n+      response as RSCResponse<NavigationFlightResponse>,\n       serverData,\n       isResponsePartial,\n       route,\n@@ -1810,7 +1811,7 @@ function writeDynamicTreeResponseIntoCache(\n     | FetchStrategy.LoadingBoundary\n     | FetchStrategy.PPRRuntime\n     | FetchStrategy.Full,\n-  response: RSCResponse,\n+  response: RSCResponse<NavigationFlightResponse>,\n   serverData: NavigationFlightResponse,\n   entry: PendingRouteCacheEntry,\n   couldBeIntercepted: boolean,\n@@ -1915,7 +1916,7 @@ function writeDynamicRenderResponseIntoCache(\n     | FetchStrategy.LoadingBoundary\n     | FetchStrategy.PPRRuntime\n     | FetchStrategy.Full,\n-  response: RSCResponse,\n+  response: RSCResponse<NavigationFlightResponse>,\n   serverData: NavigationFlightResponse,\n   isResponsePartial: boolean,\n   route: FulfilledRouteCacheEntry,\n@@ -2139,12 +2140,22 @@ function writeSeedDataIntoCache(\n   }\n }\n \n-async function fetchPrefetchResponse(\n+async function fetchPrefetchResponse<T>(\n   url: URL,\n   headers: RequestHeaders\n-): Promise<RSCResponse | null> {\n+): Promise<RSCResponse<T> | null> {\n   const fetchPriority = 'low'\n-  const response = await createFetch(url, headers, fetchPriority)\n+  // When issuing a prefetch request, don't immediately decode the response; we\n+  // use the lower level `createFromResponse` API instead because we need to do\n+  // some extra processing of the response stream. See\n+  // `createPrefetchResponseStream` for more details.\n+  const shouldImmediatelyDecode = false\n+  const response = await createFetch<T>(\n+    url,\n+    headers,\n+    fetchPriority,\n+    shouldImmediatelyDecode\n+  )\n   if (!response.ok) {\n     return null\n   }"
        },
        {
            "sha": "3697192d2660d513273fe5df7d1edf012000c673",
            "filename": "packages/next/src/client/components/segment-cache-impl/navigation.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 5,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -81,7 +81,8 @@ export function navigate(\n   currentCacheNode: CacheNode,\n   currentFlightRouterState: FlightRouterState,\n   nextUrl: string | null,\n-  shouldScroll: boolean\n+  shouldScroll: boolean,\n+  accumulation: { collectedDebugInfo?: Array<unknown> }\n ): NavigationResult {\n   const now = Date.now()\n   const href = url.href\n@@ -183,6 +184,10 @@ export function navigate(\n   }\n \n   // There's no matching prefetch for this route in the cache.\n+  let collectedDebugInfo = accumulation.collectedDebugInfo ?? []\n+  if (accumulation.collectedDebugInfo === undefined) {\n+    collectedDebugInfo = accumulation.collectedDebugInfo = []\n+  }\n   return {\n     tag: NavigationResultTag.Async,\n     data: navigateDynamicallyWithNoPrefetch(\n@@ -194,7 +199,8 @@ export function navigate(\n       currentCacheNode,\n       currentFlightRouterState,\n       shouldScroll,\n-      url.hash\n+      url.hash,\n+      collectedDebugInfo\n     ),\n   }\n }\n@@ -404,7 +410,8 @@ async function navigateDynamicallyWithNoPrefetch(\n   currentCacheNode: CacheNode,\n   currentFlightRouterState: FlightRouterState,\n   shouldScroll: boolean,\n-  hash: string\n+  hash: string,\n+  collectedDebugInfo: Array<unknown>\n ): Promise<\n   MPANavigationResult | SuccessfulNavigationResult | NoOpNavigationResult\n > {\n@@ -424,8 +431,15 @@ async function navigateDynamicallyWithNoPrefetch(\n     flightRouterState: currentFlightRouterState,\n     nextUrl,\n   })\n-  const { flightData, canonicalUrl: canonicalUrlOverride } =\n-    await promiseForDynamicServerResponse\n+  const {\n+    flightData,\n+    canonicalUrl: canonicalUrlOverride,\n+    debugInfo: debugInfoFromResponse,\n+  } = await promiseForDynamicServerResponse\n+\n+  if (debugInfoFromResponse !== null) {\n+    collectedDebugInfo.push(...debugInfoFromResponse)\n+  }\n \n   if (typeof flightData === 'string') {\n     // This is an MPA navigation."
        },
        {
            "sha": "5340f2ca9273151773f40ca52922034d2dee4810",
            "filename": "packages/next/src/client/components/use-action-queue.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 2,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fuse-action-queue.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fuse-action-queue.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fuse-action-queue.ts?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -1,5 +1,5 @@\n import type { Dispatch } from 'react'\n-import React, { use } from 'react'\n+import React, { use, useMemo } from 'react'\n import { isThenable } from '../../shared/lib/is-thenable'\n import type { AppRouterActionQueue } from './app-router-instance'\n import type {\n@@ -50,5 +50,27 @@ export function useActionQueue(\n       actionQueue.dispatch(action, setState)\n   }\n \n-  return isThenable(state) ? use(state) : state\n+  // When navigating to a non-prefetched route, then App Router state will be\n+  // blocked until the server responds. We need to transfer the `_debugInfo`\n+  // from the underlying Flight response onto the top-level promise that is\n+  // passed to React (via `use`) so that the latency is accurately represented\n+  // in the React DevTools.\n+  const stateWithDebugInfo = useMemo(() => {\n+    if (isThenable(state)) {\n+      const debugInfo: Array<unknown> = []\n+      const promiseWithDebugInfo = Promise.resolve(state).then((asyncState) => {\n+        if (asyncState.debugInfo !== null) {\n+          debugInfo.push(...asyncState.debugInfo)\n+        }\n+        return asyncState\n+      }) as Promise<AppRouterState> & { _debugInfo?: Array<unknown> }\n+      promiseWithDebugInfo._debugInfo = debugInfo\n+      return promiseWithDebugInfo\n+    }\n+    return state\n+  }, [state])\n+\n+  return isThenable(stateWithDebugInfo)\n+    ? use(stateWithDebugInfo)\n+    : stateWithDebugInfo\n }"
        },
        {
            "sha": "cc6afb8f9cd702e534fa3c4903b8e13ddaea028e",
            "filename": "packages/next/src/client/route-params.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/2e327560519ef5f641bf211877b404da7b5edbae/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts?ref=2e327560519ef5f641bf211877b404da7b5edbae",
            "patch": "@@ -21,7 +21,9 @@ export type RouteParam = {\n   type: DynamicParamTypesShort\n }\n \n-export function getRenderedSearch(response: RSCResponse): NormalizedSearch {\n+export function getRenderedSearch(\n+  response: RSCResponse<unknown>\n+): NormalizedSearch {\n   // If the server performed a rewrite, the search params used to render the\n   // page will be different from the params in the request URL. In this case,\n   // the response will include a header that gives the rewritten search query.\n@@ -37,7 +39,7 @@ export function getRenderedSearch(response: RSCResponse): NormalizedSearch {\n     .search as NormalizedSearch\n }\n \n-export function getRenderedPathname(response: RSCResponse): string {\n+export function getRenderedPathname(response: RSCResponse<unknown>): string {\n   // If the server performed a rewrite, the pathname used to render the\n   // page will be different from the pathname in the request URL. In this case,\n   // the response will include a header that gives the rewritten pathname."
        }
    ],
    "stats": {
        "total": 321,
        "additions": 243,
        "deletions": 78
    }
}