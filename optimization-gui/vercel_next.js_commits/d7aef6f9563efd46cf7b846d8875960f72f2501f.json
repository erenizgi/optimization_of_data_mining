{
    "author": "unstubbable",
    "message": "Ensure `searchParams` access in `\"use cache\"` triggers error when caught (#77838)\n\nAccessing search params in `\"use cache\"` functions is not allowed. We need to make sure that a build or dev error is still triggered even when the `searchParams` access is wrapped in a try/catch block.\r\n\r\nThis also fixes a bug where the errors were not correctly source-mapped with Turbopack.\r\n\r\nrelated: #75662\r\ncloses NAR-86",
    "sha": "d7aef6f9563efd46cf7b846d8875960f72f2501f",
    "files": [
        {
            "sha": "0f77ac6ecf8c06be20887d56d78d50fa05d51d8a",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/d7aef6f9563efd46cf7b846d8875960f72f2501f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d7aef6f9563efd46cf7b846d8875960f72f2501f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=d7aef6f9563efd46cf7b846d8875960f72f2501f",
            "patch": "@@ -1428,6 +1428,9 @@ async function renderToHTMLOrFlightImpl(\n \n     // If we encountered any unexpected errors during build we fail the\n     // prerendering phase and the build.\n+    if (workStore.invalidUsageError) {\n+      throw workStore.invalidUsageError\n+    }\n     if (response.digestErrorsMap.size) {\n       const buildFailingError = response.digestErrorsMap.values().next().value\n       if (buildFailingError) throw buildFailingError\n@@ -1612,6 +1615,10 @@ async function renderToHTMLOrFlightImpl(\n       postponedState\n     )\n \n+    if (workStore.invalidUsageError) {\n+      throw workStore.invalidUsageError\n+    }\n+\n     // If we have pending revalidates, wait until they are all resolved.\n     if (\n       workStore.pendingRevalidates ||"
        },
        {
            "sha": "996b4a86404f3b17e1752618f1de6f61662a9f42",
            "filename": "packages/next/src/server/app-render/create-component-tree.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 5,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/d7aef6f9563efd46cf7b846d8875960f72f2501f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d7aef6f9563efd46cf7b846d8875960f72f2501f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-component-tree.tsx?ref=d7aef6f9563efd46cf7b846d8875960f72f2501f",
            "patch": "@@ -329,11 +329,6 @@ async function createComponentTreeInternal({\n   const isPossiblyPartialResponse =\n     isStaticGeneration && experimental.isRoutePPREnabled === true\n \n-  // If there's a dynamic usage error attached to the store, throw it.\n-  if (workStore.dynamicUsageErr) {\n-    throw workStore.dynamicUsageErr\n-  }\n-\n   const LayoutOrPage: React.ComponentType<any> | undefined = layoutOrPageMod\n     ? interopDefault(layoutOrPageMod)\n     : undefined"
        },
        {
            "sha": "4dfb5373c80d0e345a5d2fd367d33fb83f8ab575",
            "filename": "packages/next/src/server/app-render/work-async-storage.external.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/d7aef6f9563efd46cf7b846d8875960f72f2501f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7aef6f9563efd46cf7b846d8875960f72f2501f/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-async-storage.external.ts?ref=d7aef6f9563efd46cf7b846d8875960f72f2501f",
            "patch": "@@ -1,6 +1,5 @@\n import type { AsyncLocalStorage } from 'async_hooks'\n import type { IncrementalCache } from '../lib/incremental-cache'\n-import type { DynamicServerError } from '../../client/components/hooks-server-context'\n import type { FetchMetrics } from '../base-http'\n import type { FallbackRouteParams } from '../request/fallback-params'\n import type { DeepReadonly } from '../../shared/lib/deep-readonly'\n@@ -49,7 +48,14 @@ export interface WorkStore {\n \n   dynamicUsageDescription?: string\n   dynamicUsageStack?: string\n-  dynamicUsageErr?: DynamicServerError\n+\n+  /**\n+   * Invalid usage errors might be caught in userland. We attach them to the\n+   * work store to ensure we can still fail the build or dev render.\n+   */\n+  // TODO: Collect an array of errors, and throw as AggregateError when\n+  // `serializeError` and the Dev Overlay support it.\n+  invalidUsageError?: Error\n \n   nextFetchId?: number\n   pathWasRevalidated?: boolean"
        },
        {
            "sha": "4da1f49b57c7893cbd8503ced098e49be8ab3f4f",
            "filename": "packages/next/src/server/request/search-params.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/d7aef6f9563efd46cf7b846d8875960f72f2501f/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7aef6f9563efd46cf7b846d8875960f72f2501f/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts?ref=d7aef6f9563efd46cf7b846d8875960f72f2501f",
            "patch": "@@ -462,7 +462,7 @@ export function makeErroringExoticSearchParamsForUseCache(\n         typeof prop === 'string' &&\n         (prop === 'then' || !wellKnownProperties.has(prop))\n       ) {\n-        throwForSearchParamsAccessInUseCache(workStore.route)\n+        throwForSearchParamsAccessInUseCache(workStore)\n       }\n \n       return ReflectAdapter.get(target, prop, receiver)\n@@ -476,13 +476,13 @@ export function makeErroringExoticSearchParamsForUseCache(\n         typeof prop === 'string' &&\n         (prop === 'then' || !wellKnownProperties.has(prop))\n       ) {\n-        throwForSearchParamsAccessInUseCache(workStore.route)\n+        throwForSearchParamsAccessInUseCache(workStore)\n       }\n \n       return ReflectAdapter.has(target, prop)\n     },\n     ownKeys() {\n-      throwForSearchParamsAccessInUseCache(workStore.route)\n+      throwForSearchParamsAccessInUseCache(workStore)\n     },\n   })\n "
        },
        {
            "sha": "a6d8bc5c88784152f09ff1291eddab4511257927",
            "filename": "packages/next/src/server/request/utils.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 3,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/d7aef6f9563efd46cf7b846d8875960f72f2501f/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Futils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7aef6f9563efd46cf7b846d8875960f72f2501f/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Futils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Futils.ts?ref=d7aef6f9563efd46cf7b846d8875960f72f2501f",
            "patch": "@@ -1,5 +1,6 @@\n import { StaticGenBailoutError } from '../../client/components/static-generation-bailout'\n import { afterTaskAsyncStorage } from '../app-render/after-task-async-storage.external'\n+import type { WorkStore } from '../app-render/work-async-storage.external'\n \n export function throwWithStaticGenerationBailoutError(\n   route: string,\n@@ -19,10 +20,16 @@ export function throwWithStaticGenerationBailoutErrorWithDynamicError(\n   )\n }\n \n-export function throwForSearchParamsAccessInUseCache(route: string): never {\n-  throw new Error(\n-    `Route ${route} used \"searchParams\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"searchParams\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n+export function throwForSearchParamsAccessInUseCache(\n+  workStore: WorkStore\n+): never {\n+  const error = new Error(\n+    `Route ${workStore.route} used \"searchParams\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"searchParams\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n   )\n+\n+  workStore.invalidUsageError ??= error\n+\n+  throw error\n }\n \n export function isRequestAPICallableInsideAfter() {"
        },
        {
            "sha": "3fc2cf1aedd0180cebce481b07906a3d6f2adf2d",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/d7aef6f9563efd46cf7b846d8875960f72f2501f/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7aef6f9563efd46cf7b846d8875960f72f2501f/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=d7aef6f9563efd46cf7b846d8875960f72f2501f",
            "patch": "@@ -177,6 +177,7 @@ function generateCacheEntryWithCacheContext(\n   return workUnitAsyncStorage.run(\n     cacheStore,\n     generateCacheEntryImpl,\n+    workStore,\n     outerWorkUnitStore,\n     cacheStore,\n     clientReferenceManifest,\n@@ -220,6 +221,7 @@ function propagateCacheLifeAndTags(\n \n async function collectResult(\n   savedStream: ReadableStream,\n+  workStore: WorkStore,\n   outerWorkUnitStore: WorkUnitStore | undefined,\n   innerCacheStore: UseCacheStore,\n   startTime: number,\n@@ -248,7 +250,9 @@ async function collectResult(\n   let idx = 0\n   const bufferStream = new ReadableStream({\n     pull(controller) {\n-      if (idx < buffer.length) {\n+      if (workStore.invalidUsageError) {\n+        controller.error(workStore.invalidUsageError)\n+      } else if (idx < buffer.length) {\n         controller.enqueue(buffer[idx++])\n       } else if (errors.length > 0) {\n         // TODO: Should we use AggregateError here?\n@@ -303,6 +307,7 @@ async function collectResult(\n }\n \n async function generateCacheEntryImpl(\n+  workStore: WorkStore,\n   outerWorkUnitStore: WorkUnitStore | undefined,\n   innerCacheStore: UseCacheStore,\n   clientReferenceManifest: DeepReadonly<ClientReferenceManifestForRsc>,\n@@ -411,6 +416,7 @@ async function generateCacheEntryImpl(\n \n   const promiseOfCacheEntry = collectResult(\n     savedStream,\n+    workStore,\n     outerWorkUnitStore,\n     innerCacheStore,\n     startTime,\n@@ -508,7 +514,7 @@ export function cache(\n   kind: string,\n   id: string,\n   boundArgsLength: number,\n-  fn: (...args: unknown[]) => Promise<unknown>\n+  originalFn: (...args: unknown[]) => Promise<unknown>\n ) {\n   const cacheHandler = getCacheHandler(kind)\n   if (cacheHandler === undefined) {\n@@ -519,7 +525,7 @@ export function cache(\n   const timeoutError = new UseCacheTimeoutError()\n   Error.captureStackTrace(timeoutError, cache)\n \n-  const name = fn.name\n+  const name = originalFn.name\n   const cachedFn = {\n     [name]: async function (...args: any[]) {\n       const workStore = workAsyncStorage.getStore()\n@@ -529,6 +535,8 @@ export function cache(\n         )\n       }\n \n+      let fn = originalFn\n+\n       const workUnitStore = workUnitAsyncStorage.getStore()\n \n       // Get the clientReferenceManifest while we're still in the outer Context.\n@@ -567,8 +575,6 @@ export function cache(\n         // Overwrite the props to omit $$isPageComponent.\n         args = [{ params, searchParams }]\n \n-        const originalFn = fn\n-\n         fn = {\n           [name]: async ({\n             params: serializedParams,"
        },
        {
            "sha": "141fe12424875f5c9b4166c9da6e5ac6a23f27b6",
            "filename": "test/e2e/app-dir/use-cache-standalone-search-params/app/search-params-caught/page.tsx",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/d7aef6f9563efd46cf7b846d8875960f72f2501f/test%2Fe2e%2Fapp-dir%2Fuse-cache-standalone-search-params%2Fapp%2Fsearch-params-caught%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d7aef6f9563efd46cf7b846d8875960f72f2501f/test%2Fe2e%2Fapp-dir%2Fuse-cache-standalone-search-params%2Fapp%2Fsearch-params-caught%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-standalone-search-params%2Fapp%2Fsearch-params-caught%2Fpage.tsx?ref=d7aef6f9563efd46cf7b846d8875960f72f2501f",
            "patch": "@@ -0,0 +1,15 @@\n+'use cache'\n+\n+export default async function Page({\n+  searchParams,\n+}: {\n+  searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n+}) {\n+  let param: string | string[] | undefined\n+\n+  try {\n+    param = (await searchParams).foo\n+  } catch {}\n+\n+  return <p>param: {param}</p>\n+}"
        },
        {
            "sha": "793c8b61bf3de8dd3514c0f006c435f82d835e53",
            "filename": "test/e2e/app-dir/use-cache-standalone-search-params/use-cache-standalone-search-params.test.ts",
            "status": "modified",
            "additions": 69,
            "deletions": 23,
            "changes": 92,
            "blob_url": "https://github.com/vercel/next.js/blob/d7aef6f9563efd46cf7b846d8875960f72f2501f/test%2Fe2e%2Fapp-dir%2Fuse-cache-standalone-search-params%2Fuse-cache-standalone-search-params.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d7aef6f9563efd46cf7b846d8875960f72f2501f/test%2Fe2e%2Fapp-dir%2Fuse-cache-standalone-search-params%2Fuse-cache-standalone-search-params.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-standalone-search-params%2Fuse-cache-standalone-search-params.test.ts?ref=d7aef6f9563efd46cf7b846d8875960f72f2501f",
            "patch": "@@ -11,7 +11,7 @@ const getExpectedErrorMessage = (route: string) =>\n   `Error: Route ${route} used \"searchParams\" inside \"use cache\". Accessing Dynamic data sources inside a cache scope is not supported. If you need this data inside a cached function use \"searchParams\" outside of the cached function and pass the required dynamic data in as an argument. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache`\n \n describe('use-cache-standalone-search-params', () => {\n-  const { next, isNextDev, isTurbopack, skipped } = nextTestSetup({\n+  const { next, isNextDev, skipped } = nextTestSetup({\n     files: __dirname,\n     skipDeployment: true,\n     skipStart: process.env.NEXT_TEST_MODE !== 'dev',\n@@ -43,29 +43,71 @@ describe('use-cache-standalone-search-params', () => {\n \n         const cliOutput = stripAnsi(next.cliOutput.slice(outputIndex))\n \n-        if (isTurbopack) {\n-          // TODO(veil): Should have a mapped error source.\n-          expect(errorSource).toBe(null)\n-\n-          // TODO(veil): Should be a relative filename.\n-          expect(cliOutput).toContain(`${expectedErrorMessage}\n-    at Page (file:/`)\n-        } else {\n-          expect(errorSource).toMatchInlineSnapshot(`\n-           \"app/search-params-used/page.tsx (8:17) @ Page\n-\n-              6 |   searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n-              7 | }) {\n-           >  8 |   const param = (await searchParams).foo\n-                |                 ^\n-              9 |\n-             10 |   return <p>param: {param}</p>\n-             11 | }\"\n-          `)\n-\n-          expect(cliOutput).toContain(`${expectedErrorMessage}\n+        expect(errorSource).toMatchInlineSnapshot(`\n+         \"app/search-params-used/page.tsx (8:17) @ Page\n+\n+            6 |   searchParams: Promise<{ [key: string]: string | string[] | undefined }>\n+            7 | }) {\n+         >  8 |   const param = (await searchParams).foo\n+              |                 ^\n+            9 |\n+           10 |   return <p>param: {param}</p>\n+           11 | }\"\n+        `)\n+\n+        expect(cliOutput).toContain(`${expectedErrorMessage}\n     at Page (app/search-params-used/page.tsx:8:17)`)\n-        }\n+      })\n+    })\n+\n+    describe('when searchParams are caught inside of \"use cache\"', () => {\n+      beforeAll(() => {\n+        route = '/search-params-caught'\n+      })\n+\n+      it('should show an error', async () => {\n+        const outputIndex = next.cliOutput.length\n+        const browser = await next.browser(`${route}?foo=1`)\n+\n+        await assertHasRedbox(browser)\n+\n+        const errorDescription = await getRedboxDescription(browser)\n+        const errorSource = await getRedboxSource(browser)\n+        const expectedErrorMessage = getExpectedErrorMessage(route)\n+\n+        expect(errorDescription).toBe(expectedErrorMessage)\n+\n+        const cliOutput = stripAnsi(next.cliOutput.slice(outputIndex))\n+\n+        expect(errorSource).toMatchInlineSnapshot(`\n+         \"app/search-params-caught/page.tsx (11:5) @ Page\n+\n+            9 |\n+           10 |   try {\n+         > 11 |     param = (await searchParams).foo\n+              |     ^\n+           12 |   } catch {}\n+           13 |\n+           14 |   return <p>param: {param}</p>\"\n+        `)\n+\n+        expect(cliOutput).toContain(`${expectedErrorMessage}\n+    at Page (app/search-params-caught/page.tsx:11:4)`)\n+      })\n+\n+      it('should also show an error after the second reload', async () => {\n+        // There was an obscure bug that lead to the error not being triggered\n+        // anymore starting with the third request. We test this scenario\n+        // explicitly to ensure we won't regress.\n+        const browser = await next.browser(`${route}?foo=1`)\n+        await browser.refresh()\n+        await browser.refresh()\n+\n+        await assertHasRedbox(browser)\n+\n+        const errorDescription = await getRedboxDescription(browser)\n+\n+        expect(errorDescription).toBe(getExpectedErrorMessage(route))\n       })\n     })\n \n@@ -93,6 +135,10 @@ describe('use-cache-standalone-search-params', () => {\n         getExpectedErrorMessage('/search-params-used')\n       )\n \n+      expect(cliOutput).toInclude(\n+        getExpectedErrorMessage('/search-params-caught')\n+      )\n+\n       expect(cliOutput).not.toInclude(\n         getExpectedErrorMessage('/search-params-unused')\n       )"
        }
    ],
    "stats": {
        "total": 164,
        "additions": 123,
        "deletions": 41
    }
}