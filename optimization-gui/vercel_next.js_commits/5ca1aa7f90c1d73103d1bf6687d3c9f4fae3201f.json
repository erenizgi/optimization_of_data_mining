{
    "author": "bgw",
    "message": "Turbopack: perf: Fix unused argument filtering optimization in turbo-tasks for `self` arguments (#86231)\n\nShould fix https://github.com/vercel/next.js/pull/86203\n\n## Validation\n\nI ran:\n\n```\nrm -rf .next && NEXT_TURBOPACK_TASK_STATISTICS=~/stats-with-fix.json pnpm next build --turbopack --experimental-build-mode=compile\n```\n\nover vercel-site and used `jq '[.[].cache_miss]|add'\n~/stats-with-fix.json` and `jq '[.[].cache_hit]|add'\n~/stats-with-fix.json` to measure the total cache hits/misses. These\nnumbers are pretty stable from run-to-run (`cache_miss` shows zero\nvariance, `cache_hit` shows a minor variance) because Turbopack is\n(mostly) deterministic.\n\n**Canary:**\n```\ncache_miss: 8603613\ncache_hit: 34824116\n```\n\n**With This Fix:**\n```\ncache_miss: 8602660\ncache_hit: 34825148\n```\n\nThe difference is surprisingly small (much less than 1%), but it's still\nan improvement.",
    "sha": "5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f",
    "files": [
        {
            "sha": "db1dc39001228d8465197b08cac390ab98f76c13",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f",
            "patch": "@@ -9383,6 +9383,7 @@ dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n  \"regex\",\n+ \"rstest\",\n  \"rustc-hash 2.1.1\",\n  \"syn 2.0.104\",\n ]"
        },
        {
            "sha": "d863dd79e8e189a3a1b6752defbd41e8454ec3eb",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trace_transient.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrace_transient.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrace_transient.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrace_transient.rs?ref=5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f",
            "patch": "@@ -50,6 +50,7 @@ impl Adder {\n \n     #[turbo_tasks::function]\n     async fn add_method(&self, arg1: ResolvedVc<u16>, arg2: ResolvedVc<u32>) -> Result<Vc<u64>> {\n+        let _ = self; // Make sure unused argument filtering doesn't remove the arg\n         Ok(Vc::cell(u64::from(*arg1.await?) + u64::from(*arg2.await?)))\n     }\n }"
        },
        {
            "sha": "3911f77ddc960f481357803a1297f1a5ca636169",
            "filename": "turbopack/crates/turbo-tasks-macros/Cargo.toml",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-macros%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-macros%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2FCargo.toml?ref=5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f",
            "patch": "@@ -20,3 +20,6 @@ quote = { workspace = true }\n regex = { workspace = true }\n rustc-hash = { workspace = true }\n syn = { workspace = true, features = [\"full\", \"extra-traits\", \"visit\", \"visit-mut\"] }\n+\n+[dev-dependencies]\n+rstest = { workspace = true }"
        },
        {
            "sha": "054f13e133651492853b111b74faa2a2bc510e53",
            "filename": "turbopack/crates/turbo-tasks-macros/src/func.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 7,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs?ref=5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f",
            "patch": "@@ -27,6 +27,7 @@ pub struct TurboFn<'a> {\n \n     output: Type,\n     this: Option<Input>,\n+    is_self_used: bool,\n     exposed_inputs: Vec<Input>,\n     /// Should we return `OperationVc` and require that all arguments are `NonLocalValue`s?\n     operation: bool,\n@@ -43,6 +44,7 @@ impl TurboFn<'_> {\n         orig_signature: &Signature,\n         definition_context: DefinitionContext,\n         args: FunctionArguments,\n+        is_self_used: bool,\n     ) -> Option<TurboFn<'_>> {\n         if !orig_signature.generics.params.is_empty() {\n             orig_signature\n@@ -202,6 +204,7 @@ impl TurboFn<'_> {\n             ident: orig_ident,\n             output,\n             this,\n+            is_self_used,\n             exposed_inputs,\n             operation: args.operation.is_some(),\n             inline_ident,\n@@ -271,7 +274,6 @@ impl TurboFn<'_> {\n     pub fn inline_signature_and_block<'a>(\n         &self,\n         orig_block: &'a Block,\n-        is_self_used: bool,\n     ) -> (Signature, Cow<'a, Block>) {\n         let mut shadow_self = None;\n         let (inputs, transform_stmts): (Punctuated<_, _>, Vec<Option<_>>) = self\n@@ -280,7 +282,7 @@ impl TurboFn<'_> {\n             .iter()\n             .filter(|arg| {\n                 let FnArg::Typed(pat_type) = arg else {\n-                    return is_self_used;\n+                    return self.is_self_used;\n                 };\n                 let Pat::Ident(pat_id) = &*pat_type.pat else {\n                     return true;\n@@ -543,8 +545,7 @@ impl TurboFn<'_> {\n         }\n     }\n \n-    /// The block of the exposed function for a dynamic dispatch call to the\n-    /// given trait.\n+    /// The block of the exposed function for a dynamic dispatch call to the given trait.\n     pub fn dynamic_block(&self, trait_type_ident: &Ident) -> Block {\n         let Some(converted_this) = self.converted_this() else {\n             return parse_quote! {\n@@ -579,13 +580,14 @@ impl TurboFn<'_> {\n         }\n     }\n \n-    /// The block of the exposed function for a static dispatch call to the\n-    /// given native function.\n+    /// The block of the exposed function for a static dispatch call to the given native function.\n     pub fn static_block(&self, native_function_ident: &Ident) -> Block {\n         let output = &self.output;\n         let inputs = self.inline_input_idents();\n         let assertions = self.get_assertions();\n-        let mut block = if let Some(converted_this) = self.converted_this() {\n+        let mut block = if self.is_self_used\n+            && let Some(converted_this) = self.converted_this()\n+        {\n             let persistence = self.persistence_with_this();\n             parse_quote! {\n                 {"
        },
        {
            "sha": "7549c0501159298c129e2e328f08434b79f2cd33",
            "filename": "turbopack/crates/turbo-tasks-macros/src/function_macro.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs?ref=5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f",
            "patch": "@@ -43,7 +43,7 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n         .unwrap_or_default();\n     let is_self_used = args.operation.is_some() || is_self_used(&block);\n \n-    let Some(turbo_fn) = TurboFn::new(&sig, DefinitionContext::NakedFn, args) else {\n+    let Some(turbo_fn) = TurboFn::new(&sig, DefinitionContext::NakedFn, args, is_self_used) else {\n         return quote! {\n             // An error occurred while parsing the function signature.\n         }\n@@ -53,8 +53,7 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n     let ident = &sig.ident;\n \n     let inline_function_ident = turbo_fn.inline_ident();\n-    let (inline_signature, inline_block) =\n-        turbo_fn.inline_signature_and_block(&block, is_self_used);\n+    let (inline_signature, inline_block) = turbo_fn.inline_signature_and_block(&block);\n     let inline_attrs = filter_inline_attributes(&attrs[..]);\n     let function_path_string = ident.to_string();\n "
        },
        {
            "sha": "bbfde654e93761006e22979b407a3b6b91cb7945",
            "filename": "turbopack/crates/turbo-tasks-macros/src/self_filter.rs",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fself_filter.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fself_filter.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fself_filter.rs?ref=5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f",
            "patch": "@@ -79,3 +79,38 @@ fn contains_self_token(tok: &TokenTree) -> bool {\n         TokenTree::Punct(..) | TokenTree::Literal(..) => false,\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use rstest::rstest;\n+\n+    use super::*;\n+\n+    #[rstest]\n+    #[case::no_self_usage(r#\"{ let x = 42; println!(\"hello\"); }\"#, false)]\n+    #[case::simple_self_usage(r#\"{ self.foo(); }\"#, true)]\n+    #[case::self_field_access(r#\"{ let x = self.field; }\"#, true)]\n+    #[case::self_in_nested_block(r#\"{ let x = 1; { self.method(); } }\"#, true)]\n+    #[case::self_in_impl_block_not_detected(\n+        r#\"{ impl Foo { fn bar(&self) { self.baz(); } } }\"#,\n+        false\n+    )]\n+    #[case::self_before_impl_block(\n+        r#\"{ self.foo(); impl Bar { fn baz(&self) { self.qux(); } } }\"#,\n+        true\n+    )]\n+    #[case::self_in_closure(r#\"{ let f = || { self.method(); }; }\"#, true)]\n+    #[case::self_in_if_condition(r#\"{ if self.check() { println!(\"true\"); } }\"#, true)]\n+    #[case::self_in_match_arm(r#\"{ match x { Some(_) => self.handle(), None => {}, } }\"#, true)]\n+    #[case::self_in_macro(r#\"{ println!(\"{:?}\", self); }\"#, true)]\n+    #[case::self_in_complex_macro(r#\"{ format!(\"value: {}\", self.field); }\"#, true)]\n+    #[case::no_self_with_similar_idents(r#\"{ let myself = 42; let selfish = true; }\"#, false)]\n+    #[case::empty_block(r#\"{}\"#, false)]\n+    #[case::self_in_return_statement(r#\"{ return self.value; }\"#, true)]\n+    #[case::self_as_function_argument(r#\"{ some_function(self); }\"#, true)]\n+    fn test_is_self_used(#[case] code: &str, #[case] expected: bool) {\n+        let block: syn::Block = syn::parse_str(code).unwrap();\n+        let result = is_self_used(&block);\n+        assert_eq!(result, expected);\n+    }\n+}"
        },
        {
            "sha": "50046a9a7b64dc3aa1bc70061f65f96787b5829f",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_impl_macro.rs",
            "status": "modified",
            "additions": 65,
            "deletions": 58,
            "changes": 123,
            "blob_url": "https://github.com/vercel/next.js/blob/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs?ref=5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f",
            "patch": "@@ -73,66 +73,71 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n         let mut errors = Vec::new();\n \n         for item in items.iter() {\n-            if let ImplItem::Fn(ImplItemFn {\n+            let ImplItem::Fn(ImplItemFn {\n                 attrs,\n                 vis,\n                 defaultness: _,\n                 sig,\n                 block,\n             }) = item\n-            {\n-                let ident = &sig.ident;\n-                let (func_args, attrs) = split_function_attributes(attrs);\n-                let func_args = match func_args {\n-                    Ok(None) => {\n-                        item.span()\n-                            .unwrap()\n-                            .error(\"#[turbo_tasks::function] attribute missing\")\n-                            .emit();\n-                        FunctionArguments::default()\n-                    }\n-                    Ok(Some(func_args)) => func_args,\n-                    Err(error) => {\n-                        errors.push(error.to_compile_error());\n-                        FunctionArguments::default()\n-                    }\n-                };\n-                let is_self_used = func_args.operation.is_some() || is_self_used(block);\n-\n-                let Some(turbo_fn) =\n-                    TurboFn::new(sig, DefinitionContext::ValueInherentImpl, func_args)\n-                else {\n-                    return quote! {\n-                        // An error occurred while parsing the function signature.\n-                    };\n-                };\n+            else {\n+                continue;\n+            };\n+\n+            let ident = &sig.ident;\n+            let (func_args, attrs) = split_function_attributes(attrs);\n+            let func_args = match func_args {\n+                Ok(None) => {\n+                    item.span()\n+                        .unwrap()\n+                        .error(\"#[turbo_tasks::function] attribute missing\")\n+                        .emit();\n+                    FunctionArguments::default()\n+                }\n+                Ok(Some(func_args)) => func_args,\n+                Err(error) => {\n+                    errors.push(error.to_compile_error());\n+                    FunctionArguments::default()\n+                }\n+            };\n+            let is_self_used = func_args.operation.is_some() || is_self_used(block);\n \n-                let inline_function_ident = turbo_fn.inline_ident();\n-                let (inline_signature, inline_block) =\n-                    turbo_fn.inline_signature_and_block(block, is_self_used);\n-                let inline_attrs = filter_inline_attributes(attrs.iter().copied());\n-                let function_path_string = format!(\"{ty}::{ident}\", ty = ty.to_token_stream());\n-                let native_fn = NativeFn {\n-                    function_global_name: global_name(&function_path_string),\n-                    function_path_string,\n-                    function_path: parse_quote! { <#ty>::#inline_function_ident },\n-                    is_method: turbo_fn.is_method(),\n-                    is_self_used,\n-                    filter_trait_call_args: None, // not a trait method\n+            let Some(turbo_fn) = TurboFn::new(\n+                sig,\n+                DefinitionContext::ValueInherentImpl,\n+                func_args,\n+                is_self_used,\n+            ) else {\n+                return quote! {\n+                    // An error occurred while parsing the function signature.\n                 };\n-\n-                let native_function_ident = get_inherent_impl_function_ident(ty_ident, ident);\n-                let native_function_ty = native_fn.ty();\n-                let native_function_def = native_fn.definition();\n-\n-                let turbo_signature = turbo_fn.signature();\n-                let turbo_block = turbo_fn.static_block(&native_function_ident);\n-                exposed_impl_items.push(quote! {\n-                    #(#attrs)*\n-                    #vis #turbo_signature #turbo_block\n-                });\n-\n-                all_definitions.push(quote! {\n+            };\n+\n+            let inline_function_ident = turbo_fn.inline_ident();\n+            let (inline_signature, inline_block) = turbo_fn.inline_signature_and_block(block);\n+            let inline_attrs = filter_inline_attributes(attrs.iter().copied());\n+            let function_path_string = format!(\"{ty}::{ident}\", ty = ty.to_token_stream());\n+            let native_fn = NativeFn {\n+                function_global_name: global_name(&function_path_string),\n+                function_path_string,\n+                function_path: parse_quote! { <#ty>::#inline_function_ident },\n+                is_method: turbo_fn.is_method(),\n+                is_self_used,\n+                filter_trait_call_args: None, // not a trait method\n+            };\n+\n+            let native_function_ident = get_inherent_impl_function_ident(ty_ident, ident);\n+            let native_function_ty = native_fn.ty();\n+            let native_function_def = native_fn.definition();\n+\n+            let turbo_signature = turbo_fn.signature();\n+            let turbo_block = turbo_fn.static_block(&native_function_ident);\n+            exposed_impl_items.push(quote! {\n+                #(#attrs)*\n+                #vis #turbo_signature #turbo_block\n+            });\n+\n+            all_definitions.push(quote! {\n                     #[doc(hidden)]\n                     impl #ty {\n                         // By declaring the native function's body within an `impl` block, we ensure\n@@ -153,7 +158,6 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                         turbo_tasks::macro_helpers::CollectableFunction(&#native_function_ident)\n                     }\n                 })\n-            }\n         }\n \n         quote! {\n@@ -207,11 +211,15 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                         continue;\n                     }\n                 };\n+                // operations are not currently compatible with methods\n                 let is_self_used = func_args.operation.is_some() || is_self_used(block);\n \n-                let Some(turbo_fn) =\n-                    TurboFn::new(sig, DefinitionContext::ValueTraitImpl, func_args)\n-                else {\n+                let Some(turbo_fn) = TurboFn::new(\n+                    sig,\n+                    DefinitionContext::ValueTraitImpl,\n+                    func_args,\n+                    is_self_used,\n+                ) else {\n                     return quote! {\n                         // An error occurred while parsing the function signature.\n                     };\n@@ -222,8 +230,7 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                     &format!(\"{ty_ident}_{trait_ident}_{ident}_inline\"),\n                     ident.span(),\n                 );\n-                let (inline_signature, inline_block) =\n-                    turbo_fn.inline_signature_and_block(block, is_self_used);\n+                let (inline_signature, inline_block) = turbo_fn.inline_signature_and_block(block);\n                 let inline_attrs = filter_inline_attributes(attrs.iter().copied());\n                 let native_fn = NativeFn {\n                     // This global name breaks the pattern.  It isn't clear if it is intentional"
        },
        {
            "sha": "5748d6a643752ffeb1e214e31bc2d6d17eb62d42",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_trait_macro.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs?ref=5ca1aa7f90c1d73103d1bf6687d3c9f4fae3201f",
            "patch": "@@ -176,10 +176,12 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n                 .emit();\n         }\n \n+        let is_self_used = default.as_ref().map(is_self_used).unwrap_or(false);\n         let Some(turbo_fn) = TurboFn::new(\n             sig,\n             DefinitionContext::ValueTrait,\n             FunctionArguments::default(),\n+            is_self_used,\n         ) else {\n             return quote! {\n                 // An error occurred while parsing the function signature.\n@@ -194,12 +196,10 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n         });\n \n         let default = if let Some(default) = default {\n-            let is_self_used = is_self_used(default);\n             let inline_function_ident = turbo_fn.inline_ident();\n             let inline_extension_trait_ident =\n                 Ident::new(&format!(\"{trait_ident}_{ident}_inline\"), ident.span());\n-            let (inline_signature, inline_block) =\n-                turbo_fn.inline_signature_and_block(default, is_self_used);\n+            let (inline_signature, inline_block) = turbo_fn.inline_signature_and_block(default);\n             let inline_attrs = filter_inline_attributes(attrs.iter().copied());\n \n             let function_path_string = format!(\"{trait_ident}::{ident}\");"
        }
    ],
    "stats": {
        "total": 190,
        "additions": 119,
        "deletions": 71
    }
}