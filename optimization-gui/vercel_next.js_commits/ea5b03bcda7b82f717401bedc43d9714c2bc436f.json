{
    "author": "acdlite",
    "message": "[Segment Cache] Optimistic prefetch for search params (#82586)\n\nWhen there is no matching route tree in the prefetch cache, before we\nde-opt to a blocking navigation, we will first attempt to construct an\n\"optimistic\" route tree by checking the cache for routes are likely to\nbe similar to the one we're missing.\n\nIf there's a route with the same pathname, but with different search\nparams, we can base our optimistic route on that entry.\n\nConceptually, we are simulating what would happen if we did perform a\nprefetch the requested URL, under the assumption that the server will\nnot redirect or rewrite the request in a different manner than the base\nroute tree. This assumption might not hold, in which case we'll have to\nrecover when we perform the dynamic navigation request. However, this is\nwhat would happen if a route were dynamically rewritten/ redirected in\nbetween the prefetch and the navigation. So the logic needs to exist to\nhandle this case regardless.\n\nThe implementation in this PR is a bit of an incremental step; it's not\nas general as it should be. Notably, it will bail out if the base route\ntree contains dynamic metadata, because we currently don't store the\nroute tree separately from the metadata.\n\nWe are also currently special-casing prefetch entries with an empty\nsearch string. To take advantage of the optimistic prefetch behavior,\nthere must be a prefetch entry for the target URL with no search params,\ne.g. to navigate to a page at `/target-page?search=foobar`, you must\nfirst prefetch `/target-page` (no search string). This is a somewhat\narbitrary limitation chosen as a concession to implementation\ncomplexity; the empty search string is only used because it's the one\nthat's most likely to already be cached. We will generalize this later\nto match any search string.\n\nI've added some TODO comments to describe the work necessary to enable\nthis mechanism in more cases.\n\nCo-authored-by: Zack Tanner <1939140+ztanner@users.noreply.github.com>",
    "sha": "ea5b03bcda7b82f717401bedc43d9714c2bc436f",
    "files": [
        {
            "sha": "c41a4a2dbff5779abf93e6614756ef3ee6140d30",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 150,
            "deletions": 3,
            "changes": 153,
            "blob_url": "https://github.com/vercel/next.js/blob/ea5b03bcda7b82f717401bedc43d9714c2bc436f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ea5b03bcda7b82f717401bedc43d9714c2bc436f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=ea5b03bcda7b82f717401bedc43d9714c2bc436f",
            "patch": "@@ -43,6 +43,8 @@ import type {\n   NormalizedSearch,\n   RouteCacheKey,\n } from './cache-key'\n+// TODO: Rename this module to avoid confusion with other types of cache keys\n+import { createCacheKey as createPrefetchRequestKey } from './cache-key'\n import {\n   doesStaticSegmentAppearInURL,\n   getCacheKeyForDynamicParam,\n@@ -130,6 +132,7 @@ type RouteCacheEntryShared = {\n \n   // See comment in scheduler.ts for context\n   TODO_metadataStatus: EntryStatus.Empty | EntryStatus.Fulfilled\n+  TODO_isHeadDynamic: boolean\n \n   // LRU-related fields\n   keypath: null | Prefix<RouteCacheKeypath>\n@@ -588,6 +591,7 @@ export function readOrCreateRouteCacheEntry(\n     renderedSearch: null,\n \n     TODO_metadataStatus: EntryStatus.Empty,\n+    TODO_isHeadDynamic: false,\n \n     // LRU-related fields\n     keypath: null,\n@@ -605,6 +609,135 @@ export function readOrCreateRouteCacheEntry(\n   return pendingEntry\n }\n \n+export function requestOptimisticRouteCacheEntry(\n+  now: number,\n+  requestedUrl: URL,\n+  nextUrl: string | null\n+): FulfilledRouteCacheEntry | null {\n+  // This function is called during a navigation when there was no matching\n+  // route tree in the prefetch cache. Before de-opting to a blocking,\n+  // unprefetched navigation, we will first attempt to construct an \"optimistic\"\n+  // route tree by checking the cache for similar routes.\n+  //\n+  // Check if there's a route with the same pathname, but with different\n+  // search params. We can then base our optimistic route tree on this entry.\n+  //\n+  // Conceptually, we are simulating what would happen if we did perform a\n+  // prefetch the requested URL, under the assumption that the server will\n+  // not redirect or rewrite the request in a different manner than the\n+  // base route tree. This assumption might not hold, in which case we'll have\n+  // to recover when we perform the dynamic navigation request. However, this\n+  // is what would happen if a route were dynamically rewritten/redirected\n+  // in between the prefetch and the navigation. So the logic needs to exist\n+  // to handle this case regardless.\n+\n+  // Look for a route with the same pathname, but with an empty search string.\n+  // TODO: There's nothing inherently special about the empty search string;\n+  // it's chosen somewhat arbitrarily, with the rationale that it's the most\n+  // likely one to exist. But we should update this to match _any_ search\n+  // string. The plan is to generalize this logic alongside other improvements\n+  // related to \"fallback\" cache entries.\n+  const requestedSearch = requestedUrl.search as NormalizedSearch\n+  if (requestedSearch === '') {\n+    // The caller would have already checked if a route with an empty search\n+    // string is in the cache. So we can bail out here.\n+    return null\n+  }\n+  const routeWithNoSearchParams = readRouteCacheEntry(\n+    now,\n+    createPrefetchRequestKey(\n+      requestedUrl.origin + requestedUrl.pathname,\n+      nextUrl\n+    )\n+  )\n+\n+  if (\n+    routeWithNoSearchParams === null ||\n+    routeWithNoSearchParams.status !== EntryStatus.Fulfilled ||\n+    // There's no point constructing an optimistic route tree if the metadata\n+    // isn't fully available, because we'll have to do a blocking\n+    // navigation anyway.\n+    routeWithNoSearchParams.isHeadPartial ||\n+    // We cannot reuse this route if it has dynamic metadata.\n+    // TODO: Move the metadata out of the route cache entry so the route\n+    // tree is reusable separately from the metadata. Then we can remove\n+    // these checks.\n+    routeWithNoSearchParams.TODO_metadataStatus !== EntryStatus.Empty ||\n+    routeWithNoSearchParams.TODO_isHeadDynamic\n+  ) {\n+    // Bail out of constructing an optimistic route tree. This will result in\n+    // a blocking, unprefetched navigation.\n+    return null\n+  }\n+\n+  // Now we have a base route tree we can \"patch\" with our optimistic values.\n+\n+  // Optimistically assume that redirects for the requested pathname do\n+  // not vary on the search string. Therefore, if the base route was\n+  // redirected to a different search string, then the optimistic route\n+  // should be redirected to the same search string. Otherwise, we use\n+  // the requested search string.\n+  const canonicalUrlForRouteWithNoSearchParams = new URL(\n+    routeWithNoSearchParams.canonicalUrl,\n+    requestedUrl.origin\n+  )\n+  const optimisticCanonicalSearch =\n+    canonicalUrlForRouteWithNoSearchParams.search !== ''\n+      ? // Base route was redirected. Reuse the same redirected search string.\n+        canonicalUrlForRouteWithNoSearchParams.search\n+      : requestedSearch\n+\n+  // Similarly, optimistically assume that rewrites for the requested\n+  // pathname do not vary on the search string. Therefore, if the base\n+  // route was rewritten to a different search string, then the optimistic\n+  // route should be rewritten to the same search string. Otherwise, we use\n+  // the requested search string.\n+  const optimisticRenderedSearch =\n+    routeWithNoSearchParams.renderedSearch !== ''\n+      ? // Base route was rewritten. Reuse the same rewritten search string.\n+        routeWithNoSearchParams.renderedSearch\n+      : requestedSearch\n+\n+  const optimisticUrl = new URL(\n+    routeWithNoSearchParams.canonicalUrl,\n+    location.origin\n+  )\n+  optimisticUrl.search = optimisticCanonicalSearch\n+  const optimisticCanonicalUrl = createHrefFromUrl(optimisticUrl)\n+\n+  // Clone the base route tree, and override the relevant fields with our\n+  // optimistic values.\n+  const optimisticEntry: FulfilledRouteCacheEntry = {\n+    canonicalUrl: optimisticCanonicalUrl,\n+\n+    status: EntryStatus.Fulfilled,\n+    // This isn't cloned because it's instance-specific\n+    blockedTasks: null,\n+    tree: routeWithNoSearchParams.tree,\n+    head: routeWithNoSearchParams.head,\n+    isHeadPartial: routeWithNoSearchParams.isHeadPartial,\n+    staleAt: routeWithNoSearchParams.staleAt,\n+    couldBeIntercepted: routeWithNoSearchParams.couldBeIntercepted,\n+    isPPREnabled: routeWithNoSearchParams.isPPREnabled,\n+\n+    // Override the rendered search with the optimistic value.\n+    renderedSearch: optimisticRenderedSearch,\n+\n+    TODO_metadataStatus: routeWithNoSearchParams.TODO_metadataStatus,\n+    TODO_isHeadDynamic: routeWithNoSearchParams.TODO_isHeadDynamic,\n+\n+    // LRU-related fields\n+    keypath: null,\n+    next: null,\n+    prev: null,\n+    size: 0,\n+  }\n+\n+  // Do not insert this entry into the cache. It only exists so we can\n+  // perform the current navigation. Just return it to the caller.\n+  return optimisticEntry\n+}\n+\n /**\n  * Checks if an entry for a segment exists in the cache. If so, it returns the\n  * entry, If not, it adds an empty entry to the cache and returns it.\n@@ -833,7 +966,8 @@ function fulfillRouteCacheEntry(\n   couldBeIntercepted: boolean,\n   canonicalUrl: string,\n   renderedSearch: NormalizedSearch,\n-  isPPREnabled: boolean\n+  isPPREnabled: boolean,\n+  isHeadDynamic: boolean\n ): FulfilledRouteCacheEntry {\n   const fulfilledEntry: FulfilledRouteCacheEntry = entry as any\n   fulfilledEntry.status = EntryStatus.Fulfilled\n@@ -845,6 +979,7 @@ function fulfillRouteCacheEntry(\n   fulfilledEntry.canonicalUrl = canonicalUrl\n   fulfilledEntry.renderedSearch = renderedSearch\n   fulfilledEntry.isPPREnabled = isPPREnabled\n+  fulfilledEntry.TODO_isHeadDynamic = isHeadDynamic\n   pingBlockedTasks(entry)\n   return fulfilledEntry\n }\n@@ -1272,6 +1407,10 @@ export async function fetchRouteOnCacheMiss(\n       // because all data is static in this mode.\n       isOutputExportMode\n \n+    // Regardless of the type of response, we will never receive dynamic\n+    // metadata as part of this prefetch request.\n+    const isHeadDynamic = false\n+\n     if (routeIsPPREnabled) {\n       const prefetchStream = createPrefetchResponseStream(\n         response.body,\n@@ -1315,7 +1454,8 @@ export async function fetchRouteOnCacheMiss(\n         couldBeIntercepted,\n         canonicalUrl,\n         renderedSearch,\n-        routeIsPPREnabled\n+        routeIsPPREnabled,\n+        isHeadDynamic\n       )\n     } else {\n       // PPR is not enabled for this route. The server responds with a\n@@ -1681,6 +1821,10 @@ function writeDynamicTreeResponseIntoCache(\n   const isResponsePartial =\n     response.headers.get(NEXT_DID_POSTPONE_HEADER) === '1'\n \n+  // Since this is a dynamic response, we must conservatively assume that the\n+  // head responded with dynamic data.\n+  const isHeadDynamic = true\n+\n   const fulfilledEntry = fulfillRouteCacheEntry(\n     entry,\n     convertRootFlightRouterStateToRouteTree(flightRouterState),\n@@ -1690,7 +1834,8 @@ function writeDynamicTreeResponseIntoCache(\n     couldBeIntercepted,\n     canonicalUrl,\n     renderedSearch,\n-    routeIsPPREnabled\n+    routeIsPPREnabled,\n+    isHeadDynamic\n   )\n \n   // If the server sent segment data as part of the response, we should write\n@@ -1822,6 +1967,8 @@ function writeDynamicRenderResponseIntoCache(\n     // segment data may be reused from a previous request).\n     route.head = flightData.head\n     route.isHeadPartial = flightData.isHeadPartial\n+    route.TODO_isHeadDynamic = true\n+\n     // TODO: Currently the stale time of the route tree represents the\n     // stale time of both the route tree *and* all the segment data. So we\n     // can't just overwrite this field; we have to use whichever value is"
        },
        {
            "sha": "a10cbe2b9abbdbe456bf9b602599299e9764c389",
            "filename": "packages/next/src/client/components/segment-cache-impl/navigation.ts",
            "status": "modified",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/ea5b03bcda7b82f717401bedc43d9714c2bc436f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ea5b03bcda7b82f717401bedc43d9714c2bc436f/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts?ref=ea5b03bcda7b82f717401bedc43d9714c2bc436f",
            "patch": "@@ -21,6 +21,7 @@ import {\n   readRouteCacheEntry,\n   readSegmentCacheEntry,\n   waitForSegmentCacheEntry,\n+  requestOptimisticRouteCacheEntry,\n   type RouteTree,\n   type FulfilledRouteCacheEntry,\n } from './cache'\n@@ -136,6 +137,39 @@ export function navigate(\n       url.hash\n     )\n   }\n+\n+  // There was no matching route tree in the cache. Let's see if we can\n+  // construct an \"optimistic\" route tree.\n+  const optimisticRoute = requestOptimisticRouteCacheEntry(now, url, nextUrl)\n+  if (optimisticRoute !== null) {\n+    // We have an optimistic route tree. Proceed with the normal flow.\n+    const snapshot = readRenderSnapshotFromCache(\n+      now,\n+      optimisticRoute,\n+      optimisticRoute.tree\n+    )\n+    const prefetchFlightRouterState = snapshot.flightRouterState\n+    const prefetchSeedData = snapshot.seedData\n+    const prefetchHead = optimisticRoute.head\n+    const isPrefetchHeadPartial = optimisticRoute.isHeadPartial\n+    const newCanonicalUrl = optimisticRoute.canonicalUrl\n+    return navigateUsingPrefetchedRouteTree(\n+      now,\n+      url,\n+      nextUrl,\n+      isSamePageNavigation,\n+      currentCacheNode,\n+      currentFlightRouterState,\n+      prefetchFlightRouterState,\n+      prefetchSeedData,\n+      prefetchHead,\n+      isPrefetchHeadPartial,\n+      newCanonicalUrl,\n+      shouldScroll,\n+      url.hash\n+    )\n+  }\n+\n   // There's no matching prefetch for this route in the cache.\n   return {\n     tag: NavigationResultTag.Async,"
        },
        {
            "sha": "bfb0db12593d2651f11f84512ce626383faeeb23",
            "filename": "test/e2e/app-dir/segment-cache/search-params/app/search-params-shared-loading-state/page.tsx",
            "status": "added",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/ea5b03bcda7b82f717401bedc43d9714c2bc436f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params-shared-loading-state%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/ea5b03bcda7b82f717401bedc43d9714c2bc436f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params-shared-loading-state%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params-shared-loading-state%2Fpage.tsx?ref=ea5b03bcda7b82f717401bedc43d9714c2bc436f",
            "patch": "@@ -0,0 +1,25 @@\n+import { LinkAccordion } from '../../components/link-accordion'\n+\n+export default function SearchParamsSharedLoadingStatePage() {\n+  return (\n+    <div>\n+      <p>\n+        This page tests whether a prefetched URL without search params can share\n+        its loading state with a navigation to the same URL with search params.\n+      </p>\n+\n+      <ul>\n+        <li>\n+          <LinkAccordion href=\"/search-params-shared-loading-state/target-page\">\n+            Prefetch target (no search params)\n+          </LinkAccordion>\n+        </li>\n+        <li>\n+          <LinkAccordion href=\"/search-params-shared-loading-state/target-page?param=test\">\n+            Prefetch target (with search params)\n+          </LinkAccordion>\n+        </li>\n+      </ul>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "f0aaf6628db769c87fc823d5cd40de1983ff7bad",
            "filename": "test/e2e/app-dir/segment-cache/search-params/app/search-params-shared-loading-state/target-page/client.tsx",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/ea5b03bcda7b82f717401bedc43d9714c2bc436f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params-shared-loading-state%2Ftarget-page%2Fclient.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/ea5b03bcda7b82f717401bedc43d9714c2bc436f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params-shared-loading-state%2Ftarget-page%2Fclient.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params-shared-loading-state%2Ftarget-page%2Fclient.tsx?ref=ea5b03bcda7b82f717401bedc43d9714c2bc436f",
            "patch": "@@ -0,0 +1,11 @@\n+'use client'\n+import { useSearchParams } from 'next/navigation'\n+\n+export function SearchParamsDisplay() {\n+  const searchParams = useSearchParams()\n+  const param = searchParams.get('param')\n+\n+  return (\n+    <div id=\"search-params-content\">Search param value: {param || 'none'}</div>\n+  )\n+}"
        },
        {
            "sha": "fd7b684a4c33a794f88d37c83f6f728905ad6995",
            "filename": "test/e2e/app-dir/segment-cache/search-params/app/search-params-shared-loading-state/target-page/page.tsx",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/ea5b03bcda7b82f717401bedc43d9714c2bc436f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params-shared-loading-state%2Ftarget-page%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/ea5b03bcda7b82f717401bedc43d9714c2bc436f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params-shared-loading-state%2Ftarget-page%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params-shared-loading-state%2Ftarget-page%2Fpage.tsx?ref=ea5b03bcda7b82f717401bedc43d9714c2bc436f",
            "patch": "@@ -0,0 +1,18 @@\n+import { Suspense } from 'react'\n+import { SearchParamsDisplay } from './client'\n+\n+export default function TargetPage() {\n+  return (\n+    <div>\n+      <h1>Target Page</h1>\n+      <p id=\"static-content\">Static content</p>\n+      <Suspense\n+        fallback={\n+          <div id=\"search-params-loading\">Loading search params...</div>\n+        }\n+      >\n+        <SearchParamsDisplay />\n+      </Suspense>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "7dc3755af4ee2bbbfb8479f25e4fed46fbdee9aa",
            "filename": "test/e2e/app-dir/segment-cache/search-params/segment-cache-search-params-shared-loading-state.test.ts",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/vercel/next.js/blob/ea5b03bcda7b82f717401bedc43d9714c2bc436f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fsegment-cache-search-params-shared-loading-state.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ea5b03bcda7b82f717401bedc43d9714c2bc436f/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fsegment-cache-search-params-shared-loading-state.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fsegment-cache-search-params-shared-loading-state.test.ts?ref=ea5b03bcda7b82f717401bedc43d9714c2bc436f",
            "patch": "@@ -0,0 +1,80 @@\n+import { nextTestSetup } from 'e2e-utils'\n+import { createRouterAct } from '../router-act'\n+\n+describe('segment cache (search params shared loading state)', () => {\n+  const { next, isNextDev } = nextTestSetup({\n+    files: __dirname,\n+  })\n+  if (isNextDev) {\n+    test('prefetching is disabled', () => {})\n+    return\n+  }\n+\n+  it(\n+    \"if there's no matching prefetch entry for a page with particulular \" +\n+      'search params, optimistically reuse a prefetch entry with the same ' +\n+      'pathname and different search params',\n+    async () => {\n+      let act: ReturnType<typeof createRouterAct>\n+      const browser = await next.browser(\n+        '/search-params-shared-loading-state',\n+        {\n+          beforePageLoad(page) {\n+            act = createRouterAct(page)\n+          },\n+        }\n+      )\n+\n+      // Reveal and prefetch the link without search params\n+      const revealFirstLink = await browser.elementByCss(\n+        'input[data-link-accordion=\"/search-params-shared-loading-state/target-page\"]'\n+      )\n+      await act(\n+        async () => {\n+          await revealFirstLink.click()\n+        },\n+        {\n+          includes: 'Static content',\n+        }\n+      )\n+\n+      // Reveal the second link (with search params) but block its prefetch.\n+      await act(async () => {\n+        // Block any prefetch requests when revealing the second link. We're\n+        // going to test what happens if the navigation happens before the\n+        // prefetch is fulfilled.\n+        const revealSecondLink = await browser.elementByCss(\n+          'input[data-link-accordion=\"/search-params-shared-loading-state/target-page?param=test\"]'\n+        )\n+        await act(async () => {\n+          await revealSecondLink.click()\n+        }, 'block')\n+\n+        // Navigate to the target page.\n+        const link = await browser.elementByCss(\n+          'a[href=\"/search-params-shared-loading-state/target-page?param=test\"]'\n+        )\n+        await act(\n+          async () => {\n+            await link.click()\n+          },\n+          // This should not make any additional requests, because the target\n+          // page is fully static and there was already a cached prefetch to\n+          // the same pathname. Even though the search params are different,\n+          // we're able to reuse that response.\n+          'no-requests'\n+        )\n+\n+        // Verify the navigation completed successfully\n+        const staticContent = await browser.elementById('static-content')\n+        expect(await staticContent.text()).toBe('Static content')\n+        const searchParamsContent = await browser.elementById(\n+          'search-params-content'\n+        )\n+        expect(await searchParamsContent.text()).toBe(\n+          'Search param value: test'\n+        )\n+      }, 'no-requests')\n+    }\n+  )\n+})"
        }
    ],
    "stats": {
        "total": 321,
        "additions": 318,
        "deletions": 3
    }
}