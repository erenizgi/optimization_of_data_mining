{
    "author": "devjiwonchoi",
    "message": "docs: add missing links and imports to `cacheLife` and `cacheTag` for prerender-missing-suspense error (#79247)\n\nOne of the important resources for this message is `cacheLife` and\n`cacheTag`, but the links were missing, and the snippet omitted imports,\nwhich newcomers won't know how to import unless looking up.",
    "sha": "6258af666b1a979294ffb55bf67e8a168d3a92b5",
    "files": [
        {
            "sha": "7caf08779d17f3209a59aafd3ba95117b01bc359",
            "filename": "errors/next-prerender-missing-suspense.mdx",
            "status": "modified",
            "additions": 10,
            "deletions": 1,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/6258af666b1a979294ffb55bf67e8a168d3a92b5/errors%2Fnext-prerender-missing-suspense.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/6258af666b1a979294ffb55bf67e8a168d3a92b5/errors%2Fnext-prerender-missing-suspense.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fnext-prerender-missing-suspense.mdx?ref=6258af666b1a979294ffb55bf67e8a168d3a92b5",
            "patch": "@@ -34,6 +34,9 @@ export default async function Page() {\n After:\n \n ```jsx filename=\"app/page.js\"\n+import { unstable_cacheTag as cacheTag } from 'next/cache'\n+import { unstable_cacheLife as cacheLife } from 'next/cache'\n+\n async function getRecentArticles() {\n   \"use cache\"\n   // This cache can be revalidated by webhook or server action\n@@ -212,13 +215,15 @@ Alternatively you can add a Suspense boundary above the component that is access\n \n ### Short-lived Caches\n \n-`\"use cache\"` allows you to describe a `cacheLife()` that might be too short to be practical to prerender. The utility of doing this is that it can still describe a non-zero caching time for the client router cache to reuse the cache entry in the browser and it can also be useful for protecting upstream APIs while experiencing high request traffic.\n+`\"use cache\"` allows you to describe a [`cacheLife()`](/docs/app/api-reference/functions/cacheLife) that might be too short to be practical to prerender. The utility of doing this is that it can still describe a non-zero caching time for the client router cache to reuse the cache entry in the browser and it can also be useful for protecting upstream APIs while experiencing high request traffic.\n \n If you expected the `\"use cache\"` entry to be prerenderable try describing a slightly longer `cacheLife()`.\n \n Before:\n \n ```jsx filename=\"app/page.js\"\n+import { unstable_cacheLife as cacheLife } from 'next/cache'\n+\n async function getDashboard() {\n   \"use cache\"\n   // This cache will revalidate after 1 second. It is so short\n@@ -237,6 +242,8 @@ export default async function Page() {\n After:\n \n ```jsx filename=\"app/page.js\"\n+import { unstable_cacheLife as cacheLife } from 'next/cache'\n+\n async function getDashboard() {\n   \"use cache\"\n   // This cache will revalidate after 1 minute. It's long enough that\n@@ -260,3 +267,5 @@ Alternatively you can add a Suspense boundary above the component that is access\n - [`cookies` function](/docs/app/api-reference/functions/cookies)\n - [`draftMode` function](/docs/app/api-reference/functions/draft-mode)\n - [`connection` function](/docs/app/api-reference/functions/connection)\n+- [`cacheLife` function](/docs/app/api-reference/functions/cacheLife)\n+- [`cacheTag` function](/docs/app/api-reference/functions/cacheTag)"
        }
    ],
    "stats": {
        "total": 11,
        "additions": 10,
        "deletions": 1
    }
}