{
    "author": "mischnic",
    "message": "Skip filesystem-cache.test.ts test with Webpack (#86506)\n\nIt's very flakey with Webpack",
    "sha": "bd2c871eb5cfe86739a09b6856652d61c7cc4ff0",
    "files": [
        {
            "sha": "3c81a11d605e5ad9fef9918a78744d565fd7b80a",
            "filename": "test/e2e/filesystem-cache/filesystem-cache.test.ts",
            "status": "modified",
            "additions": 142,
            "deletions": 123,
            "changes": 265,
            "blob_url": "https://github.com/vercel/next.js/blob/bd2c871eb5cfe86739a09b6856652d61c7cc4ff0/test%2Fe2e%2Ffilesystem-cache%2Ffilesystem-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bd2c871eb5cfe86739a09b6856652d61c7cc4ff0/test%2Fe2e%2Ffilesystem-cache%2Ffilesystem-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Ffilesystem-cache%2Ffilesystem-cache.test.ts?ref=bd2c871eb5cfe86739a09b6856652d61c7cc4ff0",
            "patch": "@@ -1,21 +1,31 @@\n+/* eslint-disable jest/no-standalone-expect */\n import { nextTestSetup, isNextDev } from 'e2e-utils'\n import { waitFor } from 'next-test-utils'\n \n-process.env.NEXT_PUBLIC_ENV_VAR = 'hello world'\n-// Make it easier to run in development, test directories are cleared between runs already so this is safe.\n-process.env.TURBO_ENGINE_IGNORE_DIRTY = '1'\n-// decrease the idle timeout to make the test more reliable\n-process.env.TURBO_ENGINE_SNAPSHOT_IDLE_TIMEOUT_MILLIS = '1000'\n-\n for (const cacheEnabled of [false, true]) {\n   describe(`filesystem-caching with cache ${cacheEnabled ? 'enabled' : 'disabled'}`, () => {\n+    beforeAll(() => {\n+      process.env.NEXT_PUBLIC_ENV_VAR = 'hello world'\n+    })\n+    afterAll(() => {\n+      delete process.env.NEXT_PUBLIC_ENV_VAR\n+    })\n+\n+    let envVars = [\n+      `ENABLE_CACHING=${cacheEnabled ? '1' : ''}`,\n+      // Make it easier to run in development, test directories are cleared between runs already so this is safe.\n+      `TURBO_ENGINE_IGNORE_DIRTY=1`,\n+      // decrease the idle timeout to make the test more reliable\n+      `TURBO_ENGINE_SNAPSHOT_IDLE_TIMEOUT_MILLIS=1000`,\n+    ].join(' ')\n+\n     const { skipped, next, isTurbopack } = nextTestSetup({\n       files: __dirname,\n       skipDeployment: true,\n       packageJson: {\n         scripts: {\n-          build: `ENABLE_CACHING=${cacheEnabled ? '1' : ''} next build`,\n-          dev: `ENABLE_CACHING=${cacheEnabled ? '1' : ''} next dev`,\n+          build: `${envVars} next build`,\n+          dev: `${envVars} next dev`,\n           start: 'next start',\n         },\n       },\n@@ -56,79 +66,83 @@ for (const cacheEnabled of [false, true]) {\n       await next.start()\n     }\n \n-    it('should cache or not cache loaders', async () => {\n-      let appTimestamp, unchangedTimestamp, appClientTimestamp, pagesTimestamp\n-      {\n-        const browser = await next.browser('/')\n-        appTimestamp = await browser.elementByCss('main').text()\n-        expect(appTimestamp).toMatch(/Timestamp = \\d+$/)\n-        await browser.close()\n-      }\n-      {\n-        const browser = await next.browser('/unchanged')\n-        unchangedTimestamp = await browser.elementByCss('main').text()\n-        expect(unchangedTimestamp).toMatch(/Timestamp = \\d+$/)\n-        await browser.close()\n-      }\n-      {\n-        const browser = await next.browser('/client')\n-        appClientTimestamp = await browser.elementByCss('main').text()\n-        expect(appClientTimestamp).toMatch(/Timestamp = \\d+$/)\n-        await browser.close()\n-      }\n-      {\n-        const browser = await next.browser('/pages')\n-        pagesTimestamp = await browser.elementByCss('main').text()\n-        expect(pagesTimestamp).toMatch(/Timestamp = \\d+$/)\n-        await browser.close()\n-      }\n-      await restartCycle()\n+    // Very flakey with Webpack enabled\n+    ;(process.env.IS_TURBOPACK_TEST ? it : it.skip)(\n+      'should cache or not cache loaders',\n+      async () => {\n+        let appTimestamp, unchangedTimestamp, appClientTimestamp, pagesTimestamp\n+        {\n+          const browser = await next.browser('/')\n+          appTimestamp = await browser.elementByCss('main').text()\n+          expect(appTimestamp).toMatch(/Timestamp = \\d+$/)\n+          await browser.close()\n+        }\n+        {\n+          const browser = await next.browser('/unchanged')\n+          unchangedTimestamp = await browser.elementByCss('main').text()\n+          expect(unchangedTimestamp).toMatch(/Timestamp = \\d+$/)\n+          await browser.close()\n+        }\n+        {\n+          const browser = await next.browser('/client')\n+          appClientTimestamp = await browser.elementByCss('main').text()\n+          expect(appClientTimestamp).toMatch(/Timestamp = \\d+$/)\n+          await browser.close()\n+        }\n+        {\n+          const browser = await next.browser('/pages')\n+          pagesTimestamp = await browser.elementByCss('main').text()\n+          expect(pagesTimestamp).toMatch(/Timestamp = \\d+$/)\n+          await browser.close()\n+        }\n+        await restartCycle()\n \n-      {\n-        const browser = await next.browser('/')\n-        const newTimestamp = await browser.elementByCss('main').text()\n-        expect(newTimestamp).toMatch(/Timestamp = \\d+$/)\n-        if (cacheEnabled) {\n-          expect(newTimestamp).toBe(appTimestamp)\n-        } else {\n-          expect(newTimestamp).not.toBe(appTimestamp)\n+        {\n+          const browser = await next.browser('/')\n+          const newTimestamp = await browser.elementByCss('main').text()\n+          expect(newTimestamp).toMatch(/Timestamp = \\d+$/)\n+          if (cacheEnabled) {\n+            expect(newTimestamp).toBe(appTimestamp)\n+          } else {\n+            expect(newTimestamp).not.toBe(appTimestamp)\n+          }\n+          await browser.close()\n         }\n-        await browser.close()\n-      }\n-      {\n-        const browser = await next.browser('/unchanged')\n-        const newTimestamp = await browser.elementByCss('main').text()\n-        expect(newTimestamp).toMatch(/Timestamp = \\d+$/)\n-        if (cacheEnabled) {\n-          expect(newTimestamp).toBe(unchangedTimestamp)\n-        } else {\n-          expect(newTimestamp).not.toBe(unchangedTimestamp)\n+        {\n+          const browser = await next.browser('/unchanged')\n+          const newTimestamp = await browser.elementByCss('main').text()\n+          expect(newTimestamp).toMatch(/Timestamp = \\d+$/)\n+          if (cacheEnabled) {\n+            expect(newTimestamp).toBe(unchangedTimestamp)\n+          } else {\n+            expect(newTimestamp).not.toBe(unchangedTimestamp)\n+          }\n+          await browser.close()\n         }\n-        await browser.close()\n-      }\n-      {\n-        const browser = await next.browser('/client')\n-        const newTimestamp = await browser.elementByCss('main').text()\n-        expect(newTimestamp).toMatch(/Timestamp = \\d+$/)\n-        if (cacheEnabled) {\n-          expect(newTimestamp).toBe(appClientTimestamp)\n-        } else {\n-          expect(newTimestamp).not.toBe(appClientTimestamp)\n+        {\n+          const browser = await next.browser('/client')\n+          const newTimestamp = await browser.elementByCss('main').text()\n+          expect(newTimestamp).toMatch(/Timestamp = \\d+$/)\n+          if (cacheEnabled) {\n+            expect(newTimestamp).toBe(appClientTimestamp)\n+          } else {\n+            expect(newTimestamp).not.toBe(appClientTimestamp)\n+          }\n+          await browser.close()\n         }\n-        await browser.close()\n-      }\n-      {\n-        const browser = await next.browser('/pages')\n-        const newTimestamp = await browser.elementByCss('main').text()\n-        expect(newTimestamp).toMatch(/Timestamp = \\d+$/)\n-        if (cacheEnabled) {\n-          expect(newTimestamp).toBe(pagesTimestamp)\n-        } else {\n-          expect(newTimestamp).not.toBe(pagesTimestamp)\n+        {\n+          const browser = await next.browser('/pages')\n+          const newTimestamp = await browser.elementByCss('main').text()\n+          expect(newTimestamp).toMatch(/Timestamp = \\d+$/)\n+          if (cacheEnabled) {\n+            expect(newTimestamp).toBe(pagesTimestamp)\n+          } else {\n+            expect(newTimestamp).not.toBe(pagesTimestamp)\n+          }\n+          await browser.close()\n         }\n-        await browser.close()\n       }\n-    })\n+    )\n \n     function makeTextCheck(url: string, text: string) {\n       return textCheck.bind(null, url, text)\n@@ -246,68 +260,73 @@ for (const cacheEnabled of [false, true]) {\n     ])\n \n     for (const [name, changes] of combinations) {\n-      it(`should allow to change files while stopped (${name})`, async () => {\n-        let fullInvalidation = !cacheEnabled\n-        for (const change of changes) {\n-          await change.checkInitial()\n-          if (change.fullInvalidation) {\n-            fullInvalidation = true\n-          }\n-        }\n-\n-        let unchangedTimestamp: string\n-        if (!fullInvalidation) {\n-          const browser = await next.browser('/unchanged')\n-          unchangedTimestamp = await browser.elementByCss('main').text()\n-          expect(unchangedTimestamp).toMatch(/Timestamp = \\d+$/)\n-          await browser.close()\n-        }\n-\n-        async function checkChanged() {\n+      // Very flakey with Webpack enabled\n+      ;(process.env.IS_TURBOPACK_TEST ? it : it.skip)(\n+        `should allow to change files while stopped (${name})`,\n+        async () => {\n+          let fullInvalidation = !cacheEnabled\n           for (const change of changes) {\n-            await change.checkChanged()\n+            await change.checkInitial()\n+            if (change.fullInvalidation) {\n+              fullInvalidation = true\n+            }\n           }\n \n+          let unchangedTimestamp: string\n           if (!fullInvalidation) {\n             const browser = await next.browser('/unchanged')\n-            const timestamp = await browser.elementByCss('main').text()\n-            expect(unchangedTimestamp).toEqual(timestamp)\n+            unchangedTimestamp = await browser.elementByCss('main').text()\n+            expect(unchangedTimestamp).toMatch(/Timestamp = \\d+$/)\n             await browser.close()\n           }\n-        }\n \n-        await stop()\n+          async function checkChanged() {\n+            for (const change of changes) {\n+              await change.checkChanged()\n+            }\n \n-        async function inner() {\n-          await start()\n-          await checkChanged()\n-          // Some no-op change builds\n-          for (let i = 0; i < 2; i++) {\n-            await restartCycle()\n-            await checkChanged()\n+            if (!fullInvalidation) {\n+              const browser = await next.browser('/unchanged')\n+              const timestamp = await browser.elementByCss('main').text()\n+              expect(unchangedTimestamp).toEqual(timestamp)\n+              await browser.close()\n+            }\n           }\n+\n           await stop()\n-        }\n \n-        let current = inner\n-        for (const change of changes) {\n-          const prev = current\n-          current = () => change.withChange(prev)\n-        }\n-        await current()\n+          async function inner() {\n+            await start()\n+            await checkChanged()\n+            // Some no-op change builds\n+            for (let i = 0; i < 2; i++) {\n+              await restartCycle()\n+              await checkChanged()\n+            }\n+            await stop()\n+          }\n \n-        await start()\n-        for (const change of changes) {\n-          await change.checkInitial()\n-        }\n+          let current = inner\n+          for (const change of changes) {\n+            const prev = current\n+            current = () => change.withChange(prev)\n+          }\n+          await current()\n \n-        if (!fullInvalidation) {\n-          const browser = await next.browser('/unchanged')\n-          const timestamp = await browser.elementByCss('main').text()\n-          expect(unchangedTimestamp).toEqual(timestamp)\n-          await browser.close()\n-        }\n-      }, 200000)\n+          await start()\n+          for (const change of changes) {\n+            await change.checkInitial()\n+          }\n+\n+          if (!fullInvalidation) {\n+            const browser = await next.browser('/unchanged')\n+            const timestamp = await browser.elementByCss('main').text()\n+            expect(unchangedTimestamp).toEqual(timestamp)\n+            await browser.close()\n+          }\n+        },\n+        200000\n+      )\n     }\n   })\n }"
        }
    ],
    "stats": {
        "total": 265,
        "additions": 142,
        "deletions": 123
    }
}