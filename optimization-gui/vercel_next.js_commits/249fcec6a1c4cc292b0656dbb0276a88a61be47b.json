{
    "author": "bgw",
    "message": "Turbopack: chore: Avoid string clones in Glob::parse by using RcStr (#85579)\n\n`Glob::parse` is mostly called by the `Glob::new` turbo-task function which has an `RcStr`, so let's just use that instead of doing `RcStr` -> `&str` -> `String`.",
    "sha": "249fcec6a1c4cc292b0656dbb0276a88a61be47b",
    "files": [
        {
            "sha": "8cc3a16077c2398ecb8b9a59ed91bd7ab71a3430",
            "filename": "turbopack/crates/turbo-tasks-fs/src/glob.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 23,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/249fcec6a1c4cc292b0656dbb0276a88a61be47b/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/249fcec6a1c4cc292b0656dbb0276a88a61be47b/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fglob.rs?ref=249fcec6a1c4cc292b0656dbb0276a88a61be47b",
            "patch": "@@ -24,19 +24,21 @@ use crate::globset::parse;\n #[derive(Debug, Clone)]\n #[serde(into = \"GlobForm\", try_from = \"GlobForm\")]\n pub struct Glob {\n-    glob: String,\n+    glob: RcStr,\n     #[turbo_tasks(trace_ignore)]\n     opts: GlobOptions,\n     #[turbo_tasks(trace_ignore)]\n     regex: Regex,\n     #[turbo_tasks(trace_ignore)]\n     directory_match_regex: Regex,\n }\n+\n impl PartialEq for Glob {\n     fn eq(&self, other: &Self) -> bool {\n         self.glob == other.glob\n     }\n }\n+\n impl Eq for Glob {}\n \n impl Display for Glob {\n@@ -47,6 +49,7 @@ impl Display for Glob {\n #[derive(\n     Serialize, Deserialize, Copy, Clone, PartialEq, Eq, Hash, Default, TaskInput, TraceRawVcs, Debug,\n )]\n+\n pub struct GlobOptions {\n     /// Whether the glob is a partial match.\n     /// Allows glob to match any part of the given string(s).\n@@ -58,9 +61,10 @@ pub struct GlobOptions {\n \n #[derive(Serialize, Deserialize)]\n struct GlobForm {\n-    glob: String,\n+    glob: RcStr,\n     opts: GlobOptions,\n }\n+\n impl From<Glob> for GlobForm {\n     fn from(value: Glob) -> Self {\n         Self {\n@@ -69,10 +73,11 @@ impl From<Glob> for GlobForm {\n         }\n     }\n }\n+\n impl TryFrom<GlobForm> for Glob {\n     type Error = anyhow::Error;\n     fn try_from(value: GlobForm) -> Result<Self, Self::Error> {\n-        Glob::parse(&value.glob, value.opts)\n+        Glob::parse(value.glob, value.opts)\n     }\n }\n \n@@ -92,33 +97,25 @@ impl Glob {\n         self.directory_match_regex.is_match(path.as_bytes())\n     }\n \n-    pub fn parse(input: &str, opts: GlobOptions) -> Result<Glob> {\n-        let (glob_re, directory_match_re) = parse(input, opts)?;\n+    pub fn parse(input: RcStr, opts: GlobOptions) -> Result<Glob> {\n+        let (glob_re, directory_match_re) = parse(&input, opts)?;\n         let regex = new_regex(glob_re.as_str());\n         let directory_match_regex = new_regex(directory_match_re.as_str());\n \n         Ok(Glob {\n-            glob: input.to_string(),\n+            glob: input,\n             opts,\n             regex,\n             directory_match_regex,\n         })\n     }\n }\n \n-impl TryFrom<&str> for Glob {\n-    type Error = anyhow::Error;\n-\n-    fn try_from(value: &str) -> Result<Self, Self::Error> {\n-        Glob::parse(value, GlobOptions::default())\n-    }\n-}\n-\n #[turbo_tasks::value_impl]\n impl Glob {\n     #[turbo_tasks::function]\n     pub fn new(glob: RcStr, opts: GlobOptions) -> Result<Vc<Self>> {\n-        Ok(Self::cell(Glob::parse(glob.as_str(), opts)?))\n+        Ok(Self::cell(Glob::parse(glob, opts)?))\n     }\n \n     #[turbo_tasks::function]\n@@ -166,8 +163,7 @@ fn new_regex(pattern: &str) -> Regex {\n mod tests {\n     use rstest::*;\n \n-    use super::Glob;\n-    use crate::glob::GlobOptions;\n+    use super::*;\n \n     #[rstest]\n     #[case::file(\"file.js\", \"file.js\")]\n@@ -238,7 +234,7 @@ mod tests {\n     #[case::alternatives_empty2(\"react{,-dom}\", \"react-dom\")]\n     #[case::alternatives_chars(\"[abc]\", \"b\")]\n     fn glob_match(#[case] glob: &str, #[case] path: &str) {\n-        let glob = Glob::parse(glob, GlobOptions::default()).unwrap();\n+        let glob = Glob::parse(RcStr::from(glob), GlobOptions::default()).unwrap();\n \n         println!(\"{glob:?} {path}\");\n \n@@ -253,7 +249,7 @@ mod tests {\n     )]\n     #[case::star(\"*\", \"/foo\")]\n     fn glob_not_matching(#[case] glob: &str, #[case] path: &str) {\n-        let glob = Glob::parse(glob, GlobOptions::default()).unwrap();\n+        let glob = Glob::parse(RcStr::from(glob), GlobOptions::default()).unwrap();\n \n         println!(\"{glob:?} {path}\");\n \n@@ -272,7 +268,7 @@ mod tests {\n     #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir/a/b/sub\")]\n     #[case::globstar_in_dir_partial(\"dir/**/sub/file.js\", \"dir/a/b/sub/file.js\")]\n     fn glob_can_match_directory(#[case] glob: &str, #[case] path: &str) {\n-        let glob = Glob::parse(glob, GlobOptions::default()).unwrap();\n+        let glob = Glob::parse(RcStr::from(glob), GlobOptions::default()).unwrap();\n \n         println!(\"{glob:?} {path}\");\n \n@@ -282,7 +278,7 @@ mod tests {\n     #[case::dir_and_file_partial(\"dir/file.js\", \"dir/file.js\")] // even if there was a dir, named `file.js` we know the glob wasn't intended to match it.\n     #[case::alternatives_chars(\"[abc]\", \"b\")]\n     fn glob_not_can_match_directory(#[case] glob: &str, #[case] path: &str) {\n-        let glob = Glob::parse(glob, GlobOptions::default()).unwrap();\n+        let glob = Glob::parse(RcStr::from(glob), GlobOptions::default()).unwrap();\n \n         println!(\"{glob:?} {path}\");\n \n@@ -297,7 +293,7 @@ mod tests {\n     // This is a possibly surprising case.\n     #[case::dir_match(\"node_modules/foo\", \"my_node_modules/foobar\")]\n     fn partial_glob_match(#[case] glob: &str, #[case] path: &str) {\n-        let glob = Glob::parse(glob, GlobOptions { contains: true }).unwrap();\n+        let glob = Glob::parse(RcStr::from(glob), GlobOptions { contains: true }).unwrap();\n \n         println!(\"{glob:?} {path}\");\n \n@@ -311,7 +307,7 @@ mod tests {\n     // This is a possibly surprising case\n     #[case::dir_match(\"/node_modules/\", \"node_modules/\")]\n     fn partial_glob_not_matching(#[case] glob: &str, #[case] path: &str) {\n-        let glob = Glob::parse(glob, GlobOptions { contains: true }).unwrap();\n+        let glob = Glob::parse(RcStr::from(glob), GlobOptions { contains: true }).unwrap();\n \n         println!(\"{glob:?} {path}\");\n "
        }
    ],
    "stats": {
        "total": 42,
        "additions": 19,
        "deletions": 23
    }
}