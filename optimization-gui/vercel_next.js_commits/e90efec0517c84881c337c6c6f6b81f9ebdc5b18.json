{
    "author": "ijjk",
    "message": "Add additional handling for build-complete (#82671)\n\nThis continues the `build-complete` handling for the adapters config\nadding additional prerender logic including PPR fields and expanding\ntest coverage ensuring correct outputs.",
    "sha": "e90efec0517c84881c337c6c6f6b81f9ebdc5b18",
    "files": [
        {
            "sha": "d36db27599957e07cc47c4aceb392712480a23ab",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=e90efec0517c84881c337c6c6f6b81f9ebdc5b18",
            "patch": "@@ -777,5 +777,6 @@\n   \"776\": \"`unstable_isUnrecognizedActionError` can only be used on the client.\",\n   \"777\": \"Invariant: failed to find source route %s for prerender %s\",\n   \"778\": \"`prerenderAndAbortInSequentialTasksWithStages` should not be called in edge runtime.\",\n-  \"779\": \"Route %s used \\\"searchParams\\\" inside \\\"use cache\\\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\\"searchParams\\\" outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\"\n+  \"779\": \"Route %s used \\\"searchParams\\\" inside \\\"use cache\\\". Accessing dynamic request data inside a cache scope is not supported. If you need some search params inside a cached function await \\\"searchParams\\\" outside of the cached function and pass only the required search params as arguments to the cached function. See more info here: https://nextjs.org/docs/messages/next-request-in-use-cache\",\n+  \"780\": \"Invariant: failed to find parent dynamic route for notFound route %s\"\n }"
        },
        {
            "sha": "8c0ab1103068c0c21c5447dbccb9c133448674bf",
            "filename": "packages/next/src/build/adapter/build-complete.ts",
            "status": "modified",
            "additions": 178,
            "deletions": 59,
            "changes": 237,
            "blob_url": "https://github.com/vercel/next.js/blob/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fadapter%2Fbuild-complete.ts?ref=e90efec0517c84881c337c6c6f6b81f9ebdc5b18",
            "patch": "@@ -20,6 +20,7 @@ import { normalizePagePath } from '../../shared/lib/page-path/normalize-page-pat\n import { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\n import { AdapterOutputType } from '../../shared/lib/constants'\n import { RenderingMode } from '../rendering-mode'\n+import { isDynamicRoute } from '../../shared/lib/router/utils'\n \n const glob = promisify(globOriginal)\n \n@@ -37,6 +38,7 @@ export async function handleBuildComplete({\n   prerenderManifest,\n   middlewareManifest,\n   functionsConfigManifest,\n+  hasStatic404,\n }: {\n   dir: string\n   distDir: string\n@@ -51,6 +53,7 @@ export async function handleBuildComplete({\n   prerenderManifest: PrerenderManifest\n   middlewareManifest: MiddlewareManifest\n   functionsConfigManifest: FunctionsConfigManifest\n+  hasStatic404: boolean\n }) {\n   const adapterMod = interopDefault(\n     await import(pathToFileURL(require.resolve(adapterPath)).href)\n@@ -196,6 +199,7 @@ export async function handleBuildComplete({\n       for (const page of Object.values(middlewareManifest.functions)) {\n         edgeFunctionHandlers.push(handleEdgeFunction(page))\n       }\n+      const pagesDistDir = path.join(distDir, 'server', 'pages')\n       const pageOutputMap: Record<string, AdapterOutputs[0]> = {}\n \n       for (const page of pageKeys) {\n@@ -205,9 +209,7 @@ export async function handleBuildComplete({\n         const route = normalizePagePath(page)\n \n         const pageFile = path.join(\n-          distDir,\n-          'server',\n-          'pages',\n+          pagesDistDir,\n           `${normalizePagePath(page)}.js`\n         )\n         const pageTraceFile = `${pageFile}.nft.json`\n@@ -257,14 +259,15 @@ export async function handleBuildComplete({\n         })\n       }\n       const appOutputMap: Record<string, AdapterOutputs[0]> = {}\n+      const appDistDir = path.join(distDir, 'server', 'app')\n \n       if (appPageKeys) {\n         for (const page of appPageKeys) {\n           if (middlewareManifest.functions.hasOwnProperty(page)) {\n             continue\n           }\n           const normalizedPage = normalizeAppPath(page)\n-          const pageFile = path.join(distDir, 'server', 'app', `${page}.js`)\n+          const pageFile = path.join(appDistDir, `${page}.js`)\n           const pageTraceFile = `${pageFile}.nft.json`\n           const assets = await handleTraceFiles(pageTraceFile).catch((err) => {\n             Log.warn(`Failed to copy traced files for ${pageFile}`, err)\n@@ -292,10 +295,14 @@ export async function handleBuildComplete({\n         }\n       }\n \n-      const getParentOutput = (srcRoute: string, childRoute: string) => {\n+      const getParentOutput = (\n+        srcRoute: string,\n+        childRoute: string,\n+        allowMissing?: boolean\n+      ) => {\n         const parentOutput = pageOutputMap[srcRoute] || appOutputMap[srcRoute]\n \n-        if (!parentOutput) {\n+        if (!parentOutput && !allowMissing) {\n           console.error({\n             appOutputs: Object.keys(appOutputMap),\n             pageOutputs: Object.keys(pageOutputMap),\n@@ -307,6 +314,77 @@ export async function handleBuildComplete({\n         return parentOutput\n       }\n \n+      const {\n+        prefetchSegmentDirSuffix,\n+        prefetchSegmentSuffix,\n+        varyHeader,\n+        didPostponeHeader,\n+        contentTypeHeader,\n+      } = routesManifest.rsc\n+\n+      const handleAppMeta = async (\n+        route: string,\n+        initialOutput: AdapterOutputs[0]\n+      ) => {\n+        const meta: {\n+          segmentPaths?: string[]\n+          postponed?: string\n+        } = JSON.parse(\n+          await fs\n+            .readFile(path.join(appDistDir, `${route}.meta`), 'utf8')\n+            .catch(() => '{}')\n+        )\n+\n+        if (meta.postponed && initialOutput.config) {\n+          initialOutput.config.postponed = meta.postponed\n+        }\n+\n+        if (meta?.segmentPaths) {\n+          const segmentsDir = path.join(\n+            appDistDir,\n+            `${route}${prefetchSegmentDirSuffix}`\n+          )\n+\n+          for (const segmentPath of meta.segmentPaths) {\n+            const outputSegmentPath =\n+              path.join(\n+                appDistDir,\n+                route + prefetchSegmentDirSuffix,\n+                segmentPath\n+              ) + prefetchSegmentSuffix\n+\n+            const fallbackPathname = path.join(\n+              segmentsDir,\n+              segmentPath + prefetchSegmentSuffix\n+            )\n+\n+            outputs.push({\n+              id: outputSegmentPath,\n+              pathname: outputSegmentPath,\n+              type: AdapterOutputType.PRERENDER,\n+              parentOutputId: initialOutput.parentOutputId,\n+\n+              config: {\n+                ...initialOutput.config,\n+              },\n+\n+              fallback: {\n+                filePath: fallbackPathname,\n+                initialExpiration: initialOutput.fallback?.initialExpiration,\n+                initialRevalidate: initialOutput.fallback?.initialRevalidate,\n+\n+                initialHeaders: {\n+                  ...initialOutput.fallback?.initialHeaders,\n+                  vary: varyHeader,\n+                  'content-type': contentTypeHeader,\n+                  [didPostponeHeader]: '2',\n+                },\n+              },\n+            })\n+          }\n+        }\n+      }\n+\n       for (const route in prerenderManifest.routes) {\n         const {\n           initialExpireSeconds: initialExpiration,\n@@ -316,42 +394,79 @@ export async function handleBuildComplete({\n           prefetchDataRoute,\n           dataRoute,\n           renderingMode,\n+          allowHeader,\n+          experimentalBypassFor,\n         } = prerenderManifest.routes[route]\n \n         const srcRoute = prerenderManifest.routes[route].srcRoute || route\n-        const isAppPage = dataRoute?.endsWith('.rsc')\n+        const isAppPage =\n+          Boolean(appOutputMap[srcRoute]) || srcRoute === '/_not-found'\n+\n+        const isNotFoundTrue = prerenderManifest.notFoundRoutes.includes(route)\n+\n+        let allowQuery: string[] | undefined\n+        const routeKeys = routesManifest.dynamicRoutes.find(\n+          (item) => item.page === srcRoute\n+        )?.routeKeys\n+\n+        if (!isDynamicRoute(srcRoute)) {\n+          // for non-dynamic routes we use an empty array since\n+          // no query values bust the cache for non-dynamic prerenders\n+          // prerendered paths also do not pass allowQuery as they match\n+          // during handle: 'filesystem' so should not cache differently\n+          // by query values\n+          allowQuery = []\n+        } else if (routeKeys) {\n+          // if we have routeKeys in the routes-manifest we use those\n+          // for allowQuery for dynamic routes\n+          allowQuery = Object.values(routeKeys)\n+        }\n \n-        const filePath = path.join(\n-          distDir,\n-          'server',\n-          isAppPage ? 'app' : 'pages',\n-          `${route}.html`\n+        let filePath = path.join(\n+          isAppPage ? appDistDir : pagesDistDir,\n+          `${route}.${isAppPage && !dataRoute ? 'body' : 'html'}`\n         )\n-        const initialOutput = {\n+\n+        // we use the static 404 for notFound: true if available\n+        // if not we do a blocking invoke on first request\n+        if (isNotFoundTrue && hasStatic404) {\n+          filePath = path.join(pagesDistDir, '404.html')\n+        }\n+\n+        const initialOutput: AdapterOutputs[0] = {\n           id: route,\n           type: AdapterOutputType.PRERENDER,\n           pathname: route,\n-          parentOutputId: getParentOutput(srcRoute, route).id,\n-          fallback: {\n-            filePath,\n-            initialStatus,\n-            initialHeaders,\n-            initialExpiration,\n-            initialRevalidate,\n-          },\n+          parentOutputId:\n+            srcRoute === '/_not-found'\n+              ? srcRoute\n+              : getParentOutput(srcRoute, route).id,\n+          fallback:\n+            !isNotFoundTrue || (isNotFoundTrue && hasStatic404)\n+              ? {\n+                  filePath,\n+                  initialStatus,\n+                  initialHeaders: {\n+                    ...initialHeaders,\n+                    vary: varyHeader,\n+                    'content-type': contentTypeHeader,\n+                  },\n+                  initialExpiration,\n+                  initialRevalidate: initialRevalidate || 1,\n+                }\n+              : undefined,\n           config: {\n+            allowQuery,\n+            allowHeader,\n             renderingMode,\n+            bypassFor: experimentalBypassFor,\n+            bypassToken: prerenderManifest.preview.previewModeId,\n           },\n         }\n         outputs.push(initialOutput)\n \n         if (dataRoute) {\n-          let dataFilePath = path.join(\n-            distDir,\n-            'server',\n-            'pages',\n-            `${route}.json`\n-          )\n+          let dataFilePath = path.join(pagesDistDir, `${route}.json`)\n \n           if (isAppPage) {\n             // When experimental PPR is enabled, we expect that the data\n@@ -360,9 +475,7 @@ export async function handleBuildComplete({\n             // for ppr, the only way to get the data is from the data\n             // route.\n             dataFilePath = path.join(\n-              distDir,\n-              'server',\n-              'app',\n+              appDistDir,\n               prefetchDataRoute &&\n                 renderingMode === RenderingMode.PARTIALLY_STATIC\n                 ? prefetchDataRoute\n@@ -374,12 +487,18 @@ export async function handleBuildComplete({\n             ...initialOutput,\n             id: dataRoute,\n             pathname: dataRoute,\n-            fallback: {\n-              ...initialOutput.fallback,\n-              filePath: dataFilePath,\n-            },\n+            fallback: isNotFoundTrue\n+              ? undefined\n+              : {\n+                  ...initialOutput.fallback,\n+                  filePath: dataFilePath,\n+                },\n           })\n         }\n+\n+        if (isAppPage) {\n+          await handleAppMeta(route, initialOutput)\n+        }\n       }\n \n       for (const dynamicRoute in prerenderManifest.dynamicRoutes) {\n@@ -389,62 +508,62 @@ export async function handleBuildComplete({\n           fallbackRevalidate,\n           fallbackHeaders,\n           fallbackStatus,\n+          allowHeader,\n           dataRoute,\n+          renderingMode,\n+          experimentalBypassFor,\n         } = prerenderManifest.dynamicRoutes[dynamicRoute]\n \n-        const isAppPage = dataRoute?.endsWith('.rsc')\n+        const isAppPage = Boolean(appOutputMap[dynamicRoute])\n \n-        const initialOutput = {\n+        const allowQuery = Object.values(\n+          routesManifest.dynamicRoutes.find(\n+            (item) => item.page === dynamicRoute\n+          )?.routeKeys || {}\n+        )\n+\n+        const initialOutput: AdapterOutputs[0] = {\n           id: dynamicRoute,\n           type: AdapterOutputType.PRERENDER,\n           pathname: dynamicRoute,\n           parentOutputId: getParentOutput(dynamicRoute, dynamicRoute).id,\n+          config: {\n+            allowQuery,\n+            allowHeader,\n+            renderingMode,\n+            bypassFor: experimentalBypassFor,\n+            bypassToken: prerenderManifest.preview.previewModeId,\n+          },\n           fallback:\n             typeof fallback === 'string'\n               ? {\n                   filePath: path.join(\n-                    distDir,\n-                    'server',\n-                    isAppPage ? 'app' : 'pages',\n+                    isAppPage ? appDistDir : pagesDistDir,\n                     fallback\n                   ),\n                   initialStatus: fallbackStatus,\n                   initialHeaders: fallbackHeaders,\n                   initialExpiration: fallbackExpire,\n-                  initialRevalidate: fallbackRevalidate,\n+                  initialRevalidate: fallbackRevalidate || 1,\n                 }\n               : undefined,\n         }\n         outputs.push(initialOutput)\n \n+        if (isAppPage) {\n+          await handleAppMeta(dynamicRoute, initialOutput)\n+        }\n+\n         if (dataRoute) {\n           outputs.push({\n             ...initialOutput,\n             id: dataRoute,\n             pathname: dataRoute,\n+            fallback: undefined,\n           })\n         }\n       }\n \n-      // TODO: should these be normal outputs or meta on associated routes?\n-      // for (const route of prerenderManifest.notFoundRoutes) {\n-      //   // The fallback here is the 404 page if statically generated\n-      //   // if it is not then the fallback is empty and it is generated\n-      //   // at runtime\n-\n-      //   outputs.push({\n-      //     id: route,\n-      //     type: OutputType.PRERENDER,\n-      //     pathname: route,\n-      //     runtime: 'nodejs',\n-      //     fallback: {\n-      //       filePath: '',\n-      //       initialStatus: 404,\n-      //       initialHeaders: {},\n-      //     },\n-      //   })\n-      // }\n-\n       await adapterMod.onBuildComplete({\n         routes: {\n           dynamicRoutes: routesManifest.dynamicRoutes,"
        },
        {
            "sha": "fb819845a2a2346d1d60eaad31cbb5d435d22fa9",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=e90efec0517c84881c337c6c6f6b81f9ebdc5b18",
            "patch": "@@ -3955,6 +3955,7 @@ export default async function build(\n           prerenderManifest,\n           middlewareManifest,\n           functionsConfigManifest,\n+          hasStatic404: useStaticPages404,\n           requiredServerFiles: requiredServerFilesManifest.files,\n         })\n       }"
        },
        {
            "sha": "ec40b8b19ab6779b79d2f92cd10ba418e37367b9",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=e90efec0517c84881c337c6c6f6b81f9ebdc5b18",
            "patch": "@@ -98,6 +98,17 @@ export type AdapterOutputs = Array<{\n      * matchers are the configured matchers for middleware\n      */\n     matchers?: MiddlewareMatcher[]\n+\n+    /**\n+     * bypassToken is the generated token that signals a prerender cache\n+     * should be bypassed\n+     */\n+    bypassToken?: string\n+\n+    /**\n+     * postponed is the PPR state when it postponed and is used for resuming\n+     */\n+    postponed?: string\n   }\n   /**\n    * For prerenders the parent output is the originating"
        },
        {
            "sha": "06d6b87e7e361ea6411426bf7ed503e99e62cfa2",
            "filename": "test/production/adapter-config/adapter-config.test.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/test%2Fproduction%2Fadapter-config%2Fadapter-config.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/test%2Fproduction%2Fadapter-config%2Fadapter-config.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fadapter-config%2Fadapter-config.test.ts?ref=e90efec0517c84881c337c6c6f6b81f9ebdc5b18",
            "patch": "@@ -87,6 +87,25 @@ describe('adapter-config', () => {\n       expect(fs.existsSync(output.filePath)).toBe(true)\n     }\n \n+    for (const prerenderOutput of prerenderOutputs) {\n+      try {\n+        expect(prerenderOutput.parentOutputId).toBeTruthy()\n+        if (prerenderOutput.fallback) {\n+          expect(await fs.existsSync(prerenderOutput.fallback.filePath)).toBe(\n+            true\n+          )\n+          expect(prerenderOutput.fallback.initialRevalidate).toBeDefined()\n+        }\n+\n+        expect(typeof prerenderOutput.config.bypassToken).toBe('string')\n+        expect(Array.isArray(prerenderOutput.config.allowHeader)).toBe(true)\n+        expect(Array.isArray(prerenderOutput.config.allowQuery)).toBe(true)\n+      } catch (err) {\n+        require('console').error(`invalid prerender ${prerenderOutput.id}`, err)\n+        throw err\n+      }\n+    }\n+\n     expect(buildContext.routes).toEqual({\n       dynamicRoutes: expect.toBeArray(),\n       rewrites: expect.toBeObject(),"
        },
        {
            "sha": "147c9b3e60bf4836fb7b0d3543d6943ddb2ee7f6",
            "filename": "test/production/adapter-config/pages/isr-pages-fallback-true/[slug]/index.tsx",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/test%2Fproduction%2Fadapter-config%2Fpages%2Fisr-pages-fallback-true%2F%5Bslug%5D%2Findex.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/test%2Fproduction%2Fadapter-config%2Fpages%2Fisr-pages-fallback-true%2F%5Bslug%5D%2Findex.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fadapter-config%2Fpages%2Fisr-pages-fallback-true%2F%5Bslug%5D%2Findex.tsx?ref=e90efec0517c84881c337c6c6f6b81f9ebdc5b18",
            "patch": "@@ -7,6 +7,9 @@ export function getStaticPaths() {\n       {\n         params: { slug: 'second' },\n       },\n+      {\n+        params: { slug: 'not-found' },\n+      },\n     ],\n     fallback: true,\n   }"
        },
        {
            "sha": "026449286c30cbd131179b0a786d2f9010cd796d",
            "filename": "test/production/adapter-config/pages/isr-pages/[slug]/index.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/test%2Fproduction%2Fadapter-config%2Fpages%2Fisr-pages%2F%5Bslug%5D%2Findex.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/e90efec0517c84881c337c6c6f6b81f9ebdc5b18/test%2Fproduction%2Fadapter-config%2Fpages%2Fisr-pages%2F%5Bslug%5D%2Findex.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fadapter-config%2Fpages%2Fisr-pages%2F%5Bslug%5D%2Findex.tsx?ref=e90efec0517c84881c337c6c6f6b81f9ebdc5b18",
            "patch": "@@ -16,6 +16,12 @@ export function getStaticPaths() {\n }\n \n export function getStaticProps({ params }) {\n+  if (params.slug === 'not-found') {\n+    return {\n+      notFound: true,\n+    }\n+  }\n+\n   return {\n     props: {\n       params,"
        }
    ],
    "stats": {
        "total": 280,
        "additions": 220,
        "deletions": 60
    }
}