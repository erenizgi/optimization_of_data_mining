{
    "author": "bgw",
    "message": "fix(turbopack): Use strongly consistent reads for sourcemaps in napi FFI boundary (#77511)\n\nAll turbo-task reads from an FFI boundary must be strongly-consistent.\n\nOtherwise, we might propagate errors due to inconsistent cell state.\n\nWe suspect it's the root cause for this: https://vercel.slack.com/archives/C04MKMSEV3K/p1742874851690489",
    "sha": "b005187a7f0af917683f99d8ef125e62b38dbd0b",
    "files": [
        {
            "sha": "2dc4f553f953f4ffb3034b3370a1af0fe88e7414",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 36,
            "deletions": 33,
            "changes": 69,
            "blob_url": "https://github.com/vercel/next.js/blob/b005187a7f0af917683f99d8ef125e62b38dbd0b/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b005187a7f0af917683f99d8ef125e62b38dbd0b/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=b005187a7f0af917683f99d8ef125e62b38dbd0b",
            "patch": "@@ -304,7 +304,7 @@ impl From<NapiDefineEnv> for DefineEnv {\n \n pub struct ProjectInstance {\n     turbo_tasks: NextTurboTasks,\n-    container: Vc<ProjectContainer>,\n+    container: ResolvedVc<ProjectContainer>,\n     exit_receiver: tokio::sync::Mutex<Option<ExitReceiver>>,\n }\n \n@@ -434,7 +434,7 @@ pub async fn project_new(\n     Ok(External::new_with_size_hint(\n         ProjectInstance {\n             turbo_tasks,\n-            container: *container,\n+            container,\n             exit_receiver: tokio::sync::Mutex::new(Some(exit_receiver)),\n         },\n         100,\n@@ -782,10 +782,8 @@ pub async fn project_write_all_entrypoints_to_disk(\n     let turbo_tasks = project.turbo_tasks.clone();\n     let (entrypoints, issues, diags) = turbo_tasks\n         .run_once(async move {\n-            let entrypoints_with_issues_op = get_all_written_entrypoints_with_issues_operation(\n-                project.container.to_resolved().await?,\n-                app_dir_only,\n-            );\n+            let entrypoints_with_issues_op =\n+                get_all_written_entrypoints_with_issues_operation(project.container, app_dir_only);\n \n             let EntrypointsWithIssues {\n                 entrypoints,\n@@ -879,8 +877,7 @@ pub fn project_entrypoints_subscribe(\n         func,\n         move || {\n             async move {\n-                let entrypoints_with_issues_op =\n-                    get_entrypoints_with_issues_operation(container.to_resolved().await?);\n+                let entrypoints_with_issues_op = get_entrypoints_with_issues_operation(container);\n                 let EntrypointsWithIssues {\n                     entrypoints,\n                     issues,\n@@ -1085,7 +1082,7 @@ pub fn project_hmr_identifiers_subscribe(\n         func,\n         move || async move {\n             let hmr_identifiers_with_issues_op =\n-                get_hmr_identifiers_with_issues_operation(container.to_resolved().await?);\n+                get_hmr_identifiers_with_issues_operation(container);\n             let HmrIdentifiersWithIssues {\n                 identifiers,\n                 issues,\n@@ -1236,10 +1233,11 @@ pub struct StackFrame {\n     pub method_name: Option<String>,\n }\n \n+#[turbo_tasks::function]\n pub async fn get_source_map_rope(\n     container: Vc<ProjectContainer>,\n-    file_path: String,\n-) -> Result<Option<Vc<OptionStringifiedSourceMap>>> {\n+    file_path: RcStr,\n+) -> Result<Vc<OptionStringifiedSourceMap>> {\n     let (file, module) = match Url::parse(&file_path) {\n         Ok(url) => match url.scheme() {\n             \"file\" => {\n@@ -1266,7 +1264,7 @@ pub async fn get_source_map_rope(\n         )),\n     ) else {\n         // File doesn't exist within the dist dir\n-        return Ok(None);\n+        return Ok(OptionStringifiedSourceMap::none());\n     };\n \n     let server_path = container.project().node_root().join(chunk_base.into());\n@@ -1284,24 +1282,29 @@ pub async fn get_source_map_rope(\n         // Currently, this is inaccurate as it does not cover RSC server\n         // chunks.\n         map = container.get_source_map(client_path, module);\n+        if map.await?.is_none() {\n+            bail!(\"chunk/module '{}' is missing a sourcemap\", file_path);\n+        }\n     }\n \n-    if map.await?.is_none() {\n-        bail!(\"chunk/module '{}' is missing a sourcemap\", file_path);\n-    }\n+    Ok(map)\n+}\n \n-    Ok(Some(map))\n+#[turbo_tasks::function(operation)]\n+pub fn get_source_map_rope_operation(\n+    container: ResolvedVc<ProjectContainer>,\n+    file_path: RcStr,\n+) -> Vc<OptionStringifiedSourceMap> {\n+    get_source_map_rope(*container, file_path)\n }\n \n-pub async fn get_source_map(\n-    container: Vc<ProjectContainer>,\n-    file_path: String,\n-) -> Result<Option<ReadRef<OptionSourceMap>>> {\n-    let Some(map) = get_source_map_rope(container, file_path).await? else {\n-        return Ok(None);\n-    };\n-    let map = SourceMap::new_from_rope_cached(map).await?;\n-    Ok(Some(map))\n+#[turbo_tasks::function(operation)]\n+pub fn get_source_map_operation(\n+    container: ResolvedVc<ProjectContainer>,\n+    file_path: RcStr,\n+) -> Vc<OptionSourceMap> {\n+    let map = get_source_map_rope(*container, file_path);\n+    SourceMap::new_from_rope_cached(map)\n }\n \n #[napi]\n@@ -1314,10 +1317,10 @@ pub async fn project_trace_source(\n     let container = project.container;\n     let traced_frame = turbo_tasks\n         .run_once(async move {\n-            let Some(map) = get_source_map(container, frame.file).await? else {\n-                return Ok(None);\n-            };\n-            let Some(map) = &*map else {\n+            let Some(map) = &*get_source_map_operation(container, RcStr::from(frame.file))\n+                .read_strongly_consistent()\n+                .await?\n+            else {\n                 return Ok(None);\n             };\n \n@@ -1445,10 +1448,10 @@ pub async fn project_get_source_map(\n \n     let source_map = turbo_tasks\n         .run_once(async move {\n-            let Some(map) = get_source_map_rope(container, file_path).await? else {\n-                return Ok(None);\n-            };\n-            let Some(map) = &*map.await? else {\n+            let Some(map) = &*get_source_map_rope_operation(container, RcStr::from(file_path))\n+                .read_strongly_consistent()\n+                .await?\n+            else {\n                 return Ok(None);\n             };\n             Ok(Some(map.to_str()?.to_string()))"
        }
    ],
    "stats": {
        "total": 69,
        "additions": 36,
        "deletions": 33
    }
}