{
    "author": "kdy1",
    "message": "perf(turbopack): Load `is_immutable` flag dynamically (#80506)\n\n### What?\n\nLoad `is_immutable` flag from the task state instead of only relying on the static flag.\n\n### Why?\n\nIt would allow determining more tasks as `immutable`",
    "sha": "47c146116a303262a63fcdac82c95abcc6532df6",
    "files": [
        {
            "sha": "6a7b7e71626c764585ddfd10f9ecee89987e1a3e",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/connect_child.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 5,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/47c146116a303262a63fcdac82c95abcc6532df6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/47c146116a303262a63fcdac82c95abcc6532df6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs?ref=47c146116a303262a63fcdac82c95abcc6532df6",
            "patch": "@@ -26,12 +26,12 @@ impl ConnectChildOperation {\n     pub fn run(\n         parent_task_id: TaskId,\n         child_task_id: TaskId,\n-        is_immutable: bool,\n+        mut is_child_immutable: bool,\n         mut ctx: impl ExecuteContext,\n     ) {\n         if !ctx.should_track_children() {\n             let mut task = ctx.task(child_task_id, TaskDataCategory::All);\n-            if is_immutable {\n+            if is_child_immutable {\n                 task.mark_as_immutable();\n             }\n             if !task.has_key(&CachedDataItemKey::Output {}) {\n@@ -44,6 +44,12 @@ impl ConnectChildOperation {\n             }\n             return;\n         }\n+\n+        if !is_child_immutable {\n+            let task = ctx.task(child_task_id, TaskDataCategory::All);\n+            is_child_immutable = task.is_immutable();\n+        }\n+\n         let mut parent_task = ctx.task(parent_task_id, TaskDataCategory::All);\n         let Some(InProgressState::InProgress(box InProgressStateInner { new_children, .. })) =\n             get_mut!(parent_task, InProgress)\n@@ -52,7 +58,10 @@ impl ConnectChildOperation {\n         };\n \n         // Quick skip if the child was already connected before\n-        if new_children.insert(child_task_id, is_immutable).is_some() {\n+        if new_children\n+            .insert(child_task_id, is_child_immutable)\n+            .is_some()\n+        {\n             return;\n         }\n \n@@ -76,13 +85,13 @@ impl ConnectChildOperation {\n         }\n \n         // Immutable tasks cannot be invalidated, meaning that we never reschedule them.\n-        if !is_immutable && ctx.should_track_activeness() {\n+        if !is_child_immutable && ctx.should_track_activeness() {\n             queue.push(AggregationUpdateJob::IncreaseActiveCount {\n                 task: child_task_id,\n             });\n         } else {\n             let mut task = ctx.task(child_task_id, TaskDataCategory::All);\n-            if is_immutable {\n+            if is_child_immutable {\n                 task.mark_as_immutable();\n             }\n "
        }
    ],
    "stats": {
        "total": 19,
        "additions": 14,
        "deletions": 5
    }
}