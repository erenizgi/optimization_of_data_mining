{
    "author": "mischnic",
    "message": "Turbopack: remove global_information struct (#86089)\n\nThis was always unnecessary.\n\nOr is this worse now as there are fewer strongly consistent reads?",
    "sha": "9375bc3d568b4add57cbaa99e6feed5dd51c6eb6",
    "files": [
        {
            "sha": "934affa0ad4736d10c33341acb20cb50e28a29aa",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 24,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/9375bc3d568b4add57cbaa99e6feed5dd51c6eb6/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9375bc3d568b4add57cbaa99e6feed5dd51c6eb6/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=9375bc3d568b4add57cbaa99e6feed5dd51c6eb6",
            "patch": "@@ -75,7 +75,7 @@ use crate::{\n     dynamic_imports::{NextDynamicChunkAvailability, collect_next_dynamic_chunks},\n     font::FontManifest,\n     loadable_manifest::create_react_loadable_manifest,\n-    module_graph::get_global_information_for_endpoint,\n+    module_graph::{ClientReferencesGraphs, NextDynamicGraphs, ServerActionsGraphs},\n     nft_json::NftJsonAsset,\n     paths::{\n         all_paths_in_root, all_server_paths, get_asset_paths_from_root, get_js_paths_from_root,\n@@ -1253,22 +1253,22 @@ impl AppEndpoint {\n             (AvailabilityInfo::Root, vec![])\n         };\n \n-        let global_information = get_global_information_for_endpoint(\n-            *module_graphs.base,\n-            *project.per_page_module_graph().await?,\n-        );\n-        let next_dynamic_imports = global_information\n-            .get_next_dynamic_imports_for_endpoint(*rsc_entry)\n-            .await?;\n+        let per_page_module_graph = *project.per_page_module_graph().await?;\n \n-        let client_references = global_information\n-            .get_client_references_for_endpoint(\n-                *rsc_entry,\n-                matches!(this.ty, AppEndpointType::Page { .. }),\n-                project.next_mode().await?.is_production(),\n-            )\n-            .to_resolved()\n-            .await?;\n+        let next_dynamic_imports =\n+            NextDynamicGraphs::new(*module_graphs.base, per_page_module_graph)\n+                .get_next_dynamic_imports_for_endpoint(*rsc_entry)\n+                .await?;\n+\n+        let client_references =\n+            ClientReferencesGraphs::new(*module_graphs.base, per_page_module_graph)\n+                .get_client_references_for_endpoint(\n+                    *rsc_entry,\n+                    matches!(this.ty, AppEndpointType::Page { .. }),\n+                    project.next_mode().await?.is_production(),\n+                )\n+                .to_resolved()\n+                .await?;\n \n         let client_references_chunks = get_app_client_references_chunks(\n             *client_references,\n@@ -1395,13 +1395,14 @@ impl AppEndpoint {\n             }\n         }\n \n-        let actions = global_information.get_server_actions_for_endpoint(\n-            *rsc_entry,\n-            match runtime {\n-                NextRuntime::Edge => Vc::upcast(this.app_project.edge_rsc_module_context()),\n-                NextRuntime::NodeJs => Vc::upcast(this.app_project.rsc_module_context()),\n-            },\n-        );\n+        let actions = ServerActionsGraphs::new(*module_graphs.base, per_page_module_graph)\n+            .get_server_actions_for_endpoint(\n+                *rsc_entry,\n+                match runtime {\n+                    NextRuntime::Edge => Vc::upcast(this.app_project.edge_rsc_module_context()),\n+                    NextRuntime::NodeJs => Vc::upcast(this.app_project.rsc_module_context()),\n+                },\n+            );\n \n         let server_action_manifest = create_server_actions_manifest(\n             actions,\n@@ -2074,7 +2075,7 @@ impl Endpoint for AppEndpoint {\n         let rsc_entry = app_entry.rsc_entry;\n         let runtime = app_entry.config.await?.runtime.unwrap_or_default();\n \n-        let actions = get_global_information_for_endpoint(\n+        let actions = ServerActionsGraphs::new(\n             graph,\n             *this.app_project.project().per_page_module_graph().await?,\n         )"
        },
        {
            "sha": "488749f2ab0d680ab263cc303aa21a3fd320cdeb",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 269,
            "deletions": 244,
            "changes": 513,
            "blob_url": "https://github.com/vercel/next.js/blob/9375bc3d568b4add57cbaa99e6feed5dd51c6eb6/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9375bc3d568b4add57cbaa99e6feed5dd51c6eb6/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=9375bc3d568b4add57cbaa99e6feed5dd51c6eb6",
            "patch": "@@ -41,6 +41,82 @@ pub struct NextDynamicGraph {\n     data: ResolvedVc<DynamicImportEntries>,\n }\n \n+#[turbo_tasks::value]\n+pub struct NextDynamicGraphs(Vec<ResolvedVc<NextDynamicGraph>>);\n+\n+#[turbo_tasks::value_impl]\n+impl NextDynamicGraphs {\n+    #[turbo_tasks::function(operation)]\n+    async fn new_operation(\n+        graphs: ResolvedVc<ModuleGraph>,\n+        is_single_page: bool,\n+    ) -> Result<Vc<Self>> {\n+        let graphs_ref = &graphs.await?.graphs;\n+        let next_dynamic = async {\n+            graphs_ref\n+                .iter()\n+                .map(|graph| {\n+                    NextDynamicGraph::new_with_entries(**graph, is_single_page).to_resolved()\n+                })\n+                .try_join()\n+                .await\n+        }\n+        .instrument(tracing::info_span!(\"generating next/dynamic graphs\"))\n+        .await?;\n+        Ok(Self(next_dynamic).cell())\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub async fn new(graphs: ResolvedVc<ModuleGraph>, is_single_page: bool) -> Result<Vc<Self>> {\n+        // TODO get rid of this function once everything inside of\n+        // `get_global_information_for_endpoint_inner` calls `take_collectibles()` when needed\n+        let result_op = Self::new_operation(graphs, is_single_page);\n+        let result_vc = if !is_single_page {\n+            let result_vc = result_op.resolve_strongly_consistent().await?;\n+            result_op.drop_collectibles::<Box<dyn Issue>>();\n+            *result_vc\n+        } else {\n+            result_op.connect()\n+        };\n+        Ok(result_vc)\n+    }\n+\n+    /// Returns the next/dynamic-ally imported (client) modules (from RSC and SSR modules) for the\n+    /// given endpoint.\n+    #[turbo_tasks::function]\n+    pub async fn get_next_dynamic_imports_for_endpoint(\n+        &self,\n+        entry: Vc<Box<dyn Module>>,\n+    ) -> Result<Vc<DynamicImportEntriesWithImporter>> {\n+        let span = tracing::info_span!(\"collect all next/dynamic imports for endpoint\");\n+        async move {\n+            if let [graph] = &self.0[..] {\n+                // Just a single graph, no need to merge results\n+                Ok(graph.get_next_dynamic_imports_for_endpoint(entry))\n+            } else {\n+                let result = self\n+                    .0\n+                    .iter()\n+                    .map(|graph| async move {\n+                        Ok(graph\n+                            .get_next_dynamic_imports_for_endpoint(entry)\n+                            .await?\n+                            .into_iter()\n+                            .map(|(k, v)| (*k, *v))\n+                            // TODO remove this collect and return an iterator instead\n+                            .collect::<Vec<_>>())\n+                    })\n+                    .try_flat_join()\n+                    .await?;\n+\n+                Ok(Vc::cell(result.into_iter().collect()))\n+            }\n+        }\n+        .instrument(span)\n+        .await\n+    }\n+}\n+\n #[turbo_tasks::value(transparent)]\n pub struct DynamicImportEntriesWithImporter(\n     pub  Vec<(\n@@ -161,6 +237,79 @@ pub struct ServerActionsGraph {\n     data: ResolvedVc<AllModuleActions>,\n }\n \n+#[turbo_tasks::value]\n+pub struct ServerActionsGraphs(Vec<ResolvedVc<ServerActionsGraph>>);\n+\n+#[turbo_tasks::value_impl]\n+impl ServerActionsGraphs {\n+    #[turbo_tasks::function(operation)]\n+    async fn new_operation(\n+        graphs: ResolvedVc<ModuleGraph>,\n+        is_single_page: bool,\n+    ) -> Result<Vc<Self>> {\n+        let graphs_ref = &graphs.await?.graphs;\n+        let server_actions = async {\n+            graphs_ref\n+                .iter()\n+                .map(|graph| {\n+                    ServerActionsGraph::new_with_entries(**graph, is_single_page).to_resolved()\n+                })\n+                .try_join()\n+                .await\n+        }\n+        .instrument(tracing::info_span!(\"generating server actions graphs\"))\n+        .await?;\n+        Ok(Self(server_actions).cell())\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub async fn new(graphs: ResolvedVc<ModuleGraph>, is_single_page: bool) -> Result<Vc<Self>> {\n+        // TODO get rid of this function once everything inside of\n+        // `get_global_information_for_endpoint_inner` calls `take_collectibles()` when needed\n+        let result_op = Self::new_operation(graphs, is_single_page);\n+        let result_vc = if !is_single_page {\n+            let result_vc = result_op.resolve_strongly_consistent().await?;\n+            result_op.drop_collectibles::<Box<dyn Issue>>();\n+            *result_vc\n+        } else {\n+            result_op.connect()\n+        };\n+        Ok(result_vc)\n+    }\n+\n+    /// Returns the server actions for the given page.\n+    #[turbo_tasks::function]\n+    pub async fn get_server_actions_for_endpoint(\n+        &self,\n+        entry: Vc<Box<dyn Module>>,\n+        rsc_asset_context: Vc<Box<dyn AssetContext>>,\n+    ) -> Result<Vc<AllActions>> {\n+        let span = tracing::info_span!(\"collect all server actions for endpoint\");\n+        async move {\n+            if let [graph] = &self.0[..] {\n+                // Just a single graph, no need to merge results\n+                Ok(graph.get_server_actions_for_endpoint(entry, rsc_asset_context))\n+            } else {\n+                let result = self\n+                    .0\n+                    .iter()\n+                    .map(|graph| async move {\n+                        graph\n+                            .get_server_actions_for_endpoint(entry, rsc_asset_context)\n+                            .owned()\n+                            .await\n+                    })\n+                    .try_flat_join()\n+                    .await?;\n+\n+                Ok(Vc::cell(result))\n+            }\n+        }\n+        .instrument(span)\n+        .await\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl ServerActionsGraph {\n     #[turbo_tasks::function]\n@@ -261,15 +410,111 @@ pub struct ClientReferencesGraph {\n     data: ResolvedVc<ClientReferenceData>,\n }\n \n+#[turbo_tasks::value]\n+pub struct ClientReferencesGraphs(Vec<ResolvedVc<ClientReferencesGraph>>);\n+\n+#[turbo_tasks::value_impl]\n+impl ClientReferencesGraphs {\n+    #[turbo_tasks::function(operation)]\n+    async fn new_operation(\n+        graphs: ResolvedVc<ModuleGraph>,\n+        is_single_page: bool,\n+    ) -> Result<Vc<Self>> {\n+        let graphs_ref = &graphs.await?.graphs;\n+        let client_references = async {\n+            graphs_ref\n+                .iter()\n+                .map(|graph| {\n+                    ClientReferencesGraph::new_with_entries(**graph, is_single_page).to_resolved()\n+                })\n+                .try_join()\n+                .await\n+        }\n+        .instrument(tracing::info_span!(\"generating client references graphs\"))\n+        .await?;\n+        Ok(Self(client_references).cell())\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub async fn new(graphs: ResolvedVc<ModuleGraph>, is_single_page: bool) -> Result<Vc<Self>> {\n+        // TODO get rid of this function once everything inside of\n+        // `get_global_information_for_endpoint_inner` calls `take_collectibles()` when needed\n+        let result_op = Self::new_operation(graphs, is_single_page);\n+        let result_vc = if !is_single_page {\n+            let result_vc = result_op.resolve_strongly_consistent().await?;\n+            result_op.drop_collectibles::<Box<dyn Issue>>();\n+            *result_vc\n+        } else {\n+            result_op.connect()\n+        };\n+        Ok(result_vc)\n+    }\n+\n+    /// Returns the client references for the given page.\n+    #[turbo_tasks::function]\n+    pub async fn get_client_references_for_endpoint(\n+        &self,\n+        entry: Vc<Box<dyn Module>>,\n+        has_layout_segments: bool,\n+        include_traced: bool,\n+    ) -> Result<Vc<ClientReferenceGraphResult>> {\n+        let span = tracing::info_span!(\"collect all client references for endpoint\");\n+        async move {\n+            let result = if let [graph] = &self.0[..] {\n+                // Just a single graph, no need to merge results  This also naturally aggregates\n+                // server components and server utilities in the correct order\n+                graph.get_client_references_for_endpoint(entry)\n+            } else {\n+                let results = self\n+                    .0\n+                    .iter()\n+                    .map(|graph| graph.get_client_references_for_endpoint(entry))\n+                    .try_join();\n+                // Do this separately for now, because the aggregation of multiple graph traversals\n+                // messes up the order of the server_component_entries.\n+                let server_entries = async {\n+                    if has_layout_segments {\n+                        let server_entries = find_server_entries(entry, include_traced).await?;\n+                        Ok(Some(server_entries))\n+                    } else {\n+                        Ok(None)\n+                    }\n+                };\n+                // Wait for both in parallel since `find_server_entries` tends to be slower than the\n+                // graph traversals\n+                let (results, server_entries) = join!(results, server_entries);\n+\n+                let mut result = ClientReferenceGraphResult {\n+                    client_references: results?\n+                        .iter()\n+                        .flat_map(|r| r.client_references.iter().copied())\n+                        .collect(),\n+                    ..Default::default()\n+                };\n+                if let Some(ServerEntries {\n+                    server_utils,\n+                    server_component_entries,\n+                }) = server_entries?.as_deref()\n+                {\n+                    result.server_utils = server_utils.clone();\n+                    result.server_component_entries = server_component_entries.clone();\n+                }\n+                result.cell()\n+            };\n+            Ok(result)\n+        }\n+        .instrument(span)\n+        .await\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl ClientReferencesGraph {\n     #[turbo_tasks::function]\n     pub async fn new_with_entries(\n         graph: ResolvedVc<SingleModuleGraph>,\n         is_single_page: bool,\n     ) -> Result<Vc<Self>> {\n-        // TODO if is_single_page, then perform the graph traversal below in map_client_references\n-        // already, which saves us a traversal.\n         let mapped = map_client_references(*graph);\n \n         Ok(Self {\n@@ -515,7 +760,7 @@ struct ModuleNameMap(pub FxModuleNameMap);\n \n #[tracing::instrument(level = \"info\", name = \"validate pages css imports\", skip_all)]\n #[turbo_tasks::function]\n-async fn validate_pages_css_imports(\n+async fn validate_pages_css_imports_individual(\n     graph: Vc<SingleModuleGraph>,\n     is_single_page: bool,\n     entry: Vc<Box<dyn Module>>,\n@@ -605,247 +850,27 @@ async fn validate_pages_css_imports(\n     Ok(())\n }\n \n-/// The consumers of this shouldn't need to care about the exact contents since it's abstracted away\n-/// by the accessor functions, but\n-/// - In dev, contains information about the modules of the current endpoint only\n-/// - In prod, there is a single `GlobalBuildInformation` for the whole app, containing all pages\n-#[turbo_tasks::value]\n-pub struct GlobalBuildInformation {\n-    next_dynamic: Vec<ResolvedVc<NextDynamicGraph>>,\n-    server_actions: Vec<ResolvedVc<ServerActionsGraph>>,\n-    client_references: Vec<ResolvedVc<ClientReferencesGraph>>,\n-    // Data for some more ad-hoc operations\n-    bare_graphs: ResolvedVc<ModuleGraph>,\n-    is_single_page: bool,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl GlobalBuildInformation {\n-    #[turbo_tasks::function]\n-    pub async fn new(graphs: Vc<ModuleGraph>, is_single_page: bool) -> Result<Vc<Self>> {\n-        let graphs_ref = &graphs.await?.graphs;\n-        let next_dynamic = async {\n-            graphs_ref\n-                .iter()\n-                .map(|graph| {\n-                    NextDynamicGraph::new_with_entries(**graph, is_single_page).to_resolved()\n-                })\n-                .try_join()\n-                .await\n-        }\n-        .instrument(tracing::info_span!(\"generating next/dynamic graphs\"));\n-\n-        let server_actions = async {\n-            graphs_ref\n-                .iter()\n-                .map(|graph| {\n-                    ServerActionsGraph::new_with_entries(**graph, is_single_page).to_resolved()\n-                })\n-                .try_join()\n-                .await\n-        }\n-        .instrument(tracing::info_span!(\"generating server actions graphs\"));\n-\n-        let client_references = async {\n-            graphs_ref\n-                .iter()\n-                .map(|graph| {\n-                    ClientReferencesGraph::new_with_entries(**graph, is_single_page).to_resolved()\n-                })\n-                .try_join()\n-                .await\n-        }\n-        .instrument(tracing::info_span!(\"generating client references graphs\"));\n-\n-        let (next_dynamic, server_actions, client_references) =\n-            futures::join!(next_dynamic, server_actions, client_references);\n-\n-        Ok(Self {\n-            next_dynamic: next_dynamic?,\n-            server_actions: server_actions?,\n-            client_references: client_references?,\n-            bare_graphs: graphs.to_resolved().await?,\n-            is_single_page,\n-        }\n-        .cell())\n-    }\n-\n-    /// Returns the next/dynamic-ally imported (client) modules (from RSC and SSR modules) for the\n-    /// given endpoint.\n-    #[turbo_tasks::function]\n-    pub async fn get_next_dynamic_imports_for_endpoint(\n-        &self,\n-        entry: Vc<Box<dyn Module>>,\n-    ) -> Result<Vc<DynamicImportEntriesWithImporter>> {\n-        let span = tracing::info_span!(\"collect all next/dynamic imports for endpoint\");\n-        async move {\n-            if let [graph] = &self.next_dynamic[..] {\n-                // Just a single graph, no need to merge results\n-                Ok(graph.get_next_dynamic_imports_for_endpoint(entry))\n-            } else {\n-                let result = self\n-                    .next_dynamic\n-                    .iter()\n-                    .map(|graph| async move {\n-                        Ok(graph\n-                            .get_next_dynamic_imports_for_endpoint(entry)\n-                            .await?\n-                            .into_iter()\n-                            .map(|(k, v)| (*k, *v))\n-                            // TODO remove this collect and return an iterator instead\n-                            .collect::<Vec<_>>())\n-                    })\n-                    .try_flat_join()\n-                    .await?;\n-\n-                Ok(Vc::cell(result.into_iter().collect()))\n-            }\n-        }\n-        .instrument(span)\n-        .await\n-    }\n-\n-    /// Returns the server actions for the given page.\n-    #[turbo_tasks::function]\n-    pub async fn get_server_actions_for_endpoint(\n-        &self,\n-        entry: Vc<Box<dyn Module>>,\n-        rsc_asset_context: Vc<Box<dyn AssetContext>>,\n-    ) -> Result<Vc<AllActions>> {\n-        let span = tracing::info_span!(\"collect all server actions for endpoint\");\n-        async move {\n-            if let [graph] = &self.server_actions[..] {\n-                // Just a single graph, no need to merge results\n-                Ok(graph.get_server_actions_for_endpoint(entry, rsc_asset_context))\n-            } else {\n-                let result = self\n-                    .server_actions\n-                    .iter()\n-                    .map(|graph| async move {\n-                        graph\n-                            .get_server_actions_for_endpoint(entry, rsc_asset_context)\n-                            .owned()\n-                            .await\n-                    })\n-                    .try_flat_join()\n-                    .await?;\n-\n-                Ok(Vc::cell(result))\n-            }\n-        }\n-        .instrument(span)\n-        .await\n-    }\n-\n-    /// Returns the client references for the given page.\n-    #[turbo_tasks::function]\n-    pub async fn get_client_references_for_endpoint(\n-        &self,\n-        entry: Vc<Box<dyn Module>>,\n-        has_layout_segments: bool,\n-        include_traced: bool,\n-    ) -> Result<Vc<ClientReferenceGraphResult>> {\n-        let span = tracing::info_span!(\"collect all client references for endpoint\");\n-        async move {\n-            let result = if let [graph] = &self.client_references[..] {\n-                // Just a single graph, no need to merge results  This also naturally aggregates\n-                // server components and server utilities in the correct order\n-                graph.get_client_references_for_endpoint(entry)\n-            } else {\n-                let results = self\n-                    .client_references\n-                    .iter()\n-                    .map(|graph| graph.get_client_references_for_endpoint(entry))\n-                    .try_join();\n-                // Do this separately for now, because the aggregation of multiple graph traversals\n-                // messes up the order of the server_component_entries.\n-                let server_entries = async {\n-                    if has_layout_segments {\n-                        let server_entries = find_server_entries(entry, include_traced).await?;\n-                        Ok(Some(server_entries))\n-                    } else {\n-                        Ok(None)\n-                    }\n-                };\n-                // Wait for both in parallel since `find_server_entries` tends to be slower than the\n-                // graph traversals\n-                let (results, server_entries) = join!(results, server_entries);\n-\n-                let mut result = ClientReferenceGraphResult {\n-                    client_references: results?\n-                        .iter()\n-                        .flat_map(|r| r.client_references.iter().copied())\n-                        .collect(),\n-                    ..Default::default()\n-                };\n-                if let Some(ServerEntries {\n-                    server_utils,\n-                    server_component_entries,\n-                }) = server_entries?.as_deref()\n-                {\n-                    result.server_utils = server_utils.clone();\n-                    result.server_component_entries = server_component_entries.clone();\n-                }\n-                result.cell()\n-            };\n-            Ok(result)\n-        }\n-        .instrument(span)\n-        .await\n-    }\n-\n-    #[turbo_tasks::function]\n-    /// Validates that the global CSS/SCSS/SASS imports are only valid imports with the following\n-    /// rules:\n-    /// * The import is made from a `node_modules` package\n-    /// * The import is made from a `.module.css` file\n-    /// * The import is made from the `pages/_app.js`, or equivalent file.\n-    pub async fn validate_pages_css_imports(\n-        &self,\n-        entry: Vc<Box<dyn Module>>,\n-        app_module: Vc<Box<dyn Module>>,\n-    ) -> Result<()> {\n-        let graphs = &self.bare_graphs.await?.graphs;\n-\n-        graphs\n-            .iter()\n-            .map(|graph| {\n-                validate_pages_css_imports(**graph, self.is_single_page, entry, app_module)\n-                    .as_side_effect()\n-            })\n-            .try_join()\n-            .await?;\n-\n-        Ok(())\n-    }\n-}\n-\n-#[turbo_tasks::function(operation)]\n-fn get_global_information_for_endpoint_inner_operation(\n-    module_graph: ResolvedVc<ModuleGraph>,\n-    is_single_page: bool,\n-) -> Vc<GlobalBuildInformation> {\n-    GlobalBuildInformation::new(*module_graph, is_single_page)\n-}\n-\n-/// Generates a [GlobalBuildInformation] for the given project and endpoint containing information\n-/// that is either global (module ids, chunking) or computed globally as a performance optimization\n-/// (client references, etc).\n+/// Validates that the global CSS/SCSS/SASS imports are only valid imports with the following\n+/// rules:\n+/// * The import is made from a `node_modules` package\n+/// * The import is made from a `.module.css` file\n+/// * The import is made from the `pages/_app.js`, or equivalent file.\n #[turbo_tasks::function]\n-pub async fn get_global_information_for_endpoint(\n-    module_graph: ResolvedVc<ModuleGraph>,\n+pub async fn validate_pages_css_imports(\n+    graph: Vc<ModuleGraph>,\n     is_single_page: bool,\n-) -> Result<Vc<GlobalBuildInformation>> {\n-    // TODO get rid of this function once everything inside of\n-    // `get_global_information_for_endpoint_inner` calls `take_collectibles()` when needed\n-    let result_op =\n-        get_global_information_for_endpoint_inner_operation(module_graph, is_single_page);\n-    let result_vc = if !is_single_page {\n-        let result_vc = result_op.resolve_strongly_consistent().await?;\n-        result_op.drop_collectibles::<Box<dyn Issue>>();\n-        *result_vc\n-    } else {\n-        result_op.connect()\n-    };\n-    Ok(result_vc)\n+    entry: Vc<Box<dyn Module>>,\n+    app_module: Vc<Box<dyn Module>>,\n+) -> Result<()> {\n+    let graphs = &graph.await?.graphs;\n+    graphs\n+        .iter()\n+        .map(|graph| {\n+            validate_pages_css_imports_individual(**graph, is_single_page, entry, app_module)\n+                .as_side_effect()\n+        })\n+        .try_join()\n+        .await?;\n+\n+    Ok(())\n }"
        },
        {
            "sha": "ccc1942548efb65081337894f6097bb2ada60ad3",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 12,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/9375bc3d568b4add57cbaa99e6feed5dd51c6eb6/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9375bc3d568b4add57cbaa99e6feed5dd51c6eb6/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=9375bc3d568b4add57cbaa99e6feed5dd51c6eb6",
            "patch": "@@ -71,7 +71,7 @@ use crate::{\n     },\n     font::FontManifest,\n     loadable_manifest::create_react_loadable_manifest,\n-    module_graph::get_global_information_for_endpoint,\n+    module_graph::{NextDynamicGraphs, validate_pages_css_imports},\n     nft_json::NftJsonAsset,\n     paths::{\n         all_paths_in_root, all_server_paths, get_asset_paths_from_root, get_js_paths_from_root,\n@@ -941,11 +941,7 @@ impl PageEndpoint {\n                 let client_availability_info = self.client_chunk_group().await?.availability_info;\n \n                 let client_module_graph = self.client_module_graph();\n-\n-                let global_information = get_global_information_for_endpoint(\n-                    client_module_graph,\n-                    *project.per_page_module_graph().await?,\n-                );\n+                let per_page_module_graph = *project.per_page_module_graph().await?;\n \n                 // We only validate the global css imports when there is not a `app` folder at the\n                 // root of the project.\n@@ -968,14 +964,19 @@ impl PageEndpoint {\n                         .await?\n                         .module();\n \n-                    global_information\n-                        .validate_pages_css_imports(self.client_module(), app_module)\n-                        .await?;\n+                    validate_pages_css_imports(\n+                        client_module_graph,\n+                        per_page_module_graph,\n+                        self.client_module(),\n+                        app_module,\n+                    )\n+                    .await?;\n                 }\n \n-                let next_dynamic_imports = global_information\n-                    .get_next_dynamic_imports_for_endpoint(self.client_module())\n-                    .await?;\n+                let next_dynamic_imports =\n+                    NextDynamicGraphs::new(client_module_graph, per_page_module_graph)\n+                        .get_next_dynamic_imports_for_endpoint(self.client_module())\n+                        .await?;\n                 Some((next_dynamic_imports, client_availability_info))\n             } else {\n                 None"
        }
    ],
    "stats": {
        "total": 587,
        "additions": 307,
        "deletions": 280
    }
}