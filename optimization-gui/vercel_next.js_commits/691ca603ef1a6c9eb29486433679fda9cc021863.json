{
    "author": "sokra",
    "message": "Turbopack: fix cell not found bug (#78246)\n\n### What?\n\n* Some debug asserts were missing to validate the correct category on read access via `iter()` or `extract_if()`. Added these.\n* incorrect accessed category led to empty list of dependencies after restoring from persistent caching, which led to weird bugs like Cell not found errors\n\nSo optimized the category assignment to make sure aggregation updates can operate on Meta only. Children, Collectibles and CollectiblesDependent were moved to Meta category since they are accessed during aggregation updates. `Children` are used as follower for non-aggregating nodes. `Collectibles` are read when computing the aggregated information and `CollectiblesDependent` are read when aggregated collectibles are modified.\n\n* Added a unit test reproducting this bug and the next PR in the stack also added a e2e test reproducting it.",
    "sha": "691ca603ef1a6c9eb29486433679fda9cc021863",
    "files": [
        {
            "sha": "39de94fcfc7fe1bb3fd3f4ae253d32975208f58c",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=691ca603ef1a6c9eb29486433679fda9cc021863",
            "patch": "@@ -1212,7 +1212,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         };\n         {\n             let mut ctx = self.execute_context(turbo_tasks);\n-            let mut task = ctx.task(task_id, TaskDataCategory::Data);\n+            let mut task = ctx.task(task_id, TaskDataCategory::All);\n             let in_progress = remove!(task, InProgress)?;\n             let InProgressState::Scheduled { done_event } = in_progress else {\n                 task.add_new(CachedDataItem::InProgress { value: in_progress });"
        },
        {
            "sha": "eb05f1a88e165808925d76aa3f66bb611ace5cca",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/aggregation_update.rs",
            "status": "modified",
            "additions": 141,
            "deletions": 28,
            "changes": 169,
            "blob_url": "https://github.com/vercel/next.js/blob/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs?ref=691ca603ef1a6c9eb29486433679fda9cc021863",
            "patch": "@@ -1003,7 +1003,12 @@ impl AggregationUpdateQueue {\n         #[cfg(feature = \"trace_aggregation_update\")]\n         let _span = trace_span!(\"process balance edge\").entered();\n \n-        let (mut upper, mut task) = ctx.task_pair(upper_id, task_id, TaskDataCategory::Meta);\n+        let (mut upper, mut task) = ctx.task_pair(\n+            upper_id,\n+            task_id,\n+            // For performance reasons this should stay `Meta` and not `All`\n+            TaskDataCategory::Meta,\n+        );\n         let upper_aggregation_number = get_aggregation_number(&upper);\n         let task_aggregation_number = get_aggregation_number(&task);\n \n@@ -1187,7 +1192,11 @@ impl AggregationUpdateQueue {\n             name = ctx.get_task_description(task_id)\n         )\n         .entered();\n-        let task = ctx.task(task_id, TaskDataCategory::Meta);\n+        let task = ctx.task(\n+            task_id,\n+            // For performance reasons this should stay `Meta` and not `All`\n+            TaskDataCategory::Meta,\n+        );\n         self.find_and_schedule_dirty_internal(task_id, task, ctx);\n     }\n \n@@ -1234,7 +1243,11 @@ impl AggregationUpdateQueue {\n         update: AggregatedDataUpdate,\n     ) {\n         for upper_id in upper_ids {\n-            let mut upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+            let mut upper = ctx.task(\n+                upper_id,\n+                // For performance reasons this should stay `Meta` and not `All`\n+                TaskDataCategory::Meta,\n+            );\n             let diff = update.apply(\n                 &mut upper,\n                 ctx.session_id(),\n@@ -1265,7 +1278,11 @@ impl AggregationUpdateQueue {\n         #[cfg(feature = \"trace_aggregation_update\")]\n         let _span = trace_span!(\"lost follower (n uppers)\", uppers = upper_ids.len()).entered();\n \n-        let mut follower = ctx.task(lost_follower_id, TaskDataCategory::Meta);\n+        let mut follower = ctx.task(\n+            lost_follower_id,\n+            // For performance reasons this should stay `Meta` and not `All`\n+            TaskDataCategory::Meta,\n+        );\n         let mut follower_in_upper_ids = Vec::new();\n         let mut persistent_uppers = 0;\n         upper_ids.retain(|&mut upper_id| {\n@@ -1298,7 +1315,11 @@ impl AggregationUpdateQueue {\n             if !data.is_empty() {\n                 for upper_id in upper_ids.iter() {\n                     // remove data from upper\n-                    let mut upper = ctx.task(*upper_id, TaskDataCategory::Meta);\n+                    let mut upper = ctx.task(\n+                        *upper_id,\n+                        // For performance reasons this should stay `Meta` and not `All`\n+                        TaskDataCategory::Meta,\n+                    );\n                     let diff = data.apply(\n                         &mut upper,\n                         ctx.session_id(),\n@@ -1331,7 +1352,11 @@ impl AggregationUpdateQueue {\n         }\n \n         for upper_id in follower_in_upper_ids {\n-            let mut upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+            let mut upper = ctx.task(\n+                upper_id,\n+                // For performance reasons this should stay `Meta` and not `All`\n+                TaskDataCategory::Meta,\n+            );\n             if update_count!(\n                 upper,\n                 Follower {\n@@ -1379,7 +1404,11 @@ impl AggregationUpdateQueue {\n         .entered();\n \n         lost_follower_ids.retain(|lost_follower_id| {\n-            let mut follower = ctx.task(*lost_follower_id, TaskDataCategory::Meta);\n+            let mut follower = ctx.task(\n+                *lost_follower_id,\n+                // For performance reasons this should stay `Meta` and not `All`\n+                TaskDataCategory::Meta,\n+            );\n             let mut remove_upper = false;\n             let mut follower_in_upper = false;\n             update!(follower, Upper { task: upper_id }, |old| {\n@@ -1404,7 +1433,11 @@ impl AggregationUpdateQueue {\n \n                 if !data.is_empty() {\n                     // remove data from upper\n-                    let mut upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+                    let mut upper = ctx.task(\n+                        upper_id,\n+                        // For performance reasons this should stay `Meta` and not `All`\n+                        TaskDataCategory::Meta,\n+                    );\n                     let diff = data.apply(\n                         &mut upper,\n                         ctx.session_id(),\n@@ -1434,7 +1467,11 @@ impl AggregationUpdateQueue {\n             follower_in_upper\n         });\n         for lost_follower_id in lost_follower_ids {\n-            let mut upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+            let mut upper = ctx.task(\n+                upper_id,\n+                // For performance reasons this should stay `Meta` and not `All`\n+                TaskDataCategory::Meta,\n+            );\n             if update_count!(\n                 upper,\n                 Follower {\n@@ -1479,14 +1516,22 @@ impl AggregationUpdateQueue {\n             trace_span!(\"process new follower (n uppers)\", uppers = upper_ids.len()).entered();\n \n         let follower_aggregation_number = {\n-            let follower = ctx.task(new_follower_id, TaskDataCategory::Meta);\n+            let follower = ctx.task(\n+                new_follower_id,\n+                // For performance reasons this should stay `Meta` and not `All`\n+                TaskDataCategory::Meta,\n+            );\n             get_aggregation_number(&follower)\n         };\n         let mut upper_upper_ids_with_new_follower = SmallVec::new();\n         let mut tasks_for_which_increment_active_count = SmallVec::new();\n         let mut is_active = false;\n         swap_retain(&mut upper_ids, |&mut upper_id| {\n-            let mut upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+            let mut upper = ctx.task(\n+                upper_id,\n+                // For performance reasons this should stay `Meta` and not `All`\n+                TaskDataCategory::Meta,\n+            );\n             // decide if it should be an inner or follower\n             let upper_aggregation_number = get_aggregation_number(&upper);\n \n@@ -1539,7 +1584,11 @@ impl AggregationUpdateQueue {\n         });\n \n         if !upper_ids.is_empty() {\n-            let mut follower = ctx.task(new_follower_id, TaskDataCategory::Meta);\n+            let mut follower = ctx.task(\n+                new_follower_id,\n+                // For performance reasons this should stay `Meta` and not `All`\n+                TaskDataCategory::Meta,\n+            );\n             let mut uppers_count: Option<usize> = None;\n             let mut persistent_uppers = 0;\n             swap_retain(&mut upper_ids, |&mut upper_id| {\n@@ -1579,7 +1628,11 @@ impl AggregationUpdateQueue {\n                 if has_data || !is_active {\n                     for upper_id in upper_ids.iter() {\n                         // add data to upper\n-                        let mut upper = ctx.task(*upper_id, TaskDataCategory::Meta);\n+                        let mut upper = ctx.task(\n+                            *upper_id,\n+                            // For performance reasons this should stay `Meta` and not `All`\n+                            TaskDataCategory::Meta,\n+                        );\n                         if has_data {\n                             let diff = data.apply(\n                                 &mut upper,\n@@ -1654,7 +1707,11 @@ impl AggregationUpdateQueue {\n         let mut followers_with_aggregation_number = new_follower_ids\n             .into_iter()\n             .map(|new_follower_id| {\n-                let follower = ctx.task(new_follower_id, TaskDataCategory::Meta);\n+                let follower = ctx.task(\n+                    new_follower_id,\n+                    // For performance reasons this should stay `Meta` and not `All`\n+                    TaskDataCategory::Meta,\n+                );\n                 (new_follower_id, get_aggregation_number(&follower))\n             })\n             .collect::<SmallVec<[_; 4]>>();\n@@ -1665,7 +1722,11 @@ impl AggregationUpdateQueue {\n         let mut upper_upper_ids_for_new_followers = SmallVec::new();\n         let upper_aggregation_number;\n         {\n-            let mut upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+            let mut upper = ctx.task(\n+                upper_id,\n+                // For performance reasons this should stay `Meta` and not `All`\n+                TaskDataCategory::Meta,\n+            );\n             if ctx.should_track_activeness() {\n                 let activeness_state = get!(upper, Activeness);\n                 is_active = activeness_state.is_some();\n@@ -1719,7 +1780,11 @@ impl AggregationUpdateQueue {\n             swap_retain(\n                 &mut inner_tasks_with_aggregation_number,\n                 |&mut (inner_id, _)| {\n-                    let mut inner = ctx.task(inner_id, TaskDataCategory::Meta);\n+                    let mut inner = ctx.task(\n+                        inner_id,\n+                        // For performance reasons this should stay `Meta` and not `All`\n+                        TaskDataCategory::Meta,\n+                    );\n                     if update_count!(inner, Upper { task: upper_id }, 1) {\n                         if count!(inner, Upper).is_power_of_two() {\n                             self.push_optimize_task(inner_id);\n@@ -1763,7 +1828,11 @@ impl AggregationUpdateQueue {\n             }\n             if !upper_data_updates.is_empty() {\n                 // add data to upper\n-                let mut upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+                let mut upper = ctx.task(\n+                    upper_id,\n+                    // For performance reasons this should stay `Meta` and not `All`\n+                    TaskDataCategory::Meta,\n+                );\n                 let diffs = upper_data_updates\n                     .into_iter()\n                     .filter_map(|data| {\n@@ -1804,7 +1873,11 @@ impl AggregationUpdateQueue {\n                 if !is_active {\n                     // We need to check this again, since this might have changed in the\n                     // meantime due to race conditions\n-                    let upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+                    let upper = ctx.task(\n+                        upper_id,\n+                        // For performance reasons this should stay `Meta` and not `All`\n+                        TaskDataCategory::Meta,\n+                    );\n                     is_active = upper.has_key(&CachedDataItemKey::Activeness {});\n                 }\n                 if is_active {\n@@ -1849,11 +1922,19 @@ impl AggregationUpdateQueue {\n         let _span = trace_span!(\"process new follower\").entered();\n \n         let follower_aggregation_number = {\n-            let follower = ctx.task(new_follower_id, TaskDataCategory::Meta);\n+            let follower = ctx.task(\n+                new_follower_id,\n+                // For performance reasons this should stay `Meta` and not `All`\n+                TaskDataCategory::Meta,\n+            );\n             get_aggregation_number(&follower)\n         };\n \n-        let mut upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+        let mut upper = ctx.task(\n+            upper_id,\n+            // For performance reasons this should stay `Meta` and not `All`\n+            TaskDataCategory::Meta,\n+        );\n         // decide if it should be an inner or follower\n         let upper_aggregation_number = get_aggregation_number(&upper);\n \n@@ -1912,7 +1993,11 @@ impl AggregationUpdateQueue {\n             let mut is_active = upper.has_key(&CachedDataItemKey::Activeness {});\n             drop(upper);\n \n-            let mut inner = ctx.task(new_follower_id, TaskDataCategory::Meta);\n+            let mut inner = ctx.task(\n+                new_follower_id,\n+                // For performance reasons this should stay `Meta` and not `All`\n+                TaskDataCategory::Meta,\n+            );\n             if update_count!(inner, Upper { task: upper_id }, 1) {\n                 if count!(inner, Upper).is_power_of_two() {\n                     self.push_optimize_task(new_follower_id);\n@@ -1924,7 +2009,11 @@ impl AggregationUpdateQueue {\n \n                 if !data.is_empty() {\n                     // add data to upper\n-                    let mut upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+                    let mut upper = ctx.task(\n+                        upper_id,\n+                        // For performance reasons this should stay `Meta` and not `All`\n+                        TaskDataCategory::Meta,\n+                    );\n                     let diff = data.apply(\n                         &mut upper,\n                         ctx.session_id(),\n@@ -1949,7 +2038,11 @@ impl AggregationUpdateQueue {\n                     });\n                 }\n                 if !is_active {\n-                    let upper = ctx.task(upper_id, TaskDataCategory::Meta);\n+                    let upper = ctx.task(\n+                        upper_id,\n+                        // For performance reasons this should stay `Meta` and not `All`\n+                        TaskDataCategory::Meta,\n+                    );\n                     is_active = upper.has_key(&CachedDataItemKey::Activeness {});\n                 }\n                 if is_active {\n@@ -1966,7 +2059,11 @@ impl AggregationUpdateQueue {\n         #[cfg(feature = \"trace_aggregation_update\")]\n         let _span = trace_span!(\"decrease active count\").entered();\n \n-        let mut task = ctx.task(task_id, TaskDataCategory::Meta);\n+        let mut task = ctx.task(\n+            task_id,\n+            // For performance reasons this should stay `Meta` and not `All`\n+            TaskDataCategory::Meta,\n+        );\n         let state = get_mut_or_insert_with!(task, Activeness, || ActivenessState::new(task_id));\n         let is_zero = state.decrement_active_counter();\n         let is_empty = state.is_empty();\n@@ -1991,7 +2088,11 @@ impl AggregationUpdateQueue {\n         #[cfg(feature = \"trace_aggregation_update\")]\n         let _span = trace_span!(\"increase active count\").entered();\n \n-        let mut task = ctx.task(task_id, TaskDataCategory::Meta);\n+        let mut task = ctx.task(\n+            task_id,\n+            // For performance reasons this should stay `Meta` and not `All`\n+            TaskDataCategory::Meta,\n+        );\n         let state = get_mut_or_insert_with!(task, Activeness, || ActivenessState::new(task_id));\n         let is_positive_now = state.increment_active_counter();\n         let is_empty = state.is_empty();\n@@ -2023,7 +2124,11 @@ impl AggregationUpdateQueue {\n         let _span =\n             trace_span!(\"check update aggregation number\", base_aggregation_number).entered();\n \n-        let mut task = ctx.task(task_id, TaskDataCategory::Meta);\n+        let mut task = ctx.task(\n+            task_id,\n+            // For performance reasons this should stay `Meta` and not `All`\n+            TaskDataCategory::Meta,\n+        );\n         let current = get!(task, AggregationNumber).copied().unwrap_or_default();\n         let old = current.effective;\n         // The base aggregation number can only increase\n@@ -2116,7 +2221,11 @@ impl AggregationUpdateQueue {\n         #[cfg(feature = \"trace_aggregation_update\")]\n         let _span = trace_span!(\"check optimize\").entered();\n \n-        let task = ctx.task(task_id, TaskDataCategory::All);\n+        let task = ctx.task(\n+            task_id,\n+            // For performance reasons this should stay `Meta` and not `All`\n+            TaskDataCategory::Meta,\n+        );\n         let aggregation_number = get!(task, AggregationNumber).copied().unwrap_or_default();\n         if is_root_node(aggregation_number.effective) {\n             return;\n@@ -2164,7 +2273,11 @@ impl AggregationUpdateQueue {\n                 if task_id.is_transient() {\n                     return None;\n                 }\n-                let task = ctx.task(task_id, TaskDataCategory::Meta);\n+                let task = ctx.task(\n+                    task_id,\n+                    // For performance reasons this should stay `Meta` and not `All`\n+                    TaskDataCategory::Meta,\n+                );\n                 let n = get_aggregation_number(&task);\n                 if is_root_node(n) {\n                     root_uppers += 1;"
        },
        {
            "sha": "0493e960b0061ebf6beccaf9d48deda10be369f0",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 2,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=691ca603ef1a6c9eb29486433679fda9cc021863",
            "patch": "@@ -422,14 +422,22 @@ impl<B: BackingStorage> TaskGuardImpl<'_, B> {\n                     #[cfg(debug_assertions)]\n                     debug_assert!(\n                         self.category == TaskDataCategory::Data\n-                            || self.category == TaskDataCategory::All\n+                            || self.category == TaskDataCategory::All,\n+                        \"To read data of {:?} the task need to be accessed with this category \\\n+                         (It's accessed with {:?})\",\n+                        category,\n+                        self.category\n                     );\n                 }\n                 TaskDataCategory::Meta => {\n                     #[cfg(debug_assertions)]\n                     debug_assert!(\n                         self.category == TaskDataCategory::Meta\n-                            || self.category == TaskDataCategory::All\n+                            || self.category == TaskDataCategory::All,\n+                        \"To read data of {:?} the task need to be accessed with this category \\\n+                         (It's accessed with {:?})\",\n+                        category,\n+                        self.category\n                     );\n                 }\n             }\n@@ -631,6 +639,7 @@ impl<B: BackingStorage> TaskGuard for TaskGuardImpl<'_, B> {\n         &self,\n         ty: CachedDataItemType,\n     ) -> impl Iterator<Item = (CachedDataItemKey, CachedDataItemValueRef<'_>)> {\n+        self.check_access(ty.category());\n         self.task.iter(ty)\n     }\n \n@@ -646,6 +655,7 @@ impl<B: BackingStorage> TaskGuard for TaskGuardImpl<'_, B> {\n     where\n         F: for<'a> FnMut(CachedDataItemKey, CachedDataItemValueRef<'a>) -> bool + 'l,\n     {\n+        self.check_access(ty.category());\n         if !self.backend.should_persist() || self.task_id.is_transient() {\n             return Either::Left(self.task.extract_if(ty, f));\n         }"
        },
        {
            "sha": "dfa2e5593b27616dfa3e85c4f61150a95e16fed4",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_output.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs?ref=691ca603ef1a6c9eb29486433679fda9cc021863",
            "patch": "@@ -47,7 +47,7 @@ impl UpdateOutputOperation {\n         output: Result<Result<RawVc>, Option<Cow<'static, str>>>,\n         mut ctx: impl ExecuteContext,\n     ) {\n-        let mut task = ctx.task(task_id, TaskDataCategory::Meta);\n+        let mut task = ctx.task(task_id, TaskDataCategory::All);\n         let Some(InProgressState::InProgress(box InProgressStateInner {\n             stale,\n             new_children,"
        },
        {
            "sha": "24294bb0d5b132c2558c79f0046312859133bad8",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs?ref=691ca603ef1a6c9eb29486433679fda9cc021863",
            "patch": "@@ -557,26 +557,26 @@ impl CachedDataItem {\n \n     pub fn category(&self) -> TaskDataCategory {\n         match self {\n-            Self::Collectible { .. }\n-            | Self::Child { .. }\n-            | Self::CellData { .. }\n+            Self::CellData { .. }\n             | Self::CellTypeMaxIndex { .. }\n             | Self::OutputDependency { .. }\n             | Self::CellDependency { .. }\n             | Self::CollectiblesDependency { .. }\n             | Self::OutputDependent { .. }\n-            | Self::CellDependent { .. }\n-            | Self::CollectiblesDependent { .. } => TaskDataCategory::Data,\n+            | Self::CellDependent { .. } => TaskDataCategory::Data,\n \n-            Self::Output { .. }\n+            Self::Collectible { .. }\n+            | Self::Output { .. }\n             | Self::AggregationNumber { .. }\n             | Self::Dirty { .. }\n             | Self::Follower { .. }\n+            | Self::Child { .. }\n             | Self::Upper { .. }\n             | Self::AggregatedDirtyContainer { .. }\n             | Self::AggregatedCollectible { .. }\n             | Self::AggregatedDirtyContainerCount { .. }\n-            | Self::Stateful { .. } => TaskDataCategory::Meta,\n+            | Self::Stateful { .. }\n+            | Self::CollectiblesDependent { .. } => TaskDataCategory::Meta,\n \n             Self::OutdatedCollectible { .. }\n             | Self::OutdatedOutputDependency { .. }\n@@ -639,26 +639,26 @@ impl CachedDataItemKey {\n impl CachedDataItemType {\n     pub fn category(&self) -> TaskDataCategory {\n         match self {\n-            Self::Collectible { .. }\n-            | Self::Child { .. }\n-            | Self::CellData { .. }\n+            Self::CellData { .. }\n             | Self::CellTypeMaxIndex { .. }\n             | Self::OutputDependency { .. }\n             | Self::CellDependency { .. }\n             | Self::CollectiblesDependency { .. }\n             | Self::OutputDependent { .. }\n-            | Self::CellDependent { .. }\n-            | Self::CollectiblesDependent { .. } => TaskDataCategory::Data,\n+            | Self::CellDependent { .. } => TaskDataCategory::Data,\n \n-            Self::Output { .. }\n+            Self::Collectible { .. }\n+            | Self::Output { .. }\n             | Self::AggregationNumber { .. }\n             | Self::Dirty { .. }\n             | Self::Follower { .. }\n+            | Self::Child { .. }\n             | Self::Upper { .. }\n             | Self::AggregatedDirtyContainer { .. }\n             | Self::AggregatedCollectible { .. }\n             | Self::AggregatedDirtyContainerCount { .. }\n-            | Self::Stateful { .. } => TaskDataCategory::Meta,\n+            | Self::Stateful { .. }\n+            | Self::CollectiblesDependent { .. } => TaskDataCategory::Meta,\n \n             Self::OutdatedCollectible { .. }\n             | Self::OutdatedOutputDependency { .. }"
        },
        {
            "sha": "66c0f9e8609caef9891524c1cd0a4522c7302e20",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/dirty_in_progress.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdirty_in_progress.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdirty_in_progress.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdirty_in_progress.rs?ref=691ca603ef1a6c9eb29486433679fda9cc021863",
            "patch": "@@ -33,7 +33,7 @@ async fn dirty_in_progress() {\n             output.await?;\n             println!(\"update to {}\", b);\n             input_val.state.set(b);\n-            tokio::time::sleep(Duration::from_millis(100)).await;\n+            tokio::time::sleep(Duration::from_millis(50)).await;\n             println!(\"update to {}\", c);\n             input_val.state.set(c);\n             let read = output.strongly_consistent().await?;"
        },
        {
            "sha": "8dbb4c128f1e69fa7a9ccc7355705e0d14f1515b",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/recompute_collectibles.rs",
            "status": "modified",
            "additions": 43,
            "deletions": 17,
            "changes": 60,
            "blob_url": "https://github.com/vercel/next.js/blob/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frecompute_collectibles.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/691ca603ef1a6c9eb29486433679fda9cc021863/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frecompute_collectibles.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frecompute_collectibles.rs?ref=691ca603ef1a6c9eb29486433679fda9cc021863",
            "patch": "@@ -12,12 +12,12 @@ static REGISTRATION: Registration = register!();\n #[tokio::test]\n async fn recompute() {\n     run(&REGISTRATION, || async {\n-        let input = ChangingInput {\n-            state: State::new(1),\n-        }\n-        .cell();\n-        let output = compute(input, 100);\n-        let read = output.await?;\n+        let input = ChangingInput::new(1).resolve().await?;\n+        let input2 = ChangingInput::new(2).resolve().await?;\n+        input.await?.state.set(1);\n+        input2.await?.state.set(1000);\n+        let output = compute(input, input2, 1);\n+        let read = output.strongly_consistent().await?;\n         assert_eq!(read.value, 42);\n         assert_eq!(read.collectible, \"1\");\n \n@@ -27,6 +27,13 @@ async fn recompute() {\n             assert_eq!(read.value, 42);\n             assert_eq!(read.collectible, i.to_string());\n         }\n+\n+        for i in 0..100 {\n+            input2.await?.state.set(i);\n+            let read = output.strongly_consistent().await?;\n+            assert_eq!(read.value, 42);\n+            assert_eq!(read.collectible, \"99\");\n+        }\n         anyhow::Ok(())\n     })\n     .await\n@@ -38,6 +45,18 @@ struct ChangingInput {\n     state: State<u32>,\n }\n \n+#[turbo_tasks::value_impl]\n+impl ChangingInput {\n+    #[turbo_tasks::function]\n+    fn new(key: u32) -> Vc<Self> {\n+        let _ = key;\n+        Self {\n+            state: State::new(1),\n+        }\n+        .cell()\n+    }\n+}\n+\n #[turbo_tasks::value]\n struct Output {\n     value: u32,\n@@ -58,32 +77,39 @@ impl ValueToString for Collectible {\n }\n \n #[turbo_tasks::function(operation)]\n-fn inner_compute(input: ResolvedVc<ChangingInput>) -> Vc<u32> {\n-    inner_compute2(*input, 1000)\n+async fn inner_compute(\n+    input: ResolvedVc<ChangingInput>,\n+    input2: ResolvedVc<ChangingInput>,\n+) -> Result<Vc<u32>> {\n+    println!(\"inner_compute()\");\n+    Ok(inner_compute2(*input, *input2.await?.state.get()))\n }\n \n #[turbo_tasks::function]\n async fn inner_compute2(input: Vc<ChangingInput>, innerness: u32) -> Result<Vc<u32>> {\n+    println!(\"inner_compute2({innerness})\");\n     if innerness > 0 {\n         return Ok(inner_compute2(input, innerness - 1));\n     }\n-    let collectible: ResolvedVc<Box<dyn ValueToString>> = ResolvedVc::upcast(\n-        Collectible {\n-            value: *input.await?.state.get(),\n-        }\n-        .resolved_cell(),\n-    );\n+    let value = *input.await?.state.get();\n+    let collectible: ResolvedVc<Box<dyn ValueToString>> =\n+        ResolvedVc::upcast(Collectible { value }.resolved_cell());\n     emit(collectible);\n \n     Ok(Vc::cell(42))\n }\n \n #[turbo_tasks::function]\n-async fn compute(input: ResolvedVc<ChangingInput>, innerness: u32) -> Result<Vc<Output>> {\n+async fn compute(\n+    input: ResolvedVc<ChangingInput>,\n+    input2: ResolvedVc<ChangingInput>,\n+    innerness: u32,\n+) -> Result<Vc<Output>> {\n+    println!(\"compute({innerness})\");\n     if innerness > 0 {\n-        return Ok(compute(*input, innerness - 1));\n+        return Ok(compute(*input, *input2, innerness - 1));\n     }\n-    let operation = inner_compute(input);\n+    let operation = inner_compute(input, input2);\n     let value = *operation.connect().await?;\n     let collectibles = operation.peek_collectibles::<Box<dyn ValueToString>>();\n     if collectibles.len() != 1 {"
        }
    ],
    "stats": {
        "total": 277,
        "additions": 213,
        "deletions": 64
    }
}