{
    "author": "unstubbable",
    "message": "Update cache handler interface (#76687)\n\nWith this PR, we're changing the experimental cache handler interface that's used for `\"use cache\"` cache handlers:\r\n\r\n- A new method `refreshTags(): Promise<void>` has been added.\r\n    - Next.js will call this function periodically, but always before starting a new request. When working with a remote tags service, this method should communicate with the tags service to refresh the local tags manifest accordingly.\r\n- A new method `getExpiration(...tags: string[]): Promise<Timestamp>` has been added.\r\n    - Next.js will call this function for each set of soft tags that are relevant at the start of a request. The result is the maximum timestamp of a revalidate event for the tags.\r\n- The `get` method does not accept the soft tags anymore as its second arg: `get(cacheKey: string): Promise<undefined | CacheEntry>`\r\n   - Checking the expiration of a cache entry via soft tags is now handled by Next.js.\r\n- The `receiveExpiredTags` method has been removed.\r\n    - This was used for two things:\r\n        1. Refreshing the tags in the tags manifest. This was replaced by `refreshTags`.\r\n        2. Setting the passed-in tags as expired in the tags manifest. This was used for redirecting server actions. Discarding cache entries based on these tags is now handled by Next.js internally.\r\n\r\nTo ease migration, the previous cache handler interface is still supported for now.\r\n\r\ncloses NAR-110",
    "sha": "84fde91e03918344c5d356986914ab68a5083462",
    "files": [
        {
            "sha": "00e4ccc59e96b59e293108636d8d90f6b6b6825a",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -664,5 +664,6 @@\n   \"663\": \"Invariant: client chunk changed but failed to detect hash %s\",\n   \"664\": \"Missing 'next-action' header.\",\n   \"665\": \"Failed to find Server Action \\\"%s\\\". This request might be from an older or newer deployment.\\\\nRead more: https://nextjs.org/docs/messages/failed-to-find-server-action\",\n-  \"666\": \"Turbopack builds are only available in canary builds of Next.js.\"\n+  \"666\": \"Turbopack builds are only available in canary builds of Next.js.\",\n+  \"667\": \"receiveExpiredTags is deprecated, and not expected to be called.\"\n }"
        },
        {
            "sha": "e56c20965b034754c7ee7c44ebccb0f71ce36767",
            "filename": "packages/next/src/build/static-paths/app.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -336,6 +336,7 @@ export async function buildAppStaticPaths({\n       onAfterTaskError: afterRunner.context.onTaskError,\n     },\n     buildId,\n+    previouslyRevalidatedTags: [],\n   })\n \n   const routeParams = await ComponentMod.workAsyncStorage.run("
        },
        {
            "sha": "f1c9652d1da05f3ae47d8efd80653ef8b6e887d2",
            "filename": "packages/next/src/server/after/after-context.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fafter%2Fafter-context.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fafter%2Fafter-context.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fafter%2Fafter-context.test.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -542,7 +542,7 @@ const createMockWorkStore = (afterContext: AfterContext): WorkStore => {\n     forceDynamic: false,\n     dynamicShouldError: false,\n     isStaticGeneration: false,\n-    revalidatedTags: [],\n+    pendingRevalidatedTags: [],\n     pendingRevalidates: undefined,\n     pendingRevalidateWrites: undefined,\n     incrementalCache: undefined,"
        },
        {
            "sha": "c77f881797e8e4e80630754f6d3925b70eb60993",
            "filename": "packages/next/src/server/after/revalidation-utils.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 6,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fafter%2Frevalidation-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fafter%2Frevalidation-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fafter%2Frevalidation-utils.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -26,13 +26,15 @@ export async function withExecuteRevalidates<T>(\n type RevalidationState = Required<\n   Pick<\n     WorkStore,\n-    'revalidatedTags' | 'pendingRevalidates' | 'pendingRevalidateWrites'\n+    'pendingRevalidatedTags' | 'pendingRevalidates' | 'pendingRevalidateWrites'\n   >\n >\n \n function cloneRevalidationState(store: WorkStore): RevalidationState {\n   return {\n-    revalidatedTags: store.revalidatedTags ? [...store.revalidatedTags] : [],\n+    pendingRevalidatedTags: store.pendingRevalidatedTags\n+      ? [...store.pendingRevalidatedTags]\n+      : [],\n     pendingRevalidates: { ...store.pendingRevalidates },\n     pendingRevalidateWrites: store.pendingRevalidateWrites\n       ? [...store.pendingRevalidateWrites]\n@@ -44,10 +46,12 @@ function diffRevalidationState(\n   prev: RevalidationState,\n   curr: RevalidationState\n ): RevalidationState {\n-  const prevTags = new Set(prev.revalidatedTags)\n+  const prevTags = new Set(prev.pendingRevalidatedTags)\n   const prevRevalidateWrites = new Set(prev.pendingRevalidateWrites)\n   return {\n-    revalidatedTags: curr.revalidatedTags.filter((tag) => !prevTags.has(tag)),\n+    pendingRevalidatedTags: curr.pendingRevalidatedTags.filter(\n+      (tag) => !prevTags.has(tag)\n+    ),\n     pendingRevalidates: Object.fromEntries(\n       Object.entries(curr.pendingRevalidates).filter(\n         ([key]) => !(key in prev.pendingRevalidates)\n@@ -62,13 +66,13 @@ function diffRevalidationState(\n async function executeRevalidates(\n   workStore: WorkStore,\n   {\n-    revalidatedTags,\n+    pendingRevalidatedTags,\n     pendingRevalidates,\n     pendingRevalidateWrites,\n   }: RevalidationState\n ) {\n   return Promise.all([\n-    workStore.incrementalCache?.revalidateTag(revalidatedTags),\n+    workStore.incrementalCache?.revalidateTag(pendingRevalidatedTags),\n     ...Object.values(pendingRevalidates),\n     ...pendingRevalidateWrites,\n   ])"
        },
        {
            "sha": "25b3437ea25b39e97b53f75e913621bb16d7da70",
            "filename": "packages/next/src/server/app-render/action-handler.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 36,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Faction-handler.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -113,7 +113,7 @@ function getForwardedHeaders(\n   return new Headers(mergedHeaders)\n }\n \n-async function addRevalidationHeader(\n+function addRevalidationHeader(\n   res: BaseNextResponse,\n   {\n     workStore,\n@@ -123,12 +123,6 @@ async function addRevalidationHeader(\n     requestStore: RequestStore\n   }\n ) {\n-  await Promise.all([\n-    workStore.incrementalCache?.revalidateTag(workStore.revalidatedTags || []),\n-    ...Object.values(workStore.pendingRevalidates || {}),\n-    ...(workStore.pendingRevalidateWrites || []),\n-  ])\n-\n   // If a tag was revalidated, the client router needs to invalidate all the\n   // client router cache as they may be stale. And if a path was revalidated, the\n   // client needs to invalidate all subtrees below that path.\n@@ -142,7 +136,7 @@ async function addRevalidationHeader(\n   // TODO-APP: Currently paths are treated as tags, so the second element of the tuple\n   // is always empty.\n \n-  const isTagRevalidated = workStore.revalidatedTags?.length ? 1 : 0\n+  const isTagRevalidated = workStore.pendingRevalidatedTags?.length ? 1 : 0\n   const isCookieRevalidated = getModifiedCookieValues(\n     requestStore.mutableCookies\n   ).length\n@@ -320,10 +314,10 @@ async function createRedirectRenderResult(\n       `${origin}${appRelativeRedirectUrl.pathname}${appRelativeRedirectUrl.search}`\n     )\n \n-    if (workStore.revalidatedTags) {\n+    if (workStore.pendingRevalidatedTags) {\n       forwardedHeaders.set(\n         NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n-        workStore.revalidatedTags.join(',')\n+        workStore.pendingRevalidatedTags.join(',')\n       )\n       forwardedHeaders.set(\n         NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n@@ -516,6 +510,17 @@ export async function handleAction({\n \n   requestStore.phase = 'action'\n \n+  const resolvePendingRevalidations = async () =>\n+    workUnitAsyncStorage.run(requestStore, () =>\n+      Promise.all([\n+        workStore.incrementalCache?.revalidateTag(\n+          workStore.pendingRevalidatedTags || []\n+        ),\n+        ...Object.values(workStore.pendingRevalidates || {}),\n+        ...(workStore.pendingRevalidateWrites || []),\n+      ])\n+    )\n+\n   // When running actions the default is no-store, you can still `cache: 'force-cache'`\n   workStore.fetchCache = 'default-no-store'\n \n@@ -567,13 +572,7 @@ export async function handleAction({\n \n       if (isFetchAction) {\n         res.statusCode = 500\n-        await Promise.all([\n-          workStore.incrementalCache?.revalidateTag(\n-            workStore.revalidatedTags || []\n-          ),\n-          ...Object.values(workStore.pendingRevalidates || {}),\n-          ...(workStore.pendingRevalidateWrites || []),\n-        ])\n+        await resolvePendingRevalidations()\n \n         const promise = Promise.reject(error)\n         try {\n@@ -928,10 +927,8 @@ export async function handleAction({\n \n       // For form actions, we need to continue rendering the page.\n       if (isFetchAction) {\n-        await addRevalidationHeader(res, {\n-          workStore,\n-          requestStore,\n-        })\n+        await resolvePendingRevalidations()\n+        addRevalidationHeader(res, { workStore, requestStore })\n \n         actionResult = await finalizeAndGenerateFlight(req, ctx, requestStore, {\n           actionResult: Promise.resolve(returnVal),\n@@ -952,10 +949,8 @@ export async function handleAction({\n       const redirectUrl = getURLFromRedirectError(err)\n       const redirectType = getRedirectTypeFromError(err)\n \n-      await addRevalidationHeader(res, {\n-        workStore,\n-        requestStore,\n-      })\n+      await resolvePendingRevalidations()\n+      addRevalidationHeader(res, { workStore, requestStore })\n \n       // if it's a fetch action, we'll set the status code for logging/debugging purposes\n       // but we won't set a Location header, as the redirect will be handled by the client router\n@@ -984,10 +979,8 @@ export async function handleAction({\n     } else if (isHTTPAccessFallbackError(err)) {\n       res.statusCode = getAccessFallbackHTTPStatus(err)\n \n-      await addRevalidationHeader(res, {\n-        workStore,\n-        requestStore,\n-      })\n+      await resolvePendingRevalidations()\n+      addRevalidationHeader(res, { workStore, requestStore })\n \n       if (isFetchAction) {\n         const promise = Promise.reject(err)\n@@ -1016,13 +1009,7 @@ export async function handleAction({\n \n     if (isFetchAction) {\n       res.statusCode = 500\n-      await Promise.all([\n-        workStore.incrementalCache?.revalidateTag(\n-          workStore.revalidatedTags || []\n-        ),\n-        ...Object.values(workStore.pendingRevalidates || {}),\n-        ...(workStore.pendingRevalidateWrites || []),\n-      ])\n+      await resolvePendingRevalidations()\n       const promise = Promise.reject(err)\n       try {\n         // we need to await the promise to trigger the rejection early"
        },
        {
            "sha": "bcd90c2465caa1f496529de96a9fae1bc88f2939",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 52,
            "deletions": 43,
            "changes": 95,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -70,7 +70,7 @@ import {\n   getRedirectStatusCodeFromError,\n } from '../../client/components/redirect'\n import { isRedirectError } from '../../client/components/redirect-error'\n-import { getImplicitTags } from '../lib/implicit-tags'\n+import { getImplicitTags, type ImplicitTags } from '../lib/implicit-tags'\n import { AppRenderSpan, NextNodeServerSpan } from '../lib/trace/constants'\n import { getTracer } from '../lib/trace/tracer'\n import { FlightRenderResult } from './flight-render-result'\n@@ -186,6 +186,7 @@ import type { MetadataErrorType } from '../../lib/metadata/resolve-metadata'\n import isError from '../../lib/is-error'\n import { isUseCacheTimeoutError } from '../use-cache/use-cache-errors'\n import { createServerInsertedMetadata } from './metadata-insertion/create-server-inserted-metadata'\n+import { getPreviouslyRevalidatedTags } from '../server-utils'\n \n export type GetDynamicParamFromSegment = (\n   // [slug] / [[slug]] / [...slug]\n@@ -229,6 +230,7 @@ export type AppRenderContext = {\n interface ParseRequestHeadersOptions {\n   readonly isDevWarmup: undefined | boolean\n   readonly isRoutePPREnabled: boolean\n+  readonly previewModeId: string | undefined\n }\n \n const flightDataPathHeadKey = 'h'\n@@ -247,6 +249,7 @@ interface ParsedRequestHeaders {\n   readonly isHmrRefresh: boolean\n   readonly isRSCRequest: boolean\n   readonly nonce: string | undefined\n+  readonly previouslyRevalidatedTags: string[]\n }\n \n function parseRequestHeaders(\n@@ -287,6 +290,11 @@ function parseRequestHeaders(\n   const nonce =\n     typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined\n \n+  const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(\n+    headers,\n+    options.previewModeId\n+  )\n+\n   return {\n     flightRouterState,\n     isPrefetchRequest,\n@@ -295,6 +303,7 @@ function parseRequestHeaders(\n     isRSCRequest,\n     isDevWarmupRequest,\n     nonce,\n+    previouslyRevalidatedTags,\n   }\n }\n \n@@ -698,7 +707,7 @@ async function warmupDevRender(\n     type: 'prerender',\n     phase: 'render',\n     rootParams,\n-    implicitTags: [],\n+    implicitTags: undefined,\n     renderSignal: renderController.signal,\n     controller: prerenderController,\n     cacheSignal,\n@@ -1157,7 +1166,6 @@ async function renderToHTMLOrFlightImpl(\n   parsedRequestHeaders: ParsedRequestHeaders,\n   requestEndedState: { ended?: boolean },\n   postponedState: PostponedState | null,\n-  implicitTags: Array<string>,\n   serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n   sharedContext: AppSharedContext\n ) {\n@@ -1332,6 +1340,12 @@ async function renderToHTMLOrFlightImpl(\n \n   getTracer().setRootSpanAttribute('next.route', pagePath)\n \n+  const implicitTags = await getImplicitTags(\n+    workStore.page,\n+    url,\n+    fallbackRouteParams\n+  )\n+\n   if (isStaticGeneration) {\n     // We're either building or revalidating. In either case we need to\n     // prerender our page rather than render it.\n@@ -1391,11 +1405,11 @@ async function renderToHTMLOrFlightImpl(\n     if (\n       workStore.pendingRevalidates ||\n       workStore.pendingRevalidateWrites ||\n-      workStore.revalidatedTags\n+      workStore.pendingRevalidatedTags\n     ) {\n       const pendingPromise = Promise.all([\n         workStore.incrementalCache?.revalidateTag(\n-          workStore.revalidatedTags || []\n+          workStore.pendingRevalidatedTags || []\n         ),\n         ...Object.values(workStore.pendingRevalidates || {}),\n         ...(workStore.pendingRevalidateWrites || []),\n@@ -1566,11 +1580,11 @@ async function renderToHTMLOrFlightImpl(\n     if (\n       workStore.pendingRevalidates ||\n       workStore.pendingRevalidateWrites ||\n-      workStore.revalidatedTags\n+      workStore.pendingRevalidatedTags\n     ) {\n       const pendingPromise = Promise.all([\n         workStore.incrementalCache?.revalidateTag(\n-          workStore.revalidatedTags || []\n+          workStore.pendingRevalidatedTags || []\n         ),\n         ...Object.values(workStore.pendingRevalidates || {}),\n         ...(workStore.pendingRevalidateWrites || []),\n@@ -1626,9 +1640,10 @@ export const renderToHTMLOrFlight: AppPageRender = (\n   const parsedRequestHeaders = parseRequestHeaders(req.headers, {\n     isDevWarmup,\n     isRoutePPREnabled: renderOpts.experimental.isRoutePPREnabled === true,\n+    previewModeId: renderOpts.previewProps?.previewModeId,\n   })\n \n-  const { isPrefetchRequest } = parsedRequestHeaders\n+  const { isPrefetchRequest, previouslyRevalidatedTags } = parsedRequestHeaders\n \n   const requestEndedState = { ended: false }\n   let postponedState: PostponedState | null = null\n@@ -1657,12 +1672,6 @@ export const renderToHTMLOrFlight: AppPageRender = (\n     )\n   }\n \n-  const implicitTags = getImplicitTags(\n-    renderOpts.routeModule.definition.page,\n-    url,\n-    fallbackRouteParams\n-  )\n-\n   const workStore = createWorkStore({\n     page: renderOpts.routeModule.definition.page,\n     fallbackRouteParams,\n@@ -1671,6 +1680,7 @@ export const renderToHTMLOrFlight: AppPageRender = (\n     // @TODO move to workUnitStore of type Request\n     isPrefetchRequest,\n     buildId: sharedContext.buildId,\n+    previouslyRevalidatedTags,\n   })\n \n   return workAsyncStorage.run(\n@@ -1688,7 +1698,6 @@ export const renderToHTMLOrFlight: AppPageRender = (\n     parsedRequestHeaders,\n     requestEndedState,\n     postponedState,\n-    implicitTags,\n     serverComponentsHmrCache,\n     sharedContext\n   )\n@@ -2213,7 +2222,7 @@ async function spawnDynamicValidationInDev(\n     type: 'prerender',\n     phase: 'render',\n     rootParams,\n-    implicitTags: [],\n+    implicitTags: undefined,\n     renderSignal: initialServerRenderController.signal,\n     controller: initialServerPrerenderController,\n     cacheSignal,\n@@ -2230,7 +2239,7 @@ async function spawnDynamicValidationInDev(\n     type: 'prerender',\n     phase: 'render',\n     rootParams,\n-    implicitTags: [],\n+    implicitTags: undefined,\n     renderSignal: initialClientController.signal,\n     controller: initialClientController,\n     cacheSignal,\n@@ -2376,7 +2385,7 @@ async function spawnDynamicValidationInDev(\n     type: 'prerender',\n     phase: 'render',\n     rootParams,\n-    implicitTags: [],\n+    implicitTags: undefined,\n     renderSignal: finalServerController.signal,\n     controller: finalServerController,\n     // During the final prerender we don't need to track cache access so we omit the signal\n@@ -2397,7 +2406,7 @@ async function spawnDynamicValidationInDev(\n     type: 'prerender',\n     phase: 'render',\n     rootParams,\n-    implicitTags: [],\n+    implicitTags: undefined,\n     renderSignal: finalClientController.signal,\n     controller: finalClientController,\n     // During the final prerender we don't need to track cache access so we omit the signal\n@@ -2568,7 +2577,7 @@ async function prerenderToStream(\n   metadata: AppPageRenderResultMetadata,\n   workStore: WorkStore,\n   tree: LoaderTree,\n-  implicitTags: Array<string>\n+  implicitTags: ImplicitTags\n ): Promise<PrerenderToStreamResult> {\n   // When prerendering formState is always null. We still include it\n   // because some shared APIs expect a formState value and this is slightly\n@@ -2724,15 +2733,15 @@ async function prerenderToStream(\n           type: 'prerender',\n           phase: 'render',\n           rootParams,\n-          implicitTags: implicitTags,\n+          implicitTags,\n           renderSignal: initialServerRenderController.signal,\n           controller: initialServerPrerenderController,\n           cacheSignal,\n           dynamicTracking: null,\n           revalidate: INFINITE_CACHE,\n           expire: INFINITE_CACHE,\n           stale: INFINITE_CACHE,\n-          tags: [...implicitTags],\n+          tags: [...implicitTags.tags],\n           prerenderResumeDataCache,\n         })\n \n@@ -2818,15 +2827,15 @@ async function prerenderToStream(\n             type: 'prerender',\n             phase: 'render',\n             rootParams,\n-            implicitTags: implicitTags,\n+            implicitTags,\n             renderSignal: initialClientController.signal,\n             controller: initialClientController,\n             cacheSignal: null,\n             dynamicTracking: null,\n             revalidate: INFINITE_CACHE,\n             expire: INFINITE_CACHE,\n             stale: INFINITE_CACHE,\n-            tags: [...implicitTags],\n+            tags: [...implicitTags.tags],\n             prerenderResumeDataCache,\n           }\n \n@@ -2903,7 +2912,7 @@ async function prerenderToStream(\n           type: 'prerender',\n           phase: 'render',\n           rootParams,\n-          implicitTags: implicitTags,\n+          implicitTags,\n           renderSignal: finalServerController.signal,\n           controller: finalServerController,\n           // During the final prerender we don't need to track cache access so we omit the signal\n@@ -2912,7 +2921,7 @@ async function prerenderToStream(\n           revalidate: INFINITE_CACHE,\n           expire: INFINITE_CACHE,\n           stale: INFINITE_CACHE,\n-          tags: [...implicitTags],\n+          tags: [...implicitTags.tags],\n           prerenderResumeDataCache,\n         })\n \n@@ -2972,7 +2981,7 @@ async function prerenderToStream(\n           type: 'prerender',\n           phase: 'render',\n           rootParams,\n-          implicitTags: implicitTags,\n+          implicitTags,\n           renderSignal: finalClientController.signal,\n           controller: finalClientController,\n           // For HTML Generation we don't need to track cache reads (RSC only)\n@@ -2981,7 +2990,7 @@ async function prerenderToStream(\n           revalidate: INFINITE_CACHE,\n           expire: INFINITE_CACHE,\n           stale: INFINITE_CACHE,\n-          tags: [...implicitTags],\n+          tags: [...implicitTags.tags],\n           prerenderResumeDataCache,\n         }\n \n@@ -3207,15 +3216,15 @@ async function prerenderToStream(\n           type: 'prerender',\n           phase: 'render',\n           rootParams,\n-          implicitTags: implicitTags,\n+          implicitTags,\n           renderSignal: initialServerRenderController.signal,\n           controller: initialServerPrerenderController,\n           cacheSignal,\n           dynamicTracking: null,\n           revalidate: INFINITE_CACHE,\n           expire: INFINITE_CACHE,\n           stale: INFINITE_CACHE,\n-          tags: [...implicitTags],\n+          tags: [...implicitTags.tags],\n           prerenderResumeDataCache,\n         })\n \n@@ -3224,15 +3233,15 @@ async function prerenderToStream(\n           type: 'prerender',\n           phase: 'render',\n           rootParams,\n-          implicitTags: implicitTags,\n+          implicitTags,\n           renderSignal: initialClientController.signal,\n           controller: initialClientController,\n           cacheSignal,\n           dynamicTracking: null,\n           revalidate: INFINITE_CACHE,\n           expire: INFINITE_CACHE,\n           stale: INFINITE_CACHE,\n-          tags: [...implicitTags],\n+          tags: [...implicitTags.tags],\n           prerenderResumeDataCache,\n         })\n \n@@ -3376,7 +3385,7 @@ async function prerenderToStream(\n           type: 'prerender',\n           phase: 'render',\n           rootParams,\n-          implicitTags: implicitTags,\n+          implicitTags,\n           renderSignal: finalServerController.signal,\n           controller: finalServerController,\n           // During the final prerender we don't need to track cache access so we omit the signal\n@@ -3385,7 +3394,7 @@ async function prerenderToStream(\n           revalidate: INFINITE_CACHE,\n           expire: INFINITE_CACHE,\n           stale: INFINITE_CACHE,\n-          tags: [...implicitTags],\n+          tags: [...implicitTags.tags],\n           prerenderResumeDataCache,\n         })\n \n@@ -3400,7 +3409,7 @@ async function prerenderToStream(\n           type: 'prerender',\n           phase: 'render',\n           rootParams,\n-          implicitTags: implicitTags,\n+          implicitTags,\n           renderSignal: finalClientController.signal,\n           controller: finalClientController,\n           // During the final prerender we don't need to track cache access so we omit the signal\n@@ -3409,7 +3418,7 @@ async function prerenderToStream(\n           revalidate: INFINITE_CACHE,\n           expire: INFINITE_CACHE,\n           stale: INFINITE_CACHE,\n-          tags: [...implicitTags],\n+          tags: [...implicitTags.tags],\n           prerenderResumeDataCache,\n         })\n \n@@ -3595,12 +3604,12 @@ async function prerenderToStream(\n         type: 'prerender-ppr',\n         phase: 'render',\n         rootParams,\n-        implicitTags: implicitTags,\n+        implicitTags,\n         dynamicTracking,\n         revalidate: INFINITE_CACHE,\n         expire: INFINITE_CACHE,\n         stale: INFINITE_CACHE,\n-        tags: [...implicitTags],\n+        tags: [...implicitTags.tags],\n         prerenderResumeDataCache,\n       })\n       const RSCPayload = await workUnitAsyncStorage.run(\n@@ -3628,12 +3637,12 @@ async function prerenderToStream(\n         type: 'prerender-ppr',\n         phase: 'render',\n         rootParams,\n-        implicitTags: implicitTags,\n+        implicitTags,\n         dynamicTracking,\n         revalidate: INFINITE_CACHE,\n         expire: INFINITE_CACHE,\n         stale: INFINITE_CACHE,\n-        tags: [...implicitTags],\n+        tags: [...implicitTags.tags],\n         prerenderResumeDataCache,\n       }\n       const prerender = require('react-dom/static.edge')\n@@ -3818,11 +3827,11 @@ async function prerenderToStream(\n         type: 'prerender-legacy',\n         phase: 'render',\n         rootParams,\n-        implicitTags: implicitTags,\n+        implicitTags,\n         revalidate: INFINITE_CACHE,\n         expire: INFINITE_CACHE,\n         stale: INFINITE_CACHE,\n-        tags: [...implicitTags],\n+        tags: [...implicitTags.tags],\n       })\n       // This is a regular static generation. We don't do dynamic tracking because we rely on\n       // the old-school dynamic error handling to bail out of static generation\n@@ -3991,7 +4000,7 @@ async function prerenderToStream(\n         typeof prerenderStore?.stale !== 'undefined'\n           ? prerenderStore.stale\n           : INFINITE_CACHE,\n-      tags: [...(prerenderStore?.tags || implicitTags)],\n+      tags: [...(prerenderStore?.tags || implicitTags.tags)],\n     })\n     const errorRSCPayload = await workUnitAsyncStorage.run(\n       prerenderLegacyStore,"
        },
        {
            "sha": "5e7bdfae6dccbfa1ceb17ca561279a7f7624674b",
            "filename": "packages/next/src/server/app-render/work-async-storage.external.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-async-storage.external.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -54,7 +54,15 @@ export interface WorkStore {\n   nextFetchId?: number\n   pathWasRevalidated?: boolean\n \n-  revalidatedTags?: string[]\n+  // Tags that were revalidated during the current request. They need to be sent\n+  // to cache handlers to propagate their revalidation.\n+  pendingRevalidatedTags?: string[]\n+\n+  // Tags that were previously revalidated (e.g. by a redirecting server action)\n+  // and have already been sent to cache handlers. Retrieved cache entries that\n+  // include any of these tags must be discarded.\n+  readonly previouslyRevalidatedTags: readonly string[]\n+\n   fetchMetrics?: FetchMetrics\n \n   isDraftMode?: boolean"
        },
        {
            "sha": "dc1419be4ab2d3217eb778a603d7204df3250bd3",
            "filename": "packages/next/src/server/app-render/work-unit-async-storage.external.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 19,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -14,15 +14,17 @@ import type {\n   PrerenderResumeDataCache,\n } from '../resume-data-cache/resume-data-cache'\n import type { Params } from '../request/params'\n+import type { ImplicitTags } from '../lib/implicit-tags'\n \n-type WorkUnitPhase = 'action' | 'render' | 'after'\n+export type WorkUnitPhase = 'action' | 'render' | 'after'\n \n-type PhasePartial = {\n+export interface CommonWorkUnitStore {\n   /** NOTE: Will be mutated as phases change */\n   phase: WorkUnitPhase\n+  readonly implicitTags: ImplicitTags | undefined\n }\n \n-export type RequestStore = {\n+export interface RequestStore extends CommonWorkUnitStore {\n   type: 'request'\n \n   /**\n@@ -52,7 +54,6 @@ export type RequestStore = {\n   readonly isHmrRefresh?: boolean\n   readonly serverComponentsHmrCache?: ServerComponentsHmrCache\n \n-  readonly implicitTags: string[]\n   readonly rootParams: Params\n \n   /**\n@@ -63,7 +64,7 @@ export type RequestStore = {\n   // DEV-only\n   usedDynamic?: boolean\n   prerenderPhase?: boolean\n-} & PhasePartial\n+}\n \n /**\n  * The Prerender store is for tracking information related to prerenders.\n@@ -75,9 +76,8 @@ export type RequestStore = {\n  * only needs to happen during the RSC prerender when we are prospectively prerendering\n  * to fill all caches.\n  */\n-export type PrerenderStoreModern = {\n+export interface PrerenderStoreModern extends CommonWorkUnitStore {\n   type: 'prerender'\n-  readonly implicitTags: string[]\n \n   /**\n    * This signal is aborted when the React render is complete. (i.e. it is the same signal passed to react)\n@@ -120,12 +120,11 @@ export type PrerenderStoreModern = {\n   // not part of the primary render path and are just prerendering to produce\n   // validation results\n   validating?: boolean\n-} & PhasePartial\n+}\n \n-export type PrerenderStorePPR = {\n+export interface PrerenderStorePPR extends CommonWorkUnitStore {\n   type: 'prerender-ppr'\n   readonly rootParams: Params\n-  readonly implicitTags: string[]\n   readonly dynamicTracking: null | DynamicTrackingState\n   // Collected revalidate times and tags for this document during the prerender.\n   revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n@@ -137,27 +136,25 @@ export type PrerenderStorePPR = {\n    * The resume data cache for this prerender.\n    */\n   prerenderResumeDataCache: PrerenderResumeDataCache\n-} & PhasePartial\n+}\n \n-export type PrerenderStoreLegacy = {\n+export interface PrerenderStoreLegacy extends CommonWorkUnitStore {\n   type: 'prerender-legacy'\n   readonly rootParams: Params\n-  readonly implicitTags: string[]\n   // Collected revalidate times and tags for this document during the prerender.\n   revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n   expire: number // server expiration time\n   stale: number // client expiration time\n   tags: null | string[]\n-} & PhasePartial\n+}\n \n export type PrerenderStore =\n   | PrerenderStoreLegacy\n   | PrerenderStorePPR\n   | PrerenderStoreModern\n \n-export type UseCacheStore = {\n+export interface UseCacheStore extends CommonWorkUnitStore {\n   type: 'cache'\n-  readonly implicitTags: string[]\n   // Collected revalidate times and tags for this cache entry during the cache render.\n   revalidate: number // implicit revalidate time from inner caches / fetches\n   expire: number // server expiration time\n@@ -170,11 +167,11 @@ export type UseCacheStore = {\n   readonly isHmrRefresh: boolean\n   readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n   readonly forceRevalidate: boolean\n-} & PhasePartial\n+}\n \n-export type UnstableCacheStore = {\n+export interface UnstableCacheStore extends CommonWorkUnitStore {\n   type: 'unstable-cache'\n-} & PhasePartial\n+}\n \n /**\n  * The Cache store is for tracking information inside a \"use cache\" or unstable_cache context."
        },
        {
            "sha": "92083b6152dc814493fd4e9474fdc6d6554eab47",
            "filename": "packages/next/src/server/async-storage/request-store.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -23,6 +23,7 @@ import { splitCookiesString } from '../web/utils'\n import type { ServerComponentsHmrCache } from '../response-cache'\n import type { RenderResumeDataCache } from '../resume-data-cache/resume-data-cache'\n import type { Params } from '../request/params'\n+import type { ImplicitTags } from '../lib/implicit-tags'\n \n function getHeaders(headers: Headers | IncomingHttpHeaders): ReadonlyHeaders {\n   const cleaned = HeadersAdapter.from(headers)\n@@ -67,7 +68,7 @@ type RequestContext = RequestResponsePair & {\n   renderOpts?: WrapperRenderOpts\n   isHmrRefresh?: boolean\n   serverComponentsHmrCache?: ServerComponentsHmrCache\n-  implicitTags?: string[] | undefined\n+  implicitTags: ImplicitTags | undefined\n }\n \n type RequestResponsePair =\n@@ -184,7 +185,7 @@ function createRequestStoreImpl(\n   return {\n     type: 'request',\n     phase,\n-    implicitTags: implicitTags ?? [],\n+    implicitTags,\n     // Rather than just using the whole `url` here, we pull the parts we want\n     // to ensure we don't use parts of the URL that we shouldn't. This also\n     // lets us avoid requiring an empty string for `search` in the type."
        },
        {
            "sha": "87ffd3d0db2e00be45b8e7047e6fb66c45969ac9",
            "filename": "packages/next/src/server/async-storage/work-store.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Fwork-store.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Fwork-store.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Fwork-store.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -70,6 +70,10 @@ export type WorkStoreContext = {\n    * The build ID of the current build.\n    */\n   buildId: string\n+\n+  // Tags that were previously revalidated (e.g. by a redirecting server action)\n+  // and have already been sent to cache handlers.\n+  previouslyRevalidatedTags: string[]\n }\n \n export function createWorkStore({\n@@ -79,6 +83,7 @@ export function createWorkStore({\n   requestEndedState,\n   isPrefetchRequest,\n   buildId,\n+  previouslyRevalidatedTags,\n }: WorkStoreContext): WorkStore {\n   /**\n    * Rules of Static & Dynamic HTML:\n@@ -129,6 +134,7 @@ export function createWorkStore({\n     afterContext: createAfterContext(renderOpts),\n     dynamicIOEnabled: renderOpts.experimental.dynamicIO,\n     dev: renderOpts.dev ?? false,\n+    previouslyRevalidatedTags,\n   }\n \n   // TODO: remove this when we resolve accessing the store outside the execution context"
        },
        {
            "sha": "dbf2a4519bab651971f0e10c743fccb1910f652d",
            "filename": "packages/next/src/server/base-server.ts",
            "status": "modified",
            "additions": 19,
            "deletions": 15,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fbase-server.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -84,7 +84,7 @@ import RenderResult from './render-result'\n import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\n import { denormalizePagePath } from '../shared/lib/page-path/denormalize-page-path'\n import * as Log from '../build/output/log'\n-import { getUtils } from './server-utils'\n+import { getPreviouslyRevalidatedTags, getUtils } from './server-utils'\n import isError, { getProperError } from '../lib/is-error'\n import {\n   addRequestMeta,\n@@ -131,7 +131,6 @@ import {\n   CACHE_ONE_YEAR,\n   INFINITE_CACHE,\n   MATCHED_PATH_HEADER,\n-  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n   NEXT_CACHE_TAGS_HEADER,\n   NEXT_RESUME_HEADER,\n } from '../lib/constants'\n@@ -176,9 +175,9 @@ import {\n   shouldServeStreamingMetadata,\n   isHtmlBotRequest,\n } from './lib/streaming-metadata'\n-import { getCacheHandlers } from './use-cache/handlers'\n import { InvariantError } from '../shared/lib/invariant-error'\n import { decodeQueryPathParameter } from './lib/decode-query-path-parameter'\n+import { getCacheHandlers } from './use-cache/handlers'\n \n export type FindComponentsResult = {\n   components: LoadComponentsReturnType\n@@ -1434,20 +1433,25 @@ export default abstract class Server<\n         ;(globalThis as any).__incrementalCache = incrementalCache\n       }\n \n-      // If the header is present, receive the expired tags from all the\n-      // cache handlers.\n-      const handlers = getCacheHandlers()\n-      if (handlers) {\n-        const header = req.headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER]\n-        const expiredTags = typeof header === 'string' ? header.split(',') : []\n+      const cacheHandlers = getCacheHandlers()\n \n-        const promises: Promise<void>[] = []\n-        for (const handler of handlers) {\n-          promises.push(handler.receiveExpiredTags(...expiredTags))\n-        }\n+      if (cacheHandlers) {\n+        await Promise.all(\n+          [...cacheHandlers].map(async (cacheHandler) => {\n+            if ('refreshTags' in cacheHandler) {\n+              await cacheHandler.refreshTags()\n+            } else {\n+              const previouslyRevalidatedTags = getPreviouslyRevalidatedTags(\n+                req.headers,\n+                this.getPrerenderManifest().preview.previewModeId\n+              )\n \n-        // Only await if there are any promises to wait for.\n-        if (promises.length > 0) await Promise.all(promises)\n+              await cacheHandler.receiveExpiredTags(\n+                ...previouslyRevalidatedTags\n+              )\n+            }\n+          })\n+        )\n       }\n \n       // set server components HMR cache to request meta so it can be passed"
        },
        {
            "sha": "c4bb3f7050e420ce08977e83e2e35fc31055cef5",
            "filename": "packages/next/src/server/lib/cache-handlers/default.ts",
            "status": "modified",
            "additions": 29,
            "deletions": 26,
            "changes": 55,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fcache-handlers%2Fdefault.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fcache-handlers%2Fdefault.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fcache-handlers%2Fdefault.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -1,11 +1,16 @@\n-/*\n-  This is the default \"use cache\" handler it defaults\n-  to an in memory store\n-*/\n+/**\n+ * This is the default \"use cache\" handler it defaults to an in-memory store.\n+ * In-memory caches are fragile and should not use stale-while-revalidate\n+ * semantics on the caches because it's not worth warming up an entry that's\n+ * likely going to get evicted before we get to use it anyway. However, we also\n+ * don't want to reuse a stale entry for too long so stale entries should be\n+ * considered expired/missing in such cache handlers.\n+ */\n+\n import { LRUCache } from '../lru-cache'\n-import type { CacheEntry, CacheHandler } from './types'\n+import type { CacheEntry, CacheHandlerV2 } from './types'\n import {\n-  isTagStale,\n+  isStale,\n   tagsManifest,\n } from '../incremental-cache/tags-manifest.external'\n \n@@ -36,8 +41,8 @@ const memoryCache = new LRUCache<PrivateCacheEntry>(\n )\n const pendingSets = new Map<string, Promise<void>>()\n \n-const DefaultCacheHandler: CacheHandler = {\n-  async get(cacheKey, softTags) {\n+const DefaultCacheHandler: CacheHandlerV2 = {\n+  async get(cacheKey) {\n     await pendingSets.get(cacheKey)\n \n     const privateEntry = memoryCache.get(cacheKey)\n@@ -51,15 +56,13 @@ const DefaultCacheHandler: CacheHandler = {\n       performance.timeOrigin + performance.now() >\n       entry.timestamp + entry.revalidate * 1000\n     ) {\n-      // In memory caches should expire after revalidate time because it is unlikely that\n-      // a new entry will be able to be used before it is dropped from the cache.\n+      // In-memory caches should expire after revalidate time because it is\n+      // unlikely that a new entry will be able to be used before it is dropped\n+      // from the cache.\n       return undefined\n     }\n \n-    if (\n-      isTagStale(entry.tags, entry.timestamp) ||\n-      isTagStale(softTags, entry.timestamp)\n-    ) {\n+    if (isStale(entry.tags, entry.timestamp)) {\n       return undefined\n     }\n     const [returnStream, newSaved] = entry.value.tee()\n@@ -105,22 +108,22 @@ const DefaultCacheHandler: CacheHandler = {\n     }\n   },\n \n+  async refreshTags() {\n+    // Nothing to do for an in-memory cache handler.\n+  },\n+\n+  async getExpiration(...tags) {\n+    return Math.max(...tags.map((tag) => tagsManifest.get(tag) ?? 0))\n+  },\n+\n   async expireTags(...tags) {\n+    const timestamp = Math.round(performance.timeOrigin + performance.now())\n+\n     for (const tag of tags) {\n-      if (!tagsManifest.items[tag]) {\n-        tagsManifest.items[tag] = {}\n-      }\n-      // TODO: use performance.now and update file-system-cache?\n-      tagsManifest.items[tag].revalidatedAt = Date.now()\n+      // TODO: update file-system-cache?\n+      tagsManifest.set(tag, timestamp)\n     }\n   },\n-\n-  // This is only meant to invalidate in memory tags\n-  // not meant to be propagated like expireTags would\n-  // in multi-instance scenario\n-  async receiveExpiredTags(...tags): Promise<void> {\n-    return this.expireTags(...tags)\n-  },\n }\n \n export default DefaultCacheHandler"
        },
        {
            "sha": "8cab966d6902d4585f161c299811b822a830b474",
            "filename": "packages/next/src/server/lib/cache-handlers/types.ts",
            "status": "modified",
            "additions": 89,
            "deletions": 22,
            "changes": 111,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fcache-handlers%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fcache-handlers%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fcache-handlers%2Ftypes.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -1,15 +1,13 @@\n-// In-memory caches are fragile and should not use stale-while-revalidate\n-// semantics on the caches because it's not worth warming up an entry that's\n-// likely going to get evicted before we get to use it anyway. However,\n-// we also don't want to reuse a stale entry for too long so stale entries\n-// should be considered expired/missing in such CacheHandlers.\n+/**\n+ * A timestamp in milliseconds elapsed since the epoch\n+ */\n+export type Timestamp = number\n \n-// This is the entry we store\n export interface CacheEntry {\n   /**\n-   * The ReadableStream can error and only have partial\n-   * data so any cache handlers need to handle this case\n-   * and decide to keep the partial cache around or not\n+   * The ReadableStream can error and only have partial data so any cache\n+   * handlers need to handle this case and decide to keep the partial cache\n+   * around or not.\n    */\n   value: ReadableStream<Uint8Array>\n \n@@ -19,40 +17,109 @@ export interface CacheEntry {\n   tags: string[]\n \n   /**\n-   * This is for the client not used to calculate cache entry expiration\n+   * This is for the client, not used to calculate cache entry expiration\n+   * [duration in seconds]\n    */\n   stale: number\n \n   /**\n-   * When the cache entry was created\n+   * When the cache entry was created [timestamp in milliseconds]\n    */\n-  timestamp: number\n+  timestamp: Timestamp\n \n   /**\n-   * How long the entry can last (should be longer than revalidate)\n+   * How long the entry is allowed to be used (should be longer than revalidate)\n+   * [duration in seconds]\n    */\n   expire: number\n \n   /**\n-   * How long until the entry should revalidate\n+   * How long until the entry should be revalidated [duration in seconds]\n    */\n   revalidate: number\n }\n \n+/**\n+ * @deprecated Use {@link CacheHandlerV2} instead.\n+ */\n export interface CacheHandler {\n+  /**\n+   * Retrieve a cache entry for the given cache key, if available. The softTags\n+   * should be used to check for staleness.\n+   */\n   get(cacheKey: string, softTags: string[]): Promise<undefined | CacheEntry>\n \n+  /**\n+   * Store a cache entry for the given cache key. When this is called, the entry\n+   * may still be pending, i.e. its value stream may still be written to. So it\n+   * needs to be awaited first. If a `get` for the same cache key is called\n+   * before the pending entry is complete, the cache handler must wait for the\n+   * `set` operation to finish, before returning the entry, instead of returning\n+   * undefined.\n+   */\n   set(cacheKey: string, entry: Promise<CacheEntry>): Promise<void>\n \n-  // This is called when expireTags('') is called\n-  // and should update tags manifest accordingly\n+  /**\n+   * Next.js will call this method when `revalidateTag` or `revalidatePath()` is\n+   * called. It should update the tags manifest accordingly.\n+   */\n   expireTags(...tags: string[]): Promise<void>\n \n-  // This is called when an action request sends\n-  // NEXT_CACHE_REVALIDATED_TAGS_HEADER and tells\n-  // us these tags are expired and the manifest\n-  // should be updated this differs since in a multi\n-  // instance environment you don't propagate these\n-  // as they are request specific\n+  /**\n+   * The `receiveExpiredTags` method is called when an action request sends the\n+   * 'x-next-revalidated-tags' header to indicate which tags have been expired\n+   * by the action. The local tags manifest should be updated accordingly. As\n+   * opposed to `expireTags`, the tags don't need to be propagated to a tags\n+   * service, as this was already done by the server action.\n+   */\n   receiveExpiredTags(...tags: string[]): Promise<void>\n }\n+\n+export interface CacheHandlerV2 {\n+  /**\n+   * Retrieve a cache entry for the given cache key, if available.\n+   */\n+  get(cacheKey: string): Promise<undefined | CacheEntry>\n+\n+  /**\n+   * Store a cache entry for the given cache key. When this is called, the entry\n+   * may still be pending, i.e. its value stream may still be written to. So it\n+   * needs to be awaited first. If a `get` for the same cache key is called\n+   * before the pending entry is complete, the cache handler must wait for the\n+   * `set` operation to finish, before returning the entry, instead of returning\n+   * undefined.\n+   */\n+  set(cacheKey: string, pendingEntry: Promise<CacheEntry>): Promise<void>\n+\n+  /**\n+   * Next.js will call this method periodically, but always before starting a\n+   * new request. When working with a remote tags service, this method should\n+   * communicate with the tags service to refresh the local tags manifest\n+   * accordingly.\n+   */\n+  refreshTags(): Promise<void>\n+\n+  /**\n+   * Next.js will call this method for each set of soft tags that are relevant\n+   * at the start of a request. The result is the maximum timestamp of a\n+   * revalidate event for the tags. Returns `0` if none of the tags were ever\n+   * revalidated.\n+   */\n+  getExpiration(...tags: string[]): Promise<Timestamp>\n+\n+  /**\n+   * Next.js will call this method when `revalidateTag` or `revalidatePath()` is\n+   * called. It should update the tags manifest accordingly.\n+   */\n+  expireTags(...tags: string[]): Promise<void>\n+}\n+\n+/**\n+ * This is a compatibility type to ease migration between cache handler\n+ * versions. Until the old `CacheHandler` type is removed, this type should be\n+ * used for all internal Next.js functions that deal with cache handlers to\n+ * ensure that we are compatible with both cache handler versions. An exception\n+ * is the built-in default cache handler, which implements the\n+ * {@link CacheHandlerV2} interface.\n+ */\n+export type CacheHandlerCompat = CacheHandler | CacheHandlerV2"
        },
        {
            "sha": "5537f30301989a5ff2f52f4e285dc764014e7591",
            "filename": "packages/next/src/server/lib/implicit-tags.ts",
            "status": "modified",
            "additions": 63,
            "deletions": 6,
            "changes": 69,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fimplicit-tags.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fimplicit-tags.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fimplicit-tags.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -1,5 +1,20 @@\n import { NEXT_CACHE_IMPLICIT_TAG_ID } from '../../lib/constants'\n import type { FallbackRouteParams } from '../request/fallback-params'\n+import { getCacheHandlers } from '../use-cache/handlers'\n+\n+export interface ImplicitTags {\n+  /**\n+   * For legacy usage, the implicit tags are passed to the incremental cache\n+   * handler in `get` calls.\n+   */\n+  readonly tags: string[]\n+  /**\n+   * Modern cache handlers don't receive implicit tags. Instead, the\n+   * implicit tags' expiration is stored in the work unit store, and used to\n+   * compare with a cache entry's timestamp.\n+   */\n+  expiration: number\n+}\n \n const getDerivedTags = (pathname: string): string[] => {\n   const derivedTags: string[] = [`/layout`]\n@@ -26,32 +41,74 @@ const getDerivedTags = (pathname: string): string[] => {\n   return derivedTags\n }\n \n-export function getImplicitTags(\n+async function getImplicitTagsExpiration(tags: string[]): Promise<number> {\n+  // We're starting off with assuming that implicit tags are not expired, so we\n+  // use an artificial timestamp of 0.\n+  let expiration = 0\n+\n+  const cacheHandlers = getCacheHandlers()\n+\n+  if (cacheHandlers) {\n+    const expirations = await Promise.all(\n+      [...cacheHandlers].map(async (handler) => {\n+        if ('getExpiration' in handler) {\n+          return handler.getExpiration(...tags)\n+        }\n+\n+        // Use 0 as fallback of legacy cache handlers. We don't need to track\n+        // the expiration of implicit tags for those, because they're passed\n+        // into the `get()` method and are checked internally by the cache\n+        // handler.\n+        return 0\n+      })\n+    )\n+\n+    // We use the most recent expiration from all cache handlers, i.e. the\n+    // largest timestamp. Semantically, they should all be the same though.\n+    expiration = Math.max(...expirations)\n+  }\n+\n+  return expiration\n+}\n+\n+/**\n+ * Fetches a new expiration value for the given `implicitTags`, and mutates its\n+ * `expiration` property.\n+ */\n+export async function updateImplicitTagsExpiration(\n+  implicitTags: ImplicitTags\n+): Promise<void> {\n+  implicitTags.expiration = await getImplicitTagsExpiration(implicitTags.tags)\n+}\n+\n+export async function getImplicitTags(\n   page: string,\n   url: {\n     pathname: string\n     search?: string\n   },\n   fallbackRouteParams: null | FallbackRouteParams\n-) {\n+): Promise<ImplicitTags> {\n   // TODO: Cache the result\n-  const newTags: string[] = []\n+  const tags: string[] = []\n   const hasFallbackRouteParams =\n     fallbackRouteParams && fallbackRouteParams.size > 0\n \n   // Add the derived tags from the page.\n   const derivedTags = getDerivedTags(page)\n   for (let tag of derivedTags) {\n     tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${tag}`\n-    newTags.push(tag)\n+    tags.push(tag)\n   }\n \n   // Add the tags from the pathname. If the route has unknown params, we don't\n   // want to add the pathname as a tag, as it will be invalid.\n   if (url.pathname && !hasFallbackRouteParams) {\n     const tag = `${NEXT_CACHE_IMPLICIT_TAG_ID}${url.pathname}`\n-    newTags.push(tag)\n+    tags.push(tag)\n   }\n \n-  return newTags\n+  const expiration = await getImplicitTagsExpiration(tags)\n+\n+  return { tags, expiration }\n }"
        },
        {
            "sha": "cbfd3fcff5e84e8231daad5426889a3bfdb918bd",
            "filename": "packages/next/src/server/lib/incremental-cache/file-system-cache.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 18,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -21,7 +21,7 @@ import {\n   RSC_SEGMENTS_DIR_SUFFIX,\n   RSC_SUFFIX,\n } from '../../../lib/constants'\n-import { tagsManifest } from './tags-manifest.external'\n+import { isStale, tagsManifest } from './tags-manifest.external'\n import { MultiFileWriter } from '../../../lib/multi-file-writer'\n \n type FileSystemCacheContext = Omit<\n@@ -101,9 +101,9 @@ export default class FileSystemCache implements CacheHandler {\n     }\n \n     for (const tag of tags) {\n-      const data = tagsManifest.items[tag] || {}\n-      data.revalidatedAt = Date.now()\n-      tagsManifest.items[tag] = data\n+      if (!tagsManifest.has(tag)) {\n+        tagsManifest.set(tag, Date.now())\n+      }\n     }\n   }\n \n@@ -310,18 +310,10 @@ export default class FileSystemCache implements CacheHandler {\n       }\n \n       if (cacheTags?.length) {\n-        const isStale = cacheTags.some((tag) => {\n-          return (\n-            tagsManifest?.items[tag]?.revalidatedAt &&\n-            tagsManifest?.items[tag].revalidatedAt >=\n-              (data?.lastModified || Date.now())\n-          )\n-        })\n-\n         // we trigger a blocking validation if an ISR page\n         // had a tag revalidated, if we want to be a background\n         // revalidation instead we return data.lastModified = -1\n-        if (isStale) {\n+        if (isStale(cacheTags, data?.lastModified || Date.now())) {\n           return null\n         }\n       }\n@@ -336,11 +328,7 @@ export default class FileSystemCache implements CacheHandler {\n           return true\n         }\n \n-        return (\n-          tagsManifest?.items[tag]?.revalidatedAt &&\n-          tagsManifest?.items[tag].revalidatedAt >=\n-            (data?.lastModified || Date.now())\n-        )\n+        return isStale([tag], data?.lastModified || Date.now())\n       })\n       // When revalidate tag is called we don't return\n       // stale data so it's updated right away"
        },
        {
            "sha": "2c8688077f1f247585285321030d933340731f04",
            "filename": "packages/next/src/server/lib/incremental-cache/index.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 12,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -21,20 +21,20 @@ import { normalizePagePath } from '../../../shared/lib/page-path/normalize-page-\n \n import {\n   CACHE_ONE_YEAR,\n-  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n-  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n   PRERENDER_REVALIDATE_HEADER,\n } from '../../../lib/constants'\n import { toRoute } from '../to-route'\n import { SharedCacheControls } from './shared-cache-controls'\n-import { workUnitAsyncStorageInstance } from '../../app-render/work-unit-async-storage-instance'\n import {\n   getPrerenderResumeDataCache,\n   getRenderResumeDataCache,\n+  workUnitAsyncStorage,\n } from '../../app-render/work-unit-async-storage.external'\n import { getCacheHandlers } from '../../use-cache/handlers'\n import { InvariantError } from '../../../shared/lib/invariant-error'\n import type { Revalidate } from '../cache-control'\n+import { updateImplicitTagsExpiration } from '../implicit-tags'\n+import { getPreviouslyRevalidatedTags } from '../../server-utils'\n \n export interface CacheHandlerContext {\n   fs?: CacheFs\n@@ -181,14 +181,11 @@ export class IncrementalCache implements IncrementalCacheType {\n       this.isOnDemandRevalidate = true\n     }\n \n-    if (\n-      minimalMode &&\n-      typeof requestHeaders[NEXT_CACHE_REVALIDATED_TAGS_HEADER] === 'string' &&\n-      requestHeaders[NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] ===\n+    if (minimalMode) {\n+      revalidatedTags = getPreviouslyRevalidatedTags(\n+        requestHeaders,\n         this.prerenderManifest?.preview?.previewModeId\n-    ) {\n-      revalidatedTags =\n-        requestHeaders[NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(',')\n+      )\n     }\n \n     if (CurCacheHandler) {\n@@ -277,6 +274,12 @@ export class IncrementalCache implements IncrementalCacheType {\n     }\n \n     await Promise.all(promises)\n+\n+    const workUnitStore = workUnitAsyncStorage.getStore()\n+\n+    if (workUnitStore?.implicitTags) {\n+      await updateImplicitTagsExpiration(workUnitStore.implicitTags)\n+    }\n   }\n \n   // x-ref: https://github.com/facebook/react/blob/2655c9354d8e1c54ba888444220f63e836925caa/packages/react/src/ReactFetch.js#L23\n@@ -420,7 +423,7 @@ export class IncrementalCache implements IncrementalCacheType {\n     // Unlike other caches if we have a resume data cache, we use it even if\n     // testmode would normally disable it or if requestHeaders say 'no-cache'.\n     if (ctx.kind === IncrementalCacheKind.FETCH) {\n-      const workUnitStore = workUnitAsyncStorageInstance.getStore()\n+      const workUnitStore = workUnitAsyncStorage.getStore()\n       const resumeDataCache = workUnitStore\n         ? getRenderResumeDataCache(workUnitStore)\n         : null\n@@ -567,7 +570,7 @@ export class IncrementalCache implements IncrementalCacheType {\n     // populates caches ahead of a dynamic render in dev mode to allow the RSC\n     // debug info to have the right environment associated to it.\n     if (data?.kind === CachedRouteKind.FETCH) {\n-      const workUnitStore = workUnitAsyncStorageInstance.getStore()\n+      const workUnitStore = workUnitAsyncStorage.getStore()\n       const prerenderResumeDataCache = workUnitStore\n         ? getPrerenderResumeDataCache(workUnitStore)\n         : null"
        },
        {
            "sha": "adb92884c8fb28b3d6a5463f75e2baf2116d5f30",
            "filename": "packages/next/src/server/lib/incremental-cache/tags-manifest.external.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 15,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ftags-manifest.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ftags-manifest.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ftags-manifest.external.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -1,23 +1,17 @@\n-type TagsManifest = {\n-  items: { [tag: string]: { revalidatedAt?: number } }\n-}\n+import type { Timestamp } from '../cache-handlers/types'\n \n-// we share tags manifest between \"use cache\" handlers and\n-// previous file-system-cache\n-export const tagsManifest: TagsManifest = {\n-  items: {},\n-}\n+// We share the tags manifest between the \"use cache\" handlers and the previous\n+// file-system cache.\n+export const tagsManifest = new Map<string, number>()\n \n-export const isTagStale = (tags: string[], timestamp: number) => {\n+export const isStale = (tags: string[], timestamp: Timestamp) => {\n   for (const tag of tags) {\n-    const tagEntry = tagsManifest.items[tag]\n-    if (\n-      typeof tagEntry?.revalidatedAt === 'number' &&\n-      // TODO: use performance.now and update file-system-cache?\n-      tagEntry.revalidatedAt >= timestamp\n-    ) {\n+    const revalidatedAt = tagsManifest.get(tag)\n+\n+    if (typeof revalidatedAt === 'number' && revalidatedAt >= timestamp) {\n       return true\n     }\n   }\n+\n   return false\n }"
        },
        {
            "sha": "3dd0c3a6533d7ff5d67ad8d883de4a0aa7f1e3dd",
            "filename": "packages/next/src/server/lib/patch-fetch.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 5,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -274,10 +274,7 @@ export function createPatchedFetcher(\n           }\n         }\n \n-        const implicitTags =\n-          !workUnitStore || workUnitStore.type === 'unstable-cache'\n-            ? []\n-            : workUnitStore.implicitTags\n+        const implicitTags = workUnitStore?.implicitTags\n \n         // Inside unstable-cache we treat it the same as force-no-store on the\n         // page.\n@@ -756,7 +753,7 @@ export function createPatchedFetcher(\n                   fetchUrl,\n                   fetchIdx,\n                   tags,\n-                  softTags: implicitTags,\n+                  softTags: implicitTags?.tags,\n                 })\n \n             if (hasNoExplicitCacheConfig) {"
        },
        {
            "sha": "ef8815e0501a08669b906fcf47e280b295e9696d",
            "filename": "packages/next/src/server/route-modules/app-route/module.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 10,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Froute-modules%2Fapp-route%2Fmodule.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -18,7 +18,7 @@ import {\n   type WorkStoreContext,\n } from '../../async-storage/work-store'\n import { type HTTP_METHOD, HTTP_METHODS, isHTTPMethod } from '../../web/http'\n-import { getImplicitTags } from '../../lib/implicit-tags'\n+import { getImplicitTags, type ImplicitTags } from '../../lib/implicit-tags'\n import { patchFetch } from '../../lib/patch-fetch'\n import { getTracer } from '../../lib/trace/tracer'\n import { AppRouteRouteHandlersSpan } from '../../lib/trace/constants'\n@@ -300,7 +300,7 @@ export class AppRouteRouteModule extends RouteModule<\n     // inside this function. Right now we get passed a RequestStore even when\n     // we're going to do a prerender. We should probably just split do up into prexecute and execute\n     requestStore: RequestStore,\n-    implicitTags: string[],\n+    implicitTags: ImplicitTags,\n     request: NextRequest,\n     context: AppRouteRouteHandlerContext\n   ) {\n@@ -367,7 +367,7 @@ export class AppRouteRouteModule extends RouteModule<\n               // This replicates prior behavior where rootParams is empty in routes\n               // TODO we need to make this have the proper rootParams for this route\n               rootParams: {},\n-              implicitTags: implicitTags,\n+              implicitTags,\n               renderSignal: prospectiveController.signal,\n               controller: prospectiveController,\n               cacheSignal,\n@@ -377,7 +377,7 @@ export class AppRouteRouteModule extends RouteModule<\n               revalidate: defaultRevalidate,\n               expire: INFINITE_CACHE,\n               stale: INFINITE_CACHE,\n-              tags: [...implicitTags],\n+              tags: [...implicitTags.tags],\n               prerenderResumeDataCache: null,\n             })\n \n@@ -454,15 +454,15 @@ export class AppRouteRouteModule extends RouteModule<\n             type: 'prerender',\n             phase: 'action',\n             rootParams: {},\n-            implicitTags: implicitTags,\n+            implicitTags,\n             renderSignal: finalController.signal,\n             controller: finalController,\n             cacheSignal: null,\n             dynamicTracking,\n             revalidate: defaultRevalidate,\n             expire: INFINITE_CACHE,\n             stale: INFINITE_CACHE,\n-            tags: [...implicitTags],\n+            tags: [...implicitTags.tags],\n             prerenderResumeDataCache: null,\n           })\n \n@@ -534,11 +534,11 @@ export class AppRouteRouteModule extends RouteModule<\n             type: 'prerender-legacy',\n             phase: 'action',\n             rootParams: {},\n-            implicitTags: implicitTags,\n+            implicitTags,\n             revalidate: defaultRevalidate,\n             expire: INFINITE_CACHE,\n             stale: INFINITE_CACHE,\n-            tags: [...implicitTags],\n+            tags: [...implicitTags.tags],\n           }\n \n           res = await workUnitAsyncStorage.run(\n@@ -604,7 +604,7 @@ export class AppRouteRouteModule extends RouteModule<\n \n     context.renderOpts.pendingWaitUntil = Promise.all([\n       workStore.incrementalCache?.revalidateTag(\n-        workStore.revalidatedTags || []\n+        workStore.pendingRevalidatedTags || []\n       ),\n       ...Object.values(workStore.pendingRevalidates || {}),\n     ]).finally(() => {\n@@ -655,6 +655,7 @@ export class AppRouteRouteModule extends RouteModule<\n       page: this.definition.page,\n       renderOpts: context.renderOpts,\n       buildId: context.sharedContext.buildId,\n+      previouslyRevalidatedTags: [],\n     }\n \n     // Add the fetchCache option to the renderOpts.\n@@ -665,7 +666,7 @@ export class AppRouteRouteModule extends RouteModule<\n       isAction: getIsServerAction(req),\n     }\n \n-    const implicitTags = getImplicitTags(\n+    const implicitTags = await getImplicitTags(\n       this.definition.page,\n       req.nextUrl,\n       // App Routes don't support unknown route params."
        },
        {
            "sha": "c63b4a6d25571b51783b2604ff54c32e034bdf9d",
            "filename": "packages/next/src/server/server-utils.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fserver-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fserver-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fserver-utils.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -17,10 +17,13 @@ import {\n import { removeTrailingSlash } from '../shared/lib/router/utils/remove-trailing-slash'\n import { normalizeRscURL } from '../shared/lib/router/utils/app-paths'\n import {\n+  NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER,\n+  NEXT_CACHE_REVALIDATED_TAGS_HEADER,\n   NEXT_INTERCEPTION_MARKER_PREFIX,\n   NEXT_QUERY_PARAM_PREFIX,\n } from '../lib/constants'\n import { normalizeNextQueryParam } from './web/utils'\n+import type { IncomingHttpHeaders } from 'http'\n \n export function normalizeVercelUrl(\n   req: BaseNextRequest,\n@@ -395,3 +398,13 @@ export function getUtils({\n     ) => interpolateDynamicPath(pathname, params, defaultRouteRegex),\n   }\n }\n+\n+export function getPreviouslyRevalidatedTags(\n+  headers: IncomingHttpHeaders,\n+  previewModeId: string | undefined\n+): string[] {\n+  return typeof headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER] === 'string' &&\n+    headers[NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] === previewModeId\n+    ? headers[NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(',')\n+    : []\n+}"
        },
        {
            "sha": "e81f7cbef73c3ade697d917779bac1f5f7238a02",
            "filename": "packages/next/src/server/use-cache/handlers.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 10,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fhandlers.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fhandlers.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fhandlers.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -1,5 +1,5 @@\n import DefaultCacheHandler from '../lib/cache-handlers/default'\n-import type { CacheHandler } from '../lib/cache-handlers/types'\n+import type { CacheHandlerCompat } from '../lib/cache-handlers/types'\n \n const debug = process.env.NEXT_PRIVATE_DEBUG_USE_CACHE\n   ? (message: string, ...args: any[]) => {\n@@ -18,11 +18,11 @@ const handlersSetSymbol = Symbol.for('@next/cache-handlers-set')\n  */\n const reference: typeof globalThis & {\n   [handlersSymbol]?: {\n-    RemoteCache?: CacheHandler\n-    DefaultCache?: CacheHandler\n+    RemoteCache?: CacheHandlerCompat\n+    DefaultCache?: CacheHandlerCompat\n   }\n-  [handlersMapSymbol]?: Map<string, CacheHandler>\n-  [handlersSetSymbol]?: Set<CacheHandler>\n+  [handlersMapSymbol]?: Map<string, CacheHandlerCompat>\n+  [handlersSetSymbol]?: Set<CacheHandlerCompat>\n } = globalThis\n \n /**\n@@ -37,11 +37,11 @@ export function initializeCacheHandlers(): boolean {\n   }\n \n   debug('initializing cache handlers')\n-  reference[handlersMapSymbol] = new Map<string, CacheHandler>()\n+  reference[handlersMapSymbol] = new Map<string, CacheHandlerCompat>()\n \n   // Initialize the cache from the symbol contents first.\n   if (reference[handlersSymbol]) {\n-    let fallback: CacheHandler\n+    let fallback: CacheHandlerCompat\n     if (reference[handlersSymbol].DefaultCache) {\n       debug('setting \"default\" cache handler from symbol')\n       fallback = reference[handlersSymbol].DefaultCache\n@@ -80,7 +80,7 @@ export function initializeCacheHandlers(): boolean {\n  * @param kind - The kind of cache handler to get.\n  * @returns The cache handler, or `undefined` if it is not initialized or does not exist.\n  */\n-export function getCacheHandler(kind: string): CacheHandler | undefined {\n+export function getCacheHandler(kind: string): CacheHandlerCompat | undefined {\n   // This should never be called before initializeCacheHandlers.\n   if (!reference[handlersMapSymbol]) {\n     throw new Error('Cache handlers not initialized')\n@@ -93,7 +93,9 @@ export function getCacheHandler(kind: string): CacheHandler | undefined {\n  * Get an iterator over the cache handlers.\n  * @returns An iterator over the cache handlers, or `undefined` if they are not initialized.\n  */\n-export function getCacheHandlers(): SetIterator<CacheHandler> | undefined {\n+export function getCacheHandlers():\n+  | SetIterator<CacheHandlerCompat>\n+  | undefined {\n   if (!reference[handlersSetSymbol]) {\n     return undefined\n   }\n@@ -108,7 +110,7 @@ export function getCacheHandlers(): SetIterator<CacheHandler> | undefined {\n  */\n export function setCacheHandler(\n   kind: string,\n-  cacheHandler: CacheHandler\n+  cacheHandler: CacheHandlerCompat\n ): void {\n   // This should never be called before initializeCacheHandlers.\n   if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {"
        },
        {
            "sha": "8faf4a4df03e3dd4054e6c2fe5089013a406bb49",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 31,
            "deletions": 13,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -152,11 +152,7 @@ function generateCacheEntryWithCacheContext(\n   const cacheStore: UseCacheStore = {\n     type: 'cache',\n     phase: 'render',\n-    implicitTags:\n-      outerWorkUnitStore === undefined ||\n-      outerWorkUnitStore.type === 'unstable-cache'\n-        ? []\n-        : outerWorkUnitStore.implicitTags,\n+    implicitTags: outerWorkUnitStore?.implicitTags,\n     revalidate: defaultCacheLife.revalidate,\n     expire: defaultCacheLife.expire,\n     stale: defaultCacheLife.stale,\n@@ -272,7 +268,7 @@ async function collectResult(\n       ? innerCacheStore.explicitStale\n       : innerCacheStore.stale\n \n-  const entry = {\n+  const entry: CacheEntry = {\n     value: bufferStream,\n     timestamp: startTime,\n     revalidate: collectedRevalidate,\n@@ -687,16 +683,38 @@ export function cache(\n           cacheSignal.beginRead()\n         }\n \n-        const implicitTags =\n-          workUnitStore === undefined || workUnitStore.type === 'unstable-cache'\n-            ? []\n-            : workUnitStore.implicitTags\n-\n+        const implicitTags = workUnitStore?.implicitTags\n         const forceRevalidate = shouldForceRevalidate(workStore, workUnitStore)\n \n-        const entry = forceRevalidate\n+        let entry = forceRevalidate\n           ? undefined\n-          : await cacheHandler.get(serializedCacheKey, implicitTags)\n+          : 'getExpiration' in cacheHandler\n+            ? await cacheHandler.get(serializedCacheKey)\n+            : // Legacy cache handlers require implicit tags to be passed in,\n+              // instead of checking their staleness here, as we do for modern\n+              // cache handlers (see below).\n+              await cacheHandler.get(\n+                serializedCacheKey,\n+                implicitTags?.tags ?? []\n+              )\n+\n+        if (\n+          entry &&\n+          // If the cache entry was tagged with a previously revalidated tag\n+          // (e.g. by a redirecting server action), we need to discard it.\n+          (entry.tags.some((tag) =>\n+            // TODO: Shouldn't we also consider pendingRevalidatedTags?\n+            // Curiously, this is currently not done for the incremental cache\n+            // handler. So a revalidating server action can read its own writes\n+            // only during subsequent rendering, but not in the action itself?\n+            workStore.previouslyRevalidatedTags.includes(tag)\n+          ) ||\n+            // If the cache entry was created before any of the implicit tags\n+            // were revalidated last, we need to discard it.\n+            (implicitTags && entry.timestamp <= implicitTags.expiration))\n+        ) {\n+          entry = undefined\n+        }\n \n         const currentTime = performance.timeOrigin + performance.now()\n         if ("
        },
        {
            "sha": "f1015cd0d2bed0430bf6aefa66a2557ce605e1c4",
            "filename": "packages/next/src/server/web/adapter.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fadapter.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fadapter.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fadapter.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -282,6 +282,7 @@ export async function adapter(\n                 NEXT_ROUTER_PREFETCH_HEADER\n               ),\n               buildId: buildId ?? '',\n+              previouslyRevalidatedTags: [],\n             })\n \n             return await workAsyncStorage.run(workStore, () =>"
        },
        {
            "sha": "aa52b9e4ea81f7fe55c8e9c2a344d627c6783427",
            "filename": "packages/next/src/server/web/spec-extension/revalidate.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Frevalidate.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Frevalidate.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Frevalidate.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -145,13 +145,13 @@ function revalidate(tags: string[], expression: string) {\n     }\n   }\n \n-  if (!store.revalidatedTags) {\n-    store.revalidatedTags = []\n+  if (!store.pendingRevalidatedTags) {\n+    store.pendingRevalidatedTags = []\n   }\n \n   for (const tag of tags) {\n-    if (!store.revalidatedTags.includes(tag)) {\n-      store.revalidatedTags.push(tag)\n+    if (!store.pendingRevalidatedTags.includes(tag)) {\n+      store.pendingRevalidatedTags.push(tag)\n     }\n   }\n "
        },
        {
            "sha": "8c054358af3708102c3f401ad6a6bff6a6947985",
            "filename": "packages/next/src/server/web/spec-extension/unstable-cache.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 12,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fweb%2Fspec-extension%2Funstable-cache.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -139,6 +139,8 @@ export function unstable_cache<T extends Callback>(\n       const fetchIdx =\n         (workStore ? workStore.nextFetchId : noStoreFetchIdx) ?? 1\n \n+      const implicitTags = workUnitStore?.implicitTags\n+\n       if (workStore) {\n         workStore.nextFetchId = fetchIdx + 1\n \n@@ -178,11 +180,6 @@ export function unstable_cache<T extends Callback>(\n           }\n         }\n \n-        const implicitTags =\n-          !workUnitStore || workUnitStore.type === 'unstable-cache'\n-            ? []\n-            : workUnitStore.implicitTags\n-\n         const isNestedUnstableCache =\n           workUnitStore && workUnitStore.type === 'unstable-cache'\n         if (\n@@ -199,7 +196,7 @@ export function unstable_cache<T extends Callback>(\n             kind: IncrementalCacheKind.FETCH,\n             revalidate: options.revalidate,\n             tags,\n-            softTags: implicitTags,\n+            softTags: implicitTags?.tags,\n             fetchIdx,\n             fetchUrl,\n           })\n@@ -230,6 +227,7 @@ export function unstable_cache<T extends Callback>(\n                 const innerCacheStore: UnstableCacheStore = {\n                   type: 'unstable-cache',\n                   phase: 'render',\n+                  implicitTags,\n                 }\n                 // We run the cache function asynchronously and save the result when it completes\n                 workStore.pendingRevalidates[invocationKey] =\n@@ -263,6 +261,7 @@ export function unstable_cache<T extends Callback>(\n         const innerCacheStore: UnstableCacheStore = {\n           type: 'unstable-cache',\n           phase: 'render',\n+          implicitTags,\n         }\n         // If we got this far then we had an invalid cache entry and need to generate a new one\n         const result = await workUnitAsyncStorage.run(\n@@ -293,18 +292,13 @@ export function unstable_cache<T extends Callback>(\n \n         if (!incrementalCache.isOnDemandRevalidate) {\n           // We aren't doing an on demand revalidation so we check use the cache if valid\n-          const implicitTags =\n-            !workUnitStore || workUnitStore.type === 'unstable-cache'\n-              ? []\n-              : workUnitStore.implicitTags\n-\n           const cacheEntry = await incrementalCache.get(cacheKey, {\n             kind: IncrementalCacheKind.FETCH,\n             revalidate: options.revalidate,\n             tags,\n             fetchIdx,\n             fetchUrl,\n-            softTags: implicitTags,\n+            softTags: implicitTags?.tags,\n           })\n \n           if (cacheEntry && cacheEntry.value) {\n@@ -329,6 +323,7 @@ export function unstable_cache<T extends Callback>(\n         const innerCacheStore: UnstableCacheStore = {\n           type: 'unstable-cache',\n           phase: 'render',\n+          implicitTags,\n         }\n         // If we got this far then we had an invalid cache entry and need to generate a new one\n         const result = await workUnitAsyncStorage.run("
        },
        {
            "sha": "16a2a04214e7a3af7e5cd194e9fe115ee72f4590",
            "filename": "test/e2e/app-dir/use-cache-custom-handler/app/legacy/page.tsx",
            "status": "added",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fapp%2Flegacy%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fapp%2Flegacy%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fapp%2Flegacy%2Fpage.tsx?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -0,0 +1,42 @@\n+import { Suspense } from 'react'\n+import {\n+  unstable_cacheLife as cacheLife,\n+  unstable_cacheTag as cacheTag,\n+  revalidateTag,\n+} from 'next/cache'\n+import { redirect } from 'next/navigation'\n+\n+async function getData() {\n+  'use cache: legacy'\n+\n+  cacheLife({ revalidate: 3 })\n+  cacheTag('legacy')\n+\n+  return new Date().toISOString()\n+}\n+\n+async function AsyncComp() {\n+  let data = await getData()\n+\n+  return <p id=\"data\">{data}</p>\n+}\n+\n+export default function Legacy() {\n+  return (\n+    <main>\n+      <Suspense fallback={<p>Loading...</p>}>\n+        <AsyncComp />\n+      </Suspense>\n+      <form\n+        action={async () => {\n+          'use server'\n+\n+          revalidateTag('legacy')\n+          redirect('/legacy')\n+        }}\n+      >\n+        <button id=\"revalidate\">Revalidate Tag</button>\n+      </form>\n+    </main>\n+  )\n+}"
        },
        {
            "sha": "1198d7cf35bc67c86bebb59ee4aa9bf1e4555b06",
            "filename": "test/e2e/app-dir/use-cache-custom-handler/app/page.tsx",
            "status": "modified",
            "additions": 22,
            "deletions": 5,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fapp%2Fpage.tsx?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -1,16 +1,23 @@\n import { Suspense } from 'react'\n-import { unstable_cacheLife as cacheLife } from 'next/cache'\n+import {\n+  unstable_cacheLife as cacheLife,\n+  unstable_cacheTag as cacheTag,\n+  revalidateTag,\n+} from 'next/cache'\n+import { redirect } from 'next/navigation'\n \n async function getData() {\n   'use cache'\n-  cacheLife({\n-    revalidate: 3,\n-  })\n-  return Math.random()\n+\n+  cacheLife({ revalidate: 3 })\n+  cacheTag('modern')\n+\n+  return new Date().toISOString()\n }\n \n async function AsyncComp() {\n   let data = await getData()\n+\n   return <p id=\"data\">{data}</p>\n }\n \n@@ -20,6 +27,16 @@ export default function Home() {\n       <Suspense fallback={<p>Loading...</p>}>\n         <AsyncComp />\n       </Suspense>\n+      <form\n+        action={async () => {\n+          'use server'\n+\n+          revalidateTag('modern')\n+          redirect('/')\n+        }}\n+      >\n+        <button id=\"revalidate\">Revalidate Tag</button>\n+      </form>\n     </main>\n   )\n }"
        },
        {
            "sha": "2de45c91eea7bd63c44d1bcdde3f61d49e2b2000",
            "filename": "test/e2e/app-dir/use-cache-custom-handler/handler.js",
            "status": "modified",
            "additions": 28,
            "deletions": 9,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fhandler.js",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fhandler.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fhandler.js?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -1,17 +1,36 @@\n-const cacheHandler =\n+// @ts-check\n+\n+const defaultCacheHandler =\n   require('next/dist/server/lib/cache-handlers/default').default\n \n-module.exports = {\n-  async get(cacheKey, softTags) {\n-    console.log('CustomCacheHandler::Get', cacheKey, softTags)\n-    return cacheHandler.get(cacheKey, softTags)\n+/**\n+ * @type {import('next/dist/server/lib/cache-handlers/types').CacheHandlerV2}\n+ */\n+const cacheHandler = {\n+  async get(cacheKey) {\n+    console.log('CustomCacheHandler::get', cacheKey)\n+    return defaultCacheHandler.get(cacheKey)\n   },\n \n   async set(cacheKey, pendingEntry) {\n-    console.log('CustomCacheHandler::Set', cacheKey)\n-    return cacheHandler.set(cacheKey, pendingEntry)\n+    console.log('CustomCacheHandler::set', cacheKey)\n+    return defaultCacheHandler.set(cacheKey, pendingEntry)\n+  },\n+\n+  async refreshTags() {\n+    console.log('CustomCacheHandler::refreshTags')\n+    return defaultCacheHandler.refreshTags()\n   },\n \n-  async expireTags(...tags) {},\n-  async receiveExpiredTags(...tags) {},\n+  async getExpiration(...tags) {\n+    console.log('CustomCacheHandler::getExpiration', JSON.stringify(tags))\n+    return defaultCacheHandler.getExpiration(...tags)\n+  },\n+\n+  async expireTags(...tags) {\n+    console.log('CustomCacheHandler::expireTags', JSON.stringify(tags))\n+    return defaultCacheHandler.expireTags(...tags)\n+  },\n }\n+\n+module.exports = cacheHandler"
        },
        {
            "sha": "b68700f46ac10e86b0a62ba51cca7b983ed87e2d",
            "filename": "test/e2e/app-dir/use-cache-custom-handler/legacy-handler.js",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Flegacy-handler.js",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Flegacy-handler.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Flegacy-handler.js?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -0,0 +1,37 @@\n+// @ts-check\n+\n+const defaultCacheHandler =\n+  require('next/dist/server/lib/cache-handlers/default').default\n+\n+/**\n+ * @type {import('next/dist/server/lib/cache-handlers/types').CacheHandler}\n+ */\n+const cacheHandler = {\n+  async get(cacheKey, softTags) {\n+    console.log(\n+      'LegacyCustomCacheHandler::get',\n+      cacheKey,\n+      JSON.stringify(softTags)\n+    )\n+    return defaultCacheHandler.get(cacheKey)\n+  },\n+\n+  async set(cacheKey, pendingEntry) {\n+    console.log('LegacyCustomCacheHandler::set', cacheKey)\n+    return defaultCacheHandler.set(cacheKey, pendingEntry)\n+  },\n+\n+  async expireTags(...tags) {\n+    console.log('LegacyCustomCacheHandler::expireTags', JSON.stringify(tags))\n+    return defaultCacheHandler.expireTags(...tags)\n+  },\n+\n+  async receiveExpiredTags(...tags) {\n+    console.log(\n+      'LegacyCustomCacheHandler::receiveExpiredTags',\n+      JSON.stringify(tags)\n+    )\n+  },\n+}\n+\n+module.exports = cacheHandler"
        },
        {
            "sha": "0220588c2b3c753e357c9e9fb5200333ebe4b999",
            "filename": "test/e2e/app-dir/use-cache-custom-handler/next.config.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fnext.config.js?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -6,6 +6,7 @@ const nextConfig = {\n     dynamicIO: true,\n     cacheHandlers: {\n       default: require.resolve('./handler.js'),\n+      legacy: require.resolve('./legacy-handler.js'),\n     },\n   },\n }"
        },
        {
            "sha": "ec87f3d5646199d8354b298e2d54ebe9c4d6ffb8",
            "filename": "test/e2e/app-dir/use-cache-custom-handler/use-cache-custom-handler.test.ts",
            "status": "modified",
            "additions": 122,
            "deletions": 7,
            "changes": 129,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fuse-cache-custom-handler.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fuse-cache-custom-handler.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fuse-cache-custom-handler.test.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -1,6 +1,8 @@\n-import { nextTestSetup } from 'e2e-utils'\n+import { isNextStart, nextTestSetup } from 'e2e-utils'\n import { retry } from 'next-test-utils'\n \n+const isoDateRegExp = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/\n+\n describe('use-cache-custom-handler', () => {\n   const { next, skipped } = nextTestSetup({\n     files: __dirname,\n@@ -10,24 +12,137 @@ describe('use-cache-custom-handler', () => {\n \n   if (skipped) return\n \n-  it('should use custom cache handler if provided', async () => {\n+  it('should use a modern custom cache handler if provided', async () => {\n     const outputIndex = next.cliOutput.length\n     const browser = await next.browser(`/`)\n+\n+    if (isNextStart) {\n+      // Refresh once to let it revalidate the prerendered page.\n+      await browser.refresh()\n+    }\n+\n     const initialData = await browser.elementById('data').text()\n-    expect(initialData).toMatch(/^\\d+\\.\\d+$/)\n+    expect(initialData).toMatch(isoDateRegExp)\n \n     expect(next.cliOutput.slice(outputIndex)).toContain(\n-      'CustomCacheHandler::Get'\n+      'CustomCacheHandler::refreshTags'\n     )\n+\n     expect(next.cliOutput.slice(outputIndex)).toContain(\n-      'CustomCacheHandler::Set'\n+      `CustomCacheHandler::getExpiration [\"_N_T_/layout\",\"_N_T_/page\",\"_N_T_/\"]`\n+    )\n+\n+    expect(next.cliOutput.slice(outputIndex)).toMatch(\n+      /CustomCacheHandler::get \\[\"(development|[A-Za-z0-9_-]{21})\",\"\\$undefined\",\"([0-9a-f]{2})+\",\\[\\]\\]/\n     )\n \n+    expect(next.cliOutput.slice(outputIndex)).toMatch(\n+      /CustomCacheHandler::set \\[\"(development|[A-Za-z0-9_-]{21})\",\"\\$undefined\",\"([0-9a-f]{2})+\",\\[\\]\\]/\n+    )\n+\n+    // The data should be cached initially.\n+\n+    await browser.refresh()\n+    let data = await browser.elementById('data').text()\n+    expect(data).toMatch(isoDateRegExp)\n+    expect(data).toEqual(initialData)\n+\n+    // Because we use a low `revalidate` value for the \"use cache\" function, new\n+    // data should be returned eventually.\n+\n     await retry(async () => {\n       await browser.refresh()\n+      data = await browser.elementById('data').text()\n+      expect(data).toMatch(isoDateRegExp)\n+      expect(data).not.toEqual(initialData)\n+    }, 5000)\n+  })\n+\n+  it('should use a legacy custom cache handler if provided', async () => {\n+    const outputIndex = next.cliOutput.length\n+    const browser = await next.browser(`/legacy`)\n+\n+    if (isNextStart) {\n+      // Refresh once to let it revalidate the prerendered page.\n+      await browser.refresh()\n+    }\n+\n+    const initialData = await browser.elementById('data').text()\n+    expect(initialData).toMatch(isoDateRegExp)\n+\n+    expect(next.cliOutput.slice(outputIndex)).toContain(\n+      'LegacyCustomCacheHandler::receiveExpiredTags []'\n+    )\n+\n+    expect(next.cliOutput.slice(outputIndex)).toMatch(\n+      /LegacyCustomCacheHandler::get \\[\"(development|[A-Za-z0-9_-]{21})\",\"\\$undefined\",\"([0-9a-f]{2})+\",\\[\\]\\] \\[\"_N_T_\\/layout\",\"_N_T_\\/legacy\\/layout\",\"_N_T_\\/legacy\\/page\",\"_N_T_\\/legacy\"\\]/\n+    )\n+\n+    expect(next.cliOutput.slice(outputIndex)).toMatch(\n+      /LegacyCustomCacheHandler::set \\[\"(development|[A-Za-z0-9_-]{21})\",\"\\$undefined\",\"([0-9a-f]{2})+\",\\[\\]\\]/\n+    )\n+\n+    // The data should be cached initially.\n+\n+    await browser.refresh()\n+    let data = await browser.elementById('data').text()\n+    expect(data).toMatch(isoDateRegExp)\n+    expect(data).toEqual(initialData)\n+\n+    // Because we use a low `revalidate` value for the \"use cache\" function, new\n+    // data should be returned eventually.\n+\n+    await retry(async () => {\n+      await browser.refresh()\n+      data = await browser.elementById('data').text()\n+      expect(data).toMatch(isoDateRegExp)\n+      expect(data).not.toEqual(initialData)\n+    }, 5000)\n+  })\n+\n+  it('should revalidate using a modern custom cache handler', async () => {\n+    const outputIndex = next.cliOutput.length\n+    const browser = await next.browser(`/`)\n+    const initialData = await browser.elementById('data').text()\n+    expect(initialData).toMatch(isoDateRegExp)\n+\n+    await browser.elementById('revalidate').click()\n+\n+    await retry(async () => {\n+      expect(next.cliOutput.slice(outputIndex)).toContain(\n+        'CustomCacheHandler::expireTags [\"modern\"]'\n+      )\n+\n+      const data = await browser.elementById('data').text()\n+      expect(data).toMatch(isoDateRegExp)\n+      expect(data).not.toEqual(initialData)\n+    }, 5000)\n+  })\n+\n+  it('should revalidate using a legacy custom cache handler', async () => {\n+    const outputIndex = next.cliOutput.length\n+    const browser = await next.browser(`/legacy`)\n+    const initialData = await browser.elementById('data').text()\n+    expect(initialData).toMatch(isoDateRegExp)\n+\n+    expect(next.cliOutput.slice(outputIndex)).toContain(\n+      'LegacyCustomCacheHandler::receiveExpiredTags []'\n+    )\n+\n+    await browser.elementById('revalidate').click()\n+\n+    await retry(async () => {\n+      expect(next.cliOutput.slice(outputIndex)).toContain(\n+        'LegacyCustomCacheHandler::expireTags [\"legacy\"]'\n+      )\n+\n+      expect(next.cliOutput.slice(outputIndex)).toContain(\n+        'LegacyCustomCacheHandler::receiveExpiredTags [\"legacy\"]'\n+      )\n+\n       const data = await browser.elementById('data').text()\n-      expect(data).toMatch(/^\\d+\\.\\d+$/)\n+      expect(data).toMatch(isoDateRegExp)\n       expect(data).not.toEqual(initialData)\n-    })\n+    }, 5000)\n   })\n })"
        },
        {
            "sha": "a27873c5c08c70a73164cf6a8b7a7a5e9b6635f5",
            "filename": "test/e2e/app-dir/use-cache/app/cache-tag/page.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Fcache-tag%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Fcache-tag%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Fcache-tag%2Fpage.tsx?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -1,6 +1,7 @@\n import React from 'react'\n import { unstable_cacheTag as cacheTag } from 'next/cache'\n import { RevalidateButtons } from './buttons'\n+import Link from 'next/link'\n \n async function getCachedWithTag({\n   tag,\n@@ -53,6 +54,11 @@ export default async function Page() {\n       <p id=\"r1\">[r, c] {r1}</p>\n       <p id=\"r2\">[-] {r2}</p>\n       <RevalidateButtons />\n+      <p>\n+        <Link href=\"/revalidate-and-redirect\">\n+          Go to /revalidate-and-redirect\n+        </Link>\n+      </p>\n     </div>\n   )\n }"
        },
        {
            "sha": "d6d05336bd893e094bed584c748828e5109cc8ab",
            "filename": "test/e2e/app-dir/use-cache/app/nested-in-unstable-cache/page.tsx",
            "status": "added",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Fnested-in-unstable-cache%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Fnested-in-unstable-cache%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Fnested-in-unstable-cache%2Fpage.tsx?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -0,0 +1,24 @@\n+import { revalidatePath, unstable_cache } from 'next/cache'\n+\n+async function inner() {\n+  'use cache'\n+  return Math.random()\n+}\n+\n+const outer = unstable_cache(async () => {\n+  return inner()\n+})\n+\n+export default async function Page() {\n+  return (\n+    <form\n+      action={async () => {\n+        'use server'\n+        revalidatePath('/nested-in-unstable-cache')\n+      }}\n+    >\n+      <p>{await outer()}</p>\n+      <button>Revalidate path</button>\n+    </form>\n+  )\n+}"
        },
        {
            "sha": "c3b6e612b168157bfe16b57af8062705ff5b7f13",
            "filename": "test/e2e/app-dir/use-cache/app/revalidate-and-redirect/page.tsx",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-redirect%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-redirect%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Frevalidate-and-redirect%2Fpage.tsx?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -0,0 +1,31 @@\n+import { revalidatePath, revalidateTag } from 'next/cache'\n+import { redirect } from 'next/navigation'\n+\n+export default function Page() {\n+  return (\n+    <form>\n+      <button\n+        id=\"revalidate-tag-redirect\"\n+        formAction={async () => {\n+          'use server'\n+\n+          revalidateTag('a')\n+          redirect('/cache-tag')\n+        }}\n+      >\n+        Revalidate tag and redirect\n+      </button>{' '}\n+      <button\n+        id=\"revalidate-path-redirect\"\n+        formAction={async () => {\n+          'use server'\n+\n+          revalidatePath('/cache-tag')\n+          redirect('/cache-tag')\n+        }}\n+      >\n+        Revalidate path and redirect\n+      </button>\n+    </form>\n+  )\n+}"
        },
        {
            "sha": "1aea39cefb4090ad4932037b8d99b206df2cf2c6",
            "filename": "test/e2e/app-dir/use-cache/app/with-server-action/page.tsx",
            "status": "modified",
            "additions": 0,
            "deletions": 2,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Fwith-server-action%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Fwith-server-action%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2Fwith-server-action%2Fpage.tsx?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -1,5 +1,3 @@\n-// TODO: This should not need the suspense boundary in the root layout, but\n-// currently does with Turbopack.\n import { Form } from './form'\n \n async function action() {"
        },
        {
            "sha": "fd543426e746e0a43a8aa358d135507a5c02ff6f",
            "filename": "test/e2e/app-dir/use-cache/use-cache.test.ts",
            "status": "modified",
            "additions": 67,
            "deletions": 6,
            "changes": 73,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -215,12 +215,14 @@ describe('use-cache', () => {\n       const browser = await next.browser('/cache-tag')\n       const initial = await browser.elementByCss('#a').text()\n \n-      // Bust the ISR cache first, to populate the in-memory cache for the\n-      // subsequent unstable_expireTag calls.\n-      await browser.elementByCss('#revalidate-path').click()\n-      await retry(async () => {\n-        expect(await browser.elementByCss('#a').text()).not.toBe(initial)\n-      })\n+      if (!isNextDev) {\n+        // Bust the ISR cache first, to populate the in-memory cache for the\n+        // subsequent unstable_expireTag calls.\n+        await browser.elementByCss('#revalidate-path').click()\n+        await retry(async () => {\n+          expect(await browser.elementByCss('#a').text()).not.toBe(initial)\n+        })\n+      }\n \n       let valueA = await browser.elementByCss('#a').text()\n       let valueB = await browser.elementByCss('#b').text()\n@@ -302,6 +304,63 @@ describe('use-cache', () => {\n         expect(await browser.elementByCss('#r2').text()).not.toBe(valueR2)\n       })\n     })\n+\n+    it('should revalidate caches after redirect', async () => {\n+      const browser = await next.browser('/cache-tag')\n+      const initial = await browser.elementById('a').text()\n+\n+      if (!isNextDev) {\n+        // Bust the ISR cache first to populate the \"use cache\" in-memory cache for\n+        // the subsequent revalidations.\n+        await browser.elementById('revalidate-path').click()\n+\n+        await retry(async () => {\n+          expect(await browser.elementById('a').text()).not.toBe(initial)\n+        })\n+      }\n+\n+      const valueA1 = await browser.elementById('a').text()\n+      const valueB1 = await browser.elementById('b').text()\n+      await browser.elementByCss('a[href=\"/revalidate-and-redirect\"]').click()\n+      await browser.elementById('revalidate-tag-redirect').click()\n+\n+      expect(await browser.elementById('a').text()).not.toBe(valueA1)\n+      expect(await browser.elementById('b').text()).toBe(valueB1)\n+      const valueA2 = await browser.elementById('a').text()\n+\n+      await browser.elementByCss('a[href=\"/revalidate-and-redirect\"]').click()\n+      await browser.elementById('revalidate-path-redirect').click()\n+\n+      expect(await browser.elementById('a').text()).not.toBe(valueA1)\n+      expect(await browser.elementById('a').text()).not.toBe(valueA2)\n+      expect(await browser.elementById('b').text()).not.toBe(valueB1)\n+    })\n+\n+    it('should revalidate caches nested in unstable_cache', async () => {\n+      const browser = await next.browser('/nested-in-unstable-cache')\n+      const initial = await browser.elementByCss('p').text()\n+\n+      if (!isNextDev) {\n+        // Bust the ISR cache first to populate the \"use cache\" in-memory cache for\n+        // the subsequent revalidations.\n+        await browser.elementByCss('button').click()\n+\n+        await retry(async () => {\n+          expect(await browser.elementByCss('p').text()).not.toBe(initial)\n+        })\n+      }\n+\n+      const value = await browser.elementByCss('p').text()\n+\n+      await browser.refresh()\n+      expect(await browser.elementByCss('p').text()).toBe(value)\n+\n+      await browser.elementByCss('button').click()\n+\n+      await retry(async () => {\n+        expect(await browser.elementByCss('p').text()).not.toBe(value)\n+      })\n+    })\n   }\n \n   it('should revalidate caches during on-demand revalidation', async () => {\n@@ -359,11 +418,13 @@ describe('use-cache', () => {\n         '/imported-from-client',\n         '/logs',\n         '/method-props',\n+        '/nested-in-unstable-cache',\n         '/not-found',\n         '/on-demand-revalidate',\n         '/passed-to-client',\n         '/react-cache',\n         '/referential-equality',\n+        '/revalidate-and-redirect',\n         '/rsc-payload',\n         '/static-class-method',\n         '/use-action-state',"
        },
        {
            "sha": "e30786cdd2e39c91328a21d611f3440e50768707",
            "filename": "test/production/app-dir/dynamic-io-cache-handlers/dynamic-io-cache-handlers.test.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 24,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/test%2Fproduction%2Fapp-dir%2Fdynamic-io-cache-handlers%2Fdynamic-io-cache-handlers.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/test%2Fproduction%2Fapp-dir%2Fdynamic-io-cache-handlers%2Fdynamic-io-cache-handlers.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fdynamic-io-cache-handlers%2Fdynamic-io-cache-handlers.test.ts?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -39,12 +39,16 @@ describe('dynamic-io-cache-handlers', () => {\n             console.log('symbol set', cacheKey)\n           },\n         \n-          expireTags(...tags) {\n-            console.log('symbol expireTags', tags)\n+          refreshTags() {\n+            console.log('symbol refreshTags')\n+          },\n+\n+          getExpiration(...tags) {\n+            console.log('symbol getExpiration', tags)\n           },\n         \n-          receiveExpiredTags(...tags) {\n-            console.log('symbol receiveExpiredTags', tags)\n+          expireTags(...tags) {\n+            console.log('symbol expireTags', tags)\n           }\n         }\n       }\n@@ -103,30 +107,12 @@ describe('dynamic-io-cache-handlers', () => {\n     })\n   })\n \n-  it('should call receiveExpiredTags on global default cache handler without tags if none are provided', async () => {\n+  it('should call refreshTags on global default cache handler', async () => {\n     const res = await fetchViaHTTP(appPort, '/', {})\n     expect(res.status).toBe(200)\n \n     await retry(async () => {\n-      expect(output).toContain('symbol receiveExpiredTags []')\n-    })\n-  })\n-\n-  it('should call receiveExpiredTags on global default cache handler', async () => {\n-    const res = await fetchViaHTTP(\n-      appPort,\n-      '/',\n-      {},\n-      {\n-        headers: {\n-          'x-next-revalidated-tags': 'tag1',\n-        },\n-      }\n-    )\n-    expect(res.status).toBe(200)\n-\n-    await retry(async () => {\n-      expect(output).toContain(\"symbol receiveExpiredTags [ 'tag1' ]\")\n+      expect(output).toContain('symbol refreshTags')\n     })\n   })\n })"
        },
        {
            "sha": "a0720687fb3f7019f21ba51e575c2afa2b0b0dc9",
            "filename": "tsconfig.json",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/84fde91e03918344c5d356986914ab68a5083462/tsconfig.json",
            "raw_url": "https://github.com/vercel/next.js/raw/84fde91e03918344c5d356986914ab68a5083462/tsconfig.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/tsconfig.json?ref=84fde91e03918344c5d356986914ab68a5083462",
            "patch": "@@ -24,6 +24,7 @@\n   \"include\": [\n     \"test/**/*.test.ts\",\n     \"test/**/*.test.tsx\",\n+    \"test/e2e/app-dir/use-cache-custom-handler/*.js\",\n     \"test/lib/**/*.ts\",\n     \"turbo/**/*.ts\"\n   ]"
        }
    ],
    "stats": {
        "total": 1155,
        "additions": 825,
        "deletions": 330
    }
}