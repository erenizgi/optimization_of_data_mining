{
    "author": "sokra",
    "message": "Turbopack: Redefine Background backend jobs (#83174)\n\n### What?\n\nWe don't need background jobs that run when idle. We already have a `idle_start` event for that.\nInstead we need \"background jobs\" that do not count towards activeness of the system (do not contribute to the compile duration and these effects).\n\nAlso remove a bunch of unused stuff from the manager.",
    "sha": "143769bc8304423ba2038accf6f10de240733821",
    "files": [
        {
            "sha": "ba8713777d18ab22ae89fe807041c921888f98da",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/143769bc8304423ba2038accf6f10de240733821/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/143769bc8304423ba2038accf6f10de240733821/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=143769bc8304423ba2038accf6f10de240733821",
            "patch": "@@ -2230,7 +2230,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                             let chunk_size = good_chunk_size(data.len());\n                             let chunks = data.len().div_ceil(chunk_size);\n                             for i in 0..chunks {\n-                                turbo_tasks.schedule_backend_foreground_job(\n+                                turbo_tasks.schedule_backend_background_job(\n                                     TurboTasksBackendJob::Prefetch {\n                                         data: data.clone(),\n                                         range: Some("
        },
        {
            "sha": "0a41f4804b1c4a83fb97292eec79e090c720cea8",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/143769bc8304423ba2038accf6f10de240733821/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/143769bc8304423ba2038accf6f10de240733821/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=143769bc8304423ba2038accf6f10de240733821",
            "patch": "@@ -265,7 +265,7 @@ where\n     fn schedule_task(&self, mut task: impl TaskGuard + '_) {\n         if let Some(tasks_to_prefetch) = task.prefetch() {\n             self.turbo_tasks\n-                .schedule_backend_foreground_job(TurboTasksBackendJob::Prefetch {\n+                .schedule_backend_background_job(TurboTasksBackendJob::Prefetch {\n                     data: Arc::new(tasks_to_prefetch),\n                     range: None,\n                 });"
        },
        {
            "sha": "c550f015413a69b17de66afd45fb97deeffc4e9c",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/143769bc8304423ba2038accf6f10de240733821/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/143769bc8304423ba2038accf6f10de240733821/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=143769bc8304423ba2038accf6f10de240733821",
            "patch": "@@ -39,6 +39,7 @@\n #![feature(ptr_metadata)]\n #![feature(sync_unsafe_cell)]\n #![feature(vec_into_raw_parts)]\n+#![feature(async_fn_traits)]\n \n pub mod backend;\n mod capture_future;"
        },
        {
            "sha": "fbb591a51c78cdc208f04707a5f0244fc41fc7f6",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 86,
            "deletions": 143,
            "changes": 229,
            "blob_url": "https://github.com/vercel/next.js/blob/143769bc8304423ba2038accf6f10de240733821/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/143769bc8304423ba2038accf6f10de240733821/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=143769bc8304423ba2038accf6f10de240733821",
            "patch": "@@ -249,14 +249,17 @@ pub trait TurboTasksBackendApi<B: Backend + 'static>: TurboTasksCallApi + Sync +\n     /// The caller must ensure that the task id is not used anymore.\n     unsafe fn reuse_transient_task_id(&self, id: Unused<TaskId>);\n \n+    /// Schedule a task for execution.\n     fn schedule(&self, task: TaskId);\n-    fn schedule_backend_background_job(&self, job: B::BackendJob);\n+\n+    /// Schedule a foreground backend job for execution.\n     fn schedule_backend_foreground_job(&self, job: B::BackendJob);\n \n-    fn try_foreground_done(&self) -> Result<(), EventListener>;\n-    fn wait_foreground_done_excluding_own<'a>(\n-        &'a self,\n-    ) -> Option<Pin<Box<dyn Future<Output = ()> + Send + 'a>>>;\n+    /// Schedule a background backend job for execution.\n+    ///\n+    /// Background jobs are not counted towards activeness of the system. The system is considered\n+    /// idle even with active background jobs.\n+    fn schedule_backend_background_job(&self, job: B::BackendJob);\n \n     /// Enqueues tasks for notification of changed dependencies. This will\n     /// eventually call `invalidate_tasks()` on all tasks.\n@@ -369,16 +372,18 @@ pub struct TurboTasks<B: Backend + 'static> {\n     transient_task_id_factory: IdFactoryWithReuse<TaskId>,\n     execution_id_factory: IdFactory<ExecutionId>,\n     stopped: AtomicBool,\n-    currently_scheduled_tasks: AtomicUsize,\n     currently_scheduled_foreground_jobs: AtomicUsize,\n     currently_scheduled_background_jobs: AtomicUsize,\n     scheduled_tasks: AtomicUsize,\n     start: Mutex<Option<Instant>>,\n     aggregated_update: Mutex<(Option<(Duration, usize)>, InvalidationReasonSet)>,\n-    event: Event,\n-    event_start: Event,\n-    event_foreground: Event,\n-    event_background: Event,\n+    /// Event that is triggered when currently_scheduled_foreground_jobs becomes non-zero\n+    event_foreground_start: Event,\n+    /// Event that is triggered when all foreground jobs are done\n+    /// (currently_scheduled_foreground_jobs becomes zero)\n+    event_foreground_done: Event,\n+    /// Event that is triggered when all background jobs are done\n+    event_background_done: Event,\n     program_start: Instant,\n     compilation_events: CompilationEventQueue,\n }\n@@ -499,16 +504,20 @@ impl<B: Backend + 'static> TurboTasks<B> {\n             transient_task_id_factory,\n             execution_id_factory,\n             stopped: AtomicBool::new(false),\n-            currently_scheduled_tasks: AtomicUsize::new(0),\n-            currently_scheduled_background_jobs: AtomicUsize::new(0),\n             currently_scheduled_foreground_jobs: AtomicUsize::new(0),\n+            currently_scheduled_background_jobs: AtomicUsize::new(0),\n             scheduled_tasks: AtomicUsize::new(0),\n             start: Default::default(),\n             aggregated_update: Default::default(),\n-            event: Event::new(|| || \"TurboTasks::event\".to_string()),\n-            event_start: Event::new(|| || \"TurboTasks::event_start\".to_string()),\n-            event_foreground: Event::new(|| || \"TurboTasks::event_foreground\".to_string()),\n-            event_background: Event::new(|| || \"TurboTasks::event_background\".to_string()),\n+            event_foreground_done: Event::new(|| {\n+                || \"TurboTasks::event_foreground_done\".to_string()\n+            }),\n+            event_foreground_start: Event::new(|| {\n+                || \"TurboTasks::event_foreground_start\".to_string()\n+            }),\n+            event_background_done: Event::new(|| {\n+                || \"TurboTasks::event_background_done\".to_string()\n+            }),\n             program_start: Instant::now(),\n             compilation_events: CompilationEventQueue::default(),\n         });\n@@ -688,7 +697,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n \n     #[track_caller]\n     pub(crate) fn schedule(&self, task_id: TaskId) {\n-        self.begin_primary_job();\n+        self.begin_foreground_job();\n         self.scheduled_tasks.fetch_add(1, Ordering::AcqRel);\n \n         let this = self.pin();\n@@ -757,7 +766,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                     .scope(current_task_state, single_execution_future)\n                     .await;\n             }\n-            this.finish_primary_job();\n+            this.finish_foreground_job();\n             anyhow::Ok(())\n         };\n \n@@ -866,27 +875,21 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         RawVc::LocalOutput(execution_id, local_task_id, persistence)\n     }\n \n-    fn begin_primary_job(&self) {\n+    fn begin_foreground_job(&self) {\n         if self\n-            .currently_scheduled_tasks\n+            .currently_scheduled_foreground_jobs\n             .fetch_add(1, Ordering::AcqRel)\n             == 0\n         {\n             *self.start.lock().unwrap() = Some(Instant::now());\n-            self.event_start.notify(usize::MAX);\n+            self.event_foreground_start.notify(usize::MAX);\n             self.backend.idle_end(self);\n         }\n     }\n \n-    fn begin_foreground_job(&self) {\n-        self.begin_primary_job();\n-        self.currently_scheduled_foreground_jobs\n-            .fetch_add(1, Ordering::AcqRel);\n-    }\n-\n-    fn finish_primary_job(&self) {\n+    fn finish_foreground_job(&self) {\n         if self\n-            .currently_scheduled_tasks\n+            .currently_scheduled_foreground_jobs\n             .fetch_sub(1, Ordering::AcqRel)\n             == 1\n         {\n@@ -904,44 +907,28 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                     *update = Some((start.elapsed(), total));\n                 }\n             }\n-            self.event.notify(usize::MAX);\n+            self.event_foreground_done.notify(usize::MAX);\n         }\n     }\n \n-    fn finish_foreground_job(&self) {\n-        if self\n-            .currently_scheduled_foreground_jobs\n-            .fetch_sub(1, Ordering::AcqRel)\n-            == 1\n-        {\n-            self.event_foreground.notify(usize::MAX);\n-        }\n-        self.finish_primary_job();\n+    fn begin_background_job(&self) {\n+        self.currently_scheduled_background_jobs\n+            .fetch_add(1, Ordering::Relaxed);\n     }\n \n-    pub async fn wait_foreground_done(&self) {\n+    fn finish_background_job(&self) {\n         if self\n-            .currently_scheduled_foreground_jobs\n-            .load(Ordering::Acquire)\n-            == 0\n-        {\n-            return;\n-        }\n-        let listener = self.event_foreground.listen();\n-        if self\n-            .currently_scheduled_foreground_jobs\n-            .load(Ordering::Acquire)\n-            == 0\n+            .currently_scheduled_background_jobs\n+            .fetch_sub(1, Ordering::Relaxed)\n+            == 1\n         {\n-            return;\n+            self.event_background_done.notify(usize::MAX);\n         }\n-        listener\n-            .instrument(trace_span!(\"wait_foreground_done\"))\n-            .await;\n     }\n \n     pub fn get_in_progress_count(&self) -> usize {\n-        self.currently_scheduled_tasks.load(Ordering::Acquire)\n+        self.currently_scheduled_foreground_jobs\n+            .load(Ordering::Acquire)\n     }\n \n     /// Waits for the given task to finish executing. This works by performing an untracked read,\n@@ -982,7 +969,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         timeout: Duration,\n     ) -> Option<UpdateInfo> {\n         let listener = self\n-            .event\n+            .event_foreground_done\n             .listen_with_note(|| || \"wait for update info\".to_string());\n         let wait_for_finish = {\n             let (update, reason_set) = &mut *self.aggregated_update.lock().unwrap();\n@@ -1008,9 +995,13 @@ impl<B: Backend + 'static> TurboTasks<B> {\n             } else {\n                 // wait for start, then wait for finish or timeout\n                 let start_listener = self\n-                    .event_start\n+                    .event_foreground_start\n                     .listen_with_note(|| || \"wait for update info\".to_string());\n-                if self.currently_scheduled_tasks.load(Ordering::Acquire) == 0 {\n+                if self\n+                    .currently_scheduled_foreground_jobs\n+                    .load(Ordering::Acquire)\n+                    == 0\n+                {\n                     start_listener.await;\n                 } else {\n                     drop(start_listener);\n@@ -1027,7 +1018,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                     () = tokio::time::sleep(aggregation) => {\n                         break;\n                     }\n-                    () = self.event.listen_with_note(|| || \"wait for update info\".to_string()) => {\n+                    () = self.event_foreground_done.listen_with_note(|| || \"wait for update info\".to_string()) => {\n                         // Resets the sleep\n                     }\n                 }\n@@ -1047,7 +1038,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n     }\n \n     pub async fn wait_background_done(&self) {\n-        let listener = self.event_background.listen();\n+        let listener = self.event_background_done.listen();\n         if self\n             .currently_scheduled_background_jobs\n             .load(Ordering::Acquire)\n@@ -1063,14 +1054,18 @@ impl<B: Backend + 'static> TurboTasks<B> {\n             self.stopped.store(true, Ordering::Release);\n             {\n                 let listener = self\n-                    .event\n+                    .event_foreground_done\n                     .listen_with_note(|| || \"wait for stop\".to_string());\n-                if self.currently_scheduled_tasks.load(Ordering::Acquire) != 0 {\n+                if self\n+                    .currently_scheduled_foreground_jobs\n+                    .load(Ordering::Acquire)\n+                    != 0\n+                {\n                     listener.await;\n                 }\n             }\n             {\n-                let listener = self.event_background.listen();\n+                let listener = self.event_background_done.listen();\n                 if self\n                     .currently_scheduled_background_jobs\n                     .load(Ordering::Acquire)\n@@ -1085,60 +1080,40 @@ impl<B: Backend + 'static> TurboTasks<B> {\n     }\n \n     #[track_caller]\n-    pub(crate) fn schedule_background_job<\n-        T: FnOnce(Arc<TurboTasks<B>>) -> F + Send + 'static,\n-        F: Future<Output = ()> + Send + 'static,\n-    >(\n-        &self,\n-        func: T,\n-    ) {\n-        let this = self.pin();\n-        self.currently_scheduled_background_jobs\n-            .fetch_add(1, Ordering::AcqRel);\n+    pub(crate) fn schedule_foreground_job<T>(&self, func: T)\n+    where\n+        T: AsyncFnOnce(Arc<TurboTasks<B>>) -> Arc<TurboTasks<B>> + Send + 'static,\n+        T::CallOnceFuture: Send,\n+    {\n+        let mut this = self.pin();\n+        this.begin_foreground_job();\n         tokio::spawn(\n             TURBO_TASKS\n                 .scope(this.clone(), async move {\n-                    while this.currently_scheduled_tasks.load(Ordering::Acquire) != 0 {\n-                        let listener = this.event.listen_with_note(|| {\n-                            || \"background job waiting for execution\".to_string()\n-                        });\n-                        if this.currently_scheduled_tasks.load(Ordering::Acquire) != 0 {\n-                            listener.await;\n-                        }\n-                    }\n-                    let this2 = this.clone();\n                     if !this.stopped.load(Ordering::Acquire) {\n-                        func(this).await;\n-                    }\n-                    if this2\n-                        .currently_scheduled_background_jobs\n-                        .fetch_sub(1, Ordering::AcqRel)\n-                        == 1\n-                    {\n-                        this2.event_background.notify(usize::MAX);\n+                        this = func(this.clone()).await;\n                     }\n+                    this.finish_foreground_job();\n                 })\n                 .in_current_span(),\n         );\n     }\n \n     #[track_caller]\n-    pub(crate) fn schedule_foreground_job<\n-        T: FnOnce(Arc<TurboTasks<B>>) -> F + Send + 'static,\n-        F: Future<Output = ()> + Send + 'static,\n-    >(\n-        &self,\n-        func: T,\n-    ) {\n-        let this = self.pin();\n-        this.begin_foreground_job();\n+    pub(crate) fn schedule_background_job<T>(&self, func: T)\n+    where\n+        T: AsyncFnOnce(Arc<TurboTasks<B>>) -> Arc<TurboTasks<B>> + Send + 'static,\n+        T::CallOnceFuture: Send,\n+    {\n+        let mut this = self.pin();\n+        self.begin_background_job();\n         tokio::spawn(\n             TURBO_TASKS\n                 .scope(this.clone(), async move {\n                     if !this.stopped.load(Ordering::Acquire) {\n-                        func(this.clone()).await;\n+                        this = func(this).await;\n                     }\n-                    this.finish_foreground_job();\n+                    this.finish_background_job();\n                 })\n                 .in_current_span(),\n         );\n@@ -1240,9 +1215,9 @@ impl<B: Backend + 'static> TurboTasksCallApi for TurboTasks<B> {\n     ) -> TaskId {\n         let this = self.pin();\n         self.spawn_once_task(async move {\n-            this.finish_primary_job();\n+            this.finish_foreground_job();\n             future.await?;\n-            this.begin_primary_job();\n+            this.begin_foreground_job();\n             Ok(Completion::new())\n         })\n     }\n@@ -1479,54 +1454,20 @@ impl<B: Backend + 'static> TurboTasksBackendApi<B> for TurboTasks<B> {\n \n     #[track_caller]\n     fn schedule_backend_background_job(&self, job: B::BackendJob) {\n-        self.schedule_background_job(move |this| async move {\n+        self.schedule_background_job(async move |this| {\n             this.backend.run_backend_job(job, &*this).await;\n+            this\n         })\n     }\n \n     #[track_caller]\n     fn schedule_backend_foreground_job(&self, job: B::BackendJob) {\n-        self.schedule_foreground_job(move |this| async move {\n+        self.schedule_foreground_job(async move |this| {\n             this.backend.run_backend_job(job, &*this).await;\n+            this\n         })\n     }\n \n-    fn try_foreground_done(&self) -> Result<(), EventListener> {\n-        if self\n-            .currently_scheduled_foreground_jobs\n-            .load(Ordering::Acquire)\n-            == 0\n-        {\n-            return Ok(());\n-        }\n-        let listener = self.event_foreground.listen();\n-        if self\n-            .currently_scheduled_foreground_jobs\n-            .load(Ordering::Acquire)\n-            == 0\n-        {\n-            return Ok(());\n-        }\n-        Err(listener)\n-    }\n-\n-    fn wait_foreground_done_excluding_own<'a>(\n-        &'a self,\n-    ) -> Option<Pin<Box<dyn Future<Output = ()> + Send + 'a>>> {\n-        if self\n-            .currently_scheduled_foreground_jobs\n-            .load(Ordering::Acquire)\n-            == 0\n-        {\n-            return None;\n-        }\n-        Some(Box::pin(async {\n-            self.finish_foreground_job();\n-            self.wait_foreground_done().await;\n-            self.begin_foreground_job();\n-        }))\n-    }\n-\n     /// Enqueues tasks for notification of changed dependencies. This will\n     /// eventually call `dependent_cell_updated()` on all tasks.\n     fn schedule_notify_tasks(&self, tasks: &[TaskId]) {\n@@ -1595,7 +1536,9 @@ impl<B: Backend + 'static> TurboTasksBackendApi<B> for TurboTasks<B> {\n     }\n \n     fn is_idle(&self) -> bool {\n-        self.currently_scheduled_tasks.load(Ordering::Acquire) == 0\n+        self.currently_scheduled_foreground_jobs\n+            .load(Ordering::Acquire)\n+            == 0\n     }\n }\n "
        }
    ],
    "stats": {
        "total": 234,
        "additions": 89,
        "deletions": 145
    }
}