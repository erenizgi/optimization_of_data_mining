{
    "author": "Cy-Tek",
    "message": "fix(turbopack): Recognize urls starting with // as external (#77526)\n\n- fixes\n[PACK-3337](https://linear.app/vercel/issue/PACK-3337/detect-urlexamplecomblahcss-as-external-in-css-imports)\n- This fix allows users to put a url like `@import\n\"//example.com/stylesheet.css\"` in their css files and be treated as an\nexternal url with no specified protocol\n\n \n- Refactors the code for readability by splitting up the different types\nof patterns into their own respective handler functions\n- Moved the `lazy_static` section outside of the function definition to\nslightly increase performance by no longer needing the runtime checks\nfor those elements initialization.\n- Added a test case to help make sure that the output matches what we\nexpect when encountering protocol-relative urls (e.g.\n`//example.com/stylesheet.css`)",
    "sha": "bd37836f8f380f168537910bcb050f0a75ec3a30",
    "files": [
        {
            "sha": "af6a2ab511a6caccf6860fecca1067f872eddb67",
            "filename": "turbopack/crates/turbopack-core/src/resolve/parse.rs",
            "status": "modified",
            "additions": 159,
            "deletions": 138,
            "changes": 297,
            "blob_url": "https://github.com/vercel/next.js/blob/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs?ref=bd37836f8f380f168537910bcb050f0a75ec3a30",
            "patch": "@@ -87,6 +87,13 @@ fn split_off_query_fragment(raw: RcStr) -> (Pattern, Vc<RcStr>, Vc<RcStr>) {\n     )\n }\n \n+lazy_static! {\n+    static ref WINDOWS_PATH: Regex = Regex::new(r\"^[A-Za-z]:\\\\|\\\\\\\\\").unwrap();\n+    static ref URI_PATH: Regex = Regex::new(r\"^([^/\\\\:]+:)(.+)$\").unwrap();\n+    static ref DATA_URI_REMAINDER: Regex = Regex::new(r\"^([^;,]*)(?:;([^,]+))?,(.*)$\").unwrap();\n+    static ref MODULE_PATH: Regex = Regex::new(r\"^((?:@[^/]+/)?[^/]+)(.*)$\").unwrap();\n+}\n+\n impl Request {\n     /// Turns the request into a string.\n     ///\n@@ -136,147 +143,161 @@ impl Request {\n         request.normalize();\n         Ok(match request {\n             Pattern::Dynamic => Request::Dynamic,\n-            Pattern::Constant(r) => {\n-                if r.is_empty() {\n-                    Request::Empty\n-                } else if r.starts_with('/') {\n-                    let (path, query, fragment) = split_off_query_fragment(r);\n-\n-                    Request::ServerRelative {\n-                        path,\n-                        query: query.to_resolved().await?,\n-                        fragment: fragment.to_resolved().await?,\n-                    }\n-                } else if r.starts_with('#') {\n-                    Request::PackageInternal {\n-                        path: Pattern::Constant(r),\n-                    }\n-                } else if r.starts_with(\"./\") || r.starts_with(\"../\") || &*r == \".\" || &*r == \"..\" {\n-                    let (path, query, fragment) = split_off_query_fragment(r);\n-\n-                    Request::Relative {\n-                        path,\n-                        force_in_lookup_dir: false,\n-                        query: query.to_resolved().await?,\n-                        fragment: fragment.to_resolved().await?,\n-                    }\n-                } else {\n-                    lazy_static! {\n-                        static ref WINDOWS_PATH: Regex = Regex::new(r\"^[A-Za-z]:\\\\|\\\\\\\\\").unwrap();\n-                        static ref URI_PATH: Regex = Regex::new(r\"^([^/\\\\:]+:)(.+)$\").unwrap();\n-                        static ref DATA_URI_REMAINDER: Regex =\n-                            Regex::new(r\"^([^;,]*)(?:;([^,]+))?,(.*)$\").unwrap();\n-                        static ref MODULE_PATH: Regex =\n-                            Regex::new(r\"^((?:@[^/]+/)?[^/]+)(.*)$\").unwrap();\n-                    }\n-\n-                    if WINDOWS_PATH.is_match(&r) {\n-                        let (path, query, fragment) = split_off_query_fragment(r);\n-\n-                        return Ok(Request::Windows {\n-                            path,\n-                            query: query.to_resolved().await?,\n-                            fragment: fragment.to_resolved().await?,\n-                        });\n-                    }\n-\n-                    if let Some(caps) = URI_PATH.captures(&r) {\n-                        if let (Some(protocol), Some(remainder)) = (caps.get(1), caps.get(2)) {\n-                            if let Some(caps) = DATA_URI_REMAINDER.captures(remainder.as_str()) {\n-                                let media_type = caps.get(1).map_or(\"\", |m| m.as_str()).into();\n-                                let encoding = caps.get(2).map_or(\"\", |e| e.as_str()).into();\n-                                let data = caps.get(3).map_or(\"\", |d| d.as_str()).into();\n-\n-                                return Ok(Request::DataUri {\n-                                    media_type,\n-                                    encoding,\n-                                    data: ResolvedVc::cell(data),\n-                                });\n-                            }\n-\n-                            return Ok(Request::Uri {\n-                                protocol: protocol.as_str().into(),\n-                                remainder: remainder.as_str().into(),\n-                                query: ResolvedVc::cell(RcStr::default()),\n-                                fragment: ResolvedVc::cell(RcStr::default()),\n-                            });\n-                        }\n-                    }\n-\n-                    if let Some((module, path)) = MODULE_PATH\n-                        .captures(&r)\n-                        .and_then(|caps| caps.get(1).zip(caps.get(2)))\n-                    {\n-                        let (path, query, fragment) =\n-                            split_off_query_fragment(path.as_str().into());\n-\n-                        return Ok(Request::Module {\n-                            module: module.as_str().into(),\n-                            path,\n-                            query: query.to_resolved().await?,\n-                            fragment: fragment.to_resolved().await?,\n-                        });\n-                    }\n-\n-                    Request::Unknown {\n-                        path: Pattern::Constant(r),\n-                    }\n+            Pattern::Constant(r) => Request::parse_constant_pattern(r).await?,\n+            Pattern::Concatenation(list) => Request::parse_concatenation_pattern(list).await?,\n+            Pattern::Alternatives(list) => Request::parse_alternatives_pattern(list).await?,\n+        })\n+    }\n+\n+    async fn parse_constant_pattern(r: RcStr) -> Result<Self> {\n+        if r.is_empty() {\n+            return Ok(Request::Empty);\n+        }\n+\n+        if let Some(remainder) = r.strip_prefix(\"//\") {\n+            return Ok(Request::Uri {\n+                protocol: \"//\".into(),\n+                remainder: remainder.into(),\n+                query: ResolvedVc::cell(RcStr::default()),\n+                fragment: ResolvedVc::cell(RcStr::default()),\n+            });\n+        }\n+\n+        if r.starts_with('/') {\n+            let (path, query, fragment) = split_off_query_fragment(r);\n+\n+            return Ok(Request::ServerRelative {\n+                path,\n+                query: query.to_resolved().await?,\n+                fragment: fragment.to_resolved().await?,\n+            });\n+        }\n+\n+        if r.starts_with('#') {\n+            return Ok(Request::PackageInternal {\n+                path: Pattern::Constant(r),\n+            });\n+        }\n+\n+        if r.starts_with(\"./\") || r.starts_with(\"../\") || r == \".\" || r == \"..\" {\n+            let (path, query, fragment) = split_off_query_fragment(r);\n+\n+            return Ok(Request::Relative {\n+                path,\n+                force_in_lookup_dir: false,\n+                query: query.to_resolved().await?,\n+                fragment: fragment.to_resolved().await?,\n+            });\n+        }\n+\n+        if WINDOWS_PATH.is_match(&r) {\n+            let (path, query, fragment) = split_off_query_fragment(r);\n+\n+            return Ok(Request::Windows {\n+                path,\n+                query: query.to_resolved().await?,\n+                fragment: fragment.to_resolved().await?,\n+            });\n+        }\n+\n+        if let Some(caps) = URI_PATH.captures(&r) {\n+            if let (Some(protocol), Some(remainder)) = (caps.get(1), caps.get(2)) {\n+                if let Some(caps) = DATA_URI_REMAINDER.captures(remainder.as_str()) {\n+                    let media_type = caps.get(1).map_or(\"\", |m| m.as_str()).into();\n+                    let encoding = caps.get(2).map_or(\"\", |e| e.as_str()).into();\n+                    let data = caps.get(3).map_or(\"\", |d| d.as_str()).into();\n+\n+                    return Ok(Request::DataUri {\n+                        media_type,\n+                        encoding,\n+                        data: ResolvedVc::cell(data),\n+                    });\n                 }\n+\n+                return Ok(Request::Uri {\n+                    protocol: protocol.as_str().into(),\n+                    remainder: remainder.as_str().into(),\n+                    query: ResolvedVc::cell(RcStr::default()),\n+                    fragment: ResolvedVc::cell(RcStr::default()),\n+                });\n             }\n-            Pattern::Concatenation(list) => {\n-                let mut iter = list.into_iter();\n-                if let Some(first) = iter.next() {\n-                    let mut result = Box::pin(Self::parse_ref(first)).await?;\n-                    match &mut result {\n-                        Request::Raw { path, .. } => {\n-                            path.extend(iter);\n-                        }\n-                        Request::Relative { path, .. } => {\n-                            path.extend(iter);\n-                        }\n-                        Request::Module { path, .. } => {\n-                            path.extend(iter);\n-                        }\n-                        Request::ServerRelative { path, .. } => {\n-                            path.extend(iter);\n-                        }\n-                        Request::Windows { path, .. } => {\n-                            path.extend(iter);\n-                        }\n-                        Request::Empty => {\n-                            result =\n-                                Box::pin(Self::parse_ref(Pattern::Concatenation(iter.collect())))\n-                                    .await?;\n-                        }\n-                        Request::PackageInternal { path } => {\n-                            path.extend(iter);\n-                        }\n-                        Request::DataUri { .. } => {\n-                            result = Request::Dynamic;\n-                        }\n-                        Request::Uri { .. } => {\n-                            result = Request::Dynamic;\n-                        }\n-                        Request::Unknown { path } => {\n-                            path.extend(iter);\n-                        }\n-                        Request::Dynamic => {}\n-                        Request::Alternatives { .. } => unreachable!(),\n-                    };\n-                    result\n-                } else {\n-                    Request::Empty\n+        }\n+\n+        if let Some((module, path)) = MODULE_PATH\n+            .captures(&r)\n+            .and_then(|caps| caps.get(1).zip(caps.get(2)))\n+        {\n+            let (path, query, fragment) = split_off_query_fragment(path.as_str().into());\n+\n+            return Ok(Request::Module {\n+                module: module.as_str().into(),\n+                path,\n+                query: query.to_resolved().await?,\n+                fragment: fragment.to_resolved().await?,\n+            });\n+        }\n+\n+        Ok(Request::Unknown {\n+            path: Pattern::Constant(r),\n+        })\n+    }\n+\n+    async fn parse_concatenation_pattern(list: Vec<Pattern>) -> Result<Self> {\n+        if list.is_empty() {\n+            return Ok(Request::Empty);\n+        }\n+\n+        let mut result = Box::pin(Self::parse_ref(list[0].clone())).await?;\n+\n+        for item in list.into_iter().skip(1) {\n+            match &mut result {\n+                Request::Raw { path, .. } => {\n+                    path.push(item);\n                 }\n-            }\n-            Pattern::Alternatives(list) => Request::Alternatives {\n-                requests: list\n-                    .into_iter()\n-                    .map(Value::new)\n-                    .map(Request::parse)\n-                    .map(|v| async move { v.to_resolved().await })\n-                    .try_join()\n-                    .await?,\n-            },\n+                Request::Relative { path, .. } => {\n+                    path.push(item);\n+                }\n+                Request::Module { path, .. } => {\n+                    path.push(item);\n+                }\n+                Request::ServerRelative { path, .. } => {\n+                    path.push(item);\n+                }\n+                Request::Windows { path, .. } => {\n+                    path.push(item);\n+                }\n+                Request::Empty => {\n+                    result = Box::pin(Self::parse_ref(item)).await?;\n+                }\n+                Request::PackageInternal { path } => {\n+                    path.push(item);\n+                }\n+                Request::DataUri { .. } => {\n+                    result = Request::Dynamic;\n+                }\n+                Request::Uri { .. } => {\n+                    result = Request::Dynamic;\n+                }\n+                Request::Unknown { path } => {\n+                    path.push(item);\n+                }\n+                Request::Dynamic => {}\n+                Request::Alternatives { .. } => unreachable!(),\n+            };\n+        }\n+\n+        Ok(result)\n+    }\n+\n+    async fn parse_alternatives_pattern(list: Vec<Pattern>) -> Result<Self> {\n+        Ok(Request::Alternatives {\n+            requests: list\n+                .into_iter()\n+                .map(Value::new)\n+                .map(Request::parse)\n+                .map(|v| async move { v.to_resolved().await })\n+                .try_join()\n+                .await?,\n         })\n     }\n }"
        },
        {
            "sha": "c36643743f0c0bcbab2b395f989606d6e46a3cfd",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/input/index.css",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Finput%2Findex.css",
            "raw_url": "https://github.com/vercel/next.js/raw/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Finput%2Findex.css",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Finput%2Findex.css?ref=bd37836f8f380f168537910bcb050f0a75ec3a30",
            "patch": "@@ -0,0 +1,6 @@\n+@import url(\"//example.com/something.css\");\n+@import \"//somewhere.com/example.css\";\n+\n+.foo {\n+    background: red;\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "7505b6f5e0a3db6d5e82018e9ab466f3582db2fa",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/input/index.js",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Finput%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Finput%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Finput%2Findex.js?ref=bd37836f8f380f168537910bcb050f0a75ec3a30",
            "patch": "@@ -0,0 +1 @@\n+import './index.css'\n\\ No newline at end of file"
        },
        {
            "sha": "dbf4bbf50d5f7cbbf9f76826bc10750e92bea65d",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/output/4c35f_tests_snapshot_css_protocol-dependent-import_input_index_27f91733.css",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_27f91733.css",
            "raw_url": "https://github.com/vercel/next.js/raw/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_27f91733.css",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_27f91733.css?ref=bd37836f8f380f168537910bcb050f0a75ec3a30",
            "patch": "@@ -0,0 +1,6 @@\n+@import \"//example.com/something.css\";\n+@import \"//somewhere.com/example.css\";\n+/* [project]/turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/input/index.css [test] (css) */\n+.foo{background:red}\n+\n+/*# sourceMappingURL=4c35f_tests_snapshot_css_protocol-dependent-import_input_index_27f91733.css.map*/\n\\ No newline at end of file"
        },
        {
            "sha": "d634480cb025237b5ecd85070b21222e91756f91",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/output/4c35f_tests_snapshot_css_protocol-dependent-import_input_index_27f91733.css.map",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_27f91733.css.map",
            "raw_url": "https://github.com/vercel/next.js/raw/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_27f91733.css.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_27f91733.css.map?ref=bd37836f8f380f168537910bcb050f0a75ec3a30",
            "patch": "@@ -0,0 +1,7 @@\n+{\n+  \"version\": 3,\n+  \"sources\": [],\n+  \"sections\": [\n+    {\"offset\": {\"line\": 3, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[project]/turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/input/index.css\"],\"sourcesContent\":[\"@import url(\\\"//example.com/something.css\\\");\\n@import \\\"//somewhere.com/example.css\\\";\\n\\n.foo {\\n    background: red;\\n}\"],\"names\":[],\"mappings\":\"AAGA\"}},\n+    {\"offset\": {\"line\": 3, \"column\": 20}, \"map\": {\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"A\"}}]\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "a5de8c6d7d6c9819d196d625dd199281a557fb08",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/output/4c35f_tests_snapshot_css_protocol-dependent-import_input_index_3598d8f7.js",
            "status": "added",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_3598d8f7.js",
            "raw_url": "https://github.com/vercel/next.js/raw/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_3598d8f7.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_3598d8f7.js?ref=bd37836f8f380f168537910bcb050f0a75ec3a30",
            "patch": "@@ -0,0 +1,13 @@\n+(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([\"output/4c35f_tests_snapshot_css_protocol-dependent-import_input_index_3598d8f7.js\", {\n+\n+\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/input/index.js [test] (ecmascript)\": ((__turbopack_context__) => {\n+\"use strict\";\n+\n+var { g: global, __dirname } = __turbopack_context__;\n+{\n+__turbopack_context__.s({});\n+;\n+}}),\n+}]);\n+\n+//# sourceMappingURL=4c35f_tests_snapshot_css_protocol-dependent-import_input_index_3598d8f7.js.map\n\\ No newline at end of file"
        },
        {
            "sha": "812ee7bf5c50e1a03a07f03df3f9c05a8ee1e64c",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/output/4c35f_tests_snapshot_css_protocol-dependent-import_input_index_3598d8f7.js.map",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_3598d8f7.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_3598d8f7.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_3598d8f7.js.map?ref=bd37836f8f380f168537910bcb050f0a75ec3a30",
            "patch": "@@ -0,0 +1,6 @@\n+{\n+  \"version\": 3,\n+  \"sources\": [],\n+  \"sections\": [\n+    {\"offset\": {\"line\": 7, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\"}}]\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "e6c0827fc2b6560450c00ed75d94637b10ebcdbf",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/output/4c35f_tests_snapshot_css_protocol-dependent-import_input_index_f11386a8.js",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_f11386a8.js",
            "raw_url": "https://github.com/vercel/next.js/raw/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_f11386a8.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_f11386a8.js?ref=bd37836f8f380f168537910bcb050f0a75ec3a30",
            "patch": "@@ -0,0 +1,6 @@\n+(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([\n+    \"output/4c35f_tests_snapshot_css_protocol-dependent-import_input_index_f11386a8.js\",\n+    {},\n+    {\"otherChunks\":[{\"path\":\"output/4c35f_tests_snapshot_css_protocol-dependent-import_input_index_27f91733.css\",\"included\":[\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/input/index.css [test] (css)\"]},\"output/4c35f_tests_snapshot_css_protocol-dependent-import_input_index_3598d8f7.js\"],\"runtimeModuleIds\":[\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/input/index.js [test] (ecmascript)\"]}\n+]);\n+// Dummy runtime\n\\ No newline at end of file"
        },
        {
            "sha": "c15d7ec00382d3604310ddb8b53cbdb90d9e1942",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/css/protocol-dependent-import/output/4c35f_tests_snapshot_css_protocol-dependent-import_input_index_f11386a8.js.map",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_f11386a8.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/bd37836f8f380f168537910bcb050f0a75ec3a30/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_f11386a8.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcss%2Fprotocol-dependent-import%2Foutput%2F4c35f_tests_snapshot_css_protocol-dependent-import_input_index_f11386a8.js.map?ref=bd37836f8f380f168537910bcb050f0a75ec3a30",
            "patch": "@@ -0,0 +1,5 @@\n+{\n+  \"version\": 3,\n+  \"sources\": [],\n+  \"sections\": []\n+}\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 347,
        "additions": 209,
        "deletions": 138
    }
}