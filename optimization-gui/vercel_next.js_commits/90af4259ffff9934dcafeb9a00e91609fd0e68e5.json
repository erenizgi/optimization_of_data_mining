{
    "author": "timneutkens",
    "message": "Development: Remove TypeScript from the hot path during bootup (#84090)\n\n## What?\n\nChanges the way TypeScript config validation behaves. It no longer does\n`require('typescript')` and instead reads the `tsconfig.json`.\n\nThis introduces one new limitation which is that `extends` and\n`references` cause the automatic config rewriting to be skipped, i.e. it\ndoes not verify your `extends`​ / `references`​.\n\nIn my opinion that tradeoff is fine though because if you're using these\nyou likely already don't want Next.js to actively write into the project\nconfig file. At least that has been a common feedback from the\ncommunity.\n\nIn cpu profiles this change shows 115ms -> 4ms.\n\nWhy does it take 115ms? TypeScript itself is quite large, lot of code to\nparse. However, we're only reading a few values from it like the\nversion, some config options, and the config reading logic itself. In\nthe CPU profile it really is showing 4ms spent in Next.js and the rest\nis the process of requiring TypeScript.",
    "sha": "90af4259ffff9934dcafeb9a00e91609fd0e68e5",
    "files": [
        {
            "sha": "64a5b44adc91da61b91272cbef69ac37b64f12ae",
            "filename": "packages/next/src/lib/has-necessary-dependencies.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Fhas-necessary-dependencies.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Fhas-necessary-dependencies.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fhas-necessary-dependencies.ts?ref=90af4259ffff9934dcafeb9a00e91609fd0e68e5",
            "patch": "@@ -43,6 +43,8 @@ export function hasNecessaryDependencies(\n       )\n       const pkgDir = dirname(pkgPath)\n \n+      resolutions.set(join(p.pkg, 'package.json'), pkgPath)\n+\n       if (p.exportsRestrict) {\n         const fileNameToVerify = relative(p.pkg, p.file)\n         if (fileNameToVerify) {"
        },
        {
            "sha": "a775b122bce687929be4580310506f66e28ba7e1",
            "filename": "packages/next/src/lib/typescript/getTypeScriptConfiguration.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 8,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FgetTypeScriptConfiguration.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FgetTypeScriptConfiguration.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FgetTypeScriptConfiguration.ts?ref=90af4259ffff9934dcafeb9a00e91609fd0e68e5",
            "patch": "@@ -6,36 +6,41 @@ import { FatalError } from '../fatal-error'\n import isError from '../is-error'\n \n export async function getTypeScriptConfiguration(\n-  ts: typeof import('typescript'),\n+  typescript: typeof import('typescript'),\n   tsConfigPath: string,\n   metaOnly?: boolean\n ): Promise<import('typescript').ParsedCommandLine> {\n   try {\n     const formatDiagnosticsHost: import('typescript').FormatDiagnosticsHost = {\n       getCanonicalFileName: (fileName: string) => fileName,\n-      getCurrentDirectory: ts.sys.getCurrentDirectory,\n+      getCurrentDirectory: typescript.sys.getCurrentDirectory,\n       getNewLine: () => os.EOL,\n     }\n \n-    const { config, error } = ts.readConfigFile(tsConfigPath, ts.sys.readFile)\n+    const { config, error } = typescript.readConfigFile(\n+      tsConfigPath,\n+      typescript.sys.readFile\n+    )\n     if (error) {\n-      throw new FatalError(ts.formatDiagnostic(error, formatDiagnosticsHost))\n+      throw new FatalError(\n+        typescript.formatDiagnostic(error, formatDiagnosticsHost)\n+      )\n     }\n \n     let configToParse: any = config\n \n-    const result = ts.parseJsonConfigFileContent(\n+    const result = typescript.parseJsonConfigFileContent(\n       configToParse,\n       // When only interested in meta info,\n       // avoid enumerating all files (for performance reasons)\n       metaOnly\n         ? {\n-            ...ts.sys,\n+            ...typescript.sys,\n             readDirectory(_path, extensions, _excludes, _includes, _depth) {\n               return [extensions ? `file${extensions[0]}` : `file.ts`]\n             },\n           }\n-        : ts.sys,\n+        : typescript.sys,\n       path.dirname(tsConfigPath)\n     )\n \n@@ -49,7 +54,7 @@ export async function getTypeScriptConfiguration(\n \n     if (result.errors?.length) {\n       throw new FatalError(\n-        ts.formatDiagnostic(result.errors[0], formatDiagnosticsHost)\n+        typescript.formatDiagnostic(result.errors[0], formatDiagnosticsHost)\n       )\n     }\n "
        },
        {
            "sha": "459a5df9c02bf8645fb6793a566d6ec1e98a9722",
            "filename": "packages/next/src/lib/typescript/getTypeScriptIntent.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 7,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FgetTypeScriptIntent.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FgetTypeScriptIntent.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FgetTypeScriptIntent.ts?ref=90af4259ffff9934dcafeb9a00e91609fd0e68e5",
            "patch": "@@ -1,4 +1,4 @@\n-import { existsSync, promises as fs } from 'fs'\n+import { existsSync, readFileSync } from 'fs'\n import path from 'path'\n import { recursiveReadDir } from '../recursive-readdir'\n \n@@ -15,12 +15,10 @@ export async function getTypeScriptIntent(\n   // project.\n   const hasTypeScriptConfiguration = existsSync(resolvedTsConfigPath)\n   if (hasTypeScriptConfiguration) {\n-    const content = await fs\n-      .readFile(resolvedTsConfigPath, { encoding: 'utf8' })\n-      .then(\n-        (txt) => txt.trim(),\n-        () => null\n-      )\n+    const content = readFileSync(resolvedTsConfigPath, {\n+      encoding: 'utf8',\n+    }).trim()\n+\n     return { firstTimeSetup: content === '' || content === '{}' }\n   }\n "
        },
        {
            "sha": "efae53ad441fe5c2d745ea8096c023ed35822308",
            "filename": "packages/next/src/lib/typescript/runTypeCheck.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 13,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FrunTypeCheck.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FrunTypeCheck.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FrunTypeCheck.ts?ref=90af4259ffff9934dcafeb9a00e91609fd0e68e5",
            "patch": "@@ -15,15 +15,15 @@ export interface TypeCheckResult {\n }\n \n export async function runTypeCheck(\n-  ts: typeof import('typescript'),\n+  typescript: typeof import('typescript'),\n   baseDir: string,\n   distDir: string,\n   tsConfigPath: string,\n   cacheDir?: string,\n   isAppDirEnabled?: boolean\n ): Promise<TypeCheckResult> {\n   const effectiveConfiguration = await getTypeScriptConfiguration(\n-    ts,\n+    typescript,\n     tsConfigPath\n   )\n \n@@ -35,7 +35,7 @@ export async function runTypeCheck(\n       incremental: false,\n     }\n   }\n-  const requiredConfig = getRequiredConfiguration(ts)\n+  const requiredConfig = getRequiredConfiguration(typescript)\n \n   const options = {\n     ...requiredConfig,\n@@ -56,7 +56,7 @@ export async function runTypeCheck(\n       )\n     }\n     incremental = true\n-    program = ts.createIncrementalProgram({\n+    program = typescript.createIncrementalProgram({\n       rootNames: effectiveConfiguration.fileNames,\n       options: {\n         ...options,\n@@ -66,7 +66,10 @@ export async function runTypeCheck(\n       },\n     })\n   } else {\n-    program = ts.createProgram(effectiveConfiguration.fileNames, options)\n+    program = typescript.createProgram(\n+      effectiveConfiguration.fileNames,\n+      options\n+    )\n   }\n \n   const result = program.emit()\n@@ -81,25 +84,35 @@ export async function runTypeCheck(\n     ignoreRegex.map((r) => r.source).join('|')\n   )\n \n-  const allDiagnostics = ts\n+  const allDiagnostics = typescript\n     .getPreEmitDiagnostics(program as import('typescript').Program)\n     .concat(result.diagnostics)\n     .filter((d) => !(d.file && regexIgnoredFile.test(d.file.fileName)))\n \n   const firstError =\n     allDiagnostics.find(\n-      (d) => d.category === ts.DiagnosticCategory.Error && Boolean(d.file)\n-    ) ?? allDiagnostics.find((d) => d.category === ts.DiagnosticCategory.Error)\n+      (d) =>\n+        d.category === typescript.DiagnosticCategory.Error && Boolean(d.file)\n+    ) ??\n+    allDiagnostics.find(\n+      (d) => d.category === typescript.DiagnosticCategory.Error\n+    )\n \n   // In test mode, we want to check all diagnostics, not just the first one.\n   if (process.env.__NEXT_TEST_MODE) {\n     if (firstError) {\n       const allErrors = allDiagnostics\n-        .filter((d) => d.category === ts.DiagnosticCategory.Error)\n+        .filter((d) => d.category === typescript.DiagnosticCategory.Error)\n         .map(\n           (d) =>\n             '[Test Mode] ' +\n-            getFormattedDiagnostic(ts, baseDir, distDir, d, isAppDirEnabled)\n+            getFormattedDiagnostic(\n+              typescript,\n+              baseDir,\n+              distDir,\n+              d,\n+              isAppDirEnabled\n+            )\n         )\n \n       console.error(\n@@ -115,14 +128,20 @@ export async function runTypeCheck(\n \n   if (firstError) {\n     throw new CompileError(\n-      getFormattedDiagnostic(ts, baseDir, distDir, firstError, isAppDirEnabled)\n+      getFormattedDiagnostic(\n+        typescript,\n+        baseDir,\n+        distDir,\n+        firstError,\n+        isAppDirEnabled\n+      )\n     )\n   }\n \n   const warnings = allDiagnostics\n-    .filter((d) => d.category === ts.DiagnosticCategory.Warning)\n+    .filter((d) => d.category === typescript.DiagnosticCategory.Warning)\n     .map((d) =>\n-      getFormattedDiagnostic(ts, baseDir, distDir, d, isAppDirEnabled)\n+      getFormattedDiagnostic(typescript, baseDir, distDir, d, isAppDirEnabled)\n     )\n \n   return {"
        },
        {
            "sha": "bc99e1da18ddfec5c14779c7366fd987e3d0e86d",
            "filename": "packages/next/src/lib/typescript/writeConfigurationDefaults.test.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 60,
            "changes": 67,
            "blob_url": "https://github.com/vercel/next.js/blob/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FwriteConfigurationDefaults.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FwriteConfigurationDefaults.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FwriteConfigurationDefaults.test.ts?ref=90af4259ffff9934dcafeb9a00e91609fd0e68e5",
            "patch": "@@ -40,7 +40,7 @@ describe('writeConfigurationDefaults()', () => {\n       })\n \n       await writeConfigurationDefaults(\n-        ts,\n+        ts.version,\n         tsConfigPath,\n         isFirstTimeSetup,\n         hasAppDir,\n@@ -128,7 +128,7 @@ describe('writeConfigurationDefaults()', () => {\n       )\n \n       await writeConfigurationDefaults(\n-        ts,\n+        ts.version,\n         tsConfigPath,\n         isFirstTimeSetup,\n         hasAppDir,\n@@ -150,7 +150,7 @@ describe('writeConfigurationDefaults()', () => {\n         nextAppTypes = `${distDir}/types/**/*.ts`\n       })\n \n-      it('should support empty includes when base provides it', async () => {\n+      it('should not change tsconfig with extends', async () => {\n         const include = ['**/*.ts', '**/*.tsx', nextAppTypes, '**/*.mts']\n         const content = { extends: './tsconfig.base.json' }\n         const baseContent = { include }\n@@ -160,7 +160,7 @@ describe('writeConfigurationDefaults()', () => {\n \n         await expect(\n           writeConfigurationDefaults(\n-            ts,\n+            ts.version,\n             tsConfigPath,\n             isFirstTimeSetup,\n             hasAppDir,\n@@ -173,62 +173,9 @@ describe('writeConfigurationDefaults()', () => {\n         const parsed = JSON.parse(output)\n \n         expect(parsed.include).toBeUndefined()\n-      })\n-\n-      it('should replace includes when base is missing appTypes', async () => {\n-        const include = ['**/*.ts', '**/*.tsx', '**/*.mts']\n-        const content = { extends: './tsconfig.base.json' }\n-        const baseContent = { include }\n-\n-        await writeFile(tsConfigPath, JSON.stringify(content, null, 2))\n-        await writeFile(tsConfigBasePath, JSON.stringify(baseContent, null, 2))\n-\n-        await expect(\n-          writeConfigurationDefaults(\n-            ts,\n-            tsConfigPath,\n-            isFirstTimeSetup,\n-            hasAppDir,\n-            distDir,\n-            hasPagesDir\n-          )\n-        ).resolves.not.toThrow()\n-\n-        const output = await readFile(tsConfigPath, 'utf8')\n-        const parsed = JSON.parse(output)\n-\n-        expect(parsed.include.sort()).toMatchInlineSnapshot(`\n-         [\n-           \"**/*.mts\",\n-           \"**/*.ts\",\n-           \"**/*.tsx\",\n-           \".next/types/**/*.ts\",\n-         ]\n-        `)\n-      })\n-\n-      it('should not add strictNullChecks if base provides it', async () => {\n-        const content = { extends: './tsconfig.base.json' }\n-\n-        const baseContent = {\n-          compilerOptions: { strictNullChecks: true, strict: true },\n-        }\n-\n-        await writeFile(tsConfigPath, JSON.stringify(content, null, 2))\n-        await writeFile(tsConfigBasePath, JSON.stringify(baseContent, null, 2))\n-\n-        await writeConfigurationDefaults(\n-          ts,\n-          tsConfigPath,\n-          isFirstTimeSetup,\n-          hasAppDir,\n-          distDir,\n-          hasPagesDir\n-        )\n-        const output = await readFile(tsConfigPath, 'utf8')\n-        const parsed = JSON.parse(output)\n-\n-        expect(parsed.compilerOptions.strictNullChecks).toBeUndefined()\n+        expect(parsed).toStrictEqual({\n+          extends: './tsconfig.base.json',\n+        })\n       })\n     })\n   })"
        },
        {
            "sha": "295ef689d8bec229ab77f71aeb62ac37dc82902b",
            "filename": "packages/next/src/lib/typescript/writeConfigurationDefaults.ts",
            "status": "modified",
            "additions": 136,
            "deletions": 90,
            "changes": 226,
            "blob_url": "https://github.com/vercel/next.js/blob/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FwriteConfigurationDefaults.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FwriteConfigurationDefaults.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Ftypescript%2FwriteConfigurationDefaults.ts?ref=90af4259ffff9934dcafeb9a00e91609fd0e68e5",
            "patch": "@@ -1,10 +1,9 @@\n-import { promises as fs } from 'fs'\n+import { readFileSync, writeFileSync } from 'fs'\n import { bold, cyan, white } from '../picocolors'\n import * as CommentJson from 'next/dist/compiled/comment-json'\n import semver from 'next/dist/compiled/semver'\n import os from 'os'\n import type { CompilerOptions } from 'typescript'\n-import { getTypeScriptConfiguration } from './getTypeScriptConfiguration'\n import * as Log from '../../build/output/log'\n \n type DesiredCompilerOptionsShape = {\n@@ -19,10 +18,28 @@ type DesiredCompilerOptionsShape = {\n }\n \n function getDesiredCompilerOptions(\n-  ts: typeof import('typescript'),\n-  tsOptions?: CompilerOptions\n+  typescriptVersion: string,\n+  userTsConfig?: Record<string, any>\n ): DesiredCompilerOptionsShape {\n-  const o: DesiredCompilerOptionsShape = {\n+  // ModuleKind\n+  const moduleKindESNext = 'esnext'\n+  const moduleKindES2020 = 'es2020'\n+  const moduleKindPreserve = 'preserve'\n+  const moduleKindNodeNext = 'nodenext'\n+  const moduleKindNode16 = 'node16'\n+  const moduleKindCommonJS = 'commonjs'\n+  const moduleKindAMD = 'amd'\n+\n+  // ModuleResolutionKind\n+  const moduleResolutionKindBundler = 'bundler'\n+  const moduleResolutionKindNode10 = 'node10'\n+  const moduleResolutionKindNode12 = 'node12'\n+  const moduleResolutionKindNodeJs = 'node'\n+\n+  // Jsx\n+  const jsxEmitReactJSX = 'react-jsx'\n+\n+  return {\n     target: {\n       suggested: 'ES2017',\n       reason:\n@@ -34,35 +51,35 @@ function getDesiredCompilerOptions(\n     allowJs: { suggested: true },\n     skipLibCheck: { suggested: true },\n     strict: { suggested: false },\n-    ...(semver.lt(ts.version, '5.0.0')\n+    ...(semver.lt(typescriptVersion, '5.0.0')\n       ? { forceConsistentCasingInFileNames: { suggested: true } }\n       : undefined),\n     noEmit: { suggested: true },\n-    ...(semver.gte(ts.version, '4.4.2')\n+    ...(semver.gte(typescriptVersion, '4.4.2')\n       ? { incremental: { suggested: true } }\n       : undefined),\n \n     // These values are required and cannot be changed by the user\n     // Keep this in sync with the webpack config\n     // 'parsedValue' matches the output value from ts.parseJsonConfigFileContent()\n     module: {\n-      parsedValue: ts.ModuleKind.ESNext,\n+      parsedValue: moduleKindESNext,\n       // All of these values work:\n       parsedValues: [\n-        semver.gte(ts.version, '5.4.0') && (ts.ModuleKind as any).Preserve,\n-        ts.ModuleKind.ES2020,\n-        ts.ModuleKind.ESNext,\n-        ts.ModuleKind.CommonJS,\n-        ts.ModuleKind.AMD,\n-        ts.ModuleKind.NodeNext,\n-        ts.ModuleKind.Node16,\n+        semver.gte(typescriptVersion, '5.4.0') && moduleKindPreserve,\n+        moduleKindES2020,\n+        moduleKindESNext,\n+        moduleKindCommonJS,\n+        moduleKindAMD,\n+        moduleKindNodeNext,\n+        moduleKindNode16,\n       ],\n       value: 'esnext',\n       reason: 'for dynamic import() support',\n     },\n     // TODO: Semver check not needed once Next.js repo uses 5.4.\n-    ...(semver.gte(ts.version, '5.4.0') &&\n-    tsOptions?.module === (ts.ModuleKind as any).Preserve\n+    ...(semver.gte(typescriptVersion, '5.4.0') &&\n+    userTsConfig?.compilerOptions?.module?.toLowerCase() === moduleKindPreserve\n       ? {\n           // TypeScript 5.4 introduced `Preserve`. Using `Preserve` implies\n           // - `moduleResolution` is `Bundler`\n@@ -77,21 +94,17 @@ function getDesiredCompilerOptions(\n           },\n           moduleResolution: {\n             // In TypeScript 5.0, `NodeJs` has renamed to `Node10`\n-            parsedValue:\n-              ts.ModuleResolutionKind.Bundler ??\n-              ts.ModuleResolutionKind.NodeNext ??\n-              (ts.ModuleResolutionKind as any).Node10 ??\n-              ts.ModuleResolutionKind.NodeJs,\n+            parsedValue: moduleResolutionKindBundler,\n             // All of these values work:\n             parsedValues: [\n-              (ts.ModuleResolutionKind as any).Node10 ??\n-                ts.ModuleResolutionKind.NodeJs,\n+              moduleResolutionKindNode10,\n+              moduleResolutionKindNodeJs,\n               // only newer TypeScript versions have this field, it\n               // will be filtered for new versions of TypeScript\n-              (ts.ModuleResolutionKind as any).Node12,\n-              ts.ModuleResolutionKind.Node16,\n-              ts.ModuleResolutionKind.NodeNext,\n-              ts.ModuleResolutionKind.Bundler,\n+              moduleResolutionKindNode12,\n+              moduleKindNode16,\n+              moduleKindNodeNext,\n+              moduleResolutionKindBundler,\n             ].filter((val) => typeof val !== 'undefined'),\n             value: 'node',\n             reason: 'to match webpack resolution',\n@@ -101,7 +114,7 @@ function getDesiredCompilerOptions(\n             reason: 'to match webpack resolution',\n           },\n         }),\n-    ...(tsOptions?.verbatimModuleSyntax === true\n+    ...(userTsConfig?.compilerOptions?.verbatimModuleSyntax === true\n       ? undefined\n       : {\n           isolatedModules: {\n@@ -110,27 +123,61 @@ function getDesiredCompilerOptions(\n           },\n         }),\n     jsx: {\n-      parsedValue: ts.JsxEmit.ReactJSX,\n+      parsedValue: jsxEmitReactJSX,\n       value: 'react-jsx',\n       reason: 'next.js uses the React automatic runtime',\n     },\n-  }\n-\n-  return o\n+  } satisfies DesiredCompilerOptionsShape\n }\n \n export function getRequiredConfiguration(\n-  ts: typeof import('typescript')\n+  typescript: typeof import('typescript')\n ): Partial<import('typescript').CompilerOptions> {\n   const res: Partial<import('typescript').CompilerOptions> = {}\n+  const typescriptVersion = typescript.version\n \n-  const desiredCompilerOptions = getDesiredCompilerOptions(ts)\n+  const desiredCompilerOptions = getDesiredCompilerOptions(typescriptVersion)\n   for (const optionKey of Object.keys(desiredCompilerOptions)) {\n     const ev = desiredCompilerOptions[optionKey]\n     if (!('value' in ev)) {\n       continue\n     }\n-    res[optionKey] = ev.parsedValue ?? ev.value\n+\n+    const value = ev.parsedValue ?? ev.value\n+\n+    // Convert string values back to TypeScript enum values\n+    if (optionKey === 'module' && typeof value === 'string') {\n+      const moduleMap: Record<string, import('typescript').ModuleKind> = {\n+        esnext: typescript.ModuleKind.ESNext,\n+        es2020: typescript.ModuleKind.ES2020,\n+        ...(typescript.ModuleKind.Preserve !== undefined\n+          ? { preserve: typescript.ModuleKind.Preserve }\n+          : {}),\n+        nodenext: typescript.ModuleKind.NodeNext,\n+        node16: typescript.ModuleKind.Node16,\n+        commonjs: typescript.ModuleKind.CommonJS,\n+        amd: typescript.ModuleKind.AMD,\n+      }\n+      res[optionKey] = moduleMap[value.toLowerCase()] ?? value\n+    } else if (optionKey === 'moduleResolution' && typeof value === 'string') {\n+      const moduleResolutionMap: Record<\n+        string,\n+        import('typescript').ModuleResolutionKind\n+      > = {\n+        bundler: typescript.ModuleResolutionKind.Bundler,\n+        node10: typescript.ModuleResolutionKind.Node10,\n+        node12: (typescript.ModuleResolutionKind as any).Node12,\n+        node: typescript.ModuleResolutionKind.NodeJs,\n+      }\n+      res[optionKey] = moduleResolutionMap[value.toLowerCase()] ?? value\n+    } else if (optionKey === 'jsx' && typeof value === 'string') {\n+      const jsxMap: Record<string, import('typescript').JsxEmit> = {\n+        'react-jsx': typescript.JsxEmit.ReactJSX,\n+      }\n+      res[optionKey] = jsxMap[value.toLowerCase()] ?? value\n+    } else {\n+      res[optionKey] = value\n+    }\n   }\n \n   return res\n@@ -140,40 +187,43 @@ const localDevTestFilesExcludeAction =\n   'NEXT_PRIVATE_LOCAL_DEV_TEST_FILES_EXCLUDE'\n \n export async function writeConfigurationDefaults(\n-  ts: typeof import('typescript'),\n+  typescriptVersion: string,\n   tsConfigPath: string,\n   isFirstTimeSetup: boolean,\n   hasAppDir: boolean,\n   distDir: string,\n   hasPagesDir: boolean\n ): Promise<void> {\n   if (isFirstTimeSetup) {\n-    await fs.writeFile(tsConfigPath, '{}' + os.EOL)\n+    writeFileSync(tsConfigPath, '{}' + os.EOL)\n   }\n \n-  const { options: tsOptions, raw: rawConfig } =\n-    await getTypeScriptConfiguration(ts, tsConfigPath, true)\n-\n-  const userTsConfigContent = await fs.readFile(tsConfigPath, {\n+  const userTsConfigContent = readFileSync(tsConfigPath, {\n     encoding: 'utf8',\n   })\n   const userTsConfig = CommentJson.parse(userTsConfigContent)\n-  if (userTsConfig.compilerOptions == null && !('extends' in rawConfig)) {\n+\n+  // Bail automatic setup when the user has extended or referenced another config\n+  if ('extends' in userTsConfig || 'references' in userTsConfig) {\n+    return\n+  }\n+\n+  if (userTsConfig?.compilerOptions == null) {\n     userTsConfig.compilerOptions = {}\n     isFirstTimeSetup = true\n   }\n \n-  const desiredCompilerOptions = getDesiredCompilerOptions(ts, tsOptions)\n+  const desiredCompilerOptions = getDesiredCompilerOptions(\n+    typescriptVersion,\n+    userTsConfig\n+  )\n \n   const suggestedActions: string[] = []\n   const requiredActions: string[] = []\n-  for (const optionKey of Object.keys(desiredCompilerOptions)) {\n+  for (const optionKey in desiredCompilerOptions) {\n     const check = desiredCompilerOptions[optionKey]\n     if ('suggested' in check) {\n-      if (!(optionKey in tsOptions)) {\n-        if (!userTsConfig.compilerOptions) {\n-          userTsConfig.compilerOptions = {}\n-        }\n+      if (!(optionKey in userTsConfig?.compilerOptions)) {\n         userTsConfig.compilerOptions[optionKey] = check.suggested\n         suggestedActions.push(\n           cyan(optionKey) +\n@@ -183,14 +233,28 @@ export async function writeConfigurationDefaults(\n         )\n       }\n     } else if ('value' in check) {\n-      const ev = tsOptions[optionKey]\n-      if (\n-        !('parsedValues' in check\n-          ? check.parsedValues?.includes(ev)\n-          : 'parsedValue' in check\n-            ? check.parsedValue === ev\n-            : check.value === ev)\n-      ) {\n+      let existingValue = userTsConfig?.compilerOptions?.[optionKey]\n+\n+      if (typeof existingValue === 'string') {\n+        existingValue = existingValue.toLowerCase()\n+      }\n+\n+      const shouldWriteRequiredValue = () => {\n+        // Check if the option has multiple allowed values\n+        if (check.parsedValues) {\n+          return !check.parsedValues.includes(existingValue)\n+        }\n+\n+        // Check if the option has a single parsed value\n+        if (check.parsedValue) {\n+          return check.parsedValue !== existingValue\n+        }\n+\n+        // Fall back to direct value comparison\n+        return check.value !== existingValue\n+      }\n+\n+      if (shouldWriteRequiredValue()) {\n         if (!userTsConfig.compilerOptions) {\n           userTsConfig.compilerOptions = {}\n         }\n@@ -210,7 +274,7 @@ export async function writeConfigurationDefaults(\n \n   const nextAppTypes = `${distDir}/types/**/*.ts`\n \n-  if (!('include' in rawConfig)) {\n+  if (!('include' in userTsConfig)) {\n     userTsConfig.include = hasAppDir\n       ? ['next-env.d.ts', nextAppTypes, '**/*.mts', '**/*.ts', '**/*.tsx']\n       : ['next-env.d.ts', '**/*.mts', '**/*.ts', '**/*.tsx']\n@@ -225,48 +289,29 @@ export async function writeConfigurationDefaults(\n     )\n   } else if (hasAppDir) {\n     const missingFromResolved = []\n-    if (!rawConfig.include.includes(nextAppTypes)) {\n+    if (!userTsConfig.include.includes(nextAppTypes)) {\n       missingFromResolved.push(nextAppTypes)\n     }\n \n     if (missingFromResolved.length > 0) {\n       if (!Array.isArray(userTsConfig.include)) {\n         userTsConfig.include = []\n       }\n-      // rawConfig will resolve all extends and include paths (ex: tsconfig.json, tsconfig.base.json, etc.)\n-      // if it doesn't match userTsConfig then update the userTsConfig to add the\n-      // rawConfig's includes in addition to missing items\n-      if (\n-        rawConfig.include.length !== userTsConfig.include.length ||\n-        JSON.stringify(rawConfig.include.sort()) !==\n-          JSON.stringify(userTsConfig.include.sort())\n-      ) {\n-        userTsConfig.include.push(...rawConfig.include, ...missingFromResolved)\n+\n+      missingFromResolved.forEach((item) => {\n+        userTsConfig.include.push(item)\n         suggestedActions.push(\n-          cyan('include') +\n-            ' was set to ' +\n-            bold(\n-              `[${[...rawConfig.include, ...missingFromResolved]\n-                .map((i) => `'${i}'`)\n-                .join(', ')}]`\n-            )\n+          cyan('include') + ' was updated to add ' + bold(`'${item}'`)\n         )\n-      } else {\n-        missingFromResolved.forEach((item) => {\n-          userTsConfig.include.push(item)\n-          suggestedActions.push(\n-            cyan('include') + ' was updated to add ' + bold(`'${item}'`)\n-          )\n-        })\n-      }\n+      })\n     }\n   }\n \n   // Enable the Next.js typescript plugin.\n   if (hasAppDir) {\n     // Check if the config or the resolved config has the plugin already.\n     const plugins = [\n-      ...(Array.isArray(tsOptions.plugins) ? tsOptions.plugins : []),\n+      ...(Array.isArray(userTsConfig?.plugins) ? userTsConfig.plugins : []),\n       ...(userTsConfig.compilerOptions &&\n       Array.isArray(userTsConfig.compilerOptions.plugins)\n         ? userTsConfig.compilerOptions.plugins\n@@ -283,8 +328,9 @@ export async function writeConfigurationDefaults(\n       !userTsConfig.compilerOptions ||\n       (plugins.length &&\n         !hasNextPlugin &&\n-        'extends' in rawConfig &&\n-        (!rawConfig.compilerOptions || !rawConfig.compilerOptions.plugins))\n+        'extends' in userTsConfig &&\n+        (!userTsConfig.compilerOptions ||\n+          !userTsConfig.compilerOptions.plugins))\n     ) {\n       Log.info(\n         `\\nYour ${bold(\n@@ -308,8 +354,8 @@ export async function writeConfigurationDefaults(\n     if (\n       hasPagesDir &&\n       hasAppDir &&\n-      !tsOptions.strict &&\n-      !('strictNullChecks' in tsOptions)\n+      !userTsConfig?.compilerOptions?.strict &&\n+      !('strictNullChecks' in userTsConfig?.compilerOptions)\n     ) {\n       userTsConfig.compilerOptions.strictNullChecks = true\n       suggestedActions.push(\n@@ -318,7 +364,7 @@ export async function writeConfigurationDefaults(\n     }\n   }\n \n-  if (!('exclude' in rawConfig)) {\n+  if (!('exclude' in userTsConfig)) {\n     userTsConfig.exclude = ['node_modules']\n     suggestedActions.push(\n       cyan('exclude') + ' was set to ' + bold(`['node_modules']`)\n@@ -348,7 +394,7 @@ export async function writeConfigurationDefaults(\n     return\n   }\n \n-  await fs.writeFile(\n+  writeFileSync(\n     tsConfigPath,\n     CommentJson.stringify(userTsConfig, null, 2) + os.EOL\n   )"
        },
        {
            "sha": "663cd20db862d6df243245db5117828f76c263b0",
            "filename": "packages/next/src/lib/verify-typescript-setup.ts",
            "status": "modified",
            "additions": 17,
            "deletions": 10,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Fverify-typescript-setup.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/90af4259ffff9934dcafeb9a00e91609fd0e68e5/packages%2Fnext%2Fsrc%2Flib%2Fverify-typescript-setup.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fverify-typescript-setup.ts?ref=90af4259ffff9934dcafeb9a00e91609fd0e68e5",
            "patch": "@@ -1,5 +1,5 @@\n import { bold, cyan, red, yellow } from './picocolors'\n-import path from 'path'\n+import path, { join } from 'path'\n \n import { hasNecessaryDependencies } from './has-necessary-dependencies'\n import type { NecessaryDependencies } from './has-necessary-dependencies'\n@@ -106,20 +106,22 @@ export async function verifyTypeScriptSetup({\n     }\n \n     // Load TypeScript after we're sure it exists:\n-    const tsPath = deps.resolved.get('typescript')!\n-    const ts = (await Promise.resolve(\n-      require(tsPath)\n-    )) as typeof import('typescript')\n+    const tsPackageJsonPath = deps.resolved.get(\n+      join('typescript', 'package.json')\n+    )!\n+    const typescriptPackageJson = require(tsPackageJsonPath)\n \n-    if (semver.lt(ts.version, '4.5.2')) {\n+    const typescriptVersion = typescriptPackageJson.version\n+\n+    if (semver.lt(typescriptVersion, '4.5.2')) {\n       log.warn(\n-        `Minimum recommended TypeScript version is v4.5.2, older versions can potentially be incompatible with Next.js. Detected: ${ts.version}`\n+        `Minimum recommended TypeScript version is v4.5.2, older versions can potentially be incompatible with Next.js. Detected: ${typescriptVersion}`\n       )\n     }\n \n     // Reconfigure (or create) the user's `tsconfig.json` for them:\n     await writeConfigurationDefaults(\n-      ts,\n+      typescriptVersion,\n       resolvedTsConfigPath,\n       intent.firstTimeSetup,\n       hasAppDir,\n@@ -141,17 +143,22 @@ export async function verifyTypeScriptSetup({\n       const { runTypeCheck } =\n         require('./typescript/runTypeCheck') as typeof import('./typescript/runTypeCheck')\n \n+      const tsPath = deps.resolved.get('typescript')!\n+      const typescript = (await Promise.resolve(\n+        require(tsPath)\n+      )) as typeof import('typescript')\n+\n       // Verify the project passes type-checking before we go to webpack phase:\n       result = await runTypeCheck(\n-        ts,\n+        typescript,\n         dir,\n         distDir,\n         resolvedTsConfigPath,\n         cacheDir,\n         hasAppDir\n       )\n     }\n-    return { result, version: ts.version }\n+    return { result, version: typescriptVersion }\n   } catch (err) {\n     // These are special errors that should not show a stack trace:\n     if (err instanceof CompileError) {"
        },
        {
            "sha": "2157ef087237383bc9c7dc71ab7f38d0e480c5d9",
            "filename": "test/e2e/app-dir/next-config-ts/tsconfig-extends/tsconfig.test.json",
            "status": "modified",
            "additions": 30,
            "deletions": 1,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/90af4259ffff9934dcafeb9a00e91609fd0e68e5/test%2Fe2e%2Fapp-dir%2Fnext-config-ts%2Ftsconfig-extends%2Ftsconfig.test.json",
            "raw_url": "https://github.com/vercel/next.js/raw/90af4259ffff9934dcafeb9a00e91609fd0e68e5/test%2Fe2e%2Fapp-dir%2Fnext-config-ts%2Ftsconfig-extends%2Ftsconfig.test.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fnext-config-ts%2Ftsconfig-extends%2Ftsconfig.test.json?ref=90af4259ffff9934dcafeb9a00e91609fd0e68e5",
            "patch": "@@ -1,3 +1,32 @@\n {\n-  \"extends\": \"./tsconfig.base.json\"\n+  \"extends\": \"./tsconfig.base.json\",\n+  \"compilerOptions\": {\n+    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n+    \"allowJs\": true,\n+    \"skipLibCheck\": true,\n+    \"strict\": false,\n+    \"forceConsistentCasingInFileNames\": true,\n+    \"noEmit\": true,\n+    \"incremental\": true,\n+    \"esModuleInterop\": true,\n+    \"module\": \"esnext\",\n+    \"moduleResolution\": \"bundler\",\n+    \"resolveJsonModule\": true,\n+    \"isolatedModules\": true,\n+    \"jsx\": \"react-jsx\",\n+    \"plugins\": [\n+      {\n+        \"name\": \"next\"\n+      }\n+    ],\n+    \"strictNullChecks\": false\n+  },\n+  \"include\": [\n+    \"next-env.d.ts\",\n+    \".next/types/**/*.ts\",\n+    \"**/*.mts\",\n+    \"**/*.ts\",\n+    \"**/*.tsx\"\n+  ],\n+  \"exclude\": [\"node_modules\"]\n }"
        },
        {
            "sha": "89c9bfa9dc637f6ead20716bab721b0b4c4e0013",
            "filename": "test/integration/tsconfig-verifier/test/index.test.js",
            "status": "modified",
            "additions": 23,
            "deletions": 37,
            "changes": 60,
            "blob_url": "https://github.com/vercel/next.js/blob/90af4259ffff9934dcafeb9a00e91609fd0e68e5/test%2Fintegration%2Ftsconfig-verifier%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/90af4259ffff9934dcafeb9a00e91609fd0e68e5/test%2Fintegration%2Ftsconfig-verifier%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Ftsconfig-verifier%2Ftest%2Findex.test.js?ref=90af4259ffff9934dcafeb9a00e91609fd0e68e5",
            "patch": "@@ -592,21 +592,9 @@ import path from 'path'\n \n       await writeFile(\n         tsConfigBase,\n-        `{ \"compilerOptions\": { \"verbatimModuleSyntax\": true } }`\n-      )\n-      await writeFile(tsConfig, `{ \"extends\": \"./tsconfig.base.json\" }`)\n-      await new Promise((resolve) => setTimeout(resolve, 500))\n-      const { code, stderr, stdout } = await nextBuild(appDir, undefined, {\n-        stderr: true,\n-        stdout: true,\n-      })\n-      expect(stderr + stdout).not.toContain('isolatedModules')\n-      expect(code).toBe(0)\n-\n-      expect(await readFile(tsConfig, 'utf8')).toMatchInlineSnapshot(`\n-       \"{\n-         \"extends\": \"./tsconfig.base.json\",\n-         \"compilerOptions\": {\n+        `{ \n+        \"compilerOptions\": {\n+           \"verbatimModuleSyntax\": true,\n            \"target\": \"ES2017\",\n            \"lib\": [\n              \"dom\",\n@@ -640,9 +628,20 @@ import path from 'path'\n          \"exclude\": [\n            \"node_modules\"\n          ]\n-       }\n-       \"\n-      `)\n+        }`\n+      )\n+      await writeFile(tsConfig, `{ \"extends\": \"./tsconfig.base.json\" }`)\n+      await new Promise((resolve) => setTimeout(resolve, 500))\n+      const { code, stderr, stdout } = await nextBuild(appDir, undefined, {\n+        stderr: true,\n+        stdout: true,\n+      })\n+      expect(stderr + stdout).not.toContain('isolatedModules')\n+      expect(code).toBe(0)\n+\n+      expect(await readFile(tsConfig, 'utf8')).toMatchInlineSnapshot(\n+        `\"{ \"extends\": \"./tsconfig.base.json\" }\"`\n+      )\n     })\n \n     it('allows you to extend another configuration file', async () => {\n@@ -703,15 +702,9 @@ import path from 'path'\n       expect(stderr + stdout).not.toContain('moduleResolution')\n       expect(code).toBe(0)\n \n-      expect(await readFile(tsConfig, 'utf8')).toMatchInlineSnapshot(`\n-        \"{\n-          \"extends\": \"./tsconfig.base.json\",\n-          \"compilerOptions\": {\n-            \"target\": \"ES2017\"\n-          }\n-        }\n-        \"\n-      `)\n+      expect(await readFile(tsConfig, 'utf8')).toMatchInlineSnapshot(\n+        `\"{ \"extends\": \"./tsconfig.base.json\" }\"`\n+      )\n     })\n \n     it('creates compilerOptions when you extend another config', async () => {\n@@ -771,16 +764,9 @@ import path from 'path'\n       expect(stderr + stdout).not.toContain('moduleResolution')\n       expect(code).toBe(0)\n \n-      expect(await readFile(tsConfig, 'utf8')).toMatchInlineSnapshot(`\n-        \"{\n-          \"extends\": \"./tsconfig.base.json\",\n-          \"compilerOptions\": {\n-            \"target\": \"ES2017\",\n-            \"incremental\": true\n-          }\n-        }\n-        \"\n-      `)\n+      expect(await readFile(tsConfig, 'utf8')).toMatchInlineSnapshot(\n+        `\"{ \"extends\": \"./tsconfig.base.json\" }\"`\n+      )\n     })\n \n     // TODO: Enable this test when repo has upgraded to TypeScript 5.4. Currently tested as E2E: tsconfig-module-preserve"
        }
    ],
    "stats": {
        "total": 491,
        "additions": 265,
        "deletions": 226
    }
}