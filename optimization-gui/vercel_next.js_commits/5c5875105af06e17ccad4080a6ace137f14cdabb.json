{
    "author": "acdlite",
    "message": "Remove forwardRef from Link in App Router (#77471)\n\nApp Router is running React >19, so we can remove forwardRef and receive\nthe ref as a prop instead.\n\nThe Pages Router version of Link is unchanged to support older React\nversions.",
    "sha": "5c5875105af06e17ccad4080a6ace137f14cdabb",
    "files": [
        {
            "sha": "5325c02f70a1d87cc4cd1ede37a08b31e9321191",
            "filename": "packages/next/src/client/app-dir/link.tsx",
            "status": "modified",
            "additions": 327,
            "deletions": 332,
            "changes": 659,
            "blob_url": "https://github.com/vercel/next.js/blob/5c5875105af06e17ccad4080a6ace137f14cdabb/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5c5875105af06e17ccad4080a6ace137f14cdabb/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx?ref=5c5875105af06e17ccad4080a6ace137f14cdabb",
            "patch": "@@ -296,11 +296,6 @@ function linkClicked(\n   React.startTransition(navigate)\n }\n \n-type LinkPropsReal = React.PropsWithChildren<\n-  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, keyof LinkProps> &\n-    LinkProps\n->\n-\n function formatStringOrUrl(urlObjOrString: UrlObject | string): string {\n   if (typeof urlObjOrString === 'string') {\n     return urlObjOrString\n@@ -319,367 +314,367 @@ function formatStringOrUrl(urlObjOrString: UrlObject | string): string {\n  *\n  * @see https://nextjs.org/docs/app/api-reference/components/link\n  */\n-const Link = React.forwardRef<HTMLAnchorElement, LinkPropsReal>(\n-  function LinkComponent(props, forwardedRef) {\n-    let children: React.ReactNode\n-\n-    const {\n-      href: hrefProp,\n-      as: asProp,\n-      children: childrenProp,\n-      prefetch: prefetchProp = null,\n-      passHref,\n-      replace,\n-      shallow,\n-      scroll,\n-      onClick,\n-      onMouseEnter: onMouseEnterProp,\n-      onTouchStart: onTouchStartProp,\n-      legacyBehavior = false,\n-      onNavigate,\n-      ...restProps\n-    } = props\n-\n-    children = childrenProp\n-\n-    if (\n-      legacyBehavior &&\n-      (typeof children === 'string' || typeof children === 'number')\n-    ) {\n-      children = <a>{children}</a>\n-    }\n+export default function LinkComponent(\n+  props: LinkProps & {\n+    children: React.ReactNode\n+    ref: React.Ref<HTMLAnchorElement>\n+  }\n+) {\n+  let children: React.ReactNode\n+\n+  const {\n+    href: hrefProp,\n+    as: asProp,\n+    children: childrenProp,\n+    prefetch: prefetchProp = null,\n+    passHref,\n+    replace,\n+    shallow,\n+    scroll,\n+    onClick,\n+    onMouseEnter: onMouseEnterProp,\n+    onTouchStart: onTouchStartProp,\n+    legacyBehavior = false,\n+    onNavigate,\n+    ref: forwardedRef,\n+    ...restProps\n+  } = props\n+\n+  children = childrenProp\n \n-    const router = React.useContext(AppRouterContext)\n-\n-    const prefetchEnabled = prefetchProp !== false\n-    /**\n-     * The possible states for prefetch are:\n-     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n-     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n-     * - false: we will not prefetch if in the viewport at all\n-     */\n-    const appPrefetchKind =\n-      prefetchProp === null ? PrefetchKind.AUTO : PrefetchKind.FULL\n-\n-    if (process.env.NODE_ENV !== 'production') {\n-      function createPropError(args: {\n-        key: string\n-        expected: string\n-        actual: string\n-      }) {\n-        return new Error(\n-          `Failed prop type: The prop \\`${args.key}\\` expects a ${args.expected} in \\`<Link>\\`, but got \\`${args.actual}\\` instead.` +\n-            (typeof window !== 'undefined'\n-              ? \"\\nOpen your browser's console to view the Component stack trace.\"\n-              : '')\n-        )\n-      }\n+  if (\n+    legacyBehavior &&\n+    (typeof children === 'string' || typeof children === 'number')\n+  ) {\n+    children = <a>{children}</a>\n+  }\n \n-      // TypeScript trick for type-guarding:\n-      const requiredPropsGuard: Record<LinkPropsRequired, true> = {\n-        href: true,\n-      } as const\n-      const requiredProps: LinkPropsRequired[] = Object.keys(\n-        requiredPropsGuard\n-      ) as LinkPropsRequired[]\n-      requiredProps.forEach((key: LinkPropsRequired) => {\n-        if (key === 'href') {\n-          if (\n-            props[key] == null ||\n-            (typeof props[key] !== 'string' && typeof props[key] !== 'object')\n-          ) {\n-            throw createPropError({\n-              key,\n-              expected: '`string` or `object`',\n-              actual: props[key] === null ? 'null' : typeof props[key],\n-            })\n-          }\n-        } else {\n-          // TypeScript trick for type-guarding:\n-          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n-          const _: never = key\n-        }\n-      })\n+  const router = React.useContext(AppRouterContext)\n \n-      // TypeScript trick for type-guarding:\n-      const optionalPropsGuard: Record<LinkPropsOptional, true> = {\n-        as: true,\n-        replace: true,\n-        scroll: true,\n-        shallow: true,\n-        passHref: true,\n-        prefetch: true,\n-        onClick: true,\n-        onMouseEnter: true,\n-        onTouchStart: true,\n-        legacyBehavior: true,\n-        onNavigate: true,\n-      } as const\n-      const optionalProps: LinkPropsOptional[] = Object.keys(\n-        optionalPropsGuard\n-      ) as LinkPropsOptional[]\n-      optionalProps.forEach((key: LinkPropsOptional) => {\n-        const valType = typeof props[key]\n-\n-        if (key === 'as') {\n-          if (props[key] && valType !== 'string' && valType !== 'object') {\n-            throw createPropError({\n-              key,\n-              expected: '`string` or `object`',\n-              actual: valType,\n-            })\n-          }\n-        } else if (\n-          key === 'onClick' ||\n-          key === 'onMouseEnter' ||\n-          key === 'onTouchStart' ||\n-          key === 'onNavigate'\n-        ) {\n-          if (props[key] && valType !== 'function') {\n-            throw createPropError({\n-              key,\n-              expected: '`function`',\n-              actual: valType,\n-            })\n-          }\n-        } else if (\n-          key === 'replace' ||\n-          key === 'scroll' ||\n-          key === 'shallow' ||\n-          key === 'passHref' ||\n-          key === 'prefetch' ||\n-          key === 'legacyBehavior'\n-        ) {\n-          if (props[key] != null && valType !== 'boolean') {\n-            throw createPropError({\n-              key,\n-              expected: '`boolean`',\n-              actual: valType,\n-            })\n-          }\n-        } else {\n-          // TypeScript trick for type-guarding:\n-          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n-          const _: never = key\n-        }\n-      })\n+  const prefetchEnabled = prefetchProp !== false\n+  /**\n+   * The possible states for prefetch are:\n+   * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n+   * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n+   * - false: we will not prefetch if in the viewport at all\n+   */\n+  const appPrefetchKind =\n+    prefetchProp === null ? PrefetchKind.AUTO : PrefetchKind.FULL\n+\n+  if (process.env.NODE_ENV !== 'production') {\n+    function createPropError(args: {\n+      key: string\n+      expected: string\n+      actual: string\n+    }) {\n+      return new Error(\n+        `Failed prop type: The prop \\`${args.key}\\` expects a ${args.expected} in \\`<Link>\\`, but got \\`${args.actual}\\` instead.` +\n+          (typeof window !== 'undefined'\n+            ? \"\\nOpen your browser's console to view the Component stack trace.\"\n+            : '')\n+      )\n     }\n \n-    if (process.env.NODE_ENV !== 'production') {\n-      if (props.locale) {\n-        warnOnce(\n-          'The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization'\n-        )\n-      }\n-      if (!asProp) {\n-        let href: string | undefined\n-        if (typeof hrefProp === 'string') {\n-          href = hrefProp\n-        } else if (\n-          typeof hrefProp === 'object' &&\n-          typeof hrefProp.pathname === 'string'\n+    // TypeScript trick for type-guarding:\n+    const requiredPropsGuard: Record<LinkPropsRequired, true> = {\n+      href: true,\n+    } as const\n+    const requiredProps: LinkPropsRequired[] = Object.keys(\n+      requiredPropsGuard\n+    ) as LinkPropsRequired[]\n+    requiredProps.forEach((key: LinkPropsRequired) => {\n+      if (key === 'href') {\n+        if (\n+          props[key] == null ||\n+          (typeof props[key] !== 'string' && typeof props[key] !== 'object')\n         ) {\n-          href = hrefProp.pathname\n+          throw createPropError({\n+            key,\n+            expected: '`string` or `object`',\n+            actual: props[key] === null ? 'null' : typeof props[key],\n+          })\n+        }\n+      } else {\n+        // TypeScript trick for type-guarding:\n+        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n+        const _: never = key\n+      }\n+    })\n+\n+    // TypeScript trick for type-guarding:\n+    const optionalPropsGuard: Record<LinkPropsOptional, true> = {\n+      as: true,\n+      replace: true,\n+      scroll: true,\n+      shallow: true,\n+      passHref: true,\n+      prefetch: true,\n+      onClick: true,\n+      onMouseEnter: true,\n+      onTouchStart: true,\n+      legacyBehavior: true,\n+      onNavigate: true,\n+    } as const\n+    const optionalProps: LinkPropsOptional[] = Object.keys(\n+      optionalPropsGuard\n+    ) as LinkPropsOptional[]\n+    optionalProps.forEach((key: LinkPropsOptional) => {\n+      const valType = typeof props[key]\n+\n+      if (key === 'as') {\n+        if (props[key] && valType !== 'string' && valType !== 'object') {\n+          throw createPropError({\n+            key,\n+            expected: '`string` or `object`',\n+            actual: valType,\n+          })\n+        }\n+      } else if (\n+        key === 'onClick' ||\n+        key === 'onMouseEnter' ||\n+        key === 'onTouchStart' ||\n+        key === 'onNavigate'\n+      ) {\n+        if (props[key] && valType !== 'function') {\n+          throw createPropError({\n+            key,\n+            expected: '`function`',\n+            actual: valType,\n+          })\n+        }\n+      } else if (\n+        key === 'replace' ||\n+        key === 'scroll' ||\n+        key === 'shallow' ||\n+        key === 'passHref' ||\n+        key === 'prefetch' ||\n+        key === 'legacyBehavior'\n+      ) {\n+        if (props[key] != null && valType !== 'boolean') {\n+          throw createPropError({\n+            key,\n+            expected: '`boolean`',\n+            actual: valType,\n+          })\n         }\n+      } else {\n+        // TypeScript trick for type-guarding:\n+        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n+        const _: never = key\n+      }\n+    })\n+  }\n \n-        if (href) {\n-          const hasDynamicSegment = href\n-            .split('/')\n-            .some((segment) => segment.startsWith('[') && segment.endsWith(']'))\n+  if (process.env.NODE_ENV !== 'production') {\n+    if (props.locale) {\n+      warnOnce(\n+        'The `locale` prop is not supported in `next/link` while using the `app` router. Read more about app router internalization: https://nextjs.org/docs/app/building-your-application/routing/internationalization'\n+      )\n+    }\n+    if (!asProp) {\n+      let href: string | undefined\n+      if (typeof hrefProp === 'string') {\n+        href = hrefProp\n+      } else if (\n+        typeof hrefProp === 'object' &&\n+        typeof hrefProp.pathname === 'string'\n+      ) {\n+        href = hrefProp.pathname\n+      }\n \n-          if (hasDynamicSegment) {\n-            throw new Error(\n-              `Dynamic href \\`${href}\\` found in <Link> while using the \\`/app\\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`\n-            )\n-          }\n+      if (href) {\n+        const hasDynamicSegment = href\n+          .split('/')\n+          .some((segment) => segment.startsWith('[') && segment.endsWith(']'))\n+\n+        if (hasDynamicSegment) {\n+          throw new Error(\n+            `Dynamic href \\`${href}\\` found in <Link> while using the \\`/app\\` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href`\n+          )\n         }\n       }\n     }\n+  }\n \n-    const { href, as } = React.useMemo(() => {\n-      const resolvedHref = formatStringOrUrl(hrefProp)\n-      return {\n-        href: resolvedHref,\n-        as: asProp ? formatStringOrUrl(asProp) : resolvedHref,\n+  const { href, as } = React.useMemo(() => {\n+    const resolvedHref = formatStringOrUrl(hrefProp)\n+    return {\n+      href: resolvedHref,\n+      as: asProp ? formatStringOrUrl(asProp) : resolvedHref,\n+    }\n+  }, [hrefProp, asProp])\n+\n+  // This will return the first child, if multiple are provided it will throw an error\n+  let child: any\n+  if (legacyBehavior) {\n+    if (process.env.NODE_ENV === 'development') {\n+      if (onClick) {\n+        console.warn(\n+          `\"onClick\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link`\n+        )\n       }\n-    }, [hrefProp, asProp])\n-\n-    // This will return the first child, if multiple are provided it will throw an error\n-    let child: any\n-    if (legacyBehavior) {\n-      if (process.env.NODE_ENV === 'development') {\n-        if (onClick) {\n-          console.warn(\n-            `\"onClick\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link`\n-          )\n-        }\n-        if (onMouseEnterProp) {\n-          console.warn(\n-            `\"onMouseEnter\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`\n-          )\n-        }\n-        try {\n-          child = React.Children.only(children)\n-        } catch (err) {\n-          if (!children) {\n-            throw new Error(\n-              `No children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but one child is required https://nextjs.org/docs/messages/link-no-children`\n-            )\n-          }\n+      if (onMouseEnterProp) {\n+        console.warn(\n+          `\"onMouseEnter\" was passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link`\n+        )\n+      }\n+      try {\n+        child = React.Children.only(children)\n+      } catch (err) {\n+        if (!children) {\n           throw new Error(\n-            `Multiple children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` +\n-              (typeof window !== 'undefined'\n-                ? \" \\nOpen your browser's console to view the Component stack trace.\"\n-                : '')\n+            `No children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but one child is required https://nextjs.org/docs/messages/link-no-children`\n           )\n         }\n-      } else {\n-        child = React.Children.only(children)\n+        throw new Error(\n+          `Multiple children were passed to <Link> with \\`href\\` of \\`${hrefProp}\\` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children` +\n+            (typeof window !== 'undefined'\n+              ? \" \\nOpen your browser's console to view the Component stack trace.\"\n+              : '')\n+        )\n       }\n     } else {\n-      if (process.env.NODE_ENV === 'development') {\n-        if ((children as any)?.type === 'a') {\n+      child = React.Children.only(children)\n+    }\n+  } else {\n+    if (process.env.NODE_ENV === 'development') {\n+      if ((children as any)?.type === 'a') {\n+        throw new Error(\n+          'Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'\n+        )\n+      }\n+    }\n+  }\n+\n+  const childRef: any = legacyBehavior\n+    ? child && typeof child === 'object' && child.ref\n+    : forwardedRef\n+\n+  // Use a callback ref to attach an IntersectionObserver to the anchor tag on\n+  // mount. In the future we will also use this to keep track of all the\n+  // currently mounted <Link> instances, e.g. so we can re-prefetch them after\n+  // a revalidation or refresh.\n+  const observeLinkVisibilityOnMount = React.useCallback(\n+    (element: HTMLAnchorElement | SVGAElement) => {\n+      if (prefetchEnabled && router !== null) {\n+        mountLinkInstance(element, href, router, appPrefetchKind)\n+      }\n+      return () => {\n+        unmountLinkInstance(element)\n+      }\n+    },\n+    [prefetchEnabled, href, router, appPrefetchKind]\n+  )\n+\n+  const mergedRef = useMergedRef(observeLinkVisibilityOnMount, childRef)\n+\n+  const childProps: {\n+    onTouchStart?: React.TouchEventHandler<HTMLAnchorElement>\n+    onMouseEnter: React.MouseEventHandler<HTMLAnchorElement>\n+    onClick: React.MouseEventHandler<HTMLAnchorElement>\n+    href?: string\n+    ref?: any\n+  } = {\n+    ref: mergedRef,\n+    onClick(e) {\n+      if (process.env.NODE_ENV !== 'production') {\n+        if (!e) {\n           throw new Error(\n-            'Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor'\n+            `Component rendered inside next/link has to pass click event to \"onClick\" prop.`\n           )\n         }\n       }\n-    }\n \n-    const childRef: any = legacyBehavior\n-      ? child && typeof child === 'object' && child.ref\n-      : forwardedRef\n-\n-    // Use a callback ref to attach an IntersectionObserver to the anchor tag on\n-    // mount. In the future we will also use this to keep track of all the\n-    // currently mounted <Link> instances, e.g. so we can re-prefetch them after\n-    // a revalidation or refresh.\n-    const observeLinkVisibilityOnMount = React.useCallback(\n-      (element: HTMLAnchorElement | SVGAElement) => {\n-        if (prefetchEnabled && router !== null) {\n-          mountLinkInstance(element, href, router, appPrefetchKind)\n-        }\n-        return () => {\n-          unmountLinkInstance(element)\n-        }\n-      },\n-      [prefetchEnabled, href, router, appPrefetchKind]\n-    )\n-\n-    const mergedRef = useMergedRef(observeLinkVisibilityOnMount, childRef)\n-\n-    const childProps: {\n-      onTouchStart?: React.TouchEventHandler<HTMLAnchorElement>\n-      onMouseEnter: React.MouseEventHandler<HTMLAnchorElement>\n-      onClick: React.MouseEventHandler<HTMLAnchorElement>\n-      href?: string\n-      ref?: any\n-    } = {\n-      ref: mergedRef,\n-      onClick(e) {\n-        if (process.env.NODE_ENV !== 'production') {\n-          if (!e) {\n-            throw new Error(\n-              `Component rendered inside next/link has to pass click event to \"onClick\" prop.`\n-            )\n-          }\n-        }\n+      if (!legacyBehavior && typeof onClick === 'function') {\n+        onClick(e)\n+      }\n \n-        if (!legacyBehavior && typeof onClick === 'function') {\n-          onClick(e)\n-        }\n+      if (\n+        legacyBehavior &&\n+        child.props &&\n+        typeof child.props.onClick === 'function'\n+      ) {\n+        child.props.onClick(e)\n+      }\n \n-        if (\n-          legacyBehavior &&\n-          child.props &&\n-          typeof child.props.onClick === 'function'\n-        ) {\n-          child.props.onClick(e)\n-        }\n+      if (!router) {\n+        return\n+      }\n \n-        if (!router) {\n-          return\n-        }\n+      if (e.defaultPrevented) {\n+        return\n+      }\n \n-        if (e.defaultPrevented) {\n-          return\n-        }\n+      linkClicked(e, router, href, as, replace, shallow, scroll, onNavigate)\n+    },\n+    onMouseEnter(e) {\n+      if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n+        onMouseEnterProp(e)\n+      }\n \n-        linkClicked(e, router, href, as, replace, shallow, scroll, onNavigate)\n-      },\n-      onMouseEnter(e) {\n-        if (!legacyBehavior && typeof onMouseEnterProp === 'function') {\n-          onMouseEnterProp(e)\n-        }\n+      if (\n+        legacyBehavior &&\n+        child.props &&\n+        typeof child.props.onMouseEnter === 'function'\n+      ) {\n+        child.props.onMouseEnter(e)\n+      }\n \n-        if (\n-          legacyBehavior &&\n-          child.props &&\n-          typeof child.props.onMouseEnter === 'function'\n-        ) {\n-          child.props.onMouseEnter(e)\n-        }\n+      if (!router) {\n+        return\n+      }\n \n-        if (!router) {\n-          return\n-        }\n+      if (!prefetchEnabled || process.env.NODE_ENV === 'development') {\n+        return\n+      }\n \n-        if (!prefetchEnabled || process.env.NODE_ENV === 'development') {\n-          return\n-        }\n+      onNavigationIntent(e.currentTarget as HTMLAnchorElement | SVGAElement)\n+    },\n+    onTouchStart: process.env.__NEXT_LINK_NO_TOUCH_START\n+      ? undefined\n+      : function onTouchStart(e) {\n+          if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n+            onTouchStartProp(e)\n+          }\n \n-        onNavigationIntent(e.currentTarget as HTMLAnchorElement | SVGAElement)\n-      },\n-      onTouchStart: process.env.__NEXT_LINK_NO_TOUCH_START\n-        ? undefined\n-        : function onTouchStart(e) {\n-            if (!legacyBehavior && typeof onTouchStartProp === 'function') {\n-              onTouchStartProp(e)\n-            }\n-\n-            if (\n-              legacyBehavior &&\n-              child.props &&\n-              typeof child.props.onTouchStart === 'function'\n-            ) {\n-              child.props.onTouchStart(e)\n-            }\n-\n-            if (!router) {\n-              return\n-            }\n-\n-            if (!prefetchEnabled) {\n-              return\n-            }\n-\n-            onNavigationIntent(\n-              e.currentTarget as HTMLAnchorElement | SVGAElement\n-            )\n-          },\n-    }\n+          if (\n+            legacyBehavior &&\n+            child.props &&\n+            typeof child.props.onTouchStart === 'function'\n+          ) {\n+            child.props.onTouchStart(e)\n+          }\n \n-    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n-    // defined, we specify the current 'href', so that repetition is not needed by the user.\n-    // If the url is absolute, we can bypass the logic to prepend the basePath.\n-    if (isAbsoluteUrl(as)) {\n-      childProps.href = as\n-    } else if (\n-      !legacyBehavior ||\n-      passHref ||\n-      (child.type === 'a' && !('href' in child.props))\n-    ) {\n-      childProps.href = addBasePath(as)\n-    }\n+          if (!router) {\n+            return\n+          }\n+\n+          if (!prefetchEnabled) {\n+            return\n+          }\n \n-    return legacyBehavior ? (\n-      React.cloneElement(child, childProps)\n-    ) : (\n-      <a {...restProps} {...childProps}>\n-        {children}\n-      </a>\n-    )\n+          onNavigationIntent(e.currentTarget as HTMLAnchorElement | SVGAElement)\n+        },\n+  }\n+\n+  // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n+  // defined, we specify the current 'href', so that repetition is not needed by the user.\n+  // If the url is absolute, we can bypass the logic to prepend the basePath.\n+  if (isAbsoluteUrl(as)) {\n+    childProps.href = as\n+  } else if (\n+    !legacyBehavior ||\n+    passHref ||\n+    (child.type === 'a' && !('href' in child.props))\n+  ) {\n+    childProps.href = addBasePath(as)\n   }\n-)\n \n-export default Link\n+  return legacyBehavior ? (\n+    React.cloneElement(child, childProps)\n+  ) : (\n+    <a {...restProps} {...childProps}>\n+      {children}\n+    </a>\n+  )\n+}"
        }
    ],
    "stats": {
        "total": 659,
        "additions": 327,
        "deletions": 332
    }
}