{
    "author": "sokra",
    "message": "Turbopack: avoid compation on initial write (#78342)\n\n### What?\r\n\r\nAs initial build performance is a performance bottleneck for persistent caching we want to delay compaction and don't want to execute it on the first build.",
    "sha": "73975472ad5b24afdc16acf79d657af98aad939c",
    "files": [
        {
            "sha": "490a4a008b15b987a29dd2cdca3838c688277b8a",
            "filename": "turbopack/crates/turbo-tasks-backend/src/database/turbo.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/73975472ad5b24afdc16acf79d657af98aad939c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/73975472ad5b24afdc16acf79d657af98aad939c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdatabase%2Fturbo.rs?ref=73975472ad5b24afdc16acf79d657af98aad939c",
            "patch": "@@ -89,6 +89,7 @@ impl KeyValueDatabase for TurboKeyValueDatabase {\n             batch: self.db.write_batch()?,\n             db: &self.db,\n             compact_join_handle: &self.compact_join_handle,\n+            initial_write: self.db.is_empty(),\n         }))\n     }\n \n@@ -106,6 +107,7 @@ pub struct TurboWriteBatch<'a> {\n     batch: turbo_persistence::WriteBatch<WriteBuffer<'static>, 5>,\n     db: &'a Arc<TurboPersistence>,\n     compact_join_handle: &'a Mutex<Option<JoinHandle<Result<()>>>>,\n+    initial_write: bool,\n }\n \n impl<'a> BaseWriteBatch<'a> for TurboWriteBatch<'a> {\n@@ -126,10 +128,13 @@ impl<'a> BaseWriteBatch<'a> for TurboWriteBatch<'a> {\n         // Commit the write batch\n         self.db.commit_write_batch(self.batch)?;\n \n-        // Start a new compaction in the background\n-        let db = self.db.clone();\n-        let handle = spawn(move || db.compact(COMPACT_MAX_COVERAGE, COMPACT_MAX_MERGE_SEQUENCE));\n-        self.compact_join_handle.lock().replace(handle);\n+        if !self.initial_write {\n+            // Start a new compaction in the background\n+            let db = self.db.clone();\n+            let handle =\n+                spawn(move || db.compact(COMPACT_MAX_COVERAGE, COMPACT_MAX_MERGE_SEQUENCE));\n+            self.compact_join_handle.lock().replace(handle);\n+        }\n \n         Ok(())\n     }"
        }
    ],
    "stats": {
        "total": 13,
        "additions": 9,
        "deletions": 4
    }
}