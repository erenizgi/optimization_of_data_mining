{
    "author": "unstubbable",
    "message": "Convert any export from a `'use cache'` module to a cache function (#86014)\n\nPreviously, in a `'use cache'` module, we only compiled statically-known\nexported functions and arrow expressions to cache functions. Now, we\nalso compile re-exports and exports of values that might be functions.\n\nThis includes exports like:\n- `export { getData } from './data'` - re-exporting from another module\n- `export const aliased = getData` - exporting an imported identifier\n- `const Page = withSlug(...); export default Page` - exporting the\nresult of a function call\n\nThese cases can't be statically verified as functions at compile time,\nso we generate runtime wrappers with `typeof === \"function\"` checks\n(simplified):\n\n```js\nlet $$RSC_SERVER_CACHE_getData = getData;\nif (typeof getData === \"function\") {\n    $$RSC_SERVER_CACHE_getData = React.cache(function() {\n        return cache(\"default\", \"...\", 0, getData, arguments);\n    });\n    registerServerReference($$RSC_SERVER_CACHE_getData, \"...\", null);\n    Object.defineProperty($$RSC_SERVER_CACHE_getData, \"name\", { value: \"getData\" });\n}\nexport { $$RSC_SERVER_CACHE_getData as getData };\n```\n\nThis ensures that all function exports from `'use cache'` modules are\nproperly cached, while non-function exports pass through unchanged.\n\nThis approach comes with some limitations compared to statically-known\nfunction exports:\n1. **No compile-time type checking:** We can't verify that these exports\nare actually functions. Non-function exports will be passed through\nas-is at runtime.\n2. **No async enforcement:** We can't enforce that functions must be\nasync (as we do for statically-known functions). Synchronous functions\nare supported, but will lie about their type signature. They become\nasync after being wrapped as cache functions, even though their original\nsignature was synchronous.\n\ncloses NAR-196",
    "sha": "59fe222b5e4f83349462663ce073fbbbcdf03962",
    "files": [
        {
            "sha": "07048f537b6e953f93ff8e30673e9921ae8feee4",
            "filename": "crates/next-custom-transforms/src/transforms/server_actions.rs",
            "status": "modified",
            "additions": 599,
            "deletions": 140,
            "changes": 739,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Fsrc%2Ftransforms%2Fserver_actions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Fsrc%2Ftransforms%2Fserver_actions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Fsrc%2Ftransforms%2Fserver_actions.rs?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -75,6 +75,7 @@ struct ServerReferenceExport {\n     ident: Ident,\n     export_name: ModuleExportName,\n     reference_id: Atom,\n+    needs_cache_runtime_wrapper: bool,\n }\n \n #[derive(Clone, Debug)]\n@@ -186,6 +187,7 @@ pub fn server_actions<C: Comments>(\n \n         arrow_or_fn_expr_ident: None,\n         export_name_by_local_id: Default::default(),\n+        local_ids_that_need_cache_runtime_wrapper_if_exported: FxHashSet::default(),\n \n         use_cache_telemetry_tracker,\n     })\n@@ -260,6 +262,13 @@ struct ServerActions<C: Comments> {\n     arrow_or_fn_expr_ident: Option<Ident>,\n     export_name_by_local_id: FxIndexMap<Id, ModuleExportName>,\n \n+    /// Tracks which local IDs need cache runtime wrappers if exported (collected during pre-pass).\n+    /// Includes imports, destructured identifiers, and variables with unknown-type init\n+    /// expressions (calls, identifiers, etc.). Excludes known functions (arrow/fn\n+    /// declarations) and known non-functions (object/array/literals). When these IDs are\n+    /// exported, their exports are stripped and replaced with conditional wrappers.\n+    local_ids_that_need_cache_runtime_wrapper_if_exported: FxHashSet<Id>,\n+\n     use_cache_telemetry_tracker: Rc<RefCell<FxHashMap<String, usize>>>,\n }\n \n@@ -491,6 +500,15 @@ impl<C: Comments> ServerActions<C> {\n             action_id.clone(),\n         );\n \n+        // If this is an exported arrow, remove it from export_name_by_local_id so the\n+        // post-pass doesn't register it again (it's already registered above).\n+        if self.current_export_name.is_some() {\n+            if let Some(arrow_ident) = &self.arrow_or_fn_expr_ident {\n+                self.export_name_by_local_id\n+                    .swap_remove(&arrow_ident.to_id());\n+            }\n+        }\n+\n         if let BlockStmtOrExpr::BlockStmt(block) = &mut *arrow.body {\n             block.visit_mut_with(&mut ClosureReplacer {\n                 used_ids: &ids_from_closure,\n@@ -649,6 +667,14 @@ impl<C: Comments> ServerActions<C> {\n             action_id.clone(),\n         );\n \n+        // If this is an exported function, remove it from export_name_by_local_id so the\n+        // post-pass doesn't register it again (it's already registered above).\n+        if self.current_export_name.is_some() {\n+            if let Some(ref fn_name) = fn_name {\n+                self.export_name_by_local_id.swap_remove(&fn_name.to_id());\n+            }\n+        }\n+\n         function.body.visit_mut_with(&mut ClosureReplacer {\n             used_ids: &ids_from_closure,\n             private_ctxt: self.private_ctxt,\n@@ -785,6 +811,15 @@ impl<C: Comments> ServerActions<C> {\n             reference_id.clone(),\n         );\n \n+        // If this is an exported arrow, remove it from export_name_by_local_id so the\n+        // post-pass doesn't register it again (it's already registered above).\n+        if self.current_export_name.is_some() {\n+            if let Some(arrow_ident) = &self.arrow_or_fn_expr_ident {\n+                self.export_name_by_local_id\n+                    .swap_remove(&arrow_ident.to_id());\n+            }\n+        }\n+\n         if let BlockStmtOrExpr::BlockStmt(block) = &mut *arrow.body {\n             block.visit_mut_with(&mut ClosureReplacer {\n                 used_ids: &ids_from_closure,\n@@ -816,16 +851,11 @@ impl<C: Comments> ServerActions<C> {\n         );\n \n         if let Some(Ident { sym, .. }) = &self.arrow_or_fn_expr_ident {\n-            assign_name_to_ident(&cache_ident, sym.as_str(), &mut self.hoisted_extra_items);\n-        }\n-\n-        // If this is an exported arrow, remove it from export_name_by_local_id so the\n-        // post-pass doesn't register it again (it's already registered above).\n-        if self.current_export_name.is_some() {\n-            if let Some(arrow_ident) = &self.arrow_or_fn_expr_ident {\n-                self.export_name_by_local_id\n-                    .swap_remove(&arrow_ident.to_id());\n-            }\n+            self.hoisted_extra_items\n+                .push(ModuleItem::Stmt(assign_name_to_ident(\n+                    &cache_ident,\n+                    sym.as_str(),\n+                )));\n         }\n \n         let bound_args: Vec<_> = ids_from_closure\n@@ -884,6 +914,14 @@ impl<C: Comments> ServerActions<C> {\n             reference_id.clone(),\n         );\n \n+        // If this is an exported function, remove it from export_name_by_local_id so the\n+        // post-pass doesn't register it again (it's already registered above).\n+        if self.current_export_name.is_some() {\n+            if let Some(ref fn_name) = fn_name {\n+                self.export_name_by_local_id.swap_remove(&fn_name.to_id());\n+            }\n+        }\n+\n         function.body.visit_mut_with(&mut ClosureReplacer {\n             used_ids: &ids_from_closure,\n             private_ctxt: self.private_ctxt,\n@@ -905,17 +943,17 @@ impl<C: Comments> ServerActions<C> {\n         );\n \n         if let Some(Ident { ref sym, .. }) = fn_name {\n-            assign_name_to_ident(&cache_ident, sym.as_str(), &mut self.hoisted_extra_items);\n+            self.hoisted_extra_items\n+                .push(ModuleItem::Stmt(assign_name_to_ident(\n+                    &cache_ident,\n+                    sym.as_str(),\n+                )));\n         } else if self.is_default_export() {\n-            assign_name_to_ident(&cache_ident, \"default\", &mut self.hoisted_extra_items);\n-        }\n-\n-        // If this is an exported function, remove it from export_name_by_local_id so the\n-        // post-pass doesn't register it again (it's already registered above).\n-        if self.current_export_name.is_some() {\n-            if let Some(fn_name) = fn_name {\n-                self.export_name_by_local_id.swap_remove(&fn_name.to_id());\n-            }\n+            self.hoisted_extra_items\n+                .push(ModuleItem::Stmt(assign_name_to_ident(\n+                    &cache_ident,\n+                    \"default\",\n+                )));\n         }\n \n         let bound_args: Vec<_> = ids_from_closure\n@@ -976,6 +1014,7 @@ impl<C: Comments> ServerActions<C> {\n                 ident: fn_name.clone(),\n                 export_name: export_name.clone(),\n                 reference_id: reference_id.clone(),\n+                needs_cache_runtime_wrapper: false,\n             });\n         } else if self.is_default_export() {\n             let action_ident = Ident::new(self.gen_action_ident(), span, self.private_ctxt);\n@@ -989,6 +1028,7 @@ impl<C: Comments> ServerActions<C> {\n                 ident: action_ident.clone(),\n                 export_name: export_name.clone(),\n                 reference_id: reference_id.clone(),\n+                needs_cache_runtime_wrapper: false,\n             });\n \n             // For the server layer, also hoist the function and rewrite the default export.\n@@ -1005,7 +1045,11 @@ impl<C: Comments> ServerActions<C> {\n                         ..Default::default()\n                     })))));\n \n-                assign_name_to_ident(&action_ident, \"default\", &mut self.hoisted_extra_items);\n+                self.hoisted_extra_items\n+                    .push(ModuleItem::Stmt(assign_name_to_ident(\n+                        &action_ident,\n+                        \"default\",\n+                    )));\n \n                 self.rewrite_default_fn_expr_to_proxy_expr =\n                     Some(Box::new(Expr::Ident(action_ident)));\n@@ -1032,6 +1076,7 @@ impl<C: Comments> ServerActions<C> {\n                 ident: fn_name.clone(),\n                 export_name: export_name.clone(),\n                 reference_id: reference_id.clone(),\n+                needs_cache_runtime_wrapper: false,\n             });\n         } else if self.is_default_export() {\n             let cache_ident = Ident::new(self.gen_cache_ident(), span, self.private_ctxt);\n@@ -1045,6 +1090,7 @@ impl<C: Comments> ServerActions<C> {\n                 ident: cache_ident.clone(),\n                 export_name: export_name.clone(),\n                 reference_id: reference_id.clone(),\n+                needs_cache_runtime_wrapper: false,\n             });\n         }\n     }\n@@ -1072,38 +1118,66 @@ impl<C: Comments> VisitMut for ServerActions<C> {\n         expr.expr.visit_mut_with(self);\n         self.current_export_name = old_current_export_name;\n \n-        // For 'use server' files with call expressions as default exports,\n-        // hoist the call expression to a const declarator and register it as an export.\n-        if matches!(self.file_directive, Some(Directive::UseServer))\n-            && matches!(&*expr.expr, Expr::Call(_))\n-        {\n-            let export_name = ModuleExportName::Ident(atom!(\"default\").into());\n-            let action_ident = Ident::new(self.gen_action_ident(), expr.span, self.private_ctxt);\n-            let action_id = self.generate_server_reference_id(&export_name, false, None);\n+        // For 'use server' or 'use cache' files with call expressions as default exports,\n+        // hoist the call expression to a const declarator.\n+        if matches!(&*expr.expr, Expr::Call(_)) {\n+            if matches!(self.file_directive, Some(Directive::UseServer)) {\n+                let export_name = ModuleExportName::Ident(atom!(\"default\").into());\n+                let action_ident =\n+                    Ident::new(self.gen_action_ident(), expr.span, self.private_ctxt);\n+                let action_id = self.generate_server_reference_id(&export_name, false, None);\n+\n+                self.has_action = true;\n+                self.reference_ids_by_export_name\n+                    .insert(export_name.clone(), action_id.clone());\n+\n+                self.server_reference_exports.push(ServerReferenceExport {\n+                    ident: action_ident.clone(),\n+                    export_name: export_name.clone(),\n+                    reference_id: action_id.clone(),\n+                    needs_cache_runtime_wrapper: false,\n+                });\n \n-            self.has_action = true;\n-            self.reference_ids_by_export_name\n-                .insert(export_name.clone(), action_id.clone());\n+                self.hoisted_extra_items\n+                    .push(ModuleItem::Stmt(Stmt::Decl(Decl::Var(Box::new(VarDecl {\n+                        kind: VarDeclKind::Const,\n+                        decls: vec![VarDeclarator {\n+                            span: DUMMY_SP,\n+                            name: Pat::Ident(action_ident.clone().into()),\n+                            init: Some(expr.expr.take()),\n+                            definite: false,\n+                        }],\n+                        ..Default::default()\n+                    })))));\n \n-            self.server_reference_exports.push(ServerReferenceExport {\n-                ident: action_ident.clone(),\n-                export_name: export_name.clone(),\n-                reference_id: action_id.clone(),\n-            });\n+                self.rewrite_default_fn_expr_to_proxy_expr =\n+                    Some(Box::new(Expr::Ident(action_ident)));\n+            } else if matches!(self.file_directive, Some(Directive::UseCache { .. })) {\n+                let cache_ident = Ident::new(self.gen_cache_ident(), expr.span, self.private_ctxt);\n \n-            self.hoisted_extra_items\n-                .push(ModuleItem::Stmt(Stmt::Decl(Decl::Var(Box::new(VarDecl {\n-                    kind: VarDeclKind::Const,\n-                    decls: vec![VarDeclarator {\n-                        span: DUMMY_SP,\n-                        name: Pat::Ident(action_ident.clone().into()),\n-                        init: Some(expr.expr.take()),\n-                        definite: false,\n-                    }],\n-                    ..Default::default()\n-                })))));\n+                self.export_name_by_local_id.insert(\n+                    cache_ident.to_id(),\n+                    ModuleExportName::Ident(atom!(\"default\").into()),\n+                );\n+\n+                self.local_ids_that_need_cache_runtime_wrapper_if_exported\n+                    .insert(cache_ident.to_id());\n \n-            self.rewrite_default_fn_expr_to_proxy_expr = Some(Box::new(Expr::Ident(action_ident)));\n+                self.hoisted_extra_items\n+                    .push(ModuleItem::Stmt(Stmt::Decl(Decl::Var(Box::new(VarDecl {\n+                        kind: VarDeclKind::Const,\n+                        decls: vec![VarDeclarator {\n+                            span: DUMMY_SP,\n+                            name: Pat::Ident(cache_ident.into()),\n+                            init: Some(expr.expr.take()),\n+                            definite: false,\n+                        }],\n+                        ..Default::default()\n+                    })))));\n+\n+                // Note: We don't set rewrite_default_fn_expr_to_proxy_expr here. The export will be\n+                // removed via the should_remove_statement flag in the main pass.\n+            }\n         }\n     }\n \n@@ -1698,15 +1772,33 @@ impl<C: Comments> VisitMut for ServerActions<C> {\n                             }\n                             Decl::Var(var) => {\n                                 for decl in &var.decls {\n-                                    // Collect all identifiers from the pattern (handles\n-                                    // destructuring)\n+                                    // Collect all identifiers from the pattern and track which may\n+                                    // need cache runtime wrappers. For destructuring patterns, we\n+                                    // always need wrappers since we can't statically know if the\n+                                    // destructured values are functions. For simple identifiers,\n+                                    // check the init expression.\n                                     let mut idents = vec![];\n                                     collect_idents_in_pat(&decl.name, &mut idents);\n+\n+                                    let is_destructuring = !matches!(&decl.name, Pat::Ident(_));\n+                                    let needs_wrapper = if is_destructuring {\n+                                        true\n+                                    } else if let Some(init) = &decl.init {\n+                                        may_need_cache_runtime_wrapper(init)\n+                                    } else {\n+                                        false\n+                                    };\n+\n                                     for ident in idents {\n                                         self.export_name_by_local_id.insert(\n                                             ident.to_id(),\n                                             ModuleExportName::Ident(ident.clone()),\n                                         );\n+\n+                                        if needs_wrapper {\n+                                            self.local_ids_that_need_cache_runtime_wrapper_if_exported\n+                                                .insert(ident.to_id());\n+                                        }\n                                     }\n                                 }\n                             }\n@@ -1720,6 +1812,7 @@ impl<C: Comments> VisitMut for ServerActions<C> {\n                                     ExportSpecifier::Named(ExportNamedSpecifier {\n                                         orig: ModuleExportName::Ident(orig),\n                                         exported: Some(exported),\n+                                        is_type_only: false,\n                                         ..\n                                     }) => {\n                                         // export { foo as bar } or export { foo as \"ðŸ“™\" }\n@@ -1729,6 +1822,7 @@ impl<C: Comments> VisitMut for ServerActions<C> {\n                                     ExportSpecifier::Named(ExportNamedSpecifier {\n                                         orig: ModuleExportName::Ident(orig),\n                                         exported: None,\n+                                        is_type_only: false,\n                                         ..\n                                     }) => {\n                                         // export { foo }\n@@ -1742,6 +1836,43 @@ impl<C: Comments> VisitMut for ServerActions<C> {\n                             }\n                         }\n                     }\n+                    ModuleItem::Stmt(Stmt::Decl(Decl::Var(var_decl))) => {\n+                        // Track which declarations need cache runtime wrappers if exported.\n+                        for decl in &var_decl.decls {\n+                            if let Pat::Ident(ident_pat) = &decl.name {\n+                                if let Some(init) = &decl.init {\n+                                    if may_need_cache_runtime_wrapper(init) {\n+                                        self.local_ids_that_need_cache_runtime_wrapper_if_exported\n+                                            .insert(ident_pat.id.to_id());\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                    ModuleItem::Stmt(Stmt::Decl(Decl::Fn(_fn_decl))) => {\n+                        // Function declarations are known functions and don't need runtime\n+                        // wrappers.\n+                    }\n+                    ModuleItem::ModuleDecl(ModuleDecl::Import(import_decl)) => {\n+                        // Track all imports. We don't know if they're functions, so they need\n+                        // runtime wrappers if they end up getting re-exported.\n+                        for spec in &import_decl.specifiers {\n+                            match spec {\n+                                ImportSpecifier::Named(named) => {\n+                                    self.local_ids_that_need_cache_runtime_wrapper_if_exported\n+                                        .insert(named.local.to_id());\n+                                }\n+                                ImportSpecifier::Default(default) => {\n+                                    self.local_ids_that_need_cache_runtime_wrapper_if_exported\n+                                        .insert(default.local.to_id());\n+                                }\n+                                ImportSpecifier::Namespace(ns) => {\n+                                    self.local_ids_that_need_cache_runtime_wrapper_if_exported\n+                                        .insert(ns.local.to_id());\n+                                }\n+                            }\n+                        }\n+                    }\n                     _ => {}\n                 }\n             }\n@@ -1753,21 +1884,56 @@ impl<C: Comments> VisitMut for ServerActions<C> {\n         // Main pass: For each statement, validate exports in server boundary files,\n         // visit and transform it, and add it to the output along with any hoisted items.\n         for mut stmt in stmts.take() {\n+            let mut should_remove_statement = false;\n+\n             if should_track_exports {\n                 let mut disallowed_export_span = DUMMY_SP;\n \n                 match &mut stmt {\n                     ModuleItem::ModuleDecl(ModuleDecl::ExportDecl(ExportDecl { decl, span })) => {\n                         match decl {\n                             Decl::Var(var) => {\n-                                // Check for disallowed exports like literals\n+                                let mut has_export_needing_wrapper = false;\n+\n+                                // Validate exports and check for cache runtime wrappers. Disallow\n+                                // exporting literals, objects, and arrays directly (destructuring\n+                                // patterns are allowed since we can't statically know if the\n+                                // destructured value is a function).\n                                 for decl in &var.decls {\n-                                    if let Some(init) = &decl.init {\n-                                        if let Expr::Lit(_) = &**init {\n-                                            disallowed_export_span = *span;\n+                                    if let Pat::Ident(_) = &decl.name {\n+                                        if let Some(init) = &decl.init {\n+                                            match &**init {\n+                                                Expr::Lit(_) | Expr::Object(_) | Expr::Array(_) => {\n+                                                    disallowed_export_span = *span;\n+                                                }\n+                                                _ => {}\n+                                            }\n+                                        }\n+                                    }\n+\n+                                    // For cache files, check if any identifier needs a runtime\n+                                    // wrapper.\n+                                    if in_cache_file {\n+                                        let mut idents: Vec<Ident> = Vec::new();\n+                                        collect_idents_in_pat(&decl.name, &mut idents);\n+\n+                                        for ident in idents {\n+                                            let needs_cache_runtime_wrapper = self\n+                                                .local_ids_that_need_cache_runtime_wrapper_if_exported\n+                                                .contains(&ident.to_id());\n+\n+                                            if needs_cache_runtime_wrapper {\n+                                                has_export_needing_wrapper = true;\n+                                            }\n                                         }\n                                     }\n                                 }\n+\n+                                // If this export needs a cache runtime wrapper, convert to a\n+                                // regular declaration (remove export keyword).\n+                                if in_cache_file && has_export_needing_wrapper {\n+                                    stmt = ModuleItem::Stmt(Stmt::Decl(Decl::Var(var.clone())));\n+                                }\n                             }\n                             Decl::Fn(_)\n                             | Decl::TsInterface(_)\n@@ -1779,13 +1945,115 @@ impl<C: Comments> VisitMut for ServerActions<C> {\n                         }\n                     }\n                     ModuleItem::ModuleDecl(ModuleDecl::ExportNamed(named)) => {\n-                        if !named.type_only && named.src.is_some() {\n-                            // export { foo } from './foo'\n-                            if named.specifiers.iter().any(|s| match s {\n-                                ExportSpecifier::Namespace(_) | ExportSpecifier::Default(_) => true,\n-                                ExportSpecifier::Named(s) => !s.is_type_only,\n-                            }) {\n-                                disallowed_export_span = named.span;\n+                        if !named.type_only {\n+                            if let Some(src) = &named.src {\n+                                // export { x } from './module'\n+                                if in_cache_file {\n+                                    // Transform re-exports into imports so we can wrap them with\n+                                    // cache runtime wrappers.\n+                                    let import_specs: Vec<ImportSpecifier> = named\n+                                        .specifiers\n+                                        .iter()\n+                                        .filter_map(|spec| {\n+                                            if let ExportSpecifier::Named(ExportNamedSpecifier {\n+                                                orig: ModuleExportName::Ident(orig),\n+                                                exported,\n+                                                is_type_only: false,\n+                                                ..\n+                                            }) = spec\n+                                            {\n+                                                    // Now that we're converting this to an import,\n+                                                    // track it as a local export so the post-pass\n+                                                    // can register it.\n+                                                    let export_name =\n+                                                        if let Some(exported) = exported {\n+                                                            exported.clone()\n+                                                        } else {\n+                                                            ModuleExportName::Ident(orig.clone())\n+                                                        };\n+\n+                                                    self.export_name_by_local_id\n+                                                        .insert(orig.to_id(), export_name);\n+\n+                                                    self.local_ids_that_need_cache_runtime_wrapper_if_exported\n+                                                        .insert(orig.to_id());\n+\n+                                                    return Some(ImportSpecifier::Named(\n+                                                        ImportNamedSpecifier {\n+                                                            span: DUMMY_SP,\n+                                                            local: orig.clone(),\n+                                                            imported: None,\n+                                                            is_type_only: false,\n+                                                        },\n+                                                    ));\n+                                            }\n+                                            None\n+                                        })\n+                                        .collect();\n+\n+                                    if !import_specs.is_empty() {\n+                                        // Add import statement.\n+                                        self.extra_items.push(ModuleItem::ModuleDecl(\n+                                            ModuleDecl::Import(ImportDecl {\n+                                                span: named.span,\n+                                                specifiers: import_specs,\n+                                                src: src.clone(),\n+                                                type_only: false,\n+                                                with: named.with.clone(),\n+                                                phase: Default::default(),\n+                                            }),\n+                                        ));\n+                                    }\n+\n+                                    // Remove value specifiers from the export statement, keeping\n+                                    // only type-only specifiers.\n+                                    named.specifiers.retain(|spec| {\n+                                        matches!(\n+                                            spec,\n+                                            ExportSpecifier::Named(ExportNamedSpecifier {\n+                                                is_type_only: true,\n+                                                ..\n+                                            })\n+                                        )\n+                                    });\n+\n+                                    // If all specifiers were value specifiers (converted to\n+                                    // imports), remove the entire statement.\n+                                    if named.specifiers.is_empty() {\n+                                        should_remove_statement = true;\n+                                    }\n+                                } else if named.specifiers.iter().any(|s| match s {\n+                                    ExportSpecifier::Namespace(_) | ExportSpecifier::Default(_) => {\n+                                        true\n+                                    }\n+                                    ExportSpecifier::Named(s) => !s.is_type_only,\n+                                }) {\n+                                    disallowed_export_span = named.span;\n+                                }\n+                            } else {\n+                                // For cache files, remove specifiers that need cache runtime\n+                                // wrappers. Keep type-only specifiers and value specifiers that\n+                                // don't need wrappers (like function declarations).\n+                                if in_cache_file {\n+                                    named.specifiers.retain(|spec| {\n+                                        if let ExportSpecifier::Named(ExportNamedSpecifier {\n+                                            orig: ModuleExportName::Ident(ident),\n+                                            is_type_only: false,\n+                                            ..\n+                                        }) = spec\n+                                        {\n+                                            !self\n+                                                .local_ids_that_need_cache_runtime_wrapper_if_exported\n+                                                .contains(&ident.to_id())\n+                                        } else {\n+                                            true\n+                                        }\n+                                    });\n+\n+                                    if named.specifiers.is_empty() {\n+                                        should_remove_statement = true;\n+                                    }\n+                                }\n                             }\n                         }\n                     }\n@@ -1800,7 +2068,28 @@ impl<C: Comments> VisitMut for ServerActions<C> {\n                     },\n                     ModuleItem::ModuleDecl(ModuleDecl::ExportDefaultExpr(default_expr)) => {\n                         match &mut *default_expr.expr {\n-                            Expr::Fn(_) | Expr::Arrow(_) | Expr::Ident(_) | Expr::Call(_) => {}\n+                            Expr::Fn(_) | Expr::Arrow(_) => {}\n+                            Expr::Ident(ident) => {\n+                                // For cache files, remove the export if it needs a runtime wrapper\n+                                // (we'll generate a new export when adding the wrapper).\n+                                if in_cache_file {\n+                                    let needs_cache_runtime_wrapper = self\n+                                        .local_ids_that_need_cache_runtime_wrapper_if_exported\n+                                        .contains(&ident.to_id());\n+\n+                                    if needs_cache_runtime_wrapper {\n+                                        should_remove_statement = true;\n+                                    }\n+                                }\n+                            }\n+                            Expr::Call(_call) => {\n+                                // For cache files, mark the statement for removal. After visiting\n+                                // (which transforms nested directives), we'll hoist the call to a\n+                                // const declaration that gets a cache runtime wrapper.\n+                                if in_cache_file {\n+                                    should_remove_statement = true;\n+                                }\n+                            }\n                             _ => {\n                                 disallowed_export_span = default_expr.span;\n                             }\n@@ -1830,37 +2119,55 @@ impl<C: Comments> VisitMut for ServerActions<C> {\n \n             stmt.visit_mut_with(self);\n \n-            let mut new_stmt = stmt;\n-\n-            if let Some(expr) = &self.rewrite_default_fn_expr_to_proxy_expr {\n-                new_stmt =\n-                    ModuleItem::ModuleDecl(ModuleDecl::ExportDefaultExpr(ExportDefaultExpr {\n+            let new_stmt = if should_remove_statement {\n+                None\n+            } else if let Some(expr) = self.rewrite_default_fn_expr_to_proxy_expr.take() {\n+                Some(ModuleItem::ModuleDecl(ModuleDecl::ExportDefaultExpr(\n+                    ExportDefaultExpr {\n                         span: DUMMY_SP,\n-                        expr: expr.clone(),\n-                    }));\n-                self.rewrite_default_fn_expr_to_proxy_expr = None;\n-            }\n+                        expr,\n+                    },\n+                )))\n+            } else {\n+                Some(stmt)\n+            };\n \n             if self.config.is_react_server_layer || self.file_directive.is_none() {\n                 new.append(&mut self.hoisted_extra_items);\n-                new.push(new_stmt);\n+                if let Some(stmt) = new_stmt {\n+                    new.push(stmt);\n+                }\n                 new.extend(self.annotations.drain(..).map(ModuleItem::Stmt));\n                 new.append(&mut self.extra_items);\n             }\n         }\n \n-        // Post-pass: For 'use server' files, register any exports that weren't already registered\n-        // during the main pass. So this inherently excludes self-annotated server\n-        // functions.\n-        if in_action_file {\n+        // Post-pass: For server boundary files, register any exports that weren't already\n+        // registered during the main pass.\n+        if should_track_exports {\n             for (id, export_name) in &self.export_name_by_local_id {\n-                if !self.reference_ids_by_export_name.contains_key(export_name) {\n-                    self.server_reference_exports.push(ServerReferenceExport {\n-                        ident: Ident::from(id.clone()),\n-                        export_name: export_name.clone(),\n-                        reference_id: self.generate_server_reference_id(export_name, false, None),\n-                    });\n+                if self.reference_ids_by_export_name.contains_key(export_name) {\n+                    continue;\n                 }\n+\n+                if in_cache_file\n+                    && !self\n+                        .local_ids_that_need_cache_runtime_wrapper_if_exported\n+                        .contains(id)\n+                {\n+                    continue;\n+                }\n+\n+                self.server_reference_exports.push(ServerReferenceExport {\n+                    ident: Ident::from(id.clone()),\n+                    export_name: export_name.clone(),\n+                    reference_id: self.generate_server_reference_id(\n+                        export_name,\n+                        in_cache_file,\n+                        None,\n+                    ),\n+                    needs_cache_runtime_wrapper: in_cache_file,\n+                });\n             }\n         }\n \n@@ -1935,6 +2242,7 @@ impl<C: Comments> VisitMut for ServerActions<C> {\n                 ident,\n                 export_name,\n                 reference_id: ref_id,\n+                needs_cache_runtime_wrapper,\n             } in &server_reference_exports\n             {\n                 if !self.config.is_react_server_layer {\n@@ -2060,7 +2368,133 @@ impl<C: Comments> VisitMut for ServerActions<C> {\n                             ),\n                         );\n                     }\n-                } else if !in_cache_file {\n+                } else if in_cache_file {\n+                    // Generate cache runtime wrapper for exports that might not be functions\n+                    // at compile time (re-exported identifiers, HOC results, etc.)\n+                    // Pattern: let x = orig; if (typeof orig === \"function\") { x = wrapper(...) }\n+\n+                    if !*needs_cache_runtime_wrapper {\n+                        continue;\n+                    }\n+\n+                    // Generate wrapper ident: $$RSC_SERVER_CACHE_exportName\n+                    let wrapper_ident = Ident::new(\n+                        format!(\"$$RSC_SERVER_CACHE_{}\", export_name.atom()).into(),\n+                        ident.span,\n+                        self.private_ctxt,\n+                    );\n+\n+                    self.has_cache = true;\n+                    self.reference_ids_by_export_name\n+                        .insert(export_name.clone(), ref_id.clone());\n+\n+                    // let $$RSC_SERVER_CACHE_exportName = exportName;\n+                    self.extra_items\n+                        .push(ModuleItem::Stmt(Stmt::Decl(Decl::Var(Box::new(VarDecl {\n+                            kind: VarDeclKind::Let,\n+                            decls: vec![VarDeclarator {\n+                                span: ident.span,\n+                                name: Pat::Ident(wrapper_ident.clone().into()),\n+                                init: Some(Box::new(Expr::Ident(ident.clone()))),\n+                                definite: false,\n+                            }],\n+                            ..Default::default()\n+                        })))));\n+\n+                    let wrapper_stmts = {\n+                        let mut stmts = vec![\n+                            // $$RSC_SERVER_CACHE_exportName = $$reactCache__(...);\n+                            Stmt::Expr(ExprStmt {\n+                                span: DUMMY_SP,\n+                                expr: Box::new(Expr::Assign(AssignExpr {\n+                                    span: DUMMY_SP,\n+                                    op: op!(\"=\"),\n+                                    left: AssignTarget::Simple(SimpleAssignTarget::Ident(\n+                                        wrapper_ident.clone().into(),\n+                                    )),\n+                                    right: Box::new(create_cache_wrapper(\n+                                        \"default\",\n+                                        ref_id.clone(),\n+                                        0,\n+                                        // Don't use the same name as the original to avoid\n+                                        // shadowing. We don't need it here for call stacks.\n+                                        None,\n+                                        Expr::Ident(ident.clone()),\n+                                        ident.span,\n+                                    )),\n+                                })),\n+                            }),\n+                            // registerServerReference($$RSC_SERVER_CACHE_exportName, ...);\n+                            Stmt::Expr(ExprStmt {\n+                                span: DUMMY_SP,\n+                                expr: Box::new(annotate_ident_as_server_reference(\n+                                    wrapper_ident.clone(),\n+                                    ref_id.clone(),\n+                                    ident.span,\n+                                )),\n+                            }),\n+                        ];\n+\n+                        // Only assign a name if the original ident is not a generated one.\n+                        if !ident.sym.starts_with(\"$$RSC_SERVER_\") {\n+                            // Object.defineProperty($$RSC_SERVER_CACHE_exportName, \"name\", {...});\n+                            stmts.push(assign_name_to_ident(&wrapper_ident, &ident.sym));\n+                        }\n+\n+                        stmts\n+                    };\n+\n+                    // if (typeof ident === \"function\") { $$RSC_SERVER_CACHE_exportName = wrapper }\n+                    self.extra_items.push(ModuleItem::Stmt(Stmt::If(IfStmt {\n+                        test: Box::new(Expr::Bin(BinExpr {\n+                            span: DUMMY_SP,\n+                            op: op!(\"===\"),\n+                            left: Box::new(Expr::Unary(UnaryExpr {\n+                                span: DUMMY_SP,\n+                                op: op!(\"typeof\"),\n+                                arg: Box::new(Expr::Ident(ident.clone())),\n+                            })),\n+                            right: Box::new(Expr::Lit(Lit::Str(Str {\n+                                span: DUMMY_SP,\n+                                value: atom!(\"function\").into(),\n+                                raw: None,\n+                            }))),\n+                        })),\n+                        cons: Box::new(Stmt::Block(BlockStmt {\n+                            stmts: wrapper_stmts,\n+                            ..Default::default()\n+                        })),\n+                        ..Default::default()\n+                    })));\n+\n+                    // Generate export with rename: export { $$RSC_SERVER_CACHE_name as name }\n+                    if matches!(export_name, ModuleExportName::Ident(i) if i.sym == *\"default\") {\n+                        self.extra_items.push(ModuleItem::ModuleDecl(\n+                            ModuleDecl::ExportDefaultExpr(ExportDefaultExpr {\n+                                span: DUMMY_SP,\n+                                expr: Box::new(Expr::Ident(wrapper_ident)),\n+                            }),\n+                        ));\n+                    } else {\n+                        self.extra_items\n+                            .push(ModuleItem::ModuleDecl(ModuleDecl::ExportNamed(\n+                                NamedExport {\n+                                    span: DUMMY_SP,\n+                                    specifiers: vec![ExportSpecifier::Named(\n+                                        ExportNamedSpecifier {\n+                                            span: DUMMY_SP,\n+                                            orig: ModuleExportName::Ident(wrapper_ident),\n+                                            exported: Some(export_name.clone()),\n+                                            is_type_only: false,\n+                                        },\n+                                    )],\n+                                    src: None,\n+                                    type_only: false,\n+                                    with: None,\n+                                },\n+                            )));\n+                    }\n+                } else {\n                     self.annotations.push(Stmt::Expr(ExprStmt {\n                         span: DUMMY_SP,\n                         expr: Box::new(annotate_ident_as_server_reference(\n@@ -2508,6 +2942,70 @@ fn retain_names_from_declared_idents(\n     *child_names = retained_names;\n }\n \n+/// Returns true if the expression may need a cache runtime wrapper.\n+/// Known functions and known non-functions return false.\n+fn may_need_cache_runtime_wrapper(expr: &Expr) -> bool {\n+    match expr {\n+        // Known functions - don't need wrapper\n+        Expr::Arrow(_) | Expr::Fn(_) => false,\n+        // Known non-functions - don't need wrapper\n+        Expr::Object(_) | Expr::Array(_) | Expr::Lit(_) => false,\n+        // Unknown/might be function - needs runtime check\n+        _ => true,\n+    }\n+}\n+\n+/// Creates a cache wrapper expression:\n+/// $$reactCache__(function name() { return $$cache__(...) })\n+fn create_cache_wrapper(\n+    cache_kind: &str,\n+    reference_id: Atom,\n+    bound_args_length: usize,\n+    fn_ident: Option<Ident>,\n+    target_expr: Expr,\n+    original_span: Span,\n+) -> Expr {\n+    let cache_call = CallExpr {\n+        span: original_span,\n+        callee: quote_ident!(\"$$cache__\").as_callee(),\n+        args: vec![\n+            Box::new(Expr::from(cache_kind)).as_arg(),\n+            Box::new(Expr::from(reference_id.as_str())).as_arg(),\n+            Box::new(Expr::Lit(Lit::Num(Number {\n+                span: DUMMY_SP,\n+                value: bound_args_length as f64,\n+                raw: None,\n+            })))\n+            .as_arg(),\n+            Box::new(target_expr).as_arg(),\n+            Box::new(Expr::Ident(private_ident!(DUMMY_SP, \"arguments\"))).as_arg(),\n+        ],\n+        ..Default::default()\n+    };\n+\n+    // This wrapper function ensures that we have a user-space call stack frame.\n+    let wrapper_fn_expr = Box::new(Expr::Fn(FnExpr {\n+        ident: fn_ident,\n+        function: Box::new(Function {\n+            body: Some(BlockStmt {\n+                stmts: vec![Stmt::Return(ReturnStmt {\n+                    span: DUMMY_SP,\n+                    arg: Some(Box::new(Expr::Call(cache_call))),\n+                })],\n+                ..Default::default()\n+            }),\n+            span: original_span,\n+            ..Default::default()\n+        }),\n+    }));\n+\n+    Expr::Call(CallExpr {\n+        callee: quote_ident!(\"$$reactCache__\").as_callee(),\n+        args: vec![wrapper_fn_expr.as_arg()],\n+        ..Default::default()\n+    })\n+}\n+\n #[allow(clippy::too_many_arguments)]\n fn create_and_hoist_cache_function(\n     cache_kind: &str,\n@@ -2530,7 +3028,6 @@ fn create_and_hoist_cache_function(\n             params,\n             body,\n             span: original_span,\n-            is_generator: false,\n             is_async: true,\n             ..Default::default()\n         }),\n@@ -2539,7 +3036,6 @@ fn create_and_hoist_cache_function(\n     hoisted_extra_items.push(ModuleItem::Stmt(Stmt::Decl(Decl::Var(Box::new(VarDecl {\n         span: original_span,\n         kind: VarDeclKind::Const,\n-        declare: false,\n         decls: vec![VarDeclarator {\n             span: original_span,\n             name: Pat::Ident(BindingIdent {\n@@ -2555,49 +3051,17 @@ fn create_and_hoist_cache_function(\n     // For anonymous functions, set the name property to an empty string to\n     // avoid leaking the internal variable name in stack traces.\n     if fn_ident.is_none() {\n-        assign_name_to_ident(&inner_fn_ident, \"\", hoisted_extra_items);\n+        hoisted_extra_items.push(ModuleItem::Stmt(assign_name_to_ident(&inner_fn_ident, \"\")));\n     }\n \n-    let cache_call = CallExpr {\n-        span: original_span,\n-        callee: quote_ident!(\"$$cache__\").as_callee(),\n-        args: vec![\n-            Box::new(Expr::from(cache_kind)).as_arg(),\n-            Box::new(Expr::from(reference_id.as_str())).as_arg(),\n-            Box::new(Expr::Lit(Lit::Num(Number {\n-                span: DUMMY_SP,\n-                value: bound_args_length as f64,\n-                raw: None,\n-            })))\n-            .as_arg(),\n-            Box::new(Expr::Ident(inner_fn_ident)).as_arg(),\n-            Box::new(Expr::Ident(private_ident!(DUMMY_SP, \"arguments\"))).as_arg(),\n-        ],\n-        ..Default::default()\n-    };\n-\n-    // This wrapper function ensures that we have a user-space call stack frame.\n-    let wrapper_fn_expr = Box::new(Expr::Fn(FnExpr {\n-        ident: fn_ident.clone(),\n-        function: Box::new(Function {\n-            body: Some(BlockStmt {\n-                span: DUMMY_SP,\n-                stmts: vec![Stmt::Return(ReturnStmt {\n-                    span: DUMMY_SP,\n-                    arg: Some(Box::new(Expr::Call(cache_call))),\n-                })],\n-                ..Default::default()\n-            }),\n-            span: original_span,\n-            ..Default::default()\n-        }),\n-    }));\n-\n-    let wrapper_fn = Box::new(Expr::Call(CallExpr {\n-        callee: quote_ident!(\"$$reactCache__\").as_callee(),\n-        args: vec![wrapper_fn_expr.as_arg()],\n-        ..Default::default()\n-    }));\n+    let wrapper_fn = Box::new(create_cache_wrapper(\n+        cache_kind,\n+        reference_id.clone(),\n+        bound_args_length,\n+        fn_ident.clone(),\n+        Expr::Ident(inner_fn_ident),\n+        original_span,\n+    ));\n \n     hoisted_extra_items.push(ModuleItem::ModuleDecl(ModuleDecl::ExportDecl(ExportDecl {\n         span: DUMMY_SP,\n@@ -2626,9 +3090,9 @@ fn create_and_hoist_cache_function(\n     cache_ident\n }\n \n-fn assign_name_to_ident(ident: &Ident, name: &str, extra_items: &mut Vec<ModuleItem>) {\n+fn assign_name_to_ident(ident: &Ident, name: &str) -> Stmt {\n     // Assign a name with `Object.defineProperty($$ACTION_0, 'name', {value: 'default'})`\n-    extra_items.push(quote!(\n+    quote!(\n         // WORKAROUND for https://github.com/microsoft/TypeScript/issues/61165\n         // This should just be\n         //\n@@ -2637,10 +3101,10 @@ fn assign_name_to_ident(ident: &Ident, name: &str, extra_items: &mut Vec<ModuleI\n         // but due to the above typescript bug, `Object.defineProperty` calls are typechecked incorrectly\n         // in js files, and it can cause false positives when typechecking our fixture files.\n         \"Object[\\\"defineProperty\\\"]($action, \\\"name\\\", { value: $name });\"\n-            as ModuleItem,\n+            as Stmt,\n         action: Ident = ident.clone(),\n         name: Expr = name.into(),\n-    ));\n+    )\n }\n \n fn annotate_ident_as_server_reference(ident: Ident, action_id: Atom, original_span: Span) -> Expr {\n@@ -2817,15 +3281,9 @@ fn collect_idents_in_array_pat(elems: &[Option<Pat>], idents: &mut Vec<Ident>) {\n fn collect_idents_in_object_pat(props: &[ObjectPatProp], idents: &mut Vec<Ident>) {\n     for prop in props {\n         match prop {\n-            ObjectPatProp::KeyValue(KeyValuePatProp { key, value }) => {\n-                if let PropName::Ident(ident) = key {\n-                    idents.push(Ident::new(\n-                        ident.sym.clone(),\n-                        ident.span,\n-                        SyntaxContext::empty(),\n-                    ));\n-                }\n-\n+            ObjectPatProp::KeyValue(KeyValuePatProp { value, .. }) => {\n+                // For { foo: bar }, only collect 'bar' (the local binding), not 'foo' (the property\n+                // key).\n                 match &**value {\n                     Pat::Ident(ident) => {\n                         idents.push(ident.id.clone());\n@@ -2840,6 +3298,7 @@ fn collect_idents_in_object_pat(props: &[ObjectPatProp], idents: &mut Vec<Ident>\n                 }\n             }\n             ObjectPatProp::Assign(AssignPatProp { key, .. }) => {\n+                // For { foo }, 'foo' is both the property key and local binding.\n                 idents.push(key.id.clone());\n             }\n             ObjectPatProp::Rest(RestPat { arg, .. }) => {"
        },
        {
            "sha": "191629439a99e7ec848d480b5c8fb4283c9cd319",
            "filename": "crates/next-custom-transforms/tests/errors/server-actions/client-graph/3/input.js",
            "status": "added",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fclient-graph%2F3%2Finput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fclient-graph%2F3%2Finput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fclient-graph%2F3%2Finput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,4 @@\n+'use cache'\n+\n+export const foo = {},\n+  bar = [1]"
        },
        {
            "sha": "2a9ae959c796c588f5170962deabbabd574fdbd4",
            "filename": "crates/next-custom-transforms/tests/errors/server-actions/client-graph/3/output.stderr",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fclient-graph%2F3%2Foutput.stderr",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fclient-graph%2F3%2Foutput.stderr",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fclient-graph%2F3%2Foutput.stderr?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,7 @@\n+  x Only async functions are allowed to be exported in a \"use cache\" file.\n+  | \n+   ,-[input.js:3:1]\n+ 2 |     \n+ 3 | ,-> export const foo = {},\n+ 4 | `->   bar = [1]\n+   `----"
        },
        {
            "sha": "983f9a2682017c5edbf242117e3b995261916ab7",
            "filename": "crates/next-custom-transforms/tests/errors/server-actions/server-graph/23/input.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fserver-graph%2F23%2Finput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fserver-graph%2F23%2Finput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fserver-graph%2F23%2Finput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -16,7 +16,7 @@ async function a() {\n   }\n }\n \n-export const obj = {\n+export const { foo } = {\n   foo() {\n     return 42\n   },"
        },
        {
            "sha": "1a15ae28a1767d592551ba04156cc7c20290ebb2",
            "filename": "crates/next-custom-transforms/tests/errors/server-actions/server-graph/23/output.js",
            "status": "modified",
            "additions": 15,
            "deletions": 1,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fserver-graph%2F23%2Foutput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fserver-graph%2F23%2Foutput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fserver-graph%2F23%2Foutput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -1,3 +1,6 @@\n+/* __next_internal_action_entry_do_not_use__ {\"ffab21efdafbe611287bc25c0462b1e0510d13e48b\":\"foo\"} */ import { registerServerReference } from \"private-next-rsc-server-reference\";\n+import { cache as $$cache__ } from \"private-next-rsc-cache-wrapper\";\n+import { cache as $$reactCache__ } from \"react\";\n // not exported!\n async function a() {\n     // this is allowed here\n@@ -11,7 +14,7 @@ async function a() {\n         console.log(arguments);\n     };\n }\n-export const obj = {\n+const { foo } = {\n     foo () {\n         return 42;\n     },\n@@ -22,3 +25,14 @@ export const obj = {\n         console.log(arguments);\n     }\n };\n+let $$RSC_SERVER_CACHE_foo = foo;\n+if (typeof foo === \"function\") {\n+    $$RSC_SERVER_CACHE_foo = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ffab21efdafbe611287bc25c0462b1e0510d13e48b\", 0, foo, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_foo, \"ffab21efdafbe611287bc25c0462b1e0510d13e48b\", null);\n+    Object[\"defineProperty\"]($$RSC_SERVER_CACHE_foo, \"name\", {\n+        value: \"foo\"\n+    });\n+}\n+export { $$RSC_SERVER_CACHE_foo as foo };"
        },
        {
            "sha": "191629439a99e7ec848d480b5c8fb4283c9cd319",
            "filename": "crates/next-custom-transforms/tests/errors/server-actions/server-graph/31/input.js",
            "status": "added",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fserver-graph%2F31%2Finput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fserver-graph%2F31%2Finput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fserver-graph%2F31%2Finput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,4 @@\n+'use cache'\n+\n+export const foo = {},\n+  bar = [1]"
        },
        {
            "sha": "2a9ae959c796c588f5170962deabbabd574fdbd4",
            "filename": "crates/next-custom-transforms/tests/errors/server-actions/server-graph/31/output.stderr",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fserver-graph%2F31%2Foutput.stderr",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fserver-graph%2F31%2Foutput.stderr",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ferrors%2Fserver-actions%2Fserver-graph%2F31%2Foutput.stderr?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,7 @@\n+  x Only async functions are allowed to be exported in a \"use cache\" file.\n+  | \n+   ,-[input.js:3:1]\n+ 2 |     \n+ 3 | ,-> export const foo = {},\n+ 4 | `->   bar = [1]\n+   `----"
        },
        {
            "sha": "d3d6027f00c2ab45662f8a22a76793ad84d57e3d",
            "filename": "crates/next-custom-transforms/tests/fixture.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 5,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture.rs?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -29,7 +29,7 @@ use swc_core::{\n     common::{comments::SingleThreadedComments, FileName, Mark, SyntaxContext},\n     ecma::{\n         ast::Pass,\n-        parser::{EsSyntax, Syntax},\n+        parser::{EsSyntax, Syntax, TsSyntax},\n         transforms::{\n             base::resolver,\n             react::jsx,\n@@ -534,10 +534,16 @@ fn next_font_loaders_fixture(input: PathBuf) {\n \n #[fixture(\"tests/fixture/server-actions/**/input.*\")]\n fn server_actions_fixture(input: PathBuf) {\n-    let (input_syntax, extension) = if input.extension() == Some(\"ts\".as_ref()) {\n-        (Syntax::Typescript(Default::default()), \"ts\")\n-    } else {\n-        (syntax(), \"js\")\n+    let (input_syntax, extension) = match input.extension().and_then(|e| e.to_str()) {\n+        Some(\"ts\") => (Syntax::Typescript(Default::default()), \"ts\"),\n+        Some(\"tsx\") => (\n+            Syntax::Typescript(TsSyntax {\n+                tsx: true,\n+                ..Default::default()\n+            }),\n+            \"tsx\",\n+        ),\n+        _ => (syntax(), \"js\"),\n     };\n \n     let output = input.parent().unwrap().join(format!(\"output.{extension}\"));"
        },
        {
            "sha": "689a5089dde4aa95d54141de0a151fcac8448521",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/client-graph/13/input.js",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fclient-graph%2F13%2Finput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fclient-graph%2F13%2Finput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fclient-graph%2F13%2Finput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,31 @@\n+'use cache'\n+\n+// @ts-ignore\n+import { getStuff, wrap } from './foo'\n+// @ts-ignore\n+export { getData } from './data'\n+\n+export const getCachedData = async () => {\n+  // This is not using the wrapped version of getStuff, as we're only\n+  // runtime-wrapping what flows out of the module, not into it. Would one\n+  // expect this to be cached?\n+  return getStuff()\n+}\n+\n+export const aliased = getStuff\n+\n+const Layout = wrap(async () => <div>Layout</div>)\n+const Other = wrap(async () => <div>Other</div>)\n+export const Sync = wrap(() => <div>Sync</div>)\n+\n+export const wrapped = wrap(\n+  async () => 'foo',\n+  async () => 'bar',\n+  async () => async () => 'baz',\n+  () => 'sync'\n+)\n+\n+export default Layout\n+export { Other, getStuff, staticallyKnownFunction }\n+\n+async function staticallyKnownFunction() {}"
        },
        {
            "sha": "fba80c8ff503e854d42fe8caf07a3659d63b2c7e",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/client-graph/13/output.js",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fclient-graph%2F13%2Foutput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fclient-graph%2F13%2Foutput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fclient-graph%2F13%2Foutput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,18 @@\n+/* __next_internal_action_entry_do_not_use__ {\"802af4786baeeb4011d0d5e5ff1cb669d517c9b125\":\"staticallyKnownFunction\",\"807f03edbc83b6cc7e5ccc12da8fecf25146585bb7\":\"getCachedData\",\"ff1acff246876a467753785a92d1f95ac6fe32c9b9\":\"Other\",\"ff27fadf3eeb97c777cea9f14a407b5c0b42ac65bb\":\"aliased\",\"ff438bb59117ff1af890c80ca3e39d9e888fc93033\":\"wrapped\",\"ff84effee663e5ce4e0948b55df129a8df904c67aa\":\"Sync\",\"ff8fa22f08e492db15701f58a1458cc4ebf782f855\":\"getData\",\"ff980f8c891ae27674b86a4804d306bdb3065c2e4f\":\"getStuff\",\"ffc18c215a6b7cdc64bf709f3a714ffdef1bf9651d\":\"default\"} */ import { createServerReference, callServer, findSourceMapURL } from \"private-next-rsc-action-client-wrapper\";\n+const $$RSC_SERVER_CACHE_0 = /*#__PURE__*/ createServerReference(\"807f03edbc83b6cc7e5ccc12da8fecf25146585bb7\", callServer, void 0, findSourceMapURL, \"getCachedData\");\n+export { $$RSC_SERVER_CACHE_0 as getCachedData };\n+const $$RSC_SERVER_CACHE_1 = /*#__PURE__*/ createServerReference(\"802af4786baeeb4011d0d5e5ff1cb669d517c9b125\", callServer, void 0, findSourceMapURL, \"staticallyKnownFunction\");\n+export { $$RSC_SERVER_CACHE_1 as staticallyKnownFunction };\n+const $$RSC_SERVER_CACHE_2 = /*#__PURE__*/ createServerReference(\"ff27fadf3eeb97c777cea9f14a407b5c0b42ac65bb\", callServer, void 0, findSourceMapURL, \"aliased\");\n+export { $$RSC_SERVER_CACHE_2 as aliased };\n+const $$RSC_SERVER_CACHE_3 = /*#__PURE__*/ createServerReference(\"ff84effee663e5ce4e0948b55df129a8df904c67aa\", callServer, void 0, findSourceMapURL, \"Sync\");\n+export { $$RSC_SERVER_CACHE_3 as Sync };\n+const $$RSC_SERVER_CACHE_4 = /*#__PURE__*/ createServerReference(\"ff438bb59117ff1af890c80ca3e39d9e888fc93033\", callServer, void 0, findSourceMapURL, \"wrapped\");\n+export { $$RSC_SERVER_CACHE_4 as wrapped };\n+export default /*#__PURE__*/ createServerReference(\"ffc18c215a6b7cdc64bf709f3a714ffdef1bf9651d\", callServer, void 0, findSourceMapURL, \"default\");\n+const $$RSC_SERVER_CACHE_5 = /*#__PURE__*/ createServerReference(\"ff1acff246876a467753785a92d1f95ac6fe32c9b9\", callServer, void 0, findSourceMapURL, \"Other\");\n+export { $$RSC_SERVER_CACHE_5 as Other };\n+const $$RSC_SERVER_CACHE_6 = /*#__PURE__*/ createServerReference(\"ff980f8c891ae27674b86a4804d306bdb3065c2e4f\", callServer, void 0, findSourceMapURL, \"getStuff\");\n+export { $$RSC_SERVER_CACHE_6 as getStuff };\n+const $$RSC_SERVER_CACHE_7 = /*#__PURE__*/ createServerReference(\"ff8fa22f08e492db15701f58a1458cc4ebf782f855\", callServer, void 0, findSourceMapURL, \"getData\");\n+export { $$RSC_SERVER_CACHE_7 as getData };"
        },
        {
            "sha": "76c58d547d5655af086b492166bc1ef722a0d90f",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/client-graph/14/input.js",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fclient-graph%2F14%2Finput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fclient-graph%2F14%2Finput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fclient-graph%2F14%2Finput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,3 @@\n+'use cache'\n+\n+export const { foo: fooCached } = { foo: async () => {} }"
        },
        {
            "sha": "0fe3fb9ce2a81001a5586bff7720e70672e46344",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/client-graph/14/output.js",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fclient-graph%2F14%2Foutput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fclient-graph%2F14%2Foutput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fclient-graph%2F14%2Foutput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,3 @@\n+/* __next_internal_action_entry_do_not_use__ {\"ffaa88e24cee8047d167e47f4f374dbddc187e2899\":\"fooCached\"} */ import { createServerReference, callServer, findSourceMapURL } from \"private-next-rsc-action-client-wrapper\";\n+const $$RSC_SERVER_CACHE_0 = /*#__PURE__*/ createServerReference(\"ffaa88e24cee8047d167e47f4f374dbddc187e2899\", callServer, void 0, findSourceMapURL, \"fooCached\");\n+export { $$RSC_SERVER_CACHE_0 as fooCached };"
        },
        {
            "sha": "76c58d547d5655af086b492166bc1ef722a0d90f",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/server-graph/56/input.js",
            "status": "modified",
            "additions": 1,
            "deletions": 11,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F56%2Finput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F56%2Finput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F56%2Finput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -1,13 +1,3 @@\n 'use cache'\n \n-// No method nor function property should be considered a cache function.\n-export const obj = {\n-  foo() {\n-    return 1\n-  },\n-  async bar() {\n-    return 2\n-  },\n-  baz: () => 2,\n-  qux: async () => 3,\n-}\n+export const { foo: fooCached } = { foo: async () => {} }"
        },
        {
            "sha": "9fcfe090e96b952b603af56d0a1c182e323240db",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/server-graph/56/output.js",
            "status": "modified",
            "additions": 16,
            "deletions": 10,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F56%2Foutput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F56%2Foutput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F56%2Foutput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -1,11 +1,17 @@\n-// No method nor function property should be considered a cache function.\n-export const obj = {\n-    foo () {\n-        return 1;\n-    },\n-    async bar () {\n-        return 2;\n-    },\n-    baz: ()=>2,\n-    qux: async ()=>3\n+/* __next_internal_action_entry_do_not_use__ {\"ffaa88e24cee8047d167e47f4f374dbddc187e2899\":\"fooCached\"} */ import { registerServerReference } from \"private-next-rsc-server-reference\";\n+import { cache as $$cache__ } from \"private-next-rsc-cache-wrapper\";\n+import { cache as $$reactCache__ } from \"react\";\n+const { foo: fooCached } = {\n+    foo: async ()=>{}\n };\n+let $$RSC_SERVER_CACHE_fooCached = fooCached;\n+if (typeof fooCached === \"function\") {\n+    $$RSC_SERVER_CACHE_fooCached = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ffaa88e24cee8047d167e47f4f374dbddc187e2899\", 0, fooCached, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_fooCached, \"ffaa88e24cee8047d167e47f4f374dbddc187e2899\", null);\n+    Object[\"defineProperty\"]($$RSC_SERVER_CACHE_fooCached, \"name\", {\n+        value: \"fooCached\"\n+    });\n+}\n+export { $$RSC_SERVER_CACHE_fooCached as fooCached };"
        },
        {
            "sha": "a935f3cd1a1336311de7ad0e3c8630887b2b7dbc",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/server-graph/63/data.ts",
            "status": "added",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F63%2Fdata.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F63%2Fdata.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F63%2Fdata.ts?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,2 @@\n+export interface Data {}\n+export async function getData() {}"
        },
        {
            "sha": "f6a8e7afa669339ca7dadc3e29817c63f08c33c8",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/server-graph/63/input.tsx",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F63%2Finput.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F63%2Finput.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F63%2Finput.tsx?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,30 @@\n+'use cache'\n+\n+// @ts-ignore\n+import { getStuff, wrap, type Stuff } from './foo'\n+export { getData, type Data } from './data'\n+\n+export const getCachedData = async (): Stuff => {\n+  // This is not using the wrapped version of getStuff, as we're only\n+  // runtime-wrapping what flows out of the module, not into it. Would one\n+  // expect this to be cached?\n+  return getStuff()\n+}\n+\n+export const aliased = getStuff\n+\n+const Layout = wrap(async () => <div>Layout</div>)\n+const Other = wrap(async () => <div>Other</div>)\n+export const Sync = wrap(() => <div>Sync</div>)\n+\n+export const wrapped = wrap(\n+  async () => 'foo',\n+  async () => 'bar',\n+  async () => async () => 'baz',\n+  () => 'sync'\n+)\n+\n+export default Layout\n+export { Other, getStuff, staticallyKnownFunction }\n+\n+async function staticallyKnownFunction() {}"
        },
        {
            "sha": "1163192b1e3158dd0d0a21e5f4f36c06afe0de13",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/server-graph/63/output.tsx",
            "status": "added",
            "additions": 113,
            "deletions": 0,
            "changes": 113,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F63%2Foutput.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F63%2Foutput.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F63%2Foutput.tsx?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,113 @@\n+/* __next_internal_action_entry_do_not_use__ {\"803128060c414d59f8552e4788b846c0d2b7f74743\":\"$$RSC_SERVER_CACHE_0\",\"80951c375b4a6a6e89d67b743ec5808127cfde405d\":\"$$RSC_SERVER_CACHE_1\",\"ff1acff246876a467753785a92d1f95ac6fe32c9b9\":\"Other\",\"ff27fadf3eeb97c777cea9f14a407b5c0b42ac65bb\":\"aliased\",\"ff438bb59117ff1af890c80ca3e39d9e888fc93033\":\"wrapped\",\"ff84effee663e5ce4e0948b55df129a8df904c67aa\":\"Sync\",\"ff8fa22f08e492db15701f58a1458cc4ebf782f855\":\"getData\",\"ff980f8c891ae27674b86a4804d306bdb3065c2e4f\":\"getStuff\",\"ffc18c215a6b7cdc64bf709f3a714ffdef1bf9651d\":\"default\"} */ import { registerServerReference } from \"private-next-rsc-server-reference\";\n+import { cache as $$cache__ } from \"private-next-rsc-cache-wrapper\";\n+import { cache as $$reactCache__ } from \"react\";\n+// @ts-ignore\n+import { getStuff, wrap, type Stuff } from './foo';\n+export { type Data } from './data';\n+import { getData } from './data';\n+const $$RSC_SERVER_CACHE_0_INNER = async function getCachedData() {\n+    // This is not using the wrapped version of getStuff, as we're only\n+    // runtime-wrapping what flows out of the module, not into it. Would one\n+    // expect this to be cached?\n+    return getStuff();\n+};\n+export var $$RSC_SERVER_CACHE_0 = $$reactCache__(function getCachedData() {\n+    return $$cache__(\"default\", \"803128060c414d59f8552e4788b846c0d2b7f74743\", 0, $$RSC_SERVER_CACHE_0_INNER, arguments);\n+});\n+registerServerReference($$RSC_SERVER_CACHE_0, \"803128060c414d59f8552e4788b846c0d2b7f74743\", null);\n+Object[\"defineProperty\"]($$RSC_SERVER_CACHE_0, \"name\", {\n+    value: \"getCachedData\"\n+});\n+export const getCachedData = $$RSC_SERVER_CACHE_0;\n+const aliased = getStuff;\n+const Layout = wrap(async ()=><div>Layout</div>);\n+const Other = wrap(async ()=><div>Other</div>);\n+const Sync = wrap(()=><div>Sync</div>);\n+const wrapped = wrap(async ()=>'foo', async ()=>'bar', async ()=>async ()=>'baz', ()=>'sync');\n+export { staticallyKnownFunction };\n+const $$RSC_SERVER_CACHE_1_INNER = async function staticallyKnownFunction() {};\n+export var $$RSC_SERVER_CACHE_1 = $$reactCache__(function staticallyKnownFunction() {\n+    return $$cache__(\"default\", \"80951c375b4a6a6e89d67b743ec5808127cfde405d\", 0, $$RSC_SERVER_CACHE_1_INNER, arguments);\n+});\n+registerServerReference($$RSC_SERVER_CACHE_1, \"80951c375b4a6a6e89d67b743ec5808127cfde405d\", null);\n+Object[\"defineProperty\"]($$RSC_SERVER_CACHE_1, \"name\", {\n+    value: \"staticallyKnownFunction\"\n+});\n+var staticallyKnownFunction = $$RSC_SERVER_CACHE_1;\n+let $$RSC_SERVER_CACHE_getData = getData;\n+if (typeof getData === \"function\") {\n+    $$RSC_SERVER_CACHE_getData = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ff8fa22f08e492db15701f58a1458cc4ebf782f855\", 0, getData, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_getData, \"ff8fa22f08e492db15701f58a1458cc4ebf782f855\", null);\n+    Object[\"defineProperty\"]($$RSC_SERVER_CACHE_getData, \"name\", {\n+        value: \"getData\"\n+    });\n+}\n+export { $$RSC_SERVER_CACHE_getData as getData };\n+let $$RSC_SERVER_CACHE_aliased = aliased;\n+if (typeof aliased === \"function\") {\n+    $$RSC_SERVER_CACHE_aliased = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ff27fadf3eeb97c777cea9f14a407b5c0b42ac65bb\", 0, aliased, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_aliased, \"ff27fadf3eeb97c777cea9f14a407b5c0b42ac65bb\", null);\n+    Object[\"defineProperty\"]($$RSC_SERVER_CACHE_aliased, \"name\", {\n+        value: \"aliased\"\n+    });\n+}\n+export { $$RSC_SERVER_CACHE_aliased as aliased };\n+let $$RSC_SERVER_CACHE_Sync = Sync;\n+if (typeof Sync === \"function\") {\n+    $$RSC_SERVER_CACHE_Sync = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ff84effee663e5ce4e0948b55df129a8df904c67aa\", 0, Sync, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_Sync, \"ff84effee663e5ce4e0948b55df129a8df904c67aa\", null);\n+    Object[\"defineProperty\"]($$RSC_SERVER_CACHE_Sync, \"name\", {\n+        value: \"Sync\"\n+    });\n+}\n+export { $$RSC_SERVER_CACHE_Sync as Sync };\n+let $$RSC_SERVER_CACHE_wrapped = wrapped;\n+if (typeof wrapped === \"function\") {\n+    $$RSC_SERVER_CACHE_wrapped = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ff438bb59117ff1af890c80ca3e39d9e888fc93033\", 0, wrapped, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_wrapped, \"ff438bb59117ff1af890c80ca3e39d9e888fc93033\", null);\n+    Object[\"defineProperty\"]($$RSC_SERVER_CACHE_wrapped, \"name\", {\n+        value: \"wrapped\"\n+    });\n+}\n+export { $$RSC_SERVER_CACHE_wrapped as wrapped };\n+let $$RSC_SERVER_CACHE_default = Layout;\n+if (typeof Layout === \"function\") {\n+    $$RSC_SERVER_CACHE_default = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ffc18c215a6b7cdc64bf709f3a714ffdef1bf9651d\", 0, Layout, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_default, \"ffc18c215a6b7cdc64bf709f3a714ffdef1bf9651d\", null);\n+    Object[\"defineProperty\"]($$RSC_SERVER_CACHE_default, \"name\", {\n+        value: \"Layout\"\n+    });\n+}\n+export default $$RSC_SERVER_CACHE_default;\n+let $$RSC_SERVER_CACHE_Other = Other;\n+if (typeof Other === \"function\") {\n+    $$RSC_SERVER_CACHE_Other = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ff1acff246876a467753785a92d1f95ac6fe32c9b9\", 0, Other, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_Other, \"ff1acff246876a467753785a92d1f95ac6fe32c9b9\", null);\n+    Object[\"defineProperty\"]($$RSC_SERVER_CACHE_Other, \"name\", {\n+        value: \"Other\"\n+    });\n+}\n+export { $$RSC_SERVER_CACHE_Other as Other };\n+let $$RSC_SERVER_CACHE_getStuff = getStuff;\n+if (typeof getStuff === \"function\") {\n+    $$RSC_SERVER_CACHE_getStuff = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ff980f8c891ae27674b86a4804d306bdb3065c2e4f\", 0, getStuff, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_getStuff, \"ff980f8c891ae27674b86a4804d306bdb3065c2e4f\", null);\n+    Object[\"defineProperty\"]($$RSC_SERVER_CACHE_getStuff, \"name\", {\n+        value: \"getStuff\"\n+    });\n+}\n+export { $$RSC_SERVER_CACHE_getStuff as getStuff };"
        },
        {
            "sha": "6f89eac92534a10998584a8471d6371c68f072a4",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/server-graph/64/input.js",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F64%2Finput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F64%2Finput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F64%2Finput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,10 @@\n+'use cache'\n+\n+// @ts-ignore\n+import { withSlug } from './with-slug'\n+\n+const Page = withSlug(function Page({ slug }) {\n+  return <p>Slug: {slug}</p>\n+})\n+\n+export default Page"
        },
        {
            "sha": "7c79b0aa514af581240a576d09e543db28aba50d",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/server-graph/64/output.js",
            "status": "added",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F64%2Foutput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F64%2Foutput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F64%2Foutput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,19 @@\n+/* __next_internal_action_entry_do_not_use__ {\"ffc18c215a6b7cdc64bf709f3a714ffdef1bf9651d\":\"default\"} */ import { registerServerReference } from \"private-next-rsc-server-reference\";\n+import { cache as $$cache__ } from \"private-next-rsc-cache-wrapper\";\n+import { cache as $$reactCache__ } from \"react\";\n+// @ts-ignore\n+import { withSlug } from './with-slug';\n+const Page = withSlug(function Page({ slug }) {\n+    return <p>Slug: {slug}</p>;\n+});\n+let $$RSC_SERVER_CACHE_default = Page;\n+if (typeof Page === \"function\") {\n+    $$RSC_SERVER_CACHE_default = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ffc18c215a6b7cdc64bf709f3a714ffdef1bf9651d\", 0, Page, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_default, \"ffc18c215a6b7cdc64bf709f3a714ffdef1bf9651d\", null);\n+    Object[\"defineProperty\"]($$RSC_SERVER_CACHE_default, \"name\", {\n+        value: \"Page\"\n+    });\n+}\n+export default $$RSC_SERVER_CACHE_default;"
        },
        {
            "sha": "e43b0cbefdb538ddc24c4c314a491310e3992de6",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/server-graph/65/input.js",
            "status": "added",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F65%2Finput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F65%2Finput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F65%2Finput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,19 @@\n+'use cache'\n+\n+// @ts-ignore\n+import { wrapItLikeItsHot } from './wrap-it-like-its-hot'\n+// @ts-ignore\n+import { ClientComponent } from './client-component'\n+\n+export default wrapItLikeItsHot(({ hot }) => {\n+  return (\n+    <ClientComponent\n+      action={async () => {\n+        'use server'\n+        console.log('hot action')\n+      }}\n+    >\n+      {hot}\n+    </ClientComponent>\n+  )\n+})"
        },
        {
            "sha": "67991ea4b14449c131ff44073861f53a3f1f9312",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/server-graph/65/output.js",
            "status": "added",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F65%2Foutput.js",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F65%2Foutput.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F65%2Foutput.js?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,24 @@\n+/* __next_internal_action_entry_do_not_use__ {\"006a88810ecce4a4e8b59d53b8327d7e98bbf251d7\":\"$$RSC_SERVER_ACTION_0\",\"ffc18c215a6b7cdc64bf709f3a714ffdef1bf9651d\":\"default\"} */ import { registerServerReference } from \"private-next-rsc-server-reference\";\n+import { cache as $$cache__ } from \"private-next-rsc-cache-wrapper\";\n+import { cache as $$reactCache__ } from \"react\";\n+// @ts-ignore\n+import { wrapItLikeItsHot } from './wrap-it-like-its-hot';\n+// @ts-ignore\n+import { ClientComponent } from './client-component';\n+export const $$RSC_SERVER_ACTION_0 = async function action() {\n+    console.log('hot action');\n+};\n+registerServerReference($$RSC_SERVER_ACTION_0, \"006a88810ecce4a4e8b59d53b8327d7e98bbf251d7\", null);\n+const $$RSC_SERVER_CACHE_1 = wrapItLikeItsHot(({ hot })=>{\n+    return <ClientComponent action={$$RSC_SERVER_ACTION_0}>\n+      {hot}\n+    </ClientComponent>;\n+});\n+let $$RSC_SERVER_CACHE_default = $$RSC_SERVER_CACHE_1;\n+if (typeof $$RSC_SERVER_CACHE_1 === \"function\") {\n+    $$RSC_SERVER_CACHE_default = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ffc18c215a6b7cdc64bf709f3a714ffdef1bf9651d\", 0, $$RSC_SERVER_CACHE_1, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_default, \"ffc18c215a6b7cdc64bf709f3a714ffdef1bf9651d\", null);\n+}\n+export default $$RSC_SERVER_CACHE_default;"
        },
        {
            "sha": "14262a188fdbf3d94dcb8b94e873e660e053af2d",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/server-graph/68/input.tsx",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F68%2Finput.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F68%2Finput.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F68%2Finput.tsx?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,10 @@\n+'use cache'\n+\n+// @ts-ignore\n+import { foo, bar } from './foo'\n+\n+type Foo = {}\n+type Bar = {}\n+\n+export { foo, Foo }\n+export { bar, type Bar }"
        },
        {
            "sha": "66a962ad8728bc52a9eaa48c99ea867c991ad6b7",
            "filename": "crates/next-custom-transforms/tests/fixture/server-actions/server-graph/68/output.tsx",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F68%2Foutput.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F68%2Foutput.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Ftests%2Ffixture%2Fserver-actions%2Fserver-graph%2F68%2Foutput.tsx?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,33 @@\n+/* __next_internal_action_entry_do_not_use__ {\"ffab21efdafbe611287bc25c0462b1e0510d13e48b\":\"foo\",\"ffac840dcaf5e8197cb02b7f3a43c119b7a770b272\":\"bar\"} */ import { registerServerReference } from \"private-next-rsc-server-reference\";\n+import { cache as $$cache__ } from \"private-next-rsc-cache-wrapper\";\n+import { cache as $$reactCache__ } from \"react\";\n+// @ts-ignore\n+import { foo, bar } from './foo';\n+type Foo = {\n+};\n+type Bar = {\n+};\n+export { Foo };\n+export { type Bar };\n+let $$RSC_SERVER_CACHE_foo = foo;\n+if (typeof foo === \"function\") {\n+    $$RSC_SERVER_CACHE_foo = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ffab21efdafbe611287bc25c0462b1e0510d13e48b\", 0, foo, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_foo, \"ffab21efdafbe611287bc25c0462b1e0510d13e48b\", null);\n+    Object[\"defineProperty\"]($$RSC_SERVER_CACHE_foo, \"name\", {\n+        value: \"foo\"\n+    });\n+}\n+export { $$RSC_SERVER_CACHE_foo as foo };\n+let $$RSC_SERVER_CACHE_bar = bar;\n+if (typeof bar === \"function\") {\n+    $$RSC_SERVER_CACHE_bar = $$reactCache__(function() {\n+        return $$cache__(\"default\", \"ffac840dcaf5e8197cb02b7f3a43c119b7a770b272\", 0, bar, arguments);\n+    });\n+    registerServerReference($$RSC_SERVER_CACHE_bar, \"ffac840dcaf5e8197cb02b7f3a43c119b7a770b272\", null);\n+    Object[\"defineProperty\"]($$RSC_SERVER_CACHE_bar, \"name\", {\n+        value: \"bar\"\n+    });\n+}\n+export { $$RSC_SERVER_CACHE_bar as bar };"
        },
        {
            "sha": "7d38bfa762137638e8103e8f1388cfd5e86a9158",
            "filename": "packages/next/src/server/lib/lazy-result.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Flazy-result.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Flazy-result.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Flazy-result.ts?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -2,19 +2,19 @@ export type LazyResult<TValue> = PromiseLike<TValue> & { value?: TValue }\n export type ResolvedLazyResult<TValue> = PromiseLike<TValue> & { value: TValue }\n \n /**\n- * Calls the given async function only when the returned promise-like object is\n+ * Calls the given function only when the returned promise-like object is\n  * awaited. Afterwards, it provides the resolved value synchronously as `value`\n  * property.\n  */\n export function createLazyResult<TValue>(\n-  fn: () => Promise<TValue>\n+  fn: () => Promise<TValue> | TValue\n ): LazyResult<TValue> {\n   let pendingResult: Promise<TValue> | undefined\n \n   const result: LazyResult<TValue> = {\n     then(onfulfilled, onrejected) {\n       if (!pendingResult) {\n-        pendingResult = fn()\n+        pendingResult = Promise.resolve(fn())\n       }\n \n       pendingResult"
        },
        {
            "sha": "6b26b948c5f9ddbc6488a7d277420c2a2b1db3ff",
            "filename": "test/e2e/app-dir/use-cache/app/(dynamic)/hoc/[slug]/page.tsx",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(dynamic)%2Fhoc%2F%5Bslug%5D%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(dynamic)%2Fhoc%2F%5Bslug%5D%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(dynamic)%2Fhoc%2F%5Bslug%5D%2Fpage.tsx?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,18 @@\n+'use cache: remote'\n+\n+import { withSlug } from './with-slug'\n+\n+const Page = withSlug(function PageWithSlug({ slug }: { slug: string }) {\n+  return (\n+    <div>\n+      <p>\n+        Slug: <span id=\"slug\">{slug}</span>\n+      </p>\n+      <p>\n+        Date: <span id=\"date\">{new Date().toISOString()}</span>\n+      </p>\n+    </div>\n+  )\n+})\n+\n+export default Page"
        },
        {
            "sha": "700eae9560c3f2c71cb8aa6147e2dcbde7f3b5be",
            "filename": "test/e2e/app-dir/use-cache/app/(dynamic)/hoc/[slug]/with-slug.tsx",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(dynamic)%2Fhoc%2F%5Bslug%5D%2Fwith-slug.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(dynamic)%2Fhoc%2F%5Bslug%5D%2Fwith-slug.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fapp%2F(dynamic)%2Fhoc%2F%5Bslug%5D%2Fwith-slug.tsx?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -0,0 +1,10 @@\n+export function withSlug<P extends { params: Promise<{ slug: string }> }>(\n+  Component: React.ComponentType<{ slug: string }>\n+): React.ComponentType<{ params: Promise<{ slug: string }> }> {\n+  return async function ComponentWithSlug(props: P) {\n+    const params = await props.params\n+    const slug = params.slug\n+\n+    return <Component slug={slug} />\n+  }\n+}"
        },
        {
            "sha": "51bb36e8760adc737f873eefea2c2364ca56c62e",
            "filename": "test/e2e/app-dir/use-cache/use-cache.test.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/59fe222b5e4f83349462663ce073fbbbcdf03962/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/59fe222b5e4f83349462663ce073fbbbcdf03962/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache%2Fuse-cache.test.ts?ref=59fe222b5e4f83349462663ce073fbbbcdf03962",
            "patch": "@@ -1361,6 +1361,16 @@ describe('use-cache', () => {\n       expect(initialScale2).toBe(initialScale)\n       expect(maximumScale2).toBe(maximumScale)\n     })\n+\n+    it('caches a higher-order component in a \"use cache\" module', async () => {\n+      const browser = await next.browser('/hoc/foo')\n+      const slug = await browser.elementById('slug').text()\n+      expect(slug).toBe('foo')\n+      const date = await browser.elementById('date').text()\n+      expect(date).toBeDateString()\n+      await browser.refresh()\n+      expect(await browser.elementById('date').text()).toBe(date)\n+    })\n   }\n })\n "
        }
    ],
    "stats": {
        "total": 1192,
        "additions": 1021,
        "deletions": 171
    }
}