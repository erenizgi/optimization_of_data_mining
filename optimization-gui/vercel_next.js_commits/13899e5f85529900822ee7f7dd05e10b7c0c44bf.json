{
    "author": "bgw",
    "message": "Turbopack: Restore watchers for children when using non-recursive FS watcher (#82130)\n\n**This should be merged alongside #82258, as this introduces a potentially high time complexity operation that #82258 solves.**\n\nWith this PR and the previous one, my fuzzer shows that we capture every (currently tested) file change correctly:\n\n```\nrm -rf /tmp/fuzz && cargo run --release -p turbo-tasks-fuzz -- fs-watcher --fs-root /tmp/fuzz\n```\n\nHowever, this does add an `O(n)` iteration of the `watching` map that I'm working on cleaning up (why this is still a draft).\n\nI'll do something similar to https://github.com/vercel/next.js/pull/82133, but it's a bit more complicated to switch to a `BTreeSet` because it's currently using a `DashSet`, and I don't want to introduce more locking than I have to.",
    "sha": "13899e5f85529900822ee7f7dd05e10b7c0c44bf",
    "files": [
        {
            "sha": "5f2a32361de6821cfb9d40bc44ad63cca6e07dcb",
            "filename": "turbopack/crates/turbo-tasks-fs/src/watcher.rs",
            "status": "modified",
            "additions": 82,
            "deletions": 46,
            "changes": 128,
            "blob_url": "https://github.com/vercel/next.js/blob/13899e5f85529900822ee7f7dd05e10b7c0c44bf/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/13899e5f85529900822ee7f7dd05e10b7c0c44bf/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs?ref=13899e5f85529900822ee7f7dd05e10b7c0c44bf",
            "patch": "@@ -4,13 +4,13 @@ use std::{\n     mem::take,\n     path::{Path, PathBuf},\n     sync::{\n-        Arc, LazyLock, Mutex, MutexGuard,\n+        Arc, LazyLock, Mutex,\n         mpsc::{Receiver, TryRecvError, channel},\n     },\n     time::Duration,\n };\n \n-use anyhow::{Context, Result, anyhow};\n+use anyhow::{Context, Result};\n use dashmap::DashSet;\n use notify::{\n     Config, EventKind, PollWatcher, RecommendedWatcher, RecursiveMode, Watcher,\n@@ -78,6 +78,8 @@ impl DiskWatcherInternal {\n \n #[derive(Serialize, Deserialize)]\n pub(crate) struct DiskWatcher {\n+    /// This value is [`None`] when the watcher has been stopped (see\n+    /// [`DiskWatcher::stop_watching`]).\n     #[serde(skip)]\n     internal: Mutex<Option<DiskWatcherInternal>>,\n \n@@ -118,10 +120,17 @@ impl NonRecursiveDiskWatcherState {\n \n     /// Called after a rescan in case a previously watched-but-deleted directory was recreated.\n     pub(crate) fn restore_all_watching(&self, watcher: &DiskWatcher, root_path: &Path) {\n-        let mut internal = watcher.internal.lock().unwrap();\n+        let mut internal_guard = watcher.internal.lock().unwrap();\n+        let Some(internal) = &mut *internal_guard else {\n+            return;\n+        };\n         for dir_path in self.watching.iter() {\n             // TODO: Report diagnostics if this error happens\n-            let _ = self.start_watching_dir(&mut internal, &dir_path, root_path);\n+            //\n+            // Don't watch the parents, because those are already included in `self.watching` (so\n+            // it'd be redundant), but also because this could deadlock, since we'd try to modify\n+            // `self.watching` while iterating over it (write lock overlapping with a read lock).\n+            let _ = self.start_watching_dir(internal, &dir_path, root_path);\n         }\n     }\n \n@@ -136,9 +145,24 @@ impl NonRecursiveDiskWatcherState {\n         if dir_path == root_path || !self.watching.contains(dir_path) {\n             return Ok(());\n         }\n-        let mut internal = watcher.internal.lock().unwrap();\n-        // TODO: Also restore any watchers for children of this directory\n-        self.start_watching_dir(&mut internal, dir_path, root_path)\n+        let mut internal_guard = watcher.internal.lock().unwrap();\n+        let Some(internal) = &mut *internal_guard else {\n+            return Ok(());\n+        };\n+\n+        // watch the new directory\n+        self.start_watching_dir(internal, dir_path, root_path)?;\n+\n+        // Also try to restore any watchers for children of this directory\n+        for child_path in self\n+            .watching\n+            .iter()\n+            .filter(|p| p.key().starts_with(dir_path) && **p != dir_path)\n+        {\n+            // Don't watch the parents -- see the comment on `restore_all_watching`\n+            self.start_watching_dir(internal, child_path.key(), root_path)?;\n+        }\n+        Ok(())\n     }\n \n     /// Called when a file in `dir_path` or `dir_path` itself is read or written. Adds a new watcher\n@@ -152,60 +176,72 @@ impl NonRecursiveDiskWatcherState {\n         if dir_path == root_path || self.watching.contains(dir_path) {\n             return Ok(());\n         }\n-        let mut internal = watcher.internal.lock().unwrap();\n+        let mut internal_guard = watcher.internal.lock().unwrap();\n+        let Some(internal) = &mut *internal_guard else {\n+            return Ok(());\n+        };\n         if self.watching.insert(dir_path.to_path_buf()) {\n-            self.start_watching_dir(&mut internal, dir_path, root_path)?;\n+            self.start_watching_dir_and_parents(internal, dir_path, root_path)?;\n         }\n         Ok(())\n     }\n \n-    /// Private helper, assumes that the path has already been added to `self.watching`.\n+    /// Private helper, assumes that `dir_path` has already been added to `self.watching`.\n+    ///\n+    /// This does not watch any of the parent directories. For that, use\n+    /// [`start_watching_dir_and_parents`]. Use this method when iterating over previously-watched\n+    /// values in `self.watching`.\n     fn start_watching_dir(\n         &self,\n-        watcher_internal_guard: &mut MutexGuard<Option<DiskWatcherInternal>>,\n+        watcher_internal: &mut DiskWatcherInternal,\n         dir_path: &Path,\n         root_path: &Path,\n     ) -> Result<()> {\n         debug_assert_ne!(dir_path, root_path);\n-        let Some(watcher_internal_guard) = watcher_internal_guard.as_mut() else {\n-            return Ok(());\n-        };\n \n-        let mut path = dir_path;\n-        let err_with_context = |err: anyhow::Error| {\n-            return Err(err).context(format!(\n-                \"Unable to watch {} (tried up to {})\",\n-                dir_path.display(),\n-                path.display()\n-            ));\n-        };\n+        match watcher_internal.watch(dir_path, RecursiveMode::NonRecursive) {\n+            Ok(())\n+            | Err(notify::Error {\n+                // The path was probably deleted before we could process the event, but the parent\n+                // should still be watched. The codepaths that care about this either call\n+                // `start_watching_dir_and_parents` or handle the parents themselves.\n+                kind: notify::ErrorKind::PathNotFound,\n+                ..\n+            }) => Ok(()),\n+            Err(err) => {\n+                return Err(err).context(format!(\"Unable to watch {}\", dir_path.display(),));\n+            }\n+        }\n+    }\n \n-        // watch every parent: https://docs.rs/notify/latest/notify/#parent-folder-deletion\n+    /// Private helper, assumes that `dir_path` has already been added to `self.watching`.\n+    ///\n+    /// Watches the given `dir_path` and every parent up to `root_path`. Parents must be recursively\n+    /// watched in case any of them change:\n+    /// https://docs.rs/notify/latest/notify/#parent-folder-deletion\n+    fn start_watching_dir_and_parents(\n+        &self,\n+        watcher_internal: &mut DiskWatcherInternal,\n+        dir_path: &Path,\n+        root_path: &Path,\n+    ) -> Result<()> {\n+        let mut cur_path = dir_path;\n         loop {\n-            match watcher_internal_guard.watch(path, RecursiveMode::NonRecursive) {\n-                res @ Ok(())\n-                | res @ Err(notify::Error {\n-                    // The path was probably deleted before we could process the event. That's\n-                    // okay, just make sure we're watching the parent directory, so we can know\n-                    // if it gets recreated.\n-                    kind: notify::ErrorKind::PathNotFound,\n-                    ..\n-                }) => {\n-                    let Some(parent_path) = path.parent() else {\n-                        // this should never happen as we break before we reach the root path\n-                        return err_with_context(res.err().map_or_else(\n-                            || anyhow!(\"failed to compute parent path\"),\n-                            |err| err.into(),\n-                        ));\n-                    };\n-                    if parent_path == root_path || !self.watching.insert(parent_path.to_path_buf())\n-                    {\n-                        break;\n-                    }\n-                    path = parent_path;\n-                }\n-                Err(err) => return err_with_context(err.into()),\n+            self.start_watching_dir(watcher_internal, cur_path, root_path)?;\n+\n+            let Some(parent_path) = cur_path.parent() else {\n+                // this should never happen as we break before we reach the root path\n+                anyhow::bail!(\n+                    \"failed to compute parent path of {cur_path:?} while watching {dir_path:?} in \\\n+                     root {root_path:?}\"\n+                );\n+            };\n+\n+            if parent_path == root_path || !self.watching.insert(parent_path.to_path_buf()) {\n+                break;\n             }\n+\n+            cur_path = parent_path;\n         }\n \n         Ok(())"
        }
    ],
    "stats": {
        "total": 128,
        "additions": 82,
        "deletions": 46
    }
}