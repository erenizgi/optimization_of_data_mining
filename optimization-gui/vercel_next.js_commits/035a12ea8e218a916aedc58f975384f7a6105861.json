{
    "author": "gnoff",
    "message": "[dynamicIO] Document client component remediations for sync IO (#79787)\n\nWhen you use sync IO in the client in a way that needs to be fixed we\ncurrently still just provide you with the explanation for server\ncomponents. The fixes when sync IO happens in the client are not the\nsame as when they happen in a server component so this update adds\nclient specific documentation for these situations.\n\nNamely, the key difference is that on the server you can add caching\nthrough \"use cache\" and this is not available to you in the client. sync\nIO in general is (going to be) allowed in client components broadly as\nlong as Next.js has a fallback UI to prerender. This means that \"fixing\"\nsync IO access in the client will usually be solved by wrapping in a\nSuspense boundary. The alternative is to move the sync IO out of render\nor move it to the server where it can be cached.",
    "sha": "035a12ea8e218a916aedc58f975384f7a6105861",
    "files": [
        {
            "sha": "fb06c95c2d0f82b05721a85f57f62232e21df364",
            "filename": "errors/next-prerender-crypto-client.mdx",
            "status": "added",
            "additions": 149,
            "deletions": 0,
            "changes": 149,
            "blob_url": "https://github.com/vercel/next.js/blob/035a12ea8e218a916aedc58f975384f7a6105861/errors%2Fnext-prerender-crypto-client.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/035a12ea8e218a916aedc58f975384f7a6105861/errors%2Fnext-prerender-crypto-client.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fnext-prerender-crypto-client.mdx?ref=035a12ea8e218a916aedc58f975384f7a6105861",
            "patch": "@@ -0,0 +1,149 @@\n+---\n+title: Cannot access `crypto.getRandomValue()`, `crypto.randomUUID()`, or another web or node crypto API that generates random values synchronously from a Client Component without a fallback UI defined\n+---\n+\n+## Why This Error Occurred\n+\n+A Client Component is accessing a random value synchronously from the Web Crypto API or from Node's `crypto` API.\n+\n+Client Components primarily run in the browser however on an initial page visit, Next.js will serve an HTML page produced by simulating the client environment on the server. This process is called Server Side Rendering or SSR. Next.js will attempt to prerender this HTML ahead of time however if a Client Component accesses a random source during this prerender, it cannot include this component in the prerendered HTML, otherwise the value will be fixed on each user request and not random like expected. Next.js will use the nearest Suspense boundary around this component to prerender a fallback instead however in this instance there was no Suspense boundary.\n+\n+There are a number of ways you might fix this issue depending on the specifics of your use case.\n+\n+## Possible Ways to Fix It\n+\n+### Provide Fallback UI\n+\n+If your random value is intended to be unique per Request, add a Suspense boundary around the component that calls the crypto API that produces this value. This allows Next.js to prerender a fallback UI and fill in an actual random value when the user requests the page.\n+\n+Before:\n+\n+```jsx filename=\"app/blog/new/page.js\"\n+'use client'\n+\n+export default function Page() {\n+  const newBlogId = crypto.randomUUID()\n+  return <BlogAuthoringView id={newBlogId} />\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/blog/new/page.js\"\n+\"use client\"\n+\n+import { Suspense } from 'react'\n+\n+export default function Page() {\n+  return (\n+    <Suspense fallback={<BlogAuthorSkeleton />}>\n+      <DynamicAuthoringView />\n+    </Suspense>\n+  )\n+}\n+\n+function BlogAuthorSkeleton() {\n+  ...\n+}\n+\n+function DynamicAuthoringView() {\n+  const newBlogId = crypto.randomUUID()\n+  return <BlogAuthoringView id={newBlogId} />\n+}\n+```\n+\n+### Only access crypto in the browser\n+\n+If your random value is only intended for use in the browser you can move the call into an effect or event handler. React does not run effects during server rendering and there are no events during server rendering so neither option will require the prerender to exclude this component.\n+\n+Before:\n+\n+```jsx filename=\"app/workflow.js\"\n+'use client'\n+\n+function createSecureId() {\n+  const array = new Uint8Array(16)\n+  crypto.getRandomValues(array)\n+  return array[0].toString(16)\n+}\n+\n+export default function Workflow({ currentStep, onNext, onPrev }) {\n+  const [id] = useState(createSecureId)\n+\n+  const next = onNext\n+    ? () => {\n+        trackEvent(id, 'forward')\n+        onNext()\n+      }\n+    : null\n+\n+  const previous = onPrev\n+    ? () => {\n+        trackEvent(id, 'previous')\n+        onPrev()\n+      }\n+    : null\n+\n+  return (\n+    <>\n+      {currentStep}\n+      {next ? <button onClick={next}>Next</button> : null}\n+      {previous ? <button onClick={previous}>Previous</button> : null}\n+    </>\n+  )\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/workflow.js\"\n+'use client'\n+\n+import { useRef } from 'react'\n+\n+function createSecureId() {\n+  const array = new Uint8Array(16)\n+  crypto.getRandomValues(array)\n+  return array[0].toString(16)\n+}\n+\n+function getOrCreateId(ref) {\n+  if (!ref.current) {\n+    ref.current = createSecureId()\n+  }\n+  return ref.current\n+}\n+\n+export default function Workflow({ currentStep, onNext, onPrev }) {\n+  const idRef = useRef(null)\n+\n+  const next = onNext\n+    ? () => {\n+        trackEvent(getOrCreateId(idRef), 'forward')\n+        onNext()\n+      }\n+    : null\n+\n+  const previous = onPrev\n+    ? () => {\n+        trackEvent(getOrCreateId(idRef), 'previous')\n+        onPrev()\n+      }\n+    : null\n+\n+  return (\n+    <>\n+      {currentStep}\n+      {next ? <button onClick={next}>Next</button> : null}\n+      {previous ? <button onClick={previous}>Previous</button> : null}\n+    </>\n+  )\n+}\n+```\n+\n+## Useful Links\n+\n+- [`connection` function](/docs/app/api-reference/functions/connection)\n+- [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)\n+- [Node Crypto API](https://nodejs.org/docs/latest/api/crypto.html)\n+- [`Suspense` React API](https://react.dev/reference/react/Suspense)"
        },
        {
            "sha": "30ed3bcd4380108ee451290dd61d75105ea14bad",
            "filename": "errors/next-prerender-crypto.mdx",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/035a12ea8e218a916aedc58f975384f7a6105861/errors%2Fnext-prerender-crypto.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/035a12ea8e218a916aedc58f975384f7a6105861/errors%2Fnext-prerender-crypto.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fnext-prerender-crypto.mdx?ref=035a12ea8e218a916aedc58f975384f7a6105861",
            "patch": "@@ -1,12 +1,12 @@\n ---\n-title: Cannot access `crypto.getRandomValue()`, `crypto.randomUUID()`, or another web or node crypto API that generates random values synchronously while prerendering\n+title: Cannot access `crypto.getRandomValue()`, `crypto.randomUUID()`, or another web or node crypto API that generates random values synchronously in a Server Component\n ---\n \n ## Why This Error Occurred\n \n An API that produces a random value synchronously from the Web Crypto API or from Node's `crypto` API was called outside of a `\"use cache\"` scope and without first calling `await connection()`. Random values that are produced synchronously must either be inside a `\"use cache\"` scope or be preceded with `await connection()` to explicitly communicate to Next.js whether the random values produced can be reused across many requests (cached) or if they must be unique per Request (`await connection()`).\n \n-If the API used has an async version you can also switch to that in instead of using `await connection()`.\n+If the API used has an async version you can also switch to that instead of using `await connection()`.\n \n ## Possible Ways to Fix It\n \n@@ -17,7 +17,7 @@ If you are generating a token to talk to a database that itself should be cached\n Before:\n \n ```jsx filename=\"app/page.js\"\n-async function getCachedDate(token: string) {\n+async function getCachedData(token: string) {\n   \"use cache\"\n   return db.query(token, ...)\n }\n@@ -32,7 +32,7 @@ export default async function Page() {\n After:\n \n ```jsx filename=\"app/page.js\"\n-async function getCachedDate(token: string) {\n+async function getCachedData() {\n   \"use cache\"\n   const token = crypto.getRandomUUID()\n   return db.query(token, ...)\n@@ -81,7 +81,7 @@ Before:\n ```jsx filename=\"app/page.js\"\n export default async function Page() {\n   const uuid = crypto.randomUUID()\n-  return <RequestId id={uuid}>\n+  return <RequestId id={uuid} />\n }\n ```\n \n@@ -93,7 +93,7 @@ import { connection } from 'next/server'\n export default async function Page() {\n   await connection()\n   const uuid = crypto.randomUUID()\n-  return <RequestId id={uuid}>\n+  return <RequestId id={uuid} />\n }\n ```\n "
        },
        {
            "sha": "3b93a1f62003f5c914d63eca901d3d0d7f33d112",
            "filename": "errors/next-prerender-current-time-client.mdx",
            "status": "added",
            "additions": 201,
            "deletions": 0,
            "changes": 201,
            "blob_url": "https://github.com/vercel/next.js/blob/035a12ea8e218a916aedc58f975384f7a6105861/errors%2Fnext-prerender-current-time-client.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/035a12ea8e218a916aedc58f975384f7a6105861/errors%2Fnext-prerender-current-time-client.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fnext-prerender-current-time-client.mdx?ref=035a12ea8e218a916aedc58f975384f7a6105861",
            "patch": "@@ -0,0 +1,201 @@\n+---\n+title: Cannot access current time from a Client Component without a fallback UI defined\n+---\n+\n+## Why This Error Occurred\n+\n+A Client Component is accessing the current time with `Date.now()`, `Date()`, or `new Date()`.\n+\n+Client Components primarily run in the browser however on an initial page visit, Next.js will serve an HTML page produced by simulating the client environment on the server. This process is called Server Side Rendering or SSR. Next.js will attempt to prerender this HTML ahead of time however if a Client Component accesses the current time during this prerender, it cannot include this component in the prerendered HTML, otherwise it might contain content based on a time very different from when the HTML is sent to a user. Next.js will use the nearest Suspense boundary around this component to prerender a fallback instead however in this instance there was no Suspense boundary.\n+\n+There are a number of ways you might fix this issue depending on the specifics of your use case.\n+\n+## Possible Ways to Fix It\n+\n+### Provide Fallback UI\n+\n+If you want the time value to be part of the server rendered HTML you can add a Suspense boundary around the component which allows Next.js to prerender a fallback UI ahead of a user's request and fill in the actual content when the user request occurs.\n+\n+Before:\n+\n+```jsx filename=\"app/article.js\"\n+'use client'\n+\n+export function RelativeTime({ timestamp }) {\n+  const now = Date.now()\n+  return (\n+    <span suppressHydrationWarning>{computeTimeAgo({ timestamp, now })}</span>\n+  )\n+}\n+\n+export default function Article({ articleData }) {\n+  return (\n+    <article>\n+      <h1>...</h1>\n+      <RelativeTime timestamp={articleData.publishedAt} />\n+    </article>\n+  )\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/article.js\"\n+'use client'\n+\n+import { Suspense } from 'react'\n+\n+export function RelativeTime({ timestamp }) {\n+  const now = Date.now()\n+  return <span>{computeTimeAgo({ timestamp, now })}</span>\n+}\n+\n+export default function Article({ articleData }) {\n+  return (\n+    <article>\n+      <h1>...</h1>\n+      <Suspense fallback={<span>...</span>}>\n+        <RelativeTime timestamp={articleData.publishedAt} />\n+      </Suspense>\n+    </article>\n+  )\n+}\n+```\n+\n+### Only access the time in the browser\n+\n+If you do not want to provide a fallback UI you may be able to move the time access into an effect. React does not run effects during server rendering so the time access will only occur in the browser.\n+\n+Before:\n+\n+```jsx filename=\"app/article.js\"\n+'use client'\n+\n+export function RelativeTime({ timestamp }) {\n+  const now = Date.now()\n+  return (\n+    <span suppressHydrationWarning>{computeTimeAgo({ timestamp, now })}</span>\n+  )\n+}\n+\n+export default function Article({ articleData }) {\n+  return (\n+    <article>\n+      <h1>...</h1>\n+      <RelativeTime timestamp={articleData.publishedAt} />\n+    </article>\n+  )\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/article.js\"\n+'use client'\n+\n+import { useState, useEffect } from 'react'\n+\n+export function RelativeTime({ timestamp }) {\n+  const [timeAgo, setTimeAgo] = useState('')\n+  useEffect(() => {\n+    // The effect won't run while rendering on the server\n+    const now = Date.now()\n+    setTimeAgo(computeTimeAgo({ timestamp, now }))\n+  }, [timestamp])\n+  return <span>{timeAgo}</span>\n+}\n+\n+export default function Article({ articleData }) {\n+  return (\n+    <article>\n+      <h1>...</h1>\n+      <RelativeTime timestamp={articleData.publishedAt} />\n+    </article>\n+  )\n+}\n+```\n+\n+### Cache the time in a Server Component\n+\n+While Next.js will treat reading the current time in a Server Component the same as in a Client Component, you have the additional option of caching the time read using `\"use cache\"`. With this approach the time value can be included in the prerendered HTML because you are explicitly indicating the value does not need to reflect the time of the user's request.\n+\n+Before:\n+\n+```jsx filename=\"app/home/layout.js\"\n+'use client'\n+\n+export default function Layout({ children }) {\n+  return (\n+    <>\n+      <main>{children}</main>\n+      <footer>\n+        <span>Copyright {new Date().getFullYear()}</span>\n+      </footer>\n+    </>\n+  )\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/home/layout.js\"\n+async function getCurrentYear() {\n+  'use cache'\n+  return new Date().getFullYear()\n+}\n+\n+export default async function Layout({ children }) {\n+  return (\n+    <>\n+      <main>{children}</main>\n+      <footer>\n+        <span>Copyright {await getCurrentYear()}</span>\n+      </footer>\n+    </>\n+  )\n+}\n+```\n+\n+### Performance use case\n+\n+If you are using the current time for performance tracking with elapsed time, use `performance.now()`.\n+\n+Before:\n+\n+```jsx filename=\"app/page.js\"\n+\"use client\"\n+\n+export default function Page() {\n+  const start = Date.now();\n+  const data = computeDataSlowly(...);\n+  const end = Date.now();\n+  console.log(`computeDataSlowly took ${end - start} milliseconds to complete`)\n+\n+  return ...\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/page.js\"\n+\"use client\"\n+\n+export default async function Page() {\n+  const start = performance.now();\n+  const data = computeDataSlowly(...);\n+  const end = performance.now();\n+  console.log(`computeDataSlowly took ${end - start} milliseconds to complete`)\n+  return ...\n+}\n+```\n+\n+> **Note**: If you need report an absolute time to an observability tool you can also use `performance.timeOrigin + performance.now()`.\n+\n+## Useful Links\n+\n+- [`Date.now` API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now)\n+- [`Date constructor` API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date)\n+- [`\"use cache\"`](/docs/app/api-reference/directives/use-cache)\n+- [`performance` Web API](https://developer.mozilla.org/en-US/docs/Web/API/Performance)\n+- [`Suspense` React API](https://react.dev/reference/react/Suspense)\n+- [`useEffect` React Hook](https://react.dev/reference/react/useEffect)"
        },
        {
            "sha": "23ab9314a9df3fb7c0c27e2612b1087d493dbb3a",
            "filename": "errors/next-prerender-current-time.mdx",
            "status": "modified",
            "additions": 48,
            "deletions": 26,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/035a12ea8e218a916aedc58f975384f7a6105861/errors%2Fnext-prerender-current-time.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/035a12ea8e218a916aedc58f975384f7a6105861/errors%2Fnext-prerender-current-time.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fnext-prerender-current-time.mdx?ref=035a12ea8e218a916aedc58f975384f7a6105861",
            "patch": "@@ -1,12 +1,12 @@\n ---\n-title: Cannot infer intended usage of current time with `Date.now()`, `Date()`, or `new Date()`\n+title: Cannot infer intended usage of current time with `Date.now()`, `Date()`, or `new Date()` in a Server Component\n ---\n \n ## Why This Error Occurred\n \n-Reading the current time can be ambiguous. Sometimes you intend to capture the time when something was cached, other times you intend to capture the time of a user Request. You might also be trying to measure runtime performance to track elapsed time.\n+Reading the current time in a Server Component can be ambiguous. Sometimes you intend to capture the time when something was cached, other times you intend to capture the time of a user Request. You might also be trying to measure runtime performance to track elapsed time.\n \n-In this instance Next.js cannot determine your intent from usage so it needs you to clarify your intent. The way you do that depends on your use case. See the possible solutions below for how to move forward.\n+Depending on your use case you might use alternative time APIs like `performance.now()`, you might cache the time read with `\"use cache\"`, or you might communicate that the time must be evaluated on each request by guarding it with `await connection()` or moving it into a Client Component.\n \n ## Possible Ways to Fix It\n \n@@ -94,64 +94,85 @@ export default async function Page() {\n }\n ```\n \n-### Reactive use case\n+### Request-time use case\n+\n+#### Moving time to the client\n \n-If you want the current time to change and be reactive, consider moving this usage to a Client Component. Note that Server Side Rendering timestamps in a Client Component is also considered ambiguous so to implement this properly Next.js needs you to only read the time in the browser, for instance by using `useLayoutEffect()` or `useEffect()`.\n+If the current time must be evaluated on each user Request consider moving the current time read into a Client Component. You might also find that this is more convenient when you want to do things like update the time independent of a page navigation. For instance imagine you have a relative time component. Instead of rendering the relative time in a Server Component on each Request you can render the relative time when the Client Component renders and then update it periodically.\n+\n+If you go with this approach you will need to ensure the Client Component which reads the time during render has a Suspense boundary above it. You may be able to improve the loading experience by adopting a more narrowly scoped Suspense boundary. Use your judgement about what kind of UI loading sequence you want your users to experience to guide your decision here.\n \n Before:\n \n ```jsx filename=\"app/page.js\"\n-function Timestamp() {\n-  return 'current time: ' + new Date().toString()\n+function RelativeTime({ when }) {\n+  return computeTimeAgo(new Date(), when)\n }\n \n export default async function Page() {\n+  const data = await ...\n   return (\n     <main>\n       ...\n-      <Timestamp />\n+      <Suspense>\n+        <RelativeTime when={data.createdAt} />\n+      </Suspense>\n     </main>\n   )\n }\n ```\n \n After:\n \n-```jsx filename=\"app/client-components.js\"\n+```jsx filename=\"app/relative-time.js\"\n 'use client'\n \n-import { useState, useLayoutEffect } from 'react'\n-\n-export function Timestamp() {\n-  const [time, setTime] = useState(null)\n-  useLayoutEffect(() => {\n-    // You can determine when and how often to update\n-    // the time here. In this example we update it only once\n-    setTime(new Date().toString())\n-  }, [])\n-  if (time) {\n-    return 'current time: ' + time\n-  }\n-  return null\n+import { useReducer } from 'react'\n+\n+export function RelativeTime({ when }) {\n+  const [_, update] = useReducer(() => ({}), {})\n+  const timeAgo = computeTimeAgo(new Date(), when)\n+\n+  // Whenever the timeAgo value changes a new timeout is\n+  // scheduled to update the component. Now the time can\n+  // rerender without having the Server Component render again.\n+  useEffect(() => {\n+    const updateAfter = computeTimeUntilNextUpdate(timeAgo)\n+    let timeout = setTimeout(() => {\n+      update()\n+    }, updateAfter)\n+    return () => {\n+      clearTimeout(timeout)\n+    }\n+  })\n+\n+  return timeAgo\n }\n ```\n \n ```jsx filename=\"app/page.js\"\n-import { Timestamp } from './client-components'\n+import { RelativeTime } from './relative-time'\n \n export default async function Page() {\n+  const data = await ...\n   return (\n     <main>\n       ...\n-      <Timestamp />\n+      <Suspense>\n+        <RelativeTime when={data.createdAt} />\n+      </Suspense>\n     </main>\n   )\n }\n ```\n \n-### Request-time use case\n+> **Note**: Accessing the current time in a Client Component will still cause it to be excluded from prerendered server HTML but Next.js allows this within Client Components because it can either compute the time dynamically when the user requests the HTML page or in the browser.\n+\n+#### Guarding the time with `await connection()`\n+\n+It may be that you want to make some rendering determination using the current time on the server and thus cannot move the time read into a Client Component. In this case you must instruct Next.js that the time read is meant to be evaluated at request time by preceding it with `await connection()`.\n \n-If you want the current time to represent the time of a user Request, add `await connection()` before you read the current time. This instructs Next.js that everything after the `await connection()` requires there to be a user Request before it can run. If you add `await connection()` you will also need to ensure there is a Suspense boundary somewhere above the waiting component that describes a fallback UI React can use. The Suspense can be anywhere in the parent component stack but it is shown here above the waiting component for demonstration purposes.\n+Next.js enforces that it can always produce at least a partially static initial HTML page so you will also need to ensure that there is a Suspense boundary somewhere above this component that informs Next.js about the intended fallback UI to use while prerendering this page.\n \n Before:\n \n@@ -169,6 +190,7 @@ export default async function Page() {\n After:\n \n ```jsx filename=\"app/page.js\"\n+import { Suspense } from 'react'\n import { connection } from 'next/server'\n \n async function BannerSkeleton() {"
        },
        {
            "sha": "5658c3f1c717b312fd6888a246a9cdb5263d3f99",
            "filename": "errors/next-prerender-random-client.mdx",
            "status": "added",
            "additions": 144,
            "deletions": 0,
            "changes": 144,
            "blob_url": "https://github.com/vercel/next.js/blob/035a12ea8e218a916aedc58f975384f7a6105861/errors%2Fnext-prerender-random-client.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/035a12ea8e218a916aedc58f975384f7a6105861/errors%2Fnext-prerender-random-client.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fnext-prerender-random-client.mdx?ref=035a12ea8e218a916aedc58f975384f7a6105861",
            "patch": "@@ -0,0 +1,144 @@\n+---\n+title: Cannot access `Math.random()` from a Client Component without a fallback UI defined\n+---\n+\n+## Why This Error Occurred\n+\n+A Client Component is calling `Math.random()`.\n+\n+Client Components primarily run in the browser however on an initial page visit, Next.js will serve an HTML page produced by simulating the client environment on the server. This process is called Server Side Rendering or SSR. Next.js will attempt to prerender this HTML ahead of time however if a Client Component accesses a random source during this prerender, it cannot include this component in the prerendered HTML, otherwise the value will be fixed on each user request and not random like expected. Next.js will use the nearest Suspense boundary around this component to prerender a fallback instead however in this instance there was no Suspense boundary.\n+\n+There are a number of ways you might fix this issue depending on the specifics of your use case.\n+\n+## Possible Ways to Fix It\n+\n+### Provide Fallback UI\n+\n+Typically it is not possible to use `Math.random()` in a Client Component that is Server Rendered without introducing a hydration error. However if you find yourself with a component that calls `Math.random()` during rendering, and you already handle the tricky case of hydrating this value consistently, then you can add a Suspense boundary around the component that calls `Math.random()` to allow Next.js to prerender a fallback UI and fill in an actual random value when the user requests the page.\n+\n+Before:\n+\n+```jsx filename=\"app/user-avatar.js\"\n+'use client'\n+\n+export function UserAvatar({ avatar }) {\n+  let backgroundColor = avatar.preferredBackground\n+  if (!backgroundColor) {\n+    const randomColor = `#${Math.random().toString(16).slice(2, 8)}`\n+    // imagine safelyGetRandomColor is a function that handles synchronizing\n+    // the random color chosen between SSR and hydration to avoid hydration errors\n+    backgroundColor = safelyGetRandomColor(randomColor)\n+  }\n+  return <Avatar background={backgroundColor} src={avatar.src} />\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/user-avatar.js\"\n+\"use client\"\n+\n+export function UserAvatar({ avatar }) {\n+  return (\n+    <Suspense fallback={<AvatarSkeleton />}>\n+      <DynamicUserAvatar avatar={avatar} />\n+    </Suspense>\n+  )\n+}\n+\n+function AvatarSkeleton() {\n+  ...\n+}\n+\n+function DynamicUserAvatar({ avatar }) {\n+  let backgroundColor = avatar.preferredBackground\n+  if (!backgroundColor) {\n+    const randomColor = `#${Math.random().toString(16).slice(2, 8)}`\n+    // imagine safelyGetRandomColor is a function that handles synchronizing\n+    // the random color chosen between SSR and hydration to avoid hydration errors\n+    backgroundColor = safelyGetRandomColor(randomColor)\n+  }\n+  return <Avatar background={backgroundColor} src={avatar.src} />\n+}\n+```\n+\n+### Only access `Math.random` in the browser\n+\n+If your random value is only intended for use in the browser you can move the call into an effect or event handler. React does not run effects during server rendering and there are no events during server rendering so neither option will require the prerender to exclude this component.\n+\n+Before:\n+\n+```jsx filename=\"app/workflow.js\"\n+'use client'\n+\n+export default function Workflow({ currentStep, onNext, onPrev }) {\n+  const [id] = useState(() => Math.random().toString(36).slice(2))\n+\n+  const next = onNext\n+    ? () => {\n+        trackEvent(id, 'forward')\n+        onNext()\n+      }\n+    : null\n+\n+  const previous = onPrev\n+    ? () => {\n+        trackEvent(id, 'previous')\n+        onPrev()\n+      }\n+    : null\n+\n+  return (\n+    <>\n+      {currentStep}\n+      {next ? <button onClick={next}>Next</button> : null}\n+      {previous ? <button onClick={previous}>Previous</button> : null}\n+    </>\n+  )\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/workflow.js\"\n+'use client'\n+\n+import { useRef } from 'react'\n+\n+function getOrCreateId(ref) {\n+  if (!ref.current) {\n+    ref.current = Math.random().toString(36).slice(2)\n+  }\n+  return ref.current\n+}\n+\n+export default function Workflow({ currentStep, onNext, onPrev }) {\n+  const idRef = useRef(null)\n+\n+  const next = onNext\n+    ? () => {\n+        trackEvent(getOrCreateId(idRef), 'forward')\n+        onNext()\n+      }\n+    : null\n+\n+  const previous = onPrev\n+    ? () => {\n+        trackEvent(getOrCreateId(idRef), 'previous')\n+        onPrev()\n+      }\n+    : null\n+\n+  return (\n+    <>\n+      {currentStep}\n+      {next ? <button onClick={next}>Next</button> : null}\n+      {previous ? <button onClick={previous}>Previous</button> : null}\n+    </>\n+  )\n+}\n+```\n+\n+## Useful Links\n+\n+- [`Suspense` React API](https://react.dev/reference/react/Suspense)"
        },
        {
            "sha": "bfdf5f23212a015eef99a709f754c23c6f64a6b6",
            "filename": "errors/next-prerender-random.mdx",
            "status": "modified",
            "additions": 40,
            "deletions": 7,
            "changes": 47,
            "blob_url": "https://github.com/vercel/next.js/blob/035a12ea8e218a916aedc58f975384f7a6105861/errors%2Fnext-prerender-random.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/035a12ea8e218a916aedc58f975384f7a6105861/errors%2Fnext-prerender-random.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fnext-prerender-random.mdx?ref=035a12ea8e218a916aedc58f975384f7a6105861",
            "patch": "@@ -1,14 +1,45 @@\n ---\n-title: Cannot access `Math.random()` while prerendering\n+title: Cannot infer intended usage of `Math.random()` in a Server Component\n ---\n \n ## Why This Error Occurred\n \n-A function is calling `Math.random()`. Random values are not prerenderable and must be excluded. The correct solution depends on your use case. You can find more information below about possible ways to resolves this issue.\n+A Server Component is calling `Math.random()` without specifying whether it should be cached or whether it should be evaluated on each user Request. If you want this random value to be included in the prerendered HTML for this page you must cache it using `\"use cache\"`. If you want this random value to be unique per Request you must precede it with `await connection()` so Next.js knows to exclude it from the prerendered HTML.\n \n ## Possible Ways to Fix It\n \n-If your random value is intended to be unique per Request add `await connection()` before you call `Math.random()` and ensure there is a Suspense boundary somewhere above this component. This will inform Next.js that this component should be excluded from prerendering and communicate the necessary fallback UI that should be rendered while the component renders on each Request.\n+### Cache the random value\n+\n+If your random value is cacheable, move the `Math.random()` call to a `\"use cache\"` function. For instance, imagine you have a product page and you want to randomize the product order periodically but you are fine with the random order being re-used for different users.\n+\n+Before:\n+\n+```jsx filename=\"app/page.js\"\n+export default async function Page() {\n+  const products = await getCachedProducts()\n+  const randomSeed = Math.random()\n+  const randomizedProducts = randomize(products, randomSeed)\n+  return <ProductsView products={randomizedProducts} />\n+}\n+```\n+\n+After:\n+\n+```jsx filename=\"app/page.js\"\n+export default async function Page() {\n+  'use cache'\n+  const products = await getCachedProducts()\n+  const randomSeed = Math.random()\n+  const randomizedProducts = randomize(products, randomSeed)\n+  return <ProductsView products={randomizedProducts} />\n+}\n+```\n+\n+> **Note**: `\"use cache\"` is a powerful API with some nuances. If your cache lifetime is too short Next.js may still exclude it from prerendering. Check out the docs for `\"use cache\"` to learn more.\n+\n+### Indicate the random value is unique per Request\n+\n+If you want the random value to be evaluated on each Request precede it with `await connection()`. Next.js will exclude this Server Component from the prerendered HTML and include the fallback UI from the nearest Suspense boundary wrapping this component instead. When a user makes a Request for this page the Server Component will be rendered and the updated UI will stream in dynamically.\n \n Before:\n \n@@ -32,12 +63,14 @@ async function ProductsSkeleton() {\n \n export default async function Page() {\n   const products = await getCachedProducts();\n-  return <Suspense fallback={<ProductsSkeleton />}>\n-    <DynamicProductsView products={products} />\n-  </Suspense>\n+  return (\n+    <Suspense fallback={<ProductsSkeleton />}>\n+      <DynamicProductsView products={products} />\n+    </Suspense>\n+  )\n }\n \n-async function DynamicProductsView() {\n+async function DynamicProductsView({ products }) {\n   await connection();\n   const randomSeed = Math.random()\n   const randomizedProducts = randomize(products, randomSeed)"
        },
        {
            "sha": "fd0782af1797ea2fc802dac6e99e37b1b6ebebfd",
            "filename": "packages/next/src/server/node-environment-extensions/utils.tsx",
            "status": "modified",
            "additions": 11,
            "deletions": 4,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/035a12ea8e218a916aedc58f975384f7a6105861/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/035a12ea8e218a916aedc58f975384f7a6105861/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Futils.tsx?ref=035a12ea8e218a916aedc58f975384f7a6105861",
            "patch": "@@ -11,9 +11,10 @@ type ApiType = 'time' | 'random' | 'crypto'\n export function io(expression: string, type: ApiType) {\n   const workUnitStore = workUnitAsyncStorage.getStore()\n   if (workUnitStore) {\n+    let isClient = false\n     if (\n       workUnitStore.type === 'prerender' ||\n-      workUnitStore.type === 'prerender-client'\n+      (isClient = workUnitStore.type === 'prerender-client')\n     ) {\n       const prerenderSignal = workUnitStore.controller.signal\n       if (prerenderSignal.aborted === false) {\n@@ -24,13 +25,19 @@ export function io(expression: string, type: ApiType) {\n           let message: string\n           switch (type) {\n             case 'time':\n-              message = `Route \"${workStore.route}\" used ${expression} instead of using \\`performance\\` or without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time`\n+              message = isClient\n+                ? `Route \"${workStore.route}\" used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time-client`\n+                : `Route \"${workStore.route}\" used ${expression} instead of using \\`performance\\` or without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time`\n               break\n             case 'random':\n-              message = `Route \"${workStore.route}\" used ${expression} outside of \\`\"use cache\"\\` and without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-random`\n+              message = isClient\n+                ? `Route \"${workStore.route}\" used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-random-client`\n+                : `Route \"${workStore.route}\" used ${expression} outside of \\`\"use cache\"\\` and without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-random`\n               break\n             case 'crypto':\n-              message = `Route \"${workStore.route}\" used ${expression} outside of \\`\"use cache\"\\` and without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto`\n+              message = isClient\n+                ? `Route \"${workStore.route}\" used ${expression} inside a Client Component without a Suspense boundary above it. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto-client`\n+                : `Route \"${workStore.route}\" used ${expression} outside of \\`\"use cache\"\\` and without explicitly calling \\`await connection()\\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto`\n               break\n             default:\n               throw new InvariantError("
        },
        {
            "sha": "d2f3b86dc90a4f288819d07fe9aea978e2a1404c",
            "filename": "test/e2e/app-dir/dynamic-io-errors/dynamic-io-errors.sync-attribution.test.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/035a12ea8e218a916aedc58f975384f7a6105861/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Fdynamic-io-errors.sync-attribution.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/035a12ea8e218a916aedc58f975384f7a6105861/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Fdynamic-io-errors.sync-attribution.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Fdynamic-io-errors.sync-attribution.test.ts?ref=035a12ea8e218a916aedc58f975384f7a6105861",
            "patch": "@@ -81,7 +81,7 @@ function runTests(options: { withMinification: boolean }) {\n         const expectError = createExpectError(next.cliOutput)\n \n         expectError(\n-          'Error: Route \"/\" used `new Date()` instead of using `performance` or without explicitly calling `await connection()` beforehand.'\n+          'Error: Route \"/\" used `new Date()` inside a Client Component without a Suspense boundary above it.'\n         )\n         expectError('Error occurred prerendering page \"/\"')\n       })\n@@ -167,7 +167,7 @@ function runTests(options: { withMinification: boolean }) {\n         const expectError = createExpectError(next.cliOutput)\n \n         expectError(\n-          'Error: Route \"/\" used `new Date()` instead of using `performance` or without explicitly calling `await connection()` beforehand.'\n+          'Error: Route \"/\" used `new Date()` inside a Client Component without a Suspense boundary above it.'\n         )\n         expectError('Error occurred prerendering page \"/\"')\n       })"
        }
    ],
    "stats": {
        "total": 646,
        "additions": 601,
        "deletions": 45
    }
}