{
    "author": "devjiwonchoi",
    "message": "[ts-next-plugin] fix: warn only if no type for separate export (#78629)\n\n### Why?\n\nThe \"separate export\" was not warning correctly. It is because the\n`symbol.declaration` is a declaration from the export clause. Needed to\nget from `originalSymbol.declaration`.\n\n| Before | After |\n|--------|--------|\n| ![CleanShot 2025-04-28 at 22 55\n48@2x](https://github.com/user-attachments/assets/696cfb07-e44c-4541-9486-cf62053f5acc)\n| ![CleanShot 2025-04-28 at 23 04\n31@2x](https://github.com/user-attachments/assets/817d99cb-0dd3-4fb8-84ce-5f298b32185c)\n|",
    "sha": "ab1597ab32851ac6fcd2e2a584c4074b92c11113",
    "files": [
        {
            "sha": "9aa64d30ae2e55ad1c60788fc7aea13d4ad16f37",
            "filename": "packages/next/src/server/typescript/rules/metadata.ts",
            "status": "modified",
            "additions": 60,
            "deletions": 62,
            "changes": 122,
            "blob_url": "https://github.com/vercel/next.js/blob/ab1597ab32851ac6fcd2e2a584c4074b92c11113/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Frules%2Fmetadata.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ab1597ab32851ac6fcd2e2a584c4074b92c11113/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Frules%2Fmetadata.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Ftypescript%2Frules%2Fmetadata.ts?ref=ab1597ab32851ac6fcd2e2a584c4074b92c11113",
            "patch": "@@ -166,95 +166,93 @@ const metadata = {\n             continue\n           }\n           const exportName = e.name.getText()\n-          if (exportName !== 'generateMetadata' && exportName !== 'metadata') {\n+          if (exportName !== 'metadata' && exportName !== 'generateMetadata') {\n             continue\n           }\n \n-          // Get the symbol and type for the export\n           const symbol = typeChecker.getSymbolAtLocation(e.name)\n-          if (!symbol) continue\n+          if (!symbol) {\n+            continue\n+          }\n+\n+          const originalSymbol = typeChecker.getAliasedSymbol(symbol)\n+          const declarations = originalSymbol.getDeclarations()\n+          if (!declarations) {\n+            continue\n+          }\n \n-          const type = typeChecker.getTypeOfSymbolAtLocation(symbol, e.name)\n-          if (!type) continue\n+          const declaration = declarations[0]\n+          if (hasType(declaration)) {\n+            continue\n+          }\n \n           if (exportName === 'generateMetadata') {\n             let isAsync = false\n \n-            // For export declarations, we need to get the actual declaration through the type checker\n-            const originalSymbol = typeChecker.getAliasedSymbol(symbol)\n-            const declaration = originalSymbol?.declarations?.[0]\n+            // async function() {}\n+            if (ts.isFunctionDeclaration(declaration)) {\n+              isAsync =\n+                declaration.modifiers?.some(\n+                  (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n+                ) ?? false\n+            }\n \n-            if (declaration) {\n-              if (ts.isFunctionDeclaration(declaration)) {\n+            // foo = async function() {}\n+            // foo = async () => {}\n+            if (\n+              ts.isVariableDeclaration(declaration) &&\n+              declaration.initializer\n+            ) {\n+              const initializer = declaration.initializer\n+              const isFunction =\n+                ts.isArrowFunction(initializer) ||\n+                ts.isFunctionExpression(initializer)\n+\n+              if (isFunction) {\n                 isAsync =\n-                  declaration.modifiers?.some(\n+                  initializer.modifiers?.some(\n                     (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n                   ) ?? false\n-              } else if (\n-                ts.isVariableDeclaration(declaration) &&\n-                declaration.initializer\n-              ) {\n-                if (\n-                  ts.isArrowFunction(declaration.initializer) ||\n-                  ts.isFunctionExpression(declaration.initializer)\n-                ) {\n-                  isAsync =\n-                    declaration.initializer.modifiers?.some(\n-                      (m) => m.kind === ts.SyntaxKind.AsyncKeyword\n-                    ) ?? false\n-                }\n               }\n             }\n \n-            if (\n-              declaration &&\n-              ts.isFunctionDeclaration(declaration) &&\n-              !hasType(declaration)\n-            ) {\n-              diagnostics.push({\n-                file: source,\n-                category: ts.DiagnosticCategory.Warning,\n-                code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n-                messageText: `The \"generateMetadata\" export should have a return type of ${isAsync ? '\"Promise<Metadata>\"' : '\"Metadata\"'} from \"next\".`,\n-                start: e.name.getStart(),\n-                length: e.name.getWidth(),\n-              })\n-            }\n+            diagnostics.push({\n+              file: source,\n+              category: ts.DiagnosticCategory.Warning,\n+              code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n+              messageText: `The Next.js \"generateMetadata\" export should have a return type of ${isAsync ? '\"Promise<Metadata>\"' : '\"Metadata\"'} from \"next\".`,\n+              start: e.name.getStart(),\n+              length: e.name.getWidth(),\n+            })\n           } else {\n-            // must be 'metadata' at this point\n-            const declaration = symbol.declarations?.[0]\n-            if (\n-              declaration &&\n-              ts.isVariableDeclaration(declaration) &&\n-              !hasType(declaration)\n-            ) {\n-              diagnostics.push({\n-                file: source,\n-                category: ts.DiagnosticCategory.Warning,\n-                code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n-                messageText: `The Next.js \"metadata\" export should be type of \"Metadata\" from \"next\".`,\n-                start: e.name.getStart(),\n-                length: e.name.getWidth(),\n-              })\n-            }\n+            diagnostics.push({\n+              file: source,\n+              category: ts.DiagnosticCategory.Warning,\n+              code: NEXT_TS_ERRORS.INVALID_METADATA_EXPORT,\n+              messageText: `The Next.js \"metadata\" export should be type of \"Metadata\" from \"next\".`,\n+              start: e.name.getStart(),\n+              length: e.name.getWidth(),\n+            })\n           }\n         }\n       }\n-\n       return diagnostics\n     },\n   },\n }\n \n-function hasType(\n-  node:\n-    | tsModule.FunctionDeclaration\n-    | tsModule.VariableDeclaration\n-    | tsModule.FunctionExpression\n-    | tsModule.ArrowFunction\n-): boolean {\n+function hasType(node: tsModule.Declaration): boolean {\n   const ts = getTs()\n \n+  if (\n+    !ts.isVariableDeclaration(node) &&\n+    !ts.isFunctionDeclaration(node) &&\n+    !ts.isArrowFunction(node) &&\n+    !ts.isFunctionExpression(node)\n+  ) {\n+    return false\n+  }\n+\n   // For function declarations, expressions, and arrow functions, check if they have return type\n   if (\n     ts.isFunctionDeclaration(node) ||"
        }
    ],
    "stats": {
        "total": 122,
        "additions": 60,
        "deletions": 62
    }
}