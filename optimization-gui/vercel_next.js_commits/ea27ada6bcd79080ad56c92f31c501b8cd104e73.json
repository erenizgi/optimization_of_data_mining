{
    "author": "bgw",
    "message": "fix(turbo-tasks): Add a few more transient-from-persistent task assertions (#78301)\n\nTransient tasks are tasks that depend on a value that cannot be serialized. Transient tasks and anything that depend on them therefore cannot be serialized. Because of this, it's not valid for persistent (serialized) tasks to depend on transient tasks.\n\nWe're seeing issues from transient collectibles being read from persistent tasks.\n\nThis should only be possible if a persistent task emits a transient collectible. That shouldn't be possible either (where would it get the transient collectible from?), but asserting doesn't seem like a bad idea, and might get us a stack trace closer to the root-cause.",
    "sha": "ea27ada6bcd79080ad56c92f31c501b8cd104e73",
    "files": [
        {
            "sha": "5292de1dc0c21b674f7a55eef79fda399f298844",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 37,
            "deletions": 4,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/ea27ada6bcd79080ad56c92f31c501b8cd104e73/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ea27ada6bcd79080ad56c92f31c501b8cd104e73/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=ea27ada6bcd79080ad56c92f31c501b8cd104e73",
            "patch": "@@ -1947,6 +1947,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         task_id: TaskId,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n+        self.assert_valid_collectible(task_id, collectible);\n         if !self.should_track_children() {\n             return;\n         }\n@@ -1977,6 +1978,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         task_id: TaskId,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n+        self.assert_valid_collectible(task_id, collectible);\n         if !self.should_track_children() {\n             return;\n         }\n@@ -2077,6 +2079,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         parent_task: TaskId,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n+        self.assert_not_persistent_calling_transient(parent_task, task, None);\n         ConnectChildOperation::run(parent_task, task, self.execute_context(turbo_tasks));\n     }\n \n@@ -2162,20 +2165,50 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         cell_id: Option<CellId>,\n     ) {\n         let transient_reason = if let Some(child) = child {\n-            format!(\n+            Cow::Owned(format!(\n                 \" The callee is transient because it depends on:\\n{}\",\n                 self.debug_trace_transient_task(child, cell_id),\n-            )\n+            ))\n         } else {\n-            String::new()\n+            Cow::Borrowed(\"\")\n         };\n         panic!(\n-            \"Persistent task {} is not allowed to call or read transient tasks {}.{}\",\n+            \"Persistent task {} is not allowed to call, read, or connect to transient tasks {}.{}\",\n             parent.map_or(\"unknown\", |t| t.get_name()),\n             child.map_or(\"unknown\", |t| t.get_name()),\n             transient_reason,\n         );\n     }\n+\n+    fn assert_valid_collectible(&self, task_id: TaskId, collectible: RawVc) {\n+        // these checks occur in a potentially hot codepath, but they're cheap\n+        let RawVc::TaskCell(col_task_id, col_cell_id) = collectible else {\n+            // This should never happen: The collectible APIs use ResolvedVc\n+            let task_info =\n+                if let Some(col_task_ty) = self.lookup_task_type(collectible.get_task_id()) {\n+                    Cow::Owned(format!(\" (return type of {})\", col_task_ty))\n+                } else {\n+                    Cow::Borrowed(\"\")\n+                };\n+            panic!(\"Collectible{task_info} must be a ResolvedVc\")\n+        };\n+        if col_task_id.is_transient() && !task_id.is_transient() {\n+            let transient_reason =\n+                if let Some(col_task_ty) = self.lookup_task_type(collectible.get_task_id()) {\n+                    Cow::Owned(format!(\n+                        \". The collectible is transient because it depends on:\\n{}\",\n+                        self.debug_trace_transient_task(&col_task_ty, Some(col_cell_id)),\n+                    ))\n+                } else {\n+                    Cow::Borrowed(\"\")\n+                };\n+            // this should never happen: How would a persistent function get a transient Vc?\n+            panic!(\n+                \"Collectible is transient, transient collectibles cannot be emitted from \\\n+                 persistent tasks{transient_reason}\",\n+            )\n+        }\n+    }\n }\n \n impl<B: BackingStorage> Backend for TurboTasksBackend<B> {"
        },
        {
            "sha": "e0b61f6e13b97548b14a10e922f3143c9a3ed6b3",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/transient_collectible.rs",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/vercel/next.js/blob/ea27ada6bcd79080ad56c92f31c501b8cd104e73/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftransient_collectible.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ea27ada6bcd79080ad56c92f31c501b8cd104e73/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftransient_collectible.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftransient_collectible.rs?ref=ea27ada6bcd79080ad56c92f31c501b8cd104e73",
            "patch": "@@ -0,0 +1,52 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+\n+use serde::{Deserialize, Serialize};\n+use turbo_tasks::{trace::TraceRawVcs, NonLocalValue, ResolvedVc, TaskInput};\n+use turbo_tasks_testing::{register, run_without_cache_check, Registration};\n+\n+static REGISTRATION: Registration = register!();\n+\n+const EXPECTED_MSG: &str =\n+    \"Collectible is transient, transient collectibles cannot be emitted from persistent tasks\";\n+\n+#[tokio::test]\n+async fn test_transient_emit_from_persistent() {\n+    let result = run_without_cache_check(&REGISTRATION, async {\n+        emit_incorrect_task_input_operation(IncorrectTaskInput(U32Wrapper(123).resolved_cell()))\n+            .read_strongly_consistent()\n+            .await?;\n+        anyhow::Ok(())\n+    })\n+    .await;\n+    assert!(result\n+        .unwrap_err()\n+        .to_string()\n+        .contains(&EXPECTED_MSG.escape_debug().to_string()));\n+}\n+\n+#[turbo_tasks::function(operation)]\n+async fn emit_incorrect_task_input_operation(value: IncorrectTaskInput) {\n+    turbo_tasks::emit(ResolvedVc::upcast::<Box<dyn Number>>(value.0));\n+}\n+\n+/// Has an intentionally incorrect `TaskInput` implementation\n+#[derive(\n+    Copy, Clone, Debug, PartialEq, Eq, Hash, TraceRawVcs, Serialize, Deserialize, NonLocalValue,\n+)]\n+struct IncorrectTaskInput(ResolvedVc<U32Wrapper>);\n+\n+impl TaskInput for IncorrectTaskInput {\n+    fn is_transient(&self) -> bool {\n+        false\n+    }\n+}\n+\n+#[turbo_tasks::value_trait]\n+trait Number {}\n+\n+#[turbo_tasks::value]\n+struct U32Wrapper(u32);\n+\n+#[turbo_tasks::value_impl]\n+impl Number for U32Wrapper {}"
        }
    ],
    "stats": {
        "total": 93,
        "additions": 89,
        "deletions": 4
    }
}