{
    "author": "bgw",
    "message": "refactor(turbo-tasks): Remove task id from RawVc::LocalOutput (#78561)\n\nAfter https://github.com/vercel/next.js/pull/78488 and https://github.com/vercel/next.js/pull/78487, the task id isn't really needed anymore, so this removes it!\n\nThere's no expected change in memory consumption: `RawVc` is still 128 bits because `RawVc::TaskCell` is 96 bits, and the type is aligned to the nearest 64 bit machine word.",
    "sha": "5ad81e553b7c461fa0dd3ceb483b9b4fa8cbb106",
    "files": [
        {
            "sha": "540b2afa0c01b2ee01214ecee529002ded792bc3",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 19,
            "changes": 52,
            "blob_url": "https://github.com/vercel/next.js/blob/5ad81e553b7c461fa0dd3ceb483b9b4fa8cbb106/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5ad81e553b7c461fa0dd3ceb483b9b4fa8cbb106/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=5ad81e553b7c461fa0dd3ceb483b9b4fa8cbb106",
            "patch": "@@ -1124,11 +1124,16 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             let task_name = task_type.get_name();\n \n             let cause_self = task_type.this.and_then(|cause_self_raw_vc| {\n-                let task_id = cause_self_raw_vc.get_task_id();\n+                let Some(task_id) = cause_self_raw_vc.try_get_task_id() else {\n+                    // `task_id` should never be `None` at this point, as that would imply a\n+                    // non-local task is returning a local `Vc`...\n+                    // Just ignore if it happens, as we're likely already panicking.\n+                    return None;\n+                };\n                 if task_id.is_transient() {\n                     Some(Box::new(inner_id(\n                         backend,\n-                        cause_self_raw_vc.get_task_id(),\n+                        task_id,\n                         cause_self_raw_vc.try_get_type_id(),\n                         visited_set,\n                     )))\n@@ -1140,8 +1145,16 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 .arg\n                 .get_raw_vcs()\n                 .into_iter()\n-                .map(|raw_vc| (raw_vc.get_task_id(), raw_vc.try_get_type_id()))\n-                .filter(|(task_id, _)| task_id.is_transient())\n+                .filter_map(|raw_vc| {\n+                    let Some(task_id) = raw_vc.try_get_task_id() else {\n+                        // `task_id` should never be `None` (see comment above)\n+                        return None;\n+                    };\n+                    if !task_id.is_transient() {\n+                        return None;\n+                    }\n+                    Some((task_id, raw_vc.try_get_type_id()))\n+                })\n                 .collect::<IndexSet<_>>() // dedupe\n                 .into_iter()\n                 .map(|(task_id, cell_type_id)| {\n@@ -2184,24 +2197,25 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         // these checks occur in a potentially hot codepath, but they're cheap\n         let RawVc::TaskCell(col_task_id, col_cell_id) = collectible else {\n             // This should never happen: The collectible APIs use ResolvedVc\n-            let task_info =\n-                if let Some(col_task_ty) = self.lookup_task_type(collectible.get_task_id()) {\n-                    Cow::Owned(format!(\" (return type of {})\", col_task_ty))\n-                } else {\n-                    Cow::Borrowed(\"\")\n-                };\n+            let task_info = if let Some(col_task_ty) = collectible\n+                .try_get_task_id()\n+                .and_then(|t| self.lookup_task_type(t))\n+            {\n+                Cow::Owned(format!(\" (return type of {col_task_ty})\"))\n+            } else {\n+                Cow::Borrowed(\"\")\n+            };\n             panic!(\"Collectible{task_info} must be a ResolvedVc\")\n         };\n         if col_task_id.is_transient() && !task_id.is_transient() {\n-            let transient_reason =\n-                if let Some(col_task_ty) = self.lookup_task_type(collectible.get_task_id()) {\n-                    Cow::Owned(format!(\n-                        \". The collectible is transient because it depends on:\\n{}\",\n-                        self.debug_trace_transient_task(&col_task_ty, Some(col_cell_id)),\n-                    ))\n-                } else {\n-                    Cow::Borrowed(\"\")\n-                };\n+            let transient_reason = if let Some(col_task_ty) = self.lookup_task_type(col_task_id) {\n+                Cow::Owned(format!(\n+                    \". The collectible is transient because it depends on:\\n{}\",\n+                    self.debug_trace_transient_task(&col_task_ty, Some(col_cell_id)),\n+                ))\n+            } else {\n+                Cow::Borrowed(\"\")\n+            };\n             // this should never happen: How would a persistent function get a transient Vc?\n             panic!(\n                 \"Collectible is transient, transient collectibles cannot be emitted from \\"
        },
        {
            "sha": "444281f37251b21c3819c50fe7dc91b7f9173364",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 4,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/5ad81e553b7c461fa0dd3ceb483b9b4fa8cbb106/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5ad81e553b7c461fa0dd3ceb483b9b4fa8cbb106/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=5ad81e553b7c461fa0dd3ceb483b9b4fa8cbb106",
            "patch": "@@ -48,6 +48,8 @@ use crate::{\n     VcValueType,\n };\n \n+/// Common base trait for [`TurboTasksApi`] and [`TurboTasksBackendApi`]. Provides APIs for creating\n+/// tasks from function calls.\n pub trait TurboTasksCallApi: Sync + Send {\n     /// Calls a native function with arguments. Resolves arguments when needed\n     /// with a wrapper task.\n@@ -93,6 +95,11 @@ pub trait TurboTasksCallApi: Sync + Send {\n     ) -> TaskId;\n }\n \n+/// A type-erased subset of [`TurboTasks`] stored inside a thread local when we're in a turbo task\n+/// context. Returned by the [`turbo_tasks`] helper function.\n+///\n+/// This trait is needed because thread locals cannot contain an unresolved [`Backend`] type\n+/// parameter.\n pub trait TurboTasksApi: TurboTasksCallApi + Sync + Send {\n     fn pin(&self) -> Arc<dyn TurboTasksApi>;\n \n@@ -135,9 +142,20 @@ pub trait TurboTasksApi: TurboTasksCallApi + Sync + Send {\n         options: ReadCellOptions,\n     ) -> Result<Result<TypedCellContent, EventListener>>;\n \n+    /// Reads a [`RawVc::LocalOutput`]. If the task has completed, returns the [`RawVc`] the local\n+    /// task points to.\n+    ///\n+    /// The returned [`RawVc`] may also be a [`RawVc::LocalOutput`], so this may need to be called\n+    /// recursively or in a loop.\n+    ///\n     /// This does not accept a consistency argument, as you cannot control consistency of a read of\n     /// an operation owned by your own task. Strongly consistent reads are only allowed on\n-    /// `OperationVc`s, which should never be local tasks.\n+    /// [`OperationVc`]s, which should never be local tasks.\n+    ///\n+    /// No dependency tracking will happen as a result of this function call, as it's a no-op for a\n+    /// task to depend on itself.\n+    ///\n+    /// [`OperationVc`]: crate::OperationVc\n     fn try_read_local_output(\n         &self,\n         execution_id: ExecutionId,\n@@ -216,6 +234,7 @@ impl<T> Unused<T> {\n     }\n }\n \n+/// A subset of the [`TurboTasks`] API that's exposed to [`Backend`] implementations.\n pub trait TurboTasksBackendApi<B: Backend + 'static>: TurboTasksCallApi + Sync + Send {\n     fn pin(&self) -> Arc<dyn TurboTasksBackendApi<B>>;\n \n@@ -265,8 +284,8 @@ pub trait TurboTasksBackendApi<B: Backend + 'static>: TurboTasksCallApi + Sync +\n     fn backend(&self) -> &B;\n }\n \n-/// An extension trait for methods of `TurboTasksBackendApi` that are not object-safe. This is\n-/// automatically implemented for all `TurboTasksBackendApi`s using a blanket impl.\n+/// An extension trait for methods of [`TurboTasksBackendApi`] that are not object-safe. This is\n+/// automatically implemented for all [`TurboTasksBackendApi`]s using a blanket impl.\n pub trait TurboTasksBackendApiExt<B: Backend + 'static>: TurboTasksBackendApi<B> {\n     /// Allows modification of the [`Backend::TaskState`].\n     ///\n@@ -768,6 +787,8 @@ impl<B: Backend + 'static> TurboTasks<B> {\n             self.backend.get_task_description(parent_task_id),\n             ty,\n         );\n+        #[cfg(not(feature = \"tokio_tracing\"))]\n+        let _ = parent_task_id; // suppress unused variable warning\n \n         let this = self.pin();\n         let future = async move {\n@@ -822,7 +843,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         #[cfg(not(feature = \"tokio_tracing\"))]\n         tokio::task::spawn(future);\n \n-        RawVc::LocalOutput(parent_task_id, persistence, execution_id, local_task_id)\n+        RawVc::LocalOutput(persistence, execution_id, local_task_id)\n     }\n \n     fn begin_primary_job(&self) {"
        },
        {
            "sha": "3733d19c0f40920c5828b42c40963bdfb1467b34",
            "filename": "turbopack/crates/turbo-tasks/src/raw_vc.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 13,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/5ad81e553b7c461fa0dd3ceb483b9b4fa8cbb106/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5ad81e553b7c461fa0dd3ceb483b9b4fa8cbb106/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs?ref=5ad81e553b7c461fa0dd3ceb483b9b4fa8cbb106",
            "patch": "@@ -57,7 +57,7 @@ impl Display for CellId {\n pub enum RawVc {\n     TaskOutput(TaskId),\n     TaskCell(TaskId, CellId),\n-    LocalOutput(TaskId, TaskPersistence, ExecutionId, LocalTaskId),\n+    LocalOutput(TaskPersistence, ExecutionId, LocalTaskId),\n }\n \n impl RawVc {\n@@ -84,7 +84,7 @@ impl RawVc {\n     pub fn is_transient(&self) -> bool {\n         match self {\n             RawVc::TaskOutput(task) | RawVc::TaskCell(task, ..) => task.is_transient(),\n-            RawVc::LocalOutput(_, persistence, ..) => *persistence == TaskPersistence::Transient,\n+            RawVc::LocalOutput(persistence, ..) => *persistence == TaskPersistence::Transient,\n         }\n     }\n \n@@ -148,7 +148,7 @@ impl RawVc {\n                         return Err(ResolveTypeError::NoContent);\n                     }\n                 }\n-                RawVc::LocalOutput(_task_id, _persistence, execution_id, local_task_id) => {\n+                RawVc::LocalOutput(_persistence, execution_id, local_task_id) => {\n                     current = read_local_output(&*tt, execution_id, local_task_id)\n                         .await\n                         .map_err(|source| ResolveTypeError::TaskError { source })?;\n@@ -185,7 +185,7 @@ impl RawVc {\n                     consistency = ReadConsistency::Eventual;\n                 }\n                 RawVc::TaskCell(_, _) => return Ok(current),\n-                RawVc::LocalOutput(_task_id, _persistence, execution_id, local_task_id) => {\n+                RawVc::LocalOutput(_persistence, execution_id, local_task_id) => {\n                     debug_assert_eq!(consistency, ReadConsistency::Eventual);\n                     current = read_local_output(&*tt, execution_id, local_task_id).await?;\n                 }\n@@ -200,7 +200,7 @@ impl RawVc {\n         let mut current = self;\n         loop {\n             match current {\n-                RawVc::LocalOutput(_task_id, _persistence, execution_id, local_task_id) => {\n+                RawVc::LocalOutput(_persistence, execution_id, local_task_id) => {\n                     current = read_local_output(&*tt, execution_id, local_task_id).await?;\n                 }\n                 non_local => return Ok(non_local),\n@@ -209,13 +209,17 @@ impl RawVc {\n     }\n \n     pub(crate) fn connect(&self) {\n+        let RawVc::TaskOutput(task_id) = self else {\n+            panic!(\"RawVc::connect() must only be called on a RawVc::TaskOutput\");\n+        };\n         let tt = turbo_tasks();\n-        tt.connect_task(self.get_task_id());\n+        tt.connect_task(*task_id);\n     }\n \n-    pub fn get_task_id(&self) -> TaskId {\n+    pub fn try_get_task_id(&self) -> Option<TaskId> {\n         match self {\n-            RawVc::TaskOutput(t) | RawVc::TaskCell(t, ..) | RawVc::LocalOutput(t, ..) => *t,\n+            RawVc::TaskOutput(t) | RawVc::TaskCell(t, ..) => Some(*t),\n+            RawVc::LocalOutput(..) => None,\n         }\n     }\n \n@@ -250,20 +254,30 @@ impl RawVc {\n /// This implementation of `CollectiblesSource` assumes that `self` is a `RawVc::TaskOutput`.\n impl CollectiblesSource for RawVc {\n     fn peek_collectibles<T: VcValueTrait + ?Sized>(self) -> AutoSet<ResolvedVc<T>> {\n-        debug_assert!(matches!(self, RawVc::TaskOutput(..)));\n+        let RawVc::TaskOutput(task_id) = self else {\n+            panic!(\n+                \"<RawVc as CollectiblesSource>::peek_collectibles() must only be called on a \\\n+                 RawVc::TaskOutput\"\n+            );\n+        };\n         let tt = turbo_tasks();\n         tt.notify_scheduled_tasks();\n-        let map = tt.read_task_collectibles(self.get_task_id(), T::get_trait_type_id());\n+        let map = tt.read_task_collectibles(task_id, T::get_trait_type_id());\n         map.into_iter()\n             .filter_map(|(raw, count)| (count > 0).then_some(raw.try_into().unwrap()))\n             .collect()\n     }\n \n     fn take_collectibles<T: VcValueTrait + ?Sized>(self) -> AutoSet<ResolvedVc<T>> {\n-        debug_assert!(matches!(self, RawVc::TaskOutput(..)));\n+        let RawVc::TaskOutput(task_id) = self else {\n+            panic!(\n+                \"<RawVc as CollectiblesSource>::take_collectibles() must only be called on a \\\n+                 RawVc::TaskOutput\"\n+            );\n+        };\n         let tt = turbo_tasks();\n         tt.notify_scheduled_tasks();\n-        let map = tt.read_task_collectibles(self.get_task_id(), T::get_trait_type_id());\n+        let map = tt.read_task_collectibles(task_id, T::get_trait_type_id());\n         tt.unemit_collectibles(T::get_trait_type_id(), &map);\n         map.into_iter()\n             .filter_map(|(raw, count)| (count > 0).then_some(raw.try_into().unwrap()))\n@@ -360,7 +374,7 @@ impl Future for ReadRawVcFuture {\n                             Err(err) => return Poll::Ready(Err(err)),\n                         }\n                     }\n-                    RawVc::LocalOutput(_task_id, _persistence, execution_id, local_output_id) => {\n+                    RawVc::LocalOutput(_persistence, execution_id, local_output_id) => {\n                         debug_assert_eq!(this.consistency, ReadConsistency::Eventual);\n                         let read_result = tt.try_read_local_output(execution_id, local_output_id);\n                         match read_result {"
        }
    ],
    "stats": {
        "total": 121,
        "additions": 85,
        "deletions": 36
    }
}