{
    "author": "bgw",
    "message": "Turbopack: Only benchmark file IO on `next dev` (#84474)\n\nI added this in https://github.com/vercel/next.js/pull/66057\n\nIt's too noisy and not useful on CI. CI machines are often multi-tenant and/or running many other processes during initialization.\n\nWe could check for `process.env.CI`, but I think just having the check in `next dev` is enough.\n\nhttps://vercel.slack.com/archives/C01A2M9R8RZ/p1759349240395449",
    "sha": "f8816b06794bdb8139abf0b472c944a97262a063",
    "files": [
        {
            "sha": "f5c2d11b980cb1519ad9fa5004bd1970822f6abf",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 17,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/f8816b06794bdb8139abf0b472c944a97262a063/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/f8816b06794bdb8139abf0b472c944a97262a063/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=f8816b06794bdb8139abf0b472c944a97262a063",
            "patch": "@@ -455,34 +455,40 @@ pub fn project_new(\n             }\n \n             let options: ProjectOptions = options.into();\n+            let is_dev = options.dev;\n             let container = turbo_tasks\n                 .run(async move {\n-                    let project = ProjectContainer::new(rcstr!(\"next.js\"), options.dev);\n+                    let project = ProjectContainer::new(rcstr!(\"next.js\"), is_dev);\n                     let project = project.to_resolved().await?;\n                     project.initialize(options).await?;\n                     Ok(project)\n                 })\n                 .or_else(|e| turbopack_ctx.throw_turbopack_internal_result(&e.into()))\n                 .await?;\n \n-            Handle::current().spawn({\n-                let tt = turbo_tasks.clone();\n-                async move {\n-                    let result = tt\n-                        .clone()\n-                        .run(async move {\n-                            benchmark_file_io(tt, container.project().node_root().owned().await?)\n+            if is_dev {\n+                Handle::current().spawn({\n+                    let tt = turbo_tasks.clone();\n+                    async move {\n+                        let result = tt\n+                            .clone()\n+                            .run(async move {\n+                                benchmark_file_io(\n+                                    tt,\n+                                    container.project().node_root().owned().await?,\n+                                )\n                                 .await\n-                        })\n-                        .await;\n-                    if let Err(err) = result {\n-                        // TODO Not ideal to print directly to stdout.\n-                        // We should use a compilation event instead to report async errors.\n-                        println!(\"Failed to benchmark file I/O: {err}\");\n+                            })\n+                            .await;\n+                        if let Err(err) = result {\n+                            // TODO Not ideal to print directly to stdout.\n+                            // We should use a compilation event instead to report async errors.\n+                            println!(\"Failed to benchmark file I/O: {err}\");\n+                        }\n                     }\n-                }\n-                .instrument(tracing::info_span!(\"benchmark file I/O\"))\n-            });\n+                    .instrument(tracing::info_span!(\"benchmark file I/O\"))\n+                });\n+            }\n \n             Ok(External::new(ProjectInstance {\n                 turbopack_ctx,"
        }
    ],
    "stats": {
        "total": 40,
        "additions": 23,
        "deletions": 17
    }
}