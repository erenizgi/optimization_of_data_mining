{
    "author": "acdlite",
    "message": "Remove params from segment path (#82249)\n\nWhen performing a segment prefetch, we send a \"segment path\" to the\nserver, which represents the particular segment that we're requesting.\nOriginally, I thought these needed to fully encode all the param values,\nbut since we already request the segments within the context of a\nparticular target page, it's unnecessary — the base URL already contains\nall the param information (and is indeed the source of truth for where\nthe param values come from). The only thing we need to put in the paths\nare the param names.\n\nOn the client, though, these segments are cached across pages (that's\nthe whole point of the Segment Cache). So in the prefetch cache, we do\nneed to cache them by their concrete param values.\n\nSplitting out the param names and the param values into separate keys\nwill allow us to implement \"fallback PPR\" behavior for the client, where\nif a segment entry does not reference a particular param, it can be\nreused for all possible values of that param. (We already do this for\nsearch strings.)\n\nFor now, I've split the current \"segment path\" key into two separate\nkeys, which I'm calling the \"cache key\" and the \"request key\". It's a\nbit confusing since we have so many different types of cache keys, but I\nthink it's OK for now — this will be refactored soon anyway to support\nthe fallback PPR behavior.\n\nDespite the line count, most of this PR is just a mechanical refactor.\nMost of it was done by tab completion in Cursor. The substance of the\nchange is in the `segment-value-encoding.ts` file.",
    "sha": "92042340b3b2618692c06c084405761950e190e3",
    "files": [
        {
            "sha": "1350849354295edec5fb39f92620b2b412bed8e7",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 103,
            "deletions": 56,
            "changes": 159,
            "blob_url": "https://github.com/vercel/next.js/blob/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=92042340b3b2618692c06c084405761950e190e3",
            "patch": "@@ -53,10 +53,15 @@ import {\n import { createTupleMap, type TupleMap, type Prefix } from './tuple-map'\n import { createLRU } from './lru'\n import {\n+  appendSegmentCacheKeyPart,\n+  appendSegmentRequestKeyPart,\n   convertSegmentPathToStaticExportFilename,\n-  encodeChildSegmentKey,\n-  encodeSegment,\n-  ROOT_SEGMENT_KEY,\n+  createSegmentCacheKeyPart,\n+  createSegmentRequestKeyPart,\n+  ROOT_SEGMENT_CACHE_KEY,\n+  ROOT_SEGMENT_REQUEST_KEY,\n+  type SegmentCacheKey,\n+  type SegmentRequestKey,\n } from '../../../shared/lib/segment-cache/segment-value-encoding'\n import type {\n   FlightRouterState,\n@@ -94,7 +99,8 @@ import { FetchStrategy } from '../segment-cache'\n // Rust Futures, or React Suspense.\n \n export type RouteTree = {\n-  key: string\n+  cacheKey: SegmentCacheKey\n+  requestKey: SegmentRequestKey\n   // TODO: Remove the `segment` field, now that it can be reconstructed\n   // from `param`.\n   segment: FlightRouterStateSegment\n@@ -414,7 +420,7 @@ export function readRouteCacheEntry(\n export function getSegmentKeypathForTask(\n   task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n-  path: string\n+  cacheKey: SegmentCacheKey\n ): Prefix<SegmentCacheKeypath> {\n   // When a prefetch includes dynamic data, the search params are included\n   // in the result, so we must include the search string in the segment\n@@ -427,19 +433,19 @@ export function getSegmentKeypathForTask(\n     task.fetchStrategy === FetchStrategy.Full ||\n     task.fetchStrategy === FetchStrategy.PPRRuntime ||\n     !route.isPPREnabled\n-  return isDynamicTask && path.endsWith('/' + PAGE_SEGMENT_KEY)\n-    ? [path, route.renderedSearch]\n-    : [path]\n+  return isDynamicTask && cacheKey.endsWith('/' + PAGE_SEGMENT_KEY)\n+    ? [cacheKey, route.renderedSearch]\n+    : [cacheKey]\n }\n \n export function readSegmentCacheEntry(\n   now: number,\n   route: FulfilledRouteCacheEntry,\n-  path: string\n+  cacheKey: SegmentCacheKey\n ): SegmentCacheEntry | null {\n-  if (!path.endsWith('/' + PAGE_SEGMENT_KEY)) {\n+  if (!cacheKey.endsWith('/' + PAGE_SEGMENT_KEY)) {\n     // Fast path. Search params only exist on page segments.\n-    return readExactSegmentCacheEntry(now, [path])\n+    return readExactSegmentCacheEntry(now, [cacheKey])\n   }\n \n   const renderedSearch = route.renderedSearch\n@@ -448,7 +454,7 @@ export function readSegmentCacheEntry(\n     // using a dynamic request, then we will have an entry with search params.\n     // Check for that case first.\n     const entryWithSearchParams = readExactSegmentCacheEntry(now, [\n-      path,\n+      cacheKey,\n       renderedSearch,\n     ])\n     if (entryWithSearchParams !== null) {\n@@ -462,7 +468,7 @@ export function readSegmentCacheEntry(\n   // as dynamic.\n   //\n   // See corresponding logic in `getSegmentKeypathForTask`.\n-  const entryWithoutSearchParams = readExactSegmentCacheEntry(now, [path])\n+  const entryWithoutSearchParams = readExactSegmentCacheEntry(now, [cacheKey])\n   return entryWithoutSearchParams\n }\n \n@@ -596,9 +602,9 @@ export function readOrCreateSegmentCacheEntry(\n   now: number,\n   task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n-  path: string\n+  cacheKey: SegmentCacheKey\n ): SegmentCacheEntry {\n-  const keypath = getSegmentKeypathForTask(task, route, path)\n+  const keypath = getSegmentKeypathForTask(task, route, cacheKey)\n   const existingEntry = readExactSegmentCacheEntry(now, keypath)\n   if (existingEntry !== null) {\n     return existingEntry\n@@ -888,15 +894,17 @@ function convertRootTreePrefetchToRouteTree(\n   const index = 0\n   return convertTreePrefetchToRouteTree(\n     rootTree.tree,\n-    ROOT_SEGMENT_KEY,\n+    ROOT_SEGMENT_REQUEST_KEY,\n+    ROOT_SEGMENT_CACHE_KEY,\n     pathnameParts,\n     index\n   )\n }\n \n function convertTreePrefetchToRouteTree(\n   prefetch: TreePrefetch,\n-  key: string,\n+  requestKey: SegmentRequestKey,\n+  cacheKey: SegmentCacheKey,\n   pathnameParts: Array<string>,\n   pathnamePartsIndex: number\n ): RouteTree {\n@@ -952,22 +960,30 @@ function convertTreePrefetchToRouteTree(\n       // TODO: Eventually, the param values will not be included in the response\n       // from the server. We'll instead fill them in on the client by parsing\n       // the URL. This is where we'll do that.\n-      const childKey = encodeChildSegmentKey(\n-        key,\n+      const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n+      const childRequestKey = appendSegmentRequestKeyPart(\n+        requestKey,\n         parallelRouteKey,\n-        encodeSegment(childSegment)\n+        childRequestKeyPart\n+      )\n+      const childCacheKey = appendSegmentCacheKeyPart(\n+        cacheKey,\n+        parallelRouteKey,\n+        createSegmentCacheKeyPart(childRequestKeyPart, childSegment)\n       )\n       slots[parallelRouteKey] = convertTreePrefetchToRouteTree(\n         childPrefetch,\n-        childKey,\n+        childRequestKey,\n+        childCacheKey,\n         pathnameParts,\n         childPathnamePartsIndex\n       )\n     }\n   }\n \n   return {\n-    key,\n+    cacheKey,\n+    requestKey,\n     segment,\n     param,\n     slots,\n@@ -983,13 +999,15 @@ function convertRootFlightRouterStateToRouteTree(\n ): RouteTree {\n   return convertFlightRouterStateToRouteTree(\n     flightRouterState,\n-    ROOT_SEGMENT_KEY\n+    ROOT_SEGMENT_CACHE_KEY,\n+    ROOT_SEGMENT_REQUEST_KEY\n   )\n }\n \n function convertFlightRouterStateToRouteTree(\n   flightRouterState: FlightRouterState,\n-  key: string\n+  cacheKey: SegmentCacheKey,\n+  requestKey: SegmentRequestKey\n ): RouteTree {\n   let slots: { [parallelRouteKey: string]: RouteTree } | null = null\n \n@@ -1000,14 +1018,21 @@ function convertFlightRouterStateToRouteTree(\n     // TODO: Eventually, the param values will not be included in the response\n     // from the server. We'll instead fill them in on the client by parsing\n     // the URL. This is where we'll do that.\n-    const childKey = encodeChildSegmentKey(\n-      key,\n+    const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n+    const childRequestKey = appendSegmentRequestKeyPart(\n+      requestKey,\n+      parallelRouteKey,\n+      childRequestKeyPart\n+    )\n+    const childCacheKey = appendSegmentCacheKeyPart(\n+      cacheKey,\n       parallelRouteKey,\n-      encodeSegment(childSegment)\n+      createSegmentCacheKeyPart(childRequestKeyPart, childSegment)\n     )\n     const childTree = convertFlightRouterStateToRouteTree(\n       childRouterState,\n-      childKey\n+      childCacheKey,\n+      childRequestKey\n     )\n     if (slots === null) {\n       slots = {\n@@ -1047,7 +1072,8 @@ function convertFlightRouterStateToRouteTree(\n   }\n \n   return {\n-    key,\n+    cacheKey,\n+    requestKey,\n     segment,\n     param,\n     slots,\n@@ -1091,7 +1117,7 @@ export async function fetchRouteOnCacheMiss(\n   const key = task.key\n   const href = key.href\n   const nextUrl = key.nextUrl\n-  const segmentPath = '/_tree'\n+  const segmentPath = '/_tree' as SegmentRequestKey\n \n   const headers: RequestHeaders = {\n     [RSC_HEADER]: '1',\n@@ -1337,7 +1363,7 @@ export async function fetchSegmentOnCacheMiss(\n   route: FulfilledRouteCacheEntry,\n   segmentCacheEntry: PendingSegmentCacheEntry,\n   routeKey: RouteCacheKey,\n-  segmentPath: string\n+  tree: RouteTree\n ): Promise<PrefetchSubtaskResult<FulfilledSegmentCacheEntry> | null> {\n   // This function is allowed to use async/await because it contains the actual\n   // fetch that gets issued on a cache miss. Notice it writes the result to the\n@@ -1354,29 +1380,30 @@ export async function fetchSegmentOnCacheMiss(\n   const url = new URL(route.canonicalUrl, routeKey.href)\n   const nextUrl = routeKey.nextUrl\n \n-  const normalizedSegmentPath =\n-    segmentPath === ROOT_SEGMENT_KEY\n+  const requestKey = tree.requestKey\n+  const normalizedRequestKey =\n+    requestKey === ROOT_SEGMENT_REQUEST_KEY\n       ? // The root segment is a special case. To simplify the server-side\n         // handling of these requests, we encode the root segment path as\n         // `_index` instead of as an empty string. This should be treated as\n         // an implementation detail and not as a stable part of the protocol.\n         // It just needs to match the equivalent logic that happens when\n         // prerendering the responses. It should not leak outside of Next.js.\n-        '/_index'\n-      : segmentPath\n+        ('/_index' as SegmentRequestKey)\n+      : requestKey\n \n   const headers: RequestHeaders = {\n     [RSC_HEADER]: '1',\n     [NEXT_ROUTER_PREFETCH_HEADER]: '1',\n-    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedSegmentPath,\n+    [NEXT_ROUTER_SEGMENT_PREFETCH_HEADER]: normalizedRequestKey,\n   }\n   if (nextUrl !== null) {\n     headers[NEXT_URL] = nextUrl\n   }\n \n   const requestUrl = isOutputExportMode\n     ? // In output: \"export\" mode, we need to add the segment path to the URL.\n-      addSegmentPathToUrlInOutputExportMode(url, normalizedSegmentPath)\n+      addSegmentPathToUrlInOutputExportMode(url, normalizedRequestKey)\n     : url\n   try {\n     const response = await fetchPrefetchResponse(requestUrl, headers)\n@@ -1456,7 +1483,7 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n     | FetchStrategy.PPRRuntime\n     | FetchStrategy.Full,\n   dynamicRequestTree: FlightRouterState,\n-  spawnedEntries: Map<string, PendingSegmentCacheEntry>\n+  spawnedEntries: Map<SegmentCacheKey, PendingSegmentCacheEntry>\n ): Promise<PrefetchSubtaskResult<null> | null> {\n   const url = new URL(route.canonicalUrl, task.key.href)\n   const nextUrl = task.key.nextUrl\n@@ -1658,7 +1685,7 @@ function writeDynamicTreeResponseIntoCache(\n }\n \n function rejectSegmentEntriesIfStillPending(\n-  entries: Map<string, SegmentCacheEntry>,\n+  entries: Map<SegmentCacheKey, SegmentCacheEntry>,\n   staleAt: number\n ): Array<FulfilledSegmentCacheEntry> {\n   const fulfilledEntries = []\n@@ -1683,7 +1710,7 @@ function writeDynamicRenderResponseIntoCache(\n   serverData: NavigationFlightResponse,\n   isResponsePartial: boolean,\n   route: FulfilledRouteCacheEntry,\n-  spawnedEntries: Map<string, PendingSegmentCacheEntry> | null\n+  spawnedEntries: Map<SegmentCacheKey, PendingSegmentCacheEntry> | null\n ): Array<FulfilledSegmentCacheEntry> | null {\n   if (serverData.b !== getAppBuildId()) {\n     // The server build does not match the client. Treat as a 404. During\n@@ -1728,14 +1755,21 @@ function writeDynamicRenderResponseIntoCache(\n       //\n       //   [string, Segment, string, Segment, string, Segment, ...]\n       const segmentPath = flightData.segmentPath\n-      let segmentKey = ROOT_SEGMENT_KEY\n+      let requestKey = ROOT_SEGMENT_REQUEST_KEY\n+      let cacheKey = ROOT_SEGMENT_CACHE_KEY\n       for (let i = 0; i < segmentPath.length; i += 2) {\n         const parallelRouteKey: string = segmentPath[i]\n         const segment: FlightRouterStateSegment = segmentPath[i + 1]\n-        segmentKey = encodeChildSegmentKey(\n-          segmentKey,\n+        const requestKeyPart = createSegmentRequestKeyPart(segment)\n+        requestKey = appendSegmentRequestKeyPart(\n+          requestKey,\n           parallelRouteKey,\n-          encodeSegment(segment)\n+          requestKeyPart\n+        )\n+        cacheKey = appendSegmentCacheKeyPart(\n+          cacheKey,\n+          parallelRouteKey,\n+          createSegmentCacheKeyPart(requestKeyPart, segment)\n         )\n       }\n \n@@ -1747,7 +1781,8 @@ function writeDynamicRenderResponseIntoCache(\n         staleAt,\n         seedData,\n         isResponsePartial,\n-        segmentKey,\n+        cacheKey,\n+        requestKey,\n         spawnedEntries\n       )\n     }\n@@ -1799,8 +1834,12 @@ function writeSeedDataIntoCache(\n   staleAt: number,\n   seedData: CacheNodeSeedData,\n   isResponsePartial: boolean,\n-  key: string,\n-  entriesOwnedByCurrentTask: Map<string, PendingSegmentCacheEntry> | null\n+  cacheKey: SegmentCacheKey,\n+  requestKey: SegmentRequestKey,\n+  entriesOwnedByCurrentTask: Map<\n+    SegmentCacheKey,\n+    PendingSegmentCacheEntry\n+  > | null\n ) {\n   // This function is used to write the result of a dynamic server request\n   // (CacheNodeSeedData) into the prefetch cache. It's used in cases where we\n@@ -1816,7 +1855,7 @@ function writeSeedDataIntoCache(\n   // created by a different task, because that causes data races.\n   const ownedEntry =\n     entriesOwnedByCurrentTask !== null\n-      ? entriesOwnedByCurrentTask.get(key)\n+      ? entriesOwnedByCurrentTask.get(cacheKey)\n       : undefined\n   if (ownedEntry !== undefined) {\n     fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n@@ -1826,7 +1865,7 @@ function writeSeedDataIntoCache(\n       now,\n       task,\n       route,\n-      key\n+      cacheKey\n     )\n     if (possiblyNewEntry.status === EntryStatus.Empty) {\n       // Confirmed this is a new entry. We can fulfill it.\n@@ -1853,7 +1892,7 @@ function writeSeedDataIntoCache(\n       )\n       upsertSegmentEntry(\n         now,\n-        getSegmentKeypathForTask(task, route, key),\n+        getSegmentKeypathForTask(task, route, cacheKey),\n         newEntry\n       )\n     }\n@@ -1865,6 +1904,17 @@ function writeSeedDataIntoCache(\n       const childSeedData = seedDataChildren[parallelRouteKey]\n       if (childSeedData !== null) {\n         const childSegment = childSeedData[0]\n+        const childRequestKeyPart = createSegmentRequestKeyPart(childSegment)\n+        const childRequestKey = appendSegmentRequestKeyPart(\n+          requestKey,\n+          parallelRouteKey,\n+          childRequestKeyPart\n+        )\n+        const childCacheKey = appendSegmentCacheKeyPart(\n+          cacheKey,\n+          parallelRouteKey,\n+          createSegmentCacheKeyPart(childRequestKeyPart, childSegment)\n+        )\n         writeSeedDataIntoCache(\n           now,\n           task,\n@@ -1873,11 +1923,8 @@ function writeSeedDataIntoCache(\n           staleAt,\n           childSeedData,\n           isResponsePartial,\n-          encodeChildSegmentKey(\n-            key,\n-            parallelRouteKey,\n-            encodeSegment(childSegment)\n-          ),\n+          childCacheKey,\n+          childRequestKey,\n           entriesOwnedByCurrentTask\n         )\n       }\n@@ -1961,7 +2008,7 @@ function createPrefetchResponseStream(\n \n function addSegmentPathToUrlInOutputExportMode(\n   url: URL,\n-  segmentPath: string\n+  segmentPath: SegmentRequestKey\n ): URL {\n   if (isOutputExportMode) {\n     // In output: \"export\" mode, we cannot use a header to encode the segment"
        },
        {
            "sha": "47554c19394a68a3fe6b7517e54171efe5eb9c47",
            "filename": "packages/next/src/client/components/segment-cache-impl/navigation.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts?ref=92042340b3b2618692c06c084405761950e190e3",
            "patch": "@@ -274,7 +274,7 @@ function readRenderSnapshotFromCache(\n   let loading: LoadingModuleData | Promise<LoadingModuleData> = null\n   let isPartial: boolean = true\n \n-  const segmentEntry = readSegmentCacheEntry(now, route, tree.key)\n+  const segmentEntry = readSegmentCacheEntry(now, route, tree.cacheKey)\n   if (segmentEntry !== null) {\n     switch (segmentEntry.status) {\n       case EntryStatus.Fulfilled: {"
        },
        {
            "sha": "b4b71e5565dbfb383040f0827d2cbf1200f9917c",
            "filename": "packages/next/src/client/components/segment-cache-impl/scheduler.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 28,
            "changes": 53,
            "blob_url": "https://github.com/vercel/next.js/blob/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts?ref=92042340b3b2618692c06c084405761950e190e3",
            "patch": "@@ -38,6 +38,7 @@ import {\n   addSearchParamsIfPageSegment,\n   PAGE_SEGMENT_KEY,\n } from '../../../shared/lib/segment'\n+import type { SegmentCacheKey } from '../../../shared/lib/segment-cache/segment-value-encoding'\n \n const scheduleMicrotask =\n   typeof queueMicrotask === 'function'\n@@ -583,7 +584,10 @@ function pingRootRouteTree(\n         case FetchStrategy.PPRRuntime:\n         case FetchStrategy.LoadingBoundary: {\n           // Prefetch multiple segments using a single dynamic request.\n-          const spawnedEntries = new Map<string, PendingSegmentCacheEntry>()\n+          const spawnedEntries = new Map<\n+            SegmentCacheKey,\n+            PendingSegmentCacheEntry\n+          >()\n           const dynamicRequestTree = diffRouteTreeAgainstCurrent(\n             now,\n             task,\n@@ -658,8 +662,8 @@ function pingPPRRouteTree(\n   route: FulfilledRouteCacheEntry,\n   tree: RouteTree\n ): PrefetchTaskExitStatus.InProgress | PrefetchTaskExitStatus.Done {\n-  const segment = readOrCreateSegmentCacheEntry(now, task, route, tree.key)\n-  pingPerSegment(now, task, route, segment, task.key, tree.key)\n+  const segment = readOrCreateSegmentCacheEntry(now, task, route, tree.cacheKey)\n+  pingPerSegment(now, task, route, segment, task.key, tree)\n   if (tree.slots !== null) {\n     if (!hasNetworkBandwidth(task)) {\n       // Stop prefetching segments until there's more bandwidth.\n@@ -848,7 +852,7 @@ function pingPPRDisabledRouteTreeUpToLoadingBoundary(\n   let refetchMarker: 'refetch' | 'inside-shared-layout' | null =\n     refetchMarkerContext === null ? 'inside-shared-layout' : null\n \n-  const segment = readOrCreateSegmentCacheEntry(now, task, route, tree.key)\n+  const segment = readOrCreateSegmentCacheEntry(now, task, route, tree.cacheKey)\n   switch (segment.status) {\n     case EntryStatus.Empty: {\n       // This segment is not cached. Add a refetch marker so the server knows\n@@ -861,7 +865,7 @@ function pingPPRDisabledRouteTreeUpToLoadingBoundary(\n \n       // Add the pending cache entry to the result map.\n       spawnedEntries.set(\n-        tree.key,\n+        tree.cacheKey,\n         upgradeToPendingSegment(\n           segment,\n           // Set the fetch strategy to LoadingBoundary to indicate that the server\n@@ -951,7 +955,7 @@ function pingRouteTreeAndIncludeDynamicData(\n   // explicit \"refetch\" marker so the server knows where to start rendering.\n   // Once the server starts rendering along a path, it keeps rendering the\n   // entire subtree.\n-  const segment = readOrCreateSegmentCacheEntry(now, task, route, tree.key)\n+  const segment = readOrCreateSegmentCacheEntry(now, task, route, tree.cacheKey)\n \n   let spawnedSegment: PendingSegmentCacheEntry | null = null\n \n@@ -980,7 +984,7 @@ function pingRouteTreeAndIncludeDynamicData(\n           task,\n           route,\n           segment,\n-          tree.key,\n+          tree,\n           fetchStrategy\n         )\n       }\n@@ -1001,7 +1005,7 @@ function pingRouteTreeAndIncludeDynamicData(\n           task,\n           route,\n           segment,\n-          tree.key,\n+          tree,\n           fetchStrategy\n         )\n       }\n@@ -1029,7 +1033,7 @@ function pingRouteTreeAndIncludeDynamicData(\n \n   if (spawnedSegment !== null) {\n     // Add the pending entry to the result map.\n-    spawnedEntries.set(tree.key, spawnedSegment)\n+    spawnedEntries.set(tree.cacheKey, spawnedSegment)\n   }\n \n   // Don't bother to add a refetch marker if one is already present in a parent.\n@@ -1052,7 +1056,7 @@ function pingPerSegment(\n   route: FulfilledRouteCacheEntry,\n   segment: SegmentCacheEntry,\n   routeKey: RouteCacheKey,\n-  segmentKey: string\n+  tree: RouteTree\n ): void {\n   switch (segment.status) {\n     case EntryStatus.Empty:\n@@ -1062,7 +1066,7 @@ function pingPerSegment(\n           route,\n           upgradeToPendingSegment(segment, FetchStrategy.PPR),\n           routeKey,\n-          segmentKey\n+          tree\n         )\n       )\n       break\n@@ -1090,7 +1094,7 @@ function pingPerSegment(\n               segment,\n               route,\n               routeKey,\n-              segmentKey\n+              tree\n             )\n           }\n           break\n@@ -1119,14 +1123,7 @@ function pingPerSegment(\n           // Because a rejected segment will definitely prevent the segment (and\n           // all of its children) from rendering, we perform this revalidation\n           // immediately instead of deferring it to a background task.\n-          pingPPRSegmentRevalidation(\n-            now,\n-            task,\n-            segment,\n-            route,\n-            routeKey,\n-            segmentKey\n-          )\n+          pingPPRSegmentRevalidation(now, task, segment, route, routeKey, tree)\n           break\n         default:\n           segment.fetchStrategy satisfies never\n@@ -1151,7 +1148,7 @@ function pingPPRSegmentRevalidation(\n   currentSegment: SegmentCacheEntry,\n   route: FulfilledRouteCacheEntry,\n   routeKey: RouteCacheKey,\n-  segmentKey: string\n+  tree: RouteTree\n ): void {\n   const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n     now,\n@@ -1164,13 +1161,13 @@ function pingPPRSegmentRevalidation(\n       upsertSegmentOnCompletion(\n         task,\n         route,\n-        segmentKey,\n+        tree.cacheKey,\n         spawnPrefetchSubtask(\n           fetchSegmentOnCacheMiss(\n             route,\n             upgradeToPendingSegment(revalidatingSegment, FetchStrategy.PPR),\n             routeKey,\n-            segmentKey\n+            tree\n           )\n         )\n       )\n@@ -1194,7 +1191,7 @@ function pingFullSegmentRevalidation(\n   task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n   currentSegment: SegmentCacheEntry,\n-  segmentKey: string,\n+  tree: RouteTree,\n   fetchStrategy: FetchStrategy.Full | FetchStrategy.PPRRuntime\n ): PendingSegmentCacheEntry | null {\n   const revalidatingSegment = readOrCreateRevalidatingSegmentEntry(\n@@ -1214,7 +1211,7 @@ function pingFullSegmentRevalidation(\n     upsertSegmentOnCompletion(\n       task,\n       route,\n-      segmentKey,\n+      tree.cacheKey,\n       waitForSegmentCacheEntry(pendingSegment)\n     )\n     return pendingSegment\n@@ -1239,7 +1236,7 @@ function pingFullSegmentRevalidation(\n       upsertSegmentOnCompletion(\n         task,\n         route,\n-        segmentKey,\n+        tree.cacheKey,\n         waitForSegmentCacheEntry(pendingSegment)\n       )\n       return pendingSegment\n@@ -1266,14 +1263,14 @@ const noop = () => {}\n function upsertSegmentOnCompletion(\n   task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n-  key: string,\n+  cacheKey: SegmentCacheKey,\n   promise: Promise<FulfilledSegmentCacheEntry | null>\n ) {\n   // Wait for a segment to finish loading, then upsert it into the cache\n   promise.then((fulfilled) => {\n     if (fulfilled !== null) {\n       // Received new data. Attempt to replace the existing entry in the cache.\n-      const keypath = getSegmentKeypathForTask(task, route, key)\n+      const keypath = getSegmentKeypathForTask(task, route, cacheKey)\n       upsertSegmentEntry(Date.now(), keypath, fulfilled)\n     }\n   }, noop)"
        },
        {
            "sha": "d70aadd93ba4cabdf458f074f291b72c3c444748",
            "filename": "packages/next/src/client/route-params.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Froute-params.ts?ref=92042340b3b2618692c06c084405761950e190e3",
            "patch": "@@ -1,6 +1,6 @@\n import type { DynamicParamTypesShort } from '../server/app-render/types'\n import { PAGE_SEGMENT_KEY } from '../shared/lib/segment'\n-import { ROOT_SEGMENT_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\n+import { ROOT_SEGMENT_REQUEST_KEY } from '../shared/lib/segment-cache/segment-value-encoding'\n import {\n   NEXT_REWRITTEN_PATH_HEADER,\n   NEXT_REWRITTEN_QUERY_HEADER,\n@@ -93,7 +93,7 @@ export function doesStaticSegmentAppearInURL(segment: string): boolean {\n   // inferring it on the client based on the segment type. Something like\n   // a `doesAppearInURL` flag in FlightRouterState.\n   if (\n-    segment === ROOT_SEGMENT_KEY ||\n+    segment === ROOT_SEGMENT_REQUEST_KEY ||\n     // For some reason, the loader tree sometimes includes extra __PAGE__\n     // \"layouts\" when part of a parallel route. But it's not a leaf node.\n     // Otherwise, we wouldn't need this special case because pages are"
        },
        {
            "sha": "ee3e1767b1ab37bea0f0ed7769e75af5ab926123",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 12,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=92042340b3b2618692c06c084405761950e190e3",
            "patch": "@@ -3915,8 +3915,7 @@ async function prerenderToStream(\n         flightData,\n         finalServerPrerenderStore,\n         ComponentMod,\n-        renderOpts,\n-        fallbackRouteParams\n+        renderOpts\n       )\n \n       // If there are fallback route params, the RSC data is inherently dynamic\n@@ -4130,8 +4129,7 @@ async function prerenderToStream(\n           flightData,\n           ssrPrerenderStore,\n           ComponentMod,\n-          renderOpts,\n-          fallbackRouteParams\n+          renderOpts\n         )\n       }\n \n@@ -4331,8 +4329,7 @@ async function prerenderToStream(\n           flightData,\n           prerenderLegacyStore,\n           ComponentMod,\n-          renderOpts,\n-          fallbackRouteParams\n+          renderOpts\n         )\n       }\n \n@@ -4511,8 +4508,7 @@ async function prerenderToStream(\n           flightData,\n           prerenderLegacyStore,\n           ComponentMod,\n-          renderOpts,\n-          fallbackRouteParams\n+          renderOpts\n         )\n       }\n \n@@ -4637,8 +4633,7 @@ async function collectSegmentData(\n   fullPageDataBuffer: Buffer,\n   prerenderStore: PrerenderStore,\n   ComponentMod: AppPageModule,\n-  renderOpts: RenderOpts,\n-  fallbackRouteParams: FallbackRouteParams | null\n+  renderOpts: RenderOpts\n ): Promise<Map<string, Buffer> | undefined> {\n   // Per-segment prefetch data\n   //\n@@ -4687,7 +4682,6 @@ async function collectSegmentData(\n     fullPageDataBuffer,\n     staleTime,\n     clientReferenceManifest.clientModules as ManifestNode,\n-    serverConsumerManifest,\n-    fallbackRouteParams\n+    serverConsumerManifest\n   )\n }"
        },
        {
            "sha": "2ae3feb2a6d9f14164686ca1067bd3c7593de26b",
            "filename": "packages/next/src/server/app-render/collect-segment-data.tsx",
            "status": "modified",
            "additions": 22,
            "deletions": 64,
            "changes": 86,
            "blob_url": "https://github.com/vercel/next.js/blob/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcollect-segment-data.tsx?ref=92042340b3b2618692c06c084405761950e190e3",
            "patch": "@@ -21,13 +21,12 @@ import type {\n   LoadingModuleData,\n } from '../../shared/lib/app-router-context.shared-runtime'\n import {\n-  encodeChildSegmentKey,\n-  encodeSegment,\n-  ROOT_SEGMENT_KEY,\n-  type EncodedSegment,\n+  type SegmentRequestKey,\n+  createSegmentRequestKeyPart,\n+  appendSegmentRequestKeyPart,\n+  ROOT_SEGMENT_REQUEST_KEY,\n } from '../../shared/lib/segment-cache/segment-value-encoding'\n import { getDigestForWellKnownError } from './create-error-handler'\n-import type { FallbackRouteParams } from '../request/fallback-params'\n \n // Contains metadata about the route tree. The client must fetch this before\n // it can fetch any actual segment data.\n@@ -87,13 +86,12 @@ export async function collectSegmentData(\n   fullPageDataBuffer: Buffer,\n   staleTime: number,\n   clientModules: ManifestNode,\n-  serverConsumerManifest: any,\n-  fallbackRouteParams: FallbackRouteParams | null\n-): Promise<Map<string, Buffer>> {\n+  serverConsumerManifest: any\n+): Promise<Map<SegmentRequestKey, Buffer>> {\n   // Traverse the router tree and generate a prefetch response for each segment.\n \n   // A mutable map to collect the results as we traverse the route tree.\n-  const resultMap = new Map<string, Buffer>()\n+  const resultMap = new Map<SegmentRequestKey, Buffer>()\n \n   // Before we start, warm up the module cache by decoding the page data once.\n   // Then we can assume that any remaining async tasks that occur the next time\n@@ -122,15 +120,14 @@ export async function collectSegmentData(\n   // tree, we'll also spawn additional tasks to generate the segment prefetches.\n   // The promises for these tasks are pushed to a mutable array that we will\n   // await once the route tree is fully rendered.\n-  const segmentTasks: Array<Promise<[string, Buffer]>> = []\n+  const segmentTasks: Array<Promise<[SegmentRequestKey, Buffer]>> = []\n   const { prelude: treeStream } = await prerender(\n     // RootTreePrefetch is not a valid return type for a React component, but\n     // we need to use a component so that when we decode the original stream\n     // inside of it, the side effects are transferred to the new stream.\n     // @ts-expect-error\n     <PrefetchTreeData\n       fullPageDataBuffer={fullPageDataBuffer}\n-      fallbackRouteParams={fallbackRouteParams}\n       serverConsumerManifest={serverConsumerManifest}\n       clientModules={clientModules}\n       staleTime={staleTime}\n@@ -147,7 +144,7 @@ export async function collectSegmentData(\n \n   // Write the route tree to a special `/_tree` segment.\n   const treeBuffer = await streamToBuffer(treeStream)\n-  resultMap.set('/_tree', treeBuffer)\n+  resultMap.set('/_tree' as SegmentRequestKey, treeBuffer)\n \n   // Now that we've finished rendering the route tree, all the segment tasks\n   // should have been spawned. Await them in parallel and write the segment\n@@ -161,7 +158,6 @@ export async function collectSegmentData(\n \n async function PrefetchTreeData({\n   fullPageDataBuffer,\n-  fallbackRouteParams,\n   serverConsumerManifest,\n   clientModules,\n   staleTime,\n@@ -170,10 +166,9 @@ async function PrefetchTreeData({\n }: {\n   fullPageDataBuffer: Buffer\n   serverConsumerManifest: any\n-  fallbackRouteParams: FallbackRouteParams | null\n   clientModules: ManifestNode\n   staleTime: number\n-  segmentTasks: Array<Promise<[string, Buffer]>>\n+  segmentTasks: Array<Promise<[SegmentRequestKey, Buffer]>>\n   onCompletedProcessingRouteTree: () => void\n }): Promise<RootTreePrefetch | null> {\n   // We're currently rendering a Flight response for the route tree prefetch.\n@@ -211,9 +206,8 @@ async function PrefetchTreeData({\n     flightRouterState,\n     buildId,\n     seedData,\n-    fallbackRouteParams,\n     clientModules,\n-    ROOT_SEGMENT_KEY,\n+    ROOT_SEGMENT_REQUEST_KEY,\n     segmentTasks\n   )\n \n@@ -239,9 +233,8 @@ function collectSegmentDataImpl(\n   route: FlightRouterState,\n   buildId: string,\n   seedData: CacheNodeSeedData | null,\n-  fallbackRouteParams: FallbackRouteParams | null,\n   clientModules: ManifestNode,\n-  key: string,\n+  requestKey: SegmentRequestKey,\n   segmentTasks: Array<Promise<[string, Buffer]>>\n ): TreePrefetch {\n   // Metadata about the segment. Sent as part of the tree prefetch. Null if\n@@ -256,23 +249,17 @@ function collectSegmentDataImpl(\n     const childSeedData =\n       seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n \n-    const childKey = encodeChildSegmentKey(\n-      key,\n+    const childRequestKey = appendSegmentRequestKeyPart(\n+      requestKey,\n       parallelRouteKey,\n-      Array.isArray(childSegment) && fallbackRouteParams !== null\n-        ? encodeSegmentWithPossibleFallbackParam(\n-            childSegment,\n-            fallbackRouteParams\n-          )\n-        : encodeSegment(childSegment)\n+      createSegmentRequestKeyPart(childSegment)\n     )\n     const childTree = collectSegmentDataImpl(\n       childRoute,\n       buildId,\n       childSeedData,\n-      fallbackRouteParams,\n       clientModules,\n-      childKey,\n+      childRequestKey,\n       segmentTasks\n     )\n     if (slotMetadata === null) {\n@@ -287,7 +274,7 @@ function collectSegmentDataImpl(\n       // Since we're already in the middle of a render, wait until after the\n       // current task to escape the current rendering context.\n       waitAtLeastOneReactRenderTask().then(() =>\n-        renderSegmentPrefetch(buildId, seedData, key, clientModules)\n+        renderSegmentPrefetch(buildId, seedData, requestKey, clientModules)\n       )\n     )\n   } else {\n@@ -307,41 +294,12 @@ function collectSegmentDataImpl(\n   }\n }\n \n-function encodeSegmentWithPossibleFallbackParam(\n-  segment: Exclude<FlightRouterStateSegment, string>,\n-  fallbackRouteParams: FallbackRouteParams\n-): EncodedSegment {\n-  const name = segment[0]\n-  if (!fallbackRouteParams.has(name)) {\n-    // Normal case. No matching fallback parameter.\n-    return encodeSegment(segment)\n-  }\n-  // This segment includes a fallback parameter. During prerendering, a random\n-  // placeholder value was used; however, for segment prefetches, we need the\n-  // segment path to be predictable so the server can create a rewrite for it.\n-  // So, replace the placeholder segment value with a \"template\" string,\n-  // e.g. `[name]`.\n-  // TODO: This will become a bit cleaner once remove route parameters from the\n-  // server response, and instead add them to the segment keys on the client.\n-  // Instead of a string replacement, like we do here, route params will always\n-  // be encoded in separate step from the rest of the segment, not just in the\n-  // case of fallback params.\n-  const encodedSegment = encodeSegment(segment)\n-  const lastIndex = encodedSegment.lastIndexOf('$')\n-  const encodedFallbackSegment =\n-    // NOTE: This is guaranteed not to clash with the rest of the segment\n-    // because non-simple characters (including [ and ]) trigger a base\n-    // 64 encoding.\n-    encodedSegment.substring(0, lastIndex + 1) + `[${name}]`\n-  return encodedFallbackSegment as EncodedSegment\n-}\n-\n async function renderSegmentPrefetch(\n   buildId: string,\n   seedData: CacheNodeSeedData,\n-  key: string,\n+  requestKey: SegmentRequestKey,\n   clientModules: ManifestNode\n-): Promise<[string, Buffer]> {\n+): Promise<[SegmentRequestKey, Buffer]> {\n   // Render the segment data to a stream.\n   // In the future, this is where we can include additional metadata, like the\n   // stale time and cache tags.\n@@ -368,10 +326,10 @@ async function renderSegmentPrefetch(\n     }\n   )\n   const segmentBuffer = await streamToBuffer(segmentStream)\n-  if (key === ROOT_SEGMENT_KEY) {\n-    return ['/_index', segmentBuffer]\n+  if (requestKey === ROOT_SEGMENT_REQUEST_KEY) {\n+    return ['/_index' as SegmentRequestKey, segmentBuffer]\n   } else {\n-    return [key, segmentBuffer]\n+    return [requestKey, segmentBuffer]\n   }\n }\n "
        },
        {
            "sha": "b6d621f19b33e3972f9ee1b49335af7cb71c6bd0",
            "filename": "packages/next/src/shared/lib/segment-cache/segment-value-encoding.ts",
            "status": "modified",
            "additions": 44,
            "deletions": 19,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment-cache%2Fsegment-value-encoding.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/92042340b3b2618692c06c084405761950e190e3/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment-cache%2Fsegment-value-encoding.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fsegment-cache%2Fsegment-value-encoding.ts?ref=92042340b3b2618692c06c084405761950e190e3",
            "patch": "@@ -4,11 +4,17 @@ import type { Segment as FlightRouterStateSegment } from '../../../server/app-re\n // TypeScript trick to simulate opaque types, like in Flow.\n type Opaque<K, T> = T & { __brand: K }\n \n-export type EncodedSegment = Opaque<'EncodedSegment', string>\n+export type SegmentRequestKeyPart = Opaque<'SegmentRequestKeyPart', string>\n+export type SegmentRequestKey = Opaque<'SegmentRequestKey', string>\n+export type SegmentCacheKeyPart = Opaque<'SegmentCacheKeyPart', string>\n+export type SegmentCacheKey = Opaque<'SegmentCacheKey', string>\n \n-export function encodeSegment(\n+export const ROOT_SEGMENT_REQUEST_KEY = '' as SegmentRequestKey\n+export const ROOT_SEGMENT_CACHE_KEY = '' as SegmentCacheKey\n+\n+export function createSegmentRequestKeyPart(\n   segment: FlightRouterStateSegment\n-): EncodedSegment {\n+): SegmentRequestKeyPart {\n   if (typeof segment === 'string') {\n     if (segment.startsWith(PAGE_SEGMENT_KEY)) {\n       // The Flight Router State type sometimes includes the search params in\n@@ -20,7 +26,7 @@ export function encodeSegment(\n       // Segment Cache implementation has settled.\n       // TODO: We should hoist the search params out of the FlightRouterState\n       // type entirely, This is our plan for dynamic route params, too.\n-      return PAGE_SEGMENT_KEY as EncodedSegment\n+      return PAGE_SEGMENT_KEY as SegmentRequestKeyPart\n     }\n     const safeName =\n       // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\n@@ -31,26 +37,22 @@ export function encodeSegment(\n         : encodeToFilesystemAndURLSafeString(segment)\n     // Since this is not a dynamic segment, it's fully encoded. It does not\n     // need to be \"hydrated\" with a param value.\n-    return safeName as EncodedSegment\n+    return safeName as SegmentRequestKeyPart\n   }\n+\n   const name = segment[0]\n-  const paramValue = segment[1]\n   const paramType = segment[2]\n   const safeName = encodeToFilesystemAndURLSafeString(name)\n-  const safeValue = encodeToFilesystemAndURLSafeString(paramValue)\n \n-  const encodedName = '$' + paramType + '$' + safeName + '$' + safeValue\n-  return encodedName as EncodedSegment\n+  const encodedName = '$' + paramType + '$' + safeName\n+  return encodedName as SegmentRequestKeyPart\n }\n \n-export const ROOT_SEGMENT_KEY = ''\n-\n-export function encodeChildSegmentKey(\n-  // TODO: Make segment keys an opaque type, too?\n-  parentSegmentKey: string,\n+export function appendSegmentRequestKeyPart(\n+  parentRequestKey: SegmentRequestKey,\n   parallelRouteKey: string,\n-  segment: EncodedSegment\n-): string {\n+  childRequestKeyPart: SegmentRequestKeyPart\n+): SegmentRequestKey {\n   // Aside from being filesystem safe, segment keys are also designed so that\n   // each segment and parallel route creates its own subdirectory. Roughly in\n   // the same shape as the source app directory. This is mostly just for easier\n@@ -61,10 +63,33 @@ export function encodeChildSegmentKey(\n   // common case. Saves some bytes (and it's what the app directory does).\n   const slotKey =\n     parallelRouteKey === 'children'\n-      ? segment\n-      : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${segment}`\n+      ? childRequestKeyPart\n+      : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childRequestKeyPart}`\n+  return (parentRequestKey + '/' + slotKey) as SegmentRequestKey\n+}\n \n-  return parentSegmentKey + '/' + slotKey\n+export function createSegmentCacheKeyPart(\n+  requestKeyPart: SegmentRequestKeyPart,\n+  segment: FlightRouterStateSegment\n+): SegmentCacheKeyPart {\n+  if (typeof segment === 'string') {\n+    return requestKeyPart as any as SegmentCacheKeyPart\n+  }\n+  const paramValue = segment[1]\n+  const safeValue = encodeToFilesystemAndURLSafeString(paramValue)\n+  return (requestKeyPart + '$' + safeValue) as SegmentCacheKeyPart\n+}\n+\n+export function appendSegmentCacheKeyPart(\n+  parentSegmentKey: SegmentCacheKey,\n+  parallelRouteKey: string,\n+  childCacheKeyPart: SegmentCacheKeyPart\n+): SegmentCacheKey {\n+  const slotKey =\n+    parallelRouteKey === 'children'\n+      ? childCacheKeyPart\n+      : `@${encodeToFilesystemAndURLSafeString(parallelRouteKey)}/${childCacheKeyPart}`\n+  return (parentSegmentKey + '/' + slotKey) as SegmentCacheKey\n }\n \n // Define a regex pattern to match the most common characters found in a route"
        }
    ],
    "stats": {
        "total": 385,
        "additions": 203,
        "deletions": 182
    }
}