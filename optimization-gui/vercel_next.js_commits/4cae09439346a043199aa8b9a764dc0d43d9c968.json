{
    "author": "icyJoseph",
    "message": "docs: cache components - introduction (#85196)",
    "sha": "4cae09439346a043199aa8b9a764dc0d43d9c968",
    "files": [
        {
            "sha": "58b9b81a28f63e5ee3e2a87a4b0905e5cfc657bc",
            "filename": "docs/01-app/01-getting-started/03-layouts-and-pages.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F01-getting-started%2F03-layouts-and-pages.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F01-getting-started%2F03-layouts-and-pages.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F03-layouts-and-pages.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -269,7 +269,7 @@ export default async function Page({ searchParams }) {\n }\n ```\n \n-Using `searchParams` opts your page into [**dynamic rendering**](/docs/app/getting-started/partial-prerendering#dynamic-rendering) because it requires a incoming request to read the search parameters from.\n+Using `searchParams` opts your page into [**dynamic rendering**](/docs/app/guides/caching#dynamic-rendering) because it requires a incoming request to read the search parameters from.\n \n Client Components can read search params using the [`useSearchParams`](/docs/app/api-reference/functions/use-search-params) hook.\n "
        },
        {
            "sha": "f9ece422095c6214d4355ea71eb03e2ff5943a11",
            "filename": "docs/01-app/01-getting-started/05-server-and-client-components.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F01-getting-started%2F05-server-and-client-components.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F01-getting-started%2F05-server-and-client-components.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F05-server-and-client-components.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -102,7 +102,7 @@ export default function LikeButton({ likes }) {\n On the server, Next.js uses React's APIs to orchestrate rendering. The rendering work is split into chunks, by individual route segments ([layouts and pages](/docs/app/getting-started/layouts-and-pages)):\n \n - **Server Components** are rendered into a special data format called the React Server Component Payload (RSC Payload).\n-- **Client Components** and the RSC Payload are used to [prerender](/docs/app/getting-started/partial-prerendering#how-does-partial-prerendering-work) HTML.\n+- **Client Components** and the RSC Payload are used to [pre-render](/docs/app/guides/caching#rendering-strategies) HTML.\n \n > **What is the React Server Component Payload (RSC)?**\n >"
        },
        {
            "sha": "e934eef484e84b8e3ab66a7c152ac414479bdc59",
            "filename": "docs/01-app/01-getting-started/06-cache-components.mdx",
            "status": "added",
            "additions": 564,
            "deletions": 0,
            "changes": 564,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F06-cache-components.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -0,0 +1,564 @@\n+---\n+title: Cache Components\n+description: Learn how to use Cache Components and combine the benefits of static and dynamic rendering.\n+version: beta\n+related:\n+  title: Next Steps\n+  description: Learn more about the config option for Cache Components.\n+  links:\n+    - app/api-reference/config/next-config-js/cacheComponents\n+    - app/api-reference/directives/use-cache\n+    - app/api-reference/functions/cacheLife\n+    - app/api-reference/functions/cacheTag\n+    - app/api-reference/functions/revalidateTag\n+    - app/api-reference/functions/updateTag\n+---\n+\n+Cache Components is a new approach to rendering and caching in Next.js that provides fine-grained control over what gets cached and when, while ensuring a great user experience through **Partial Prerendering (PPR)**.\n+\n+## Cache Components\n+\n+When developing dynamic applications, you have to balance two primary approaches:\n+\n+- **Fully static pages** load fast but can't show personalized or real-time data\n+- **Fully dynamic pages** can show fresh data but require rendering everything on each request, leading to slower initial loads\n+\n+With Cache Components enabled, Next.js treats all routes as **dynamic by default**. Every request renders with the latest available data. However, most pages are made up of both static and dynamic parts, and not all dynamic data needs to be resolved from source on every request.\n+\n+Cache Components allows you to mark data, and even parts of your UI as cacheable, which includes them in the pre-render pass alongside static parts of the page.\n+\n+> **Before Cache Components**, Next.js tried to statically optimize **entire** pages automatically, which could lead to unexpected behavior when adding dynamic code.\n+\n+Cache Components implements **Partial Prerendering (PPR)**, and `use cache` to give you the best of both worlds:\n+\n+<Image\n+  alt=\"Partially re-rendered Product Page showing static nav and product information, and dynamic cart and recommended products\"\n+  srcLight=\"/learn/light/thinking-in-ppr.png\"\n+  srcDark=\"/learn/dark/thinking-in-ppr.png\"\n+  width=\"1600\"\n+  height=\"632\"\n+/>\n+\n+When a user visits a route:\n+\n+- The server sends a **static shell** containing cached content, ensuring a fast initial load\n+- Dynamic sections wrapped in `Suspense` boundaries display fallback UI in the shell\n+- Only the dynamic parts render to replace their fallbacks, streaming in parallel as they become ready\n+- You can include otherwise-dynamic data in the initial shell by caching it with `use cache`\n+\n+> **ðŸŽ¥ Watch:** Why PPR and how it works â†’ [YouTube (10 minutes)](https://www.youtube.com/watch?v=MTcPrTIBkpA).\n+\n+## How it Works\n+\n+Cache Components gives you three key tools to control rendering:\n+\n+### 1. Suspense for runtime data\n+\n+Some data is only available at runtime when an actual user makes a request. APIs like [`cookies`](/docs/app/api-reference/functions/cookies), [`headers`](/docs/app/api-reference/functions/headers), and [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) access request-specific information. Wrap components using these APIs in `Suspense` boundaries so the rest of the page can be pre-rendered as a static shell.\n+\n+**Runtime APIs include:**\n+\n+- [`cookies`](/docs/app/api-reference/functions/cookies)\n+- [`headers`](/docs/app/api-reference/functions/headers)\n+- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)\n+\n+### 2. Suspense for dynamic data\n+\n+Dynamic data like [`fetch`](/docs/app/api-reference/functions/fetch) calls or database queries (`db.query(...)`) can change between requests but isn't user-specific. The [`connection`](/docs/app/api-reference/functions/connection) API is meta-dynamicâ€”it represents waiting for a user navigation even though there's no actual data to return. Wrap components that use these in `Suspense` boundaries to enable streaming.\n+\n+**Dynamic data patterns include:**\n+\n+- [`fetch`](/docs/app/api-reference/functions/fetch) requests\n+- Database queries\n+- [`connection`](/docs/app/api-reference/functions/connection)\n+- [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)\n+\n+### 3. Cached data with `use cache`\n+\n+Add `use cache` to any Server Component to make it cached and include it in the pre-rendered shell. You cannot use runtime APIs from inside a cached component. You can also mark utility functions as `use cache` and call them from Server Components.\n+\n+```tsx\n+'use cache'\n+export async function getProducts() {\n+  const data = await db.query('SELECT * FROM products')\n+  return data\n+}\n+```\n+\n+## Using Suspense Boundaries\n+\n+React [Suspense](https://react.dev/reference/react/Suspense) boundaries let you define what fallback UI to use when it wraps dynamic or runtime data.\n+\n+Content outside the boundary, including the fallback UI, is pre-rendered as a static shell, while content inside the boundary streams in when ready.\n+\n+Here's how to use `Suspense` with Cache Components:\n+\n+```tsx filename=\"app/page.tsx\" switcher\n+import { Suspense } from 'react'\n+\n+export default function Page() {\n+  return (\n+    <>\n+      <h1>This will be pre-rendered</h1>\n+      <Suspense fallback={<Skeleton />}>\n+        <DynamicContent />\n+      </Suspense>\n+    </>\n+  )\n+}\n+\n+async function DynamicContent() {\n+  const res = await fetch('http://api.cms.com/posts')\n+  const { posts } = await res.json()\n+  return <div>{/* ... */}</div>\n+}\n+```\n+\n+```jsx filename=\"app/page.js\" switcher\n+import { Suspense } from 'react'\n+\n+export default function Page() {\n+  return (\n+    <>\n+      <h1>This will be pre-rendered</h1>\n+      <Suspense fallback={<Skeleton />}>\n+        <DynamicContent />\n+      </Suspense>\n+    </>\n+  )\n+}\n+\n+async function DynamicContent() {\n+  const res = await fetch('http://api.cms.com/posts')\n+  const { posts } = await res.json()\n+  return <div>{/* ... */}</div>\n+}\n+```\n+\n+At build time, Next.js pre-renders the static content and the `fallback` UI, while the dynamic content is postponed until a user requests the route.\n+\n+Wrapping a component in `Suspense` doesn't make it dynamic; your API usage does. `Suspense` acts as a boundary that encapsulates dynamic content and enables streaming.\n+\n+### Missing Suspense boundaries\n+\n+Cache Components enforces that dynamic code must be wrapped in a `Suspense` boundary. If you forget, you'll see this error:\n+\n+> Uncached data was accessed outside of `<Suspense>`\n+>\n+> This delays the entire page from rendering, resulting in a slow user\n+> experience. Next.js uses this error to ensure your app loads instantly\n+> on every navigation.\n+\n+This error helps prevent a situation where, instead of getting a static shell instantly, users would hit a blocking runtime render with nothing to show. To fix it, add a `Suspense` boundary or use `use cache` to cache the work instead.\n+\n+### How streaming works\n+\n+Streaming splits the route into chunks and progressively streams them to the client as they become ready.\n+This allows the user to see parts of the page immediately, before the entire content has finished\n+rendering.\n+\n+<Image\n+  alt=\"Diagram showing partially rendered page on the client, with loading UI for chunks that are being streamed.\"\n+  srcLight=\"/docs/light/server-rendering-with-streaming.png\"\n+  srcDark=\"/docs/dark/server-rendering-with-streaming.png\"\n+  width=\"1600\"\n+  height=\"785\"\n+/>\n+\n+With partial pre-rendering, the initial UI can be sent immediately to the browser while the dynamic parts render. This decreases time to UI and may decrease total request time depending on how much of your UI is pre-rendered.\n+\n+<Image\n+  alt=\"Diagram showing parallelization of route segments during streaming, showing data fetching,rendering, and hydration of individual chunks.\"\n+  srcLight=\"/docs/light/sequential-parallel-data-fetching.png\"\n+  srcDark=\"/docs/dark/sequential-parallel-data-fetching.png\"\n+  width=\"1600\"\n+  height=\"525\"\n+/>\n+\n+To reduce network overhead, the full response, including static HTML and streamed dynamic parts, is sent in a **single HTTP request**. This avoids extra round-trips and improves both initial load and overall performance.\n+\n+## Using `use cache`\n+\n+While `Suspense` boundaries manage dynamic content, the [`use cache`](/docs/app/api-reference/directives/use-cache) directive is available for caching data or computations that don't change often.\n+\n+### Basic Usage\n+\n+Add `use cache` to cache a page, component, or async function, and define a lifetime with [`cacheLife`](/docs/app/api-reference/functions/cacheLife):\n+\n+```tsx filename=\"app/page.tsx\" highlight={1,4,5} switcher\n+import { cacheLife } from 'next/cache'\n+\n+export default async function Page() {\n+  'use cache'\n+  cacheLife('hours')\n+  // fetch or compute\n+  return <div>...</div>\n+}\n+```\n+\n+```jsx filename=\"app/page.js\" highlight={1,4,5} switcher\n+import { cacheLife } from 'next/cache'\n+\n+export default async function Page() {\n+  'use cache'\n+  cacheLife('hours')\n+  // fetch or compute\n+  return <div>...</div>\n+}\n+```\n+\n+### Caveats\n+\n+When using `use cache`, keep these constraints in mind:\n+\n+#### Arguments must be serializable\n+\n+Like Server Actions, arguments to cached functions must be serializable. This means you can pass primitives, plain objects, and arrays, but not class instances, functions, or other complex types.\n+\n+#### Accepting unserializable values without introspection\n+\n+You can accept unserializable values as arguments as long as you don't introspect them. However, you can return them. This allows patterns like cached components that accept Server or Client Components as children:\n+\n+```tsx filename=\"app/cached-wrapper.tsx\" switcher\n+import { ReactNode } from 'react'\n+\n+export async function CachedWrapper({ children }: { children: ReactNode }) {\n+  'use cache'\n+  // Don't introspect children, just pass it through\n+  return (\n+    <div className=\"wrapper\">\n+      <header>Cached Header</header>\n+      {children}\n+    </div>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/cached-wrapper.js\" switcher\n+export async function CachedWrapper({ children }) {\n+  'use cache'\n+  // Don't introspect children, just pass it through\n+  return (\n+    <div className=\"wrapper\">\n+      <header>Cached Header</header>\n+      {children}\n+    </div>\n+  )\n+}\n+```\n+\n+#### Avoid passing dynamic inputs\n+\n+You must not pass dynamic or runtime data into `use cache` functions unless you avoid introspecting them. Passing values from `cookies()`, `headers()`, or other runtime APIs as arguments will cause errors, as the cache key cannot be determined at pre-render time.\n+\n+### Tagging and Revalidating\n+\n+Tag cached data with [`cacheTag`](/docs/app/api-reference/functions/cacheTag) and revalidate it after mutations using [`updateTag`](/docs/app/api-reference/functions/updateTag) in Server Actions for immediate updates, or [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) delay in updates are acceptable.\n+\n+#### With `updateTag`\n+\n+Use `updateTag` when you need to expire and immediately refreshing cached data within the same request:\n+\n+```tsx filename=\"app/actions.ts\" highlight={1,4,5,13}\n+import { cacheTag, updateTag } from 'next/cache'\n+\n+export async function getCart() {\n+  'use cache'\n+  cacheTag('cart')\n+  // fetch data\n+}\n+\n+export async function updateCard(itemId: string) {\n+  'use server'\n+  // write data using the itemId\n+  // update the user cart\n+  updateTag('cart')\n+}\n+```\n+\n+#### With `revalidateTag`\n+\n+Use `revalidateTag` when you want to invalidate only properly tagged cached entries with stale-while-revalidate behavior. This is ideal for static content that can tolerate eventual consistency.\n+\n+```tsx filename=\"app/actions.ts\" highlight={1,4,5,12}\n+import { cacheTag, revalidateTag } from 'next/cache'\n+\n+export async function getPosts() {\n+  'use cache'\n+  cacheTag('posts')\n+  // fetch data\n+}\n+\n+export async function createPost(post: FormData) {\n+  'use server'\n+  // write data using the FormData\n+  revalidateTag('posts', 'max')\n+}\n+```\n+\n+For more detailed explanation and usage examples, see the [`use cache` API reference](/docs/app/api-reference/directives/use-cache).\n+\n+## Enabling Cache Components\n+\n+You can enable Cache Components (which includes PPR) by adding the [`cacheComponents`](/docs/app/api-reference/config/next-config-js/cacheComponents) option to your Next config file:\n+\n+```ts filename=\"next.config.ts\" highlight={4} switcher\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  cacheComponents: true,\n+}\n+\n+export default nextConfig\n+```\n+\n+```js filename=\"next.config.js\" highlight={3} switcher\n+/** @type {import('next').NextConfig} */\n+const nextConfig = {\n+  cacheComponents: true,\n+}\n+\n+module.exports = nextConfig\n+```\n+\n+### Effect on Route Segment Config\n+\n+When Cache Components is enabled, several route segment config options are no longer needed or supported. Here's what changes and how to migrate:\n+\n+#### `dynamic = \"force-dynamic\"`\n+\n+**Not needed.** All pages are dynamic by default with Cache Components enabled, so this configuration is unnecessary.\n+\n+```tsx\n+// Before - No longer needed\n+export const dynamic = 'force-dynamic'\n+\n+export default function Page() {\n+  return <div>...</div>\n+}\n+```\n+\n+```tsx\n+// After - Just remove it, pages are dynamic by default\n+export default function Page() {\n+  return <div>...</div>\n+}\n+```\n+\n+#### `dynamic = \"force-static\"`\n+\n+**Replace with `use cache`.** You must add `use cache` to each Layout and Page for the associated route instead.\n+\n+Note: `force-static` previously allowed the use of runtime APIs like `cookies()`, but this is no longer supported. If you add `use cache` and see an error related to runtime data, you must remove the use of runtime APIs.\n+\n+```tsx\n+// Before\n+export const dynamic = 'force-static'\n+\n+export default async function Page() {\n+  const data = await fetch('https://api.example.com/data')\n+  return <div>...</div>\n+}\n+```\n+\n+```tsx\n+// After - Use 'use cache' instead\n+export default async function Page() {\n+  'use cache'\n+  const data = await fetch('https://api.example.com/data')\n+  return <div>...</div>\n+}\n+```\n+\n+#### `revalidate`\n+\n+**Replace with `cacheLife`.** Use the `cacheLife` function to define cache duration instead of the route segment config.\n+\n+```tsx\n+// Before\n+export const revalidate = 3600 // 1 hour\n+\n+export default async function Page() {\n+  return <div>...</div>\n+}\n+```\n+\n+```tsx\n+// After - Use cacheLife\n+import { cacheLife } from 'next/cache'\n+\n+export default async function Page() {\n+  'use cache'\n+  cacheLife('hours')\n+  return <div>...</div>\n+}\n+```\n+\n+#### `fetchCache`\n+\n+**Not needed.** With `use cache`, all data fetching within a cached scope is automatically cached, making `fetchCache` unnecessary.\n+\n+```tsx\n+// Before\n+export const fetchCache = 'force-cache'\n+```\n+\n+```tsx\n+// After - Use 'use cache' to control caching behavior\n+export default async function Page() {\n+  'use cache'\n+  // All fetches here are cached\n+  return <div>...</div>\n+}\n+```\n+\n+## Before vs. After Cache Components\n+\n+Understanding how Cache Components changes your mental model:\n+\n+### Before Cache Components\n+\n+- **Static by default**: Next.js tried to pre-render and cache as much as possible for you unless you opted out\n+- **Route-level controls**: Switches like `dynamic`, `revalidate`, `fetchCache` controlled caching for the whole page\n+- **Limits of `fetch`**: Using `fetch` alone was incomplete, as it didn't cover direct database clients or other server-side IO. A nested `fetch` switching to dynamic (e.g., `{ cache: 'no-store' }`) could unintentionally change the entire route behavior\n+\n+### With Cache Components\n+\n+- **Dynamic by default**: Everything is dynamic by default. You decide which parts to cache by adding [`use cache`](/docs/app/api-reference/directives/use-cache) where it helps\n+- **Fine-grained control**: File/component/function-level [`use cache`](/docs/app/api-reference/directives/use-cache) and [`cacheLife`](/docs/app/api-reference/functions/cacheLife) control caching exactly where you need it\n+- **Streaming stays**: Use `<Suspense>` or a `loading.(js|tsx)` file to stream dynamic parts while the shell shows immediately\n+- **Beyond `fetch`**: Using the `use cache` directive caching can be applied to all server IO (database calls, APIs, computations), not just `fetch`. Nested `fetch` calls won't silently flip an entire route because behavior is governed by explicit cache boundaries and `Suspense`\n+\n+## Examples\n+\n+### Dynamic APIs\n+\n+When accessing runtime APIs like `cookies()`, Next.js will only pre-render the fallback UI above this component.\n+\n+In this example, we have no fallback defined, so Next.js shows an error instructing us to provide one. The `<User />` component needs to be wrapped in `Suspense` because it uses the `cookies` API:\n+\n+```jsx filename=\"app/user.js\" switcher\n+import { cookies } from 'next/headers'\n+\n+export async function User() {\n+  const session = (await cookies()).get('session')?.value\n+  return '...'\n+}\n+```\n+\n+```tsx filename=\"app/user.tsx\" switcher\n+import { cookies } from 'next/headers'\n+\n+export async function User() {\n+  const session = (await cookies()).get('session')?.value\n+  return '...'\n+}\n+```\n+\n+Now we have a `Suspense` boundary around our User component we can pre-render the Page with a Skeleton UI and stream in the `<User />` UI when a specific user makes a request\n+\n+```tsx filename=\"app/page.tsx\" switcher\n+import { Suspense } from 'react'\n+import { User, AvatarSkeleton } from './user'\n+\n+export default function Page() {\n+  return (\n+    <section>\n+      <h1>This will be pre-rendered</h1>\n+      <Suspense fallback={<AvatarSkeleton />}>\n+        <User />\n+      </Suspense>\n+    </section>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/page.js\" switcher\n+import { Suspense } from 'react'\n+import { User, AvatarSkeleton } from './user'\n+\n+export default function Page() {\n+  return (\n+    <section>\n+      <h1>This will be pre-rendered</h1>\n+      <Suspense fallback={<AvatarSkeleton />}>\n+        <User />\n+      </Suspense>\n+    </section>\n+  )\n+}\n+```\n+\n+### Passing dynamic props\n+\n+Components only opt into dynamic rendering when the value is accessed. For example, if you are reading `searchParams` from a `<Page />` component, you can forward this value to another component as a prop:\n+\n+```tsx filename=\"app/page.tsx\" switcher\n+import { Table, TableSkeleton } from './table'\n+import { Suspense } from 'react'\n+\n+export default function Page({\n+  searchParams,\n+}: {\n+  searchParams: Promise<{ sort: string }>\n+}) {\n+  return (\n+    <section>\n+      <h1>This will be pre-rendered</h1>\n+      <Suspense fallback={<TableSkeleton />}>\n+        <Table searchParams={searchParams.then((search) => search.sort)} />\n+      </Suspense>\n+    </section>\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/page.js\" switcher\n+import { Table, TableSkeleton } from './table'\n+import { Suspense } from 'react'\n+\n+export default function Page({ searchParams }) {\n+  return (\n+    <section>\n+      <h1>This will be pre-rendered</h1>\n+      <Suspense fallback={<TableSkeleton />}>\n+        <Table searchParams={searchParams.then((search) => search.sort)} />\n+      </Suspense>\n+    </section>\n+  )\n+}\n+```\n+\n+Inside of the table component, accessing the value from `searchParams` will make the component dynamic while the rest of the page will be pre-rendered.\n+\n+```tsx filename=\"app/table.tsx\" switcher\n+export async function Table({ sortPromise }: { sortPromise: Promise<string> }) {\n+  const sort = (await sortPromise) === 'true'\n+  return '...'\n+}\n+```\n+\n+```jsx filename=\"app/table.js\" switcher\n+export async function Table({ sortPromise }) {\n+  const sort = (await sortPromise) === 'true'\n+  return '...'\n+}\n+```\n+\n+## Frequently Asked Questions\n+\n+### Does this replace Partial Prerendering (PPR)?\n+\n+No. Cache Components **implements** PPR as a feature. The old experimental PPR flag has been removed but PPR is here to stay.\n+\n+PPR provides the static shell and streaming infrastructure; `use cache` lets you include optimized dynamic output in that shell when beneficial.\n+\n+### What should I cache first?\n+\n+What you cache should be a function of what you want your UI loading states to be. If data doesn't depend on runtime data and you're okay with a cached value being served for multiple requests over a period of time, use `use cache` with `cacheLife` to describe that behavior.\n+\n+For content management systems with update mechanisms, consider using tags with longer cache durations and rely on `revalidateTag` to mark static initial UI as ready for revalidation. This pattern allows you to serve fast, cached responses while still updating content when it actually changes, rather than expiring the cache preemptively.\n+\n+### How do I update cached content quickly?\n+\n+Use [`cacheTag`](/docs/app/api-reference/functions/cacheTag) to tag your cached data, then trigger [`updateTag`](/docs/app/api-reference/functions/updateTag) or [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)."
        },
        {
            "sha": "8d4b776330b47fcee82ec64120ddd615786eb11d",
            "filename": "docs/01-app/01-getting-started/06-partial-prerendering.mdx",
            "status": "removed",
            "additions": 0,
            "deletions": 280,
            "changes": 280,
            "blob_url": "https://github.com/vercel/next.js/blob/56136287eb8d937c7732797c31f3d3f8b67e54d4/docs%2F01-app%2F01-getting-started%2F06-partial-prerendering.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/56136287eb8d937c7732797c31f3d3f8b67e54d4/docs%2F01-app%2F01-getting-started%2F06-partial-prerendering.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F06-partial-prerendering.mdx?ref=56136287eb8d937c7732797c31f3d3f8b67e54d4",
            "patch": "@@ -1,280 +0,0 @@\n----\n-title: Partial Prerendering\n-description: Learn how to use Partial Prerendering and combine the benefits of static and dynamic rendering.\n-version: experimental\n-related:\n-  title: Next Steps\n-  description: Learn more about the config option for Partial Prerendering.\n-  links:\n-    - app/api-reference/config/next-config-js/ppr\n----\n-\n-Partial Prerendering (PPR) is a rendering strategy that allows you to combine static and dynamic content in the same route. This improves the initial page performance while still supporting personalized, dynamic data.\n-\n-<Image\n-  alt=\"Partially Prerendered Product Page showing static nav and product information, and dynamic cart and recommended products\"\n-  srcLight=\"/learn/light/thinking-in-ppr.png\"\n-  srcDark=\"/learn/dark/thinking-in-ppr.png\"\n-  width=\"1600\"\n-  height=\"632\"\n-/>\n-\n-When a user visits a route:\n-\n-- The server sends a **shell** containing the static content, ensuring a fast initial load.\n-- The shell leaves **holes** for the dynamic content that will load in asynchronously.\n-- The dynamic holes are **streamed in parallel**, reducing the overall load time of the page.\n-\n-> **ðŸŽ¥ Watch:** Why PPR and how it works â†’ [YouTube (10 minutes)](https://www.youtube.com/watch?v=MTcPrTIBkpA).\n-\n-## How does Partial Prerendering work?\n-\n-To understand Partial Prerendering, it helps to be familiar with the rendering strategies available in Next.js.\n-\n-### Static Rendering\n-\n-With Static Rendering, HTML is generated ahead of timeâ€”either at build time or through [revalidation](/docs/app/guides/incremental-static-regeneration). The result is cached and shared across users and requests.\n-\n-In Partial Prerendering, Next.js prerenders a **static shell** for a route. This can include the layout and any other components that don't depend on request-time data.\n-\n-### Dynamic Rendering\n-\n-With Dynamic Rendering, HTML is generated at **request time**. This allows you to serve personalized content based on request-time data.\n-\n-A component becomes dynamic if it uses the following APIs:\n-\n-- [`cookies`](/docs/app/api-reference/functions/cookies)\n-- [`headers`](/docs/app/api-reference/functions/headers)\n-- [`connection`](/docs/app/api-reference/functions/connection)\n-- [`draftMode`](/docs/app/api-reference/functions/draft-mode)\n-- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)\n-- [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)\n-- [`fetch`](/docs/app/api-reference/functions/fetch) with `{ cache: 'no-store' }`\n-\n-In Partial Prerendering, using these APIs throws a special React error that informs Next.js the component cannot be statically rendered, causing a build error. You can use a [Suspense](#suspense) boundary to wrap your component to defer rendering until runtime.\n-\n-### Suspense\n-\n-React [Suspense](https://react.dev/reference/react/Suspense) is used to defer rendering parts of your application until some condition is met.\n-\n-In Partial Prerendering, Suspense is used to mark **dynamic boundaries** in your component tree.\n-\n-At build time, Next.js prerenders the static content and the `fallback` UI. The dynamic content is **postponed** until the user requests the route.\n-\n-Wrapping a component in Suspense doesn't make the component itself dynamic (your API usage does), but rather Suspense is used as a boundary that encapsulates dynamic content and enable [streaming](#streaming)\n-\n-```jsx filename=\"app/page.js\"\n-import { Suspense } from 'react'\n-import StaticComponent from './StaticComponent'\n-import DynamicComponent from './DynamicComponent'\n-import Fallback from './Fallback'\n-\n-export const experimental_ppr = true\n-\n-export default function Page() {\n-  return (\n-    <>\n-      <StaticComponent />\n-      <Suspense fallback={<Fallback />}>\n-        <DynamicComponent />\n-      </Suspense>\n-    </>\n-  )\n-}\n-```\n-\n-### Streaming\n-\n-Streaming splits the route into chunks and progressively streams them to the client as they become ready. This allows the user to see parts of the page immediately, before the entire content has finished rendering.\n-\n-<Image\n-  alt=\"Diagram showing partially rendered page on the client, with loading UI for chunks that are being streamed.\"\n-  srcLight=\"/docs/light/server-rendering-with-streaming.png\"\n-  srcDark=\"/docs/dark/server-rendering-with-streaming.png\"\n-  width=\"1600\"\n-  height=\"785\"\n-/>\n-\n-In Partial Prerendering, dynamic components wrapped in Suspense start streaming from the server in parallel.\n-\n-<Image\n-  alt=\"Diagram showing parallelization of route segments during streaming, showing data fetching, rendering, and hydration of individual chunks.\"\n-  srcLight=\"/docs/light/sequential-parallel-data-fetching.png\"\n-  srcDark=\"/docs/dark/sequential-parallel-data-fetching.png\"\n-  width=\"1600\"\n-  height=\"525\"\n-/>\n-\n-To reduce network overhead, the full responseâ€”including static HTML and streamed dynamic partsâ€”is sent in a **single HTTP request**. This avoids extra roundtrips and improves both initial load and overall performance.\n-\n-## Enabling Partial Prerendering\n-\n-You can enable PPR by adding the [`ppr`](https://rc.nextjs.org/docs/app/api-reference/next-config-js/ppr) option to your `next.config.ts` file:\n-\n-```ts filename=\"next.config.ts\" highlight={5} switcher\n-import type { NextConfig } from 'next'\n-\n-const nextConfig: NextConfig = {\n-  experimental: {\n-    ppr: 'incremental',\n-  },\n-}\n-\n-export default nextConfig\n-```\n-\n-```js filename=\"next.config.js\" highlight={4} switcher\n-/** @type {import('next').NextConfig} */\n-const nextConfig = {\n-  experimental: {\n-    ppr: 'incremental',\n-  },\n-}\n-```\n-\n-The `'incremental'` value allows you to adopt PPR for specific routes:\n-\n-```tsx filename=\"/app/dashboard/layout.tsx\" switcher\n-export const experimental_ppr = true\n-\n-export default function Layout({ children }: { children: React.ReactNode }) {\n-  // ...\n-}\n-```\n-\n-```jsx filename=\"/app/dashboard/layout.jsx\" switcher\n-export const experimental_ppr = true\n-\n-export default function Layout({ children }) {\n-  // ...\n-}\n-```\n-\n-Routes that don't have `experimental_ppr` will default to `false` and will not be prerendered using PPR. You need to explicitly opt-in to PPR for each route.\n-\n-> **Good to know**:\n->\n-> - `experimental_ppr` will apply to all children of the route segment, including nested layouts and pages. You don't have to add it to every file, only the top segment of a route.\n-> - To disable PPR for children segments, you can set `experimental_ppr` to `false` in the child segment.\n-\n-## Examples\n-\n-### Dynamic APIs\n-\n-When using Dynamic APIs that require looking at the incoming request, Next.js will opt into dynamic rendering for the route. To continue using PPR, wrap the component with Suspense. For example, the `<User />` component is dynamic because it uses the `cookies` API:\n-\n-```jsx filename=\"app/user.js\" switcher\n-import { cookies } from 'next/headers'\n-\n-export async function User() {\n-  const session = (await cookies()).get('session')?.value\n-  return '...'\n-}\n-```\n-\n-```tsx filename=\"app/user.tsx\" switcher\n-import { cookies } from 'next/headers'\n-\n-export async function User() {\n-  const session = (await cookies()).get('session')?.value\n-  return '...'\n-}\n-```\n-\n-The `<User />` component will be streamed while any other content inside `<Page />` will be prerendered and become part of the static shell.\n-\n-```tsx filename=\"app/page.tsx\" switcher\n-import { Suspense } from 'react'\n-import { User, AvatarSkeleton } from './user'\n-\n-export const experimental_ppr = true\n-\n-export default function Page() {\n-  return (\n-    <section>\n-      <h1>This will be prerendered</h1>\n-      <Suspense fallback={<AvatarSkeleton />}>\n-        <User />\n-      </Suspense>\n-    </section>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/page.js\" switcher\n-import { Suspense } from 'react'\n-import { User, AvatarSkeleton } from './user'\n-\n-export const experimental_ppr = true\n-\n-export default function Page() {\n-  return (\n-    <section>\n-      <h1>This will be prerendered</h1>\n-      <Suspense fallback={<AvatarSkeleton />}>\n-        <User />\n-      </Suspense>\n-    </section>\n-  )\n-}\n-```\n-\n-### Passing dynamic props\n-\n-Components only opt into dynamic rendering when the value is accessed. For example, if you are reading `searchParams` from a `<Page />` component, you can forward this value to another component as a prop:\n-\n-```tsx filename=\"app/page.tsx\" switcher\n-import { Table, TableSkeleton } from './table'\n-import { Suspense } from 'react'\n-\n-export default function Page({\n-  searchParams,\n-}: {\n-  searchParams: Promise<{ sort: string }>\n-}) {\n-  return (\n-    <section>\n-      <h1>This will be prerendered</h1>\n-      <Suspense fallback={<TableSkeleton />}>\n-        <Table searchParams={searchParams} />\n-      </Suspense>\n-    </section>\n-  )\n-}\n-```\n-\n-```jsx filename=\"app/page.js\" switcher\n-import { Table, TableSkeleton } from './table'\n-import { Suspense } from 'react'\n-\n-export default function Page({ searchParams }) {\n-  return (\n-    <section>\n-      <h1>This will be prerendered</h1>\n-      <Suspense fallback={<TableSkeleton />}>\n-        <Table searchParams={searchParams} />\n-      </Suspense>\n-    </section>\n-  )\n-}\n-```\n-\n-Inside of the table component, accessing the value from `searchParams` will make the component dynamic while the rest of the page will be prerendered.\n-\n-```tsx filename=\"app/table.tsx\" switcher\n-export async function Table({\n-  searchParams,\n-}: {\n-  searchParams: Promise<{ sort: string }>\n-}) {\n-  const sort = (await searchParams).sort === 'true'\n-  return '...'\n-}\n-```\n-\n-```jsx filename=\"app/table.js\" switcher\n-export async function Table({ searchParams }) {\n-  const sort = (await searchParams).sort === 'true'\n-  return '...'\n-}\n-```"
        },
        {
            "sha": "f9c4ca256d820d62f78a92ab7f71b0bba901e5e5",
            "filename": "docs/01-app/01-getting-started/07-fetching-data.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F01-getting-started%2F07-fetching-data.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F01-getting-started%2F07-fetching-data.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F07-fetching-data.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -57,7 +57,7 @@ export default async function Page() {\n \n > **Good to know:**\n >\n-> - `fetch` responses are not cached by default. However, Next.js will [prerender](/docs/app/getting-started/partial-prerendering#static-rendering) the route and the output will be cached for improved performance. If you'd like to opt into [dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering), use the `{ cache: 'no-store' }` option. See the [`fetch` API Reference](/docs/app/api-reference/functions/fetch).\n+> - `fetch` responses are not cached by default. However, Next.js will [pre-render](/docs/app/guides/caching#static-rendering) the route and the output will be cached for improved performance. If you'd like to opt into [dynamic rendering](/docs/app/guides/caching#dynamic-rendering), use the `{ cache: 'no-store' }` option. See the [`fetch` API Reference](/docs/app/api-reference/functions/fetch).\n > - During development, you can log `fetch` calls for better visibility and debugging. See the [`logging` API reference](/docs/app/api-reference/config/next-config-js/logging).\n \n #### With an ORM or database\n@@ -273,7 +273,7 @@ export const getPost = cache(async (id) => {\n \n > **Warning:** The content below assumes the [`cacheComponents` config option](/docs/app/api-reference/config/next-config-js/cacheComponents) is enabled in your application. The flag was introduced in Next.js 15 canary.\n \n-When using `async/await` in Server Components, Next.js will opt into [dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering). This means the data will be fetched and rendered on the server for every user request. If there are any slow data requests, the whole route will be blocked from rendering.\n+When you fetch data in Server Components, the data is fetched and rendered on the server for each request. If you have any slow data requests, the whole route will be blocked from rendering until all the data is fetched.\n \n To improve the initial load time and user experience, you can use streaming to break up the page's HTML into smaller chunks and progressively send those chunks from the server to the client.\n "
        },
        {
            "sha": "b08e97a035f6df34fd618a4c5da7ac4561d43ea6",
            "filename": "docs/01-app/01-getting-started/09-caching-and-revalidating.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F01-getting-started%2F09-caching-and-revalidating.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F01-getting-started%2F09-caching-and-revalidating.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F09-caching-and-revalidating.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -38,7 +38,7 @@ export default async function Page() {\n }\n ```\n \n-> **Good to know**: Although `fetch` requests are not cached by default, Next.js will [prerender](/docs/app/getting-started/partial-prerendering#static-rendering) routes that have `fetch` requests and cache the HTML. If you want to guarantee a route is [dynamic](/docs/app/getting-started/partial-prerendering#dynamic-rendering), use the [`connection` API](/docs/app/api-reference/functions/connection).\n+> **Good to know**: Although `fetch` requests are not cached by default, Next.js will [pre-render](/docs/app/guides/caching#static-rendering) routes that have `fetch` requests and cache the HTML. If you want to guarantee a route is [dynamic](/docs/app/guides/caching#dynamic-rendering), use the [`connection` API](/docs/app/api-reference/functions/connection).\n \n To revalidate the data returned by a `fetch` request, you can use the `next.revalidate` option.\n "
        },
        {
            "sha": "b08e724d9a13379237478a7465b4bdb1c337ba1b",
            "filename": "docs/01-app/02-guides/caching.mdx",
            "status": "modified",
            "additions": 30,
            "deletions": 4,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fcaching.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fcaching.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fcaching.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -33,6 +33,32 @@ Caching behavior changes depending on whether the route is statically or dynamic\n \n Fetch caching is **not** supported in `proxy`. Any fetches done inside of your `proxy` will be uncached.\n \n+## Rendering Strategies\n+\n+To understand how caching works in Next.js, it's helpful to understand the rendering strategies available. The rendering strategy determines when your route's HTML is generated, which directly impacts what can be cached.\n+\n+### Static Rendering\n+\n+With Static Rendering, routes are rendered at **build time** or in the background after [data revalidation](/docs/app/guides/incremental-static-regeneration). The result is cached and can be reused across requests. Static routes are fully cached in the [Full Route Cache](#full-route-cache).\n+\n+### Dynamic Rendering\n+\n+With Dynamic Rendering, routes are rendered at **request time**. This happens when your route uses request-specific information like cookies, headers, or search params.\n+\n+A route becomes dynamic when it uses any of these APIs:\n+\n+- [`cookies`](/docs/app/api-reference/functions/cookies)\n+- [`headers`](/docs/app/api-reference/functions/headers)\n+- [`connection`](/docs/app/api-reference/functions/connection)\n+- [`draftMode`](/docs/app/api-reference/functions/draft-mode)\n+- [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional)\n+- [`unstable_noStore`](/docs/app/api-reference/functions/unstable_noStore)\n+- [`fetch`](/docs/app/api-reference/functions/fetch) with `{ cache: 'no-store' }`\n+\n+Dynamic routes are not cached in the Full Route Cache, but can still use the [Data Cache](#data-cache) for data requests.\n+\n+> **Good to know**: You can use [Cache Components](/docs/app/getting-started/cache-components) to mix static and dynamic rendering within the same route.\n+\n ## Request Memoization\n \n Next.js extends the [`fetch` API](#fetch) to automatically **memoize** requests that have the same URL and options. This means you can call a fetch function for the same data in multiple places in a React component tree while only executing it once.\n@@ -293,7 +319,7 @@ This diagram shows the difference between statically and dynamically rendered ro\n   height=\"1314\"\n />\n \n-Learn more about [static and dynamic rendering](/docs/app/getting-started/partial-prerendering#static-rendering).\n+Learn more about [static and dynamic rendering](#rendering-strategies).\n \n ### Duration\n \n@@ -335,7 +361,7 @@ With the Router Cache:\n The cache is stored in the browser's temporary memory. Two factors determine how long the router cache lasts:\n \n - **Session**: The cache persists across navigation. However, it's cleared on page refresh.\n-- **Automatic Invalidation Period**: The cache of layouts and loading states is automatically invalidated after a specific time. The duration depends on how the resource was [prefetched](/docs/app/api-reference/components/link#prefetch), and if the resource was [statically generated](/docs/app/getting-started/partial-prerendering#static-rendering):\n+- **Automatic Invalidation Period**: The cache of layouts and loading states is automatically invalidated after a specific time. The duration depends on how the resource was [prefetched](/docs/app/api-reference/components/link#prefetch), and if the resource was [statically generated](#static-rendering):\n   - **Default Prefetching** (`prefetch={null}` or unspecified): not cached for dynamic pages, 5 minutes for static pages.\n   - **Full Prefetching** (`prefetch={true}` or `router.prefetch`): 5 minutes for both static & dynamic pages.\n \n@@ -423,8 +449,8 @@ Data returned from `fetch` is _not_ automatically cached in the Data Cache.\n \n By default, when no `cache` or `next.revalidate` options are provided:\n \n-- [Dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering): Fetch runs on every request and always returns fresh data.\n-- [Static rendering](/docs/app/getting-started/partial-prerendering#static-rendering): Fetched data is stored in the [Data Cache](#data-cache), and the rendered output in the [Full Route Cache](#full-route-cache). Next.js serves this cached result until the path is revalidated.\n+- [Dynamic rendering](#dynamic-rendering): Fetch runs on every request and always returns fresh data.\n+- [Static rendering](#static-rendering): Fetched data is stored in the [Data Cache](#data-cache), and the rendered output in the [Full Route Cache](#full-route-cache). Next.js serves this cached result until the path is revalidated.\n \n See the [`fetch` API Reference](/docs/app/api-reference/functions/fetch) for more options.\n "
        },
        {
            "sha": "8b483e25a6e606c0019bbf8335469b6e8d14b4fb",
            "filename": "docs/01-app/02-guides/content-security-policy.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fcontent-security-policy.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fcontent-security-policy.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fcontent-security-policy.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -35,7 +35,7 @@ If an attacker wanted to load a script into your page, they'd need to guess the\n \n [Proxy](/docs/app/api-reference/file-conventions/proxy) enables you to add headers and generate nonces before the page renders.\n \n-Every time a page is viewed, a fresh nonce should be generated. This means that you **must use [dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering) to add nonces**.\n+Every time a page is viewed, a fresh nonce should be generated. This means that you **must use [dynamic rendering](/docs/app/guides/caching#dynamic-rendering) to add nonces**.\n \n For example:\n "
        },
        {
            "sha": "fc593d470a5d923056a061662d72b499ec7f80b8",
            "filename": "docs/01-app/02-guides/draft-mode.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fdraft-mode.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fdraft-mode.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fdraft-mode.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -9,7 +9,7 @@ related:\n     - app/api-reference/functions/draft-mode\n ---\n \n-**Draft Mode** allows you to preview draft content from your headless CMS in your Next.js application. This is useful for static pages that are generated at build time as it allows you to switch to [dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering) and see the draft changes without having to rebuild your entire site.\n+**Draft Mode** allows you to preview draft content from your headless CMS in your Next.js application. This is useful for static pages that are generated at build time as it allows you to switch to [dynamic rendering](/docs/app/guides/caching#dynamic-rendering) and see the draft changes without having to rebuild your entire site.\n \n This page walks through how to enable and use Draft Mode.\n "
        },
        {
            "sha": "678aae44aff0cbc66f3cd5749003aada3dc88618",
            "filename": "docs/01-app/02-guides/incremental-static-regeneration.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fincremental-static-regeneration.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fincremental-static-regeneration.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fincremental-static-regeneration.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -277,7 +277,7 @@ export default async function Page() {\n }\n ```\n \n-We recommend setting a high revalidation time. For instance, 1 hour instead of 1 second. If you need more precision, consider using on-demand revalidation. If you need real-time data, consider switching to [dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering).\n+We recommend setting a high revalidation time. For instance, 1 hour instead of 1 second. If you need more precision, consider using on-demand revalidation. If you need real-time data, consider switching to [dynamic rendering](/docs/app/guides/caching#dynamic-rendering).\n \n ### On-demand revalidation with `revalidatePath`\n \n@@ -573,7 +573,7 @@ This will make the Next.js server console log ISR cache hits and misses. You can\n - ISR is only supported when using the Node.js runtime (default).\n - ISR is not supported when creating a [Static Export](/docs/app/guides/static-exports).\n - If you have multiple `fetch` requests in a statically rendered route, and each has a different `revalidate` frequency, the lowest time will be used for ISR. However, those revalidate frequencies will still be respected by the [Data Cache](/docs/app/guides/caching#data-cache).\n-- If any of the `fetch` requests used on a route have a `revalidate` time of `0`, or an explicit `no-store`, the route will be [dynamically rendered](/docs/app/getting-started/partial-prerendering#dynamic-rendering).\n+- If any of the `fetch` requests used on a route have a `revalidate` time of `0`, or an explicit `no-store`, the route will be [dynamically rendered](/docs/app/guides/caching#dynamic-rendering).\n - Proxy won't be executed for on-demand ISR requests, meaning any path rewrites or logic in Proxy will not be applied. Ensure you are revalidating the exact path. For example, `/post/1` instead of a rewritten `/post-1`.\n \n </AppOnly>"
        },
        {
            "sha": "450cafbb7f69184cce225fd5f219e1b8c3359c9d",
            "filename": "docs/01-app/02-guides/migrating/app-router-migration.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fmigrating%2Fapp-router-migration.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fmigrating%2Fapp-router-migration.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fmigrating%2Fapp-router-migration.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -473,7 +473,7 @@ In addition, the new `useRouter` hook has the following changes:\n - The `locale`, `locales`, `defaultLocales`, `domainLocales` values have been removed because built-in i18n Next.js features are no longer necessary in the `app` directory. [Learn more about i18n](/docs/app/guides/internationalization).\n - `basePath` has been removed. The alternative will not be part of `useRouter`. It has not yet been implemented.\n - `asPath` has been removed because the concept of `as` has been removed from the new router.\n-- `isReady` has been removed because it is no longer necessary. During [static rendering](/docs/app/getting-started/partial-prerendering#static-rendering), any component that uses the [`useSearchParams()`](/docs/app/api-reference/functions/use-search-params) hook will skip the prerendering step and instead be rendered on the client at runtime.\n+- `isReady` has been removed because it is no longer necessary. During [static rendering](/docs/app/guides/caching#static-rendering), any component that uses the [`useSearchParams()`](/docs/app/api-reference/functions/use-search-params) hook will skip the prerendering step and instead be rendered on the client at runtime.\n - `route` has been removed. `usePathname` or `useSelectedLayoutSegments()` provide an alternative.\n \n [View the `useRouter()` API reference](/docs/app/api-reference/functions/use-router)."
        },
        {
            "sha": "baaa8324399fe1a44e2e8d806339e5834ca32e22",
            "filename": "docs/01-app/02-guides/prefetching.mdx",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fprefetching.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fprefetching.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fprefetching.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -23,11 +23,11 @@ When navigating to the new page, there's no full page reload or browser loading\n \n ## Prefetching static vs. dynamic routes\n \n-|                                                                   | **Static page** | **Dynamic page**                                                                                               |\n-| ----------------------------------------------------------------- | --------------- | -------------------------------------------------------------------------------------------------------------- |\n-| **Prefetched**                                                    | Yes, full route | No, unless [`loading.js`](/docs/app/api-reference/file-conventions/loading)                                    |\n-| [**Client Cache TTL**](/docs/app/guides/caching#full-route-cache) | 5 min (default) | Off, unless [enabled](/docs/app/api-reference/config/next-config-js/staleTimes)                                |\n-| **Server roundtrip on click**                                     | No              | Yes, streamed after [shell](/docs/app/getting-started/partial-prerendering#how-does-partial-prerendering-work) |\n+|                                                                   | **Static page** | **Dynamic page**                                                                |\n+| ----------------------------------------------------------------- | --------------- | ------------------------------------------------------------------------------- |\n+| **Prefetched**                                                    | Yes, full route | No, unless [`loading.js`](/docs/app/api-reference/file-conventions/loading)     |\n+| [**Client Cache TTL**](/docs/app/guides/caching#full-route-cache) | 5 min (default) | Off, unless [enabled](/docs/app/api-reference/config/next-config-js/staleTimes) |\n+| **Server roundtrip on click**                                     | No              | Yes, streamed after [shell](/docs/app/getting-started/cache-components)         |\n \n > **Good to know:** During the initial navigation, the browser fetches the HTML, JavaScript, and React Server Components (RSC) Payload. For subsequent navigations, the browser will fetch the RSC Payload for Server Components and JS bundle for Client Components.\n "
        },
        {
            "sha": "a467615ec594f58f8b334b5df3ea1af5bcae9c2a",
            "filename": "docs/01-app/02-guides/production-checklist.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fproduction-checklist.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fproduction-checklist.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fproduction-checklist.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -17,7 +17,7 @@ These Next.js optimizations are enabled by default and require no configuration:\n - **[Server Components](/docs/app/getting-started/server-and-client-components):** Next.js uses Server Components by default. Server Components run on the server, and don't require JavaScript to render on the client. As such, they have no impact on the size of your client-side JavaScript bundles. You can then use [Client Components](/docs/app/getting-started/server-and-client-components) as needed for interactivity.\n - **[Code-splitting](/docs/app/getting-started/linking-and-navigating#how-navigation-works):** Server Components enable automatic code-splitting by route segments. You may also consider [lazy loading](/docs/app/guides/lazy-loading) Client Components and third-party libraries, where appropriate.\n - **[Prefetching](/docs/app/getting-started/linking-and-navigating#prefetching):** When a link to a new route enters the user's viewport, Next.js prefetches the route in background. This makes navigation to new routes almost instant. You can opt out of prefetching, where appropriate.\n-- **[Static Rendering](/docs/app/getting-started/partial-prerendering#static-rendering):** Next.js statically renders Server and Client Components on the server at build time and caches the rendered result to improve your application's performance. You can opt into [Dynamic Rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering) for specific routes, where appropriate. {/* TODO: Update when PPR is stable */}\n+- **[Static Rendering](/docs/app/guides/caching#static-rendering):** Next.js statically renders Server and Client Components on the server at build time and caches the rendered result to improve your application's performance. You can opt into [Dynamic Rendering](/docs/app/guides/caching#dynamic-rendering) for specific routes, where appropriate. {/* TODO: Update when PPR is stable */}\n - **[Caching](/docs/app/guides/caching):** Next.js caches data requests, the rendered result of Server and Client Components, static assets, and more, to reduce the number of network requests to your server, database, and backend services. You may opt out of caching, where appropriate.\n \n </AppOnly>\n@@ -44,7 +44,7 @@ While building your application, we recommend using the following features to en\n - **[`<Link>` component](/docs/app/api-reference/components/link):** Use the `<Link>` component for [client-side navigation and prefetching](/docs/app/getting-started/linking-and-navigating#how-navigation-works).\n - **[Error Handling](/docs/app/getting-started/error-handling):** Gracefully handle [catch-all errors](/docs/app/getting-started/error-handling) and [404 errors](/docs/app/api-reference/file-conventions/not-found) in production by creating custom error pages.\n - **[Client and Server Components](/docs/app/getting-started/server-and-client-components#examples):** Follow the recommended composition patterns for Server and Client Components, and check the placement of your [`\"use client\"` boundaries](/docs/app/getting-started/server-and-client-components#examples#moving-client-components-down-the-tree) to avoid unnecessarily increasing your client-side JavaScript bundle.\n-- **[Dynamic APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering):** Be aware that Dynamic APIs like [`cookies`](/docs/app/api-reference/functions/cookies) and the [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) prop will opt the entire route into [Dynamic Rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering) (or your whole application if used in the [Root Layout](/docs/app/api-reference/file-conventions/layout#root-layout)). Ensure Dynamic API usage is intentional and wrap them in `<Suspense>` boundaries where appropriate.\n+- **[Dynamic APIs](/docs/app/guides/caching#dynamic-rendering):** Be aware that Dynamic APIs like [`cookies`](/docs/app/api-reference/functions/cookies) and the [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) prop will opt the entire route into [Dynamic Rendering](/docs/app/guides/caching#dynamic-rendering) (or your whole application if used in the [Root Layout](/docs/app/api-reference/file-conventions/layout#root-layout)). Ensure Dynamic API usage is intentional and wrap them in `<Suspense>` boundaries where appropriate.\n \n > **Good to know**: [Partial Prerendering (experimental)](/blog/next-14#partial-prerendering-preview) will allow parts of a route to be dynamic without opting the whole route into dynamic rendering.\n "
        },
        {
            "sha": "905bc42da2e6a2b9518d635f4f885af62e21963b",
            "filename": "docs/01-app/02-guides/self-hosting.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fself-hosting.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F02-guides%2Fself-hosting.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F02-guides%2Fself-hosting.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -208,9 +208,9 @@ module.exports = {\n }\n ```\n \n-## Partial Prerendering\n+## Cache Components\n \n-[Partial Prerendering (experimental)](/docs/app/getting-started/partial-prerendering) works by default with Next.js and is not a CDN-only feature. This includes deployment as a Node.js server (through `next start`) and when used with a Docker container.\n+[Cache Components](/docs/app/getting-started/cache-components) works by default with Next.js and is not a CDN-only feature. This includes deployment as a Node.js server (through `next start`) and when used with a Docker container.\n \n ## Usage with CDNs\n "
        },
        {
            "sha": "77c156f61fb56e295d936679d427c7af6176630a",
            "filename": "docs/01-app/03-api-reference/01-directives/use-cache.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -105,7 +105,7 @@ The return value of the cacheable function must be serializable. This ensures th\n \n When used at the top of a [layout](/docs/app/api-reference/file-conventions/layout) or [page](/docs/app/api-reference/file-conventions/page), the route segment will be prerendered, allowing it to later be [revalidated](#during-revalidation).\n \n-This means `use cache` cannot be used with [request-time APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering) like `cookies` or `headers`.\n+This means `use cache` cannot be used with [runtime data](/docs/app/getting-started/cache-components#1-suspense-for-runtime-data) like `cookies` or `headers`.\n \n > **Note:** If you need to cache content that depends on cookies, headers, or search params, use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead.\n \n@@ -187,7 +187,7 @@ export default function Page() {\n > **Good to know**:\n >\n > - If `use cache` is added only to the `layout` or the `page`, only that route segment and any components imported into it will be cached.\n-> - If any of the nested children in the route use [Dynamic APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering), then the route will opt out of prerendering.\n+> - If any of the nested children in the route use [Dynamic APIs](/docs/app/guides/caching#dynamic-rendering), then the route will opt out of pre-rendering.\n \n ### Caching a component's output with `use cache`\n "
        },
        {
            "sha": "06f62859a4c266baa503c018dc81af2d1fc7ada6",
            "filename": "docs/01-app/03-api-reference/03-file-conventions/01-metadata/app-icons.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2F01-metadata%2Fapp-icons.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2F01-metadata%2Fapp-icons.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2F01-metadata%2Fapp-icons.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -166,7 +166,7 @@ export default function Icon() {\n \n > **Good to know**:\n >\n-> - By default, generated icons are [**statically optimized**](/docs/app/getting-started/partial-prerendering#static-rendering) (generated at build time and cached) unless they use [Dynamic APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering#dynamic-apis) or uncached data.\n+> - By default, generated icons are [**statically optimized**](/docs/app/guides/caching#static-rendering) (generated at build time and cached) unless they use [Dynamic APIs](/docs/app/guides/caching#dynamic-rendering) or uncached data.\n > - You can generate multiple icons in the same file using [`generateImageMetadata`](/docs/app/api-reference/functions/generate-image-metadata).\n > - You cannot generate a `favicon` icon. Use [`icon`](#icon) or a [favicon.ico](#favicon) file instead.\n > - App icons are special Route Handlers that are cached by default unless they use a [Dynamic API](/docs/app/guides/caching#dynamic-apis) or [dynamic config](/docs/app/guides/caching#segment-config-options) option."
        },
        {
            "sha": "b898b1f0aa3ea80a2461c04cc72dc787427d8da9",
            "filename": "docs/01-app/03-api-reference/03-file-conventions/01-metadata/opengraph-image.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2F01-metadata%2Fopengraph-image.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2F01-metadata%2Fopengraph-image.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2F01-metadata%2Fopengraph-image.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -88,7 +88,7 @@ Generate a route segment's shared image by creating an `opengraph-image` or `twi\n \n > **Good to know**:\n >\n-> - By default, generated images are [**statically optimized**](/docs/app/getting-started/partial-prerendering#static-rendering) (generated at build time and cached) unless they use [Dynamic APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering#dynamic-apis) or uncached data.\n+> - By default, generated images are [**statically optimized**](/docs/app/guides/caching#static-rendering) (generated at build time and cached) unless they use [Dynamic APIs](/docs/app/guides/caching#dynamic-rendering) or uncached data.\n > - You can generate multiple Images in the same file using [`generateImageMetadata`](/docs/app/api-reference/functions/generate-image-metadata).\n > - `opengraph-image.js` and `twitter-image.js` are special Route Handlers that is cached by default unless it uses a [Dynamic API](/docs/app/guides/caching#dynamic-apis) or [dynamic config](/docs/app/guides/caching#segment-config-options) option.\n \n@@ -330,7 +330,7 @@ export default function Image() {}\n This example uses the `params` object and external data to generate the image.\n \n > **Good to know**:\n-> By default, this generated image will be [statically optimized](/docs/app/getting-started/partial-prerendering#static-rendering). You can configure the individual `fetch` [`options`](/docs/app/api-reference/functions/fetch) or route segments [options](/docs/app/api-reference/file-conventions/route-segment-config#revalidate) to change this behavior.\n+> By default, this generated image will be [statically optimized](/docs/app/guides/caching#static-rendering). You can configure the individual `fetch` [`options`](/docs/app/api-reference/functions/fetch) or route segments [options](/docs/app/api-reference/file-conventions/route-segment-config#revalidate) to change this behavior.\n \n ```tsx filename=\"app/posts/[slug]/opengraph-image.tsx\" switcher\n import { ImageResponse } from 'next/og'"
        },
        {
            "sha": "27e84fe4fd17fb101c1f1a3235b72fcd164f404f",
            "filename": "docs/01-app/03-api-reference/03-file-conventions/dynamic-routes.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Fdynamic-routes.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Fdynamic-routes.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Fdynamic-routes.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -149,7 +149,7 @@ export default async function Page(props: PageProps<'/[locale]'>) {\n \n ### With `generateStaticParams`\n \n-The [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params) function can be used to [statically generate](/docs/app/getting-started/partial-prerendering#static-rendering) routes at build time instead of on-demand at request time.\n+The [`generateStaticParams`](/docs/app/api-reference/functions/generate-static-params) function can be used to [statically generate](/docs/app/guides/caching#static-rendering) routes at build time instead of on-demand at request time.\n \n ```tsx filename=\"app/blog/[slug]/page.tsx\" switcher\n export async function generateStaticParams() {"
        },
        {
            "sha": "b05c0bda90c775602261b51f979e0006737c16f4",
            "filename": "docs/01-app/03-api-reference/03-file-conventions/page.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Fpage.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Fpage.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Fpage.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -115,7 +115,7 @@ export default function Page({ searchParams }) {\n \n - Since the `searchParams` prop is a promise. You must use `async/await` or React's [`use`](https://react.dev/reference/react/use) function to access the values.\n   - In version 14 and earlier, `searchParams` was a synchronous prop. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n-- `searchParams` is a **[Dynamic API](/docs/app/getting-started/partial-prerendering#dynamic-rendering)** whose values cannot be known ahead of time. Using it will opt the page into **[dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering)** at request time.\n+- `searchParams` is a **[Dynamic API](/docs/app/guides/caching#dynamic-rendering)** whose values cannot be known ahead of time. Using it will opt the page into **[dynamic rendering](/docs/app/guides/caching#dynamic-rendering)** at request time.\n - `searchParams` is a plain JavaScript object, not a `URLSearchParams` instance.\n \n ### Page Props Helper"
        },
        {
            "sha": "63f4bd36ca3cbe947e01b5982da7675835b58bf4",
            "filename": "docs/01-app/03-api-reference/03-file-conventions/parallel-routes.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Fparallel-routes.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Fparallel-routes.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Fparallel-routes.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -66,7 +66,7 @@ export default function Layout({ children, team, analytics }) {\n }\n ```\n \n-However, slots are **not** route segments and do not affect the URL structure. For example, for `/@analytics/views`, the URL will be `/views` since `@analytics` is a slot. Slots are combined with the regular [Page](/docs/app/api-reference/file-conventions/page) component to form the final page associated with the route segment. Because of this, you cannot have separate [static](/docs/app/getting-started/partial-prerendering#static-rendering) and [dynamic](/docs/app/getting-started/partial-prerendering#dynamic-rendering) slots at the same route segment level. If one slot is dynamic, all slots at that level must be dynamic.\n+However, slots are **not** route segments and do not affect the URL structure. For example, for `/@analytics/views`, the URL will be `/views` since `@analytics` is a slot. Slots are combined with the regular [Page](/docs/app/api-reference/file-conventions/page) component to form the final page associated with the route segment. Because of this, you cannot have separate [static](/docs/app/guides/caching#static-rendering) and [dynamic](/docs/app/guides/caching#dynamic-rendering) slots at the same route segment level. If one slot is dynamic, all slots at that level must be dynamic.\n \n > **Good to know**:\n >"
        },
        {
            "sha": "742573c283502f39dd7f1c5fb1714e8af551d07d",
            "filename": "docs/01-app/03-api-reference/03-file-conventions/route-segment-config.mdx",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Froute-segment-config.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Froute-segment-config.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F03-file-conventions%2Froute-segment-config.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -40,11 +40,11 @@ export const dynamic = 'auto'\n > **Good to know**: The new model in the `app` directory favors granular caching control at the `fetch` request level over the binary all-or-nothing model of `getServerSideProps` and `getStaticProps` at the page-level in the `pages` directory. The `dynamic` option is a way to opt back in to the previous model as a convenience and provides a simpler migration path.\n \n - **`'auto'`** (default): The default option to cache as much as possible without preventing any components from opting into dynamic behavior.\n-- **`'force-dynamic'`**: Force [dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering), which will result in routes being rendered for each user at request time. This option is equivalent to:\n+- **`'force-dynamic'`**: Force [dynamic rendering](/docs/app/guides/caching#dynamic-rendering), which will result in routes being rendered for each user at request time. This option is equivalent to:\n   - Setting the option of every `fetch()` request in a layout or page to `{ cache: 'no-store', next: { revalidate: 0 } }`.\n   - Setting the segment config to `export const fetchCache = 'force-no-store'`\n \n-- **`'error'`**: Force static rendering and cache the data of a layout or page by causing an error if any components use [Dynamic APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering) or uncached data. This option is equivalent to:\n+- **`'error'`**: Force static rendering and cache the data of a layout or page by causing an error if any components use [Dynamic APIs](/docs/app/guides/caching#dynamic-rendering) or uncached data. This option is equivalent to:\n   - `getStaticProps()` in the `pages` directory.\n   - Setting the option of every `fetch()` request in a layout or page to `{ cache: 'force-cache' }`.\n   - Setting the segment config to `fetchCache = 'only-cache'`.\n@@ -89,8 +89,8 @@ export const revalidate = false\n // false | 0 | number\n ```\n \n-- **`false`** (default): The default heuristic to cache any `fetch` requests that set their `cache` option to `'force-cache'` or are discovered before a [Dynamic API](/docs/app/getting-started/partial-prerendering#dynamic-rendering#dynamic-apis) is used. Semantically equivalent to `revalidate: Infinity` which effectively means the resource should be cached indefinitely. It is still possible for individual `fetch` requests to use `cache: 'no-store'` or `revalidate: 0` to avoid being cached and make the route dynamically rendered. Or set `revalidate` to a positive number lower than the route default to increase the revalidation frequency of a route.\n-- **`0`**: Ensure a layout or page is always [dynamically rendered](/docs/app/getting-started/partial-prerendering#dynamic-rendering) even if no Dynamic APIs or uncached data fetches are discovered. This option changes the default of `fetch` requests that do not set a `cache` option to `'no-store'` but leaves `fetch` requests that opt into `'force-cache'` or use a positive `revalidate` as is.\n+- **`false`** (default): The default heuristic to cache any `fetch` requests that set their `cache` option to `'force-cache'` or are discovered before a [Dynamic API](/docs/app/guides/caching#dynamic-rendering) is used. Semantically equivalent to `revalidate: Infinity` which effectively means the resource should be cached indefinitely. It is still possible for individual `fetch` requests to use `cache: 'no-store'` or `revalidate: 0` to avoid being cached and make the route dynamically rendered. Or set `revalidate` to a positive number lower than the route default to increase the revalidation frequency of a route.\n+- **`0`**: Ensure a layout or page is always [dynamically rendered](/docs/app/guides/caching#dynamic-rendering) even if no Dynamic APIs or uncached data fetches are discovered. This option changes the default of `fetch` requests that do not set a `cache` option to `'no-store'` but leaves `fetch` requests that opt into `'force-cache'` or use a positive `revalidate` as is.\n - **`number`**: (in seconds) Set the default revalidation frequency of a layout or page to `n` seconds.\n \n > **Good to know**:\n@@ -109,7 +109,7 @@ export const revalidate = false\n <details>\n   <summary>This is an advanced option that should only be used if you specifically need to override the default behavior.</summary>\n \n-By default, Next.js **will cache** any `fetch()` requests that are reachable **before** any [Dynamic APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering#dynamic-apis) are used and **will not cache** `fetch` requests that are discovered **after** Dynamic APIs are used.\n+By default, Next.js **will cache** any `fetch()` requests that are reachable **before** any [Dynamic APIs](/docs/app/guides/caching#dynamic-rendering) are used and **will not cache** `fetch` requests that are discovered **after** Dynamic APIs are used.\n \n `fetchCache` allows you to override the default `cache` option of all `fetch` requests in a layout or page.\n "
        },
        {
            "sha": "6ff8ec63c58c4651bb9a10e34baa3c93ea1f74b0",
            "filename": "docs/01-app/03-api-reference/04-functions/after.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fafter.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fafter.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2Fafter.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -37,7 +37,7 @@ export default function Layout({ children }) {\n }\n ```\n \n-> **Good to know:** `after` is not a [Dynamic API](/docs/app/getting-started/partial-prerendering#dynamic-rendering) and calling it does not cause a route to become dynamic. If it's used within a static page, the callback will execute at build time, or whenever a page is revalidated.\n+> **Good to know:** `after` is not a [Dynamic API](/docs/app/guides/caching#dynamic-rendering) and calling it does not cause a route to become dynamic. If it's used within a static page, the callback will execute at build time, or whenever a page is revalidated.\n \n ## Reference\n \n@@ -111,7 +111,7 @@ export async function POST(request) {\n }\n ```\n \n-However, you cannot use these request APIs inside `after` in [Server Components](/docs/app/getting-started/server-and-client-components). This is because Next.js needs to know which part of the tree access the request APIs to support [Partial Prerendering](/docs/app/getting-started/partial-prerendering), but `after` runs after React's rendering lifecycle.\n+However, you cannot use these request APIs inside `after` in [Server Components](/docs/app/getting-started/server-and-client-components). This is because Next.js needs to know which part of the tree access the request APIs to support [Cache Components](/docs/app/getting-started/cache-components), but `after` runs after React's rendering lifecycle.\n \n ## Platform Support\n "
        },
        {
            "sha": "9168f06bd7e363a5ad0d6ea448956970fb7db02b",
            "filename": "docs/01-app/03-api-reference/04-functions/connection.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fconnection.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fconnection.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2Fconnection.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -5,7 +5,7 @@ description: API Reference for the connection function.\n \n The `connection()` function allows you to indicate rendering should wait for an incoming user request before continuing.\n \n-It's useful when a component doesnâ€™t use [Dynamic APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering), but you want it to be dynamically rendered at runtime and not statically rendered at build time. This usually occurs when you access external information that you intentionally want to change the result of a render, such as `Math.random()` or `new Date()`.\n+It's useful when a component doesn't use [Dynamic APIs](/docs/app/guides/caching#dynamic-rendering), but you want it to be dynamically rendered at runtime and not statically rendered at build time. This usually occurs when you access external information that you intentionally want to change the result of a render, such as `Math.random()` or `new Date()`.\n \n ```ts filename=\"app/page.tsx\" switcher\n import { connection } from 'next/server'"
        },
        {
            "sha": "b161c006ed938a8fca44e2312127124b24750d31",
            "filename": "docs/01-app/03-api-reference/04-functions/cookies.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fcookies.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fcookies.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2Fcookies.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -67,7 +67,7 @@ To learn more about these options, see the [MDN docs](https://developer.mozilla.\n \n - `cookies` is an **asynchronous** function that returns a promise. You must use `async/await` or React's [`use`](https://react.dev/reference/react/use) function to access cookies.\n   - In version 14 and earlier, `cookies` was a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n-- `cookies` is a [Dynamic API](/docs/app/getting-started/partial-prerendering#dynamic-rendering) whose returned values cannot be known ahead of time. Using it in a layout or page will opt a route into [dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering).\n+- `cookies` is a [Dynamic API](/docs/app/guides/caching#dynamic-rendering) whose returned values cannot be known ahead of time. Using it in a layout or page will opt a route into [dynamic rendering](/docs/app/guides/caching#dynamic-rendering).\n - The `.delete` method can only be called:\n   - In a [Server Action](/docs/app/getting-started/updating-data) or [Route Handler](/docs/app/api-reference/file-conventions/route).\n   - If it belongs to the same domain from which `.set` is called. For wildcard domains, the specific subdomain must be an exact match. Additionally, the code must be executed on the same protocol (HTTP or HTTPS) as the cookie you want to delete."
        },
        {
            "sha": "e0a00eb161099706c184329763ef233f6a717362",
            "filename": "docs/01-app/03-api-reference/04-functions/fetch.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Ffetch.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Ffetch.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2Ffetch.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -49,7 +49,7 @@ Configure how the request should interact with Next.js [Data Cache](/docs/app/gu\n fetch(`https://...`, { cache: 'force-cache' | 'no-store' })\n ```\n \n-- **`auto no cache`** (default): Next.js fetches the resource from the remote server on every request in development, but will fetch once during `next build` because the route will be statically prerendered. If [Dynamic APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering) are detected on the route, Next.js will fetch the resource on every request.\n+- **`auto no cache`** (default): Next.js fetches the resource from the remote server on every request in development, but will fetch once during `next build` because the route will be statically prerendered. If [Dynamic APIs](/docs/app/guides/caching#dynamic-rendering) are detected on the route, Next.js will fetch the resource on every request.\n - **`no-store`**: Next.js fetches the resource from the remote server on every request, even if Dynamic APIs are not detected on the route.\n - **`force-cache`**: Next.js looks for a matching request in its Data Cache.\n   - If there is a match and it is fresh, it will be returned from the cache."
        },
        {
            "sha": "aecceb326115f526b494444e9edffdc4f129ee24",
            "filename": "docs/01-app/03-api-reference/04-functions/generate-static-params.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fgenerate-static-params.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fgenerate-static-params.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2Fgenerate-static-params.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -3,7 +3,7 @@ title: generateStaticParams\n description: API reference for the generateStaticParams function.\n ---\n \n-The `generateStaticParams` function can be used in combination with [dynamic route segments](/docs/app/api-reference/file-conventions/dynamic-routes) to [**statically generate**](/docs/app/getting-started/partial-prerendering#static-rendering) routes at build time instead of on-demand at request time.\n+The `generateStaticParams` function can be used in combination with [dynamic route segments](/docs/app/api-reference/file-conventions/dynamic-routes) to [**statically generate**](/docs/app/guides/caching#static-rendering) routes at build time instead of on-demand at request time.\n \n ```tsx filename=\"app/blog/[slug]/page.tsx\" switcher\n // Return a list of `params` to populate the [slug] dynamic segment"
        },
        {
            "sha": "f0e0dda6cbc169698b4025b8cce78ae3948e2964",
            "filename": "docs/01-app/03-api-reference/04-functions/headers.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fheaders.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fheaders.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2Fheaders.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -45,7 +45,7 @@ export default async function Page() {\n - `headers` is an **asynchronous** function that returns a promise. You must use `async/await` or React's [`use`](https://react.dev/reference/react/use) function.\n   - In version 14 and earlier, `headers` was a synchronous function. To help with backwards compatibility, you can still access it synchronously in Next.js 15, but this behavior will be deprecated in the future.\n - Since `headers` is read-only, you cannot `set` or `delete` the outgoing request headers.\n-- `headers` is a [Dynamic API](/docs/app/getting-started/partial-prerendering#dynamic-rendering#dynamic-apis) whose returned values cannot be known ahead of time. Using it in will opt a route into **[dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering)**.\n+- `headers` is a [Dynamic API](/docs/app/guides/caching#dynamic-rendering) whose returned values cannot be known ahead of time. Using it in will opt a route into **[dynamic rendering](/docs/app/guides/caching#dynamic-rendering)**.\n \n ## Examples\n "
        },
        {
            "sha": "7603c1159139aeb797231321ae92413ed4b0a8cf",
            "filename": "docs/01-app/03-api-reference/04-functions/use-router.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fuse-router.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fuse-router.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2Fuse-router.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -112,7 +112,7 @@ export default function Layout({ children }) {\n }\n ```\n \n-> **Good to know**: `<NavigationEvents>` is wrapped in a [`Suspense` boundary](/docs/app/api-reference/file-conventions/loading#examples) because[`useSearchParams()`](/docs/app/api-reference/functions/use-search-params) causes client-side rendering up to the closest `Suspense` boundary during [static rendering](/docs/app/getting-started/partial-prerendering#static-rendering). [Learn more](/docs/app/api-reference/functions/use-search-params#behavior).\n+> **Good to know**: `<NavigationEvents>` is wrapped in a [`Suspense` boundary](/docs/app/api-reference/file-conventions/loading#examples) because[`useSearchParams()`](/docs/app/api-reference/functions/use-search-params) causes client-side rendering up to the closest `Suspense` boundary during [static rendering](/docs/app/guides/caching#static-rendering). [Learn more](/docs/app/api-reference/functions/use-search-params#behavior).\n \n ### Disabling scroll to top\n "
        },
        {
            "sha": "189263b7ae1cb7865276b69150afd44816ee2edd",
            "filename": "docs/01-app/03-api-reference/04-functions/use-search-params.mdx",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fuse-search-params.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F04-functions%2Fuse-search-params.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2Fuse-search-params.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -79,7 +79,7 @@ const searchParams = useSearchParams()\n \n ### Static Rendering\n \n-If a route is [statically rendered](/docs/app/getting-started/partial-prerendering#static-rendering), calling `useSearchParams` will cause the Client Component tree up to the closest [`Suspense` boundary](/docs/app/api-reference/file-conventions/loading#examples) to be client-side rendered.\n+If a route is [statically rendered](/docs/app/guides/caching#static-rendering), calling `useSearchParams` will cause the Client Component tree up to the closest [`Suspense` boundary](/docs/app/api-reference/file-conventions/loading#examples) to be client-side rendered.\n \n This allows a part of the route to be statically rendered while the dynamic part that uses `useSearchParams` is client-side rendered.\n \n@@ -176,14 +176,14 @@ export default function Page() {\n > **Good to know**:\n >\n > - In development, routes are rendered on-demand, so `useSearchParams` doesn't suspend and things may appear to work without `Suspense`.\n-> - During production builds, a [static page](/docs/app/getting-started/partial-prerendering#static-rendering) that calls `useSearchParams` from a Client Component must be wrapped in a `Suspense` boundary, otherwise the build fails with the [Missing Suspense boundary with useSearchParams](/docs/messages/missing-suspense-with-csr-bailout) error.\n-> - If you intend the route to be dynamically rendered, prefer using the [`connection`](/docs/app/api-reference/functions/connection) function first in a Server Component to wait for an incoming request, this excludes everything below from prerendering. See what makes a route dynamic in the [Dynamic Rendering guide](/docs/app/getting-started/partial-prerendering#dynamic-rendering).\n+> - During production builds, a [static page](/docs/app/guides/caching#static-rendering) that calls `useSearchParams` from a Client Component must be wrapped in a `Suspense` boundary, otherwise the build fails with the [Missing Suspense boundary with useSearchParams](/docs/messages/missing-suspense-with-csr-bailout) error.\n+> - If you intend the route to be dynamically rendered, prefer using the [`connection`](/docs/app/api-reference/functions/connection) function first in a Server Component to wait for an incoming request, this excludes everything below from prerendering. See what makes a route dynamic in the [Dynamic Rendering guide](/docs/app/guides/caching#dynamic-rendering).\n > - If you're already in a Server Component Page, consider using the [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional) and passing the values to Client Components.\n > - You can also pass the Page [`searchParams` prop](/docs/app/api-reference/file-conventions/page#searchparams-optional) directly to a Client Component and unwrap it with React's `use()`. Although this will suspend, so the Client Component should be wrapped with a `Suspense` boundary.\n \n ### Dynamic Rendering\n \n-If a route is [dynamically rendered](/docs/app/getting-started/partial-prerendering#dynamic-rendering), `useSearchParams` will be available on the server during the initial server render of the Client Component.\n+If a route is [dynamically rendered](/docs/app/guides/caching#dynamic-rendering), `useSearchParams` will be available on the server during the initial server render of the Client Component.\n \n For example:\n "
        },
        {
            "sha": "e89ef128de6e300d147464b7f2c0a364e27c8693",
            "filename": "docs/01-app/03-api-reference/05-config/01-next-config-js/devIndicators.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FdevIndicators.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FdevIndicators.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FdevIndicators.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -22,7 +22,7 @@ Setting `devIndicators` to `false` will hide the indicator, however Next.js will\n \n If you expect a route to be static and the indicator has marked it as dynamic, it's likely the route has opted out of static rendering.\n \n-You can confirm if a route is [static](/docs/app/getting-started/partial-prerendering#static-rendering) or [dynamic](/docs/app/getting-started/partial-prerendering#dynamic-rendering) by building your application using `next build --debug`, and checking the output in your terminal. Static (or prerendered) routes will display a `â—‹` symbol, whereas dynamic routes will display a `Æ’` symbol. For example:\n+You can confirm if a route is [static](/docs/app/guides/caching#static-rendering) or [dynamic](/docs/app/guides/caching#dynamic-rendering) by building your application using `next build --debug`, and checking the output in your terminal. Static (or prerendered) routes will display a `â—‹` symbol, whereas dynamic routes will display a `Æ’` symbol. For example:\n \n ```bash filename=\"Build Output\"\n Route (app)\n@@ -37,7 +37,7 @@ Route (app)\n \n There are two reasons a route might opt out of static rendering:\n \n-- The presence of [Dynamic APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering) which rely on runtime information.\n+- The presence of [Dynamic APIs](/docs/app/guides/caching#dynamic-rendering) which rely on runtime information.\n - An [uncached data request](/docs/app/getting-started/fetching-data), like a call to an ORM or database driver.\n \n Check your route for any of these conditions, and if you are not able to statically render the route, then consider using [`loading.js`](/docs/app/api-reference/file-conventions/loading) or [`<Suspense />`](https://react.dev/reference/react/Suspense) to leverage [streaming](/docs/app/getting-started/linking-and-navigating#streaming)."
        },
        {
            "sha": "02ec900156f19628cff1728a4542e50582df690e",
            "filename": "docs/01-app/03-api-reference/05-config/01-next-config-js/ppr.mdx",
            "status": "removed",
            "additions": 0,
            "deletions": 87,
            "changes": 87,
            "blob_url": "https://github.com/vercel/next.js/blob/56136287eb8d937c7732797c31f3d3f8b67e54d4/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2Fppr.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/56136287eb8d937c7732797c31f3d3f8b67e54d4/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2Fppr.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2Fppr.mdx?ref=56136287eb8d937c7732797c31f3d3f8b67e54d4",
            "patch": "@@ -1,87 +0,0 @@\n----\n-title: ppr\n-description: Learn how to enable Partial Prerendering in Next.js.\n-version: canary\n-related:\n-  title: Learn more about Partial Prerendering\n-  links:\n-    - app/getting-started/partial-prerendering\n----\n-\n-Partial Prerendering (PPR) enables you to combine static and dynamic components together in the same route. Learn more about [PPR](/docs/app/getting-started/partial-prerendering).\n-\n-## Using Partial Prerendering\n-\n-### Incremental Adoption (Version 15)\n-\n-In Next.js 15, you can incrementally adopt Partial Prerendering in [layouts](/docs/app/api-reference/file-conventions/layout) and [pages](/docs/app/api-reference/file-conventions/page) by setting the [`ppr`](/docs/app/api-reference/config/next-config-js/ppr) option in `next.config.js` to `incremental`, and exporting the `experimental_ppr` [route config option](/docs/app/api-reference/file-conventions/route-segment-config) at the top of the file:\n-\n-```ts filename=\"next.config.ts\" switcher\n-import type { NextConfig } from 'next'\n-\n-const nextConfig: NextConfig = {\n-  experimental: {\n-    ppr: 'incremental',\n-  },\n-}\n-\n-export default nextConfig\n-```\n-\n-```js filename=\"next.config.js\" switcher\n-/** @type {import('next').NextConfig} */\n-const nextConfig = {\n-  experimental: {\n-    ppr: 'incremental',\n-  },\n-}\n-\n-module.exports = nextConfig\n-```\n-\n-```tsx filename=\"app/page.tsx\" switcher\n-import { Suspense } from \"react\"\n-import { StaticComponent, DynamicComponent, Fallback } from \"@/app/ui\"\n-\n-export const experimental_ppr = true\n-\n-export default function Page() {\n-  return {\n-     <>\n-      <StaticComponent />\n-      <Suspense fallback={<Fallback />}>\n-        <DynamicComponent />\n-      </Suspense>\n-     </>\n-  };\n-}\n-```\n-\n-```jsx filename=\"app/page.js\" switcher\n-import { Suspense } from \"react\"\n-import { StaticComponent, DynamicComponent, Fallback } from \"@/app/ui\"\n-\n-export const experimental_ppr = true\n-\n-export default function Page() {\n-  return {\n-     <>\n-      <StaticComponent />\n-      <Suspense fallback={<Fallback />}>\n-        <DynamicComponent />\n-      </Suspense>\n-     </>\n-  };\n-}\n-```\n-\n-> **Good to know**:\n->\n-> - Routes that don't have `experimental_ppr` will default to `false` and will not be prerendered using PPR. You need to explicitly opt-in to PPR for each route.\n-> - `experimental_ppr` will apply to all children of the route segment, including nested layouts and pages. You don't have to add it to every file, only the top segment of a route.\n-> - To disable PPR for children segments, you can set `experimental_ppr` to `false` in the child segment.\n-\n-| Version   | Changes                                     |\n-| --------- | ------------------------------------------- |\n-| `v15.0.0` | experimental `incremental` value introduced |\n-| `v14.0.0` | experimental `ppr` introduced               |"
        },
        {
            "sha": "327005ddd10844ac504cc37cbfb7f019b02741e7",
            "filename": "errors/app-static-to-dynamic-error.mdx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/errors%2Fapp-static-to-dynamic-error.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/errors%2Fapp-static-to-dynamic-error.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fapp-static-to-dynamic-error.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -19,5 +19,5 @@ To resolve this issue, you have two main options:\n \n ## Useful Links\n \n-- [Static and Dynamic Rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering) - Learn more about the differences between static and dynamic rendering in Next.js.\n-- [Dynamic APIs](/docs/app/getting-started/partial-prerendering#dynamic-rendering) - Understand more about the usage of dynamic server functions in your Next.js application.\n+- [Static and Dynamic Rendering](/docs/app/guides/caching#rendering-strategies) - Learn more about the differences between static and dynamic rendering in Next.js.\n+- [Dynamic APIs](/docs/app/guides/caching#dynamic-rendering) - Understand more about the usage of dynamic server functions in your Next.js application."
        },
        {
            "sha": "2ccb4fbfc6b897c7e3f18b3e046f2a653626d8c1",
            "filename": "errors/missing-suspense-with-csr-bailout.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/errors%2Fmissing-suspense-with-csr-bailout.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/errors%2Fmissing-suspense-with-csr-bailout.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fmissing-suspense-with-csr-bailout.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -177,4 +177,4 @@ This configuration option will be removed in a future major version.\n \n - [`useSearchParams`](/docs/app/api-reference/functions/use-search-params)\n - [`connection`](/docs/app/api-reference/functions/connection)\n-- [Dynamic Rendering guide](/docs/app/getting-started/partial-prerendering#dynamic-rendering)\n+- [Dynamic Rendering guide](/docs/app/guides/caching#dynamic-rendering)"
        },
        {
            "sha": "1fdbbdac5021dd9c95b97dc91c34ebfe03e7d705",
            "filename": "errors/sync-dynamic-apis.mdx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4cae09439346a043199aa8b9a764dc0d43d9c968/errors%2Fsync-dynamic-apis.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/4cae09439346a043199aa8b9a764dc0d43d9c968/errors%2Fsync-dynamic-apis.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/errors%2Fsync-dynamic-apis.mdx?ref=4cae09439346a043199aa8b9a764dc0d43d9c968",
            "patch": "@@ -5,7 +5,7 @@ description: Learn more about why accessing certain APIs synchronously now warns\n \n ## Why This Warning Occurred\n \n-Somewhere in your code you used an API that opts into [dynamic rendering](/docs/app/getting-started/partial-prerendering#dynamic-rendering).\n+Somewhere in your code you used an API that opts into [dynamic rendering](/docs/app/guides/caching#dynamic-rendering).\n \n Dynamic APIs are:\n "
        }
    ],
    "stats": {
        "total": 1065,
        "additions": 644,
        "deletions": 421
    }
}