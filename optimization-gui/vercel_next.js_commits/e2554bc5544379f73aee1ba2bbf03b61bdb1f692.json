{
    "author": "eps1lon",
    "message": "[test] Let pending test finish on abort (#86307)",
    "sha": "e2554bc5544379f73aee1ba2bbf03b61bdb1f692",
    "files": [
        {
            "sha": "a2c2fa904e6178f21bcb4d1259c3bb023c85f388",
            "filename": "run-tests.js",
            "status": "modified",
            "additions": 136,
            "deletions": 110,
            "changes": 246,
            "blob_url": "https://github.com/vercel/next.js/blob/e2554bc5544379f73aee1ba2bbf03b61bdb1f692/run-tests.js",
            "raw_url": "https://github.com/vercel/next.js/raw/e2554bc5544379f73aee1ba2bbf03b61bdb1f692/run-tests.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/run-tests.js?ref=e2554bc5544379f73aee1ba2bbf03b61bdb1f692",
            "patch": "@@ -501,10 +501,11 @@ ${ENDGROUP}`)\n     `jest${process.platform === 'win32' ? '.CMD' : ''}`\n   )\n   let firstError = true\n-  let killed = false\n+  const testController = new AbortController()\n+  const testSignal = testController.signal\n   let hadFailures = false\n \n-  const runTest = (/** @type {TestFile} */ test, isFinalRun, isRetry) =>\n+  const runTestOnce = (/** @type {TestFile} */ test, isFinalRun, isRetry) =>\n     new Promise((resolve, reject) => {\n       const start = new Date().getTime()\n       let outputChunks = []\n@@ -618,11 +619,11 @@ ${ENDGROUP}`)\n           if (hideOutput) {\n             await outputSema.acquire()\n             const isExpanded =\n-              firstError && !killed && !shouldContinueTestsOnError\n+              firstError && !testSignal.aborted && !shouldContinueTestsOnError\n             if (isExpanded) {\n               firstError = false\n               process.stdout.write(`❌ ${test.file} output:\\n`)\n-            } else if (killed) {\n+            } else if (testSignal.aborted) {\n               process.stdout.write(`${GROUP}${test.file} output (killed)\\n`)\n             } else {\n               process.stdout.write(`${GROUP}❌ ${test.file} output\\n`)\n@@ -636,7 +637,7 @@ ${ENDGROUP}`)\n               output += chunk.toString()\n             }\n \n-            if (process.env.CI && !killed) {\n+            if (process.env.CI && !testSignal.aborted) {\n               errorsPerTests.set(test.file, output)\n             }\n \n@@ -682,10 +683,105 @@ ${ENDGROUP}`)\n       })\n     })\n \n+  const runTest = async (/** @type {TestFile} */ test) => {\n+    let passed = false\n+\n+    const shouldSkipRetries = skipRetryTestManifest.find((t) =>\n+      t.includes(test.file)\n+    )\n+    const numRetries = shouldSkipRetries ? 0 : originalRetries\n+    if (shouldSkipRetries) {\n+      console.log(\n+        `Skipping retry for ${test.file} due to skipRetryTestManifest`\n+      )\n+    }\n+\n+    for (let i = 0; i < numRetries + 1; i++) {\n+      try {\n+        console.log(`Starting ${test.file} retry ${i}/${numRetries}`)\n+        const time = await runTestOnce(\n+          test,\n+          shouldSkipRetries || i === numRetries,\n+          shouldSkipRetries || i > 0\n+        )\n+        timings.push({\n+          file: test.file,\n+          time,\n+        })\n+        passed = true\n+        console.log(\n+          `${test.file} finished on retry ${i}/${numRetries} in ${time / 1000}s`\n+        )\n+        break\n+      } catch (err) {\n+        if (i < numRetries) {\n+          try {\n+            let testDir = path.dirname(path.join(__dirname, test.file))\n+\n+            // if test is nested in a test folder traverse up a dir to ensure\n+            // we clean up relevant test files\n+            if (testDir.endsWith('/test') || testDir.endsWith('\\\\test')) {\n+              testDir = path.join(testDir, '..')\n+            }\n+            console.log('Cleaning test files at', testDir)\n+            await exec(`git clean -fdx \"${testDir}\"`)\n+            await exec(`git checkout \"${testDir}\"`)\n+          } catch (err) {}\n+        } else {\n+          console.error(`${test.file} failed due to ${err}`)\n+        }\n+      }\n+    }\n+\n+    if (!passed) {\n+      hadFailures = true\n+      const error = new Error(\n+        // \"failed to pass within\" is a keyword parsed by next-pr-webhook\n+        `${test.file} failed to pass within ${numRetries} retries`\n+      )\n+      console.error(error.message)\n+\n+      if (!shouldContinueTestsOnError) {\n+        testController.abort(error)\n+      } else {\n+        console.log(\n+          `CONTINUE_ON_ERROR enabled, continuing tests after ${test.file} failed`\n+        )\n+      }\n+    }\n+\n+    // Emit test output if test failed or if we're continuing tests on error\n+    // This is parsed by the commenter webhook to notify about failing tests\n+    if ((!passed || shouldContinueTestsOnError) && isTestJob) {\n+      try {\n+        const testsOutput = await fsp.readFile(\n+          `${test.file}${RESULTS_EXT}`,\n+          'utf8'\n+        )\n+        const obj = JSON.parse(testsOutput)\n+        obj.processEnv = {\n+          NEXT_TEST_MODE: process.env.NEXT_TEST_MODE,\n+          HEADLESS: process.env.HEADLESS,\n+        }\n+        await outputSema.acquire()\n+        if (GROUP) console.log(`${GROUP}Result as JSON for tooling`)\n+        console.log(\n+          `--test output start--`,\n+          JSON.stringify(obj),\n+          `--test output end--`\n+        )\n+        if (ENDGROUP) console.log(ENDGROUP)\n+        outputSema.release()\n+      } catch (err) {\n+        console.log(`Failed to load test output`, err)\n+      }\n+    }\n+  }\n+\n   const directorySemas = new Map()\n \n   const originalRetries = numRetries\n-  await Promise.all(\n+  const results = await Promise.allSettled(\n     tests.map(async (test) => {\n       const dirName = path.dirname(test.file)\n       let dirSema = directorySemas.get(dirName)\n@@ -695,109 +791,39 @@ ${ENDGROUP}`)\n       if (/^test[/\\\\]integration/.test(test.file) && dirSema === undefined) {\n         directorySemas.set(dirName, (dirSema = new Sema(1)))\n       }\n+      // TODO: Use explicit resource managment instead of this acquire/release pattern\n+      // once CI runs with Node.js 24+.\n       if (dirSema) await dirSema.acquire()\n-\n       await sema.acquire()\n-      let passed = false\n \n-      const shouldSkipRetries = skipRetryTestManifest.find((t) =>\n-        t.includes(test.file)\n-      )\n-      const numRetries = shouldSkipRetries ? 0 : originalRetries\n-      if (shouldSkipRetries) {\n-        console.log(\n-          `Skipping retry for ${test.file} due to skipRetryTestManifest`\n-        )\n-      }\n-\n-      for (let i = 0; i < numRetries + 1; i++) {\n-        try {\n-          console.log(`Starting ${test.file} retry ${i}/${numRetries}`)\n-          const time = await runTest(\n-            test,\n-            shouldSkipRetries || i === numRetries,\n-            shouldSkipRetries || i > 0\n-          )\n-          timings.push({\n-            file: test.file,\n-            time,\n-          })\n-          passed = true\n-          console.log(\n-            `Finished ${test.file} on retry ${i}/${numRetries} in ${\n-              time / 1000\n-            }s`\n-          )\n-          break\n-        } catch (err) {\n-          if (i < numRetries) {\n-            try {\n-              let testDir = path.dirname(path.join(__dirname, test.file))\n-\n-              // if test is nested in a test folder traverse up a dir to ensure\n-              // we clean up relevant test files\n-              if (testDir.endsWith('/test') || testDir.endsWith('\\\\test')) {\n-                testDir = path.join(testDir, '..')\n-              }\n-              console.log('Cleaning test files at', testDir)\n-              await exec(`git clean -fdx \"${testDir}\"`)\n-              await exec(`git checkout \"${testDir}\"`)\n-            } catch (err) {}\n-          } else {\n-            console.error(`${test.file} failed due to ${err}`)\n-          }\n-        }\n-      }\n-\n-      if (!passed) {\n-        console.error(\n-          `${test.file} failed to pass within ${numRetries} retries`\n-        )\n-\n-        if (!shouldContinueTestsOnError) {\n-          killed = true\n-          children.forEach((child) => child.kill())\n-          cleanUpAndExit(1)\n-        } else {\n-          hadFailures = true\n-          console.log(\n-            `CONTINUE_ON_ERROR enabled, continuing tests after ${test.file} failed`\n-          )\n+      try {\n+        if (testSignal.aborted) {\n+          // We already logged the abort reason. No need to include it in cause.\n+          const error = new Error(`Skipped due to abort.`)\n+          error.name = test.file\n+          throw error\n         }\n-      }\n \n-      // Emit test output if test failed or if we're continuing tests on error\n-      // This is parsed by the commenter webhook to notify about failing tests\n-      if ((!passed || shouldContinueTestsOnError) && isTestJob) {\n-        try {\n-          const testsOutput = await fsp.readFile(\n-            `${test.file}${RESULTS_EXT}`,\n-            'utf8'\n-          )\n-          const obj = JSON.parse(testsOutput)\n-          obj.processEnv = {\n-            NEXT_TEST_MODE: process.env.NEXT_TEST_MODE,\n-            HEADLESS: process.env.HEADLESS,\n-          }\n-          await outputSema.acquire()\n-          if (GROUP) console.log(`${GROUP}Result as JSON for tooling`)\n-          console.log(\n-            `--test output start--`,\n-            JSON.stringify(obj),\n-            `--test output end--`\n-          )\n-          if (ENDGROUP) console.log(ENDGROUP)\n-          outputSema.release()\n-        } catch (err) {\n-          console.log(`Failed to load test output`, err)\n-        }\n+        await runTest(test)\n+      } finally {\n+        sema.release()\n+        if (dirSema) dirSema.release()\n       }\n-\n-      sema.release()\n-      if (dirSema) dirSema.release()\n     })\n   )\n \n+  for (const result of results) {\n+    if (result.status === 'rejected') {\n+      hadFailures = true\n+      console.error(result.reason)\n+    }\n+  }\n+\n+  if (hadFailures && !shouldContinueTestsOnError) {\n+    // TODO: Does it make sense to update timings if there were failures if without shouldContinueTestsOnError?\n+    return hadFailures\n+  }\n+\n   if (options.timings) {\n     const curTimings = {}\n     // let junitData = `<testsuites name=\"jest tests\">`\n@@ -857,20 +883,20 @@ ${ENDGROUP}`)\n     }\n   }\n \n-  // Return whether there were any failures\n   return hadFailures\n }\n \n-main()\n-  .then((hadFailures) => {\n+main().then(\n+  (hadFailures) => {\n     if (hadFailures) {\n       console.error('Some tests failed')\n-      cleanUpAndExit(1)\n+      return cleanUpAndExit(1)\n     } else {\n-      cleanUpAndExit(0)\n+      return cleanUpAndExit(0)\n     }\n-  })\n-  .catch((err) => {\n-    console.error(err)\n-    cleanUpAndExit(1)\n-  })\n+  },\n+  (reason) => {\n+    console.error(reason)\n+    return cleanUpAndExit(1)\n+  }\n+)"
        }
    ],
    "stats": {
        "total": 246,
        "additions": 136,
        "deletions": 110
    }
}