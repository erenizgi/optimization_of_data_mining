{
    "author": "bgw",
    "message": "Turbopack: Make the \"non-recursive\" logic for the fs watcher a runtime flag instead of a build-time one (#82031)\n\nWe use different modes on macos/windows and linux for watching files for performance reasons: https://github.com/vercel/turborepo/pull/4100\n\nNow with `TURBO_TASKS_FORCE_WATCH_MODE=recursive` or `TURBO_TASKS_FORCE_WATCH_MODE=nonrecursive`, you can force the watcher into either mode, independent of platform.\n\n### Why?\n\n- Platform-specific compilation flags are annoying and it's easy to accidentally break compilation on another platform.\n- It's actually really useful to be able to force recursive or non-recursive mode without switching platforms when testing the watcher to narrow down bugs. E.g. on Linux:\n\n```\n# this fails to receive watch events after directories are added/removed\nrm -rf /tmp/fuzz && RUST_BACKTRACE=1 TURBO_TASKS_FORCE_WATCH_MODE=nonrecursive cargo run --release -p turbo-tasks-fuzz -- fs-watcher --fs-root /tmp/fuzz\n\n# but this (simulating the behavior of macos/windows) works fine\nrm -rf /tmp/fuzz && RUST_BACKTRACE=1 TURBO_TASKS_FORCE_WATCH_MODE=recursive cargo run --release -p turbo-tasks-fuzz -- fs-watcher --fs-root /tmp/fuzz\n```\n\n- There's not all that many places this flag needs to be checked, and compared to the cost of the syscalls happening at those callsites, the impact should be basically zero.",
    "sha": "7e4c74b9f59550f974f9240e5b4a8b72e67997fd",
    "files": [
        {
            "sha": "de1aaf4898bab39ad1e8bc8bc6a2c8557b9bdfaa",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 8,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/7e4c74b9f59550f974f9240e5b4a8b72e67997fd/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7e4c74b9f59550f974f9240e5b4a8b72e67997fd/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=7e4c74b9f59550f974f9240e5b4a8b72e67997fd",
            "patch": "@@ -255,9 +255,10 @@ impl DiskFileSystemInner {\n         let invalidator = turbo_tasks::get_invalidator();\n         self.invalidator_map\n             .insert(path_to_key(path), invalidator, None);\n-        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n-        if let Some(dir) = path.parent() {\n-            self.watcher.ensure_watching(dir, self.root_path())?;\n+        if let Some(non_recursive) = &self.watcher.non_recursive_state\n+            && let Some(dir) = path.parent()\n+        {\n+            non_recursive.ensure_watching(&self.watcher, dir, self.root_path())?;\n         }\n         Ok(())\n     }\n@@ -284,9 +285,10 @@ impl DiskFileSystemInner {\n             .collect::<Vec<_>>();\n         invalidators.insert(invalidator, Some(write_content));\n         drop(invalidator_map);\n-        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n-        if let Some(dir) = path.parent() {\n-            self.watcher.ensure_watching(dir, self.root_path())?;\n+        if let Some(non_recursive) = &self.watcher.non_recursive_state\n+            && let Some(dir) = path.parent()\n+        {\n+            non_recursive.ensure_watching(&self.watcher, dir, self.root_path())?;\n         }\n         Ok(old_invalidators)\n     }\n@@ -297,8 +299,9 @@ impl DiskFileSystemInner {\n         let invalidator = turbo_tasks::get_invalidator();\n         self.dir_invalidator_map\n             .insert(path_to_key(path), invalidator, None);\n-        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n-        self.watcher.ensure_watching(path, self.root_path())?;\n+        if let Some(non_recursive) = &self.watcher.non_recursive_state {\n+            non_recursive.ensure_watching(&self.watcher, path, self.root_path())?;\n+        }\n         Ok(())\n     }\n "
        },
        {
            "sha": "093b6c5b63b0d3f5b391ed1d7ed160c37e005d41",
            "filename": "turbopack/crates/turbo-tasks-fs/src/watcher.rs",
            "status": "modified",
            "additions": 132,
            "deletions": 73,
            "changes": 205,
            "blob_url": "https://github.com/vercel/next.js/blob/7e4c74b9f59550f974f9240e5b4a8b72e67997fd/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7e4c74b9f59550f974f9240e5b4a8b72e67997fd/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs?ref=7e4c74b9f59550f974f9240e5b4a8b72e67997fd",
            "patch": "@@ -1,16 +1,17 @@\n use std::{\n     any::Any,\n-    fmt,\n+    env, fmt,\n     mem::take,\n     path::{Path, PathBuf},\n     sync::{\n-        Arc, Mutex,\n+        Arc, LazyLock, Mutex, MutexGuard,\n         mpsc::{Receiver, TryRecvError, channel},\n     },\n     time::Duration,\n };\n \n-use anyhow::Result;\n+use anyhow::{Context, Result};\n+use dashmap::DashSet;\n use notify::{\n     Config, EventKind, PollWatcher, RecommendedWatcher, RecursiveMode, Watcher,\n     event::{MetadataKind, ModifyKind, RenameMode},\n@@ -32,6 +33,35 @@ use crate::{\n     path_to_key,\n };\n \n+static WATCH_RECURSIVE_MODE: LazyLock<RecursiveMode> = LazyLock::new(|| {\n+    match env::var(\"TURBO_TASKS_FORCE_WATCH_MODE\").as_deref() {\n+        Ok(\"recursive\") => {\n+            return RecursiveMode::Recursive;\n+        }\n+        Ok(\"nonrecursive\") => {\n+            return RecursiveMode::NonRecursive;\n+        }\n+        Ok(_) => {\n+            eprintln!(\n+                \"unsupported `TURBO_TASKS_FORCE_WATCH_MODE`, must be `recursive` or `nonrecursive`\"\n+            );\n+        }\n+        _ => {}\n+    }\n+    if cfg!(any(target_os = \"macos\", target_os = \"windows\")) {\n+        // these platforms have efficient recursive watchers, it's best to track the entire\n+        // directory and filter events to the files we care about\n+        RecursiveMode::Recursive\n+    } else {\n+        // inotify on linux is non-recursive, so notify-rs's implementation is inefficient, it's\n+        // better for us to just track it ourselves and only watch the files we know we care about\n+        //\n+        // See: https://github.com/vercel/turborepo/pull/4100\n+        RecursiveMode::NonRecursive\n+    }\n+});\n+\n+/// A thin wrapper around [`RecommendedWatcher`] and [`PollWatcher`].\n enum DiskWatcherInternal {\n     Recommended(RecommendedWatcher),\n     Polling(PollWatcher),\n@@ -46,76 +76,96 @@ impl DiskWatcherInternal {\n     }\n }\n \n-#[derive(Default, Serialize, Deserialize)]\n+#[derive(Serialize, Deserialize)]\n pub(crate) struct DiskWatcher {\n-    #[serde(skip)]\n-    watcher: Mutex<Option<DiskWatcherInternal>>,\n-\n     /// Array of paths that should not notify invalidations.\n     /// `notify` currently doesn't support unwatching subpaths from the root,\n     /// so underlying we still watches filesystem event but only skips to\n     /// invalidate.\n     ignored_subpaths: Vec<PathBuf>,\n \n-    /// Keeps track of which directories are currently watched. This is only\n-    /// used on OSs that doesn't support recursive watching.\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n     #[serde(skip)]\n-    watching: dashmap::DashSet<PathBuf>,\n+    internal: Mutex<Option<DiskWatcherInternal>>,\n+\n+    #[serde(skip, default = \"NonRecursiveDiskWatcherState::try_new\")]\n+    pub(crate) non_recursive_state: Option<NonRecursiveDiskWatcherState>,\n }\n \n-impl DiskWatcher {\n-    pub(crate) fn new(ignored_subpaths: Vec<PathBuf>) -> Self {\n+impl Default for DiskWatcher {\n+    fn default() -> Self {\n         Self {\n-            ignored_subpaths,\n-            ..Default::default()\n+            ignored_subpaths: Vec::new(),\n+            internal: Mutex::new(None),\n+            non_recursive_state: NonRecursiveDiskWatcherState::try_new(),\n+        }\n+    }\n+}\n+\n+/// Extra state used by [`DiskWatcher`] when [`WATCH_RECURSIVE_MODE`] is\n+/// [`RecursiveMode::NonRecursive`] (default on Linux).\n+pub(crate) struct NonRecursiveDiskWatcherState {\n+    /// Keeps track of which directories are currently (or were previously) watched.\n+    watching: DashSet<PathBuf>,\n+}\n+\n+impl NonRecursiveDiskWatcherState {\n+    fn try_new() -> Option<NonRecursiveDiskWatcherState> {\n+        match *WATCH_RECURSIVE_MODE {\n+            RecursiveMode::Recursive => None,\n+            RecursiveMode::NonRecursive => Some(NonRecursiveDiskWatcherState {\n+                watching: DashSet::new(),\n+            }),\n         }\n     }\n \n     /// Called after a rescan in case a previously watched-but-deleted directory was recreated.\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n-    pub(crate) fn restore_all_watching(&self, root_path: &Path) {\n-        let mut watcher = self.watcher.lock().unwrap();\n+    pub(crate) fn restore_all_watching(&self, watcher: &DiskWatcher, root_path: &Path) {\n+        let mut internal = watcher.internal.lock().unwrap();\n         for dir_path in self.watching.iter() {\n             // TODO: Report diagnostics if this error happens\n-            let _ = self.start_watching_dir(&mut watcher, &dir_path, root_path);\n+            let _ = self.start_watching_dir(&mut internal, &dir_path, root_path);\n         }\n     }\n \n     /// Called when a new directory is found in a parent directory we're watching.\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n-    pub(crate) fn restore_if_watching(&self, dir_path: &Path, root_path: &Path) -> Result<()> {\n+    pub(crate) fn restore_if_watching(\n+        &self,\n+        watcher: &DiskWatcher,\n+        dir_path: &Path,\n+        root_path: &Path,\n+    ) -> Result<()> {\n         if self.watching.contains(dir_path) {\n-            let mut watcher = self.watcher.lock().unwrap();\n+            let mut internal = watcher.internal.lock().unwrap();\n             // TODO: Also restore any watchers for children of this directory\n-            self.start_watching_dir(&mut watcher, dir_path, root_path)?;\n+            self.start_watching_dir(&mut internal, dir_path, root_path)?;\n         }\n         Ok(())\n     }\n \n-    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n-    pub(crate) fn ensure_watching(&self, dir_path: &Path, root_path: &Path) -> Result<()> {\n+    pub(crate) fn ensure_watching(\n+        &self,\n+        watcher: &DiskWatcher,\n+        dir_path: &Path,\n+        root_path: &Path,\n+    ) -> Result<()> {\n         if self.watching.contains(dir_path) {\n             return Ok(());\n         }\n-        let mut watcher = self.watcher.lock().unwrap();\n+        let mut internal = watcher.internal.lock().unwrap();\n         if self.watching.insert(dir_path.to_path_buf()) {\n-            self.start_watching_dir(&mut watcher, dir_path, root_path)?;\n+            self.start_watching_dir(&mut internal, dir_path, root_path)?;\n         }\n         Ok(())\n     }\n \n     /// Private helper, assumes that the path has already been added to `self.watching`.\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n     fn start_watching_dir(\n         &self,\n-        watcher: &mut std::sync::MutexGuard<Option<DiskWatcherInternal>>,\n+        watcher_internal_guard: &mut MutexGuard<Option<DiskWatcherInternal>>,\n         dir_path: &Path,\n         root_path: &Path,\n     ) -> Result<()> {\n-        use anyhow::Context; // inner import due to conditional compilation\n-\n-        if let Some(watcher) = watcher.as_mut() {\n+        if let Some(watcher_internal_guard) = watcher_internal_guard.as_mut() {\n             let mut path = dir_path;\n             let err_with_context = |err| {\n                 return Err(err).context(format!(\n@@ -124,7 +174,7 @@ impl DiskWatcher {\n                     path.display()\n                 ));\n             };\n-            while let Err(err) = watcher.watch(path, RecursiveMode::NonRecursive) {\n+            while let Err(err) = watcher_internal_guard.watch(path, RecursiveMode::NonRecursive) {\n                 match err {\n                     notify::Error {\n                         kind: notify::ErrorKind::PathNotFound,\n@@ -153,6 +203,15 @@ impl DiskWatcher {\n         }\n         Ok(())\n     }\n+}\n+\n+impl DiskWatcher {\n+    pub(crate) fn new(ignored_subpaths: Vec<PathBuf>) -> Self {\n+        Self {\n+            ignored_subpaths,\n+            ..Default::default()\n+        }\n+    }\n \n     /// Create a watcher and start watching by creating `debounced` watcher\n     /// via `full debouncer`\n@@ -171,12 +230,12 @@ impl DiskWatcher {\n     /// - Doesn't emit Modify events after a Create event\n     pub(crate) fn start_watching(\n         &self,\n-        inner: Arc<DiskFileSystemInner>,\n+        fs_inner: Arc<DiskFileSystemInner>,\n         report_invalidation_reason: bool,\n         poll_interval: Option<Duration>,\n     ) -> Result<()> {\n-        let mut watcher_guard = self.watcher.lock().unwrap();\n-        if watcher_guard.is_some() {\n+        let mut internal_guard = self.internal.lock().unwrap();\n+        if internal_guard.is_some() {\n             return Ok(());\n         }\n \n@@ -188,33 +247,29 @@ impl DiskWatcher {\n         // we should track and invalidate each part of a symlink chain ourselves in turbo-tasks-fs\n         config.with_follow_symlinks(false);\n \n-        let mut watcher = if let Some(poll_interval) = poll_interval {\n+        let mut internal = if let Some(poll_interval) = poll_interval {\n             let config = config.with_poll_interval(poll_interval);\n \n             DiskWatcherInternal::Polling(PollWatcher::new(tx, config)?)\n         } else {\n             DiskWatcherInternal::Recommended(RecommendedWatcher::new(tx, Config::default())?)\n         };\n \n-        // Macos and Windows provide efficient recursive directory watchers. On other platforms, we\n-        // only track the directories we need: https://github.com/vercel/turborepo/pull/4100\n-        #[cfg(any(target_os = \"macos\", target_os = \"windows\"))]\n-        {\n-            watcher.watch(inner.root_path(), RecursiveMode::Recursive)?;\n-        }\n-\n-        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n-        for dir_path in self.watching.iter() {\n-            watcher.watch(&dir_path, RecursiveMode::NonRecursive)?;\n+        if let Some(non_recursive) = &self.non_recursive_state {\n+            for dir_path in non_recursive.watching.iter() {\n+                internal.watch(&dir_path, RecursiveMode::NonRecursive)?;\n+            }\n+        } else {\n+            internal.watch(fs_inner.root_path(), RecursiveMode::Recursive)?;\n         }\n \n         // We need to invalidate all reads that happened before watching\n         // Best is to start_watching before starting to read\n         {\n-            let _span = tracing::info_span!(\"invalidate filesystem\").entered();\n-            let span = tracing::Span::current();\n-            let invalidator_map = take(&mut *inner.invalidator_map.lock().unwrap());\n-            let dir_invalidator_map = take(&mut *inner.dir_invalidator_map.lock().unwrap());\n+            let span = tracing::info_span!(\"invalidate filesystem\");\n+            let _span = span.clone().entered();\n+            let invalidator_map = take(&mut *fs_inner.invalidator_map.lock().unwrap());\n+            let dir_invalidator_map = take(&mut *fs_inner.dir_invalidator_map.lock().unwrap());\n             let iter = invalidator_map\n                 .into_par_iter()\n                 .chain(dir_invalidator_map.into_par_iter());\n@@ -223,7 +278,7 @@ impl DiskWatcher {\n                 iter.flat_map(|(path, invalidators)| {\n                     let _span = span.clone().entered();\n                     let reason = WatchStart {\n-                        name: inner.name.clone(),\n+                        name: fs_inner.name.clone(),\n                         path: path.into(),\n                     };\n                     invalidators\n@@ -248,21 +303,21 @@ impl DiskWatcher {\n             }\n         }\n \n-        watcher_guard.replace(watcher);\n-        drop(watcher_guard);\n+        internal_guard.replace(internal);\n+        drop(internal_guard);\n \n         spawn_thread(move || {\n-            inner\n+            fs_inner\n                 .clone()\n                 .watcher\n-                .watch_thread(rx, inner, report_invalidation_reason)\n+                .watch_thread(rx, fs_inner, report_invalidation_reason)\n         });\n \n         Ok(())\n     }\n \n     pub(crate) fn stop_watching(&self) {\n-        if let Some(watcher) = self.watcher.lock().unwrap().take() {\n+        if let Some(watcher) = self.internal.lock().unwrap().take() {\n             drop(watcher);\n             // thread will detect the stop because the channel is disconnected\n         }\n@@ -283,8 +338,11 @@ impl DiskWatcher {\n         let mut batched_invalidate_path_and_children = FxHashSet::default();\n         let mut batched_invalidate_path_and_children_dir = FxHashSet::default();\n \n-        #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n-        let mut batched_new_paths = FxHashSet::default();\n+        let mut batched_new_paths = if self.non_recursive_state.is_some() {\n+            Some(FxHashSet::default())\n+        } else {\n+            None\n+        };\n \n         'outer: loop {\n             let mut event_result = rx.recv().or(Err(TryRecvError::Disconnected));\n@@ -304,13 +362,14 @@ impl DiskWatcher {\n                         if event.need_rescan() {\n                             let _lock = inner.invalidation_lock.blocking_write();\n \n-                            #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n-                            {\n+                            if let Some(non_recursive) = &self.non_recursive_state {\n                                 // we can't narrow this down to a smaller set of paths: Rescan\n                                 // events (at least when tested on Linux) come with no `paths`, and\n                                 // we use only one global `notify::Watcher` instance.\n-                                self.restore_all_watching(inner.root_path());\n-                                batched_new_paths.clear();\n+                                non_recursive.restore_all_watching(self, inner.root_path());\n+                                if let Some(batched_new_paths) = &mut batched_new_paths {\n+                                    batched_new_paths.clear();\n+                                }\n                             }\n \n                             if report_invalidation_reason {\n@@ -380,8 +439,9 @@ impl DiskWatcher {\n                                     }\n                                 });\n \n-                                #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n-                                batched_new_paths.extend(paths.clone());\n+                                if let Some(batched_new_paths) = &mut batched_new_paths {\n+                                    batched_new_paths.extend(paths.clone());\n+                                }\n                             }\n                             EventKind::Remove(_) => {\n                                 batched_invalidate_path_and_children.extend(paths.clone());\n@@ -406,8 +466,9 @@ impl DiskWatcher {\n                                     if let Some(parent) = destination.parent() {\n                                         batched_invalidate_path_dir.insert(PathBuf::from(parent));\n                                     }\n-                                    #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n-                                    batched_new_paths.insert(destination.clone());\n+                                    if let Some(batched_new_paths) = &mut batched_new_paths {\n+                                        batched_new_paths.insert(destination.clone());\n+                                    }\n                                 } else {\n                                     // If we hit here, we expect this as a bug either in\n                                     // notify or system weirdness.\n@@ -478,13 +539,11 @@ impl DiskWatcher {\n             }\n \n             // We need to start watching first before invalidating the changed paths...\n-            // This is only needed on platforms we don't do recursive watching on:\n-            // https://github.com/vercel/turborepo/pull/4100\n-            #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n-            {\n-                for path in batched_new_paths.drain() {\n+            // This is only needed on platforms we don't do recursive watching on.\n+            if let Some(non_recursive) = &self.non_recursive_state {\n+                for path in batched_new_paths.as_mut().unwrap().drain() {\n                     // TODO: Report diagnostics if this error happens\n-                    let _ = self.restore_if_watching(&path, inner.root_path());\n+                    let _ = non_recursive.restore_if_watching(self, &path, inner.root_path());\n                 }\n             }\n "
        }
    ],
    "stats": {
        "total": 224,
        "additions": 143,
        "deletions": 81
    }
}