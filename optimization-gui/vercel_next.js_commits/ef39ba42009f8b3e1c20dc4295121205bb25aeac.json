{
    "author": "kdy1",
    "message": "perf(turbopack): Spawn only one thread for one `write file` effect (#79318)\n\n### What?\n\nReplace `retry_future` call with `retry_blocking`.\n\n### Why?\n\n`tokio::fs` is a trap for this kind of usage. Each function call will spawn one thread until it reaches the thread pool limit. Our previous code could spawn at most eight threads to handle one `write file` effect.\n\nThe numbers at x-ref: https://vercel.slack.com/archives/C06PPGZ0FD3/p1747437041264999",
    "sha": "ef39ba42009f8b3e1c20dc4295121205bb25aeac",
    "files": [
        {
            "sha": "9507f0591f5908d688a5038b3bb2de119d385c7f",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 31,
            "deletions": 27,
            "changes": 58,
            "blob_url": "https://github.com/vercel/next.js/blob/ef39ba42009f8b3e1c20dc4295121205bb25aeac/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ef39ba42009f8b3e1c20dc4295121205bb25aeac/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=ef39ba42009f8b3e1c20dc4295121205bb25aeac",
            "patch": "@@ -52,7 +52,7 @@ use serde::{Deserialize, Serialize};\n use serde_json::Value;\n use tokio::{\n     fs,\n-    io::{AsyncBufReadExt, AsyncReadExt, AsyncWriteExt, BufReader},\n+    io::{AsyncBufReadExt, AsyncReadExt, BufReader},\n     sync::{RwLock, RwLockReadGuard},\n };\n use tracing::Instrument;\n@@ -757,7 +757,7 @@ impl FileSystem for DiskFileSystem {\n             }\n \n             match &*content {\n-                FileContent::Content(file) => {\n+                FileContent::Content(..) => {\n                     let create_directory = compare == FileComparison::Create;\n                     if create_directory {\n                         if let Some(parent) = full_path.parent() {\n@@ -770,34 +770,38 @@ impl FileSystem for DiskFileSystem {\n                             })?;\n                         }\n                     }\n+\n                     let full_path_to_write = full_path.clone();\n-                    retry_future(move || {\n-                        let full_path = full_path_to_write.clone();\n-                        async move {\n-                            let mut f = fs::File::create(&full_path).await?;\n-                            tokio::io::copy(&mut file.read(), &mut f).await?;\n+                    let content = content.clone();\n+                    retry_blocking(&full_path_to_write, move |full_path| {\n+                        use std::io::Write;\n+\n+                        let mut f = std::fs::File::create(full_path)?;\n+                        let FileContent::Content(file) = &*content else {\n+                            unreachable!()\n+                        };\n+                        std::io::copy(&mut file.read(), &mut f)?;\n+                        #[cfg(target_family = \"unix\")]\n+                        f.set_permissions(file.meta.permissions.into())?;\n+                        f.flush()?;\n+                        #[cfg(feature = \"write_version\")]\n+                        {\n+                            let mut full_path = full_path.into_owned();\n+                            let hash = hash_xxh3_hash64(file);\n+                            let ext = full_path.extension();\n+                            let ext = if let Some(ext) = ext {\n+                                format!(\"{:016x}.{}\", hash, ext.to_string_lossy())\n+                            } else {\n+                                format!(\"{:016x}\", hash)\n+                            };\n+                            full_path.set_extension(ext);\n+                            let mut f = std::fs::File::create(&full_path)?;\n+                            std::io::copy(&mut file.read(), &mut f)?;\n                             #[cfg(target_family = \"unix\")]\n-                            f.set_permissions(file.meta.permissions.into()).await?;\n-                            f.flush().await?;\n-                            #[cfg(feature = \"write_version\")]\n-                            {\n-                                let mut full_path = full_path.into_owned();\n-                                let hash = hash_xxh3_hash64(file);\n-                                let ext = full_path.extension();\n-                                let ext = if let Some(ext) = ext {\n-                                    format!(\"{:016x}.{}\", hash, ext.to_string_lossy())\n-                                } else {\n-                                    format!(\"{:016x}\", hash)\n-                                };\n-                                full_path.set_extension(ext);\n-                                let mut f = fs::File::create(&full_path).await?;\n-                                tokio::io::copy(&mut file.read(), &mut f).await?;\n-                                #[cfg(target_family = \"unix\")]\n-                                f.set_permissions(file.meta.permissions.into()).await?;\n-                                f.flush().await?;\n-                            }\n-                            Ok::<(), io::Error>(())\n+                            f.set_permissions(file.meta.permissions.into())?;\n+                            f.flush()?;\n                         }\n+                        Ok::<(), io::Error>(())\n                     })\n                     .concurrency_limited(&inner.semaphore)\n                     .instrument(tracing::info_span!("
        }
    ],
    "stats": {
        "total": 58,
        "additions": 31,
        "deletions": 27
    }
}