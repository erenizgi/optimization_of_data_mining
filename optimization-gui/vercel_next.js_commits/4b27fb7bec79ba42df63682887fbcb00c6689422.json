{
    "author": "lukesandberg",
    "message": "Fix an issue in how css references are collected under `next build --turbopack` (#81704)\n\n## Fix how client references are discovered during `next build --turbopack`\r\n\r\nTo correctly serve js and css resources during server side rendering we construct a client manifest that lists all the server components and their requires resources.  Prior to this PR there was a bug where we would sometimes fail to serve css resources.  The cases we have seen this is when a `not-found.js` file references css that is also referenced by a layout.\r\n\r\nWhen present, all pages pages implicitly depend on this module and  crticically depend on it as an early implicit dependency of the generated `app-page.js` file.  This means if a `not-found.js` file (or another error file) would happen to depend on the same css as a normal component we would associate it as a client-reference of that component instead of any other.  Then on a server side render we would simply omit it.\r\n\r\nThis PR address this by ensuring we always associate client resources with _every_ server component that depends on them, not just the first one.  To do this we precompute the full set of server components that depend on each client resource in the module graph and then after our dfs traversal we can collect all server components for a given entry point and then perform the association.  Further more we ensure that if a resource is reachable 'directly' from the page it is associated as 'framework' dependency.  This wasn't know to be an issue but it seems possible that if a conditionally rendered server component depended on a core framework dependency we might see the same problem.\r\n\r\nThe downside of this approach is simply the additional 'fixed point' traversal (shared across all routes) and the slightly more complex bookkeeping during each route computation.  From looking at traces building vercel-site i see that `find_server_entries` dominates the collection of client-resources (by factor of ~20, so resolving the TODO added here is probably the best approach to resolving any potential production build regressions.   However, `find_server_entries` will likely still be needed in a development scenario.  In either case however this is a very small part of the build taking ~20us per entry point.\r\n\r\nFixes #77861\r\nFixes #79535\r\nFixes PACK-4282\r\nFixes PACK-4940",
    "sha": "4b27fb7bec79ba42df63682887fbcb00c6689422",
    "files": [
        {
            "sha": "0bc7003d4dead9f939eee264f2d3159557dd13f1",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/4b27fb7bec79ba42df63682887fbcb00c6689422/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/4b27fb7bec79ba42df63682887fbcb00c6689422/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=4b27fb7bec79ba42df63682887fbcb00c6689422",
            "patch": "@@ -4262,6 +4262,7 @@ dependencies = [\n  \"indexmap 2.9.0\",\n  \"next-core\",\n  \"regex\",\n+ \"roaring\",\n  \"rustc-hash 2.1.1\",\n  \"serde\",\n  \"serde_json\","
        },
        {
            "sha": "1830ad6c458d891d67c2f01a527461a25bb71073",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/4b27fb7bec79ba42df63682887fbcb00c6689422/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4b27fb7bec79ba42df63682887fbcb00c6689422/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=4b27fb7bec79ba42df63682887fbcb00c6689422",
            "patch": "@@ -398,6 +398,7 @@ regex = \"1.10.6\"\n regress = \"0.10.3\"\n reqwest = { version = \"0.12.20\", default-features = false }\n ringmap = \"0.1.3\"\n+roaring = \"0.10.10\"\n rstest = \"0.16.0\"\n rustc-hash = \"2.1.1\"\n semver = \"1.0.16\""
        },
        {
            "sha": "b4eb3df2a4f18a9914367c16fc65acd03ece6331",
            "filename": "crates/next-api/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/4b27fb7bec79ba42df63682887fbcb00c6689422/crates%2Fnext-api%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4b27fb7bec79ba42df63682887fbcb00c6689422/crates%2Fnext-api%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2FCargo.toml?ref=4b27fb7bec79ba42df63682887fbcb00c6689422",
            "patch": "@@ -23,6 +23,7 @@ futures = { workspace = true }\n indexmap = { workspace = true }\n next-core = { workspace = true }\n regex = { workspace = true }\n+roaring = { workspace = true }\n rustc-hash = { workspace = true }\n serde = { workspace = true }\n serde_json = { workspace = true }"
        },
        {
            "sha": "7f021e40be104434b934b08f3b9d2549990d1ea1",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/4b27fb7bec79ba42df63682887fbcb00c6689422/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4b27fb7bec79ba42df63682887fbcb00c6689422/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=4b27fb7bec79ba42df63682887fbcb00c6689422",
            "patch": "@@ -1937,10 +1937,10 @@ impl Endpoint for AppEndpoint {\n         };\n \n         async move {\n-            let output = self.output().await?;\n-            let output_assets = self.output().output_assets();\n-            let node_root = this.app_project.project().node_root();\n-            let node_root_ref = &node_root.await?;\n+            let output = self.output();\n+            let output_assets = output.output_assets();\n+            let output = output.await?;\n+            let node_root = &*this.app_project.project().node_root().await?;\n \n             let (server_paths, client_paths) = if this\n                 .app_project\n@@ -1969,7 +1969,7 @@ impl Endpoint for AppEndpoint {\n \n             let written_endpoint = match *output {\n                 AppEndpointOutput::NodeJs { rsc_chunk, .. } => EndpointOutputPaths::NodeJs {\n-                    server_entry_path: node_root_ref\n+                    server_entry_path: node_root\n                         .get_path_to(&*rsc_chunk.path().await?)\n                         .context(\"Node.js chunk entry path must be inside the node root\")?\n                         .to_string(),"
        },
        {
            "sha": "3d985af34ae9d9516c3c9f758d1510a2e1c5cfda",
            "filename": "crates/next-api/src/client_references.rs",
            "status": "modified",
            "additions": 135,
            "deletions": 8,
            "changes": 143,
            "blob_url": "https://github.com/vercel/next.js/blob/4b27fb7bec79ba42df63682887fbcb00c6689422/crates%2Fnext-api%2Fsrc%2Fclient_references.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4b27fb7bec79ba42df63682887fbcb00c6689422/crates%2Fnext-api%2Fsrc%2Fclient_references.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fclient_references.rs?ref=4b27fb7bec79ba42df63682887fbcb00c6689422",
            "patch": "@@ -1,16 +1,23 @@\n use anyhow::Result;\n use next_core::{\n-    self,\n     next_client_reference::{CssClientReferenceModule, EcmascriptClientReferenceModule},\n     next_server_component::server_component_module::NextServerComponentModule,\n };\n+use roaring::RoaringBitmap;\n use rustc_hash::FxHashMap;\n use serde::{Deserialize, Serialize};\n use turbo_tasks::{\n-    NonLocalValue, ResolvedVc, TryFlatJoinIterExt, Vc, debug::ValueDebugFormat, trace::TraceRawVcs,\n+    FxIndexSet, NonLocalValue, ResolvedVc, TryFlatJoinIterExt, Vc, debug::ValueDebugFormat,\n+    trace::TraceRawVcs,\n };\n use turbopack::css::chunk::CssChunkPlaceable;\n-use turbopack_core::{module::Module, module_graph::SingleModuleGraph};\n+use turbopack_core::{\n+    module::Module,\n+    module_graph::{\n+        GraphTraversalAction, SingleModuleGraph, SingleModuleGraphModuleNode,\n+        chunk_group_info::RoaringBitmapWrapper,\n+    },\n+};\n \n #[derive(\n     Copy, Clone, Serialize, Deserialize, Eq, PartialEq, TraceRawVcs, ValueDebugFormat, NonLocalValue,\n@@ -24,15 +31,42 @@ pub enum ClientReferenceMapType {\n     ServerComponent(ResolvedVc<NextServerComponentModule>),\n }\n \n-#[turbo_tasks::value(transparent)]\n-pub struct ClientReferencesSet(FxHashMap<ResolvedVc<Box<dyn Module>>, ClientReferenceMapType>);\n+#[turbo_tasks::value]\n+pub struct ClientReferencesSet {\n+    pub client_references: FxHashMap<ResolvedVc<Box<dyn Module>>, ClientReferenceMapType>,\n+    // All the server components in the graph.\n+    server_components: FxIndexSet<ResolvedVc<NextServerComponentModule>>,\n+    // All the server components that depend on each module\n+    // This only includes mappings for modules with client references and the bitmaps reference\n+    // indices into `[server_components]`\n+    server_components_for_client_references:\n+        FxHashMap<ResolvedVc<Box<dyn Module>>, RoaringBitmapWrapper>,\n+}\n+\n+impl ClientReferencesSet {\n+    /// Returns all the server components that depend on the given client reference\n+    pub fn server_components_for_client_reference(\n+        &self,\n+        module: ResolvedVc<Box<dyn Module>>,\n+    ) -> impl Iterator<Item = ResolvedVc<NextServerComponentModule>> {\n+        let bitmap = &self\n+            .server_components_for_client_references\n+            .get(&module)\n+            .expect(\"Module should be a client reference module\")\n+            .0;\n+\n+        bitmap\n+            .iter()\n+            .map(|index| *self.server_components.get_index(index as usize).unwrap())\n+    }\n+}\n \n #[turbo_tasks::function]\n pub async fn map_client_references(\n     graph: Vc<SingleModuleGraph>,\n ) -> Result<Vc<ClientReferencesSet>> {\n+    let graph = graph.await?;\n     let client_references = graph\n-        .await?\n         .iter_nodes()\n         .map(|node| async move {\n             let module = node.module;\n@@ -68,6 +102,99 @@ pub async fn map_client_references(\n             }\n         })\n         .try_flat_join()\n-        .await?;\n-    Ok(Vc::cell(client_references.into_iter().collect()))\n+        .await?\n+        .into_iter()\n+        .collect::<FxHashMap<_, _>>();\n+\n+    let mut server_components = FxIndexSet::default();\n+    let mut module_to_server_component_bits = FxHashMap::default();\n+    if !client_references.is_empty() {\n+        graph.traverse_edges_from_entries_fixed_point(\n+            graph.entry_modules(),\n+            |parent_info, node| {\n+                let module = node.module();\n+                let module_type = client_references.get(&module);\n+                let mut should_visit_children = match module_to_server_component_bits.entry(module)\n+                {\n+                    std::collections::hash_map::Entry::Occupied(_) => false,\n+                    std::collections::hash_map::Entry::Vacant(vacant_entry) => {\n+                        // only do this the first time we visit the node.\n+                        let bits = vacant_entry.insert(RoaringBitmap::new());\n+                        if let Some(ClientReferenceMapType::ServerComponent(\n+                            server_component_module,\n+                        )) = module_type\n+                        {\n+                            let index = server_components.insert_full(*server_component_module).0;\n+\n+                            bits.insert(index.try_into().unwrap());\n+                        }\n+                        true\n+                    }\n+                };\n+                if let Some((SingleModuleGraphModuleNode{module: parent_module}, _)) = parent_info\n+                    // Skip self cycles such as in\n+                    // test/e2e/app-dir/dynamic-import/app/page.tsx where a very-dynamic import induces a\n+                    // self cycle. They don't introduce new bits anyway.\n+                    && module != *parent_module\n+                {\n+                    // Copy parent bits down.  `traverse_edges_from_entries_fixed_point` always\n+                    // visits parents before children so we can simply assert\n+                    // that the parent it set.\n+                    let [Some(current), Some(parent)] =\n+                        module_to_server_component_bits.get_disjoint_mut([&module, parent_module])\n+                    else {\n+                        unreachable!()\n+                    };\n+                    // Check if we are adding new bits and thus need to revisit children unless we\n+                    // are already planning to because this is a new node.\n+                    if !should_visit_children {\n+                        let len = current.len();\n+                        *current |= &*parent;\n+                        // did we find new bits? If so visit the children again\n+                        should_visit_children = len != current.len();\n+                    } else {\n+                        *current |= &*parent;\n+                    }\n+                }\n+\n+                Ok(match module_type {\n+                    Some(\n+                        ClientReferenceMapType::EcmascriptClientReference { .. }\n+                        | ClientReferenceMapType::CssClientReference { .. },\n+                    ) => {\n+                        // No need to explore these subgraphs ever, these are the leaves in the\n+                        // server component graph\n+                        GraphTraversalAction::Skip\n+                    }\n+                    // Continue on server components and through graphs of non-ClientReference\n+                    // modules, but only if our set of parent components has changed.\n+                    _ => {\n+                        if should_visit_children {\n+                            GraphTraversalAction::Continue\n+                        } else {\n+                            GraphTraversalAction::Skip\n+                        }\n+                    }\n+                })\n+            },\n+        )?;\n+    }\n+\n+    // Filter down to just the client reference modules to reduce datastructure size\n+    let server_components_for_client_references = module_to_server_component_bits\n+        .into_iter()\n+        .filter_map(|(k, v)| match client_references.get(&k) {\n+            Some(\n+                ClientReferenceMapType::CssClientReference(_)\n+                | ClientReferenceMapType::EcmascriptClientReference { .. },\n+            ) => Some((k, RoaringBitmapWrapper(v))),\n+            _ => None,\n+        })\n+        .collect();\n+\n+    Ok(ClientReferencesSet::cell(ClientReferencesSet {\n+        client_references,\n+        server_components,\n+        server_components_for_client_references,\n+    }))\n }"
        },
        {
            "sha": "55fe1eaa014a2da11120e2a0e373e7169dd630e5",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 109,
            "deletions": 60,
            "changes": 169,
            "blob_url": "https://github.com/vercel/next.js/blob/4b27fb7bec79ba42df63682887fbcb00c6689422/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4b27fb7bec79ba42df63682887fbcb00c6689422/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=4b27fb7bec79ba42df63682887fbcb00c6689422",
            "patch": "@@ -1,6 +1,6 @@\n-use std::borrow::Cow;\n+use std::{borrow::Cow, collections::hash_map::Entry};\n \n-use anyhow::Result;\n+use anyhow::{Ok, Result};\n use either::Either;\n use next_core::{\n     next_client_reference::{\n@@ -10,12 +10,12 @@ use next_core::{\n     next_dynamic::NextDynamicEntryModule,\n     next_manifests::ActionLayer,\n };\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    CollectiblesSource, FxIndexMap, FxIndexSet, ReadRef, ResolvedVc, TryFlatJoinIterExt,\n-    TryJoinIterExt, ValueToString, Vc,\n+    CollectiblesSource, FxIndexMap, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt,\n+    ValueToString, Vc,\n };\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::css::{CssModuleAsset, ModuleCssAsset};\n@@ -285,33 +285,65 @@ impl ClientReferencesGraph {\n                 Either::Right(graph.entry_modules())\n             };\n \n-            let mut client_references = FxIndexSet::default();\n-            // Make sure None (for the various internal next/dist/esm/client/components/*) is\n-            // listed first\n-            let mut client_references_by_server_component =\n-                FxIndexMap::from_iter([(None, Vec::new())]);\n-\n+            // Because we care about 'evaluation order' we need to collect client references in the\n+            // post_order callbacks which is the same as evaluation order\n+            let mut client_references = Vec::new();\n+            let mut client_reference_modules = Vec::new();\n+            let mut server_components = FxHashSet::default();\n+\n+            // Track how we reached each client reference.  This way if a client reference is\n+            // referenced by the root and by a server component we don't only associate it with the\n+            // server component.\n+            #[derive(PartialEq, Eq, Copy, Clone)]\n+            enum ParentType {\n+                ServerComponent,\n+                Page,\n+                Both,\n+            }\n+            impl ParentType {\n+                fn merge(left: Self, right: Self) -> Self {\n+                    if left == right {\n+                        left\n+                    } else {\n+                        // One is Both or one is ServerComponent and the other is Page, which means\n+                        // Both\n+                        Self::Both\n+                    }\n+                }\n+            }\n+            // Perform a DFS traversal to collect all client references and the set of server\n+            // components for each module.\n             graph.traverse_edges_from_entries_dfs(\n                 entries,\n-                // state_map is `module -> Option< the current so parent server component >`\n+                // state_map is `module -> ParentType` to tracke whether the module is reachable\n+                // directly from an entry point.\n                 &mut FxHashMap::default(),\n                 |parent_info, node, state_map| {\n                     let module = node.module();\n-                    let module_type = data.get(&module);\n-\n-                    let current_server_component = if let Some(\n-                        ClientReferenceMapType::ServerComponent(module),\n-                    ) = module_type\n-                    {\n-                        Some(*module)\n-                    } else if let Some((parent_node, _)) = parent_info {\n-                        *state_map.get(&parent_node.module).unwrap()\n-                    } else {\n-                        // a root node\n-                        None\n-                    };\n-\n-                    state_map.insert(module, current_server_component);\n+                    let module_type = data.client_references.get(&module);\n+\n+                    let parent_type =\n+                        if let Some(ClientReferenceMapType::ServerComponent(_)) = module_type {\n+                            ParentType::ServerComponent\n+                        } else if let Some((parent_node, _)) = parent_info {\n+                            *state_map.get(&parent_node.module).unwrap()\n+                        } else {\n+                            // a root node\n+                            ParentType::Page\n+                        };\n+\n+                    match state_map.entry(module) {\n+                        Entry::Occupied(mut occupied_entry) => {\n+                            let current = occupied_entry.get_mut();\n+                            let merged = ParentType::merge(*current, parent_type);\n+                            if merged != parent_type {\n+                                *current = merged;\n+                            }\n+                        }\n+                        Entry::Vacant(vacant_entry) => {\n+                            vacant_entry.insert(parent_type);\n+                        }\n+                    }\n \n                     Ok(match module_type {\n                         Some(\n@@ -321,45 +353,60 @@ impl ClientReferencesGraph {\n                         _ => GraphTraversalAction::Continue,\n                     })\n                 },\n-                |parent_info, node, state_map| {\n-                    let Some((parent_node, _)) = parent_info else {\n+                |_, node, state_map| {\n+                    let module = node.module();\n+                    let Some(module_type) = data.client_references.get(&module) else {\n                         return Ok(());\n                     };\n-                    let parent_module = parent_node.module;\n-\n-                    let parent_server_component = *state_map.get(&parent_module).unwrap();\n-\n-                    match data.get(&node.module()) {\n-                        Some(ClientReferenceMapType::EcmascriptClientReference {\n-                            module: module_ref,\n-                            ssr_module,\n-                        }) => {\n-                            let client_reference: ClientReference = ClientReference {\n-                                server_component: parent_server_component,\n-                                ty: ClientReferenceType::EcmascriptClientReference(*module_ref),\n-                            };\n-                            client_references.insert(client_reference);\n-                            client_references_by_server_component\n-                                .entry(parent_server_component)\n-                                .or_insert_with(Vec::new)\n-                                .push(*ssr_module);\n+\n+                    let ty = match module_type {\n+                        ClientReferenceMapType::EcmascriptClientReference {\n+                            module,\n+                            ssr_module: _,\n+                        } => ClientReferenceType::EcmascriptClientReference(*module),\n+                        ClientReferenceMapType::CssClientReference(module) => {\n+                            ClientReferenceType::CssClientReference(*module)\n                         }\n-                        Some(ClientReferenceMapType::CssClientReference(module_ref)) => {\n-                            let client_reference = ClientReference {\n-                                server_component: parent_server_component,\n-                                ty: ClientReferenceType::CssClientReference(*module_ref),\n-                            };\n-                            client_references.insert(client_reference);\n+                        ClientReferenceMapType::ServerComponent(sc) => {\n+                            server_components.insert(*sc);\n+                            return Ok(());\n                         }\n-                        _ => {}\n                     };\n+\n+                    if *state_map.get(&module).unwrap() == ParentType::ServerComponent {\n+                        // This is only reachable through server components, we need to wait to\n+                        // compute the client references until we have seen all server components\n+                        // reachable by this entrypoint, then we can intersect that with the set of\n+                        // server components that depend on this client reference\n+                        client_reference_modules.push((module, ty));\n+                    } else {\n+                        // Otherwise there is some path from the root directly to the reference,\n+                        // just associate it with the root.\n+                        client_references.push(ClientReference {\n+                            server_component: None,\n+                            ty,\n+                        })\n+                    }\n+\n                     Ok(())\n                 },\n             )?;\n \n+            // Now compute all the parent components for each client reference module reachable from\n+            // server components\n+            client_references.extend(client_reference_modules.into_iter().flat_map(\n+                |(module, ty)| {\n+                    data.server_components_for_client_reference(module)\n+                        .filter(|sc| server_components.contains(sc))\n+                        .map(move |sc| ClientReference {\n+                            server_component: Some(sc),\n+                            ty,\n+                        })\n+                },\n+            ));\n+\n             Ok(ClientReferenceGraphResult {\n                 client_references: client_references.into_iter().collect(),\n-                client_references_by_server_component,\n                 server_utils: vec![],\n                 server_component_entries: vec![],\n             }\n@@ -679,11 +726,7 @@ impl GlobalBuildInformation {\n                 let results = self\n                     .client_references\n                     .iter()\n-                    .map(|graph| async move {\n-                        let get_client_references_for_endpoint =\n-                            graph.get_client_references_for_endpoint(entry).await?;\n-                        Ok(get_client_references_for_endpoint)\n-                    })\n+                    .map(|graph| graph.get_client_references_for_endpoint(entry))\n                     .try_join()\n                     .await?;\n \n@@ -695,6 +738,12 @@ impl GlobalBuildInformation {\n                 result\n             };\n \n+            // TODO(luke.sandberg): at least in the whole_app_module_graph case we should be able to\n+            // collect server components and server utilities during the above traversals in the\n+            // correct order.  `find_server_entries returns them in reverse topological order (root\n+            // layout first, page last) but the above traversals find them in DFS post\n+            // order which means we would need to reverse it.\n+            // For server_utils the order is irrelevant.\n             if has_layout_segments {\n                 // Do this separately for now, because the graph traversal order messes up the order\n                 // of the server_component_entries."
        },
        {
            "sha": "3dda849ca17c0357b70b066ba0f21fa985e841c1",
            "filename": "crates/next-core/src/next_client_reference/visit_client_reference.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 11,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/4b27fb7bec79ba42df63682887fbcb00c6689422/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4b27fb7bec79ba42df63682887fbcb00c6689422/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs?ref=4b27fb7bec79ba42df63682887fbcb00c6689422",
            "patch": "@@ -6,7 +6,7 @@ use serde::{Deserialize, Serialize};\n use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    FxIndexMap, FxIndexSet, NonLocalValue, ReadRef, ResolvedVc, TryJoinIterExt, ValueToString, Vc,\n+    FxIndexSet, NonLocalValue, ReadRef, ResolvedVc, TryJoinIterExt, ValueToString, Vc,\n     debug::ValueDebugFormat,\n     graph::{AdjacencyMap, GraphTraversal, Visit, VisitControlFlow},\n     trace::TraceRawVcs,\n@@ -75,10 +75,6 @@ pub enum ClientReferenceType {\n #[derive(Clone, Debug, Default)]\n pub struct ClientReferenceGraphResult {\n     pub client_references: Vec<ClientReference>,\n-    /// Only the [`ClientReferenceType::EcmascriptClientReference`]s are listed in this map.\n-    #[allow(clippy::type_complexity)]\n-    pub client_references_by_server_component:\n-        FxIndexMap<Option<ResolvedVc<NextServerComponentModule>>, Vec<ResolvedVc<Box<dyn Module>>>>,\n     pub server_component_entries: Vec<ResolvedVc<NextServerComponentModule>>,\n     pub server_utils: Vec<ResolvedVc<NextServerUtilityModule>>,\n }\n@@ -115,12 +111,6 @@ impl ClientReferenceGraphResult {\n     pub fn extend(&mut self, other: &Self) {\n         self.client_references\n             .extend(other.client_references.iter().copied());\n-        for (k, v) in other.client_references_by_server_component.iter() {\n-            self.client_references_by_server_component\n-                .entry(*k)\n-                .or_insert_with(Vec::new)\n-                .extend(v);\n-        }\n         self.server_component_entries\n             .extend(other.server_component_entries.iter().copied());\n         self.server_utils.extend(other.server_utils.iter().copied());"
        },
        {
            "sha": "1d8e05f4a1100f2460093e52cbcf43af62a7934c",
            "filename": "test/e2e/app-dir/initial-css-not-found/initial-css-not-found.test.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 6,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/4b27fb7bec79ba42df63682887fbcb00c6689422/test%2Fe2e%2Fapp-dir%2Finitial-css-not-found%2Finitial-css-not-found.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/4b27fb7bec79ba42df63682887fbcb00c6689422/test%2Fe2e%2Fapp-dir%2Finitial-css-not-found%2Finitial-css-not-found.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Finitial-css-not-found%2Finitial-css-not-found.test.ts?ref=4b27fb7bec79ba42df63682887fbcb00c6689422",
            "patch": "@@ -10,15 +10,11 @@ describe('initial-css-not-found', () => {\n   it('should serve styles', async () => {\n     const browser = await next.browser('/')\n \n+    // Simply check that our css was served and applied.\n     expect(\n       await browser.eval(\n         `window.getComputedStyle(document.querySelector('body')).color`\n       )\n-    ).toBe(\n-      // This only fails in production turbopack builds\n-      process.env.IS_TURBOPACK_TEST && process.env.NEXT_TEST_MODE !== 'dev'\n-        ? 'rgb(0, 0, 0)'\n-        : 'rgb(255, 0, 0)'\n-    )\n+    ).toBe('rgb(255, 0, 0)')\n   })\n })"
        },
        {
            "sha": "44f8da8905030ff84fa8a50a631d8d0ab55d8705",
            "filename": "turbopack/crates/turbopack-core/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/4b27fb7bec79ba42df63682887fbcb00c6689422/turbopack%2Fcrates%2Fturbopack-core%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/4b27fb7bec79ba42df63682887fbcb00c6689422/turbopack%2Fcrates%2Fturbopack-core%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2FCargo.toml?ref=4b27fb7bec79ba42df63682887fbcb00c6689422",
            "patch": "@@ -24,7 +24,7 @@ indexmap = { workspace = true }\n once_cell = { workspace = true }\n patricia_tree = \"0.5.5\"\n petgraph = { workspace = true, features = [\"serde-1\"] }\n-roaring = { version = \"0.10.10\", features = [\"serde\"] }\n+roaring = { workspace = true, features = [\"serde\"] }\n ref-cast = \"1.0.20\"\n rustc-hash = { workspace = true }\n regex = { workspace = true }"
        },
        {
            "sha": "242fa60ef0fb379e54873a2b09c329cac9851be0",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/4b27fb7bec79ba42df63682887fbcb00c6689422/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4b27fb7bec79ba42df63682887fbcb00c6689422/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=4b27fb7bec79ba42df63682887fbcb00c6689422",
            "patch": "@@ -25,6 +25,7 @@ use crate::{\n #[derive(\n     Clone, Debug, Default, PartialEq, Serialize, Deserialize, TraceRawVcs, ValueDebugFormat,\n )]\n+#[repr(transparent)]\n pub struct RoaringBitmapWrapper(#[turbo_tasks(trace_ignore)] pub RoaringBitmap);\n \n impl TaskInput for RoaringBitmapWrapper {"
        },
        {
            "sha": "2d5bcc610a991670a598eded969c472ac6b74f42",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 116,
            "deletions": 0,
            "changes": 116,
            "blob_url": "https://github.com/vercel/next.js/blob/4b27fb7bec79ba42df63682887fbcb00c6689422/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4b27fb7bec79ba42df63682887fbcb00c6689422/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=4b27fb7bec79ba42df63682887fbcb00c6689422",
            "patch": "@@ -563,6 +563,70 @@ impl SingleModuleGraph {\n         Ok(())\n     }\n \n+    /// Traverses all reachable nodes and also continue revisiting them as long the visitor returns\n+    /// GraphTraversalAction::Continue. The visitor is responsible for the runtime complexity and\n+    /// eventual termination of the traversal. This corresponds to computing a fixed point state for\n+    /// the graph.\n+    ///\n+    /// It is guaranteed that the parent node passed to the `visit` function, if any, has\n+    /// already been passed to `visit`.\n+    ///\n+    /// * `entries` - The entry modules to start the traversal from\n+    /// * `visit` - Called for a specific edge\n+    ///    - Receives: Option(originating &SingleModuleGraphNode, edge &ChunkingType), target\n+    ///      &SingleModuleGraphNode\n+    ///    - Return [GraphTraversalAction]s to control the traversal\n+    ///\n+    /// Returns the number of node visits (i.e. higher than the node\n+    /// count if there are retraversals).\n+    pub fn traverse_edges_from_entries_fixed_point<'a>(\n+        &'a self,\n+        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n+        mut visit: impl FnMut(\n+            Option<(&'a SingleModuleGraphModuleNode, &'a RefData)>,\n+            &'a SingleModuleGraphNode,\n+        ) -> Result<GraphTraversalAction>,\n+    ) -> Result<usize> {\n+        let mut queue = VecDeque::default();\n+        let mut queue_set = FxHashSet::default();\n+\n+        for module in entries {\n+            let index = self.get_module(module).unwrap();\n+            let action = visit(None, self.graph.node_weight(index).unwrap())?;\n+            if action == GraphTraversalAction::Continue && queue_set.insert(index) {\n+                queue.push_back(index);\n+            }\n+        }\n+\n+        let mut visit_count = 0;\n+        while let Some(index) = queue.pop_front() {\n+            queue_set.remove(&index);\n+            let node = match self.graph.node_weight(index).unwrap() {\n+                SingleModuleGraphNode::Module(single_module_graph_module_node) => {\n+                    single_module_graph_module_node\n+                }\n+                _ => {\n+                    continue; // we don't traverse into parent graphs\n+                }\n+            };\n+            visit_count += 1;\n+            for edge in self\n+                .graph\n+                .edges_directed(index, petgraph::Direction::Outgoing)\n+            {\n+                let refdata = edge.weight();\n+                let target_index = edge.target();\n+                let target = self.graph.node_weight(edge.target()).unwrap();\n+                let action = visit(Some((node, refdata)), target)?;\n+                if action == GraphTraversalAction::Continue && queue_set.insert(target_index) {\n+                    queue.push_back(target_index);\n+                }\n+            }\n+        }\n+\n+        Ok(visit_count)\n+    }\n+\n     /// Traverses all reachable edges in dfs order. The preorder visitor can be used to\n     /// forward state down the graph, and to skip subgraphs.\n     ///\n@@ -1937,6 +2001,58 @@ pub mod tests {\n         .await;\n     }\n \n+    #[tokio::test]\n+    async fn traverse_edges_from_entries_fixed_point_cycle() {\n+        run_graph_test(\n+            vec![rcstr!(\"a.js\")],\n+            {\n+                let mut deps = FxHashMap::default();\n+                // A cycle of length 3\n+                deps.insert(rcstr!(\"a.js\"), vec![rcstr!(\"b.js\")]);\n+                deps.insert(rcstr!(\"b.js\"), vec![rcstr!(\"c.js\")]);\n+                deps.insert(rcstr!(\"c.js\"), vec![rcstr!(\"a.js\")]);\n+                deps\n+            },\n+            |graph, entry_modules, module_to_name| {\n+                let mut visits = Vec::new();\n+                let mut count = 0;\n+\n+                graph.traverse_edges_from_entries_fixed_point(\n+                    entry_modules,\n+                    |parent, target| {\n+                        visits.push((\n+                            parent\n+                                .map(|(node, _)| module_to_name.get(&node.module).unwrap().clone()),\n+                            module_to_name.get(&target.module()).unwrap().clone(),\n+                        ));\n+                        count += 1;\n+\n+                        // We are a cycle so we need to break the loop eventually\n+                        Ok(if count < 6 {\n+                            GraphTraversalAction::Continue\n+                        } else {\n+                            GraphTraversalAction::Skip\n+                        })\n+                    },\n+                )?;\n+                assert_eq!(\n+                    vec![\n+                        (None, rcstr!(\"a.js\")),\n+                        (Some(rcstr!(\"a.js\")), rcstr!(\"b.js\")),\n+                        (Some(rcstr!(\"b.js\")), rcstr!(\"c.js\")),\n+                        (Some(rcstr!(\"c.js\")), rcstr!(\"a.js\")),\n+                        // we start following the cycle again\n+                        (Some(rcstr!(\"a.js\")), rcstr!(\"b.js\")),\n+                        (Some(rcstr!(\"b.js\")), rcstr!(\"c.js\")),\n+                    ],\n+                    visits\n+                );\n+\n+                Ok(())\n+            },\n+        )\n+        .await;\n+    }\n     #[turbo_tasks::value(shared)]\n     struct TestRepo {\n         repo: FxHashMap<FileSystemPath, Vec<FileSystemPath>>,"
        },
        {
            "sha": "c3f9ddaa965491b90d68b2bf92127b6a44218830",
            "filename": "turbopack/crates/turbopack-trace-server/src/main.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/4b27fb7bec79ba42df63682887fbcb00c6689422/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fmain.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4b27fb7bec79ba42df63682887fbcb00c6689422/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fmain.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fmain.rs?ref=4b27fb7bec79ba42df63682887fbcb00c6689422",
            "patch": "@@ -30,7 +30,9 @@ fn main() {\n     let args: FxIndexSet<String> = std::env::args().skip(1).collect();\n \n     let mut iter = args.iter();\n-    let arg = iter.next().expect(\"missing argument: trace file path\");\n+    let arg = iter\n+        .next()\n+        .expect(\"missing positional argument for the trace file path\");\n     let port = iter.next().map_or(5747, |s| s.parse().unwrap());\n \n     let store = Arc::new(StoreContainer::new());"
        }
    ],
    "stats": {
        "total": 468,
        "additions": 376,
        "deletions": 92
    }
}