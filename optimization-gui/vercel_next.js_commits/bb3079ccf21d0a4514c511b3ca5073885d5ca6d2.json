{
    "author": "acdlite",
    "message": "Unify Link and Form prefetching (#76184)\n\nThis updates the Form component to use the same visibility tracking\nimplementation as the Link component.\n\nIt's basically the same changes that were introduced in\nhttps://github.com/vercel/next.js/pull/74670. The resulting improvements\nare the same as those for Link:\n\n- Prefetches are initiated directly inside the IntersectionObserver, not\nin a useEffect.\n- Prefetches initiated by a form component will be canceled if the form\nexits the viewport (if the Segment Cache is enabled).\n- Prefetches will be re-triggered when the cache is invalidated (if the\nSegment Cache is enabled).",
    "sha": "bb3079ccf21d0a4514c511b3ca5073885d5ca6d2",
    "files": [
        {
            "sha": "e968cf42379e7961c59b891434d8453c3bf50387",
            "filename": "packages/next/src/client/app-dir/form.tsx",
            "status": "modified",
            "additions": 20,
            "deletions": 23,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Fform.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Fform.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Fform.tsx?ref=bb3079ccf21d0a4514c511b3ca5073885d5ca6d2",
            "patch": "@@ -1,8 +1,7 @@\n 'use client'\n \n-import { useEffect, type FormEvent, useContext } from 'react'\n+import { useCallback, type FormEvent, useContext } from 'react'\n import { addBasePath } from '../add-base-path'\n-import { useIntersection } from '../use-intersection'\n import { useMergedRef } from '../use-merged-ref'\n import {\n   AppRouterContext,\n@@ -17,6 +16,10 @@ import {\n   hasUnsupportedSubmitterAttributes,\n   type FormProps,\n } from '../form-shared'\n+import {\n+  mountLinkInstance,\n+  unmountLinkInstance,\n+} from '../components/segment-cache/links'\n \n export type { FormProps }\n \n@@ -93,39 +96,33 @@ export default function Form({\n     // if we don't have an action path, we can't prefetch anything.\n     !!router && isNavigatingForm && prefetch === null\n \n-  const [setIntersectionRef, isVisible] = useIntersection({\n-    rootMargin: '200px',\n-    disabled: !isPrefetchEnabled,\n-  })\n+  const observeFormVisibilityOnMount = useCallback(\n+    (element: HTMLFormElement) => {\n+      if (isPrefetchEnabled && router !== null) {\n+        mountLinkInstance(element, actionProp, router, PrefetchKind.AUTO)\n+      }\n+      return () => {\n+        unmountLinkInstance(element)\n+      }\n+    },\n+    [isPrefetchEnabled, actionProp, router]\n+  )\n \n-  const ownRef = useMergedRef<HTMLFormElement>(\n-    setIntersectionRef,\n+  const mergedRef = useMergedRef(\n+    observeFormVisibilityOnMount,\n     externalRef ?? null\n   )\n \n-  useEffect(() => {\n-    if (!isVisible || !isPrefetchEnabled) {\n-      return\n-    }\n-\n-    try {\n-      const prefetchKind = PrefetchKind.AUTO\n-      router.prefetch(actionProp, { kind: prefetchKind })\n-    } catch (err) {\n-      console.error(err)\n-    }\n-  }, [isPrefetchEnabled, isVisible, actionProp, prefetch, router])\n-\n   if (!isNavigatingForm) {\n-    return <form {...props} ref={ownRef} />\n+    return <form {...props} ref={mergedRef} />\n   }\n \n   const actionHref = addBasePath(actionProp)\n \n   return (\n     <form\n       {...props}\n-      ref={ownRef}\n+      ref={mergedRef}\n       action={actionHref}\n       onSubmit={(event) =>\n         onFormSubmit(event, {"
        },
        {
            "sha": "20a056596749533a9d3cfc4001644d75cc8cdf94",
            "filename": "packages/next/src/client/app-dir/link.tsx",
            "status": "modified",
            "additions": 4,
            "deletions": 285,
            "changes": 289,
            "blob_url": "https://github.com/vercel/next.js/blob/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Flink.tsx?ref=bb3079ccf21d0a4514c511b3ca5073885d5ca6d2",
            "patch": "@@ -13,17 +13,10 @@ import { isAbsoluteUrl } from '../../shared/lib/utils'\n import { addBasePath } from '../add-base-path'\n import { warnOnce } from '../../shared/lib/utils/warn-once'\n import {\n-  type PrefetchTask,\n-  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n-  cancelPrefetchTask,\n-  bumpPrefetchTask,\n-  PrefetchPriority,\n-} from '../components/segment-cache/scheduler'\n-import { getCurrentAppRouterState } from '../../shared/lib/router/action-queue'\n-import { createCacheKey } from '../components/segment-cache/cache-key'\n-import { createPrefetchURL } from '../components/app-router'\n-import type { FlightRouterState } from '../../server/app-render/types'\n-import { getCurrentCacheVersion } from '../components/segment-cache/cache'\n+  mountLinkInstance,\n+  onNavigationIntent,\n+  unmountLinkInstance,\n+} from '../components/segment-cache/links'\n \n type Url = string | UrlObject\n type RequiredKeys<T> = {\n@@ -211,280 +204,6 @@ export type LinkProps<RouteInferType = any> = InternalLinkProps\n type LinkPropsRequired = RequiredKeys<LinkProps>\n type LinkPropsOptional = OptionalKeys<Omit<InternalLinkProps, 'locale'>>\n \n-type LinkInstance = {\n-  router: AppRouterInstance\n-  kind: PrefetchKind.AUTO | PrefetchKind.FULL\n-  prefetchHref: string\n-\n-  isVisible: boolean\n-  wasHoveredOrTouched: boolean\n-\n-  // The most recently initiated prefetch task. It may or may not have\n-  // already completed.  The same prefetch task object can be reused across\n-  // multiple prefetches of the same link.\n-  prefetchTask: PrefetchTask | null\n-\n-  // The cache version at the time the task was initiated. This is used to\n-  // determine if the cache was invalidated since the task was initiated.\n-  cacheVersion: number\n-}\n-\n-// Use a WeakMap to associate a Link instance with its DOM element. This is\n-// used by the IntersectionObserver to track the link's visibility.\n-const links:\n-  | WeakMap<HTMLAnchorElement | SVGAElement, LinkInstance>\n-  | Map<Element, LinkInstance> =\n-  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n-\n-// A Set of the currently visible links. We re-prefetch visible links after a\n-// cache invalidation, or when the current URL changes. It's a separate data\n-// structure from the WeakMap above because only the visible links need to\n-// be enumerated.\n-const visibleLinks: Set<LinkInstance> = new Set()\n-\n-// A single IntersectionObserver instance shared by all <Link> components.\n-const observer: IntersectionObserver | null =\n-  typeof IntersectionObserver === 'function'\n-    ? new IntersectionObserver(handleIntersect, {\n-        rootMargin: '200px',\n-      })\n-    : null\n-\n-function mountLinkInstance(\n-  element: HTMLAnchorElement | SVGAElement,\n-  href: string,\n-  router: AppRouterInstance,\n-  kind: PrefetchKind.AUTO | PrefetchKind.FULL\n-) {\n-  let prefetchUrl: URL | null = null\n-  try {\n-    prefetchUrl = createPrefetchURL(href)\n-    if (prefetchUrl === null) {\n-      // We only track the link if it's prefetchable. For example, this excludes\n-      // links to external URLs.\n-      return\n-    }\n-  } catch {\n-    // createPrefetchURL sometimes throws an error if an invalid URL is\n-    // provided, though I'm not sure if it's actually necessary.\n-    // TODO: Consider removing the throw from the inner function, or change it\n-    // to reportError. Or maybe the error isn't even necessary for automatic\n-    // prefetches, just navigations.\n-    const reportErrorFn =\n-      typeof reportError === 'function' ? reportError : console.error\n-    reportErrorFn(\n-      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n-    )\n-    return\n-  }\n-\n-  const instance: LinkInstance = {\n-    prefetchHref: prefetchUrl.href,\n-    router,\n-    kind,\n-    isVisible: false,\n-    wasHoveredOrTouched: false,\n-    prefetchTask: null,\n-    cacheVersion: -1,\n-  }\n-  const existingInstance = links.get(element)\n-  if (existingInstance !== undefined) {\n-    // This shouldn't happen because each <Link> component should have its own\n-    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n-    // case there's a logical error somewhere else.\n-    unmountLinkInstance(element)\n-  }\n-  links.set(element, instance)\n-  if (observer !== null) {\n-    observer.observe(element)\n-  }\n-}\n-\n-function unmountLinkInstance(element: HTMLAnchorElement | SVGAElement) {\n-  const instance = links.get(element)\n-  if (instance !== undefined) {\n-    links.delete(element)\n-    visibleLinks.delete(instance)\n-    const prefetchTask = instance.prefetchTask\n-    if (prefetchTask !== null) {\n-      cancelPrefetchTask(prefetchTask)\n-    }\n-  }\n-  if (observer !== null) {\n-    observer.unobserve(element)\n-  }\n-}\n-\n-function handleIntersect(entries: Array<IntersectionObserverEntry>) {\n-  for (const entry of entries) {\n-    // Some extremely old browsers or polyfills don't reliably support\n-    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n-    // really. But whatever this is fine.)\n-    const isVisible = entry.intersectionRatio > 0\n-    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n-  }\n-}\n-\n-function onLinkVisibilityChanged(\n-  element: HTMLAnchorElement | SVGAElement,\n-  isVisible: boolean\n-) {\n-  if (process.env.NODE_ENV !== 'production') {\n-    // Prefetching on viewport is disabled in development for performance\n-    // reasons, because it requires compiling the target page.\n-    // TODO: Investigate re-enabling this.\n-    return\n-  }\n-\n-  const instance = links.get(element)\n-  if (instance === undefined) {\n-    return\n-  }\n-\n-  instance.isVisible = isVisible\n-  if (isVisible) {\n-    visibleLinks.add(instance)\n-  } else {\n-    visibleLinks.delete(instance)\n-  }\n-  rescheduleLinkPrefetch(instance)\n-}\n-\n-function onNavigationIntent(element: HTMLAnchorElement | SVGAElement) {\n-  const instance = links.get(element)\n-  if (instance === undefined) {\n-    return\n-  }\n-  // Prefetch the link on hover/touchstart.\n-  if (instance !== undefined) {\n-    instance.wasHoveredOrTouched = true\n-    rescheduleLinkPrefetch(instance)\n-  }\n-}\n-\n-function rescheduleLinkPrefetch(instance: LinkInstance) {\n-  const existingPrefetchTask = instance.prefetchTask\n-\n-  if (!instance.isVisible) {\n-    // Cancel any in-progress prefetch task. (If it already finished then this\n-    // is a no-op.)\n-    if (existingPrefetchTask !== null) {\n-      cancelPrefetchTask(existingPrefetchTask)\n-    }\n-    // We don't need to reset the prefetchTask to null upon cancellation; an\n-    // old task object can be rescheduled with bumpPrefetchTask. This is a\n-    // micro-optimization but also makes the code simpler (don't need to\n-    // worry about whether an old task object is stale).\n-    return\n-  }\n-\n-  if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n-    // The old prefetch implementation does not have different priority levels.\n-    // Just schedule a new prefetch task.\n-    prefetchWithOldCacheImplementation(instance)\n-    return\n-  }\n-\n-  // In the Segment Cache implementation, we assign a higher priority level to\n-  // links that were at one point hovered or touched. Since the queue is last-\n-  // in-first-out, the highest priority Link is whichever one was hovered last.\n-  //\n-  // We also increase the relative priority of links whenever they re-enter the\n-  // viewport, as if they were being scheduled for the first time.\n-  const priority = instance.wasHoveredOrTouched\n-    ? PrefetchPriority.Intent\n-    : PrefetchPriority.Default\n-  if (existingPrefetchTask === null) {\n-    // Initiate a prefetch task.\n-    const appRouterState = getCurrentAppRouterState()\n-    if (appRouterState !== null) {\n-      const nextUrl = appRouterState.nextUrl\n-      const treeAtTimeOfPrefetch = appRouterState.tree\n-      const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n-      instance.prefetchTask = scheduleSegmentPrefetchTask(\n-        cacheKey,\n-        treeAtTimeOfPrefetch,\n-        instance.kind === PrefetchKind.FULL,\n-        priority\n-      )\n-      instance.cacheVersion = getCurrentCacheVersion()\n-    }\n-  } else {\n-    // We already have an old task object that we can reschedule. This is\n-    // effectively the same as canceling the old task and creating a new one.\n-    bumpPrefetchTask(existingPrefetchTask, priority)\n-  }\n-}\n-\n-export function pingVisibleLinks(\n-  nextUrl: string | null,\n-  tree: FlightRouterState\n-) {\n-  // For each currently visible link, cancel the existing prefetch task (if it\n-  // exists) and schedule a new one. This is effectively the same as if all the\n-  // visible links left and then re-entered the viewport.\n-  //\n-  // This is called when the Next-Url or the base tree changes, since those\n-  // may affect the result of a prefetch task. It's also called after a\n-  // cache invalidation.\n-  const currentCacheVersion = getCurrentCacheVersion()\n-  for (const instance of visibleLinks) {\n-    const task = instance.prefetchTask\n-    if (\n-      task !== null &&\n-      instance.cacheVersion === currentCacheVersion &&\n-      task.key.nextUrl === nextUrl &&\n-      task.treeAtTimeOfPrefetch === tree\n-    ) {\n-      // The cache has not been invalidated, and none of the inputs have\n-      // changed. Bail out.\n-      continue\n-    }\n-    // Something changed. Cancel the existing prefetch task and schedule a\n-    // new one.\n-    if (task !== null) {\n-      cancelPrefetchTask(task)\n-    }\n-    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n-    const priority = instance.wasHoveredOrTouched\n-      ? PrefetchPriority.Intent\n-      : PrefetchPriority.Default\n-    instance.prefetchTask = scheduleSegmentPrefetchTask(\n-      cacheKey,\n-      tree,\n-      instance.kind === PrefetchKind.FULL,\n-      priority\n-    )\n-    instance.cacheVersion = getCurrentCacheVersion()\n-  }\n-}\n-\n-function prefetchWithOldCacheImplementation(instance: LinkInstance) {\n-  // This is the path used when the Segment Cache is not enabled.\n-  if (typeof window === 'undefined') {\n-    return\n-  }\n-\n-  const doPrefetch = async () => {\n-    // note that `appRouter.prefetch()` is currently sync,\n-    // so we have to wrap this call in an async function to be able to catch() errors below.\n-    return instance.router.prefetch(instance.prefetchHref, {\n-      kind: instance.kind,\n-    })\n-  }\n-\n-  // Prefetch the page if asked (only in the client)\n-  // We need to handle a prefetch error here since we may be\n-  // loading with priority which can reject but we don't\n-  // want to force navigation since this is only a prefetch\n-  doPrefetch().catch((err) => {\n-    if (process.env.NODE_ENV !== 'production') {\n-      // rethrow to show invalid URL errors\n-      throw err\n-    }\n-  })\n-}\n-\n function isModifiedEvent(event: React.MouseEvent): boolean {\n   const eventTarget = event.currentTarget as HTMLAnchorElement | SVGAElement\n   const target = eventTarget.getAttribute('target')"
        },
        {
            "sha": "ad3659425bb97b70b8564d5d17ca4991c1133291",
            "filename": "packages/next/src/client/components/app-router.tsx",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fapp-router.tsx?ref=bb3079ccf21d0a4514c511b3ca5073885d5ca6d2",
            "patch": "@@ -62,7 +62,7 @@ import { prefetch as prefetchWithSegmentCache } from '../components/segment-cach\n import { getRedirectTypeFromError, getURLFromRedirectError } from './redirect'\n import { isRedirectError, RedirectType } from './redirect-error'\n import { prefetchReducer } from './router-reducer/reducers/prefetch-reducer'\n-import { pingVisibleLinks } from '../app-dir/link'\n+import { pingVisibleLinks } from './segment-cache/links'\n \n const globalMutable: {\n   pendingMpaPath?: string"
        },
        {
            "sha": "634a8436f9eb7044070eaee363c5eb8836f0d074",
            "filename": "packages/next/src/client/components/router-reducer/reducers/server-action-reducer.ts",
            "status": "modified",
            "additions": 11,
            "deletions": 6,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fserver-action-reducer.ts?ref=bb3079ccf21d0a4514c511b3ca5073885d5ca6d2",
            "patch": "@@ -360,12 +360,17 @@ export function serverActionReducer(\n       }\n \n       if (redirectLocation && redirectHref) {\n-        // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n-        // with the FlightData that we got from the server action for the target page, so that it's\n-        // available when the page is navigated to and doesn't need to be re-fetched.\n-        // We only do this if the server action didn't revalidate any data, as in that case the\n-        // client cache will be cleared and the data will be re-fetched anyway.\n-        if (!actionRevalidated) {\n+        if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE && !actionRevalidated) {\n+          // Because the RedirectBoundary will trigger a navigation, we need to seed the prefetch cache\n+          // with the FlightData that we got from the server action for the target page, so that it's\n+          // available when the page is navigated to and doesn't need to be re-fetched.\n+          // We only do this if the server action didn't revalidate any data, as in that case the\n+          // client cache will be cleared and the data will be re-fetched anyway.\n+          // NOTE: We don't do this in the Segment Cache implementation.\n+          // Dynamic data should never be placed into the cache, unless it's\n+          // \"converted\" to static data using <Link prefetch={true}>. What we\n+          // do instead is re-prefetch links and forms whenever the cache is\n+          // invalidated.\n           createSeededPrefetchCacheEntry({\n             url: redirectLocation,\n             data: {"
        },
        {
            "sha": "e2ca3d9bd2338a7ce190a75d8f4d485d998fdaa6",
            "filename": "packages/next/src/client/components/segment-cache/cache.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fcache.ts?ref=bb3079ccf21d0a4514c511b3ca5073885d5ca6d2",
            "patch": "@@ -52,7 +52,7 @@ import type {\n } from '../../../server/app-render/types'\n import { normalizeFlightData } from '../../flight-data-helpers'\n import { STATIC_STALETIME_MS } from '../router-reducer/prefetch-cache-utils'\n-import { pingVisibleLinks } from '../../app-dir/link'\n+import { pingVisibleLinks } from './links'\n \n // A note on async/await when working in the prefetch cache:\n //"
        },
        {
            "sha": "3756f480ef2d420a12ddc7014c5d23578f33a2c5",
            "filename": "packages/next/src/client/components/segment-cache/links.ts",
            "status": "added",
            "additions": 288,
            "deletions": 0,
            "changes": 288,
            "blob_url": "https://github.com/vercel/next.js/blob/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Flinks.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Flinks.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Flinks.ts?ref=bb3079ccf21d0a4514c511b3ca5073885d5ca6d2",
            "patch": "@@ -0,0 +1,288 @@\n+import type { FlightRouterState } from '../../../server/app-render/types'\n+import type { AppRouterInstance } from '../../../shared/lib/app-router-context.shared-runtime'\n+import { getCurrentAppRouterState } from '../../../shared/lib/router/action-queue'\n+import { createPrefetchURL } from '../app-router'\n+import { PrefetchKind } from '../router-reducer/router-reducer-types'\n+import { getCurrentCacheVersion } from './cache'\n+import { createCacheKey } from './cache-key'\n+import {\n+  type PrefetchTask,\n+  PrefetchPriority,\n+  schedulePrefetchTask as scheduleSegmentPrefetchTask,\n+  cancelPrefetchTask,\n+  bumpPrefetchTask,\n+} from './scheduler'\n+\n+type LinkElement = HTMLAnchorElement | SVGAElement | HTMLFormElement\n+\n+type LinkInstance = {\n+  router: AppRouterInstance\n+  kind: PrefetchKind.AUTO | PrefetchKind.FULL\n+  prefetchHref: string\n+\n+  isVisible: boolean\n+  wasHoveredOrTouched: boolean\n+\n+  // The most recently initiated prefetch task. It may or may not have\n+  // already completed.  The same prefetch task object can be reused across\n+  // multiple prefetches of the same link.\n+  prefetchTask: PrefetchTask | null\n+\n+  // The cache version at the time the task was initiated. This is used to\n+  // determine if the cache was invalidated since the task was initiated.\n+  cacheVersion: number\n+}\n+\n+// Use a WeakMap to associate a Link instance with its DOM element. This is\n+// used by the IntersectionObserver to track the link's visibility.\n+const links: WeakMap<LinkElement, LinkInstance> | Map<Element, LinkInstance> =\n+  typeof WeakMap === 'function' ? new WeakMap() : new Map()\n+\n+// A Set of the currently visible links. We re-prefetch visible links after a\n+// cache invalidation, or when the current URL changes. It's a separate data\n+// structure from the WeakMap above because only the visible links need to\n+// be enumerated.\n+const visibleLinks: Set<LinkInstance> = new Set()\n+\n+// A single IntersectionObserver instance shared by all <Link> components.\n+const observer: IntersectionObserver | null =\n+  typeof IntersectionObserver === 'function'\n+    ? new IntersectionObserver(handleIntersect, {\n+        rootMargin: '200px',\n+      })\n+    : null\n+\n+export function mountLinkInstance(\n+  element: LinkElement,\n+  href: string,\n+  router: AppRouterInstance,\n+  kind: PrefetchKind.AUTO | PrefetchKind.FULL\n+) {\n+  let prefetchUrl: URL | null = null\n+  try {\n+    prefetchUrl = createPrefetchURL(href)\n+    if (prefetchUrl === null) {\n+      // We only track the link if it's prefetchable. For example, this excludes\n+      // links to external URLs.\n+      return\n+    }\n+  } catch {\n+    // createPrefetchURL sometimes throws an error if an invalid URL is\n+    // provided, though I'm not sure if it's actually necessary.\n+    // TODO: Consider removing the throw from the inner function, or change it\n+    // to reportError. Or maybe the error isn't even necessary for automatic\n+    // prefetches, just navigations.\n+    const reportErrorFn =\n+      typeof reportError === 'function' ? reportError : console.error\n+    reportErrorFn(\n+      `Cannot prefetch '${href}' because it cannot be converted to a URL.`\n+    )\n+    return\n+  }\n+\n+  const instance: LinkInstance = {\n+    prefetchHref: prefetchUrl.href,\n+    router,\n+    kind,\n+    isVisible: false,\n+    wasHoveredOrTouched: false,\n+    prefetchTask: null,\n+    cacheVersion: -1,\n+  }\n+  const existingInstance = links.get(element)\n+  if (existingInstance !== undefined) {\n+    // This shouldn't happen because each <Link> component should have its own\n+    // anchor tag instance, but it's defensive coding to avoid a memory leak in\n+    // case there's a logical error somewhere else.\n+    unmountLinkInstance(element)\n+  }\n+  links.set(element, instance)\n+  if (observer !== null) {\n+    observer.observe(element)\n+  }\n+}\n+\n+export function unmountLinkInstance(element: LinkElement) {\n+  const instance = links.get(element)\n+  if (instance !== undefined) {\n+    links.delete(element)\n+    visibleLinks.delete(instance)\n+    const prefetchTask = instance.prefetchTask\n+    if (prefetchTask !== null) {\n+      cancelPrefetchTask(prefetchTask)\n+    }\n+  }\n+  if (observer !== null) {\n+    observer.unobserve(element)\n+  }\n+}\n+\n+function handleIntersect(entries: Array<IntersectionObserverEntry>) {\n+  for (const entry of entries) {\n+    // Some extremely old browsers or polyfills don't reliably support\n+    // isIntersecting so we check intersectionRatio instead. (Do we care? Not\n+    // really. But whatever this is fine.)\n+    const isVisible = entry.intersectionRatio > 0\n+    onLinkVisibilityChanged(entry.target as HTMLAnchorElement, isVisible)\n+  }\n+}\n+\n+export function onLinkVisibilityChanged(\n+  element: LinkElement,\n+  isVisible: boolean\n+) {\n+  if (process.env.NODE_ENV !== 'production') {\n+    // Prefetching on viewport is disabled in development for performance\n+    // reasons, because it requires compiling the target page.\n+    // TODO: Investigate re-enabling this.\n+    return\n+  }\n+\n+  const instance = links.get(element)\n+  if (instance === undefined) {\n+    return\n+  }\n+\n+  instance.isVisible = isVisible\n+  if (isVisible) {\n+    visibleLinks.add(instance)\n+  } else {\n+    visibleLinks.delete(instance)\n+  }\n+  rescheduleLinkPrefetch(instance)\n+}\n+\n+export function onNavigationIntent(element: HTMLAnchorElement | SVGAElement) {\n+  const instance = links.get(element)\n+  if (instance === undefined) {\n+    return\n+  }\n+  // Prefetch the link on hover/touchstart.\n+  if (instance !== undefined) {\n+    instance.wasHoveredOrTouched = true\n+    rescheduleLinkPrefetch(instance)\n+  }\n+}\n+\n+function rescheduleLinkPrefetch(instance: LinkInstance) {\n+  const existingPrefetchTask = instance.prefetchTask\n+\n+  if (!instance.isVisible) {\n+    // Cancel any in-progress prefetch task. (If it already finished then this\n+    // is a no-op.)\n+    if (existingPrefetchTask !== null) {\n+      cancelPrefetchTask(existingPrefetchTask)\n+    }\n+    // We don't need to reset the prefetchTask to null upon cancellation; an\n+    // old task object can be rescheduled with bumpPrefetchTask. This is a\n+    // micro-optimization but also makes the code simpler (don't need to\n+    // worry about whether an old task object is stale).\n+    return\n+  }\n+\n+  if (!process.env.__NEXT_CLIENT_SEGMENT_CACHE) {\n+    // The old prefetch implementation does not have different priority levels.\n+    // Just schedule a new prefetch task.\n+    prefetchWithOldCacheImplementation(instance)\n+    return\n+  }\n+\n+  // In the Segment Cache implementation, we assign a higher priority level to\n+  // links that were at one point hovered or touched. Since the queue is last-\n+  // in-first-out, the highest priority Link is whichever one was hovered last.\n+  //\n+  // We also increase the relative priority of links whenever they re-enter the\n+  // viewport, as if they were being scheduled for the first time.\n+  const priority = instance.wasHoveredOrTouched\n+    ? PrefetchPriority.Intent\n+    : PrefetchPriority.Default\n+  if (existingPrefetchTask === null) {\n+    // Initiate a prefetch task.\n+    const appRouterState = getCurrentAppRouterState()\n+    if (appRouterState !== null) {\n+      const nextUrl = appRouterState.nextUrl\n+      const treeAtTimeOfPrefetch = appRouterState.tree\n+      const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n+      instance.prefetchTask = scheduleSegmentPrefetchTask(\n+        cacheKey,\n+        treeAtTimeOfPrefetch,\n+        instance.kind === PrefetchKind.FULL,\n+        priority\n+      )\n+      instance.cacheVersion = getCurrentCacheVersion()\n+    }\n+  } else {\n+    // We already have an old task object that we can reschedule. This is\n+    // effectively the same as canceling the old task and creating a new one.\n+    bumpPrefetchTask(existingPrefetchTask, priority)\n+  }\n+}\n+\n+export function pingVisibleLinks(\n+  nextUrl: string | null,\n+  tree: FlightRouterState\n+) {\n+  // For each currently visible link, cancel the existing prefetch task (if it\n+  // exists) and schedule a new one. This is effectively the same as if all the\n+  // visible links left and then re-entered the viewport.\n+  //\n+  // This is called when the Next-Url or the base tree changes, since those\n+  // may affect the result of a prefetch task. It's also called after a\n+  // cache invalidation.\n+  const currentCacheVersion = getCurrentCacheVersion()\n+  for (const instance of visibleLinks) {\n+    const task = instance.prefetchTask\n+    if (\n+      task !== null &&\n+      instance.cacheVersion === currentCacheVersion &&\n+      task.key.nextUrl === nextUrl &&\n+      task.treeAtTimeOfPrefetch === tree\n+    ) {\n+      // The cache has not been invalidated, and none of the inputs have\n+      // changed. Bail out.\n+      continue\n+    }\n+    // Something changed. Cancel the existing prefetch task and schedule a\n+    // new one.\n+    if (task !== null) {\n+      cancelPrefetchTask(task)\n+    }\n+    const cacheKey = createCacheKey(instance.prefetchHref, nextUrl)\n+    const priority = instance.wasHoveredOrTouched\n+      ? PrefetchPriority.Intent\n+      : PrefetchPriority.Default\n+    instance.prefetchTask = scheduleSegmentPrefetchTask(\n+      cacheKey,\n+      tree,\n+      instance.kind === PrefetchKind.FULL,\n+      priority\n+    )\n+    instance.cacheVersion = getCurrentCacheVersion()\n+  }\n+}\n+\n+function prefetchWithOldCacheImplementation(instance: LinkInstance) {\n+  // This is the path used when the Segment Cache is not enabled.\n+  if (typeof window === 'undefined') {\n+    return\n+  }\n+\n+  const doPrefetch = async () => {\n+    // note that `appRouter.prefetch()` is currently sync,\n+    // so we have to wrap this call in an async function to be able to catch() errors below.\n+    return instance.router.prefetch(instance.prefetchHref, {\n+      kind: instance.kind,\n+    })\n+  }\n+\n+  // Prefetch the page if asked (only in the client)\n+  // We need to handle a prefetch error here since we may be\n+  // loading with priority which can reject but we don't\n+  // want to force navigation since this is only a prefetch\n+  doPrefetch().catch((err) => {\n+    if (process.env.NODE_ENV !== 'production') {\n+      // rethrow to show invalid URL errors\n+      throw err\n+    }\n+  })\n+}"
        },
        {
            "sha": "fd1dd4646897b6856174c8d9ce0c3bc11b5c6db8",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/app/page.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fapp%2Fpage.tsx?ref=bb3079ccf21d0a4514c511b3ca5073885d5ca6d2",
            "patch": "@@ -1,5 +1,5 @@\n import { revalidatePath, revalidateTag } from 'next/cache'\n-import { LinkAccordion } from '../components/link-accordion'\n+import { LinkAccordion, FormAccordion } from '../components/link-accordion'\n import Link from 'next/link'\n \n export default async function Page() {\n@@ -31,6 +31,11 @@ export default async function Page() {\n             Link to target page with prefetching enabled\n           </LinkAccordion>\n         </li>\n+        <li>\n+          <FormAccordion action=\"/greeting\">\n+            Form pointing to target page with prefetching enabled\n+          </FormAccordion>\n+        </li>\n         <li>\n           <Link prefetch={false} href=\"/greeting\">\n             Link to target with prefetching disabled"
        },
        {
            "sha": "16f565f598ee3290add57f34000d083567f60f39",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/components/link-accordion.tsx",
            "status": "modified",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fcomponents%2Flink-accordion.tsx?ref=bb3079ccf21d0a4514c511b3ca5073885d5ca6d2",
            "patch": "@@ -1,6 +1,7 @@\n 'use client'\n \n import Link from 'next/link'\n+import Form from 'next/form'\n import { useState } from 'react'\n \n export function LinkAccordion({\n@@ -31,3 +32,32 @@ export function LinkAccordion({\n     </>\n   )\n }\n+\n+export function FormAccordion({\n+  action,\n+  children,\n+  prefetch,\n+}: {\n+  action: string\n+  children: React.ReactNode\n+  prefetch?: null | false\n+}) {\n+  const [isVisible, setIsVisible] = useState(false)\n+  return (\n+    <>\n+      <input\n+        type=\"checkbox\"\n+        checked={isVisible}\n+        onChange={() => setIsVisible(!isVisible)}\n+        data-form-accordion={action}\n+      />\n+      {isVisible ? (\n+        <Form action={action} prefetch={prefetch}>\n+          <button>{children}</button>\n+        </Form>\n+      ) : (\n+        <>{children} (form is hidden)</>\n+      )}\n+    </>\n+  )\n+}"
        },
        {
            "sha": "e6ec7cd1bc521a1b42fc453416a7ef81b287b1a7",
            "filename": "test/e2e/app-dir/segment-cache/revalidation/segment-cache-revalidation.test.ts",
            "status": "modified",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/vercel/next.js/blob/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fsegment-cache-revalidation.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bb3079ccf21d0a4514c511b3ca5073885d5ca6d2/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fsegment-cache-revalidation.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frevalidation%2Fsegment-cache-revalidation.test.ts?ref=bb3079ccf21d0a4514c511b3ca5073885d5ca6d2",
            "patch": "@@ -97,6 +97,59 @@ describe('segment cache (revalidation)', () => {\n     }, 'no-requests')\n   })\n \n+  it('refetch visible Form components after cache is revalidated', async () => {\n+    // This is the same as the previous test, but for forms. Since the\n+    // prefetching implementation is shared between Link and Form, we don't\n+    // bother to test every feature using both Link and Form; this test should\n+    // be sufficient.\n+    let act: ReturnType<typeof createRouterAct>\n+    const browser = await next.browser('/', {\n+      beforePageLoad(page: Playwright.Page) {\n+        act = createRouterAct(page)\n+      },\n+    })\n+\n+    const formVisibilityToggle = await browser.elementByCss(\n+      'input[data-form-accordion=\"/greeting\"]'\n+    )\n+\n+    // Reveal the form that points to the target page to trigger a prefetch\n+    await act(\n+      async () => {\n+        await formVisibilityToggle.click()\n+      },\n+      {\n+        includes: 'random-greeting',\n+      }\n+    )\n+\n+    // Perform an action that calls revalidatePath. This should cause the\n+    // corresponding entry to be evicted from the client cache, and a new\n+    // prefetch to be requested.\n+    await act(\n+      async () => {\n+        const revalidateByPath = await browser.elementById('revalidate-by-path')\n+        await revalidateByPath.click()\n+      },\n+      {\n+        includes: 'random-greeting [1]',\n+      }\n+    )\n+    TestLog.assert(['REQUEST: random-greeting'])\n+\n+    // Navigate to the target page.\n+    await act(async () => {\n+      const button = await browser.elementByCss(\n+        'form[action=\"/greeting\"] button'\n+      )\n+      await button.click()\n+      // Navigation should finish immedately because the page is\n+      // fully prefetched.\n+      const greeting = await browser.elementById('greeting')\n+      expect(await greeting.innerHTML()).toBe('random-greeting [1]')\n+    }, 'no-requests')\n+  })\n+\n   it('evict client cache when Server Action calls revalidateTag', async () => {\n     let act: ReturnType<typeof createRouterAct>\n     const browser = await next.browser('/', {"
        }
    ],
    "stats": {
        "total": 731,
        "additions": 414,
        "deletions": 317
    }
}