{
    "author": "mischnic",
    "message": "Turbopack: store vectors instead of hashmaps in ResolveResult (#76053)\n\n@bgw ðŸ˜‰ \r\n\r\n- We never actually perform any lookup operations on these maps\r\n- While I'm at it, also make that Vec a boxed slice\r\n\r\nNo perf difference though, do we still want this?\r\n\r\n```\r\ntesting against 0293c96cf32\r\n\r\ncanary 0153bc2d61\r\n13,1 GB\r\n\r\n538.20s user 78.03s system 843% cpu 1:13.04 total\r\n553.22s user 84.42s system 893% cpu 1:11.37 total\r\n548.03s user 80.97s system 901% cpu 1:09.79 total\r\n\r\nmischnic/resolve-result-repr e5618d72ed\r\n\r\n13,1 GB\r\n540.10s user 81.18s system 897% cpu 1:09.23 total\r\n542.19s user 80.08s system 896% cpu 1:09.39 total\r\n552.28s user 84.43s system 888% cpu 1:11.63 total\r\n```",
    "sha": "1b845bd997fc3ff374ee6909a24a40fd889a0f22",
    "files": [
        {
            "sha": "1ee89fc4f5dcc55f0fd99f6dd0962bfa52394f86",
            "filename": "crates/next-core/src/hmr_entry.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fhmr_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fhmr_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fhmr_entry.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -132,7 +132,7 @@ impl ValueToString for HmrEntryModuleReference {\n impl ModuleReference for HmrEntryModuleReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::module(self.module).cell()\n+        *ModuleResolveResult::module(self.module)\n     }\n }\n "
        },
        {
            "sha": "4c35279dfd8fb78f68e89daa0a28f091eb9bb943",
            "filename": "crates/next-core/src/next_app/include_modules_module.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_app%2Finclude_modules_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_app%2Finclude_modules_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Finclude_modules_module.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -162,7 +162,7 @@ impl ValueToString for IncludedModuleReference {\n impl ModuleReference for IncludedModuleReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::module(self.module).cell()\n+        *ModuleResolveResult::module(self.module)\n     }\n }\n "
        },
        {
            "sha": "55b594d073b71060698609c2b0b3859d28d78b26",
            "filename": "crates/next-core/src/next_client_reference/css_client_reference/css_client_reference_module.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fcss_client_reference%2Fcss_client_reference_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fcss_client_reference%2Fcss_client_reference_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fcss_client_reference%2Fcss_client_reference_module.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -94,7 +94,7 @@ impl ChunkableModuleReference for CssClientReference {\n impl ModuleReference for CssClientReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::module(self.module).cell()\n+        *ModuleResolveResult::module(self.module)\n     }\n }\n "
        },
        {
            "sha": "fa4d9436ecefbce1a2528ee959293fc98b2dc3e0",
            "filename": "crates/next-core/src/next_client_reference/ecmascript_client_reference/ecmascript_client_reference_module.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fecmascript_client_reference%2Fecmascript_client_reference_module.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -379,7 +379,7 @@ impl ChunkableModuleReference for EcmascriptClientReference {\n impl ModuleReference for EcmascriptClientReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::module(self.module).cell()\n+        *ModuleResolveResult::module(self.module)\n     }\n }\n "
        },
        {
            "sha": "d67e571684a4dc0cd9d9bfb67b3edd8ab20bef87",
            "filename": "crates/next-core/src/next_edge/unsupported.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Funsupported.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Funsupported.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_edge%2Funsupported.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -64,10 +64,9 @@ impl ImportMappingReplacement for NextEdgeUnsupportedModuleReplacer {\n             };\n             let content = AssetContent::file(File::from(code).into());\n             let source = VirtualSource::new(root_path, content).to_resolved().await?;\n-            return Ok(ImportMapResult::Result(\n-                ResolveResult::source(ResolvedVc::upcast(source)).resolved_cell(),\n-            )\n-            .cell());\n+            return Ok(\n+                ImportMapResult::Result(ResolveResult::source(ResolvedVc::upcast(source))).cell(),\n+            );\n         };\n \n         Ok(ImportMapResult::NoEntry.cell())"
        },
        {
            "sha": "a8c5f58ca74acb7cc14206e92c12a8e63cf73e60",
            "filename": "crates/next-core/src/next_font/google/mod.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 15,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -136,10 +136,7 @@ impl NextFontGoogleReplacer {\n             )\n             .cell()),\n         ).to_resolved().await?;\n-        Ok(ImportMapResult::Result(\n-            ResolveResult::source(ResolvedVc::upcast(js_asset)).resolved_cell(),\n-        )\n-        .cell())\n+        Ok(ImportMapResult::Result(ResolveResult::source(ResolvedVc::upcast(js_asset))).cell())\n     }\n }\n \n@@ -268,10 +265,7 @@ impl NextFontGoogleCssModuleReplacer {\n         .to_resolved()\n         .await?;\n \n-        Ok(ImportMapResult::Result(\n-            ResolveResult::source(ResolvedVc::upcast(css_asset)).resolved_cell(),\n-        )\n-        .cell())\n+        Ok(ImportMapResult::Result(ResolveResult::source(ResolvedVc::upcast(css_asset))).cell())\n     }\n }\n \n@@ -380,9 +374,7 @@ impl ImportMappingReplacement for NextFontGoogleFontFileReplacer {\n         // really matter either.\n         let Some(font) = fetch_from_google_fonts(Vc::cell(url.into()), font_virtual_path).await?\n         else {\n-            return Ok(\n-                ImportMapResult::Result(ResolveResult::unresolvable().resolved_cell()).cell(),\n-            );\n+            return Ok(ImportMapResult::Result(ResolveResult::unresolvable()).cell());\n         };\n \n         let font_source = VirtualSource::new(\n@@ -392,10 +384,7 @@ impl ImportMappingReplacement for NextFontGoogleFontFileReplacer {\n         .to_resolved()\n         .await?;\n \n-        Ok(ImportMapResult::Result(\n-            ResolveResult::source(ResolvedVc::upcast(font_source)).resolved_cell(),\n-        )\n-        .cell())\n+        Ok(ImportMapResult::Result(ResolveResult::source(ResolvedVc::upcast(font_source))).cell())\n     }\n }\n "
        },
        {
            "sha": "97cd8e60b5dacc96bab01b7fbc643de0cbdcd702",
            "filename": "crates/next-core/src/next_font/local/mod.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 14,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Fmod.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -122,13 +122,12 @@ impl BeforeResolvePlugin for NextFontLocalResolvePlugin {\n                             .resolved_cell()\n                             .emit();\n \n-                            return Ok(ResolveResultOption::some(\n-                                ResolveResult::primary(ResolveResultItem::Error(ResolvedVc::cell(\n+                            return Ok(ResolveResultOption::some(*ResolveResult::primary(\n+                                ResolveResultItem::Error(ResolvedVc::cell(\n                                     format!(\"Font file not found: Can't resolve {}'\", font_path)\n                                         .into(),\n-                                )))\n-                                .into(),\n-                            ));\n+                                )),\n+                            )));\n                         }\n                     }\n                 }\n@@ -180,9 +179,9 @@ impl BeforeResolvePlugin for NextFontLocalResolvePlugin {\n                 .to_resolved()\n                 .await?;\n \n-                Ok(ResolveResultOption::some(\n-                    ResolveResult::source(ResolvedVc::upcast(js_asset)).cell(),\n-                ))\n+                Ok(ResolveResultOption::some(*ResolveResult::source(\n+                    ResolvedVc::upcast(js_asset),\n+                )))\n             }\n             \"@vercel/turbopack-next/internal/font/local/cssmodule.module.css\" => {\n                 let query = query_vc.await?.to_string();\n@@ -211,9 +210,9 @@ impl BeforeResolvePlugin for NextFontLocalResolvePlugin {\n                 .to_resolved()\n                 .await?;\n \n-                Ok(ResolveResultOption::some(\n-                    ResolveResult::source(ResolvedVc::upcast(css_asset)).cell(),\n-                ))\n+                Ok(ResolveResultOption::some(*ResolveResult::source(\n+                    ResolvedVc::upcast(css_asset),\n+                )))\n             }\n             \"@vercel/turbopack-next/internal/font/local/font\" => {\n                 let NextFontLocalFontFileOptions {\n@@ -243,9 +242,9 @@ impl BeforeResolvePlugin for NextFontLocalResolvePlugin {\n                         .to_resolved()\n                         .await?;\n \n-                Ok(ResolveResultOption::some(\n-                    ResolveResult::source(ResolvedVc::upcast(font_source)).cell(),\n-                ))\n+                Ok(ResolveResultOption::some(*ResolveResult::source(\n+                    ResolvedVc::upcast(font_source),\n+                )))\n             }\n             _ => Ok(ResolveResultOption::none()),\n         }"
        },
        {
            "sha": "dc80d3b2243417cc3fed9d25a71c026497a654f3",
            "filename": "crates/next-core/src/next_server/resolve.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Fresolve.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -415,14 +415,13 @@ impl AfterResolvePlugin for ExternalCjsModulesResolvePlugin {\n             }\n         };\n \n-        Ok(ResolveResultOption::some(\n-            ResolveResult::primary(ResolveResultItem::External {\n+        Ok(ResolveResultOption::some(*ResolveResult::primary(\n+            ResolveResultItem::External {\n                 name: request_str.into(),\n                 ty: external_type,\n                 traced: ExternalTraced::Traced,\n-            })\n-            .cell(),\n-        ))\n+            },\n+        )))\n     }\n }\n "
        },
        {
            "sha": "f5dab3848da23eb5365ed187ccb1d49909e5f063",
            "filename": "crates/next-core/src/next_server_component/server_component_reference.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_server_component%2Fserver_component_reference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_server_component%2Fserver_component_reference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server_component%2Fserver_component_reference.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -37,7 +37,7 @@ impl ValueToString for NextServerComponentModuleReference {\n impl ModuleReference for NextServerComponentModuleReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::module(self.asset).cell()\n+        *ModuleResolveResult::module(self.asset)\n     }\n }\n "
        },
        {
            "sha": "251424566689db32e25807d00d5ae5d0aca9446d",
            "filename": "crates/next-core/src/next_server_utility/server_utility_reference.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_server_utility%2Fserver_utility_reference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_server_utility%2Fserver_utility_reference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server_utility%2Fserver_utility_reference.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -37,7 +37,7 @@ impl ValueToString for NextServerUtilityModuleReference {\n impl ModuleReference for NextServerUtilityModuleReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::module(self.asset).cell()\n+        *ModuleResolveResult::module(self.asset)\n     }\n }\n "
        },
        {
            "sha": "8d950f4da44e4b4e474a317c8f76f6091bcb67bb",
            "filename": "crates/next-core/src/next_shared/resolve.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 23,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_shared%2Fresolve.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -144,12 +144,9 @@ impl BeforeResolvePlugin for InvalidImportResolvePlugin {\n         .resolved_cell()\n         .emit();\n \n-        ResolveResultOption::some(\n-            ResolveResult::primary(ResolveResultItem::Error(ResolvedVc::cell(\n-                self.message.join(\"\\n\").into(),\n-            )))\n-            .cell(),\n-        )\n+        ResolveResultOption::some(*ResolveResult::primary(ResolveResultItem::Error(\n+            ResolvedVc::cell(self.message.join(\"\\n\").into()),\n+        )))\n     }\n }\n \n@@ -245,14 +242,13 @@ impl AfterResolvePlugin for NextExternalResolvePlugin {\n         // Replace '/esm/' with '/' to match the CJS version of the file.\n         let specifier: RcStr = specifier.replace(\"/esm/\", \"/\").into();\n \n-        Ok(Vc::cell(Some(\n-            ResolveResult::primary(ResolveResultItem::External {\n+        Ok(Vc::cell(Some(ResolveResult::primary(\n+            ResolveResultItem::External {\n                 name: specifier.clone(),\n                 ty: ExternalType::CommonJs,\n                 traced: ExternalTraced::Traced,\n-            })\n-            .resolved_cell(),\n-        )))\n+            },\n+        ))))\n     }\n }\n \n@@ -324,12 +320,9 @@ impl AfterResolvePlugin for NextNodeSharedRuntimeResolvePlugin {\n             .root()\n             .join(format!(\"{base}/{resource_request}\").into());\n \n-        Ok(Vc::cell(Some(\n-            ResolveResult::source(ResolvedVc::upcast(\n-                FileSource::new(new_path).to_resolved().await?,\n-            ))\n-            .resolved_cell(),\n-        )))\n+        Ok(Vc::cell(Some(ResolveResult::source(ResolvedVc::upcast(\n+            FileSource::new(new_path).to_resolved().await?,\n+        )))))\n     }\n }\n \n@@ -426,11 +419,8 @@ impl AfterResolvePlugin for NextSharedRuntimeResolvePlugin {\n         let raw_fs_path = &*fs_path.await?;\n         let modified_path = raw_fs_path.path.replace(\"next/dist/esm/\", \"next/dist/\");\n         let new_path = fs_path.root().join(modified_path.into());\n-        Ok(Vc::cell(Some(\n-            ResolveResult::source(ResolvedVc::upcast(\n-                FileSource::new(new_path).to_resolved().await?,\n-            ))\n-            .resolved_cell(),\n-        )))\n+        Ok(Vc::cell(Some(ResolveResult::source(ResolvedVc::upcast(\n+            FileSource::new(new_path).to_resolved().await?,\n+        )))))\n     }\n }"
        },
        {
            "sha": "35a34f3e3f49376f545088a8bdd6bb157dc671e3",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -129,6 +129,8 @@ pub use vc::{\n     VcValueTypeCast,\n };\n \n+pub type SliceMap<K, V> = Box<[(K, V)]>;\n+\n pub type FxIndexSet<T> = indexmap::IndexSet<T, BuildHasherDefault<FxHasher>>;\n pub type FxIndexMap<K, V> = indexmap::IndexMap<K, V, BuildHasherDefault<FxHasher>>;\n pub type FxDashMap<K, V> = dashmap::DashMap<K, V, BuildHasherDefault<FxHasher>>;"
        },
        {
            "sha": "4e59a696a8f0e19cc069eb2c64dc7156179941ac",
            "filename": "turbopack/crates/turbo-tasks/src/trace.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrace.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrace.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrace.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -122,6 +122,14 @@ impl<T: TraceRawVcs> TraceRawVcs for Vec<T> {\n     }\n }\n \n+impl<T: TraceRawVcs> TraceRawVcs for Box<[T]> {\n+    fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n+        for item in self.iter() {\n+            TraceRawVcs::trace_raw_vcs(item, trace_context);\n+        }\n+    }\n+}\n+\n impl<T: TraceRawVcs, const N: usize> TraceRawVcs for [T; N] {\n     fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n         for item in self.iter() {"
        },
        {
            "sha": "951bb4ccc70f3e3778b1a2be61a79a0134175e0f",
            "filename": "turbopack/crates/turbopack-core/src/reference/mod.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fmod.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -56,7 +56,7 @@ pub struct SingleModuleReference {\n impl ModuleReference for SingleModuleReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::module(self.asset).cell()\n+        *ModuleResolveResult::module(self.asset)\n     }\n }\n \n@@ -110,7 +110,7 @@ impl ChunkableModuleReference for SingleChunkableModuleReference {\n impl ModuleReference for SingleChunkableModuleReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::module(self.asset).cell()\n+        *ModuleResolveResult::module(self.asset)\n     }\n }\n \n@@ -133,7 +133,7 @@ pub struct SingleOutputAssetReference {\n impl ModuleReference for SingleOutputAssetReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::output_asset(RequestKey::default(), self.asset).cell()\n+        *ModuleResolveResult::output_asset(RequestKey::default(), self.asset)\n     }\n }\n \n@@ -210,7 +210,7 @@ pub struct TracedModuleReference {\n impl ModuleReference for TracedModuleReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::module(self.module).cell()\n+        *ModuleResolveResult::module(self.module)\n     }\n }\n "
        },
        {
            "sha": "14666d66648db7d433c80a7d3e2587231f93baec",
            "filename": "turbopack/crates/turbopack-core/src/reference/source_map.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fsource_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fsource_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Freference%2Fsource_map.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -44,14 +44,13 @@ impl ModuleReference for SourceMapReference {\n     #[turbo_tasks::function]\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n         if let Some(file) = self.get_file().await {\n-            return Ok(ModuleResolveResult::module(ResolvedVc::upcast(\n+            return Ok(*ModuleResolveResult::module(ResolvedVc::upcast(\n                 RawModule::new(Vc::upcast(FileSource::new(file)))\n                     .to_resolved()\n                     .await?,\n-            ))\n-            .cell());\n+            )));\n         }\n-        Ok(ModuleResolveResult::unresolvable().cell())\n+        Ok(*ModuleResolveResult::unresolvable())\n     }\n }\n "
        },
        {
            "sha": "8194f04cca5262347758e241a479a56552579dcc",
            "filename": "turbopack/crates/turbopack-core/src/resolve/mod.rs",
            "status": "modified",
            "additions": 275,
            "deletions": 215,
            "changes": 490,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fmod.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -12,7 +12,7 @@ use serde::{Deserialize, Serialize};\n use tracing::{Instrument, Level};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    fxindexmap, trace::TraceRawVcs, FxIndexMap, FxIndexSet, NonLocalValue, ReadRef, ResolvedVc,\n+    trace::TraceRawVcs, FxIndexMap, FxIndexSet, NonLocalValue, ReadRef, ResolvedVc, SliceMap,\n     TaskInput, TryJoinIterExt, Value, ValueToString, Vc,\n };\n use turbo_tasks_fs::{\n@@ -102,84 +102,91 @@ impl ModuleResolveResultItem {\n }\n \n #[turbo_tasks::value(shared)]\n-#[derive(Clone, Debug)]\n+#[derive(Clone)]\n pub struct ModuleResolveResult {\n-    pub primary: FxIndexMap<RequestKey, ModuleResolveResultItem>,\n-    pub affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n-}\n-\n-impl Default for ModuleResolveResult {\n-    fn default() -> Self {\n-        ModuleResolveResult::unresolvable()\n-    }\n+    pub primary: SliceMap<RequestKey, ModuleResolveResultItem>,\n+    pub affecting_sources: Box<[ResolvedVc<Box<dyn Source>>]>,\n }\n \n impl ModuleResolveResult {\n-    pub fn unresolvable() -> Self {\n+    pub fn unresolvable() -> ResolvedVc<Self> {\n         ModuleResolveResult {\n-            primary: FxIndexMap::default(),\n-            affecting_sources: Vec::new(),\n+            primary: Default::default(),\n+            affecting_sources: Default::default(),\n         }\n+        .resolved_cell()\n     }\n \n     pub fn unresolvable_with_affecting_sources(\n         affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n-    ) -> ModuleResolveResult {\n+    ) -> ResolvedVc<Self> {\n         ModuleResolveResult {\n-            primary: FxIndexMap::default(),\n-            affecting_sources,\n+            primary: Default::default(),\n+            affecting_sources: affecting_sources.into_boxed_slice(),\n         }\n+        .resolved_cell()\n     }\n \n-    pub fn module(module: ResolvedVc<Box<dyn Module>>) -> ModuleResolveResult {\n+    pub fn module(module: ResolvedVc<Box<dyn Module>>) -> ResolvedVc<Self> {\n         Self::module_with_key(RequestKey::default(), module)\n     }\n \n     pub fn module_with_key(\n         request_key: RequestKey,\n         module: ResolvedVc<Box<dyn Module>>,\n-    ) -> ModuleResolveResult {\n+    ) -> ResolvedVc<Self> {\n         ModuleResolveResult {\n-            primary: fxindexmap! { request_key => ModuleResolveResultItem::Module(module) },\n-            affecting_sources: Vec::new(),\n+            primary: vec![(request_key, ModuleResolveResultItem::Module(module))]\n+                .into_boxed_slice(),\n+            affecting_sources: Default::default(),\n         }\n+        .resolved_cell()\n     }\n \n     pub fn output_asset(\n         request_key: RequestKey,\n         output_asset: ResolvedVc<Box<dyn OutputAsset>>,\n-    ) -> ModuleResolveResult {\n+    ) -> ResolvedVc<Self> {\n         ModuleResolveResult {\n-            primary: fxindexmap! { request_key => ModuleResolveResultItem::OutputAsset(output_asset) },\n-            affecting_sources: Vec::new(),\n+            primary: vec![(\n+                request_key,\n+                ModuleResolveResultItem::OutputAsset(output_asset),\n+            )]\n+            .into_boxed_slice(),\n+            affecting_sources: Default::default(),\n         }\n+        .resolved_cell()\n     }\n \n     pub fn modules(\n         modules: impl IntoIterator<Item = (RequestKey, ResolvedVc<Box<dyn Module>>)>,\n-    ) -> ModuleResolveResult {\n+    ) -> ResolvedVc<Self> {\n         ModuleResolveResult {\n             primary: modules\n                 .into_iter()\n                 .map(|(k, v)| (k, ModuleResolveResultItem::Module(v)))\n                 .collect(),\n-            affecting_sources: Vec::new(),\n+            affecting_sources: Default::default(),\n         }\n+        .resolved_cell()\n     }\n \n     pub fn modules_with_affecting_sources(\n         modules: impl IntoIterator<Item = (RequestKey, ResolvedVc<Box<dyn Module>>)>,\n         affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n-    ) -> ModuleResolveResult {\n+    ) -> ResolvedVc<Self> {\n         ModuleResolveResult {\n             primary: modules\n                 .into_iter()\n                 .map(|(k, v)| (k, ModuleResolveResultItem::Module(v)))\n                 .collect(),\n-            affecting_sources,\n+            affecting_sources: affecting_sources.into_boxed_slice(),\n         }\n+        .resolved_cell()\n     }\n+}\n \n+impl ModuleResolveResult {\n     /// Returns all module results (but ignoring any errors).\n     pub fn primary_modules_raw_iter(\n         &self,\n@@ -190,24 +197,37 @@ impl ModuleResolveResult {\n         })\n     }\n \n-    pub fn add_affecting_source_ref(&mut self, source: ResolvedVc<Box<dyn Source>>) {\n-        self.affecting_sources.push(source);\n-    }\n-\n     pub fn affecting_sources_iter(&self) -> impl Iterator<Item = ResolvedVc<Box<dyn Source>>> + '_ {\n         self.affecting_sources.iter().copied()\n     }\n \n-    fn clone_with_affecting_sources(\n-        &self,\n-        affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n-    ) -> ModuleResolveResult {\n+    pub fn is_unresolvable_ref(&self) -> bool {\n+        self.primary.is_empty()\n+    }\n+}\n+\n+pub struct ModuleResolveResultBuilder {\n+    pub primary: FxIndexMap<RequestKey, ModuleResolveResultItem>,\n+    pub affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n+}\n+\n+impl From<ModuleResolveResultBuilder> for ModuleResolveResult {\n+    fn from(v: ModuleResolveResultBuilder) -> Self {\n         ModuleResolveResult {\n-            primary: self.primary.clone(),\n-            affecting_sources,\n+            primary: v.primary.into_iter().collect(),\n+            affecting_sources: v.affecting_sources.into_boxed_slice(),\n         }\n     }\n-\n+}\n+impl From<ModuleResolveResult> for ModuleResolveResultBuilder {\n+    fn from(v: ModuleResolveResult) -> Self {\n+        ModuleResolveResultBuilder {\n+            primary: IntoIterator::into_iter(v.primary).collect(),\n+            affecting_sources: v.affecting_sources.into_vec(),\n+        }\n+    }\n+}\n+impl ModuleResolveResultBuilder {\n     pub fn merge_alternatives(&mut self, other: &ModuleResolveResult) {\n         for (k, v) in other.primary.iter() {\n             if !self.primary.contains_key(k) {\n@@ -227,34 +247,42 @@ impl ModuleResolveResult {\n                 .copied(),\n         );\n     }\n-\n-    pub fn is_unresolvable_ref(&self) -> bool {\n-        self.primary.is_empty()\n-    }\n }\n \n #[turbo_tasks::value_impl]\n impl ModuleResolveResult {\n     #[turbo_tasks::function]\n     pub async fn with_affecting_source(\n-        self: Vc<Self>,\n+        &self,\n         source: ResolvedVc<Box<dyn Source>>,\n     ) -> Result<Vc<Self>> {\n-        let mut this = self.owned().await?;\n-        this.add_affecting_source_ref(source);\n-        Ok(this.into())\n+        Ok(Self {\n+            primary: self.primary.clone(),\n+            affecting_sources: self\n+                .affecting_sources\n+                .iter()\n+                .copied()\n+                .chain(std::iter::once(source))\n+                .collect(),\n+        }\n+        .cell())\n     }\n \n     #[turbo_tasks::function]\n     pub async fn with_affecting_sources(\n-        self: Vc<Self>,\n+        &self,\n         sources: Vec<ResolvedVc<Box<dyn Source>>>,\n     ) -> Result<Vc<Self>> {\n-        let mut this = self.owned().await?;\n-        for source in sources {\n-            this.add_affecting_source_ref(source);\n+        Ok(Self {\n+            primary: self.primary.clone(),\n+            affecting_sources: self\n+                .affecting_sources\n+                .iter()\n+                .copied()\n+                .chain(sources)\n+                .collect(),\n         }\n-        Ok(this.into())\n+        .cell())\n     }\n \n     /// Returns the first [ModuleResolveResult] that is not\n@@ -269,12 +297,16 @@ impl ModuleResolveResult {\n         for result in results {\n             let result_ref = result.await?;\n             if !result_ref.is_unresolvable_ref() {\n-                return Ok(result_ref\n-                    .clone_with_affecting_sources(affecting_sources)\n-                    .cell());\n+                return Ok(Self {\n+                    primary: result_ref.primary.clone(),\n+                    affecting_sources: affecting_sources.into_boxed_slice(),\n+                }\n+                .cell());\n             }\n         }\n-        Ok(ModuleResolveResult::unresolvable_with_affecting_sources(affecting_sources).into())\n+        Ok(*ModuleResolveResult::unresolvable_with_affecting_sources(\n+            affecting_sources,\n+        ))\n     }\n \n     #[turbo_tasks::function]\n@@ -284,15 +316,15 @@ impl ModuleResolveResult {\n         }\n         let mut iter = results.into_iter().try_join().await?.into_iter();\n         if let Some(current) = iter.next() {\n-            let mut current = ReadRef::into_owned(current);\n+            let mut current: ModuleResolveResultBuilder = ReadRef::into_owned(current).into();\n             for result in iter {\n                 // For clippy -- This explicit deref is necessary\n                 let other = &*result;\n                 current.merge_alternatives(other);\n             }\n-            Ok(Self::cell(current))\n+            Ok(Self::cell(current.into()))\n         } else {\n-            Ok(Self::cell(ModuleResolveResult::unresolvable()))\n+            Ok(*ModuleResolveResult::unresolvable())\n         }\n     }\n \n@@ -313,17 +345,17 @@ impl ModuleResolveResult {\n         }\n         let mut iter = results.into_iter().try_join().await?.into_iter();\n         if let Some(current) = iter.next() {\n-            let mut current = ReadRef::into_owned(current);\n+            let mut current: ModuleResolveResultBuilder = ReadRef::into_owned(current).into();\n             for result in iter {\n                 // For clippy -- This explicit deref is necessary\n                 let other = &*result;\n                 current.merge_alternatives(other);\n             }\n             current.affecting_sources.extend(affecting_sources);\n-            Ok(Self::cell(current))\n+            Ok(Self::cell(current.into()))\n         } else {\n-            Ok(Self::cell(\n-                ModuleResolveResult::unresolvable_with_affecting_sources(affecting_sources),\n+            Ok(*ModuleResolveResult::unresolvable_with_affecting_sources(\n+                affecting_sources,\n             ))\n         }\n     }\n@@ -370,8 +402,19 @@ impl ModuleResolveResult {\n     }\n }\n \n-#[derive(Copy, Clone)]\n-#[turbo_tasks::value(shared)]\n+#[derive(\n+    Copy,\n+    Clone,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    TaskInput,\n+    Hash,\n+    NonLocalValue,\n+    TraceRawVcs,\n+    Serialize,\n+    Deserialize,\n+)]\n pub enum ExternalTraced {\n     Untraced,\n     Traced,\n@@ -416,7 +459,7 @@ impl Display for ExternalType {\n }\n \n #[turbo_tasks::value(shared)]\n-#[derive(Clone)]\n+#[derive(Debug, Clone)]\n pub enum ResolveResultItem {\n     Source(ResolvedVc<Box<dyn Source>>),\n     External {\n@@ -477,14 +520,8 @@ impl RequestKey {\n #[turbo_tasks::value(shared)]\n #[derive(Clone)]\n pub struct ResolveResult {\n-    pub primary: FxIndexMap<RequestKey, ResolveResultItem>,\n-    pub affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n-}\n-\n-impl Default for ResolveResult {\n-    fn default() -> Self {\n-        ResolveResult::unresolvable()\n-    }\n+    pub primary: SliceMap<RequestKey, ResolveResultItem>,\n+    pub affecting_sources: Box<[ResolvedVc<Box<dyn Source>>]>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -543,113 +580,84 @@ impl ValueToString for ResolveResult {\n }\n \n impl ResolveResult {\n-    pub fn unresolvable() -> Self {\n+    pub fn unresolvable() -> ResolvedVc<Self> {\n         ResolveResult {\n-            primary: FxIndexMap::default(),\n-            affecting_sources: Vec::new(),\n+            primary: Default::default(),\n+            affecting_sources: Default::default(),\n         }\n+        .resolved_cell()\n     }\n \n     pub fn unresolvable_with_affecting_sources(\n         affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n-    ) -> ResolveResult {\n+    ) -> ResolvedVc<Self> {\n         ResolveResult {\n-            primary: FxIndexMap::default(),\n-            affecting_sources,\n+            primary: Default::default(),\n+            affecting_sources: affecting_sources.into_boxed_slice(),\n         }\n+        .resolved_cell()\n     }\n \n-    pub fn primary(result: ResolveResultItem) -> ResolveResult {\n+    pub fn primary(result: ResolveResultItem) -> ResolvedVc<Self> {\n         Self::primary_with_key(RequestKey::default(), result)\n     }\n \n-    pub fn primary_with_key(request_key: RequestKey, result: ResolveResultItem) -> ResolveResult {\n+    pub fn primary_with_key(\n+        request_key: RequestKey,\n+        result: ResolveResultItem,\n+    ) -> ResolvedVc<Self> {\n         ResolveResult {\n-            primary: fxindexmap! { request_key => result },\n-            affecting_sources: Vec::new(),\n+            primary: vec![(request_key, result)].into_boxed_slice(),\n+            affecting_sources: Default::default(),\n         }\n+        .resolved_cell()\n     }\n \n     pub fn primary_with_affecting_sources(\n         request_key: RequestKey,\n         result: ResolveResultItem,\n         affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n-    ) -> ResolveResult {\n-        let mut primary = FxIndexMap::with_capacity_and_hasher(1, Default::default());\n-        primary.insert(request_key, result);\n+    ) -> ResolvedVc<Self> {\n         ResolveResult {\n-            primary,\n-            affecting_sources,\n+            primary: vec![(request_key, result)].into_boxed_slice(),\n+            affecting_sources: affecting_sources.into_boxed_slice(),\n         }\n+        .resolved_cell()\n     }\n \n-    pub fn source(source: ResolvedVc<Box<dyn Source>>) -> ResolveResult {\n+    pub fn source(source: ResolvedVc<Box<dyn Source>>) -> ResolvedVc<Self> {\n         Self::source_with_key(RequestKey::default(), source)\n     }\n \n     pub fn source_with_key(\n         request_key: RequestKey,\n         source: ResolvedVc<Box<dyn Source>>,\n-    ) -> ResolveResult {\n-        let mut primary = FxIndexMap::with_capacity_and_hasher(1, Default::default());\n-        primary.insert(request_key, ResolveResultItem::Source(source));\n+    ) -> ResolvedVc<Self> {\n         ResolveResult {\n-            primary,\n-            affecting_sources: Vec::new(),\n+            primary: vec![(request_key, ResolveResultItem::Source(source))].into_boxed_slice(),\n+            affecting_sources: Default::default(),\n         }\n+        .resolved_cell()\n     }\n \n     pub fn source_with_affecting_sources(\n         request_key: RequestKey,\n         source: ResolvedVc<Box<dyn Source>>,\n         affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n-    ) -> ResolveResult {\n-        let mut primary = FxIndexMap::with_capacity_and_hasher(1, Default::default());\n-        primary.insert(request_key, ResolveResultItem::Source(source));\n+    ) -> ResolvedVc<Self> {\n         ResolveResult {\n-            primary,\n-            affecting_sources,\n+            primary: vec![(request_key, ResolveResultItem::Source(source))].into_boxed_slice(),\n+            affecting_sources: affecting_sources.into_boxed_slice(),\n         }\n+        .resolved_cell()\n     }\n+}\n \n-    pub fn add_affecting_source_ref(&mut self, reference: ResolvedVc<Box<dyn Source>>) {\n-        self.affecting_sources.push(reference);\n-    }\n-\n+impl ResolveResult {\n     pub fn get_affecting_sources(&self) -> impl Iterator<Item = ResolvedVc<Box<dyn Source>>> + '_ {\n         self.affecting_sources.iter().copied()\n     }\n \n-    fn clone_with_affecting_sources(\n-        &self,\n-        affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n-    ) -> ResolveResult {\n-        ResolveResult {\n-            primary: self.primary.clone(),\n-            affecting_sources,\n-        }\n-    }\n-\n-    pub fn merge_alternatives(&mut self, other: &ResolveResult) {\n-        for (k, v) in other.primary.iter() {\n-            if !self.primary.contains_key(k) {\n-                self.primary.insert(k.clone(), v.clone());\n-            }\n-        }\n-        let set = self\n-            .affecting_sources\n-            .iter()\n-            .copied()\n-            .collect::<FxHashSet<_>>();\n-        self.affecting_sources.extend(\n-            other\n-                .affecting_sources\n-                .iter()\n-                .filter(|source| !set.contains(source))\n-                .copied(),\n-        );\n-    }\n-\n     pub fn is_unresolvable_ref(&self) -> bool {\n         self.primary.is_empty()\n     }\n@@ -687,7 +695,8 @@ impl ResolveResult {\n                 .copied()\n                 .map(affecting_source_fn)\n                 .try_join()\n-                .await?,\n+                .await?\n+                .into_boxed_slice(),\n         })\n     }\n \n@@ -784,17 +793,63 @@ impl ResolveResult {\n     }\n \n     pub fn add_conditions<'a>(&mut self, conditions: impl IntoIterator<Item = (&'a str, bool)>) {\n-        let mut primary = self.primary.drain(..).collect::<Vec<_>>();\n+        let mut primary = std::mem::take(&mut self.primary);\n         for (k, v) in conditions {\n             for (key, _) in primary.iter_mut() {\n                 key.conditions.insert(k.to_string(), v);\n             }\n         }\n-        for (k, v) in primary {\n-            self.primary.insert(k, v);\n+        // Deduplicate\n+        self.primary = IntoIterator::into_iter(primary)\n+            .collect::<FxIndexMap<_, _>>()\n+            .into_iter()\n+            .collect::<Vec<_>>()\n+            .into_boxed_slice();\n+    }\n+}\n+\n+pub struct ResolveResultBuilder {\n+    pub primary: FxIndexMap<RequestKey, ResolveResultItem>,\n+    pub affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n+}\n+\n+impl From<ResolveResultBuilder> for ResolveResult {\n+    fn from(v: ResolveResultBuilder) -> Self {\n+        ResolveResult {\n+            primary: v.primary.into_iter().collect(),\n+            affecting_sources: v.affecting_sources.into_boxed_slice(),\n+        }\n+    }\n+}\n+impl From<ResolveResult> for ResolveResultBuilder {\n+    fn from(v: ResolveResult) -> Self {\n+        ResolveResultBuilder {\n+            primary: IntoIterator::into_iter(v.primary).collect(),\n+            affecting_sources: v.affecting_sources.into_vec(),\n         }\n     }\n }\n+impl ResolveResultBuilder {\n+    pub fn merge_alternatives(&mut self, other: &ResolveResult) {\n+        for (k, v) in other.primary.iter() {\n+            if !self.primary.contains_key(k) {\n+                self.primary.insert(k.clone(), v.clone());\n+            }\n+        }\n+        let set = self\n+            .affecting_sources\n+            .iter()\n+            .copied()\n+            .collect::<FxHashSet<_>>();\n+        self.affecting_sources.extend(\n+            other\n+                .affecting_sources\n+                .iter()\n+                .filter(|source| !set.contains(source))\n+                .copied(),\n+        );\n+    }\n+}\n \n #[turbo_tasks::value_impl]\n impl ResolveResult {\n@@ -812,24 +867,36 @@ impl ResolveResult {\n \n     #[turbo_tasks::function]\n     pub async fn with_affecting_source(\n-        self: Vc<Self>,\n-        affecting_source: ResolvedVc<Box<dyn Source>>,\n+        &self,\n+        source: ResolvedVc<Box<dyn Source>>,\n     ) -> Result<Vc<Self>> {\n-        let mut this = self.owned().await?;\n-        this.add_affecting_source_ref(affecting_source);\n-        Ok(this.into())\n+        Ok(Self {\n+            primary: self.primary.clone(),\n+            affecting_sources: self\n+                .affecting_sources\n+                .iter()\n+                .copied()\n+                .chain(std::iter::once(source))\n+                .collect(),\n+        }\n+        .cell())\n     }\n \n     #[turbo_tasks::function]\n     pub async fn with_affecting_sources(\n-        self: Vc<Self>,\n-        affecting_sources: Vec<ResolvedVc<Box<dyn Source>>>,\n+        &self,\n+        sources: Vec<ResolvedVc<Box<dyn Source>>>,\n     ) -> Result<Vc<Self>> {\n-        let mut this = self.owned().await?;\n-        for affecting_source in affecting_sources {\n-            this.add_affecting_source_ref(affecting_source);\n+        Ok(Self {\n+            primary: self.primary.clone(),\n+            affecting_sources: self\n+                .affecting_sources\n+                .iter()\n+                .copied()\n+                .chain(sources)\n+                .collect(),\n         }\n-        Ok(this.into())\n+        .cell())\n     }\n \n     /// Returns the first [ResolveResult] that is not\n@@ -844,12 +911,16 @@ impl ResolveResult {\n         for result in results {\n             let result_ref = result.await?;\n             if !result_ref.is_unresolvable_ref() {\n-                return Ok(result_ref\n-                    .clone_with_affecting_sources(affecting_sources)\n-                    .cell());\n+                return Ok(Self {\n+                    primary: result_ref.primary.clone(),\n+                    affecting_sources: affecting_sources.into_boxed_slice(),\n+                }\n+                .cell());\n             }\n         }\n-        Ok(ResolveResult::unresolvable_with_affecting_sources(affecting_sources).into())\n+        Ok(*ResolveResult::unresolvable_with_affecting_sources(\n+            affecting_sources,\n+        ))\n     }\n \n     #[turbo_tasks::function]\n@@ -859,15 +930,15 @@ impl ResolveResult {\n         }\n         let mut iter = results.into_iter().try_join().await?.into_iter();\n         if let Some(current) = iter.next() {\n-            let mut current = ReadRef::into_owned(current);\n+            let mut current: ResolveResultBuilder = ReadRef::into_owned(current).into();\n             for result in iter {\n                 // For clippy -- This explicit deref is necessary\n                 let other = &*result;\n                 current.merge_alternatives(other);\n             }\n-            Ok(Self::cell(current))\n+            Ok(Self::cell(current.into()))\n         } else {\n-            Ok(Self::cell(ResolveResult::unresolvable()))\n+            Ok(*ResolveResult::unresolvable())\n         }\n     }\n \n@@ -888,17 +959,17 @@ impl ResolveResult {\n         }\n         let mut iter = results.into_iter().try_join().await?.into_iter();\n         if let Some(current) = iter.next() {\n-            let mut current = ReadRef::into_owned(current);\n+            let mut current: ResolveResultBuilder = ReadRef::into_owned(current).into();\n             for result in iter {\n                 // For clippy -- This explicit deref is necessary\n                 let other = &*result;\n                 current.merge_alternatives(other);\n             }\n             current.affecting_sources.extend(affecting_sources);\n-            Ok(Self::cell(current))\n+            Ok(Self::cell(current.into()))\n         } else {\n-            Ok(Self::cell(\n-                ResolveResult::unresolvable_with_affecting_sources(affecting_sources),\n+            Ok(*ResolveResult::unresolvable_with_affecting_sources(\n+                affecting_sources,\n             ))\n         }\n     }\n@@ -1384,7 +1455,7 @@ async fn find_package(\n \n fn merge_results(results: Vec<Vc<ResolveResult>>) -> Vc<ResolveResult> {\n     match results.len() {\n-        0 => ResolveResult::unresolvable().into(),\n+        0 => *ResolveResult::unresolvable(),\n         1 => results.into_iter().next().unwrap(),\n         _ => ResolveResult::alternatives(results),\n     }\n@@ -1398,7 +1469,7 @@ fn merge_results_with_affecting_sources(\n         return merge_results(results);\n     }\n     match results.len() {\n-        0 => ResolveResult::unresolvable_with_affecting_sources(affecting_sources).cell(),\n+        0 => *ResolveResult::unresolvable_with_affecting_sources(affecting_sources),\n         1 => results\n             .into_iter()\n             .next()\n@@ -1422,7 +1493,7 @@ pub async fn resolve_raw(\n         path: ResolvedVc<FileSystemPath>,\n     ) -> Result<Vc<ResolveResult>> {\n         let RealPathResult { path, symlinks } = &*path.realpath_with_links().await?;\n-        Ok(ResolveResult::source_with_affecting_sources(\n+        Ok(*ResolveResult::source_with_affecting_sources(\n             RequestKey::new(request.into()),\n             ResolvedVc::upcast(FileSource::new(**path).to_resolved().await?),\n             symlinks\n@@ -1434,8 +1505,7 @@ pub async fn resolve_raw(\n                 })\n                 .try_join()\n                 .await?,\n-        )\n-        .cell())\n+        ))\n     }\n \n     let mut results = Vec::new();\n@@ -1654,9 +1724,8 @@ async fn handle_after_resolve_plugins(\n                 new_primary.extend(\n                     new_result\n                         .primary\n-                        .values()\n-                        .cloned()\n-                        .map(|item| (key.clone(), item)),\n+                        .iter()\n+                        .map(|(_, item)| (key.clone(), item.clone())),\n                 );\n                 new_affecting_sources.extend(new_result.affecting_sources.iter().copied());\n             } else {\n@@ -1671,12 +1740,12 @@ async fn handle_after_resolve_plugins(\n         return Ok(result);\n     }\n \n-    let mut affecting_sources = result_value.affecting_sources.clone();\n+    let mut affecting_sources = result_value.affecting_sources.to_vec();\n     affecting_sources.append(&mut new_affecting_sources);\n \n     Ok(ResolveResult {\n-        primary: new_primary,\n-        affecting_sources,\n+        primary: new_primary.into_iter().collect(),\n+        affecting_sources: affecting_sources.into_boxed_slice(),\n     }\n     .cell())\n }\n@@ -1744,7 +1813,7 @@ async fn resolve_internal_inline(\n         }\n \n         let result = match &*request_value {\n-            Request::Dynamic => ResolveResult::unresolvable().into(),\n+            Request::Dynamic => *ResolveResult::unresolvable(),\n             Request::Alternatives { requests } => {\n                 let results = requests\n                     .iter()\n@@ -1903,9 +1972,9 @@ async fn resolve_internal_inline(\n                     .emit();\n                 }\n \n-                ResolveResult::unresolvable().into()\n+                *ResolveResult::unresolvable()\n             }\n-            Request::Empty => ResolveResult::unresolvable().into(),\n+            Request::Empty => *ResolveResult::unresolvable(),\n             Request::PackageInternal { path } => {\n                 let options_value = options.await?;\n                 let (conditions, unspecified_conditions) = options_value\n@@ -1936,15 +2005,14 @@ async fn resolve_internal_inline(\n                 fragment: _,\n             } => {\n                 let uri: RcStr = format!(\"{}{}\", protocol, remainder).into();\n-                ResolveResult::primary_with_key(\n+                *ResolveResult::primary_with_key(\n                     RequestKey::new(uri.clone()),\n                     ResolveResultItem::External {\n                         name: uri,\n                         ty: ExternalType::Url,\n                         traced: ExternalTraced::Untraced,\n                     },\n                 )\n-                .into()\n             }\n             Request::Unknown { path } => {\n                 if !has_alias {\n@@ -1960,7 +2028,7 @@ async fn resolve_internal_inline(\n                     .resolved_cell()\n                     .emit();\n                 }\n-                ResolveResult::unresolvable().into()\n+                *ResolveResult::unresolvable()\n             }\n         };\n \n@@ -2027,11 +2095,12 @@ async fn resolve_into_folder(\n                         // we are not that strict when a main field fails to resolve\n                         // we continue to try other alternatives\n                         if !result.is_unresolvable_ref() {\n-                            let mut result = result.with_request_ref(\".\".into());\n-                            result.add_affecting_source_ref(ResolvedVc::upcast(\n+                            let mut result: ResolveResultBuilder =\n+                                result.with_request_ref(\".\".into()).into();\n+                            result.affecting_sources.push(ResolvedVc::upcast(\n                                 FileSource::new(package_json_path).to_resolved().await?,\n                             ));\n-                            return Ok(result.cell());\n+                            return Ok(ResolveResult::from(result).cell());\n                         }\n                     }\n                 };\n@@ -2041,12 +2110,12 @@ async fn resolve_into_folder(\n     }\n \n     if options_value.fully_specified {\n-        return Ok(ResolveResult::unresolvable().cell());\n+        return Ok(*ResolveResult::unresolvable());\n     }\n \n     // fall back to dir/index.[js,ts,...]\n     let pattern = match &options_value.default_files[..] {\n-        [] => return Ok(ResolveResult::unresolvable().cell()),\n+        [] => return Ok(*ResolveResult::unresolvable()),\n         [file] => Pattern::Constant(format!(\"./{file}\").into()),\n         files => Pattern::Alternatives(\n             files\n@@ -2326,14 +2395,11 @@ async fn apply_in_package(\n         let request_key = RequestKey::new(request.clone());\n \n         if value.as_bool() == Some(false) {\n-            return Ok(Some(\n-                ResolveResult::primary_with_affecting_sources(\n-                    request_key,\n-                    ResolveResultItem::Ignore,\n-                    refs,\n-                )\n-                .cell(),\n-            ));\n+            return Ok(Some(*ResolveResult::primary_with_affecting_sources(\n+                request_key,\n+                ResolveResultItem::Ignore,\n+                refs,\n+            )));\n         }\n \n         if let Some(value) = value.as_str() {\n@@ -2368,9 +2434,9 @@ async fn apply_in_package(\n         .resolved_cell()\n         .emit();\n \n-        return Ok(Some(\n-            ResolveResult::unresolvable_with_affecting_sources(refs).cell(),\n-        ));\n+        return Ok(Some(*ResolveResult::unresolvable_with_affecting_sources(\n+            refs,\n+        )));\n     }\n     Ok(None)\n }\n@@ -2464,10 +2530,9 @@ async fn resolve_module_request(\n     .await?;\n \n     if result.packages.is_empty() {\n-        return Ok(ResolveResult::unresolvable_with_affecting_sources(\n+        return Ok(*ResolveResult::unresolvable_with_affecting_sources(\n             result.affecting_sources.clone(),\n-        )\n-        .into());\n+        ));\n     }\n \n     let mut results = vec![];\n@@ -2642,14 +2707,13 @@ async fn resolve_import_map_result(\n                 ))\n             }\n         }\n-        ImportMapResult::External(name, ty, traced) => Some(\n-            ResolveResult::primary(ResolveResultItem::External {\n+        ImportMapResult::External(name, ty, traced) => {\n+            Some(*ResolveResult::primary(ResolveResultItem::External {\n                 name: name.clone(),\n                 ty: *ty,\n                 traced: *traced,\n-            })\n-            .cell(),\n-        ),\n+            }))\n+        }\n         ImportMapResult::AliasExternal {\n             name,\n             ty,\n@@ -2681,14 +2745,11 @@ async fn resolve_import_map_result(\n                 .await?\n                 .is_unresolvable_ref();\n                 if is_external_resolvable {\n-                    Some(\n-                        ResolveResult::primary(ResolveResultItem::External {\n-                            name: name.clone(),\n-                            ty: *ty,\n-                            traced: *traced,\n-                        })\n-                        .cell(),\n-                    )\n+                    Some(*ResolveResult::primary(ResolveResultItem::External {\n+                        name: name.clone(),\n+                        ty: *ty,\n+                        traced: *traced,\n+                    }))\n                 } else {\n                     None\n                 }\n@@ -2764,7 +2825,7 @@ async fn resolved(\n         }\n     }\n \n-    Ok(ResolveResult::source_with_affecting_sources(\n+    Ok(*ResolveResult::source_with_affecting_sources(\n         request_key,\n         ResolvedVc::upcast(\n             FileSource::new_with_query(**path, query)\n@@ -2780,8 +2841,7 @@ async fn resolved(\n             })\n             .try_join()\n             .await?,\n-    )\n-    .cell())\n+    ))\n }\n \n async fn handle_exports_imports_field(\n@@ -2875,13 +2935,13 @@ async fn resolve_package_internal_with_imports_field(\n         }\n         .resolved_cell()\n         .emit();\n-        return Ok(ResolveResult::unresolvable().into());\n+        return Ok(*ResolveResult::unresolvable());\n     }\n \n     let imports_result = imports_field(file_path).await?;\n     let (imports, package_json_path) = match &*imports_result {\n         ImportsFieldResult::Some(i, p) => (i, *p),\n-        ImportsFieldResult::None => return Ok(ResolveResult::unresolvable().cell()),\n+        ImportsFieldResult::None => return Ok(*ResolveResult::unresolvable()),\n     };\n \n     handle_exports_imports_field(\n@@ -2936,7 +2996,7 @@ pub async fn handle_resolve_error(\n                 source,\n             )\n             .await?;\n-            ModuleResolveResult::unresolvable().cell()\n+            *ModuleResolveResult::unresolvable()\n         }\n     })\n }\n@@ -2980,7 +3040,7 @@ pub async fn handle_resolve_source_error(\n                 source,\n             )\n             .await?;\n-            ResolveResult::unresolvable().cell()\n+            *ResolveResult::unresolvable()\n         }\n     })\n }"
        },
        {
            "sha": "ec973cb0badd6a215ed9d69b3d8127d761735dd0",
            "filename": "turbopack/crates/turbopack-core/src/resolve/options.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Foptions.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -434,12 +434,12 @@ async fn import_mapping_to_result(\n             traced: *traced,\n             lookup_dir: *lookup_dir,\n         },\n-        ReplacedImportMapping::Ignore => ImportMapResult::Result(\n-            ResolveResult::primary(ResolveResultItem::Ignore).resolved_cell(),\n-        ),\n-        ReplacedImportMapping::Empty => ImportMapResult::Result(\n-            ResolveResult::primary(ResolveResultItem::Empty).resolved_cell(),\n-        ),\n+        ReplacedImportMapping::Ignore => {\n+            ImportMapResult::Result(ResolveResult::primary(ResolveResultItem::Ignore))\n+        }\n+        ReplacedImportMapping::Empty => {\n+            ImportMapResult::Result(ResolveResult::primary(ResolveResultItem::Empty))\n+        }\n         ReplacedImportMapping::PrimaryAlternative(name, context) => {\n             let request = Request::parse(Value::new(name.clone()))\n                 .to_resolved()"
        },
        {
            "sha": "9eb07982399aeb2c49e1a6506f634bd060f2bf0b",
            "filename": "turbopack/crates/turbopack-core/src/resolve/origin.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Forigin.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Forigin.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Forigin.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -86,7 +86,7 @@ async fn resolve_asset(\n     reference_type: Value<ReferenceType>,\n ) -> Result<Vc<ModuleResolveResult>> {\n     if let Some(asset) = *resolve_origin.get_inner_asset(request).await? {\n-        return Ok(ModuleResolveResult::module(asset).cell());\n+        return Ok(*ModuleResolveResult::module(asset));\n     }\n     Ok(resolve_origin\n         .asset_context()"
        },
        {
            "sha": "e3605b924989598e64e9f421054cd4a2c2e9613c",
            "filename": "turbopack/crates/turbopack-css/src/references/internal.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Freferences%2Finternal.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Freferences%2Finternal.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Freferences%2Finternal.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -26,7 +26,7 @@ impl InternalCssAssetReference {\n impl ModuleReference for InternalCssAssetReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::module(self.module).cell()\n+        *ModuleResolveResult::module(self.module)\n     }\n }\n "
        },
        {
            "sha": "2d4ddd31547f01b673db173781ef5f989df1eb31",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/base.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbase.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -175,12 +175,11 @@ impl ModuleReference for EsmAssetReference {\n                         ResolvedVc::try_downcast_type(self.origin)\n                             .expect(\"EsmAssetReference origin should be a EcmascriptModuleAsset\");\n \n-                    return Ok(ModuleResolveResult::module(\n+                    return Ok(*ModuleResolveResult::module(\n                         EcmascriptModulePartAsset::select_part(*module, part.clone())\n                             .to_resolved()\n                             .await?,\n-                    )\n-                    .cell());\n+                    ));\n                 }\n \n                 bail!(\"export_name is required for part import\")"
        },
        {
            "sha": "38e9e1973e0dee0b55d40c48d332c22a88059371",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/node.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -33,12 +33,11 @@ impl PackageJsonReference {\n impl ModuleReference for PackageJsonReference {\n     #[turbo_tasks::function]\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n-        Ok(ModuleResolveResult::module(ResolvedVc::upcast(\n+        Ok(*ModuleResolveResult::module(ResolvedVc::upcast(\n             RawModule::new(Vc::upcast(FileSource::new(*self.package_json)))\n                 .to_resolved()\n                 .await?,\n-        ))\n-        .cell())\n+        )))\n     }\n }\n \n@@ -117,7 +116,7 @@ async fn resolve_reference_from_dir(\n             .await?\n             .into_iter(),\n         ),\n-        (None, None) => return Ok(ModuleResolveResult::unresolvable().cell()),\n+        (None, None) => return Ok(*ModuleResolveResult::unresolvable()),\n     };\n     let mut affecting_sources = Vec::new();\n     let mut results = Vec::new();\n@@ -142,7 +141,10 @@ async fn resolve_reference_from_dir(\n             PatternMatch::Directory(..) => {}\n         }\n     }\n-    Ok(ModuleResolveResult::modules_with_affecting_sources(results, affecting_sources).cell())\n+    Ok(*ModuleResolveResult::modules_with_affecting_sources(\n+        results,\n+        affecting_sources,\n+    ))\n }\n \n #[turbo_tasks::value_impl]"
        },
        {
            "sha": "3840e4a3aa6573d4e4941e8520514df3783d948b",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/pattern_mapping.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fpattern_mapping.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fpattern_mapping.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fpattern_mapping.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -411,7 +411,7 @@ impl PatternMapping {\n             ))\n             .cell()),\n             1 => {\n-                let resolve_item = result.primary.first().unwrap().1;\n+                let resolve_item = &result.primary.first().unwrap().1;\n                 let single_pattern_mapping =\n                     to_single_pattern_mapping(origin, chunking_context, resolve_item, resolve_type)\n                         .await?;"
        },
        {
            "sha": "2cc94776c3736090be382e935f3b5ca187b27434",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/require_context.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Frequire_context.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -264,7 +264,7 @@ impl RequireContextAssetReference {\n impl ModuleReference for RequireContextAssetReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::module(ResolvedVc::upcast(self.inner)).cell()\n+        *ModuleResolveResult::module(ResolvedVc::upcast(self.inner))\n     }\n }\n "
        },
        {
            "sha": "1315b140640f9ee166fb74db90a48009839662a1",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/typescript.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Ftypescript.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Ftypescript.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Ftypescript.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -35,12 +35,11 @@ impl TsConfigReference {\n impl ModuleReference for TsConfigReference {\n     #[turbo_tasks::function]\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n-        Ok(ModuleResolveResult::module(ResolvedVc::upcast(\n+        Ok(*ModuleResolveResult::module(ResolvedVc::upcast(\n             TsConfigModuleAsset::new(*self.origin, Vc::upcast(FileSource::new(*self.tsconfig)))\n                 .to_resolved()\n                 .await?,\n-        ))\n-        .cell())\n+        )))\n     }\n }\n \n@@ -93,9 +92,9 @@ impl ModuleReference for TsReferencePathAssetReference {\n                     .module()\n                     .to_resolved()\n                     .await?;\n-                ModuleResolveResult::module(module).cell()\n+                *ModuleResolveResult::module(module)\n             } else {\n-                ModuleResolveResult::unresolvable().cell()\n+                *ModuleResolveResult::unresolvable()\n             },\n         )\n     }"
        },
        {
            "sha": "ca9f969253f4e4271651ad20bcdf28174531856c",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/worker.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fworker.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -91,12 +91,11 @@ impl ModuleReference for WorkerAssetReference {\n     #[turbo_tasks::function]\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n         if let Some(worker_loader_module) = self.worker_loader_module().await? {\n-            Ok(ModuleResolveResult::module(ResolvedVc::upcast(\n+            Ok(*ModuleResolveResult::module(ResolvedVc::upcast(\n                 worker_loader_module.to_resolved().await?,\n-            ))\n-            .cell())\n+            )))\n         } else {\n-            Ok(ModuleResolveResult::unresolvable().cell())\n+            Ok(*ModuleResolveResult::unresolvable())\n         }\n     }\n }"
        },
        {
            "sha": "b0224dac351d2efdb97a36fb939d40e9b67c1305",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/reference.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Freference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Freference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Freference.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -97,7 +97,7 @@ impl ModuleReference for EcmascriptModulePartReference {\n         } else {\n             ResolvedVc::upcast(self.module)\n         };\n-        Ok(ModuleResolveResult::module(module).cell())\n+        Ok(*ModuleResolveResult::module(module))\n     }\n }\n "
        },
        {
            "sha": "a6b4135f6109b66f76491a63a4308ee9634a1452",
            "filename": "turbopack/crates/turbopack-ecmascript/src/typescript/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftypescript%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftypescript%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftypescript%2Fmod.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -240,12 +240,11 @@ impl TsExtendsReference {\n impl ModuleReference for TsExtendsReference {\n     #[turbo_tasks::function]\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n-        Ok(ModuleResolveResult::module(ResolvedVc::upcast(\n+        Ok(*ModuleResolveResult::module(ResolvedVc::upcast(\n             RawModule::new(*ResolvedVc::upcast(self.config))\n                 .to_resolved()\n                 .await?,\n-        ))\n-        .cell())\n+        )))\n     }\n }\n "
        },
        {
            "sha": "3d2c1b6d3017a5df4befd56bff6117ffaecc6d4d",
            "filename": "turbopack/crates/turbopack-ecmascript/src/webpack/mod.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 6,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fmod.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -100,14 +100,13 @@ impl ModuleReference for WebpackChunkAssetReference {\n                 let filename = format!(\"./chunks/{}.js\", chunk_id).into();\n                 let source = Vc::upcast(FileSource::new(context_path.join(filename)));\n \n-                ModuleResolveResult::module(ResolvedVc::upcast(\n+                *ModuleResolveResult::module(ResolvedVc::upcast(\n                     WebpackModuleAsset::new(source, *self.runtime, *self.transforms)\n                         .to_resolved()\n                         .await?,\n                 ))\n-                .cell()\n             }\n-            WebpackRuntime::None => ModuleResolveResult::unresolvable().cell(),\n+            WebpackRuntime::None => *ModuleResolveResult::unresolvable(),\n         })\n     }\n }\n@@ -136,12 +135,11 @@ pub struct WebpackEntryAssetReference {\n impl ModuleReference for WebpackEntryAssetReference {\n     #[turbo_tasks::function]\n     async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n-        Ok(ModuleResolveResult::module(ResolvedVc::upcast(\n+        Ok(*ModuleResolveResult::module(ResolvedVc::upcast(\n             WebpackModuleAsset::new(*self.source, *self.runtime, *self.transforms)\n                 .to_resolved()\n                 .await?,\n-        ))\n-        .cell())\n+        )))\n     }\n }\n "
        },
        {
            "sha": "238291b6ef8832d8b4829c7a3a8f5aa3bf17ef78",
            "filename": "turbopack/crates/turbopack-ecmascript/src/worker_chunk/module.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fworker_chunk%2Fmodule.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fworker_chunk%2Fmodule.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fworker_chunk%2Fmodule.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -113,7 +113,7 @@ impl ChunkableModuleReference for WorkerModuleReference {\n impl ModuleReference for WorkerModuleReference {\n     #[turbo_tasks::function]\n     fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        ModuleResolveResult::module(self.module).cell()\n+        *ModuleResolveResult::module(self.module)\n     }\n }\n "
        },
        {
            "sha": "4783ebe893df8d91072493978ba7874c3eb526f1",
            "filename": "turbopack/crates/turbopack-resolve/src/node_native_binding.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -197,7 +197,7 @@ pub async fn resolve_node_pre_gyp_files(\n                         _ => {}\n                     }\n                 }\n-                return Ok(ModuleResolveResult::modules_with_affecting_sources(\n+                return Ok(*ModuleResolveResult::modules_with_affecting_sources(\n                     sources\n                         .into_iter()\n                         .map(|(key, source)| async move {\n@@ -215,12 +215,11 @@ pub async fn resolve_node_pre_gyp_files(\n                         })\n                         .try_join()\n                         .await?,\n-                )\n-                .cell());\n+                ));\n             }\n         };\n     }\n-    Ok(ModuleResolveResult::unresolvable().cell())\n+    Ok(*ModuleResolveResult::unresolvable())\n }\n \n #[turbo_tasks::value]\n@@ -305,7 +304,7 @@ pub async fn resolve_node_gyp_build_files(\n                         }\n                     }\n                     if !resolved.is_empty() {\n-                        return Ok(ModuleResolveResult::modules_with_affecting_sources(\n+                        return Ok(*ModuleResolveResult::modules_with_affecting_sources(\n                             resolved\n                                 .into_iter()\n                                 .map(|(key, source)| async move {\n@@ -320,8 +319,7 @@ pub async fn resolve_node_gyp_build_files(\n                                 .await?\n                                 .into_iter(),\n                             merged_affecting_sources,\n-                        )\n-                        .into());\n+                        ));\n                     }\n                 }\n             }\n@@ -441,5 +439,5 @@ pub async fn resolve_node_bindings_files(\n         .map(|try_dir| try_path(format!(\"{}/{}\", try_dir, &file_name).into()))\n         .try_flat_join()\n         .await?;\n-    Ok(ModuleResolveResult::modules(modules).cell())\n+    Ok(*ModuleResolveResult::modules(modules))\n }"
        },
        {
            "sha": "a3aaab23e466333d1350b261c7aaae593a748b8d",
            "filename": "turbopack/crates/turbopack-resolve/src/typescript.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Ftypescript.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1b845bd997fc3ff374ee6909a24a40fd889a0f22/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Ftypescript.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Ftypescript.rs?ref=1b845bd997fc3ff374ee6909a24a40fd889a0f22",
            "patch": "@@ -466,8 +466,7 @@ pub async fn type_resolve(\n #[turbo_tasks::function]\n pub async fn as_typings_result(result: Vc<ModuleResolveResult>) -> Result<Vc<ModuleResolveResult>> {\n     let mut result = result.owned().await?;\n-    result.primary = take(&mut result.primary)\n-        .into_iter()\n+    result.primary = IntoIterator::into_iter(take(&mut result.primary))\n         .map(|(mut k, v)| {\n             k.conditions.insert(\"types\".to_string(), true);\n             (k, v)"
        }
    ],
    "stats": {
        "total": 714,
        "additions": 376,
        "deletions": 338
    }
}