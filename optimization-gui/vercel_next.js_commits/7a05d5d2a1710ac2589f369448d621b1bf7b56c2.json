{
    "author": "wyattjoh",
    "message": "fix(build): improve static path generation performance and fix parameter collisions (#81254)\n\n## Summary\n\n• **Performance**: Replace O(n²) parameter deduplication with O(n)\nMap-based approach\n• **Architecture**: Rewrite `assignErrorIfEmpty` using [Trie data\nstructure](https://en.wikipedia.org/wiki/Trie)\n• **Testing**: Add comprehensive test coverage for edge cases including\nparameter collisions and complex route hierarchies\n\n## Technical Details\n\n### Performance Optimization\n- **Before**: O(n²) nested loops comparing each parameter combination\nagainst all previous ones\n- **After**: O(n) Map-based deduplication using unique string keys for\neach parameter combination\n- **Impact**: Significant performance improvement for routes with many\nparameter combinations\n\n### Trie-Based Route Analysis\nReplaces linear route comparison with efficient Trie data structure:\n\n- **Nodes**: Represent unique parameter combinations \n- **Edges**: Represent parameter values with collision-safe keys\n- **Algorithm**: [DFS\ntraversal](https://en.wikipedia.org/wiki/Depth-first_search) determines\n`throwOnEmptyStaticShell` based on child relationships\n\n**Example**: For routes `/blog/[slug]` and `/blog/first-post`:\n- Trie identifies `/blog/[slug]` as parent to concrete route\n`/blog/first-post`\n- Sets `throwOnEmptyStaticShell = false` for parent, `true` for concrete\nroute",
    "sha": "7a05d5d2a1710ac2589f369448d621b1bf7b56c2",
    "files": [
        {
            "sha": "a7ffb6506bce9c835efda6aaaaeedb28a2f7a03a",
            "filename": "packages/next/src/build/static-paths/app.test.ts",
            "status": "modified",
            "additions": 231,
            "deletions": 2,
            "changes": 233,
            "blob_url": "https://github.com/vercel/next.js/blob/7a05d5d2a1710ac2589f369448d621b1bf7b56c2/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7a05d5d2a1710ac2589f369448d621b1bf7b56c2/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.test.ts?ref=7a05d5d2a1710ac2589f369448d621b1bf7b56c2",
            "patch": "@@ -7,7 +7,7 @@ import {\n import type { PrerenderedRoute } from './types'\n \n describe('assignErrorIfEmpty', () => {\n-  it('should assign throwOnEmptyStaticShell false for a static route', () => {\n+  it('should assign throwOnEmptyStaticShell true for a static route with no children', () => {\n     const prerenderedRoutes: PrerenderedRoute[] = [\n       {\n         params: {},\n@@ -25,7 +25,7 @@ describe('assignErrorIfEmpty', () => {\n     expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(true)\n   })\n \n-  it('should assign throwOnEmptyStaticShell to the prerendered routes', () => {\n+  it('should assign throwOnEmptyStaticShell based on route hierarchy', () => {\n     const prerenderedRoutes: PrerenderedRoute[] = [\n       {\n         params: {},\n@@ -110,6 +110,216 @@ describe('assignErrorIfEmpty', () => {\n     expect(prerenderedRoutes[3].throwOnEmptyStaticShell).toBe(true)\n     expect(prerenderedRoutes[4].throwOnEmptyStaticShell).toBe(false)\n   })\n+\n+  it('should handle parameter value collisions', () => {\n+    const params = [{ slug: ['foo', 'bar'] }, { slug: 'foo,bar' }]\n+\n+    const unique = filterUniqueRootParamsCombinations(['slug'], params)\n+\n+    expect(unique).toEqual([{ slug: ['foo', 'bar'] }, { slug: 'foo,bar' }])\n+  })\n+\n+  it('should handle multiple routes at the same trie node', () => {\n+    const prerenderedRoutes: PrerenderedRoute[] = [\n+      {\n+        params: { id: '1' },\n+        pathname: '/1/[name]',\n+        encodedPathname: '/1/[name]',\n+        fallbackRouteParams: ['name'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { id: '1' },\n+        pathname: '/1/[name]/[extra]',\n+        encodedPathname: '/1/[name]/[extra]',\n+        fallbackRouteParams: ['name', 'extra'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { id: '1', name: 'test' },\n+        pathname: '/1/test',\n+        encodedPathname: '/1/test',\n+        fallbackRouteParams: [],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+    ]\n+\n+    assignErrorIfEmpty(prerenderedRoutes, ['id', 'name', 'extra'])\n+\n+    expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false)\n+    expect(prerenderedRoutes[1].throwOnEmptyStaticShell).toBe(false)\n+    expect(prerenderedRoutes[2].throwOnEmptyStaticShell).toBe(true)\n+  })\n+\n+  it('should handle empty input', () => {\n+    const prerenderedRoutes: PrerenderedRoute[] = []\n+    assignErrorIfEmpty(prerenderedRoutes, [])\n+    expect(prerenderedRoutes).toEqual([])\n+  })\n+\n+  it('should handle blog/[slug] not throwing when concrete routes exist (from docs example)', () => {\n+    const prerenderedRoutes: PrerenderedRoute[] = [\n+      {\n+        params: {},\n+        pathname: '/blog/[slug]',\n+        encodedPathname: '/blog/[slug]',\n+        fallbackRouteParams: ['slug'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { slug: 'first-post' },\n+        pathname: '/blog/first-post',\n+        encodedPathname: '/blog/first-post',\n+        fallbackRouteParams: [],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { slug: 'second-post' },\n+        pathname: '/blog/second-post',\n+        encodedPathname: '/blog/second-post',\n+        fallbackRouteParams: [],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+    ]\n+\n+    assignErrorIfEmpty(prerenderedRoutes, ['slug'])\n+\n+    expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false) // Should not throw - has concrete children\n+    expect(prerenderedRoutes[1].throwOnEmptyStaticShell).toBe(true) // Should throw - concrete route\n+    expect(prerenderedRoutes[2].throwOnEmptyStaticShell).toBe(true) // Should throw - concrete route\n+  })\n+\n+  it('should handle catch-all routes with different fallback parameter counts (from docs example)', () => {\n+    const prerenderedRoutes: PrerenderedRoute[] = [\n+      {\n+        params: {},\n+        pathname: '/[id]/[...slug]',\n+        encodedPathname: '/[id]/[...slug]',\n+        fallbackRouteParams: ['id', 'slug'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { id: '1234' },\n+        pathname: '/1234/[...slug]',\n+        encodedPathname: '/1234/[...slug]',\n+        fallbackRouteParams: ['slug'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { id: '1234', slug: ['about', 'us'] },\n+        pathname: '/1234/about/us',\n+        encodedPathname: '/1234/about/us',\n+        fallbackRouteParams: [],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+    ]\n+\n+    assignErrorIfEmpty(prerenderedRoutes, ['id', 'slug'])\n+\n+    expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false) // Should not throw - has children\n+    expect(prerenderedRoutes[1].throwOnEmptyStaticShell).toBe(false) // Should not throw - has children\n+    expect(prerenderedRoutes[2].throwOnEmptyStaticShell).toBe(true) // Should throw - concrete route\n+  })\n+\n+  it('should handle nested routes with multiple parameter depths', () => {\n+    const prerenderedRoutes: PrerenderedRoute[] = [\n+      {\n+        params: {},\n+        pathname: '/[category]/[subcategory]/[item]',\n+        encodedPathname: '/[category]/[subcategory]/[item]',\n+        fallbackRouteParams: ['category', 'subcategory', 'item'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { category: 'electronics' },\n+        pathname: '/electronics/[subcategory]/[item]',\n+        encodedPathname: '/electronics/[subcategory]/[item]',\n+        fallbackRouteParams: ['subcategory', 'item'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { category: 'electronics', subcategory: 'phones' },\n+        pathname: '/electronics/phones/[item]',\n+        encodedPathname: '/electronics/phones/[item]',\n+        fallbackRouteParams: ['item'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: {\n+          category: 'electronics',\n+          subcategory: 'phones',\n+          item: 'iphone',\n+        },\n+        pathname: '/electronics/phones/iphone',\n+        encodedPathname: '/electronics/phones/iphone',\n+        fallbackRouteParams: [],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+    ]\n+\n+    assignErrorIfEmpty(prerenderedRoutes, ['category', 'subcategory', 'item'])\n+\n+    // All except the last one should not throw on empty static shell\n+    expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false)\n+    expect(prerenderedRoutes[1].throwOnEmptyStaticShell).toBe(false)\n+    expect(prerenderedRoutes[2].throwOnEmptyStaticShell).toBe(false)\n+    expect(prerenderedRoutes[3].throwOnEmptyStaticShell).toBe(true)\n+  })\n+\n+  it('should handle routes at same trie node with different fallback parameter lengths', () => {\n+    const prerenderedRoutes: PrerenderedRoute[] = [\n+      {\n+        params: { locale: 'en' },\n+        pathname: '/en/[...segments]',\n+        encodedPathname: '/en/[...segments]',\n+        fallbackRouteParams: ['segments'],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+      {\n+        params: { locale: 'en' },\n+        pathname: '/en',\n+        encodedPathname: '/en',\n+        fallbackRouteParams: [],\n+        fallbackMode: FallbackMode.NOT_FOUND,\n+        fallbackRootParams: [],\n+        throwOnEmptyStaticShell: true,\n+      },\n+    ]\n+\n+    assignErrorIfEmpty(prerenderedRoutes, ['locale', 'segments'])\n+\n+    // The route with more fallback params should not throw on empty static shell\n+    expect(prerenderedRoutes[0].throwOnEmptyStaticShell).toBe(false)\n+    expect(prerenderedRoutes[1].throwOnEmptyStaticShell).toBe(true)\n+  })\n })\n \n describe('filterUniqueParams', () => {\n@@ -154,4 +364,23 @@ describe('filterUniqueRootParamsCombinations', () => {\n \n     expect(unique).toEqual([{ id: '1' }, { id: '2' }])\n   })\n+\n+  it('should handle multiple root parameters', () => {\n+    const params = [\n+      { lang: 'en', region: 'US', page: 'home' },\n+      { lang: 'en', region: 'US', page: 'about' },\n+      { lang: 'fr', region: 'CA', page: 'home' },\n+      { lang: 'fr', region: 'CA', page: 'about' },\n+    ]\n+\n+    const unique = filterUniqueRootParamsCombinations(\n+      ['lang', 'region'],\n+      params\n+    )\n+\n+    expect(unique).toEqual([\n+      { lang: 'en', region: 'US' },\n+      { lang: 'fr', region: 'CA' },\n+    ])\n+  })\n })"
        },
        {
            "sha": "4f1fce57dd0e4c05f2223a928c0efc842f566138",
            "filename": "packages/next/src/build/static-paths/app.ts",
            "status": "modified",
            "additions": 221,
            "deletions": 87,
            "changes": 308,
            "blob_url": "https://github.com/vercel/next.js/blob/7a05d5d2a1710ac2589f369448d621b1bf7b56c2/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7a05d5d2a1710ac2589f369448d621b1bf7b56c2/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fstatic-paths%2Fapp.ts?ref=7a05d5d2a1710ac2589f369448d621b1bf7b56c2",
            "patch": "@@ -1,4 +1,4 @@\n-import type { ParamValue, Params } from '../../server/request/params'\n+import type { Params } from '../../server/request/params'\n import type { AppPageModule } from '../../server/route-modules/app-page/module'\n import type { AppSegment } from '../segment-config/app/app-segments'\n import type { PrerenderedRoute, StaticPathsResult } from './types'\n@@ -18,68 +18,66 @@ import escapePathDelimiters from '../../shared/lib/router/utils/escape-path-deli\n import { createIncrementalCache } from '../../export/helpers/create-incremental-cache'\n import type { NextConfigComplete } from '../../server/config-shared'\n \n-/**\n- * Compares two parameters to see if they're equal.\n- *\n- * @param a - The first parameter.\n- * @param b - The second parameter.\n- * @returns Whether the parameters are equal.\n- */\n-function areParamValuesEqual(a: ParamValue, b: ParamValue) {\n-  // If they're equal, then we can return true.\n-  if (a === b) {\n-    return true\n-  }\n-\n-  // If they're both arrays, then we can return true if they have the same\n-  // length and all the items are the same.\n-  if (Array.isArray(a) && Array.isArray(b)) {\n-    if (a.length !== b.length) {\n-      return false\n-    }\n-\n-    return a.every((item, index) => item === b[index])\n-  }\n-\n-  // Otherwise, they're not equal.\n-  return false\n-}\n-\n /**\n  * Filters out duplicate parameters from a list of parameters.\n+ * This function uses a Map to efficiently store and retrieve unique parameter combinations.\n  *\n- * @param routeParamKeys - The keys of the parameters.\n- * @param routeParams - The list of parameters to filter.\n- * @returns The list of unique parameters.\n+ * @param routeParamKeys - The keys of the parameters. These should be sorted to ensure consistent key generation.\n+ * @param routeParams - The list of parameter objects to filter.\n+ * @returns A new array containing only the unique parameter combinations.\n  */\n export function filterUniqueParams(\n   routeParamKeys: readonly string[],\n   routeParams: readonly Params[]\n ): Params[] {\n-  const unique: Params[] = []\n+  // A Map is used to store unique parameter combinations. The key of the Map\n+  // is a string representation of the parameter combination, and the value\n+  // is the actual `Params` object.\n+  const unique = new Map<string, Params>()\n \n-  paramsLoop: for (const params of routeParams) {\n-    uniqueLoop: for (const item of unique) {\n-      for (const key of routeParamKeys) {\n-        // If the param is not the same, then we need to check the next item\n-        if (!areParamValuesEqual(item[key], params[key])) {\n-          continue uniqueLoop\n-        }\n+  // Iterate over each parameter object in the input array.\n+  for (const params of routeParams) {\n+    let key = '' // Initialize an empty string to build the unique key for the current `params` object.\n+\n+    // Iterate through the `routeParamKeys` (which are assumed to be sorted).\n+    // This consistent order is crucial for generating a stable and unique key\n+    // for each parameter combination.\n+    for (const paramKey of routeParamKeys) {\n+      const value = params[paramKey]\n+\n+      // Construct a part of the key using the parameter key and its value.\n+      // A type prefix (`A:` for Array, `S:` for String, `U:` for undefined) is added to the value\n+      // to prevent collisions. For example, `['a', 'b']` and `'a,b'` would\n+      // otherwise generate the same string representation, leading to incorrect\n+      // deduplication. This ensures that different types with the same string\n+      // representation are treated as distinct.\n+      let valuePart: string\n+      if (Array.isArray(value)) {\n+        valuePart = `A:${value.join(',')}`\n+      } else if (value === undefined) {\n+        valuePart = `U:undefined`\n+      } else {\n+        valuePart = `S:${value}`\n       }\n-\n-      // If we got here, then all params matched and we found a duplicate\n-      continue paramsLoop\n+      key += `${paramKey}:${valuePart}|`\n     }\n \n-    // If we got here, then we checked all items and found no duplicates\n-    unique.push(params)\n+    // If the generated key is not already in the `unique` Map, it means this\n+    // parameter combination is unique so far. Add it to the Map.\n+    if (!unique.has(key)) {\n+      unique.set(key, params)\n+    }\n   }\n \n-  return unique\n+  // Convert the Map's values (the unique `Params` objects) back into an array\n+  // and return it.\n+  return Array.from(unique.values())\n }\n \n /**\n  * Filters out all combinations of root params from a list of parameters.\n+ * This function extracts only the root parameters from each parameter object\n+ * and then filters out duplicate combinations using a Map for efficiency.\n  *\n  * Given the following root param ('lang'), and the following routeParams:\n  *\n@@ -100,33 +98,58 @@ export function filterUniqueParams(\n  * ]\n  * ```\n  *\n- * @param rootParamKeys - The keys of the root params.\n- * @param routeParams - The list of parameters to filter.\n- * @returns The list of combinations of root params.\n+ * @param rootParamKeys - The keys of the root params. These should be sorted\n+ *   to ensure consistent key generation for the internal Map.\n+ * @param routeParams - The list of parameter objects to filter.\n+ * @returns A new array containing only the unique combinations of root params.\n  */\n export function filterUniqueRootParamsCombinations(\n   rootParamKeys: readonly string[],\n   routeParams: readonly Params[]\n ): Params[] {\n-  const combinations: Params[] = []\n-\n-  paramsLoop: for (const params of routeParams) {\n-    const combination: Params = {}\n+  // A Map is used to store unique combinations of root parameters.\n+  // The key of the Map is a string representation of the root parameter\n+  // combination, and the value is the `Params` object containing only\n+  // the root parameters.\n+  const combinations = new Map<string, Params>()\n \n-    // Collect all root params. As soon as we don't find a root param, break.\n-    for (const key of rootParamKeys) {\n-      if (params[key]) {\n-        combination[key] = params[key]\n+  // Iterate over each parameter object in the input array.\n+  for (const params of routeParams) {\n+    const combination: Params = {} // Initialize an object to hold only the root parameters.\n+    let key = '' // Initialize an empty string to build the unique key for the current root parameter combination.\n+\n+    // Iterate through the `rootParamKeys` (which are assumed to be sorted).\n+    // This consistent order is crucial for generating a stable and unique key\n+    // for each root parameter combination.\n+    for (const rootKey of rootParamKeys) {\n+      const value = params[rootKey]\n+      combination[rootKey] = value // Add the root parameter and its value to the combination object.\n+\n+      // Construct a part of the key using the root parameter key and its value.\n+      // A type prefix (`A:` for Array, `S:` for String, `U:` for undefined) is added to the value\n+      // to prevent collisions. This ensures that different types with the same\n+      // string representation are treated as distinct.\n+      let valuePart: string\n+      if (Array.isArray(value)) {\n+        valuePart = `A:${value.join(',')}`\n+      } else if (value === undefined) {\n+        valuePart = `U:undefined`\n       } else {\n-        // Skip this combination if we don't have all root params\n-        continue paramsLoop\n+        valuePart = `S:${value}`\n       }\n+      key += `${rootKey}:${valuePart}|`\n     }\n \n-    combinations.push(combination)\n+    // If the generated key is not already in the `combinations` Map, it means\n+    // this root parameter combination is unique so far. Add it to the Map.\n+    if (!combinations.has(key)) {\n+      combinations.set(key, combination)\n+    }\n   }\n \n-  return filterUniqueParams(rootParamKeys, combinations)\n+  // Convert the Map's values (the unique root parameter `Params` objects)\n+  // back into an array and return it.\n+  return Array.from(combinations.values())\n }\n \n /**\n@@ -223,47 +246,158 @@ function validateParams(\n   return valid\n }\n \n+interface TrieNode {\n+  /**\n+   * The children of the node. Each key is a unique string representation of a parameter value,\n+   * and the value is the next TrieNode in the path.\n+   */\n+  children: Map<string, TrieNode>\n+\n+  /**\n+   * The routes that are associated with this specific parameter combination (node).\n+   * These are the routes whose concrete parameters lead to this node in the Trie.\n+   */\n+  routes: PrerenderedRoute[]\n+}\n+\n /**\n  * Assigns the throwOnEmptyStaticShell property to each of the prerendered routes.\n+ * This function uses a Trie data structure to efficiently determine whether each route\n+ * should throw an error when its static shell is empty.\n+ *\n+ * A route should not throw on empty static shell if it has child routes in the Trie. For example,\n+ * if we have two routes, `/blog/first-post` and `/blog/[slug]`, the route for\n+ * `/blog/[slug]` should not throw because `/blog/first-post` is a more specific concrete route.\n  *\n  * @param prerenderedRoutes - The prerendered routes.\n  * @param routeParamKeys - The keys of the route parameters.\n  */\n export function assignErrorIfEmpty(\n   prerenderedRoutes: readonly PrerenderedRoute[],\n   routeParamKeys: readonly string[]\n-) {\n-  // If we're rendering a more specific route, then we don't need to error\n-  // if the route is empty.\n-  for (const prerenderedRoute of prerenderedRoutes) {\n-    let throwOnEmptyStaticShell: boolean = true\n-\n-    // If the route has fallbackRouteParams, then we need to check if the\n-    // route is a more specific route.\n-    const { fallbackRouteParams, params } = prerenderedRoute\n-    if (fallbackRouteParams && fallbackRouteParams.length > 0) {\n-      siblingLoop: for (const other of prerenderedRoutes) {\n-        // Skip the current route.\n-        if (other === prerenderedRoute) continue\n+): void {\n+  // If there are no routes to process, exit early.\n+  if (prerenderedRoutes.length === 0) {\n+    return\n+  }\n \n-        for (const key of routeParamKeys) {\n-          // If the key is a fallback route param, then we can skip it, because\n-          // it always matches.\n-          if (fallbackRouteParams.includes(key)) {\n-            throwOnEmptyStaticShell = false\n-            break siblingLoop\n-          }\n+  // Initialize the root of the Trie. This node represents the starting point\n+  // before any parameters have been considered.\n+  const root: TrieNode = { children: new Map(), routes: [] }\n \n-          // If the param value is not equal, then we can break out of the loop\n-          // because the route is not a more specific route.\n-          if (!areParamValuesEqual(params[key], other.params[key])) {\n-            continue siblingLoop\n-          }\n+  // Phase 1: Build the Trie.\n+  // Iterate over each prerendered route and insert it into the Trie.\n+  // Each route's concrete parameter values form a path in the Trie.\n+  for (const route of prerenderedRoutes) {\n+    let currentNode = root // Start building the path from the root for each route.\n+\n+    // Iterate through the sorted parameter keys. The order of keys is crucial\n+    // for ensuring that routes with the same concrete parameters follow the\n+    // same path in the Trie, regardless of the original order of properties\n+    // in the `params` object.\n+    for (const key of routeParamKeys) {\n+      // Check if the current route actually has a concrete value for this parameter.\n+      // If a dynamic segment is not filled (i.e., it's a fallback), it won't have\n+      // this property, and we stop building the path for this route at this point.\n+      if (route.params.hasOwnProperty(key)) {\n+        const value = route.params[key]\n+\n+        // Generate a unique key for the parameter's value. This is critical\n+        // to prevent collisions between different data types that might have\n+        // the same string representation (e.g., `['a', 'b']` vs `'a,b'`).\n+        // A type prefix (`A:` for Array, `S:` for String, `U:` for undefined)\n+        // is added to the value to prevent collisions. This ensures that\n+        // different types with the same string representation are treated as\n+        // distinct.\n+        let valueKey: string\n+        if (Array.isArray(value)) {\n+          valueKey = `A:${value.join(',')}`\n+        } else if (value === undefined) {\n+          valueKey = `U:undefined`\n+        } else {\n+          valueKey = `S:${value}`\n+        }\n+\n+        // Look for a child node corresponding to this `valueKey` from the `currentNode`.\n+        let childNode = currentNode.children.get(valueKey)\n+        if (!childNode) {\n+          // If the child node doesn't exist, create a new one and add it to\n+          // the current node's children.\n+          childNode = { children: new Map(), routes: [] }\n+          currentNode.children.set(valueKey, childNode)\n         }\n+        // Move deeper into the Trie to the `childNode` for the next parameter.\n+        currentNode = childNode\n       }\n     }\n+    // After processing all concrete parameters for the route, add the full\n+    // `PrerenderedRoute` object to the `routes` array of the `currentNode`.\n+    // This node represents the unique concrete parameter combination for this route.\n+    currentNode.routes.push(route)\n+  }\n+\n+  // Phase 2: Traverse the Trie to assign the `throwOnEmptyStaticShell` property.\n+  // This is done using an iterative Depth-First Search (DFS) approach with an\n+  // explicit stack to avoid JavaScript's recursion depth limits (stack overflow)\n+  // for very deep routing structures.\n+  const stack: TrieNode[] = [root] // Initialize the stack with the root node.\n+\n+  while (stack.length > 0) {\n+    const node = stack.pop()! // Pop the next node to process from the stack.\n+\n+    // `hasChildren` indicates if this node has any more specific concrete\n+    // parameter combinations branching off from it. If true, it means this\n+    // node represents a prefix for other, more specific routes.\n+    const hasChildren = node.children.size > 0\n+\n+    // If the current node has routes associated with it (meaning, routes whose\n+    // concrete parameters lead to this node's path in the Trie).\n+    if (node.routes.length > 0) {\n+      // Determine the minimum number of fallback parameters among all routes\n+      // that are associated with this current Trie node. This is used to\n+      // identify if a route should not throw on empty static shell relative to another route *at the same level*\n+      // of concrete parameters, but with fewer fallback parameters.\n+      let minFallbacks = Infinity\n+      for (const r of node.routes) {\n+        // `fallbackRouteParams?.length ?? 0` handles cases where `fallbackRouteParams`\n+        // might be `undefined` or `null`, treating them as 0 length.\n+        minFallbacks = Math.min(\n+          minFallbacks,\n+          r.fallbackRouteParams?.length ?? 0\n+        )\n+      }\n \n-    prerenderedRoute.throwOnEmptyStaticShell = throwOnEmptyStaticShell\n+      // Now, for each `PrerenderedRoute` associated with this node:\n+      for (const route of node.routes) {\n+        // A route is ok not to throw on an empty static shell (and thus\n+        // `throwOnEmptyStaticShell` should be `false`) if either of the\n+        // following conditions is met:\n+        // 1. `hasChildren` is true: This node has further concrete parameter children.\n+        //    This means the current route is a parent to more specific routes (e.g.,\n+        //    `/blog/[slug]` should not throw when concrete routes like `/blog/first-post` exist).\n+        // OR\n+        // 2. `route.fallbackRouteParams.length > minFallbacks`: This route has\n+        //    more fallback parameters than another route at the same Trie node.\n+        //    This implies the current route is a more general version that should not throw\n+        //    compared to a more specific route that has fewer fallback parameters\n+        //    (e.g., `/1234/[...slug]` should not throw relative to `/[id]/[...slug]`).\n+        if (\n+          hasChildren ||\n+          (route.fallbackRouteParams &&\n+            route.fallbackRouteParams.length > minFallbacks)\n+        ) {\n+          route.throwOnEmptyStaticShell = false // Should not throw on empty static shell.\n+        } else {\n+          route.throwOnEmptyStaticShell = true // Should throw on empty static shell.\n+        }\n+      }\n+    }\n+\n+    // Add all children of the current node to the stack. This ensures that\n+    // the traversal continues to explore deeper paths in the Trie.\n+    for (const child of node.children.values()) {\n+      stack.push(child)\n+    }\n   }\n }\n \n@@ -489,7 +623,7 @@ export async function buildAppStaticPaths({\n   if (hadAllParamsGenerated || isRoutePPREnabled) {\n     if (isRoutePPREnabled) {\n       // Discover all unique combinations of the rootParams so we can generate\n-      // shells for each of them if they're available.\n+      // routes that won't throw on empty static shell for each of them if they're available.\n       routeParams.unshift(\n         ...filterUniqueRootParamsCombinations(rootParamKeys, routeParams)\n       )"
        }
    ],
    "stats": {
        "total": 541,
        "additions": 452,
        "deletions": 89
    }
}