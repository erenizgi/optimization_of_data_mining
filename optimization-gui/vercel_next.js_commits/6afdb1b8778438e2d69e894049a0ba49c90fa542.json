{
    "author": "lukesandberg",
    "message": "[turbopack] Reduce indirection in turbo-tasks dispatching (#80695)\n\n### What?\nTurboTasks uses numeric ids to reference traits, values and functions, these are used to in serialization routines, dispatching and runtime type checking for traits.\n\nThis PR adjusts the dispatching codepaths to instead leverage `&'static` references so that these hot codepaths don't have to reference the registry data structures.\n\n`dynamic_call` now uses as `&'static NativeFunction` instead of a `FunctionId`\n`trait_call` now uses a `&'static TraitMethod` instead of a `TraitId` and a `Cow<'static, str>`\n\nIn principle this will bloat struct sizes since all the `id` types are `u32`, however, in many cases i checked, the reference fit neatly into existing padding\n\n`LocalTaskType`, `CachedTaskType`: no change\n`FunctionAndArg`:  24->32 bytes (afaict this struct is extremely temporary)\n`TaskStatistics`: I changed the map key here so that map will perhaps get larger as well (though it depends on internals of HashMap, afaict, there is padding already so i think this one is a wash)\n\nCall frames will also get bigger to account for the references\n\n### Why?\n\nThis should remove some small fixed overhead from the codepaths that launch new tasks. Generally registry lookups should be fast but I observed that we often call `registry::get_function` multiple times in the same codepath.  The trait_call codepaths had similar problems but with even more indirection.\n\nAll the generated function stubs have trivial access to the static references since the macro is already what manages the lifetimes. So all in all this mostly simplifies the calling conventions\n\nA final small win is that we no longer need to generate `static once_cell` fields for the function ids, which should help a bit with compile time and does reduce binary size.\n\nrunning `cargo bloat --release --bin turbopack-cli`\ncanary: 48.5MiB .text section size, the file size is 153.0MiB\nfunc_refs: 48.4MiB .text section size, the file size is 151.5MiB\n\nso a tiny reduction in code but 2mb of binary size due to a reduction in `DATA` section entries for all the static variables.",
    "sha": "6afdb1b8778438e2d69e894049a0ba49c90fa542",
    "files": [
        {
            "sha": "00405467ab972c1f0b183ebad03d1152d6e2edec",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 16,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -24,8 +24,8 @@ use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n use smallvec::{SmallVec, smallvec};\n use tokio::time::{Duration, Instant};\n use turbo_tasks::{\n-    CellId, FunctionId, FxDashMap, KeyValuePair, RawVc, ReadCellOptions, ReadConsistency,\n-    SessionId, TRANSIENT_TASK_BIT, TaskId, TraitTypeId, TurboTasksBackendApi, ValueTypeId,\n+    CellId, FxDashMap, KeyValuePair, RawVc, ReadCellOptions, ReadConsistency, SessionId,\n+    TRANSIENT_TASK_BIT, TaskId, TraitTypeId, TurboTasksBackendApi, ValueTypeId,\n     backend::{\n         Backend, BackendJobId, CachedTaskType, CellContent, TaskExecutionSpec, TransientTaskRoot,\n         TransientTaskType, TurboTasksExecutionError, TypedCellContent,\n@@ -371,12 +371,12 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n     fn track_cache_hit(&self, task_type: &CachedTaskType) {\n         self.task_statistics\n-            .map(|stats| stats.increment_cache_hit(task_type.fn_type));\n+            .map(|stats| stats.increment_cache_hit(task_type.native_fn));\n     }\n \n     fn track_cache_miss(&self, task_type: &CachedTaskType) {\n         self.task_statistics\n-            .map(|stats| stats.increment_cache_miss(task_type.fn_type));\n+            .map(|stats| stats.increment_cache_miss(task_type.native_fn));\n     }\n }\n \n@@ -1391,11 +1391,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         )\n     }\n \n-    fn try_get_function_id(&self, task_id: TaskId) -> Option<FunctionId> {\n-        self.lookup_task_type(task_id)\n-            .map(|task_type| task_type.fn_type)\n-    }\n-\n     fn task_execution_canceled(\n         &self,\n         task_id: TaskId,\n@@ -1532,10 +1527,14 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         let (span, future) = match task_type {\n             TaskType::Cached(task_type) => {\n-                let CachedTaskType { fn_type, this, arg } = &*task_type;\n+                let CachedTaskType {\n+                    native_fn,\n+                    this,\n+                    arg,\n+                } = &*task_type;\n                 (\n-                    registry::get_function(*fn_type).span(task_id.persistence()),\n-                    registry::get_function(*fn_type).execute(*this, &**arg),\n+                    native_fn.span(task_id.persistence()),\n+                    native_fn.execute(*this, &**arg),\n                 )\n             }\n             TaskType::Transient(task_type) => {\n@@ -2652,10 +2651,6 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n         self.0.get_task_description(task)\n     }\n \n-    fn try_get_function_id(&self, task_id: TaskId) -> Option<FunctionId> {\n-        self.0.try_get_function_id(task_id)\n-    }\n-\n     type TaskState = ();\n     fn new_task_state(&self, _task: TaskId) -> Self::TaskState {}\n "
        },
        {
            "sha": "0cff3d32a2f295f54819a01471450fb827c0322b",
            "filename": "turbopack/crates/turbo-tasks-macros-shared/src/ident.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fident.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fident.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fident.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -29,13 +29,6 @@ pub fn get_native_function_ident(ident: &Ident) -> Ident {\n     )\n }\n \n-pub fn get_native_function_id_ident(ident: &Ident) -> Ident {\n-    Ident::new(\n-        &format!(\"{}_FUNCTION_ID\", ident.to_string().to_uppercase()),\n-        ident.span(),\n-    )\n-}\n-\n pub fn get_trait_type_ident(ident: &Ident) -> Ident {\n     Ident::new(\n         &format!(\"{}_TRAIT_TYPE\", ident.to_string().to_uppercase()),"
        },
        {
            "sha": "4a607023fd0c7098587e336cd1ff7d23a8c7880e",
            "filename": "turbopack/crates/turbo-tasks-macros/src/func.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 19,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -598,7 +598,7 @@ impl TurboFn<'_> {\n \n     /// The block of the exposed function for a dynamic dispatch call to the\n     /// given trait.\n-    pub fn dynamic_block(&self, trait_type_id_ident: &Ident) -> Block {\n+    pub fn dynamic_block(&self, trait_type_ident: &Ident) -> Block {\n         let Some(converted_this) = self.converted_this() else {\n             return parse_quote! {\n                 {\n@@ -618,10 +618,11 @@ impl TurboFn<'_> {\n                 let inputs = std::boxed::Box::new((#(#inputs,)*));\n                 let this = #converted_this;\n                 let persistence = #persistence;\n+                static TRAIT_METHOD: turbo_tasks::macro_helpers::Lazy<&'static turbo_tasks::TraitMethod> =\n+                        turbo_tasks::macro_helpers::Lazy::new(|| #trait_type_ident.get(stringify!(#ident)));\n                 <#output as turbo_tasks::task::TaskOutput>::try_from_raw_vc(\n                     turbo_tasks::trait_call(\n-                        *#trait_type_id_ident,\n-                        std::borrow::Cow::Borrowed(stringify!(#ident)),\n+                        *TRAIT_METHOD,\n                         this,\n                         inputs as std::boxed::Box<dyn turbo_tasks::MagicAny>,\n                         persistence,\n@@ -633,7 +634,7 @@ impl TurboFn<'_> {\n \n     /// The block of the exposed function for a static dispatch call to the\n     /// given native function.\n-    pub fn static_block(&self, native_function_id_ident: &Ident) -> Block {\n+    pub fn static_block(&self, native_function_ident: &Ident) -> Block {\n         let output = &self.output;\n         let inputs = self.inline_input_idents();\n         let assertions = self.get_assertions();\n@@ -647,7 +648,7 @@ impl TurboFn<'_> {\n                     let persistence = #persistence;\n                     <#output as turbo_tasks::task::TaskOutput>::try_from_raw_vc(\n                         turbo_tasks::dynamic_call(\n-                            *#native_function_id_ident,\n+                            &#native_function_ident,\n                             Some(this),\n                             inputs as std::boxed::Box<dyn turbo_tasks::MagicAny>,\n                             persistence,\n@@ -664,7 +665,7 @@ impl TurboFn<'_> {\n                     let persistence = #persistence;\n                     <#output as turbo_tasks::task::TaskOutput>::try_from_raw_vc(\n                         turbo_tasks::dynamic_call(\n-                            *#native_function_id_ident,\n+                            &#native_function_ident,\n                             None,\n                             inputs as std::boxed::Box<dyn turbo_tasks::MagicAny>,\n                             persistence,\n@@ -1140,7 +1141,7 @@ impl NativeFn {\n                     {\n                         #[allow(deprecated)]\n                         turbo_tasks::macro_helpers::NativeFunction::new_method(\n-                            #function_path_string.to_owned(),\n+                            #function_path_string,\n                             turbo_tasks::macro_helpers::FunctionMeta {\n                                 local: #local,\n                                 invalidator: #invalidator,\n@@ -1156,7 +1157,7 @@ impl NativeFn {\n                     {\n                         #[allow(deprecated)]\n                         turbo_tasks::macro_helpers::NativeFunction::new_method_without_this(\n-                            #function_path_string.to_owned(),\n+                            #function_path_string,\n                             turbo_tasks::macro_helpers::FunctionMeta {\n                                 local: #local,\n                                 invalidator: #invalidator,\n@@ -1173,7 +1174,7 @@ impl NativeFn {\n                 {\n                     #[allow(deprecated)]\n                     turbo_tasks::macro_helpers::NativeFunction::new_function(\n-                        #function_path_string.to_owned(),\n+                        #function_path_string,\n                         turbo_tasks::macro_helpers::FunctionMeta {\n                             local: #local,\n                             invalidator: #invalidator,\n@@ -1185,16 +1186,6 @@ impl NativeFn {\n             }\n         }\n     }\n-\n-    pub fn id_ty(&self) -> Type {\n-        parse_quote! { turbo_tasks::FunctionId }\n-    }\n-\n-    pub fn id_definition(&self, native_function_id_path: &Path) -> TokenStream {\n-        quote! {\n-            turbo_tasks::registry::get_function_id(&*#native_function_id_path)\n-        }\n-    }\n }\n \n pub fn filter_inline_attributes<'a>("
        },
        {
            "sha": "8a7b105e2d7ca8f248170b19499382661d8fdcf9",
            "filename": "turbopack/crates/turbo-tasks-macros/src/function_macro.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 13,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -1,9 +1,7 @@\n use proc_macro::TokenStream;\n use quote::quote;\n use syn::{ItemFn, parse_macro_input, parse_quote};\n-use turbo_tasks_macros_shared::{\n-    get_native_function_id_ident, get_native_function_ident, is_self_used,\n-};\n+use turbo_tasks_macros_shared::{get_native_function_ident, is_self_used};\n \n use crate::func::{\n     DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n@@ -73,12 +71,8 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n     let native_function_ty = native_fn.ty();\n     let native_function_def = native_fn.definition();\n \n-    let native_function_id_ident = get_native_function_id_ident(ident);\n-    let native_function_id_ty = native_fn.id_ty();\n-    let native_function_id_def = native_fn.id_definition(&native_function_ident.clone().into());\n-\n     let exposed_signature = turbo_fn.signature();\n-    let exposed_block = turbo_fn.static_block(&native_function_id_ident);\n+    let exposed_block = turbo_fn.static_block(&native_function_ident);\n \n     quote! {\n         #(#attrs)*\n@@ -93,11 +87,6 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n             turbo_tasks::macro_helpers::Lazy<#native_function_ty> =\n                 turbo_tasks::macro_helpers::Lazy::new(|| #native_function_def);\n \n-        #[doc(hidden)]\n-        pub(crate) static #native_function_id_ident:\n-            turbo_tasks::macro_helpers::Lazy<#native_function_id_ty> =\n-                turbo_tasks::macro_helpers::Lazy::new(|| #native_function_id_def);\n-\n         #(#errors)*\n     }\n     .into()"
        },
        {
            "sha": "098c05c914a78bf7d3587d35f3dfba3078837df0",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_impl_macro.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 25,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -9,9 +9,8 @@ use syn::{\n     spanned::Spanned,\n };\n use turbo_tasks_macros_shared::{\n-    get_inherent_impl_function_id_ident, get_inherent_impl_function_ident, get_path_ident,\n-    get_register_trait_impls_ident, get_register_trait_methods_ident,\n-    get_trait_impl_function_id_ident, get_trait_impl_function_ident, get_type_ident, is_self_used,\n+    get_inherent_impl_function_ident, get_path_ident, get_register_trait_impls_ident,\n+    get_register_trait_methods_ident, get_trait_impl_function_ident, get_type_ident, is_self_used,\n };\n \n use crate::{\n@@ -129,13 +128,8 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                 let native_function_ty = native_fn.ty();\n                 let native_function_def = native_fn.definition();\n \n-                let native_function_id_ident = get_inherent_impl_function_id_ident(ty_ident, ident);\n-                let native_function_id_ty = native_fn.id_ty();\n-                let native_function_id_def =\n-                    native_fn.id_definition(&native_function_ident.clone().into());\n-\n                 let turbo_signature = turbo_fn.signature();\n-                let turbo_block = turbo_fn.static_block(&native_function_id_ident);\n+                let turbo_block = turbo_fn.static_block(&native_function_ident);\n                 exposed_impl_items.push(quote! {\n                     #(#attrs)*\n                     #vis #turbo_signature #turbo_block\n@@ -157,10 +151,6 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                     pub(crate) static #native_function_ident:\n                         turbo_tasks::macro_helpers::Lazy<#native_function_ty> =\n                             turbo_tasks::macro_helpers::Lazy::new(|| #native_function_def);\n-                    #[doc(hidden)]\n-                    pub(crate) static #native_function_id_ident:\n-                        turbo_tasks::macro_helpers::Lazy<#native_function_id_ty> =\n-                            turbo_tasks::macro_helpers::Lazy::new(|| #native_function_id_def);\n                 })\n             }\n         }\n@@ -260,14 +250,8 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                 let native_function_ty = native_fn.ty();\n                 let native_function_def = native_fn.definition();\n \n-                let native_function_id_ident =\n-                    get_trait_impl_function_id_ident(ty_ident, &trait_ident, ident);\n-                let native_function_id_ty = native_fn.id_ty();\n-                let native_function_id_def =\n-                    native_fn.id_definition(&native_function_ident.clone().into());\n-\n                 let turbo_signature = turbo_fn.signature();\n-                let turbo_block = turbo_fn.static_block(&native_function_id_ident);\n+                let turbo_block = turbo_fn.static_block(&native_function_ident);\n \n                 trait_functions.push(quote! {\n                     #(#attrs)*\n@@ -295,14 +279,13 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                     pub(crate) static #native_function_ident:\n                         turbo_tasks::macro_helpers::Lazy<#native_function_ty> =\n                             turbo_tasks::macro_helpers::Lazy::new(|| #native_function_def);\n-                    #[doc(hidden)]\n-                    pub(crate) static #native_function_id_ident:\n-                        turbo_tasks::macro_helpers::Lazy<#native_function_id_ty> =\n-                            turbo_tasks::macro_helpers::Lazy::new(|| #native_function_id_def);\n                 });\n \n                 trait_registers.push(quote! {\n-                    value.register_trait_method(<Box<dyn #trait_path> as turbo_tasks::VcValueTrait>::get_trait_type_id(), stringify!(#ident).into(), *#native_function_id_ident);\n+                    value.register_trait_method(\n+                        <Box<dyn #trait_path> as turbo_tasks::VcValueTrait>::get_trait_type_id(),\n+                        stringify!(#ident),\n+                        &#native_function_ident);\n                 });\n             }\n         }"
        },
        {
            "sha": "1e66c7c8b938d8d8ab0c7ef64a3d278622fece6b",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_trait_macro.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 19,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -5,9 +5,8 @@ use syn::{\n     FnArg, ItemTrait, Pat, TraitItem, TraitItemFn, parse_macro_input, parse_quote, spanned::Spanned,\n };\n use turbo_tasks_macros_shared::{\n-    ValueTraitArguments, get_trait_default_impl_function_id_ident,\n-    get_trait_default_impl_function_ident, get_trait_type_id_ident, get_trait_type_ident,\n-    get_trait_type_vtable_registry, is_self_used,\n+    ValueTraitArguments, get_trait_default_impl_function_ident, get_trait_type_id_ident,\n+    get_trait_type_ident, get_trait_type_vtable_registry, is_self_used,\n };\n \n use crate::{\n@@ -168,8 +167,7 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n         };\n \n         let turbo_signature = turbo_fn.signature();\n-        let arg_types = turbo_fn.exposed_input_types();\n-        let dynamic_block = turbo_fn.dynamic_block(&trait_type_id_ident);\n+        let dynamic_block = turbo_fn.dynamic_block(&trait_type_ident);\n         dynamic_trait_fns.push(quote! {\n             #turbo_signature #dynamic_block\n         });\n@@ -204,14 +202,10 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n             let native_function_ty = native_function.ty();\n             let native_function_def = native_function.definition();\n \n-            let native_function_id_ident =\n-                get_trait_default_impl_function_id_ident(trait_ident, ident);\n-            let native_function_id_ty = native_function.id_ty();\n-            let native_function_id_def =\n-                native_function.id_definition(&native_function_ident.clone().into());\n-\n             trait_methods.push(quote! {\n-                trait_type.register_default_trait_method::<(#(#arg_types,)*)>(stringify!(#ident).into(), *#native_function_id_ident);\n+                trait_type.register_default_trait_method(\n+                    stringify!(#ident),\n+                    &#native_function_ident);\n             });\n \n             native_functions.push(quote! {\n@@ -235,16 +229,12 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n                 pub(crate) static #native_function_ident:\n                     turbo_tasks::macro_helpers::Lazy<#native_function_ty> =\n                         turbo_tasks::macro_helpers::Lazy::new(|| #native_function_def);\n-                #[doc(hidden)]\n-                pub(crate) static #native_function_id_ident:\n-                    turbo_tasks::macro_helpers::Lazy<#native_function_id_ty> =\n-                        turbo_tasks::macro_helpers::Lazy::new(|| #native_function_id_def);\n             });\n \n-            Some(turbo_fn.static_block(&native_function_id_ident))\n+            Some(turbo_fn.static_block(&native_function_ident))\n         } else {\n             trait_methods.push(quote! {\n-                trait_type.register_trait_method::<(#(#arg_types,)*)>(stringify!(#ident).into());\n+                trait_type.register_trait_method(stringify!(#ident));\n             });\n             None\n         };\n@@ -293,7 +283,7 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n         #[doc(hidden)]\n         pub(crate) static #trait_type_ident: turbo_tasks::macro_helpers::Lazy<turbo_tasks::TraitType> =\n             turbo_tasks::macro_helpers::Lazy::new(|| {\n-                let mut trait_type = turbo_tasks::TraitType::new(stringify!(#trait_ident).to_string());;\n+                let mut trait_type = turbo_tasks::TraitType::new(stringify!(#trait_ident));;\n                 #(#trait_methods)*\n                 trait_type\n             });"
        },
        {
            "sha": "5ddc143c33bcbf50d55198e2f5ac0402e99570b4",
            "filename": "turbopack/crates/turbo-tasks-testing/src/lib.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 8,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -4,7 +4,6 @@ pub mod retry;\n mod run;\n \n use std::{\n-    borrow::Cow,\n     future::Future,\n     mem::replace,\n     panic::AssertUnwindSafe,\n@@ -21,7 +20,6 @@ use turbo_tasks::{\n     backend::{CellContent, TaskCollectiblesMap, TypedCellContent},\n     event::{Event, EventListener},\n     message_queue::CompilationEvent,\n-    registry,\n     test_helpers::with_turbo_tasks_for_testing,\n     util::{SharedError, StaticOrArc},\n };\n@@ -43,13 +41,13 @@ pub struct VcStorage {\n impl VcStorage {\n     fn dynamic_call(\n         &self,\n-        func: turbo_tasks::FunctionId,\n+        func: &'static turbo_tasks::macro_helpers::NativeFunction,\n         this_arg: Option<RawVc>,\n         arg: Box<dyn MagicAny>,\n     ) -> RawVc {\n         let this = self.this.upgrade().unwrap();\n         let handle = tokio::runtime::Handle::current();\n-        let future = registry::get_function(func).execute(this_arg, &*arg);\n+        let future = func.execute(this_arg, &*arg);\n         let i = {\n             let mut tasks = self.tasks.lock().unwrap();\n             let i = tasks.len();\n@@ -92,7 +90,7 @@ impl VcStorage {\n impl TurboTasksCallApi for VcStorage {\n     fn dynamic_call(\n         &self,\n-        func: turbo_tasks::FunctionId,\n+        func: &'static turbo_tasks::macro_helpers::NativeFunction,\n         this: Option<RawVc>,\n         arg: Box<dyn MagicAny>,\n         _persistence: TaskPersistence,\n@@ -101,7 +99,7 @@ impl TurboTasksCallApi for VcStorage {\n     }\n     fn native_call(\n         &self,\n-        _func: turbo_tasks::FunctionId,\n+        _func: &'static turbo_tasks::macro_helpers::NativeFunction,\n         _this: Option<RawVc>,\n         _arg: Box<dyn MagicAny>,\n         _persistence: TaskPersistence,\n@@ -111,8 +109,7 @@ impl TurboTasksCallApi for VcStorage {\n \n     fn trait_call(\n         &self,\n-        _trait_type: turbo_tasks::TraitTypeId,\n-        _trait_fn_name: Cow<'static, str>,\n+        _trait_type: &'static turbo_tasks::TraitMethod,\n         _this: RawVc,\n         _arg: Box<dyn MagicAny>,\n         _persistence: TaskPersistence,"
        },
        {
            "sha": "813e3a97c3f9196e26c7b4633dbc4714f6b84264",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 24,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -18,9 +18,10 @@ use turbo_rcstr::RcStr;\n \n pub use crate::id::BackendJobId;\n use crate::{\n-    FunctionId, RawVc, ReadCellOptions, ReadRef, SharedReference, TaskId, TaskIdSet, TraitRef,\n-    TraitTypeId, TurboTasksPanic, ValueTypeId, VcRead, VcValueTrait, VcValueType,\n+    RawVc, ReadCellOptions, ReadRef, SharedReference, TaskId, TaskIdSet, TraitRef, TraitTypeId,\n+    TurboTasksPanic, ValueTypeId, VcRead, VcValueTrait, VcValueType,\n     event::EventListener,\n+    macro_helpers::NativeFunction,\n     magic_any::MagicAny,\n     manager::{ReadConsistency, TurboTasksBackendApi},\n     raw_vc::CellId,\n@@ -66,7 +67,7 @@ impl Debug for TransientTaskType {\n /// backend either to execute a function or to look up a cached result.\n #[derive(Debug, Eq)]\n pub struct CachedTaskType {\n-    pub fn_type: FunctionId,\n+    pub native_fn: &'static NativeFunction,\n     pub this: Option<RawVc>,\n     pub arg: Box<dyn MagicAny>,\n }\n@@ -75,7 +76,7 @@ impl CachedTaskType {\n     /// Get the name of the function from the registry. Equivalent to the\n     /// [`Display`]/[`ToString::to_string`] implementation, but does not allocate a [`String`].\n     pub fn get_name(&self) -> &'static str {\n-        &registry::get_function(self.fn_type).name\n+        self.native_fn.name\n     }\n }\n \n@@ -84,15 +85,15 @@ impl CachedTaskType {\n impl PartialEq for CachedTaskType {\n     #[expect(clippy::op_ref)]\n     fn eq(&self, other: &Self) -> bool {\n-        self.fn_type == other.fn_type && self.this == other.this && &self.arg == &other.arg\n+        self.native_fn == other.native_fn && self.this == other.this && &self.arg == &other.arg\n     }\n }\n \n // Manual implementation because we have to have a manual `PartialEq` implementation, and clippy\n // complains if we have a derived `Hash` impl, but manual `PartialEq` impl.\n impl Hash for CachedTaskType {\n     fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n-        self.fn_type.hash(state);\n+        self.native_fn.hash(state);\n         self.this.hash(state);\n         self.arg.hash(state);\n     }\n@@ -194,11 +195,11 @@ mod ser {\n \n     enum FunctionAndArg<'a> {\n         Owned {\n-            fn_type: FunctionId,\n+            native_fn: &'static NativeFunction,\n             arg: Box<dyn MagicAny>,\n         },\n         Borrowed {\n-            fn_type: FunctionId,\n+            native_fn: &'static NativeFunction,\n             arg: &'a dyn MagicAny,\n         },\n     }\n@@ -208,13 +209,15 @@ mod ser {\n         where\n             S: Serializer,\n         {\n-            let FunctionAndArg::Borrowed { fn_type, arg } = self else {\n+            let FunctionAndArg::Borrowed { native_fn, arg } = self else {\n                 unreachable!();\n             };\n             let mut state = serializer.serialize_seq(Some(2))?;\n-            state.serialize_element(&fn_type)?;\n+            // It would be a little tricky but we _could_ store the function id on the native_fn so\n+            // that instead of a hashmap lookup this would be a memory access on the NativeFn\n+            state.serialize_element(&registry::get_function_id(native_fn))?;\n             let arg = *arg;\n-            let arg = registry::get_function(*fn_type).arg_meta.as_serialize(arg);\n+            let arg = native_fn.arg_meta.as_serialize(arg);\n             state.serialize_element(arg)?;\n             state.end()\n         }\n@@ -234,16 +237,15 @@ mod ser {\n                 where\n                     A: serde::de::SeqAccess<'de>,\n                 {\n-                    let fn_type = seq\n+                    let fn_id = seq\n                         .next_element()?\n                         .ok_or_else(|| serde::de::Error::invalid_length(0, &self))?;\n-                    let seed = registry::get_function(fn_type)\n-                        .arg_meta\n-                        .deserialization_seed();\n+                    let native_fn = registry::get_function(fn_id);\n+                    let seed = native_fn.arg_meta.deserialization_seed();\n                     let arg = seq\n                         .next_element_seed(seed)?\n                         .ok_or_else(|| serde::de::Error::invalid_length(1, &self))?;\n-                    Ok(FunctionAndArg::Owned { fn_type, arg })\n+                    Ok(FunctionAndArg::Owned { native_fn, arg })\n                 }\n             }\n             deserializer.deserialize_seq(Visitor)\n@@ -255,10 +257,14 @@ mod ser {\n         where\n             S: ser::Serializer,\n         {\n-            let CachedTaskType { fn_type, this, arg } = self;\n+            let CachedTaskType {\n+                native_fn,\n+                this,\n+                arg,\n+            } = self;\n             let mut s = serializer.serialize_tuple(2)?;\n             s.serialize_element(&FunctionAndArg::Borrowed {\n-                fn_type: *fn_type,\n+                native_fn,\n                 arg: &**arg,\n             })?;\n             s.serialize_element(this)?;\n@@ -280,7 +286,7 @@ mod ser {\n                 where\n                     A: serde::de::SeqAccess<'de>,\n                 {\n-                    let FunctionAndArg::Owned { fn_type, arg } = seq\n+                    let FunctionAndArg::Owned { native_fn, arg } = seq\n                         .next_element()?\n                         .ok_or_else(|| serde::de::Error::invalid_length(0, &self))?\n                     else {\n@@ -289,7 +295,11 @@ mod ser {\n                     let this = seq\n                         .next_element()?\n                         .ok_or_else(|| serde::de::Error::invalid_length(1, &self))?;\n-                    Ok(CachedTaskType { fn_type, this, arg })\n+                    Ok(CachedTaskType {\n+                        native_fn,\n+                        this,\n+                        arg,\n+                    })\n                 }\n             }\n             deserializer.deserialize_tuple(2, Visitor)\n@@ -679,10 +689,6 @@ pub trait Backend: Sync + Send {\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> TaskId;\n \n-    /// For persistent tasks with associated\n-    /// [`NativeFunction`][crate::native_function::NativeFunction]s, return the [`FunctionId`].\n-    fn try_get_function_id(&self, task_id: TaskId) -> Option<FunctionId>;\n-\n     fn connect_task(\n         &self,\n         task: TaskId,"
        },
        {
            "sha": "9f78499ff2a5fad993c3df288e80dc7baf43e399",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -77,7 +77,6 @@ mod state;\n pub mod task;\n pub mod task_statistics;\n pub mod trace;\n-mod trait_helpers;\n mod trait_ref;\n mod triomphe_utils;\n pub mod util;"
        },
        {
            "sha": "b7fd06c43501e1c50ee06920eddbc0703ee75323",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 51,
            "deletions": 41,
            "changes": 92,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -1,6 +1,5 @@\n use std::{\n     any::Any,\n-    borrow::Cow,\n     future::Future,\n     hash::BuildHasherDefault,\n     mem::take,\n@@ -24,16 +23,17 @@ use turbo_tasks_malloc::TurboMalloc;\n \n use crate::{\n     Completion, InvalidationReason, InvalidationReasonSet, OutputContent, ReadCellOptions,\n-    ResolvedVc, SharedReference, TaskId, TaskIdSet, ValueTypeId, Vc, VcRead, VcValueTrait,\n-    VcValueType,\n+    ResolvedVc, SharedReference, TaskId, TaskIdSet, TraitMethod, ValueTypeId, Vc, VcRead,\n+    VcValueTrait, VcValueType,\n     backend::{\n         Backend, CachedTaskType, CellContent, TaskCollectiblesMap, TaskExecutionSpec,\n         TransientTaskType, TurboTasksExecutionError, TypedCellContent,\n     },\n     capture_future::{self, CaptureFuture},\n     event::{Event, EventListener},\n-    id::{BackendJobId, ExecutionId, FunctionId, LocalTaskId, TRANSIENT_TASK_BIT, TraitTypeId},\n+    id::{BackendJobId, ExecutionId, LocalTaskId, TRANSIENT_TASK_BIT, TraitTypeId},\n     id_factory::IdFactoryWithReuse,\n+    macro_helpers::NativeFunction,\n     magic_any::MagicAny,\n     message_queue::{CompilationEvent, CompilationEventQueue},\n     raw_vc::{CellId, RawVc},\n@@ -42,7 +42,6 @@ use crate::{\n     task::local_task::{LocalTask, LocalTaskType},\n     task_statistics::TaskStatisticsApi,\n     trace::TraceRawVcs,\n-    trait_helpers::get_trait_method,\n     util::{IdFactory, StaticOrArc},\n     vc::ReadVcFuture,\n };\n@@ -54,7 +53,7 @@ pub trait TurboTasksCallApi: Sync + Send {\n     /// with a wrapper task.\n     fn dynamic_call(\n         &self,\n-        func: FunctionId,\n+        native_fn: &'static NativeFunction,\n         this: Option<RawVc>,\n         arg: Box<dyn MagicAny>,\n         persistence: TaskPersistence,\n@@ -63,7 +62,7 @@ pub trait TurboTasksCallApi: Sync + Send {\n     /// All inputs must be resolved.\n     fn native_call(\n         &self,\n-        func: FunctionId,\n+        native_fn: &'static NativeFunction,\n         this: Option<RawVc>,\n         arg: Box<dyn MagicAny>,\n         persistence: TaskPersistence,\n@@ -72,8 +71,7 @@ pub trait TurboTasksCallApi: Sync + Send {\n     /// Uses a wrapper task to resolve\n     fn trait_call(\n         &self,\n-        trait_type: TraitTypeId,\n-        trait_fn_name: Cow<'static, str>,\n+        trait_method: &'static TraitMethod,\n         this: RawVc,\n         arg: Box<dyn MagicAny>,\n         persistence: TaskPersistence,\n@@ -590,19 +588,27 @@ impl<B: Backend + 'static> TurboTasks<B> {\n \n     pub(crate) fn native_call(\n         &self,\n-        fn_type: FunctionId,\n+        native_fn: &'static NativeFunction,\n         this: Option<RawVc>,\n         arg: Box<dyn MagicAny>,\n         persistence: TaskPersistence,\n     ) -> RawVc {\n         match persistence {\n             TaskPersistence::Local => {\n-                let task_type = LocalTaskType::Native { fn_type, this, arg };\n+                let task_type = LocalTaskType::Native {\n+                    native_fn,\n+                    this,\n+                    arg,\n+                };\n                 self.schedule_local_task(task_type, persistence)\n             }\n             TaskPersistence::Transient => {\n-                let immutable = registry::get_function(fn_type).function_meta.immutable;\n-                let task_type = CachedTaskType { fn_type, this, arg };\n+                let immutable = native_fn.function_meta.immutable;\n+                let task_type = CachedTaskType {\n+                    native_fn,\n+                    this,\n+                    arg,\n+                };\n \n                 RawVc::TaskOutput(self.backend.get_or_create_transient_task(\n                     task_type,\n@@ -612,8 +618,12 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                 ))\n             }\n             TaskPersistence::Persistent => {\n-                let immutable = registry::get_function(fn_type).function_meta.immutable;\n-                let task_type = CachedTaskType { fn_type, this, arg };\n+                let immutable = native_fn.function_meta.immutable;\n+                let task_type = CachedTaskType {\n+                    native_fn,\n+                    this,\n+                    arg,\n+                };\n \n                 RawVc::TaskOutput(self.backend.get_or_create_persistent_task(\n                     task_type,\n@@ -627,24 +637,25 @@ impl<B: Backend + 'static> TurboTasks<B> {\n \n     pub fn dynamic_call(\n         &self,\n-        fn_type: FunctionId,\n+        native_fn: &'static NativeFunction,\n         this: Option<RawVc>,\n         arg: Box<dyn MagicAny>,\n         persistence: TaskPersistence,\n     ) -> RawVc {\n-        if this.is_none_or(|this| this.is_resolved())\n-            && registry::get_function(fn_type).arg_meta.is_resolved(&*arg)\n-        {\n-            return self.native_call(fn_type, this, arg, persistence);\n+        if this.is_none_or(|this| this.is_resolved()) && native_fn.arg_meta.is_resolved(&*arg) {\n+            return self.native_call(native_fn, this, arg, persistence);\n         }\n-        let task_type = LocalTaskType::ResolveNative { fn_type, this, arg };\n+        let task_type = LocalTaskType::ResolveNative {\n+            native_fn,\n+            this,\n+            arg,\n+        };\n         self.schedule_local_task(task_type, persistence)\n     }\n \n     pub fn trait_call(\n         &self,\n-        trait_type: TraitTypeId,\n-        mut trait_fn_name: Cow<'static, str>,\n+        trait_method: &'static TraitMethod,\n         this: RawVc,\n         arg: Box<dyn MagicAny>,\n         persistence: TaskPersistence,\n@@ -653,21 +664,22 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         // for resolved cells we already know the value type so we can lookup the\n         // function\n         if let RawVc::TaskCell(_, CellId { type_id, .. }) = this {\n-            match get_trait_method(trait_type, type_id, trait_fn_name) {\n-                Ok(native_fn) => {\n-                    let arg = registry::get_function(native_fn).arg_meta.filter_owned(arg);\n+            match registry::get_value_type(type_id).get_trait_method(trait_method) {\n+                Some(native_fn) => {\n+                    let arg = native_fn.arg_meta.filter_owned(arg);\n                     return self.dynamic_call(native_fn, Some(this), arg, persistence);\n                 }\n-                Err(name) => {\n-                    trait_fn_name = name;\n+                None => {\n+                    // We are destined to fail at this point, but we just retry resolution in the\n+                    // local task since we cannot report an error from here.\n+                    // TODO: A panic seems appropriate since the immediate caller is to blame\n                 }\n             }\n         }\n \n         // create a wrapper task to resolve all inputs\n         let task_type = LocalTaskType::ResolveTrait {\n-            trait_type,\n-            method_name: trait_fn_name,\n+            trait_method,\n             this,\n             arg,\n         };\n@@ -1150,31 +1162,30 @@ impl<B: Backend + 'static> TurboTasks<B> {\n impl<B: Backend + 'static> TurboTasksCallApi for TurboTasks<B> {\n     fn dynamic_call(\n         &self,\n-        func: FunctionId,\n+        native_fn: &'static NativeFunction,\n         this: Option<RawVc>,\n         arg: Box<dyn MagicAny>,\n         persistence: TaskPersistence,\n     ) -> RawVc {\n-        self.dynamic_call(func, this, arg, persistence)\n+        self.dynamic_call(native_fn, this, arg, persistence)\n     }\n     fn native_call(\n         &self,\n-        func: FunctionId,\n+        native_fn: &'static NativeFunction,\n         this: Option<RawVc>,\n         arg: Box<dyn MagicAny>,\n         persistence: TaskPersistence,\n     ) -> RawVc {\n-        self.native_call(func, this, arg, persistence)\n+        self.native_call(native_fn, this, arg, persistence)\n     }\n     fn trait_call(\n         &self,\n-        trait_type: TraitTypeId,\n-        trait_fn_name: Cow<'static, str>,\n+        trait_method: &'static TraitMethod,\n         this: RawVc,\n         arg: Box<dyn MagicAny>,\n         persistence: TaskPersistence,\n     ) -> RawVc {\n-        self.trait_call(trait_type, trait_fn_name, this, arg, persistence)\n+        self.trait_call(trait_method, this, arg, persistence)\n     }\n \n     #[track_caller]\n@@ -1627,7 +1638,7 @@ pub async fn run_once_with_reason<T: Send + 'static>(\n \n /// Calls [`TurboTasks::dynamic_call`] for the current turbo tasks instance.\n pub fn dynamic_call(\n-    func: FunctionId,\n+    func: &'static NativeFunction,\n     this: Option<RawVc>,\n     arg: Box<dyn MagicAny>,\n     persistence: TaskPersistence,\n@@ -1637,13 +1648,12 @@ pub fn dynamic_call(\n \n /// Calls [`TurboTasks::trait_call`] for the current turbo tasks instance.\n pub fn trait_call(\n-    trait_type: TraitTypeId,\n-    trait_fn_name: Cow<'static, str>,\n+    trait_method: &'static TraitMethod,\n     this: RawVc,\n     arg: Box<dyn MagicAny>,\n     persistence: TaskPersistence,\n ) -> RawVc {\n-    with_turbo_tasks(|tt| tt.trait_call(trait_type, trait_fn_name, this, arg, persistence))\n+    with_turbo_tasks(|tt| tt.trait_call(trait_method, this, arg, persistence))\n }\n \n pub fn turbo_tasks() -> Arc<dyn TurboTasksApi> {"
        },
        {
            "sha": "1b63d9a6c6a12a4627cd1f1bd6c5e4f5e7b07199",
            "filename": "turbopack/crates/turbo-tasks/src/native_function.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 25,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -157,15 +157,15 @@ pub struct FunctionMeta {\n /// `#[turbo_tasks::function]`.\n pub struct NativeFunction {\n     /// A readable name of the function that is used to reporting purposes.\n-    pub name: String,\n+    pub(crate) name: &'static str,\n \n-    pub function_meta: FunctionMeta,\n+    pub(crate) function_meta: FunctionMeta,\n \n-    pub arg_meta: ArgMeta,\n+    pub(crate) arg_meta: ArgMeta,\n \n     /// The functor that creates a functor from inputs. The inner functor\n     /// handles the task execution.\n-    pub implementation: Box<dyn TaskFn + Send + Sync + 'static>,\n+    pub(crate) implementation: Box<dyn TaskFn + Send + Sync + 'static>,\n }\n \n impl Debug for NativeFunction {\n@@ -179,7 +179,7 @@ impl Debug for NativeFunction {\n \n impl NativeFunction {\n     pub fn new_function<Mode, Inputs>(\n-        name: String,\n+        name: &'static str,\n         function_meta: FunctionMeta,\n         implementation: impl IntoTaskFn<Mode, Inputs>,\n     ) -> Self\n@@ -195,7 +195,7 @@ impl NativeFunction {\n     }\n \n     pub fn new_method_without_this<Mode, Inputs, I>(\n-        name: String,\n+        name: &'static str,\n         function_meta: FunctionMeta,\n         arg_filter: Option<(FilterOwnedArgsFunctor, FilterAndResolveFunctor)>,\n         implementation: I,\n@@ -217,7 +217,7 @@ impl NativeFunction {\n     }\n \n     pub fn new_method<Mode, This, Inputs, I>(\n-        name: String,\n+        name: &'static str,\n         function_meta: FunctionMeta,\n         arg_filter: Option<(FilterOwnedArgsFunctor, FilterAndResolveFunctor)>,\n         implementation: I,\n@@ -256,43 +256,31 @@ impl NativeFunction {\n     pub fn span(&'static self, persistence: TaskPersistence) -> Span {\n         match persistence {\n             TaskPersistence::Persistent => {\n-                tracing::trace_span!(\"turbo_tasks::function\", name = self.name.as_str())\n+                tracing::trace_span!(\"turbo_tasks::function\", name = self.name)\n             }\n             TaskPersistence::Transient => {\n-                tracing::trace_span!(\n-                    \"turbo_tasks::function\",\n-                    name = self.name.as_str(),\n-                    transient = true,\n-                )\n+                tracing::trace_span!(\"turbo_tasks::function\", name = self.name, transient = true,)\n             }\n             TaskPersistence::Local => {\n-                tracing::trace_span!(\n-                    \"turbo_tasks::function\",\n-                    name = self.name.as_str(),\n-                    local = true,\n-                )\n+                tracing::trace_span!(\"turbo_tasks::function\", name = self.name, local = true,)\n             }\n         }\n     }\n \n     pub fn resolve_span(&'static self, persistence: TaskPersistence) -> Span {\n         match persistence {\n             TaskPersistence::Persistent => {\n-                tracing::trace_span!(\"turbo_tasks::resolve_call\", name = self.name.as_str())\n+                tracing::trace_span!(\"turbo_tasks::resolve_call\", name = self.name)\n             }\n             TaskPersistence::Transient => {\n                 tracing::trace_span!(\n                     \"turbo_tasks::resolve_call\",\n-                    name = self.name.as_str(),\n+                    name = self.name,\n                     transient = true,\n                 )\n             }\n             TaskPersistence::Local => {\n-                tracing::trace_span!(\n-                    \"turbo_tasks::resolve_call\",\n-                    name = self.name.as_str(),\n-                    local = true,\n-                )\n+                tracing::trace_span!(\"turbo_tasks::resolve_call\", name = self.name, local = true,)\n             }\n         }\n     }"
        },
        {
            "sha": "c7f626e15f0b86005e96aa32d51753ec49c17fcf",
            "filename": "turbopack/crates/turbo-tasks/src/task/local_task.rs",
            "status": "modified",
            "additions": 64,
            "deletions": 76,
            "changes": 140,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Flocal_task.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -1,14 +1,14 @@\n-use std::{borrow::Cow, fmt, fmt::Write, sync::Arc};\n+use std::{borrow::Cow, fmt, sync::Arc};\n \n use anyhow::{Result, anyhow};\n \n use crate::{\n-    FunctionId, MagicAny, OutputContent, RawVc, TaskPersistence, TraitTypeId, TurboTasksBackendApi,\n+    MagicAny, OutputContent, RawVc, TaskPersistence, TraitMethod, TurboTasksBackendApi,\n     ValueTypeId,\n     backend::{Backend, TaskExecutionSpec, TypedCellContent},\n     event::Event,\n+    macro_helpers::NativeFunction,\n     registry,\n-    trait_helpers::{get_trait_method, has_trait, traits},\n };\n \n /// A potentially in-flight local task stored in `CurrentGlobalTaskState::local_tasks`.\n@@ -26,27 +26,25 @@ pub fn get_local_task_execution_spec<'a>(\n ) -> TaskExecutionSpec<'a> {\n     match ty {\n         LocalTaskType::Native {\n-            fn_type: native_fn_id,\n+            native_fn,\n             this,\n             arg,\n         } => {\n-            let func = registry::get_function(*native_fn_id);\n-            let span = func.span(TaskPersistence::Local);\n+            let span = native_fn.span(TaskPersistence::Local);\n             let entered = span.enter();\n-            let future = func.execute(*this, &**arg);\n+            let future = native_fn.execute(*this, &**arg);\n             drop(entered);\n             TaskExecutionSpec { future, span }\n         }\n         LocalTaskType::ResolveNative {\n-            fn_type: native_fn_id,\n+            native_fn,\n             this,\n             arg,\n         } => {\n-            let func = registry::get_function(*native_fn_id);\n-            let span = func.resolve_span(TaskPersistence::Local);\n+            let span = native_fn.resolve_span(TaskPersistence::Local);\n             let entered = span.enter();\n             let future = Box::pin(LocalTaskType::run_resolve_native(\n-                *native_fn_id,\n+                native_fn,\n                 *this,\n                 &**arg,\n                 persistence,\n@@ -56,17 +54,14 @@ pub fn get_local_task_execution_spec<'a>(\n             TaskExecutionSpec { future, span }\n         }\n         LocalTaskType::ResolveTrait {\n-            trait_type: trait_type_id,\n-            method_name: name,\n+            trait_method,\n             this,\n             arg,\n         } => {\n-            let trait_type = registry::get_trait(*trait_type_id);\n-            let span = trait_type.resolve_span(name);\n+            let span = trait_method.resolve_span();\n             let entered = span.enter();\n             let future = Box::pin(LocalTaskType::run_resolve_trait(\n-                *trait_type_id,\n-                name.clone(),\n+                trait_method,\n                 *this,\n                 &**arg,\n                 persistence,\n@@ -81,15 +76,15 @@ pub fn get_local_task_execution_spec<'a>(\n pub enum LocalTaskType {\n     /// A normal task execution a native (rust) function\n     Native {\n-        fn_type: FunctionId,\n+        native_fn: &'static NativeFunction,\n         this: Option<RawVc>,\n         arg: Box<dyn MagicAny>,\n     },\n \n     /// A resolve task, which resolves arguments and calls the function with resolve arguments. The\n     /// inner function call will be a `PersistentTaskType` or `LocalTaskType::Native`.\n     ResolveNative {\n-        fn_type: FunctionId,\n+        native_fn: &'static NativeFunction,\n         this: Option<RawVc>,\n         arg: Box<dyn MagicAny>,\n     },\n@@ -98,16 +93,35 @@ pub enum LocalTaskType {\n     /// method on that value. Then it calls that method. The method call will do a cache lookup and\n     /// might resolve arguments before.\n     ResolveTrait {\n-        trait_type: TraitTypeId,\n-        method_name: Cow<'static, str>,\n+        trait_method: &'static TraitMethod,\n         this: RawVc,\n         arg: Box<dyn MagicAny>,\n     },\n }\n \n impl fmt::Display for LocalTaskType {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.get_name())\n+        match self {\n+            LocalTaskType::Native {\n+                native_fn,\n+                this: _,\n+                arg: _,\n+            } => f.write_str(native_fn.name),\n+            LocalTaskType::ResolveNative {\n+                native_fn,\n+                this: _,\n+                arg: _,\n+            } => write!(f, \"*{}\", native_fn.name),\n+            LocalTaskType::ResolveTrait {\n+                trait_method,\n+                this: _,\n+                arg: _,\n+            } => write!(\n+                f,\n+                \"*{}::{}\",\n+                trait_method.trait_name, trait_method.method_name\n+            ),\n+        }\n     }\n }\n \n@@ -120,33 +134,27 @@ impl LocalTaskType {\n     pub fn get_name(&self) -> Cow<'static, str> {\n         match self {\n             Self::Native {\n-                fn_type: native_fn,\n+                native_fn,\n                 this: _,\n                 arg: _,\n-            } => Cow::Borrowed(&registry::get_function(*native_fn).name),\n+            } => Cow::Borrowed(native_fn.name),\n             Self::ResolveNative {\n-                fn_type: native_fn,\n+                native_fn,\n                 this: _,\n                 arg: _,\n-            } => format!(\"*{}\", registry::get_function(*native_fn).name).into(),\n+            } => format!(\"*{}\", native_fn.name).into(),\n             Self::ResolveTrait {\n-                trait_type: trait_id,\n-                method_name: fn_name,\n+                trait_method,\n                 this: _,\n                 arg: _,\n-            } => format!(\"*{}::{}\", registry::get_trait(*trait_id).name, fn_name).into(),\n-        }\n-    }\n-\n-    pub fn try_get_function_id(&self) -> Option<FunctionId> {\n-        match self {\n-            Self::Native { fn_type, .. } | Self::ResolveNative { fn_type, .. } => Some(*fn_type),\n-            Self::ResolveTrait { .. } => None,\n+            } => format!(\"*{}::{}\", trait_method.trait_name, trait_method.method_name).into(),\n         }\n     }\n \n-    pub async fn run_resolve_native<B: Backend + 'static>(\n-        fn_id: FunctionId,\n+    /// Implementation of the LocalTaskType::ResolveNative task.\n+    /// Resolves all the task inputs and then calls the given function.\n+    async fn run_resolve_native<B: Backend + 'static>(\n+        native_fn: &'static NativeFunction,\n         mut this: Option<RawVc>,\n         arg: &dyn MagicAny,\n         persistence: TaskPersistence,\n@@ -155,13 +163,12 @@ impl LocalTaskType {\n         if let Some(this) = this.as_mut() {\n             *this = this.resolve().await?;\n         }\n-        let arg = registry::get_function(fn_id).arg_meta.resolve(arg).await?;\n-        Ok(turbo_tasks.native_call(fn_id, this, arg, persistence))\n+        let arg = native_fn.arg_meta.resolve(arg).await?;\n+        Ok(turbo_tasks.native_call(native_fn, this, arg, persistence))\n     }\n-\n-    pub async fn run_resolve_trait<B: Backend + 'static>(\n-        trait_type: TraitTypeId,\n-        name: Cow<'static, str>,\n+    /// Implementation of the LocalTaskType::ResolveTrait task.\n+    async fn run_resolve_trait<B: Backend + 'static>(\n+        trait_method: &'static TraitMethod,\n         this: RawVc,\n         arg: &dyn MagicAny,\n         persistence: TaskPersistence,\n@@ -170,40 +177,22 @@ impl LocalTaskType {\n         let this = this.resolve().await?;\n         let TypedCellContent(this_ty, _) = this.into_read().await?;\n \n-        let native_fn_id = Self::resolve_trait_method_from_value(trait_type, this_ty, name)?;\n-        let native_fn = registry::get_function(native_fn_id);\n+        let native_fn = Self::resolve_trait_method_from_value(trait_method, this_ty)?;\n         let arg = native_fn.arg_meta.filter_and_resolve(arg).await?;\n-        Ok(turbo_tasks.dynamic_call(native_fn_id, Some(this), arg, persistence))\n+        Ok(turbo_tasks.native_call(native_fn, Some(this), arg, persistence))\n     }\n \n     fn resolve_trait_method_from_value(\n-        trait_type: TraitTypeId,\n+        trait_method: &'static TraitMethod,\n         value_type: ValueTypeId,\n-        name: Cow<'static, str>,\n-    ) -> Result<FunctionId> {\n-        match get_trait_method(trait_type, value_type, name) {\n-            Ok(native_fn) => Ok(native_fn),\n-            Err(name) => {\n-                if !has_trait(value_type, trait_type) {\n-                    let traits = traits(value_type).iter().fold(String::new(), |mut out, t| {\n-                        let _ = write!(out, \" {t}\");\n-                        out\n-                    });\n-                    Err(anyhow!(\n-                        \"{} doesn't implement {} (only{})\",\n-                        registry::get_value_type(value_type),\n-                        registry::get_trait(trait_type),\n-                        traits,\n-                    ))\n-                } else {\n-                    Err(anyhow!(\n-                        \"{} implements trait {}, but method {} is missing\",\n-                        registry::get_value_type(value_type),\n-                        registry::get_trait(trait_type),\n-                        name\n-                    ))\n-                }\n-            }\n+    ) -> Result<&'static NativeFunction> {\n+        match registry::get_value_type(value_type).get_trait_method(trait_method) {\n+            Some(native_fn) => Ok(native_fn),\n+            None => Err(anyhow!(\n+                \"{} doesn't implement the trait for {:?}, the compiler should have flagged this\",\n+                registry::get_value_type(value_type),\n+                trait_method\n+            )),\n         }\n     }\n }\n@@ -229,7 +218,7 @@ pub(crate) mod tests {\n         crate::register();\n         assert_eq!(\n             LocalTaskType::Native {\n-                fn_type: *MOCK_FUNC_TASK_FUNCTION_ID,\n+                native_fn: &MOCK_FUNC_TASK_FUNCTION,\n                 this: None,\n                 arg: Box::new(()),\n             }\n@@ -238,8 +227,7 @@ pub(crate) mod tests {\n         );\n         assert_eq!(\n             LocalTaskType::ResolveTrait {\n-                trait_type: *MOCKTRAIT_TRAIT_TYPE_ID,\n-                method_name: \"mock_method_task\".into(),\n+                trait_method: MOCKTRAIT_TRAIT_TYPE.get(\"mock_method_task\"),\n                 this: RawVc::TaskOutput(unsafe { TaskId::new_unchecked(1) }),\n                 arg: Box::new(()),\n             }"
        },
        {
            "sha": "220a8160bddf9212e7dd774e8e87c7888e3235ee",
            "filename": "turbopack/crates/turbo-tasks/src/task_statistics.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask_statistics.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask_statistics.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask_statistics.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -2,7 +2,7 @@ use std::sync::{Arc, OnceLock};\n \n use serde::{Serialize, Serializer, ser::SerializeMap};\n \n-use crate::{FunctionId, FxDashMap, registry};\n+use crate::{FxDashMap, macro_helpers::NativeFunction, registry};\n \n /// An API for optionally enabling, updating, and reading aggregated statistics.\n #[derive(Default)]\n@@ -38,24 +38,24 @@ impl TaskStatisticsApi {\n \n /// A type representing the enabled state of [`TaskStatisticsApi`]. Implements [`serde::Serialize`].\n pub struct TaskStatistics {\n-    inner: FxDashMap<FunctionId, TaskFunctionStatistics>,\n+    inner: FxDashMap<&'static NativeFunction, TaskFunctionStatistics>,\n }\n \n impl TaskStatistics {\n-    pub fn increment_cache_hit(&self, function_id: FunctionId) {\n-        self.with_task_type_statistics(function_id, |stats| stats.cache_hit += 1)\n+    pub fn increment_cache_hit(&self, native_fn: &'static NativeFunction) {\n+        self.with_task_type_statistics(native_fn, |stats| stats.cache_hit += 1)\n     }\n \n-    pub fn increment_cache_miss(&self, function_id: FunctionId) {\n-        self.with_task_type_statistics(function_id, |stats| stats.cache_miss += 1)\n+    pub fn increment_cache_miss(&self, native_fn: &'static NativeFunction) {\n+        self.with_task_type_statistics(native_fn, |stats| stats.cache_miss += 1)\n     }\n \n     fn with_task_type_statistics(\n         &self,\n-        task_function_id: FunctionId,\n+        native_fn: &'static NativeFunction,\n         func: impl Fn(&mut TaskFunctionStatistics),\n     ) {\n-        func(self.inner.entry(task_function_id).or_default().value_mut())\n+        func(self.inner.entry(native_fn).or_default().value_mut())\n     }\n }\n \n@@ -73,7 +73,7 @@ impl Serialize for TaskStatistics {\n     {\n         let mut map = serializer.serialize_map(Some(self.inner.len()))?;\n         for entry in &self.inner {\n-            let key = registry::get_function_global_name(*entry.key());\n+            let key = registry::get_function_global_name(registry::get_function_id(entry.key()));\n             map.serialize_entry(key, entry.value())?;\n         }\n         map.end()"
        },
        {
            "sha": "026392c50c4e529cf76a95c4292b08a7db1e92c1",
            "filename": "turbopack/crates/turbo-tasks/src/trait_helpers.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 33,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/2502c0a40c78b4eaa284c5b2925430764c384137/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrait_helpers.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2502c0a40c78b4eaa284c5b2925430764c384137/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrait_helpers.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrait_helpers.rs?ref=2502c0a40c78b4eaa284c5b2925430764c384137",
            "patch": "@@ -1,33 +0,0 @@\n-use std::borrow::Cow;\n-\n-use crate::{FunctionId, TraitType, TraitTypeId, ValueTypeId, registry};\n-\n-pub fn get_trait_method(\n-    trait_type: TraitTypeId,\n-    value_type: ValueTypeId,\n-    name: Cow<'static, str>,\n-) -> Result<FunctionId, Cow<'static, str>> {\n-    let key = (trait_type, name);\n-    if let Some(func) = registry::get_value_type(value_type).get_trait_method(&key) {\n-        Ok(*func)\n-    } else if let Some(func) = registry::get_trait(trait_type)\n-        .methods\n-        .get(&key.1)\n-        .and_then(|method| method.default_method)\n-    {\n-        Ok(func)\n-    } else {\n-        Err(key.1)\n-    }\n-}\n-\n-pub fn has_trait(value_type: ValueTypeId, trait_type: TraitTypeId) -> bool {\n-    registry::get_value_type(value_type).has_trait(&trait_type)\n-}\n-\n-pub fn traits(value_type: ValueTypeId) -> Vec<&'static TraitType> {\n-    registry::get_value_type(value_type)\n-        .traits_iter()\n-        .map(registry::get_trait)\n-        .collect()\n-}"
        },
        {
            "sha": "18c69a181253ae674b1511095e38e150f4be40f5",
            "filename": "turbopack/crates/turbo-tasks/src/value_type.rs",
            "status": "modified",
            "additions": 63,
            "deletions": 59,
            "changes": 122,
            "blob_url": "https://github.com/vercel/next.js/blob/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvalue_type.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6afdb1b8778438e2d69e894049a0ba49c90fa542/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvalue_type.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvalue_type.rs?ref=6afdb1b8778438e2d69e894049a0ba49c90fa542",
            "patch": "@@ -1,6 +1,5 @@\n use std::{\n     any::{Any, type_name},\n-    borrow::Cow,\n     fmt::{self, Debug, Display, Formatter},\n     hash::Hash,\n     sync::Arc,\n@@ -12,11 +11,11 @@ use tracing::Span;\n \n use crate::{\n     RawVc, VcValueType,\n-    id::{FunctionId, TraitTypeId},\n-    magic_any::{AnyDeserializeSeed, MagicAny, MagicAnyDeserializeSeed, MagicAnySerializeSeed},\n-    registry::{register_trait_type, register_value_type},\n+    id::TraitTypeId,\n+    macro_helpers::NativeFunction,\n+    magic_any::{AnyDeserializeSeed, MagicAny, MagicAnyDeserializeSeed},\n+    registry::{self, register_trait_type, register_value_type},\n     task::shared_reference::TypedSharedReference,\n-    trace::TraceRawVcs,\n     vc::VcCellMode,\n };\n \n@@ -37,9 +36,9 @@ pub struct ValueType {\n     /// A readable name of the type\n     pub name: String,\n     /// Set of traits available\n-    pub traits: AutoSet<TraitTypeId>,\n+    traits: AutoSet<TraitTypeId>,\n     /// List of trait methods available\n-    pub trait_methods: AutoMap<(TraitTypeId, Cow<'static, str>), FunctionId>,\n+    trait_methods: AutoMap<&'static TraitMethod, &'static NativeFunction>,\n \n     /// Functors for serialization\n     magic_serialization: Option<(MagicSerializationFn, MagicAnyDeserializeSeed)>,\n@@ -75,8 +74,12 @@ impl Debug for ValueType {\n     fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n         let mut d = f.debug_struct(\"ValueType\");\n         d.field(\"name\", &self.name);\n-        for ((_trait_type, name), _value) in self.trait_methods.iter() {\n-            d.field(name, &\"(trait fn)\");\n+        for trait_id in self.traits.iter() {\n+            for (name, m) in &registry::get_trait(*trait_id).methods {\n+                if self.trait_methods.contains_key(&m) {\n+                    d.field(name, &\"(trait fn)\");\n+                }\n+            }\n         }\n         d.finish()\n     }\n@@ -166,17 +169,21 @@ impl ValueType {\n     pub fn register_trait_method(\n         &mut self,\n         trait_type: TraitTypeId,\n-        name: Cow<'static, str>,\n-        native_fn: FunctionId,\n+        name: &str,\n+        native_fn: &'static NativeFunction,\n     ) {\n-        self.trait_methods.insert((trait_type, name), native_fn);\n+        self.trait_methods\n+            .insert(registry::get_trait(trait_type).get(name), native_fn);\n     }\n \n     pub fn get_trait_method(\n         &self,\n-        trait_method_key: &(TraitTypeId, Cow<'static, str>),\n-    ) -> Option<&FunctionId> {\n-        self.trait_methods.get(trait_method_key)\n+        trait_method: &'static TraitMethod,\n+    ) -> Option<&'static NativeFunction> {\n+        match self.trait_methods.get(trait_method) {\n+            Some(f) => Some(*f),\n+            None => trait_method.default_method,\n+        }\n     }\n \n     /// This is internally used by `#[turbo_tasks::value_impl]`\n@@ -205,23 +212,44 @@ impl ValueType {\n }\n \n pub struct TraitMethod {\n-    pub default_method: Option<FunctionId>,\n-    pub arg_serializer: MagicAnySerializeSeed,\n-    pub arg_deserializer: MagicAnyDeserializeSeed,\n+    pub(crate) trait_name: &'static str,\n+    pub(crate) method_name: &'static str,\n+    pub(crate) default_method: Option<&'static NativeFunction>,\n+}\n+impl Hash for TraitMethod {\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        (self as *const TraitMethod).hash(state);\n+    }\n }\n \n+impl Eq for TraitMethod {}\n+\n+impl PartialEq for TraitMethod {\n+    fn eq(&self, other: &Self) -> bool {\n+        std::ptr::eq(self, other)\n+    }\n+}\n impl Debug for TraitMethod {\n     fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"TraitMethod\")\n+            .field(\"trait_name\", &self.trait_name)\n+            .field(\"name\", &self.method_name)\n             .field(\"default_method\", &self.default_method)\n             .finish()\n     }\n }\n-\n+impl TraitMethod {\n+    pub(crate) fn resolve_span(&self) -> Span {\n+        tracing::trace_span!(\n+            \"turbo_tasks::resolve_trait_call\",\n+            name = format_args!(\"{}::{}\", &self.trait_name, &self.method_name),\n+        )\n+    }\n+}\n #[derive(Debug)]\n pub struct TraitType {\n-    pub name: String,\n-    pub(crate) methods: AutoMap<Cow<'static, str>, TraitMethod>,\n+    pub name: &'static str,\n+    pub(crate) methods: AutoMap<&'static str, TraitMethod>,\n }\n \n impl Hash for TraitType {\n@@ -245,68 +273,44 @@ impl PartialEq for TraitType {\n }\n \n impl TraitType {\n-    pub fn new(name: String) -> Self {\n+    pub fn new(name: &'static str) -> Self {\n         Self {\n             name,\n             methods: AutoMap::new(),\n         }\n     }\n \n-    pub fn register_trait_method<T>(&mut self, name: Cow<'static, str>)\n-    where\n-        T: Serialize\n-            + for<'de> Deserialize<'de>\n-            + Debug\n-            + Eq\n-            + Hash\n-            + Send\n-            + Sync\n-            + TraceRawVcs\n-            + 'static,\n-    {\n+    pub fn register_trait_method(&mut self, name: &'static str) {\n         self.methods.insert(\n             name,\n             TraitMethod {\n+                trait_name: self.name,\n+                method_name: name,\n                 default_method: None,\n-                arg_serializer: MagicAnySerializeSeed::new::<T>(),\n-                arg_deserializer: MagicAnyDeserializeSeed::new::<T>(),\n             },\n         );\n     }\n \n-    pub fn register_default_trait_method<T>(\n+    pub fn register_default_trait_method(\n         &mut self,\n-        name: Cow<'static, str>,\n-        native_fn: FunctionId,\n-    ) where\n-        T: Serialize\n-            + for<'de> Deserialize<'de>\n-            + Debug\n-            + Eq\n-            + Hash\n-            + Send\n-            + Sync\n-            + TraceRawVcs\n-            + 'static,\n-    {\n+        name: &'static str,\n+        native_fn: &'static NativeFunction,\n+    ) {\n         self.methods.insert(\n             name,\n             TraitMethod {\n+                trait_name: self.name,\n+                method_name: name,\n                 default_method: Some(native_fn),\n-                arg_serializer: MagicAnySerializeSeed::new::<T>(),\n-                arg_deserializer: MagicAnyDeserializeSeed::new::<T>(),\n             },\n         );\n     }\n \n-    pub fn register(&'static self, global_name: &'static str) {\n-        register_trait_type(global_name, self);\n+    pub fn get(&self, name: &str) -> &TraitMethod {\n+        self.methods.get(name).unwrap()\n     }\n \n-    pub fn resolve_span(&'static self, name: &str) -> Span {\n-        tracing::trace_span!(\n-            \"turbo_tasks::resolve_trait_call\",\n-            name = format_args!(\"{}::{name}\", &self.name),\n-        )\n+    pub fn register(&'static self, global_name: &'static str) {\n+        register_trait_type(global_name, self);\n     }\n }"
        }
    ],
    "stats": {
        "total": 650,
        "additions": 275,
        "deletions": 375
    }
}