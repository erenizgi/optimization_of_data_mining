{
    "author": "mischnic",
    "message": "Turbopack: remove unused IncludeModulesModule (#76868)\n\nUsing this would break the module graph and chunking now anyway .",
    "sha": "c2d28fa7edb3213b897cca9ad16d53b0c7888024",
    "files": [
        {
            "sha": "bc73a830909128fd3c7e17b3a06a66e7dfb208cb",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 16,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/c2d28fa7edb3213b897cca9ad16d53b0c7888024/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c2d28fa7edb3213b897cca9ad16d53b0c7888024/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=c2d28fa7edb3213b897cca9ad16d53b0c7888024",
            "patch": "@@ -906,25 +906,12 @@ impl PageEndpoint {\n             } = *self.internal_ssr_chunk_module().await?;\n \n             let project = this.pages_project.project();\n+            // The SSR and Client Graphs are not connected in Pages Router.\n+            // We are only interested in get_next_dynamic_imports_for_endpoint at the\n+            // moment, which only needs the client graph anyway.\n             let module_graph = project.module_graph(*ssr_module, ChunkGroupType::Entry);\n \n             let next_dynamic_imports = if let PageEndpointType::Html = this.ty {\n-                // The SSR and Client Graphs are not connected in Pages Router.\n-                // We are only interested in get_next_dynamic_imports_for_endpoint at the\n-                // moment, which only needs the client graph anyway.\n-                //\n-                // If we do want to change this to have both included. We'd need to create a\n-                // `IncludeModulesModule` that includes both SSR and Client (and use that both\n-                // there and in Project::get_all_entries):\n-                // let client_module = self.client_module().to_resolved().await?;\n-                // let ssr_module = self.internal_ssr_chunk_module().await?.ssr_module;\n-                // Ok(Vc::upcast(IncludeModulesModule::new(\n-                //     self.source()\n-                //         .ident()\n-                //         .with_modifier(Vc::cell(\"unified entrypoint\".into())),\n-                //     vec![*client_module, *ssr_module],\n-                // )))\n-\n                 let client_availability_info = self.client_chunks().await?.availability_info;\n \n                 let client_module_graph = self.client_module_graph();"
        },
        {
            "sha": "4c35279dfd8fb78f68e89daa0a28f091eb9bb943",
            "filename": "crates/next-core/src/next_app/include_modules_module.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 170,
            "changes": 170,
            "blob_url": "https://github.com/vercel/next.js/blob/ec2ca8b671c33fe616af656f582059feaf5d0c27/crates%2Fnext-core%2Fsrc%2Fnext_app%2Finclude_modules_module.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ec2ca8b671c33fe616af656f582059feaf5d0c27/crates%2Fnext-core%2Fsrc%2Fnext_app%2Finclude_modules_module.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Finclude_modules_module.rs?ref=ec2ca8b671c33fe616af656f582059feaf5d0c27",
            "patch": "@@ -1,170 +0,0 @@\n-use anyhow::Result;\n-use turbo_rcstr::RcStr;\n-use turbo_tasks::{ResolvedVc, TryJoinIterExt, ValueToString, Vc};\n-use turbo_tasks_fs::glob::Glob;\n-use turbopack_core::{\n-    asset::{Asset, AssetContent},\n-    chunk::{ChunkItem, ChunkType, ChunkableModule, ChunkableModuleReference, ChunkingContext},\n-    ident::AssetIdent,\n-    module::Module,\n-    module_graph::ModuleGraph,\n-    reference::{ModuleReference, ModuleReferences},\n-    resolve::ModuleResolveResult,\n-};\n-use turbopack_ecmascript::chunk::{\n-    EcmascriptChunkItem, EcmascriptChunkItemContent, EcmascriptChunkPlaceable, EcmascriptChunkType,\n-    EcmascriptExports,\n-};\n-\n-/// A virtual module that references other modules, but doesn't do anything at\n-/// runtime. It can be used to include modules into a chunk.\n-#[turbo_tasks::value]\n-pub struct IncludeModulesModule {\n-    ident: ResolvedVc<AssetIdent>,\n-    modules: Vec<ResolvedVc<Box<dyn Module>>>,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl IncludeModulesModule {\n-    #[turbo_tasks::function]\n-    pub fn new(\n-        ident: ResolvedVc<AssetIdent>,\n-        modules: Vec<ResolvedVc<Box<dyn Module>>>,\n-    ) -> Vc<Self> {\n-        Self { ident, modules }.cell()\n-    }\n-}\n-\n-impl Asset for IncludeModulesModule {\n-    fn content(self: Vc<Self>) -> Vc<AssetContent> {\n-        todo!(\"IncludeModulesModule doesn't implement content()\")\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl Module for IncludeModulesModule {\n-    #[turbo_tasks::function]\n-    fn ident(&self) -> Vc<AssetIdent> {\n-        *self.ident\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn references(&self) -> Result<Vc<ModuleReferences>> {\n-        Ok(Vc::cell(\n-            self.modules\n-                .iter()\n-                .map(|&module| async move {\n-                    Ok(ResolvedVc::upcast(\n-                        IncludedModuleReference::new(*module).to_resolved().await?,\n-                    ))\n-                })\n-                .try_join()\n-                .await?,\n-        ))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl EcmascriptChunkPlaceable for IncludeModulesModule {\n-    #[turbo_tasks::function]\n-    fn get_exports(self: Vc<Self>) -> Vc<EcmascriptExports> {\n-        EcmascriptExports::None.cell()\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn is_marked_as_side_effect_free(self: Vc<Self>, _: Vc<Glob>) -> Vc<bool> {\n-        Vc::cell(true)\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ChunkableModule for IncludeModulesModule {\n-    #[turbo_tasks::function]\n-    fn as_chunk_item(\n-        self: ResolvedVc<Self>,\n-        _module_graph: Vc<ModuleGraph>,\n-        chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    ) -> Vc<Box<dyn ChunkItem>> {\n-        Vc::upcast(\n-            IncludeModulesChunkItem {\n-                module: self,\n-                chunking_context,\n-            }\n-            .cell(),\n-        )\n-    }\n-}\n-\n-/// The chunk item for [`IncludeModulesModule`].\n-#[turbo_tasks::value]\n-struct IncludeModulesChunkItem {\n-    module: ResolvedVc<IncludeModulesModule>,\n-    chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ChunkItem for IncludeModulesChunkItem {\n-    #[turbo_tasks::function]\n-    fn chunking_context(&self) -> Vc<Box<dyn ChunkingContext>> {\n-        Vc::upcast(*self.chunking_context)\n-    }\n-    #[turbo_tasks::function]\n-    fn asset_ident(&self) -> Vc<AssetIdent> {\n-        self.module.ident()\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn ty(&self) -> Vc<Box<dyn ChunkType>> {\n-        Vc::upcast(Vc::<EcmascriptChunkType>::default())\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn module(&self) -> Vc<Box<dyn Module>> {\n-        Vc::upcast(*self.module)\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl EcmascriptChunkItem for IncludeModulesChunkItem {\n-    #[turbo_tasks::function]\n-    fn content(&self) -> Vc<EcmascriptChunkItemContent> {\n-        EcmascriptChunkItemContent {\n-            ..Default::default()\n-        }\n-        .cell()\n-    }\n-}\n-\n-/// A module reference that references a module that is references from the\n-/// [`IncludeModulesModule`].\n-#[turbo_tasks::value]\n-pub struct IncludedModuleReference {\n-    pub module: ResolvedVc<Box<dyn Module>>,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl IncludedModuleReference {\n-    #[turbo_tasks::function]\n-    pub fn new(module: ResolvedVc<Box<dyn Module>>) -> Vc<Self> {\n-        IncludedModuleReference { module }.cell()\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ValueToString for IncludedModuleReference {\n-    #[turbo_tasks::function]\n-    fn to_string(&self) -> Vc<RcStr> {\n-        Vc::cell(\"module\".into())\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ModuleReference for IncludedModuleReference {\n-    #[turbo_tasks::function]\n-    fn resolve_reference(&self) -> Vc<ModuleResolveResult> {\n-        *ModuleResolveResult::module(self.module)\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ChunkableModuleReference for IncludedModuleReference {}"
        },
        {
            "sha": "8fb20595e07b0b1da52debcb3133752c2c4cdbd2",
            "filename": "crates/next-core/src/next_app/mod.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/c2d28fa7edb3213b897cca9ad16d53b0c7888024/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c2d28fa7edb3213b897cca9ad16d53b0c7888024/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmod.rs?ref=c2d28fa7edb3213b897cca9ad16d53b0c7888024",
            "patch": "@@ -3,7 +3,6 @@ pub mod app_client_shared_chunks;\n pub mod app_entry;\n pub mod app_page_entry;\n pub mod app_route_entry;\n-pub mod include_modules_module;\n pub mod metadata;\n \n use std::{"
        }
    ],
    "stats": {
        "total": 190,
        "additions": 3,
        "deletions": 187
    }
}