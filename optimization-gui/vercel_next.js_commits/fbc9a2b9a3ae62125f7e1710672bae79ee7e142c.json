{
    "author": "lubieowoce",
    "message": "[Cache Components] Atomic setTimeouts (#86093)\n\nThis PR exploits some Node internals to make sure that, if we schedule\nsome timeouts back to back to perform staged rendering, they'll actually\nrun in the same iteration of the event loop.\n\nIf we cannot patch the timeouts correctly (due to runtime differences in\ne.g. Bun, or changes in future node versions), we'll warn that Cache\nComponents may not function correctly, and run the timers normally.\ntimer/immediate interleaving is rare in practice, and we'll usually be\nfine even without this patch, so it's better to warn and try to carry on\nrather than to error out.\n\n(h/t to @sokra for finding this trick)",
    "sha": "fbc9a2b9a3ae62125f7e1710672bae79ee7e142c",
    "files": [
        {
            "sha": "aee5a1d98deb78b5058ff4fee2fc542701016bc3",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/fbc9a2b9a3ae62125f7e1710672bae79ee7e142c/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/fbc9a2b9a3ae62125f7e1710672bae79ee7e142c/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=fbc9a2b9a3ae62125f7e1710672bae79ee7e142c",
            "patch": "@@ -930,5 +930,8 @@\n   \"929\": \"No pages or app directory found.\",\n   \"930\": \"Expected a dynamic route, but got a static route: %s\",\n   \"931\": \"Unexpected empty path segments match for a route \\\"%s\\\" with param \\\"%s\\\" of type \\\"%s\\\"\",\n-  \"932\": \"Could not resolve param value for segment: %s\"\n+  \"932\": \"Could not resolve param value for segment: %s\",\n+  \"933\": \"An unexpected error occurred while adjusting `_idleStart` on an atomic timer\",\n+  \"934\": \"createAtomicTimerGroup cannot be called in the edge runtime\",\n+  \"935\": \"Cannot schedule more timers into a group that already executed\"\n }"
        },
        {
            "sha": "a95883c2489b42f73e1f88573930c7b6272bb486",
            "filename": "packages/next/src/server/app-render/app-render-prerender-utils.ts",
            "status": "modified",
            "additions": 18,
            "deletions": 10,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/fbc9a2b9a3ae62125f7e1710672bae79ee7e142c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fbc9a2b9a3ae62125f7e1710672bae79ee7e142c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts?ref=fbc9a2b9a3ae62125f7e1710672bae79ee7e142c",
            "patch": "@@ -1,4 +1,5 @@\n import { InvariantError } from '../../shared/lib/invariant-error'\n+import { createAtomicTimerGroup } from './app-render-scheduling'\n \n /**\n  * This is a utility function to make scheduling sequential tasks that run back to back easier.\n@@ -14,19 +15,22 @@ export function prerenderAndAbortInSequentialTasks<R>(\n     )\n   } else {\n     return new Promise((resolve, reject) => {\n+      const scheduleTimeout = createAtomicTimerGroup()\n+\n       let pendingResult: Promise<R>\n-      setTimeout(() => {\n+      scheduleTimeout(() => {\n         try {\n           pendingResult = prerender()\n           pendingResult.catch(() => {})\n         } catch (err) {\n           reject(err)\n         }\n-      }, 0)\n-      setTimeout(() => {\n+      })\n+\n+      scheduleTimeout(() => {\n         abort()\n         resolve(pendingResult)\n-      }, 0)\n+      })\n     })\n   }\n }\n@@ -46,22 +50,26 @@ export function prerenderAndAbortInSequentialTasksWithStages<R>(\n     )\n   } else {\n     return new Promise((resolve, reject) => {\n+      const scheduleTimeout = createAtomicTimerGroup()\n+\n       let pendingResult: Promise<R>\n-      setTimeout(() => {\n+      scheduleTimeout(() => {\n         try {\n           pendingResult = prerender()\n           pendingResult.catch(() => {})\n         } catch (err) {\n           reject(err)\n         }\n-      }, 0)\n-      setTimeout(() => {\n+      })\n+\n+      scheduleTimeout(() => {\n         advanceStage()\n-      }, 0)\n-      setTimeout(() => {\n+      })\n+\n+      scheduleTimeout(() => {\n         abort()\n         resolve(pendingResult)\n-      }, 0)\n+      })\n     })\n   }\n }"
        },
        {
            "sha": "470aa680c5c1c89e9214e0ee4e450a2ee8959d6d",
            "filename": "packages/next/src/server/app-render/app-render-render-utils.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 10,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/fbc9a2b9a3ae62125f7e1710672bae79ee7e142c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-render-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fbc9a2b9a3ae62125f7e1710672bae79ee7e142c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-render-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-render-utils.ts?ref=fbc9a2b9a3ae62125f7e1710672bae79ee7e142c",
            "patch": "@@ -1,4 +1,5 @@\n import { InvariantError } from '../../shared/lib/invariant-error'\n+import { createAtomicTimerGroup } from './app-render-scheduling'\n \n /**\n  * This is a utility function to make scheduling sequential tasks that run back to back easier.\n@@ -14,18 +15,21 @@ export function scheduleInSequentialTasks<R>(\n     )\n   } else {\n     return new Promise((resolve, reject) => {\n+      const scheduleTimeout = createAtomicTimerGroup()\n+\n       let pendingResult: R | Promise<R>\n-      setTimeout(() => {\n+      scheduleTimeout(() => {\n         try {\n           pendingResult = render()\n         } catch (err) {\n           reject(err)\n         }\n-      }, 0)\n-      setTimeout(() => {\n+      })\n+\n+      scheduleTimeout(() => {\n         followup()\n         resolve(pendingResult)\n-      }, 0)\n+      })\n     })\n   }\n }\n@@ -46,19 +50,21 @@ export function pipelineInSequentialTasks<A, B, C>(\n     )\n   } else {\n     return new Promise((resolve, reject) => {\n+      const scheduleTimeout = createAtomicTimerGroup()\n+\n       let oneResult: A | undefined = undefined\n-      setTimeout(() => {\n+      scheduleTimeout(() => {\n         try {\n           oneResult = one()\n         } catch (err) {\n           clearTimeout(twoId)\n           clearTimeout(threeId)\n           reject(err)\n         }\n-      }, 0)\n+      })\n \n       let twoResult: B | undefined = undefined\n-      const twoId = setTimeout(() => {\n+      const twoId = scheduleTimeout(() => {\n         // if `one` threw, then this timeout would've been cleared,\n         // so if we got here, we're guaranteed to have a value.\n         try {\n@@ -67,17 +73,17 @@ export function pipelineInSequentialTasks<A, B, C>(\n           clearTimeout(threeId)\n           reject(err)\n         }\n-      }, 0)\n+      })\n \n-      const threeId = setTimeout(() => {\n+      const threeId = scheduleTimeout(() => {\n         // if `two` threw, then this timeout would've been cleared,\n         // so if we got here, we're guaranteed to have a value.\n         try {\n           resolve(three(twoResult!))\n         } catch (err) {\n           reject(err)\n         }\n-      }, 0)\n+      })\n     })\n   }\n }"
        },
        {
            "sha": "be6c54f1135dda0cdaf2f7004505169a91458290",
            "filename": "packages/next/src/server/app-render/app-render-scheduling.ts",
            "status": "added",
            "additions": 192,
            "deletions": 0,
            "changes": 192,
            "blob_url": "https://github.com/vercel/next.js/blob/fbc9a2b9a3ae62125f7e1710672bae79ee7e142c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-scheduling.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/fbc9a2b9a3ae62125f7e1710672bae79ee7e142c/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-scheduling.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-scheduling.ts?ref=fbc9a2b9a3ae62125f7e1710672bae79ee7e142c",
            "patch": "@@ -0,0 +1,192 @@\n+import { InvariantError } from '../../shared/lib/invariant-error'\n+\n+/*\n+==========================\n+| Background             |\n+==========================\n+\n+Node.js does not guarantee that two timers scheduled back to back will run\n+on the same iteration of the event loop:\n+\n+```ts\n+setTimeout(one, 0)\n+setTimeout(two, 0)\n+```\n+\n+Internally, each timer is assigned a `_idleStart` property that holds\n+an internal libuv timestamp in millisecond resolution.\n+This will be used to determine if the timer is already \"expired\" and should be executed.\n+However, even in sync code, it's possible for two timers to get different `_idleStart` values.\n+This can cause one of the timers to be executed, and the other to be delayed until the next timer phase.\n+\n+The delaying happens [here](https://github.com/nodejs/node/blob/c208ffc66bb9418ff026c4e3fa82e5b4387bd147/lib/internal/timers.js#L556-L564).\n+and can be debugged by running node with `NODE_DEBUG=timer`.\n+\n+The easiest way to observe it is to run this program in a loop until it exits with status 1:\n+\n+```\n+// test.js\n+\n+let immediateRan = false\n+const t1 = setTimeout(() => {\n+  console.log('timeout 1')\n+  setImmediate(() => {\n+    console.log('immediate 1')\n+    immediateRan = true\n+  })\n+})\n+\n+const t2 = setTimeout(() => {\n+  console.log('timeout 2')\n+  if (immediateRan) {\n+    console.log('immediate ran before the second timeout!')\n+    console.log(\n+      `t1._idleStart: ${t1._idleStart}, t2_idleStart: ${t2._idleStart}`\n+    );\n+    process.exit(1)\n+  }\n+})\n+```\n+\n+```bash\n+#!/usr/bin/env bash\n+\n+i=1;\n+while true; do\n+  output=\"$(NODE_DEBUG=timer node test.js 2>&1)\";\n+  if [ \"$?\" -eq 1 ]; then\n+    echo \"failed after $i iterations\";\n+    echo \"$output\";\n+    break;\n+  fi;\n+  i=$((i+1));\n+done\n+```\n+\n+If `t2` is deferred to the next iteration of the event loop,\n+then the immediate scheduled from inside `t1` will run first.\n+When this occurs, `_idleStart` is reliably different between `t1` and `t2`.\n+\n+==========================\n+| Solution               |\n+==========================\n+\n+We can guarantee that multiple timers (with the same delay, usually `0`)\n+run together without any delays by making sure that their `_idleStart`s are the same,\n+because that's what's used to determine if a timer should be deferred or not.\n+Luckily, this property is currently exposed to userland and mutable,\n+so we can patch it.\n+\n+Another related trick we could potentially apply is making\n+a timer immediately be considered expired by doing  `timer._idleStart -= 2`.\n+(the value must be more than `1`, the delay that actually gets set for `setTimeout(cb, 0)`).\n+This makes node view this timer as \"a 1ms timer scheduled 2ms ago\",\n+meaning that it should definitely run in the next timer phase.\n+However, I'm not confident we know all the side effects of doing this,\n+so for now, simply ensuring coordination is enough.\n+*/\n+\n+let shouldAttemptPatching = true\n+\n+function warnAboutTimers() {\n+  console.warn(\n+    \"Next.js cannot guarantee that Cache Components will run as expected due to the current runtime's implementation of `setTimeout()`.\\nPlease report a github issue here: https://github.com/vercel/next.js/issues/new/\"\n+  )\n+}\n+\n+/**\n+ * Allows scheduling multiple timers (equivalent to `setTimeout(cb, delayMs)`)\n+ * that are guaranteed to run in the same iteration of the event loop.\n+ *\n+ * @param delayMs - the delay to pass to `setTimeout`. (default: 0)\n+ *\n+ * */\n+export function createAtomicTimerGroup(delayMs = 0) {\n+  if (process.env.NEXT_RUNTIME === 'edge') {\n+    throw new InvariantError(\n+      'createAtomicTimerGroup cannot be called in the edge runtime'\n+    )\n+  } else {\n+    let isFirstCallback = true\n+    let firstTimerIdleStart: number | null = null\n+    let didFirstTimerRun = false\n+\n+    // As a sanity check, we schedule an immediate from the first timeout\n+    // to check if the execution was interrupted.\n+    let didImmediateRun = false\n+    function runFirstCallback(callback: () => void) {\n+      didFirstTimerRun = true\n+      if (shouldAttemptPatching) {\n+        setImmediate(() => {\n+          didImmediateRun = true\n+        })\n+      }\n+      return callback()\n+    }\n+\n+    function runSubsequentCallback(callback: () => void) {\n+      if (shouldAttemptPatching) {\n+        if (didImmediateRun) {\n+          // If the immediate managed to run between the timers, then we're not\n+          // able to provide the guarantees that we're supposed to\n+          shouldAttemptPatching = false\n+          warnAboutTimers()\n+        }\n+      }\n+      return callback()\n+    }\n+\n+    return function scheduleTimeout(callback: () => void) {\n+      if (didFirstTimerRun) {\n+        throw new InvariantError(\n+          'Cannot schedule more timers into a group that already executed'\n+        )\n+      }\n+\n+      const timer = setTimeout(\n+        isFirstCallback ? runFirstCallback : runSubsequentCallback,\n+        delayMs,\n+        callback\n+      )\n+      isFirstCallback = false\n+\n+      if (!shouldAttemptPatching) {\n+        // We already tried patching some timers, and it didn't work.\n+        // No point trying again.\n+        return timer\n+      }\n+\n+      // NodeJS timers have a `_idleStart` property, but it doesn't exist e.g. in Bun.\n+      // If it's not present, we'll warn and try to continue.\n+      try {\n+        if ('_idleStart' in timer && typeof timer._idleStart === 'number') {\n+          // If this is the first timer that was scheduled, save its `_idleStart`.\n+          // We'll copy it onto subsequent timers to guarantee that they'll all be\n+          // considered expired in the same iteration of the event loop\n+          // and thus will all be executed in the same timer phase.\n+          if (firstTimerIdleStart === null) {\n+            firstTimerIdleStart = timer._idleStart\n+          } else {\n+            timer._idleStart = firstTimerIdleStart\n+          }\n+        } else {\n+          shouldAttemptPatching = false\n+          warnAboutTimers()\n+        }\n+      } catch (err) {\n+        // This should never fail in current Node, but it might start failing in the future.\n+        // We might be okay even without tweaking the timers, so warn and try to continue.\n+        console.error(\n+          new InvariantError(\n+            'An unexpected error occurred while adjusting `_idleStart` on an atomic timer',\n+            { cause: err }\n+          )\n+        )\n+        shouldAttemptPatching = false\n+        warnAboutTimers()\n+      }\n+\n+      return timer\n+    }\n+  }\n+}"
        }
    ],
    "stats": {
        "total": 251,
        "additions": 230,
        "deletions": 21
    }
}