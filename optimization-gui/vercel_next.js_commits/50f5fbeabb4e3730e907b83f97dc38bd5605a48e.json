{
    "author": "sokra",
    "message": "Turbopack: add a batch add method to the storage (#84270)\n\n### What?\n\nMakes adding multiple items at once more efficient.",
    "sha": "50f5fbeabb4e3730e907b83f97dc38bd5605a48e",
    "files": [
        {
            "sha": "7be7f8a259e7f9d3168b8f0a0c52d5b6bb92dd9f",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/dynamic_storage.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/50f5fbeabb4e3730e907b83f97dc38bd5605a48e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fdynamic_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/50f5fbeabb4e3730e907b83f97dc38bd5605a48e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fdynamic_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fdynamic_storage.rs?ref=50f5fbeabb4e3730e907b83f97dc38bd5605a48e",
            "patch": "@@ -58,6 +58,19 @@ impl DynamicStorage {\n         self.get_or_create_map_mut(ty).add(item)\n     }\n \n+    pub fn extend(\n+        &mut self,\n+        ty: CachedDataItemType,\n+        item: impl Iterator<Item = CachedDataItem>,\n+    ) -> bool {\n+        let map = self.get_or_create_map_mut(ty);\n+        let mut added = true;\n+        for item in item {\n+            added = map.add(item) && added;\n+        }\n+        added\n+    }\n+\n     pub fn insert(&mut self, item: CachedDataItem) -> Option<CachedDataItemValue> {\n         let ty = item.ty();\n         self.get_or_create_map_mut(ty).insert(item)"
        },
        {
            "sha": "cd924b85d127c2439718cae72f01685df5354489",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 57,
            "deletions": 2,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/50f5fbeabb4e3730e907b83f97dc38bd5605a48e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/50f5fbeabb4e3730e907b83f97dc38bd5605a48e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=50f5fbeabb4e3730e907b83f97dc38bd5605a48e",
            "patch": "@@ -364,9 +364,26 @@ impl<'e, B: BackingStorage> ChildExecuteContext<'e> for ChildExecuteContextImpl<\n \n pub trait TaskGuard: Debug {\n     fn id(&self) -> TaskId;\n+    /// Adds a new item to the task if the key is not already present.\n+    /// Returns `true` if the item was added.\n+    /// Returns `false` if an item with the same key was already present.\n     #[must_use]\n     fn add(&mut self, item: CachedDataItem) -> bool;\n+    /// Adds a new item to the task. The key must not be already present.\n+    /// Might panic if the key is already present.\n     fn add_new(&mut self, item: CachedDataItem);\n+    /// Extends the task with items from the iterator.\n+    /// Overwrites existing keys.\n+    /// Returns `true` if all items were new and added.\n+    /// Returns `false` if any item had a key that was already present.\n+    fn extend(\n+        &mut self,\n+        ty: CachedDataItemType,\n+        items: impl Iterator<Item = CachedDataItem>,\n+    ) -> bool;\n+    /// Extends the task with items from the iterator.\n+    /// Might panic if any item has a key that is already present.\n+    fn extend_new(&mut self, ty: CachedDataItemType, items: impl Iterator<Item = CachedDataItem>);\n     fn insert(&mut self, item: CachedDataItem) -> Option<CachedDataItemValue>;\n     fn update(\n         &mut self,\n@@ -489,11 +506,49 @@ impl<B: BackingStorage> TaskGuard for TaskGuardImpl<'_, B> {\n \n     #[track_caller]\n     fn add_new(&mut self, item: CachedDataItem) {\n-        self.check_access(item.category());\n-        let added = self.add(item);\n+        let category = item.category();\n+        self.check_access(category);\n+        if !self.task_id.is_transient() && item.is_persistent() {\n+            self.task.track_modification(category.into_specific());\n+        }\n+        let added = self.task.add(item);\n         assert!(added, \"Item already exists\");\n     }\n \n+    #[track_caller]\n+    fn extend(\n+        &mut self,\n+        ty: CachedDataItemType,\n+        items: impl Iterator<Item = CachedDataItem>,\n+    ) -> bool {\n+        let category = ty.category();\n+        self.check_access(category);\n+        if !self.task_id.is_transient() && ty.is_persistent() {\n+            let mut items = items.peekable();\n+            // Check if the iterator is empty\n+            if items.peek().is_none() {\n+                return true;\n+            }\n+            // TODO this is not optimal as we always track a modification even if nothing is changed\n+            self.task.track_modification(category.into_specific());\n+            self.task.extend(ty, items)\n+        } else {\n+            self.task.extend(ty, items)\n+        }\n+    }\n+\n+    #[track_caller]\n+    fn extend_new(&mut self, ty: CachedDataItemType, items: impl Iterator<Item = CachedDataItem>) {\n+        let category = ty.category();\n+        self.check_access(category);\n+        if !self.task_id.is_transient() && ty.is_persistent() {\n+            self.task.track_modification(category.into_specific());\n+        }\n+\n+        let added = self.task.extend(ty, items);\n+        assert!(added, \"At least one item already exists\");\n+    }\n+\n     #[track_caller]\n     fn insert(&mut self, item: CachedDataItem) -> Option<CachedDataItemValue> {\n         let category = item.category();"
        },
        {
            "sha": "aeb0e076ad621b4bdbd711ee629f006322c8d4af",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/storage.rs",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/50f5fbeabb4e3730e907b83f97dc38bd5605a48e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/50f5fbeabb4e3730e907b83f97dc38bd5605a48e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs?ref=50f5fbeabb4e3730e907b83f97dc38bd5605a48e",
            "patch": "@@ -317,6 +317,36 @@ macro_rules! generate_inner_storage_internal {\n         $crate::generate_inner_storage_internal!(update: $self, $key, $update: $($config)+)\n     };\n \n+    // fn extend\n+    (extend: $self:ident, $ty:ident, $items:ident: $tag:ident $key_field:ident => $field:ident,) => {\n+        if let CachedDataItemType::$tag = $ty {\n+            return $self.$field.extend($items.map(|item| {\n+                let pair = turbo_tasks::KeyValuePair::into_key_and_value(item);\n+                if let (CachedDataItemKey::$tag { $key_field }, CachedDataItemValue::$tag { value }) = pair {\n+                    ($key_field, value)\n+                } else {\n+                    unreachable!()\n+                }\n+            }));\n+        }\n+    };\n+    (extend: $self:ident, $ty:ident, $items:ident: $tag:ident => $field:ident,) => {\n+        if let CachedDataItemType::$tag = $ty {\n+            return $self.$field.extend($items.map(|item| {\n+                let pair = turbo_tasks::KeyValuePair::into_key_and_value(item);\n+                if let (_, CachedDataItemValue::$tag { value }) = pair {\n+                    ((), value)\n+                } else {\n+                    unreachable!()\n+                }\n+            }));\n+        }\n+    };\n+    (extend: $self:ident, $ty:ident, $items:ident: $tag:ident $($key_field:ident)? => $field:ident, $($config:tt)+) => {\n+        $crate::generate_inner_storage_internal!(extend: $self, $ty, $items: $tag $($key_field)? => $field,);\n+        $crate::generate_inner_storage_internal!(extend: $self, $ty, $items: $($config)+)\n+    };\n+\n     // fn get_mut_or_insert_with\n     (get_mut_or_insert_with: $self:ident, $key:ident, $insert_with:ident: $tag:ident $key_field:ident => $field:ident,) => {\n         if let CachedDataItemKey::$tag { $key_field } = $key {\n@@ -426,6 +456,12 @@ macro_rules! generate_inner_storage {\n                 self.dynamic.add(item)\n             }\n \n+            pub fn extend(&mut self, ty: CachedDataItemType, items: impl Iterator<Item = CachedDataItem>) -> bool {\n+                use crate::data_storage::Storage;\n+                $crate::generate_inner_storage_internal!(extend: self, ty, items: $($config)*);\n+                self.dynamic.extend(ty, items)\n+            }\n+\n             pub fn insert(&mut self, item: CachedDataItem) -> Option<CachedDataItemValue> {\n                 use crate::data_storage::Storage;\n                 $crate::generate_inner_storage_internal!(CachedDataItem: self, item, value, option_value, insert(value): $($config)*);"
        },
        {
            "sha": "52f3e7c701e3e32cd698207057b117109fe01b5a",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data_storage.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 0,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/50f5fbeabb4e3730e907b83f97dc38bd5605a48e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/50f5fbeabb4e3730e907b83f97dc38bd5605a48e/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata_storage.rs?ref=50f5fbeabb4e3730e907b83f97dc38bd5605a48e",
            "patch": "@@ -10,7 +10,15 @@ pub trait Storage {\n     where\n         Self: 'l;\n \n+    /// Adds a key-value pair to the storage, if the key is not already present.\n+    /// Returns `true` if the key was not present and the value was added.\n+    /// Returns `false` if the key was already present.\n     fn add(&mut self, key: Self::K, value: Self::V) -> bool;\n+    /// Extends the storage with key-value pairs from the iterator.\n+    /// Overwrites existing keys.\n+    /// Returns `true` if all keys were new and added.\n+    /// Returns `false` if any key was already present.\n+    fn extend(&mut self, items: impl Iterator<Item = (Self::K, Self::V)>) -> bool;\n     fn insert(&mut self, key: Self::K, value: Self::V) -> Option<Self::V>;\n     fn remove(&mut self, key: &Self::K) -> Option<Self::V>;\n     fn contains_key(&self, key: &Self::K) -> bool;\n@@ -60,6 +68,14 @@ impl<V> Storage for OptionStorage<V> {\n         }\n     }\n \n+    fn extend(&mut self, items: impl Iterator<Item = (Self::K, Self::V)>) -> bool {\n+        let mut added = true;\n+        for (_, value) in items {\n+            added = self.insert((), value).is_none() && added;\n+        }\n+        added\n+    }\n+\n     fn insert(&mut self, _: (), value: V) -> Option<V> {\n         self.value.replace(value)\n     }\n@@ -148,6 +164,13 @@ impl<K: Hash + Eq, V> Storage for AutoMapStorage<K, V> {\n         }\n     }\n \n+    fn extend(&mut self, items: impl Iterator<Item = (Self::K, Self::V)>) -> bool {\n+        let len = self.map.len();\n+        let mut count = 0;\n+        self.map.extend(items.inspect(|_| count += 1));\n+        self.map.len() == len + count\n+    }\n+\n     fn insert(&mut self, key: K, value: V) -> Option<V> {\n         self.map.insert(key, value)\n     }"
        }
    ],
    "stats": {
        "total": 131,
        "additions": 129,
        "deletions": 2
    }
}