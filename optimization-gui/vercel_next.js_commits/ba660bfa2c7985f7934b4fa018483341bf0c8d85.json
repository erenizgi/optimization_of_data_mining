{
    "author": "lukesandberg",
    "message": "Remove uses of `read_glob` from `node_native_bindings` (#79154)\n\nRemove two calls to `read_glob` that could be trivially satisfied by `read_dir`.  This makes it clearer that the reads are shallow and avoids allocating extra maps and `globs` (smaller vc-cell keys, etc)",
    "sha": "ba660bfa2c7985f7934b4fa018483341bf0c8d85",
    "files": [
        {
            "sha": "d549b6a1ea2807556c3e2df71de9fc613d1291e3",
            "filename": "turbopack/crates/turbopack-core/src/target.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/ba660bfa2c7985f7934b4fa018483341bf0c8d85/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Ftarget.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ba660bfa2c7985f7934b4fa018483341bf0c8d85/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Ftarget.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Ftarget.rs?ref=ba660bfa2c7985f7934b4fa018483341bf0c8d85",
            "patch": "@@ -60,12 +60,13 @@ impl CompileTarget {\n         }\n     }\n \n+    /// Returns the expected extension of the dynamic library, including the `.`.\n     pub fn dylib_ext(&self) -> &'static str {\n         let platform = self.platform;\n         match platform {\n-            Platform::Win32 => \"dll\",\n-            Platform::Darwin => \"dylib\",\n-            _ => \"so\",\n+            Platform::Win32 => \".dll\",\n+            Platform::Darwin => \".dylib\",\n+            _ => \".so\",\n         }\n     }\n "
        },
        {
            "sha": "f81a6963dd2fafae86ae26ed8ef30c6ce8062658",
            "filename": "turbopack/crates/turbopack-resolve/src/node_native_binding.rs",
            "status": "modified",
            "additions": 34,
            "deletions": 35,
            "changes": 69,
            "blob_url": "https://github.com/vercel/next.js/blob/ba660bfa2c7985f7934b4fa018483341bf0c8d85/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ba660bfa2c7985f7934b4fa018483341bf0c8d85/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-resolve%2Fsrc%2Fnode_native_binding.rs?ref=ba660bfa2c7985f7934b4fa018483341bf0c8d85",
            "patch": "@@ -5,7 +5,7 @@ use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{FxIndexMap, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, ValueToString, Vc};\n use turbo_tasks_fs::{\n-    DirectoryEntry, FileContent, FileSystemEntryType, FileSystemPath, glob::Glob,\n+    DirectoryContent, DirectoryEntry, FileContent, FileSystemEntryType, FileSystemPath,\n     json::parse_json_rope_with_source_context,\n };\n use turbopack_core::{\n@@ -132,23 +132,22 @@ pub async fn resolve_node_pre_gyp_files(\n                         )\n                         .into();\n \n-                    for (key, entry) in config_file_dir\n+                    // Find all dynamic libraries in the given directory.\n+                    if let DirectoryContent::Entries(entries) = &*config_file_dir\n                         .join(native_binding_path.clone())\n-                        .read_glob(\n-                            Glob::new(format!(\"*.{}\", compile_target.dylib_ext()).into()),\n-                            false,\n-                        )\n+                        .read_dir()\n                         .await?\n-                        .results\n-                        .iter()\n                     {\n-                        if let &DirectoryEntry::File(dylib) | &DirectoryEntry::Symlink(dylib) =\n-                            entry\n-                        {\n-                            sources.insert(\n-                                format!(\"{native_binding_path}/{key}\").into(),\n-                                Vc::upcast(FileSource::new(*dylib)),\n-                            );\n+                        let extension = compile_target.dylib_ext();\n+                        for (key, entry) in entries.iter().filter(|(k, _)| k.ends_with(extension)) {\n+                            if let &DirectoryEntry::File(dylib) | &DirectoryEntry::Symlink(dylib) =\n+                                entry\n+                            {\n+                                sources.insert(\n+                                    format!(\"{native_binding_path}/{key}\").into(),\n+                                    Vc::upcast(FileSource::new(*dylib)),\n+                                );\n+                            }\n                         }\n                     }\n \n@@ -165,33 +164,33 @@ pub async fn resolve_node_pre_gyp_files(\n                         );\n                     }\n                 }\n-                for (key, entry) in config_file_dir\n+                if let DirectoryContent::Entries(entries) = &*config_file_dir\n                     // TODO\n                     // read the dependencies path from `bindings.gyp`\n                     .join(\"deps/lib\".into())\n-                    .read_glob(Glob::new(\"*\".into()), false)\n+                    .read_dir()\n                     .await?\n-                    .results\n-                    .iter()\n                 {\n-                    match *entry {\n-                        DirectoryEntry::File(dylib) => {\n-                            sources.insert(\n-                                format!(\"deps/lib/{key}\").into(),\n-                                Vc::upcast(FileSource::new(*dylib)),\n-                            );\n-                        }\n-                        DirectoryEntry::Symlink(dylib) => {\n-                            let realpath_with_links = dylib.realpath_with_links().await?;\n-                            for &symlink in realpath_with_links.symlinks.iter() {\n-                                affecting_paths.push(*symlink);\n+                    for (key, entry) in entries.iter() {\n+                        match *entry {\n+                            DirectoryEntry::File(dylib) => {\n+                                sources.insert(\n+                                    format!(\"deps/lib/{key}\").into(),\n+                                    Vc::upcast(FileSource::new(*dylib)),\n+                                );\n+                            }\n+                            DirectoryEntry::Symlink(dylib) => {\n+                                let realpath_with_links = dylib.realpath_with_links().await?;\n+                                for &symlink in realpath_with_links.symlinks.iter() {\n+                                    affecting_paths.push(*symlink);\n+                                }\n+                                sources.insert(\n+                                    format!(\"deps/lib/{key}\").into(),\n+                                    Vc::upcast(FileSource::new(*realpath_with_links.path)),\n+                                );\n                             }\n-                            sources.insert(\n-                                format!(\"deps/lib/{key}\").into(),\n-                                Vc::upcast(FileSource::new(*realpath_with_links.path)),\n-                            );\n+                            _ => {}\n                         }\n-                        _ => {}\n                     }\n                 }\n                 return Ok(*ModuleResolveResult::modules_with_affecting_sources("
        }
    ],
    "stats": {
        "total": 76,
        "additions": 38,
        "deletions": 38
    }
}