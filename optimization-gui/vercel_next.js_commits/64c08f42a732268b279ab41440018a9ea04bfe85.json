{
    "author": "xusd320",
    "message": "feat(turbo-tasks-fs): support multi denied_paths (#88186)\n\nSupport multi denied_paths in `DiskFileSystem`, it's useful to reduce\nredundant task invalidation.",
    "sha": "64c08f42a732268b279ab41440018a9ea04bfe85",
    "files": [
        {
            "sha": "10354016731436718a7568fb3f6ddf6e004aab9e",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/64c08f42a732268b279ab41440018a9ea04bfe85/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64c08f42a732268b279ab41440018a9ea04bfe85/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=64c08f42a732268b279ab41440018a9ea04bfe85",
            "patch": "@@ -166,8 +166,8 @@ pub struct ProjectOptions {\n     /// E.g. `/home/user/projects/my-repo`.\n     pub root_path: RcStr,\n \n-    /// A path which contains the app/pages directories, relative to [`Project::root_path`], always\n-    /// Unix path. E.g. `apps/my-app`\n+    /// A path which contains the app/pages directories, relative to [`Project::project_path`],\n+    /// always Unix path. E.g. `apps/my-app`\n     pub project_path: RcStr,\n \n     /// The contents of next.config.js, serialized to JSON.\n@@ -817,10 +817,10 @@ impl Project {\n             }\n         };\n \n-        Ok(DiskFileSystem::new_with_denied_path(\n+        Ok(DiskFileSystem::new_with_denied_paths(\n             rcstr!(PROJECT_FILESYSTEM_NAME),\n             self.root_path.clone(),\n-            denied_path,\n+            vec![denied_path],\n         ))\n     }\n "
        },
        {
            "sha": "1b44f1b8d41495a92fa38bf5a63d3d7373ef8988",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 39,
            "deletions": 38,
            "changes": 77,
            "blob_url": "https://github.com/vercel/next.js/blob/64c08f42a732268b279ab41440018a9ea04bfe85/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64c08f42a732268b279ab41440018a9ea04bfe85/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=64c08f42a732268b279ab41440018a9ea04bfe85",
            "patch": "@@ -285,9 +285,9 @@ struct DiskFileSystemInner {\n \n     #[turbo_tasks(debug_ignore, trace_ignore)]\n     watcher: DiskWatcher,\n-    /// A root path that we do not allow access to from this filesystem.\n+    /// Root paths that we do not allow access to from this filesystem.\n     /// Useful for things like output directories to prevent accidental ouroboros situations.\n-    denied_path: Option<RcStr>,\n+    denied_paths: Vec<RcStr>,\n }\n \n impl DiskFileSystemInner {\n@@ -300,24 +300,19 @@ impl DiskFileSystemInner {\n     /// Checks if a path is within the denied path\n     /// Returns true if the path should be treated as non-existent\n     ///\n-    /// Since denied_path is guaranteed to be:\n+    /// Since denied_paths are guaranteed to be:\n     /// - normalized (no ../ traversals)\n     /// - using unix separators (/)\n     /// - relative to the fs root\n     ///\n     /// We can efficiently check using string operations\n     fn is_path_denied(&self, path: &FileSystemPath) -> bool {\n-        let Some(denied_path) = &self.denied_path else {\n-            return false;\n-        };\n-        // If the path starts with the denied path then there are three cases\n-        // * they are equal => denied\n-        // * root relative path is a descendant which means the next character is a / => denied\n-        // * anything else => not denied (covers denying `.next` but allowing `.next2`)\n         let path = &path.path;\n-        path.starts_with(denied_path.as_str())\n-            && (path.len() == denied_path.len()\n-                || path.as_bytes().get(denied_path.len()) == Some(&b'/'))\n+        self.denied_paths.iter().any(|denied_path| {\n+            path.starts_with(denied_path.as_str())\n+                && (path.len() == denied_path.len()\n+                    || path.as_bytes().get(denied_path.len()) == Some(&b'/'))\n+        })\n     }\n \n     /// registers the path as an invalidator for the current task,\n@@ -612,7 +607,7 @@ impl DiskFileSystem {\n     /// * `root` - Path to the given filesystem's root. Should be\n     ///   [canonicalized][std::fs::canonicalize].\n     pub fn new(name: RcStr, root: RcStr) -> Vc<Self> {\n-        Self::new_internal(name, root, None)\n+        Self::new_internal(name, root, Vec::new())\n     }\n \n     /// Create a new instance of `DiskFileSystem`.\n@@ -621,22 +616,24 @@ impl DiskFileSystem {\n     /// * `name` - Name of the filesystem.\n     /// * `root` - Path to the given filesystem's root. Should be\n     ///   [canonicalized][std::fs::canonicalize].\n-    /// * `denied_path` - A path within this filesystem that is not allowed to be accessed or\n-    ///   navigated into.  This must be normalized, non-empty and relative to the fs root.\n-    pub fn new_with_denied_path(name: RcStr, root: RcStr, denied_path: RcStr) -> Vc<Self> {\n-        debug_assert!(!denied_path.is_empty(), \"denied_path must not be empty\");\n-        debug_assert!(\n-            normalize_path(&denied_path).as_deref() == Some(&*denied_path),\n-            \"denied_path must be normalized: {denied_path:?}\"\n-        );\n-        Self::new_internal(name, root, Some(denied_path))\n+    /// * `denied_paths` - Paths within this filesystem that are not allowed to be accessed or\n+    ///   navigated into.  These must be normalized, non-empty and relative to the fs root.\n+    pub fn new_with_denied_paths(name: RcStr, root: RcStr, denied_paths: Vec<RcStr>) -> Vc<Self> {\n+        for denied_path in &denied_paths {\n+            debug_assert!(!denied_path.is_empty(), \"denied_path must not be empty\");\n+            debug_assert!(\n+                normalize_path(denied_path).as_deref() == Some(&**denied_path),\n+                \"denied_path must be normalized: {denied_path:?}\"\n+            );\n+        }\n+        Self::new_internal(name, root, denied_paths)\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl DiskFileSystem {\n     #[turbo_tasks::function]\n-    fn new_internal(name: RcStr, root: RcStr, denied_path: Option<RcStr>) -> Vc<Self> {\n+    fn new_internal(name: RcStr, root: RcStr, denied_paths: Vec<RcStr>) -> Vc<Self> {\n         mark_stateful();\n \n         let instance = DiskFileSystem {\n@@ -650,7 +647,7 @@ impl DiskFileSystem {\n                 read_semaphore: create_read_semaphore(),\n                 write_semaphore: create_write_semaphore(),\n                 watcher: DiskWatcher::new(),\n-                denied_path,\n+                denied_paths,\n             }),\n         };\n \n@@ -732,15 +729,18 @@ impl FileSystem for DiskFileSystem {\n                 bail!(anyhow!(e).context(format!(\"reading dir {}\", full_path.display())))\n             }\n         };\n-        let denied_entry = match self.inner.denied_path.as_ref() {\n-            Some(denied_path) => {\n+        let dir_path = fs_path.path.as_str();\n+        let denied_entries: FxHashSet<&str> = self\n+            .inner\n+            .denied_paths\n+            .iter()\n+            .filter_map(|denied_path| {\n                 // If we have a denied path, we need to see if the current directory is a prefix of\n                 // the denied path meaning that it is possible that some directory entry needs to be\n                 // filtered. we do this first to avoid string manipulation on every\n                 // iteration of the directory entries. So while expanding `foo/bar`,\n                 // if `foo/bar/baz` is denied, we filter out `baz`.\n                 // But if foo/bar/baz/qux is denied we don't filter anything from this level.\n-                let dir_path = fs_path.path.as_str();\n                 if denied_path.starts_with(dir_path) {\n                     let denied_path_suffix =\n                         if denied_path.as_bytes().get(dir_path.len()) == Some(&b'/') {\n@@ -755,9 +755,8 @@ impl FileSystem for DiskFileSystem {\n                 } else {\n                     None\n                 }\n-            }\n-            None => None,\n-        };\n+            })\n+            .collect();\n \n         let entries = read_dir\n             .filter_map(|r| {\n@@ -769,9 +768,7 @@ impl FileSystem for DiskFileSystem {\n                 // we filter out any non unicode names\n                 let file_name: RcStr = e.file_name().to_str()?.into();\n                 // Filter out denied entries\n-                if let Some(denied_name) = denied_entry\n-                    && denied_name == file_name.as_str()\n-                {\n+                if denied_entries.contains(file_name.as_str()) {\n                     return None;\n                 }\n \n@@ -3118,7 +3115,8 @@ mod tests {\n             ));\n \n             tt.run_once(async {\n-                let fs = DiskFileSystem::new_with_denied_path(rcstr!(\"test\"), root, denied_path);\n+                let fs =\n+                    DiskFileSystem::new_with_denied_paths(rcstr!(\"test\"), root, vec![denied_path]);\n                 let root_path = fs.root().await?;\n \n                 // Test 1: Reading allowed file should work\n@@ -3169,7 +3167,8 @@ mod tests {\n             ));\n \n             tt.run_once(async {\n-                let fs = DiskFileSystem::new_with_denied_path(rcstr!(\"test\"), root, denied_path);\n+                let fs =\n+                    DiskFileSystem::new_with_denied_paths(rcstr!(\"test\"), root, vec![denied_path]);\n                 let root_path = fs.root().await?;\n \n                 // Test: read_dir on root should not include denied_dir\n@@ -3219,7 +3218,8 @@ mod tests {\n             ));\n \n             tt.run_once(async {\n-                let fs = DiskFileSystem::new_with_denied_path(rcstr!(\"test\"), root, denied_path);\n+                let fs =\n+                    DiskFileSystem::new_with_denied_paths(rcstr!(\"test\"), root, vec![denied_path]);\n                 let root_path = fs.root().await?;\n \n                 // Test: read_glob with ** should not reveal denied files\n@@ -3285,7 +3285,8 @@ mod tests {\n             ));\n \n             tt.run_once(async {\n-                let fs = DiskFileSystem::new_with_denied_path(rcstr!(\"test\"), root, denied_path);\n+                let fs =\n+                    DiskFileSystem::new_with_denied_paths(rcstr!(\"test\"), root, vec![denied_path]);\n                 let root_path = fs.root().await?;\n \n                 // Test 1: Writing to allowed directory should work"
        },
        {
            "sha": "fb3722945e79b812b19917c71517b45f57d21a40",
            "filename": "turbopack/crates/turbopack-cli/src/util.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/64c08f42a732268b279ab41440018a9ea04bfe85/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Futil.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/64c08f42a732268b279ab41440018a9ea04bfe85/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Futil.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-cli%2Fsrc%2Futil.rs?ref=64c08f42a732268b279ab41440018a9ea04bfe85",
            "patch": "@@ -65,8 +65,11 @@ pub async fn project_fs(\n     watch: bool,\n     denied_root_path: RcStr,\n ) -> Result<Vc<Box<dyn FileSystem>>> {\n-    let disk_fs =\n-        DiskFileSystem::new_with_denied_path(rcstr!(\"project\"), project_dir, denied_root_path);\n+    let disk_fs = DiskFileSystem::new_with_denied_paths(\n+        rcstr!(\"project\"),\n+        project_dir,\n+        vec![denied_root_path],\n+    );\n     if watch {\n         disk_fs.await?.start_watching(None).await?;\n     }"
        }
    ],
    "stats": {
        "total": 92,
        "additions": 48,
        "deletions": 44
    }
}