{
    "author": "gnoff",
    "message": "[dynamicIO] prioritize preprocessing RSC rows when prerendering (#80125)\n\nWhen prerendering with dynamicIO we take advantage of a few things about\nmicrotask behavior to ensure that anything prerenderable in RSC is\nincluded in the HTML prerender. We found however that with large enough\nRSC payloads certain things that should have been prerenderable could be\nincorrectly excluded when paired with sync IO in the client because this\ncauses the prerender to abort earlier than one task. To prevent this we\nallow the RSC response to pre-process entirely before continuing with\nthe prerender. This is possible as long as the RSC prerender is fully\ncomplete before the HTML prerender begins.\n\nWe only do this when dynamicIO is enabled and only during prerender. By\nconstruction this means that this also never happens in edge runtime.",
    "sha": "5a4a08fdce91a038f2ed3a70568d3ed040403150",
    "files": [
        {
            "sha": "a7c92e9ae2fc92d290b48139d63ccfca4bba331c",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/5a4a08fdce91a038f2ed3a70568d3ed040403150/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/5a4a08fdce91a038f2ed3a70568d3ed040403150/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=5a4a08fdce91a038f2ed3a70568d3ed040403150",
            "patch": "@@ -692,5 +692,6 @@\n   \"691\": \"Accessed fallback \\\\`params\\\\` during prerendering.\",\n   \"692\": \"Expected clientReferenceManifest to be defined.\",\n   \"693\": \"%s must not be used within a client component. Next.js should be preventing %s from being included in client components statically, but did not in this case.\",\n-  \"694\": \"createPrerenderPathname was called inside a client component scope.\"\n+  \"694\": \"createPrerenderPathname was called inside a client component scope.\",\n+  \"695\": \"Expected workUnitAsyncStorage to have a store.\"\n }"
        },
        {
            "sha": "30bca6f6e6a2a170b9a2dd06eed0d3eaf8299f0d",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 26,
            "deletions": 19,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/5a4a08fdce91a038f2ed3a70568d3ed040403150/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5a4a08fdce91a038f2ed3a70568d3ed040403150/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=5a4a08fdce91a038f2ed3a70568d3ed040403150",
            "patch": "@@ -3780,25 +3780,32 @@ async function prerenderToStream(\n     )\n \n     try {\n-      const fizzStream = await renderToInitialFizzStream({\n-        ReactDOMServer: require('react-dom/server.edge'),\n-        element: (\n-          <ErrorApp\n-            reactServerStream={errorServerStream}\n-            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n-            preinitScripts={errorPreinitScripts}\n-            clientReferenceManifest={clientReferenceManifest}\n-            gracefullyDegrade={!!botType}\n-            nonce={nonce}\n-          />\n-        ),\n-        streamOptions: {\n-          nonce,\n-          // Include hydration scripts in the HTML\n-          bootstrapScripts: [errorBootstrapScript],\n-          formState,\n-        },\n-      })\n+      // TODO we should use the same prerender semantics that we initially rendered\n+      // with in this case too. The only reason why this is ok atm is because it's essentially\n+      // an empty page and no user code runs.\n+      const fizzStream = await workUnitAsyncStorage.run(\n+        prerenderLegacyStore,\n+        renderToInitialFizzStream,\n+        {\n+          ReactDOMServer: require('react-dom/server.edge'),\n+          element: (\n+            <ErrorApp\n+              reactServerStream={errorServerStream}\n+              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n+              preinitScripts={errorPreinitScripts}\n+              clientReferenceManifest={clientReferenceManifest}\n+              gracefullyDegrade={!!botType}\n+              nonce={nonce}\n+            />\n+          ),\n+          streamOptions: {\n+            nonce,\n+            // Include hydration scripts in the HTML\n+            bootstrapScripts: [errorBootstrapScript],\n+            formState,\n+          },\n+        }\n+      )\n \n       if (shouldGenerateStaticFlightData(workStore)) {\n         const flightData = await streamToBuffer("
        },
        {
            "sha": "5be7a328072170fbdac55814ba4ed568f8122048",
            "filename": "packages/next/src/server/app-render/use-flight-response.tsx",
            "status": "modified",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/5a4a08fdce91a038f2ed3a70568d3ed040403150/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fuse-flight-response.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5a4a08fdce91a038f2ed3a70568d3ed040403150/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fuse-flight-response.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fuse-flight-response.tsx?ref=5a4a08fdce91a038f2ed3a70568d3ed040403150",
            "patch": "@@ -3,6 +3,8 @@ import type { BinaryStreamOf } from './app-render'\n \n import { htmlEscapeJsonString } from '../htmlescape'\n import type { DeepReadonly } from '../../shared/lib/deep-readonly'\n+import { workUnitAsyncStorage } from './work-unit-async-storage.external'\n+import { InvariantError } from '../../shared/lib/invariant-error'\n \n const isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n \n@@ -45,6 +47,24 @@ export function useFlightStream<T>(\n     nonce,\n   })\n \n+  // Edge pages are never prerendered so they necessarily cannot have a workUnitStore type\n+  // that requires the nextTick behavior. This is why it is safe to access a node only API here\n+  if (process.env.NEXT_RUNTIME !== 'edge') {\n+    const workUnitStore = workUnitAsyncStorage.getStore()\n+    if (!workUnitStore) {\n+      throw new InvariantError('Expected workUnitAsyncStorage to have a store.')\n+    }\n+    if (workUnitStore.type === 'prerender-client') {\n+      const responseOnNextTick = new Promise<T>((r) => {\n+        process.nextTick(() => {\n+          r(newResponse)\n+        })\n+      })\n+      flightResponses.set(flightStream, responseOnNextTick)\n+      return responseOnNextTick\n+    }\n+  }\n+\n   flightResponses.set(flightStream, newResponse)\n \n   return newResponse"
        },
        {
            "sha": "95aa996b6fd8a48e23c2aaef14a1977d2b3ddcba",
            "filename": "test/e2e/app-dir/dynamic-io-errors/dynamic-io-errors.sync-attribution.test.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 12,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/5a4a08fdce91a038f2ed3a70568d3ed040403150/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Fdynamic-io-errors.sync-attribution.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5a4a08fdce91a038f2ed3a70568d3ed040403150/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Fdynamic-io-errors.sync-attribution.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Fdynamic-io-errors.sync-attribution.test.ts?ref=5a4a08fdce91a038f2ed3a70568d3ed040403150",
            "patch": "@@ -1,4 +1,5 @@\n import { nextTestSetup } from 'e2e-utils'\n+import { assertNoErrorToast } from 'next-test-utils'\n \n import { createExpectError } from './utils'\n \n@@ -18,11 +19,6 @@ function runTests(options: { withMinification: boolean }) {\n         return\n       }\n \n-      if (isNextDev) {\n-        it('does not run in dev', () => {})\n-        return\n-      }\n-\n       beforeEach(async () => {\n         if (!withMinification) {\n           await next.patchFile('next.config.js', (content) =>\n@@ -34,14 +30,22 @@ function runTests(options: { withMinification: boolean }) {\n         }\n       })\n \n-      it('should not error the build sync IO is used inside a Suspense Boundary in a client Component and nothing else is dynamic', async () => {\n-        try {\n+      if (isNextDev) {\n+        it('does not show a validation error in the dev overlay', async () => {\n           await next.start()\n-        } catch {\n-          throw new Error('expected build not to fail')\n-        }\n-        expect(next.cliOutput).toContain('◐ / ')\n-      })\n+          const browser = await next.browser('/')\n+          await assertNoErrorToast(browser)\n+        })\n+      } else {\n+        it('should not error the build sync IO is used inside a Suspense Boundary in a client Component and nothing else is dynamic', async () => {\n+          try {\n+            await next.start()\n+          } catch {\n+            throw new Error('expected build not to fail')\n+          }\n+          expect(next.cliOutput).toContain('◐ / ')\n+        })\n+      }\n     })\n     describe('Error Attribution with Sync IO - Guarded RSC with unguarded Client sync IO', () => {\n       const { next, isNextDev, skipped } = nextTestSetup({"
        },
        {
            "sha": "10e2e2ae4b458627abe57482ca95fdca8ea85c95",
            "filename": "test/e2e/app-dir/dynamic-io-errors/fixtures/sync-attribution/guarded-async-guarded-clientsync/app/layout.tsx",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/5a4a08fdce91a038f2ed3a70568d3ed040403150/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fsync-attribution%2Fguarded-async-guarded-clientsync%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/5a4a08fdce91a038f2ed3a70568d3ed040403150/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fsync-attribution%2Fguarded-async-guarded-clientsync%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fdynamic-io-errors%2Ffixtures%2Fsync-attribution%2Fguarded-async-guarded-clientsync%2Fapp%2Flayout.tsx?ref=5a4a08fdce91a038f2ed3a70568d3ed040403150",
            "patch": "@@ -3,6 +3,12 @@ export default function Root({ children }: { children: React.ReactNode }) {\n     <html>\n       <body>\n         <main>{children}</main>\n+        <div>\n+          We add extra content here because it increases the size of the dev RSC\n+          payload which exercises the preloading of the RSC chunks more. We want\n+          a greater page weight than this simple test would otherwise have\n+          produced.\n+        </div>\n       </body>\n     </html>\n   )"
        },
        {
            "sha": "85ee69e094a03103f381ca0a189fcf327a7d6405",
            "filename": "test/lib/next-test-utils.ts",
            "status": "modified",
            "additions": 25,
            "deletions": 2,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/5a4a08fdce91a038f2ed3a70568d3ed040403150/test%2Flib%2Fnext-test-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5a4a08fdce91a038f2ed3a70568d3ed040403150/test%2Flib%2Fnext-test-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Flib%2Fnext-test-utils.ts?ref=5a4a08fdce91a038f2ed3a70568d3ed040403150",
            "patch": "@@ -851,8 +851,11 @@ export async function assertHasRedbox(browser: Playwright) {\n   }\n }\n \n-export async function assertNoRedbox(browser: Playwright) {\n-  await waitFor(5000)\n+export async function assertNoRedbox(\n+  browser: Playwright,\n+  { waitInMs = 5000 }: { waitInMs?: number } = {}\n+) {\n+  await waitFor(waitInMs)\n   const redbox = browser.locateRedbox()\n \n   if (await redbox.isVisible()) {\n@@ -873,6 +876,26 @@ export async function assertNoRedbox(browser: Playwright) {\n   }\n }\n \n+export async function assertNoErrorToast(browser: Playwright): Promise<void> {\n+  let didOpenRedbox = false\n+\n+  try {\n+    await browser.waitForElementByCss('[data-issues]').click()\n+    didOpenRedbox = true\n+  } catch {\n+    // We expect this to fail.\n+  }\n+\n+  if (didOpenRedbox) {\n+    // If a redbox was opened unexpectedly, we use the `assertNoRedbox` helper\n+    // to print a useful error message containing the redbox contents.\n+    await assertNoRedbox(browser, {\n+      // We already know the redbox is open, so we can skip waiting for it.\n+      waitInMs: 0,\n+    })\n+  }\n+}\n+\n export async function hasErrorToast(browser: Playwright): Promise<boolean> {\n   return Boolean(\n     await browser.eval(() => {"
        }
    ],
    "stats": {
        "total": 129,
        "additions": 95,
        "deletions": 34
    }
}