{
    "author": "icyJoseph",
    "message": "docs: use cache remote (#86546)",
    "sha": "916f45d5e54061721154d0f86f4bbe50951cf5cd",
    "files": [
        {
            "sha": "b9acb4086d4caf96864c2329b9929af6eb6c7cdd",
            "filename": "docs/01-app/03-api-reference/01-directives/use-cache-remote.mdx",
            "status": "modified",
            "additions": 233,
            "deletions": 187,
            "changes": 420,
            "blob_url": "https://github.com/vercel/next.js/blob/916f45d5e54061721154d0f86f4bbe50951cf5cd/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache-remote.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/916f45d5e54061721154d0f86f4bbe50951cf5cd/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache-remote.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F01-directives%2Fuse-cache-remote.mdx?ref=916f45d5e54061721154d0f86f4bbe50951cf5cd",
            "patch": "@@ -1,6 +1,6 @@\n ---\n title: 'use cache: remote'\n-description: 'Learn how to use the `\"use cache: remote\"` directive to enable caching in dynamic contexts in your Next.js application.'\n+description: 'Learn how to use the \"use cache: remote\" directive for persistent, shared caching using remote cache handlers.'\n related:\n   title: Related\n   description: View related API references.\n@@ -14,12 +14,15 @@ related:\n     - app/api-reference/functions/connection\n ---\n \n-The `'use cache: remote'` directive enables caching of **shared data** in dynamic contexts where regular [`use cache`](/docs/app/api-reference/directives/use-cache) would not work, for example after calling [`await connection()`](/docs/app/api-reference/functions/connection), [`await cookies()`](/docs/app/api-reference/functions/cookies) or [`await headers()`](/docs/app/api-reference/functions/headers).\n+While the `use cache` directive is sufficient for most application needs, you might occasionally notice that cached operations are re-running more often than expected, or that your upstream services (CMS, databases, external APIs) are getting more hits than you'd expect. This can happen because in-memory caching has inherent limitations:\n \n-> **Good to know:**\n->\n-> - Results are stored in server-side cache handlers and shared across all users.\n-> - For **user-specific data** that depends on [`await cookies()`](/docs/app/api-reference/functions/cookies) or [`await headers()`](/docs/app/api-reference/functions/headers), use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead.\n+- Cache entries being evicted to make room for new ones\n+- Memory constraints in your deployment environment\n+- Cache not persisting across requests or server restarts\n+\n+Note that `use cache` still provides value beyond server-side caching: it informs Next.js what can be prefetched and defines stale times for client-side navigation.\n+\n+The `'use cache: remote'` directive lets you declaratively specify that a cached output should be stored in a **remote cache** instead of in-memory. While this gives you more durable caching for specific operations, it comes with tradeoffs: infrastructure cost and network latency during cache lookups.\n \n ## Usage\n \n@@ -44,222 +47,144 @@ const nextConfig = {\n export default nextConfig\n ```\n \n-Then add `'use cache: remote'` to your function that needs to cache data in a dynamic context.\n+Then add `'use cache: remote'` to the functions or components where you've determined remote caching is justified. The handler implementation is configured via [`cacheHandlers`](/docs/app/api-reference/config/next-config-js/cacheHandlers), though hosting providers should typically provide this automatically. If you're self-hosting, see the `cacheHandlers` configuration reference to set up your cache storage.\n \n-### Basic example\n+### When to avoid remote caching\n \n-Cache product pricing that needs to be fetched at request time but can be shared across all users. Use [`cacheLife`](/docs/app/api-reference/functions/cacheLife#custom-cache-profiles) to set the cache lifetime of the price.\n+- If you already have a server-side cache key-value store wrapping your data layer, `use cache` may be sufficient to include data in the static shell without adding another caching layer\n+- If operations are already fast (< 50ms) due to proximity or local access, the remote cache lookup might not improve performance\n+- If cache keys have mostly unique values per request (search filters, price ranges, user-specific parameters), cache utilization will be near-zero\n+- If data changes frequently (seconds to minutes), cache hits will quickly go stale, leading to frequent misses and waiting for upstream revalidation\n \n-```tsx filename=\"app/product/[id]/page.tsx\" switcher\n-import { Suspense } from 'react'\n-import { connection } from 'next/server'\n-import { cacheTag, cacheLife } from 'next/cache'\n+### When remote caching makes sense\n \n-export default async function ProductPage({\n-  params,\n-}: {\n-  params: Promise<{ id: string }>\n-}) {\n-  const { id } = await params\n+Remote caching provides the most value when content is deferred to request time (outside the static shell). This typically happens when a component accesses request values like [`cookies()`](/docs/app/api-reference/functions/cookies), [`headers()`](/docs/app/api-reference/functions/headers), or [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional), placing it inside a Suspense boundary. In this context:\n \n-  return (\n-    <div>\n-      <ProductDetails id={id} />\n-      <Suspense fallback={<div>Loading price...</div>}>\n-        <ProductPrice productId={id} />\n-      </Suspense>\n-    </div>\n-  )\n-}\n+- Each request executes the component and looks up the cache\n+- In serverless environments, each instance has its own ephemeral memory with low cache hit rates\n+- Remote caching provides a shared cache across all instances, improving hit rates and reducing backend load\n \n-function ProductDetails({ id }: { id: string }) {\n-  return <div>Product: {id}</div>\n-}\n+Compelling scenarios for `'use cache: remote'`:\n \n-async function ProductPrice({ productId }: { productId: string }) {\n-  // Calling connection() makes this component dynamic, preventing\n-  // it from being included in the static shell. This ensures the price\n-  // is always fetched at request time.\n-  await connection()\n+- **Rate-limited APIs**: Your upstream service has rate limits or request quotas that you risk hitting\n+- **Protecting slow backends**: Your database or API becomes a bottleneck under high traffic\n+- **Expensive operations**: Database queries or computations that are costly to run repeatedly\n+- **Flaky or unreliable services**: External services that occasionally fail or have availability issues\n \n-  // Now we can cache the price in a remote cache handler.\n-  // Regular 'use cache' would NOT work here because we're in a dynamic context.\n-  const price = await getProductPrice(productId)\n+In these cases, the cost and latency of remote caching is justified by avoiding worse outcomes (rate limit errors, backend overload, high compute bills, or degraded user experience).\n \n-  return <div>Price: ${price}</div>\n-}\n+For static shell content, `use cache` is usually sufficient. However, if your static pages share data from an upstream that can't handle concurrent revalidation requests (like a rate-limited CMS), `use cache: remote` acts as a shared cache layer in front of that upstream. This is the same pattern as putting a key-value store in front of a database, but declared in your code rather than configured in infrastructure.\n \n-async function getProductPrice(productId: string) {\n-  'use cache: remote'\n-  cacheTag(`product-price-${productId}`)\n-  cacheLife({ expire: 3600 }) // 1 hour\n+### How `use cache: remote` differs from `use cache` and `use cache: private`\n \n-  // This database query is cached and shared across all users\n-  return db.products.getPrice(productId)\n-}\n-```\n+Next.js provides three caching directives, each designed for different use cases:\n \n-```jsx filename=\"app/product/[id]/page.js\" switcher\n-import { Suspense } from 'react'\n-import { connection } from 'next/server'\n-import { cacheTag, cacheLife } from 'next/cache'\n+| Feature                                 | `use cache`                     | `'use cache: remote'`             | `'use cache: private'` |\n+| --------------------------------------- | ------------------------------- | --------------------------------- | ---------------------- |\n+| **Server-side caching**                 | In-memory or cache handler      | Remote cache handler              | None                   |\n+| **Cache scope**                         | Shared across all users         | Shared across all users           | Per-client (browser)   |\n+| **Can access cookies/headers directly** | No (must pass as arguments)     | No (must pass as arguments)       | Yes                    |\n+| **Server cache utilization**            | May be low outside static shell | High (shared across instances)    | N/A                    |\n+| **Additional costs**                    | None                            | Infrastructure (storage, network) | None                   |\n+| **Latency impact**                      | None                            | Cache handler lookup              | None                   |\n \n-export default async function ProductPage({ params }) {\n-  const { id } = await params\n+### Caching with runtime data\n+\n+Both `use cache` and `'use cache: remote'` directives can't access runtime data like cookies or search params directly, since this data isn't available when computing the cache. However, you can extract values from these APIs and pass them as arguments to cached functions. See [with runtime data](/docs/app/getting-started/cache-components#with-runtime-data) for this pattern.\n \n+In general, but most importantly for `'use cache: remote'`, be thoughtful about which values you include in cache keys. Each unique value creates a separate cache entry, reducing cache utilization. Consider this example with search filters:\n+\n+```tsx filename=\"app/products/[category]/page.tsx\"\n+import { Suspense } from 'react'\n+\n+export default async function ProductsPage({\n+  params,\n+  searchParams,\n+}: {\n+  params: Promise<{ category: string }>\n+  searchParams: Promise<{ minPrice?: string }>\n+}) {\n   return (\n-    <div>\n-      <ProductDetails id={id} />\n-      <Suspense fallback={<div>Loading price...</div>}>\n-        <ProductPrice productId={id} />\n-      </Suspense>\n-    </div>\n+    <Suspense fallback={<div>Loading...</div>}>\n+      <ProductList params={params} searchParams={searchParams} />\n+    </Suspense>\n   )\n }\n \n-function ProductDetails({ id }) {\n-  return <div>Product: {id}</div>\n-}\n+async function ProductList({\n+  params,\n+  searchParams,\n+}: {\n+  params: Promise<{ category: string }>\n+  searchParams: Promise<{ minPrice?: string }>\n+}) {\n+  const { category } = await params\n \n-async function ProductPrice({ productId }) {\n-  // Calling connection() makes this component dynamic, preventing\n-  // it from being included in the static shell. This ensures the price\n-  // is always fetched at request time.\n-  await connection()\n+  const { minPrice } = await searchParams\n \n-  // Now we can cache the price in a remote cache handler.\n-  // Regular 'use cache' would NOT work here because we're in a dynamic context.\n-  const price = await getProductPrice(productId)\n+  // Cache only on category (few unique values)\n+  // Don't include price filter (many unique values)\n+  const products = await getProductsByCategory(category)\n \n-  return <div>Price: ${price}</div>\n+  // Filter price in memory instead of creating cache entries\n+  // for every price value\n+  const filtered = minPrice\n+    ? products.filter((p) => p.price >= parseFloat(minPrice))\n+    : products\n+\n+  return <div>{/* render filtered products */}</div>\n }\n \n-async function getProductPrice(productId) {\n+async function getProductsByCategory(category: string) {\n   'use cache: remote'\n-  cacheTag(`product-price-${productId}`)\n-  cacheLife({ expire: 3600 }) // 1 hour\n-\n-  // This database query is cached and shared across all users\n-  return db.products.getPrice(productId)\n+  // Only category is part of the cache key\n+  // Much better utilization than caching every price filter value\n+  return db.products.findByCategory(category)\n }\n ```\n \n-> **Note:** Regular [`use cache`](/docs/app/api-reference/directives/use-cache) will not cache anything when used in a dynamic context (after [`await connection()`](/docs/app/api-reference/functions/connection), [`await cookies()`](/docs/app/api-reference/functions/cookies), [`await headers()`](/docs/app/api-reference/functions/headers), etc.). Use `'use cache: remote'` to enable runtime caching in these scenarios.\n-\n-## How `use cache: remote` differs from `use cache` and `use cache: private`\n-\n-Next.js provides three caching directives, each designed for different use cases:\n-\n-| Feature                          | `use cache`                         | `'use cache: remote'`                                     | `'use cache: private'`              |\n-| -------------------------------- | ----------------------------------- | --------------------------------------------------------- | ----------------------------------- |\n-| **Works in dynamic context**     | No (requires static context)        | Yes (designed for dynamic contexts)                       | Yes                                 |\n-| **Access to `await cookies()`**  | No                                  | No                                                        | Yes                                 |\n-| **Access to `await headers()`**  | No                                  | No                                                        | Yes                                 |\n-| **After `await connection()`**   | No (won't cache)                    | No                                                        | No                                  |\n-| **Stored in cache handler**      | Yes (server-side)                   | Yes (server-side)                                         | No (client-side only)               |\n-| **Cache scope**                  | Global (shared)                     | Global (shared)                                           | Per-user (isolated)                 |\n-| **Supports runtime prefetching** | N/A (pre-rendered at build)         | No                                                        | Yes (when configured)               |\n-| **Use case**                     | Static, shared content (build-time) | Dynamic, shared content in runtime contexts (per-request) | Personalized, user-specific content |\n+In this example, the remote handler stores more data per cache entry (all products in a category) to achieve better cache hit rates. This is worth it when the cost of cache misses (hitting your backend) outweighs the storage cost of larger entries.\n \n-> **Note:** While you can't call `await cookies()` or `await headers()` inside `'use cache: remote'`, you can read the values before calling a function that is wrapped by `'use cache: remote'` and the arguments will be included in the cache key. Note that this is not recommended as it will dramatically increase the cache size and reduce the cache hit rate.\n+The same principle applies to user-specific data. Rather than caching per-user data directly, use user preferences to determine what shared data to cache.\n \n-### When to use each directive\n+For example, if users have a language preference in their session, extract that preference and use it to cache shared content:\n \n-Choose the right caching directive based on your use case:\n+- Instead of remote caching `getUserProfile(sessionID)`, which creates one entry per user\n+- Remote cache `getCMSContent(language)` to create one entry per language\n \n-**Use [`use cache`](/docs/app/api-reference/directives/use-cache) when:**\n-\n-- Content can be prerendered at build time\n-- Content is shared across all users\n-- Content doesn't depend on request-specific data\n-\n-**Use `'use cache: remote'` when:**\n-\n-- You need caching within dynamic context\n-- Content is shared across users but must be rendered per-request (after `await connection()`)\n-- You want to cache expensive operations in a server-side cache handler\n-\n-**Use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) when:**\n-\n-- Content is personalized per-user (depends on cookies, headers)\n-- You need [runtime prefetching](/docs/app/guides/prefetching) of user-specific content\n-- Content should never be shared between users\n-\n-## How it works\n-\n-The `'use cache: remote'` directive enables runtime caching of shared data in dynamic contexts by storing results in server-side cache handlers rather than prerendering at build time.\n-\n-### Dynamic context detection\n-\n-When Next.js encounters certain APIs like [`connection()`](/docs/app/api-reference/functions/connection), [`cookies()`](/docs/app/api-reference/functions/cookies), or [`headers()`](/docs/app/api-reference/functions/headers), the context becomes \"dynamic\". In a dynamic context:\n-\n-1. **Regular `use cache` stops working** - it won't cache anything\n-2. **`'use cache: remote'` continues to work** - it is cached by a remote cache handler.\n-3. **Results are stored server-side** in a key-value store configured for your deployment\n-4. **Cached data is shared across requests** - reducing database load and origin requests\n-\n-> **Good to know:** Without `'use cache: remote'`, functions in dynamic contexts would execute on every request, potentially creating performance bottlenecks. Remote caching eliminates this issue by storing results in server-side cache handlers.\n-\n-### Storage behavior\n-\n-Remote caches are **persisted using server-side cache handlers**, which may include:\n-\n-- **Distributed key-value stores** (in-memory or persistent storage solutions)\n-- **File system or in-memory storage** (often used in development or for custom deployments)\n-- **Environment-specific caches** (provided by your hosting infrastructure)\n-- **Custom or configured cache handlers** (depending on your application's setup)\n-\n-This means:\n-\n-1. Cached data is shared across all users and requests\n-2. Cache entries persist beyond a single session\n-3. Cache invalidation works via [`cacheTag`](/docs/app/api-reference/functions/cacheTag) and [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)\n-4. Cache expiration is controlled by [`cacheLife`](/docs/app/api-reference/functions/cacheLife) configuration\n-\n-### Dynamic context example\n-\n-```tsx\n-async function UserDashboard() {\n-  // Calling connection() makes the context dynamic\n-  await connection()\n+```tsx filename=\"app/components/welcome-message.tsx\"\n+import { cookies } from 'next/headers'\n+import { cacheLife } from 'next/cache'\n \n-  // Without any caching directive, this runs on every request\n-  const stats = await getStats()\n+export async function WelcomeMessage() {\n+  // Extract the language preference (not unique per user)\n+  const language = (await cookies()).get('language')?.value || 'en'\n \n-  // With 'use cache: remote', this is cached in the remote handler\n-  const analytics = await getAnalytics()\n+  // Cache based on language (few unique values: en, es, fr, de, etc.)\n+  // All users who prefer 'en' share the same cache entry\n+  const content = await getCMSContent(language)\n \n-  return (\n-    <div>\n-      <Stats data={stats} />\n-      <Analytics data={analytics} />\n-    </div>\n-  )\n+  return <div>{content.welcomeMessage}</div>\n }\n \n-async function getAnalytics() {\n+async function getCMSContent(language: string) {\n   'use cache: remote'\n-  cacheLife({ expire: 300 }) // 5 minutes\n-\n-  // This expensive operation is cached and shared across all requests\n-  return fetchAnalyticsData()\n+  cacheLife({ expire: 3600 })\n+  // Creates ~10-50 cache entries (one per language)\n+  // instead of thousands (one per user)\n+  return cms.getHomeContent(language)\n }\n ```\n \n-## Request APIs and remote caches\n+This way all users who prefer the same language share a cache entry, improving cache utilization and reducing load on your CMS.\n \n-While `'use cache: remote'` technically allows access to request-specific data by calling API's like [`cookies()`](/docs/app/api-reference/functions/cookies) and [`headers()`](/docs/app/api-reference/functions/headers) before calling a function that is wrapped by `'use cache: remote'`, it's generally not recommended to use them together:\n+The pattern is the same in both examples: find the dimension with fewer unique values (category vs. price, language vs. user ID), cache on that dimension, and filter or select the rest in memory.\n \n-| API                                                                                   | Allowed in `use cache` | Allowed in `'use cache: remote'` | Recommended                                                                                |\n-| ------------------------------------------------------------------------------------- | ---------------------- | -------------------------------- | ------------------------------------------------------------------------------------------ |\n-| [`cookies()`](/docs/app/api-reference/functions/cookies)                              | No                     | No                               | Use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead |\n-| [`headers()`](/docs/app/api-reference/functions/headers)                              | No                     | No                               | Use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead |\n-| [`connection()`](/docs/app/api-reference/functions/connection)                        | No                     | No                               | No - these cannot ever be cached                                                           |\n-| [`searchParams`](/docs/app/api-reference/file-conventions/page#searchparams-optional) | No                     | No                               | Use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead |\n+If the service used by `getUserProfile` cannot scale with your frontend load, you may still be able to use the `use cache` directive with a short `cacheLife` for in-memory caching. However, for most user data, you likely want to fetch directly from the source (which might already be wrapped in a key/value store as mentioned in the guidelines above).\n \n-> **Important:** If you need to cache based on cookies, headers, or search params, use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead. Remote caches are shared across all users, so caching user-specific data in them can lead to incorrect results being served to different users.\n+Only use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) if you have compliance requirements or can't refactor to pass runtime data as arguments.\n \n-## Nesting rules\n+### Nesting rules\n \n Remote caches have specific nesting rules:\n \n@@ -284,7 +209,7 @@ async function innerRemote() {\n // VALID: Remote inside regular cache\n async function outerCache() {\n   'use cache'\n-  // If this is in a dynamic context, the inner remote cache will work\n+  // The inner remote cache will work when deferred to request time\n   const result = await innerRemote()\n   return result\n }\n@@ -323,16 +248,135 @@ async function innerPrivate() {\n \n The following examples demonstrate common patterns for using `'use cache: remote'`. For details about `cacheLife` parameters (`stale`, `revalidate`, `expire`), see the [`cacheLife` API reference](/docs/app/api-reference/functions/cacheLife).\n \n-### Per-request database queries\n+### With user preferences\n+\n+Cache product pricing based on the user's currency preference. Since the currency is stored in a cookie, this component renders at request time. Remote caching is valuable here because all users with the same currency share the cached price, and in serverless environments, all instances share the same remote cache.\n+\n+```tsx filename=\"app/product/[id]/page.tsx\" switcher\n+import { Suspense } from 'react'\n+import { cookies } from 'next/headers'\n+import { cacheTag, cacheLife } from 'next/cache'\n+\n+export async function generateStaticParams() {\n+  return [{ id: '1' }, { id: '2' }, { id: '3' }]\n+}\n+\n+export default async function ProductPage({\n+  params,\n+}: {\n+  params: Promise<{ id: string }>\n+}) {\n+  const { id } = await params\n+\n+  return (\n+    <div>\n+      <ProductDetails id={id} />\n+      <Suspense fallback={<div>Loading price...</div>}>\n+        <ProductPrice productId={id} />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+function ProductDetails({ id }: { id: string }) {\n+  return <div>Product: {id}</div>\n+}\n+\n+async function ProductPrice({ productId }: { productId: string }) {\n+  // Reading cookies defers this component to request time\n+  const currency = (await cookies()).get('currency')?.value ?? 'USD'\n+\n+  // Cache the price per product and currency combination\n+  // All users with the same currency share this cache entry\n+  const price = await getProductPrice(productId, currency)\n+\n+  return (\n+    <div>\n+      Price: {price} {currency}\n+    </div>\n+  )\n+}\n+\n+async function getProductPrice(productId: string, currency: string) {\n+  'use cache: remote'\n+  cacheTag(`product-price-${productId}`)\n+  cacheLife({ expire: 3600 }) // 1 hour\n+\n+  // Cached per (productId, currency) - few currencies means high cache utilization\n+  return db.products.getPrice(productId, currency)\n+}\n+```\n+\n+```jsx filename=\"app/product/[id]/page.js\" switcher\n+import { Suspense } from 'react'\n+import { cookies } from 'next/headers'\n+import { cacheTag, cacheLife } from 'next/cache'\n+\n+export async function generateStaticParams() {\n+  return [{ id: '1' }, { id: '2' }, { id: '3' }]\n+}\n+\n+export default async function ProductPage({ params }) {\n+  const { id } = await params\n+\n+  return (\n+    <div>\n+      <ProductDetails id={id} />\n+      <Suspense fallback={<div>Loading price...</div>}>\n+        <ProductPrice productId={id} />\n+      </Suspense>\n+    </div>\n+  )\n+}\n+\n+function ProductDetails({ id }) {\n+  return <div>Product: {id}</div>\n+}\n+\n+async function ProductPrice({ productId }) {\n+  // Reading cookies defers this component to request time\n+  const currency = (await cookies()).get('currency')?.value ?? 'USD'\n+\n+  // Cache the price per product and currency combination\n+  // All users with the same currency share this cache entry\n+  const price = await getProductPrice(productId, currency)\n+\n+  return (\n+    <div>\n+      Price: {price} {currency}\n+    </div>\n+  )\n+}\n+\n+async function getProductPrice(productId, currency) {\n+  'use cache: remote'\n+  cacheTag(`product-price-${productId}`)\n+  cacheLife({ expire: 3600 }) // 1 hour\n+\n+  // Cached per (productId, currency) - few currencies means high cache utilization\n+  return db.products.getPrice(productId, currency)\n+}\n+```\n+\n+### Reducing database load\n \n-Cache expensive database queries that are accessed in dynamic contexts, reducing load on your database:\n+Cache expensive database queries, reducing load on your database. In this example, we don't access `cookies()`, `headers()`, or `searchParams`. If we had a requirement to not include these stats in the static shell, we could use [`connection()`](/docs/app/api-reference/functions/connection) to explicitly defer to request time:\n \n ```tsx filename=\"app/dashboard/page.tsx\"\n+import { Suspense } from 'react'\n import { connection } from 'next/server'\n import { cacheLife, cacheTag } from 'next/cache'\n \n-export default async function DashboardPage() {\n-  // Make context dynamic\n+export default function DashboardPage() {\n+  return (\n+    <Suspense fallback={<div>Loading stats...</div>}>\n+      <DashboardStats />\n+    </Suspense>\n+  )\n+}\n+\n+async function DashboardStats() {\n+  // Defer to request time\n   await connection()\n \n   const stats = await getGlobalStats()\n@@ -357,6 +401,8 @@ async function getGlobalStats() {\n }\n ```\n \n+With this setup, your upstream database sees at most one request per minute, regardless of how many users visit the dashboard.\n+\n ### API responses in streaming contexts\n \n Cache API responses that are fetched during streaming or after dynamic operations:\n@@ -377,7 +423,7 @@ export default async function FeedPage() {\n }\n \n async function FeedItems() {\n-  // Dynamic context\n+  // Defer to request time\n   await connection()\n \n   const items = await getFeedItems()\n@@ -405,7 +451,7 @@ import { connection } from 'next/server'\n import { cacheLife } from 'next/cache'\n \n export default async function ReportsPage() {\n-  // Dynamic security check\n+  // Defer to request time (for security check)\n   await connection()\n \n   const report = await generateReport()\n@@ -504,7 +550,7 @@ function ProductDetails({ product }) {\n }\n \n async function ProductPriceComponent({ productId }) {\n-  // Make this component dynamic\n+  // Defer to request time\n   await connection()\n \n   const price = await getProductPrice(productId)\n@@ -538,7 +584,7 @@ function RecommendationsList({ items }) {\n > **Good to know**:\n >\n > - Remote caches are stored in server-side cache handlers and shared across all users\n-> - Remote caches work in dynamic contexts where regular [`use cache`](/docs/app/api-reference/directives/use-cache) would fail\n+> - `'use cache: remote'` works outside the static shell where [`use cache`](/docs/app/api-reference/directives/use-cache) may not provide server-side cache hits\n > - Use [`cacheTag()`](/docs/app/api-reference/functions/cacheTag) and [`revalidateTag()`](/docs/app/api-reference/functions/revalidateTag) to invalidate remote caches on-demand\n > - Use [`cacheLife()`](/docs/app/api-reference/functions/cacheLife) to configure cache expiration\n > - For user-specific data, use [`'use cache: private'`](/docs/app/api-reference/directives/use-cache-private) instead of `'use cache: remote'`"
        }
    ],
    "stats": {
        "total": 420,
        "additions": 233,
        "deletions": 187
    }
}