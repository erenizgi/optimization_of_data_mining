{
    "author": "bgw",
    "message": "Turbopack: Use strongly consistent reads in `random_change` unit test (#84505)\n\nI can't reproduce it locally, but I've noticed this test flake a few times in CI. Use strongly consistent reads to hopefully fix that.",
    "sha": "6a0718dc05df76b52c81799f3b1bd6f89bf848d2",
    "files": [
        {
            "sha": "b6c1855f6ef494d59e1368a9b805eec16a05a68f",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/random_change.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 14,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/6a0718dc05df76b52c81799f3b1bd6f89bf848d2/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6a0718dc05df76b52c81799f3b1bd6f89bf848d2/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs?ref=6a0718dc05df76b52c81799f3b1bd6f89bf848d2",
            "patch": "@@ -3,24 +3,30 @@\n #![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n \n use anyhow::{Result, bail};\n-use rand::Rng;\n-use turbo_tasks::{State, Vc};\n+use rand::{Rng, SeedableRng, rngs::StdRng};\n+use turbo_tasks::{ResolvedVc, State, Vc};\n use turbo_tasks_testing::{Registration, register, run_once};\n \n static REGISTRATION: Registration = register!();\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn random_change() {\n     run_once(&REGISTRATION, || async {\n-        let state = make_state();\n-        let value = rand::rng().random_range(0..100);\n-        state.await?.state.set(value);\n+        let state = make_state_operation().resolve_strongly_consistent().await?;\n \n-        let result = func(state, 0).await?;\n-        assert_eq!(result.value, value);\n+        let mut rng = StdRng::from_seed(Default::default());\n+        let func_op = func_operation(state);\n+        let func2_op = func2_operation(state);\n+        for _i in 0..10 {\n+            let value = rng.random_range(0..100);\n+            state.await?.state.set(value);\n \n-        let result = func2(state).await?;\n-        assert_eq!(result.value, value);\n+            let result = func_op.read_strongly_consistent().await?;\n+            assert_eq!(result.value, value);\n+\n+            let result = func2_op.read_strongly_consistent().await?;\n+            assert_eq!(result.value, value);\n+        }\n \n         anyhow::Ok(())\n     })\n@@ -40,20 +46,25 @@ struct ValueContainer {\n     state: State<i32>,\n }\n \n-#[turbo_tasks::function]\n-fn make_state() -> Vc<ValueContainer> {\n+#[turbo_tasks::function(operation)]\n+fn make_state_operation() -> Vc<ValueContainer> {\n     ValueContainer {\n         state: State::new(0),\n     }\n     .cell()\n }\n \n-#[turbo_tasks::function]\n-async fn func2(input: Vc<ValueContainer>) -> Result<Vc<Value>> {\n+#[turbo_tasks::function(operation)]\n+async fn func2_operation(input: ResolvedVc<ValueContainer>) -> Result<Vc<Value>> {\n     let state = input.await?;\n     let value = state.state.get();\n     println!(\"func2 {}\", *value);\n-    Ok(func(input, -*value))\n+    Ok(func(*input, -*value))\n+}\n+\n+#[turbo_tasks::function(operation)]\n+async fn func_operation(input: ResolvedVc<ValueContainer>) -> Vc<Value> {\n+    func(*input, 0)\n }\n \n #[turbo_tasks::function]"
        }
    ],
    "stats": {
        "total": 39,
        "additions": 25,
        "deletions": 14
    }
}