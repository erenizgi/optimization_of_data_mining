{
    "author": "kdy1",
    "message": "test(next-swc): Add tests for the React Compiler support (#79499)\n\n### What?\n\nAdd tests for the interestingness detection for the RC\n\n### Why?",
    "sha": "c810c30c4e988d84b99da906ccef8755ff0e1c85",
    "files": [
        {
            "sha": "c5ebf586b84f7684752ed796113094852dcb341f",
            "filename": "crates/next-custom-transforms/src/react_compiler.rs",
            "status": "modified",
            "additions": 197,
            "deletions": 27,
            "changes": 224,
            "blob_url": "https://github.com/vercel/next.js/blob/c810c30c4e988d84b99da906ccef8755ff0e1c85/crates%2Fnext-custom-transforms%2Fsrc%2Freact_compiler.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/c810c30c4e988d84b99da906ccef8755ff0e1c85/crates%2Fnext-custom-transforms%2Fsrc%2Freact_compiler.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-custom-transforms%2Fsrc%2Freact_compiler.rs?ref=c810c30c4e988d84b99da906ccef8755ff0e1c85",
            "patch": "@@ -1,5 +1,8 @@\n use swc_core::ecma::{\n-    ast::{Callee, Expr, FnDecl, FnExpr, Pat, Program, ReturnStmt, Stmt, VarDeclarator},\n+    ast::{\n+        Callee, ExportDefaultDecl, ExportDefaultExpr, Expr, FnDecl, FnExpr, Pat, Program, Stmt,\n+        VarDeclarator,\n+    },\n     visit::{Visit, VisitWith},\n };\n \n@@ -34,18 +37,40 @@ impl Visit for Finder {\n         node.visit_children_with(self);\n     }\n \n+    fn visit_export_default_decl(&mut self, node: &ExportDefaultDecl) {\n+        let old = self.is_interested;\n+\n+        self.is_interested = true;\n+\n+        node.visit_children_with(self);\n+\n+        self.is_interested = old;\n+    }\n+\n+    fn visit_export_default_expr(&mut self, node: &ExportDefaultExpr) {\n+        let old = self.is_interested;\n+\n+        self.is_interested = true;\n+\n+        node.visit_children_with(self);\n+\n+        self.is_interested = old;\n+    }\n+\n     fn visit_expr(&mut self, node: &Expr) {\n         if self.found {\n             return;\n         }\n-        if matches!(\n-            node,\n-            Expr::JSXMember(..)\n-                | Expr::JSXNamespacedName(..)\n-                | Expr::JSXEmpty(..)\n-                | Expr::JSXElement(..)\n-                | Expr::JSXFragment(..)\n-        ) {\n+        if self.is_interested\n+            && matches!(\n+                node,\n+                Expr::JSXMember(..)\n+                    | Expr::JSXNamespacedName(..)\n+                    | Expr::JSXEmpty(..)\n+                    | Expr::JSXElement(..)\n+                    | Expr::JSXFragment(..)\n+            )\n+        {\n             self.found = true;\n             return;\n         }\n@@ -55,6 +80,7 @@ impl Visit for Finder {\n \n     fn visit_fn_decl(&mut self, node: &FnDecl) {\n         let old = self.is_interested;\n+\n         self.is_interested = node.ident.sym.starts_with(\"use\")\n             || node.ident.sym.starts_with(|c: char| c.is_ascii_uppercase());\n \n@@ -75,19 +101,6 @@ impl Visit for Finder {\n         self.is_interested = old;\n     }\n \n-    fn visit_return_stmt(&mut self, node: &ReturnStmt) {\n-        if self.is_interested {\n-            if let Some(Expr::JSXElement(..) | Expr::JSXEmpty(..) | Expr::JSXFragment(..)) =\n-                node.arg.as_deref()\n-            {\n-                self.found = true;\n-                return;\n-            }\n-        }\n-\n-        node.visit_children_with(self);\n-    }\n-\n     fn visit_stmt(&mut self, node: &Stmt) {\n         if self.found {\n             return;\n@@ -98,15 +111,172 @@ impl Visit for Finder {\n     fn visit_var_declarator(&mut self, node: &VarDeclarator) {\n         let old = self.is_interested;\n \n-        if let Pat::Ident(ident) = &node.name {\n-            self.is_interested = ident.sym.starts_with(\"use\")\n-                || ident.sym.starts_with(|c: char| c.is_ascii_uppercase());\n-        } else {\n-            self.is_interested = false;\n+        if matches!(node.init.as_deref(), Some(Expr::Fn(..) | Expr::Arrow(..))) {\n+            if let Pat::Ident(ident) = &node.name {\n+                self.is_interested = ident.sym.starts_with(\"use\")\n+                    || ident.sym.starts_with(|c: char| c.is_ascii_uppercase());\n+            } else {\n+                self.is_interested = false;\n+            }\n         }\n \n         node.visit_children_with(self);\n \n         self.is_interested = old;\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use swc_core::{\n+        common::FileName,\n+        ecma::parser::{parse_file_as_program, EsSyntax},\n+    };\n+    use testing::run_test2;\n+\n+    use super::*;\n+\n+    fn assert_required(code: &str, required: bool) {\n+        run_test2(false, |cm, _| {\n+            let fm = cm.new_source_file(FileName::Custom(\"test.tsx\".into()).into(), code.into());\n+\n+            let program = parse_file_as_program(\n+                &fm,\n+                swc_core::ecma::parser::Syntax::Es(EsSyntax {\n+                    jsx: true,\n+                    ..Default::default()\n+                }),\n+                Default::default(),\n+                Default::default(),\n+                &mut vec![],\n+            )\n+            .unwrap();\n+\n+            assert_eq!(is_required(&program), required);\n+\n+            Ok(())\n+        })\n+        .unwrap();\n+    }\n+\n+    #[test]\n+    fn lazy_return() {\n+        assert_required(\n+            \"\n+            function Foo() {\n+                const a = <div>Hello</div>;\n+\n+                return a\n+            }\n+            \",\n+            true,\n+        );\n+\n+        assert_required(\n+            \"\n+            function Foo() {\n+            \",\n+            false,\n+        );\n+    }\n+\n+    #[test]\n+    fn return_jsx() {\n+        assert_required(\n+            \"\n+            function Foo() {\n+                return <div>Hello</div>;\n+            }\n+            \",\n+            true,\n+        );\n+    }\n+\n+    #[test]\n+    fn use_hooks() {\n+        assert_required(\n+            \"\n+            function Foo(props) {\n+                const [a, b] = useState(0);\n+\n+                return props.children;\n+            }\n+            \",\n+            true,\n+        );\n+    }\n+\n+    #[test]\n+    fn arrow_function() {\n+        assert_required(\n+            \"\n+            const Foo = () => <div>Hello</div>;\n+            \",\n+            true,\n+        );\n+\n+        assert_required(\n+            \"\n+            const Foo = () => {\n+                return <div>Hello</div>;\n+            };\n+            \",\n+            true,\n+        );\n+    }\n+\n+    #[test]\n+    fn export_const_arrow_function() {\n+        assert_required(\n+            \"\n+            export const Foo = () => <div>Hello</div>;\n+            \",\n+            true,\n+        );\n+\n+        assert_required(\n+            \"\n+            export const Foo = () => {\n+                return <div>Hello</div>;\n+            };\n+            \",\n+            true,\n+        );\n+    }\n+\n+    #[test]\n+    fn normal_arrow_function() {\n+        assert_required(\n+            \"\n+            const Foo = () => {\n+                const a = 1;\n+                console.log(a);\n+            };\n+            \",\n+            false,\n+        );\n+    }\n+\n+    #[test]\n+    fn export_default_arrow_function() {\n+        assert_required(\n+            \"\n+            export default () => <div>Hello</div>;\n+            \",\n+            true,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_required_arrow_function() {\n+        assert_required(\n+            \"\n+            export default () => {\n+                const a = 1;\n+                console.log(a);\n+            };\n+            \",\n+            false,\n+        );\n+    }\n+}"
        }
    ],
    "stats": {
        "total": 224,
        "additions": 197,
        "deletions": 27
    }
}