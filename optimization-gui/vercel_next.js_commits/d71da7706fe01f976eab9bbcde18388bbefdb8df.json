{
    "author": "unstubbable",
    "message": "Ignore an existing HMR refresh hash cookie with `next start` (#77714)\n\nThis is a follow-up fix for #75474.\n\nWhen switching from `next dev` to `next start` locally, a user might\nhave an existing HMR refresh hash session cookie.\n\nWe need to make sure that the hash value is excluded from any `\"use\ncache\"` cache keys, when running with `next start`. Otherwise, the cache\nkeys will be different when prerendering vs. handling a dynamic request,\ne.g. when executing a server action.\n\nIn production, we now also omit the serialized `\"$undefined\"` value for\nthe HMR refresh hash from the cache keys to keep them shorter.",
    "sha": "d71da7706fe01f976eab9bbcde18388bbefdb8df",
    "files": [
        {
            "sha": "288e2ca84f671136fcad418b12d509976b3d45c5",
            "filename": "packages/next/src/server/app-render/work-unit-async-storage.external.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/d71da7706fe01f976eab9bbcde18388bbefdb8df/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d71da7706fe01f976eab9bbcde18388bbefdb8df/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts?ref=d71da7706fe01f976eab9bbcde18388bbefdb8df",
            "patch": "@@ -269,8 +269,13 @@ export function getRenderResumeDataCache(\n }\n \n export function getHmrRefreshHash(\n+  workStore: WorkStore,\n   workUnitStore: WorkUnitStore\n ): string | undefined {\n+  if (!workStore.dev) {\n+    return undefined\n+  }\n+\n   return workUnitStore.type === 'cache'\n     ? workUnitStore.hmrRefreshHash\n     : workUnitStore.type === 'request'"
        },
        {
            "sha": "a46932d5e1f011b78fef9815837e59f1f3840731",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 10,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/d71da7706fe01f976eab9bbcde18388bbefdb8df/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d71da7706fe01f976eab9bbcde18388bbefdb8df/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=d71da7706fe01f976eab9bbcde18388bbefdb8df",
            "patch": "@@ -53,12 +53,9 @@ import type { Params } from '../request/params'\n import React from 'react'\n import type { ImplicitTags } from '../lib/implicit-tags'\n \n-type CacheKeyParts = [\n-  buildId: string,\n-  hmrRefreshHash: string | undefined,\n-  id: string,\n-  args: unknown[],\n-]\n+type CacheKeyParts =\n+  | [buildId: string, id: string, args: unknown[]]\n+  | [buildId: string, id: string, args: unknown[], hmrRefreshHash: string]\n \n export interface UseCachePageComponentProps {\n   params: Promise<Params>\n@@ -162,7 +159,8 @@ function generateCacheEntryWithCacheContext(\n     explicitExpire: undefined,\n     explicitStale: undefined,\n     tags: null,\n-    hmrRefreshHash: outerWorkUnitStore && getHmrRefreshHash(outerWorkUnitStore),\n+    hmrRefreshHash:\n+      outerWorkUnitStore && getHmrRefreshHash(workStore, outerWorkUnitStore),\n     isHmrRefresh: useCacheOrRequestStore?.isHmrRefresh ?? false,\n     serverComponentsHmrCache: useCacheOrRequestStore?.serverComponentsHmrCache,\n     forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),\n@@ -309,7 +307,7 @@ async function generateCacheEntryImpl(\n ): Promise<[ReadableStream, Promise<CacheEntry>]> {\n   const temporaryReferences = createServerTemporaryReferenceSet()\n \n-  const [, , , args] =\n+  const [, , args] =\n     typeof encodedArguments === 'string'\n       ? await decodeReply<CacheKeyParts>(\n           encodedArguments,\n@@ -543,7 +541,8 @@ export function cache(\n       // components have been edited. This is a very coarse approach. But it's\n       // also only a temporary solution until Action IDs are unique per\n       // implementation. Remove this once Action IDs hash the implementation.\n-      const hmrRefreshHash = workUnitStore && getHmrRefreshHash(workUnitStore)\n+      const hmrRefreshHash =\n+        workUnitStore && getHmrRefreshHash(workStore, workUnitStore)\n \n       const hangingInputAbortSignal =\n         workUnitStore?.type === 'prerender'\n@@ -605,7 +604,11 @@ export function cache(\n       }\n \n       const temporaryReferences = createClientTemporaryReferenceSet()\n-      const cacheKeyParts: CacheKeyParts = [buildId, hmrRefreshHash, id, args]\n+\n+      const cacheKeyParts: CacheKeyParts = hmrRefreshHash\n+        ? [buildId, id, args, hmrRefreshHash]\n+        : [buildId, id, args]\n+\n       const encodedCacheKeyParts: FormData | string = await encodeReply(\n         cacheKeyParts,\n         { temporaryReferences, signal: hangingInputAbortSignal }"
        },
        {
            "sha": "ab8d2dc449440be7aa3437d653f1187a4c81efc1",
            "filename": "test/development/app-dir/use-cache-dev/app/page.tsx",
            "status": "removed",
            "additions": 0,
            "deletions": 28,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/ff4ee00adca2fd90a9e2a896bb18dfdf6e5bf5eb/test%2Fdevelopment%2Fapp-dir%2Fuse-cache-dev%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/ff4ee00adca2fd90a9e2a896bb18dfdf6e5bf5eb/test%2Fdevelopment%2Fapp-dir%2Fuse-cache-dev%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fuse-cache-dev%2Fapp%2Fpage.tsx?ref=ff4ee00adca2fd90a9e2a896bb18dfdf6e5bf5eb",
            "patch": "@@ -1,28 +0,0 @@\n-async function getRandomValue() {\n-  'use cache'\n-\n-  return Math.random()\n-}\n-\n-async function getData() {\n-  'use cache'\n-\n-  return fetch('https://next-data-api-endpoint.vercel.app/api/random').then(\n-    (res) =>\n-      res\n-        .text()\n-        .then(async (text) => [text, 'foo', await getRandomValue()] as const)\n-  )\n-}\n-\n-export default async function Page() {\n-  const [fetchedRandom, text, mathRandom] = await getData()\n-\n-  return (\n-    <div id=\"container\">\n-      <p id=\"fetchedRandom\">{fetchedRandom}</p>\n-      <p id=\"text\">{text}</p>\n-      <p id=\"mathRandom\">{mathRandom}</p>\n-    </div>\n-  )\n-}"
        },
        {
            "sha": "6c349bbb74504fcd66b2a3554437d470bcd409de",
            "filename": "test/development/app-dir/use-cache-dev/use-cache-dev.test.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 160,
            "changes": 160,
            "blob_url": "https://github.com/vercel/next.js/blob/ff4ee00adca2fd90a9e2a896bb18dfdf6e5bf5eb/test%2Fdevelopment%2Fapp-dir%2Fuse-cache-dev%2Fuse-cache-dev.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/ff4ee00adca2fd90a9e2a896bb18dfdf6e5bf5eb/test%2Fdevelopment%2Fapp-dir%2Fuse-cache-dev%2Fuse-cache-dev.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fuse-cache-dev%2Fuse-cache-dev.test.ts?ref=ff4ee00adca2fd90a9e2a896bb18dfdf6e5bf5eb",
            "patch": "@@ -1,160 +0,0 @@\n-import { nextTestSetup } from 'e2e-utils'\n-import { retry } from 'next-test-utils'\n-\n-describe('use-cache-dev', () => {\n-  const { next, isTurbopack } = nextTestSetup({\n-    files: __dirname,\n-  })\n-\n-  it('should update cached data after editing a file', async () => {\n-    const browser = await next.browser('/')\n-\n-    const [initialFetchedRandom, initialText, initialMathRandom] =\n-      await Promise.all([\n-        browser.elementById('fetchedRandom').text(),\n-        browser.elementById('text').text(),\n-        browser.elementById('mathRandom').text(),\n-      ])\n-\n-    expect(initialFetchedRandom).toMatch(/[0,1]\\.\\d+/)\n-    expect(initialText).toBe('foo')\n-    expect(initialMathRandom).toMatch(/[0,1]\\.\\d+/)\n-\n-    // Edit something inside of \"use cache\" in the page.tsx file.\n-    await next.patchFile('app/page.tsx', (content) =>\n-      content.replace('foo', 'bar')\n-    )\n-\n-    let newFetchedRandom: string\n-    let newText: string\n-    let newMathRandom: string\n-\n-    await retry(async () => {\n-      ;[newFetchedRandom, newText, newMathRandom] = await Promise.all([\n-        browser.elementById('fetchedRandom').text(),\n-        browser.elementById('text').text(),\n-        browser.elementById('mathRandom').text(),\n-      ])\n-\n-      // Cached via server components HMR cache:\n-      expect(newFetchedRandom).toBe(initialFetchedRandom)\n-\n-      // Edited value:\n-      expect(newText).toBe('bar')\n-\n-      // Newly computed value due to cache miss.\n-      expect(newMathRandom).not.toBe(initialMathRandom)\n-      expect(newMathRandom).toMatch(/[0,1]\\.\\d+/)\n-    })\n-\n-    // Now revert the edit.\n-    await next.patchFile('app/page.tsx', (content) =>\n-      content.replace('bar', 'foo')\n-    )\n-\n-    await retry(async () => {\n-      const [fetchedRandom, text, mathRandom] = await Promise.all([\n-        browser.elementById('fetchedRandom').text(),\n-        browser.elementById('text').text(),\n-        browser.elementById('mathRandom').text(),\n-      ])\n-\n-      // Cached via server components HMR cache:\n-      expect(fetchedRandom).toBe(initialFetchedRandom)\n-\n-      // Edited value:\n-      expect(text).toBe(initialText)\n-\n-      // Newly computed value due to cache miss, because the initial request did\n-      // not use an HMR hash for the cache key.\n-      // TODO: Can we get a cache hit here? It's a micro optimization though.\n-      expect(mathRandom).not.toBe(initialFetchedRandom)\n-      expect(mathRandom).not.toBe(newMathRandom)\n-      expect(mathRandom).toMatch(/[0,1]\\.\\d+/)\n-    })\n-\n-    // Apply the initial edit again.\n-    await next.patchFile(\n-      'app/page.tsx',\n-      (content) => content.replace('foo', 'bar'),\n-      async () =>\n-        retry(async () => {\n-          const [fetchedRandom, text, mathRandom] = await Promise.all([\n-            browser.elementById('fetchedRandom').text(),\n-            browser.elementById('text').text(),\n-            browser.elementById('mathRandom').text(),\n-          ])\n-\n-          // This should be a full cache hit now:\n-          expect(fetchedRandom).toBe(newFetchedRandom)\n-          expect(text).toBe(newText)\n-\n-          if (isTurbopack) {\n-            // TODO: Turbopack does not provide content hashes during HMR, so we\n-            // actually get a cache miss. However, fetchedRandom is still cached\n-            // because of the server components HMR cache.\n-            expect(mathRandom).not.toBe(newMathRandom)\n-            expect(mathRandom).toMatch(/[0,1]\\.\\d+/)\n-          } else {\n-            expect(mathRandom).toBe(newMathRandom)\n-          }\n-        })\n-    )\n-  })\n-\n-  it('should return cached data after reload', async () => {\n-    let $ = await next.render$('/')\n-    const initialContent = $('#container').text()\n-    $ = await next.render$('/')\n-    const content = $('#container').text()\n-\n-    expect(content).toEqual(initialContent)\n-  })\n-\n-  it('should return fresh data after hard reload', async () => {\n-    let $ = await next.render$('/')\n-    const initialContent = $('#container').text()\n-\n-    $ = await next.render$(\n-      '/',\n-      {},\n-      { headers: { 'cache-control': 'no-cache' } }\n-    )\n-\n-    const hardReloadContent = $('#container').text()\n-\n-    expect(hardReloadContent).not.toEqual(initialContent)\n-\n-    // After a subsequent soft reload, cached data from the hard reload should\n-    // be returned.\n-\n-    const softReloadContent = $('#container').text()\n-\n-    expect(softReloadContent).toEqual(hardReloadContent)\n-  })\n-\n-  it('should successfully finish compilation when \"use cache\" directive is added/removed', async () => {\n-    await next.browser('/')\n-    let cliOutputLength = next.cliOutput.length\n-\n-    // Disable \"use cache\" directive\n-    await next.patchFile('app/page.tsx', (content) =>\n-      content.replace(`'use cache'`, `// 'use cache'`)\n-    )\n-\n-    await retry(async () => {\n-      expect(next.cliOutput.slice(cliOutputLength)).toInclude('✓ Compiled')\n-    }, 10_000)\n-\n-    cliOutputLength = next.cliOutput.length\n-\n-    // Re-enable \"use cache\" directive\n-    await next.patchFile('app/page.tsx', (content) =>\n-      content.replace(`// 'use cache'`, `'use cache'`)\n-    )\n-\n-    await retry(async () => {\n-      expect(next.cliOutput.slice(cliOutputLength)).toInclude('✓ Compiled')\n-    }, 10_000)\n-  })\n-})"
        },
        {
            "sha": "37779995c26f0e0cd922a54f992f86db685c00ef",
            "filename": "test/e2e/app-dir/use-cache-custom-handler/use-cache-custom-handler.test.ts",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/d71da7706fe01f976eab9bbcde18388bbefdb8df/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fuse-cache-custom-handler.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d71da7706fe01f976eab9bbcde18388bbefdb8df/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fuse-cache-custom-handler.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-custom-handler%2Fuse-cache-custom-handler.test.ts?ref=d71da7706fe01f976eab9bbcde18388bbefdb8df",
            "patch": "@@ -32,11 +32,11 @@ describe('use-cache-custom-handler', () => {\n     )\n \n     expect(next.cliOutput.slice(outputIndex)).toMatch(\n-      /ModernCustomCacheHandler::get \\[\"(development|[A-Za-z0-9_-]{21})\",\"\\$undefined\",\"([0-9a-f]{2})+\",\\[\\]\\]/\n+      /ModernCustomCacheHandler::get \\[\"(development|[A-Za-z0-9_-]{21})\",\"([0-9a-f]{2})+\",\\[\\]\\]/\n     )\n \n     expect(next.cliOutput.slice(outputIndex)).toMatch(\n-      /ModernCustomCacheHandler::set \\[\"(development|[A-Za-z0-9_-]{21})\",\"\\$undefined\",\"([0-9a-f]{2})+\",\\[\\]\\]/\n+      /ModernCustomCacheHandler::set \\[\"(development|[A-Za-z0-9_-]{21})\",\"([0-9a-f]{2})+\",\\[\\]\\]/\n     )\n \n     // The data should be cached initially.\n@@ -67,11 +67,11 @@ describe('use-cache-custom-handler', () => {\n     )\n \n     expect(next.cliOutput.slice(outputIndex)).toMatch(\n-      /LegacyCustomCacheHandler::get \\[\"(development|[A-Za-z0-9_-]{21})\",\"\\$undefined\",\"([0-9a-f]{2})+\",\\[\\]\\] \\[\"_N_T_\\/layout\",\"_N_T_\\/legacy\\/layout\",\"_N_T_\\/legacy\\/page\",\"_N_T_\\/legacy\"\\]/\n+      /LegacyCustomCacheHandler::get \\[\"(development|[A-Za-z0-9_-]{21})\",\"([0-9a-f]{2})+\",\\[\\]\\] \\[\"_N_T_\\/layout\",\"_N_T_\\/legacy\\/layout\",\"_N_T_\\/legacy\\/page\",\"_N_T_\\/legacy\"\\]/\n     )\n \n     expect(next.cliOutput.slice(outputIndex)).toMatch(\n-      /LegacyCustomCacheHandler::set \\[\"(development|[A-Za-z0-9_-]{21})\",\"\\$undefined\",\"([0-9a-f]{2})+\",\\[\\]\\]/\n+      /LegacyCustomCacheHandler::set \\[\"(development|[A-Za-z0-9_-]{21})\",\"([0-9a-f]{2})+\",\\[\\]\\]/\n     )\n \n     // The data should be cached initially."
        },
        {
            "sha": "888614deda3ba5d744d1a7e5dac131038dba2b12",
            "filename": "test/e2e/app-dir/use-cache-dev/app/layout.tsx",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/d71da7706fe01f976eab9bbcde18388bbefdb8df/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d71da7706fe01f976eab9bbcde18388bbefdb8df/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fapp%2Flayout.tsx?ref=d71da7706fe01f976eab9bbcde18388bbefdb8df",
            "previous_filename": "test/development/app-dir/use-cache-dev/app/layout.tsx"
        },
        {
            "sha": "adefe9cb4f7754956817bb47359c371f148b9fea",
            "filename": "test/e2e/app-dir/use-cache-dev/app/page.tsx",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/d71da7706fe01f976eab9bbcde18388bbefdb8df/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/d71da7706fe01f976eab9bbcde18388bbefdb8df/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fapp%2Fpage.tsx?ref=d71da7706fe01f976eab9bbcde18388bbefdb8df",
            "patch": "@@ -0,0 +1,41 @@\n+import { revalidatePath } from 'next/cache'\n+\n+async function getRandomValue() {\n+  'use cache'\n+\n+  return Math.random()\n+}\n+\n+async function getData() {\n+  'use cache'\n+\n+  return fetch('https://next-data-api-endpoint.vercel.app/api/random').then(\n+    (res) =>\n+      res\n+        .text()\n+        .then(async (text) => [text, 'foo', await getRandomValue()] as const)\n+  )\n+}\n+\n+export default async function Page() {\n+  const [fetchedRandom, text, mathRandom] = await getData()\n+\n+  return (\n+    <>\n+      <div id=\"container\">\n+        <p id=\"fetchedRandom\">{fetchedRandom}</p>\n+        <p id=\"text\">{text}</p>\n+        <p id=\"mathRandom\">{mathRandom}</p>\n+      </div>\n+      <p id=\"uncached\">{new Date().toISOString()}</p>\n+      <form\n+        action={async () => {\n+          'use server'\n+          revalidatePath('/')\n+        }}\n+      >\n+        <button id=\"revalidate\">Revalidate</button>\n+      </form>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "441c4c002a6b3655ebe666305af57e553cc5df7e",
            "filename": "test/e2e/app-dir/use-cache-dev/next.config.js",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/d71da7706fe01f976eab9bbcde18388bbefdb8df/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/d71da7706fe01f976eab9bbcde18388bbefdb8df/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fnext.config.js?ref=d71da7706fe01f976eab9bbcde18388bbefdb8df",
            "previous_filename": "test/development/app-dir/use-cache-dev/next.config.js"
        },
        {
            "sha": "dd0ad36846317d92768b098f9db5992dd904b082",
            "filename": "test/e2e/app-dir/use-cache-dev/use-cache-dev.test.ts",
            "status": "added",
            "additions": 219,
            "deletions": 0,
            "changes": 219,
            "blob_url": "https://github.com/vercel/next.js/blob/d71da7706fe01f976eab9bbcde18388bbefdb8df/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fuse-cache-dev.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d71da7706fe01f976eab9bbcde18388bbefdb8df/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fuse-cache-dev.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fuse-cache-dev%2Fuse-cache-dev.test.ts?ref=d71da7706fe01f976eab9bbcde18388bbefdb8df",
            "patch": "@@ -0,0 +1,219 @@\n+import { nextTestSetup } from 'e2e-utils'\n+import { retry } from 'next-test-utils'\n+\n+describe('use-cache-dev', () => {\n+  const { next, skipped, isNextDev, isTurbopack } = nextTestSetup({\n+    files: __dirname,\n+    skipDeployment: true,\n+  })\n+\n+  if (skipped) {\n+    return\n+  }\n+\n+  if (isNextDev) {\n+    it('should update cached data after editing a file', async () => {\n+      const browser = await next.browser('/')\n+\n+      const [initialFetchedRandom, initialText, initialMathRandom] =\n+        await Promise.all([\n+          browser.elementById('fetchedRandom').text(),\n+          browser.elementById('text').text(),\n+          browser.elementById('mathRandom').text(),\n+        ])\n+\n+      expect(initialFetchedRandom).toMatch(/[0,1]\\.\\d+/)\n+      expect(initialText).toBe('foo')\n+      expect(initialMathRandom).toMatch(/[0,1]\\.\\d+/)\n+\n+      // Edit something inside of \"use cache\" in the page.tsx file.\n+      await next.patchFile('app/page.tsx', (content) =>\n+        content.replace('foo', 'bar')\n+      )\n+\n+      let newFetchedRandom: string\n+      let newText: string\n+      let newMathRandom: string\n+\n+      await retry(async () => {\n+        ;[newFetchedRandom, newText, newMathRandom] = await Promise.all([\n+          browser.elementById('fetchedRandom').text(),\n+          browser.elementById('text').text(),\n+          browser.elementById('mathRandom').text(),\n+        ])\n+\n+        // Cached via server components HMR cache:\n+        expect(newFetchedRandom).toBe(initialFetchedRandom)\n+\n+        // Edited value:\n+        expect(newText).toBe('bar')\n+\n+        // Newly computed value due to cache miss.\n+        expect(newMathRandom).not.toBe(initialMathRandom)\n+        expect(newMathRandom).toMatch(/[0,1]\\.\\d+/)\n+      })\n+\n+      // Now revert the edit.\n+      await next.patchFile('app/page.tsx', (content) =>\n+        content.replace('bar', 'foo')\n+      )\n+\n+      await retry(async () => {\n+        const [fetchedRandom, text, mathRandom] = await Promise.all([\n+          browser.elementById('fetchedRandom').text(),\n+          browser.elementById('text').text(),\n+          browser.elementById('mathRandom').text(),\n+        ])\n+\n+        // Cached via server components HMR cache:\n+        expect(fetchedRandom).toBe(initialFetchedRandom)\n+\n+        // Edited value:\n+        expect(text).toBe(initialText)\n+\n+        // Newly computed value due to cache miss, because the initial request did\n+        // not use an HMR hash for the cache key.\n+        // TODO: Can we get a cache hit here? It's a micro optimization though.\n+        expect(mathRandom).not.toBe(initialFetchedRandom)\n+        expect(mathRandom).not.toBe(newMathRandom)\n+        expect(mathRandom).toMatch(/[0,1]\\.\\d+/)\n+      })\n+\n+      // Apply the initial edit again.\n+      await next.patchFile(\n+        'app/page.tsx',\n+        (content) => content.replace('foo', 'bar'),\n+        async () =>\n+          retry(async () => {\n+            const [fetchedRandom, text, mathRandom] = await Promise.all([\n+              browser.elementById('fetchedRandom').text(),\n+              browser.elementById('text').text(),\n+              browser.elementById('mathRandom').text(),\n+            ])\n+\n+            // This should be a full cache hit now:\n+            expect(fetchedRandom).toBe(newFetchedRandom)\n+            expect(text).toBe(newText)\n+\n+            if (isTurbopack) {\n+              // TODO: Turbopack does not provide content hashes during HMR, so we\n+              // actually get a cache miss. However, fetchedRandom is still cached\n+              // because of the server components HMR cache.\n+              expect(mathRandom).not.toBe(newMathRandom)\n+              expect(mathRandom).toMatch(/[0,1]\\.\\d+/)\n+            } else {\n+              expect(mathRandom).toBe(newMathRandom)\n+            }\n+          })\n+      )\n+    })\n+\n+    it('should return cached data after reload', async () => {\n+      let $ = await next.render$('/')\n+      const initialContent = $('#container').text()\n+      $ = await next.render$('/')\n+      const content = $('#container').text()\n+\n+      expect(content).toEqual(initialContent)\n+    })\n+\n+    it('should return fresh data after hard reload', async () => {\n+      let $ = await next.render$('/')\n+      const initialContent = $('#container').text()\n+\n+      $ = await next.render$(\n+        '/',\n+        {},\n+        { headers: { 'cache-control': 'no-cache' } }\n+      )\n+\n+      const hardReloadContent = $('#container').text()\n+\n+      expect(hardReloadContent).not.toEqual(initialContent)\n+\n+      // After a subsequent soft reload, cached data from the hard reload should\n+      // be returned.\n+\n+      const softReloadContent = $('#container').text()\n+\n+      expect(softReloadContent).toEqual(hardReloadContent)\n+    })\n+\n+    it('should successfully finish compilation when \"use cache\" directive is added/removed', async () => {\n+      await next.browser('/')\n+      let cliOutputLength = next.cliOutput.length\n+\n+      // Disable \"use cache\" directive\n+      await next.patchFile('app/page.tsx', (content) =>\n+        content.replace(`'use cache'`, `// 'use cache'`)\n+      )\n+\n+      await retry(async () => {\n+        expect(next.cliOutput.slice(cliOutputLength)).toInclude('✓ Compiled')\n+      }, 10_000)\n+\n+      cliOutputLength = next.cliOutput.length\n+\n+      // Re-enable \"use cache\" directive\n+      await next.patchFile('app/page.tsx', (content) =>\n+        content.replace(`// 'use cache'`, `'use cache'`)\n+      )\n+\n+      await retry(async () => {\n+        expect(next.cliOutput.slice(cliOutputLength)).toInclude('✓ Compiled')\n+      }, 10_000)\n+    })\n+  } else {\n+    it('should ignore an existing HMR refresh hash cookie with \"next start\"', async () => {\n+      const browser = await next.browser('/')\n+\n+      const [initialFetchedRandom, initialMathRandom] = await Promise.all([\n+        browser.elementById('fetchedRandom').text(),\n+        browser.elementById('mathRandom').text(),\n+      ])\n+\n+      await browser.addCookie({\n+        name: '__next_hmr_refresh_hash__',\n+        value: 'test',\n+      })\n+\n+      // First, revalidate the prerendered page with a server action. This uses\n+      // a request work unit store, so the HMR refresh cookie is available.\n+\n+      await browser.elementById('revalidate').click()\n+\n+      let revalidatedFetchedRandom: string\n+      let revalidatedMathRandom: string\n+\n+      await retry(async () => {\n+        ;[revalidatedFetchedRandom, revalidatedMathRandom] = await Promise.all([\n+          browser.elementById('fetchedRandom').text(),\n+          browser.elementById('mathRandom').text(),\n+        ])\n+\n+        expect(revalidatedFetchedRandom).not.toBe(initialFetchedRandom)\n+        expect(revalidatedMathRandom).not.toBe(initialMathRandom)\n+      })\n+\n+      let initialUncached = await browser.elementById('uncached').text()\n+\n+      // Now refresh the page. Due to the prior revalidation it will be a cache\n+      // miss, and the page will be prerendered. This uses a prerender work unit\n+      // store, so the HMR refresh cookie is not available.\n+\n+      await browser.refresh()\n+\n+      await retry(async () => {\n+        const [fetchedRandom, mathRandom, uncached] = await Promise.all([\n+          browser.elementById('fetchedRandom').text(),\n+          browser.elementById('mathRandom').text(),\n+          browser.elementById('uncached').text(),\n+        ])\n+\n+        expect(uncached).not.toBe(initialUncached)\n+        expect(fetchedRandom).toBe(revalidatedFetchedRandom)\n+        expect(mathRandom).toBe(revalidatedMathRandom)\n+      })\n+    })\n+  }\n+})"
        }
    ],
    "stats": {
        "total": 484,
        "additions": 282,
        "deletions": 202
    }
}