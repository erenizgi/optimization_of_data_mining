{
    "author": "sokra",
    "message": "Turbopack: fix and finish immutable tasks (#80996)\n\n### What?\n\nFixes the problems with the implementation of immutable tasks, adds tests and debug asserts to ensure it's working.\n\n* There was some confusion between children and dependencies. Children are not involved with immutablility, only dependencies are.\n* Opt out of immutablility for reading collectibles and for getting an invalidator.\n* Removed `#[turbo_tasks::function(invalidator)]` and the logic of discovering statically immutable with macro code. It won't work as local tasks are invisible and can cause dependencies\n\n\nFollow-up changes:\n* Technically immutability could be per cell instead of per task. A task produces immutable cells until it does something that depends on mutable cells or other opt-outs. It could be `RawVc::ImmutableCell` and the immutable flag would be only in `InProgressState` and not on a task.",
    "sha": "5dac44820cdb54bcffeb31fdf534bed75db93649",
    "files": [
        {
            "sha": "34abe45520332a53bda1e54c36aff4798dd1b52e",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -431,7 +431,7 @@ impl ProjectContainer {\n \n #[turbo_tasks::value_impl]\n impl ProjectContainer {\n-    #[turbo_tasks::function(invalidator)]\n+    #[turbo_tasks::function]\n     pub async fn project(&self) -> Result<Vc<Project>> {\n         let env_map: Vc<EnvMap>;\n         let next_config;"
        },
        {
            "sha": "9cf6be646e67a78db75fb04d5763d1f37315ca18",
            "filename": "crates/next-api/src/versioned_content_map.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/crates%2Fnext-api%2Fsrc%2Fversioned_content_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/crates%2Fnext-api%2Fsrc%2Fversioned_content_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fversioned_content_map.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -213,7 +213,7 @@ impl VersionedContentMap {\n         Ok(Vc::cell(None))\n     }\n \n-    #[turbo_tasks::function(invalidator)]\n+    #[turbo_tasks::function]\n     pub async fn keys_in_path(&self, root: FileSystemPath) -> Result<Vc<Vec<RcStr>>> {\n         let keys = {\n             let map = &self.map_path_to_op.get().0;\n@@ -230,7 +230,7 @@ impl VersionedContentMap {\n         Ok(Vc::cell(keys))\n     }\n \n-    #[turbo_tasks::function(invalidator)]\n+    #[turbo_tasks::function]\n     fn raw_get(&self, path: FileSystemPath) -> Vc<OptionMapEntry> {\n         let assets = {\n             let map = &self.map_path_to_op.get().0;"
        },
        {
            "sha": "8c68589ecef84e8f8ed2d955a3b9717c76eb5081",
            "filename": "packages/next/src/build/swc/generated-native.d.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fswc%2Fgenerated-native.d.ts?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -107,7 +107,7 @@ export interface NapiProjectOptions {\n   /** A path inside the root_path which contains the app/pages directories. */\n   projectPath: RcStr\n   /**\n-   * next.config's distDir. Project initialization occurs eariler than\n+   * next.config's distDir. Project initialization occurs earlier than\n    * deserializing next.config, so passing it as separate option.\n    */\n   distDir: RcStr\n@@ -153,7 +153,7 @@ export interface NapiPartialProjectOptions {\n   /** A path inside the root_path which contains the app/pages directories. */\n   projectPath?: RcStr\n   /**\n-   * next.config's distDir. Project initialization occurs eariler than\n+   * next.config's distDir. Project initialization occurs earlier than\n    * deserializing next.config, so passing it as separate option.\n    */\n   distDir?: RcStr | undefined | null"
        },
        {
            "sha": "7f0a9f0992aafba53dd8d3249cf72e3e043243e2",
            "filename": "turbopack/crates/turbo-tasks-backend/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2FCargo.toml?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -17,6 +17,7 @@ default = []\n print_cache_item_size = []\n verify_serialization = []\n verify_aggregation_graph = []\n+verify_immutable = []\n trace_aggregation_update = []\n trace_find_and_schedule = []\n trace_task_completion = []"
        },
        {
            "sha": "a372637b46451b7146e138735e45264d8e8ab2f5",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 80,
            "deletions": 48,
            "changes": 128,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -23,6 +23,7 @@ use parking_lot::{Condvar, Mutex};\n use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n use smallvec::{SmallVec, smallvec};\n use tokio::time::{Duration, Instant};\n+use tracing::field::Empty;\n use turbo_tasks::{\n     CellId, FxDashMap, KeyValuePair, RawVc, ReadCellOptions, ReadConsistency, SessionId,\n     TRANSIENT_TASK_BIT, TaskExecutionReason, TaskId, TraitTypeId, TurboTasksBackendApi,\n@@ -52,7 +53,7 @@ use crate::{\n             is_root_node, prepare_new_children,\n         },\n         storage::{\n-            InnerStorageSnapshot, Storage, get, get_many, get_mut, get_mut_or_insert_with,\n+            InnerStorageSnapshot, Storage, count, get, get_many, get_mut, get_mut_or_insert_with,\n             iter_many, remove,\n         },\n     },\n@@ -413,10 +414,9 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         tx: Option<&'l B::ReadTransaction<'tx>>,\n         parent_task: TaskId,\n         child_task: TaskId,\n-        is_immutable: bool,\n         turbo_tasks: &'l dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n-        operation::ConnectChildOperation::run(parent_task, child_task, is_immutable, unsafe {\n+        operation::ConnectChildOperation::run(parent_task, child_task, unsafe {\n             self.execute_context_with_tx(tx, turbo_tasks)\n         });\n     }\n@@ -425,13 +425,11 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         &self,\n         parent_task: TaskId,\n         child_task: TaskId,\n-        is_immutable: bool,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n         operation::ConnectChildOperation::run(\n             parent_task,\n             child_task,\n-            is_immutable,\n             self.execute_context(turbo_tasks),\n         );\n     }\n@@ -591,6 +589,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             };\n             if self.should_track_dependencies()\n                 && let Some(reader) = reader\n+                && (!task.is_immutable() || cfg!(feature = \"verify_immutable\"))\n             {\n                 let _ = task.add(CachedDataItem::OutputDependent {\n                     task: reader,\n@@ -656,15 +655,13 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             task_id: TaskId,\n             ctx: &mut impl ExecuteContext<'_>,\n         ) {\n-            if !backend.should_track_dependencies() {\n-                return;\n-            }\n-            if let Some(reader) = reader {\n-                if reader == task_id {\n-                    // We never want to have a dependency on ourselves, otherwise we end up in a\n-                    // loop of re-executing the same task.\n-                    return;\n-                }\n+            if backend.should_track_dependencies()\n+                && let Some(reader) = reader\n+                // We never want to have a dependency on ourselves, otherwise we end up in a\n+                // loop of re-executing the same task.\n+                && reader != task_id\n+                && (!task.is_immutable() || cfg!(feature = \"verify_immutable\"))\n+            {\n                 let _ = task.add(CachedDataItem::CellDependent {\n                     cell,\n                     task: reader,\n@@ -1153,12 +1150,11 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         &self,\n         task_type: CachedTaskType,\n         parent_task: TaskId,\n-        is_immutable: bool,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> TaskId {\n         if let Some(task_id) = self.task_cache.lookup_forward(&task_type) {\n             self.track_cache_hit(&task_type);\n-            self.connect_child(parent_task, task_id, is_immutable, turbo_tasks);\n+            self.connect_child(parent_task, task_id, turbo_tasks);\n             return task_id;\n         }\n \n@@ -1198,9 +1194,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         };\n \n         // Safety: `tx` is a valid transaction from `self.backend.backing_storage`.\n-        unsafe {\n-            self.connect_child_with_tx(tx.as_ref(), parent_task, task_id, is_immutable, turbo_tasks)\n-        };\n+        unsafe { self.connect_child_with_tx(tx.as_ref(), parent_task, task_id, turbo_tasks) };\n \n         task_id\n     }\n@@ -1209,7 +1203,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         &self,\n         task_type: CachedTaskType,\n         parent_task: TaskId,\n-        is_immutable: bool,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> TaskId {\n         if !parent_task.is_transient() {\n@@ -1221,7 +1214,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         }\n         if let Some(task_id) = self.task_cache.lookup_forward(&task_type) {\n             self.track_cache_hit(&task_type);\n-            self.connect_child(parent_task, task_id, is_immutable, turbo_tasks);\n+            self.connect_child(parent_task, task_id, turbo_tasks);\n             return task_id;\n         }\n \n@@ -1233,11 +1226,11 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             unsafe {\n                 self.transient_task_id_factory.reuse(task_id);\n             }\n-            self.connect_child(parent_task, existing_task_id, is_immutable, turbo_tasks);\n+            self.connect_child(parent_task, existing_task_id, turbo_tasks);\n             return existing_task_id;\n         }\n \n-        self.connect_child(parent_task, task_id, is_immutable, turbo_tasks);\n+        self.connect_child(parent_task, task_id, turbo_tasks);\n \n         task_id\n     }\n@@ -1580,6 +1573,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         _memory_usage: usize,\n         cell_counters: &AutoMap<ValueTypeId, u32, BuildHasherDefault<FxHasher>, 8>,\n         stateful: bool,\n+        has_invalidator: bool,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> bool {\n         // Task completion is a 4 step process:\n@@ -1596,7 +1590,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         // The task might be invalidated during this process, so we need to change the stale flag\n         // at the start of every step.\n \n-        let _span = tracing::trace_span!(\"task execution completed\").entered();\n+        let span = tracing::trace_span!(\"task execution completed\", immutable = Empty).entered();\n         let mut ctx = self.execute_context(turbo_tasks);\n \n         //// STEP 1 ////\n@@ -1610,6 +1604,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             ref mut done,\n             ref done_event,\n             ref mut new_children,\n+            session_dependent,\n             ..\n         }) = in_progress\n         else {\n@@ -1643,7 +1638,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             // new_children list now.\n             AggregationUpdateQueue::run(\n                 AggregationUpdateJob::DecreaseActiveCounts {\n-                    task_ids: new_children.into_keys().collect(),\n+                    task_ids: new_children.into_iter().collect(),\n                 },\n                 &mut ctx,\n             );\n@@ -1662,6 +1657,11 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             let _ = task.add(CachedDataItem::Stateful { value: () });\n         }\n \n+        // handle has_invalidator\n+        if has_invalidator {\n+            let _ = task.add(CachedDataItem::HasInvalidator { value: () });\n+        }\n+\n         // handle cell counters: update max index and remove cells that are no longer used\n         let old_counters: FxHashMap<_, _> =\n             get_many!(task, CellTypeMaxIndex { cell_type } max_index => (cell_type, *max_index));\n@@ -1691,14 +1691,28 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         let mut old_edges = Vec::new();\n \n         let has_children = !new_children.is_empty();\n-        let has_mutable_children =\n-            has_children && new_children.values().any(|is_immutable| !*is_immutable);\n-\n-        // If the task is not stateful and has no mutable children, it does not have a way to be\n-        // invalidated and we can mark it as immutable.\n-        if !stateful && !has_mutable_children {\n-            task.mark_as_immutable();\n-        }\n+        let is_immutable = task.is_immutable();\n+        let task_dependencies_for_immutable =\n+            // Task was previously marked as immutable\n+            if !is_immutable\n+            // Task is not session dependent (session dependent tasks can change between sessions)\n+            && !session_dependent\n+            // Task has no invalidator\n+            && !task.has_key(&CachedDataItemKey::HasInvalidator {})\n+            // This is a hack for the streaming hack.\n+            && !task.has_key(&CachedDataItemKey::Stateful {})\n+            // Task has no dependencies on collectibles\n+            && count!(task, CollectiblesDependency) == 0\n+        {\n+            Some(\n+                // Collect all dependencies on tasks to check if all dependencies are immutable\n+                iter_many!(task, OutputDependency { target } => target)\n+                    .chain(iter_many!(task, CellDependency { target } => target.task))\n+                    .collect::<FxHashSet<_>>(),\n+            )\n+        } else {\n+            None\n+        };\n \n         // Prepare all new children\n         if has_children {\n@@ -1709,7 +1723,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         if has_children {\n             old_edges.extend(\n                 iter_many!(task, Child { task } => task)\n-                    .filter(|task| new_children.remove(task).is_none())\n+                    .filter(|task| !new_children.remove(task))\n                     .map(OutdatedEdge::Child),\n             );\n         } else {\n@@ -1740,7 +1754,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     }),\n             );\n         }\n-        if !task.is_immutable() && self.should_track_dependencies() {\n+        if self.should_track_dependencies() {\n             old_edges.extend(iter_many!(task, OutdatedCellDependency { target } => OutdatedEdge::CellDependency(target)));\n             old_edges.extend(iter_many!(task, OutdatedOutputDependency { target } => OutdatedEdge::OutputDependency(target)));\n             old_edges.extend(\n@@ -1766,6 +1780,17 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         drop(task);\n \n+        // Check if the task can be marked as immutable\n+        let mut is_now_immutable = false;\n+        if let Some(dependencies) = task_dependencies_for_immutable\n+            && dependencies\n+                .iter()\n+                .all(|&task_id| ctx.task(task_id, TaskDataCategory::Data).is_immutable())\n+        {\n+            is_now_immutable = true;\n+        }\n+        span.record(\"immutable\", is_immutable || is_now_immutable);\n+\n         if !queue.is_empty() || !old_edges.is_empty() {\n             #[cfg(feature = \"trace_task_completion\")]\n             let _span = tracing::trace_span!(\"remove old edges and prepare new children\").entered();\n@@ -1809,27 +1834,31 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             // that. (We already filtered out the old children from that list)\n             AggregationUpdateQueue::run(\n                 AggregationUpdateJob::DecreaseActiveCounts {\n-                    task_ids: new_children.into_keys().collect(),\n+                    task_ids: new_children.into_iter().collect(),\n                 },\n                 &mut ctx,\n             );\n             return true;\n         }\n \n+        // If the task is not stateful and has no mutable children, it does not have a way to be\n+        // invalidated and we can mark it as immutable.\n+        if is_now_immutable {\n+            let _ = task.add(CachedDataItem::Immutable { value: () });\n+        }\n+\n         let mut queue = AggregationUpdateQueue::new();\n \n         if has_children {\n-            let is_immutable = task.is_immutable();\n-            let has_active_count = !is_immutable\n-                && ctx.should_track_activeness()\n+            let has_active_count = ctx.should_track_activeness()\n                 && get!(task, Activeness).map_or(false, |activeness| activeness.active_counter > 0);\n             connect_children(\n                 task_id,\n                 &mut task,\n                 new_children,\n                 &mut queue,\n                 has_active_count,\n-                !is_immutable && ctx.should_track_activeness(),\n+                ctx.should_track_activeness(),\n             );\n         }\n \n@@ -2130,8 +2159,11 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 task: task_id,\n                 collectible_type,\n             };\n-            if reader.add(CachedDataItem::CollectiblesDependency { target, value: () }) {\n-                reader.remove(&CachedDataItemKey::OutdatedCollectiblesDependency { target });\n+            if reader\n+                .remove(&CachedDataItemKey::OutdatedCollectiblesDependency { target })\n+                .is_none()\n+            {\n+                let _ = reader.add(CachedDataItem::CollectiblesDependency { target, value: () });\n             }\n         }\n         collectibles\n@@ -2293,7 +2325,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) {\n         self.assert_not_persistent_calling_transient(parent_task, task, None);\n-        ConnectChildOperation::run(parent_task, task, false, self.execute_context(turbo_tasks));\n+        ConnectChildOperation::run(parent_task, task, self.execute_context(turbo_tasks));\n     }\n \n     fn create_transient_task(&self, task_type: TransientTaskType) -> TaskId {\n@@ -2318,7 +2350,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     effective: u32::MAX,\n                 },\n             });\n-            if !task.state().is_immutable() && self.should_track_activeness() {\n+            if self.should_track_activeness() {\n                 task.add(CachedDataItem::Activeness {\n                     value: ActivenessState::new_root(root_type, task_id),\n                 });\n@@ -2631,22 +2663,20 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n         &self,\n         task_type: CachedTaskType,\n         parent_task: TaskId,\n-        is_immutable: bool,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> TaskId {\n         self.0\n-            .get_or_create_persistent_task(task_type, parent_task, is_immutable, turbo_tasks)\n+            .get_or_create_persistent_task(task_type, parent_task, turbo_tasks)\n     }\n \n     fn get_or_create_transient_task(\n         &self,\n         task_type: CachedTaskType,\n         parent_task: TaskId,\n-        is_immutable: bool,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> TaskId {\n         self.0\n-            .get_or_create_transient_task(task_type, parent_task, is_immutable, turbo_tasks)\n+            .get_or_create_transient_task(task_type, parent_task, turbo_tasks)\n     }\n \n     fn invalidate_task(&self, task_id: TaskId, turbo_tasks: &dyn TurboTasksBackendApi<Self>) {\n@@ -2708,6 +2738,7 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n         _memory_usage: usize,\n         cell_counters: &AutoMap<ValueTypeId, u32, BuildHasherDefault<FxHasher>, 8>,\n         stateful: bool,\n+        has_invalidator: bool,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> bool {\n         self.0.task_execution_completed(\n@@ -2716,6 +2747,7 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n             _memory_usage,\n             cell_counters,\n             stateful,\n+            has_invalidator,\n             turbo_tasks,\n         )\n     }"
        },
        {
            "sha": "e62cfb6ad635efc07fe8dfb25561e0a1ca29cc78",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/connect_child.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 26,
            "changes": 29,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_child.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -23,17 +23,9 @@ pub enum ConnectChildOperation {\n }\n \n impl ConnectChildOperation {\n-    pub fn run(\n-        parent_task_id: TaskId,\n-        child_task_id: TaskId,\n-        mut is_child_immutable: bool,\n-        mut ctx: impl ExecuteContext,\n-    ) {\n+    pub fn run(parent_task_id: TaskId, child_task_id: TaskId, mut ctx: impl ExecuteContext) {\n         if !ctx.should_track_children() {\n             let mut task = ctx.task(child_task_id, TaskDataCategory::All);\n-            if is_child_immutable {\n-                task.mark_as_immutable();\n-            }\n             if !task.has_key(&CachedDataItemKey::Output {}) {\n                 let description = ctx.get_task_desc_fn(child_task_id);\n                 let should_schedule = task.add(CachedDataItem::new_scheduled(\n@@ -48,11 +40,6 @@ impl ConnectChildOperation {\n             return;\n         }\n \n-        if !is_child_immutable {\n-            let task = ctx.task(child_task_id, TaskDataCategory::All);\n-            is_child_immutable = task.is_immutable();\n-        }\n-\n         let mut parent_task = ctx.task(parent_task_id, TaskDataCategory::All);\n         let Some(InProgressState::InProgress(box InProgressStateInner { new_children, .. })) =\n             get_mut!(parent_task, InProgress)\n@@ -61,10 +48,7 @@ impl ConnectChildOperation {\n         };\n \n         // Quick skip if the child was already connected before\n-        if new_children\n-            .insert(child_task_id, is_child_immutable)\n-            .is_some()\n-        {\n+        if !new_children.insert(child_task_id) {\n             return;\n         }\n \n@@ -87,20 +71,13 @@ impl ConnectChildOperation {\n             });\n         }\n \n-        // https://vercel.slack.com/archives/C03EWR7LGEN/p1750889741099559\n-        // HACK: immutable tracking is broken, disable it for now\n-        is_child_immutable = false;\n-\n         // Immutable tasks cannot be invalidated, meaning that we never reschedule them.\n-        if !is_child_immutable && ctx.should_track_activeness() {\n+        if ctx.should_track_activeness() {\n             queue.push(AggregationUpdateJob::IncreaseActiveCount {\n                 task: child_task_id,\n             });\n         } else {\n             let mut task = ctx.task(child_task_id, TaskDataCategory::All);\n-            if is_child_immutable {\n-                task.mark_as_immutable();\n-            }\n \n             if !task.has_key(&CachedDataItemKey::Output {}) {\n                 let description = ctx.get_task_desc_fn(child_task_id);"
        },
        {
            "sha": "8dac36ffa293c0b8532884f7e15ce2f4c3dc1151",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/connect_children.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_children.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_children.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fconnect_children.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -1,4 +1,4 @@\n-use rustc_hash::FxHashMap;\n+use rustc_hash::FxHashSet;\n use smallvec::SmallVec;\n use turbo_tasks::TaskId;\n \n@@ -14,7 +14,7 @@ use crate::{\n pub fn connect_children(\n     parent_task_id: TaskId,\n     parent_task: &mut impl TaskGuard,\n-    new_children: FxHashMap<TaskId, bool>,\n+    new_children: FxHashSet<TaskId>,\n     queue: &mut AggregationUpdateQueue,\n     has_active_count: bool,\n     should_track_activeness: bool,\n@@ -25,14 +25,14 @@ pub fn connect_children(\n \n     let parent_aggregation = get_aggregation_number(parent_task);\n \n-    for &new_child in new_children.keys() {\n+    for &new_child in new_children.iter() {\n         parent_task.add_new(CachedDataItem::Child {\n             task: new_child,\n             value: (),\n         });\n     }\n \n-    let new_follower_ids: SmallVec<_> = new_children.keys().copied().collect();\n+    let new_follower_ids: SmallVec<_> = new_children.into_iter().collect();\n \n     let aggregating_node = is_aggregating_node(parent_aggregation);\n     let upper_ids = (!aggregating_node).then(|| get_uppers(&*parent_task));"
        },
        {
            "sha": "2e78cf05e6472fceae9a222b99db8d2af821cc70",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/invalidate.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 0,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -197,6 +197,25 @@ pub fn make_task_dirty_internal(\n     queue: &mut AggregationUpdateQueue,\n     ctx: &impl ExecuteContext,\n ) {\n+    // There must be no way to invalidate immutable tasks. If there would be a way the task is not\n+    // immutable.\n+    #[cfg(any(debug_assertions, feature = \"verify_immutable\"))]\n+    if task.is_immutable() {\n+        #[cfg(feature = \"trace_task_dirty\")]\n+        let extra_info = format!(\n+            \" Invalidation cause: {}\",\n+            TaskDirtyCauseInContext::new(&cause, ctx)\n+        );\n+        #[cfg(not(feature = \"trace_task_dirty\"))]\n+        let extra_info = \"\";\n+\n+        panic!(\n+            \"Task {} is immutable, but was made dirty. This should not happen and is a \\\n+             bug.{extra_info}\",\n+            ctx.get_task_description(task_id),\n+        );\n+    }\n+\n     if make_stale\n         && let Some(InProgressState::InProgress(box InProgressStateInner { stale, .. })) =\n             get_mut!(task, InProgress)"
        },
        {
            "sha": "e3a0f2a84c22cc5d1f21e20f2d29a245b013f309",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 8,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -316,7 +316,6 @@ pub trait TaskGuard: Debug {\n         F: for<'a> FnMut(CachedDataItemKey, CachedDataItemValueRef<'a>) -> bool + 'l;\n     fn invalidate_serialization(&mut self);\n     fn is_immutable(&self) -> bool;\n-    fn mark_as_immutable(&mut self);\n }\n \n struct TaskGuardImpl<'a, B: BackingStorage> {\n@@ -506,13 +505,7 @@ impl<B: BackingStorage> TaskGuard for TaskGuardImpl<'_, B> {\n     }\n \n     fn is_immutable(&self) -> bool {\n-        // https://vercel.slack.com/archives/C03EWR7LGEN/p1750889741099559\n-        // HACK: immutable tracking is broken, disable it for now\n-        false\n-        // self.task.state().is_immutable()\n-    }\n-    fn mark_as_immutable(&mut self) {\n-        self.task.state_mut().set_is_immutable(true);\n+        self.task.contains_key(&CachedDataItemKey::Immutable {})\n     }\n }\n "
        },
        {
            "sha": "8c148296a9481b07ed2e572e9d08ced631ebbe17",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/prepare_new_children.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fprepare_new_children.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fprepare_new_children.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fprepare_new_children.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -1,6 +1,6 @@\n use std::{cmp::max, num::NonZeroU32};\n \n-use rustc_hash::FxHashMap;\n+use rustc_hash::FxHashSet;\n use turbo_tasks::TaskId;\n \n use crate::backend::{\n@@ -15,7 +15,7 @@ const AGGREGATION_NUMBER_BUFFER_SPACE: u32 = 3;\n pub fn prepare_new_children(\n     parent_task_id: TaskId,\n     parent_task: &mut impl TaskGuard,\n-    new_children: &FxHashMap<TaskId, bool>,\n+    new_children: &FxHashSet<TaskId>,\n     queue: &mut AggregationUpdateQueue,\n ) {\n     if new_children.is_empty() {\n@@ -48,7 +48,7 @@ pub fn prepare_new_children(\n     if !is_aggregating_node(future_parent_aggregation) {\n         let child_base_aggregation_number =\n             future_parent_aggregation + AGGREGATION_NUMBER_BUFFER_SPACE;\n-        for &new_child in new_children.keys() {\n+        for &new_child in new_children.iter() {\n             queue.push(AggregationUpdateJob::UpdateAggregationNumber {\n                 task_id: new_child,\n                 base_aggregation_number: child_base_aggregation_number,"
        },
        {
            "sha": "bfc06d8e1253ace3d2a0c576b963ba2a0d5c1ee5",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_output.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -62,7 +62,7 @@ impl UpdateOutputOperation {\n             return;\n         }\n         let children = if ctx.should_track_children() {\n-            new_children.keys().copied().collect()\n+            new_children.iter().copied().collect()\n         } else {\n             Default::default()\n         };"
        },
        {
            "sha": "020fd00da6845ed734f245fa06fd926cdff309e9",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/storage.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -99,7 +99,6 @@ bitfield! {\n     /// Item was modified after snapshot mode was entered. A snapshot was taken.\n     pub meta_snapshot, set_meta_snapshot: 4;\n     pub data_snapshot, set_data_snapshot: 5;\n-    pub is_immutable, set_is_immutable: 6;\n }\n \n impl InnerStorageState {"
        },
        {
            "sha": "74aab83d520a8c5839f380ebf813dc438775ff77",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 5,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -1,6 +1,6 @@\n use std::cmp::Ordering;\n \n-use rustc_hash::FxHashMap;\n+use rustc_hash::FxHashSet;\n use serde::{Deserialize, Serialize};\n use turbo_tasks::{\n     CellId, KeyValuePair, SessionId, TaskExecutionReason, TaskId, TraitTypeId,\n@@ -316,9 +316,7 @@ pub struct InProgressStateInner {\n     pub done_event: Event,\n     /// Children that should be connected to the task and have their active_count decremented\n     /// once the task completes.\n-    ///\n-    /// The bool value is `is_immutable` of the child task.\n-    pub new_children: FxHashMap<TaskId, bool>,\n+    pub new_children: FxHashSet<TaskId>,\n }\n \n #[derive(Debug)]\n@@ -454,6 +452,12 @@ pub enum CachedDataItem {\n     Stateful {\n         value: (),\n     },\n+    HasInvalidator {\n+        value: (),\n+    },\n+    Immutable {\n+        value: (),\n+    },\n \n     // Transient Root Type\n     #[serde(skip)]\n@@ -519,6 +523,8 @@ impl CachedDataItem {\n             }\n             CachedDataItem::AggregatedDirtyContainerCount { .. } => true,\n             CachedDataItem::Stateful { .. } => true,\n+            CachedDataItem::HasInvalidator { .. } => true,\n+            CachedDataItem::Immutable { .. } => true,\n             CachedDataItem::Activeness { .. } => false,\n             CachedDataItem::InProgress { .. } => false,\n             CachedDataItem::InProgressCell { .. } => false,\n@@ -577,6 +583,8 @@ impl CachedDataItem {\n             | Self::AggregatedCollectible { .. }\n             | Self::AggregatedDirtyContainerCount { .. }\n             | Self::Stateful { .. }\n+            | Self::HasInvalidator { .. }\n+            | Self::Immutable { .. }\n             | Self::CollectiblesDependent { .. } => TaskDataCategory::Meta,\n \n             Self::OutdatedCollectible { .. }\n@@ -620,6 +628,8 @@ impl CachedDataItemKey {\n             }\n             CachedDataItemKey::AggregatedDirtyContainerCount { .. } => true,\n             CachedDataItemKey::Stateful { .. } => true,\n+            CachedDataItemKey::HasInvalidator { .. } => true,\n+            CachedDataItemKey::Immutable { .. } => true,\n             CachedDataItemKey::Activeness { .. } => false,\n             CachedDataItemKey::InProgress { .. } => false,\n             CachedDataItemKey::InProgressCell { .. } => false,\n@@ -657,6 +667,8 @@ impl CachedDataItemType {\n             | Self::AggregatedCollectible { .. }\n             | Self::AggregatedDirtyContainerCount { .. }\n             | Self::Stateful { .. }\n+            | Self::HasInvalidator { .. }\n+            | Self::Immutable { .. }\n             | Self::CollectiblesDependent { .. } => TaskDataCategory::Meta,\n \n             Self::OutdatedCollectible { .. }\n@@ -689,7 +701,9 @@ impl CachedDataItemType {\n             | Self::AggregatedDirtyContainer\n             | Self::AggregatedCollectible\n             | Self::AggregatedDirtyContainerCount\n-            | Self::Stateful => true,\n+            | Self::Stateful\n+            | Self::HasInvalidator\n+            | Self::Immutable => true,\n \n             Self::Activeness\n             | Self::InProgress"
        },
        {
            "sha": "c76c23590f8abb72a26bb431cb26992e4ebb6395",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/detached.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -163,7 +163,7 @@ async fn spawns_detached_changing(\n }\n \n // spawns_detached should take a dependency on this function for each input\n-#[turbo_tasks::function(invalidator)]\n+#[turbo_tasks::function]\n async fn read_changing_input(changing_input: Vc<ChangingInput>) -> Vc<u32> {\n     // when changing_input.set is called, it will trigger an invalidator for this task\n     Vc::cell(*changing_input.await.unwrap().state.get())"
        },
        {
            "sha": "8171cead7dd405d173b65ea3ff1986d88de3f032",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/dirty_in_progress.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdirty_in_progress.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdirty_in_progress.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdirty_in_progress.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -71,7 +71,7 @@ impl ValueToString for Collectible {\n     }\n }\n \n-#[turbo_tasks::function(operation, invalidator)]\n+#[turbo_tasks::function(operation)]\n async fn inner_compute(input: ResolvedVc<ChangingInput>) -> Result<Vc<u32>> {\n     println!(\"start inner_compute\");\n     let value = *input.await?.state.get();"
        },
        {
            "sha": "4a3ddce3bfa73e8df9c06e750dee994c28af834e",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/emptied_cells.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -56,7 +56,7 @@ async fn compute(input: Vc<ChangingInput>) -> Result<Vc<u32>> {\n     Ok(Vc::cell(value))\n }\n \n-#[turbo_tasks::function(invalidator)]\n+#[turbo_tasks::function]\n async fn inner_compute(input: Vc<ChangingInput>) -> Result<Vc<u32>> {\n     println!(\"inner_compute()\");\n     let state_value = *input.await?.state.get();"
        },
        {
            "sha": "d90a4cb2f78debce26db9c911d4c1fb480d78e3d",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/immutable.rs",
            "status": "added",
            "additions": 106,
            "deletions": 0,
            "changes": 106,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fimmutable.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fimmutable.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fimmutable.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -0,0 +1,106 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use anyhow::Result;\n+use turbo_tasks::{State, Vc};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn hidden_mutate() {\n+    run(&REGISTRATION, || async {\n+        let input = create_input().resolve().await?;\n+        input.await?.state.set(1);\n+        let changing_value = compute(input);\n+        assert_eq!(changing_value.await?.value, 1);\n+\n+        let changing_value_resolved = changing_value.resolve().await?;\n+        let read_input = read_input(changing_value_resolved);\n+        let static_immutable = immutable_fn(changing_value_resolved);\n+        let read_self = changing_value_resolved.read_self();\n+        let static_immutable_self = changing_value_resolved.immutable_self_fn();\n+        assert_eq!(*read_input.await?, 1);\n+        assert_eq!(*static_immutable.await?, 42);\n+        assert_eq!(*read_self.await?, 1);\n+        assert_eq!(*static_immutable_self.await?, 42);\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(10);\n+        assert_eq!(changing_value.strongly_consistent().await?.value, 10);\n+        assert_eq!(*read_input.strongly_consistent().await?, 10);\n+        assert_eq!(*static_immutable.strongly_consistent().await?, 42);\n+        assert_eq!(*read_self.strongly_consistent().await?, 10);\n+        assert_eq!(*static_immutable_self.strongly_consistent().await?, 42);\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(5);\n+        assert_eq!(changing_value.strongly_consistent().await?.value, 5);\n+        assert_eq!(*read_input.strongly_consistent().await?, 5);\n+        assert_eq!(*static_immutable.strongly_consistent().await?, 42);\n+        assert_eq!(*read_self.strongly_consistent().await?, 5);\n+        assert_eq!(*static_immutable_self.strongly_consistent().await?, 42);\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap();\n+}\n+\n+#[turbo_tasks::value]\n+struct ChangingInput {\n+    state: State<u32>,\n+}\n+\n+#[turbo_tasks::value]\n+struct Value {\n+    value: u32,\n+}\n+\n+#[turbo_tasks::function]\n+async fn create_input() -> Result<Vc<ChangingInput>> {\n+    println!(\"create_input()\");\n+    Ok(ChangingInput {\n+        state: State::new(0),\n+    }\n+    .cell())\n+}\n+\n+#[turbo_tasks::function]\n+async fn compute(input: Vc<ChangingInput>) -> Result<Vc<Value>> {\n+    println!(\"compute()\");\n+    let input = input.await?;\n+    let value = input.state.get();\n+    Ok(Value { value: *value }.cell())\n+}\n+\n+#[turbo_tasks::function]\n+async fn read_input(input: Vc<Value>) -> Result<Vc<u32>> {\n+    println!(\"read_input()\");\n+    let value = input.await?;\n+    Ok(Vc::cell(value.value))\n+}\n+\n+#[turbo_tasks::function]\n+fn immutable_fn(input: Vc<Value>) -> Vc<u32> {\n+    let _ = input;\n+    println!(\"immutable_fn()\");\n+    Vc::cell(42)\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Value {\n+    #[turbo_tasks::function]\n+    fn read_self(&self) -> Vc<u32> {\n+        println!(\"read_self()\");\n+        Vc::cell(self.value)\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn immutable_self_fn(self: Vc<Value>) -> Vc<u32> {\n+        let _ = self;\n+        println!(\"immutable_self_fn()\");\n+        Vc::cell(42)\n+    }\n+}"
        },
        {
            "sha": "841c4564af44482ef10aff3dcb96187e23b5749f",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/random_change.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -48,15 +48,15 @@ fn make_state() -> Vc<ValueContainer> {\n     .cell()\n }\n \n-#[turbo_tasks::function(invalidator)]\n+#[turbo_tasks::function]\n async fn func2(input: Vc<ValueContainer>) -> Result<Vc<Value>> {\n     let state = input.await?;\n     let value = state.state.get();\n     println!(\"func2 {}\", *value);\n     Ok(func(input, -*value))\n }\n \n-#[turbo_tasks::function(invalidator)]\n+#[turbo_tasks::function]\n async fn func(input: Vc<ValueContainer>, nesting: i32) -> Result<Vc<Value>> {\n     let state = input.await?;\n     let value = state.state.get();"
        },
        {
            "sha": "d7ccf3b37b6cfd48693ba0b20901fda06767875f",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/read_ref_cell.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -70,7 +70,7 @@ impl Counter {\n \n #[turbo_tasks::value_impl]\n impl Counter {\n-    #[turbo_tasks::function(invalidator)]\n+    #[turbo_tasks::function]\n     fn get_value(&self) -> Result<Vc<CounterValue>> {\n         let mut lock = self.value.lock().unwrap();\n         lock.1 = Some(get_invalidator());"
        },
        {
            "sha": "17a69e9c151d3dcd320eedb75e2c1b7c3bf570ba",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/recompute.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -112,7 +112,7 @@ struct Output {\n     random_value: u32,\n }\n \n-#[turbo_tasks::function(invalidator)]\n+#[turbo_tasks::function]\n async fn compute(input: Vc<ChangingInput>, input2: Vc<ChangingInput>) -> Result<Vc<Output>> {\n     let state_value = *input.await?.state.get();\n     let state_value2 = if state_value < 5 {\n@@ -130,7 +130,7 @@ async fn compute(input: Vc<ChangingInput>, input2: Vc<ChangingInput>) -> Result<\n     .cell())\n }\n \n-#[turbo_tasks::function(invalidator)]\n+#[turbo_tasks::function]\n async fn compute2(input: Vc<ChangingInput>) -> Result<Vc<u32>> {\n     let state_value = *input.await?.state.get();\n     Ok(Vc::cell(state_value))"
        },
        {
            "sha": "54074af628add5406275d33f6a10419e5b044dc9",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/recompute_collectibles.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute_collectibles.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute_collectibles.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute_collectibles.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -76,7 +76,7 @@ impl ValueToString for Collectible {\n     }\n }\n \n-#[turbo_tasks::function(operation, invalidator)]\n+#[turbo_tasks::function(operation)]\n async fn inner_compute(\n     input: ResolvedVc<ChangingInput>,\n     input2: ResolvedVc<ChangingInput>,\n@@ -85,7 +85,7 @@ async fn inner_compute(\n     Ok(inner_compute2(*input, *input2.await?.state.get()))\n }\n \n-#[turbo_tasks::function(invalidator)]\n+#[turbo_tasks::function]\n async fn inner_compute2(input: Vc<ChangingInput>, innerness: u32) -> Result<Vc<u32>> {\n     println!(\"inner_compute2({innerness})\");\n     if innerness > 0 {"
        },
        {
            "sha": "c556e8d422489a98683213a157f6d7885fb08779",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trait_ref_cell.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -87,7 +87,7 @@ trait CounterTrait {\n \n #[turbo_tasks::value_impl]\n impl CounterTrait for Counter {\n-    #[turbo_tasks::function(invalidator)]\n+    #[turbo_tasks::function]\n     fn get_value(&self) -> Result<Vc<CounterValue>> {\n         let mut lock = self.value.lock().unwrap();\n         lock.1 = Some(get_invalidator());"
        },
        {
            "sha": "15917f62563bf60c4ba240bb3b0d23ac3cd26a99",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trait_ref_cell_mode.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell_mode.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell_mode.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell_mode.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -135,12 +135,12 @@ where\n     Ok(TraitRef::cell(picked_vc.into_trait_ref().await?))\n }\n \n-#[turbo_tasks::function(invalidator)]\n+#[turbo_tasks::function]\n async fn shared_value_from_input(input: Vc<CellIdSelector>) -> Result<Vc<Box<dyn ValueTrait>>> {\n     value_from_input::<SharedValue>(input, Vc::<SharedValue>::cell).await\n }\n \n-#[turbo_tasks::function(invalidator)]\n+#[turbo_tasks::function]\n async fn new_value_from_input(input: Vc<CellIdSelector>) -> Result<Vc<Box<dyn ValueTrait>>> {\n     value_from_input::<NewValue>(input, Vc::<NewValue>::cell).await\n }"
        },
        {
            "sha": "836a7adf1e7e366b3517767da7e9dc6aa15b69bd",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -547,7 +547,7 @@ impl Debug for DiskFileSystem {\n \n #[turbo_tasks::value_impl]\n impl FileSystem for DiskFileSystem {\n-    #[turbo_tasks::function(fs, invalidator)]\n+    #[turbo_tasks::function(fs)]\n     async fn read(&self, fs_path: FileSystemPath) -> Result<Vc<FileContent>> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n@@ -573,7 +573,7 @@ impl FileSystem for DiskFileSystem {\n         Ok(content.cell())\n     }\n \n-    #[turbo_tasks::function(fs, invalidator)]\n+    #[turbo_tasks::function(fs)]\n     async fn raw_read_dir(&self, fs_path: FileSystemPath) -> Result<Vc<RawDirectoryContent>> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n@@ -628,7 +628,7 @@ impl FileSystem for DiskFileSystem {\n         Ok(RawDirectoryContent::new(entries))\n     }\n \n-    #[turbo_tasks::function(fs, invalidator)]\n+    #[turbo_tasks::function(fs)]\n     async fn read_link(&self, fs_path: FileSystemPath) -> Result<Vc<LinkContent>> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path.clone()).await?;\n@@ -715,7 +715,7 @@ impl FileSystem for DiskFileSystem {\n         .cell())\n     }\n \n-    #[turbo_tasks::function(fs, invalidator)]\n+    #[turbo_tasks::function(fs)]\n     async fn write(&self, fs_path: FileSystemPath, content: Vc<FileContent>) -> Result<()> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n@@ -842,7 +842,7 @@ impl FileSystem for DiskFileSystem {\n         Ok(())\n     }\n \n-    #[turbo_tasks::function(fs, invalidator)]\n+    #[turbo_tasks::function(fs)]\n     async fn write_link(&self, fs_path: FileSystemPath, target: Vc<LinkContent>) -> Result<()> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n@@ -965,7 +965,7 @@ impl FileSystem for DiskFileSystem {\n         Ok(())\n     }\n \n-    #[turbo_tasks::function(fs, invalidator)]\n+    #[turbo_tasks::function(fs)]\n     async fn metadata(&self, fs_path: FileSystemPath) -> Result<Vc<FileMeta>> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;"
        },
        {
            "sha": "04266ef3404c84885574b525078d8f8421c71f7b",
            "filename": "turbopack/crates/turbo-tasks-macros-tests/tests/function/fail_attribute_invalid_args.stderr",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_attribute_invalid_args.stderr",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_attribute_invalid_args.stderr",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_attribute_invalid_args.stderr?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -1,4 +1,4 @@\n-error: unexpected token, expected one of: \"fs\", \"network\", \"operation\", \"local\", \"invalidator\"\n+error: unexpected token, expected one of: \"fs\", \"network\", \"operation\", \"local\"\n  --> tests/function/fail_attribute_invalid_args.rs:9:25\n   |\n 9 | #[turbo_tasks::function(invalid_argument)]"
        },
        {
            "sha": "54e38531e026243eab0cf19257f1e86b6a15f4ed",
            "filename": "turbopack/crates/turbo-tasks-macros-tests/tests/function/fail_attribute_invalid_args_inherent_impl.stderr",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_attribute_invalid_args_inherent_impl.stderr",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_attribute_invalid_args_inherent_impl.stderr",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-tests%2Ftests%2Ffunction%2Ffail_attribute_invalid_args_inherent_impl.stderr?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -1,4 +1,4 @@\n-error: unexpected token, expected one of: \"fs\", \"network\", \"operation\", \"local\", \"invalidator\"\n+error: unexpected token, expected one of: \"fs\", \"network\", \"operation\", \"local\"\n   --> tests/function/fail_attribute_invalid_args_inherent_impl.rs:14:29\n    |\n 14 |     #[turbo_tasks::function(invalid_argument)]"
        },
        {
            "sha": "a6309b69ccbb7930a2f1c7ff08e48a795189b55d",
            "filename": "turbopack/crates/turbo-tasks-macros/src/func.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 17,
            "changes": 18,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -734,9 +734,6 @@ pub struct FunctionArguments {\n     /// task-local state. The function call itself will not be cached, but cells will be created on\n     /// the parent task.\n     pub local: Option<Span>,\n-    /// If true, the function will be allowed to call `get_invalidator` . If this is false, the\n-    /// `get_invalidator` function will panic on calls.\n-    pub invalidator: Option<Span>,\n }\n \n impl Parse for FunctionArguments {\n@@ -764,14 +761,11 @@ impl Parse for FunctionArguments {\n                 (\"local\", Meta::Path(_)) => {\n                     parsed_args.local = Some(meta.span());\n                 }\n-                (\"invalidator\", Meta::Path(_)) => {\n-                    parsed_args.invalidator = Some(meta.span());\n-                }\n                 (_, meta) => {\n                     return Err(syn::Error::new_spanned(\n                         meta,\n                         \"unexpected token, expected one of: \\\"fs\\\", \\\"network\\\", \\\"operation\\\", \\\n-                         \\\"local\\\", \\\"invalidator\\\"\",\n+                         \\\"local\\\"\",\n                     ));\n                 }\n             }\n@@ -1099,8 +1093,6 @@ pub struct NativeFn {\n     pub is_self_used: bool,\n     pub filter_trait_call_args: Option<FilterTraitCallArgsTokens>,\n     pub local: bool,\n-    pub invalidator: bool,\n-    pub immutable: bool,\n }\n \n impl NativeFn {\n@@ -1116,8 +1108,6 @@ impl NativeFn {\n             is_self_used,\n             filter_trait_call_args,\n             local,\n-            invalidator,\n-            immutable,\n         } = self;\n \n         if *is_method {\n@@ -1144,8 +1134,6 @@ impl NativeFn {\n                             #function_path_string,\n                             turbo_tasks::macro_helpers::FunctionMeta {\n                                 local: #local,\n-                                invalidator: #invalidator,\n-                                immutable: #immutable,\n                             },\n                             #arg_filter,\n                             #function_path,\n@@ -1160,8 +1148,6 @@ impl NativeFn {\n                             #function_path_string,\n                             turbo_tasks::macro_helpers::FunctionMeta {\n                                 local: #local,\n-                                invalidator: #invalidator,\n-                                immutable: #immutable,\n                             },\n                             #arg_filter,\n                             #function_path,\n@@ -1177,8 +1163,6 @@ impl NativeFn {\n                         #function_path_string,\n                         turbo_tasks::macro_helpers::FunctionMeta {\n                             local: #local,\n-                            invalidator: #invalidator,\n-                            immutable: #immutable,\n                         },\n                         #function_path,\n                     )"
        },
        {
            "sha": "a59032e7e5999f65d2417dd98e2fba84cebcab2a",
            "filename": "turbopack/crates/turbo-tasks-macros/src/function_macro.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 15,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -40,7 +40,6 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n         .inspect_err(|err| errors.push(err.to_compile_error()))\n         .unwrap_or_default();\n     let local = args.local.is_some();\n-    let invalidator = args.invalidator.is_some();\n     let is_self_used = args.operation.is_some() || is_self_used(&block);\n \n     let Some(turbo_fn) = TurboFn::new(&sig, DefinitionContext::NakedFn, args) else {\n@@ -64,8 +63,6 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n         is_self_used,\n         filter_trait_call_args: None, // not a trait method\n         local,\n-        invalidator,\n-        immutable: is_immutable(&sig) && !invalidator,\n     };\n     let native_function_ident = get_native_function_ident(ident);\n     let native_function_ty = native_fn.ty();\n@@ -91,15 +88,3 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n     }\n     .into()\n }\n-\n-/// Computes whether the task is statically immutable based on the signature.\n-/// - if the task is `async` we assume it is reading some other task.\n-/// - if a task accepts `&self` then we know it read `Vc<Self>` in the generated calling code. See\n-///   also: turbopack/crates/turbo-tasks/src/task/function.rs for the binding code.\n-pub(crate) fn is_immutable(sig: &syn::Signature) -> bool {\n-    sig.asyncness.is_none()\n-        && match sig.receiver() {\n-            Some(recv) => recv.reference.is_none(),\n-            _ => true,\n-        }\n-}"
        },
        {
            "sha": "7f7cca6330497041c662240c813291a7156ccab7",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_impl_macro.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 12,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -13,12 +13,9 @@ use turbo_tasks_macros_shared::{\n     get_register_trait_methods_ident, get_trait_impl_function_ident, get_type_ident, is_self_used,\n };\n \n-use crate::{\n-    func::{\n-        DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n-        split_function_attributes,\n-    },\n-    function_macro::is_immutable,\n+use crate::func::{\n+    DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n+    split_function_attributes,\n };\n \n struct ValueImplArguments {\n@@ -97,7 +94,6 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                     }\n                 };\n                 let local = func_args.local.is_some();\n-                let invalidator = func_args.invalidator.is_some();\n                 let is_self_used = func_args.operation.is_some() || is_self_used(block);\n \n                 let Some(turbo_fn) =\n@@ -120,8 +116,6 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                     is_self_used,\n                     filter_trait_call_args: None, // not a trait method\n                     local,\n-                    invalidator,\n-                    immutable: is_immutable(sig) && !invalidator,\n                 };\n \n                 let native_function_ident = get_inherent_impl_function_ident(ty_ident, ident);\n@@ -208,7 +202,6 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                     }\n                 };\n                 let local = func_args.local.is_some();\n-                let invalidator = func_args.invalidator.is_some();\n                 let is_self_used = func_args.operation.is_some() || is_self_used(block);\n \n                 let Some(turbo_fn) =\n@@ -241,8 +234,6 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                     is_self_used,\n                     filter_trait_call_args: turbo_fn.filter_trait_call_args(),\n                     local,\n-                    invalidator,\n-                    immutable: is_immutable(sig) && !invalidator,\n                 };\n \n                 let native_function_ident ="
        },
        {
            "sha": "5d69c1a7780fca5cc6b0959f6084dca93d24e7dd",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_trait_macro.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 8,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -8,12 +8,9 @@ use turbo_tasks_macros_shared::{\n     ValueTraitArguments, get_trait_default_impl_function_ident, get_trait_type_ident, is_self_used,\n };\n \n-use crate::{\n-    func::{\n-        DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n-        split_function_attributes,\n-    },\n-    function_macro::is_immutable,\n+use crate::func::{\n+    DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n+    split_function_attributes,\n };\n \n pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n@@ -191,8 +188,6 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n                 //   argument. (This could be fixed)\n                 // - This only makes sense when a default implementation is present.\n                 local: false,\n-                invalidator: func_args.invalidator.is_some(),\n-                immutable: is_immutable(sig) && func_args.invalidator.is_none(),\n             };\n \n             let native_function_ident = get_trait_default_impl_function_ident(trait_ident, ident);"
        },
        {
            "sha": "8aa5262dd028f5aaa2a36f97ea41d5cb7052fdd0",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -578,6 +578,7 @@ pub trait Backend: Sync + Send {\n         memory_usage: usize,\n         cell_counters: &AutoMap<ValueTypeId, u32, BuildHasherDefault<FxHasher>, 8>,\n         stateful: bool,\n+        has_invalidator: bool,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> bool;\n \n@@ -675,15 +676,13 @@ pub trait Backend: Sync + Send {\n         &self,\n         task_type: CachedTaskType,\n         parent_task: TaskId,\n-        is_immutable: bool,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> TaskId;\n \n     fn get_or_create_transient_task(\n         &self,\n         task_type: CachedTaskType,\n         parent_task: TaskId,\n-        is_immutable: bool,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> TaskId;\n "
        },
        {
            "sha": "22acf9b99d6a89c80311a9fd1ce37f7559a47829",
            "filename": "turbopack/crates/turbo-tasks/src/invalidation.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 16,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Finvalidation.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Finvalidation.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Finvalidation.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -9,33 +9,20 @@ use std::{\n use anyhow::Result;\n use indexmap::map::Entry;\n use serde::{Deserialize, Serialize, de::Visitor};\n-use tokio::{runtime::Handle, task_local};\n+use tokio::runtime::Handle;\n \n use crate::{\n     FxIndexMap, FxIndexSet, TaskId, TurboTasksApi,\n     magic_any::HasherMut,\n-    manager::{current_task, with_turbo_tasks},\n+    manager::{current_task, mark_invalidator, with_turbo_tasks},\n     trace::TraceRawVcs,\n     util::StaticOrArc,\n };\n \n-task_local! {\n-    static DISALLOW_INVALIDATOR: ();\n-}\n-\n-pub fn disallow_invalidator<R>(f: impl Future<Output = R>) -> impl Future<Output = R> {\n-    DISALLOW_INVALIDATOR.scope((), f)\n-}\n-\n /// Get an [`Invalidator`] that can be used to invalidate the current task\n /// based on external events.\n pub fn get_invalidator() -> Invalidator {\n-    if DISALLOW_INVALIDATOR.try_with(|_| {}).is_ok() {\n-        panic!(\n-            \"Invalidator can only be used in the turbo-tasks function that has \\\n-             #[turbo_tasks::function(invalidator)] attribute\"\n-        );\n-    }\n+    mark_invalidator();\n \n     let handle = Handle::current();\n     Invalidator {"
        },
        {
            "sha": "629d9be3fd62e931bd85056b1432f95c5b211d96",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 34,
            "deletions": 9,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -405,6 +405,9 @@ struct CurrentTaskState {\n     /// True if the current task has state in cells\n     stateful: bool,\n \n+    /// True if the current task uses an external invalidator\n+    has_invalidator: bool,\n+\n     /// Tracks how many cells of each type has been allocated so far during this task execution.\n     /// When a task is re-executed, the cell count may not match the existing cell vec length.\n     ///\n@@ -432,6 +435,7 @@ impl CurrentTaskState {\n             execution_id,\n             tasks_to_notify: SmallVec::new(),\n             stateful: false,\n+            has_invalidator: false,\n             cell_counters: Some(AutoMap::default()),\n             local_tasks: Vec::new(),\n             local_task_tracker: TaskTracker::new(),\n@@ -604,7 +608,6 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                 self.schedule_local_task(task_type, persistence)\n             }\n             TaskPersistence::Transient => {\n-                let immutable = native_fn.function_meta.immutable;\n                 let task_type = CachedTaskType {\n                     native_fn,\n                     this,\n@@ -614,12 +617,10 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                 RawVc::TaskOutput(self.backend.get_or_create_transient_task(\n                     task_type,\n                     current_task(\"turbo_function calls\"),\n-                    immutable,\n                     self,\n                 ))\n             }\n             TaskPersistence::Persistent => {\n-                let immutable = native_fn.function_meta.immutable;\n                 let task_type = CachedTaskType {\n                     native_fn,\n                     this,\n@@ -629,7 +630,6 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                 RawVc::TaskOutput(self.backend.get_or_create_persistent_task(\n                     task_type,\n                     current_task(\"turbo_function calls\"),\n-                    immutable,\n                     self,\n                 ))\n             }\n@@ -733,7 +733,10 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                         };\n \n                         this.backend.task_execution_result(task_id, result, &*this);\n-                        let stateful = this.finish_current_task_state();\n+                        let FinishedTaskState {\n+                            stateful,\n+                            has_invalidator,\n+                        } = this.finish_current_task_state();\n                         let cell_counters = CURRENT_TASK_STATE\n                             .with(|ts| ts.write().unwrap().cell_counters.take().unwrap());\n                         let schedule_again = this.backend.task_execution_completed(\n@@ -742,6 +745,7 @@ impl<B: Backend + 'static> TurboTasks<B> {\n                             memory_usage,\n                             &cell_counters,\n                             stateful,\n+                            has_invalidator,\n                             &*this,\n                         );\n                         // task_execution_completed might need to notify tasks\n@@ -1137,27 +1141,39 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         );\n     }\n \n-    fn finish_current_task_state(&self) -> bool {\n-        let (stateful, tasks) = CURRENT_TASK_STATE.with(|cell| {\n+    fn finish_current_task_state(&self) -> FinishedTaskState {\n+        let (stateful, has_invalidator, tasks) = CURRENT_TASK_STATE.with(|cell| {\n             let CurrentTaskState {\n                 tasks_to_notify,\n                 stateful,\n+                has_invalidator,\n                 ..\n             } = &mut *cell.write().unwrap();\n-            (*stateful, take(tasks_to_notify))\n+            (*stateful, *has_invalidator, take(tasks_to_notify))\n         });\n \n         if !tasks.is_empty() {\n             self.backend.invalidate_tasks(&tasks, self);\n         }\n-        stateful\n+        FinishedTaskState {\n+            stateful,\n+            has_invalidator,\n+        }\n     }\n \n     pub fn backend(&self) -> &B {\n         &self.backend\n     }\n }\n \n+struct FinishedTaskState {\n+    /// True if the task has state in cells\n+    stateful: bool,\n+\n+    /// True if the task uses an external invalidator\n+    has_invalidator: bool,\n+}\n+\n impl<B: Backend + 'static> TurboTasksCallApi for TurboTasks<B> {\n     fn dynamic_call(\n         &self,\n@@ -1743,6 +1759,15 @@ pub fn mark_stateful() -> SerializationInvalidator {\n     })\n }\n \n+pub fn mark_invalidator() {\n+    CURRENT_TASK_STATE.with(|cell| {\n+        let CurrentTaskState {\n+            has_invalidator, ..\n+        } = &mut *cell.write().unwrap();\n+        *has_invalidator = true;\n+    })\n+}\n+\n pub fn prevent_gc() {\n     // There is a hack in UpdateCellOperation that need to be updated when this is changed.\n     mark_stateful();"
        },
        {
            "sha": "f1eb4134d5b3785872f1f75f0d21707322c539bd",
            "filename": "turbopack/crates/turbo-tasks/src/native_function.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 14,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -144,13 +144,6 @@ pub struct FunctionMeta {\n     /// task-local state. The function call itself will not be cached, but cells will be created on\n     /// the parent task.\n     pub local: bool,\n-\n-    /// If true, the function will be allowed to call `get_invalidator`. If this is false, the\n-    /// `get_invalidator` function will panic on calls.\n-    pub invalidator: bool,\n-\n-    /// If true, the function is statically analyzable immutable.\n-    pub immutable: bool,\n }\n \n /// A native (rust) turbo-tasks function. It's used internally by\n@@ -242,13 +235,7 @@ impl NativeFunction {\n     /// Executed the function\n     pub fn execute(&'static self, this: Option<RawVc>, arg: &dyn MagicAny) -> NativeTaskFuture {\n         match (self.implementation).functor(this, arg) {\n-            Ok(functor) => {\n-                if !self.function_meta.invalidator {\n-                    return Box::pin(crate::invalidation::disallow_invalidator(functor));\n-                }\n-\n-                functor\n-            }\n+            Ok(functor) => functor,\n             Err(err) => Box::pin(async { Err(err) }),\n         }\n     }"
        },
        {
            "sha": "ac6983ac6db4e9e24f5d13b02ea949662745177f",
            "filename": "turbopack/crates/turbopack-core/src/version.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fversion.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fversion.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fversion.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -272,7 +272,7 @@ pub struct VersionState {\n \n #[turbo_tasks::value_impl]\n impl VersionState {\n-    #[turbo_tasks::function(invalidator)]\n+    #[turbo_tasks::function]\n     pub fn get(&self) -> Vc<Box<dyn Version>> {\n         TraitRef::cell(self.version.get().0.clone())\n     }"
        },
        {
            "sha": "29cce8cecb1b6cc799bfb99574e2ede81a721667",
            "filename": "turbopack/crates/turbopack-dev-server/src/source/asset_graph.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fasset_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fasset_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-dev-server%2Fsrc%2Fsource%2Fasset_graph.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -87,7 +87,7 @@ impl AssetGraphContentSource {\n         })\n     }\n \n-    #[turbo_tasks::function(invalidator)]\n+    #[turbo_tasks::function]\n     async fn all_assets_map(&self) -> Result<Vc<OutputAssetsMap>> {\n         Ok(Vc::cell(\n             expand("
        },
        {
            "sha": "a8a25b03917b9d4d97b95a707c18914494548d14",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5dac44820cdb54bcffeb31fdf534bed75db93649/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=5dac44820cdb54bcffeb31fdf534bed75db93649",
            "patch": "@@ -411,7 +411,7 @@ impl ModuleTypeResult {\n \n #[turbo_tasks::value_impl]\n impl EcmascriptParsable for EcmascriptModuleAsset {\n-    #[turbo_tasks::function(invalidator)]\n+    #[turbo_tasks::function]\n     async fn failsafe_parse(self: Vc<Self>) -> Result<Vc<ParseResult>> {\n         let real_result = self.parse();\n         let this = self.await?;"
        }
    ],
    "stats": {
        "total": 530,
        "additions": 312,
        "deletions": 218
    }
}