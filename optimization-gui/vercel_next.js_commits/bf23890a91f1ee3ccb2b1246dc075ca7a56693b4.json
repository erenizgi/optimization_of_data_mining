{
    "author": "lubieowoce",
    "message": "[Cache Components] Fast setImmediate (#86018)\n\n> This place is not a place of honor... no highly esteemed deed is\ncommemorated here... nothing valued is here.\n> What is here was dangerous and repulsive to us. This message is a\nwarning about danger.\n\nyou think you know when setImmediate is supposed to run? no you don't\n\n---\n\nThis PR introduces a patch to the Node `setImmediate` builtin. The patch\nis enabled by calling\n`DANGEROUSLY_runPendingImmediatesAfterCurrentTask()`. All immediates\nscheduled after that point (until the end of the task) will be captured\nand executed right after that task (after `process.nextTick` and\n`microtasks`). This applies to immediates scheduled from immediates as\nwell.\n\nThis is relevant when scheduling back-to-back timeouts for staged\nrendering in Cache Components:\n\n```ts\nsetTimeout(() => {\n  // runs first\n  \n  DANGEROUSLY_runPendingImmediatesAfterCurrentTask() // enable the patch\n  setImmediate(() => {\n    // runs second (normally, it'd run last!)\n  })\n})\n\nsetTimeout(() => {\n  // runs third\n})\n```\nthe immediate scheduled from inside the first timeout will **always**\nrun before the second timeout.\n\nA side-effect of this is that `setImmediate` will no longer be\nconsidered IO in the Cache Components rendering model, because\nimmediates will always run before we advance the stage (or abort a\nprerender), and thus can't result in a dynamic hole. This brings the\nruntime behavior in line with React Devtools, which does not show\n`setImmediate` as IO.\n\nThis patch also has some observable differences in behavior from native\n`setImmediate`, mostly to do with uncaught errors:\n1. sync errors in `process.nextTick` no longer interrupt\n`processTicksAndRejections` (which would make us move onto the next\nevent loop step, and run the rest of the nextTick queue after the next\ntask, breaking our scheduling). They're rethrown in a microtask, which\nchanges the timing of `uncaughtException` a bit.\n2. unhandled rejections will trigger `unhandledRejection` after _all_\nfast immediates are done executing, not after each immediate. This\nhappens because our userspace immediate scheduling relies on nextTick,\nand [rejections are only processed after everything else in\n`processTicksAndRejections` is\ndone](https://github.com/nodejs/node/blob/d546e7fd0bc3cbb4bcc2baae6f3aa44d2e81a413/lib/internal/process/task_queues.js#L104-L105).\n\nWe hope that these divergences in behavior are niche enough to not\naffect any real world code. Both are potentially fixable by managing our\nown nextTick queue, more, but we'll try to avoid that complexity for\nnow.",
    "sha": "bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
    "files": [
        {
            "sha": "73d189c59dd5d3d014bb5e98956d446bd0ccc09d",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 14,
            "deletions": 1,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -951,5 +951,18 @@\n   \"950\": \"The manifests singleton was not initialized.\",\n   \"951\": \"The client reference manifest for route \\\"%s\\\" does not exist.\",\n   \"952\": \"Cannot access \\\"%s\\\" without a work store.\",\n-  \"953\": \"This is a proxied client reference manifest. The property \\\"%s\\\" is not handled.\"\n+  \"953\": \"This is a proxied client reference manifest. The property \\\"%s\\\" is not handled.\",\n+  \"954\": \"Cannot start capturing immediates again without finishing the previous task (state: %s)\",\n+  \"955\": \"An unexpected error occurred while executing immediates\",\n+  \"956\": \"performWork can only be called while waiting (state: %s)\",\n+  \"957\": \"Cannot stop capturing immediates before execution is finished (state: %s)\",\n+  \"958\": \"Expected all captured immediates to have been executed (state: %s)\",\n+  \"959\": \"scheduleWorkAfterTicksAndMicrotasks can only be called while waiting (state: %s)\",\n+  \"960\": \"DANGEROUSLY_runPendingImmediatesAfterCurrentTask cannot be called in the edge runtime\",\n+  \"961\": \"The \\\"callback\\\" argument must be of type function. Received %s\",\n+  \"962\": \"expectNoPendingImmediates cannot be called in the edge runtime\",\n+  \"963\": \"Fast setImmediate is not available in the edge runtime.\",\n+  \"964\": \"An unexpected error occurred while starting to capture immediates\",\n+  \"965\": \"Expected setImmediate to reject invalid arguments\",\n+  \"966\": \"Expected process.nextTick to reject invalid arguments\"\n }"
        },
        {
            "sha": "d800a0b0a6ea7d744441f17bdc20e36105624e40",
            "filename": "packages/next/src/server/app-render/app-render-prerender-utils.ts",
            "status": "modified",
            "additions": 26,
            "deletions": 8,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-prerender-utils.ts?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -1,5 +1,9 @@\n import { InvariantError } from '../../shared/lib/invariant-error'\n import { createAtomicTimerGroup } from './app-render-scheduling'\n+import {\n+  DANGEROUSLY_runPendingImmediatesAfterCurrentTask,\n+  expectNoPendingImmediates,\n+} from '../node-environment-extensions/fast-set-immediate.external'\n \n /**\n  * This is a utility function to make scheduling sequential tasks that run back to back easier.\n@@ -20,16 +24,21 @@ export function prerenderAndAbortInSequentialTasks<R>(\n       let pendingResult: Promise<R>\n       scheduleTimeout(() => {\n         try {\n+          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n           pendingResult = prerender()\n           pendingResult.catch(() => {})\n         } catch (err) {\n           reject(err)\n         }\n       })\n-\n       scheduleTimeout(() => {\n-        abort()\n-        resolve(pendingResult)\n+        try {\n+          expectNoPendingImmediates()\n+          abort()\n+          resolve(pendingResult)\n+        } catch (err) {\n+          reject(err)\n+        }\n       })\n     })\n   }\n@@ -55,20 +64,29 @@ export function prerenderAndAbortInSequentialTasksWithStages<R>(\n       let pendingResult: Promise<R>\n       scheduleTimeout(() => {\n         try {\n+          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n           pendingResult = prerender()\n           pendingResult.catch(() => {})\n         } catch (err) {\n           reject(err)\n         }\n       })\n-\n       scheduleTimeout(() => {\n-        advanceStage()\n+        try {\n+          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+          advanceStage()\n+        } catch (err) {\n+          reject(err)\n+        }\n       })\n-\n       scheduleTimeout(() => {\n-        abort()\n-        resolve(pendingResult)\n+        try {\n+          expectNoPendingImmediates()\n+          abort()\n+          resolve(pendingResult)\n+        } catch (err) {\n+          reject(err)\n+        }\n       })\n     })\n   }"
        },
        {
            "sha": "c7afbea7d0746e339bd10bbb4058a1af4f2a6b03",
            "filename": "packages/next/src/server/app-render/app-render-render-utils.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-render-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-render-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-render-utils.ts?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -1,5 +1,9 @@\n import { InvariantError } from '../../shared/lib/invariant-error'\n import { createAtomicTimerGroup } from './app-render-scheduling'\n+import {\n+  DANGEROUSLY_runPendingImmediatesAfterCurrentTask,\n+  expectNoPendingImmediates,\n+} from '../node-environment-extensions/fast-set-immediate.external'\n \n /**\n  * This is a utility function to make scheduling sequential tasks that run back to back easier.\n@@ -20,15 +24,21 @@ export function scheduleInSequentialTasks<R>(\n       let pendingResult: R | Promise<R>\n       scheduleTimeout(() => {\n         try {\n+          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n           pendingResult = render()\n         } catch (err) {\n           reject(err)\n         }\n       })\n \n       scheduleTimeout(() => {\n-        followup()\n-        resolve(pendingResult)\n+        try {\n+          expectNoPendingImmediates()\n+          followup()\n+          resolve(pendingResult)\n+        } catch (err) {\n+          reject(err)\n+        }\n       })\n     })\n   }\n@@ -55,6 +65,7 @@ export function pipelineInSequentialTasks<A, B, C>(\n       let oneResult: A\n       scheduleTimeout(() => {\n         try {\n+          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n           oneResult = one()\n         } catch (err) {\n           clearTimeout(twoId)\n@@ -69,6 +80,7 @@ export function pipelineInSequentialTasks<A, B, C>(\n         // if `one` threw, then this timeout would've been cleared,\n         // so if we got here, we're guaranteed to have a value.\n         try {\n+          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n           twoResult = two(oneResult!)\n         } catch (err) {\n           clearTimeout(threeId)\n@@ -82,6 +94,7 @@ export function pipelineInSequentialTasks<A, B, C>(\n         // if `two` threw, then this timeout would've been cleared,\n         // so if we got here, we're guaranteed to have a value.\n         try {\n+          expectNoPendingImmediates()\n           threeResult = three(twoResult!)\n         } catch (err) {\n           clearTimeout(fourId)"
        },
        {
            "sha": "55ba8f4b3a54a6c95435d85cf60e07cd5d56edd9",
            "filename": "packages/next/src/server/app-render/app-render-scheduling.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-scheduling.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-scheduling.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render-scheduling.ts?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -1,4 +1,5 @@\n import { InvariantError } from '../../shared/lib/invariant-error'\n+import { unpatchedSetImmediate } from '../node-environment-extensions/fast-set-immediate.external'\n \n /*\n ==========================\n@@ -112,12 +113,15 @@ export function createAtomicTimerGroup(delayMs = 0) {\n     let didFirstTimerRun = false\n \n     // As a sanity check, we schedule an immediate from the first timeout\n-    // to check if the execution was interrupted.\n+    // to check if the execution was interrupted (i.e. if it ran between the timeouts).\n+    // Note that we're deliberately bypassing the \"fast setImmediate\" patch here --\n+    // otherwise, this check would always fail, because the immediate\n+    // would always run before the second timeout.\n     let didImmediateRun = false\n     function runFirstCallback(callback: () => void) {\n       didFirstTimerRun = true\n       if (shouldAttemptPatching) {\n-        setImmediate(() => {\n+        unpatchedSetImmediate(() => {\n           didImmediateRun = true\n         })\n       }"
        },
        {
            "sha": "cec611ba292d8f22ab1ef80265f922f9613341b7",
            "filename": "packages/next/src/server/node-environment-extensions/fast-set-immediate.external.test.ts",
            "status": "added",
            "additions": 1445,
            "deletions": 0,
            "changes": 1445,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Ffast-set-immediate.external.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Ffast-set-immediate.external.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Ffast-set-immediate.external.test.ts?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,1445 @@\n+import { AsyncLocalStorage } from 'node:async_hooks'\n+import { createPromiseWithResolvers } from '../../shared/lib/promise-with-resolvers'\n+import {\n+  DANGEROUSLY_runPendingImmediatesAfterCurrentTask,\n+  expectNoPendingImmediates,\n+} from './fast-set-immediate.external'\n+import { createAtomicTimerGroup } from '../app-render/app-render-scheduling'\n+\n+function createLogger() {\n+  const logs: string[] = []\n+\n+  const log = (...args: any[]) => {\n+    const { inspect } = require('node:util') as typeof import('node:util')\n+    const { writeFileSync } = require('node:fs') as typeof import('node:fs')\n+\n+    let logLine = args\n+      .map((arg) =>\n+        typeof arg === 'string' ? arg : inspect(arg, { colors: true })\n+      )\n+      .join(' ')\n+\n+    logs.push(logLine)\n+    writeFileSync(process.stdout.fd, logLine + '\\n')\n+  }\n+  return { logs, log }\n+}\n+\n+it('runs immediates after each task', async () => {\n+  const { log, logs } = createLogger()\n+  const done = createPromiseWithResolvers<void>()\n+\n+  setTimeout(() => {\n+    DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+    log('timeout 1')\n+    setImmediate(() => {\n+      log('timeout 1 -> immediate 1')\n+      process.nextTick(() => {\n+        log('timeout 1 -> immediate 1 -> nextTick 1')\n+        queueMicrotask(() => {\n+          log('timeout 1 -> immediate 1 -> nextTick 1 -> microtask 1')\n+        })\n+        queueMicrotask(() => {\n+          process.nextTick(() => {\n+            log(\n+              'timeout 1 -> immediate 1 -> nextTick 1 -> microtask 2 -> nextTick'\n+            )\n+          })\n+        })\n+      })\n+    })\n+    setImmediate(() => {\n+      log('timeout 1 -> immediate 2')\n+    })\n+    process.nextTick(() => {\n+      log('timeout 1 -> nextTick 1')\n+      queueMicrotask(() => {\n+        log('timeout 1 -> nextTick 1 -> microtask 1')\n+      })\n+      queueMicrotask(() => {\n+        process.nextTick(() => {\n+          log('timeout 1 -> nextTick 1 -> microtask 2 -> nextTick')\n+        })\n+      })\n+      process.nextTick(() => {\n+        log('timeout 1 -> nextTick 1 -> nextTick 1')\n+      })\n+    })\n+  })\n+\n+  setTimeout(() => {\n+    DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+    log('timeout 2')\n+    setImmediate(() => {\n+      log('timeout 2 -> immediate 1')\n+      setImmediate(() => {\n+        log('timeout 2 -> immediate 1 -> immediate 1')\n+      })\n+    })\n+  })\n+\n+  setTimeout(() => {\n+    log('timeout 3')\n+    try {\n+      expectNoPendingImmediates()\n+      done.resolve()\n+    } catch (err) {\n+      done.reject(err)\n+    }\n+  })\n+\n+  await done.promise\n+\n+  expect(logs).toEqual([\n+    // ===================================\n+    'timeout 1',\n+    'timeout 1 -> nextTick 1',\n+    'timeout 1 -> nextTick 1 -> nextTick 1',\n+    'timeout 1 -> nextTick 1 -> microtask 1',\n+    'timeout 1 -> nextTick 1 -> microtask 2 -> nextTick',\n+    // ======================\n+    'timeout 1 -> immediate 1',\n+    'timeout 1 -> immediate 1 -> nextTick 1',\n+    'timeout 1 -> immediate 1 -> nextTick 1 -> microtask 1',\n+    'timeout 1 -> immediate 1 -> nextTick 1 -> microtask 2 -> nextTick',\n+    // ======================\n+    'timeout 1 -> immediate 2',\n+    // ===================================\n+    'timeout 2',\n+    // ======================\n+    'timeout 2 -> immediate 1',\n+    // ======================\n+    'timeout 2 -> immediate 1 -> immediate 1',\n+    // ===================================\n+    'timeout 3',\n+  ])\n+})\n+\n+it('only affects the task it is called in', async () => {\n+  const { log, logs } = createLogger()\n+  const done = createPromiseWithResolvers<void>()\n+\n+  // This test includes a native setImmediate, so we want to avoid\n+  // flakiness due to timer/immediate interleaving\n+  const scheduleTimeout = createAtomicTimerGroup()\n+\n+  scheduleTimeout(() => {\n+    DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+    log('timeout 1')\n+    setImmediate(() => {\n+      log('timeout 1 -> immediate 1 (fast)')\n+      setImmediate(() => {\n+        log('timeout 1 -> immediate 1 (fast) -> immediate 1 (fast)')\n+      })\n+    })\n+  })\n+\n+  scheduleTimeout(() => {\n+    log('timeout 2')\n+    try {\n+      expectNoPendingImmediates()\n+      // resolved elsewhere\n+    } catch (err) {\n+      done.reject(err)\n+    }\n+\n+    // NOTE: native immediate\n+    setImmediate(() => {\n+      log('timeout 2 -> immediate 1 (native)')\n+      done.resolve()\n+    })\n+  })\n+\n+  scheduleTimeout(() => {\n+    log('timeout 3')\n+    try {\n+      expectNoPendingImmediates()\n+      // resolved elsewhere\n+    } catch (err) {\n+      done.reject(err)\n+    }\n+  })\n+\n+  await done.promise\n+\n+  expect(logs).toEqual([\n+    // ===================================\n+    'timeout 1',\n+    // ======================\n+    'timeout 1 -> immediate 1 (fast)',\n+    // ======================\n+    'timeout 1 -> immediate 1 (fast) -> immediate 1 (fast)',\n+    // ===================================\n+    'timeout 2',\n+    // ===================================\n+    'timeout 3',\n+    // ======================\n+    'timeout 2 -> immediate 1 (native)',\n+  ])\n+})\n+\n+it('does not run immediates scheduled before it was called', async () => {\n+  const { log, logs } = createLogger()\n+  const done = createPromiseWithResolvers<void>()\n+\n+  // This test includes a native setImmediate, so we want to avoid\n+  // flakiness due to timer/immediate interleaving\n+  const scheduleTimeout = createAtomicTimerGroup()\n+\n+  scheduleTimeout(() => {\n+    log('timeout 1')\n+\n+    // NOTE: native immediate\n+    setImmediate(() => {\n+      log('timeout 1 -> immediate 1 (native)')\n+      done.resolve()\n+    })\n+\n+    DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+    setImmediate(() => {\n+      log('timeout 1 -> immediate 2 (fast)')\n+    })\n+  })\n+\n+  scheduleTimeout(() => {\n+    log('timeout 2')\n+    try {\n+      expectNoPendingImmediates()\n+      // resolved elsewhere\n+    } catch (err) {\n+      done.reject(err)\n+    }\n+  })\n+\n+  await done.promise\n+\n+  expect(logs).toEqual([\n+    // ===================================\n+    'timeout 1',\n+    // ======================\n+    'timeout 1 -> immediate 2 (fast)',\n+    // ===================================\n+    'timeout 2',\n+    // ======================\n+    'timeout 1 -> immediate 1 (native)',\n+  ])\n+})\n+\n+it('runs immediates scheduled in nextTick', async () => {\n+  const { log, logs } = createLogger()\n+  const done = createPromiseWithResolvers<void>()\n+\n+  setTimeout(() => {\n+    DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+    log('timeout 1')\n+    process.nextTick(() => {\n+      setImmediate(() => {\n+        log('timeout 1 -> nextTick -> immediate 1')\n+        process.nextTick(() => {\n+          setImmediate(() => {\n+            log(\n+              'timeout 1 -> nextTick -> immediate 1 -> nextTick -> immediate 1'\n+            )\n+          })\n+        })\n+      })\n+    })\n+  })\n+\n+  setTimeout(() => {\n+    log('timeout 2')\n+    try {\n+      expectNoPendingImmediates()\n+      done.resolve()\n+    } catch (err) {\n+      done.reject(err)\n+    }\n+  })\n+\n+  await done.promise\n+\n+  expect(logs).toEqual([\n+    // ===================================\n+    'timeout 1',\n+    // ======================\n+    'timeout 1 -> nextTick -> immediate 1',\n+    // ======================\n+    'timeout 1 -> nextTick -> immediate 1 -> nextTick -> immediate 1',\n+    // ===================================\n+    'timeout 2',\n+  ])\n+})\n+\n+it('runs ticks and microtasks from immediates before moving onto the next task', async () => {\n+  const { log, logs } = createLogger()\n+  const done = createPromiseWithResolvers<void>()\n+\n+  setTimeout(() => {\n+    DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+    log('timeout 1')\n+    setImmediate(() => {\n+      log('timeout 1 -> immediate 1')\n+      queueMicrotask(() => {\n+        log('timeout 1 -> immediate 1 -> microtask 1')\n+        queueMicrotask(() => {\n+          log('timeout 1 -> immediate 1 -> microtask 1 -> microtask 1')\n+        })\n+        process.nextTick(() => {\n+          log('timeout 1 -> immediate 1 -> microtask 1 -> nextTick')\n+        })\n+      })\n+      process.nextTick(() => {\n+        log('timeout 1 -> immediate 1 -> nextTick')\n+      })\n+    })\n+  })\n+\n+  setTimeout(() => {\n+    log('timeout 2')\n+    try {\n+      expectNoPendingImmediates()\n+      done.resolve()\n+    } catch (err) {\n+      done.reject(err)\n+    }\n+  })\n+\n+  await done.promise\n+\n+  expect(logs).toEqual([\n+    // ===================================\n+    'timeout 1',\n+    // ======================\n+    'timeout 1 -> immediate 1',\n+    'timeout 1 -> immediate 1 -> nextTick',\n+    'timeout 1 -> immediate 1 -> microtask 1',\n+    'timeout 1 -> immediate 1 -> microtask 1 -> microtask 1',\n+    'timeout 1 -> immediate 1 -> microtask 1 -> nextTick',\n+    // ===================================\n+    'timeout 2',\n+  ])\n+})\n+\n+describe('alternate sources of immediates', () => {\n+  it('promisify(setImmediate)', async () => {\n+    // `setImmediate` defines a `util.promisify.custom`, and so does our patch.\n+    const { log, logs } = createLogger()\n+    const done = createPromiseWithResolvers<void>()\n+\n+    const { promisify } = require('node:util') as typeof import('node:util')\n+    const promisifiedSetImmediate = promisify(setImmediate)\n+\n+    setTimeout(() => {\n+      DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+      log('timeout 1')\n+      promisifiedSetImmediate().then(() => {\n+        log('timeout 1 -> immediate 1')\n+      })\n+    })\n+\n+    setTimeout(() => {\n+      log('timeout 2')\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1',\n+      // ======================\n+      'timeout 1 -> immediate 1',\n+      // ======================\n+      'timeout 2',\n+    ])\n+  })\n+\n+  it('require(\"node:timers\").setImmediate', async () => {\n+    const { log, logs } = createLogger()\n+    const done = createPromiseWithResolvers<void>()\n+\n+    const timers = require('node:timers') as typeof import('node:timers')\n+\n+    setTimeout(() => {\n+      DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+      log('timeout 1')\n+      timers.setImmediate(() => {\n+        log('timeout 1 -> immediate 1')\n+      })\n+    })\n+\n+    setTimeout(() => {\n+      log('timeout 2')\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1',\n+      // ======================\n+      'timeout 1 -> immediate 1',\n+      // ======================\n+      'timeout 2',\n+    ])\n+  })\n+\n+  it('require(\"node:timers/promises\").setImmediate', async () => {\n+    const { log, logs } = createLogger()\n+    const done = createPromiseWithResolvers<void>()\n+\n+    const timersPromises =\n+      require('node:timers/promises') as typeof import('node:timers/promises')\n+\n+    setTimeout(() => {\n+      DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+      log('timeout 1')\n+      timersPromises.setImmediate().then(() => {\n+        log('timeout 1 -> immediate 1')\n+      })\n+    })\n+\n+    setTimeout(() => {\n+      log('timeout 2')\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1',\n+      // ======================\n+      'timeout 1 -> immediate 1',\n+      // ======================\n+      'timeout 2',\n+    ])\n+  })\n+})\n+\n+describe('patched function behavior', () => {\n+  describe('setImmediate', () => {\n+    it('extra arguments are passed to callback', async () => {\n+      const done = createPromiseWithResolvers<void>()\n+      const passedArgs = [1, 2, 3]\n+\n+      setTimeout(() => {\n+        DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+        setImmediate(\n+          (...receivedArgs) => {\n+            try {\n+              expect(passedArgs).toEqual(receivedArgs)\n+              done.resolve()\n+            } catch (err) {\n+              done.reject(err)\n+            }\n+          },\n+          ...passedArgs\n+        )\n+      })\n+\n+      await done.promise\n+    })\n+\n+    it('validates the first argument', async () => {\n+      const done = createPromiseWithResolvers<void>()\n+\n+      setTimeout(() => {\n+        DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+        try {\n+          expect(() => setImmediate(undefined as any)).toThrow(\n+            /The \"callback\" argument must be of type function. Received undefined/\n+          )\n+          expect(() => setImmediate('not a callback' as any)).toThrow(\n+            /The \"callback\" argument must be of type function. Received type string/\n+          )\n+          done.resolve()\n+        } catch (err) {\n+          done.reject(err)\n+        }\n+      })\n+\n+      await done.promise\n+    })\n+  })\n+\n+  describe('process.nextTick', () => {\n+    it('extra arguments are passed to callback', async () => {\n+      const done = createPromiseWithResolvers<void>()\n+      const passedArgs = [1, 2, 3]\n+\n+      setTimeout(() => {\n+        DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+        process.nextTick(\n+          (...receivedArgs: unknown[]) => {\n+            try {\n+              expect(passedArgs).toEqual(receivedArgs)\n+              done.resolve()\n+            } catch (err) {\n+              done.reject(err)\n+            }\n+          },\n+          ...passedArgs\n+        )\n+      })\n+\n+      await done.promise\n+    })\n+\n+    it('validates the first argument', async () => {\n+      const done = createPromiseWithResolvers<void>()\n+\n+      setTimeout(() => {\n+        DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+        try {\n+          expect(() => process.nextTick(undefined as any)).toThrow(\n+            /The \"callback\" argument must be of type function. Received undefined/\n+          )\n+          expect(() => process.nextTick('not a callback' as any)).toThrow(\n+            /The \"callback\" argument must be of type function. Received type string/\n+          )\n+          done.resolve()\n+        } catch (err) {\n+          done.reject(err)\n+        }\n+      })\n+\n+      await done.promise\n+    })\n+  })\n+})\n+\n+describe('async context propagation', () => {\n+  it('propagates AsyncLocalStorage to setImmediate', async () => {\n+    const { log, logs } = createLogger()\n+    const done = createPromiseWithResolvers<void>()\n+    const Ctx = new AsyncLocalStorage<string>()\n+\n+    Ctx.run('outer', () => {\n+      setTimeout(() => {\n+        DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+        log(`timeout 1 :: ${Ctx.getStore()}`)\n+        setImmediate(() => {\n+          // The outer context should be readable here\n+          log(`timeout 1 -> immediate 1 :: ${Ctx.getStore()}`)\n+          // Shadow the outer context\n+          Ctx.run('inner', () => {\n+            setImmediate(() => {\n+              // The inner context should be readable here\n+              log(\n+                `timeout 1 -> immediate 1 -> immediate 1 :: ${Ctx.getStore()}`\n+              )\n+            })\n+          })\n+        })\n+      })\n+    })\n+\n+    setTimeout(() => {\n+      // The context should not be readable here\n+      log(`timeout 2 :: ${Ctx.getStore()}`)\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1 :: outer',\n+      // ======================\n+      'timeout 1 -> immediate 1 :: outer',\n+      // ======================\n+      'timeout 1 -> immediate 1 -> immediate 1 :: inner',\n+      // ===================================\n+      'timeout 2 :: undefined',\n+    ])\n+  })\n+\n+  it('does not break AsyncLocalStorage propagation in process.nextTick', async () => {\n+    // We don't alter the implementation of `process.nextTick` much,\n+    // but we do patch it, so as a sanity check it's worth verifying that\n+    // we're not breaking async context propagation.\n+\n+    const { log, logs } = createLogger()\n+    const done = createPromiseWithResolvers<void>()\n+    const Ctx = new AsyncLocalStorage<string>()\n+\n+    Ctx.run('hello', () => {\n+      setTimeout(() => {\n+        DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+        log(`timeout 1 :: ${Ctx.getStore()}`)\n+        process.nextTick(() => {\n+          // the context should be readable here\n+          log(`timeout 1 -> nextTick :: ${Ctx.getStore()}`)\n+        })\n+      })\n+    })\n+\n+    setTimeout(() => {\n+      // The context should not be readable here\n+      log(`timeout 2 :: ${Ctx.getStore()}`)\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1 :: hello',\n+      // ======================\n+      'timeout 1 -> nextTick :: hello',\n+      // ===================================\n+      'timeout 2 :: undefined',\n+    ])\n+  })\n+})\n+\n+describe('allows cancelling immediates', () => {\n+  it('synchronously', async () => {\n+    const { log, logs } = createLogger()\n+\n+    const done = createPromiseWithResolvers<void>()\n+\n+    setTimeout(() => {\n+      DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+      log('timeout 1')\n+      setImmediate(() => {\n+        log('timeout 1 -> immediate 1')\n+      })\n+      const immediate2 = setImmediate(() => {\n+        log('timeout 1 -> immediate 2')\n+      })\n+      clearImmediate(immediate2)\n+    })\n+\n+    setTimeout(() => {\n+      log('timeout 2')\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1',\n+      // ======================\n+      'timeout 1 -> immediate 1',\n+      // ===================================\n+      'timeout 2',\n+    ])\n+  })\n+\n+  it('from a nextTick', async () => {\n+    const { log, logs } = createLogger()\n+\n+    const done = createPromiseWithResolvers<void>()\n+\n+    setTimeout(() => {\n+      DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+      log('timeout 1')\n+      setImmediate(() => {\n+        log('timeout 1 -> immediate 1')\n+      })\n+      const immediate2 = setImmediate(() => {\n+        log('timeout 1 -> immediate 2')\n+      })\n+      process.nextTick(() => {\n+        clearImmediate(immediate2)\n+      })\n+    })\n+    setTimeout(() => {\n+      log('timeout 2')\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1',\n+      // ======================\n+      'timeout 1 -> immediate 1',\n+      // ===================================\n+      'timeout 2',\n+    ])\n+  })\n+\n+  it('from another immediate', async () => {\n+    const { log, logs } = createLogger()\n+\n+    const done = createPromiseWithResolvers<void>()\n+\n+    setTimeout(() => {\n+      DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+      log('timeout 1')\n+      setImmediate(() => {\n+        log('timeout 1 -> immediate 1')\n+        clearImmediate(immediate2)\n+      })\n+      const immediate2 = setImmediate(() => {\n+        log('timeout 1 -> immediate 2')\n+      })\n+    })\n+    setTimeout(() => {\n+      log('timeout 2')\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1',\n+      // ======================\n+      'timeout 1 -> immediate 1',\n+      // ===================================\n+      'timeout 2',\n+    ])\n+  })\n+\n+  it('promisified - with an AbortSignal after creating', async () => {\n+    const { log, logs } = createLogger()\n+\n+    const done = createPromiseWithResolvers<void>()\n+\n+    const { promisify } = require('node:util') as typeof import('node:util')\n+    const promisifiedSetImmediate = promisify(setImmediate)\n+\n+    const abortError = new Error('Stop right there')\n+    let thrownOnAbort: unknown\n+\n+    setTimeout(() => {\n+      DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+      log('timeout 1')\n+      setImmediate(() => {\n+        log('timeout 1 -> immediate 1')\n+      })\n+\n+      const abortController = new AbortController()\n+\n+      promisifiedSetImmediate(undefined, {\n+        signal: abortController.signal,\n+      }).then(\n+        () => {\n+          log('timeout 1 -> immediate 2')\n+        },\n+        (err) => {\n+          thrownOnAbort = err\n+        }\n+      )\n+\n+      abortController.abort(abortError)\n+    })\n+    setTimeout(() => {\n+      log('timeout 2')\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1',\n+      // ======================\n+      'timeout 1 -> immediate 1',\n+      // ===================================\n+      'timeout 2',\n+    ])\n+    expect(thrownOnAbort).toBe(abortError)\n+  })\n+\n+  it('promisified - with an AbortSignal that was already aborted', async () => {\n+    const { log, logs } = createLogger()\n+\n+    const done = createPromiseWithResolvers<void>()\n+\n+    const { promisify } = require('node:util') as typeof import('node:util')\n+    const promisifiedSetImmediate = promisify(setImmediate)\n+\n+    const abortError = new Error('Stop right there')\n+    let thrownOnAbort: unknown\n+\n+    setTimeout(() => {\n+      DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+\n+      log('timeout 1')\n+      setImmediate(() => {\n+        log('timeout 1 -> immediate 1')\n+      })\n+\n+      const abortController = new AbortController()\n+      abortController.abort(abortError)\n+\n+      promisifiedSetImmediate(undefined, {\n+        signal: abortController.signal,\n+      }).then(\n+        () => {\n+          log('timeout 1 -> immediate 2')\n+        },\n+        (err) => {\n+          thrownOnAbort = err\n+        }\n+      )\n+    })\n+    setTimeout(() => {\n+      log('timeout 2')\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1',\n+      // ======================\n+      'timeout 1 -> immediate 1',\n+      // ===================================\n+      'timeout 2',\n+    ])\n+    expect(thrownOnAbort).toBe(abortError)\n+  })\n+})\n+\n+describe('uncaught errors in setImmediate do not affect surrounding tasks or other immediates', () => {\n+  type TriggeredUncaught = {\n+    error: unknown\n+    kind: 'uncaughtException' | 'unhandledRejection'\n+  }\n+\n+  const trackUncaughtErrors = (\n+    handler: (\n+      error: unknown,\n+      kind: 'uncaughtException' | 'unhandledRejection'\n+    ) => void\n+  ) => {\n+    // We have to use this instead of `process.on(\"uncaughtException\")`,\n+    // because if an actual \"uncaughtException\" event fires, Jest will fail the test.\n+    const onUncaughtException = (err: unknown) => {\n+      handler(err, 'uncaughtException')\n+    }\n+    process.setUncaughtExceptionCaptureCallback(onUncaughtException)\n+\n+    // If an unhandled rejection occurs, Jest will fail the test.\n+    // Here, we're triggering one deliberately, so we need to work around Jest's behavior.\n+    // This seems to be the best we can do, and there's no official solution:\n+    // https://github.com/jestjs/jest/issues/5620\n+    const prevListeners = process.rawListeners('unhandledRejection')\n+    process.removeAllListeners('unhandledRejection')\n+    const onUnhandledRejection = (err: unknown) => {\n+      handler(err, 'unhandledRejection')\n+    }\n+    process.on('unhandledRejection', onUnhandledRejection)\n+\n+    return {\n+      [Symbol.dispose]() {\n+        process.setUncaughtExceptionCaptureCallback(null)\n+\n+        process.off('unhandledRejection', onUnhandledRejection)\n+        for (const listener of prevListeners) {\n+          process.on(\n+            'unhandledRejection',\n+            listener as NodeJS.UnhandledRejectionListener\n+          )\n+        }\n+      },\n+    }\n+  }\n+\n+  it('sync errors trigger uncaughtException', async () => {\n+    const { log, logs } = createLogger()\n+    const done = createPromiseWithResolvers<void>()\n+\n+    const Ctx = new AsyncLocalStorage<string>()\n+    const contextValue = 'hello'\n+\n+    let triggeredError: TriggeredUncaught | undefined = undefined\n+    using _ = trackUncaughtErrors((error, kind) => {\n+      log(`${kind} - ${Ctx.getStore()}`)\n+      triggeredError = { error, kind }\n+    })\n+\n+    const error = new Error('kaboom')\n+\n+    Ctx.run(contextValue, () => {\n+      setTimeout(() => {\n+        DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+        log('timeout 1')\n+\n+        setImmediate(() => {\n+          log('timeout 1 -> immediate 1')\n+\n+          // In the patch, we rethrow the synchronous error asynchronously,\n+          // so unfortunately ticks will run before uncaughtException.\n+          process.nextTick(() => {\n+            log('timeout 1 -> immediate 1 -> nextTick')\n+          })\n+\n+          throw error\n+        })\n+\n+        setImmediate(() => {\n+          log('timeout 1 -> immediate 2')\n+        })\n+      })\n+    })\n+\n+    setTimeout(() => {\n+      log('timeout 2')\n+      // This ensures that we don't fall into this task in an invalid state.\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(triggeredError).toEqual({ error, kind: 'uncaughtException' })\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1',\n+      // ======================\n+      'timeout 1 -> immediate 1',\n+      'timeout 1 -> immediate 1 -> nextTick', // undesirable (too early) but acceptable\n+\n+      // FIXME: no async context in uncaughtException\n+      // `uncaughtException - ${contextValue}`,\n+      `uncaughtException - undefined`,\n+\n+      // ======================\n+      'timeout 1 -> immediate 2',\n+      // ===================================\n+      'timeout 2',\n+    ])\n+  })\n+\n+  it('sync errors in nextTick trigger uncaughtException', async () => {\n+    const { log, logs } = createLogger()\n+    const done = createPromiseWithResolvers<void>()\n+\n+    const Ctx = new AsyncLocalStorage<string>()\n+    const contextValue = 'hello'\n+\n+    let triggeredError: TriggeredUncaught | undefined = undefined\n+    using _ = trackUncaughtErrors((error, kind) => {\n+      // Ideally, we can read the async context in an uncaughtException handler\n+      log(`${kind} - ${Ctx.getStore()}`)\n+      triggeredError = { error, kind }\n+    })\n+\n+    const error = new Error('kaboom')\n+\n+    Ctx.run(contextValue, () => {\n+      setTimeout(() => {\n+        DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+        log('timeout 1')\n+        setImmediate(() => {\n+          log('timeout 1 -> immediate 1')\n+          process.nextTick(() => {\n+            log(`timeout 1 -> immediate 1 -> nextTick - ${Ctx.getStore()}`)\n+            throw error\n+          })\n+        })\n+        setImmediate(() => {\n+          log('timeout 1 -> immediate 2')\n+        })\n+      })\n+    })\n+\n+    setTimeout(() => {\n+      log('timeout 2')\n+      // This ensures that we don't fall into this task in an invalid state.\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(triggeredError).toEqual({ error, kind: 'uncaughtException' })\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1',\n+      // ======================\n+      'timeout 1 -> immediate 1',\n+      `timeout 1 -> immediate 1 -> nextTick - ${contextValue}`,\n+\n+      // FIXME: no async context in uncaughtException\n+      // `uncaughtException - ${contextValue}`,\n+      `uncaughtException - undefined`,\n+\n+      // ======================\n+      'timeout 1 -> immediate 2',\n+      // ===================================\n+      'timeout 2',\n+    ])\n+  })\n+\n+  it('sync errors in nextTick before immediate', async () => {\n+    const { log, logs } = createLogger()\n+    const done = createPromiseWithResolvers<void>()\n+\n+    let triggeredError: TriggeredUncaught | undefined = undefined\n+    using _ = trackUncaughtErrors((error, kind) => {\n+      log(kind)\n+      triggeredError = { error, kind }\n+    })\n+\n+    const error = new Error('kaboom')\n+\n+    setTimeout(() => {\n+      DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+      log('timeout 1')\n+      process.nextTick(() => {\n+        log('timeout 1 -> nextTick')\n+        throw error\n+      })\n+      setImmediate(() => {\n+        log('timeout 1 -> immediate 1')\n+      })\n+      setImmediate(() => {\n+        log('timeout 1 -> immediate 2')\n+      })\n+    })\n+\n+    setTimeout(() => {\n+      log('timeout 2')\n+      // This ensures that we don't fall into this task in an invalid state.\n+      try {\n+        expectNoPendingImmediates()\n+        done.resolve()\n+      } catch (err) {\n+        done.reject(err)\n+      }\n+    })\n+\n+    await done.promise\n+\n+    expect(triggeredError).toEqual({ error, kind: 'uncaughtException' })\n+\n+    expect(logs).toEqual([\n+      // ===================================\n+      'timeout 1',\n+      'timeout 1 -> nextTick',\n+      'uncaughtException',\n+      // ======================\n+      'timeout 1 -> immediate 1',\n+      // ======================\n+      'timeout 1 -> immediate 2',\n+      // ===================================\n+      'timeout 2',\n+    ])\n+  })\n+\n+  describe('unhandled rejections', () => {\n+    type Case = {\n+      name: string\n+      immediate: (\n+        name: string,\n+        error: Error,\n+        log: (...args: any[]) => void\n+      ) => void\n+    }\n+\n+    const unhandledRejectionCases: Case[] = [\n+      {\n+        name: 'Promise.resolve().then(...)',\n+        immediate: (name, error, log) => {\n+          log(name)\n+          void Promise.resolve().then(() => {\n+            log(`${name} :: erroring`)\n+            throw error\n+          })\n+        },\n+      },\n+      {\n+        name: 'throw in unawaited async IIFE',\n+        immediate: (name, error, log) => {\n+          log(name)\n+          void (async () => {\n+            await Promise.resolve()\n+            log(`${name} :: erroring`)\n+            throw error\n+          })()\n+        },\n+      },\n+      {\n+        name: 'Promise.reject(...)',\n+        immediate: (name, error, log) => {\n+          log(name)\n+          log(`${name} :: erroring`)\n+          Promise.reject(error)\n+        },\n+      },\n+      {\n+        name: 'throw in async immediate',\n+        immediate: async (name, error, log) => {\n+          log(name)\n+          await Promise.resolve()\n+          log(`${name} :: erroring`)\n+          throw error\n+        },\n+      },\n+    ]\n+\n+    it.each(unhandledRejectionCases)('$name', async ({ immediate }) => {\n+      const { log, logs } = createLogger()\n+      const done = createPromiseWithResolvers<void>()\n+\n+      const Ctx = new AsyncLocalStorage<string>()\n+      const contextValue = 'hello'\n+\n+      let triggeredError: TriggeredUncaught | undefined = undefined\n+      using _ = trackUncaughtErrors((error, kind) => {\n+        // async context should be preserved\n+        log(`${kind} - ${Ctx.getStore()}`)\n+        triggeredError = { error, kind }\n+      })\n+\n+      const error = new Error('kaboom')\n+\n+      Ctx.run(contextValue, () => {\n+        setTimeout(() => {\n+          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+          log('timeout 1')\n+          setImmediate(() => {\n+            return immediate('timeout 1 -> immediate 1', error, log)\n+          })\n+          setImmediate(() => {\n+            log('timeout 1 -> immediate 2')\n+          })\n+        })\n+      })\n+\n+      setTimeout(() => {\n+        log('timeout 2')\n+        // This ensures that we don't fall into this task in an invalid state.\n+        try {\n+          expectNoPendingImmediates()\n+          done.resolve()\n+        } catch (err) {\n+          done.reject(err)\n+        }\n+      })\n+\n+      await done.promise\n+\n+      expect(triggeredError).toEqual({ error, kind: 'unhandledRejection' })\n+\n+      expect(logs).toEqual([\n+        // ===================================\n+        'timeout 1',\n+        // ======================\n+        'timeout 1 -> immediate 1',\n+        'timeout 1 -> immediate 1 :: erroring',\n+\n+        // FIXME: we would like to observe the rejection here...\n+        // `unhandledRejection - ${contextValue}`,\n+\n+        // ======================\n+        'timeout 1 -> immediate 2',\n+\n+        // FIXME: ...but it happens here, after the second immediate:\n+        `unhandledRejection - ${contextValue}`,\n+        // This is because unhandled rejections are only processed after the nextTick queue is empty:\n+        // https://github.com/nodejs/node/blob/d546e7fd0bc3cbb4bcc2baae6f3aa44d2e81a413/lib/internal/process/task_queues.js#L104-L105\n+        // and in our implementation, the second immediate is actually a nextTick.\n+\n+        // ===================================\n+        'timeout 2',\n+      ])\n+    })\n+  })\n+})\n+\n+describe('error recovery', () => {\n+  describe('when crashing, it bails out to native setImmediate and does not break subsequent calls', () => {\n+    const expectCorrectRunToWork = async () => {\n+      const { log, logs } = createLogger()\n+      const done = createPromiseWithResolvers<void>()\n+\n+      setTimeout(() => {\n+        try {\n+          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+        } catch (err) {\n+          return done.reject(err)\n+        }\n+\n+        log('timeout 1')\n+\n+        setImmediate(() => {\n+          log('timeout 1 -> immediate 1')\n+        })\n+        setImmediate(() => {\n+          log('timeout 1 -> immediate 2')\n+        })\n+      })\n+\n+      setTimeout(() => {\n+        log('timeout 2')\n+\n+        try {\n+          expectNoPendingImmediates()\n+          done.resolve()\n+        } catch (err) {\n+          done.reject(err)\n+        }\n+      })\n+\n+      await done.promise\n+\n+      expect(logs).toEqual([\n+        'timeout 1',\n+        'timeout 1 -> immediate 1',\n+        'timeout 1 -> immediate 2',\n+        'timeout 2',\n+      ])\n+    }\n+\n+    const schedulingCases = [\n+      {\n+        description: 'in sync code',\n+        scheduleCrash: (cb: () => void) => {\n+          cb()\n+        },\n+      },\n+      {\n+        description: 'in nextTick',\n+        scheduleCrash: (cb: () => void) => {\n+          process.nextTick(() => {\n+            cb()\n+          })\n+        },\n+      },\n+      {\n+        description: 'in microtask',\n+        scheduleCrash: (cb: () => void) => {\n+          queueMicrotask(() => {\n+            cb()\n+          })\n+        },\n+      },\n+      {\n+        description: 'after microtasks',\n+        scheduleCrash: (cb: () => void) => {\n+          queueMicrotask(() => {\n+            process.nextTick(() => {\n+              cb()\n+            })\n+          })\n+        },\n+      },\n+    ]\n+\n+    describe.each([\n+      {\n+        description: 'starting capture twice in the same task',\n+        invalidCall: () => {\n+          DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+        },\n+      },\n+      {\n+        description: 'expectNoPendingImmediates in the same task as capture',\n+        invalidCall: () => {\n+          expectNoPendingImmediates()\n+        },\n+      },\n+    ])('crash reason - $description', ({ invalidCall }) => {\n+      it.each(schedulingCases)(\n+        'after a crash - $description',\n+        async ({ scheduleCrash }) => {\n+          // In the first run, we trigger a crash\n+\n+          const { log, logs } = createLogger()\n+          const dones = [\n+            createPromiseWithResolvers<void>(),\n+            createPromiseWithResolvers<void>(),\n+            createPromiseWithResolvers<void>(),\n+          ]\n+\n+          // This test includes a native setImmediate, so we want to avoid\n+          // flakiness due to timer/immediate interleaving\n+          const scheduleTimeout = createAtomicTimerGroup()\n+\n+          scheduleTimeout(() => {\n+            // NOTE: native immediate\n+            setImmediate(() => {\n+              log('immediate 1 (native)')\n+              dones[0].resolve()\n+            })\n+          })\n+          scheduleTimeout(() => {\n+            DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+            log('timeout 1')\n+\n+            setImmediate(() => {\n+              log('timeout 1 -> immediate 1 (patched)')\n+              dones[1].resolve()\n+            })\n+\n+            setImmediate(() => {\n+              log('timeout 1 -> immediate 2 (patched)')\n+              dones[2].resolve()\n+            })\n+\n+            scheduleCrash(() => {\n+              expect(() => invalidCall()).toThrow()\n+            })\n+          })\n+\n+          await Promise.all(dones.map((d) => d.promise))\n+\n+          expect(logs).toEqual([\n+            'timeout 1',\n+            // The queued immediates should be rescheduled using native `setImmediate`,\n+            // so we should observe them happening after the native one we scheduled earlier\n+            'immediate 1 (native)',\n+            'timeout 1 -> immediate 1 (patched)',\n+            'timeout 1 -> immediate 2 (patched)',\n+          ])\n+\n+          // The next run should work correctly\n+          await expectCorrectRunToWork()\n+        }\n+      )\n+\n+      it.each(schedulingCases)(\n+        'after a crash in a patched immediate - $description',\n+        async ({ scheduleCrash }) => {\n+          // In the first run, we trigger a crash\n+\n+          const { log, logs } = createLogger()\n+          const dones = [\n+            createPromiseWithResolvers<void>(),\n+            createPromiseWithResolvers<void>(),\n+            createPromiseWithResolvers<void>(),\n+          ]\n+\n+          // This test includes a native setImmediate, so we want to avoid\n+          // flakiness due to timer/immediate interleaving\n+          const scheduleTimeout = createAtomicTimerGroup()\n+\n+          scheduleTimeout(() => {\n+            // NOTE: native immediate\n+            setImmediate(() => {\n+              log('immediate 1 (native)')\n+              dones[0].resolve()\n+            })\n+          })\n+          scheduleTimeout(() => {\n+            DANGEROUSLY_runPendingImmediatesAfterCurrentTask()\n+            log('timeout 1')\n+\n+            setImmediate(() => {\n+              log('timeout 1 -> immediate 1 (patched)')\n+              dones[1].resolve()\n+            })\n+\n+            setImmediate(() => {\n+              log('timeout 1 -> immediate 2 (patched)')\n+              scheduleCrash(() => {\n+                expect(() => expectNoPendingImmediates()).toThrow()\n+              })\n+            })\n+\n+            setImmediate(() => {\n+              log('timeout 1 -> immediate 3 (patched)')\n+              dones[2].resolve()\n+            })\n+          })\n+\n+          await Promise.all(dones.map((d) => d.promise))\n+\n+          expect(logs).toEqual([\n+            'timeout 1',\n+            'timeout 1 -> immediate 1 (patched)',\n+            'timeout 1 -> immediate 2 (patched)',\n+            // The remaining queued immediate should be rescheduled using native `setImmediate`,\n+            // so we should observe it happening after the native one we scheduled earlier\n+            'immediate 1 (native)',\n+            'timeout 1 -> immediate 3 (patched)',\n+          ])\n+\n+          // The next run should work correctly\n+          await expectCorrectRunToWork()\n+        }\n+      )\n+    })\n+  })\n+})"
        },
        {
            "sha": "2d906004638aa8eac71b22356985f9a849dc7aa3",
            "filename": "packages/next/src/server/node-environment-extensions/fast-set-immediate.external.ts",
            "status": "added",
            "additions": 797,
            "deletions": 0,
            "changes": 797,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Ffast-set-immediate.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Ffast-set-immediate.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Ffast-set-immediate.external.ts?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,797 @@\n+import { promisify } from 'node:util'\n+import { InvariantError } from '../../shared/lib/invariant-error'\n+import { bindSnapshot } from '../app-render/async-local-storage'\n+\n+type Execution = {\n+  state: ExecutionState\n+  queuedImmediates: QueueItem[]\n+}\n+\n+enum ExecutionState {\n+  Waiting = 1,\n+  Working = 2,\n+  Finished = 3,\n+  Abandoned = 4,\n+}\n+\n+let wasEnabledAtLeastOnce = false\n+\n+let pendingNextTicks = 0\n+let currentExecution: Execution | null = null\n+\n+const originalSetImmediate = globalThis.setImmediate\n+const originalClearImmediate = globalThis.clearImmediate\n+const originalNextTick = process.nextTick\n+\n+export { originalSetImmediate as unpatchedSetImmediate }\n+\n+function install() {\n+  if (process.env.NEXT_RUNTIME === 'edge') {\n+    // Nothing to patch. The exported functions all error if used in the edge runtime,\n+    // so we're not going to violate any assumptions by not patching.\n+    return\n+  } else {\n+    debug?.('installing fast setImmediate patch')\n+\n+    const nodeTimers = require('node:timers') as typeof import('node:timers')\n+    globalThis.setImmediate = nodeTimers.setImmediate =\n+      // Workaround for missing __promisify__ which is not a real property\n+      patchedSetImmediate as unknown as typeof setImmediate\n+    globalThis.clearImmediate = nodeTimers.clearImmediate =\n+      patchedClearImmediate\n+\n+    const nodeTimersPromises =\n+      require('node:timers/promises') as typeof import('node:timers/promises')\n+    nodeTimersPromises.setImmediate =\n+      patchedSetImmediatePromise as typeof import('node:timers/promises').setImmediate\n+\n+    process.nextTick = patchedNextTick\n+  }\n+}\n+\n+/**\n+ * **WARNING: This function changes the usual behavior of the event loop!**\n+ * **Be VERY careful about where you call it.**\n+ *\n+ * Starts capturing calls to `setImmediate` to run them as \"fast immediates\".\n+ * All calls captured in this way will be executed after the current task\n+ * (after callbacks from `process.nextTick()`, microtasks, and nextTicks scheduled from microtasks).\n+ * This function needs to be called again in each task that needs the\n+ * \"fast immediates\" behavior.\n+ *\n+ * ### Motivation\n+ *\n+ * We don't want `setImmediate` to be considered IO in Cache Components.\n+ * To achieve this in a staged (pre)render, we want to allow immediates scheduled\n+ * in stage N to run before stage N+1.\n+ * Since we schedule stages using sequential `setTimeout`, this isn't possible without\n+ * intercepting `setImmediate` and doing the scheduling on our own.\n+ * We refer to this as a \"fast immediate\".\n+ *\n+ * Notably, this affects React's `scheduleWork` in render, which uses `setImmediate`.\n+ * This is desirable -- if async work was scheduled during a stage, then it should\n+ * get to run before we finish that stage.\n+ *\n+ * ### Example\n+ *\n+ * ```ts\n+ * setTimeout(() => {\n+ *   runPendingImmediatesAfterCurrentTask()\n+ *   console.log(\"timeout 1\")\n+ *   setImmediate(() => {\n+ *     console.log(\"immediate!!!\")\n+ *   })\n+ * })\n+ * setTimeout(() => {\n+ *   console.log(\"timeout 2\")\n+ * })\n+ * ```\n+ * will print\n+ *\n+ * ```\n+ * timeout 1\n+ * immediate!!!\n+ * timeout 2\n+ * ```\n+ *\n+ * instead of the usual order\n+ * ```\n+ * timeout 1\n+ * timeout 2\n+ * immediate!!!\n+ * ```\n+ * > **NOTE**\n+ * > The above is *most common* order, but it's not guaranteed.\n+ * > Under some circumstances (e.g. when the event loop is blocked on CPU work),\n+ * > Node will reorder things and run the immediate before timeout 2.\n+ * > So, in a sense, we're just making this reordering happen consistently.\n+ *\n+ * Recursive `setImmediate` calls will also be executed as \"fast immediates\".\n+ * If multiple immediates were scheduled, `process.nextTick()` (and associated microtasks)\n+ * will be allowed to execute between them.\n+ * See the unit tests for more examples.\n+ * */\n+export function DANGEROUSLY_runPendingImmediatesAfterCurrentTask() {\n+  if (process.env.NEXT_RUNTIME === 'edge') {\n+    throw new InvariantError(\n+      'DANGEROUSLY_runPendingImmediatesAfterCurrentTask cannot be called in the edge runtime'\n+    )\n+  } else {\n+    const execution = startCapturingImmediates()\n+\n+    try {\n+      scheduleWorkAfterNextTicksAndMicrotasks(execution)\n+    } catch (err) {\n+      // If this error comes from a bail() call, rethrow it.\n+      if (execution.state === ExecutionState.Abandoned) {\n+        throw err\n+      }\n+      // Otherwise, bail out here.\n+      bail(\n+        execution,\n+        new InvariantError(\n+          'An unexpected error occurred while starting to capture immediates',\n+          {\n+            cause: err,\n+          }\n+        )\n+      )\n+    }\n+  }\n+}\n+\n+/**\n+ * This should always be called a task after `DANGEROUSLY_runPendingImmediatesAfterCurrentTask`\n+ * to make sure that everything executed as expected and we're not left in an inconsistent state.\n+ * Ideally, this wouldn't be necessary, but we're not in control of the event loop\n+ * and need to guard against unexpected behaviors not forseen in this implementation,\n+ * so we have to be defensive.\n+ */\n+export function expectNoPendingImmediates() {\n+  if (process.env.NEXT_RUNTIME === 'edge') {\n+    throw new InvariantError(\n+      'expectNoPendingImmediates cannot be called in the edge runtime'\n+    )\n+  } else {\n+    if (currentExecution !== null) {\n+      bail(\n+        currentExecution,\n+        new InvariantError(\n+          `Expected all captured immediates to have been executed (state: ${ExecutionState[currentExecution.state]})`\n+        )\n+      )\n+    }\n+  }\n+}\n+\n+/**\n+ * Wait until all nextTicks and microtasks spawned from the current task are done,\n+ * then execute any immediates that they queued.\n+ * */\n+function scheduleWorkAfterNextTicksAndMicrotasks(execution: Execution) {\n+  if (execution.state !== ExecutionState.Waiting) {\n+    throw new InvariantError(\n+      `scheduleWorkAfterTicksAndMicrotasks can only be called while waiting (state: ${ExecutionState[execution.state]})`\n+    )\n+  }\n+\n+  // We want to execute \"fast immediates\" after all the nextTicks and microtasks\n+  // spawned from the current task are done.\n+  // The ordering here is:\n+  //\n+  // 1. sync code\n+  // 2. process.nextTick (scheduled from sync code, or from one of these nextTicks)\n+  // 3. microtasks\n+  // 4. process.nextTick (scheduled from microtasks, e.g. `queueMicrotask(() => process.nextTick(callback))`)\n+  //\n+  // We want to run to run in step 4, because that's the latest point before the next tick.\n+  // However, there might also be other callbacks scheduled to run in that step.\n+  // But importantly, they had to be scheduled using a `process.nextTick`,\n+  // so we can detect them by checking if `pendingNextTicks > 0`.\n+  // In that case, we'll just reschedule ourselves in the same way again to let them run first.\n+  // (this process can theoretically repeat multiple times, hence the recursion).\n+\n+  queueMicrotask(() => {\n+    // (note that this call won't increment `pendingNextTicks`,\n+    // only the patched `process.nextTick` does that, so this won't loop infinitely)\n+    originalNextTick(() => {\n+      // We're now in a nextTick, which means that we're executing inside `processTicksAndRejections`:\n+      // https://github.com/nodejs/node/blob/d546e7fd0bc3cbb4bcc2baae6f3aa44d2e81a413/lib/internal/process/task_queues.js#L84\n+      // All the work scheduled here will happen within that `processTicksAndRejections` loop.\n+      // Reading the source of `processTicksAndRejections` can help understand the timing here --\n+      // All we're really doing is strategically pushing callbacks into the two queues\n+      // (nextTicks and microtasks) that that function is currently looping over.\n+\n+      try {\n+        if (\n+          execution.state === ExecutionState.Abandoned ||\n+          currentExecution !== execution\n+        ) {\n+          debug?.(`scheduler :: the execution was abandoned`)\n+          return\n+        }\n+        if (pendingNextTicks > 0) {\n+          // Other nextTicks have been scheduled. Let those run first, then try again --\n+          // we're simulating a event loop task, so all nextTicks should be exhausted before we execute.\n+          debug?.(`scheduler :: yielding to ${pendingNextTicks} nextTicks`)\n+          return scheduleWorkAfterNextTicksAndMicrotasks(execution)\n+        }\n+\n+        // There's no other nextTicks, we're the last one, so we're about to move on to the next task (likely a timer).\n+        // Now, we can try and execute any queued immediates.\n+        return performWork(execution)\n+      } catch (err) {\n+        // If this error comes from a bail() call, rethrow it.\n+\n+        // typescript can't tell that the state might've been mutated\n+        // and the narrowing from above is no longer valid\n+        const executionAfterWork = execution as Execution\n+        if (executionAfterWork.state === ExecutionState.Abandoned) {\n+          throw err\n+        }\n+\n+        // Otherwise, bail out here (which will trigger an uncaught exception)\n+        // Note that we're using the same microtask trick as `safelyRunNextTickCallback`.\n+        queueMicrotask(() => {\n+          bail(\n+            execution,\n+            new InvariantError(\n+              'An unexpected error occurred while executing immediates',\n+              { cause: err }\n+            )\n+          )\n+        })\n+      }\n+    })\n+  })\n+}\n+\n+/** Execute one immediate, and schedule a check for more (in case there's others in the queue) */\n+function performWork(execution: Execution) {\n+  if (execution.state === ExecutionState.Abandoned) {\n+    return\n+  }\n+\n+  debug?.(`scheduler :: performing work`)\n+\n+  if (execution.state !== ExecutionState.Waiting) {\n+    throw new InvariantError(\n+      `performWork can only be called while waiting (state: ${ExecutionState[execution.state]})`\n+    )\n+  }\n+  execution.state = ExecutionState.Working\n+\n+  const queueItem = takeNextActiveQueueItem(execution)\n+\n+  if (queueItem === null) {\n+    debug?.(`scheduler :: no immediates queued, exiting`)\n+    stopCapturingImmediates(execution)\n+    return\n+  }\n+\n+  debug?.(`scheduler :: executing queued immediate`)\n+\n+  const { immediateObject, callback, args } = queueItem\n+\n+  immediateObject[INTERNALS].queueItem = null\n+  clearQueueItem(queueItem)\n+\n+  // Execute the immediate.\n+\n+  // If a sync error was thrown in the immediate, we want to trigger a `uncaughtException`.\n+  // However, we're executing in a nextTick, and if a nextTick callback errors,\n+  // It'll break out of `processTicksAndRejections` (note the lack of a `catch` block):\n+  //   https://github.com/nodejs/node/blob/d546e7fd0bc3cbb4bcc2baae6f3aa44d2e81a413/lib/internal/process/task_queues.js#L81-L97\n+  // Meaning that the event loop will stop executing nextTicks and move on to the next timer\n+  // (or other phase of the event loop, but we expect to be running in a sequence of timers here).\n+  // Then, the remaining ticks will run after that timer, since they're still in the queue.\n+  //\n+  // This would completely break the timing we're trying to achieve here --\n+  // The point of this patch is to execute immediates before the next timer!\n+  // So, we need to work around this behavior. (both here and in our `process.nextTick` patch).\n+  //\n+  // We can sidestep this by catching the synchronous error and rethrowing it in a microtask.\n+  // (NOTE: if we use `queueMicrotask`, it'll trigger `uncaughtException`, not `unhandledRejection`,\n+  // because there's no promise being rejected.)\n+  //\n+  // This will make `uncaughtException` happen:\n+  // - Before the next fast immediate (`scheduleWorkAfterNextTicksAndMicrotasks` also uses `queueMicrotask`).\n+  //   This is good, and matches usual observable behavior of immediates.\n+  // - AFTER nextTicks scheduled from the immediate itself.\n+  //   This deviates from native setImmediate, which would call `uncaughtException` first,\n+  //   and skip ahead to the next task as explained above.\n+  //\n+  // This is technically an observable difference in behavior, but it seems niche enough that\n+  // it shouldn't cause problems -- we don't expect user code to use `uncaughtException` for control flow,\n+  // only error reporting, so subtly changing the timing shouldn't matter.\n+\n+  let didThrow = false\n+  let thrownValue: unknown = undefined\n+  queueMicrotask(() => {\n+    if (didThrow) {\n+      debug?.('scheduler :: rethrowing sync error from immediate in microtask')\n+      throw thrownValue\n+    }\n+  })\n+\n+  try {\n+    if (args !== null) {\n+      callback.apply(null, args)\n+    } else {\n+      callback()\n+    }\n+  } catch (err) {\n+    // We'll rethrow the error in the microtask above.\n+    didThrow = true\n+    thrownValue = err\n+  }\n+\n+  // Schedule the loop again in case there's more immediates after this one.\n+  // Note that we can't just check if the queue is empty now, because new immediates\n+  // might still be scheduled asynchronously, from an upcoming nextTick or microtask.\n+  execution.state = ExecutionState.Waiting\n+  scheduleWorkAfterNextTicksAndMicrotasks(execution)\n+}\n+\n+function takeNextActiveQueueItem(execution: Execution): ActiveQueueItem | null {\n+  // Find the first (if any) queued immediate that wasn't cleared.\n+  // We don't remove immediates from the array when they're cleared,\n+  // so this requires some legwork to exclude (and possibly drop) cleared items.\n+  const { queuedImmediates } = execution\n+\n+  let firstActiveItem: ActiveQueueItem | null = null\n+  let firstActiveItemIndex = -1\n+  for (let i = 0; i < queuedImmediates.length; i++) {\n+    const item = queuedImmediates[i]\n+    if (!item.isCleared) {\n+      firstActiveItem = item\n+      firstActiveItemIndex = i\n+      break\n+    }\n+  }\n+\n+  if (firstActiveItem === null) {\n+    // We didn't find an active item.\n+\n+    // If the queue isn't empty, then it must only contain cleared items. Empty it.\n+    if (queuedImmediates.length > 0) {\n+      queuedImmediates.length = 0\n+    }\n+\n+    return null\n+  }\n+\n+  // Remove all items up to and including `nextActiveItemIndex` from the queue.\n+  // (if it's not the first item, then it must be preceded by cleared items, which we want to drop anyway)\n+  if (firstActiveItemIndex === 0) {\n+    // Fast path - drop the first item\n+    // (`splice` creates a result array for the removed items, so this is more efficient)\n+    queuedImmediates.shift()\n+  } else {\n+    queuedImmediates.splice(0, firstActiveItemIndex + 1)\n+  }\n+\n+  return firstActiveItem\n+}\n+\n+function startCapturingImmediates(): Execution {\n+  if (currentExecution !== null) {\n+    bail(\n+      currentExecution,\n+      new InvariantError(\n+        `Cannot start capturing immediates again without finishing the previous task (state: ${ExecutionState[currentExecution.state]})`\n+      )\n+    )\n+  }\n+  wasEnabledAtLeastOnce = true\n+\n+  const execution: Execution = {\n+    state: ExecutionState.Waiting,\n+    queuedImmediates: [],\n+  }\n+  currentExecution = execution\n+\n+  return execution\n+}\n+\n+function stopCapturingImmediates(execution: Execution) {\n+  if (execution.state === ExecutionState.Abandoned) {\n+    return\n+  }\n+\n+  // This check enforces that we run performWork at least once before stopping\n+  // to make sure that we've waited for all the nextTicks and microtasks\n+  // that might've scheduled some immediates after sync code.\n+  if (execution.state !== ExecutionState.Working) {\n+    throw new InvariantError(\n+      `Cannot stop capturing immediates before execution is finished (state: ${ExecutionState[execution.state]})`\n+    )\n+  }\n+\n+  execution.state = ExecutionState.Finished\n+\n+  if (currentExecution === execution) {\n+    currentExecution = null\n+  }\n+}\n+\n+function bail(execution: Execution, error: Error): never {\n+  // Reset the state as best we can to prevent further crashes.\n+  // Otherwise, any subsequent call to `DANGEROUSLY_runPendingImmediatesAfterCurrentTask`\n+  // would error, requiring a server restart to fix.\n+\n+  if (currentExecution === execution) {\n+    currentExecution = null\n+  }\n+\n+  execution.state = ExecutionState.Abandoned\n+\n+  // If we have any queued immediates, schedule them with native `setImmediate` and clear the queue.\n+  // We don't want to skip running them altogether, because that could lead to\n+  // e.g. hanging promises (for `new Promise((resolve) => setImmediate(resolve))`),\n+  // but we're in an inconsistent state and can't run them as fast immediates,\n+  // so this is the next best thing.\n+  for (const queueItem of execution.queuedImmediates) {\n+    if (queueItem.isCleared) {\n+      continue\n+    }\n+    scheduleQueuedImmediateAsNativeImmediate(queueItem)\n+  }\n+  execution.queuedImmediates.length = 0\n+\n+  // Don't reset `pendingNextTicks` -- it will reset to 0 on its own as the nextTicks execute.\n+  // If we set it to 0 here while we still have pending ticks, they'd decrement it below 0.\n+\n+  throw error\n+}\n+\n+function scheduleQueuedImmediateAsNativeImmediate(queueItem: ActiveQueueItem) {\n+  const { callback, args, immediateObject } = queueItem\n+  const hasRef = immediateObject[INTERNALS].hasRef\n+\n+  clearQueueItem(queueItem)\n+\n+  const nativeImmediate =\n+    args !== null\n+      ? originalSetImmediate(callback, ...args)\n+      : originalSetImmediate(callback)\n+\n+  if (!hasRef) {\n+    nativeImmediate.unref()\n+  }\n+\n+  // Make our fake immediate object proxy all relevant operations\n+  // (clearing, ref(), unref(), hasRef()) to the actual native immediate.\n+  proxyQueuedImmediateToNativeImmediate(immediateObject, nativeImmediate)\n+}\n+\n+type QueueItem = ActiveQueueItem | ClearedQueueItem\n+type ActiveQueueItem = {\n+  isCleared: false\n+  callback: (...args: any[]) => any\n+  args: any[] | null\n+  immediateObject: NextImmediate\n+}\n+type ClearedQueueItem = {\n+  isCleared: true\n+  callback: null\n+  args: null\n+  immediateObject: null\n+}\n+\n+function clearQueueItem(originalQueueItem: QueueItem) {\n+  const queueItem = originalQueueItem as ClearedQueueItem\n+  queueItem.isCleared = true\n+  queueItem.callback = null\n+  queueItem.args = null\n+  queueItem.immediateObject = null\n+}\n+\n+//========================================================\n+\n+function patchedNextTick<TArgs extends any[]>(\n+  callback: (...args: TArgs) => void,\n+  ...args: TArgs\n+): void\n+function patchedNextTick() {\n+  if (currentExecution === null) {\n+    return originalNextTick.apply(\n+      null,\n+      // @ts-expect-error: this is valid, but typescript doesn't get it\n+      arguments\n+    )\n+  }\n+\n+  if (arguments.length === 0 || typeof arguments[0] !== 'function') {\n+    // Let the original nextTick error for invalid arguments\n+    // so that we don't have to mirror the error message.\n+    originalNextTick.apply(\n+      null,\n+      // @ts-expect-error: explicitly passing arguments that we know are invalid\n+      arguments\n+    )\n+\n+    // We expect the above call to throw. If it didn't, something's broken.\n+    bail(\n+      currentExecution,\n+      new InvariantError(\n+        'Expected process.nextTick to reject invalid arguments'\n+      )\n+    )\n+  }\n+\n+  debug?.(\n+    `scheduler :: process.nextTick called (previous pending: ${pendingNextTicks})`\n+  )\n+\n+  const callback: (...args: any[]) => any = arguments[0]\n+  const args: any[] | null =\n+    arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : null\n+\n+  pendingNextTicks += 1\n+  return originalNextTick(safelyRunNextTickCallback, callback, args)\n+}\n+\n+function safelyRunNextTickCallback(\n+  callback: (...args: any[]) => any,\n+  args: any[] | null\n+) {\n+  pendingNextTicks -= 1\n+  debug?.(\n+    `scheduler :: process.nextTick executing (still pending: ${pendingNextTicks})`\n+  )\n+\n+  // Synchronous errors in nextTick break out of `processTicksAndRejections` and cause us\n+  // to move on to the next timer without having executed the whole nextTick queue,\n+  // which breaks our entire scheduling mechanism. See `performWork` for more details.\n+  try {\n+    if (args !== null) {\n+      callback.apply(null, args)\n+    } else {\n+      callback()\n+    }\n+  } catch (err) {\n+    // We want to make sure `nextTick` is cheap, so unlike `performWork`,\n+    // we only queue the microtask if an error actually occurs.\n+    // This (observably) changes the timing of `uncaughtException` even more,\n+    // because it'll run after microtasks queued from the nextTick,\n+    // but hopefully this is niche enough to not affect any real world code.\n+    queueMicrotask(() => {\n+      debug?.(`scheduler :: rethrowing sync error from nextTick in a microtask`)\n+      throw err\n+    })\n+  }\n+}\n+\n+function patchedSetImmediate<TArgs extends any[]>(\n+  callback: (...args: TArgs) => void,\n+  ...args: TArgs\n+): NodeJS.Immediate\n+function patchedSetImmediate(callback: (args: void) => void): NodeJS.Immediate\n+function patchedSetImmediate(): NodeJS.Immediate {\n+  if (currentExecution === null) {\n+    return originalSetImmediate.apply(\n+      null,\n+      // @ts-expect-error: this is valid, but typescript doesn't get it\n+      arguments\n+    )\n+  }\n+\n+  if (arguments.length === 0 || typeof arguments[0] !== 'function') {\n+    // Let the original setImmediate error for invalid arguments\n+    // so that we don't have to mirror the error message.\n+    originalSetImmediate.apply(\n+      null,\n+      // @ts-expect-error: explicitly passing arguments that we know are invalid\n+      arguments\n+    )\n+\n+    // We expect the above call to throw. If it didn't, something's broken.\n+    bail(\n+      currentExecution,\n+      new InvariantError('Expected setImmediate to reject invalid arguments')\n+    )\n+  }\n+\n+  const callback: (...args: any[]) => any = arguments[0]\n+  const args: any[] | null =\n+    arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : null\n+\n+  // Normally, Node would capture and propagate the async context to the immediate.\n+  // We'll be running it on our own queue, so we need to propagate it ourselves.\n+  const callbackWithAsyncContext = bindSnapshot(callback)\n+\n+  const immediateObject = new NextImmediate()\n+\n+  const queueItem: ActiveQueueItem = {\n+    isCleared: false,\n+    callback: callbackWithAsyncContext,\n+    args,\n+    immediateObject,\n+  }\n+  currentExecution.queuedImmediates.push(queueItem)\n+\n+  immediateObject[INTERNALS].queueItem = queueItem\n+\n+  return immediateObject\n+}\n+\n+function patchedSetImmediatePromise<T = void>(\n+  value: T,\n+  options?: import('node:timers').TimerOptions\n+): Promise<T> {\n+  if (currentExecution === null) {\n+    const originalPromisify: (typeof setImmediate)['__promisify__'] =\n+      // @ts-expect-error: the types for `promisify.custom` are strange\n+      originalSetImmediate[promisify.custom]\n+    return originalPromisify(value, options)\n+  }\n+\n+  return new Promise<T>((resolve, reject) => {\n+    // The abort signal makes the promise reject.\n+    // If it is already aborted, we reject immediately.\n+    const signal = options?.signal\n+    if (signal && signal.aborted) {\n+      return reject(signal.reason)\n+    }\n+\n+    const immediate = patchedSetImmediate(resolve, value)\n+\n+    // Unref-ing only really has an observable effect if we bail out to a native immediate,\n+    // but we do it for completeness\n+    if (options?.ref === false) {\n+      immediate.unref()\n+    }\n+\n+    if (signal) {\n+      signal.addEventListener(\n+        'abort',\n+        () => {\n+          patchedClearImmediate(immediate)\n+          reject(signal.reason)\n+        },\n+        { once: true }\n+      )\n+    }\n+  })\n+}\n+\n+patchedSetImmediate[promisify.custom] = patchedSetImmediatePromise\n+\n+const patchedClearImmediate = (\n+  immediateObject: NodeJS.Immediate | undefined\n+) => {\n+  // NOTE: we defensively check for patched immediates even if we're not\n+  // currently capturing immediates, because the objects returned from\n+  // the patched setImmediate can be kept around for arbitrarily long.\n+  // As an optimization, we only do this if the patch was enabled at least once --\n+  // otherwise, no patched objects could've been created.\n+  if (\n+    wasEnabledAtLeastOnce &&\n+    immediateObject &&\n+    typeof immediateObject === 'object' &&\n+    INTERNALS in immediateObject\n+  ) {\n+    ;(immediateObject as NextImmediate)[Symbol.dispose]()\n+  } else {\n+    originalClearImmediate(immediateObject)\n+  }\n+}\n+\n+//========================================================\n+\n+const INTERNALS: unique symbol = Symbol.for('next.Immediate.internals')\n+\n+type NextImmediateInternals =\n+  | {\n+      /** Stored to reflect `ref()`/`unref()` calls, but has no effect otherwise */\n+      hasRef: boolean\n+      queueItem: ActiveQueueItem | null\n+      nativeImmediate: null\n+    }\n+  | {\n+      hasRef: null\n+      queueItem: null\n+      nativeImmediate: NodeJS.Immediate\n+    }\n+\n+function proxyQueuedImmediateToNativeImmediate(\n+  immediateObject: NextImmediate,\n+  nativeImmediate: NodeJS.Immediate\n+) {\n+  immediateObject[INTERNALS].hasRef = null\n+  immediateObject[INTERNALS].queueItem = null\n+  immediateObject[INTERNALS].nativeImmediate = nativeImmediate\n+}\n+\n+/** Makes sure that we're implementing all the public `Immediate` methods */\n+interface NativeImmediate extends NodeJS.Immediate {}\n+\n+/** Implements a shim for the native `Immediate` class returned by `setImmediate` */\n+class NextImmediate implements NativeImmediate {\n+  [INTERNALS]: NextImmediateInternals = {\n+    queueItem: null,\n+    hasRef: true,\n+    nativeImmediate: null,\n+  }\n+  hasRef() {\n+    const internals = this[INTERNALS]\n+    if (internals.queueItem) {\n+      return internals.hasRef\n+    } else if (internals.nativeImmediate) {\n+      return internals.nativeImmediate.hasRef()\n+    } else {\n+      // if we're no longer queued (cleared or executed), hasRef is always false\n+      return false\n+    }\n+  }\n+  ref() {\n+    const internals = this[INTERNALS]\n+    if (internals.queueItem) {\n+      internals.hasRef = true\n+    } else if (internals.nativeImmediate) {\n+      internals.nativeImmediate.ref()\n+    }\n+    return this\n+  }\n+  unref() {\n+    const internals = this[INTERNALS]\n+    if (internals.queueItem) {\n+      internals.hasRef = false\n+    } else if (internals.nativeImmediate) {\n+      internals.nativeImmediate.unref()\n+    }\n+    return this\n+  }\n+\n+  /**\n+   * Node invokes `_onImmediate` when an immediate is executed:\n+   * https://github.com/nodejs/node/blob/42d363205715ffa5a4a6d90f4be1311487053d65/lib/internal/timers.js#L504\n+   * It's visible on the public types, so we want to have it here for parity, but it's a noop.\n+   * */\n+  _onImmediate() {}\n+\n+  [Symbol.dispose]() {\n+    // This is equivalent to `clearImmediate`.\n+    const internals = this[INTERNALS]\n+    if (internals.queueItem) {\n+      // this is still queued. drop it.\n+      const queueItem = internals.queueItem\n+      internals.queueItem = null\n+      clearQueueItem(queueItem)\n+    } else if (internals.nativeImmediate) {\n+      internals.nativeImmediate[Symbol.dispose]()\n+    }\n+  }\n+}\n+\n+// ==========================================\n+\n+const debug =\n+  process.env.NEXT_DEBUG_IMMEDIATES !== '1'\n+    ? undefined\n+    : (...args: any[]) => {\n+        if (process.env.NEXT_RUNTIME === 'edge') {\n+          throw new InvariantError(\n+            'Fast setImmediate is not available in the edge runtime.'\n+          )\n+        } else {\n+          const { inspect } = require('node:util') as typeof import('node:util')\n+          const { writeFileSync } =\n+            require('node:fs') as typeof import('node:fs')\n+\n+          let logLine =\n+            args\n+              .map((arg) =>\n+                typeof arg === 'string' ? arg : inspect(arg, { colors: true })\n+              )\n+              .join(' ') + '\\n'\n+\n+          logLine = '\\x1B[2m' + logLine + '\\x1B[22m' // styleText('dim', logLine)\n+          writeFileSync(process.stdout.fd, logLine)\n+        }\n+      }\n+\n+// ==========================================\n+\n+install()"
        },
        {
            "sha": "f0300cd4c9439ddb1db81128fba8ef41e9ebc811",
            "filename": "packages/next/src/server/node-environment.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment.ts?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -17,3 +17,4 @@ import './node-environment-extensions/random'\n import './node-environment-extensions/date'\n import './node-environment-extensions/web-crypto'\n import './node-environment-extensions/node-crypto'\n+import './node-environment-extensions/fast-set-immediate.external'"
        },
        {
            "sha": "59417ac59cb5873496d05ac94a3c73b9388d3fae",
            "filename": "test/development/app-dir/cache-components-tasks/cache-components-tasks.test.ts",
            "status": "added",
            "additions": 190,
            "deletions": 0,
            "changes": 190,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Fcache-components-tasks.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Fcache-components-tasks.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Fcache-components-tasks.test.ts?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,190 @@\n+import { nextTestSetup } from 'e2e-utils'\n+import { retry } from 'next-test-utils'\n+import * as nodePath from 'node:path'\n+import type { Playwright } from '../../../lib/next-webdriver'\n+\n+describe.each([\n+  {\n+    description: 'without runtime prefetch configs',\n+    hasRuntimePrefetch: false,\n+    fixturePath: 'fixtures/without-prefetch-config',\n+  },\n+  {\n+    description: 'with runtime prefetch configs',\n+    hasRuntimePrefetch: true,\n+    fixturePath: 'fixtures/with-prefetch-config',\n+  },\n+])(\n+  'cache-components-tasks - $description',\n+  ({ fixturePath, hasRuntimePrefetch }) => {\n+    const { next, isTurbopack, isNextDev } = nextTestSetup({\n+      files: nodePath.join(__dirname, fixturePath),\n+    })\n+\n+    function assertLog(\n+      logs: Array<{ source: string; message: string }>,\n+      message: string,\n+      expectedEnvironment: string\n+    ) {\n+      // Match logs that contain the message, with any environment.\n+      const logPattern = new RegExp(\n+        `^(?=.*\\\\b${message}\\\\b)(?=.*\\\\b(Cache|Prerender|Prefetch|Prefetchable|Server)\\\\b).*`\n+      )\n+      const logMessages = logs.map((log) => log.message)\n+      const messages = logMessages.filter((message) => logPattern.test(message))\n+\n+      // If there's zero or more than one logs that match, the test is not set up correctly.\n+      if (messages.length === 0) {\n+        throw new Error(\n+          `Found no logs matching '${message}':\\n\\n${logMessages.map((s, i) => `${i}. ${s}`).join('\\n')}}`\n+        )\n+      }\n+      if (messages.length > 1) {\n+        throw new Error(\n+          `Found multiple logs matching '${message}':\\n\\n${messages.map((s, i) => `${i}. ${s}`).join('\\n')}`\n+        )\n+      }\n+\n+      // The message should have the expected environment.\n+      const actualMessageText = messages[0]\n+      const [, actualEnvironment] = actualMessageText.match(logPattern)!\n+      expect([actualEnvironment, actualMessageText]).toEqual([\n+        expectedEnvironment,\n+        expect.stringContaining(message),\n+      ])\n+    }\n+\n+    function assertNoUnexpectedErrorsInCli() {\n+      // We should not see any errors related to the aborted render.\n+      expect(next.cliOutput).not.toContain(\n+        'AbortError: This operation was aborted'\n+      )\n+      // We should not see warnings related to setTimeout.\n+      expect(next.cliOutput).not.toContain(\n+        \"Next.js cannot guarantee that Cache Components will run as expected due to the current runtime's implementation of `setTimeout()`\"\n+      )\n+    }\n+\n+    async function testInitialLoad(\n+      path: string,\n+      assertLogs: (browser: Playwright) => Promise<void>\n+    ) {\n+      const browser = await next.browser(path)\n+\n+      // Initial load.\n+      await retry(() => assertLogs(browser))\n+      assertNoUnexpectedErrorsInCli()\n+\n+      // After another load (with warm caches) the logs should be the same.\n+      await browser.loadPage(next.url + path) // clears old logs\n+      await retry(() => assertLogs(browser))\n+      assertNoUnexpectedErrorsInCli()\n+\n+      if (isNextDev && isTurbopack) {\n+        // FIXME:\n+        // In Turbopack, requests to the /revalidate route seem to occasionally crash\n+        // due to some HMR or compilation issue. `revalidatePath` throws this error:\n+        //\n+        //   Invariant: static generation store missing in revalidatePath <path>\n+        //\n+        // This is unrelated to the logic being tested here, so for now, we skip the assertions\n+        // that require us to revalidate.\n+        console.log('WARNING: skipping revalidation assertions in turbopack')\n+        return\n+      }\n+\n+      // After a revalidation the subsequent warmup render must discard stale\n+      // cache entries.\n+      // This should not affect the environment labels.\n+      await revalidatePath(path)\n+\n+      await browser.loadPage(next.url + path) // clears old logs\n+      await retry(() => assertLogs(browser))\n+      assertNoUnexpectedErrorsInCli()\n+    }\n+\n+    async function testNavigation(\n+      path: string,\n+      assertLogs: (browser: Playwright) => Promise<void>\n+    ) {\n+      const browser = await next.browser('/')\n+\n+      // Initial nav (first time loading the page)\n+      await browser.elementByCss(`a[href=\"${path}\"]`).click()\n+      await retry(() => assertLogs(browser))\n+      assertNoUnexpectedErrorsInCli()\n+\n+      // Reload, and perform another nav (with warm caches). the logs should be the same.\n+      await browser.loadPage(next.url + '/') // clears old logs\n+      await browser.elementByCss(`a[href=\"${path}\"]`).click()\n+      await retry(() => assertLogs(browser))\n+      assertNoUnexpectedErrorsInCli()\n+\n+      if (isNextDev && isTurbopack) {\n+        // FIXME:\n+        // In Turbopack, requests to the /revalidate route seem to occasionally crash\n+        // due to some HMR or compilation issue. `revalidatePath` throws this error:\n+        //\n+        //   Invariant: static generation store missing in revalidatePath <path>\n+        //\n+        // This is unrelated to the logic being tested here, so for now, we skip the assertions\n+        // that require us to revalidate.\n+        console.log('WARNING: skipping revalidation assertions in turbopack')\n+        return\n+      }\n+\n+      // After a revalidation the subsequent warmup render must discard stale\n+      // cache entries.\n+      // This should not affect the environment labels.\n+      await revalidatePath(path)\n+\n+      await browser.loadPage(next.url + '/') // clears old logs\n+      await browser.elementByCss(`a[href=\"${path}\"]`).click()\n+      await retry(() => assertLogs(browser))\n+      assertNoUnexpectedErrorsInCli()\n+    }\n+\n+    async function revalidatePath(path: string) {\n+      const response = await next.fetch(\n+        `/revalidate?path=${encodeURIComponent(path)}`\n+      )\n+      if (!response.ok) {\n+        throw new Error(\n+          `Failed to revalidate path: '${path}' - server responded with status ${response.status}`\n+        )\n+      }\n+    }\n+\n+    const RUNTIME_ENV = hasRuntimePrefetch ? 'Prefetch' : 'Prefetchable'\n+\n+    describe.each([\n+      { description: 'initial load', isInitialLoad: true },\n+      { description: 'navigation', isInitialLoad: false },\n+    ])('$description', ({ isInitialLoad }) => {\n+      it('setImmediate resolves between tasks', async () => {\n+        const path = '/simple'\n+        const assertLogs = async (browser: Playwright) => {\n+          const logs = await browser.log()\n+          assertLog(logs, 'after immediate - static - layout', 'Prerender')\n+          assertLog(logs, 'after immediate - static - page', 'Prerender')\n+\n+          assertLog(logs, 'after cookies - layout', RUNTIME_ENV)\n+          assertLog(logs, 'after cookies - page', RUNTIME_ENV)\n+          assertLog(logs, 'after immediate - runtime - layout', RUNTIME_ENV)\n+          assertLog(logs, 'after immediate - runtime - page', RUNTIME_ENV)\n+\n+          assertLog(logs, 'after connection - layout', 'Server')\n+          assertLog(logs, 'after connection - page', 'Server')\n+          assertLog(logs, 'after immediate - dynamic - layout', 'Server')\n+          assertLog(logs, 'after immediate - dynamic - page', 'Server')\n+        }\n+\n+        if (isInitialLoad) {\n+          await testInitialLoad(path, assertLogs)\n+        } else {\n+          await testNavigation(path, assertLogs)\n+        }\n+      })\n+    })\n+  }\n+)"
        },
        {
            "sha": "e7077399c03ce1479a655dc647c0545b64531628",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/with-prefetch-config/app/layout.tsx",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Flayout.tsx?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,7 @@\n+export default function Root({ children }: { children: React.ReactNode }) {\n+  return (\n+    <html>\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "837dca653a8fd3b671afbebb1a7f4a54160e9b48",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/with-prefetch-config/app/page.tsx",
            "status": "added",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Fpage.tsx?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,14 @@\n+import Link from 'next/link'\n+\n+export default function Page() {\n+  // NOTE: these links must be kept in sync with `path` variables used in the test\n+  return (\n+    <main>\n+      <ul>\n+        <li>\n+          <Link href=\"/simple\">/simple</Link>\n+        </li>\n+      </ul>\n+    </main>\n+  )\n+}"
        },
        {
            "sha": "d246995676e4b5addb3021282b0aa293c3f6a9a0",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/with-prefetch-config/app/revalidate/route.ts",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Frevalidate%2Froute.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Frevalidate%2Froute.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Frevalidate%2Froute.ts?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,8 @@\n+import { revalidatePath } from 'next/cache'\n+\n+export async function GET(request: Request) {\n+  const path = new URL(request.url).searchParams.get('path')!\n+  revalidatePath(path)\n+\n+  return Response.json({ revalidated: true })\n+}"
        },
        {
            "sha": "c81790e9f6e6cfaf6120829fcd4a6d7b9335631b",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/with-prefetch-config/app/shared.tsx",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Fshared.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Fshared.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Fshared.tsx?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,31 @@\n+import { cookies } from 'next/headers'\n+import { connection } from 'next/server'\n+\n+function immediate() {\n+  return new Promise<void>((resolve) => setImmediate(resolve))\n+}\n+\n+export async function Static({ label }: { label: string }) {\n+  await immediate()\n+  await immediate()\n+  console.log(`after immediate - static - ${label}`)\n+  return <div>Static - {label}</div>\n+}\n+\n+export async function Runtime({ label }: { label: string }) {\n+  await cookies()\n+  console.log(`after cookies - ${label}`)\n+  await immediate()\n+  await immediate()\n+  console.log(`after immediate - runtime - ${label}`)\n+  return <div>Runtime - {label}</div>\n+}\n+\n+export async function Dynamic({ label }: { label: string }) {\n+  await connection()\n+  console.log(`after connection - ${label}`)\n+  await immediate()\n+  await immediate()\n+  console.log(`after immediate - dynamic - ${label}`)\n+  return <div>Dynamic - {label}</div>\n+}"
        },
        {
            "sha": "cd2b95affea518a123cc32a153e9daa85c30731e",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/with-prefetch-config/app/simple/layout.tsx",
            "status": "added",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Fsimple%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Fsimple%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Fsimple%2Flayout.tsx?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,22 @@\n+import { Suspense } from 'react'\n+import { Static, Runtime, Dynamic } from '../shared'\n+\n+export const unstable_prefetch = { mode: 'runtime', samples: [{}] }\n+\n+export default function Root({ children }: { children: React.ReactNode }) {\n+  return (\n+    <>\n+      <div>\n+        <Static label=\"layout\" />\n+        <Suspense fallback=\"Loading...\">\n+          <Runtime label=\"layout\" />\n+        </Suspense>\n+        <Suspense fallback=\"Loading...\">\n+          <Dynamic label=\"layout\" />\n+        </Suspense>\n+      </div>\n+      <hr />\n+      {children}\n+    </>\n+  )\n+}"
        },
        {
            "sha": "ba361fa6d15a29fab52db44cdef880568d12e538",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/with-prefetch-config/app/simple/page.tsx",
            "status": "added",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Fsimple%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Fsimple%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fapp%2Fsimple%2Fpage.tsx?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,16 @@\n+import { Suspense } from 'react'\n+import { Static, Runtime, Dynamic } from '../shared'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <Static label=\"page\" />\n+      <Suspense fallback=\"Loading...\">\n+        <Runtime label=\"page\" />\n+      </Suspense>\n+      <Suspense fallback=\"Loading...\">\n+        <Dynamic label=\"page\" />\n+      </Suspense>\n+    </main>\n+  )\n+}"
        },
        {
            "sha": "fa33c7c54f24cc9c85addd95f17ab7b6ebc6d751",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/with-prefetch-config/next.config.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fnext.config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fnext.config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwith-prefetch-config%2Fnext.config.ts?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,7 @@\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  cacheComponents: true,\n+}\n+\n+export default nextConfig"
        },
        {
            "sha": "e7077399c03ce1479a655dc647c0545b64531628",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/without-prefetch-config/app/layout.tsx",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Flayout.tsx?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,7 @@\n+export default function Root({ children }: { children: React.ReactNode }) {\n+  return (\n+    <html>\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "837dca653a8fd3b671afbebb1a7f4a54160e9b48",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/without-prefetch-config/app/page.tsx",
            "status": "added",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Fpage.tsx?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,14 @@\n+import Link from 'next/link'\n+\n+export default function Page() {\n+  // NOTE: these links must be kept in sync with `path` variables used in the test\n+  return (\n+    <main>\n+      <ul>\n+        <li>\n+          <Link href=\"/simple\">/simple</Link>\n+        </li>\n+      </ul>\n+    </main>\n+  )\n+}"
        },
        {
            "sha": "d246995676e4b5addb3021282b0aa293c3f6a9a0",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/without-prefetch-config/app/revalidate/route.ts",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Frevalidate%2Froute.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Frevalidate%2Froute.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Frevalidate%2Froute.ts?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,8 @@\n+import { revalidatePath } from 'next/cache'\n+\n+export async function GET(request: Request) {\n+  const path = new URL(request.url).searchParams.get('path')!\n+  revalidatePath(path)\n+\n+  return Response.json({ revalidated: true })\n+}"
        },
        {
            "sha": "c81790e9f6e6cfaf6120829fcd4a6d7b9335631b",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/without-prefetch-config/app/shared.tsx",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Fshared.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Fshared.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Fshared.tsx?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,31 @@\n+import { cookies } from 'next/headers'\n+import { connection } from 'next/server'\n+\n+function immediate() {\n+  return new Promise<void>((resolve) => setImmediate(resolve))\n+}\n+\n+export async function Static({ label }: { label: string }) {\n+  await immediate()\n+  await immediate()\n+  console.log(`after immediate - static - ${label}`)\n+  return <div>Static - {label}</div>\n+}\n+\n+export async function Runtime({ label }: { label: string }) {\n+  await cookies()\n+  console.log(`after cookies - ${label}`)\n+  await immediate()\n+  await immediate()\n+  console.log(`after immediate - runtime - ${label}`)\n+  return <div>Runtime - {label}</div>\n+}\n+\n+export async function Dynamic({ label }: { label: string }) {\n+  await connection()\n+  console.log(`after connection - ${label}`)\n+  await immediate()\n+  await immediate()\n+  console.log(`after immediate - dynamic - ${label}`)\n+  return <div>Dynamic - {label}</div>\n+}"
        },
        {
            "sha": "a985803951507b8b3c0d525e35502ee9d7d9fa13",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/without-prefetch-config/app/simple/layout.tsx",
            "status": "added",
            "additions": 20,
            "deletions": 0,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Fsimple%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Fsimple%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Fsimple%2Flayout.tsx?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,20 @@\n+import { Suspense } from 'react'\n+import { Static, Runtime, Dynamic } from '../shared'\n+\n+export default function Root({ children }: { children: React.ReactNode }) {\n+  return (\n+    <>\n+      <div>\n+        <Static label=\"layout\" />\n+        <Suspense fallback=\"Loading...\">\n+          <Runtime label=\"layout\" />\n+        </Suspense>\n+        <Suspense fallback=\"Loading...\">\n+          <Dynamic label=\"layout\" />\n+        </Suspense>\n+      </div>\n+      <hr />\n+      {children}\n+    </>\n+  )\n+}"
        },
        {
            "sha": "ba361fa6d15a29fab52db44cdef880568d12e538",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/without-prefetch-config/app/simple/page.tsx",
            "status": "added",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Fsimple%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Fsimple%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fapp%2Fsimple%2Fpage.tsx?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,16 @@\n+import { Suspense } from 'react'\n+import { Static, Runtime, Dynamic } from '../shared'\n+\n+export default async function Page() {\n+  return (\n+    <main>\n+      <Static label=\"page\" />\n+      <Suspense fallback=\"Loading...\">\n+        <Runtime label=\"page\" />\n+      </Suspense>\n+      <Suspense fallback=\"Loading...\">\n+        <Dynamic label=\"page\" />\n+      </Suspense>\n+    </main>\n+  )\n+}"
        },
        {
            "sha": "fa33c7c54f24cc9c85addd95f17ab7b6ebc6d751",
            "filename": "test/development/app-dir/cache-components-tasks/fixtures/without-prefetch-config/next.config.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fnext.config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/bf23890a91f1ee3ccb2b1246dc075ca7a56693b4/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fnext.config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fapp-dir%2Fcache-components-tasks%2Ffixtures%2Fwithout-prefetch-config%2Fnext.config.ts?ref=bf23890a91f1ee3ccb2b1246dc075ca7a56693b4",
            "patch": "@@ -0,0 +1,7 @@\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  cacheComponents: true,\n+}\n+\n+export default nextConfig"
        }
    ],
    "stats": {
        "total": 2715,
        "additions": 2702,
        "deletions": 13
    }
}