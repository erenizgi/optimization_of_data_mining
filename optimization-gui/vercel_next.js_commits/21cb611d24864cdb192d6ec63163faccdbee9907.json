{
    "author": "sokra",
    "message": "Turbopack: fix race condition when adding dependencies (#84946)\n\n### What?\n\nThere is a race condition with the way we add the dependency backedges. We add the \"dependent\" edge first and in a separate lock the \"dependency\" edge. But if an invalidation happens just between these locks it do not invalidate the task as it's either still \"outdated\" or doesn't have a \"dependency\" edge yet. So we loose an invalidation.\n\nAdding the dependency first is also a bit problematic as task could be in progress, which won't cause a dependency to be added, or it could be untracked() which would only add the dependency when the task is an error.\n\nFor now this fixes the race condition by locking both tasks at the same time. But that's not optimal for performance, especially for this common operation (reading a output or cell).\nAs follow-up we need to look into something with better performance",
    "sha": "21cb611d24864cdb192d6ec63163faccdbee9907",
    "files": [
        {
            "sha": "3d1d9674a45434fb776bc68a8175a62827ec96b4",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 48,
            "deletions": 19,
            "changes": 67,
            "blob_url": "https://github.com/vercel/next.js/blob/21cb611d24864cdb192d6ec63163faccdbee9907/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/21cb611d24864cdb192d6ec63163faccdbee9907/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=21cb611d24864cdb192d6ec63163faccdbee9907",
            "patch": "@@ -467,7 +467,19 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         self.assert_not_persistent_calling_transient(reader, task_id, /* cell_id */ None);\n \n         let mut ctx = self.execute_context(turbo_tasks);\n-        let mut task = ctx.task(task_id, TaskDataCategory::All);\n+        let (mut task, reader_task) = if self.should_track_dependencies()\n+            && !matches!(options.tracking, ReadTracking::Untracked)\n+            && let Some(reader_id) = reader\n+            && reader_id != task_id\n+        {\n+            // Having a task_pair here is not optimal, but otherwise this would lead to a race\n+            // condition. See below.\n+            // TODO(sokra): solve that in a more performant way.\n+            let (task, reader) = ctx.task_pair(task_id, reader_id, TaskDataCategory::All);\n+            (task, Some(reader))\n+        } else {\n+            (ctx.task(task_id, TaskDataCategory::All), None)\n+        };\n \n         fn listen_to_done_event<B: BackingStorage>(\n             this: &TurboTasksBackendInner<B>,\n@@ -710,18 +722,22 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     )))\n                 }\n             };\n-            if self.should_track_dependencies()\n-                && let Some(reader) = reader\n+            if let Some(mut reader_task) = reader_task\n                 && options.tracking.should_track(result.is_err())\n                 && (!task.is_immutable() || cfg!(feature = \"verify_immutable\"))\n             {\n+                let reader = reader.unwrap();\n                 let _ = task.add(CachedDataItem::OutputDependent {\n                     task: reader,\n                     value: (),\n                 });\n                 drop(task);\n \n-                let mut reader_task = ctx.task(reader, TaskDataCategory::Data);\n+                // Note: We use `task_pair` earlier to lock the task and its reader at the same\n+                // time. If we didn't and just locked the reader here, an invalidation could occur\n+                // between grabbing the locks. If that happened, and if the task is \"outdated\" or\n+                // doesn't have the dependency edge yet, the invalidation would be lost.\n+\n                 if reader_task\n                     .remove(&CachedDataItemKey::OutdatedOutputDependency { target: task_id })\n                     .is_none()\n@@ -735,6 +751,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n             return result;\n         }\n+        drop(reader_task);\n \n         let note = move || {\n             let reader_desc = reader.map(|r| self.get_task_desc_fn(r));\n@@ -771,29 +788,28 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n     ) -> Result<Result<TypedCellContent, EventListener>> {\n         self.assert_not_persistent_calling_transient(reader, task_id, Some(cell));\n \n-        fn add_cell_dependency<B: BackingStorage>(\n-            backend: &TurboTasksBackendInner<B>,\n+        fn add_cell_dependency(\n+            task_id: TaskId,\n             mut task: impl TaskGuard,\n             reader: Option<TaskId>,\n+            reader_task: Option<impl TaskGuard>,\n             cell: CellId,\n-            task_id: TaskId,\n-            ctx: &mut impl ExecuteContext<'_>,\n         ) {\n-            if backend.should_track_dependencies()\n-                && let Some(reader) = reader\n-                // We never want to have a dependency on ourselves, otherwise we end up in a\n-                // loop of re-executing the same task.\n-                && reader != task_id\n+            if let Some(mut reader_task) = reader_task\n                 && (!task.is_immutable() || cfg!(feature = \"verify_immutable\"))\n             {\n                 let _ = task.add(CachedDataItem::CellDependent {\n                     cell,\n-                    task: reader,\n+                    task: reader.unwrap(),\n                     value: (),\n                 });\n                 drop(task);\n \n-                let mut reader_task = ctx.task(reader, TaskDataCategory::Data);\n+                // Note: We use `task_pair` earlier to lock the task and its reader at the same\n+                // time. If we didn't and just locked the reader here, an invalidation could occur\n+                // between grabbing the locks. If that happened, and if the task is \"outdated\" or\n+                // doesn't have the dependency edge yet, the invalidation would be lost.\n+\n                 let target = CellRef {\n                     task: task_id,\n                     cell,\n@@ -808,7 +824,20 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         }\n \n         let mut ctx = self.execute_context(turbo_tasks);\n-        let mut task = ctx.task(task_id, TaskDataCategory::Data);\n+        let (mut task, reader_task) = if self.should_track_dependencies()\n+            && !matches!(options.tracking, ReadTracking::Untracked)\n+            && let Some(reader_id) = reader\n+            && reader_id != task_id\n+        {\n+            // Having a task_pair here is not optimal, but otherwise this would lead to a race\n+            // condition. See below.\n+            // TODO(sokra): solve that in a more performant way.\n+            let (task, reader) = ctx.task_pair(task_id, reader_id, TaskDataCategory::Data);\n+            (task, Some(reader))\n+        } else {\n+            (ctx.task(task_id, TaskDataCategory::Data), None)\n+        };\n+\n         let content = if options.final_read_hint {\n             remove!(task, CellData { cell })\n         } else if let Some(content) = get!(task, CellData { cell }) {\n@@ -819,7 +848,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         };\n         if let Some(content) = content {\n             if options.tracking.should_track(false) {\n-                add_cell_dependency(self, task, reader, cell, task_id, &mut ctx);\n+                add_cell_dependency(task_id, task, reader, reader_task, cell);\n             }\n             return Ok(Ok(TypedCellContent(\n                 cell.type_id,\n@@ -846,7 +875,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         .copied();\n         let Some(max_id) = max_id else {\n             if options.tracking.should_track(true) {\n-                add_cell_dependency(self, task, reader, cell, task_id, &mut ctx);\n+                add_cell_dependency(task_id, task, reader, reader_task, cell);\n             }\n             bail!(\n                 \"Cell {cell:?} no longer exists in task {} (no cell of this type exists)\",\n@@ -855,7 +884,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         };\n         if cell.index >= max_id {\n             if options.tracking.should_track(true) {\n-                add_cell_dependency(self, task, reader, cell, task_id, &mut ctx);\n+                add_cell_dependency(task_id, task, reader, reader_task, cell);\n             }\n             bail!(\n                 \"Cell {cell:?} no longer exists in task {} (index out of bounds)\","
        },
        {
            "sha": "6d8d6f570c63b2fdf995fcdd390b01d66a8ad138",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 7,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/21cb611d24864cdb192d6ec63163faccdbee9907/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/21cb611d24864cdb192d6ec63163faccdbee9907/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=21cb611d24864cdb192d6ec63163faccdbee9907",
            "patch": "@@ -47,20 +47,21 @@ enum TransactionState<'a, 'tx, B: BackingStorage> {\n }\n \n pub trait ExecuteContext<'e>: Sized {\n+    type TaskGuardImpl: TaskGuard + 'e;\n     fn child_context<'l, 'r>(&'r self) -> impl ChildExecuteContext<'l> + use<'e, 'l, Self>\n     where\n         'e: 'l;\n     fn session_id(&self) -> SessionId;\n-    fn task(&mut self, task_id: TaskId, category: TaskDataCategory) -> impl TaskGuard + 'e;\n+    fn task(&mut self, task_id: TaskId, category: TaskDataCategory) -> Self::TaskGuardImpl;\n     fn is_once_task(&self, task_id: TaskId) -> bool;\n     fn task_pair(\n         &mut self,\n         task_id1: TaskId,\n         task_id2: TaskId,\n         category: TaskDataCategory,\n-    ) -> (impl TaskGuard + 'e, impl TaskGuard + 'e);\n+    ) -> (Self::TaskGuardImpl, Self::TaskGuardImpl);\n     fn schedule(&mut self, task_id: TaskId);\n-    fn schedule_task(&self, task: impl TaskGuard + '_);\n+    fn schedule_task(&self, task: Self::TaskGuardImpl);\n     fn operation_suspend_point<T>(&mut self, op: &T)\n     where\n         T: Clone + Into<AnyOperation>;\n@@ -162,6 +163,8 @@ impl<'e, 'tx, B: BackingStorage> ExecuteContext<'e> for ExecuteContextImpl<'e, '\n where\n     'tx: 'e,\n {\n+    type TaskGuardImpl = TaskGuardImpl<'e, B>;\n+\n     fn child_context<'l, 'r>(&'r self) -> impl ChildExecuteContext<'l> + use<'e, 'tx, 'l, B>\n     where\n         'e: 'l,\n@@ -176,7 +179,7 @@ where\n         self.backend.session_id()\n     }\n \n-    fn task(&mut self, task_id: TaskId, category: TaskDataCategory) -> impl TaskGuard + 'e {\n+    fn task(&mut self, task_id: TaskId, category: TaskDataCategory) -> Self::TaskGuardImpl {\n         let mut task = self.backend.storage.access_mut(task_id);\n         if !task.state().is_restored(category) {\n             if task_id.is_transient() {\n@@ -224,7 +227,7 @@ where\n         task_id1: TaskId,\n         task_id2: TaskId,\n         category: TaskDataCategory,\n-    ) -> (impl TaskGuard + 'e, impl TaskGuard + 'e) {\n+    ) -> (Self::TaskGuardImpl, Self::TaskGuardImpl) {\n         let (mut task1, mut task2) = self.backend.storage.access_pair_mut(task_id1, task_id2);\n         let is_restored1 = task1.state().is_restored(category);\n         let is_restored2 = task2.state().is_restored(category);\n@@ -277,7 +280,7 @@ where\n         self.schedule_task(task);\n     }\n \n-    fn schedule_task(&self, mut task: impl TaskGuard + '_) {\n+    fn schedule_task(&self, mut task: Self::TaskGuardImpl) {\n         if let Some(tasks_to_prefetch) = task.prefetch() {\n             self.turbo_tasks\n                 .schedule_backend_background_job(TurboTasksBackendJob::Prefetch {\n@@ -367,7 +370,7 @@ pub trait TaskGuard: Debug {\n     fn is_immutable(&self) -> bool;\n }\n \n-struct TaskGuardImpl<'a, B: BackingStorage> {\n+pub struct TaskGuardImpl<'a, B: BackingStorage> {\n     task_id: TaskId,\n     task: StorageWriteGuard<'a>,\n     backend: &'a TurboTasksBackendInner<B>,"
        },
        {
            "sha": "f880f414f894396502a66e540039d98cd85d683d",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/21cb611d24864cdb192d6ec63163faccdbee9907/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/21cb611d24864cdb192d6ec63163faccdbee9907/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=21cb611d24864cdb192d6ec63163faccdbee9907",
            "patch": "@@ -1761,6 +1761,7 @@ impl CurrentCellRef {\n                 self.current_task,\n                 self.index,\n                 ReadCellOptions {\n+                    // INVALIDATION: Reading our own cell must be untracked\n                     tracking: ReadTracking::Untracked,\n                     ..Default::default()\n                 },\n@@ -1879,6 +1880,7 @@ impl CurrentCellRef {\n                 self.current_task,\n                 self.index,\n                 ReadCellOptions {\n+                    // INVALIDATION: Reading our own cell must be untracked\n                     tracking: ReadTracking::Untracked,\n                     ..Default::default()\n                 },"
        }
    ],
    "stats": {
        "total": 86,
        "additions": 60,
        "deletions": 26
    }
}