{
    "author": "unstubbable",
    "message": "Add more debug logs to `'use cache'` wrapper (#88219)\n\nThe cache handlers are generally responsible for adding debug logs to\ntheir methods, see\n`packages/next/src/server/lib/cache-handlers/default.ts` for reference.\nHowever, the `'use cache'` wrapper in\n`packages/next/src/server/use-cache/use-cache-wrapper.ts` also adds a\nfew debug logs of its own that pertain to logic that is specific to the\nwrapper itself, e.g. when discarding cache entries because of tag\nrevalidation. With this PR, we're now also logging cache hits and misses\nin the Resume Data Cache, as well as when entries are omitted from the\nstatic or runtime shell due to their revalidate, expire or stale values.\n\nDocs:\nhttps://nextjs.org/docs/app/api-reference/directives/use-cache#verbose-logging",
    "sha": "6805af48baf1128e6b2a9e8f1752ee5982f02c60",
    "files": [
        {
            "sha": "b1467b944792ba9159ff4ac07b2d9d756a41bfb1",
            "filename": "packages/next/src/server/use-cache/use-cache-wrapper.ts",
            "status": "modified",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/6805af48baf1128e6b2a9e8f1752ee5982f02c60/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/6805af48baf1128e6b2a9e8f1752ee5982f02c60/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fuse-cache%2Fuse-cache-wrapper.ts?ref=6805af48baf1128e6b2a9e8f1752ee5982f02c60",
            "patch": "@@ -1256,6 +1256,20 @@ export async function cache(\n               // generating static pages for such data. It's better to leave\n               // a dynamic hole that can be filled in during the resume with\n               // a potentially cached entry.\n+              if (existingEntry.revalidate === 0) {\n+                debug?.(\n+                  'omitting entry',\n+                  serializedCacheKey,\n+                  'from static shell due to revalidate: 0'\n+                )\n+              } else {\n+                debug?.(\n+                  'omitting entry',\n+                  serializedCacheKey,\n+                  'from static shell due to short expire value:',\n+                  existingEntry.expire\n+                )\n+              }\n               if (cacheSignal) {\n                 cacheSignal.endRead()\n               }\n@@ -1307,6 +1321,12 @@ export async function cache(\n               // stale in less then 30 seconds, we consider this cache entry\n               // dynamic as it's not worth prefetching. It's better to leave\n               // a dynamic hole that can be filled during the navigation.\n+              debug?.(\n+                'omitting entry',\n+                serializedCacheKey,\n+                'from runtime shell due to short stale value:',\n+                existingEntry.stale\n+              )\n               if (cacheSignal) {\n                 cacheSignal.endRead()\n               }\n@@ -1344,6 +1364,8 @@ export async function cache(\n         }\n       }\n \n+      debug?.('Resume Data Cache entry found', serializedCacheKey)\n+\n       // We want to make sure we only propagate cache life & tags if the\n       // entry was *not* omitted from the prerender. So we only do this\n       // after the above early returns.\n@@ -1360,6 +1382,8 @@ export async function cache(\n         stream = streamA\n       }\n     } else {\n+      debug?.('Resume Data Cache entry not found', serializedCacheKey)\n+\n       if (cacheSignal) {\n         cacheSignal.endRead()\n       }\n@@ -1481,6 +1505,20 @@ export async function cache(\n           // pages for such data. It's better to leave a dynamic hole that\n           // can be filled in during the resume with a potentially cached\n           // entry.\n+          if (entry.revalidate === 0) {\n+            debug?.(\n+              'omitting entry',\n+              serializedCacheKey,\n+              'from static shell due to revalidate: 0'\n+            )\n+          } else {\n+            debug?.(\n+              'omitting entry',\n+              serializedCacheKey,\n+              'from static shell due to short expire value:',\n+              entry.expire\n+            )\n+          }\n           if (cacheSignal) {\n             cacheSignal.endRead()\n           }"
        }
    ],
    "stats": {
        "total": 38,
        "additions": 38,
        "deletions": 0
    }
}