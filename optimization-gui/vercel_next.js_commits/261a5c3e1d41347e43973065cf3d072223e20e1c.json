{
    "author": "lukesandberg",
    "message": "[turbopack] mark `rcstr!` allocated Rcstr values as 'static' and stop refcounting them (#81994)\n\n# Optimize RcStr with Static Atom Support\n\n## What?\nFor RcStr values allocated by the `rcstr!` macro we shouldn't bother reference counting them since they are pinned to a static memory location already.  This uses a spare tag bit `0b10` to mark such strings as 'static' which allows us to to optimize the `clone` and `drop`.  The only practical cost is an additional constant bit mask when reading the value as a pointer. \n\nAlso:\n* add a fast path for `PartialEq<RcStr>` to handle identical values, this is useful especially for inline RcStr values but adds a fast path for refcounted strings as well.\n * compute the `hash` of `rcstr!` parameters at compile time by `const`-ifying the hash fn\n * allocate static storage for the `PrecomputeHash` struct\n       - ideally we would 'const' allocate it, but `String` isn't const compatible.  We could maybe use `String::from_raw_parts` but it would depend on too many implementation details.  The real solution here is probably to change the definition of PrehashedString to hold an Either or a Cow?  not sure if that is worth it.\n\n## Why?\n\nAtomic ref counting is cheap but not free, we have a large number of `rcstr!` allocated strings and so it is pure overhead to spend any time refcounting them when the count will never hit zero.\n\nSee the upstack PR for some performance measurements on vercel-site",
    "sha": "261a5c3e1d41347e43973065cf3d072223e20e1c",
    "files": [
        {
            "sha": "31b96beee01da814fc1f787da10790886dd04354",
            "filename": "turbopack/crates/turbo-rcstr/src/dynamic.rs",
            "status": "modified",
            "additions": 76,
            "deletions": 15,
            "changes": 91,
            "blob_url": "https://github.com/vercel/next.js/blob/261a5c3e1d41347e43973065cf3d072223e20e1c/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Fdynamic.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/261a5c3e1d41347e43973065cf3d072223e20e1c/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Fdynamic.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Fdynamic.rs?ref=261a5c3e1d41347e43973065cf3d072223e20e1c",
            "patch": "@@ -3,12 +3,37 @@ use std::{num::NonZeroU8, ptr::NonNull};\n use triomphe::Arc;\n \n use crate::{\n-    INLINE_TAG, INLINE_TAG_INIT, LEN_OFFSET, RcStr, TAG_MASK,\n+    INLINE_TAG, INLINE_TAG_INIT, LEN_OFFSET, RcStr, STATIC_TAG, TAG_MASK,\n     tagged_value::{MAX_INLINE_LEN, TaggedValue},\n };\n \n-pub(crate) struct PrehashedString {\n-    pub value: String,\n+pub enum Payload {\n+    String(String),\n+    Ref(&'static str),\n+}\n+\n+impl Payload {\n+    pub(crate) fn as_str(&self) -> &str {\n+        match self {\n+            Payload::String(s) => s,\n+            Payload::Ref(s) => s,\n+        }\n+    }\n+    pub(crate) fn into_string(self) -> String {\n+        match self {\n+            Payload::String(s) => s,\n+            Payload::Ref(r) => r.to_string(),\n+        }\n+    }\n+}\n+impl PartialEq for Payload {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.as_str() == other.as_str()\n+    }\n+}\n+\n+pub struct PrehashedString {\n+    pub value: Payload,\n     /// This is not the actual `fxhash`, but rather it's a value that passed to\n     /// `write_u64` of [rustc_hash::FxHasher].\n     pub hash: u64,\n@@ -46,7 +71,7 @@ pub(crate) fn new_atom<T: AsRef<str> + Into<String>>(text: T) -> RcStr {\n     let hash = hash_bytes(text.as_ref().as_bytes());\n \n     let entry: Arc<PrehashedString> = Arc::new(PrehashedString {\n-        value: text.into(),\n+        value: Payload::String(text.into()),\n         hash,\n     });\n     let entry = Arc::into_raw(entry);\n@@ -61,6 +86,22 @@ pub(crate) fn new_atom<T: AsRef<str> + Into<String>>(text: T) -> RcStr {\n     }\n }\n \n+#[inline(always)]\n+pub(crate) fn new_static_atom(string: &'static PrehashedString) -> RcStr {\n+    let mut entry = string as *const PrehashedString;\n+    debug_assert!(0 == entry as u8 & TAG_MASK);\n+    // Tag it as a static pointer\n+    entry = ((entry as usize) | STATIC_TAG as usize) as *mut PrehashedString;\n+    let ptr: NonNull<PrehashedString> = unsafe {\n+        // Safety: Box::into_raw returns a non-null pointer\n+        NonNull::new_unchecked(entry as *mut _)\n+    };\n+\n+    RcStr {\n+        unsafe_data: TaggedValue::new_ptr(ptr),\n+    }\n+}\n+\n /// Attempts to construct an RcStr but only if it can be constructed inline.\n /// This is primarily useful in constant contexts.\n #[doc(hidden)]\n@@ -90,7 +131,7 @@ const SEED2: u64 = 0x13198a2e03707344;\n const PREVENT_TRIVIAL_ZERO_COLLAPSE: u64 = 0xa4093822299f31d0;\n \n #[inline]\n-fn multiply_mix(x: u64, y: u64) -> u64 {\n+const fn multiply_mix(x: u64, y: u64) -> u64 {\n     #[cfg(target_pointer_width = \"64\")]\n     {\n         // We compute the full u64 x u64 -> u128 product, this is a single mul\n@@ -131,6 +172,26 @@ fn multiply_mix(x: u64, y: u64) -> u64 {\n     }\n }\n \n+// Const compatible helper function to read a u64 from a byte array at a given offset\n+const fn read_u64_le(bytes: &[u8], offset: usize) -> u64 {\n+    (bytes[offset] as u64)\n+        | ((bytes[offset + 1] as u64) << 8)\n+        | ((bytes[offset + 2] as u64) << 16)\n+        | ((bytes[offset + 3] as u64) << 24)\n+        | ((bytes[offset + 4] as u64) << 32)\n+        | ((bytes[offset + 5] as u64) << 40)\n+        | ((bytes[offset + 6] as u64) << 48)\n+        | ((bytes[offset + 7] as u64) << 56)\n+}\n+\n+// Const compatible helper function to read a u32 from a byte array at a given offset\n+const fn read_u32_le(bytes: &[u8], offset: usize) -> u32 {\n+    (bytes[offset] as u32)\n+        | ((bytes[offset + 1] as u32) << 8)\n+        | ((bytes[offset + 2] as u32) << 16)\n+        | ((bytes[offset + 3] as u32) << 24)\n+}\n+\n /// Copied from `hash_bytes` of `rustc-hash`.\n ///\n /// See: https://github.com/rust-lang/rustc-hash/blob/dc5c33f1283de2da64d8d7a06401d91aded03ad4/src/lib.rs#L252-L297\n@@ -149,19 +210,20 @@ fn multiply_mix(x: u64, y: u64) -> u64 {\n /// We don't bother avalanching here as we'll feed this hash into a\n /// multiplication after which we take the high bits, which avalanches for us.\n #[inline]\n-fn hash_bytes(bytes: &[u8]) -> u64 {\n+#[doc(hidden)]\n+pub const fn hash_bytes(bytes: &[u8]) -> u64 {\n     let len = bytes.len();\n     let mut s0 = SEED1;\n     let mut s1 = SEED2;\n \n     if len <= 16 {\n         // XOR the input into s0, s1.\n         if len >= 8 {\n-            s0 ^= u64::from_le_bytes(bytes[0..8].try_into().unwrap());\n-            s1 ^= u64::from_le_bytes(bytes[len - 8..].try_into().unwrap());\n+            s0 ^= read_u64_le(bytes, 0);\n+            s1 ^= read_u64_le(bytes, len - 8);\n         } else if len >= 4 {\n-            s0 ^= u32::from_le_bytes(bytes[0..4].try_into().unwrap()) as u64;\n-            s1 ^= u32::from_le_bytes(bytes[len - 4..].try_into().unwrap()) as u64;\n+            s0 ^= read_u32_le(bytes, 0) as u64;\n+            s1 ^= read_u32_le(bytes, len - 4) as u64;\n         } else if len > 0 {\n             let lo = bytes[0];\n             let mid = bytes[len / 2];\n@@ -173,8 +235,8 @@ fn hash_bytes(bytes: &[u8]) -> u64 {\n         // Handle bulk (can partially overlap with suffix).\n         let mut off = 0;\n         while off < len - 16 {\n-            let x = u64::from_le_bytes(bytes[off..off + 8].try_into().unwrap());\n-            let y = u64::from_le_bytes(bytes[off + 8..off + 16].try_into().unwrap());\n+            let x = read_u64_le(bytes, off);\n+            let y = read_u64_le(bytes, off + 8);\n \n             // Replace s1 with a mix of s0, x, and y, and s0 with s1.\n             // This ensures the compiler can unroll this loop into two\n@@ -188,9 +250,8 @@ fn hash_bytes(bytes: &[u8]) -> u64 {\n             off += 16;\n         }\n \n-        let suffix = &bytes[len - 16..];\n-        s0 ^= u64::from_le_bytes(suffix[0..8].try_into().unwrap());\n-        s1 ^= u64::from_le_bytes(suffix[8..16].try_into().unwrap());\n+        s0 ^= read_u64_le(bytes, len - 16);\n+        s1 ^= read_u64_le(bytes, len - 8);\n     }\n \n     multiply_mix(s0, s1) ^ (len as u64)"
        },
        {
            "sha": "b43c61fbf2593a786113e228f1c8d2cfb0ce8235",
            "filename": "turbopack/crates/turbo-rcstr/src/lib.rs",
            "status": "modified",
            "additions": 106,
            "deletions": 40,
            "changes": 146,
            "blob_url": "https://github.com/vercel/next.js/blob/261a5c3e1d41347e43973065cf3d072223e20e1c/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/261a5c3e1d41347e43973065cf3d072223e20e1c/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Flib.rs?ref=261a5c3e1d41347e43973065cf3d072223e20e1c",
            "patch": "@@ -17,7 +17,7 @@ use triomphe::Arc;\n use turbo_tasks_hash::{DeterministicHash, DeterministicHasher};\n \n use crate::{\n-    dynamic::{deref_from, new_atom},\n+    dynamic::{deref_from, hash_bytes, new_atom},\n     tagged_value::TaggedValue,\n };\n \n@@ -71,35 +71,61 @@ pub struct RcStr {\n     unsafe_data: TaggedValue,\n }\n \n+const _: () = {\n+    // Enforce that RcStr triggers the non-zero size optimization.\n+    assert!(std::mem::size_of::<RcStr>() == std::mem::size_of::<Option<RcStr>>());\n+};\n+\n unsafe impl Send for RcStr {}\n unsafe impl Sync for RcStr {}\n \n+// Marks a payload that is stored in an Arc\n const DYNAMIC_TAG: u8 = 0b_00;\n+const PREHASHED_STRING_LOCATION: u8 = 0b_0;\n+// Marks a payload that has been leaked since it has a static lifetime\n+const STATIC_TAG: u8 = 0b_10;\n+// The payload is stored inline\n const INLINE_TAG: u8 = 0b_01; // len in upper nybble\n+const INLINE_LOCATION: u8 = 0b_1;\n const INLINE_TAG_INIT: NonZeroU8 = NonZeroU8::new(INLINE_TAG).unwrap();\n const TAG_MASK: u8 = 0b_11;\n+const LOCATION_MASK: u8 = 0b_1;\n+// For inline tags the length is stored in the upper 4 bits of the tag byte\n const LEN_OFFSET: usize = 4;\n const LEN_MASK: u8 = 0xf0;\n \n impl RcStr {\n     #[inline(always)]\n     fn tag(&self) -> u8 {\n-        self.unsafe_data.tag() & TAG_MASK\n+        self.unsafe_data.tag_byte() & TAG_MASK\n+    }\n+    #[inline(always)]\n+    fn location(&self) -> u8 {\n+        self.unsafe_data.tag_byte() & LOCATION_MASK\n     }\n \n     #[inline(never)]\n     pub fn as_str(&self) -> &str {\n-        match self.tag() {\n-            DYNAMIC_TAG => unsafe { dynamic::deref_from(self.unsafe_data).value.as_str() },\n-            INLINE_TAG => {\n-                let len = (self.unsafe_data.tag() & LEN_MASK) >> LEN_OFFSET;\n-                let src = self.unsafe_data.data();\n-                unsafe { std::str::from_utf8_unchecked(&src[..(len as usize)]) }\n-            }\n+        match self.location() {\n+            PREHASHED_STRING_LOCATION => self.prehashed_string_as_str(),\n+            INLINE_LOCATION => self.inline_as_str(),\n             _ => unsafe { debug_unreachable!() },\n         }\n     }\n \n+    fn inline_as_str(&self) -> &str {\n+        debug_assert!(self.location() == INLINE_LOCATION);\n+        let len = (self.unsafe_data.tag_byte() & LEN_MASK) >> LEN_OFFSET;\n+        let src = self.unsafe_data.data();\n+        unsafe { std::str::from_utf8_unchecked(&src[..(len as usize)]) }\n+    }\n+\n+    // Extract the str reference from a string stored in a PrehashedString\n+    fn prehashed_string_as_str(&self) -> &str {\n+        debug_assert!(self.location() == PREHASHED_STRING_LOCATION);\n+        unsafe { dynamic::deref_from(self.unsafe_data).value.as_str() }\n+    }\n+\n     /// Returns an owned mutable [`String`].\n     ///\n     /// This implementation is more efficient than [`ToString::to_string`]:\n@@ -113,31 +139,19 @@ impl RcStr {\n                 // convert `self` into `arc`\n                 let arc = unsafe { dynamic::restore_arc(ManuallyDrop::new(self).unsafe_data) };\n                 match Arc::try_unwrap(arc) {\n-                    Ok(v) => v.value,\n-                    Err(arc) => arc.value.to_string(),\n+                    Ok(v) => v.value.into_string(),\n+                    Err(arc) => arc.value.as_str().to_string(),\n                 }\n             }\n-            INLINE_TAG => self.as_str().to_string(),\n+            INLINE_TAG => self.inline_as_str().to_string(),\n+            STATIC_TAG => self.prehashed_string_as_str().to_string(),\n             _ => unsafe { debug_unreachable!() },\n         }\n     }\n \n     pub fn map(self, f: impl FnOnce(String) -> String) -> Self {\n         RcStr::from(Cow::Owned(f(self.into_owned())))\n     }\n-\n-    #[inline]\n-    pub(crate) fn from_alias(alias: TaggedValue) -> Self {\n-        if alias.tag() & TAG_MASK == DYNAMIC_TAG {\n-            unsafe {\n-                let arc = dynamic::restore_arc(alias);\n-                forget(arc.clone());\n-                forget(arc);\n-            }\n-        }\n-\n-        Self { unsafe_data: alias }\n-    }\n }\n \n impl DeterministicHash for RcStr {\n@@ -264,7 +278,18 @@ impl From<RcStr> for PathBuf {\n impl Clone for RcStr {\n     #[inline(always)]\n     fn clone(&self) -> Self {\n-        Self::from_alias(self.unsafe_data)\n+        let alias = self.unsafe_data;\n+        // We only need to increment the ref count for DYNAMIC_TAG values\n+        // For STATIC_TAG and INLINE_TAG we can just copy the value.\n+        if alias.tag_byte() & TAG_MASK == DYNAMIC_TAG {\n+            unsafe {\n+                let arc = dynamic::restore_arc(alias);\n+                forget(arc.clone());\n+                forget(arc);\n+            }\n+        }\n+\n+        RcStr { unsafe_data: alias }\n     }\n }\n \n@@ -276,13 +301,20 @@ impl Default for RcStr {\n \n impl PartialEq for RcStr {\n     fn eq(&self, other: &Self) -> bool {\n-        match (self.tag(), other.tag()) {\n-            (DYNAMIC_TAG, DYNAMIC_TAG) => {\n+        // For inline RcStrs this is sufficient and for out of line values it handles a simple\n+        // identity cases\n+        if self.unsafe_data == other.unsafe_data {\n+            return true;\n+        }\n+        // They can still be equal if they are both stored on the heap\n+        match (self.location(), other.location()) {\n+            (PREHASHED_STRING_LOCATION, PREHASHED_STRING_LOCATION) => {\n                 let l = unsafe { deref_from(self.unsafe_data) };\n                 let r = unsafe { deref_from(other.unsafe_data) };\n                 l.hash == r.hash && l.value == r.value\n             }\n-            (INLINE_TAG, INLINE_TAG) => self.unsafe_data == other.unsafe_data,\n+            // NOTE: it is never possible for an inline storage string to compare equal to a dynamic\n+            // allocated string, the construction routines separate the strings based on length.\n             _ => false,\n         }\n     }\n@@ -304,13 +336,13 @@ impl Ord for RcStr {\n \n impl Hash for RcStr {\n     fn hash<H: Hasher>(&self, state: &mut H) {\n-        match self.tag() {\n-            DYNAMIC_TAG => {\n+        match self.location() {\n+            PREHASHED_STRING_LOCATION => {\n                 let l = unsafe { deref_from(self.unsafe_data) };\n                 state.write_u64(l.hash);\n                 state.write_u8(0xff);\n             }\n-            INLINE_TAG => {\n+            INLINE_LOCATION => {\n                 self.as_str().hash(state);\n             }\n             _ => unsafe { debug_unreachable!() },\n@@ -333,33 +365,58 @@ impl<'de> Deserialize<'de> for RcStr {\n \n impl Drop for RcStr {\n     fn drop(&mut self) {\n-        if self.tag() == DYNAMIC_TAG {\n-            unsafe { drop(dynamic::restore_arc(self.unsafe_data)) }\n+        match self.tag() {\n+            DYNAMIC_TAG => unsafe { drop(dynamic::restore_arc(self.unsafe_data)) },\n+            STATIC_TAG => {\n+                // do nothing, these are never deallocated\n+            }\n+            INLINE_TAG => {\n+                // do nothing, these payloads need no drop logic\n+            }\n+            _ => unsafe { debug_unreachable!() },\n         }\n     }\n }\n \n+// Exports for our macro\n #[doc(hidden)]\n pub const fn inline_atom(s: &str) -> Option<RcStr> {\n     dynamic::inline_atom(s)\n }\n \n+#[doc(hidden)]\n+#[inline(always)]\n+pub fn from_static(s: &'static PrehashedString) -> RcStr {\n+    dynamic::new_static_atom(s)\n+}\n+#[doc(hidden)]\n+pub use dynamic::PrehashedString;\n+\n+#[doc(hidden)]\n+pub const fn make_const_prehashed_string(text: &'static str) -> PrehashedString {\n+    PrehashedString {\n+        value: dynamic::Payload::Ref(text),\n+        hash: hash_bytes(text.as_bytes()),\n+    }\n+}\n+\n /// Create an rcstr from a string literal.\n /// allocates the RcStr inline when possible otherwise uses a `LazyLock` to manage the allocation.\n #[macro_export]\n macro_rules! rcstr {\n     ($s:expr) => {{\n         const INLINE: core::option::Option<$crate::RcStr> = $crate::inline_atom($s);\n-        // this condition should be able to be compile time evaluated and inlined.\n+        // This condition can be compile time evaluated and inlined.\n         if INLINE.is_some() {\n             INLINE.unwrap()\n         } else {\n-            #[inline(never)]\n             fn get_rcstr() -> $crate::RcStr {\n-                static CACHE: std::sync::LazyLock<$crate::RcStr> =\n-                    std::sync::LazyLock::new(|| $crate::RcStr::from($s));\n-\n-                (*CACHE).clone()\n+                // Allocate static storage for the PrehashedString\n+                static RCSTR_STORAGE: $crate::PrehashedString =\n+                    $crate::make_const_prehashed_string($s);\n+                // This basically just tags a bit onto the raw pointer and wraps it in an RcStr\n+                // should be fast enough to do every time.\n+                $crate::from_static(&RCSTR_STORAGE)\n             }\n             get_rcstr()\n         }\n@@ -460,6 +517,15 @@ mod tests {\n         assert_eq!(rcstr!(\"abcdefghi\"), RcStr::from(\"abcdefghi\"));\n     }\n \n+    #[test]\n+    fn test_static_atom() {\n+        const LONG: &str = \"a very long string that lives forever\";\n+        let leaked = rcstr!(LONG);\n+        let not_leaked = RcStr::from(LONG);\n+        assert_ne!(leaked.tag(), not_leaked.tag());\n+        assert_eq!(leaked, not_leaked);\n+    }\n+\n     #[test]\n     fn test_inline_atom() {\n         // This is a silly test, just asserts that we can evaluate this in a constant context."
        },
        {
            "sha": "d1329535aea69fde09f711a5af003a951c2490ee",
            "filename": "turbopack/crates/turbo-rcstr/src/tagged_value.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 4,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/261a5c3e1d41347e43973065cf3d072223e20e1c/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Ftagged_value.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/261a5c3e1d41347e43973065cf3d072223e20e1c/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Ftagged_value.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Ftagged_value.rs?ref=261a5c3e1d41347e43973065cf3d072223e20e1c",
            "patch": "@@ -3,6 +3,13 @@\n use std::{num::NonZeroU8, os::raw::c_void, ptr::NonNull, slice};\n \n use self::raw_types::*;\n+#[cfg(not(any(\n+    target_pointer_width = \"32\",\n+    target_pointer_width = \"16\",\n+    feature = \"atom_size_64\",\n+    feature = \"atom_size_128\"\n+)))]\n+use crate::TAG_MASK;\n \n #[cfg(feature = \"atom_size_128\")]\n mod raw_types {\n@@ -89,16 +96,18 @@ impl TaggedValue {\n             feature = \"atom_size_128\"\n         ))]\n         {\n-            self.value.get() as usize as _\n+            use crate::TAG_MASK;\n+\n+            (self.value.get() as usize & !(TAG_MASK as usize)) as _\n         }\n         #[cfg(not(any(\n             target_pointer_width = \"32\",\n             target_pointer_width = \"16\",\n             feature = \"atom_size_64\",\n             feature = \"atom_size_128\"\n         )))]\n-        unsafe {\n-            std::mem::transmute(Some(self.value))\n+        {\n+            (self.value.as_ptr() as usize & !(TAG_MASK as usize)) as _\n         }\n     }\n \n@@ -108,7 +117,7 @@ impl TaggedValue {\n     }\n \n     #[inline(always)]\n-    pub fn tag(&self) -> u8 {\n+    pub fn tag_byte(&self) -> u8 {\n         (self.get_value() & 0xff) as u8\n     }\n "
        }
    ],
    "stats": {
        "total": 254,
        "additions": 195,
        "deletions": 59
    }
}