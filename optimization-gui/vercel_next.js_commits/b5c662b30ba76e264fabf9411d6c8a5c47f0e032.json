{
    "author": "sokra",
    "message": "Turbopack: flatten trace when it reaches cut off depth (#88118)\n\n### What?\n\nPreviously when the trace depth reaches 150 it ignored the spans and therefore lost time.\n\nThis fixes it by flattening spans instead of dropping them. This keeps the time, but still restricts the depth.\n\nAlso limits depth to 80 instead of 150 which is more reasonable.",
    "sha": "b5c662b30ba76e264fabf9411d6c8a5c47f0e032",
    "files": [
        {
            "sha": "9397524dde8fe809c9cbd245264c5d2b5ad72333",
            "filename": "turbopack/crates/turbopack-trace-server/src/store.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 4,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/b5c662b30ba76e264fabf9411d6c8a5c47f0e032/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fstore.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b5c662b30ba76e264fabf9411d6c8a5c47f0e032/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fstore.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fstore.rs?ref=b5c662b30ba76e264fabf9411d6c8a5c47f0e032",
            "patch": "@@ -16,7 +16,11 @@ use crate::{\n \n pub type SpanId = NonZeroUsize;\n \n-const CUT_OFF_DEPTH: u32 = 150;\n+/// This max depth is used to avoid deep recursion in the span tree,\n+/// which can lead to stack overflows and performance issues.\n+/// Spans deeper than this depth will be re-parented to an ancestor\n+/// at the cut-off depth (Flattening).\n+const CUT_OFF_DEPTH: u32 = 80;\n \n pub struct Store {\n     pub(crate) spans: Vec<Span>,\n@@ -110,17 +114,25 @@ impl Store {\n             extra: OnceLock::new(),\n             names: OnceLock::new(),\n         });\n-        let parent = if let Some(parent) = parent {\n+        let mut parent = if let Some(parent) = parent {\n             outdated_spans.insert(parent);\n             &mut self.spans[parent.get()]\n         } else {\n             &mut self.spans[0]\n         };\n-        parent.start = min(parent.start, start);\n-        let depth = parent.depth + 1;\n+        let mut depth = parent.depth + 1;\n+        if depth >= CUT_OFF_DEPTH\n+            && let Some(parent_of_parent) = parent.parent\n+        {\n+            outdated_spans.insert(parent_of_parent);\n+            self.spans[id.get()].parent = Some(parent_of_parent);\n+            parent = &mut self.spans[parent_of_parent.get()];\n+            depth = CUT_OFF_DEPTH - 1;\n+        }\n         if depth < CUT_OFF_DEPTH {\n             parent.events.push(SpanEvent::Child { index: id });\n         }\n+        parent.start = min(parent.start, start);\n         let span = &mut self.spans[id.get()];\n         span.depth = depth;\n         id"
        }
    ],
    "stats": {
        "total": 20,
        "additions": 16,
        "deletions": 4
    }
}