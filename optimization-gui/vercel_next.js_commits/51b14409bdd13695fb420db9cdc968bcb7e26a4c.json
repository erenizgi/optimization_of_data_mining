{
    "author": "gnoff",
    "message": "Fix reentrancy of unhandledRejection filtering (#83741)\n\nNode's internal implementation of process.removeAllListeners calls\nprocess.removeListener internally. The simple patching method originally\ntried does not account for this which can lead to listeners not being\nremoved from the actual process event emitter.\n\nTo fix this I modeled the patch as explicitly not allowing sync\nreentrancy. You can never call a patched function from inside the\nexecution of another because we bypass it by setting a flag during patch\nexecution.\n\nBecause of this I also removed the calls to original*() methods while\ninstalling and uninstalling the patch. These can be done using the\nregular process methods before and after installation/uninstallation\nrespectively. This was done to avoid needing to manually scope the\nbypass which would have been fine but is a bit more convoluted and its\neasier to just use the true underlying methods in the right temporal\nscope\n\nI also removed an unecessary rejectionHandled handler because we not\nlonger use catch on the underlying promise and thus do not create any\nnew handled rejections.\n\nI also added unit tests",
    "sha": "51b14409bdd13695fb420db9cdc968bcb7e26a4c",
    "files": [
        {
            "sha": "e27652ee3ac67c3115ad878d8580d7ae2db1fe3b",
            "filename": "packages/next/src/server/node-environment-extensions/unhandled-rejection.test.ts",
            "status": "added",
            "additions": 1015,
            "deletions": 0,
            "changes": 1015,
            "blob_url": "https://github.com/vercel/next.js/blob/51b14409bdd13695fb420db9cdc968bcb7e26a4c/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Funhandled-rejection.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/51b14409bdd13695fb420db9cdc968bcb7e26a4c/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Funhandled-rejection.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Funhandled-rejection.test.ts?ref=51b14409bdd13695fb420db9cdc968bcb7e26a4c",
            "patch": "@@ -0,0 +1,1015 @@\n+/**\n+ * Testing unhandled rejections in Jest is quite tricky because by default Jest will fail the test\n+ * if there are any unhandled rejections. This is a unit test and we want to test the node patch\n+ * with as little manipulation of the runtime as possible. The strategy we take is to run a special\n+ * function in each test inside a Worker thread. This allows us to have an isolated node environment\n+ * that won't interfere with anything going on inside the process running Jest. We support a native TS authoring\n+ * experience by passing the code for the Worker as a string gathered from toString-ing the worker test function.\n+ *\n+ * This is convenient for typescript and linting but it isn't perfect because it might trick you into thinking\n+ * you can share state from inside and outside the work function which you cannot. Instead you must report serializable\n+ * values back to the main thread using `reportResult`. Another place to watch out for is that requiring code in the\n+ * worker requires targeting next/dist files (javascript only) and you must target from the package root down.\n+ * Environment variables are not carried over to the worker thread so if you you want to configure them it\n+ * must be done inside the worker function implementation.\n+ *\n+ * I'm largely happy with this setup because you can mostly ignore the fact that there are two worlds\n+ * but if you make changes consider the context these tests are running in otherwise you might get unexpected results.\n+ *\n+ * @jest-environment node\n+ */\n+\n+/* eslint-disable @next/internal/typechecked-require */\n+\n+type ReportableResult =\n+  | CountReport\n+  | UHRReport\n+  | ErrorReport\n+  | OutputReport\n+  | ErrorLogReport\n+  | SerializableDataReport\n+type ErrorReport = { type: 'error'; message: string }\n+type OutputReport = { type: 'output'; message: string }\n+type CountReport = {\n+  type: 'count'\n+  count: number\n+}\n+type UHRReport = {\n+  type: 'uhr'\n+  reason: string\n+}\n+type ErrorLogReport = {\n+  type: 'error-log'\n+  message: string\n+}\n+type SerializableDataReport = {\n+  type: 'serialized'\n+  key: string\n+  data: string\n+}\n+\n+declare global {\n+  function reportResult(result: ReportableResult): void\n+}\n+\n+import type { WorkUnitStore } from '../app-render/work-unit-async-storage.external'\n+\n+import { Worker } from 'node:worker_threads'\n+\n+type WorkerResult = {\n+  exitCode: number\n+  stderr: string\n+  uhr: Array<UHRReport>\n+  count: Array<CountReport>\n+  errorLog: Array<ErrorLogReport>\n+  data: Record<string, unknown>\n+  messages: Array<ReportableResult>\n+}\n+\n+export function runWorkerCode(fn: Function): Promise<WorkerResult> {\n+  return new Promise((resolve, reject) => {\n+    const script = `\n+      const { parentPort } = require('node:worker_threads');\n+      (async () => {\n+        const { AsyncLocalStorage } = require('node:async_hooks');\n+        // We need to put this on the global because Next.js does not import it\n+        // from node directly to be compatible with edge runtimes.\n+        globalThis.AsyncLocalStorage = AsyncLocalStorage;\n+\n+        const { parentPort } = require('node:worker_threads');\n+        global.reportResult = (value) => {\n+          parentPort?.postMessage(value);\n+        };\n+\n+        const fn = (${fn.toString()});\n+        try {\n+          const out = await fn();\n+          await new Promise(r => setImmediate(r));\n+          reportResult({ type: 'result', out });\n+        } catch (e) {\n+          reportResult({ type: 'error', message: String(e && e.message || e) });\n+        }\n+      })();\n+    `\n+\n+    const w = new Worker(script, {\n+      eval: true,\n+      workerData: null,\n+      argv: [],\n+      execArgv: [],\n+      stderr: true,\n+      stdout: false,\n+    })\n+\n+    const messages: Array<ReportableResult> = []\n+    const uhr: Array<UHRReport> = []\n+    const count: Array<CountReport> = []\n+    const errorLog: Array<ErrorLogReport> = []\n+    const data = {} as Record<string, unknown>\n+    let stderr = ''\n+\n+    w.on('message', (m) => {\n+      messages.push(m)\n+      switch (m.type) {\n+        case 'uhr':\n+          uhr.push(m.reason)\n+          break\n+        case 'count':\n+          count.push(m.count)\n+          break\n+        case 'error-log':\n+          errorLog.push(m.message)\n+          break\n+        case 'serialized':\n+          data[m.key] = JSON.parse(m.data)\n+          break\n+        default:\n+          break\n+      }\n+    })\n+    w.on('error', (err) => console.error('Worker error', err))\n+    w.on('error', reject)\n+    w.stderr?.on('data', (b) => (stderr += String(b)))\n+    w.on('exit', (code) =>\n+      resolve({\n+        exitCode: code ?? -1,\n+        uhr,\n+        count,\n+        errorLog,\n+        data,\n+        messages,\n+        stderr,\n+      })\n+    )\n+  })\n+}\n+\n+describe('unhandled-rejection filter', () => {\n+  describe('environment variable configuration', () => {\n+    it('should not install filter by default', async () => {\n+      async function testForWorker() {\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        reportResult({\n+          type: 'count',\n+          count: process.listeners('unhandledRejection').length,\n+        })\n+      }\n+\n+      const { messages, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(messages).toEqual(\n+        expect.arrayContaining([expect.objectContaining({ count: 0 })])\n+      )\n+    })\n+\n+    it('should not install filter when disabled', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = 'disabled'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        reportResult({\n+          type: 'count',\n+          count: process.listeners('unhandledRejection').length,\n+        })\n+      }\n+\n+      const { messages, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(messages).toEqual(\n+        expect.arrayContaining([expect.objectContaining({ count: 0 })])\n+      )\n+    })\n+\n+    it('should install filter rejections when environment variable is enabled', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = 'enabled'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        reportResult({\n+          type: 'count',\n+          count: process.listeners('unhandledRejection').length,\n+        })\n+      }\n+\n+      const { messages, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(messages).toEqual(\n+        expect.arrayContaining([expect.objectContaining({ count: 1 })])\n+      )\n+    })\n+\n+    it('should install filter rejections when environment variable is enabled in debug mode', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = 'debug'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        reportResult({\n+          type: 'count',\n+          count: process.listeners('unhandledRejection').length,\n+        })\n+      }\n+\n+      const { messages, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(messages).toEqual(\n+        expect.arrayContaining([expect.objectContaining({ count: 1 })])\n+      )\n+    })\n+  })\n+\n+  describe('filtering functionality', () => {\n+    it('should suppress rejections from aborted prerender contexts', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = '1'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        process.on('unhandledRejection', (reason) => {\n+          reportResult({ type: 'uhr', reason: String(reason) })\n+        })\n+\n+        Promise.reject('outside store + before')\n+        workUnitAsyncStorage.run(\n+          {\n+            type: 'prerender',\n+            renderSignal: { aborted: true },\n+          } as WorkUnitStore,\n+          async () => {\n+            Promise.reject('immediate abort + sync')\n+            await 1\n+            Promise.reject('immediate abort + micro')\n+            await new Promise((r) => setTimeout(r, 10))\n+            Promise.reject('immediate abort + task')\n+          }\n+        )\n+        const delayedAbortStore = {\n+          type: 'prerender',\n+          renderSignal: { aborted: false },\n+        }\n+        workUnitAsyncStorage.run(\n+          delayedAbortStore as WorkUnitStore,\n+          async () => {\n+            Promise.reject('before abort + sync')\n+            await 1\n+            Promise.reject('before abort + micro')\n+            await new Promise((r) => setTimeout(r, 10))\n+            Promise.reject('before abort + task')\n+            await new Promise((r) => setImmediate(r))\n+            // We mutate this after a task b/c in Next.js this is always done right at the beginning\n+            // of a task and any promises rejecting in prior tasks would have already observed their\n+            // rejections as unhandled without the aborted signal\n+            delayedAbortStore.renderSignal.aborted = true\n+            Promise.reject('after abort + sync')\n+            await 1\n+            Promise.reject('after abort + micro')\n+            await new Promise((r) => setTimeout(r, 10))\n+            Promise.reject('delayed abort + task')\n+          }\n+        )\n+        Promise.reject('outside store + after')\n+      }\n+\n+      const { uhr, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(uhr).toEqual(\n+        expect.arrayContaining([\n+          'outside store + before',\n+          'outside store + after',\n+          'before abort + sync',\n+          'before abort + micro',\n+          'before abort + task',\n+        ])\n+      )\n+    })\n+\n+    it('should suppress rejections from aborted prerender-client contexts', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = '1'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        process.on('unhandledRejection', (reason) => {\n+          reportResult({ type: 'uhr', reason: String(reason) })\n+        })\n+\n+        Promise.reject('outside store + before')\n+        workUnitAsyncStorage.run(\n+          {\n+            type: 'prerender-client',\n+            renderSignal: { aborted: true },\n+          } as WorkUnitStore,\n+          async () => {\n+            Promise.reject('immediate abort + sync')\n+            await 1\n+            Promise.reject('immediate abort + micro')\n+            await new Promise((r) => setTimeout(r, 10))\n+            Promise.reject('immediate abort + task')\n+          }\n+        )\n+        const delayedAbortStore = {\n+          type: 'prerender-client',\n+          renderSignal: { aborted: false },\n+        }\n+        workUnitAsyncStorage.run(\n+          delayedAbortStore as WorkUnitStore,\n+          async () => {\n+            Promise.reject('before abort + sync')\n+            await 1\n+            Promise.reject('before abort + micro')\n+            await new Promise((r) => setTimeout(r, 10))\n+            Promise.reject('before abort + task')\n+            await new Promise((r) => setImmediate(r))\n+            // We mutate this after a task b/c in Next.js this is always done right at the beginning\n+            // of a task and any promises rejecting in prior tasks would have already observed their\n+            // rejections as unhandled without the aborted signal\n+            delayedAbortStore.renderSignal.aborted = true\n+            Promise.reject('after abort + sync')\n+            await 1\n+            Promise.reject('after abort + micro')\n+            await new Promise((r) => setTimeout(r, 10))\n+            Promise.reject('delayed abort + task')\n+          }\n+        )\n+        Promise.reject('outside store + after')\n+      }\n+\n+      const { uhr, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(uhr).toEqual(\n+        expect.arrayContaining([\n+          'outside store + before',\n+          'outside store + after',\n+          'before abort + sync',\n+          'before abort + micro',\n+          'before abort + task',\n+        ])\n+      )\n+    })\n+\n+    it('should suppress rejections from aborted prerender-runtime contexts', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = '1'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        process.on('unhandledRejection', (reason) => {\n+          reportResult({ type: 'uhr', reason: String(reason) })\n+        })\n+\n+        Promise.reject('outside store + before')\n+        workUnitAsyncStorage.run(\n+          {\n+            type: 'prerender-runtime',\n+            renderSignal: { aborted: true },\n+          } as WorkUnitStore,\n+          async () => {\n+            Promise.reject('immediate abort + sync')\n+            await 1\n+            Promise.reject('immediate abort + micro')\n+            await new Promise((r) => setTimeout(r, 10))\n+            Promise.reject('immediate abort + task')\n+          }\n+        )\n+        const delayedAbortStore = {\n+          type: 'prerender-runtime',\n+          renderSignal: { aborted: false },\n+        }\n+        workUnitAsyncStorage.run(\n+          delayedAbortStore as WorkUnitStore,\n+          async () => {\n+            Promise.reject('before abort + sync')\n+            await 1\n+            Promise.reject('before abort + micro')\n+            await new Promise((r) => setTimeout(r, 10))\n+            Promise.reject('before abort + task')\n+            await new Promise((r) => setImmediate(r))\n+            // We mutate this after a task b/c in Next.js this is always done right at the beginning\n+            // of a task and any promises rejecting in prior tasks would have already observed their\n+            // rejections as unhandled without the aborted signal\n+            delayedAbortStore.renderSignal.aborted = true\n+            Promise.reject('after abort + sync')\n+            await 1\n+            Promise.reject('after abort + micro')\n+            await new Promise((r) => setTimeout(r, 10))\n+            Promise.reject('delayed abort + task')\n+          }\n+        )\n+        Promise.reject('outside store + after')\n+      }\n+\n+      const { uhr, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(uhr).toEqual(\n+        expect.arrayContaining([\n+          'outside store + before',\n+          'outside store + after',\n+          'before abort + sync',\n+          'before abort + micro',\n+          'before abort + task',\n+        ])\n+      )\n+    })\n+\n+    it('should pass through rejections from non-aborted prerender contexts', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = '1'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        process.on('unhandledRejection', (reason) => {\n+          reportResult({ type: 'uhr', reason: String(reason) })\n+        })\n+\n+        Promise.reject('outside store + before')\n+        workUnitAsyncStorage.run(\n+          {\n+            type: 'request',\n+          } as WorkUnitStore,\n+          async () => {\n+            Promise.reject('in store + sync')\n+            await 1\n+            Promise.reject('in store + micro')\n+            await new Promise((r) => setTimeout(r, 10))\n+            Promise.reject('in store + task')\n+          }\n+        )\n+        Promise.reject('outside store + after')\n+      }\n+\n+      const { uhr, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(uhr).toEqual(\n+        expect.arrayContaining([\n+          'outside store + before',\n+          'outside store + after',\n+          'in store + sync',\n+          'in store + micro',\n+          'in store + task',\n+        ])\n+      )\n+    })\n+\n+    it('should call console.error when no handlers are present', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = '1'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        console.error = (...args: Array<any>) => {\n+          reportResult({ type: 'error-log', message: args.join(' ') })\n+        }\n+\n+        Promise.reject('BOOM')\n+      }\n+\n+      const { uhr, errorLog, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(uhr).toEqual([])\n+      expect(errorLog).toEqual(['Unhandled Rejection: BOOM'])\n+    })\n+  })\n+\n+  describe('process method interception', () => {\n+    it('should handle process.once listeners correctly', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = 'enabled'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        let callCount = 0\n+\n+        process.on('unhandledRejection', () => {\n+          // this is a noop handler so that we don't trigger the default\n+          // process killing behavior after the once handler is called\n+        })\n+\n+        process.once('unhandledRejection', (reason) => {\n+          callCount++\n+          reportResult({ type: 'uhr', reason: String(reason) })\n+        })\n+\n+        Promise.reject('FIRST')\n+        Promise.reject('SECOND')\n+        Promise.reject('THIRD')\n+        Promise.reject('FOURTH')\n+        Promise.reject('FIFTH')\n+\n+        await new Promise((r) => setTimeout(r, 10))\n+\n+        reportResult({ type: 'count', count: callCount })\n+      }\n+\n+      const { uhr, count, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(uhr).toEqual(['FIRST'])\n+      expect(count).toEqual([1])\n+    })\n+\n+    it('should handle process.removeListener correctly', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = 'enabled'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        const handler1 = (reason: unknown) => {\n+          reportResult({ type: 'uhr', reason: `[1]: ${String(reason)}` })\n+        }\n+        const handler2 = (reason: unknown) => {\n+          reportResult({ type: 'uhr', reason: `[2]: ${String(reason)}` })\n+        }\n+\n+        process.on('unhandledRejection', handler1)\n+        process.on('unhandledRejection', handler2)\n+        process.once('unhandledRejection', handler1)\n+        process.once('unhandledRejection', handler2)\n+        process.addListener('unhandledRejection', handler1)\n+        process.addListener('unhandledRejection', handler2)\n+        process.prependListener('unhandledRejection', handler1)\n+        process.prependListener('unhandledRejection', handler2)\n+        process.prependOnceListener('unhandledRejection', handler1)\n+        process.prependOnceListener('unhandledRejection', handler2)\n+\n+        process.off('unhandledRejection', handler1)\n+        process.removeListener('unhandledRejection', handler1)\n+\n+        Promise.reject('BOOM1')\n+        Promise.reject('BOOM2')\n+        await new Promise((r) => setTimeout(r, 10))\n+\n+        process.off('unhandledRejection', handler1)\n+        process.removeListener('unhandledRejection', handler1)\n+        process.off('unhandledRejection', handler2)\n+        process.removeListener('unhandledRejection', handler2)\n+\n+        Promise.reject('BOOM3')\n+        await new Promise((r) => setTimeout(r, 10))\n+      }\n+\n+      const { uhr, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(uhr).toEqual([\n+        // ... BOOM1 time\n+        '[2]: BOOM1', // prependOnceListener(... handler2)\n+        '[1]: BOOM1', // prependOnceListener(... handler1)\n+        '[2]: BOOM1', // prependListener(... handler2)\n+        '[1]: BOOM1', // prependListener(... handler1)\n+        '[1]: BOOM1', // process.on(... handler1)\n+        '[2]: BOOM1', // process.on(... handler2)\n+        // we removed the process.once(..., handler1)\n+        '[2]: BOOM1', // process.once(... handler2)\n+        // we removed the process.addListener(..., handler1)\n+        '[2]: BOOM1', // process.addListener(... handler2)\n+        // ... BOOM2 time\n+        // once listeners are exhausted so they are skipped\n+        '[2]: BOOM2', // prependListener(... handler2)\n+        '[1]: BOOM2', // prependListener(... handler1)\n+        '[1]: BOOM2', // process.on(... handler1)\n+        '[2]: BOOM2', // process.on(... handler2)\n+        // once listeners are exhausted so they are skipped\n+        // we removed the process.addListener(..., handler1)\n+        '[2]: BOOM2', // process.addListener(... handler2)\n+        // ... BOOM3 time\n+        // all handler1 handlers have been removed\n+        '[2]: BOOM3', // prependListener(... handler2)\n+        // all remaining handler2 handlers have been removed\n+      ])\n+    })\n+\n+    it('should uninstall filter when removeAllListeners() is called without arguments', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = 'enabled'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        process.on('unhandledRejection', (reason) => {\n+          reportResult({ type: 'uhr', reason: String(reason) })\n+        })\n+\n+        Promise.reject('outside 1')\n+\n+        await workUnitAsyncStorage.run(\n+          {\n+            type: 'prerender',\n+            renderSignal: { aborted: true },\n+          } as WorkUnitStore,\n+          async () => {\n+            await new Promise((r) => setImmediate(r))\n+            Promise.reject('Should be filtered out')\n+            await new Promise((r) => setImmediate(r))\n+          }\n+        )\n+\n+        process.removeAllListeners()\n+\n+        process.on('unhandledRejection', (reason) => {\n+          reportResult({ type: 'uhr', reason: String(reason) })\n+        })\n+\n+        Promise.reject('outside 2')\n+\n+        // After uninstalling, rejections that would be filtered should now pass through\n+        await workUnitAsyncStorage.run(\n+          {\n+            type: 'prerender',\n+            renderSignal: { aborted: true },\n+          } as WorkUnitStore,\n+          async () => {\n+            await new Promise((r) => setImmediate(r))\n+            Promise.reject('should not be filtered after uninstall')\n+            await new Promise((r) => setImmediate(r))\n+          }\n+        )\n+\n+        Promise.reject('outside 3')\n+      }\n+\n+      const { uhr, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(uhr).toEqual([\n+        'outside 1',\n+        'outside 2',\n+        'should not be filtered after uninstall',\n+        'outside 3',\n+      ])\n+    })\n+\n+    it('should not uninstall filter when removeAllListeners(\"unhandledRejection\") is called', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = 'enabled'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        process.on('unhandledRejection', (reason) => {\n+          reportResult({ type: 'uhr', reason: String(reason) })\n+        })\n+\n+        Promise.reject('outside 1')\n+\n+        await workUnitAsyncStorage.run(\n+          {\n+            type: 'prerender',\n+            renderSignal: { aborted: true },\n+          } as WorkUnitStore,\n+          async () => {\n+            await new Promise((r) => setImmediate(r))\n+            Promise.reject('Should be filtered out')\n+            await new Promise((r) => setImmediate(r))\n+          }\n+        )\n+\n+        process.removeAllListeners('unhandledRejection')\n+\n+        process.on('unhandledRejection', (reason) => {\n+          reportResult({ type: 'uhr', reason: String(reason) })\n+        })\n+\n+        Promise.reject('outside 2')\n+\n+        // After uninstalling, rejections that would be filtered should now pass through\n+        await workUnitAsyncStorage.run(\n+          {\n+            type: 'prerender',\n+            renderSignal: { aborted: true },\n+          } as WorkUnitStore,\n+          async () => {\n+            await new Promise((r) => setImmediate(r))\n+            Promise.reject('Should be filtered out')\n+            await new Promise((r) => setImmediate(r))\n+          }\n+        )\n+        Promise.reject('outside 3')\n+      }\n+\n+      const { uhr, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(uhr).toEqual(['outside 1', 'outside 2', 'outside 3'])\n+    })\n+\n+    it('should not affect other listeners when adding/removing listeners from within a handler', async () => {\n+      // This test asserts that our patch preserves node's semantics that all listeners registered when\n+      // an event is emitted will be invoked regardless of whether there are mutations to the listeners\n+      // during event handling.\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = 'enabled'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        const onceHandler = (reason: unknown) => {\n+          reportResult({ type: 'uhr', reason: `once: ${String(reason)}` })\n+        }\n+\n+        const handler1 = (reason: unknown) => {\n+          reportResult({\n+            type: 'count',\n+            count: process.listeners('unhandledRejection').length,\n+          })\n+          reportResult({ type: 'uhr', reason: `handler1: ${String(reason)}` })\n+\n+          // Try to add a new handler from within this handler\n+          const appendHandler = (innerReason: unknown) => {\n+            reportResult({\n+              type: 'uhr',\n+              reason: `append: ${String(innerReason)}`,\n+            })\n+          }\n+          process.on('unhandledRejection', appendHandler)\n+\n+          const prependHandler = (innerReason: unknown) => {\n+            reportResult({\n+              type: 'uhr',\n+              reason: `prepend: ${String(innerReason)}`,\n+            })\n+          }\n+          process.prependListener('unhandledRejection', prependHandler)\n+\n+          // Try to remove handler3 from within this handler\n+          process.removeListener('unhandledRejection', handler3)\n+        }\n+\n+        const handler2 = (reason: unknown) => {\n+          reportResult({ type: 'uhr', reason: `handler2: ${String(reason)}` })\n+        }\n+\n+        const handler3 = (reason: unknown) => {\n+          reportResult({ type: 'uhr', reason: `handler3: ${String(reason)}` })\n+        }\n+\n+        const handler4 = (reason: unknown) => {\n+          reportResult({ type: 'uhr', reason: `handler4: ${String(reason)}` })\n+        }\n+\n+        // Add handlers in a specific order\n+        process.once('unhandledRejection', onceHandler)\n+        process.on('unhandledRejection', handler1) // This will modify listeners during execution\n+        process.on('unhandledRejection', handler2) // Should always run\n+        process.on('unhandledRejection', handler3) // Will be removed by handler1, but should still run for first event\n+        process.on('unhandledRejection', handler4) // Should always run\n+\n+        // First rejection - all original handlers should run despite handler1 modifying the list\n+        Promise.reject('first')\n+        // Second rejection - handler3 should be gone, dynamic handler should be present\n+        Promise.reject('second')\n+        await new Promise((r) => setTimeout(r, 10))\n+      }\n+\n+      const { uhr, count, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(count).toEqual([\n+        // First event, the once handler is removed before execution so it no longer counts\n+        // But we also have our filter handler\n+        5,\n+        // Then when the second event happens we have added 2 additional handlers and removed 1\n+        // So the count increase by 1\n+        6,\n+      ])\n+      expect(uhr).toEqual([\n+        // First event - all original handlers should run\n+        'once: first',\n+        'handler1: first',\n+        'handler2: first',\n+        'handler3: first', // Still runs even though handler1 removed it\n+        'handler4: first',\n+\n+        // Second event - handler3 is gone, dynamic handler is present\n+        'prepend: second',\n+        'handler1: second',\n+        'handler2: second',\n+        'handler4: second',\n+        'append: second', // The dynamically added handler now runs\n+      ])\n+    })\n+\n+    it('should preserve native function toString behavior for patched process methods', async () => {\n+      async function testForWorker() {\n+        const originalMethods = [\n+          process.on,\n+          process.addListener,\n+          process.off,\n+          process.removeListener,\n+          process.prependListener,\n+          process.once,\n+          process.prependOnceListener,\n+          process.removeAllListeners,\n+          process.listeners,\n+        ]\n+\n+        const originalToStrings = originalMethods.map((m) => m.toString())\n+        const originalNames = originalMethods.map((m) => m.name)\n+\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = 'enabled'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        const patchedMethods = [\n+          process.on,\n+          process.addListener,\n+          process.off,\n+          process.removeListener,\n+          process.prependListener,\n+          process.once,\n+          process.prependOnceListener,\n+          process.removeAllListeners,\n+          process.listeners,\n+        ]\n+\n+        const patchedToStrings = patchedMethods.map((m) => m.toString())\n+        const patchedNames = patchedMethods.map((m) => m.name)\n+\n+        reportResult({\n+          type: 'serialized',\n+          key: 'originalToStrings',\n+          data: JSON.stringify(originalToStrings),\n+        })\n+        reportResult({\n+          type: 'serialized',\n+          key: 'patchedToStrings',\n+          data: JSON.stringify(patchedToStrings),\n+        })\n+        reportResult({\n+          type: 'serialized',\n+          key: 'originalNames',\n+          data: JSON.stringify(originalNames),\n+        })\n+        reportResult({\n+          type: 'serialized',\n+          key: 'patchedNames',\n+          data: JSON.stringify(patchedNames),\n+        })\n+      }\n+\n+      const { data, exitCode } = await runWorkerCode(testForWorker)\n+\n+      type ReportedData = {\n+        originalToStrings: string[]\n+        patchedToStrings: string[]\n+        originalNames: string[]\n+        patchedNames: string[]\n+      }\n+\n+      const results = data as unknown as ReportedData\n+\n+      expect(results.originalNames).toEqual(results.patchedNames)\n+      expect(results.originalToStrings).toEqual(results.patchedToStrings)\n+      expect(exitCode).toBe(0)\n+    })\n+  })\n+\n+  describe('error handling in handlers', () => {\n+    it('should handle errors thrown by user handlers gracefully', async () => {\n+      async function testForWorker() {\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = 'enabled'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        process.on('unhandledRejection', () => {\n+          throw new Error('Handler error')\n+        })\n+\n+        process.once('uncaughtException', (error) => {\n+          reportResult({ type: 'error', message: error.message })\n+        })\n+\n+        workUnitAsyncStorage.run(\n+          { type: 'request' } as WorkUnitStore,\n+          async () => {\n+            Promise.reject(new Error('Original error'))\n+            await new Promise((r) => setImmediate(r))\n+            await new Promise((r) => setTimeout(r, 10))\n+          }\n+        )\n+      }\n+\n+      const { messages, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(messages).toEqual(\n+        expect.arrayContaining([\n+          expect.objectContaining({ type: 'error', message: 'Handler error' }),\n+        ])\n+      )\n+    })\n+  })\n+\n+  describe('integration with existing listeners', () => {\n+    it('should capture and preserve existing listeners during installation', async () => {\n+      async function testForWorker() {\n+        // Add listener before installing filter\n+        process.on('unhandledRejection', (reason) => {\n+          reportResult({ type: 'uhr', reason: `existing: ${String(reason)}` })\n+        })\n+\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = 'enabled'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        // Test non-filtered rejection\n+        workUnitAsyncStorage.run(\n+          { type: 'request' } as WorkUnitStore,\n+          async () => {\n+            Promise.reject('passes through')\n+            await new Promise((r) => setTimeout(r, 10))\n+          }\n+        )\n+\n+        // Test filtered rejection\n+        workUnitAsyncStorage.run(\n+          {\n+            type: 'prerender',\n+            renderSignal: { aborted: true },\n+          } as WorkUnitStore,\n+          async () => {\n+            Promise.reject('should be filtered')\n+            await new Promise((r) => setTimeout(r, 10))\n+          }\n+        )\n+      }\n+\n+      const { uhr, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(uhr).toEqual(['existing: passes through'])\n+    })\n+\n+    it('should be able to clear listeners that existed prior to installation', async () => {\n+      async function testForWorker() {\n+        // Add listener before installing filter\n+        process.on('unhandledRejection', (reason) => {\n+          reportResult({ type: 'uhr', reason: `existing: ${String(reason)}` })\n+        })\n+\n+        process.env.NEXT_USE_UNHANDLED_REJECTION_FILTER = 'enabled'\n+        require('next/dist/server/node-environment-extensions/unhandled-rejection')\n+\n+        process.removeAllListeners('unhandledRejection')\n+\n+        process.on('unhandledRejection', (reason) => {\n+          reportResult({ type: 'uhr', reason: `after: ${String(reason)}` })\n+        })\n+\n+        const {\n+          workUnitAsyncStorage,\n+        } = require('next/dist/server/app-render/work-unit-async-storage.external')\n+\n+        // Test non-filtered rejection\n+        workUnitAsyncStorage.run(\n+          { type: 'request' } as WorkUnitStore,\n+          async () => {\n+            Promise.reject('passes through')\n+            await new Promise((r) => setTimeout(r, 10))\n+          }\n+        )\n+\n+        // Test filtered rejection\n+        workUnitAsyncStorage.run(\n+          {\n+            type: 'prerender',\n+            renderSignal: { aborted: true },\n+          } as WorkUnitStore,\n+          async () => {\n+            Promise.reject('should be filtered')\n+            await new Promise((r) => setTimeout(r, 10))\n+          }\n+        )\n+      }\n+\n+      const { uhr, exitCode } = await runWorkerCode(testForWorker)\n+\n+      expect(exitCode).toBe(0)\n+      expect(uhr).toEqual(['after: passes through'])\n+    })\n+  })\n+})"
        },
        {
            "sha": "95f954ed58f912a9c94bbf6d54d02d2ce5aad43d",
            "filename": "packages/next/src/server/node-environment-extensions/unhandled-rejection.tsx",
            "status": "modified",
            "additions": 199,
            "deletions": 127,
            "changes": 326,
            "blob_url": "https://github.com/vercel/next.js/blob/51b14409bdd13695fb420db9cdc968bcb7e26a4c/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Funhandled-rejection.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/51b14409bdd13695fb420db9cdc968bcb7e26a4c/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Funhandled-rejection.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fnode-environment-extensions%2Funhandled-rejection.tsx?ref=51b14409bdd13695fb420db9cdc968bcb7e26a4c",
            "patch": "@@ -76,19 +76,70 @@ let underlyingListeners: Array<NodeJS.UnhandledRejectionListener> = []\n // details like whether the listener is a once listener.\n let listenerMetadata: Array<ListenerMetadata> = []\n \n-let originalProcessOn: typeof process.on\n+// These methods are used to restore the original implementations when uninstalling the patch\n let originalProcessAddListener: typeof process.addListener\n-let originalProcessOnce: typeof process.once\n let originalProcessRemoveListener: typeof process.removeListener\n-let originalProcessRemoveAllListeners: typeof process.removeAllListeners\n-let originalProcessListeners: typeof process.listeners\n+let originalProcessOn: typeof process.on\n+let originalProcessOff: typeof process.off\n let originalProcessPrependListener: typeof process.prependListener\n+let originalProcessOnce: typeof process.once\n let originalProcessPrependOnceListener: typeof process.prependOnceListener\n-let originalProcessOff: typeof process.off\n+let originalProcessRemoveAllListeners: typeof process.removeAllListeners\n+let originalProcessListeners: typeof process.listeners\n+\n+type UnderlyingMethod =\n+  | typeof originalProcessAddListener\n+  | typeof originalProcessRemoveListener\n+  | typeof originalProcessOn\n+  | typeof originalProcessOff\n+  | typeof originalProcessPrependListener\n+  | typeof originalProcessOnce\n+  | typeof originalProcessPrependOnceListener\n+  | typeof originalProcessRemoveAllListeners\n+  | typeof originalProcessListeners\n \n let didWarnPrepend = false\n let didWarnRemoveAll = false\n \n+// Some of these base methods call others and we don't want them to call the patched version so we\n+// need a way to synchronously disable the patch temporarily.\n+let bypassPatch = false\n+\n+// This patch ensures that if any patched methods end up calling other methods internally they will\n+// bypass the patch during their execution. This is important for removeAllListeners in particular\n+// because it calls removeListener internally and we want to ensure it actually clears the listeners\n+// from the process queue and not our private queue.\n+function patchWithoutReentrancy<T extends UnderlyingMethod>(\n+  original: T,\n+  patchedImpl: T\n+): T {\n+  // Produce a function which has the correct name\n+  const patched = {\n+    [original.name]: function (...args: Parameters<T>) {\n+      if (bypassPatch) {\n+        return Reflect.apply(original, process, args)\n+      }\n+\n+      const previousBypassPatch = bypassPatch\n+      bypassPatch = true\n+      try {\n+        return Reflect.apply(patchedImpl, process, args)\n+      } finally {\n+        bypassPatch = previousBypassPatch\n+      }\n+    } as any,\n+  }[original.name]\n+\n+  // Preserve the original toString behavior\n+  Object.defineProperty(patched, 'toString', {\n+    value: original.toString.bind(original),\n+    writable: true,\n+    configurable: true,\n+  })\n+\n+  return patched\n+}\n+\n /**\n  * Installs a filtering unhandled rejection handler that intelligently suppresses\n  * rejections from aborted prerender contexts.\n@@ -114,67 +165,118 @@ function installUnhandledRejectionFilter(): void {\n     once: false,\n   }))\n \n+  // Remove all existing handlers\n+  process.removeAllListeners('unhandledRejection')\n+\n+  // Install our filtering handler\n+  process.addListener('unhandledRejection', filteringUnhandledRejectionHandler)\n+\n   // Store the original process methods\n-  originalProcessOn = process.on\n   originalProcessAddListener = process.addListener\n-  originalProcessOnce = process.once\n-  originalProcessOff = process.off\n   originalProcessRemoveListener = process.removeListener\n-  originalProcessRemoveAllListeners = process.removeAllListeners\n-  originalProcessListeners = process.listeners\n+  originalProcessOn = process.on\n+  originalProcessOff = process.off\n   originalProcessPrependListener = process.prependListener\n+  originalProcessOnce = process.once\n   originalProcessPrependOnceListener = process.prependOnceListener\n+  originalProcessRemoveAllListeners = process.removeAllListeners\n+  originalProcessListeners = process.listeners\n \n-  // Helper function to create a patched method that preserves toString behavior\n-  function patchMethod<T extends Function>(original: T, patchedImpl: T): T {\n-    // Preserve the original toString behavior\n-    Object.defineProperty(patchedImpl, 'toString', {\n-      value: original.toString.bind(original),\n-      writable: true,\n-      configurable: true,\n-    })\n-    return patchedImpl\n-  }\n+  process.addListener = patchWithoutReentrancy(\n+    originalProcessAddListener,\n+    function (event: string | symbol, listener: (...args: any[]) => void) {\n+      if (event === 'unhandledRejection') {\n+        debug?.('process.addListener', listener.toString())\n+        // Add new handlers to our internal queue instead of the process\n+        underlyingListeners.push(listener as NodeJS.UnhandledRejectionListener)\n+        listenerMetadata.push({ listener, once: false })\n+        return process\n+      }\n+      // For other events, use the original method\n+      return originalProcessAddListener.call(process, event as any, listener)\n+    } as typeof process.addListener\n+  )\n \n-  // Intercept process.on to capture new unhandled rejection handlers\n-  process.on = patchMethod(originalProcessOn, function (\n-    event: string | symbol,\n-    listener: (...args: any[]) => void\n-  ) {\n-    if (event === 'unhandledRejection') {\n-      debug?.('process.on/addListener', listener.toString())\n-      // Add new handlers to our internal queue instead of the process\n-      underlyingListeners.push(listener as NodeJS.UnhandledRejectionListener)\n-      listenerMetadata.push({ listener, once: false })\n-      return process\n-    }\n-    // For other events, use the original method\n-    return originalProcessOn.call(process, event, listener)\n-  } as typeof process.on)\n+  // Intercept process.removeListener (alias for process.off)\n+  process.removeListener = patchWithoutReentrancy(\n+    originalProcessRemoveListener,\n+    function (event: string | symbol, listener: (...args: any[]) => void) {\n+      if (event === 'unhandledRejection') {\n+        debug?.('process.removeListener', listener.toString())\n+        // Check if they're trying to remove our filtering handler\n+        if (listener === filteringUnhandledRejectionHandler) {\n+          uninstallUnhandledRejectionFilter()\n+          return process\n+        }\n \n-  // Intercept process.addListener (alias for process.on)\n-  process.addListener = patchMethod(\n-    originalProcessAddListener,\n-    process.on as typeof originalProcessAddListener\n+        const index = underlyingListeners.lastIndexOf(listener)\n+        if (index > -1) {\n+          debug?.('process.removeListener match found', index)\n+          underlyingListeners.splice(index, 1)\n+          listenerMetadata.splice(index, 1)\n+        } else {\n+          debug?.('process.removeListener match not found', index)\n+        }\n+        return process\n+      }\n+      // For other events, use the original method\n+      return originalProcessRemoveListener.call(process, event, listener)\n+    } as typeof process.off\n   )\n \n-  // Intercept process.once for one-time handlers\n-  process.once = patchMethod(originalProcessOnce, function (\n-    event: string | symbol,\n-    listener: (...args: any[]) => void\n-  ) {\n-    if (event === 'unhandledRejection') {\n-      debug?.('process.once', listener.toString())\n-      underlyingListeners.push(listener)\n-      listenerMetadata.push({ listener, once: true })\n-      return process\n-    }\n-    // For other events, use the original method\n-    return originalProcessOnce.call(process, event, listener)\n-  } as typeof process.once)\n+  // If the process.on is referentially process.addListener then share the patched version as well\n+  if (originalProcessOn === originalProcessAddListener) {\n+    process.on = process.addListener\n+  } else {\n+    process.on = patchWithoutReentrancy(originalProcessOn, function (\n+      event: string | symbol,\n+      listener: (...args: any[]) => void\n+    ) {\n+      if (event === 'unhandledRejection') {\n+        debug?.('process.on', listener.toString())\n+        // Add new handlers to our internal queue instead of the process\n+        underlyingListeners.push(listener as NodeJS.UnhandledRejectionListener)\n+        listenerMetadata.push({ listener, once: false })\n+        return process\n+      }\n+      // For other events, use the original method\n+      return originalProcessOn.call(process, event, listener)\n+    } as typeof process.on)\n+  }\n+\n+  // If the process.off is referentially process.addListener then share the patched version as well\n+  if (originalProcessOff === originalProcessRemoveListener) {\n+    process.off = process.removeListener\n+  } else {\n+    process.off = patchWithoutReentrancy(originalProcessOff, function (\n+      event: string | symbol,\n+      listener: (...args: any[]) => void\n+    ) {\n+      if (event === 'unhandledRejection') {\n+        debug?.('process.off', listener.toString())\n+        // Check if they're trying to remove our filtering handler\n+        if (listener === filteringUnhandledRejectionHandler) {\n+          uninstallUnhandledRejectionFilter()\n+          return process\n+        }\n+\n+        const index = underlyingListeners.lastIndexOf(listener)\n+        if (index > -1) {\n+          debug?.('process.off match found', index)\n+          underlyingListeners.splice(index, 1)\n+          listenerMetadata.splice(index, 1)\n+        } else {\n+          debug?.('process.off match not found', index)\n+        }\n+        return process\n+      }\n+      // For other events, use the original method\n+      return originalProcessOff.call(process, event, listener)\n+    } as typeof process.off)\n+  }\n \n   // Intercept process.prependListener for handlers that should go first\n-  process.prependListener = patchMethod(\n+  process.prependListener = patchWithoutReentrancy(\n     originalProcessPrependListener,\n     function (event: string | symbol, listener: (...args: any[]) => void) {\n       if (event === 'unhandledRejection') {\n@@ -202,8 +304,26 @@ function installUnhandledRejectionFilter(): void {\n     } as typeof process.prependListener\n   )\n \n+  // Intercept process.once for one-time handlers\n+  process.once = patchWithoutReentrancy(originalProcessOnce, function (\n+    event: string | symbol,\n+    listener: (...args: any[]) => void\n+  ) {\n+    if (event === 'unhandledRejection') {\n+      debug?.('process.once', listener.toString())\n+      underlyingListeners.push(listener as NodeJS.UnhandledRejectionListener)\n+      listenerMetadata.push({\n+        listener: listener as NodeJS.UnhandledRejectionListener,\n+        once: true,\n+      })\n+      return process\n+    }\n+    // For other events, use the original method\n+    return originalProcessOnce.call(process, event, listener)\n+  } as typeof process.once)\n+\n   // Intercept process.prependOnceListener for one-time handlers that should go first\n-  process.prependOnceListener = patchMethod(\n+  process.prependOnceListener = patchWithoutReentrancy(\n     originalProcessPrependOnceListener,\n     function (event: string | symbol, listener: (...args: any[]) => void) {\n       if (event === 'unhandledRejection') {\n@@ -216,8 +336,13 @@ function installUnhandledRejectionFilter(): void {\n           )\n         }\n         // Add to the beginning of our internal queue\n-        underlyingListeners.unshift(listener)\n-        listenerMetadata.unshift({ listener, once: true })\n+        underlyingListeners.unshift(\n+          listener as NodeJS.UnhandledRejectionListener\n+        )\n+        listenerMetadata.unshift({\n+          listener: listener as NodeJS.UnhandledRejectionListener,\n+          once: true,\n+        })\n         return process\n       }\n       // For other events, use the original method\n@@ -229,41 +354,8 @@ function installUnhandledRejectionFilter(): void {\n     } as typeof process.prependOnceListener\n   )\n \n-  // Intercept process.removeListener\n-  process.removeListener = patchMethod(originalProcessRemoveListener, function (\n-    event: string | symbol,\n-    listener: (...args: any[]) => void\n-  ) {\n-    if (event === 'unhandledRejection') {\n-      debug?.('process.removeListener', listener.toString())\n-      // Check if they're trying to remove our filtering handler\n-      if (listener === filteringUnhandledRejectionHandler) {\n-        uninstallUnhandledRejectionFilter()\n-        return process\n-      }\n-\n-      const index = underlyingListeners.lastIndexOf(listener)\n-      if (index > -1) {\n-        debug?.('process.removeListener match found', index)\n-        underlyingListeners.splice(index, 1)\n-        listenerMetadata.splice(index, 1)\n-      } else {\n-        debug?.('process.removeListener match not found', index)\n-      }\n-      return process\n-    }\n-    // For other events, use the original method\n-    return originalProcessRemoveListener.call(process, event, listener)\n-  } as typeof process.removeListener)\n-\n-  // Intercept process.off (alias for process.removeListener)\n-  process.off = patchMethod(\n-    originalProcessOff,\n-    process.removeListener as typeof originalProcessOff\n-  )\n-\n   // Intercept process.removeAllListeners\n-  process.removeAllListeners = patchMethod(\n+  process.removeAllListeners = patchWithoutReentrancy(\n     originalProcessRemoveAllListeners,\n     function (event?: string | symbol) {\n       if (event === 'unhandledRejection') {\n@@ -301,33 +393,22 @@ function installUnhandledRejectionFilter(): void {\n   )\n \n   // Intercept process.listeners to return our internal handlers for unhandled rejection\n-  process.listeners = patchMethod(originalProcessListeners, function (\n-    event: string | symbol\n-  ) {\n-    if (event === 'unhandledRejection') {\n-      debug?.(\n-        'process.listeners',\n-        [filteringUnhandledRejectionHandler, ...underlyingListeners].map((l) =>\n-          l.toString()\n+  process.listeners = patchWithoutReentrancy(\n+    originalProcessListeners,\n+    function (event: string | symbol) {\n+      if (event === 'unhandledRejection') {\n+        debug?.(\n+          'process.listeners',\n+          [filteringUnhandledRejectionHandler, ...underlyingListeners].map(\n+            (l) => l.toString()\n+          )\n         )\n-      )\n-      return [filteringUnhandledRejectionHandler, ...underlyingListeners]\n-    }\n-    return originalProcessListeners.call(process, event as any)\n-  } as typeof process.listeners)\n-\n-  // Remove all existing handlers\n-  originalProcessRemoveAllListeners.call(process, 'unhandledRejection')\n-\n-  // Install our filtering handler\n-  originalProcessOn.call(\n-    process,\n-    'unhandledRejection',\n-    filteringUnhandledRejectionHandler\n+        return [filteringUnhandledRejectionHandler, ...underlyingListeners]\n+      }\n+      return originalProcessListeners.call(process, event as any)\n+    } as typeof process.listeners\n   )\n \n-  originalProcessOn.call(process, 'rejectionHandled', noopRejectionHandled)\n-\n   filterInstalled = true\n \n   debug?.(\n@@ -373,24 +454,17 @@ function uninstallUnhandledRejectionFilter(): void {\n   process.listeners = originalProcessListeners\n \n   // Remove our filtering handler\n-  originalProcessRemoveListener.call(\n-    process,\n+  process.removeListener(\n     'unhandledRejection',\n     filteringUnhandledRejectionHandler\n   )\n \n-  originalProcessRemoveListener.call(\n-    process,\n-    'rejectionHandled',\n-    noopRejectionHandled\n-  )\n-\n   // Re-register all the handlers that were in our internal queue\n   for (const meta of listenerMetadata) {\n     if (meta.once) {\n-      originalProcessOnce.call(process, 'unhandledRejection', meta.listener)\n+      process.once('unhandledRejection', meta.listener)\n     } else {\n-      originalProcessOn.call(process, 'unhandledRejection', meta.listener)\n+      process.addListener('unhandledRejection', meta.listener)\n     }\n   }\n \n@@ -473,8 +547,6 @@ function filteringUnhandledRejectionHandler(\n   }\n }\n \n-function noopRejectionHandled() {}\n-\n // Install the filter when this module is imported\n if (ENABLE_UHR_FILTER) {\n   installUnhandledRejectionFilter()"
        }
    ],
    "stats": {
        "total": 1341,
        "additions": 1214,
        "deletions": 127
    }
}