{
    "author": "huozhi",
    "message": "script: align the commits group logic with the origin script (#86079)",
    "sha": "8d891a26b5007cac96e69d20c37ee6acfa18d8cd",
    "files": [
        {
            "sha": "facaddd47562e3f3612cde0317467f4fd98d29c0",
            "filename": "scripts/generate-release-log.mjs",
            "status": "modified",
            "additions": 12,
            "deletions": 207,
            "changes": 219,
            "blob_url": "https://github.com/vercel/next.js/blob/8d891a26b5007cac96e69d20c37ee6acfa18d8cd/scripts%2Fgenerate-release-log.mjs",
            "raw_url": "https://github.com/vercel/next.js/raw/8d891a26b5007cac96e69d20c37ee6acfa18d8cd/scripts%2Fgenerate-release-log.mjs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/scripts%2Fgenerate-release-log.mjs?ref=8d891a26b5007cac96e69d20c37ee6acfa18d8cd",
            "patch": "@@ -1,108 +1,7 @@\n // @ts-check\n import fetch from 'node-fetch'\n \n-// Helper function to create a fresh copy of the categories structure\n-function createCategoriesStructure() {\n-  const RELEASE_CATEGORIES = {\n-    '### Core Changes': [],\n-    '### Minor Changes': [],\n-    '### Documentation Changes': [],\n-    '### Example Changes': [],\n-    '### Misc Changes': [],\n-    '### Patches': [],\n-    '### Credits': [],\n-  }\n-  return RELEASE_CATEGORIES\n-}\n-\n-async function main() {\n-  // Check if we have command line arguments for version comparison\n-  const args = process.argv.slice(2)\n-\n-  if (args.length === 2) {\n-    // Mode 1: Compare between two versions/commits\n-    const [fromVersion, toVersion] = args\n-    return await generateLogBetweenVersions(fromVersion, toVersion)\n-  } else if (args.length === 0) {\n-    // Mode 2: Original behavior - generate logs for latest canary releases\n-    return await generateLatestCanaryLogs()\n-  } else {\n-    console.error(\n-      'Usage: node generate-release-log.mjs [fromVersion toVersion]'\n-    )\n-    console.error(\n-      '  With no arguments: generates logs for latest canary releases'\n-    )\n-    console.error(\n-      '  With two arguments: generates logs between two versions/commits'\n-    )\n-    process.exit(1)\n-  }\n-}\n-\n-async function generateLogBetweenVersions(fromVersion, toVersion) {\n-  console.log(`Fetching commits between ${fromVersion} and ${toVersion}...`)\n-\n-  try {\n-    // Use GitHub API to compare commits between two references\n-    const response = await fetch(\n-      `https://api.github.com/repos/vercel/next.js/compare/${fromVersion}...${toVersion}`\n-    )\n-\n-    if (!response.ok) {\n-      throw new Error(\n-        `GitHub API error: ${response.status} ${response.statusText}`\n-      )\n-    }\n-\n-    const compareData = await response.json()\n-    const commits = compareData.commits || []\n-\n-    console.log(\n-      `Found ${commits.length} commits between ${fromVersion} and ${toVersion}`\n-    )\n-\n-    // Filter out version bump commits and other non-meaningful commits\n-    const filteredCommits = commits.filter((commit) => {\n-      const message = commit.commit.message.split('\\n')[0]\n-      const author = commit.author?.login || commit.commit.author.name\n-\n-      // Skip version bump commits (usually just version number changes)\n-      if (message.match(/^v\\d+\\.\\d+\\.\\d+(-\\w+\\.\\d+)?$/)) {\n-        console.log(`Skipping version bump commit: ${message}`)\n-        return false\n-      }\n-\n-      // Skip automated release commits\n-      if (author === 'vercel-release-bot' && message.match(/^v\\d+\\.\\d+\\.\\d+/)) {\n-        console.log(`Skipping automated release commit: ${message}`)\n-        return false\n-      }\n-\n-      return true\n-    })\n-\n-    console.log(`After filtering: ${filteredCommits.length} commits to include`)\n-\n-    // Categorize commits based on their commit messages\n-    const categorizedCommits = categorizeCommits(filteredCommits)\n-\n-    // Generate formatted output\n-    const content = formatCommitLog(categorizedCommits, fromVersion, toVersion)\n-\n-    return {\n-      fromVersion,\n-      toVersion,\n-      commitCount: filteredCommits.length,\n-      content,\n-    }\n-  } catch (error) {\n-    console.error('Error fetching commits:', error.message)\n-    process.exit(1)\n-  }\n-}\n-\n-async function generateLatestCanaryLogs() {\n+export async function main() {\n   const releasesArray = await fetch(\n     'https://api.github.com/repos/vercel/next.js/releases?per_page=100'\n   ).then((r) => r.json())\n@@ -126,7 +25,15 @@ async function generateLatestCanaryLogs() {\n \n   const releases = allReleases.filter((v) => v.tag_name.includes(targetVersion))\n \n-  const lineItems = createCategoriesStructure()\n+  const lineItems = {\n+    '### Core Changes': [],\n+    '### Minor Changes': [],\n+    '### Documentation Changes': [],\n+    '### Example Changes': [],\n+    '### Misc Changes': [],\n+    '### Patches': [],\n+    '### Credits': [],\n+  }\n \n   Object.keys(lineItems).forEach((header) => {\n     releases.forEach((release) => {\n@@ -184,13 +91,10 @@ async function generateLatestCanaryLogs() {\n       let creditsMessage = `Huge thanks to `\n \n       if (items.length > 1) {\n-        creditsMessage += items\n-          .slice(0, items.length - 1)\n-          .map((name) => `@${name}`)\n-          .join(`, `)\n+        creditsMessage += items.slice(0, items.length - 1).join(`, `)\n         creditsMessage += `, and `\n       }\n-      creditsMessage += `@${items[items.length - 1]}`\n+      creditsMessage += items[items.length - 1]\n       creditsMessage += ` for helping!`\n \n       finalMessage.push(creditsMessage)\n@@ -209,105 +113,6 @@ async function generateLatestCanaryLogs() {\n   }\n }\n \n-function categorizeCommits(commits) {\n-  const categories = createCategoriesStructure()\n-\n-  commits.forEach((commit) => {\n-    const message = commit.commit.message\n-    const author = commit.author?.login || commit.commit.author.name\n-    const sha = commit.sha.substring(0, 7)\n-\n-    // Extract commit message without merge info\n-    const cleanMessage = message.split('\\n')[0]\n-\n-    // Categorize based on commit message patterns\n-    if (cleanMessage.includes('feat:') || cleanMessage.includes('feature:')) {\n-      categories['### Core Changes'].push(\n-        `- ${cleanMessage} (${author}, ${sha})`\n-      )\n-    } else if (\n-      cleanMessage.includes('fix:') ||\n-      cleanMessage.includes('bugfix:')\n-    ) {\n-      categories['### Patches'].push(`- ${cleanMessage} (${author}, ${sha})`)\n-    } else if (\n-      cleanMessage.includes('docs:') ||\n-      cleanMessage.includes('documentation:')\n-    ) {\n-      categories['### Documentation Changes'].push(\n-        `- ${cleanMessage} (${author}, ${sha})`\n-      )\n-    } else if (\n-      cleanMessage.includes('example:') ||\n-      cleanMessage.includes('examples:')\n-    ) {\n-      categories['### Example Changes'].push(\n-        `- ${cleanMessage} (${author}, ${sha})`\n-      )\n-    } else if (\n-      cleanMessage.includes('chore:') ||\n-      cleanMessage.includes('refactor:')\n-    ) {\n-      categories['### Minor Changes'].push(\n-        `- ${cleanMessage} (${author}, ${sha})`\n-      )\n-    } else {\n-      categories['### Misc Changes'].push(\n-        `- ${cleanMessage} (${author}, ${sha})`\n-      )\n-    }\n-\n-    // Extract contributors for credits\n-    if (author && !categories['### Credits'].includes(author)) {\n-      categories['### Credits'].push(author)\n-    }\n-  })\n-\n-  return categories\n-}\n-\n-function formatCommitLog(categorizedCommits, fromVersion, toVersion) {\n-  let finalMessage = []\n-\n-  // Add header\n-  finalMessage.push(`# Changes between ${fromVersion} and ${toVersion}`)\n-  finalMessage.push('')\n-\n-  Object.keys(categorizedCommits).forEach((header) => {\n-    const items = categorizedCommits[header]\n-\n-    if (!items.length) {\n-      return\n-    }\n-\n-    finalMessage.push(header)\n-    finalMessage.push('')\n-\n-    if (header === '### Credits') {\n-      const uniqueCredits = [...new Set(items)]\n-      let creditsMessage = `Huge thanks to `\n-\n-      if (uniqueCredits.length > 1) {\n-        creditsMessage += uniqueCredits\n-          .slice(0, uniqueCredits.length - 1)\n-          .map((name) => `@${name}`)\n-          .join(`, `)\n-        creditsMessage += `, and `\n-      }\n-      creditsMessage += `@${uniqueCredits[uniqueCredits.length - 1]}`\n-      creditsMessage += ` for helping!`\n-\n-      finalMessage.push(creditsMessage)\n-    } else {\n-      items.forEach((item) => finalMessage.push(item))\n-    }\n-\n-    finalMessage.push('')\n-  })\n-\n-  return finalMessage.join('\\n')\n-}\n-\n main().then((result) => {\n   console.log(result.content)\n })"
        }
    ],
    "stats": {
        "total": 219,
        "additions": 12,
        "deletions": 207
    }
}