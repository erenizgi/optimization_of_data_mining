{
    "author": "kdy1",
    "message": "perf(turbopack): Drop `tokio::fs` usages (#80674)\n\n### What?\n\n`std::fs` with manual `spawn_blocking` is better than using `tokio::fs`\n\n### Why?\n\n`tokio::fs` inevitably calls `spawn_blocking` internally, but it calls `spawn_blocking` way too much time\n\n---------\n\nCo-authored-by: graphite-app[bot] <96075541+graphite-app[bot]@users.noreply.github.com>\nCo-authored-by: Tobias Koppers <tobias.koppers@googlemail.com>",
    "sha": "3d0e472132e8495feaf0ebfc8f9718faac6dc505",
    "files": [
        {
            "sha": "9f36127dfe365518b7942f93bf77c6a32d29c15e",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 85,
            "deletions": 72,
            "changes": 157,
            "blob_url": "https://github.com/vercel/next.js/blob/3d0e472132e8495feaf0ebfc8f9718faac6dc505/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3d0e472132e8495feaf0ebfc8f9718faac6dc505/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=3d0e472132e8495feaf0ebfc8f9718faac6dc505",
            "patch": "@@ -29,7 +29,7 @@ use std::{\n     fmt::{self, Debug, Display, Formatter},\n     fs::FileType,\n     future::Future,\n-    io::{self, BufRead, ErrorKind},\n+    io::{self, BufRead, BufReader, ErrorKind, Read},\n     mem::take,\n     path::{MAIN_SEPARATOR, Path, PathBuf},\n     sync::Arc,\n@@ -51,11 +51,7 @@ use read_glob::{read_glob, track_glob};\n use rustc_hash::FxHashSet;\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n-use tokio::{\n-    fs,\n-    io::{AsyncBufReadExt, AsyncReadExt, BufReader},\n-    sync::{RwLock, RwLockReadGuard},\n-};\n+use tokio::sync::{RwLock, RwLockReadGuard};\n use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n@@ -72,7 +68,7 @@ use self::{invalidation::Write, json::UnparseableJson, mutex_map::MutexMap};\n use crate::{\n     attach::AttachedFileSystem,\n     invalidator_map::WriteContent,\n-    retry::{retry_blocking, retry_future},\n+    retry::retry_blocking,\n     rope::{Rope, RopeReader},\n };\n \n@@ -390,12 +386,12 @@ impl DiskFileSystemInner {\n         let root_path = self.root_path().to_path_buf();\n \n         // create the directory for the filesystem on disk, if it doesn't exist\n-        retry_future(|| {\n-            let path = root_path.as_path();\n-            fs::create_dir_all(&root_path).instrument(tracing::info_span!(\n-                \"create root directory\",\n-                path = display(path.display())\n-            ))\n+        retry_blocking(root_path.clone(), move |path| {\n+            let _tracing =\n+                tracing::info_span!(\"create root directory\", path = display(path.display()))\n+                    .entered();\n+\n+            std::fs::create_dir_all(path)\n         })\n         .concurrency_limited(&self.semaphore)\n         .await?;\n@@ -413,7 +409,7 @@ impl DiskFileSystemInner {\n         );\n         if !already_created {\n             let func = |p: &Path| std::fs::create_dir_all(p);\n-            retry_blocking(directory, func)\n+            retry_blocking(directory.to_path_buf(), func)\n                 .concurrency_limited(&self.semaphore)\n                 .instrument(tracing::info_span!(\n                     \"create directory\",\n@@ -559,7 +555,7 @@ impl FileSystem for DiskFileSystem {\n         self.inner.register_read_invalidator(&full_path)?;\n \n         let _lock = self.inner.lock_path(&full_path).await;\n-        let content = match retry_future(|| File::from_path(full_path.clone()))\n+        let content = match retry_blocking(full_path.clone(), |path: &Path| File::from_path(path))\n             .concurrency_limited(&self.inner.semaphore)\n             .instrument(tracing::info_span!(\n                 \"read file\",\n@@ -586,7 +582,7 @@ impl FileSystem for DiskFileSystem {\n \n         // we use the sync std function here as it's a lot faster (600%) in\n         // node-file-trace\n-        let read_dir = match retry_blocking(&full_path, |path| {\n+        let read_dir = match retry_blocking(full_path.clone(), |path| {\n             let _span =\n                 tracing::info_span!(\"read directory\", path = display(path.display())).entered();\n             std::fs::read_dir(path)\n@@ -640,17 +636,18 @@ impl FileSystem for DiskFileSystem {\n         self.inner.register_read_invalidator(&full_path)?;\n \n         let _lock = self.inner.lock_path(&full_path).await;\n-        let link_path = match retry_future(|| fs::read_link(&full_path))\n-            .concurrency_limited(&self.inner.semaphore)\n-            .instrument(tracing::info_span!(\n-                \"read symlink\",\n-                path = display(full_path.display())\n-            ))\n-            .await\n-        {\n-            Ok(res) => res,\n-            Err(_) => return Ok(LinkContent::NotFound.cell()),\n-        };\n+        let link_path =\n+            match retry_blocking(full_path.clone(), |path: &Path| std::fs::read_link(path))\n+                .concurrency_limited(&self.inner.semaphore)\n+                .instrument(tracing::info_span!(\n+                    \"read symlink\",\n+                    path = display(full_path.display())\n+                ))\n+                .await\n+            {\n+                Ok(res) => res,\n+                Err(_) => return Ok(LinkContent::NotFound.cell()),\n+            };\n         let is_link_absolute = link_path.is_absolute();\n \n         let mut file = link_path.clone();\n@@ -779,7 +776,7 @@ impl FileSystem for DiskFileSystem {\n \n                     let full_path_to_write = full_path.clone();\n                     let content = content.clone();\n-                    retry_blocking(&full_path_to_write, move |full_path| {\n+                    retry_blocking(full_path_to_write.into_owned(), move |full_path| {\n                         use std::io::Write;\n \n                         let mut f = std::fs::File::create(full_path)?;\n@@ -818,21 +815,23 @@ impl FileSystem for DiskFileSystem {\n                     .with_context(|| format!(\"failed to write to {}\", full_path.display()))?;\n                 }\n                 FileContent::NotFound => {\n-                    retry_blocking(&full_path, |path| std::fs::remove_file(path))\n-                        .concurrency_limited(&inner.semaphore)\n-                        .instrument(tracing::info_span!(\n-                            \"remove file\",\n-                            path = display(full_path.display())\n-                        ))\n-                        .await\n-                        .or_else(|err| {\n-                            if err.kind() == ErrorKind::NotFound {\n-                                Ok(())\n-                            } else {\n-                                Err(err)\n-                            }\n-                        })\n-                        .with_context(|| anyhow!(\"removing {} failed\", full_path.display()))?;\n+                    retry_blocking(full_path.clone().into_owned(), |path| {\n+                        std::fs::remove_file(path)\n+                    })\n+                    .concurrency_limited(&inner.semaphore)\n+                    .instrument(tracing::info_span!(\n+                        \"remove file\",\n+                        path = display(full_path.display())\n+                    ))\n+                    .await\n+                    .or_else(|err| {\n+                        if err.kind() == ErrorKind::NotFound {\n+                            Ok(())\n+                        } else {\n+                            Err(err)\n+                        }\n+                    })\n+                    .with_context(|| anyhow!(\"removing {} failed\", full_path.display()))?;\n                 }\n             }\n \n@@ -865,13 +864,15 @@ impl FileSystem for DiskFileSystem {\n \n             // TODO(sokra) preform a untracked read here, register an invalidator and get\n             // all existing invalidators\n-            let old_content = match retry_blocking(&full_path, |path| std::fs::read_link(path))\n-                .concurrency_limited(&inner.semaphore)\n-                .instrument(tracing::info_span!(\n-                    \"read symlink before write\",\n-                    path = display(full_path.display())\n-                ))\n-                .await\n+            let old_content = match retry_blocking(full_path.clone().into_owned(), |path| {\n+                std::fs::read_link(path)\n+            })\n+            .concurrency_limited(&inner.semaphore)\n+            .instrument(tracing::info_span!(\n+                \"read symlink before write\",\n+                path = display(full_path.display())\n+            ))\n+            .await\n             {\n                 Ok(res) => Some((res.is_absolute(), res)),\n                 Err(_) => None,\n@@ -916,7 +917,7 @@ impl FileSystem for DiskFileSystem {\n                         PathBuf::from(unix_to_sys(target).as_ref())\n                     };\n                     let full_path = full_path.into_owned();\n-                    retry_blocking(&target_path, move |target_path| {\n+                    retry_blocking(target_path, move |target_path| {\n                         let _span = tracing::info_span!(\n                             \"write symlink\",\n                             path = display(target_path.display())\n@@ -944,17 +945,19 @@ impl FileSystem for DiskFileSystem {\n                     anyhow::bail!(\"invalid symlink target: {}\", full_path.display())\n                 }\n                 LinkContent::NotFound => {\n-                    retry_blocking(&full_path, |path| std::fs::remove_file(path))\n-                        .concurrency_limited(&inner.semaphore)\n-                        .await\n-                        .or_else(|err| {\n-                            if err.kind() == ErrorKind::NotFound {\n-                                Ok(())\n-                            } else {\n-                                Err(err)\n-                            }\n-                        })\n-                        .with_context(|| anyhow!(\"removing {} failed\", full_path.display()))?;\n+                    retry_blocking(full_path.clone().into_owned(), |path| {\n+                        std::fs::remove_file(path)\n+                    })\n+                    .concurrency_limited(&inner.semaphore)\n+                    .await\n+                    .or_else(|err| {\n+                        if err.kind() == ErrorKind::NotFound {\n+                            Ok(())\n+                        } else {\n+                            Err(err)\n+                        }\n+                    })\n+                    .with_context(|| anyhow!(\"removing {} failed\", full_path.display()))?;\n                 }\n             }\n \n@@ -970,7 +973,7 @@ impl FileSystem for DiskFileSystem {\n         self.inner.register_read_invalidator(&full_path)?;\n \n         let _lock = self.inner.lock_path(&full_path).await;\n-        let meta = retry_blocking(&full_path, |path| std::fs::metadata(path))\n+        let meta = retry_blocking(full_path.clone(), |path| std::fs::metadata(path))\n             .concurrency_limited(&self.inner.semaphore)\n             .instrument(tracing::info_span!(\n                 \"read metadata\",\n@@ -1708,8 +1711,11 @@ impl FileContent {\n     /// Performs a comparison of self's data against a disk file's streamed\n     /// read.\n     async fn streaming_compare(&self, path: &Path) -> Result<FileComparison> {\n-        let old_file = extract_disk_access(retry_future(|| fs::File::open(path)).await, path)?;\n-        let Some(mut old_file) = old_file else {\n+        let old_file = extract_disk_access(\n+            retry_blocking(path.to_path_buf(), |path| std::fs::File::open(path)).await,\n+            path,\n+        )?;\n+        let Some(old_file) = old_file else {\n             return Ok(match self {\n                 FileContent::NotFound => FileComparison::Equal,\n                 _ => FileComparison::Create,\n@@ -1720,7 +1726,14 @@ impl FileContent {\n             return Ok(FileComparison::NotEqual);\n         };\n \n-        let old_meta = extract_disk_access(retry_future(|| old_file.metadata()).await, path)?;\n+        let old_meta = extract_disk_access(\n+            retry_blocking(path.to_path_buf(), {\n+                let file_for_metadata = old_file.try_clone()?;\n+                move |_| file_for_metadata.metadata()\n+            })\n+            .await,\n+            path,\n+        )?;\n         let Some(old_meta) = old_meta else {\n             // If we failed to get meta, then the old file has been deleted between the\n             // handle open. In which case, we just pretend the file never\n@@ -1735,10 +1748,10 @@ impl FileContent {\n         // So meta matches, and we have a file handle. Let's stream the contents to see\n         // if they match.\n         let mut new_contents = new_file.read();\n-        let mut old_contents = BufReader::new(&mut old_file);\n+        let mut old_contents = BufReader::new(old_file);\n         Ok(loop {\n             let new_chunk = new_contents.fill_buf()?;\n-            let Ok(old_chunk) = old_contents.fill_buf().await else {\n+            let Ok(old_chunk) = old_contents.fill_buf() else {\n                 break FileComparison::NotEqual;\n             };\n \n@@ -1793,12 +1806,12 @@ pub struct File {\n \n impl File {\n     /// Reads a [File] from the given path\n-    async fn from_path(p: PathBuf) -> io::Result<Self> {\n-        let mut file = fs::File::open(p).await?;\n-        let metadata = file.metadata().await?;\n+    fn from_path(p: &Path) -> io::Result<Self> {\n+        let mut file = std::fs::File::open(p)?;\n+        let metadata = file.metadata()?;\n \n         let mut output = Vec::with_capacity(metadata.len() as usize);\n-        file.read_to_end(&mut output).await?;\n+        file.read_to_end(&mut output)?;\n \n         Ok(File {\n             meta: metadata.into(),"
        },
        {
            "sha": "44ae3c4477848b5a8a3c7ee9f0928ca1a2aca6cb",
            "filename": "turbopack/crates/turbo-tasks-fs/src/retry.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 40,
            "changes": 47,
            "blob_url": "https://github.com/vercel/next.js/blob/3d0e472132e8495feaf0ebfc8f9718faac6dc505/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fretry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3d0e472132e8495feaf0ebfc8f9718faac6dc505/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fretry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fretry.rs?ref=3d0e472132e8495feaf0ebfc8f9718faac6dc505",
            "patch": "@@ -1,34 +1,17 @@\n-use std::{future::Future, io, io::ErrorKind, path::Path, thread::sleep, time::Duration};\n-\n-use futures_retry::{ErrorHandler, FutureRetry, RetryPolicy};\n+use std::{\n+    io::{self, ErrorKind},\n+    path::{Path, PathBuf},\n+    thread::sleep,\n+    time::Duration,\n+};\n \n const MAX_RETRY_ATTEMPTS: usize = 10;\n \n-pub(crate) async fn retry_future<'a, R, F, Fut>(func: F) -> io::Result<R>\n-where\n-    F: FnMut() -> Fut + Unpin,\n-    Fut: Future<Output = io::Result<R>> + 'a,\n-{\n-    match FutureRetry::new(\n-        func,\n-        FsRetryHandler {\n-            max_attempts: MAX_RETRY_ATTEMPTS,\n-        },\n-    )\n-    .await\n-    {\n-        Ok((r, _attempts)) => Ok(r),\n-        Err((err, _attempts)) => Err(err),\n-    }\n-}\n-\n-pub(crate) async fn retry_blocking<R, F>(path: impl AsRef<Path>, func: F) -> io::Result<R>\n+pub(crate) async fn retry_blocking<R, F>(path: PathBuf, func: F) -> io::Result<R>\n where\n     F: Fn(&Path) -> io::Result<R> + Send + 'static,\n     R: Send + 'static,\n {\n-    let path = path.as_ref().to_owned();\n-\n     turbo_tasks::spawn_blocking(move || {\n         let mut attempt = 1;\n \n@@ -60,19 +43,3 @@ fn can_retry(err: &io::Error) -> bool {\n fn get_retry_wait_time(attempt: usize) -> Duration {\n     Duration::from_millis((attempt as u64) * 100)\n }\n-\n-struct FsRetryHandler {\n-    max_attempts: usize,\n-}\n-\n-impl ErrorHandler<io::Error> for FsRetryHandler {\n-    type OutError = io::Error;\n-\n-    fn handle(&mut self, attempt: usize, e: io::Error) -> RetryPolicy<io::Error> {\n-        if attempt == self.max_attempts || !can_retry(&e) {\n-            RetryPolicy::ForwardError(e)\n-        } else {\n-            RetryPolicy::WaitRetry(get_retry_wait_time(attempt))\n-        }\n-    }\n-}"
        }
    ],
    "stats": {
        "total": 204,
        "additions": 92,
        "deletions": 112
    }
}