{
    "author": "sokra",
    "message": "Turbopack: Split AggregatedDirtyContainerCount (#86072)\n\nSplit AggregatedDirtyContainerCount\n\nimprove test case to test session dependent and restoring\n\n<!-- Thanks for opening a PR! Your contribution is much appreciated.\nTo make sure your PR is handled as smoothly as possible we request that you follow the checklist sections below.\nChoose the right checklist for the change(s) that you're making:\n\n## For Contributors\n\n### Improving Documentation\n\n- Run `pnpm prettier-fix` to fix formatting issues before opening the PR.\n- Read the Docs Contribution Guide to ensure your contribution follows the docs guidelines: https://nextjs.org/docs/community/contribution-guide\n\n### Fixing a bug\n\n- Related issues linked using `fixes #number`\n- Tests added. See: https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs\n- Errors have a helpful link attached, see https://github.com/vercel/next.js/blob/canary/contributing.md\n\n### Adding a feature\n\n- Implements an existing feature request or RFC. Make sure the feature request has been accepted for implementation before opening a PR. (A discussion must be opened, see https://github.com/vercel/next.js/discussions/new?category=ideas)\n- Related issues/discussions are linked using `fixes #number`\n- e2e tests added (https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs)\n- Documentation added\n- Telemetry added. In case of a feature if it's used or not.\n- Errors have a helpful link attached, see https://github.com/vercel/next.js/blob/canary/contributing.md\n\n\n## For Maintainers\n\n- Minimal description (aim for explaining to someone not on the team to understand the PR)\n- When linking to a Slack thread, you might want to share details of the conclusion\n- Link both the Linear (Fixes NEXT-xxx) and the GitHub issues\n- Add review comments if necessary to explain to the reviewer the logic behind a change\n\n### What?\n\n### Why?\n\n### How?\n\nCloses NEXT-\nFixes #\n\n-->",
    "sha": "4795a00b60de95a33a9184d54f9dc39cef302e3d",
    "files": [
        {
            "sha": "90be149ec7a7dae25b6f4dad6271a03b134391dd",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 89,
            "deletions": 67,
            "changes": 156,
            "blob_url": "https://github.com/vercel/next.js/blob/4795a00b60de95a33a9184d54f9dc39cef302e3d/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4795a00b60de95a33a9184d54f9dc39cef302e3d/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=4795a00b60de95a33a9184d54f9dc39cef302e3d",
            "patch": "@@ -48,8 +48,8 @@ use crate::backend::operation::TaskDirtyCause;\n use crate::{\n     backend::{\n         operation::{\n-            AggregatedDataUpdate, AggregationUpdateJob, AggregationUpdateQueue,\n-            CleanupOldEdgesOperation, ConnectChildOperation, ExecuteContext, ExecuteContextImpl,\n+            AggregationUpdateJob, AggregationUpdateQueue, CleanupOldEdgesOperation,\n+            ComputeDirtyAndCleanUpdate, ConnectChildOperation, ExecuteContext, ExecuteContextImpl,\n             Operation, OutdatedEdge, TaskGuard, connect_children, get_aggregation_number,\n             get_uppers, is_root_node, make_task_dirty_internal, prepare_new_children,\n         },\n@@ -570,11 +570,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             let is_dirty = task.is_dirty(self.session_id);\n \n             // Check the dirty count of the root node\n-            let dirty_tasks = get!(task, AggregatedDirtyContainerCount)\n-                .cloned()\n-                .unwrap_or_default()\n-                .get(self.session_id);\n-            if dirty_tasks > 0 || is_dirty {\n+            let has_dirty_containers = task.has_dirty_containers(self.session_id);\n+            if has_dirty_containers || is_dirty {\n                 let activeness = get_mut!(task, Activeness);\n                 let mut task_ids_to_schedule: Vec<_> = Vec::new();\n                 // When there are dirty task, subscribe to the all_clean_event\n@@ -615,7 +612,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                             parent_and_count: Option<(TaskId, i32)>,\n                             visited: &mut FxHashSet<TaskId>,\n                         ) -> String {\n-                            let task = ctx.task(task_id, TaskDataCategory::Data);\n+                            let task = ctx.task(task_id, TaskDataCategory::All);\n                             let is_dirty = task.is_dirty(ctx.session_id());\n                             let in_progress =\n                                 get!(task, InProgress).map_or(\"not in progress\", |p| match p {\n@@ -637,21 +634,24 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                             };\n \n                             // Check the dirty count of the root node\n-                            let dirty_tasks = get!(task, AggregatedDirtyContainerCount)\n-                                .cloned()\n-                                .unwrap_or_default()\n-                                .get(ctx.session_id());\n+                            let has_dirty_containers = task.has_dirty_containers(ctx.session_id());\n \n                             let task_description = ctx.get_task_description(task_id);\n-                            let is_dirty = if is_dirty { \", dirty\" } else { \"\" };\n+                            let is_dirty_label = if is_dirty { \", dirty\" } else { \"\" };\n+                            let has_dirty_containers_label = if has_dirty_containers {\n+                                \", dirty containers\"\n+                            } else {\n+                                \"\"\n+                            };\n                             let count = if let Some((_, count)) = parent_and_count {\n                                 format!(\" {count}\")\n                             } else {\n                                 String::new()\n                             };\n                             let mut info = format!(\n                                 \"{task_id} {task_description}{count} (aggr={aggregation_number}, \\\n-                                 {in_progress}, {activeness}{is_dirty})\",\n+                                 {in_progress}, \\\n+                                 {activeness}{is_dirty_label}{has_dirty_containers_label})\",\n                             );\n                             let children: Vec<_> =\n                                 task.dirty_containers_with_count(ctx.session_id()).collect();\n@@ -661,8 +661,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                                 info.push_str(\"\\n  ERROR: missing upper connection\");\n                             }\n \n-                            if dirty_tasks > 0 || !children.is_empty() {\n-                                writeln!(info, \"\\n  {dirty_tasks} dirty tasks:\").unwrap();\n+                            if has_dirty_containers || !children.is_empty() {\n+                                writeln!(info, \"\\n  dirty tasks:\").unwrap();\n \n                                 for (child_task_id, count) in children {\n                                     let task_description = ctx.get_task_description(child_task_id);\n@@ -2363,68 +2363,92 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             },\n         ));\n \n-        // Update the dirty state\n-        let old_dirtyness = task.dirtyness_and_session();\n+        // Grab the old dirty state\n+        let old_dirtyness = get!(task, Dirty).cloned();\n+        let (old_self_dirty, old_current_session_self_clean, old_clean_in_session) =\n+            match old_dirtyness {\n+                None => (false, false, None),\n+                Some(Dirtyness::Dirty) => (true, false, None),\n+                Some(Dirtyness::SessionDependent) => {\n+                    let clean_in_session = get!(task, CleanInSession).copied();\n+                    (\n+                        true,\n+                        clean_in_session == Some(self.session_id),\n+                        clean_in_session,\n+                    )\n+                }\n+            };\n \n-        let new_dirtyness = if session_dependent {\n-            Some((Dirtyness::SessionDependent, Some(self.session_id)))\n-        } else {\n-            None\n-        };\n+        // Compute the new dirty state\n+        let (new_dirtyness, new_clean_in_session, new_self_dirty, new_current_session_self_clean) =\n+            if session_dependent {\n+                (\n+                    Some(Dirtyness::SessionDependent),\n+                    Some(self.session_id),\n+                    true,\n+                    true,\n+                )\n+            } else {\n+                (None, None, false, false)\n+            };\n \n-        let dirty_changed = old_dirtyness != new_dirtyness;\n-        let data_update = if dirty_changed {\n-            if let Some((value, _)) = new_dirtyness {\n+        // Update the dirty state\n+        if old_dirtyness != new_dirtyness {\n+            if let Some(value) = new_dirtyness {\n                 task.insert(CachedDataItem::Dirty { value });\n             } else if old_dirtyness.is_some() {\n                 task.remove(&CachedDataItemKey::Dirty {});\n             }\n-            if let Some(session_id) = new_dirtyness.and_then(|t| t.1) {\n+        }\n+        if old_clean_in_session != new_clean_in_session {\n+            if let Some(session_id) = new_clean_in_session {\n                 task.insert(CachedDataItem::CleanInSession { value: session_id });\n-            } else if old_dirtyness.is_some_and(|t| t.1.is_some()) {\n+            } else if old_clean_in_session.is_some() {\n                 task.remove(&CachedDataItemKey::CleanInSession {});\n             }\n+        }\n \n-            let mut dirty_containers = get!(task, AggregatedDirtyContainerCount)\n+        // Propagate dirtyness changes\n+        let data_update = if old_self_dirty != new_self_dirty\n+            || old_current_session_self_clean != new_current_session_self_clean\n+        {\n+            let dirty_container_count = get!(task, AggregatedDirtyContainerCount)\n                 .cloned()\n                 .unwrap_or_default();\n-            if let Some((old_dirtyness, old_clean_in_session)) = old_dirtyness {\n-                dirty_containers\n-                    .update_with_dirtyness_and_session(old_dirtyness, old_clean_in_session);\n-            }\n-            let aggregated_update = match (old_dirtyness, new_dirtyness) {\n-                (None, None) => unreachable!(),\n-                (Some(old), None) => {\n-                    dirty_containers.undo_update_with_dirtyness_and_session(old.0, old.1)\n-                }\n-                (None, Some(new)) => {\n-                    dirty_containers.update_with_dirtyness_and_session(new.0, new.1)\n-                }\n-                (Some(old), Some(new)) => {\n-                    dirty_containers.replace_dirtyness_and_session(old.0, old.1, new.0, new.1)\n+            let current_session_clean_container_count = get!(\n+                task,\n+                AggregatedSessionDependentCleanContainerCount {\n+                    session_id: self.session_id\n                 }\n-            };\n-            if !aggregated_update.is_zero() {\n-                if aggregated_update.get(self.session_id) < 0\n-                    && let Some(activeness_state) = get_mut!(task, Activeness)\n-                {\n+            )\n+            .copied()\n+            .unwrap_or_default();\n+            let result = ComputeDirtyAndCleanUpdate {\n+                old_dirty_container_count: dirty_container_count,\n+                new_dirty_container_count: dirty_container_count,\n+                old_current_session_clean_container_count: current_session_clean_container_count,\n+                new_current_session_clean_container_count: current_session_clean_container_count,\n+                old_self_dirty,\n+                new_self_dirty,\n+                old_current_session_self_clean,\n+                new_current_session_self_clean,\n+            }\n+            .compute();\n+            if result.dirty_count_update - result.current_session_clean_update < 0 {\n+                // The task is clean now\n+                if let Some(activeness_state) = get_mut!(task, Activeness) {\n                     activeness_state.all_clean_event.notify(usize::MAX);\n                     activeness_state.unset_active_until_clean();\n                     if activeness_state.is_empty() {\n                         task.remove(&CachedDataItemKey::Activeness {});\n                     }\n                 }\n-                AggregationUpdateJob::data_update(\n-                    &mut task,\n-                    AggregatedDataUpdate::new().dirty_container_update(\n-                        task_id,\n-                        aggregated_update.count,\n-                        aggregated_update.current_session_clean(ctx.session_id()),\n-                    ),\n-                )\n-            } else {\n-                None\n             }\n+            result\n+                .aggregated_update(task_id)\n+                .and_then(|aggregated_update| {\n+                    AggregationUpdateJob::data_update(&mut task, aggregated_update)\n+                })\n         } else {\n             None\n         };\n@@ -2891,10 +2915,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         let mut ctx = self.execute_context(turbo_tasks);\n         let mut task = ctx.task(task_id, TaskDataCategory::All);\n         let is_dirty = task.is_dirty(self.session_id);\n-        let has_dirty_containers = get!(task, AggregatedDirtyContainerCount)\n-            .map_or(false, |dirty_containers| {\n-                dirty_containers.get(self.session_id) > 0\n-            });\n+        let has_dirty_containers = task.has_dirty_containers(self.session_id);\n         if is_dirty || has_dirty_containers {\n             if let Some(activeness_state) = get_mut!(task, Activeness) {\n                 // We will finish the task, but it would be removed after the task is done\n@@ -2984,8 +3005,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 }\n \n                 let is_dirty = get!(task, Dirty).is_some();\n-                let has_dirty_container =\n-                    get!(task, AggregatedDirtyContainerCount).is_some_and(|count| count.count > 0);\n+                let has_dirty_container = task.has_dirty_containers(self.session_id);\n                 let should_be_in_upper = is_dirty || has_dirty_container;\n \n                 let aggregation_number = get_aggregation_number(&task);\n@@ -3008,17 +3028,19 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n                 if should_be_in_upper {\n                     for upper_id in uppers {\n-                        let task = ctx.task(task_id, TaskDataCategory::All);\n+                        let task = ctx.task(upper_id, TaskDataCategory::All);\n                         let in_upper = get!(task, AggregatedDirtyContainer { task: task_id })\n                             .is_some_and(|&dirty| dirty > 0);\n                         if !in_upper {\n+                            let containers: Vec<_> = get_many!(task, AggregatedDirtyContainer { task: task_id } value => (task_id, *value));\n                             panic!(\n                                 \"Task {} ({}) is dirty, but is not listed in the upper task {} \\\n-                                 ({})\",\n+                                 ({})\\nThese dirty containers are present:\\n{:#?}\",\n                                 task_id,\n                                 ctx.get_task_description(task_id),\n                                 upper_id,\n-                                ctx.get_task_description(upper_id)\n+                                ctx.get_task_description(upper_id),\n+                                containers,\n                             );\n                         }\n                     }"
        },
        {
            "sha": "1103f2aa40367b1ea57c1e98e324567041f74cf1",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/aggregation_update.rs",
            "status": "modified",
            "additions": 161,
            "deletions": 50,
            "changes": 211,
            "blob_url": "https://github.com/vercel/next.js/blob/4795a00b60de95a33a9184d54f9dc39cef302e3d/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4795a00b60de95a33a9184d54f9dc39cef302e3d/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs?ref=4795a00b60de95a33a9184d54f9dc39cef302e3d",
            "patch": "@@ -34,7 +34,7 @@ use crate::{\n     },\n     data::{\n         ActivenessState, AggregationNumber, CachedDataItem, CachedDataItemKey, CachedDataItemType,\n-        CollectibleRef, DirtyContainerCount,\n+        CollectibleRef,\n     },\n     utils::swap_retain,\n };\n@@ -93,6 +93,79 @@ pub fn get_aggregation_number(task: &impl TaskGuard) -> u32 {\n         .unwrap_or_default()\n }\n \n+#[derive(Debug)]\n+pub struct ComputeDirtyAndCleanUpdate {\n+    pub old_dirty_container_count: i32,\n+    pub new_dirty_container_count: i32,\n+    pub old_current_session_clean_container_count: i32,\n+    pub new_current_session_clean_container_count: i32,\n+    pub old_self_dirty: bool,\n+    pub new_self_dirty: bool,\n+    pub old_current_session_self_clean: bool,\n+    pub new_current_session_self_clean: bool,\n+}\n+\n+pub struct ComputeDirtyAndCleanUpdateResult {\n+    pub dirty_count_update: i32,\n+    pub current_session_clean_update: i32,\n+}\n+\n+impl ComputeDirtyAndCleanUpdate {\n+    pub fn compute(self) -> ComputeDirtyAndCleanUpdateResult {\n+        let ComputeDirtyAndCleanUpdate {\n+            old_dirty_container_count,\n+            new_dirty_container_count,\n+            old_current_session_clean_container_count,\n+            new_current_session_clean_container_count,\n+            old_self_dirty,\n+            new_self_dirty,\n+            old_current_session_self_clean,\n+            new_current_session_self_clean,\n+        } = self;\n+        let was_dirty_without_clean = old_self_dirty || old_dirty_container_count > 0;\n+        let is_dirty_without_clean = new_self_dirty || new_dirty_container_count > 0;\n+        let was_dirty = old_self_dirty && !old_current_session_self_clean\n+            || old_dirty_container_count > 0\n+                && old_dirty_container_count > old_current_session_clean_container_count;\n+        let is_dirty = new_self_dirty && !new_current_session_self_clean\n+            || new_dirty_container_count > 0\n+                && new_dirty_container_count > new_current_session_clean_container_count;\n+        let was_flagged_clean = was_dirty_without_clean && !was_dirty;\n+        let is_flagged_clean = is_dirty_without_clean && !is_dirty;\n+\n+        fn before_after_to_diff_value(before: bool, after: bool) -> i32 {\n+            match (before, after) {\n+                (true, false) => -1,\n+                (false, true) => 1,\n+                _ => 0,\n+            }\n+        }\n+        let dirty_count_update =\n+            before_after_to_diff_value(was_dirty_without_clean, is_dirty_without_clean);\n+        let current_session_clean_update =\n+            before_after_to_diff_value(was_flagged_clean, is_flagged_clean);\n+\n+        ComputeDirtyAndCleanUpdateResult {\n+            dirty_count_update,\n+            current_session_clean_update,\n+        }\n+    }\n+}\n+\n+impl ComputeDirtyAndCleanUpdateResult {\n+    pub fn aggregated_update(&self, task_id: TaskId) -> Option<AggregatedDataUpdate> {\n+        if self.dirty_count_update != 0 || self.current_session_clean_update != 0 {\n+            Some(AggregatedDataUpdate::new().dirty_container_update(\n+                task_id,\n+                self.dirty_count_update,\n+                self.current_session_clean_update,\n+            ))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n #[derive(Serialize, Deserialize, Clone, Debug)]\n pub struct InnerOfUppersHasNewFollowersJob {\n     pub upper_ids: TaskIdVec,\n@@ -254,13 +327,22 @@ impl AggregatedDataUpdate {\n     /// upper task.\n     fn from_task(task: &mut impl TaskGuard, current_session_id: SessionId) -> Self {\n         let aggregation = get_aggregation_number(task);\n-        let mut dirty_container_count = Default::default();\n+        let mut dirty_count = 0;\n+        let mut current_session_clean_count = 0;\n         let mut collectibles_update: Vec<_> =\n             get_many!(task, Collectible { collectible } count => (collectible, *count));\n         if is_aggregating_node(aggregation) {\n-            dirty_container_count = get!(task, AggregatedDirtyContainerCount)\n-                .cloned()\n+            dirty_count = get!(task, AggregatedDirtyContainerCount)\n+                .copied()\n                 .unwrap_or_default();\n+            current_session_clean_count = get!(\n+                task,\n+                AggregatedSessionDependentCleanContainerCount {\n+                    session_id: current_session_id\n+                }\n+            )\n+            .copied()\n+            .unwrap_or_default();\n             let collectibles = iter_many!(\n                 task,\n                 AggregatedCollectible {\n@@ -273,9 +355,6 @@ impl AggregatedDataUpdate {\n                 collectibles_update.push((collectible, 1));\n             }\n         }\n-        let mut dirty_count = dirty_container_count.count;\n-        let mut current_session_clean_count =\n-            dirty_container_count.current_session_clean(current_session_id);\n         let (dirty, current_session_clean) = task.dirty(current_session_id);\n         if dirty {\n             dirty_count += 1;\n@@ -410,56 +489,88 @@ impl AggregatedDataUpdate {\n             // compute aggregated update\n             let was_single_container_clean = old_dirty_single_container_count > 0\n                 && old_dirty_single_container_count\n-                    - old_single_container_current_session_clean_count\n-                    <= 0;\n+                    <= old_single_container_current_session_clean_count;\n             let is_single_container_clean = new_dirty_single_container_count > 0\n                 && new_dirty_single_container_count\n-                    - new_single_container_current_session_clean_count\n-                    <= 0;\n+                    <= new_single_container_current_session_clean_count;\n             let current_session_clean_update =\n                 before_after_to_diff_value(was_single_container_clean, is_single_container_clean);\n \n-            let aggregated_update = DirtyContainerCount::from_current_session_clean(\n-                dirty_container_count_update,\n-                current_session_id,\n-                current_session_clean_update,\n-            );\n+            if dirty_container_count_update != 0 || current_session_clean_update != 0 {\n+                let (is_self_dirty, current_session_self_clean) = task.dirty(current_session_id);\n \n-            if !aggregated_update.is_zero() {\n-                let dirtyness_and_session = task.dirtyness_and_session();\n                 let task_id = task.id();\n-                update!(task, AggregatedDirtyContainerCount, |old: Option<\n-                    DirtyContainerCount,\n-                >| {\n-                    let mut new = old.unwrap_or_default();\n-                    if let Some((dirtyness, clean_in_session)) = dirtyness_and_session {\n-                        new.update_with_dirtyness_and_session(dirtyness, clean_in_session);\n-                    }\n-                    let aggregated_update = new.update_count(&aggregated_update);\n-                    if let Some((dirtyness, clean_in_session)) = dirtyness_and_session {\n-                        new.undo_update_with_dirtyness_and_session(dirtyness, clean_in_session);\n-                    }\n-                    if !aggregated_update.is_zero() {\n-                        result.dirty_container_update = Some((\n-                            task_id,\n-                            aggregated_update.count,\n-                            SessionDependent::new(\n-                                aggregated_update.current_session_clean(current_session_id),\n-                            ),\n-                        ));\n-                    }\n-                    (!new.is_zero()).then_some(new)\n-                });\n-                if let Some((_, count, current_session_clean)) = result.dirty_container_update\n-                    && count - *current_session_clean < 0\n-                {\n-                    // When the current task is no longer dirty, we need to fire the\n-                    // aggregate root events and do some cleanup\n-                    if let Some(activeness_state) = get_mut!(task, Activeness) {\n-                        activeness_state.all_clean_event.notify(usize::MAX);\n-                        activeness_state.unset_active_until_clean();\n-                        if activeness_state.is_empty() {\n-                            task.remove(&CachedDataItemKey::Activeness {});\n+\n+                // Update AggregatedDirtyContainerCount and compute aggregate value\n+                let old_dirty_container_count;\n+                let new_dirty_container_count;\n+                if dirty_container_count_update != 0 {\n+                    new_dirty_container_count = update_count_and_get!(\n+                        task,\n+                        AggregatedDirtyContainerCount,\n+                        dirty_container_count_update\n+                    );\n+                    old_dirty_container_count =\n+                        new_dirty_container_count - dirty_container_count_update;\n+                } else {\n+                    new_dirty_container_count = get!(task, AggregatedDirtyContainerCount)\n+                        .copied()\n+                        .unwrap_or_default();\n+                    old_dirty_container_count = new_dirty_container_count;\n+                };\n+\n+                // Update AggregatedSessionDependentCleanContainerCount and compute aggregate value\n+                let new_current_session_clean_container_count;\n+                let old_current_session_clean_container_count;\n+                if current_session_clean_update != 0 {\n+                    new_current_session_clean_container_count = update_count_and_get!(\n+                        task,\n+                        AggregatedSessionDependentCleanContainerCount {\n+                            session_id: current_session_id\n+                        },\n+                        current_session_clean_update\n+                    );\n+                    old_current_session_clean_container_count =\n+                        new_current_session_clean_container_count - current_session_clean_update;\n+                } else {\n+                    new_current_session_clean_container_count = get!(\n+                        task,\n+                        AggregatedSessionDependentCleanContainerCount {\n+                            session_id: current_session_id\n+                        }\n+                    )\n+                    .copied()\n+                    .unwrap_or_default();\n+                    old_current_session_clean_container_count =\n+                        new_current_session_clean_container_count;\n+                };\n+\n+                let compute_result = ComputeDirtyAndCleanUpdate {\n+                    old_dirty_container_count,\n+                    new_dirty_container_count,\n+                    old_current_session_clean_container_count,\n+                    new_current_session_clean_container_count,\n+                    old_self_dirty: is_self_dirty,\n+                    new_self_dirty: is_self_dirty,\n+                    old_current_session_self_clean: current_session_self_clean,\n+                    new_current_session_self_clean: current_session_self_clean,\n+                }\n+                .compute();\n+\n+                if let Some(aggregated_update) = compute_result.aggregated_update(task_id) {\n+                    result = aggregated_update;\n+\n+                    if let Some((_, count, current_session_clean)) = result.dirty_container_update\n+                        && count - *current_session_clean < 0\n+                    {\n+                        // When the current task is no longer dirty, we need to fire the\n+                        // aggregate root events and do some cleanup\n+                        if let Some(activeness_state) = get_mut!(task, Activeness) {\n+                            activeness_state.all_clean_event.notify(usize::MAX);\n+                            activeness_state.unset_active_until_clean();\n+                            if activeness_state.is_empty() {\n+                                task.remove(&CachedDataItemKey::Activeness {});\n+                            }\n                         }\n                     }\n                 }"
        },
        {
            "sha": "6d2005eda5aa3e32df72727e46a914026129f3c5",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/invalidate.rs",
            "status": "modified",
            "additions": 57,
            "deletions": 41,
            "changes": 98,
            "blob_url": "https://github.com/vercel/next.js/blob/4795a00b60de95a33a9184d54f9dc39cef302e3d/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4795a00b60de95a33a9184d54f9dc39cef302e3d/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Finvalidate.rs?ref=4795a00b60de95a33a9184d54f9dc39cef302e3d",
            "patch": "@@ -8,7 +8,7 @@ use crate::{\n         operation::{\n             ExecuteContext, Operation, TaskGuard,\n             aggregation_update::{\n-                AggregatedDataUpdate, AggregationUpdateJob, AggregationUpdateQueue,\n+                AggregationUpdateJob, AggregationUpdateQueue, ComputeDirtyAndCleanUpdate,\n             },\n         },\n         storage::{get, get_mut, remove},\n@@ -234,7 +234,7 @@ pub fn make_task_dirty_internal(\n     let old = task.insert(CachedDataItem::Dirty {\n         value: Dirtyness::Dirty,\n     });\n-    let mut dirty_container = match old {\n+    let (old_self_dirty, old_current_session_self_clean) = match old {\n         Some(CachedDataItemValue::Dirty {\n             value: Dirtyness::Dirty,\n         }) => {\n@@ -252,38 +252,48 @@ pub fn make_task_dirty_internal(\n         Some(CachedDataItemValue::Dirty {\n             value: Dirtyness::SessionDependent,\n         }) => {\n+            // It was a session-dependent dirty before, so we need to remove that clean count\n             let old = remove!(task, CleanInSession);\n-            match old {\n-                None => {\n-                    #[cfg(feature = \"trace_task_dirty\")]\n-                    let _span = tracing::trace_span!(\n-                        \"session-dependent task already dirty\",\n-                        name = ctx.get_task_description(task_id),\n-                        cause = %TaskDirtyCauseInContext::new(&cause, ctx)\n-                    )\n-                    .entered();\n-                    // already dirty\n-                    return;\n-                }\n-                Some(session_id) => {\n-                    // Got dirty in that one session only\n-                    let mut dirty_container = get!(task, AggregatedDirtyContainerCount)\n-                        .cloned()\n-                        .unwrap_or_default();\n-                    dirty_container.update_session_dependent(session_id, 1);\n-                    dirty_container\n-                }\n+            if let Some(session_id) = old\n+                && session_id == ctx.session_id()\n+            {\n+                // There was a clean count for a session. If it was the current session, we need to\n+                // propagate that change.\n+                (true, true)\n+            } else {\n+                #[cfg(feature = \"trace_task_dirty\")]\n+                let _span = tracing::trace_span!(\n+                    \"session-dependent task already dirty\",\n+                    name = ctx.get_task_description(task_id),\n+                    cause = %TaskDirtyCauseInContext::new(&cause, ctx)\n+                )\n+                .entered();\n+                // already dirty\n+                return;\n             }\n         }\n         None => {\n-            // Get dirty for all sessions\n-            get!(task, AggregatedDirtyContainerCount)\n-                .cloned()\n-                .unwrap_or_default()\n+            // It was clean before, so we need to increase the dirty count\n+            (false, false)\n         }\n         _ => unreachable!(),\n     };\n \n+    let new_self_dirty = true;\n+    let new_current_session_self_clean = false;\n+\n+    let dirty_container_count = get!(task, AggregatedDirtyContainerCount)\n+        .copied()\n+        .unwrap_or_default();\n+    let current_session_clean_container_count = get!(\n+        task,\n+        AggregatedSessionDependentCleanContainerCount {\n+            session_id: ctx.session_id(),\n+        }\n+    )\n+    .copied()\n+    .unwrap_or_default();\n+\n     #[cfg(feature = \"trace_task_dirty\")]\n     let _span = tracing::trace_span!(\n         \"make task dirty\",\n@@ -293,21 +303,27 @@ pub fn make_task_dirty_internal(\n     )\n     .entered();\n \n-    let should_schedule = {\n-        let aggregated_update =\n-            dirty_container.update_with_dirtyness_and_session(Dirtyness::Dirty, None);\n-        if !aggregated_update.is_zero() {\n-            queue.extend(AggregationUpdateJob::data_update(\n-                &mut task,\n-                AggregatedDataUpdate::new().dirty_container_update(\n-                    task_id,\n-                    aggregated_update.count,\n-                    aggregated_update.current_session_clean(ctx.session_id()),\n-                ),\n-            ));\n-        }\n-        !ctx.should_track_activeness() || task.has_key(&CachedDataItemKey::Activeness {})\n-    };\n+    let result = ComputeDirtyAndCleanUpdate {\n+        old_dirty_container_count: dirty_container_count,\n+        new_dirty_container_count: dirty_container_count,\n+        old_current_session_clean_container_count: current_session_clean_container_count,\n+        new_current_session_clean_container_count: current_session_clean_container_count,\n+        old_self_dirty,\n+        new_self_dirty,\n+        old_current_session_self_clean,\n+        new_current_session_self_clean,\n+    }\n+    .compute();\n+\n+    if let Some(aggregated_update) = result.aggregated_update(task_id) {\n+        queue.extend(AggregationUpdateJob::data_update(\n+            &mut task,\n+            aggregated_update,\n+        ));\n+    }\n+\n+    let should_schedule =\n+        !ctx.should_track_activeness() || task.has_key(&CachedDataItemKey::Activeness {});\n \n     if should_schedule {\n         let description = || ctx.get_task_desc_fn(task_id);"
        },
        {
            "sha": "ffc103e1d703d5bc24c7abb4b74806b8e15c6732",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 7,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/4795a00b60de95a33a9184d54f9dc39cef302e3d/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4795a00b60de95a33a9184d54f9dc39cef302e3d/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=4795a00b60de95a33a9184d54f9dc39cef302e3d",
            "patch": "@@ -25,7 +25,7 @@ use crate::{\n     backing_storage::BackingStorage,\n     data::{\n         CachedDataItem, CachedDataItemKey, CachedDataItemType, CachedDataItemValue,\n-        CachedDataItemValueRef, CachedDataItemValueRefMut, DirtyContainerCount, Dirtyness,\n+        CachedDataItemValueRef, CachedDataItemValueRefMut, Dirtyness,\n     },\n };\n \n@@ -469,10 +469,20 @@ pub trait TaskGuard: Debug {\n         )\n     }\n \n-    fn dirty_container_count(&self) -> DirtyContainerCount {\n-        get!(self, AggregatedDirtyContainerCount)\n-            .cloned()\n-            .unwrap_or_default()\n+    fn has_dirty_containers(&self, session_id: SessionId) -> bool {\n+        let dirty_count = get!(self, AggregatedDirtyContainerCount)\n+            .copied()\n+            .unwrap_or_default();\n+        if dirty_count <= 0 {\n+            return false;\n+        }\n+        let clean_count = get!(\n+            self,\n+            AggregatedSessionDependentCleanContainerCount { session_id }\n+        )\n+        .copied()\n+        .unwrap_or_default();\n+        dirty_count > clean_count\n     }\n }\n \n@@ -799,8 +809,8 @@ impl_operation!(AggregationUpdate aggregation_update::AggregationUpdateQueue);\n pub use self::invalidate::TaskDirtyCause;\n pub use self::{\n     aggregation_update::{\n-        AggregatedDataUpdate, AggregationUpdateJob, get_aggregation_number, get_uppers,\n-        is_aggregating_node, is_root_node,\n+        AggregatedDataUpdate, AggregationUpdateJob, ComputeDirtyAndCleanUpdate,\n+        get_aggregation_number, get_uppers, is_aggregating_node, is_root_node,\n     },\n     cleanup_old_edges::OutdatedEdge,\n     connect_children::connect_children,"
        },
        {
            "sha": "54763bf9c70c5ea24fd41b91e27cb9884042f789",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 360,
            "changes": 370,
            "blob_url": "https://github.com/vercel/next.js/blob/4795a00b60de95a33a9184d54f9dc39cef302e3d/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4795a00b60de95a33a9184d54f9dc39cef302e3d/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs?ref=4795a00b60de95a33a9184d54f9dc39cef302e3d",
            "patch": "@@ -1,5 +1,3 @@\n-use std::cmp::Ordering;\n-\n use rustc_hash::FxHashSet;\n use serde::{Deserialize, Serialize};\n use turbo_tasks::{\n@@ -149,363 +147,6 @@ pub enum Dirtyness {\n     SessionDependent,\n }\n \n-fn add_with_diff(v: &mut i32, u: i32) -> i32 {\n-    let old = *v;\n-    *v += u;\n-    if old <= 0 && *v > 0 {\n-        1\n-    } else if old > 0 && *v <= 0 {\n-        -1\n-    } else {\n-        0\n-    }\n-}\n-\n-/// Represents a count of dirty containers. Since dirtiness can be session dependent, there might be\n-/// a different count for a specific session. It only need to store the highest session count, since\n-/// old sessions can't be visited again, so we can ignore their counts.\n-#[derive(Debug, Default, Clone, Serialize, Deserialize, PartialEq, Eq)]\n-pub struct DirtyContainerCount {\n-    pub count: i32,\n-    pub count_in_session: Option<(SessionId, i32)>,\n-}\n-\n-impl DirtyContainerCount {\n-    pub fn from_current_session_clean(\n-        count: i32,\n-        current_session_id: SessionId,\n-        current_session_clean: i32,\n-    ) -> DirtyContainerCount {\n-        DirtyContainerCount {\n-            count,\n-            count_in_session: Some((current_session_id, count - current_session_clean)),\n-        }\n-    }\n-\n-    pub fn current_session_clean(&self, current_session_id: SessionId) -> i32 {\n-        if let Some((s, c)) = self.count_in_session\n-            && s == current_session_id\n-        {\n-            return self.count - c;\n-        }\n-        0\n-    }\n-\n-    /// Get the count for a specific session. It's only expected to be asked for the current\n-    /// session, since old session counts might be dropped.\n-    pub fn get(&self, session: SessionId) -> i32 {\n-        if let Some((s, count)) = self.count_in_session\n-            && s == session\n-        {\n-            return count;\n-        }\n-        self.count\n-    }\n-\n-    /// Increase/decrease the count by the given value.\n-    pub fn update(&mut self, count: i32) -> DirtyContainerCount {\n-        self.update_count(&DirtyContainerCount {\n-            count,\n-            count_in_session: None,\n-        })\n-    }\n-\n-    /// Increase/decrease the count by the given value, but does not update the count for a specific\n-    /// session. This matches the \"dirty, but clean in one session\" behavior.\n-    pub fn update_session_dependent(\n-        &mut self,\n-        ignore_session: SessionId,\n-        count: i32,\n-    ) -> DirtyContainerCount {\n-        self.update_count(&DirtyContainerCount {\n-            count,\n-            count_in_session: Some((ignore_session, 0)),\n-        })\n-    }\n-\n-    /// Adds the `count` to the current count. This correctly handles session dependent counts.\n-    /// Returns a new count object that represents the aggregated count. The aggregated count will\n-    /// be +1 when the self count changes from <= 0 to > 0 and -1 when the self count changes from >\n-    /// 0 to <= 0. The same for the session dependent count.\n-    pub fn update_count(&mut self, count: &DirtyContainerCount) -> DirtyContainerCount {\n-        let mut diff = DirtyContainerCount::default();\n-        match (\n-            self.count_in_session.as_mut(),\n-            count.count_in_session.as_ref(),\n-        ) {\n-            (None, None) => {}\n-            (Some((s, c)), None) => {\n-                let d = add_with_diff(c, count.count);\n-                diff.count_in_session = Some((*s, d));\n-            }\n-            (None, Some((s, c))) => {\n-                let mut new = self.count;\n-                let d = add_with_diff(&mut new, *c);\n-                self.count_in_session = Some((*s, new));\n-                diff.count_in_session = Some((*s, d));\n-            }\n-            (Some((s1, c1)), Some((s2, c2))) => match (*s1).cmp(s2) {\n-                Ordering::Less => {\n-                    let mut new = self.count;\n-                    let d = add_with_diff(&mut new, *c2);\n-                    self.count_in_session = Some((*s2, new));\n-                    diff.count_in_session = Some((*s2, d));\n-                }\n-                Ordering::Equal => {\n-                    let d = add_with_diff(c1, *c2);\n-                    diff.count_in_session = Some((*s1, d));\n-                }\n-                Ordering::Greater => {\n-                    let d = add_with_diff(c1, count.count);\n-                    diff.count_in_session = Some((*s1, d));\n-                }\n-            },\n-        }\n-        let d = add_with_diff(&mut self.count, count.count);\n-        diff.count = d;\n-        diff\n-    }\n-\n-    /// Applies a dirtyness to the count. Returns an aggregated count that represents the change.\n-    pub fn update_with_dirtyness_and_session(\n-        &mut self,\n-        dirtyness: Dirtyness,\n-        clean_in_session: Option<SessionId>,\n-    ) -> DirtyContainerCount {\n-        if let (Dirtyness::SessionDependent, Some(session_id)) = (dirtyness, clean_in_session) {\n-            self.update_session_dependent(session_id, 1)\n-        } else {\n-            self.update(1)\n-        }\n-    }\n-\n-    /// Undoes the effect of a dirtyness on the count. Returns an aggregated count that represents\n-    /// the change.\n-    pub fn undo_update_with_dirtyness_and_session(\n-        &mut self,\n-        dirtyness: Dirtyness,\n-        clean_in_session: Option<SessionId>,\n-    ) -> DirtyContainerCount {\n-        if let (Dirtyness::SessionDependent, Some(session_id)) = (dirtyness, clean_in_session) {\n-            self.update_session_dependent(session_id, -1)\n-        } else {\n-            self.update(-1)\n-        }\n-    }\n-\n-    /// Replaces the old dirtyness with the new one. Returns an aggregated count that represents\n-    /// the change.\n-    pub fn replace_dirtyness_and_session(\n-        &mut self,\n-        old_dirtyness: Dirtyness,\n-        old_clean_in_session: Option<SessionId>,\n-        new_dirtyness: Dirtyness,\n-        new_clean_in_session: Option<SessionId>,\n-    ) -> DirtyContainerCount {\n-        let mut diff =\n-            self.undo_update_with_dirtyness_and_session(old_dirtyness, old_clean_in_session);\n-        diff.update_count(\n-            &self.update_with_dirtyness_and_session(new_dirtyness, new_clean_in_session),\n-        );\n-        diff\n-    }\n-\n-    /// Returns true if the count is zero and applying it would have no effect\n-    pub fn is_zero(&self) -> bool {\n-        self.count == 0 && self.count_in_session.map(|(_, c)| c == 0).unwrap_or(true)\n-    }\n-\n-    /// Negates the counts.\n-    pub fn negate(&self) -> Self {\n-        Self {\n-            count: -self.count,\n-            count_in_session: self.count_in_session.map(|(s, c)| (s, -c)),\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod dirty_container_count_tests {\n-    use turbo_tasks::SessionId;\n-\n-    use super::*;\n-\n-    const SESSION_1: SessionId = unsafe { SessionId::new_unchecked(1) };\n-    const SESSION_2: SessionId = unsafe { SessionId::new_unchecked(2) };\n-    const SESSION_3: SessionId = unsafe { SessionId::new_unchecked(3) };\n-\n-    #[test]\n-    fn test_update() {\n-        let mut count = DirtyContainerCount::default();\n-        assert!(count.is_zero());\n-\n-        let diff = count.update(1);\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 1);\n-        assert_eq!(diff.get(SESSION_1), 1);\n-        assert_eq!(count.get(SESSION_2), 1);\n-        assert_eq!(diff.get(SESSION_2), 1);\n-\n-        let diff = count.update(-1);\n-        assert!(count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 0);\n-        assert_eq!(diff.get(SESSION_1), -1);\n-        assert_eq!(count.get(SESSION_2), 0);\n-        assert_eq!(diff.get(SESSION_2), -1);\n-\n-        let diff = count.update(2);\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 2);\n-        assert_eq!(diff.get(SESSION_1), 1);\n-        assert_eq!(count.get(SESSION_2), 2);\n-        assert_eq!(diff.get(SESSION_2), 1);\n-\n-        let diff = count.update(-1);\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 1);\n-        assert_eq!(diff.get(SESSION_1), 0);\n-        assert_eq!(count.get(SESSION_2), 1);\n-        assert_eq!(diff.get(SESSION_2), 0);\n-\n-        let diff = count.update(-1);\n-        assert!(count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 0);\n-        assert_eq!(diff.get(SESSION_1), -1);\n-        assert_eq!(count.get(SESSION_2), 0);\n-        assert_eq!(diff.get(SESSION_2), -1);\n-\n-        let diff = count.update(-1);\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), -1);\n-        assert_eq!(diff.get(SESSION_1), 0);\n-        assert_eq!(count.get(SESSION_2), -1);\n-        assert_eq!(diff.get(SESSION_2), 0);\n-\n-        let diff = count.update(2);\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 1);\n-        assert_eq!(diff.get(SESSION_1), 1);\n-        assert_eq!(count.get(SESSION_2), 1);\n-        assert_eq!(diff.get(SESSION_2), 1);\n-\n-        let diff = count.update(-2);\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), -1);\n-        assert_eq!(diff.get(SESSION_1), -1);\n-        assert_eq!(count.get(SESSION_2), -1);\n-        assert_eq!(diff.get(SESSION_2), -1);\n-\n-        let diff = count.update(1);\n-        assert!(count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 0);\n-        assert_eq!(diff.get(SESSION_1), 0);\n-        assert_eq!(count.get(SESSION_2), 0);\n-        assert_eq!(diff.get(SESSION_2), 0);\n-    }\n-\n-    #[test]\n-    fn test_session_dependent() {\n-        let mut count = DirtyContainerCount::default();\n-        assert!(count.is_zero());\n-\n-        let diff = count.update_session_dependent(SESSION_1, 1);\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 0);\n-        assert_eq!(diff.get(SESSION_1), 0);\n-        assert_eq!(count.get(SESSION_2), 1);\n-        assert_eq!(diff.get(SESSION_2), 1);\n-\n-        let diff = count.update_session_dependent(SESSION_1, -1);\n-        assert!(count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 0);\n-        assert_eq!(diff.get(SESSION_1), 0);\n-        assert_eq!(count.get(SESSION_2), 0);\n-        assert_eq!(diff.get(SESSION_2), -1);\n-\n-        let diff = count.update_session_dependent(SESSION_1, 2);\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 0);\n-        assert_eq!(diff.get(SESSION_1), 0);\n-        assert_eq!(count.get(SESSION_2), 2);\n-        assert_eq!(diff.get(SESSION_2), 1);\n-\n-        let diff = count.update_session_dependent(SESSION_2, -2);\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 0);\n-        assert_eq!(diff.get(SESSION_1), -1);\n-        assert_eq!(count.get(SESSION_2), 2);\n-        assert_eq!(diff.get(SESSION_2), 0);\n-        assert_eq!(count.get(SESSION_3), 0);\n-        assert_eq!(diff.get(SESSION_3), -1);\n-    }\n-\n-    #[test]\n-    fn test_update_with_dirtyness_and_session() {\n-        let mut count = DirtyContainerCount::default();\n-        let diff = count.update_with_dirtyness_and_session(Dirtyness::Dirty, None);\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 1);\n-        assert_eq!(diff.get(SESSION_1), 1);\n-        assert_eq!(count.get(SESSION_2), 1);\n-        assert_eq!(diff.get(SESSION_2), 1);\n-\n-        let diff = count.undo_update_with_dirtyness_and_session(Dirtyness::Dirty, None);\n-        assert!(count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 0);\n-        assert_eq!(diff.get(SESSION_1), -1);\n-        assert_eq!(count.get(SESSION_2), 0);\n-        assert_eq!(diff.get(SESSION_2), -1);\n-\n-        let mut count = DirtyContainerCount::default();\n-        let diff =\n-            count.update_with_dirtyness_and_session(Dirtyness::SessionDependent, Some(SESSION_1));\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 0);\n-        assert_eq!(diff.get(SESSION_1), 0);\n-        assert_eq!(count.get(SESSION_2), 1);\n-        assert_eq!(diff.get(SESSION_2), 1);\n-\n-        let diff = count\n-            .undo_update_with_dirtyness_and_session(Dirtyness::SessionDependent, Some(SESSION_1));\n-        assert!(count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 0);\n-        assert_eq!(diff.get(SESSION_1), 0);\n-        assert_eq!(count.get(SESSION_2), 0);\n-        assert_eq!(diff.get(SESSION_2), -1);\n-    }\n-\n-    #[test]\n-    fn test_replace_dirtyness_and_session() {\n-        let mut count = DirtyContainerCount::default();\n-        count.update_with_dirtyness_and_session(Dirtyness::Dirty, None);\n-        let diff = count.replace_dirtyness_and_session(\n-            Dirtyness::Dirty,\n-            None,\n-            Dirtyness::SessionDependent,\n-            Some(SESSION_1),\n-        );\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 0);\n-        assert_eq!(diff.get(SESSION_1), -1);\n-        assert_eq!(count.get(SESSION_2), 1);\n-        assert_eq!(diff.get(SESSION_2), 0);\n-\n-        let mut count = DirtyContainerCount::default();\n-        count.update_with_dirtyness_and_session(Dirtyness::SessionDependent, Some(SESSION_1));\n-        let diff = count.replace_dirtyness_and_session(\n-            Dirtyness::SessionDependent,\n-            Some(SESSION_1),\n-            Dirtyness::Dirty,\n-            None,\n-        );\n-        assert!(!count.is_zero());\n-        assert_eq!(count.get(SESSION_1), 1);\n-        assert_eq!(diff.get(SESSION_1), 1);\n-        assert_eq!(count.get(SESSION_2), 1);\n-        assert_eq!(diff.get(SESSION_2), 0);\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy)]\n pub enum RootType {\n     RootTask,\n@@ -665,7 +306,11 @@ pub enum CachedDataItem {\n         value: i32,\n     },\n     AggregatedDirtyContainerCount {\n-        value: DirtyContainerCount,\n+        value: i32,\n+    },\n+    AggregatedSessionDependentCleanContainerCount {\n+        session_id: SessionId,\n+        value: i32,\n     },\n \n     // Flags\n@@ -746,6 +391,7 @@ impl CachedDataItem {\n                 !collectible.cell.task.is_transient()\n             }\n             CachedDataItem::AggregatedDirtyContainerCount { .. } => true,\n+            CachedDataItem::AggregatedSessionDependentCleanContainerCount { .. } => true,\n             CachedDataItem::Stateful { .. } => true,\n             CachedDataItem::HasInvalidator { .. } => true,\n             CachedDataItem::Immutable { .. } => true,\n@@ -819,6 +465,7 @@ impl CachedDataItem {\n             | Self::AggregatedSessionDependentCleanContainer { .. }\n             | Self::AggregatedCollectible { .. }\n             | Self::AggregatedDirtyContainerCount { .. }\n+            | Self::AggregatedSessionDependentCleanContainerCount { .. }\n             | Self::Stateful { .. }\n             | Self::HasInvalidator { .. }\n             | Self::Immutable { .. }\n@@ -868,6 +515,7 @@ impl CachedDataItemKey {\n                 !collectible.cell.task.is_transient()\n             }\n             CachedDataItemKey::AggregatedDirtyContainerCount { .. } => true,\n+            CachedDataItemKey::AggregatedSessionDependentCleanContainerCount { .. } => true,\n             CachedDataItemKey::Stateful { .. } => true,\n             CachedDataItemKey::HasInvalidator { .. } => true,\n             CachedDataItemKey::Immutable { .. } => true,\n@@ -909,6 +557,7 @@ impl CachedDataItemType {\n             | Self::AggregatedSessionDependentCleanContainer { .. }\n             | Self::AggregatedCollectible { .. }\n             | Self::AggregatedDirtyContainerCount { .. }\n+            | Self::AggregatedSessionDependentCleanContainerCount { .. }\n             | Self::Stateful { .. }\n             | Self::HasInvalidator { .. }\n             | Self::Immutable { .. }\n@@ -946,6 +595,7 @@ impl CachedDataItemType {\n             | Self::AggregatedSessionDependentCleanContainer\n             | Self::AggregatedCollectible\n             | Self::AggregatedDirtyContainerCount\n+            | Self::AggregatedSessionDependentCleanContainerCount\n             | Self::Stateful\n             | Self::HasInvalidator\n             | Self::Immutable => true,"
        }
    ],
    "stats": {
        "total": 859,
        "additions": 334,
        "deletions": 525
    }
}