{
    "author": "sokra",
    "message": "Turbopack: avoid snapshotting while continuously idle, fix spans  (#86611)\n\n### What?\n\nWhile idle only snapshot once. Start snapshotting again when idle has been left.\n\nPlace persisting spans on top level.\n\nFix some missing spans.",
    "sha": "86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c",
    "files": [
        {
            "sha": "72d1f61baf5e4166f52aeced7c3d9a3a1472a679",
            "filename": "crates/napi/src/next_api/project.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 7,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnapi%2Fsrc%2Fnext_api%2Fproject.rs?ref=86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c",
            "patch": "@@ -405,8 +405,14 @@ pub fn project_new(\n     }\n     let mut compress = Compression::None;\n     if let Some(mut trace) = trace {\n+        let internal_dir = PathBuf::from(&options.root_path)\n+            .join(&options.project_path)\n+            .join(&options.dist_dir);\n+        let trace_file = internal_dir.join(\"trace-turbopack\");\n+\n         println!(\"Turbopack tracing enabled with targets: {trace}\");\n         println!(\"  Note that this might have a small performance impact.\");\n+        println!(\"  Trace output will be written to {}\", trace_file.display());\n \n         trace = trace\n             .split(\",\")\n@@ -441,27 +447,20 @@ pub fn project_new(\n \n         let subscriber = subscriber.with(FilterLayer::try_new(&trace).unwrap());\n \n-        let internal_dir = PathBuf::from(&options.root_path)\n-            .join(&options.project_path)\n-            .join(&options.dist_dir);\n         std::fs::create_dir_all(&internal_dir)\n             .context(\"Unable to create .next directory\")\n             .unwrap();\n-        let trace_file;\n         let (trace_writer, trace_writer_guard) = match compress {\n             Compression::None => {\n-                trace_file = internal_dir.join(\"trace-turbopack\");\n                 let trace_writer = std::fs::File::create(trace_file.clone()).unwrap();\n                 TraceWriter::new(trace_writer)\n             }\n             Compression::GzipFast => {\n-                trace_file = internal_dir.join(\"trace-turbopack\");\n                 let trace_writer = std::fs::File::create(trace_file.clone()).unwrap();\n                 let trace_writer = GzEncoder::new(trace_writer, flate2::Compression::fast());\n                 TraceWriter::new(trace_writer)\n             }\n             Compression::GzipBest => {\n-                trace_file = internal_dir.join(\"trace-turbopack\");\n                 let trace_writer = std::fs::File::create(trace_file.clone()).unwrap();\n                 let trace_writer = GzEncoder::new(trace_writer, flate2::Compression::best());\n                 TraceWriter::new(trace_writer)"
        },
        {
            "sha": "f1c03d1b58cfcdbb71e12add71e2e6b880a8a176",
            "filename": "turbopack/crates/turbo-persistence/src/db.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-persistence%2Fsrc%2Fdb.rs?ref=86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c",
            "patch": "@@ -489,6 +489,7 @@ impl<S: ParallelScheduler> TurboPersistence<S> {\n \n         new_meta_files.sort_unstable_by_key(|(seq, _)| *seq);\n \n+        let sync_span = tracing::info_span!(\"sync new files\").entered();\n         let mut new_meta_files = self\n             .parallel_scheduler\n             .parallel_map_collect_owned::<_, _, Result<Vec<_>>>(new_meta_files, |(seq, file)| {\n@@ -511,6 +512,7 @@ impl<S: ParallelScheduler> TurboPersistence<S> {\n             }\n             anyhow::Ok(())\n         })?;\n+        drop(sync_span);\n \n         let new_meta_info = new_meta_files\n             .iter()"
        },
        {
            "sha": "9cf0e2b7e3097c1aa8f2b4b3b307f67feb11a173",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 60,
            "deletions": 47,
            "changes": 107,
            "blob_url": "https://github.com/vercel/next.js/blob/86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c",
            "patch": "@@ -24,7 +24,7 @@ use parking_lot::{Condvar, Mutex};\n use rustc_hash::{FxHashMap, FxHashSet, FxHasher};\n use smallvec::{SmallVec, smallvec};\n use tokio::time::{Duration, Instant};\n-use tracing::{Span, info_span, trace_span};\n+use tracing::{Span, trace_span};\n use turbo_tasks::{\n     CellId, FxDashMap, FxIndexMap, KeyValuePair, RawVc, ReadCellOptions, ReadConsistency,\n     ReadOutputOptions, ReadTracking, SessionId, TRANSIENT_TASK_BIT, TaskExecutionReason, TaskId,\n@@ -1002,26 +1002,38 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         }\n     }\n \n-    fn snapshot(&self) -> Option<(Instant, bool)> {\n+    fn snapshot_and_persist(\n+        &self,\n+        parent_span: Option<tracing::Id>,\n+        reason: &str,\n+    ) -> Option<(Instant, bool)> {\n+        let snapshot_span =\n+            tracing::trace_span!(parent: parent_span.clone(), \"snapshot\", reason = reason)\n+                .entered();\n         let start = Instant::now();\n         debug_assert!(self.should_persist());\n-        let mut snapshot_request = self.snapshot_request.lock();\n-        snapshot_request.snapshot_requested = true;\n-        let active_operations = self\n-            .in_progress_operations\n-            .fetch_or(SNAPSHOT_REQUESTED_BIT, Ordering::Relaxed);\n-        if active_operations != 0 {\n-            self.operations_suspended\n-                .wait_while(&mut snapshot_request, |_| {\n-                    self.in_progress_operations.load(Ordering::Relaxed) != SNAPSHOT_REQUESTED_BIT\n-                });\n+\n+        let suspended_operations;\n+        {\n+            let _span = tracing::info_span!(\"blocking\").entered();\n+            let mut snapshot_request = self.snapshot_request.lock();\n+            snapshot_request.snapshot_requested = true;\n+            let active_operations = self\n+                .in_progress_operations\n+                .fetch_or(SNAPSHOT_REQUESTED_BIT, Ordering::Relaxed);\n+            if active_operations != 0 {\n+                self.operations_suspended\n+                    .wait_while(&mut snapshot_request, |_| {\n+                        self.in_progress_operations.load(Ordering::Relaxed)\n+                            != SNAPSHOT_REQUESTED_BIT\n+                    });\n+            }\n+            suspended_operations = snapshot_request\n+                .suspended_operations\n+                .iter()\n+                .map(|op| op.arc().clone())\n+                .collect::<Vec<_>>();\n         }\n-        let suspended_operations = snapshot_request\n-            .suspended_operations\n-            .iter()\n-            .map(|op| op.arc().clone())\n-            .collect::<Vec<_>>();\n-        drop(snapshot_request);\n         self.storage.start_snapshot();\n         let mut persisted_task_cache_log = self\n             .persisted_task_cache_log\n@@ -1105,11 +1117,9 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             )\n         };\n \n-        let snapshot = {\n-            let _span = tracing::trace_span!(\"take snapshot\");\n-            self.storage\n-                .take_snapshot(&preprocess, &process, &process_snapshot)\n-        };\n+        let snapshot = self\n+            .storage\n+            .take_snapshot(&preprocess, &process, &process_snapshot);\n \n         #[cfg(feature = \"print_cache_item_size\")]\n         #[derive(Default)]\n@@ -1195,10 +1205,14 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         swap_retain(&mut persisted_task_cache_log, |shard| !shard.is_empty());\n \n-        let mut new_items = false;\n+        drop(snapshot_span);\n \n-        if !persisted_task_cache_log.is_empty() || !task_snapshots.is_empty() {\n-            new_items = true;\n+        if persisted_task_cache_log.is_empty() && task_snapshots.is_empty() {\n+            return Some((snapshot_time, false));\n+        }\n+\n+        let _span = tracing::info_span!(parent: parent_span, \"persist\", reason = reason).entered();\n+        {\n             if let Err(err) = self.backing_storage.save_snapshot(\n                 self.session_id,\n                 suspended_operations,\n@@ -1240,18 +1254,16 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             }\n         }\n \n-        if new_items {\n-            let elapsed = start.elapsed();\n-            // avoid spamming the event queue with information about fast operations\n-            if elapsed > Duration::from_secs(10) {\n-                turbo_tasks().send_compilation_event(Arc::new(TimingEvent::new(\n-                    \"Finished writing to filesystem cache\".to_string(),\n-                    elapsed,\n-                )));\n-            }\n+        let elapsed = start.elapsed();\n+        // avoid spamming the event queue with information about fast operations\n+        if elapsed > Duration::from_secs(10) {\n+            turbo_tasks().send_compilation_event(Arc::new(TimingEvent::new(\n+                \"Finished writing to filesystem cache\".to_string(),\n+                elapsed,\n+            )));\n         }\n \n-        Some((snapshot_time, new_items))\n+        Some((snapshot_time, true))\n     }\n \n     fn startup(&self, turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>) {\n@@ -1273,7 +1285,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         if self.should_persist() {\n             // Schedule the snapshot job\n-            let _span = Span::none().entered();\n+            let _span = trace_span!(\"persisting background job\").entered();\n+            let _span = tracing::info_span!(\"thread\").entered();\n             turbo_tasks.schedule_backend_background_job(TurboTasksBackendJob::InitialSnapshot);\n         }\n     }\n@@ -1291,8 +1304,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             self.verify_aggregation_graph(turbo_tasks, false);\n         }\n         if self.should_persist() {\n-            let _span = tracing::info_span!(\"persist on stop\").entered();\n-            self.snapshot();\n+            self.snapshot_and_persist(Span::current().into(), \"stop\");\n         }\n         self.task_cache.drop_contents();\n         drop_contents(&self.transient_tasks);\n@@ -2477,6 +2489,9 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n                     let last_snapshot = self.last_snapshot.load(Ordering::Relaxed);\n                     let mut last_snapshot = self.start_time + Duration::from_millis(last_snapshot);\n+                    let mut idle_start_listener = self.idle_start_event.listen();\n+                    let mut idle_end_listener = self.idle_end_event.listen();\n+                    let mut fresh_idle = true;\n                     loop {\n                         const FIRST_SNAPSHOT_WAIT: Duration = Duration::from_secs(300);\n                         const SNAPSHOT_INTERVAL: Duration = Duration::from_secs(120);\n@@ -2494,9 +2509,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                             if self.stopping.load(Ordering::Acquire) {\n                                 return;\n                             }\n-                            let mut idle_start_listener = self.idle_start_event.listen();\n-                            let mut idle_end_listener = self.idle_end_event.listen();\n-                            let mut idle_time = if turbo_tasks.is_idle() {\n+                            let mut idle_time = if turbo_tasks.is_idle() && fresh_idle {\n                                 Instant::now() + idle_timeout\n                             } else {\n                                 far_future()\n@@ -2507,6 +2520,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                                         return;\n                                     },\n                                     _ = &mut idle_start_listener => {\n+                                        fresh_idle = true;\n                                         idle_time = Instant::now() + idle_timeout;\n                                         idle_start_listener = self.idle_start_event.listen()\n                                     },\n@@ -2527,12 +2541,12 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                             }\n                         }\n \n-                        let _span = info_span!(\"persist\", reason = reason).entered();\n                         let this = self.clone();\n-                        let snapshot = this.snapshot();\n+                        let snapshot = this.snapshot_and_persist(None, reason);\n                         if let Some((snapshot_start, new_data)) = snapshot {\n                             last_snapshot = snapshot_start;\n-                            if new_data {\n+                            if !new_data {\n+                                fresh_idle = false;\n                                 continue;\n                             }\n                             let last_snapshot = last_snapshot.duration_since(self.start_time);\n@@ -2541,7 +2555,6 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                                 Ordering::Relaxed,\n                             );\n \n-                            let _span = Span::none().entered();\n                             turbo_tasks.schedule_backend_background_job(\n                                 TurboTasksBackendJob::FollowUpSnapshot,\n                             );\n@@ -2550,7 +2563,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     }\n                 }\n                 TurboTasksBackendJob::Prefetch { data, range } => {\n-                    let range = if let Some(range) = range {\n+                    let range: Range<usize> = if let Some(range) = range {\n                         range\n                     } else {\n                         if data.len() > 128 {"
        },
        {
            "sha": "d0eaff2554ac27f33b7fed8fcbb02ba8fe34ace0",
            "filename": "turbopack/crates/turbo-tasks-backend/src/kv_backing_storage.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs?ref=86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c",
            "patch": "@@ -317,7 +317,7 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n             > + Send\n             + Sync,\n     {\n-        let _span = tracing::trace_span!(\"save snapshot\", session_id = ?session_id, operations = operations.len());\n+        let _span = tracing::info_span!(\"save snapshot\", session_id = ?session_id, operations = operations.len()).entered();\n         let mut batch = self.inner.database.write_batch()?;\n \n         // Start organizing the updates in parallel"
        },
        {
            "sha": "b2f4dd664c4a297617d99b8851c479e456ba2f8a",
            "filename": "turbopack/crates/turbopack-trace-server/src/span_ref.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fspan_ref.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fspan_ref.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-trace-server%2Fsrc%2Fspan_ref.rs?ref=86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c",
            "patch": "@@ -475,7 +475,7 @@ impl<'a> SpanRef<'a> {\n                             .and_modify(|_, v| v.push(span.index()))\n                             .or_insert_with(|| (format!(\"{name}={value}\"), vec![span.index()]));\n                     }\n-                    if !span.is_complete() && !span.time_data().ignore_self_time {\n+                    if !span.is_complete() && span.span.name != \"thread\" {\n                         let name = \"incomplete_span\";\n                         index\n                             .raw_entry_mut()"
        },
        {
            "sha": "fea6abdf31c0f1d5f80c83defa16f9e1edab1722",
            "filename": "turbopack/crates/turbopack-trace-utils/src/tracing_presets.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c/turbopack%2Fcrates%2Fturbopack-trace-utils%2Fsrc%2Ftracing_presets.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c/turbopack%2Fcrates%2Fturbopack-trace-utils%2Fsrc%2Ftracing_presets.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-trace-utils%2Fsrc%2Ftracing_presets.rs?ref=86f3bf1a6eecec990ba0984ea6ca5c5bd919c13c",
            "patch": "@@ -5,6 +5,8 @@ pub static TRACING_OVERVIEW_TARGETS: Lazy<Vec<&str>> = Lazy::new(|| {\n         \"turbo_tasks=info\",\n         \"turbo_tasks_fs=info\",\n         \"turbo_tasks_fetch=info\",\n+        \"turbo_tasks_backend=info\",\n+        \"turbo_persistence=info\",\n         \"turbopack=info\",\n         \"turbopack_binding=info\",\n         \"turbopack_browser=info\","
        }
    ],
    "stats": {
        "total": 128,
        "additions": 72,
        "deletions": 56
    }
}