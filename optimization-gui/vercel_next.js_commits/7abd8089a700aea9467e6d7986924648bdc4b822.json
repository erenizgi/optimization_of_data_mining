{
    "author": "sokra",
    "message": "Turbopack: use the same serialization method for lookup as for storing (#84765)\n\n### What?\n\nThis makes sure to use the same method for serializing CachedTaskType for storing and lookup.\nBefore that we instantiated the serialization twice and that caused some weird behavior on linux.\n\nBefore this fix I was seeing that serialization of CachedTaskType was not byte to byte identical between storing and lookup. This caused tasks to not be found, which will lead to very weird effects: stale tasks, cell not found, etc.\n\nI was expecting that pot serialization is deterministic, but turns out it isn't fully deterministic. It has some logic to deduplicate Symbols (like enum variant names). But it deduplicates these `&'static str`s based on the pointer address of the static string. Turns out that Rust doesn't guarantee that static strings are deduplicated in all cases.\n\nI assume that we are somehow running into that problem when having two variants of the serialization. They ended up serializing task types differently (one didn't have a symbol deduplicated in the serialized form. But that's more a wild guess. It did fix the bug, but I have a hard time understanding why this is happening.\n\nOn long term, I think we should change pot to avoid using pointer addresses and do a real comparision instead.\n\n> why does the `inline(never)` fix it?\n\nI'm not super sure, but here is my theory. The rust compiler on linux is very aggressive in inlining the whole stuff, up to the point where it inlines the Serialize implementation of CachedTaskType and RawVc into the call side (`turbo-tasks-backend` crate). It can't inline the Serialize implementation that's behind the `arg` `MagicAny` stuff. So we are duplicating the RawVc Serialize logic into two crates. This way we end up with two `&'static str` of `TaskCell` for the enum variant. This string is not deduplicated during linking for whatever reason (It's not guaranteed). So in the end the Symbol is not deduplicated in the serialized form of the CachedTaskType.\n\nThe stuff above might happen or not. It's in the fate of the compiler. And we also don't rely on that the Symbol is deduplicated. But we rely on a deterministic serialized version. The problem is that the lookup path and the store path have two separate calls to `serialize`, so it might end up inlining into two different places. So that might end up being aggressive in one place and not so aggressive in the other place. So in the end it might end up deduplicating in the lookup path and not deduplicating in the store path, which would cause different serialized versions in the two paths.\n\nTo avoid that, I changed to code to use the `serialize_task_type` function in both places. And the `inline(never)` ensures that it won't be duplicated by inlining.\n\nDon't ask me how long it took to figure that out...",
    "sha": "7abd8089a700aea9467e6d7986924648bdc4b822",
    "files": [
        {
            "sha": "77015dbe2b7cfcded8549f6241213a048539ba1f",
            "filename": "turbopack/crates/turbo-tasks-backend/src/kv_backing_storage.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 10,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/7abd8089a700aea9467e6d7986924648bdc4b822/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7abd8089a700aea9467e6d7986924648bdc4b822/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fkv_backing_storage.rs?ref=7abd8089a700aea9467e6d7986924648bdc4b822",
            "patch": "@@ -357,8 +357,12 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n \n                             let mut task_type_bytes = Vec::new();\n                             for (task_type, task_id) in updates {\n+                                serialize_task_type(\n+                                    &task_type,\n+                                    &mut task_type_bytes,\n+                                    Some(task_id),\n+                                )?;\n                                 let task_id: u32 = *task_id;\n-                                serialize_task_type(&task_type, &mut task_type_bytes, task_id)?;\n \n                                 batch\n                                     .put(\n@@ -441,8 +445,8 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n                     .entered();\n                     let mut task_type_bytes = Vec::new();\n                     for (task_type, task_id) in task_cache_updates.into_iter().flatten() {\n+                        serialize_task_type(&task_type, &mut task_type_bytes, Some(task_id))?;\n                         let task_id = *task_id;\n-                        serialize_task_type(&task_type, &mut task_type_bytes, task_id)?;\n \n                         batch\n                             .put(\n@@ -499,8 +503,10 @@ impl<T: KeyValueDatabase + Send + Sync + 'static> BackingStorageSealed\n             tx: &D::ReadTransaction<'_>,\n             task_type: &CachedTaskType,\n         ) -> Result<Option<TaskId>> {\n-            let task_type = POT_CONFIG.serialize(task_type)?;\n-            let Some(bytes) = database.get(tx, KeySpace::ForwardTaskCache, &task_type)? else {\n+            let mut task_type_bytes = Vec::new();\n+            serialize_task_type(task_type, &mut task_type_bytes, None)?;\n+            let Some(bytes) = database.get(tx, KeySpace::ForwardTaskCache, &task_type_bytes)?\n+            else {\n                 return Ok(None);\n             };\n             let bytes = bytes.borrow().try_into()?;\n@@ -645,23 +651,37 @@ where\n     Ok(())\n }\n \n+// DO NOT REMOVE THE `inline(never)` ATTRIBUTE!\n+// `pot` uses the pointer address of `&'static str` to deduplicate Symbols.\n+// If this function is inlined into multiple different callsites it might inline the Serialize\n+// implementation too, which can pull a `&'static str` from another crate into this crate.\n+// Since string deduplication between crates is not guaranteed, it can lead to behavior changes due\n+// to the pointer addresses. This can lead to lookup path and store path creating different\n+// serialization of the same task type, which breaks task cache lookups.\n+#[inline(never)]\n fn serialize_task_type(\n-    task_type: &Arc<CachedTaskType>,\n+    task_type: &CachedTaskType,\n     mut task_type_bytes: &mut Vec<u8>,\n-    task_id: u32,\n+    task_id: Option<TaskId>,\n ) -> Result<()> {\n     task_type_bytes.clear();\n     POT_CONFIG\n-        .serialize_into(&**task_type, &mut task_type_bytes)\n-        .with_context(|| anyhow!(\"Unable to serialize task {task_id} cache key {task_type:?}\"))?;\n+        .serialize_into(task_type, &mut task_type_bytes)\n+        .with_context(|| {\n+            if let Some(task_id) = task_id {\n+                anyhow!(\"Unable to serialize task {task_id} cache key {task_type:?}\")\n+            } else {\n+                anyhow!(\"Unable to serialize task cache key {task_type:?}\")\n+            }\n+        })?;\n     #[cfg(feature = \"verify_serialization\")]\n     {\n         let deserialize: Result<CachedTaskType, _> = serde_path_to_error::deserialize(\n             &mut pot_de_symbol_list().deserializer_for_slice(&*task_type_bytes)?,\n         );\n         if let Err(err) = deserialize {\n-            println!(\"Task type would not be deserializable {task_id}: {err:?}\\n{task_type:#?}\");\n-            panic!(\"Task type would not be deserializable {task_id}: {err:?}\");\n+            println!(\"Task type would not be deserializable {task_id:?}: {err:?}\\n{task_type:#?}\");\n+            panic!(\"Task type would not be deserializable {task_id:?}: {err:?}\");\n         }\n     }\n     Ok(())"
        }
    ],
    "stats": {
        "total": 40,
        "additions": 30,
        "deletions": 10
    }
}