{
    "author": "mischnic",
    "message": "Turbopack: ignore static asset imports for Edge (#77382)\n\nCloses PACK-4072 \r\n\r\nIgnore static asset imports in Edge, these are really intended for the client (i.e. for\r\npages and not routes, for example `import logo from \"./logo.svg\"`), while still allowing `new URL(..., import.meta.url)`.\r\n\r\nThis replicates what Webpack does. A proper solution for assets on Edge would require some change on the Next.js side to actually tell the bundler if an asset is intended for the server (e.g. for next/og: wasm, fonts), or for the browser.",
    "sha": "2b635e5570b3b746c10ecb4cc9a5a976c2a19114",
    "files": [
        {
            "sha": "b680827278c09011b2fd50e4c307a6de4de742f2",
            "filename": "crates/next-core/src/next_server/transforms.rs",
            "status": "modified",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/vercel/next.js/blob/2b635e5570b3b746c10ecb4cc9a5a976c2a19114/crates%2Fnext-core%2Fsrc%2Fnext_server%2Ftransforms.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2b635e5570b3b746c10ecb4cc9a5a976c2a19114/crates%2Fnext-core%2Fsrc%2Fnext_server%2Ftransforms.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_server%2Ftransforms.rs?ref=2b635e5570b3b746c10ecb4cc9a5a976c2a19114",
            "patch": "@@ -3,6 +3,7 @@ use next_custom_transforms::transforms::strip_page_exports::ExportFilter;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, Vc};\n use turbopack::module_options::{ModuleRule, ModuleRuleEffect, RuleCondition};\n+use turbopack_core::reference_type::{ReferenceType, UrlReferenceSubType};\n \n use crate::{\n     mode::NextMode,\n@@ -193,6 +194,31 @@ pub async fn get_next_server_transforms_rules(\n                 matches!(*mode.await?, NextMode::Build),\n             ));\n         }\n+\n+        if matches!(context_ty, ServerContextType::AppRoute { .. }) {\n+            // Ignore static asset imports in Edge routes, these are really intended for the client\n+            // (i.e. for pages), while still allowing `new URL(..., import.meta.url)`\n+            rules.push(ModuleRule::new(\n+                RuleCondition::all(vec![\n+                    RuleCondition::not(RuleCondition::ReferenceType(ReferenceType::Url(\n+                        UrlReferenceSubType::Undefined,\n+                    ))),\n+                    RuleCondition::any(vec![\n+                        RuleCondition::ResourcePathEndsWith(\".apng\".to_string()),\n+                        RuleCondition::ResourcePathEndsWith(\".avif\".to_string()),\n+                        RuleCondition::ResourcePathEndsWith(\".gif\".to_string()),\n+                        RuleCondition::ResourcePathEndsWith(\".ico\".to_string()),\n+                        RuleCondition::ResourcePathEndsWith(\".jpg\".to_string()),\n+                        RuleCondition::ResourcePathEndsWith(\".jpeg\".to_string()),\n+                        RuleCondition::ResourcePathEndsWith(\".png\".to_string()),\n+                        RuleCondition::ResourcePathEndsWith(\".svg\".to_string()),\n+                        RuleCondition::ResourcePathEndsWith(\".webp\".to_string()),\n+                        RuleCondition::ResourcePathEndsWith(\".woff2\".to_string()),\n+                    ]),\n+                ]),\n+                vec![ModuleRuleEffect::Ignore],\n+            ));\n+        }\n     }\n \n     Ok(rules)"
        },
        {
            "sha": "fc30e5f84d03cd8b76ba694de43c3de1494a938d",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/esm/binding.rs",
            "status": "modified",
            "additions": 64,
            "deletions": 21,
            "changes": 85,
            "blob_url": "https://github.com/vercel/next.js/blob/2b635e5570b3b746c10ecb4cc9a5a976c2a19114/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbinding.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2b635e5570b3b746c10ecb4cc9a5a976c2a19114/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbinding.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fesm%2Fbinding.rs?ref=2b635e5570b3b746c10ecb4cc9a5a976c2a19114",
            "patch": "@@ -18,7 +18,7 @@ use super::EsmAssetReference;\n use crate::{\n     code_gen::{CodeGen, CodeGeneration},\n     create_visitor,\n-    references::AstPath,\n+    references::{esm::base::ReferencedAsset, AstPath},\n };\n \n #[derive(Hash, Clone, Debug, Serialize, Deserialize, PartialEq, Eq, TraceRawVcs, NonLocalValue)]\n@@ -50,7 +50,20 @@ impl EsmBinding {\n \n         let export = self.export.clone();\n         let imported_module = self.reference.get_referenced_asset();\n-        let imported_module = imported_module.await?.get_ident(chunking_context).await?;\n+\n+        enum ImportedIdent {\n+            Module(String),\n+            None,\n+            Unresolvable,\n+        }\n+\n+        let imported_ident = match &*imported_module.await? {\n+            ReferencedAsset::None => ImportedIdent::None,\n+            imported_module => imported_module\n+                .get_ident(chunking_context)\n+                .await?\n+                .map_or(ImportedIdent::Unresolvable, ImportedIdent::Module),\n+        };\n \n         let mut ast_path = self.ast_path.0.clone();\n         loop {\n@@ -60,17 +73,34 @@ impl EsmBinding {\n                 Some(swc_core::ecma::visit::AstParentKind::Prop(PropField::Shorthand)) => {\n                     ast_path.pop();\n                     visitors.push(\n-                    create_visitor!(exact ast_path, visit_mut_prop(prop: &mut Prop) {\n-                        if let Prop::Shorthand(ident) = prop {\n-                            // TODO: Merge with the above condition when https://rust-lang.github.io/rfcs/2497-if-let-chains.html lands.\n-                            if let Some(imported_ident) = imported_module.as_deref() {\n-                                *prop = Prop::KeyValue(KeyValueProp {\n-                                    key: PropName::Ident(ident.clone().into()),\n-                                    value: Box::new(make_expr(imported_ident, export.as_deref(), ident.span, false))\n-                                });\n+                        create_visitor!(exact ast_path, visit_mut_prop(prop: &mut Prop) {\n+                            if let Prop::Shorthand(ident) = prop {\n+                                // TODO: Merge with the above condition when https://rust-lang.github.io/rfcs/2497-if-let-chains.html lands.\n+                                match &imported_ident {\n+                                    ImportedIdent::Module(imported_ident) => {\n+                                        *prop = Prop::KeyValue(KeyValueProp {\n+                                            key: PropName::Ident(ident.clone().into()),\n+                                            value: Box::new(make_expr(\n+                                                imported_ident,\n+                                                export.as_deref(),\n+                                                ident.span,\n+                                                false,\n+                                            )),\n+                                        });\n+                                    }\n+                                    ImportedIdent::None => {\n+                                        *prop = Prop::KeyValue(KeyValueProp {\n+                                            key: PropName::Ident(ident.clone().into()),\n+                                            value: Expr::undefined(ident.span),\n+                                        });\n+                                    }\n+                                    ImportedIdent::Unresolvable => {\n+                                        // Do nothing, the reference will insert a throw\n+                                    }\n+                                }\n                             }\n-                        }\n-                    }));\n+                        }),\n+                    );\n                     break;\n                 }\n                 // Any other expression can be replaced with the import accessor.\n@@ -85,13 +115,18 @@ impl EsmBinding {\n \n                     visitors.push(\n                         create_visitor!(exact ast_path, visit_mut_expr(expr: &mut Expr) {\n-                            if let Some(ident) = imported_module.as_deref() {\n-                                use swc_core::common::Spanned;\n-                                *expr = make_expr(ident, export.as_deref(), expr.span(), in_call);\n+                            use swc_core::common::Spanned;\n+                            match &imported_ident {\n+                                ImportedIdent::Module(imported_ident) => {\n+                                    *expr = make_expr(imported_ident, export.as_deref(), expr.span(), in_call);\n+                                }\n+                                ImportedIdent::None => {\n+                                    *expr = *Expr::undefined(expr.span());\n+                                }\n+                                ImportedIdent::Unresolvable => {\n+                                    // Do nothing, the reference will insert a throw\n+                                }\n                             }\n-                            // If there's no identifier for the imported module,\n-                            // resolution failed and will insert code that throws\n-                            // before this expression is reached. Leave behind the original identifier.\n                         }),\n                     );\n                     break;\n@@ -111,14 +146,22 @@ impl EsmBinding {\n \n                         visitors.push(\n                         create_visitor!(exact ast_path, visit_mut_simple_assign_target(l: &mut SimpleAssignTarget) {\n-                                if let Some(ident) = imported_module.as_deref() {\n-                                    use swc_core::common::Spanned;\n-                                    *l = match make_expr(ident, export.as_deref(), l.span(), false) {\n+                            use swc_core::common::Spanned;\n+                            match &imported_ident {\n+                                ImportedIdent::Module(imported_ident) => {\n+                                    *l = match make_expr(imported_ident, export.as_deref(), l.span(), false) {\n                                         Expr::Ident(ident) => SimpleAssignTarget::Ident(ident.into()),\n                                         Expr::Member(member) => SimpleAssignTarget::Member(member),\n                                         _ => unreachable!(),\n                                     };\n                                 }\n+                                ImportedIdent::None => {\n+                                    // Do nothing, cannot assign to `undefined`\n+                                }\n+                                ImportedIdent::Unresolvable => {\n+                                    // Do nothing, the reference will insert a throw\n+                                }\n+                            }\n                         }));\n                         break;\n                     }"
        }
    ],
    "stats": {
        "total": 111,
        "additions": 90,
        "deletions": 21
    }
}