{
    "author": "mischnic",
    "message": "Turbopack: ModuleGraphRef (#83890)\n\nSome preparatory refactoring:\n\n- A specialized variable to contain a `Vec<ReadRef<Graph>>`. This means you can easily await all graphs first, and then call `graph_ref.traverse()` later.\n- The only downside here is that `ModuleGraphRef::get_entry` doesn't print the module's ident anymore, if it cannot be found. Or do we have an escape hatch to call async code in a sync function for this usecase?",
    "sha": "287b763fdc1a3ec74d0e04e194c2ac94e287aa1e",
    "files": [
        {
            "sha": "68f3623a06f49a3926c407d6ef737e3d5a2e5103",
            "filename": "crates/next-api/src/webpack_stats.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs?ref=287b763fdc1a3ec74d0e04e194c2ac94e287aa1e",
            "patch": "@@ -56,7 +56,7 @@ where\n     };\n \n     let asset_reasons = {\n-        let module_graph = module_graph.await?;\n+        let module_graph = module_graph.read_graphs().await?;\n         let mut edges = vec![];\n         module_graph\n             .traverse_all_edges_unordered(|(parent_node, r), current| {"
        },
        {
            "sha": "1d3db5da1025116f52a08e9d54a2a5a344a1ee34",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 6,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=287b763fdc1a3ec74d0e04e194c2ac94e287aa1e",
            "patch": "@@ -19,7 +19,7 @@ use turbo_tasks::{\n use crate::{\n     chunk::ChunkingType,\n     module::Module,\n-    module_graph::{GraphTraversalAction, ModuleGraph, RefData, SingleModuleGraphModuleNode},\n+    module_graph::{GraphTraversalAction, ModuleGraphRef, RefData, SingleModuleGraphModuleNode},\n };\n \n #[derive(\n@@ -368,7 +368,7 @@ impl Ord for TraversalPriority {\n     }\n }\n \n-pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGroupInfo>> {\n+pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<ChunkGroupInfo>> {\n     let span_outer = tracing::info_span!(\n         \"compute chunk group info\",\n         module_count = tracing::field::Empty,\n@@ -389,12 +389,16 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n         let mut module_chunk_groups: FxHashMap<ResolvedVc<Box<dyn Module>>, RoaringBitmapWrapper> =\n             FxHashMap::default();\n \n-        let graphs = graph.graphs.iter().try_join().await?;\n-        let module_count = graphs.iter().map(|g| g.graph.node_count()).sum::<usize>();\n+        let module_count = graph\n+            .graphs\n+            .iter()\n+            .map(|g| g.graph.node_count())\n+            .sum::<usize>();\n         span.record(\"module_count\", module_count);\n \n         // use all entries from all graphs\n-        let entries = graphs\n+        let entries = graph\n+            .graphs\n             .iter()\n             .flat_map(|g| g.entries.iter())\n             .collect::<Vec<_>>();\n@@ -476,7 +480,8 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n             }\n         }\n \n-        let entry_chunk_group_keys = graphs\n+        let entry_chunk_group_keys = graph\n+            .graphs\n             .iter()\n             .flat_map(|g| g.entries.iter())\n             .flat_map(|chunk_group| {"
        },
        {
            "sha": "e054ef485609c87e24aa1dc1986d21a67a4f26e3",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/export_usage.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fexport_usage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fexport_usage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fexport_usage.rs?ref=287b763fdc1a3ec74d0e04e194c2ac94e287aa1e",
            "patch": "@@ -13,7 +13,7 @@ pub async fn compute_export_usage_info(\n     graph: ResolvedVc<ModuleGraph>,\n ) -> Result<Vc<ExportUsageInfo>> {\n     let mut used_exports = FxHashMap::<_, ModuleExportUsageInfo>::default();\n-    let graph = graph.await?;\n+    let graph = graph.read_graphs().await?;\n     graph\n         .traverse_all_edges_unordered(|(_, ref_data), target| {\n             let e = used_exports.entry(target.module).or_default();"
        },
        {
            "sha": "184596086016a08956703d3eef8597b59807976a",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/merged_modules.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs?ref=287b763fdc1a3ec74d0e04e194c2ac94e287aa1e",
            "patch": "@@ -77,9 +77,9 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n     async move {\n         let async_module_info = module_graph.async_module_info().await?;\n         let chunk_group_info = module_graph.chunk_group_info().await?;\n-        let module_graph = module_graph.await?;\n+        let module_graph = module_graph.read_graphs().await?;\n \n-        let graphs = module_graph.graphs.iter().try_join().await?;\n+        let graphs = &module_graph.graphs;\n         let module_count = graphs.iter().map(|g| g.graph.node_count()).sum::<usize>();\n         span.record(\"module_count\", module_count);\n "
        },
        {
            "sha": "57ef5914e093587a2c59dfba1edeae8d30320155",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 45,
            "deletions": 49,
            "changes": 94,
            "blob_url": "https://github.com/vercel/next.js/blob/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=287b763fdc1a3ec74d0e04e194c2ac94e287aa1e",
            "patch": "@@ -1060,8 +1060,8 @@ impl ModuleGraph {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn chunk_group_info(&self) -> Result<Vc<ChunkGroupInfo>> {\n-        compute_chunk_group_info(self).await\n+    pub async fn chunk_group_info(self: Vc<Self>) -> Result<Vc<ChunkGroupInfo>> {\n+        compute_chunk_group_info(&self.read_graphs().await?).await\n     }\n \n     #[turbo_tasks::function]\n@@ -1105,11 +1105,11 @@ impl ModuleGraph {\n         self: Vc<Self>,\n         module: ResolvedVc<Box<dyn Module>>,\n     ) -> Result<Vc<AsyncModuleInfo>> {\n-        let this = self.await?;\n-        let graphs = this.get_graphs().await?;\n+        let graph_ref = self.read_graphs().await?;\n+        let graphs = &graph_ref.graphs;\n         let async_modules_info = self.async_module_info().await?;\n \n-        let entry = ModuleGraph::get_entry(&graphs, module).await?;\n+        let entry = graph_ref.get_entry(module)?;\n         let referenced_modules =\n             iter_neighbors_rev(&graphs[entry.graph_idx()].graph, entry.node_idx)\n                 .filter(|(edge_idx, _)| {\n@@ -1192,31 +1192,33 @@ macro_rules! get_node_idx {\n pub(crate) use get_node_idx;\n \n impl ModuleGraph {\n-    pub async fn get_graphs(&self) -> Result<Vec<ReadRef<SingleModuleGraph>>> {\n-        self.graphs.iter().try_join().await\n+    pub async fn read_graphs(self: Vc<ModuleGraph>) -> Result<ModuleGraphRef> {\n+        Ok(ModuleGraphRef {\n+            graphs: self.await?.graphs.iter().try_join().await?,\n+        })\n     }\n+}\n \n-    async fn get_entry(\n-        graphs: &[ReadRef<SingleModuleGraph>],\n-        entry: ResolvedVc<Box<dyn Module>>,\n-    ) -> Result<GraphNodeIndex> {\n-        let Some(idx) = graphs.iter().enumerate().find_map(|(graph_idx, graph)| {\n-            graph.modules.get(&entry).map(|node_idx| GraphNodeIndex {\n-                graph_idx: u32::try_from(graph_idx).unwrap(),\n-                node_idx: *node_idx,\n+/// The ReadRef version of ModuleGraph. This is better for eventual consistency, as the graphs\n+/// aren't awaited multiple times within the same task.\n+pub struct ModuleGraphRef {\n+    pub graphs: Vec<ReadRef<SingleModuleGraph>>,\n+}\n+\n+impl ModuleGraphRef {\n+    fn get_entry(&self, entry: ResolvedVc<Box<dyn Module>>) -> Result<GraphNodeIndex> {\n+        let Some(idx) = self\n+            .graphs\n+            .iter()\n+            .enumerate()\n+            .find_map(|(graph_idx, graph)| {\n+                graph.modules.get(&entry).map(|node_idx| GraphNodeIndex {\n+                    graph_idx: u32::try_from(graph_idx).unwrap(),\n+                    node_idx: *node_idx,\n+                })\n             })\n-        }) else {\n-            bail!(\n-                \"Couldn't find entry module {} in module graph (potential entries: {:?})\",\n-                entry.ident().to_string().await?,\n-                graphs\n-                    .iter()\n-                    .flat_map(|g| g.entries.iter())\n-                    .flat_map(|e| e.entries())\n-                    .map(|e| e.ident().to_string())\n-                    .try_join()\n-                    .await?\n-            );\n+        else {\n+            bail!(\"Couldn't find entry module in module graph\");\n         };\n         Ok(idx)\n     }\n@@ -1225,8 +1227,7 @@ impl ModuleGraph {\n     /// This is primarily useful for debugging.\n     pub async fn get_ids(&self) -> Result<FxHashMap<ResolvedVc<Box<dyn Module>>, ReadRef<RcStr>>> {\n         Ok(self\n-            .get_graphs()\n-            .await?\n+            .graphs\n             .iter()\n             .flat_map(|g| g.iter_nodes())\n             .map(async |n| Ok((n.module, n.module.ident().to_string().await?)))\n@@ -1254,14 +1255,13 @@ impl ModuleGraph {\n             &'_ SingleModuleGraphModuleNode,\n         ) -> Result<GraphTraversalAction>,\n     ) -> Result<()> {\n-        let graphs = self.get_graphs().await?;\n+        let graphs = &self.graphs;\n \n         let mut queue = VecDeque::from(\n             entries\n                 .into_iter()\n-                .map(|e| ModuleGraph::get_entry(&graphs, e))\n-                .try_join()\n-                .await?,\n+                .map(|e| self.get_entry(e))\n+                .collect::<Result<Vec<_>>>()?,\n         );\n         let mut visited = HashSet::new();\n         for entry_node in &queue {\n@@ -1309,12 +1309,12 @@ impl ModuleGraph {\n             &'_ SingleModuleGraphModuleNode,\n         ) -> GraphTraversalAction,\n     ) -> Result<()> {\n-        let graphs = self.get_graphs().await?;\n+        let graphs = &self.graphs;\n \n         let entries = entries.into_iter();\n         let mut stack = Vec::with_capacity(entries.size_hint().0);\n         for entry in entries {\n-            stack.push(ModuleGraph::get_entry(&graphs, entry).await?);\n+            stack.push(self.get_entry(entry)?);\n         }\n         let mut visited = HashSet::new();\n         for entry_node in &stack {\n@@ -1359,9 +1359,9 @@ impl ModuleGraph {\n             &'_ SingleModuleGraphModuleNode,\n         ) -> Result<()>,\n     ) -> Result<()> {\n-        let graphs = self.get_graphs().await?;\n+        let graphs = &self.graphs;\n \n-        for graph in &graphs {\n+        for graph in graphs {\n             let graph = &graph.graph;\n             for edge in graph.edge_references() {\n                 let source = match graph.node_weight(edge.source()).unwrap() {\n@@ -1413,7 +1413,7 @@ impl ModuleGraph {\n             &mut S,\n         ) -> Result<()>,\n     ) -> Result<()> {\n-        let graphs = self.get_graphs().await?;\n+        let graphs = &self.graphs;\n \n         let entries = entries.into_iter().collect::<Vec<_>>();\n \n@@ -1425,11 +1425,7 @@ impl ModuleGraph {\n         let mut stack: Vec<(Pass, Option<(GraphNodeIndex, EdgeIndex)>, GraphNodeIndex)> =\n             Vec::with_capacity(entries.len());\n         for entry in entries.into_iter().rev() {\n-            stack.push((\n-                Pass::ExpandAndVisit,\n-                None,\n-                ModuleGraph::get_entry(&graphs, entry).await?,\n-            ));\n+            stack.push((Pass::ExpandAndVisit, None, self.get_entry(entry)?));\n         }\n         let mut expanded = HashSet::new();\n         while let Some((pass, parent, current)) = stack.pop() {\n@@ -1495,7 +1491,7 @@ impl ModuleGraph {\n         mut visit_cycle: impl FnMut(&[&SingleModuleGraphModuleNode]),\n     ) -> Result<()> {\n         for graph in &self.graphs {\n-            graph.await?.traverse_cycles(&edge_filter, &mut visit_cycle);\n+            graph.traverse_cycles(&edge_filter, &mut visit_cycle);\n         }\n         Ok(())\n     }\n@@ -1532,7 +1528,7 @@ impl ModuleGraph {\n         ) -> Result<GraphTraversalAction>,\n         priority: impl Fn(&'_ SingleModuleGraphModuleNode, &mut S) -> Result<P>,\n     ) -> Result<usize> {\n-        let graphs = self.get_graphs().await?;\n+        let graphs = &self.graphs;\n \n         #[derive(PartialEq, Eq)]\n         struct NodeWithPriority<T: Ord> {\n@@ -1559,15 +1555,15 @@ impl ModuleGraph {\n         let mut queue = BinaryHeap::from_iter(\n             entries\n                 .into_iter()\n-                .map(async |(m, priority)| {\n+                .map(|(m, priority)| {\n                     Ok(NodeWithPriority {\n-                        node: ModuleGraph::get_entry(&graphs, m).await?,\n+                        node: self.get_entry(m)?,\n                         priority,\n                     })\n                 })\n-                .try_join()\n-                .await?,\n+                .collect::<Result<Vec<_>>>()?,\n         );\n+\n         for entry_node in &queue {\n             visit(None, get_node!(graphs, entry_node.node)?, state)?;\n         }"
        },
        {
            "sha": "1b1f739311315603d177bc84d9a0838f76b4ca06",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/module_batches.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs?ref=287b763fdc1a3ec74d0e04e194c2ac94e287aa1e",
            "patch": "@@ -20,7 +20,7 @@ use crate::{\n     chunk::{ChunkableModule, ChunkingType},\n     module::Module,\n     module_graph::{\n-        GraphTraversalAction, ModuleGraph,\n+        GraphTraversalAction, ModuleGraph, ModuleGraphRef,\n         chunk_group_info::{ChunkGroupInfo, ChunkGroupKey, RoaringBitmapWrapper},\n         module_batch::{ModuleBatch, ModuleBatchGroup, ModuleOrBatch},\n         traced_di_graph::{TracedDiGraph, iter_neighbors_rev},\n@@ -276,7 +276,7 @@ impl PreBatches {\n         &mut self,\n         entry: ResolvedVc<Box<dyn Module>>,\n         chunk_group_info: &ChunkGroupInfo,\n-        module_graph: &ModuleGraph,\n+        module_graph: &ModuleGraphRef,\n         queue: &mut VecDeque<(ResolvedVc<Box<dyn Module>>, PreBatchIndex)>,\n     ) -> Result<Vec<PreBatchItem>> {\n         let mut state = TraversalState {\n@@ -346,7 +346,7 @@ pub async fn compute_module_batches(\n     let span = outer_span.clone();\n     async move {\n         let chunk_group_info = module_graph.chunk_group_info().await?;\n-        let module_graph = module_graph.await?;\n+        let module_graph = module_graph.read_graphs().await?;\n \n         let mut pre_batches = PreBatches::new();\n "
        },
        {
            "sha": "9bf1d5f5c3a63b98d0446c4253e5ebe752b597e9",
            "filename": "turbopack/crates/turbopack/src/global_module_ids.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fglobal_module_ids.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/287b763fdc1a3ec74d0e04e194c2ac94e287aa1e/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fglobal_module_ids.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fglobal_module_ids.rs?ref=287b763fdc1a3ec74d0e04e194c2ac94e287aa1e",
            "patch": "@@ -19,8 +19,8 @@ pub async fn get_global_module_id_strategy(\n ) -> Result<Vc<GlobalModuleIdStrategy>> {\n     let span = tracing::info_span!(\"compute module id map\");\n     async move {\n-        let module_graph = module_graph.await?;\n-        let graphs = module_graph.graphs.iter().try_join().await?;\n+        let module_graph = module_graph.read_graphs().await?;\n+        let graphs = &module_graph.graphs;\n \n         // All modules in the graph\n         let module_idents = graphs"
        }
    ],
    "stats": {
        "total": 129,
        "additions": 65,
        "deletions": 64
    }
}