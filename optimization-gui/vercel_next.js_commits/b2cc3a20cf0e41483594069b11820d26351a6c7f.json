{
    "author": "sokra",
    "message": "Turbopack: fix race condition when invalidating (#86859)\n\n### What?\r\n\r\nFixes a race condition where invalidations got lost, especially after restoring from persistent cache.\r\n\r\nTheoretically when executing a task again we would remove all dependencies and they would be slowly added again while outputs/cells are read during the execution.\r\n\r\nBut in practice we don't want to do that, as removing and re-adding dependencies would be very expensive and usually most dependencies stay the same anyway.\r\nThis is especially expensive as dependencies are bi-directional, so we would also need to remove and re-add the `dependent` edge (the reverse edge) which would require touching a lot tasks.\r\nTouching persisted items of a task is also expensive as touching them would mark the task as \"needs persisting\", which would store it to DB causing more unnecessary work.\r\n\r\nSo instead we mark all dependencies as outdated when the task starts to execute and slowly remove the outdated flags. When the task has finished we really remove all remaining outdated dependencies. The \"outdated\" marker is transient, so it won't be persisted and it's only uni-directional, meaning it will only be on the in-progress task and not on the reverse edge.\r\n\r\nBut that also means we need to make an additional check when invalidating a task based on the \"dependent\" edge. These edge might be outdated, so we need to make the extra check whether the \"dependency\" (the reverse edge) is marked as \"outdated\". In that case we can ignore the \"dependent\" edge.\r\n\r\nAt least that was my thinking before this change...\r\n\r\nThere is also \"recomputing\" of tasks. This happens when some cells are no longer available (e. g. they might not be serializable and therefore not in the persistent cache). In this phase we re-execute a tasks to recompute these cells. For a \"recomputing\" tasks we don't expect any changes to cells. We detect if we are in the \"recomputing\" phase, by checking the \"dirty\" flag of the task. If it's not dirty, we are recomputing and don't expect changes. If it's dirty, some inputs might have changed and we can expect potential changes to cell. It's important to note that a task might become dirty during execution so we would start the task for recomputing, but while it's executing there are concurrent changes to cells it did read or will read which switches it to the normal execution. Note that therefore it need to be made dirty.\r\n\r\nLet's considers the two cases \"did read\" and \"will read\":\r\n\r\n\"did read\": In this case there is a normal dependency and we can follow it as usual and make the task dirty and stale. Note that the task might read the cell again during the current execution, but that's not a problem.\r\n\r\n\"will read\": In this case there is a outdated dependency. (Luckily we have a dependency at all. If we would do the \"theoretical\" solution, where all dependencies are removed when starting to execute, we couldn't detect that case at all.) We can follow the outdated dependency, and we want to flag the task as dirty (That's the change of this PR), but don't want to flag the task as stale. So the current execution is still valid, but it's potentially switched from \"recomputing\" to normal execution.\r\n\r\nBefore this change the task was not made dirty in the \"will read\" case and this caused it to stay in the \"recomputing\" execution. But since we don't expect (and allow) changes to cells in that phase, the change got lost and didn't fully propagate through the dependency graph causing all kind of weird effects:\r\n* stuck errors\r\n* cell not found errors\r\n* missing updates\r\n* inconsistent states\r\n* incorrect content hashes on files\r\n\r\nExplainer on dirty vs stale:\r\n\r\n`dirty` is persisted and indicates whether some task inputs have changed. It will become clean again after the task execution has finished.\r\n`stale` is a flag on `InProgress` tasks. It's not persisted. It indicates that the current in progress task execution is outdated/stale, since some inputs, that have already been read, have changed during the execution.\r\nWhen a task finishes executing and it's stale, dirty will not cleared and the task will directly execute again.",
    "sha": "b2cc3a20cf0e41483594069b11820d26351a6c7f",
    "files": [
        {
            "sha": "765df76264fd6699d3493485097a272239822e8d",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/b2cc3a20cf0e41483594069b11820d26351a6c7f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b2cc3a20cf0e41483594069b11820d26351a6c7f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=b2cc3a20cf0e41483594069b11820d26351a6c7f",
            "patch": "@@ -2176,15 +2176,17 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 span.record(\"result\", \"once task\");\n                 continue;\n             }\n+            let mut make_stale = true;\n             let dependent = ctx.task(dependent_task_id, TaskDataCategory::All);\n             if dependent.has_key(&CachedDataItemKey::OutdatedOutputDependency { target: task_id }) {\n-                // output dependency is outdated, so it hasn't read the output yet\n-                // and doesn't need to be invalidated\n                 #[cfg(feature = \"trace_task_output_dependencies\")]\n                 span.record(\"result\", \"outdated dependency\");\n-                continue;\n-            }\n-            if !dependent.has_key(&CachedDataItemKey::OutputDependency { target: task_id }) {\n+                // output dependency is outdated, so it hasn't read the output yet\n+                // and doesn't need to be invalidated\n+                // But importantly we still need to make the task dirty as it should no longer\n+                // be considered as \"recomputation\".\n+                make_stale = false;\n+            } else if !dependent.has_key(&CachedDataItemKey::OutputDependency { target: task_id }) {\n                 // output dependency has been removed, so the task doesn't depend on the\n                 // output anymore and doesn't need to be invalidated\n                 #[cfg(feature = \"trace_task_output_dependencies\")]\n@@ -2194,7 +2196,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             make_task_dirty_internal(\n                 dependent,\n                 dependent_task_id,\n-                true,\n+                make_stale,\n                 #[cfg(feature = \"trace_task_dirty\")]\n                 TaskDirtyCause::OutputChange { task_id },\n                 &mut queue,"
        },
        {
            "sha": "7f0dfca74832d450846e27d9acedb62319b74e16",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_cell.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 5,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/b2cc3a20cf0e41483594069b11820d26351a6c7f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b2cc3a20cf0e41483594069b11820d26351a6c7f/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_cell.rs?ref=b2cc3a20cf0e41483594069b11820d26351a6c7f",
            "patch": "@@ -184,15 +184,17 @@ impl Operation for UpdateCellOperation {\n                             // once tasks are never invalidated\n                             continue;\n                         }\n+                        let mut make_stale = true;\n                         let dependent = ctx.task(dependent_task_id, TaskDataCategory::All);\n                         if dependent.has_key(&CachedDataItemKey::OutdatedCellDependency {\n                             target: cell_ref,\n                         }) {\n                             // cell dependency is outdated, so it hasn't read the cell yet\n-                            // and doesn't need to be invalidated\n-                            continue;\n-                        }\n-                        if !dependent\n+                            // and doesn't need to be invalidated.\n+                            // But importantly we still need to make the task dirty as it should no\n+                            // longer be considered as \"recomputation\".\n+                            make_stale = false;\n+                        } else if !dependent\n                             .has_key(&CachedDataItemKey::CellDependency { target: cell_ref })\n                         {\n                             // cell dependency has been removed, so the task doesn't depend on the\n@@ -203,7 +205,7 @@ impl Operation for UpdateCellOperation {\n                         make_task_dirty_internal(\n                             dependent,\n                             dependent_task_id,\n-                            true,\n+                            make_stale,\n                             #[cfg(feature = \"trace_task_dirty\")]\n                             TaskDirtyCause::CellChange {\n                                 value_type: cell_ref.cell.type_id,"
        }
    ],
    "stats": {
        "total": 26,
        "additions": 15,
        "deletions": 11
    }
}