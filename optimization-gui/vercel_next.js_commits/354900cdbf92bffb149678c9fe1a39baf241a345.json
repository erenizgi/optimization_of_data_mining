{
    "author": "bgw",
    "message": "chore(turbo-tasks-backend): Remove unused support for nested database operations (#80816)\n\nSupporting nested operations adds a lot of complexity. I have a feeling it's partially responsible for some of the lifetime stuff here. It doesn't look like it's actually needed?\n\nSanity checked with:\n\n```\ncargo check --features turbo-tasks-backend/lmdb\n```",
    "sha": "354900cdbf92bffb149678c9fe1a39baf241a345",
    "files": [
        {
            "sha": "9db68e98b0b14e02b16408fa6413d51027d2353c",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 87,
            "changes": 89,
            "blob_url": "https://github.com/vercel/next.js/blob/354900cdbf92bffb149678c9fe1a39baf241a345/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/354900cdbf92bffb149678c9fe1a39baf241a345/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fmod.rs?ref=354900cdbf92bffb149678c9fe1a39baf241a345",
            "patch": "@@ -10,7 +10,7 @@ mod update_output;\n \n use std::{\n     fmt::{Debug, Formatter},\n-    mem::{take, transmute},\n+    mem::transmute,\n };\n \n use serde::{Deserialize, Serialize};\n@@ -45,25 +45,6 @@ enum TransactionState<'a, 'tx, B: BackingStorage> {\n     Owned(Option<B::ReadTransaction<'tx>>),\n }\n \n-impl<'a, 'tx1, B: BackingStorage> TransactionState<'a, 'tx1, B> {\n-    fn borrow<'l, 'tx2>(&'l self) -> TransactionState<'l, 'tx2, B>\n-    where\n-        'a: 'l,\n-        'tx1: 'a + 'tx2,\n-        'tx2: 'l,\n-    {\n-        match self {\n-            TransactionState::None => TransactionState::None,\n-            TransactionState::Borrowed(tx) => {\n-                TransactionState::Borrowed(tx.map(B::lower_read_transaction))\n-            }\n-            TransactionState::Owned(tx) => {\n-                TransactionState::Borrowed(tx.as_ref().map(B::lower_read_transaction))\n-            }\n-        }\n-    }\n-}\n-\n pub trait ExecuteContext<'e>: Sized {\n     fn session_id(&self) -> SessionId;\n     fn task(&mut self, task_id: TaskId, category: TaskDataCategory) -> impl TaskGuard + 'e;\n@@ -79,30 +60,18 @@ pub trait ExecuteContext<'e>: Sized {\n     where\n         T: Clone + Into<AnyOperation>;\n     fn suspending_requested(&self) -> bool;\n-    type Backend;\n-    fn run_operation(\n-        &mut self,\n-        parent_op_ref: &mut impl Operation,\n-        run: impl FnOnce(&mut ExecuteContextImpl<'_, '_, Self::Backend>),\n-    );\n     fn get_task_desc_fn(&self, task_id: TaskId) -> impl Fn() -> String + Send + Sync + 'static;\n     fn get_task_description(&self, task_id: TaskId) -> String;\n     fn should_track_children(&self) -> bool;\n     fn should_track_dependencies(&self) -> bool;\n     fn should_track_activeness(&self) -> bool;\n }\n \n-pub struct ParentRef<'a> {\n-    op: &'a AnyOperation,\n-    parent: &'a Option<ParentRef<'a>>,\n-}\n-\n pub struct ExecuteContextImpl<'e, 'tx, B: BackingStorage>\n where\n     Self: 'e,\n     'tx: 'e,\n {\n-    parent: Option<ParentRef<'e>>,\n     backend: &'e TurboTasksBackendInner<B>,\n     turbo_tasks: &'e dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     _operation_guard: Option<OperationGuard<'e, B>>,\n@@ -121,7 +90,6 @@ where\n             backend,\n             turbo_tasks,\n             _operation_guard: Some(backend.start_operation()),\n-            parent: None,\n             transaction: TransactionState::None,\n         }\n     }\n@@ -135,7 +103,6 @@ where\n             backend,\n             turbo_tasks,\n             _operation_guard: Some(backend.start_operation()),\n-            parent: None,\n             transaction: TransactionState::Borrowed(transaction),\n         }\n     }\n@@ -292,65 +259,13 @@ where\n     }\n \n     fn operation_suspend_point<T: Clone + Into<AnyOperation>>(&mut self, op: &T) {\n-        if self.parent.is_some() {\n-            self.backend.operation_suspend_point(|| {\n-                let mut nested = Vec::new();\n-                nested.push(op.clone().into());\n-                let mut cur = self.parent.as_ref();\n-                while let Some(ParentRef { op, parent }) = cur {\n-                    nested.push((*op).clone());\n-                    cur = parent.as_ref();\n-                }\n-                AnyOperation::Nested(nested)\n-            });\n-        } else {\n-            self.backend.operation_suspend_point(|| op.clone().into());\n-        }\n+        self.backend.operation_suspend_point(|| op.clone().into());\n     }\n \n     fn suspending_requested(&self) -> bool {\n         self.backend.suspending_requested()\n     }\n \n-    type Backend = B;\n-\n-    fn run_operation(\n-        &mut self,\n-        parent_op_ref: &mut impl Operation,\n-        run: impl FnOnce(&mut ExecuteContextImpl<'_, '_, B>),\n-    ) {\n-        let parent_op = take(parent_op_ref);\n-        let parent_op: AnyOperation = parent_op.into();\n-        let this = &*self;\n-        fn run_with_inner_ctx<'a, B: BackingStorage>(\n-            backend: &'a TurboTasksBackendInner<B>,\n-            turbo_tasks: &'a dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n-            parent: ParentRef<'a>,\n-            transaction: TransactionState<'a, '_, B>,\n-            run: impl FnOnce(&mut ExecuteContextImpl<'_, '_, B>),\n-        ) {\n-            let mut inner_ctx: ExecuteContextImpl<'_, '_, B> = ExecuteContextImpl {\n-                backend,\n-                turbo_tasks,\n-                _operation_guard: None,\n-                parent: Some(parent),\n-                transaction,\n-            };\n-            run(&mut inner_ctx);\n-        }\n-        run_with_inner_ctx(\n-            self.backend,\n-            self.turbo_tasks,\n-            ParentRef {\n-                op: &parent_op,\n-                parent: &this.parent,\n-            },\n-            self.transaction.borrow(),\n-            run,\n-        );\n-        *parent_op_ref = parent_op.try_into().unwrap();\n-    }\n-\n     fn get_task_desc_fn(&self, task_id: TaskId) -> impl Fn() -> String + Send + Sync + 'static {\n         self.backend.get_task_desc_fn(task_id)\n     }"
        }
    ],
    "stats": {
        "total": 89,
        "additions": 2,
        "deletions": 87
    }
}