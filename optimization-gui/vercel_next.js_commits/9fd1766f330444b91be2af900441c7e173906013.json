{
    "author": "acdlite",
    "message": "[Segment Cache] Search param fallback handling (#75990)\n\nThis implements search param handling in the Segment Cache.\n\nWhen a cache entry is fetched via PPR, search params are treated as\ndynamic data. We can share the same cache entry for every set of search\nparams for a given page segment.\n\nBy contrast, when a cache entry is fetched using a dynamic request (e.g.\nusing `<Link prefetch={true}`), the result may vary by the search param\nvalues. So we must include the search params in the cache key.\n\nDuring a navigation, we will first check for the more specific cache\nentry (i.e. one that includes search params), and then fallback to the\nPPR version if no such entry exists.",
    "sha": "9fd1766f330444b91be2af900441c7e173906013",
    "files": [
        {
            "sha": "5a15113cebeb8547fcd6fe602aeea5760020850e",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache-key.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 13,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/9fd1766f330444b91be2af900441c7e173906013/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache-key.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/9fd1766f330444b91be2af900441c7e173906013/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache-key.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache-key.ts?ref=9fd1766f330444b91be2af900441c7e173906013",
            "patch": "@@ -3,13 +3,17 @@ type Opaque<K, T> = T & { __brand: K }\n \n // Only functions in this module should be allowed to create CacheKeys.\n export type NormalizedHref = Opaque<'NormalizedHref', string>\n+export type NormalizedSearch = Opaque<'NormalizedSearch', string>\n export type NormalizedNextUrl = Opaque<'NormalizedNextUrl', string>\n \n export type RouteCacheKey = Opaque<\n   'RouteCacheKey',\n   {\n     href: NormalizedHref\n+    search: NormalizedSearch\n     nextUrl: NormalizedNextUrl | null\n+\n+    // TODO: Eventually the dynamic params will be added here, too.\n   }\n >\n \n@@ -18,20 +22,10 @@ export function createCacheKey(\n   nextUrl: string | null\n ): RouteCacheKey {\n   const originalUrl = new URL(originalHref)\n-\n-  // TODO: As of now, we never include search params in the cache key because\n-  // per-segment prefetch requests are always static, and cannot contain search\n-  // params. But to support <Link prefetch={true}>, we will sometimes populate\n-  // the cache with dynamic data, so this will have to change.\n-  originalUrl.search = ''\n-\n-  const normalizedHref = originalUrl.href as NormalizedHref\n-  const normalizedNextUrl = nextUrl as NormalizedNextUrl | null\n-\n   const cacheKey = {\n-    href: normalizedHref,\n-    nextUrl: normalizedNextUrl,\n+    href: originalHref as NormalizedHref,\n+    search: originalUrl.search as NormalizedSearch,\n+    nextUrl: nextUrl as NormalizedNextUrl | null,\n   } as RouteCacheKey\n-\n   return cacheKey\n }"
        },
        {
            "sha": "5b85ca4cd7b6d96295ebcee1293ade805cb3ee06",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 119,
            "deletions": 30,
            "changes": 149,
            "blob_url": "https://github.com/vercel/next.js/blob/9fd1766f330444b91be2af900441c7e173906013/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/9fd1766f330444b91be2af900441c7e173906013/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=9fd1766f330444b91be2af900441c7e173906013",
            "patch": "@@ -36,6 +36,7 @@ import { createHrefFromUrl } from '../router-reducer/create-href-from-url'\n import type {\n   NormalizedHref,\n   NormalizedNextUrl,\n+  NormalizedSearch,\n   RouteCacheKey,\n } from './cache-key'\n import { createTupleMap, type TupleMap, type Prefix } from './tuple-map'\n@@ -53,6 +54,7 @@ import type {\n import { normalizeFlightData } from '../../flight-data-helpers'\n import { STATIC_STALETIME_MS } from '../router-reducer/prefetch-cache-utils'\n import { pingVisibleLinks } from '../links'\n+import { PAGE_SEGMENT_KEY } from '../../../shared/lib/segment'\n \n // A note on async/await when working in the prefetch cache:\n //\n@@ -157,9 +159,9 @@ type SegmentCacheEntryShared = {\n   revalidating: SegmentCacheEntry | null\n \n   // LRU-related fields\n-  key: null | string\n-  next: null | RouteCacheEntry\n-  prev: null | RouteCacheEntry\n+  keypath: null | Prefix<SegmentCacheKeypath>\n+  next: null | SegmentCacheEntry\n+  prev: null | SegmentCacheEntry\n   size: number\n }\n \n@@ -230,9 +232,9 @@ let routeCacheLru = createLRU<RouteCacheEntry>(\n   onRouteLRUEviction\n )\n \n-// TODO: We may eventually store segment entries in a tuple map, too, to\n-// account for search params.\n-let segmentCacheMap = new Map<string, SegmentCacheEntry>()\n+type SegmentCacheKeypath = [string, NormalizedSearch]\n+let segmentCacheMap: TupleMap<SegmentCacheKeypath, SegmentCacheEntry> =\n+  createTupleMap()\n // NOTE: Segments and Route entries are managed by separate LRUs. We could\n // combine them into a single LRU, but because they are separate types, we'd\n // need to wrap each one in an extra LRU node (to maintain monomorphism, at the\n@@ -269,7 +271,7 @@ export function revalidateEntireCache(\n   // correctly: background revalidations. See note in `upsertSegmentEntry`.\n   routeCacheMap = createTupleMap()\n   routeCacheLru = createLRU(maxRouteLruSize, onRouteLRUEviction)\n-  segmentCacheMap = new Map()\n+  segmentCacheMap = createTupleMap()\n   segmentCacheLru = createLRU(maxSegmentLruSize, onSegmentLRUEviction)\n \n   // Prefetch all the currently visible links again, to re-fill the cache.\n@@ -316,12 +318,61 @@ export function readRouteCacheEntry(\n   return readExactRouteCacheEntry(now, key.href, key.nextUrl)\n }\n \n+export function getSegmentKeypathForTask(\n+  task: PrefetchTask,\n+  route: FulfilledRouteCacheEntry,\n+  path: string\n+): Prefix<SegmentCacheKeypath> {\n+  // When a prefetch includes dynamic data, the search params are included\n+  // in the result, so we must include the search string in the segment\n+  // cache key. (Note that this is true even if the search string is empty.)\n+  //\n+  // If we're fetching using PPR, we do not need to include the search params in\n+  // the cache key, because the search params are treated as dynamic data. The\n+  // cache entry is valid for all possible search param values.\n+  const isDynamicTask = task.includeDynamicData || !route.isPPREnabled\n+  return isDynamicTask && path.endsWith('/' + PAGE_SEGMENT_KEY)\n+    ? [path, task.key.search]\n+    : [path]\n+}\n+\n export function readSegmentCacheEntry(\n   now: number,\n+  routeCacheKey: RouteCacheKey,\n   path: string\n ): SegmentCacheEntry | null {\n-  const existingEntry = segmentCacheMap.get(path)\n-  if (existingEntry !== undefined) {\n+  if (!path.endsWith('/' + PAGE_SEGMENT_KEY)) {\n+    // Fast path. Search params only exist on page segments.\n+    return readExactSegmentCacheEntry(now, [path])\n+  }\n+\n+  // Page segments may or may not contain search params. If they were prefetched\n+  // using a dynamic request, then we will have an entry with search params.\n+  // Check for that case first.\n+  const entryWithSearchParams = readExactSegmentCacheEntry(now, [\n+    path,\n+    routeCacheKey.search,\n+  ])\n+  if (entryWithSearchParams !== null) {\n+    return entryWithSearchParams\n+  }\n+\n+  // If we did not find an entry with the given search params, check for a\n+  // \"fallback\" entry, where the search params are treated as dynamic data. This\n+  // is the common case because PPR/static prerenders always treat search params\n+  // as dynamic.\n+  //\n+  // See corresponding logic in `getSegmentKeypathForTask`.\n+  const entryWithoutSearchParams = readExactSegmentCacheEntry(now, [path])\n+  return entryWithoutSearchParams\n+}\n+\n+function readExactSegmentCacheEntry(\n+  now: number,\n+  keypath: Prefix<SegmentCacheKeypath>\n+): SegmentCacheEntry | null {\n+  const existingEntry = segmentCacheMap.get(keypath)\n+  if (existingEntry !== null) {\n     // Check if the entry is stale\n     if (existingEntry.staleAt > now) {\n       // Reuse the existing entry.\n@@ -335,14 +386,18 @@ export function readSegmentCacheEntry(\n       const revalidatingEntry = existingEntry.revalidating\n       if (revalidatingEntry !== null) {\n         // There's a revalidation in progress. Upsert it.\n-        const upsertedEntry = upsertSegmentEntry(now, path, revalidatingEntry)\n+        const upsertedEntry = upsertSegmentEntry(\n+          now,\n+          keypath,\n+          revalidatingEntry\n+        )\n         if (upsertedEntry !== null && upsertedEntry.staleAt > now) {\n           // We can use the upserted revalidation entry.\n           return upsertedEntry\n         }\n       } else {\n         // Evict the stale entry from the cache.\n-        deleteSegmentFromCache(existingEntry, path)\n+        deleteSegmentFromCache(existingEntry, keypath)\n       }\n     }\n   }\n@@ -435,20 +490,21 @@ export function readOrCreateRouteCacheEntry(\n  */\n export function readOrCreateSegmentCacheEntry(\n   now: number,\n-  // TODO: Don't need to pass the whole route. Just `staleAt`.\n+  task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n   path: string\n ): SegmentCacheEntry {\n-  const existingEntry = readSegmentCacheEntry(now, path)\n+  const keypath = getSegmentKeypathForTask(task, route, path)\n+  const existingEntry = readExactSegmentCacheEntry(now, keypath)\n   if (existingEntry !== null) {\n     return existingEntry\n   }\n   // Create a pending entry and add it to the cache.\n   const pendingEntry = createDetachedSegmentCacheEntry(route.staleAt)\n-  segmentCacheMap.set(path, pendingEntry)\n+  segmentCacheMap.set(keypath, pendingEntry)\n   // Stash the keypath on the entry so we know how to remove it from the map\n   // if it gets evicted from the LRU.\n-  pendingEntry.key = path\n+  pendingEntry.keypath = keypath\n   segmentCacheLru.put(pendingEntry)\n   return pendingEntry\n }\n@@ -480,7 +536,7 @@ export function readOrCreateRevalidatingSegmentEntry(\n \n export function upsertSegmentEntry(\n   now: number,\n-  segmentKeyPath: string,\n+  keypath: Prefix<SegmentCacheKeypath>,\n   candidateEntry: SegmentCacheEntry\n ): SegmentCacheEntry | null {\n   // We have a new entry that has not yet been inserted into the cache. Before\n@@ -489,7 +545,7 @@ export function upsertSegmentEntry(\n   // TODO: We should not upsert an entry if its key was invalidated in the time\n   // since the request was made. We can do that by passing the \"owner\" entry to\n   // this function and confirming it's the same as `existingEntry`.\n-  const existingEntry = readSegmentCacheEntry(now, segmentKeyPath)\n+  const existingEntry = readExactSegmentCacheEntry(now, keypath)\n   if (existingEntry !== null) {\n     if (candidateEntry.isPartial && !existingEntry.isPartial) {\n       // Don't replace a full segment with a partial one. A case where this\n@@ -508,12 +564,12 @@ export function upsertSegmentEntry(\n       return null\n     }\n     // Evict the existing entry from the cache.\n-    deleteSegmentFromCache(existingEntry, segmentKeyPath)\n+    deleteSegmentFromCache(existingEntry, keypath)\n   }\n-  segmentCacheMap.set(segmentKeyPath, candidateEntry)\n+  segmentCacheMap.set(keypath, candidateEntry)\n   // Stash the keypath on the entry so we know how to remove it from the map\n   // if it gets evicted from the LRU.\n-  candidateEntry.key = segmentKeyPath\n+  candidateEntry.keypath = keypath\n   segmentCacheLru.put(candidateEntry)\n   return candidateEntry\n }\n@@ -534,7 +590,7 @@ export function createDetachedSegmentCacheEntry(\n     promise: null,\n \n     // LRU-related fields\n-    key: null,\n+    keypath: null,\n     next: null,\n     prev: null,\n     size: 0,\n@@ -561,9 +617,12 @@ function deleteRouteFromCache(\n   routeCacheLru.delete(entry)\n }\n \n-function deleteSegmentFromCache(entry: SegmentCacheEntry, key: string): void {\n+function deleteSegmentFromCache(\n+  entry: SegmentCacheEntry,\n+  keypath: Prefix<SegmentCacheKeypath>\n+): void {\n   cancelEntryListeners(entry)\n-  segmentCacheMap.delete(key)\n+  segmentCacheMap.delete(keypath)\n   segmentCacheLru.delete(entry)\n   clearRevalidatingSegmentFromOwner(entry)\n }\n@@ -601,11 +660,11 @@ function onRouteLRUEviction(entry: RouteCacheEntry): void {\n \n function onSegmentLRUEviction(entry: SegmentCacheEntry): void {\n   // The LRU evicted this entry. Remove it from the map.\n-  const key = entry.key\n-  if (key !== null) {\n-    entry.key = null\n+  const keypath = entry.keypath\n+  if (keypath !== null) {\n+    entry.keypath = null\n     cancelEntryListeners(entry)\n-    segmentCacheMap.delete(key)\n+    segmentCacheMap.delete(keypath)\n   }\n }\n \n@@ -785,9 +844,25 @@ function convertFlightRouterStateToRouteTree(\n     }\n   }\n \n+  // The navigation implementation expects the search params to be included\n+  // in the segment. However, in the case of a static response, the search\n+  // params are omitted. So the client needs to add them back in when reading\n+  // from the Segment Cache.\n+  //\n+  // For consistency, we'll do this for dynamic responses, too.\n+  //\n+  // TODO: We should move search params out of FlightRouterState and handle them\n+  // entirely on the client, similar to our plan for dynamic params.\n+  const originalSegment = flightRouterState[0]\n+  const segmentWithoutSearchParams =\n+    typeof originalSegment === 'string' &&\n+    originalSegment.startsWith(PAGE_SEGMENT_KEY)\n+      ? PAGE_SEGMENT_KEY\n+      : originalSegment\n+\n   return {\n     key,\n-    segment: flightRouterState[0],\n+    segment: segmentWithoutSearchParams,\n     slots,\n     isRootLayout: flightRouterState[4] === true,\n   }\n@@ -1174,6 +1249,7 @@ export async function fetchSegmentPrefetchesUsingDynamicRequest(\n     // in the LRU as more data comes in.\n     fulfilledEntries = writeDynamicRenderResponseIntoCache(\n       Date.now(),\n+      task,\n       response,\n       serverData,\n       route,\n@@ -1262,6 +1338,7 @@ function rejectSegmentEntriesIfStillPending(\n \n function writeDynamicRenderResponseIntoCache(\n   now: number,\n+  task: PrefetchTask,\n   response: Response,\n   serverData: NavigationFlightResponse,\n   route: FulfilledRouteCacheEntry,\n@@ -1312,6 +1389,7 @@ function writeDynamicRenderResponseIntoCache(\n           : STATIC_STALETIME_MS\n       writeSeedDataIntoCache(\n         now,\n+        task,\n         route,\n         now + staleTimeMs,\n         seedData,\n@@ -1337,6 +1415,7 @@ function writeDynamicRenderResponseIntoCache(\n \n function writeSeedDataIntoCache(\n   now: number,\n+  task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n   staleAt: number,\n   seedData: CacheNodeSeedData,\n@@ -1360,7 +1439,12 @@ function writeSeedDataIntoCache(\n     fulfillSegmentCacheEntry(ownedEntry, rsc, loading, staleAt, isPartial)\n   } else {\n     // There's no matching entry. Attempt to create a new one.\n-    const possiblyNewEntry = readOrCreateSegmentCacheEntry(now, route, key)\n+    const possiblyNewEntry = readOrCreateSegmentCacheEntry(\n+      now,\n+      task,\n+      route,\n+      key\n+    )\n     if (possiblyNewEntry.status === EntryStatus.Empty) {\n       // Confirmed this is a new entry. We can fulfill it.\n       const newEntry = possiblyNewEntry\n@@ -1375,7 +1459,11 @@ function writeSeedDataIntoCache(\n         staleAt,\n         isPartial\n       )\n-      upsertSegmentEntry(now, key, newEntry)\n+      upsertSegmentEntry(\n+        now,\n+        getSegmentKeypathForTask(task, route, key),\n+        newEntry\n+      )\n     }\n   }\n   // Recursively write the child data into the cache.\n@@ -1387,6 +1475,7 @@ function writeSeedDataIntoCache(\n         const childSegment = childSeedData[0]\n         writeSeedDataIntoCache(\n           now,\n+          task,\n           route,\n           staleAt,\n           childSeedData,"
        },
        {
            "sha": "ad8d947505d321469c4e9294d763950e4d983fd1",
            "filename": "packages/next/src/client/components/segment-cache-impl/navigation.ts",
            "status": "modified",
            "additions": 33,
            "deletions": 6,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/9fd1766f330444b91be2af900441c7e173906013/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/9fd1766f330444b91be2af900441c7e173906013/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fnavigation.ts?ref=9fd1766f330444b91be2af900441c7e173906013",
            "patch": "@@ -23,7 +23,11 @@ import {\n   waitForSegmentCacheEntry,\n   type RouteTree,\n } from './cache'\n-import { createCacheKey } from './cache-key'\n+import { createCacheKey, type RouteCacheKey } from './cache-key'\n+import {\n+  addSearchParamsIfPageSegment,\n+  PAGE_SEGMENT_KEY,\n+} from '../../../shared/lib/segment'\n import { NavigationResultTag } from '../segment-cache'\n \n type MPANavigationResult = {\n@@ -112,7 +116,7 @@ export function navigate(\n   const route = readRouteCacheEntry(now, cacheKey)\n   if (route !== null && route.status === EntryStatus.Fulfilled) {\n     // We have a matching prefetch.\n-    const snapshot = readRenderSnapshotFromCache(now, route.tree)\n+    const snapshot = readRenderSnapshotFromCache(now, cacheKey, route.tree)\n     const prefetchFlightRouterState = snapshot.flightRouterState\n     const prefetchSeedData = snapshot.seedData\n     const prefetchHead = route.head\n@@ -244,6 +248,7 @@ function navigationTaskToResult(\n \n function readRenderSnapshotFromCache(\n   now: number,\n+  routeCacheKey: RouteCacheKey,\n   tree: RouteTree\n ): { flightRouterState: FlightRouterState; seedData: CacheNodeSeedData } {\n   let childRouterStates: { [parallelRouteKey: string]: FlightRouterState } = {}\n@@ -254,7 +259,11 @@ function readRenderSnapshotFromCache(\n   if (slots !== null) {\n     for (const parallelRouteKey in slots) {\n       const childTree = slots[parallelRouteKey]\n-      const childResult = readRenderSnapshotFromCache(now, childTree)\n+      const childResult = readRenderSnapshotFromCache(\n+        now,\n+        routeCacheKey,\n+        childTree\n+      )\n       childRouterStates[parallelRouteKey] = childResult.flightRouterState\n       childSeedDatas[parallelRouteKey] = childResult.seedData\n     }\n@@ -264,7 +273,7 @@ function readRenderSnapshotFromCache(\n   let loading: LoadingModuleData | Promise<LoadingModuleData> = null\n   let isPartial: boolean = true\n \n-  const segmentEntry = readSegmentCacheEntry(now, tree.key)\n+  const segmentEntry = readSegmentCacheEntry(now, routeCacheKey, tree.key)\n   if (segmentEntry !== null) {\n     switch (segmentEntry.status) {\n       case EntryStatus.Fulfilled: {\n@@ -299,15 +308,33 @@ function readRenderSnapshotFromCache(\n     }\n   }\n \n+  const segment =\n+    tree.segment === PAGE_SEGMENT_KEY && routeCacheKey.search\n+      ? // The navigation implementation expects the search params to be\n+        // included in the segment. However, the Segment Cache tracks search\n+        // params separately from the rest of the segment key. So we need to\n+        // add them back here.\n+        //\n+        // See corresponding comment in convertFlightRouterStateToTree.\n+        //\n+        // TODO: What we should do instead is update the navigation diffing\n+        // logic to compare search params explicitly. This is a temporary\n+        // solution until more of the Segment Cache implementation has settled.\n+        addSearchParamsIfPageSegment(\n+          tree.segment,\n+          Object.fromEntries(new URLSearchParams(routeCacheKey.search))\n+        )\n+      : tree.segment\n+\n   return {\n     flightRouterState: [\n-      tree.segment,\n+      segment,\n       childRouterStates,\n       null,\n       null,\n       tree.isRootLayout,\n     ],\n-    seedData: [tree.segment, rsc, childSeedDatas, loading, isPartial],\n+    seedData: [segment, rsc, childSeedDatas, loading, isPartial],\n   }\n }\n "
        },
        {
            "sha": "4a5c2bdd76f5bacbcba1c5d7a6a79883c3195eb7",
            "filename": "packages/next/src/client/components/segment-cache-impl/scheduler.ts",
            "status": "modified",
            "additions": 49,
            "deletions": 7,
            "changes": 56,
            "blob_url": "https://github.com/vercel/next.js/blob/9fd1766f330444b91be2af900441c7e173906013/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/9fd1766f330444b91be2af900441c7e173906013/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts?ref=9fd1766f330444b91be2af900441c7e173906013",
            "patch": "@@ -23,6 +23,7 @@ import {\n   upgradeToPendingSegment,\n   waitForSegmentCacheEntry,\n   resetRevalidatingSegmentEntry,\n+  getSegmentKeypathForTask,\n } from './cache'\n import type { RouteCacheKey } from './cache-key'\n import { PrefetchPriority } from '../segment-cache'\n@@ -480,6 +481,7 @@ function pingRootRouteTree(\n           const spawnedEntries = new Map<string, PendingSegmentCacheEntry>()\n           const dynamicRequestTree = diffRouteTreeAgainstCurrent(\n             now,\n+            task,\n             route,\n             task.treeAtTimeOfPrefetch,\n             tree,\n@@ -520,7 +522,7 @@ function pingPPRRouteTree(\n   route: FulfilledRouteCacheEntry,\n   tree: RouteTree\n ): PrefetchTaskExitStatus.InProgress | PrefetchTaskExitStatus.Done {\n-  const segment = readOrCreateSegmentCacheEntry(now, route, tree.key)\n+  const segment = readOrCreateSegmentCacheEntry(now, task, route, tree.key)\n   pingPerSegment(now, task, route, segment, task.key, tree.key)\n   if (tree.slots !== null) {\n     if (!hasNetworkBandwidth()) {\n@@ -543,6 +545,7 @@ function pingPPRRouteTree(\n \n function diffRouteTreeAgainstCurrent(\n   now: number,\n+  task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n   oldTree: FlightRouterState,\n   newTree: RouteTree,\n@@ -576,6 +579,7 @@ function diffRouteTreeAgainstCurrent(\n         // This segment is already part of the current route. Keep traversing.\n         const requestTreeChild = diffRouteTreeAgainstCurrent(\n           now,\n+          task,\n           route,\n           oldTreeChild,\n           newTreeChild,\n@@ -606,6 +610,7 @@ function diffRouteTreeAgainstCurrent(\n             const requestTreeChild =\n               pingPPRDisabledRouteTreeUpToLoadingBoundary(\n                 now,\n+                task,\n                 route,\n                 newTreeChild,\n                 null,\n@@ -634,6 +639,7 @@ function diffRouteTreeAgainstCurrent(\n             // populate the segment cache.\n             const requestTreeChild = pingRouteTreeAndIncludeDynamicData(\n               now,\n+              task,\n               route,\n               newTreeChild,\n               false,\n@@ -660,6 +666,7 @@ function diffRouteTreeAgainstCurrent(\n \n function pingPPRDisabledRouteTreeUpToLoadingBoundary(\n   now: number,\n+  task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n   tree: RouteTree,\n   refetchMarkerContext: 'refetch' | 'inside-shared-layout' | null,\n@@ -679,7 +686,7 @@ function pingPPRDisabledRouteTreeUpToLoadingBoundary(\n   let refetchMarker: 'refetch' | 'inside-shared-layout' | null =\n     refetchMarkerContext === null ? 'inside-shared-layout' : null\n \n-  const segment = readOrCreateSegmentCacheEntry(now, route, tree.key)\n+  const segment = readOrCreateSegmentCacheEntry(now, task, route, tree.key)\n   switch (segment.status) {\n     case EntryStatus.Empty: {\n       // This segment is not cached. Add a refetch marker so the server knows\n@@ -747,6 +754,7 @@ function pingPPRDisabledRouteTreeUpToLoadingBoundary(\n       requestTreeChildren[parallelRouteKey] =\n         pingPPRDisabledRouteTreeUpToLoadingBoundary(\n           now,\n+          task,\n           route,\n           childTree,\n           refetchMarkerContext,\n@@ -766,6 +774,7 @@ function pingPPRDisabledRouteTreeUpToLoadingBoundary(\n \n function pingRouteTreeAndIncludeDynamicData(\n   now: number,\n+  task: PrefetchTask,\n   route: FulfilledRouteCacheEntry,\n   tree: RouteTree,\n   isInsideRefetchingParent: boolean,\n@@ -779,7 +788,7 @@ function pingRouteTreeAndIncludeDynamicData(\n   // explicit \"refetch\" marker so the server knows where to start rendering.\n   // Once the server starts rendering along a path, it keeps rendering the\n   // entire subtree.\n-  const segment = readOrCreateSegmentCacheEntry(now, route, tree.key)\n+  const segment = readOrCreateSegmentCacheEntry(now, task, route, tree.key)\n \n   let spawnedSegment: PendingSegmentCacheEntry | null = null\n \n@@ -794,7 +803,13 @@ function pingRouteTreeAndIncludeDynamicData(\n       if (segment.isPartial) {\n         // The cached segment contians dynamic holes. Since this is a Full\n         // prefetch, we need to include it in the request.\n-        spawnedSegment = pingFullSegmentRevalidation(now, segment, tree.key)\n+        spawnedSegment = pingFullSegmentRevalidation(\n+          now,\n+          task,\n+          route,\n+          segment,\n+          tree.key\n+        )\n       }\n       break\n     }\n@@ -803,7 +818,13 @@ function pingRouteTreeAndIncludeDynamicData(\n       // There's either another prefetch currently in progress, or the previous\n       // attempt failed. If it wasn't a Full prefetch, fetch it again.\n       if (segment.fetchStrategy !== FetchStrategy.Full) {\n-        spawnedSegment = pingFullSegmentRevalidation(now, segment, tree.key)\n+        spawnedSegment = pingFullSegmentRevalidation(\n+          now,\n+          task,\n+          route,\n+          segment,\n+          tree.key\n+        )\n       }\n       break\n     }\n@@ -817,6 +838,7 @@ function pingRouteTreeAndIncludeDynamicData(\n       requestTreeChildren[parallelRouteKey] =\n         pingRouteTreeAndIncludeDynamicData(\n           now,\n+          task,\n           route,\n           childTree,\n           isInsideRefetchingParent || spawnedSegment !== null,\n@@ -883,6 +905,7 @@ function pingPerSegment(\n             // `hasLoading` in the route tree prefetch response.\n             pingPPRSegmentRevalidation(\n               now,\n+              task,\n               segment,\n               route,\n               routeKey,\n@@ -914,7 +937,14 @@ function pingPerSegment(\n           // Because a rejected segment will definitely prevent the segment (and\n           // all of its children) from rendering, we perform this revalidation\n           // immediately instead of deferring it to a background task.\n-          pingPPRSegmentRevalidation(now, segment, route, routeKey, segmentKey)\n+          pingPPRSegmentRevalidation(\n+            now,\n+            task,\n+            segment,\n+            route,\n+            routeKey,\n+            segmentKey\n+          )\n           break\n         default:\n           segment.fetchStrategy satisfies never\n@@ -935,6 +965,7 @@ function pingPerSegment(\n \n function pingPPRSegmentRevalidation(\n   now: number,\n+  task: PrefetchTask,\n   currentSegment: SegmentCacheEntry,\n   route: FulfilledRouteCacheEntry,\n   routeKey: RouteCacheKey,\n@@ -949,6 +980,8 @@ function pingPPRSegmentRevalidation(\n       // Spawn a prefetch request and upsert the segment into the cache\n       // upon completion.\n       upsertSegmentOnCompletion(\n+        task,\n+        route,\n         segmentKey,\n         spawnPrefetchSubtask(\n           fetchSegmentOnCacheMiss(\n@@ -976,6 +1009,8 @@ function pingPPRSegmentRevalidation(\n \n function pingFullSegmentRevalidation(\n   now: number,\n+  task: PrefetchTask,\n+  route: FulfilledRouteCacheEntry,\n   currentSegment: SegmentCacheEntry,\n   segmentKey: string\n ): PendingSegmentCacheEntry | null {\n@@ -994,6 +1029,8 @@ function pingFullSegmentRevalidation(\n       FetchStrategy.Full\n     )\n     upsertSegmentOnCompletion(\n+      task,\n+      route,\n       segmentKey,\n       waitForSegmentCacheEntry(pendingSegment)\n     )\n@@ -1012,6 +1049,8 @@ function pingFullSegmentRevalidation(\n         FetchStrategy.Full\n       )\n       upsertSegmentOnCompletion(\n+        task,\n+        route,\n         segmentKey,\n         waitForSegmentCacheEntry(pendingSegment)\n       )\n@@ -1037,14 +1076,17 @@ function pingFullSegmentRevalidation(\n const noop = () => {}\n \n function upsertSegmentOnCompletion(\n+  task: PrefetchTask,\n+  route: FulfilledRouteCacheEntry,\n   key: string,\n   promise: Promise<FulfilledSegmentCacheEntry | null>\n ) {\n   // Wait for a segment to finish loading, then upsert it into the cache\n   promise.then((fulfilled) => {\n     if (fulfilled !== null) {\n       // Received new data. Attempt to replace the existing entry in the cache.\n-      upsertSegmentEntry(Date.now(), key, fulfilled)\n+      const keypath = getSegmentKeypathForTask(task, route, key)\n+      upsertSegmentEntry(Date.now(), keypath, fulfilled)\n     }\n   }, noop)\n }"
        },
        {
            "sha": "7ac3b722ce9e23c4ff7881692d5de7f4751cd776",
            "filename": "packages/next/src/server/app-render/segment-value-encoding.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/9fd1766f330444b91be2af900441c7e173906013/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fsegment-value-encoding.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/9fd1766f330444b91be2af900441c7e173906013/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fsegment-value-encoding.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fsegment-value-encoding.ts?ref=9fd1766f330444b91be2af900441c7e173906013",
            "patch": "@@ -1,3 +1,4 @@\n+import { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\n import type { Segment as FlightRouterStateSegment } from './types'\n \n // TypeScript trick to simulate opaque types, like in Flow.\n@@ -9,6 +10,18 @@ export function encodeSegment(\n   segment: FlightRouterStateSegment\n ): EncodedSegment {\n   if (typeof segment === 'string') {\n+    if (segment.startsWith(PAGE_SEGMENT_KEY)) {\n+      // The Flight Router State type sometimes includes the search params in\n+      // the page segment. However, the Segment Cache tracks this as a separate\n+      // key. So, we strip the search params here, and then add them back when\n+      // the cache entry is turned back into a FlightRouterState. This is an\n+      // unfortunate consequence of the FlightRouteState being used both as a\n+      // transport type and as a cache key; we'll address this once more of the\n+      // Segment Cache implementation has settled.\n+      // TODO: We should hoist the search params out of the FlightRouterState\n+      // type entirely, This is our plan for dynamic route params, too.\n+      return PAGE_SEGMENT_KEY as EncodedSegment\n+    }\n     const safeName =\n       // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\".\n       // But params typically don't include the leading slash. We should use"
        },
        {
            "sha": "dbce4ea8e3aeb6cb61b81712b62288d5abaf776b",
            "filename": "test/e2e/app-dir/segment-cache/search-params/app/layout.tsx",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Flayout.tsx?ref=9fd1766f330444b91be2af900441c7e173906013",
            "patch": "@@ -0,0 +1,11 @@\n+export default function RootLayout({\n+  children,\n+}: {\n+  children: React.ReactNode\n+}) {\n+  return (\n+    <html lang=\"en\">\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "38a1dac0eb37d880aab4562eb1d3744c059d7b6d",
            "filename": "test/e2e/app-dir/segment-cache/search-params/app/search-params/page.tsx",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Fpage.tsx?ref=9fd1766f330444b91be2af900441c7e173906013",
            "patch": "@@ -0,0 +1,39 @@\n+import { LinkAccordion } from '../../components/link-accordion'\n+\n+export default function SearchParamsPage() {\n+  return (\n+    <>\n+      <p>\n+        Demonstrates that we can prefetch a page that reads from search params\n+      </p>\n+      <ul>\n+        <li>\n+          <LinkAccordion href=\"/search-params/target-page?searchParam=a_PPR\">\n+            searchParam=a_PPR\n+          </LinkAccordion>\n+        </li>\n+        <li>\n+          <LinkAccordion\n+            prefetch={true}\n+            href=\"/search-params/target-page?searchParam=b_full\"\n+          >\n+            searchParam=b_full, prefetch=true\n+          </LinkAccordion>\n+        </li>\n+        <li>\n+          <LinkAccordion href=\"/search-params/target-page?searchParam=c_PPR\">\n+            searchParam=c_PPR\n+          </LinkAccordion>\n+        </li>\n+        <li>\n+          <LinkAccordion\n+            prefetch={true}\n+            href=\"/search-params/target-page?searchParam=d_full\"\n+          >\n+            searchParam=d_full, prefetch=true\n+          </LinkAccordion>\n+        </li>\n+      </ul>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "6f0ba58995a4679f37c80cdcc2744d0243a1be50",
            "filename": "test/e2e/app-dir/segment-cache/search-params/app/search-params/target-page/layout.tsx",
            "status": "added",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Ftarget-page%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Ftarget-page%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Ftarget-page%2Flayout.tsx?ref=9fd1766f330444b91be2af900441c7e173906013",
            "patch": "@@ -0,0 +1,8 @@\n+export default function SearchParamsLayout({ children }) {\n+  return (\n+    <div>\n+      <p>Search params shared layout</p>\n+      {children}\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "b8829770a640dbad413f8efe16ae366b3318b9d1",
            "filename": "test/e2e/app-dir/segment-cache/search-params/app/search-params/target-page/page.tsx",
            "status": "added",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Ftarget-page%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Ftarget-page%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fapp%2Fsearch-params%2Ftarget-page%2Fpage.tsx?ref=9fd1766f330444b91be2af900441c7e173906013",
            "patch": "@@ -0,0 +1,16 @@\n+import { Suspense } from 'react'\n+\n+async function Content({ searchParams }) {\n+  const { searchParam } = await searchParams\n+  return `Search param: ${searchParam}`\n+}\n+\n+export default async function Target({ searchParams }) {\n+  return (\n+    <Suspense fallback=\"Loading...\">\n+      <div id=\"target-page-with-search-param\">\n+        <Content searchParams={searchParams} />\n+      </div>\n+    </Suspense>\n+  )\n+}"
        },
        {
            "sha": "4bb0955e44c7f9639847ea5e328a1c7036e1d884",
            "filename": "test/e2e/app-dir/segment-cache/search-params/components/link-accordion.tsx",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fcomponents%2Flink-accordion.tsx?ref=9fd1766f330444b91be2af900441c7e173906013",
            "patch": "@@ -0,0 +1,33 @@\n+'use client'\n+\n+import Link from 'next/link'\n+import { useState } from 'react'\n+\n+export function LinkAccordion({\n+  href,\n+  children,\n+  prefetch,\n+}: {\n+  href: string\n+  children: React.ReactNode\n+  prefetch?: boolean\n+}) {\n+  const [isVisible, setIsVisible] = useState(false)\n+  return (\n+    <>\n+      <input\n+        type=\"checkbox\"\n+        checked={isVisible}\n+        onChange={() => setIsVisible(!isVisible)}\n+        data-link-accordion={href}\n+      />\n+      {isVisible ? (\n+        <Link prefetch={prefetch} href={href}>\n+          {children}\n+        </Link>\n+      ) : (\n+        <>{children} (link is hidden)</>\n+      )}\n+    </>\n+  )\n+}"
        },
        {
            "sha": "a74129c5a24f2a6e1e828d8224b872c67645319b",
            "filename": "test/e2e/app-dir/segment-cache/search-params/next.config.js",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fnext.config.js?ref=9fd1766f330444b91be2af900441c7e173906013",
            "patch": "@@ -0,0 +1,12 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  experimental: {\n+    ppr: true,\n+    dynamicIO: true,\n+    clientSegmentCache: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "03540daef13cfe7956c1e2d0394eb9a60acf0480",
            "filename": "test/e2e/app-dir/segment-cache/search-params/segment-cache-search-params.test.ts",
            "status": "added",
            "additions": 144,
            "deletions": 0,
            "changes": 144,
            "blob_url": "https://github.com/vercel/next.js/blob/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fsegment-cache-search-params.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/9fd1766f330444b91be2af900441c7e173906013/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fsegment-cache-search-params.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fsearch-params%2Fsegment-cache-search-params.test.ts?ref=9fd1766f330444b91be2af900441c7e173906013",
            "patch": "@@ -0,0 +1,144 @@\n+import { nextTestSetup } from 'e2e-utils'\n+import type * as Playwright from 'playwright'\n+import { createRouterAct } from '../router-act'\n+\n+describe('segment cache (search params)', () => {\n+  const { next, isNextDev, skipped } = nextTestSetup({\n+    files: __dirname,\n+    skipDeployment: true,\n+  })\n+  if (isNextDev || skipped) {\n+    test('ppr is disabled', () => {})\n+    return\n+  }\n+\n+  it('when fetching with PPR, does not include search params in the cache key', async () => {\n+    let act: ReturnType<typeof createRouterAct>\n+    const browser = await next.browser('/search-params', {\n+      beforePageLoad(page: Playwright.Page) {\n+        act = createRouterAct(page)\n+      },\n+    })\n+\n+    // Prefetch a page with search param `a_PPR`.\n+    const revealA = await browser.elementByCss(\n+      'input[data-link-accordion=\"/search-params/target-page?searchParam=a_PPR\"]'\n+    )\n+    await act(\n+      async () => {\n+        await revealA.click()\n+      },\n+      // The response will include a shell of the page, but nothing that is\n+      // based on the search param.\n+      {\n+        includes:\n+          // This is the id assigned to a container div\n+          'target-page-with-search-param',\n+      }\n+    )\n+\n+    // Prefetch the same page but with the search param changed to `c_PPR`.\n+    const revealC = await browser.elementByCss(\n+      'input[data-link-accordion=\"/search-params/target-page?searchParam=c_PPR\"]'\n+    )\n+    await act(\n+      async () => {\n+        await revealC.click()\n+      },\n+      // This should not issue a new request for the page segment, because\n+      // search params are not included in the the PPR shell. So we can reuse\n+      // the shell we fetched for `searchParam=a`.\n+      { includes: 'target-page-with-search-param', block: 'reject' }\n+    )\n+\n+    // Navigate to one of the links.\n+    const linkC = await browser.elementByCss(\n+      'a[href=\"/search-params/target-page?searchParam=c_PPR\"]'\n+    )\n+    await act(\n+      async () => {\n+        await linkC.click()\n+      },\n+      // The search param streams in on navigation\n+      {\n+        includes: 'Search param: c_PPR',\n+      }\n+    )\n+    const result = await browser.elementById('target-page-with-search-param')\n+    expect(await result.innerText()).toBe('Search param: c_PPR')\n+  })\n+\n+  it('when fetching without PPR (e.g. prefetch={true}), includes the search params in the cache key', async () => {\n+    let act: ReturnType<typeof createRouterAct>\n+    const browser = await next.browser('/search-params', {\n+      beforePageLoad(page: Playwright.Page) {\n+        act = createRouterAct(page)\n+      },\n+    })\n+\n+    // Prefetch a page with search param `b_full`. This link has prefetch={true}\n+    // so it will fetch the entire page, including the search param.\n+    const revealB = await browser.elementByCss(\n+      'input[data-link-accordion=\"/search-params/target-page?searchParam=b_full\"]'\n+    )\n+    await act(\n+      async () => {\n+        await revealB.click()\n+      },\n+      // The response will include the entire page, including the search param.\n+      {\n+        includes: 'Search param: b_full',\n+      }\n+    )\n+\n+    // Prefetch a link with a different search param, and without\n+    // prefetch={true}. This must fetch a new shell, because it can't use the\n+    // entry we fetched for `searchParam=b_full` (because that one wasn't a\n+    // shell â€” it included the search param).\n+    const revealA = await browser.elementByCss(\n+      'input[data-link-accordion=\"/search-params/target-page?searchParam=a_PPR\"]'\n+    )\n+    await act(\n+      async () => {\n+        await revealA.click()\n+      },\n+      // The response will include a shell of the page, but nothing that is\n+      // based on the search param.\n+      { includes: 'target-page-with-search-param' }\n+    )\n+\n+    // Prefetch a different link using prefetch={true}. Again, this must issue\n+    // a new request, because it's a full page prefetch and we haven't fetched\n+    // this particular search param before.\n+    // TODO: As an future optimization, if a navigation to this link occurs\n+    // before the prefetch completes, we could render the PPR shell in\n+    // the meantime, since it contains no search params. This would effectively\n+    // be a \"per-segment fallback\".\n+    const revealD = await browser.elementByCss(\n+      'input[data-link-accordion=\"/search-params/target-page?searchParam=d_full\"]'\n+    )\n+    await act(\n+      async () => {\n+        await revealD.click()\n+      },\n+      // The response will include the entire page, including the search param.\n+      { includes: 'Search param: d_full' }\n+    )\n+\n+    // Navigate to one of the fully prefetched links.\n+    const linkD = await browser.elementByCss(\n+      'a[href=\"/search-params/target-page?searchParam=d_full\"]'\n+    )\n+    await act(\n+      async () => {\n+        await linkD.click()\n+        const result = await browser.elementById(\n+          'target-page-with-search-param'\n+        )\n+        expect(await result.innerText()).toBe('Search param: d_full')\n+      },\n+      // No requests should be issued, because the page was fully prefetched.\n+      'no-requests'\n+    )\n+  })\n+})"
        }
    ],
    "stats": {
        "total": 540,
        "additions": 484,
        "deletions": 56
    }
}