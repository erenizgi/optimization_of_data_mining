{
    "author": "lukesandberg",
    "message": "[turbopack] Simplify `Request::parse(Pattern)` the recursive portion doesn't need to be async (#80510)\n\n## Optimize Request parsing in Turbopack core resolver\n\n### What?\nRefactored the `Request::parse_ref` method and related functions to improve performance by:\n- Converting async functions to synchronous where possible\n- Normalizing patterns before parsing to improve cache hits\n- Handling alternatives pattern separately in the async `parse_inner` function\n- Adopt `rcstr!` in a few places\n\n### Why?\nThis should be a small perf enhancement, basically just noticed the `Box::pin` calls and decided to track down what was fundamentally async.",
    "sha": "4186665bf0bc0c8cc4bb4e00063145aa312195f6",
    "files": [
        {
            "sha": "b52582eb7a8309b091d93af962cb28561c2db09b",
            "filename": "turbopack/crates/turbopack-core/src/resolve/parse.rs",
            "status": "modified",
            "additions": 60,
            "deletions": 48,
            "changes": 108,
            "blob_url": "https://github.com/vercel/next.js/blob/4186665bf0bc0c8cc4bb4e00063145aa312195f6/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4186665bf0bc0c8cc4bb4e00063145aa312195f6/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fparse.rs?ref=4186665bf0bc0c8cc4bb4e00063145aa312195f6",
            "patch": "@@ -142,88 +142,91 @@ impl Request {\n         })\n     }\n \n-    pub async fn parse_ref(mut request: Pattern) -> Result<Self> {\n-        request.normalize();\n-        Ok(match request {\n+    /// Internal construction function.  Should only be called with normalized patterns, or\n+    /// recursively. Most users should call [Self::parse] instead.\n+    fn parse_ref(request: Pattern) -> Self {\n+        match request {\n             Pattern::Dynamic => Request::Dynamic,\n-            Pattern::Constant(r) => Request::parse_constant_pattern(r).await?,\n-            Pattern::Concatenation(list) => Request::parse_concatenation_pattern(list).await?,\n-            Pattern::Alternatives(list) => Request::parse_alternatives_pattern(list).await?,\n-        })\n+            Pattern::Constant(r) => Request::parse_constant_pattern(r),\n+            Pattern::Concatenation(list) => Request::parse_concatenation_pattern(list),\n+            Pattern::Alternatives(_) => panic!(\n+                \"request should be normalized and alternatives should have already been handled.\",\n+            ),\n+        }\n     }\n \n-    async fn parse_constant_pattern(r: RcStr) -> Result<Self> {\n+    fn parse_constant_pattern(r: RcStr) -> Self {\n         if r.is_empty() {\n-            return Ok(Request::Empty);\n+            return Request::Empty;\n         }\n \n         if let Some(remainder) = r.strip_prefix(\"//\") {\n-            return Ok(Request::Uri {\n+            return Request::Uri {\n                 protocol: rcstr!(\"//\"),\n                 remainder: remainder.into(),\n                 query: RcStr::default(),\n                 fragment: RcStr::default(),\n-            });\n+            };\n         }\n \n         if r.starts_with('/') {\n             let (path, query, fragment) = split_off_query_fragment(&r);\n \n-            return Ok(Request::ServerRelative {\n+            return Request::ServerRelative {\n                 path,\n                 query,\n                 fragment,\n-            });\n+            };\n         }\n \n         if r.starts_with('#') {\n-            return Ok(Request::PackageInternal {\n+            return Request::PackageInternal {\n                 path: Pattern::Constant(r),\n-            });\n+            };\n         }\n \n         if r.starts_with(\"./\") || r.starts_with(\"../\") || r == \".\" || r == \"..\" {\n             let (path, query, fragment) = split_off_query_fragment(&r);\n \n-            return Ok(Request::Relative {\n+            return Request::Relative {\n                 path,\n                 force_in_lookup_dir: false,\n                 query,\n                 fragment,\n-            });\n+            };\n         }\n \n         if WINDOWS_PATH.is_match(&r) {\n             let (path, query, fragment) = split_off_query_fragment(&r);\n \n-            return Ok(Request::Windows {\n+            return Request::Windows {\n                 path,\n                 query,\n                 fragment,\n-            });\n+            };\n         }\n \n         if let Some(caps) = URI_PATH.captures(&r)\n             && let (Some(protocol), Some(remainder)) = (caps.get(1), caps.get(2))\n         {\n             if let Some(caps) = DATA_URI_REMAINDER.captures(remainder.as_str()) {\n-                let media_type = caps.get(1).map_or(\"\", |m| m.as_str()).into();\n-                let encoding = caps.get(2).map_or(\"\", |e| e.as_str()).into();\n-                let data = caps.get(3).map_or(\"\", |d| d.as_str()).into();\n+                let media_type = caps.get(1).map_or(RcStr::default(), |m| m.as_str().into());\n+                let encoding = caps.get(2).map_or(RcStr::default(), |e| e.as_str().into());\n+                let data = caps.get(3).map_or(RcStr::default(), |d| d.as_str().into());\n \n-                return Ok(Request::DataUri {\n+                return Request::DataUri {\n                     media_type,\n                     encoding,\n                     data: ResolvedVc::cell(data),\n-                });\n+                };\n             }\n \n-            return Ok(Request::Uri {\n+            return Request::Uri {\n                 protocol: protocol.as_str().into(),\n                 remainder: remainder.as_str().into(),\n                 query: RcStr::default(),\n                 fragment: RcStr::default(),\n-            });\n+            };\n         }\n \n         if let Some((module, path)) = MODULE_PATH\n@@ -232,25 +235,25 @@ impl Request {\n         {\n             let (path, query, fragment) = split_off_query_fragment(path.as_str());\n \n-            return Ok(Request::Module {\n+            return Request::Module {\n                 module: module.as_str().into(),\n                 path,\n                 query,\n                 fragment,\n-            });\n+            };\n         }\n \n-        Ok(Request::Unknown {\n+        Request::Unknown {\n             path: Pattern::Constant(r),\n-        })\n+        }\n     }\n \n-    async fn parse_concatenation_pattern(list: Vec<Pattern>) -> Result<Self> {\n+    fn parse_concatenation_pattern(list: Vec<Pattern>) -> Self {\n         if list.is_empty() {\n-            return Ok(Request::Empty);\n+            return Request::Empty;\n         }\n \n-        let mut result = Box::pin(Self::parse_ref(list[0].clone())).await?;\n+        let mut result = Self::parse_ref(list[0].clone());\n \n         for item in list.into_iter().skip(1) {\n             match &mut result {\n@@ -270,7 +273,7 @@ impl Request {\n                     path.push(item);\n                 }\n                 Request::Empty => {\n-                    result = Box::pin(Self::parse_ref(item)).await?;\n+                    result = Self::parse_ref(item);\n                 }\n                 Request::PackageInternal { path } => {\n                     path.push(item);\n@@ -289,30 +292,39 @@ impl Request {\n             };\n         }\n \n-        Ok(result)\n-    }\n-\n-    async fn parse_alternatives_pattern(list: Vec<Pattern>) -> Result<Self> {\n-        Ok(Request::Alternatives {\n-            requests: list\n-                .into_iter()\n-                .map(Request::parse)\n-                .map(|v| async move { v.to_resolved().await })\n-                .try_join()\n-                .await?,\n-        })\n+        result\n     }\n \n     pub fn parse_string(request: RcStr) -> Vc<Self> {\n         Self::parse(request.into())\n     }\n+\n+    pub fn parse(mut request: Pattern) -> Vc<Self> {\n+        // Call normalize before parse_inner to improve cache hits.\n+        request.normalize();\n+        Self::parse_inner(request)\n+    }\n }\n \n #[turbo_tasks::value_impl]\n impl Request {\n     #[turbo_tasks::function]\n-    pub async fn parse(request: Pattern) -> Result<Vc<Self>> {\n-        Ok(Self::cell(Request::parse_ref(request).await?))\n+    async fn parse_inner(request: Pattern) -> Result<Vc<Self>> {\n+        // Because we are normalized, we should handle alternatives here\n+        if let Pattern::Alternatives(alts) = request {\n+            Ok(Self::cell(Self::Alternatives {\n+                requests: alts\n+                    .into_iter()\n+                    // We can call parse_inner directly because these patterns are already\n+                    // normalized.  We don't call `Self::parse_ref` so we can try to get a cache hit\n+                    // on the sub-patterns\n+                    .map(|p| Self::parse_inner(p).to_resolved())\n+                    .try_join()\n+                    .await?,\n+            }))\n+        } else {\n+            Ok(Self::cell(Self::parse_ref(request)))\n+        }\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "69d660906b9b815d8bcf3878d19c03acc83126bb",
            "filename": "turbopack/crates/turbopack-core/src/resolve/pattern.rs",
            "status": "modified",
            "additions": 13,
            "deletions": 6,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/4186665bf0bc0c8cc4bb4e00063145aa312195f6/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4186665bf0bc0c8cc4bb4e00063145aa312195f6/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fresolve%2Fpattern.rs?ref=4186665bf0bc0c8cc4bb4e00063145aa312195f6",
            "patch": "@@ -10,7 +10,7 @@ use regex::Regex;\n use rustc_hash::{FxHashMap, FxHashSet};\n use serde::{Deserialize, Serialize};\n use tracing::Instrument;\n-use turbo_rcstr::RcStr;\n+use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n     NonLocalValue, ResolvedVc, TaskInput, ValueToString, Vc, debug::ValueDebugFormat,\n     trace::TraceRawVcs,\n@@ -448,13 +448,20 @@ impl Pattern {\n         current\n     }\n \n+    /// Normalizes paths by\n+    /// - processing path segments: `.` and `..`\n+    /// - normalizing windows filepaths by replacing `\\` with `/`\n+    ///\n+    /// The Pattern must have already been processed by [Self::normalize].\n+    /// Returns [Option::None] if any of the patterns attempt to navigate out of the root.\n     pub fn with_normalized_path(&self) -> Option<Pattern> {\n         let mut new = self.clone();\n \n         fn normalize_path_internal(pattern: &mut Pattern) -> Option<()> {\n             match pattern {\n                 Pattern::Constant(c) => {\n-                    *c = (*(normalize_path(c)?)).into();\n+                    let normalized = c.replace('\\\\', \"/\");\n+                    *c = (*(normalize_path(normalized.as_str())?)).into();\n                     Some(())\n                 }\n                 Pattern::Dynamic => Some(()),\n@@ -490,7 +497,7 @@ impl Pattern {\n                             }\n                         }\n                     }\n-                    let separator: RcStr = \"/\".into();\n+                    let separator = rcstr!(\"/\");\n                     *list = segments\n                         .into_iter()\n                         .flat_map(|c| {\n@@ -1091,7 +1098,7 @@ impl Pattern {\n \n     pub fn or_any_nested_file(&self) -> Self {\n         let mut new = self.clone();\n-        new.push(Pattern::Constant(\"/\".into()));\n+        new.push(Pattern::Constant(rcstr!(\"/\")));\n         new.push(Pattern::Dynamic);\n         new.normalize();\n         Pattern::alternatives([self.clone(), new])\n@@ -1548,10 +1555,10 @@ pub async fn read_matches(\n             }\n             if prefix.is_empty() {\n                 if let Some(pos) = pat.match_position(\"./\") {\n-                    results.push((pos, PatternMatch::Directory(\"./\".into(), lookup_dir)));\n+                    results.push((pos, PatternMatch::Directory(rcstr!(\"./\"), lookup_dir)));\n                 }\n                 if let Some(pos) = pat.could_match_position(\"./\") {\n-                    nested.push((pos, read_matches(*lookup_dir, \"./\".into(), false, pattern)));\n+                    nested.push((pos, read_matches(*lookup_dir, rcstr!(\"./\"), false, pattern)));\n                 }\n             } else {\n                 prefix.push('/');"
        }
    ],
    "stats": {
        "total": 127,
        "additions": 73,
        "deletions": 54
    }
}