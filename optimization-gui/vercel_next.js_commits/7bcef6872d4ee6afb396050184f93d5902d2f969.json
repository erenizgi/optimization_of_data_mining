{
    "author": "ztanner",
    "message": "upgrade to path-to-regexp@6.3.0 (#80123)\n\nUpgrades `path-to-regexp` to address backing concerns from\n`CVE-2024-45296`. As a result, this requires some additional\npre-processing on the paths we generate for interception routes, to\nensure we pass a compliant value into `path-to-regexp`.",
    "sha": "7bcef6872d4ee6afb396050184f93d5902d2f969",
    "files": [
        {
            "sha": "727205af7b6ee9efa513d37481a535242d4a9287",
            "filename": "packages/next/package.json",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fpackage.json?ref=7bcef6872d4ee6afb396050184f93d5902d2f969",
            "patch": "@@ -291,7 +291,7 @@\n     \"p-limit\": \"3.1.0\",\n     \"p-queue\": \"6.6.2\",\n     \"path-browserify\": \"1.0.1\",\n-    \"path-to-regexp\": \"6.1.0\",\n+    \"path-to-regexp\": \"6.3.0\",\n     \"picomatch\": \"4.0.1\",\n     \"postcss-flexbugs-fixes\": \"5.0.2\",\n     \"postcss-modules-extract-imports\": \"3.0.0\","
        },
        {
            "sha": "6a86d020d3a90575e4e21b4f490c88c7bf980576",
            "filename": "packages/next/src/compiled/path-to-regexp/index.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Fcompiled%2Fpath-to-regexp%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Fcompiled%2Fpath-to-regexp%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fcompiled%2Fpath-to-regexp%2Findex.js?ref=7bcef6872d4ee6afb396050184f93d5902d2f969",
            "patch": "@@ -1 +1 @@\n-(()=>{\"use strict\";if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var e={};(()=>{var r=e;Object.defineProperty(r,\"__esModule\",{value:true});function lexer(e){var r=[];var n=0;while(n<e.length){var t=e[n];if(t===\"*\"||t===\"+\"||t===\"?\"){r.push({type:\"MODIFIER\",index:n,value:e[n++]});continue}if(t===\"\\\\\"){r.push({type:\"ESCAPED_CHAR\",index:n++,value:e[n++]});continue}if(t===\"{\"){r.push({type:\"OPEN\",index:n,value:e[n++]});continue}if(t===\"}\"){r.push({type:\"CLOSE\",index:n,value:e[n++]});continue}if(t===\":\"){var i=\"\";var a=n+1;while(a<e.length){var o=e.charCodeAt(a);if(o>=48&&o<=57||o>=65&&o<=90||o>=97&&o<=122||o===95){i+=e[a++];continue}break}if(!i)throw new TypeError(\"Missing parameter name at \"+n);r.push({type:\"NAME\",index:n,value:i});n=a;continue}if(t===\"(\"){var f=1;var u=\"\";var a=n+1;if(e[a]===\"?\"){throw new TypeError('Pattern cannot start with \"?\" at '+a)}while(a<e.length){if(e[a]===\"\\\\\"){u+=e[a++]+e[a++];continue}if(e[a]===\")\"){f--;if(f===0){a++;break}}else if(e[a]===\"(\"){f++;if(e[a+1]!==\"?\"){throw new TypeError(\"Capturing groups are not allowed at \"+a)}}u+=e[a++]}if(f)throw new TypeError(\"Unbalanced pattern at \"+n);if(!u)throw new TypeError(\"Missing pattern at \"+n);r.push({type:\"PATTERN\",index:n,value:u});n=a;continue}r.push({type:\"CHAR\",index:n,value:e[n++]})}r.push({type:\"END\",index:n,value:\"\"});return r}function parse(e,r){if(r===void 0){r={}}var n=lexer(e);var t=r.prefixes,i=t===void 0?\"./\":t;var a=\"[^\"+escapeString(r.delimiter||\"/#?\")+\"]+?\";var o=[];var f=0;var u=0;var p=\"\";var tryConsume=function(e){if(u<n.length&&n[u].type===e)return n[u++].value};var mustConsume=function(e){var r=tryConsume(e);if(r!==undefined)return r;var t=n[u],i=t.type,a=t.index;throw new TypeError(\"Unexpected \"+i+\" at \"+a+\", expected \"+e)};var consumeText=function(){var e=\"\";var r;while(r=tryConsume(\"CHAR\")||tryConsume(\"ESCAPED_CHAR\")){e+=r}return e};while(u<n.length){var v=tryConsume(\"CHAR\");var c=tryConsume(\"NAME\");var s=tryConsume(\"PATTERN\");if(c||s){var d=v||\"\";if(i.indexOf(d)===-1){p+=d;d=\"\"}if(p){o.push(p);p=\"\"}o.push({name:c||f++,prefix:d,suffix:\"\",pattern:s||a,modifier:tryConsume(\"MODIFIER\")||\"\"});continue}var g=v||tryConsume(\"ESCAPED_CHAR\");if(g){p+=g;continue}if(p){o.push(p);p=\"\"}var x=tryConsume(\"OPEN\");if(x){var d=consumeText();var l=tryConsume(\"NAME\")||\"\";var h=tryConsume(\"PATTERN\")||\"\";var m=consumeText();mustConsume(\"CLOSE\");o.push({name:l||(h?f++:\"\"),pattern:l&&!h?a:h,prefix:d,suffix:m,modifier:tryConsume(\"MODIFIER\")||\"\"});continue}mustConsume(\"END\")}return o}r.parse=parse;function compile(e,r){return tokensToFunction(parse(e,r),r)}r.compile=compile;function tokensToFunction(e,r){if(r===void 0){r={}}var n=flags(r);var t=r.encode,i=t===void 0?function(e){return e}:t,a=r.validate,o=a===void 0?true:a;var f=e.map((function(e){if(typeof e===\"object\"){return new RegExp(\"^(?:\"+e.pattern+\")$\",n)}}));return function(r){var n=\"\";for(var t=0;t<e.length;t++){var a=e[t];if(typeof a===\"string\"){n+=a;continue}var u=r?r[a.name]:undefined;var p=a.modifier===\"?\"||a.modifier===\"*\";var v=a.modifier===\"*\"||a.modifier===\"+\";if(Array.isArray(u)){if(!v){throw new TypeError('Expected \"'+a.name+'\" to not repeat, but got an array')}if(u.length===0){if(p)continue;throw new TypeError('Expected \"'+a.name+'\" to not be empty')}for(var c=0;c<u.length;c++){var s=i(u[c],a);if(o&&!f[t].test(s)){throw new TypeError('Expected all \"'+a.name+'\" to match \"'+a.pattern+'\", but got \"'+s+'\"')}n+=a.prefix+s+a.suffix}continue}if(typeof u===\"string\"||typeof u===\"number\"){var s=i(String(u),a);if(o&&!f[t].test(s)){throw new TypeError('Expected \"'+a.name+'\" to match \"'+a.pattern+'\", but got \"'+s+'\"')}n+=a.prefix+s+a.suffix;continue}if(p)continue;var d=v?\"an array\":\"a string\";throw new TypeError('Expected \"'+a.name+'\" to be '+d)}return n}}r.tokensToFunction=tokensToFunction;function match(e,r){var n=[];var t=pathToRegexp(e,n,r);return regexpToFunction(t,n,r)}r.match=match;function regexpToFunction(e,r,n){if(n===void 0){n={}}var t=n.decode,i=t===void 0?function(e){return e}:t;return function(n){var t=e.exec(n);if(!t)return false;var a=t[0],o=t.index;var f=Object.create(null);var _loop_1=function(e){if(t[e]===undefined)return\"continue\";var n=r[e-1];if(n.modifier===\"*\"||n.modifier===\"+\"){f[n.name]=t[e].split(n.prefix+n.suffix).map((function(e){return i(e,n)}))}else{f[n.name]=i(t[e],n)}};for(var u=1;u<t.length;u++){_loop_1(u)}return{path:a,index:o,params:f}}}r.regexpToFunction=regexpToFunction;function escapeString(e){return e.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g,\"\\\\$1\")}function flags(e){return e&&e.sensitive?\"\":\"i\"}function regexpToRegexp(e,r){if(!r)return e;var n=e.source.match(/\\((?!\\?)/g);if(n){for(var t=0;t<n.length;t++){r.push({name:t,prefix:\"\",suffix:\"\",modifier:\"\",pattern:\"\"})}}return e}function arrayToRegexp(e,r,n){var t=e.map((function(e){return pathToRegexp(e,r,n).source}));return new RegExp(\"(?:\"+t.join(\"|\")+\")\",flags(n))}function stringToRegexp(e,r,n){return tokensToRegexp(parse(e,n),r,n)}function tokensToRegexp(e,r,n){if(n===void 0){n={}}var t=n.strict,i=t===void 0?false:t,a=n.start,o=a===void 0?true:a,f=n.end,u=f===void 0?true:f,p=n.encode,v=p===void 0?function(e){return e}:p;var c=\"[\"+escapeString(n.endsWith||\"\")+\"]|$\";var s=\"[\"+escapeString(n.delimiter||\"/#?\")+\"]\";var d=o?\"^\":\"\";for(var g=0,x=e;g<x.length;g++){var l=x[g];if(typeof l===\"string\"){d+=escapeString(v(l))}else{var h=escapeString(v(l.prefix));var m=escapeString(v(l.suffix));if(l.pattern){if(r)r.push(l);if(h||m){if(l.modifier===\"+\"||l.modifier===\"*\"){var E=l.modifier===\"*\"?\"?\":\"\";d+=\"(?:\"+h+\"((?:\"+l.pattern+\")(?:\"+m+h+\"(?:\"+l.pattern+\"))*)\"+m+\")\"+E}else{d+=\"(?:\"+h+\"(\"+l.pattern+\")\"+m+\")\"+l.modifier}}else{d+=\"(\"+l.pattern+\")\"+l.modifier}}else{d+=\"(?:\"+h+m+\")\"+l.modifier}}}if(u){if(!i)d+=s+\"?\";d+=!n.endsWith?\"$\":\"(?=\"+c+\")\"}else{var T=e[e.length-1];var y=typeof T===\"string\"?s.indexOf(T[T.length-1])>-1:T===undefined;if(!i){d+=\"(?:\"+s+\"(?=\"+c+\"))?\"}if(!y){d+=\"(?=\"+s+\"|\"+c+\")\"}}return new RegExp(d,flags(n))}r.tokensToRegexp=tokensToRegexp;function pathToRegexp(e,r,n){if(e instanceof RegExp)return regexpToRegexp(e,r);if(Array.isArray(e))return arrayToRegexp(e,r,n);return stringToRegexp(e,r,n)}r.pathToRegexp=pathToRegexp})();module.exports=e})();\n\\ No newline at end of file\n+(()=>{\"use strict\";if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var e={};(()=>{var n=e;Object.defineProperty(n,\"__esModule\",{value:true});n.pathToRegexp=n.tokensToRegexp=n.regexpToFunction=n.match=n.tokensToFunction=n.compile=n.parse=void 0;function lexer(e){var n=[];var r=0;while(r<e.length){var t=e[r];if(t===\"*\"||t===\"+\"||t===\"?\"){n.push({type:\"MODIFIER\",index:r,value:e[r++]});continue}if(t===\"\\\\\"){n.push({type:\"ESCAPED_CHAR\",index:r++,value:e[r++]});continue}if(t===\"{\"){n.push({type:\"OPEN\",index:r,value:e[r++]});continue}if(t===\"}\"){n.push({type:\"CLOSE\",index:r,value:e[r++]});continue}if(t===\":\"){var a=\"\";var i=r+1;while(i<e.length){var o=e.charCodeAt(i);if(o>=48&&o<=57||o>=65&&o<=90||o>=97&&o<=122||o===95){a+=e[i++];continue}break}if(!a)throw new TypeError(\"Missing parameter name at \".concat(r));n.push({type:\"NAME\",index:r,value:a});r=i;continue}if(t===\"(\"){var c=1;var f=\"\";var i=r+1;if(e[i]===\"?\"){throw new TypeError('Pattern cannot start with \"?\" at '.concat(i))}while(i<e.length){if(e[i]===\"\\\\\"){f+=e[i++]+e[i++];continue}if(e[i]===\")\"){c--;if(c===0){i++;break}}else if(e[i]===\"(\"){c++;if(e[i+1]!==\"?\"){throw new TypeError(\"Capturing groups are not allowed at \".concat(i))}}f+=e[i++]}if(c)throw new TypeError(\"Unbalanced pattern at \".concat(r));if(!f)throw new TypeError(\"Missing pattern at \".concat(r));n.push({type:\"PATTERN\",index:r,value:f});r=i;continue}n.push({type:\"CHAR\",index:r,value:e[r++]})}n.push({type:\"END\",index:r,value:\"\"});return n}function parse(e,n){if(n===void 0){n={}}var r=lexer(e);var t=n.prefixes,a=t===void 0?\"./\":t,i=n.delimiter,o=i===void 0?\"/#?\":i;var c=[];var f=0;var u=0;var p=\"\";var tryConsume=function(e){if(u<r.length&&r[u].type===e)return r[u++].value};var mustConsume=function(e){var n=tryConsume(e);if(n!==undefined)return n;var t=r[u],a=t.type,i=t.index;throw new TypeError(\"Unexpected \".concat(a,\" at \").concat(i,\", expected \").concat(e))};var consumeText=function(){var e=\"\";var n;while(n=tryConsume(\"CHAR\")||tryConsume(\"ESCAPED_CHAR\")){e+=n}return e};var isSafe=function(e){for(var n=0,r=o;n<r.length;n++){var t=r[n];if(e.indexOf(t)>-1)return true}return false};var safePattern=function(e){var n=c[c.length-1];var r=e||(n&&typeof n===\"string\"?n:\"\");if(n&&!r){throw new TypeError('Must have text between two parameters, missing text after \"'.concat(n.name,'\"'))}if(!r||isSafe(r))return\"[^\".concat(escapeString(o),\"]+?\");return\"(?:(?!\".concat(escapeString(r),\")[^\").concat(escapeString(o),\"])+?\")};while(u<r.length){var v=tryConsume(\"CHAR\");var s=tryConsume(\"NAME\");var d=tryConsume(\"PATTERN\");if(s||d){var g=v||\"\";if(a.indexOf(g)===-1){p+=g;g=\"\"}if(p){c.push(p);p=\"\"}c.push({name:s||f++,prefix:g,suffix:\"\",pattern:d||safePattern(g),modifier:tryConsume(\"MODIFIER\")||\"\"});continue}var x=v||tryConsume(\"ESCAPED_CHAR\");if(x){p+=x;continue}if(p){c.push(p);p=\"\"}var h=tryConsume(\"OPEN\");if(h){var g=consumeText();var l=tryConsume(\"NAME\")||\"\";var m=tryConsume(\"PATTERN\")||\"\";var T=consumeText();mustConsume(\"CLOSE\");c.push({name:l||(m?f++:\"\"),pattern:l&&!m?safePattern(g):m,prefix:g,suffix:T,modifier:tryConsume(\"MODIFIER\")||\"\"});continue}mustConsume(\"END\")}return c}n.parse=parse;function compile(e,n){return tokensToFunction(parse(e,n),n)}n.compile=compile;function tokensToFunction(e,n){if(n===void 0){n={}}var r=flags(n);var t=n.encode,a=t===void 0?function(e){return e}:t,i=n.validate,o=i===void 0?true:i;var c=e.map((function(e){if(typeof e===\"object\"){return new RegExp(\"^(?:\".concat(e.pattern,\")$\"),r)}}));return function(n){var r=\"\";for(var t=0;t<e.length;t++){var i=e[t];if(typeof i===\"string\"){r+=i;continue}var f=n?n[i.name]:undefined;var u=i.modifier===\"?\"||i.modifier===\"*\";var p=i.modifier===\"*\"||i.modifier===\"+\";if(Array.isArray(f)){if(!p){throw new TypeError('Expected \"'.concat(i.name,'\" to not repeat, but got an array'))}if(f.length===0){if(u)continue;throw new TypeError('Expected \"'.concat(i.name,'\" to not be empty'))}for(var v=0;v<f.length;v++){var s=a(f[v],i);if(o&&!c[t].test(s)){throw new TypeError('Expected all \"'.concat(i.name,'\" to match \"').concat(i.pattern,'\", but got \"').concat(s,'\"'))}r+=i.prefix+s+i.suffix}continue}if(typeof f===\"string\"||typeof f===\"number\"){var s=a(String(f),i);if(o&&!c[t].test(s)){throw new TypeError('Expected \"'.concat(i.name,'\" to match \"').concat(i.pattern,'\", but got \"').concat(s,'\"'))}r+=i.prefix+s+i.suffix;continue}if(u)continue;var d=p?\"an array\":\"a string\";throw new TypeError('Expected \"'.concat(i.name,'\" to be ').concat(d))}return r}}n.tokensToFunction=tokensToFunction;function match(e,n){var r=[];var t=pathToRegexp(e,r,n);return regexpToFunction(t,r,n)}n.match=match;function regexpToFunction(e,n,r){if(r===void 0){r={}}var t=r.decode,a=t===void 0?function(e){return e}:t;return function(r){var t=e.exec(r);if(!t)return false;var i=t[0],o=t.index;var c=Object.create(null);var _loop_1=function(e){if(t[e]===undefined)return\"continue\";var r=n[e-1];if(r.modifier===\"*\"||r.modifier===\"+\"){c[r.name]=t[e].split(r.prefix+r.suffix).map((function(e){return a(e,r)}))}else{c[r.name]=a(t[e],r)}};for(var f=1;f<t.length;f++){_loop_1(f)}return{path:i,index:o,params:c}}}n.regexpToFunction=regexpToFunction;function escapeString(e){return e.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g,\"\\\\$1\")}function flags(e){return e&&e.sensitive?\"\":\"i\"}function regexpToRegexp(e,n){if(!n)return e;var r=/\\((?:\\?<(.*?)>)?(?!\\?)/g;var t=0;var a=r.exec(e.source);while(a){n.push({name:a[1]||t++,prefix:\"\",suffix:\"\",modifier:\"\",pattern:\"\"});a=r.exec(e.source)}return e}function arrayToRegexp(e,n,r){var t=e.map((function(e){return pathToRegexp(e,n,r).source}));return new RegExp(\"(?:\".concat(t.join(\"|\"),\")\"),flags(r))}function stringToRegexp(e,n,r){return tokensToRegexp(parse(e,r),n,r)}function tokensToRegexp(e,n,r){if(r===void 0){r={}}var t=r.strict,a=t===void 0?false:t,i=r.start,o=i===void 0?true:i,c=r.end,f=c===void 0?true:c,u=r.encode,p=u===void 0?function(e){return e}:u,v=r.delimiter,s=v===void 0?\"/#?\":v,d=r.endsWith,g=d===void 0?\"\":d;var x=\"[\".concat(escapeString(g),\"]|$\");var h=\"[\".concat(escapeString(s),\"]\");var l=o?\"^\":\"\";for(var m=0,T=e;m<T.length;m++){var E=T[m];if(typeof E===\"string\"){l+=escapeString(p(E))}else{var w=escapeString(p(E.prefix));var y=escapeString(p(E.suffix));if(E.pattern){if(n)n.push(E);if(w||y){if(E.modifier===\"+\"||E.modifier===\"*\"){var R=E.modifier===\"*\"?\"?\":\"\";l+=\"(?:\".concat(w,\"((?:\").concat(E.pattern,\")(?:\").concat(y).concat(w,\"(?:\").concat(E.pattern,\"))*)\").concat(y,\")\").concat(R)}else{l+=\"(?:\".concat(w,\"(\").concat(E.pattern,\")\").concat(y,\")\").concat(E.modifier)}}else{if(E.modifier===\"+\"||E.modifier===\"*\"){throw new TypeError('Can not repeat \"'.concat(E.name,'\" without a prefix and suffix'))}l+=\"(\".concat(E.pattern,\")\").concat(E.modifier)}}else{l+=\"(?:\".concat(w).concat(y,\")\").concat(E.modifier)}}}if(f){if(!a)l+=\"\".concat(h,\"?\");l+=!r.endsWith?\"$\":\"(?=\".concat(x,\")\")}else{var A=e[e.length-1];var _=typeof A===\"string\"?h.indexOf(A[A.length-1])>-1:A===undefined;if(!a){l+=\"(?:\".concat(h,\"(?=\").concat(x,\"))?\")}if(!_){l+=\"(?=\".concat(h,\"|\").concat(x,\")\")}}return new RegExp(l,flags(r))}n.tokensToRegexp=tokensToRegexp;function pathToRegexp(e,n,r){if(e instanceof RegExp)return regexpToRegexp(e,n);if(Array.isArray(e))return arrayToRegexp(e,n,r);return stringToRegexp(e,n,r)}n.pathToRegexp=pathToRegexp})();module.exports=e})();\n\\ No newline at end of file"
        },
        {
            "sha": "d41ddd5a76a01f2e1f41aed7c8dce404c008fe40",
            "filename": "packages/next/src/lib/generate-interception-routes-rewrites.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fgenerate-interception-routes-rewrites.ts?ref=7bcef6872d4ee6afb396050184f93d5902d2f969",
            "patch": "@@ -1,10 +1,10 @@\n-import { pathToRegexp } from 'next/dist/compiled/path-to-regexp'\n import { NEXT_URL } from '../client/components/app-router-headers'\n import {\n   extractInterceptionRouteInformation,\n   isInterceptionRouteAppPath,\n } from '../shared/lib/router/utils/interception-routes'\n import type { Rewrite } from './load-custom-routes'\n+import { safePathToRegexp } from '../shared/lib/router/utils/route-match-utils'\n \n // a function that converts normalised paths (e.g. /foo/[bar]/[baz]) to the format expected by pathToRegexp (e.g. /foo/:bar/:baz)\n function toPathToRegexpPath(path: string): string {\n@@ -41,7 +41,7 @@ export function generateInterceptionRoutesRewrites(\n       // pathToRegexp returns a regex that matches the path, but we need to\n       // convert it to a string that can be used in a header value\n       // to the format that Next/the proxy expects\n-      let interceptingRouteRegex = pathToRegexp(normalizedInterceptingRoute)\n+      let interceptingRouteRegex = safePathToRegexp(normalizedInterceptingRoute)\n         .toString()\n         .slice(2, -3)\n "
        },
        {
            "sha": "0a2498471c6dc2886d13aa571c04e2ebbdb5b3f3",
            "filename": "packages/next/src/lib/route-pattern-normalizer.ts",
            "status": "added",
            "additions": 126,
            "deletions": 0,
            "changes": 126,
            "blob_url": "https://github.com/vercel/next.js/blob/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Flib%2Froute-pattern-normalizer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Flib%2Froute-pattern-normalizer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Froute-pattern-normalizer.ts?ref=7bcef6872d4ee6afb396050184f93d5902d2f969",
            "patch": "@@ -0,0 +1,126 @@\n+import type { Token } from 'next/dist/compiled/path-to-regexp'\n+\n+/**\n+ * Route pattern normalization utilities for path-to-regexp compatibility.\n+ *\n+ * path-to-regexp 6.3.0+ introduced stricter validation that rejects certain\n+ * patterns commonly used in Next.js interception routes. This module provides\n+ * normalization functions to make Next.js route patterns compatible with the\n+ * updated library while preserving all functionality.\n+ */\n+\n+/**\n+ * Internal separator used to normalize adjacent parameter patterns.\n+ * This unique marker is inserted between adjacent parameters and stripped out\n+ * during parameter extraction to avoid conflicts with real URL content.\n+ */\n+const PARAM_SEPARATOR = '_NEXTSEP_'\n+\n+/**\n+ * Detects if a route pattern needs normalization for path-to-regexp compatibility.\n+ */\n+export function hasAdjacentParameterIssues(route: string): boolean {\n+  if (typeof route !== 'string') return false\n+\n+  // Check for interception route markers followed immediately by parameters\n+  // Pattern: /(.):param, /(..):param, /(...):param, /(.)(.):param etc.\n+  // These patterns cause \"Must have text between two parameters\" errors\n+  if (/\\/\\(\\.{1,3}\\):[^/\\s]+/.test(route)) {\n+    return true\n+  }\n+\n+  // Check for basic adjacent parameters without separators\n+  // Pattern: :param1:param2 (but not :param* or other URL patterns)\n+  if (/:[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z_][a-zA-Z0-9_]*/.test(route)) {\n+    return true\n+  }\n+\n+  return false\n+}\n+\n+/**\n+ * Normalizes route patterns that have adjacent parameters without text between them.\n+ * Inserts a unique separator that can be safely stripped out later.\n+ */\n+export function normalizeAdjacentParameters(route: string): string {\n+  let normalized = route\n+\n+  // Handle interception route patterns: (.):param -> (.)_NEXTSEP_:param\n+  normalized = normalized.replace(\n+    /(\\([^)]*\\)):([^/\\s]+)/g,\n+    `$1${PARAM_SEPARATOR}:$2`\n+  )\n+\n+  // Handle other adjacent parameter patterns: :param1:param2 -> :param1_NEXTSEP_:param2\n+  normalized = normalized.replace(/:([^:/\\s)]+)(?=:)/g, `:$1${PARAM_SEPARATOR}`)\n+\n+  return normalized\n+}\n+\n+/**\n+ * Normalizes tokens that have repeating modifiers (* or +) but empty prefix and suffix.\n+ *\n+ * path-to-regexp 6.3.0+ introduced validation that throws:\n+ * \"Can not repeat without prefix/suffix\"\n+ *\n+ * This occurs when a token has modifier: '*' or '+' with both prefix: '' and suffix: ''\n+ */\n+export function normalizeTokensForRegexp(tokens: Token[]): Token[] {\n+  return tokens.map((token) => {\n+    // Token union type: Token = string | TokenObject\n+    // Literal path segments are strings, parameters/wildcards are objects\n+    if (\n+      typeof token === 'object' &&\n+      token !== null &&\n+      // Not all token objects have 'modifier' property (e.g., simple text tokens)\n+      'modifier' in token &&\n+      // Only repeating modifiers (* or +) cause the validation error\n+      // Other modifiers like '?' (optional) are fine\n+      (token.modifier === '*' || token.modifier === '+') &&\n+      // Token objects can have different shapes depending on route pattern\n+      'prefix' in token &&\n+      'suffix' in token &&\n+      // Both prefix and suffix must be empty strings\n+      // This is what causes the validation error in path-to-regexp\n+      token.prefix === '' &&\n+      token.suffix === ''\n+    ) {\n+      // Add minimal prefix to satisfy path-to-regexp validation\n+      // We use '/' as it's the most common path delimiter and won't break route matching\n+      // The prefix gets used in regex generation but doesn't affect parameter extraction\n+      return {\n+        ...token,\n+        prefix: '/',\n+      }\n+    }\n+    return token\n+  })\n+}\n+\n+/**\n+ * Strips normalization separators from extracted route parameters.\n+ * Used by both server and client code to clean up parameters after route matching.\n+ */\n+export function stripParameterSeparators(\n+  params: Record<string, any>\n+): Record<string, any> {\n+  const cleaned: Record<string, any> = {}\n+\n+  for (const [key, value] of Object.entries(params)) {\n+    if (typeof value === 'string') {\n+      // Remove the separator if it appears at the start of parameter values\n+      cleaned[key] = value.replace(new RegExp(`^${PARAM_SEPARATOR}`), '')\n+    } else if (Array.isArray(value)) {\n+      // Handle array parameters (from repeated route segments)\n+      cleaned[key] = value.map((item) =>\n+        typeof item === 'string'\n+          ? item.replace(new RegExp(`^${PARAM_SEPARATOR}`), '')\n+          : item\n+      )\n+    } else {\n+      cleaned[key] = value\n+    }\n+  }\n+\n+  return cleaned\n+}"
        },
        {
            "sha": "7fdf995b4f69c6cd6fbaa6a61cd5032618b2cdd7",
            "filename": "packages/next/src/lib/try-to-parse-path.ts",
            "status": "modified",
            "additions": 22,
            "deletions": 1,
            "changes": 23,
            "blob_url": "https://github.com/vercel/next.js/blob/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Flib%2Ftry-to-parse-path.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Flib%2Ftry-to-parse-path.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Ftry-to-parse-path.ts?ref=7bcef6872d4ee6afb396050184f93d5902d2f969",
            "patch": "@@ -2,6 +2,7 @@ import type { Token } from 'next/dist/compiled/path-to-regexp'\n import { parse, tokensToRegexp } from 'next/dist/compiled/path-to-regexp'\n import { parse as parseURL } from 'url'\n import isError from './is-error'\n+import { normalizeTokensForRegexp } from './route-pattern-normalizer'\n \n interface ParseResult {\n   error?: any\n@@ -34,6 +35,22 @@ function reportError({ route, parsedPath }: ParseResult, err: any) {\n   }\n }\n \n+/**\n+ * Safe wrapper around tokensToRegexp that handles path-to-regexp 6.3.0+ validation errors.\n+ */\n+function safeTokensToRegexp(tokens: Token[]): RegExp {\n+  try {\n+    return tokensToRegexp(tokens)\n+  } catch (error) {\n+    if (isError(error)) {\n+      // Try to normalize tokens with repeating modifiers but no prefix/suffix\n+      const normalizedTokens = normalizeTokensForRegexp(tokens)\n+      return tokensToRegexp(normalizedTokens)\n+    }\n+    throw error\n+  }\n+}\n+\n /**\n  * Attempts to parse a given route with `path-to-regexp` and returns an object\n  * with the result. Whenever an error happens on parse, it will print an error\n@@ -55,7 +72,11 @@ export function tryToParsePath(\n     }\n \n     result.tokens = parse(result.parsedPath)\n-    result.regexStr = tokensToRegexp(result.tokens).source\n+\n+    // Use safe wrapper instead of proactive detection\n+    if (result.tokens) {\n+      result.regexStr = safeTokensToRegexp(result.tokens).source\n+    }\n   } catch (err) {\n     reportError(result, err)\n     result.error = err"
        },
        {
            "sha": "912ed8b4d35157b7474229e0b9d4f26e60fdcc48",
            "filename": "packages/next/src/shared/lib/router/utils/path-match.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fpath-match.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fpath-match.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fpath-match.ts?ref=7bcef6872d4ee6afb396050184f93d5902d2f969",
            "patch": "@@ -1,6 +1,6 @@\n import type { Key } from 'next/dist/compiled/path-to-regexp'\n-import { pathToRegexp } from 'next/dist/compiled/path-to-regexp'\n import { regexpToFunction } from 'next/dist/compiled/path-to-regexp'\n+import { pathToRegexp } from 'next/dist/compiled/path-to-regexp'\n \n interface Options {\n   /**"
        },
        {
            "sha": "25f3d26ad31f2ffd77812322a990143f4bbbee84",
            "filename": "packages/next/src/shared/lib/router/utils/prepare-destination.ts",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fprepare-destination.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fprepare-destination.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fprepare-destination.ts?ref=7bcef6872d4ee6afb396050184f93d5902d2f969",
            "patch": "@@ -4,7 +4,6 @@ import type { NextParsedUrlQuery } from '../../../../server/request-meta'\n import type { RouteHas } from '../../../../lib/load-custom-routes'\n import type { BaseNextRequest } from '../../../../server/base-http'\n \n-import { compile, pathToRegexp } from 'next/dist/compiled/path-to-regexp'\n import { escapeStringRegexp } from '../../escape-regexp'\n import { parseUrl } from './parse-url'\n import {\n@@ -13,6 +12,7 @@ import {\n } from './interception-routes'\n import { getCookieParser } from '../../../../server/api-utils/get-cookie-parser'\n import type { Params } from '../../../../server/request/params'\n+import { safePathToRegexp, safeCompile } from './route-match-utils'\n \n /**\n  * Ensure only a-zA-Z are used for param names for proper interpolating\n@@ -156,7 +156,7 @@ export function compileNonPath(value: string, params: Params): string {\n \n   // the value needs to start with a forward-slash to be compiled\n   // correctly\n-  return compile(`/${value}`, { validate: false })(params).slice(1)\n+  return safeCompile(`/${value}`, { validate: false })(params).slice(1)\n }\n \n export function parseDestination(args: {\n@@ -222,20 +222,20 @@ export function prepareDestination(args: {\n   const destParams: (string | number)[] = []\n \n   const destPathParamKeys: Key[] = []\n-  pathToRegexp(destPath, destPathParamKeys)\n+  safePathToRegexp(destPath, destPathParamKeys)\n   for (const key of destPathParamKeys) {\n     destParams.push(key.name)\n   }\n \n   if (destHostname) {\n     const destHostnameParamKeys: Key[] = []\n-    pathToRegexp(destHostname, destHostnameParamKeys)\n+    safePathToRegexp(destHostname, destHostnameParamKeys)\n     for (const key of destHostnameParamKeys) {\n       destParams.push(key.name)\n     }\n   }\n \n-  const destPathCompiler = compile(\n+  const destPathCompiler = safeCompile(\n     destPath,\n     // we don't validate while compiling the destination since we should\n     // have already validated before we got to this point and validating\n@@ -248,7 +248,7 @@ export function prepareDestination(args: {\n \n   let destHostnameCompiler\n   if (destHostname) {\n-    destHostnameCompiler = compile(destHostname, { validate: false })\n+    destHostnameCompiler = safeCompile(destHostname, { validate: false })\n   }\n \n   // update any params in query values"
        },
        {
            "sha": "e99d024865508529ab6d9a4cec406eba78ee1bc3",
            "filename": "packages/next/src/shared/lib/router/utils/route-match-utils.ts",
            "status": "added",
            "additions": 124,
            "deletions": 0,
            "changes": 124,
            "blob_url": "https://github.com/vercel/next.js/blob/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-match-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-match-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-match-utils.ts?ref=7bcef6872d4ee6afb396050184f93d5902d2f969",
            "patch": "@@ -0,0 +1,124 @@\n+/**\n+ * Client-safe utilities for route matching that don't import server-side\n+ * utilities to avoid bundling issues with Turbopack\n+ */\n+\n+import type {\n+  Key,\n+  TokensToRegexpOptions,\n+  ParseOptions,\n+  TokensToFunctionOptions,\n+} from 'next/dist/compiled/path-to-regexp'\n+import {\n+  pathToRegexp,\n+  compile,\n+  regexpToFunction,\n+} from 'next/dist/compiled/path-to-regexp'\n+import {\n+  hasAdjacentParameterIssues,\n+  normalizeAdjacentParameters,\n+  stripParameterSeparators,\n+} from '../../../../lib/route-pattern-normalizer'\n+\n+/**\n+ * Client-safe wrapper around pathToRegexp that handles path-to-regexp 6.3.0+ validation errors.\n+ * This includes both \"Can not repeat without prefix/suffix\" and \"Must have text between parameters\" errors.\n+ */\n+export function safePathToRegexp(\n+  route: string | RegExp | Array<string | RegExp>,\n+  keys?: Key[],\n+  options?: TokensToRegexpOptions & ParseOptions\n+): RegExp {\n+  if (typeof route !== 'string') {\n+    return pathToRegexp(route, keys, options)\n+  }\n+\n+  // Check if normalization is needed and cache the result\n+  const needsNormalization = hasAdjacentParameterIssues(route)\n+  const routeToUse = needsNormalization\n+    ? normalizeAdjacentParameters(route)\n+    : route\n+\n+  try {\n+    return pathToRegexp(routeToUse, keys, options)\n+  } catch (error) {\n+    // Only try normalization if we haven't already normalized\n+    if (!needsNormalization) {\n+      try {\n+        const normalizedRoute = normalizeAdjacentParameters(route)\n+        return pathToRegexp(normalizedRoute, keys, options)\n+      } catch (retryError) {\n+        // If that doesn't work, fall back to original error\n+        throw error\n+      }\n+    }\n+    throw error\n+  }\n+}\n+\n+/**\n+ * Client-safe wrapper around compile that handles path-to-regexp 6.3.0+ validation errors.\n+ * No server-side error reporting to avoid bundling issues.\n+ */\n+export function safeCompile(\n+  route: string,\n+  options?: TokensToFunctionOptions & ParseOptions\n+) {\n+  // Check if normalization is needed and cache the result\n+  const needsNormalization = hasAdjacentParameterIssues(route)\n+  const routeToUse = needsNormalization\n+    ? normalizeAdjacentParameters(route)\n+    : route\n+\n+  try {\n+    return compile(routeToUse, options)\n+  } catch (error) {\n+    // Only try normalization if we haven't already normalized\n+    if (!needsNormalization) {\n+      try {\n+        const normalizedRoute = normalizeAdjacentParameters(route)\n+        return compile(normalizedRoute, options)\n+      } catch (retryError) {\n+        // If that doesn't work, fall back to original error\n+        throw error\n+      }\n+    }\n+    throw error\n+  }\n+}\n+\n+/**\n+ * Client-safe wrapper around regexpToFunction that automatically cleans parameters.\n+ */\n+export function safeRegexpToFunction<\n+  T extends Record<string, any> = Record<string, any>,\n+>(regexp: RegExp, keys?: Key[]): (pathname: string) => { params: T } | false {\n+  const originalMatcher = regexpToFunction<T>(regexp, keys || [])\n+\n+  return (pathname: string) => {\n+    const result = originalMatcher(pathname)\n+    if (!result) return false\n+\n+    // Clean parameters before returning\n+    return {\n+      ...result,\n+      params: stripParameterSeparators(result.params as any) as T,\n+    }\n+  }\n+}\n+\n+/**\n+ * Safe wrapper for route matcher functions that automatically cleans parameters.\n+ * This is client-safe and doesn't import path-to-regexp.\n+ */\n+export function safeRouteMatcher<T extends Record<string, any>>(\n+  matcherFn: (pathname: string) => false | T\n+): (pathname: string) => false | T {\n+  return (pathname: string) => {\n+    const result = matcherFn(pathname)\n+    if (!result) return false\n+\n+    // Clean parameters before returning\n+    return stripParameterSeparators(result) as T\n+  }\n+}"
        },
        {
            "sha": "dba877ce56675d518169449591691da8c00feea8",
            "filename": "packages/next/src/shared/lib/router/utils/route-matcher.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-matcher.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-matcher.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-matcher.ts?ref=7bcef6872d4ee6afb396050184f93d5902d2f969",
            "patch": "@@ -1,6 +1,7 @@\n import type { Group } from './route-regex'\n import { DecodeError } from '../../utils'\n import type { Params } from '../../../../server/request/params'\n+import { safeRouteMatcher } from './route-match-utils'\n \n export interface RouteMatchFn {\n   (pathname: string): false | Params\n@@ -17,7 +18,7 @@ export function getRouteMatcher({\n   re,\n   groups,\n }: RouteMatcherOptions): RouteMatchFn {\n-  return (pathname: string) => {\n+  const rawMatcher = (pathname: string) => {\n     const routeMatch = re.exec(pathname)\n     if (!routeMatch) return false\n \n@@ -43,4 +44,7 @@ export function getRouteMatcher({\n \n     return params\n   }\n+\n+  // Wrap with safe matcher to handle parameter cleaning\n+  return safeRouteMatcher(rawMatcher)\n }"
        },
        {
            "sha": "87957b137c84d539fa3b4e8eb186e0d02292fffe",
            "filename": "packages/next/src/shared/lib/turbopack/manifest-loader.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Fmanifest-loader.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7bcef6872d4ee6afb396050184f93d5902d2f969/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Fmanifest-loader.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fturbopack%2Fmanifest-loader.ts?ref=7bcef6872d4ee6afb396050184f93d5902d2f969",
            "patch": "@@ -12,7 +12,6 @@ import type {\n import type { BuildManifest } from '../../../server/get-page-files'\n import type { AppBuildManifest } from '../../../build/webpack/plugins/app-build-manifest-plugin'\n import type { PagesManifest } from '../../../build/webpack/plugins/pages-manifest-plugin'\n-import { pathToRegexp } from 'next/dist/compiled/path-to-regexp'\n import type { ActionManifest } from '../../../build/webpack/plugins/flight-client-entry-plugin'\n import type { NextFontManifest } from '../../../build/webpack/plugins/next-font-manifest-plugin'\n import type { REACT_LOADABLE_MANIFEST } from '../constants'\n@@ -54,6 +53,7 @@ import {\n   removeRouteSuffix,\n } from '../../../server/dev/turbopack-utils'\n import { tryToParsePath } from '../../../lib/try-to-parse-path'\n+import { safePathToRegexp } from '../router/utils/route-match-utils'\n import type { Entrypoints } from '../../../build/swc/types'\n \n interface InstrumentationDefinition {\n@@ -715,7 +715,7 @@ export class TurbopackManifestLoader {\n     )) {\n       for (const matcher of fun.matchers) {\n         if (!matcher.regexp) {\n-          matcher.regexp = pathToRegexp(matcher.originalSource, [], {\n+          matcher.regexp = safePathToRegexp(matcher.originalSource, [], {\n             delimiter: '/',\n             sensitive: false,\n             strict: true,"
        },
        {
            "sha": "7af316e0079c765435ff83818a7fe9b62ba26faa",
            "filename": "pnpm-lock.yaml",
            "status": "modified",
            "additions": 8,
            "deletions": 13,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/7bcef6872d4ee6afb396050184f93d5902d2f969/pnpm-lock.yaml",
            "raw_url": "https://github.com/vercel/next.js/raw/7bcef6872d4ee6afb396050184f93d5902d2f969/pnpm-lock.yaml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/pnpm-lock.yaml?ref=7bcef6872d4ee6afb396050184f93d5902d2f969",
            "patch": "@@ -1430,8 +1430,8 @@ importers:\n         specifier: 1.0.1\n         version: 1.0.1\n       path-to-regexp:\n-        specifier: 6.1.0\n-        version: 6.1.0\n+        specifier: 6.3.0\n+        version: 6.3.0\n       picomatch:\n         specifier: 4.0.1\n         version: 4.0.1\n@@ -12938,11 +12938,8 @@ packages:\n   path-to-regexp@3.3.0:\n     resolution: {integrity: sha512-qyCH421YQPS2WFDxDjftfc1ZR5WKQzVzqsp4n9M2kQhVOo/ByahFoUNJfl58kOcEGfQ//7weFTDhm+ss8Ecxgw==}\n \n-  path-to-regexp@6.1.0:\n-    resolution: {integrity: sha512-h9DqehX3zZZDCEm+xbfU0ZmwCGFCAAraPJWMXJ4+v32NjZJilVg3k1TcKsRgIb8IQ/izZSaydDc1OhJCZvs2Dw==}\n-\n-  path-to-regexp@6.2.1:\n-    resolution: {integrity: sha512-JLyh7xT1kizaEvcaXOQwOc2/Yhw6KZOvPf1S8401UyLk86CU79LN3vl7ztXGm/pZ+YjoyAJ4rxmHwbkBXJX+yw==}\n+  path-to-regexp@6.3.0:\n+    resolution: {integrity: sha512-Yhpw4T9C6hPpgPeA28us07OJeqZ5EzQTkbfwuhsUg0c237RomFoETJgmp2sa3F/41gfLE6G5cqcYwznmeEeOlQ==}\n \n   path-type@1.1.0:\n     resolution: {integrity: sha512-S4eENJz1pkiQn9Znv33Q+deTOKmbl+jj1Fl+qiP/vYezj+S8x+J3Uo0ISrx/QoEvIlOaDWJhPaRd1flJ9HXZqg==}\n@@ -21695,7 +21692,7 @@ snapshots:\n \n   '@types/path-to-regexp@1.7.0':\n     dependencies:\n-      path-to-regexp: 6.1.0\n+      path-to-regexp: 6.3.0\n \n   '@types/picomatch@2.3.3': {}\n \n@@ -24578,7 +24575,7 @@ snapshots:\n       msgpack-lite: 0.1.26\n       node-abort-controller: 3.1.1\n       opentracing: 0.14.7\n-      path-to-regexp: 0.1.7\n+      path-to-regexp: 0.1.12\n       protobufjs: 7.2.4\n       retry: 0.13.1\n       semver: 7.6.3\n@@ -30282,7 +30279,7 @@ snapshots:\n       headers-polyfill: 4.0.3\n       is-node-process: 1.2.0\n       outvariant: 1.4.2\n-      path-to-regexp: 6.2.1\n+      path-to-regexp: 6.3.0\n       strict-event-emitter: 0.5.1\n       type-fest: 4.18.3\n       yargs: 17.7.2\n@@ -31175,9 +31172,7 @@ snapshots:\n \n   path-to-regexp@3.3.0: {}\n \n-  path-to-regexp@6.1.0: {}\n-\n-  path-to-regexp@6.2.1: {}\n+  path-to-regexp@6.3.0: {}\n \n   path-type@1.1.0:\n     dependencies:"
        }
    ],
    "stats": {
        "total": 326,
        "additions": 298,
        "deletions": 28
    }
}