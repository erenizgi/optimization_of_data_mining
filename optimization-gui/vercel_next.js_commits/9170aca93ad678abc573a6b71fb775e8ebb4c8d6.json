{
    "author": "sokra",
    "message": "Turbopack: improve var names, add some unit tests (#81412)\n\n### What?\n\n* improve variables names\n* add unit tests",
    "sha": "9170aca93ad678abc573a6b71fb775e8ebb4c8d6",
    "files": [
        {
            "sha": "709053963e4a890831bd52f3f7576d106ae100fc",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/9170aca93ad678abc573a6b71fb775e8ebb4c8d6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9170aca93ad678abc573a6b71fb775e8ebb4c8d6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=9170aca93ad678abc573a6b71fb775e8ebb4c8d6",
            "patch": "@@ -528,15 +528,15 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 .unwrap_or_default()\n                 .get(self.session_id);\n             if dirty_tasks > 0 || is_dirty {\n-                let root = get_mut!(task, Activeness);\n+                let activeness = get_mut!(task, Activeness);\n                 let mut task_ids_to_schedule: Vec<_> = Vec::new();\n                 // When there are dirty task, subscribe to the all_clean_event\n-                let root = if let Some(root) = root {\n+                let activeness = if let Some(activeness) = activeness {\n                     // This makes sure all tasks stay active and this task won't stale.\n                     // active_until_clean is automatically removed when this\n                     // task is clean.\n-                    root.set_active_until_clean();\n-                    root\n+                    activeness.set_active_until_clean();\n+                    activeness\n                 } else {\n                     // If we don't have a root state, add one. This also makes sure all tasks stay\n                     // active and this task won't stale. active_until_clean\n@@ -557,7 +557,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                     }\n                     get!(task, Activeness).unwrap()\n                 };\n-                let listener = root.all_clean_event.listen_with_note(move || {\n+                let listener = activeness.all_clean_event.listen_with_note(move || {\n                     format!(\"try_read_task_output (strongly consistent) from {reader:?}\")\n                 });\n                 drop(task);\n@@ -1951,11 +1951,11 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 };\n                 if !aggregated_update.is_zero() {\n                     if aggregated_update.get(self.session_id) < 0\n-                        && let Some(root_state) = get_mut!(task, Activeness)\n+                        && let Some(activeness_state) = get_mut!(task, Activeness)\n                     {\n-                        root_state.all_clean_event.notify(usize::MAX);\n-                        root_state.unset_active_until_clean();\n-                        if root_state.is_empty() {\n+                        activeness_state.all_clean_event.notify(usize::MAX);\n+                        activeness_state.unset_active_until_clean();\n+                        if activeness_state.is_empty() {\n                             task.remove(&CachedDataItemKey::Activeness {});\n                         }\n                     }\n@@ -2384,15 +2384,15 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n                 dirty_containers.get(self.session_id) > 0\n             });\n         if is_dirty || has_dirty_containers {\n-            if let Some(root_state) = get_mut!(task, Activeness) {\n+            if let Some(activeness_state) = get_mut!(task, Activeness) {\n                 // We will finish the task, but it would be removed after the task is done\n-                root_state.unset_root_type();\n-                root_state.set_active_until_clean();\n+                activeness_state.unset_root_type();\n+                activeness_state.set_active_until_clean();\n             };\n-        } else if let Some(root_state) = remove!(task, Activeness) {\n+        } else if let Some(activeness_state) = remove!(task, Activeness) {\n             // Technically nobody should be listening to this event, but just in case\n             // we notify it anyway\n-            root_state.all_clean_event.notify(usize::MAX);\n+            activeness_state.all_clean_event.notify(usize::MAX);\n         }\n     }\n "
        },
        {
            "sha": "ac8d5bc727f8f0b8d2eef9b84565b35e96a42b34",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/aggregation_update.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/9170aca93ad678abc573a6b71fb775e8ebb4c8d6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9170aca93ad678abc573a6b71fb775e8ebb4c8d6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Faggregation_update.rs?ref=9170aca93ad678abc573a6b71fb775e8ebb4c8d6",
            "patch": "@@ -346,10 +346,10 @@ impl AggregatedDataUpdate {\n                 {\n                     // When the current task is no longer dirty, we need to fire the\n                     // aggregate root events and do some cleanup\n-                    if let Some(root_state) = get_mut!(task, Activeness) {\n-                        root_state.all_clean_event.notify(usize::MAX);\n-                        root_state.unset_active_until_clean();\n-                        if root_state.is_empty() {\n+                    if let Some(activeness_state) = get_mut!(task, Activeness) {\n+                        activeness_state.all_clean_event.notify(usize::MAX);\n+                        activeness_state.unset_active_until_clean();\n+                        if activeness_state.is_empty() {\n                             task.remove(&CachedDataItemKey::Activeness {});\n                         }\n                     }"
        },
        {
            "sha": "715ee59cae942dacf2d3a29f37565fc89db13d67",
            "filename": "turbopack/crates/turbo-tasks-backend/src/data.rs",
            "status": "modified",
            "additions": 188,
            "deletions": 0,
            "changes": 188,
            "blob_url": "https://github.com/vercel/next.js/blob/9170aca93ad678abc573a6b71fb775e8ebb4c8d6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/9170aca93ad678abc573a6b71fb775e8ebb4c8d6/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fdata.rs?ref=9170aca93ad678abc573a6b71fb775e8ebb4c8d6",
            "patch": "@@ -294,6 +294,194 @@ impl DirtyContainerCount {\n     }\n }\n \n+#[cfg(test)]\n+mod dirty_container_count_tests {\n+    use turbo_tasks::SessionId;\n+\n+    use super::*;\n+\n+    const SESSION_1: SessionId = unsafe { SessionId::new_unchecked(1) };\n+    const SESSION_2: SessionId = unsafe { SessionId::new_unchecked(2) };\n+    const SESSION_3: SessionId = unsafe { SessionId::new_unchecked(3) };\n+\n+    #[test]\n+    fn test_update() {\n+        let mut count = DirtyContainerCount::default();\n+        assert!(count.is_zero());\n+\n+        let diff = count.update(1);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 1);\n+        assert_eq!(diff.get(SESSION_1), 1);\n+        assert_eq!(count.get(SESSION_2), 1);\n+        assert_eq!(diff.get(SESSION_2), 1);\n+\n+        let diff = count.update(-1);\n+        assert!(count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 0);\n+        assert_eq!(diff.get(SESSION_1), -1);\n+        assert_eq!(count.get(SESSION_2), 0);\n+        assert_eq!(diff.get(SESSION_2), -1);\n+\n+        let diff = count.update(2);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 2);\n+        assert_eq!(diff.get(SESSION_1), 1);\n+        assert_eq!(count.get(SESSION_2), 2);\n+        assert_eq!(diff.get(SESSION_2), 1);\n+\n+        let diff = count.update(-1);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 1);\n+        assert_eq!(diff.get(SESSION_1), 0);\n+        assert_eq!(count.get(SESSION_2), 1);\n+        assert_eq!(diff.get(SESSION_2), 0);\n+\n+        let diff = count.update(-1);\n+        assert!(count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 0);\n+        assert_eq!(diff.get(SESSION_1), -1);\n+        assert_eq!(count.get(SESSION_2), 0);\n+        assert_eq!(diff.get(SESSION_2), -1);\n+\n+        let diff = count.update(-1);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), -1);\n+        assert_eq!(diff.get(SESSION_1), 0);\n+        assert_eq!(count.get(SESSION_2), -1);\n+        assert_eq!(diff.get(SESSION_2), 0);\n+\n+        let diff = count.update(2);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 1);\n+        assert_eq!(diff.get(SESSION_1), 1);\n+        assert_eq!(count.get(SESSION_2), 1);\n+        assert_eq!(diff.get(SESSION_2), 1);\n+\n+        let diff = count.update(-2);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), -1);\n+        assert_eq!(diff.get(SESSION_1), -1);\n+        assert_eq!(count.get(SESSION_2), -1);\n+        assert_eq!(diff.get(SESSION_2), -1);\n+\n+        let diff = count.update(1);\n+        assert!(count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 0);\n+        assert_eq!(diff.get(SESSION_1), 0);\n+        assert_eq!(count.get(SESSION_2), 0);\n+        assert_eq!(diff.get(SESSION_2), 0);\n+    }\n+\n+    #[test]\n+    fn test_session_dependent() {\n+        let mut count = DirtyContainerCount::default();\n+        assert!(count.is_zero());\n+\n+        let diff = count.update_session_dependent(SESSION_1, 1);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 0);\n+        assert_eq!(diff.get(SESSION_1), 0);\n+        assert_eq!(count.get(SESSION_2), 1);\n+        assert_eq!(diff.get(SESSION_2), 1);\n+\n+        let diff = count.update_session_dependent(SESSION_1, -1);\n+        assert!(count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 0);\n+        assert_eq!(diff.get(SESSION_1), 0);\n+        assert_eq!(count.get(SESSION_2), 0);\n+        assert_eq!(diff.get(SESSION_2), -1);\n+\n+        let diff = count.update_session_dependent(SESSION_1, 2);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 0);\n+        assert_eq!(diff.get(SESSION_1), 0);\n+        assert_eq!(count.get(SESSION_2), 2);\n+        assert_eq!(diff.get(SESSION_2), 1);\n+\n+        let diff = count.update_session_dependent(SESSION_2, -2);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 0);\n+        assert_eq!(diff.get(SESSION_1), -1);\n+        assert_eq!(count.get(SESSION_2), 2);\n+        assert_eq!(diff.get(SESSION_2), 0);\n+        assert_eq!(count.get(SESSION_3), 0);\n+        assert_eq!(diff.get(SESSION_3), -1);\n+    }\n+\n+    #[test]\n+    fn test_update_with_dirty_state() {\n+        let mut count = DirtyContainerCount::default();\n+        let dirty = DirtyState {\n+            clean_in_session: None,\n+        };\n+        let diff = count.update_with_dirty_state(&dirty);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 1);\n+        assert_eq!(diff.get(SESSION_1), 1);\n+        assert_eq!(count.get(SESSION_2), 1);\n+        assert_eq!(diff.get(SESSION_2), 1);\n+\n+        let diff = count.undo_update_with_dirty_state(&dirty);\n+        assert!(count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 0);\n+        assert_eq!(diff.get(SESSION_1), -1);\n+        assert_eq!(count.get(SESSION_2), 0);\n+        assert_eq!(diff.get(SESSION_2), -1);\n+\n+        let mut count = DirtyContainerCount::default();\n+        let dirty = DirtyState {\n+            clean_in_session: Some(SESSION_1),\n+        };\n+        let diff = count.update_with_dirty_state(&dirty);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 0);\n+        assert_eq!(diff.get(SESSION_1), 0);\n+        assert_eq!(count.get(SESSION_2), 1);\n+        assert_eq!(diff.get(SESSION_2), 1);\n+\n+        let diff = count.undo_update_with_dirty_state(&dirty);\n+        assert!(count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 0);\n+        assert_eq!(diff.get(SESSION_1), 0);\n+        assert_eq!(count.get(SESSION_2), 0);\n+        assert_eq!(diff.get(SESSION_2), -1);\n+    }\n+\n+    #[test]\n+    fn test_replace_dirty_state() {\n+        let mut count = DirtyContainerCount::default();\n+        let old = DirtyState {\n+            clean_in_session: None,\n+        };\n+        let new = DirtyState {\n+            clean_in_session: Some(SESSION_1),\n+        };\n+        count.update_with_dirty_state(&old);\n+        let diff = count.replace_dirty_state(&old, &new);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 0);\n+        assert_eq!(diff.get(SESSION_1), -1);\n+        assert_eq!(count.get(SESSION_2), 1);\n+        assert_eq!(diff.get(SESSION_2), 0);\n+\n+        let mut count = DirtyContainerCount::default();\n+        let old = DirtyState {\n+            clean_in_session: Some(SESSION_1),\n+        };\n+        let new = DirtyState {\n+            clean_in_session: None,\n+        };\n+        count.update_with_dirty_state(&old);\n+        let diff = count.replace_dirty_state(&old, &new);\n+        assert!(!count.is_zero());\n+        assert_eq!(count.get(SESSION_1), 1);\n+        assert_eq!(diff.get(SESSION_1), 1);\n+        assert_eq!(count.get(SESSION_2), 1);\n+        assert_eq!(diff.get(SESSION_2), 0);\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy)]\n pub enum RootType {\n     RootTask,"
        }
    ],
    "stats": {
        "total": 224,
        "additions": 206,
        "deletions": 18
    }
}