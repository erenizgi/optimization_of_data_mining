{
    "author": "bgw",
    "message": "chore(turbopack): Make TaskInputs use ResolvedVc (#77700)\n\nIt's totally valid for `TaskInput`s to use `Vc`, but `ResolvedVc` is marginally more preferable for a number of performance and functionality reasons (a sane `Eq`+`Hash` impl, doing work more eagerly, synchronous downcasting support).",
    "sha": "63cb50327c163f3533365654f44222f3a109f00e",
    "files": [
        {
            "sha": "b7ed1b2d4fe8c0a180686ae5d1bbfc4a837948c6",
            "filename": "crates/next-api/src/app.rs",
            "status": "modified",
            "additions": 43,
            "deletions": 36,
            "changes": 79,
            "blob_url": "https://github.com/vercel/next.js/blob/63cb50327c163f3533365654f44222f3a109f00e/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/63cb50327c163f3533365654f44222f3a109f00e/crates%2Fnext-api%2Fsrc%2Fapp.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fapp.rs?ref=63cb50327c163f3533365654f44222f3a109f00e",
            "patch": "@@ -1150,10 +1150,8 @@ impl AppEndpoint {\n             ),\n         };\n \n-        let node_root = project.node_root();\n-\n-        let client_relative_path = project.client_relative_path();\n-\n+        let node_root = project.node_root().to_resolved().await?;\n+        let client_relative_path = project.client_relative_path().to_resolved().await?;\n         let server_path = node_root.join(\"server\".into());\n \n         let mut server_assets = fxindexset![];\n@@ -1174,16 +1172,20 @@ impl AppEndpoint {\n             )\n             .await?;\n \n-        let client_chunking_context = project.client_chunking_context();\n+        let client_chunking_context = project.client_chunking_context().to_resolved().await?;\n \n         let ssr_chunking_context = if process_ssr {\n-            Some(match runtime {\n-                NextRuntime::NodeJs => Vc::upcast(project.server_chunking_context(true)),\n-                NextRuntime::Edge => this\n-                    .app_project\n-                    .project()\n-                    .edge_chunking_context(process_client_assets),\n-            })\n+            Some(\n+                match runtime {\n+                    NextRuntime::NodeJs => Vc::upcast(project.server_chunking_context(true)),\n+                    NextRuntime::Edge => this\n+                        .app_project\n+                        .project()\n+                        .edge_chunking_context(process_client_assets),\n+                }\n+                .to_resolved()\n+                .await?,\n+            )\n         } else {\n             None\n         };\n@@ -1193,7 +1195,7 @@ impl AppEndpoint {\n                 .with_modifier(client_shared_chunks_modifier()),\n             this.app_project.client_runtime_entries(),\n             *module_graphs.full,\n-            client_chunking_context,\n+            *client_chunking_context,\n         )\n         .await?;\n \n@@ -1216,18 +1218,23 @@ impl AppEndpoint {\n             .get_next_dynamic_imports_for_endpoint(*rsc_entry)\n             .await?;\n \n-        let client_references = reduced_graphs.get_client_references_for_endpoint(\n-            *rsc_entry,\n-            matches!(this.ty, AppEndpointType::Page { .. }),\n-        );\n+        let client_references = reduced_graphs\n+            .get_client_references_for_endpoint(\n+                *rsc_entry,\n+                matches!(this.ty, AppEndpointType::Page { .. }),\n+            )\n+            .to_resolved()\n+            .await?;\n \n         let client_references_chunks = get_app_client_references_chunks(\n-            client_references,\n+            *client_references,\n             *module_graphs.full,\n-            client_chunking_context,\n+            *client_chunking_context,\n             Value::new(client_shared_availability_info),\n-            ssr_chunking_context,\n-        );\n+            ssr_chunking_context.map(|ctx| *ctx),\n+        )\n+        .to_resolved()\n+        .await?;\n         let client_references_chunks_ref = client_references_chunks.await?;\n \n         let mut entry_client_chunks = FxIndexSet::default();\n@@ -1272,7 +1279,7 @@ impl AppEndpoint {\n                     node_root.join(\n                         format!(\"server/app{manifest_path_prefix}/app-build-manifest.json\",).into(),\n                     ),\n-                    client_relative_path,\n+                    *client_relative_path,\n                 )\n                 .await?\n                 .to_resolved()\n@@ -1328,7 +1335,7 @@ impl AppEndpoint {\n                         node_root.join(\n                             format!(\"server/app{manifest_path_prefix}/build-manifest.json\",).into(),\n                         ),\n-                        client_relative_path,\n+                        *client_relative_path,\n                     )\n                     .await?\n                     .to_resolved()\n@@ -1363,7 +1370,7 @@ impl AppEndpoint {\n         let server_action_manifest = create_server_actions_manifest(\n             actions,\n             project.project_path(),\n-            node_root,\n+            *node_root,\n             app_entry.original_name.clone(),\n             runtime,\n             match runtime {\n@@ -1384,7 +1391,7 @@ impl AppEndpoint {\n \n         let app_entry_chunks = self\n             .app_entry_chunks(\n-                client_references,\n+                *client_references,\n                 *server_action_manifest_loader,\n                 server_path,\n                 process_client_assets,\n@@ -1410,13 +1417,13 @@ impl AppEndpoint {\n                     entry_name: app_entry.original_name.clone(),\n                     client_references,\n                     client_references_chunks,\n-                    rsc_app_entry_chunks: *app_entry_chunks,\n+                    rsc_app_entry_chunks: app_entry_chunks,\n                     client_chunking_context,\n                     ssr_chunking_context,\n-                    async_module_info: module_graphs.full.async_module_info(),\n-                    next_config: project.next_config(),\n+                    async_module_info: module_graphs.full.async_module_info().to_resolved().await?,\n+                    next_config: project.next_config().to_resolved().await?,\n                     runtime,\n-                    mode: project.next_mode(),\n+                    mode: *project.next_mode().await?,\n                 })\n                 .to_resolved()\n                 .await?;\n@@ -1428,7 +1435,7 @@ impl AppEndpoint {\n \n             let next_font_manifest_output = create_font_manifest(\n                 project.client_root(),\n-                node_root,\n+                *node_root,\n                 this.app_project.app_dir(),\n                 &app_entry.original_name,\n                 &app_entry.original_name,\n@@ -1476,7 +1483,7 @@ impl AppEndpoint {\n                 if emit_manifests == EmitManifests::Full {\n                     let dynamic_import_entries = collect_next_dynamic_chunks(\n                         *module_graphs.full,\n-                        Vc::upcast(client_chunking_context),\n+                        *ResolvedVc::upcast(client_chunking_context),\n                         next_dynamic_imports,\n                         NextDynamicChunkAvailability::ClientReferences(\n                             &*(client_references_chunks.await?),\n@@ -1486,7 +1493,7 @@ impl AppEndpoint {\n \n                     let loadable_manifest_output = create_react_loadable_manifest(\n                         *dynamic_import_entries,\n-                        client_relative_path,\n+                        *client_relative_path,\n                         node_root.join(\n                             format!(\n                                 \"server/app{}/react-loadable-manifest\",\n@@ -1556,7 +1563,7 @@ impl AppEndpoint {\n                 if emit_manifests != EmitManifests::None {\n                     // create app paths manifest\n                     let app_paths_manifest_output =\n-                        create_app_paths_manifest(node_root, &app_entry.original_name, entry_file)\n+                        create_app_paths_manifest(*node_root, &app_entry.original_name, entry_file)\n                             .await?;\n                     server_assets.insert(app_paths_manifest_output);\n                 }\n@@ -1576,7 +1583,7 @@ impl AppEndpoint {\n                 if emit_manifests != EmitManifests::None {\n                     // create app paths manifest\n                     let app_paths_manifest_output = create_app_paths_manifest(\n-                        node_root,\n+                        *node_root,\n                         &app_entry.original_name,\n                         server_path\n                             .await?\n@@ -1594,7 +1601,7 @@ impl AppEndpoint {\n                     // create react-loadable-manifest for next/dynamic\n                     let dynamic_import_entries = collect_next_dynamic_chunks(\n                         *module_graphs.full,\n-                        Vc::upcast(client_chunking_context),\n+                        *ResolvedVc::upcast(client_chunking_context),\n                         next_dynamic_imports,\n                         NextDynamicChunkAvailability::ClientReferences(\n                             &*(client_references_chunks.await?),\n@@ -1604,7 +1611,7 @@ impl AppEndpoint {\n \n                     let loadable_manifest_output = create_react_loadable_manifest(\n                         *dynamic_import_entries,\n-                        client_relative_path,\n+                        *client_relative_path,\n                         node_root.join(\n                             format!(\n                                 \"server/app{}/react-loadable-manifest\","
        },
        {
            "sha": "94785b7028c3241989690c9668247dc81549babe",
            "filename": "crates/next-core/src/next_manifests/client_reference_manifest.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/63cb50327c163f3533365654f44222f3a109f00e/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/63cb50327c163f3533365654f44222f3a109f00e/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_manifests%2Fclient_reference_manifest.rs?ref=63cb50327c163f3533365654f44222f3a109f00e",
            "patch": "@@ -32,18 +32,18 @@ use crate::{\n \n #[derive(TaskInput, Clone, Hash, Debug, PartialEq, Eq, Serialize, Deserialize, TraceRawVcs)]\n pub struct ClientReferenceManifestOptions {\n-    pub node_root: Vc<FileSystemPath>,\n-    pub client_relative_path: Vc<FileSystemPath>,\n+    pub node_root: ResolvedVc<FileSystemPath>,\n+    pub client_relative_path: ResolvedVc<FileSystemPath>,\n     pub entry_name: RcStr,\n-    pub client_references: Vc<ClientReferenceGraphResult>,\n-    pub client_references_chunks: Vc<ClientReferencesChunks>,\n-    pub rsc_app_entry_chunks: Vc<OutputAssets>,\n-    pub client_chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    pub ssr_chunking_context: Option<Vc<Box<dyn ChunkingContext>>>,\n-    pub async_module_info: Vc<AsyncModulesInfo>,\n-    pub next_config: Vc<NextConfig>,\n+    pub client_references: ResolvedVc<ClientReferenceGraphResult>,\n+    pub client_references_chunks: ResolvedVc<ClientReferencesChunks>,\n+    pub rsc_app_entry_chunks: ResolvedVc<OutputAssets>,\n+    pub client_chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+    pub ssr_chunking_context: Option<ResolvedVc<Box<dyn ChunkingContext>>>,\n+    pub async_module_info: ResolvedVc<AsyncModulesInfo>,\n+    pub next_config: ResolvedVc<NextConfig>,\n     pub runtime: NextRuntime,\n-    pub mode: Vc<NextMode>,\n+    pub mode: NextMode,\n }\n \n #[turbo_tasks::value_impl]\n@@ -181,7 +181,7 @@ impl ClientReferenceManifest {\n                 let server_path = client_reference_module_ref.server_ident.to_string().await?;\n                 let client_module = client_reference_module_ref.client_module;\n                 let client_chunk_item_id = client_module\n-                    .chunk_item_id(Vc::upcast(client_chunking_context))\n+                    .chunk_item_id(*ResolvedVc::upcast(client_chunking_context))\n                     .await?;\n \n                 let (client_chunks_paths, client_is_async) =\n@@ -226,11 +226,11 @@ impl ClientReferenceManifest {\n                 if let Some(ssr_chunking_context) = ssr_chunking_context {\n                     let ssr_module = client_reference_module_ref.ssr_module;\n                     let ssr_chunk_item_id = ssr_module\n-                        .chunk_item_id(Vc::upcast(ssr_chunking_context))\n+                        .chunk_item_id(*ResolvedVc::upcast(ssr_chunking_context))\n                         .await?;\n \n                     let rsc_chunk_item_id = client_reference_module\n-                        .chunk_item_id(Vc::upcast(ssr_chunking_context))\n+                        .chunk_item_id(*ResolvedVc::upcast(ssr_chunking_context))\n                         .await?;\n \n                     let (ssr_chunks_paths, ssr_is_async) = if runtime == NextRuntime::Edge {\n@@ -385,7 +385,7 @@ impl ClientReferenceManifest {\n                 }\n \n                 let inlined = next_config.await?.experimental.inline_css.unwrap_or(false)\n-                    && mode.await?.is_production();\n+                    && mode.is_production();\n                 let entry_css_files_vec = entry_css_files_with_chunk\n                     .into_iter()\n                     .map(async |(path, chunk)| {"
        },
        {
            "sha": "1ff402df9b0abaa9c47a5360199d53ff60a977f9",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 27,
            "deletions": 23,
            "changes": 50,
            "blob_url": "https://github.com/vercel/next.js/blob/63cb50327c163f3533365654f44222f3a109f00e/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/63cb50327c163f3533365654f44222f3a109f00e/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=63cb50327c163f3533365654f44222f3a109f00e",
            "patch": "@@ -413,9 +413,9 @@ impl EcmascriptAnalyzable for EcmascriptModuleAsset {\n     #[turbo_tasks::function]\n     async fn module_content(\n         self: Vc<Self>,\n-        module_graph: Vc<ModuleGraph>,\n-        chunking_context: Vc<Box<dyn ChunkingContext>>,\n-        async_module_info: Option<Vc<AsyncModuleInfo>>,\n+        module_graph: ResolvedVc<ModuleGraph>,\n+        chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+        async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n     ) -> Result<Vc<EcmascriptModuleContent>> {\n         let parsed = self.parse().to_resolved().await?;\n \n@@ -430,17 +430,17 @@ impl EcmascriptAnalyzable for EcmascriptModuleAsset {\n         Ok(EcmascriptModuleContent::new(\n             EcmascriptModuleContentOptions {\n                 parsed,\n-                ident: self.ident(),\n+                ident: self.ident().to_resolved().await?,\n                 specified_module_type: module_type_result.module_type,\n                 module_graph,\n                 chunking_context,\n-                references: analyze.references(),\n-                esm_references: *analyze_ref.esm_references,\n-                code_generation: *analyze_ref.code_generation,\n-                async_module: *analyze_ref.async_module,\n+                references: analyze.references().to_resolved().await?,\n+                esm_references: analyze_ref.esm_references,\n+                code_generation: analyze_ref.code_generation,\n+                async_module: analyze_ref.async_module,\n                 generate_source_map,\n                 original_source_map: analyze_ref.source_map,\n-                exports: *analyze_ref.exports,\n+                exports: analyze_ref.exports,\n                 async_module_info,\n             },\n         ))\n@@ -775,18 +775,18 @@ pub struct EcmascriptModuleContent {\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, TaskInput, TraceRawVcs)]\n pub struct EcmascriptModuleContentOptions {\n     parsed: ResolvedVc<ParseResult>,\n-    ident: Vc<AssetIdent>,\n+    ident: ResolvedVc<AssetIdent>,\n     specified_module_type: SpecifiedModuleType,\n-    module_graph: Vc<ModuleGraph>,\n-    chunking_context: Vc<Box<dyn ChunkingContext>>,\n-    references: Vc<ModuleReferences>,\n-    esm_references: Vc<EsmAssetReferences>,\n-    code_generation: Vc<CodeGens>,\n-    async_module: Vc<OptionAsyncModule>,\n+    module_graph: ResolvedVc<ModuleGraph>,\n+    chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+    references: ResolvedVc<ModuleReferences>,\n+    esm_references: ResolvedVc<EsmAssetReferences>,\n+    code_generation: ResolvedVc<CodeGens>,\n+    async_module: ResolvedVc<OptionAsyncModule>,\n     generate_source_map: bool,\n     original_source_map: ResolvedVc<OptionStringifiedSourceMap>,\n-    exports: Vc<EcmascriptExports>,\n-    async_module_info: Option<Vc<AsyncModuleInfo>>,\n+    exports: ResolvedVc<EcmascriptExports>,\n+    async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -815,7 +815,11 @@ impl EcmascriptModuleContent {\n                 if let Some(async_module) = &*async_module.await? {\n                     Some(\n                         async_module\n-                            .code_generation(async_module_info, references, chunking_context)\n+                            .code_generation(\n+                                async_module_info.map(|info| *info),\n+                                *references,\n+                                *chunking_context,\n+                            )\n                             .await?,\n                     )\n                 } else {\n@@ -824,7 +828,7 @@ impl EcmascriptModuleContent {\n                 if let EcmascriptExports::EsmExports(exports) = *exports.await? {\n                     Some(\n                         exports\n-                            .code_generation(module_graph, chunking_context, *parsed)\n+                            .code_generation(*module_graph, *chunking_context, *parsed)\n                             .await?,\n                     )\n                 } else {\n@@ -835,13 +839,13 @@ impl EcmascriptModuleContent {\n             let esm_code_gens = esm_references\n                 .await?\n                 .iter()\n-                .map(|r| r.code_generation(chunking_context))\n+                .map(|r| r.code_generation(*chunking_context))\n                 .try_join()\n                 .await?;\n             let code_gens = code_generation\n                 .await?\n                 .iter()\n-                .map(|c| c.code_generation(module_graph, chunking_context))\n+                .map(|c| c.code_generation(*module_graph, *chunking_context))\n                 .try_join()\n                 .await?;\n \n@@ -857,7 +861,7 @@ impl EcmascriptModuleContent {\n \n         gen_content_with_code_gens(\n             parsed,\n-            ident,\n+            *ident,\n             specified_module_type,\n             code_gens,\n             generate_source_map,"
        },
        {
            "sha": "ed6f033ac96712441e5f2fabe5a0a8344e4f130e",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/locals/chunk_item.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 10,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/63cb50327c163f3533365654f44222f3a109f00e/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/63cb50327c163f3533365654f44222f3a109f00e/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fchunk_item.rs?ref=63cb50327c163f3533365654f44222f3a109f00e",
            "patch": "@@ -34,20 +34,20 @@ impl EcmascriptChunkItem for EcmascriptModuleLocalsChunkItem {\n     #[turbo_tasks::function]\n     async fn content_with_async_module_info(\n         &self,\n-        async_module_info: Option<Vc<AsyncModuleInfo>>,\n+        async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n     ) -> Result<Vc<EcmascriptChunkItemContent>> {\n         let module = self.module.await?;\n         let chunking_context = self.chunking_context;\n         let module_graph = self.module_graph;\n-        let exports = self.module.get_exports();\n+        let exports = self.module.get_exports().to_resolved().await?;\n         let original_module = module.module;\n         let parsed = original_module.parse().to_resolved().await?;\n \n         let analyze = original_module.analyze();\n         let analyze_result = analyze.await?;\n         let async_module_options = analyze_result\n             .async_module\n-            .module_options(async_module_info);\n+            .module_options(async_module_info.map(|info| *info));\n \n         let module_type_result = *original_module.determine_module_type().await?;\n         let generate_source_map = *chunking_context\n@@ -56,14 +56,14 @@ impl EcmascriptChunkItem for EcmascriptModuleLocalsChunkItem {\n \n         let content = EcmascriptModuleContent::new(EcmascriptModuleContentOptions {\n             parsed,\n-            ident: self.module.ident(),\n+            ident: self.module.ident().to_resolved().await?,\n             specified_module_type: module_type_result.module_type,\n-            module_graph: *module_graph,\n-            chunking_context: *chunking_context,\n-            references: analyze.local_references(),\n-            esm_references: *analyze_result.esm_local_references,\n-            code_generation: *analyze_result.code_generation,\n-            async_module: *analyze_result.async_module,\n+            module_graph,\n+            chunking_context,\n+            references: analyze.local_references().to_resolved().await?,\n+            esm_references: analyze_result.esm_local_references,\n+            code_generation: analyze_result.code_generation,\n+            async_module: analyze_result.async_module,\n             generate_source_map,\n             original_source_map: analyze_result.source_map,\n             exports,"
        },
        {
            "sha": "ace13f51b23eb9bd442dccd92218737a96fc39b3",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/chunk_item.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 10,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/63cb50327c163f3533365654f44222f3a109f00e/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/63cb50327c163f3533365654f44222f3a109f00e/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fchunk_item.rs?ref=63cb50327c163f3533365654f44222f3a109f00e",
            "patch": "@@ -42,7 +42,7 @@ impl EcmascriptChunkItem for EcmascriptModulePartChunkItem {\n     #[turbo_tasks::function]\n     async fn content_with_async_module_info(\n         &self,\n-        async_module_info: Option<Vc<AsyncModuleInfo>>,\n+        async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n     ) -> Result<Vc<EcmascriptChunkItemContent>> {\n         let module = self.module.await?;\n \n@@ -53,7 +53,9 @@ impl EcmascriptChunkItem for EcmascriptModulePartChunkItem {\n \n         let analyze = self.module.analyze();\n         let analyze_ref = analyze.await?;\n-        let async_module_options = analyze_ref.async_module.module_options(async_module_info);\n+        let async_module_options = analyze_ref\n+            .async_module\n+            .module_options(async_module_info.map(|info| *info));\n \n         let module_type_result = *module.full_module.determine_module_type().await?;\n         let generate_source_map = *self\n@@ -63,17 +65,17 @@ impl EcmascriptChunkItem for EcmascriptModulePartChunkItem {\n \n         let content = EcmascriptModuleContent::new(EcmascriptModuleContentOptions {\n             parsed,\n-            ident: self.module.ident(),\n+            ident: self.module.ident().to_resolved().await?,\n             specified_module_type: module_type_result.module_type,\n-            module_graph: *self.module_graph,\n-            chunking_context: *self.chunking_context,\n-            references: analyze.references(),\n-            esm_references: *analyze_ref.esm_references,\n-            code_generation: *analyze_ref.code_generation,\n-            async_module: *analyze_ref.async_module,\n+            module_graph: self.module_graph,\n+            chunking_context: self.chunking_context,\n+            references: analyze.references().to_resolved().await?,\n+            esm_references: analyze_ref.esm_references,\n+            code_generation: analyze_ref.code_generation,\n+            async_module: analyze_ref.async_module,\n             generate_source_map,\n             original_source_map: analyze_ref.source_map,\n-            exports: *analyze_ref.exports,\n+            exports: analyze_ref.exports,\n             async_module_info,\n         });\n "
        }
    ],
    "stats": {
        "total": 199,
        "additions": 106,
        "deletions": 93
    }
}