{
    "author": "lubieowoce",
    "message": "refactor: clean up forked Form implementations (#76495)\n\nSplit out of #76184 because it got a bit involved and i want to do it in\nisolation.\n\nRemoves dead code from the forked implementations of Form for app and\npages dir. There's some shared utils but not much. Mostly involves\nremoving code for prefetching and server actions from the pages\nimplementation.\n\nAlso took this opportunity to fix some stuff for pages:\n- improve error messages, previously they were linking to `/app/` docs\n- use `React.forwardRef`: technically, you can use React <19 in pages,\nwhere `forwardRef` is still needed",
    "sha": "101ca810a38bfcc26ade2c6b463a5e0b32adbb28",
    "files": [
        {
            "sha": "58c47958b7640b6d8a76e1b871ea6b313c614dbb",
            "filename": "packages/next/src/client/app-dir/form.tsx",
            "status": "modified",
            "additions": 28,
            "deletions": 218,
            "changes": 246,
            "blob_url": "https://github.com/vercel/next.js/blob/101ca810a38bfcc26ade2c6b463a5e0b32adbb28/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Fform.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/101ca810a38bfcc26ade2c6b463a5e0b32adbb28/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Fform.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fapp-dir%2Fform.tsx?ref=101ca810a38bfcc26ade2c6b463a5e0b32adbb28",
            "patch": "@@ -1,6 +1,6 @@\n 'use client'\n \n-import { useEffect, type HTMLProps, type FormEvent, useContext } from 'react'\n+import { useEffect, type FormEvent, useContext } from 'react'\n import { addBasePath } from '../add-base-path'\n import { useIntersection } from '../use-intersection'\n import { useMergedRef } from '../use-merged-ref'\n@@ -9,56 +9,16 @@ import {\n   type AppRouterInstance,\n } from '../../shared/lib/app-router-context.shared-runtime'\n import { PrefetchKind } from '../components/router-reducer/router-reducer-types'\n-import { RouterContext } from '../../shared/lib/router-context.shared-runtime'\n-import type { NextRouter } from '../router'\n-\n-const DISALLOWED_FORM_PROPS = ['method', 'encType', 'target'] as const\n-\n-type HTMLFormProps = HTMLProps<HTMLFormElement>\n-type DisallowedFormProps = (typeof DISALLOWED_FORM_PROPS)[number]\n-\n-type InternalFormProps = {\n-  /**\n-   * `action` can be either a `string` or a function.\n-   * - If `action` is a string, it will be interpreted as a path or URL to navigate to when the form is submitted.\n-   *   The path will be prefetched when the form becomes visible.\n-   * - If `action` is a function, it will be called when the form is submitted. See the [React docs](https://react.dev/reference/react-dom/components/form#props) for more.\n-   */\n-  action: NonNullable<HTMLFormProps['action']>\n-  /**\n-   * Controls how the route specified by `action` is prefetched.\n-   * Any `<Form />` that is in the viewport (initially or through scroll) will be prefetched.\n-   * Prefetch can be disabled by passing `prefetch={false}`. Prefetching is only enabled in production.\n-   *\n-   * Options:\n-   * - `null` (default): For statically generated pages, this will prefetch the full React Server Component data. For dynamic pages, this will prefetch up to the nearest route segment with a [`loading.js`](https://nextjs.org/docs/app/api-reference/file-conventions/loading) file. If there is no loading file, it will not fetch the full tree to avoid fetching too much data.\n-   * - `false`: This will not prefetch any data.\n-   *\n-   * In pages dir, prefetching is not supported, and passing this prop will emit a warning.\n-   *\n-   * @defaultValue `null`\n-   */\n-  prefetch?: false | null\n-  /**\n-   * Whether submitting the form should replace the current `history` state instead of adding a new url into the stack.\n-   * Only valid if `action` is a string.\n-   *\n-   * @defaultValue `false`\n-   */\n-  replace?: boolean\n-  /**\n-   * Override the default scroll behavior when navigating.\n-   * Only valid if `action` is a string.\n-   *\n-   * @defaultValue `true`\n-   */\n-  scroll?: boolean\n-} & Omit<HTMLFormProps, 'action' | DisallowedFormProps>\n+import {\n+  checkFormActionUrl,\n+  createFormSubmitDestinationUrl,\n+  DISALLOWED_FORM_PROPS,\n+  hasReactClientActionAttributes,\n+  hasUnsupportedSubmitterAttributes,\n+  type FormProps,\n+} from '../form-shared'\n \n-// `RouteInferType` is a stub here to avoid breaking `typedRoutes` when the type\n-// isn't generated yet. It will be replaced when the webpack plugin runs.\n-// eslint-disable-next-line @typescript-eslint/no-unused-vars\n-export type FormProps<RouteInferType = any> = InternalFormProps\n+export type { FormProps }\n \n export default function Form({\n   replace,\n@@ -67,15 +27,15 @@ export default function Form({\n   ref: externalRef,\n   ...props\n }: FormProps) {\n-  const router = useAppOrPagesRouter()\n+  const router = useContext(AppRouterContext)\n \n   const actionProp = props.action\n   const isNavigatingForm = typeof actionProp === 'string'\n \n   // Validate `action`\n   if (process.env.NODE_ENV === 'development') {\n     if (isNavigatingForm) {\n-      checkActionUrl(actionProp, 'action')\n+      checkFormActionUrl(actionProp, 'action')\n     }\n   }\n \n@@ -91,16 +51,10 @@ export default function Form({\n       console.error('The `prefetch` prop of <Form> must be `false` or `null`')\n     }\n \n-    if (prefetchProp !== undefined) {\n-      if (!isAppRouter(router)) {\n-        console.error(\n-          'Passing `prefetch` to a <Form> has no effect in the pages directory.'\n-        )\n-      } else if (!isNavigatingForm) {\n-        console.error(\n-          'Passing `prefetch` to a <Form> whose `action` is a function has no effect.'\n-        )\n-      }\n+    if (prefetchProp !== undefined && !isNavigatingForm) {\n+      console.error(\n+        'Passing `prefetch` to a <Form> whose `action` is a function has no effect.'\n+      )\n     }\n   }\n \n@@ -136,11 +90,8 @@ export default function Form({\n   }\n \n   const isPrefetchEnabled =\n-    // there is no notion of instant loading states in pages dir, so prefetching is pointless\n-    isAppRouter(router) &&\n-    // if we don't have an action path, we can't preload anything anyway.\n-    isNavigatingForm &&\n-    prefetch === null\n+    // if we don't have an action path, we can't prefetch anything.\n+    !!router && isNavigatingForm && prefetch === null\n \n   const [setIntersectionRef, isVisible] = useIntersection({\n     rootMargin: '200px',\n@@ -202,7 +153,7 @@ function onFormSubmit(\n     onSubmit: FormProps['onSubmit']\n     replace: FormProps['replace']\n     scroll: FormProps['scroll']\n-    router: SomeRouter\n+    router: AppRouterInstance | null\n   }\n ) {\n   if (typeof onSubmit === 'function') {\n@@ -215,6 +166,12 @@ function onFormSubmit(\n     }\n   }\n \n+  if (!router) {\n+    // Form was somehow used outside of the router (but not in pages, the implementation is forked!).\n+    // We can't perform a soft navigation, so let the native submit handling do its thing.\n+    return\n+  }\n+\n   const formElement = event.currentTarget\n   const submitter = (event.nativeEvent as SubmitEvent).submitter\n \n@@ -246,160 +203,20 @@ function onFormSubmit(\n     const submitterFormAction = submitter.getAttribute('formAction')\n     if (submitterFormAction !== null) {\n       if (process.env.NODE_ENV === 'development') {\n-        checkActionUrl(submitterFormAction, 'formAction')\n+        checkFormActionUrl(submitterFormAction, 'formAction')\n       }\n       action = submitterFormAction\n     }\n   }\n \n-  let targetUrl: URL\n-  try {\n-    // NOTE: It might be more correct to resolve URLs relative to `document.baseURI`,\n-    // but we already do it relative to `location.href` elsewhere:\n-    //  (see e.g. https://github.com/vercel/next.js/blob/bb0e6722f87ceb2d43015f5b8a413d0072f2badf/packages/next/src/client/components/app-router.tsx#L146)\n-    // so it's better to stay consistent.\n-    const base = window.location.href\n-    targetUrl = new URL(action, base)\n-  } catch (err) {\n-    throw new Error(`Cannot parse form action \"${action}\" as a URL`, {\n-      cause: err,\n-    })\n-  }\n-  if (targetUrl.searchParams.size) {\n-    // url-encoded HTML forms *overwrite* any search params in the `action` url:\n-    //\n-    //  \"Let `query` be the result of running the application/x-www-form-urlencoded serializer [...]\"\n-    //  \"Set parsed action's query component to `query`.\"\n-    //   https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#submit-mutate-action\n-    //\n-    // We need to match that.\n-    // (note that all other parts of the URL, like `hash`, are preserved)\n-    targetUrl.search = ''\n-  }\n-\n-  const formData = new FormData(formElement)\n-\n-  for (let [name, value] of formData) {\n-    if (typeof value !== 'string') {\n-      // For file inputs, the native browser behavior is to use the filename as the value instead:\n-      //\n-      //   \"If entry's value is a File object, then let value be entry's value's name. Otherwise, let value be entry's value.\"\n-      //   https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n-      //\n-      if (process.env.NODE_ENV === 'development') {\n-        console.warn(\n-          `<Form> only supports file inputs if \\`action\\` is a function. File inputs cannot be used if \\`action\\` is a string, ` +\n-            `because files cannot be encoded as search params.`\n-        )\n-      }\n-      value = value.name\n-    }\n-\n-    targetUrl.searchParams.append(name, value)\n-  }\n+  const targetUrl = createFormSubmitDestinationUrl(action, formElement)\n \n   // Finally, no more reasons for bailing out.\n   event.preventDefault()\n \n   const method = replace ? 'replace' : 'push'\n   const targetHref = targetUrl.href\n-  if (isAppRouter(router)) {\n-    router[method](targetHref, { scroll })\n-  } else {\n-    // TODO(form): Make this use a transition so that pending states work\n-    //\n-    // Unlike the app router, pages router doesn't use startTransition,\n-    // and can't easily be wrapped in one because of implementation details\n-    // (e.g. it doesn't use any react state)\n-    // But it's important to have this wrapped in a transition because\n-    // pending states from e.g. `useFormStatus` rely on that.\n-    // So this needs some follow up work.\n-    router[method](targetHref, undefined, { scroll })\n-  }\n-}\n-\n-type SomeRouter = AppRouterInstance | NextRouter\n-\n-function isAppRouter(router: SomeRouter): router is AppRouterInstance {\n-  return !('asPath' in router)\n-}\n-\n-function useAppOrPagesRouter(): SomeRouter {\n-  const pagesRouter = useContext(RouterContext)\n-  const appRouter = useContext(AppRouterContext)\n-  if (pagesRouter) {\n-    return pagesRouter\n-  } else {\n-    // We're in the app directory if there is no pages router.\n-    return appRouter!\n-  }\n-}\n-\n-function checkActionUrl(action: string, source: 'action' | 'formAction') {\n-  const aPropName = source === 'action' ? `an \\`action\\`` : `a \\`formAction\\``\n-\n-  let testUrl: URL\n-  try {\n-    testUrl = new URL(action, 'http://n')\n-  } catch (err) {\n-    console.error(\n-      `<Form> received ${aPropName} that cannot be parsed as a URL: \"${action}\".`\n-    )\n-    return\n-  }\n-\n-  // url-encoded HTML forms ignore any queryparams in the `action` url. We need to match that.\n-  if (testUrl.searchParams.size) {\n-    console.warn(\n-      `<Form> received ${aPropName} that contains search params: \"${action}\". This is not supported, and they will be ignored. ` +\n-        `If you need to pass in additional search params, use an \\`<input type=\"hidden\" />\\` instead.`\n-    )\n-  }\n-}\n-\n-const isSupportedEncType = (value: string) =>\n-  value === 'application/x-www-form-urlencoded'\n-const isSupportedMethod = (value: string) => value === 'get'\n-const isSupportedTarget = (value: string) => value === '_self'\n-\n-function hasUnsupportedSubmitterAttributes(submitter: HTMLElement): boolean {\n-  // A submitter can override `encType` for the form.\n-  const formEncType = submitter.getAttribute('formEncType')\n-  if (formEncType !== null && !isSupportedEncType(formEncType)) {\n-    if (process.env.NODE_ENV === 'development') {\n-      console.error(\n-        `<Form>'s \\`encType\\` was set to an unsupported value via \\`formEncType=\"${formEncType}\"\\`. ` +\n-          `This will disable <Form>'s navigation functionality. If you need this, use a native <form> element instead.`\n-      )\n-    }\n-    return true\n-  }\n-\n-  // A submitter can override `method` for the form.\n-  const formMethod = submitter.getAttribute('formMethod')\n-  if (formMethod !== null && !isSupportedMethod(formMethod)) {\n-    if (process.env.NODE_ENV === 'development') {\n-      console.error(\n-        `<Form>'s \\`method\\` was set to an unsupported value via \\`formMethod=\"${formMethod}\"\\`. ` +\n-          `This will disable <Form>'s navigation functionality. If you need this, use a native <form> element instead.`\n-      )\n-    }\n-    return true\n-  }\n-\n-  // A submitter can override `target` for the form.\n-  const formTarget = submitter.getAttribute('formTarget')\n-  if (formTarget !== null && !isSupportedTarget(formTarget)) {\n-    if (process.env.NODE_ENV === 'development') {\n-      console.error(\n-        `<Form>'s \\`target\\` was set to an unsupported value via \\`formTarget=\"${formTarget}\"\\`. ` +\n-          `This will disable <Form>'s navigation functionality. If you need this, use a native <form> element instead.`\n-      )\n-    }\n-    return true\n-  }\n-\n-  return false\n+  router[method](targetHref, { scroll })\n }\n \n function hasReactServerActionAttributes(submitter: HTMLElement) {\n@@ -409,10 +226,3 @@ function hasReactServerActionAttributes(submitter: HTMLElement) {\n     name && (name.startsWith('$ACTION_ID_') || name.startsWith('$ACTION_REF_'))\n   )\n }\n-\n-function hasReactClientActionAttributes(submitter: HTMLElement) {\n-  // CSR: https://github.com/facebook/react/blob/942eb80381b96f8410eab1bef1c539bed1ab0eb1/packages/react-dom-bindings/src/client/ReactDOMComponent.js#L482-L487\n-  // SSR: https://github.com/facebook/react/blob/942eb80381b96f8410eab1bef1c539bed1ab0eb1/packages/react-dom-bindings/src/client/ReactDOMComponent.js#L2401\n-  const action = submitter.getAttribute('formAction')\n-  return action && /\\s*javascript:/i.test(action)\n-}"
        },
        {
            "sha": "793d8c2d7a6028cb537958299d390e5c60cc8c35",
            "filename": "packages/next/src/client/form-shared.tsx",
            "status": "added",
            "additions": 180,
            "deletions": 0,
            "changes": 180,
            "blob_url": "https://github.com/vercel/next.js/blob/101ca810a38bfcc26ade2c6b463a5e0b32adbb28/packages%2Fnext%2Fsrc%2Fclient%2Fform-shared.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/101ca810a38bfcc26ade2c6b463a5e0b32adbb28/packages%2Fnext%2Fsrc%2Fclient%2Fform-shared.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fform-shared.tsx?ref=101ca810a38bfcc26ade2c6b463a5e0b32adbb28",
            "patch": "@@ -0,0 +1,180 @@\n+import type { HTMLProps } from 'react'\n+\n+export const DISALLOWED_FORM_PROPS = ['method', 'encType', 'target'] as const\n+\n+type HTMLFormProps = HTMLProps<HTMLFormElement>\n+type DisallowedFormProps = (typeof DISALLOWED_FORM_PROPS)[number]\n+\n+type InternalFormProps = {\n+  /**\n+   * `action` can be either a `string` or a function.\n+   * - If `action` is a string, it will be interpreted as a path or URL to navigate to when the form is submitted.\n+   *   The path will be prefetched when the form becomes visible.\n+   * - If `action` is a function, it will be called when the form is submitted. See the [React docs](https://react.dev/reference/react-dom/components/form#props) for more.\n+   */\n+  action: NonNullable<HTMLFormProps['action']>\n+  /**\n+   * Controls how the route specified by `action` is prefetched.\n+   * Any `<Form />` that is in the viewport (initially or through scroll) will be prefetched.\n+   * Prefetch can be disabled by passing `prefetch={false}`. Prefetching is only enabled in production.\n+   *\n+   * Options:\n+   * - `null` (default): For statically generated pages, this will prefetch the full React Server Component data. For dynamic pages, this will prefetch up to the nearest route segment with a [`loading.js`](https://nextjs.org/docs/app/api-reference/file-conventions/loading) file. If there is no loading file, it will not fetch the full tree to avoid fetching too much data.\n+   * - `false`: This will not prefetch any data.\n+   *\n+   * In pages dir, prefetching is not supported, and passing this prop will emit a warning.\n+   *\n+   * @defaultValue `null`\n+   */\n+  prefetch?: false | null\n+  /**\n+   * Whether submitting the form should replace the current `history` state instead of adding a new url into the stack.\n+   * Only valid if `action` is a string.\n+   *\n+   * @defaultValue `false`\n+   */\n+  replace?: boolean\n+  /**\n+   * Override the default scroll behavior when navigating.\n+   * Only valid if `action` is a string.\n+   *\n+   * @defaultValue `true`\n+   */\n+  scroll?: boolean\n+} & Omit<HTMLFormProps, 'action' | DisallowedFormProps>\n+\n+// `RouteInferType` is a stub here to avoid breaking `typedRoutes` when the type\n+// isn't generated yet. It will be replaced when the webpack plugin runs.\n+// eslint-disable-next-line @typescript-eslint/no-unused-vars\n+export type FormProps<RouteInferType = any> = InternalFormProps\n+\n+export function createFormSubmitDestinationUrl(\n+  action: string,\n+  formElement: HTMLFormElement\n+) {\n+  let targetUrl: URL\n+  try {\n+    // NOTE: It might be more correct to resolve URLs relative to `document.baseURI`,\n+    // but we already do it relative to `location.href` elsewhere:\n+    //  (see e.g. https://github.com/vercel/next.js/blob/bb0e6722f87ceb2d43015f5b8a413d0072f2badf/packages/next/src/client/components/app-router.tsx#L146)\n+    // so it's better to stay consistent.\n+    const base = window.location.href\n+    targetUrl = new URL(action, base)\n+  } catch (err) {\n+    throw new Error(`Cannot parse form action \"${action}\" as a URL`, {\n+      cause: err,\n+    })\n+  }\n+  if (targetUrl.searchParams.size) {\n+    // url-encoded HTML forms *overwrite* any search params in the `action` url:\n+    //\n+    //  \"Let `query` be the result of running the application/x-www-form-urlencoded serializer [...]\"\n+    //  \"Set parsed action's query component to `query`.\"\n+    //   https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#submit-mutate-action\n+    //\n+    // We need to match that.\n+    // (note that all other parts of the URL, like `hash`, are preserved)\n+    targetUrl.search = ''\n+  }\n+\n+  const formData = new FormData(formElement)\n+\n+  for (let [name, value] of formData) {\n+    if (typeof value !== 'string') {\n+      // For file inputs, the native browser behavior is to use the filename as the value instead:\n+      //\n+      //   \"If entry's value is a File object, then let value be entry's value's name. Otherwise, let value be entry's value.\"\n+      //   https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n+      //\n+      if (process.env.NODE_ENV === 'development') {\n+        console.warn(\n+          `<Form> only supports file inputs if \\`action\\` is a function. File inputs cannot be used if \\`action\\` is a string, ` +\n+            `because files cannot be encoded as search params.`\n+        )\n+      }\n+      value = value.name\n+    }\n+\n+    targetUrl.searchParams.append(name, value)\n+  }\n+  return targetUrl\n+}\n+\n+export function checkFormActionUrl(\n+  action: string,\n+  source: 'action' | 'formAction'\n+) {\n+  const aPropName = source === 'action' ? `an \\`action\\`` : `a \\`formAction\\``\n+\n+  let testUrl: URL\n+  try {\n+    testUrl = new URL(action, 'http://n')\n+  } catch (err) {\n+    console.error(\n+      `<Form> received ${aPropName} that cannot be parsed as a URL: \"${action}\".`\n+    )\n+    return\n+  }\n+\n+  // url-encoded HTML forms ignore any queryparams in the `action` url. We need to match that.\n+  if (testUrl.searchParams.size) {\n+    console.warn(\n+      `<Form> received ${aPropName} that contains search params: \"${action}\". This is not supported, and they will be ignored. ` +\n+        `If you need to pass in additional search params, use an \\`<input type=\"hidden\" />\\` instead.`\n+    )\n+  }\n+}\n+\n+export const isSupportedFormEncType = (value: string) =>\n+  value === 'application/x-www-form-urlencoded'\n+export const isSupportedFormMethod = (value: string) => value === 'get'\n+export const isSupportedFormTarget = (value: string) => value === '_self'\n+\n+export function hasUnsupportedSubmitterAttributes(\n+  submitter: HTMLElement\n+): boolean {\n+  // A submitter can override `encType` for the form.\n+  const formEncType = submitter.getAttribute('formEncType')\n+  if (formEncType !== null && !isSupportedFormEncType(formEncType)) {\n+    if (process.env.NODE_ENV === 'development') {\n+      console.error(\n+        `<Form>'s \\`encType\\` was set to an unsupported value via \\`formEncType=\"${formEncType}\"\\`. ` +\n+          `This will disable <Form>'s navigation functionality. If you need this, use a native <form> element instead.`\n+      )\n+    }\n+    return true\n+  }\n+\n+  // A submitter can override `method` for the form.\n+  const formMethod = submitter.getAttribute('formMethod')\n+  if (formMethod !== null && !isSupportedFormMethod(formMethod)) {\n+    if (process.env.NODE_ENV === 'development') {\n+      console.error(\n+        `<Form>'s \\`method\\` was set to an unsupported value via \\`formMethod=\"${formMethod}\"\\`. ` +\n+          `This will disable <Form>'s navigation functionality. If you need this, use a native <form> element instead.`\n+      )\n+    }\n+    return true\n+  }\n+\n+  // A submitter can override `target` for the form.\n+  const formTarget = submitter.getAttribute('formTarget')\n+  if (formTarget !== null && !isSupportedFormTarget(formTarget)) {\n+    if (process.env.NODE_ENV === 'development') {\n+      console.error(\n+        `<Form>'s \\`target\\` was set to an unsupported value via \\`formTarget=\"${formTarget}\"\\`. ` +\n+          `This will disable <Form>'s navigation functionality. If you need this, use a native <form> element instead.`\n+      )\n+    }\n+    return true\n+  }\n+\n+  return false\n+}\n+\n+export function hasReactClientActionAttributes(submitter: HTMLElement) {\n+  // CSR: https://github.com/facebook/react/blob/942eb80381b96f8410eab1bef1c539bed1ab0eb1/packages/react-dom-bindings/src/client/ReactDOMComponent.js#L482-L487\n+  // SSR: https://github.com/facebook/react/blob/942eb80381b96f8410eab1bef1c539bed1ab0eb1/packages/react-dom-bindings/src/client/ReactDOMComponent.js#L2401\n+  const action = submitter.getAttribute('formAction')\n+  return action && /\\s*javascript:/i.test(action)\n+}"
        },
        {
            "sha": "8fdefc9f88914acbc63e48d1d7af274baea0e2ec",
            "filename": "packages/next/src/client/form.tsx",
            "status": "modified",
            "additions": 50,
            "deletions": 299,
            "changes": 349,
            "blob_url": "https://github.com/vercel/next.js/blob/101ca810a38bfcc26ade2c6b463a5e0b32adbb28/packages%2Fnext%2Fsrc%2Fclient%2Fform.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/101ca810a38bfcc26ade2c6b463a5e0b32adbb28/packages%2Fnext%2Fsrc%2Fclient%2Fform.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fform.tsx?ref=101ca810a38bfcc26ade2c6b463a5e0b32adbb28",
            "patch": "@@ -1,120 +1,52 @@\n 'use client'\n \n-import { useEffect, type HTMLProps, type FormEvent, useContext } from 'react'\n+import { type FormEvent, useContext, forwardRef } from 'react'\n import { addBasePath } from './add-base-path'\n-import { useIntersection } from './use-intersection'\n-import { useMergedRef } from './use-merged-ref'\n-import {\n-  AppRouterContext,\n-  type AppRouterInstance,\n-} from '../shared/lib/app-router-context.shared-runtime'\n-import { PrefetchKind } from './components/router-reducer/router-reducer-types'\n import { RouterContext } from '../shared/lib/router-context.shared-runtime'\n import type { NextRouter } from './router'\n-\n-const DISALLOWED_FORM_PROPS = ['method', 'encType', 'target'] as const\n-\n-type HTMLFormProps = HTMLProps<HTMLFormElement>\n-type DisallowedFormProps = (typeof DISALLOWED_FORM_PROPS)[number]\n-\n-type InternalFormProps = {\n-  /**\n-   * `action` can be either a `string` or a function.\n-   * - If `action` is a string, it will be interpreted as a path or URL to navigate to when the form is submitted.\n-   *   The path will be prefetched when the form becomes visible.\n-   * - If `action` is a function, it will be called when the form is submitted. See the [React docs](https://react.dev/reference/react-dom/components/form#props) for more.\n-   */\n-  action: NonNullable<HTMLFormProps['action']>\n-  /**\n-   * Controls how the route specified by `action` is prefetched.\n-   * Any `<Form />` that is in the viewport (initially or through scroll) will be prefetched.\n-   * Prefetch can be disabled by passing `prefetch={false}`. Prefetching is only enabled in production.\n-   *\n-   * Options:\n-   * - `null` (default): For statically generated pages, this will prefetch the full React Server Component data. For dynamic pages, this will prefetch up to the nearest route segment with a [`loading.js`](https://nextjs.org/docs/app/api-reference/file-conventions/loading) file. If there is no loading file, it will not fetch the full tree to avoid fetching too much data.\n-   * - `false`: This will not prefetch any data.\n-   *\n-   * In pages dir, prefetching is not supported, and passing this prop will emit a warning.\n-   *\n-   * @defaultValue `null`\n-   */\n-  prefetch?: false | null\n-  /**\n-   * Whether submitting the form should replace the current `history` state instead of adding a new url into the stack.\n-   * Only valid if `action` is a string.\n-   *\n-   * @defaultValue `false`\n-   */\n-  replace?: boolean\n-  /**\n-   * Override the default scroll behavior when navigating.\n-   * Only valid if `action` is a string.\n-   *\n-   * @defaultValue `true`\n-   */\n-  scroll?: boolean\n-} & Omit<HTMLFormProps, 'action' | DisallowedFormProps>\n-\n-// `RouteInferType` is a stub here to avoid breaking `typedRoutes` when the type\n-// isn't generated yet. It will be replaced when the webpack plugin runs.\n-// eslint-disable-next-line @typescript-eslint/no-unused-vars\n-export type FormProps<RouteInferType = any> = InternalFormProps\n-\n-export default function Form({\n-  replace,\n-  scroll,\n-  prefetch: prefetchProp,\n-  ref: externalRef,\n-  ...props\n-}: FormProps) {\n-  const router = useAppOrPagesRouter()\n+import {\n+  checkFormActionUrl,\n+  createFormSubmitDestinationUrl,\n+  DISALLOWED_FORM_PROPS,\n+  hasReactClientActionAttributes,\n+  hasUnsupportedSubmitterAttributes,\n+  type FormProps,\n+} from './form-shared'\n+\n+export type { FormProps }\n+\n+const Form = forwardRef<HTMLFormElement, FormProps>(function FormComponent(\n+  { replace, scroll, prefetch: prefetchProp, ...props },\n+  ref\n+) {\n+  const router = useContext(RouterContext)\n \n   const actionProp = props.action\n   const isNavigatingForm = typeof actionProp === 'string'\n \n   // Validate `action`\n   if (process.env.NODE_ENV === 'development') {\n     if (isNavigatingForm) {\n-      checkActionUrl(actionProp, 'action')\n+      checkFormActionUrl(actionProp, 'action')\n     }\n   }\n \n   // Validate `prefetch`\n   if (process.env.NODE_ENV === 'development') {\n-    if (\n-      !(\n-        prefetchProp === undefined ||\n-        prefetchProp === false ||\n-        prefetchProp === null\n-      )\n-    ) {\n-      console.error('The `prefetch` prop of <Form> must be `false` or `null`')\n-    }\n-\n     if (prefetchProp !== undefined) {\n-      if (!isAppRouter(router)) {\n-        console.error(\n-          'Passing `prefetch` to a <Form> has no effect in the pages directory.'\n-        )\n-      } else if (!isNavigatingForm) {\n-        console.error(\n-          'Passing `prefetch` to a <Form> whose `action` is a function has no effect.'\n-        )\n-      }\n+      console.error(\n+        'Passing `prefetch` to a <Form> has no effect in the pages directory.'\n+      )\n     }\n   }\n \n-  const prefetch =\n-    prefetchProp === false || prefetchProp === null ? prefetchProp : null\n-\n   // Validate `scroll` and `replace`\n   if (process.env.NODE_ENV === 'development') {\n     if (!isNavigatingForm && (replace !== undefined || scroll !== undefined)) {\n       console.error(\n         'Passing `replace` or `scroll` to a <Form> whose `action` is a function has no effect.\\n' +\n           'See the relevant docs to learn how to control this behavior for navigations triggered from actions:\\n' +\n-          '  `redirect()`       - https://nextjs.org/docs/app/api-reference/functions/redirect#parameters\\n' +\n-          '  `router.replace()` - https://nextjs.org/docs/app/api-reference/functions/use-router#userouter\\n'\n+          '  `router.replace()` - https://nextjs.org/docs/pages/api-reference/functions/use-router#routerreplace\\n'\n       )\n     }\n   }\n@@ -123,58 +55,22 @@ export default function Form({\n   for (const key of DISALLOWED_FORM_PROPS) {\n     if (key in props) {\n       if (process.env.NODE_ENV === 'development') {\n-        console.error(\n-          `<Form> does not support changing \\`${key}\\`. ` +\n-            (isNavigatingForm\n-              ? `If you'd like to use it to perform a mutation, consider making \\`action\\` a function instead.\\n` +\n-                `Learn more: https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations`\n-              : '')\n-        )\n+        console.error(`<Form> does not support changing \\`${key}\\`.`)\n       }\n       delete (props as Record<string, unknown>)[key]\n     }\n   }\n \n-  const isPrefetchEnabled =\n-    // there is no notion of instant loading states in pages dir, so prefetching is pointless\n-    isAppRouter(router) &&\n-    // if we don't have an action path, we can't preload anything anyway.\n-    isNavigatingForm &&\n-    prefetch === null\n-\n-  const [setIntersectionRef, isVisible] = useIntersection({\n-    rootMargin: '200px',\n-    disabled: !isPrefetchEnabled,\n-  })\n-\n-  const ownRef = useMergedRef<HTMLFormElement>(\n-    setIntersectionRef,\n-    externalRef ?? null\n-  )\n-\n-  useEffect(() => {\n-    if (!isVisible || !isPrefetchEnabled) {\n-      return\n-    }\n-\n-    try {\n-      const prefetchKind = PrefetchKind.AUTO\n-      router.prefetch(actionProp, { kind: prefetchKind })\n-    } catch (err) {\n-      console.error(err)\n-    }\n-  }, [isPrefetchEnabled, isVisible, actionProp, prefetch, router])\n-\n   if (!isNavigatingForm) {\n-    return <form {...props} ref={ownRef} />\n+    return <form {...props} ref={ref} />\n   }\n \n   const actionHref = addBasePath(actionProp)\n \n   return (\n     <form\n       {...props}\n-      ref={ownRef}\n+      ref={ref}\n       action={actionHref}\n       onSubmit={(event) =>\n         onFormSubmit(event, {\n@@ -187,7 +83,9 @@ export default function Form({\n       }\n     />\n   )\n-}\n+})\n+\n+export default Form\n \n function onFormSubmit(\n   event: FormEvent<HTMLFormElement>,\n@@ -202,7 +100,7 @@ function onFormSubmit(\n     onSubmit: FormProps['onSubmit']\n     replace: FormProps['replace']\n     scroll: FormProps['scroll']\n-    router: SomeRouter\n+    router: NextRouter | null\n   }\n ) {\n   if (typeof onSubmit === 'function') {\n@@ -215,21 +113,20 @@ function onFormSubmit(\n     }\n   }\n \n+  if (!router) {\n+    // Form was somehow used outside of the router (but not in app/, the implementation is forked!).\n+    // We can't perform a soft navigation, so let the native submit handling do its thing.\n+    return\n+  }\n+\n   const formElement = event.currentTarget\n   const submitter = (event.nativeEvent as SubmitEvent).submitter\n \n   let action = actionHref\n \n   if (submitter) {\n-    if (process.env.NODE_ENV === 'development') {\n-      // the way server actions are encoded (e.g. `formMethod=\"post\")\n-      // causes some unnecessary dev-mode warnings from `hasUnsupportedSubmitterAttributes`.\n-      // we'd bail out anyway, but we just do it silently.\n-      if (hasReactServerActionAttributes(submitter)) {\n-        return\n-      }\n-    }\n-\n+    // this is page-router-only, so we don't need to worry about false positives\n+    // from the attributes that react adds for server actions.\n     if (hasUnsupportedSubmitterAttributes(submitter)) {\n       return\n     }\n@@ -246,173 +143,27 @@ function onFormSubmit(\n     const submitterFormAction = submitter.getAttribute('formAction')\n     if (submitterFormAction !== null) {\n       if (process.env.NODE_ENV === 'development') {\n-        checkActionUrl(submitterFormAction, 'formAction')\n+        checkFormActionUrl(submitterFormAction, 'formAction')\n       }\n       action = submitterFormAction\n     }\n   }\n \n-  let targetUrl: URL\n-  try {\n-    // NOTE: It might be more correct to resolve URLs relative to `document.baseURI`,\n-    // but we already do it relative to `location.href` elsewhere:\n-    //  (see e.g. https://github.com/vercel/next.js/blob/bb0e6722f87ceb2d43015f5b8a413d0072f2badf/packages/next/src/client/components/app-router.tsx#L146)\n-    // so it's better to stay consistent.\n-    const base = window.location.href\n-    targetUrl = new URL(action, base)\n-  } catch (err) {\n-    throw new Error(`Cannot parse form action \"${action}\" as a URL`, {\n-      cause: err,\n-    })\n-  }\n-  if (targetUrl.searchParams.size) {\n-    // url-encoded HTML forms *overwrite* any search params in the `action` url:\n-    //\n-    //  \"Let `query` be the result of running the application/x-www-form-urlencoded serializer [...]\"\n-    //  \"Set parsed action's query component to `query`.\"\n-    //   https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#submit-mutate-action\n-    //\n-    // We need to match that.\n-    // (note that all other parts of the URL, like `hash`, are preserved)\n-    targetUrl.search = ''\n-  }\n-\n-  const formData = new FormData(formElement)\n-\n-  for (let [name, value] of formData) {\n-    if (typeof value !== 'string') {\n-      // For file inputs, the native browser behavior is to use the filename as the value instead:\n-      //\n-      //   \"If entry's value is a File object, then let value be entry's value's name. Otherwise, let value be entry's value.\"\n-      //   https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n-      //\n-      if (process.env.NODE_ENV === 'development') {\n-        console.warn(\n-          `<Form> only supports file inputs if \\`action\\` is a function. File inputs cannot be used if \\`action\\` is a string, ` +\n-            `because files cannot be encoded as search params.`\n-        )\n-      }\n-      value = value.name\n-    }\n-\n-    targetUrl.searchParams.append(name, value)\n-  }\n+  const targetUrl = createFormSubmitDestinationUrl(action, formElement)\n \n   // Finally, no more reasons for bailing out.\n   event.preventDefault()\n \n   const method = replace ? 'replace' : 'push'\n-  const targetHref = targetUrl.href\n-  if (isAppRouter(router)) {\n-    router[method](targetHref, { scroll })\n-  } else {\n-    // TODO(form): Make this use a transition so that pending states work\n-    //\n-    // Unlike the app router, pages router doesn't use startTransition,\n-    // and can't easily be wrapped in one because of implementation details\n-    // (e.g. it doesn't use any react state)\n-    // But it's important to have this wrapped in a transition because\n-    // pending states from e.g. `useFormStatus` rely on that.\n-    // So this needs some follow up work.\n-    router[method](targetHref, undefined, { scroll })\n-  }\n-}\n-\n-type SomeRouter = AppRouterInstance | NextRouter\n-\n-function isAppRouter(router: SomeRouter): router is AppRouterInstance {\n-  return !('asPath' in router)\n-}\n-\n-function useAppOrPagesRouter(): SomeRouter {\n-  const pagesRouter = useContext(RouterContext)\n-  const appRouter = useContext(AppRouterContext)\n-  if (pagesRouter) {\n-    return pagesRouter\n-  } else {\n-    // We're in the app directory if there is no pages router.\n-    return appRouter!\n-  }\n-}\n-\n-function checkActionUrl(action: string, source: 'action' | 'formAction') {\n-  const aPropName = source === 'action' ? `an \\`action\\`` : `a \\`formAction\\``\n-\n-  let testUrl: URL\n-  try {\n-    testUrl = new URL(action, 'http://n')\n-  } catch (err) {\n-    console.error(\n-      `<Form> received ${aPropName} that cannot be parsed as a URL: \"${action}\".`\n-    )\n-    return\n-  }\n-\n-  // url-encoded HTML forms ignore any queryparams in the `action` url. We need to match that.\n-  if (testUrl.searchParams.size) {\n-    console.warn(\n-      `<Form> received ${aPropName} that contains search params: \"${action}\". This is not supported, and they will be ignored. ` +\n-        `If you need to pass in additional search params, use an \\`<input type=\"hidden\" />\\` instead.`\n-    )\n-  }\n-}\n-\n-const isSupportedEncType = (value: string) =>\n-  value === 'application/x-www-form-urlencoded'\n-const isSupportedMethod = (value: string) => value === 'get'\n-const isSupportedTarget = (value: string) => value === '_self'\n-\n-function hasUnsupportedSubmitterAttributes(submitter: HTMLElement): boolean {\n-  // A submitter can override `encType` for the form.\n-  const formEncType = submitter.getAttribute('formEncType')\n-  if (formEncType !== null && !isSupportedEncType(formEncType)) {\n-    if (process.env.NODE_ENV === 'development') {\n-      console.error(\n-        `<Form>'s \\`encType\\` was set to an unsupported value via \\`formEncType=\"${formEncType}\"\\`. ` +\n-          `This will disable <Form>'s navigation functionality. If you need this, use a native <form> element instead.`\n-      )\n-    }\n-    return true\n-  }\n-\n-  // A submitter can override `method` for the form.\n-  const formMethod = submitter.getAttribute('formMethod')\n-  if (formMethod !== null && !isSupportedMethod(formMethod)) {\n-    if (process.env.NODE_ENV === 'development') {\n-      console.error(\n-        `<Form>'s \\`method\\` was set to an unsupported value via \\`formMethod=\"${formMethod}\"\\`. ` +\n-          `This will disable <Form>'s navigation functionality. If you need this, use a native <form> element instead.`\n-      )\n-    }\n-    return true\n-  }\n-\n-  // A submitter can override `target` for the form.\n-  const formTarget = submitter.getAttribute('formTarget')\n-  if (formTarget !== null && !isSupportedTarget(formTarget)) {\n-    if (process.env.NODE_ENV === 'development') {\n-      console.error(\n-        `<Form>'s \\`target\\` was set to an unsupported value via \\`formTarget=\"${formTarget}\"\\`. ` +\n-          `This will disable <Form>'s navigation functionality. If you need this, use a native <form> element instead.`\n-      )\n-    }\n-    return true\n-  }\n-\n-  return false\n-}\n-\n-function hasReactServerActionAttributes(submitter: HTMLElement) {\n-  // https://github.com/facebook/react/blob/942eb80381b96f8410eab1bef1c539bed1ab0eb1/packages/react-client/src/ReactFlightReplyClient.js#L931-L934\n-  const name = submitter.getAttribute('name')\n-  return (\n-    name && (name.startsWith('$ACTION_ID_') || name.startsWith('$ACTION_REF_'))\n-  )\n-}\n-\n-function hasReactClientActionAttributes(submitter: HTMLElement) {\n-  // CSR: https://github.com/facebook/react/blob/942eb80381b96f8410eab1bef1c539bed1ab0eb1/packages/react-dom-bindings/src/client/ReactDOMComponent.js#L482-L487\n-  // SSR: https://github.com/facebook/react/blob/942eb80381b96f8410eab1bef1c539bed1ab0eb1/packages/react-dom-bindings/src/client/ReactDOMComponent.js#L2401\n-  const action = submitter.getAttribute('formAction')\n-  return action && /\\s*javascript:/i.test(action)\n+  const targetHref = targetUrl.href // TODO: will pages router be happy about an absolute URL here?\n+\n+  // TODO(form): Make this use a transition so that pending states work\n+  //\n+  // Unlike the app router, pages router doesn't use startTransition,\n+  // and can't easily be wrapped in one because of implementation details\n+  // (e.g. it doesn't use any react state)\n+  // But it's important to have this wrapped in a transition because\n+  // pending states from e.g. `useFormStatus` rely on that.\n+  // So this needs some follow up work.\n+  router[method](targetHref, undefined, { scroll })\n }"
        }
    ],
    "stats": {
        "total": 775,
        "additions": 258,
        "deletions": 517
    }
}