{
    "author": "sokra",
    "message": "[Turbopack] allow to merge into big enough chunk candidate when 100% overlap (#76321)\n\n### What?\n\nInstead of not looking for further merge candiates when the min chunk size has reached, continue to merge with small chunks that are in all of these chunk groups.",
    "sha": "26543f1eec9c59739e12b08b3800bbb0818b577a",
    "files": [
        {
            "sha": "10aa73332bae949a1b4161733b0045b4517d4bf8",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunking/production.rs",
            "status": "modified",
            "additions": 66,
            "deletions": 45,
            "changes": 111,
            "blob_url": "https://github.com/vercel/next.js/blob/26543f1eec9c59739e12b08b3800bbb0818b577a/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking%2Fproduction.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/26543f1eec9c59739e12b08b3800bbb0818b577a/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking%2Fproduction.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking%2Fproduction.rs?ref=26543f1eec9c59739e12b08b3800bbb0818b577a",
            "patch": "@@ -156,6 +156,15 @@ pub async fn make_production_chunks(\n                             if value <= 1 {\n                                 continue;\n                             }\n+                            // If the candidate is already big enough, avoid shrinking the sharing\n+                            if candidate.size > merge_threshold\n+                                && value != candidate.chunk_groups_len()\n+                            {\n+                                continue;\n+                            }\n+                            if other.size > merge_threshold && value != other.chunk_groups_len() {\n+                                continue;\n+                            }\n                             if let Some((best_i1, best_i2, best_value)) = best_combination.as_mut()\n                             {\n                                 if value > *best_value {\n@@ -170,63 +179,75 @@ pub async fn make_production_chunks(\n                         selection.push(candidate);\n                     }\n \n-                    if let Some((best_i1, best_i2, _)) = best_combination.as_ref() {\n-                        let other = selection.swap_remove(*best_i2);\n-                        let mut candidate = selection.swap_remove(*best_i1);\n-                        for unused in selection {\n-                            chunks_to_merge.push(unused);\n-                        }\n-                        // Merge other into candidate\n-                        let MergeCandidate {\n-                            size,\n-                            chunk_items,\n-                            chunk_groups,\n-                        } = other;\n-                        candidate.size += size;\n-                        candidate.chunk_items.extend(chunk_items);\n-                        candidate.chunk_groups =\n-                            merge_chunk_groups(&candidate.chunk_groups, &chunk_groups);\n-\n-                        // Merged chunk either goes back to the heap or\n-                        // is considered for merging again\n-                        if candidate.size > merge_threshold {\n+                    let best_value =\n+                        if let Some((best_i1, best_i2, best_value)) = best_combination.as_ref() {\n+                            let other = selection.swap_remove(*best_i2);\n+                            let mut candidate = selection.swap_remove(*best_i1);\n+                            // Merge other into candidate\n+                            let MergeCandidate {\n+                                size,\n+                                chunk_items,\n+                                chunk_groups,\n+                            } = other;\n+                            candidate.size += size;\n+                            candidate.chunk_items.extend(chunk_items);\n+                            candidate.chunk_groups =\n+                                merge_chunk_groups(&candidate.chunk_groups, &chunk_groups);\n+\n+                            // Merged candidate is pushed back into the queue\n+                            chunks_to_merge.push(candidate);\n+\n+                            *best_value\n+                        } else {\n+                            u64::MAX\n+                        };\n+                    for unused in selection {\n+                        // Candiates from selection that are already big enough move into the\n+                        // heap again when no more merges are expected.\n+                        // Since we can only merge into big enough candates when overlap ==\n+                        // chunk_groups_len we can use that as condition.\n+                        if unused.size > merge_threshold && unused.chunk_groups_len() > best_value {\n                             heap.push(ChunkCandidate {\n-                                size: candidate.size,\n-                                chunk_items: candidate.chunk_items,\n-                                chunk_groups: candidate.chunk_groups,\n+                                size: unused.size,\n+                                chunk_items: unused.chunk_items,\n+                                chunk_groups: unused.chunk_groups,\n                             });\n                         } else {\n-                            chunks_to_merge.push(candidate);\n-                        }\n-                    } else {\n-                        // No merges possible\n-                        for unused in selection {\n                             chunks_to_merge.push(unused);\n                         }\n+                    }\n+                    if best_combination.is_none() {\n+                        // No merges possible\n                         break;\n                     }\n                 }\n \n-                // Left-over chunks are merged together forming the remainer chunk, which includes\n-                // all modules that are not sharable\n-                if let Some(MergeCandidate {\n-                    mut size,\n-                    mut chunk_items,\n-                    chunk_groups: _,\n-                }) = chunks_to_merge.pop()\n+                let mut remainer_size = 0;\n+                let mut remainer_chunk_items = Vec::new();\n+                for MergeCandidate {\n+                    size,\n+                    chunk_items,\n+                    chunk_groups,\n+                } in chunks_to_merge.into_iter()\n                 {\n-                    for chunk in chunks_to_merge {\n-                        let MergeCandidate {\n-                            size: other_size,\n-                            chunk_items: other_chunk_items,\n-                            chunk_groups: _,\n-                        } = chunk;\n-                        size += other_size;\n-                        chunk_items.extend(other_chunk_items);\n+                    if size > merge_threshold {\n+                        heap.push(ChunkCandidate {\n+                            size,\n+                            chunk_items,\n+                            chunk_groups,\n+                        });\n+                    } else {\n+                        remainer_size += size;\n+                        remainer_chunk_items.extend(chunk_items);\n                     }\n+                }\n+\n+                // Left-over chunks are merged together forming the remainer chunk, which includes\n+                // all modules that are not sharable\n+                if !remainer_chunk_items.is_empty() {\n                     heap.push(ChunkCandidate {\n-                        size,\n-                        chunk_items,\n+                        size: remainer_size,\n+                        chunk_items: remainer_chunk_items,\n                         chunk_groups: None,\n                     });\n                 }"
        }
    ],
    "stats": {
        "total": 111,
        "additions": 66,
        "deletions": 45
    }
}