{
    "author": "acdlite",
    "message": "[Segment Cache] Implement hash-only navigations (#76179)\n\nWhen a navigation happens and the only thing that changes is the hash\nfragment, we must do some special handling to ensure that the hash is\ncorrectly scrolled into view.\n\nNearly all of this is handled by ScrollAndFocusHandler; for the Segment\nCache, the only thing we need to do is update a few of the fields on the\nrouter state object, like `scrollableSegments` and `onlyHashChange`.",
    "sha": "20f72b93f0740c96dc7906d0996cc526fb24ffe7",
    "files": [
        {
            "sha": "15dd351f8327a68479fcb53b3a3c02af02f3ec36",
            "filename": "packages/next/src/client/components/router-reducer/reducers/navigate-reducer.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 8,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/20f72b93f0740c96dc7906d0996cc526fb24ffe7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/20f72b93f0740c96dc7906d0996cc526fb24ffe7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts?ref=20f72b93f0740c96dc7906d0996cc526fb24ffe7",
            "patch": "@@ -101,6 +101,7 @@ function triggerLazyFetchForLeafSegments(\n }\n \n function handleNavigationResult(\n+  url: URL,\n   state: ReadonlyReducerState,\n   mutable: Mutable,\n   pendingPush: boolean,\n@@ -112,24 +113,46 @@ function handleNavigationResult(\n       const newUrl = result.data\n       return handleExternalUrl(state, mutable, newUrl, pendingPush)\n     }\n-    case NavigationResultTag.NoOp:\n-      // The server responded with no change to the current page.\n+    case NavigationResultTag.NoOp: {\n+      // The server responded with no change to the current page. However, if\n+      // the URL changed, we still need to update that.\n+      const newCanonicalUrl = result.data.canonicalUrl\n+      mutable.canonicalUrl = newCanonicalUrl\n+\n+      // Check if the only thing that changed was the hash fragment.\n+      const oldUrl = new URL(state.canonicalUrl, url)\n+      const onlyHashChange =\n+        // We don't need to compare the origins, because client-driven\n+        // navigations are always same-origin.\n+        url.pathname === oldUrl.pathname &&\n+        url.search === oldUrl.search &&\n+        url.hash !== oldUrl.hash\n+      if (onlyHashChange) {\n+        // The only updated part of the URL is the hash.\n+        mutable.onlyHashChange = true\n+        mutable.shouldScroll = result.data.shouldScroll\n+        mutable.hashFragment = url.hash\n+        // Setting this to an empty array triggers a scroll for all new and\n+        // updated segments. See `ScrollAndFocusHandler` for more details.\n+        mutable.scrollableSegments = []\n+      }\n+\n       return handleMutable(state, mutable)\n+    }\n     case NavigationResultTag.Success: {\n       // Received a new result.\n       mutable.cache = result.data.cacheNode\n       mutable.patchedTree = result.data.flightRouterState\n       mutable.canonicalUrl = result.data.canonicalUrl\n       mutable.scrollableSegments = result.data.scrollableSegments\n       mutable.shouldScroll = result.data.shouldScroll\n-      // TODO: Not yet implemented\n-      // mutable.hashFragment = hash\n+      mutable.hashFragment = result.data.hash\n       return handleMutable(state, mutable)\n     }\n     case NavigationResultTag.Async: {\n       return result.data.then(\n         (asyncResult) =>\n-          handleNavigationResult(state, mutable, pendingPush, asyncResult),\n+          handleNavigationResult(url, state, mutable, pendingPush, asyncResult),\n         // If the navigation failed, return the current state.\n         // TODO: This matches the current behavior but we need to do something\n         // better here if the network fails.\n@@ -138,9 +161,10 @@ function handleNavigationResult(\n         }\n       )\n     }\n-    default:\n-      const _exhaustiveCheck: never = result\n+    default: {\n+      result satisfies never\n       return state\n+    }\n   }\n }\n \n@@ -189,7 +213,7 @@ export function navigateReducer(\n       state.nextUrl,\n       shouldScroll\n     )\n-    return handleNavigationResult(state, mutable, pendingPush, result)\n+    return handleNavigationResult(url, state, mutable, pendingPush, result)\n   }\n \n   const prefetchValues = getOrCreatePrefetchCacheEntry({"
        },
        {
            "sha": "28aaffca1e55bd51517d366d40a2c56ed431bcdc",
            "filename": "packages/next/src/client/components/segment-cache/navigation.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 22,
            "changes": 62,
            "blob_url": "https://github.com/vercel/next.js/blob/20f72b93f0740c96dc7906d0996cc526fb24ffe7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/20f72b93f0740c96dc7906d0996cc526fb24ffe7/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts?ref=20f72b93f0740c96dc7906d0996cc526fb24ffe7",
            "patch": "@@ -39,7 +39,10 @@ type MPANavigationResult = {\n \n type NoOpNavigationResult = {\n   tag: NavigationResultTag.NoOp\n-  data: null\n+  data: {\n+    canonicalUrl: string\n+    shouldScroll: boolean\n+  }\n }\n \n type SuccessfulNavigationResult = {\n@@ -50,6 +53,7 @@ type SuccessfulNavigationResult = {\n     canonicalUrl: string\n     scrollableSegments: Array<FlightSegmentPath>\n     shouldScroll: boolean\n+    hash: string\n   }\n }\n \n@@ -66,11 +70,6 @@ export type NavigationResult =\n   | NoOpNavigationResult\n   | AsyncNavigationResult\n \n-const noOpNavigationResult: NoOpNavigationResult = {\n-  tag: NavigationResultTag.NoOp,\n-  data: null,\n-}\n-\n /**\n  * Navigate to a new URL, using the Segment Cache to construct a response.\n  *\n@@ -97,7 +96,7 @@ export function navigate(\n     const prefetchSeedData = snapshot.seedData\n     const prefetchHead = route.head\n     const isPrefetchHeadPartial = route.isHeadPartial\n-    const canonicalUrl = route.canonicalUrl\n+    const newCanonicalUrl = route.canonicalUrl\n     return navigateUsingPrefetchedRouteTree(\n       url,\n       nextUrl,\n@@ -107,8 +106,9 @@ export function navigate(\n       prefetchSeedData,\n       prefetchHead,\n       isPrefetchHeadPartial,\n-      canonicalUrl,\n-      shouldScroll\n+      newCanonicalUrl,\n+      shouldScroll,\n+      url.hash\n     )\n   }\n   // There's no matching prefetch for this route in the cache.\n@@ -119,7 +119,8 @@ export function navigate(\n       nextUrl,\n       currentCacheNode,\n       currentFlightRouterState,\n-      shouldScroll\n+      shouldScroll,\n+      url.hash\n     ),\n   }\n }\n@@ -134,7 +135,8 @@ function navigateUsingPrefetchedRouteTree(\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n   canonicalUrl: string,\n-  shouldScroll: boolean\n+  shouldScroll: boolean,\n+  hash: string\n ): SuccessfulNavigationResult | NoOpNavigationResult | MPANavigationResult {\n   // Recursively construct a prefetch tree by reading from the Segment Cache. To\n   // maintain compatibility, we output the same data structures as the old\n@@ -169,19 +171,28 @@ function navigateUsingPrefetchedRouteTree(\n       currentCacheNode,\n       canonicalUrl,\n       scrollableSegments,\n-      shouldScroll\n+      shouldScroll,\n+      hash\n     )\n   }\n-  // The server sent back an empty tree patch. There's nothing to update.\n-  return noOpNavigationResult\n+  // The server sent back an empty tree patch. There's nothing to update, except\n+  // possibly the URL.\n+  return {\n+    tag: NavigationResultTag.NoOp,\n+    data: {\n+      canonicalUrl,\n+      shouldScroll,\n+    },\n+  }\n }\n \n function navigationTaskToResult(\n   task: PPRNavigationTask,\n   currentCacheNode: CacheNode,\n   canonicalUrl: string,\n   scrollableSegments: Array<FlightSegmentPath>,\n-  shouldScroll: boolean\n+  shouldScroll: boolean,\n+  hash: string\n ): SuccessfulNavigationResult | MPANavigationResult {\n   const flightRouterState = task.route\n   if (flightRouterState === null) {\n@@ -201,6 +212,7 @@ function navigationTaskToResult(\n       canonicalUrl,\n       scrollableSegments,\n       shouldScroll,\n+      hash,\n     },\n   }\n }\n@@ -279,7 +291,8 @@ async function navigateDynamicallyWithNoPrefetch(\n   nextUrl: string | null,\n   currentCacheNode: CacheNode,\n   currentFlightRouterState: FlightRouterState,\n-  shouldScroll: boolean\n+  shouldScroll: boolean,\n+  hash: string\n ): Promise<\n   MPANavigationResult | SuccessfulNavigationResult | NoOpNavigationResult\n > {\n@@ -302,9 +315,6 @@ async function navigateDynamicallyWithNoPrefetch(\n   const { flightData, canonicalUrl: canonicalUrlOverride } =\n     await promiseForDynamicServerResponse\n \n-  // TODO: Detect if the only thing that changed was the hash, like we do in\n-  // in navigateReducer\n-\n   if (typeof flightData === 'string') {\n     // This is an MPA navigation.\n     const newUrl = flightData\n@@ -364,11 +374,19 @@ async function navigateDynamicallyWithNoPrefetch(\n       currentCacheNode,\n       canonicalUrl,\n       scrollableSegments,\n-      shouldScroll\n+      shouldScroll,\n+      hash\n     )\n   }\n-  // The server sent back an empty tree patch. There's nothing to update.\n-  return noOpNavigationResult\n+  // The server sent back an empty tree patch. There's nothing to update, except\n+  // possibly the URL.\n+  return {\n+    tag: NavigationResultTag.NoOp,\n+    data: {\n+      canonicalUrl,\n+      shouldScroll,\n+    },\n+  }\n }\n \n function simulatePrefetchTreeUsingDynamicTreePatch("
        }
    ],
    "stats": {
        "total": 102,
        "additions": 72,
        "deletions": 30
    }
}