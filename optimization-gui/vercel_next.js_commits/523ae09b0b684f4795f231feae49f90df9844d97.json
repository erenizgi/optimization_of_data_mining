{
    "author": "lubieowoce",
    "message": "[Cache Components] Faster partial hydration in PPR resumes (#82742)\n\nThis PR fixes some HTML/RSC stream interleaving logic that, under some\ncircumstances, resulted in hydration of a resumed page being delayed\nunnecessarily.\n\nFixes NAR-284\n\n---\n\nWhen SSRing a page, we're mixing two streams -- the HTML stream, and the\nRSC stream (containing scripts with RSC data, used for hydration). In a\nregular (non-PPR) render, we need to wait for react to flush the first\nHTML chunk (containing `<html><body>...`) before we can send the first\nRSC script. This was implemented in `createMergedTransformStream`.\n\nThe problem was that `createMergedTransformStream` was also re-used when\nrendering a PPR `resume()`. In that case, we're only outputting the\ndynamic portion of HTML, and the shell is sent separately (either by the\nnext server, outside of `app-render`, or by infrastructure), meaning\nthat is _not_ part of the stream that `createMergedTransformStream`\nreceives. But the \"wait for the first html chunk\" logic was still there,\nand thus, we were accidentally delaying sending any RSC scripts until\nthe first piece of dynamic HTML was rendered even if they had no\nconnection to each other. In particular, this also prevented us from\nsending hydration data for the static shell.\n\nThere's one edge case here -- if we didn't produce a static shell (e.g.\nfor suspense-above-body), we should still apply the html-waiting logic,\notherwise we'd end up sending scripts before the body is rendered. But\nif we have a shell, we shouldn't wait for the HTML at all.\n\nThis is now solved as follows:\n1. During the prerender, we track whether or not a shell (aka \"prelude\")\nwas produced, and store that information in the postponed state object\n2. When resuming, we check whether the prerender had a shell, and if it\ndoes, we don't wait for HTML (under the assumption that it was already\nsent separately, outside the dynamic render)\n\nTo test this, I've had to extend our testing setup a bit -- with the\ndefault settings, playwright would wait until `load` is fired, which\nseems to fire after all the HTML finished streaming and thus doesn't let\nus inspect whether partial hydration is working correctly. We're also\nwaiting for `load` in `elementByCss` (apparently, for compatibility with\ntests written before playwright) so i've had to work around that as\nwell.",
    "sha": "523ae09b0b684f4795f231feae49f90df9844d97",
    "files": [
        {
            "sha": "9cc0312427bcce61c43dcf114dbbf3b51d4fffb0",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 40,
            "deletions": 23,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -107,6 +107,7 @@ import {\n import {\n   DynamicState,\n   type PostponedState,\n+  DynamicHTMLPreludeState,\n   parsePostponedState,\n } from './postponed-state'\n import {\n@@ -2291,8 +2292,8 @@ async function renderToStream(\n         )\n       } else if (postponedState) {\n         // We assume we have dynamic HTML requiring a resume render to complete\n-        const postponed = getPostponedFromState(postponedState)\n-\n+        const { postponed, preludeState } =\n+          getPostponedFromState(postponedState)\n         const resume = (\n           require('react-dom/server') as typeof import('react-dom/server')\n         ).resume\n@@ -2319,6 +2320,12 @@ async function renderToStream(\n           tracingMetadata: tracingMetadata,\n         })\n         return await continueDynamicHTMLResume(htmlStream, {\n+          // If the prelude is empty (i.e. is no static shell), we should wait for initial HTML to be rendered\n+          // to avoid injecting RSC data too early.\n+          // If we have a non-empty-prelude (i.e. a static HTML shell), then it's already been sent separately,\n+          // so we shouldn't wait for any HTML to be emitted from the resume before sending RSC data.\n+          delayDataUntilFirstHtmlChunk:\n+            preludeState === DynamicHTMLPreludeState.Empty,\n           inlinedDataStream: createInlinedDataReadableStream(\n             reactServerResult.consume(),\n             nonce,\n@@ -3919,6 +3926,9 @@ async function prerenderToStream(\n           // Dynamic HTML case\n           metadata.postponed = await getDynamicHTMLPostponedState(\n             postponed,\n+            preludeIsEmpty\n+              ? DynamicHTMLPreludeState.Empty\n+              : DynamicHTMLPreludeState.Full,\n             fallbackRouteParams,\n             resumeDataCache\n           )\n@@ -4071,27 +4081,28 @@ async function prerenderToStream(\n       const prerender = (\n         require('react-dom/static') as typeof import('react-dom/static')\n       ).prerender\n-      const { prelude, postponed } = await workUnitAsyncStorage.run(\n-        ssrPrerenderStore,\n-        prerender,\n-        <App\n-          reactServerStream={reactServerResult.asUnclosingStream()}\n-          preinitScripts={preinitScripts}\n-          clientReferenceManifest={clientReferenceManifest}\n-          ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n-          nonce={nonce}\n-        />,\n-        {\n-          onError: htmlRendererErrorHandler,\n-          onHeaders: (headers: Headers) => {\n-            headers.forEach((value, key) => {\n-              appendHeader(key, value)\n-            })\n-          },\n-          maxHeadersLength: reactMaxHeadersLength,\n-          bootstrapScripts: [bootstrapScript],\n-        }\n-      )\n+      const { prelude: unprocessedPrelude, postponed } =\n+        await workUnitAsyncStorage.run(\n+          ssrPrerenderStore,\n+          prerender,\n+          <App\n+            reactServerStream={reactServerResult.asUnclosingStream()}\n+            preinitScripts={preinitScripts}\n+            clientReferenceManifest={clientReferenceManifest}\n+            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n+            nonce={nonce}\n+          />,\n+          {\n+            onError: htmlRendererErrorHandler,\n+            onHeaders: (headers: Headers) => {\n+              headers.forEach((value, key) => {\n+                appendHeader(key, value)\n+              })\n+            },\n+            maxHeadersLength: reactMaxHeadersLength,\n+            bootstrapScripts: [bootstrapScript],\n+          }\n+        )\n       const getServerInsertedHTML = makeGetServerInsertedHTML({\n         polyfills,\n         renderServerInsertedHTML,\n@@ -4115,6 +4126,9 @@ async function prerenderToStream(\n         )\n       }\n \n+      const { prelude, preludeIsEmpty } =\n+        await processPrelude(unprocessedPrelude)\n+\n       /**\n        * When prerendering there are three outcomes to consider\n        *\n@@ -4135,6 +4149,9 @@ async function prerenderToStream(\n           // Dynamic HTML case.\n           metadata.postponed = await getDynamicHTMLPostponedState(\n             postponed,\n+            preludeIsEmpty\n+              ? DynamicHTMLPreludeState.Empty\n+              : DynamicHTMLPreludeState.Full,\n             fallbackRouteParams,\n             prerenderResumeDataCache\n           )"
        },
        {
            "sha": "8e4697f76d3a261e460b340e449c2b5cd7489c91",
            "filename": "packages/next/src/server/app-render/postponed-state.test.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 7,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.test.ts?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -8,6 +8,7 @@ import {\n   getDynamicDataPostponedState,\n   getDynamicHTMLPostponedState,\n   parsePostponedState,\n+  DynamicHTMLPreludeState,\n } from './postponed-state'\n \n describe('getDynamicHTMLPostponedState', () => {\n@@ -30,19 +31,23 @@ describe('getDynamicHTMLPostponedState', () => {\n \n     const state = await getDynamicHTMLPostponedState(\n       { [key]: key, nested: { [key]: key } },\n+      DynamicHTMLPreludeState.Full,\n       fallbackRouteParams,\n       prerenderResumeDataCache\n     )\n \n     const parsed = parsePostponedState(state, { slug: '123' })\n     expect(parsed).toMatchInlineSnapshot(`\n      {\n-       \"data\": {\n-         \"123\": \"123\",\n-         \"nested\": {\n+       \"data\": [\n+         1,\n+         {\n            \"123\": \"123\",\n+           \"nested\": {\n+             \"123\": \"123\",\n+           },\n          },\n-       },\n+       ],\n        \"renderResumeDataCache\": {\n          \"cache\": Map {\n            \"1\" => Promise {},\n@@ -65,17 +70,19 @@ describe('getDynamicHTMLPostponedState', () => {\n   it('serializes a HTML postponed state without fallback params', async () => {\n     const state = await getDynamicHTMLPostponedState(\n       { key: 'value' },\n+      DynamicHTMLPreludeState.Full,\n       null,\n       createPrerenderResumeDataCache()\n     )\n-    expect(state).toMatchInlineSnapshot(`\"15:{\"key\":\"value\"}null\"`)\n+    expect(state).toMatchInlineSnapshot(`\"19:[1,{\"key\":\"value\"}]null\"`)\n   })\n \n   it('can serialize and deserialize a HTML postponed state with fallback params', async () => {\n     const key = '%%drp:slug:e9615126684e5%%'\n     const fallbackRouteParams = new Map([['slug', key]])\n     const state = await getDynamicHTMLPostponedState(\n       { [key]: key },\n+      DynamicHTMLPreludeState.Full,\n       fallbackRouteParams,\n       createPrerenderResumeDataCache()\n     )\n@@ -85,7 +92,7 @@ describe('getDynamicHTMLPostponedState', () => {\n     const parsed = parsePostponedState(state, params)\n     expect(parsed).toEqual({\n       type: DynamicState.HTML,\n-      data: { [value]: value },\n+      data: [1, { [value]: value }],\n       renderResumeDataCache: createPrerenderResumeDataCache(),\n     })\n \n@@ -105,7 +112,7 @@ describe('getDynamicDataPostponedState', () => {\n \n describe('parsePostponedState', () => {\n   it('parses a HTML postponed state with fallback params', () => {\n-    const state = `2589:39[[\"slug\",\"%%drp:slug:e9615126684e5%%\"]]{\"t\":2,\"d\":{\"nextSegmentId\":2,\"rootFormatContext\":{\"insertionMode\":0,\"selectedValue\":null,\"tagScope\":0},\"progressiveChunkSize\":12800,\"resumableState\":{\"idPrefix\":\"\",\"nextFormID\":0,\"streamingFormat\":0,\"instructions\":0,\"hasBody\":true,\"hasHtml\":true,\"unknownResources\":{},\"dnsResources\":{},\"connectResources\":{\"default\":{},\"anonymous\":{},\"credentials\":{}},\"imageResources\":{},\"styleResources\":{},\"scriptResources\":{\"/_next/static/chunks/webpack-6b2534a6458c6fe5.js\":null,\"/_next/static/chunks/f5e865f6-5e04edf75402c5e9.js\":null,\"/_next/static/chunks/9440-26a4cfbb73347735.js\":null,\"/_next/static/chunks/main-app-315ef55d588dbeeb.js\":null,\"/_next/static/chunks/8630-8e01a4bea783c651.js\":null,\"/_next/static/chunks/app/layout-1b900e1a3caf3737.js\":null},\"moduleUnknownResources\":{},\"moduleScriptResources\":{\"/_next/static/chunks/webpack-6b2534a6458c6fe5.js\":null}},\"replayNodes\":[[\"oR\",0,[[\"Context.Provider\",0,[[\"ServerInsertedHTMLProvider\",0,[[\"Context.Provider\",0,[[\"n7\",0,[[\"nU\",0,[[\"nF\",0,[[\"n9\",0,[[\"Fragment\",0,[[\"Context.Provider\",2,[[\"Context.Provider\",0,[[\"Context.Provider\",0,[[\"Context.Provider\",0,[[\"Context.Provider\",0,[[\"Context.Provider\",0,[[\"nY\",0,[[\"nX\",0,[[\"Fragment\",\"c\",[[\"Fragment\",0,[[\"html\",1,[[\"body\",0,[[\"main\",3,[[\"j\",0,[[\"Fragment\",0,[[\"Context.Provider\",\"validation\",[[\"i\",2,[[\"Fragment\",0,[[\"E\",0,[[\"R\",0,[[\"h\",0,[[\"Fragment\",0,[[\"O\",0,[[\"Fragment\",0,[[\"s\",0,[[\"c\",0,[[\"s\",0,[[\"c\",0,[[\"v\",0,[[\"Context.Provider\",0,[[\"Fragment\",\"c\",[[\"j\",1,[[\"Fragment\",0,[[\"Context.Provider\",\"slug|%%drp:slug:e9615126684e5%%|d\",[[\"i\",2,[[\"Fragment\",0,[[\"E\",0,[[\"R\",0,[[\"h\",0,[[\"Fragment\",0,[[\"O\",0,[[\"Fragment\",0,[[\"s\",0,[[\"Fragment\",0,[[\"s\",0,[[\"c\",0,[[\"v\",0,[[\"Context.Provider\",0,[[\"Fragment\",\"c\",[[\"j\",1,[[\"Fragment\",0,[[\"Context.Provider\",\"__PAGE__\",[[\"i\",2,[[\"Fragment\",0,[[\"E\",0,[[\"R\",0,[[\"h\",0,[[\"Fragment\",0,[[\"O\",0,[[\"Suspense\",0,[[\"s\",0,[[\"Fragment\",0,[[\"s\",0,[[\"c\",0,[[\"v\",0,[[\"Context.Provider\",0,[[\"Fragment\",\"c\",[[\"Fragment\",0,[],{\"1\":1}]],null]],null]],null]],null]],null]],null]],null]],null,[\"Suspense Fallback\",0,[],null],0]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],\"replaySlots\":null}}null`\n+    const state = `2593:39[[\"slug\",\"%%drp:slug:e9615126684e5%%\"]][1,{\"t\":2,\"d\":{\"nextSegmentId\":2,\"rootFormatContext\":{\"insertionMode\":0,\"selectedValue\":null,\"tagScope\":0},\"progressiveChunkSize\":12800,\"resumableState\":{\"idPrefix\":\"\",\"nextFormID\":0,\"streamingFormat\":0,\"instructions\":0,\"hasBody\":true,\"hasHtml\":true,\"unknownResources\":{},\"dnsResources\":{},\"connectResources\":{\"default\":{},\"anonymous\":{},\"credentials\":{}},\"imageResources\":{},\"styleResources\":{},\"scriptResources\":{\"/_next/static/chunks/webpack-6b2534a6458c6fe5.js\":null,\"/_next/static/chunks/f5e865f6-5e04edf75402c5e9.js\":null,\"/_next/static/chunks/9440-26a4cfbb73347735.js\":null,\"/_next/static/chunks/main-app-315ef55d588dbeeb.js\":null,\"/_next/static/chunks/8630-8e01a4bea783c651.js\":null,\"/_next/static/chunks/app/layout-1b900e1a3caf3737.js\":null},\"moduleUnknownResources\":{},\"moduleScriptResources\":{\"/_next/static/chunks/webpack-6b2534a6458c6fe5.js\":null}},\"replayNodes\":[[\"oR\",0,[[\"Context.Provider\",0,[[\"ServerInsertedHTMLProvider\",0,[[\"Context.Provider\",0,[[\"n7\",0,[[\"nU\",0,[[\"nF\",0,[[\"n9\",0,[[\"Fragment\",0,[[\"Context.Provider\",2,[[\"Context.Provider\",0,[[\"Context.Provider\",0,[[\"Context.Provider\",0,[[\"Context.Provider\",0,[[\"Context.Provider\",0,[[\"nY\",0,[[\"nX\",0,[[\"Fragment\",\"c\",[[\"Fragment\",0,[[\"html\",1,[[\"body\",0,[[\"main\",3,[[\"j\",0,[[\"Fragment\",0,[[\"Context.Provider\",\"validation\",[[\"i\",2,[[\"Fragment\",0,[[\"E\",0,[[\"R\",0,[[\"h\",0,[[\"Fragment\",0,[[\"O\",0,[[\"Fragment\",0,[[\"s\",0,[[\"c\",0,[[\"s\",0,[[\"c\",0,[[\"v\",0,[[\"Context.Provider\",0,[[\"Fragment\",\"c\",[[\"j\",1,[[\"Fragment\",0,[[\"Context.Provider\",\"slug|%%drp:slug:e9615126684e5%%|d\",[[\"i\",2,[[\"Fragment\",0,[[\"E\",0,[[\"R\",0,[[\"h\",0,[[\"Fragment\",0,[[\"O\",0,[[\"Fragment\",0,[[\"s\",0,[[\"Fragment\",0,[[\"s\",0,[[\"c\",0,[[\"v\",0,[[\"Context.Provider\",0,[[\"Fragment\",\"c\",[[\"j\",1,[[\"Fragment\",0,[[\"Context.Provider\",\"__PAGE__\",[[\"i\",2,[[\"Fragment\",0,[[\"E\",0,[[\"R\",0,[[\"h\",0,[[\"Fragment\",0,[[\"O\",0,[[\"Suspense\",0,[[\"s\",0,[[\"Fragment\",0,[[\"s\",0,[[\"c\",0,[[\"v\",0,[[\"Context.Provider\",0,[[\"Fragment\",\"c\",[[\"Fragment\",0,[],{\"1\":1}]],null]],null]],null]],null]],null]],null]],null]],null,[\"Suspense Fallback\",0,[],null],0]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],null]],\"replaySlots\":null}}]null`\n     const params = {\n       slug: Math.random().toString(16).slice(3),\n     }"
        },
        {
            "sha": "9396904a3086fe118cffd681f66999689f290778",
            "filename": "packages/next/src/server/app-render/postponed-state.ts",
            "status": "modified",
            "additions": 22,
            "deletions": 12,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fpostponed-state.ts?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -47,35 +47,48 @@ export type DynamicHTMLPostponedState = {\n   /**\n    * The postponed data used by React.\n    */\n-  readonly data: object\n+  readonly data: [\n+    preludeState: DynamicHTMLPreludeState,\n+    postponed: ReactPostponed,\n+  ]\n \n   /**\n    * The immutable resume data cache.\n    */\n   readonly renderResumeDataCache: RenderResumeDataCache\n }\n \n+export const enum DynamicHTMLPreludeState {\n+  Empty = 0,\n+  Full = 1,\n+}\n+\n+type ReactPostponed = NonNullable<\n+  import('react-dom/static').PrerenderResult['postponed']\n+>\n+\n export type PostponedState =\n   | DynamicDataPostponedState\n   | DynamicHTMLPostponedState\n \n export async function getDynamicHTMLPostponedState(\n-  data: object,\n+  postponed: ReactPostponed,\n+  preludeState: DynamicHTMLPreludeState,\n   fallbackRouteParams: FallbackRouteParams | null,\n   resumeDataCache: PrerenderResumeDataCache | RenderResumeDataCache\n ): Promise<string> {\n-  if (!fallbackRouteParams || fallbackRouteParams.size === 0) {\n-    const postponedString = JSON.stringify(data)\n+  const data: DynamicHTMLPostponedState['data'] = [preludeState, postponed]\n+  const dataString = JSON.stringify(data)\n \n+  if (!fallbackRouteParams || fallbackRouteParams.size === 0) {\n     // Serialized as `<postponedString.length>:<postponedString><renderResumeDataCache>`\n-    return `${postponedString.length}:${postponedString}${await stringifyResumeDataCache(\n+    return `${dataString.length}:${dataString}${await stringifyResumeDataCache(\n       createRenderResumeDataCache(resumeDataCache)\n     )}`\n   }\n \n   const replacements: Array<[string, string]> = Array.from(fallbackRouteParams)\n   const replacementsString = JSON.stringify(replacements)\n-  const dataString = JSON.stringify(data)\n \n   // Serialized as `<replacements.length><replacements><data>`\n   const postponedString = `${replacementsString.length}${replacementsString}${dataString}`\n@@ -168,10 +181,7 @@ export function parsePostponedState(\n   }\n }\n \n-export function getPostponedFromState(state: PostponedState): any {\n-  if (state.type === DynamicState.DATA) {\n-    return null\n-  }\n-\n-  return state.data\n+export function getPostponedFromState(state: DynamicHTMLPostponedState) {\n+  const [preludeState, postponed] = state.data\n+  return { preludeState, postponed }\n }"
        },
        {
            "sha": "38018d3e2d54da6aedb4375f5f15a96e1abb62c6",
            "filename": "packages/next/src/server/stream-utils/node-web-streams-helper.ts",
            "status": "modified",
            "additions": 55,
            "deletions": 24,
            "changes": 79,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/packages%2Fnext%2Fsrc%2Fserver%2Fstream-utils%2Fnode-web-streams-helper.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/packages%2Fnext%2Fsrc%2Fserver%2Fstream-utils%2Fnode-web-streams-helper.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fstream-utils%2Fnode-web-streams-helper.ts?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -449,32 +449,40 @@ function createDeferredSuffixStream(\n   })\n }\n \n-// Merge two streams into one. Ensure the final transform stream is closed\n-// when both are finished.\n-function createMergedTransformStream(\n-  stream: ReadableStream<Uint8Array>\n+function createFlightDataInjectionTransformStream(\n+  stream: ReadableStream<Uint8Array>,\n+  delayDataUntilFirstHtmlChunk: boolean\n ): TransformStream<Uint8Array, Uint8Array> {\n+  let htmlStreamFinished = false\n+\n   let pull: Promise<void> | null = null\n   let donePulling = false\n \n-  async function startPulling(controller: TransformStreamDefaultController) {\n-    if (pull) {\n-      return\n+  function startOrContinuePulling(\n+    controller: TransformStreamDefaultController\n+  ) {\n+    if (!pull) {\n+      pull = startPulling(controller)\n     }\n+    return pull\n+  }\n \n+  async function startPulling(controller: TransformStreamDefaultController) {\n     const reader = stream.getReader()\n \n-    // NOTE: streaming flush\n-    // We are buffering here for the inlined data stream because the\n-    // \"shell\" stream might be chunkenized again by the underlying stream\n-    // implementation, e.g. with a specific high-water mark. To ensure it's\n-    // the safe timing to pipe the data stream, this extra tick is\n-    // necessary.\n-\n-    // We don't start reading until we've left the current Task to ensure\n-    // that it's inserted after flushing the shell. Note that this implementation\n-    // might get stale if impl details of Fizz change in the future.\n-    await atLeastOneTask()\n+    if (delayDataUntilFirstHtmlChunk) {\n+      // NOTE: streaming flush\n+      // We are buffering here for the inlined data stream because the\n+      // \"shell\" stream might be chunkenized again by the underlying stream\n+      // implementation, e.g. with a specific high-water mark. To ensure it's\n+      // the safe timing to pipe the data stream, this extra tick is\n+      // necessary.\n+\n+      // We don't start reading until we've left the current Task to ensure\n+      // that it's inserted after flushing the shell. Note that this implementation\n+      // might get stale if impl details of Fizz change in the future.\n+      await atLeastOneTask()\n+    }\n \n     try {\n       while (true) {\n@@ -484,6 +492,12 @@ function createMergedTransformStream(\n           return\n         }\n \n+        // We want to prioritize HTML over RSC data.\n+        // The SSR render is based on the same RSC stream, so when we get a new RSC chunk,\n+        // we're likely to produce an HTML chunk as well, so give it a chance to flush first.\n+        if (!delayDataUntilFirstHtmlChunk && !htmlStreamFinished) {\n+          await atLeastOneTask()\n+        }\n         controller.enqueue(value)\n       }\n     } catch (err) {\n@@ -492,19 +506,25 @@ function createMergedTransformStream(\n   }\n \n   return new TransformStream({\n+    start(controller) {\n+      if (!delayDataUntilFirstHtmlChunk) {\n+        startOrContinuePulling(controller)\n+      }\n+    },\n     transform(chunk, controller) {\n       controller.enqueue(chunk)\n \n       // Start the streaming if it hasn't already been started yet.\n-      if (!pull) {\n-        pull = startPulling(controller)\n+      if (delayDataUntilFirstHtmlChunk) {\n+        startOrContinuePulling(controller)\n       }\n     },\n     flush(controller) {\n+      htmlStreamFinished = true\n       if (donePulling) {\n         return\n       }\n-      return pull || startPulling(controller)\n+      return startOrContinuePulling(controller)\n     },\n   })\n }\n@@ -711,7 +731,9 @@ export async function continueFizzStream(\n       : null,\n \n     // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n-    inlinedDataStream ? createMergedTransformStream(inlinedDataStream) : null,\n+    inlinedDataStream\n+      ? createFlightDataInjectionTransformStream(inlinedDataStream, true)\n+      : null,\n \n     // Validate the root layout for missing html or body tags\n     validateRootLayout ? createRootLayoutValidatorStream() : null,\n@@ -781,7 +803,9 @@ export async function continueStaticPrerender(\n       // Transform metadata\n       .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n       // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n-      .pipeThrough(createMergedTransformStream(inlinedDataStream))\n+      .pipeThrough(\n+        createFlightDataInjectionTransformStream(inlinedDataStream, true)\n+      )\n       // Close tags should always be deferred to the end\n       .pipeThrough(createMoveSuffixStream())\n   )\n@@ -791,11 +815,13 @@ type ContinueResumeOptions = {\n   inlinedDataStream: ReadableStream<Uint8Array>\n   getServerInsertedHTML: () => Promise<string>\n   getServerInsertedMetadata: () => Promise<string>\n+  delayDataUntilFirstHtmlChunk: boolean\n }\n \n export async function continueDynamicHTMLResume(\n   renderStream: ReadableStream<Uint8Array>,\n   {\n+    delayDataUntilFirstHtmlChunk,\n     inlinedDataStream,\n     getServerInsertedHTML,\n     getServerInsertedMetadata,\n@@ -810,7 +836,12 @@ export async function continueDynamicHTMLResume(\n       // Transform metadata\n       .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n       // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n-      .pipeThrough(createMergedTransformStream(inlinedDataStream))\n+      .pipeThrough(\n+        createFlightDataInjectionTransformStream(\n+          inlinedDataStream,\n+          delayDataUntilFirstHtmlChunk\n+        )\n+      )\n       // Close tags should always be deferred to the end\n       .pipeThrough(createMoveSuffixStream())\n   )"
        },
        {
            "sha": "387b5cb1896e77653bc19c6694f7c8a3e3acbfad",
            "filename": "test/e2e/app-dir/ppr-partial-hydration/app/hydration-indicator.tsx",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fhydration-indicator.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fhydration-indicator.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fhydration-indicator.tsx?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -0,0 +1,15 @@\n+'use client'\n+import { useEffect, useState } from 'react'\n+\n+export function HydrationIndicator({ id }: { id?: string }) {\n+  const [isMounted, setIsMounted] = useState(false)\n+  useEffect(() => {\n+    setIsMounted(true)\n+    return () => setIsMounted(false)\n+  }, [])\n+  return (\n+    <div id={id} data-is-hydrated={isMounted ? 'true' : 'false'}>\n+      {isMounted ? 'ðŸŸ¢ Hydrated' : 'âšª Not hydrated yet'}\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "db0be73f49876d403a0901010e754929e6e91aad",
            "filename": "test/e2e/app-dir/ppr-partial-hydration/app/with-shell/layout.tsx",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwith-shell%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwith-shell%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwith-shell%2Flayout.tsx?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -0,0 +1,11 @@\n+export default function RootLayout({\n+  children,\n+}: Readonly<{\n+  children: React.ReactNode\n+}>) {\n+  return (\n+    <html lang=\"en\">\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "0bfe1329f028fb6b41090c4cf081e5832ded68f1",
            "filename": "test/e2e/app-dir/ppr-partial-hydration/app/with-shell/with-streaming-metadata/page.tsx",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwith-shell%2Fwith-streaming-metadata%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwith-shell%2Fwith-streaming-metadata%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwith-shell%2Fwith-streaming-metadata%2Fpage.tsx?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -0,0 +1,40 @@\n+import { Suspense } from 'react'\n+import { connection } from 'next/server'\n+import { setTimeout } from 'timers/promises'\n+import { HydrationIndicator } from '../../hydration-indicator'\n+import type { Metadata } from 'next'\n+\n+export async function generateMetadata(): Promise<Metadata> {\n+  await connection()\n+  return {\n+    title: 'Resume test',\n+  }\n+}\n+\n+export default function Page() {\n+  return (\n+    <main id=\"shell\">\n+      <h1>This is a page with static shell + streaming metadata</h1>\n+      <div>\n+        <p>Static shell</p>\n+        <HydrationIndicator id=\"shell-hydrated\" />\n+        <hr />\n+        <Suspense fallback={<div id=\"dynamic-fallback\">Loading...</div>}>\n+          <SlowServerComponent delay={500} />\n+        </Suspense>\n+      </div>\n+    </main>\n+  )\n+}\n+\n+async function SlowServerComponent({ delay }: { delay: number }) {\n+  await connection()\n+  await setTimeout(delay)\n+  const randomValue = Math.floor(Math.random() * 1000)\n+  return (\n+    <div id=\"dynamic\">\n+      <div>{`Random value: ${randomValue}`}</div>\n+      <HydrationIndicator id=\"dynamic-hydrated\" />\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "342db4ba8997d52ea4d871c3d2b6c8be11a5b3fa",
            "filename": "test/e2e/app-dir/ppr-partial-hydration/app/with-shell/without-metadata/page.tsx",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwith-shell%2Fwithout-metadata%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwith-shell%2Fwithout-metadata%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwith-shell%2Fwithout-metadata%2Fpage.tsx?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -0,0 +1,32 @@\n+import { Suspense } from 'react'\n+import { connection } from 'next/server'\n+import { setTimeout } from 'timers/promises'\n+import { HydrationIndicator } from '../../hydration-indicator'\n+\n+export default function Page() {\n+  return (\n+    <main id=\"shell\">\n+      <h1>This is a page with static shell + no streaming metadata</h1>\n+      <div>\n+        <p>Static shell</p>\n+        <HydrationIndicator id=\"shell-hydrated\" />\n+        <hr />\n+        <Suspense fallback={<div id=\"dynamic-fallback\">Loading...</div>}>\n+          <SlowServerComponent delay={500} />\n+        </Suspense>\n+      </div>\n+    </main>\n+  )\n+}\n+\n+async function SlowServerComponent({ delay }: { delay: number }) {\n+  await connection()\n+  await setTimeout(delay)\n+  const randomValue = Math.floor(Math.random() * 1000)\n+  return (\n+    <div id=\"dynamic\">\n+      <div>{`Random value: ${randomValue}`}</div>\n+      <HydrationIndicator id=\"dynamic-hydrated\" />\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "61aa13e87286270ffb12444cb8443b5dab31e0ba",
            "filename": "test/e2e/app-dir/ppr-partial-hydration/app/without-shell/layout.tsx",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwithout-shell%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwithout-shell%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwithout-shell%2Flayout.tsx?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -0,0 +1,15 @@\n+import { Suspense } from 'react'\n+\n+export default function RootLayout({\n+  children,\n+}: Readonly<{\n+  children: React.ReactNode\n+}>) {\n+  return (\n+    <Suspense>\n+      <html lang=\"en\">\n+        <body>{children}</body>\n+      </html>\n+    </Suspense>\n+  )\n+}"
        },
        {
            "sha": "c166d32414dba9ad78edc1e279f7ff6194c9900c",
            "filename": "test/e2e/app-dir/ppr-partial-hydration/app/without-shell/with-streaming-metadata/page.tsx",
            "status": "added",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwithout-shell%2Fwith-streaming-metadata%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwithout-shell%2Fwith-streaming-metadata%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwithout-shell%2Fwith-streaming-metadata%2Fpage.tsx?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -0,0 +1,43 @@\n+import { Suspense } from 'react'\n+import { connection } from 'next/server'\n+import { setTimeout } from 'timers/promises'\n+import { HydrationIndicator } from '../../hydration-indicator'\n+import type { Metadata } from 'next'\n+\n+export async function generateMetadata(): Promise<Metadata> {\n+  await connection()\n+  return {\n+    title: 'Resume test',\n+  }\n+}\n+\n+export default async function Page() {\n+  // Trigger the Suspense-around-body in the root layout so that no static shell is produced\n+  await connection()\n+\n+  return (\n+    <main id=\"shell\">\n+      <h1>This is a page with no static shell + with streaming metadata</h1>\n+      <div>\n+        <p>Dynamic shell</p>\n+        <HydrationIndicator id=\"shell-hydrated\" />\n+        <hr />\n+        <Suspense fallback={<div id=\"dynamic-fallback\">Loading...</div>}>\n+          <SlowServerComponent delay={500} />\n+        </Suspense>\n+      </div>\n+    </main>\n+  )\n+}\n+\n+async function SlowServerComponent({ delay }: { delay: number }) {\n+  await connection()\n+  await setTimeout(delay)\n+  const randomValue = Math.floor(Math.random() * 1000)\n+  return (\n+    <div id=\"dynamic\">\n+      <div>{`Random value: ${randomValue}`}</div>\n+      <HydrationIndicator id=\"dynamic-hydrated\" />\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "d15f617b9950a59010cdb4a871bd0f2c0d8e7d21",
            "filename": "test/e2e/app-dir/ppr-partial-hydration/app/without-shell/without-metadata/page.tsx",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwithout-shell%2Fwithout-metadata%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwithout-shell%2Fwithout-metadata%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fapp%2Fwithout-shell%2Fwithout-metadata%2Fpage.tsx?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -0,0 +1,35 @@\n+import { Suspense } from 'react'\n+import { connection } from 'next/server'\n+import { setTimeout } from 'timers/promises'\n+import { HydrationIndicator } from '../../hydration-indicator'\n+\n+export default async function Page() {\n+  // Trigger the Suspense-around-body in the root layout so that no static shell is produced\n+  await connection()\n+\n+  return (\n+    <main id=\"shell\">\n+      <h1>This is a page with no static shell + no streaming metadata</h1>\n+      <div>\n+        <p>Dynamic shell</p>\n+        <HydrationIndicator id=\"shell-hydrated\" />\n+        <hr />\n+        <Suspense fallback={<div id=\"dynamic-fallback\">Loading...</div>}>\n+          <SlowServerComponent delay={500} />\n+        </Suspense>\n+      </div>\n+    </main>\n+  )\n+}\n+\n+async function SlowServerComponent({ delay }: { delay: number }) {\n+  await connection()\n+  await setTimeout(delay)\n+  const randomValue = Math.floor(Math.random() * 1000)\n+  return (\n+    <div id=\"dynamic\">\n+      <div>{`Random value: ${randomValue}`}</div>\n+      <HydrationIndicator id=\"dynamic-hydrated\" />\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "1f6180914624ce06f623e2e1bfae09845d254abb",
            "filename": "test/e2e/app-dir/ppr-partial-hydration/next.config.ts",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fnext.config.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fnext.config.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fnext.config.ts?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -0,0 +1,11 @@\n+import type { NextConfig } from 'next'\n+\n+const nextConfig: NextConfig = {\n+  experimental: {\n+    ppr: true,\n+    // until the flags are merged, test both `ppr` and `cacheComponents`\n+    // cacheComponents: true,\n+  },\n+}\n+\n+export default nextConfig"
        },
        {
            "sha": "333dbffb2e1d23045a09c7e8e11692e5cfef4be4",
            "filename": "test/e2e/app-dir/ppr-partial-hydration/ppr-partial-hydration.test.ts",
            "status": "added",
            "additions": 139,
            "deletions": 0,
            "changes": 139,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fppr-partial-hydration.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fppr-partial-hydration.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fppr-partial-hydration%2Fppr-partial-hydration.test.ts?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -0,0 +1,139 @@\n+// CASES:\n+// shell + no metadata\n+// shell + streaming metadata\n+// no shell + no metadata\n+// no shell + streaming metadata\n+\n+import { nextTestSetup } from '../../../lib/e2e-utils'\n+import { retry } from '../../../lib/next-test-utils'\n+\n+describe('PPR - partial hydration', () => {\n+  const { next, isNextDev } = nextTestSetup({ files: __dirname })\n+  if (isNextDev) {\n+    it.skip('only testable in production', () => {})\n+    return\n+  }\n+\n+  describe.each([\n+    {\n+      description: 'Static shell, no streaming metadata',\n+      path: '/with-shell/without-metadata',\n+    },\n+    {\n+      // Streaming metadata shouldn't affect streaming order, because if we have a static shell,\n+      // then RSC scripts (and thus hydration) don't need to wait for any HTML to be rendered.\n+      // I'm including it here for completeness.\n+      description: 'Static shell, streaming metadata',\n+      path: '/with-shell/with-streaming-metadata',\n+    },\n+    {\n+      description: 'No static shell, no streaming metadata',\n+      path: '/without-shell/without-metadata',\n+    },\n+    {\n+      // Streaming metadata is relevant, because it can affect how the HTML and RSC streams are interleaved.\n+      // If we have no static shell, RSC script tags won't be sent until the first SSR HTML chunk is sent.\n+      // Streaming metadata results in a HTML chunk, and thus it can affect this.\n+      description: 'No static shell, streaming metadata',\n+      path: '/without-shell/with-streaming-metadata',\n+    },\n+  ])('$description', ({ path }) => {\n+    it('should hydrate the shell without waiting for slow suspense boundaries', async () => {\n+      const browser = await next.browser(path, {\n+        waitHydration: false,\n+        waitUntil: 'commit', // do not wait for \"load\", we want to inspect the page as it streams in\n+      })\n+\n+      // Initially, only the shell should be visible\n+      await retry(\n+        async () => {\n+          // The shell should be hydrated as soon as possible,\n+          // without waiting for the dynamic content\n+          expect(\n+            await browser\n+              .elementByCssInstant('#shell-hydrated', { state: 'visible' })\n+              .getAttribute('data-is-hydrated')\n+          ).toBe('true')\n+\n+          // The dynamic content hasn't streamed in yet, we should only see the fallback\n+          expect(await browser.elementsByCss('main #dynamic')).toHaveLength(0)\n+          expect(\n+            await browser\n+              .elementByCssInstant('#dynamic-fallback', { state: 'visible' })\n+              .text()\n+          ).toContain('Loading...')\n+        },\n+        1000,\n+        50\n+      )\n+\n+      // Then, the slow content should stream in and hydrate\n+      await retry(async () => {\n+        // The shell is already hydrated, this shouldn't change\n+        expect(\n+          await browser\n+            .elementByCssInstant('#shell-hydrated', { state: 'visible' })\n+            .getAttribute('data-is-hydrated')\n+        ).toBe('true')\n+\n+        // The dynamic content should be visible and hydrated\n+        expect(\n+          await browser\n+            .elementByCssInstant('#dynamic', { state: 'visible' })\n+            .text()\n+        ).toMatch(/Random value: \\d+/)\n+        expect(\n+          await browser\n+            .elementByCssInstant('#dynamic-hydrated', { state: 'visible' })\n+            .getAttribute('data-is-hydrated')\n+        ).toBe('true')\n+      })\n+\n+      // If the HTML and RSC streams were interleaved correctly, we shouldn't be in quirks mode\n+      // (we would be happen if an RSC script was sent before `<!DOCTYPE html>`)\n+      expect(await browser.eval(() => document.compatMode)).not.toBe(\n+        'BackCompat'\n+      )\n+    })\n+\n+    it('should produce a valid HTML document', async () => {\n+      // This test is meant to check if we're interleaving the HTML and RSC streams correctly.\n+      // In particular, RSC script tags should never appear before the initial HTML\n+      // (which could happen if we e.g. have no static shell and don't wait for it to be rendered before sending them)\n+      const response = await next.fetch(path)\n+      expect(response.status).toBe(200)\n+      const text = await response\n+        .text()\n+        // Ignore the sentinel. For pages with no static shell, it ends up at the front\n+        // and messes up the assertion.\n+        .then((s) => s.replace('<!-- PPR_BOUNDARY_SENTINEL -->', ''))\n+\n+      expect(text).toStartWith('<!DOCTYPE html>')\n+      expect(text).toEndWith('</body></html>')\n+    })\n+\n+    it('should display the shell without JS', async () => {\n+      const browser = await next.browser(path, {\n+        disableJavaScript: true,\n+        waitUntil: 'load', // Unlike the previous test, we want the page to load fully\n+      })\n+      expect(await browser.elementByCss('#shell').text()).toContain(\n+        'This is a page'\n+      )\n+      expect(\n+        await browser\n+          .elementByCss('#shell-hydrated', { state: 'visible' })\n+          .getAttribute('data-is-hydrated')\n+      ).toBe('false')\n+\n+      // The dynamic content can't be inserted into the document because we disabled JS,\n+      // so we should only see the fallback\n+      expect(await browser.elementsByCss('main #dynamic')).toHaveLength(0)\n+      expect(\n+        await browser\n+          .elementByCss('#dynamic-fallback', { state: 'visible' })\n+          .text()\n+      ).toContain('Loading...')\n+    })\n+  })\n+})"
        },
        {
            "sha": "7b1cd585cb6de0ed5db826cbc85d37faddcec6c6",
            "filename": "test/lib/browsers/playwright.ts",
            "status": "modified",
            "additions": 49,
            "deletions": 9,
            "changes": 58,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/test%2Flib%2Fbrowsers%2Fplaywright.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/test%2Flib%2Fbrowsers%2Fplaywright.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Flib%2Fbrowsers%2Fplaywright.ts?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -57,6 +57,20 @@ interface ElementHandleExt extends ElementHandle {\n   text(): Promise<string>\n }\n \n+export type ElementByCssOpts = {\n+  timeout?: number\n+  /** The state of the DOM element. */\n+  state?: 'attached' | 'visible' | 'hidden'\n+  /** The state of the page. */\n+  waitUntil?: false | 'load' | 'domcontentloaded' | 'networkidle'\n+}\n+\n+export type PlaywrightNavigationWaitUntil =\n+  | 'load'\n+  | 'domcontentloaded'\n+  | 'networkidle'\n+  | 'commit'\n+\n export class Playwright<TCurrent = undefined> {\n   private activeTrace?: string\n   private eventCallbacks: Record<EventType, Set<(...args: any[]) => void>> = {\n@@ -229,6 +243,7 @@ export class Playwright<TCurrent = undefined> {\n       cpuThrottleRate?: number\n       pushErrorAsConsoleLog?: boolean\n       beforePageLoad?: (page: Page) => void | Promise<void>\n+      waitUntil?: PlaywrightNavigationWaitUntil\n     }\n   ) {\n     await this.close()\n@@ -312,7 +327,7 @@ export class Playwright<TCurrent = undefined> {\n \n     await opts?.beforePageLoad?.(page)\n \n-    await page.goto(url, { waitUntil: 'load' })\n+    await page.goto(url, { waitUntil: opts?.waitUntil ?? 'load' })\n   }\n \n   back(options?: Parameters<Page['goBack']>[0]) {\n@@ -371,8 +386,20 @@ export class Playwright<TCurrent = undefined> {\n     })\n   }\n \n-  elementByCss(selector: string) {\n-    return this.waitForElementByCss(selector, 5_000)\n+  elementByCss(selector: string, opts?: ElementByCssOpts) {\n+    return this.waitForElementByCss(selector, {\n+      timeout: 5_000,\n+      ...opts,\n+    })\n+  }\n+\n+  /** A replacement for the default `browser.elementByCss` that doesn't wait for the page to fire \"load\". */\n+  elementByCssInstant(selector: string, opts?: ElementByCssOpts) {\n+    return this.waitForElementByCss(selector, {\n+      timeout: 10,\n+      waitUntil: false,\n+      ...opts,\n+    })\n   }\n \n   hasElementByCss(selector: string) {\n@@ -455,16 +482,29 @@ export class Playwright<TCurrent = undefined> {\n     )\n   }\n \n-  waitForElementByCss(selector: string, timeout = 10_000) {\n+  waitForElementByCss(selector: string, opts: number | ElementByCssOpts = {}) {\n+    const {\n+      timeout = 10_000,\n+      waitUntil = 'load', // TODO: we should get rid of this and fix the tests that implicitly rely on it\n+      state = 'attached', // TODO: we should probably default to \"visible\" instead\n+    } = typeof opts === 'number' ? { timeout: opts } : opts\n+\n     return this.startChain(async () => {\n       const el = await page.waitForSelector(selector, {\n         timeout,\n-        state: 'attached',\n+        state,\n       })\n-      // it seems selenium waits longer and tests rely on this behavior\n-      // so we wait for the load event fire before returning\n-      await page.waitForLoadState()\n-      return this.wrapElement(el, selector)\n+      if (waitUntil !== false) {\n+        // it seems selenium waits longer and tests rely on this behavior\n+        // so we wait for the load event fire before returning\n+        await page.waitForLoadState(waitUntil)\n+      }\n+      return this.wrapElement(\n+        // Playwright has `null` as a possible return type in case `state` is `detached`,\n+        // but we don't allow passing that here, so we can assume it's non-null\n+        el!,\n+        selector\n+      )\n     })\n   }\n "
        },
        {
            "sha": "8214ddd6cee28efbcb3596e9032f5618947ed21b",
            "filename": "test/lib/next-webdriver.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 3,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/523ae09b0b684f4795f231feae49f90df9844d97/test%2Flib%2Fnext-webdriver.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/523ae09b0b684f4795f231feae49f90df9844d97/test%2Flib%2Fnext-webdriver.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Flib%2Fnext-webdriver.ts?ref=523ae09b0b684f4795f231feae49f90df9844d97",
            "patch": "@@ -1,6 +1,9 @@\n import { getFullUrl, waitFor } from 'next-test-utils'\n import os from 'os'\n-import { Playwright } from './browsers/playwright'\n+import {\n+  Playwright,\n+  PlaywrightNavigationWaitUntil,\n+} from './browsers/playwright'\n import { Page } from 'playwright'\n \n export type { Playwright }\n@@ -53,6 +56,10 @@ export interface WebdriverOptions {\n    * allow retrying hydration wait if reload occurs\n    */\n   retryWaitHydration?: boolean\n+  /**\n+   * The browser event to wait for during the initial page load. Passed through to `browser.loadPage`\n+   * */\n+  waitUntil?: PlaywrightNavigationWaitUntil\n   /**\n    * disable cache for page load\n    */\n@@ -114,6 +121,7 @@ export default async function webdriver(\n     cpuThrottleRate,\n     pushErrorAsConsoleLog,\n     userAgent,\n+    waitUntil,\n   } = options\n \n   const { Playwright, quit } = await import('./browsers/playwright')\n@@ -145,13 +153,14 @@ export default async function webdriver(\n     cpuThrottleRate,\n     beforePageLoad,\n     pushErrorAsConsoleLog,\n+    waitUntil,\n   })\n   console.log(`\\n> Loaded browser with ${fullUrl}\\n`)\n \n   browserTeardown.push(browser.close.bind(browser))\n \n   // Wait for application to hydrate\n-  if (waitHydration) {\n+  if (!disableJavaScript && waitHydration) {\n     console.log(`\\n> Waiting hydration for ${fullUrl}\\n`)\n \n     const checkHydrated = async () => {\n@@ -204,7 +213,9 @@ export default async function webdriver(\n   // This is a temporary workaround for turbopack starting watching too late.\n   // So we delay file changes to give it some time\n   // to connect the WebSocket and start watching.\n-  if (process.env.IS_TURBOPACK_TEST) {\n+  // TODO: Is this still needed? Can we wait in a more useful way, like a socket connection event?\n+  if (process.env.IS_TURBOPACK_TEST && process.env.TURBOPACK_DEV) {\n+    console.log(`\\n> Waiting for for turbopack watcher to start`)\n     await waitFor(1000)\n   }\n   return browser"
        }
    ],
    "stats": {
        "total": 613,
        "additions": 535,
        "deletions": 78
    }
}