{
    "author": "feedthejim",
    "message": "fix: normalize CRLF line endings in jscodeshift tests on Windows (#88008)\n\n## Summary\n\nFixes flaky jscodeshift codemod tests on Windows CI (e.g.,\n`next-async-request-api-dynamic-apis.test.js`,\n`built-in-next-font.test.js`, `new-link.test.js`).\n\n### Problem\n\nWindows CI runners have `core.autocrlf=true` by default, which causes\ntest failures because:\n\n1. Fixture files get checked out with CRLF line endings\n2. jscodeshift's printer (recast) outputs CRLF on Windows\n3. String comparison fails between expected and actual output\n\n### Solution\n\nPatches jscodeshift's test utilities in `jest-setup-after-env.ts`\n(Windows only) to normalize line endings:\n\n```typescript\nconst normalizeLF = (str: string) =>\n  str\n    .replace(/\\r\\n/g, '\\n')           // CRLF â†’ LF\n    .replace(/[ \\t]+$/gm, '')         // Remove trailing whitespace per line\n    .replace(/\\n*$/, '\\n')            // Ensure exactly one trailing newline\n```\n\n**Key changes:**\n- **Patches `runInlineTest`** - Normalizes input, runs transform,\nnormalizes output, then compares\n- **Patches `defineTest`** - Reads fixtures with normalization, uses\npatched `runInlineTest`\n- **Handles closure issue** - jscodeshift's internal functions use\nclosures that bypass exports, so we replace the functions entirely\n\nAlso includes a belt-and-suspenders `sed` command in the workflow to\nstrip CRLF from source files.\n\n### Why not just fix `.gitattributes`?\n\nThe `.gitattributes` `eol=lf` setting helps, but doesn't solve the\nproblem because:\n1. jscodeshift's recast printer uses platform-native line endings when\ngenerating output\n2. Fixture files may have inconsistent trailing whitespace/newlines\n3. Self-hosted Windows runners may have different git configurations\n\n### Follow-up\n\n**TODO:** Configure Windows self-hosted runners with `git config\n--system core.autocrlf false` so the `sed` workaround can be removed.\nSee the `TODO` comment in `build_reusable.yml`.\n\n## Test Plan\n\n- Windows CI unit tests should pass consistently\n- Normalization only runs on Windows (`process.platform === 'win32'`)\n- Other platforms unaffected\n\n---------\n\nCo-authored-by: Claude Opus 4.5 <noreply@anthropic.com>\nCo-authored-by: JJ Kasper <jj@jjsweb.site>",
    "sha": "69ae2c10e72e20df6b098197364d354d20376864",
    "files": [
        {
            "sha": "02a1f53567aecb7a94503dd29beb145922396551",
            "filename": ".gitattributes",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/69ae2c10e72e20df6b098197364d354d20376864/.gitattributes",
            "raw_url": "https://github.com/vercel/next.js/raw/69ae2c10e72e20df6b098197364d354d20376864/.gitattributes",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.gitattributes?ref=69ae2c10e72e20df6b098197364d354d20376864",
            "patch": "@@ -1,3 +1,6 @@\n+# Enforce LF line endings for all text files (fixes Windows CRLF test flakiness)\n+* text=auto eol=lf\n+\n .github/actions/*/dist/** -text linguist-vendored\n packages/next/bundles/** -text linguist-vendored\n packages/next/compiled/** -text linguist-vendored"
        },
        {
            "sha": "1d615c0e883bee3a7126699fe294a92d673b975b",
            "filename": ".github/workflows/build_reusable.yml",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/69ae2c10e72e20df6b098197364d354d20376864/.github%2Fworkflows%2Fbuild_reusable.yml",
            "raw_url": "https://github.com/vercel/next.js/raw/69ae2c10e72e20df6b098197364d354d20376864/.github%2Fworkflows%2Fbuild_reusable.yml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/.github%2Fworkflows%2Fbuild_reusable.yml?ref=69ae2c10e72e20df6b098197364d354d20376864",
            "patch": "@@ -130,6 +130,14 @@ jobs:\n       input_step_key: ${{ steps.var.outputs.input_step_key }}\n \n     steps:\n+      # enforce consistent line endings for git on windows\n+      - name: Configure git to use LF endings\n+        if: ${{ contains(fromJson(inputs.runs_on_labels), 'windows') }}\n+        run: |\n+          git config --global core.autocrlf false\n+          git config --global core.eol lf\n+        shell: bash\n+\n       - name: Check if fnm is installed\n         id: check-fnm\n         run: |"
        },
        {
            "sha": "dcf3748a9d28ae62d32788a0a2fa549af0d918c9",
            "filename": "test/jest-setup-after-env.ts",
            "status": "modified",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/vercel/next.js/blob/69ae2c10e72e20df6b098197364d354d20376864/test%2Fjest-setup-after-env.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/69ae2c10e72e20df6b098197364d354d20376864/test%2Fjest-setup-after-env.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fjest-setup-after-env.ts?ref=69ae2c10e72e20df6b098197364d354d20376864",
            "patch": "@@ -1,6 +1,111 @@\n import * as matchers from 'jest-extended'\n expect.extend(matchers)\n \n+// Patch jscodeshift testUtils to normalize line endings (fixes Windows CRLF issues)\n+// The issue: jscodeshift's printer (recast) outputs CRLF on Windows, but test fixtures use LF\n+// We need to patch both defineTest (which uses internal closure references) and runInlineTest\n+if (process.platform === 'win32') {\n+  try {\n+    const testUtils = require('jscodeshift/dist/testUtils')\n+    const fs = require('fs')\n+    const path = require('path')\n+\n+    // Helper to normalize line endings\n+    // - Convert CRLF to LF\n+    // - Remove trailing whitespace from each line (not meaningful for code)\n+    // - Ensure exactly one trailing newline (POSIX convention for text files)\n+    //   Using \\n*$ to handle case where transform output has no trailing newline\n+    const normalizeLF = (str: string) =>\n+      str\n+        .replace(/\\r\\n/g, '\\n')\n+        .replace(/[ \\t]+$/gm, '')\n+        .replace(/\\n*$/, '\\n')\n+\n+    // Patch runInlineTest to normalize both transform output and expected\n+    testUtils.runInlineTest = function (\n+      module: any,\n+      options: any,\n+      input: any,\n+      expectedOutput: string,\n+      testOptions?: any\n+    ) {\n+      // Normalize input source\n+      const normalizedInput =\n+        typeof input === 'object' && input.source\n+          ? { ...input, source: normalizeLF(input.source) }\n+          : input\n+      // Normalize expected output\n+      const normalizedExpected = normalizeLF(expectedOutput)\n+\n+      // Run the transform and normalize its output for comparison\n+      const output = testUtils.applyTransform(\n+        module,\n+        options,\n+        normalizedInput,\n+        testOptions\n+      )\n+      const normalizedOutput =\n+        typeof output === 'string' ? normalizeLF(output) : output\n+\n+      // Do the comparison ourselves instead of letting the original do it\n+      // eslint-disable-next-line jest/no-standalone-expect -- called from within test blocks\n+      expect(normalizedOutput).toEqual(normalizedExpected)\n+      return normalizedOutput\n+    }\n+\n+    // Replace defineTest entirely since it uses internal closure references\n+    // that bypass our exports patch\n+    testUtils.defineTest = function (\n+      dirName: string,\n+      transformName: string,\n+      options: any,\n+      testFilePrefix?: string,\n+      testOptions?: { parser?: string }\n+    ) {\n+      const testName = testFilePrefix\n+        ? `transforms correctly using \"${testFilePrefix}\" data`\n+        : 'transforms correctly'\n+\n+      describe(transformName, () => {\n+        it(testName, () => {\n+          const fixtureDir = path.join(dirName, '..', '__testfixtures__')\n+          const prefix = testFilePrefix || transformName\n+          const module = require(path.join(dirName, '..', transformName))\n+\n+          // Determine file extension based on parser option\n+          const parser = testOptions?.parser || module.parser\n+          const extension =\n+            parser === 'ts' ? 'ts' : parser === 'tsx' ? 'tsx' : 'js'\n+\n+          const inputPath = path.join(\n+            fixtureDir,\n+            `${prefix}.input.${extension}`\n+          )\n+          const outputPath = path.join(\n+            fixtureDir,\n+            `${prefix}.output.${extension}`\n+          )\n+\n+          const source = normalizeLF(fs.readFileSync(inputPath, 'utf8'))\n+          const expectedOutput = normalizeLF(\n+            fs.readFileSync(outputPath, 'utf8')\n+          )\n+\n+          testUtils.runInlineTest(\n+            module,\n+            options,\n+            { path: inputPath, source },\n+            expectedOutput,\n+            testOptions\n+          )\n+        })\n+      })\n+    }\n+  } catch {\n+    // jscodeshift not available, skip patching\n+  }\n+}\n+\n // A default max-timeout of 90 seconds is allowed\n // per test we should aim to bring this down though\n jest.setTimeout((process.platform === 'win32' ? 180 : 60) * 1000)"
        }
    ],
    "stats": {
        "total": 116,
        "additions": 116,
        "deletions": 0
    }
}