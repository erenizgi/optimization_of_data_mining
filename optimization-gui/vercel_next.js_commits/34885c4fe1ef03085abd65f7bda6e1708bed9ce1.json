{
    "author": "huozhi",
    "message": "Revert \"Turbopack: layout segment optimization for Pages\" (#77339)\n\nReverts vercel/next.js#74815\n \n`test/integration/app-document/test/index.test.js` starts failing since\n#74815\n\nx-ref:\nhttps://github.com/vercel/next.js/actions/runs/13972070006/job/39119143367?pr=77335",
    "sha": "34885c4fe1ef03085abd65f7bda6e1708bed9ce1",
    "files": [
        {
            "sha": "ea10b60bf2f1b6254891f6db8d7722a52f7b6adc",
            "filename": "crates/next-api/src/pages.rs",
            "status": "modified",
            "additions": 45,
            "deletions": 144,
            "changes": 189,
            "blob_url": "https://github.com/vercel/next.js/blob/34885c4fe1ef03085abd65f7bda6e1708bed9ce1/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/34885c4fe1ef03085abd65f7bda6e1708bed9ce1/crates%2Fnext-api%2Fsrc%2Fpages.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fpages.rs?ref=34885c4fe1ef03085abd65f7bda6e1708bed9ce1",
            "patch": "@@ -31,7 +31,7 @@ use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n     fxindexmap, trace::TraceRawVcs, Completion, FxIndexMap, NonLocalValue, ResolvedVc, TaskInput,\n-    Value, ValueToString, Vc,\n+    Value, Vc,\n };\n use turbo_tasks_fs::{\n     self, File, FileContent, FileSystem, FileSystemPath, FileSystemPathOption, VirtualFileSystem,\n@@ -46,15 +46,15 @@ use turbopack_core::{\n     asset::AssetContent,\n     chunk::{\n         availability_info::AvailabilityInfo, ChunkGroupResult, ChunkingContext, ChunkingContextExt,\n-        EvaluatableAsset, EvaluatableAssets,\n+        EntryChunkGroupResult, EvaluatableAsset, EvaluatableAssets,\n     },\n     context::AssetContext,\n     file_source::FileSource,\n     ident::AssetIdent,\n     module::Module,\n     module_graph::{\n         chunk_group_info::{ChunkGroup, ChunkGroupEntry},\n-        GraphEntries, ModuleGraph, SingleModuleGraph, VisitedModules,\n+        GraphEntries, ModuleGraph,\n     },\n     output::{OptionOutputAsset, OutputAsset, OutputAssets},\n     reference_type::{EcmaScriptModulesReferenceSubType, EntryReferenceSubType, ReferenceType},\n@@ -772,45 +772,7 @@ impl PageEndpoint {\n         let this = self.await?;\n         let project = this.pages_project.project();\n         let evaluatable_assets = self.client_evaluatable_assets();\n-        Ok(project.module_graph_for_modules(evaluatable_assets))\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn ssr_module_graph(self: Vc<Self>) -> Result<Vc<ModuleGraph>> {\n-        let this = self.await?;\n-        let project = this.pages_project.project();\n-\n-        if *project.per_page_module_graph().await? {\n-            let ssr_chunk_module = self.internal_ssr_chunk_module().await?;\n-            // Implements layout segment optimization to compute a graph \"chain\" for document, app,\n-            // page\n-            let mut graphs = vec![];\n-            let mut visited_modules = VisitedModules::empty();\n-            for module in [\n-                ssr_chunk_module.document_module,\n-                ssr_chunk_module.app_module,\n-            ]\n-            .into_iter()\n-            .flatten()\n-            {\n-                let graph = SingleModuleGraph::new_with_entries_visited_intern(\n-                    vec![ChunkGroupEntry::Shared(module)],\n-                    visited_modules,\n-                );\n-                graphs.push(graph);\n-                visited_modules = visited_modules.concatenate(graph);\n-            }\n-\n-            let graph = SingleModuleGraph::new_with_entries_visited_intern(\n-                vec![ChunkGroupEntry::Entry(vec![ssr_chunk_module.ssr_module])],\n-                visited_modules,\n-            );\n-            graphs.push(graph);\n-\n-            Ok(ModuleGraph::from_graphs(graphs))\n-        } else {\n-            Ok(*project.whole_app_module_graphs().await?.full)\n-        }\n+        Ok(project.module_graph_for_entries(evaluatable_assets))\n     }\n \n     #[turbo_tasks::function]\n@@ -890,8 +852,10 @@ impl PageEndpoint {\n             .module();\n \n         let config = parse_config_from_source(ssr_module, NextRuntime::default()).await?;\n-        Ok(if config.runtime == NextRuntime::Edge {\n-            let modules = create_page_ssr_entry_module(\n+        let is_edge = matches!(config.runtime, NextRuntime::Edge);\n+\n+        let ssr_module = if is_edge {\n+            create_page_ssr_entry_module(\n                 *this.pathname,\n                 reference_type,\n                 project_root,\n@@ -902,28 +866,15 @@ impl PageEndpoint {\n                 config.runtime,\n                 this.pages_project.project().next_config(),\n             )\n-            .await?;\n-\n-            InternalSsrChunkModule {\n-                ssr_module: modules.ssr_module,\n-                app_module: modules.app_module,\n-                document_module: modules.document_module,\n-                runtime: config.runtime,\n-            }\n         } else {\n             let pathname = &**this.pathname.await?;\n \n             // `/_app` and `/_document` never get rendered directly so they don't need to be\n             // wrapped in the route module.\n             if pathname == \"/_app\" || pathname == \"/_document\" {\n-                InternalSsrChunkModule {\n-                    ssr_module: ssr_module.to_resolved().await?,\n-                    app_module: None,\n-                    document_module: None,\n-                    runtime: config.runtime,\n-                }\n+                ssr_module\n             } else {\n-                let modules = create_page_ssr_entry_module(\n+                create_page_ssr_entry_module(\n                     *this.pathname,\n                     reference_type,\n                     project_root,\n@@ -934,14 +885,12 @@ impl PageEndpoint {\n                     config.runtime,\n                     this.pages_project.project().next_config(),\n                 )\n-                .await?;\n-                InternalSsrChunkModule {\n-                    ssr_module: modules.ssr_module,\n-                    app_module: modules.app_module,\n-                    document_module: modules.document_module,\n-                    runtime: config.runtime,\n-                }\n             }\n+        };\n+\n+        Ok(InternalSsrChunkModule {\n+            ssr_module: ssr_module.to_resolved().await?,\n+            runtime: config.runtime,\n         }\n         .cell())\n     }\n@@ -951,7 +900,7 @@ impl PageEndpoint {\n         self: Vc<Self>,\n         ty: SsrChunkType,\n         node_path: Vc<FileSystemPath>,\n-        node_chunking_context: Vc<NodeJsChunkingContext>,\n+        chunking_context: Vc<NodeJsChunkingContext>,\n         edge_chunking_context: Vc<Box<dyn ChunkingContext>>,\n         runtime_entries: Vc<EvaluatableAssets>,\n         edge_runtime_entries: Vc<EvaluatableAssets>,\n@@ -961,16 +910,14 @@ impl PageEndpoint {\n \n             let InternalSsrChunkModule {\n                 ssr_module,\n-                app_module,\n-                document_module,\n                 runtime,\n             } = *self.internal_ssr_chunk_module().await?;\n \n             let project = this.pages_project.project();\n             // The SSR and Client Graphs are not connected in Pages Router.\n             // We are only interested in get_next_dynamic_imports_for_endpoint at the\n             // moment, which only needs the client graph anyway.\n-            let ssr_module_graph = self.ssr_module_graph();\n+            let module_graph = project.module_graph(*ssr_module);\n \n             let next_dynamic_imports = if let PageEndpointType::Html = this.ty {\n                 let client_availability_info = self.client_chunks().await?.availability_info;\n@@ -1005,40 +952,6 @@ impl PageEndpoint {\n                 DynamicImportedChunks::default().resolved_cell()\n             };\n \n-            let chunking_context: Vc<Box<dyn ChunkingContext>> = match runtime {\n-                NextRuntime::NodeJs => Vc::upcast(node_chunking_context),\n-                NextRuntime::Edge => Vc::upcast(edge_chunking_context),\n-            };\n-\n-            let mut current_chunks = OutputAssets::empty();\n-            let mut current_availability_info = AvailabilityInfo::Root;\n-            for layout in [document_module, app_module].iter().flatten().copied() {\n-                let span = tracing::trace_span!(\n-                    \"layout segment\",\n-                    name = display(layout.ident().to_string().await?)\n-                );\n-                async {\n-                    let chunk_group = chunking_context\n-                        .chunk_group(\n-                            layout.ident(),\n-                            ChunkGroup::Shared(layout),\n-                            ssr_module_graph,\n-                            Value::new(current_availability_info),\n-                        )\n-                        .await?;\n-\n-                    current_chunks = current_chunks\n-                        .concatenate(*chunk_group.assets)\n-                        .resolve()\n-                        .await?;\n-                    current_availability_info = chunk_group.availability_info;\n-\n-                    anyhow::Ok(())\n-                }\n-                .instrument(span)\n-                .await?;\n-            }\n-\n             let ssr_module_evaluatable = ResolvedVc::try_sidecast(ssr_module)\n                 .context(\"could not process page loader entry module\")?;\n             let is_edge = matches!(runtime, NextRuntime::Edge);\n@@ -1049,15 +962,18 @@ impl PageEndpoint {\n                     .map(|m| ResolvedVc::upcast(*m))\n                     .chain(std::iter::once(ResolvedVc::upcast(ssr_module_evaluatable)));\n \n-                let edge_files = edge_chunking_context.evaluated_chunk_group_assets(\n-                    ssr_module.ident(),\n-                    ChunkGroup::Entry(evaluatable_assets.collect()),\n-                    ssr_module_graph,\n-                    Value::new(current_availability_info),\n-                );\n+                let edge_files = edge_chunking_context\n+                    .evaluated_chunk_group_assets(\n+                        ssr_module.ident(),\n+                        ChunkGroup::Entry(evaluatable_assets.collect()),\n+                        module_graph,\n+                        Value::new(AvailabilityInfo::Root),\n+                    )\n+                    .to_resolved()\n+                    .await?;\n \n                 Ok(SsrChunk::Edge {\n-                    files: current_chunks.concatenate(edge_files).to_resolved().await?,\n+                    files: edge_files,\n                     dynamic_import_entries,\n                 }\n                 .cell())\n@@ -1068,15 +984,17 @@ impl PageEndpoint {\n \n                 let ssr_entry_chunk_path_string: RcStr = format!(\"pages{asset_path}\").into();\n                 let ssr_entry_chunk_path = node_path.join(ssr_entry_chunk_path_string);\n-                let ssr_entry_chunk = node_chunking_context\n-                    .entry_chunk_group_asset(\n+                let EntryChunkGroupResult {\n+                    asset: ssr_entry_chunk,\n+                    ..\n+                } = *chunking_context\n+                    .entry_chunk_group(\n                         ssr_entry_chunk_path,\n                         runtime_entries.with_entry(*ssr_module_evaluatable),\n-                        ssr_module_graph,\n-                        current_chunks,\n-                        Value::new(current_availability_info),\n+                        module_graph,\n+                        OutputAssets::empty(),\n+                        Value::new(AvailabilityInfo::Root),\n                     )\n-                    .to_resolved()\n                     .await?;\n \n                 let server_asset_trace_file = if this\n@@ -1446,8 +1364,6 @@ impl PageEndpoint {\n #[turbo_tasks::value]\n pub struct InternalSsrChunkModule {\n     pub ssr_module: ResolvedVc<Box<dyn Module>>,\n-    pub app_module: Option<ResolvedVc<Box<dyn Module>>>,\n-    pub document_module: Option<ResolvedVc<Box<dyn Module>>>,\n     pub runtime: NextRuntime,\n }\n \n@@ -1551,32 +1467,17 @@ impl Endpoint for PageEndpoint {\n         let this = self.await?;\n \n         let ssr_chunk_module = self.internal_ssr_chunk_module().await?;\n+        let mut modules = vec![ChunkGroupEntry::Entry(vec![ssr_chunk_module.ssr_module])];\n \n-        let shared_entries = [\n-            ssr_chunk_module.document_module,\n-            ssr_chunk_module.app_module,\n-        ];\n-\n-        let modules = shared_entries\n-            .into_iter()\n-            .flatten()\n-            .map(ChunkGroupEntry::Shared)\n-            .chain(std::iter::once(ChunkGroupEntry::Entry(vec![\n-                ssr_chunk_module.ssr_module,\n-            ])))\n-            .chain(if this.ty == PageEndpointType::Html {\n-                Some(ChunkGroupEntry::Entry(\n-                    self.client_evaluatable_assets()\n-                        .await?\n-                        .iter()\n-                        .map(|m| ResolvedVc::upcast(*m))\n-                        .collect(),\n-                ))\n-                .into_iter()\n-            } else {\n-                None.into_iter()\n-            })\n-            .collect::<Vec<_>>();\n+        if let PageEndpointType::Html = this.ty {\n+            modules.push(ChunkGroupEntry::Entry(\n+                self.client_evaluatable_assets()\n+                    .await?\n+                    .iter()\n+                    .map(|m| ResolvedVc::upcast(*m))\n+                    .collect(),\n+            ));\n+        }\n \n         Ok(Vc::cell(modules))\n     }"
        },
        {
            "sha": "ecda6ea683b2c3766d2ec1cc86f30f800b417359",
            "filename": "crates/next-api/src/project.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 13,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/34885c4fe1ef03085abd65f7bda6e1708bed9ce1/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/34885c4fe1ef03085abd65f7bda6e1708bed9ce1/crates%2Fnext-api%2Fsrc%2Fproject.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fproject.rs?ref=34885c4fe1ef03085abd65f7bda6e1708bed9ce1",
            "patch": "@@ -895,7 +895,7 @@ impl Project {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn module_graph_for_modules(\n+    pub async fn module_graph_for_entries(\n         self: Vc<Self>,\n         evaluatable_assets: Vc<EvaluatableAssets>,\n     ) -> Result<Vc<ModuleGraph>> {\n@@ -912,18 +912,6 @@ impl Project {\n         })\n     }\n \n-    #[turbo_tasks::function]\n-    pub async fn module_graph_for_entries(\n-        self: Vc<Self>,\n-        entries: Vc<GraphEntries>,\n-    ) -> Result<Vc<ModuleGraph>> {\n-        Ok(if *self.per_page_module_graph().await? {\n-            ModuleGraph::from_modules(entries)\n-        } else {\n-            *self.whole_app_module_graphs().await?.full\n-        })\n-    }\n-\n     #[turbo_tasks::function]\n     pub async fn whole_app_module_graphs(self: ResolvedVc<Self>) -> Result<Vc<ModuleGraphs>> {\n         async move {"
        },
        {
            "sha": "a747d0d51cfb3378fc712967e831ed77f74d0018",
            "filename": "crates/next-core/src/next_pages/page_entry.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 26,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/34885c4fe1ef03085abd65f7bda6e1708bed9ce1/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/34885c4fe1ef03085abd65f7bda6e1708bed9ce1/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_pages%2Fpage_entry.rs?ref=34885c4fe1ef03085abd65f7bda6e1708bed9ce1",
            "patch": "@@ -23,13 +23,6 @@ use crate::{\n     util::{file_content_rope, load_next_js_template, NextRuntime},\n };\n \n-#[turbo_tasks::value]\n-pub struct PageSsrEntryModule {\n-    pub ssr_module: ResolvedVc<Box<dyn Module>>,\n-    pub app_module: Option<ResolvedVc<Box<dyn Module>>>,\n-    pub document_module: Option<ResolvedVc<Box<dyn Module>>>,\n-}\n-\n #[turbo_tasks::function]\n pub async fn create_page_ssr_entry_module(\n     pathname: Vc<RcStr>,\n@@ -41,7 +34,7 @@ pub async fn create_page_ssr_entry_module(\n     pages_structure: Vc<PagesStructure>,\n     runtime: NextRuntime,\n     next_config: Vc<NextConfig>,\n-) -> Result<Vc<PageSsrEntryModule>> {\n+) -> Result<Vc<Box<dyn Module>>> {\n     let definition_page = &*next_original_name.await?;\n     let definition_pathname = &*pathname.await?;\n \n@@ -125,28 +118,28 @@ pub async fn create_page_ssr_entry_module(\n \n     let pages_structure_ref = pages_structure.await?;\n \n-    let (app_module, document_module) =\n-        if reference_type == ReferenceType::Entry(EntryReferenceSubType::Page) {\n-            let document_module = process_global_item(\n+    if reference_type == ReferenceType::Entry(EntryReferenceSubType::Page) {\n+        inner_assets.insert(\n+            INNER_DOCUMENT.into(),\n+            process_global_item(\n                 *pages_structure_ref.document,\n                 Value::new(reference_type.clone()),\n                 ssr_module_context,\n             )\n             .to_resolved()\n-            .await?;\n-            let app_module = process_global_item(\n+            .await?,\n+        );\n+        inner_assets.insert(\n+            INNER_APP.into(),\n+            process_global_item(\n                 *pages_structure_ref.app,\n                 Value::new(reference_type.clone()),\n                 ssr_module_context,\n             )\n             .to_resolved()\n-            .await?;\n-            inner_assets.insert(INNER_DOCUMENT.into(), document_module);\n-            inner_assets.insert(INNER_APP.into(), app_module);\n-            (Some(app_module), Some(document_module))\n-        } else {\n-            (None, None)\n-        };\n+            .await?,\n+        );\n+    }\n \n     let mut ssr_module = ssr_module_context\n         .process(\n@@ -177,12 +170,7 @@ pub async fn create_page_ssr_entry_module(\n         }\n     }\n \n-    Ok(PageSsrEntryModule {\n-        ssr_module: ssr_module.to_resolved().await?,\n-        app_module,\n-        document_module,\n-    }\n-    .cell())\n+    Ok(ssr_module)\n }\n \n #[turbo_tasks::function]"
        },
        {
            "sha": "c45e9a957a9c7b66ae4ab20969719cd1560f04be",
            "filename": "packages/next/src/server/dev/hot-reloader-turbopack.ts",
            "status": "modified",
            "additions": 9,
            "deletions": 13,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/34885c4fe1ef03085abd65f7bda6e1708bed9ce1/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/34885c4fe1ef03085abd65f7bda6e1708bed9ce1/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts?ref=34885c4fe1ef03085abd65f7bda6e1708bed9ce1",
            "patch": "@@ -296,7 +296,7 @@ export async function createHotReloaderTurbopack(\n       // Always clear the cache, don't check if files have changed\n       force?: boolean\n     } = {}\n-  ): boolean {\n+  ): void {\n     if (force) {\n       for (const { path, contentHash } of writtenEndpoint.serverPaths) {\n         serverPathState.set(path, contentHash)\n@@ -328,7 +328,7 @@ export async function createHotReloaderTurbopack(\n       }\n \n       if (!hasChange) {\n-        return false\n+        return\n       }\n     }\n \n@@ -351,7 +351,7 @@ export async function createHotReloaderTurbopack(\n       deleteCache(file)\n     }\n \n-    return true\n+    return\n   }\n \n   const buildingIds = new Set()\n@@ -601,9 +601,9 @@ export async function createHotReloaderTurbopack(\n           serverFields,\n \n           hooks: {\n-            handleWrittenEndpoint: (id, result, forceDeleteCache) => {\n+            handleWrittenEndpoint: (id, result) => {\n               currentWrittenEntrypoints.set(id, result)\n-              return clearRequireCache(id, result, { force: forceDeleteCache })\n+              clearRequireCache(id, result)\n             },\n             propagateServerField: propagateServerField.bind(null, opts),\n             sendHmr,\n@@ -997,12 +997,10 @@ export async function createHotReloaderTurbopack(\n                 logErrors: true,\n                 hooks: {\n                   subscribeToChanges,\n-                  handleWrittenEndpoint: (id, result, forceDeleteCache) => {\n+                  handleWrittenEndpoint: (id, result) => {\n+                    clearRequireCache(id, result)\n                     currentWrittenEntrypoints.set(id, result)\n                     assetMapper.setPathsForKey(id, result.clientPaths)\n-                    return clearRequireCache(id, result, {\n-                      force: forceDeleteCache,\n-                    })\n                   },\n                 },\n               })\n@@ -1063,12 +1061,10 @@ export async function createHotReloaderTurbopack(\n \n               hooks: {\n                 subscribeToChanges,\n-                handleWrittenEndpoint: (id, result, forceDeleteCache) => {\n+                handleWrittenEndpoint: (id, result) => {\n                   currentWrittenEntrypoints.set(id, result)\n+                  clearRequireCache(id, result)\n                   assetMapper.setPathsForKey(id, result.clientPaths)\n-                  return clearRequireCache(id, result, {\n-                    force: forceDeleteCache,\n-                  })\n                 },\n               },\n             })"
        },
        {
            "sha": "faa1acdb5ba04acebe773729de5d2f525ee145c0",
            "filename": "packages/next/src/server/dev/turbopack-utils.ts",
            "status": "modified",
            "additions": 13,
            "deletions": 25,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/34885c4fe1ef03085abd65f7bda6e1708bed9ce1/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fturbopack-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/34885c4fe1ef03085abd65f7bda6e1708bed9ce1/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fturbopack-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fturbopack-utils.ts?ref=34885c4fe1ef03085abd65f7bda6e1708bed9ce1",
            "patch": "@@ -98,9 +98,8 @@ export type ChangeSubscriptions = Map<\n \n export type HandleWrittenEndpoint = (\n   key: EntryKey,\n-  result: TurbopackResult<WrittenEndpoint>,\n-  forceDeleteCache: boolean\n-) => boolean\n+  result: TurbopackResult<WrittenEndpoint>\n+) => void\n \n export type StartChangeSubscription = (\n   key: EntryKey,\n@@ -178,17 +177,11 @@ export async function handleRouteType({\n       const serverKey = getEntryKey('pages', 'server', page)\n \n       try {\n-        // In the best case scenario, Turbopack chunks document, app, page separately in that order,\n-        // so it can happen that the chunks of document change, but the chunks of app and page\n-        // don't. We still need to reload the page chunks in that case though, otherwise the version\n-        // of the document or app component export from the pages template is stale.\n-        let documentOrAppChanged = false\n         if (entrypoints.global.app) {\n           const key = getEntryKey('pages', 'server', '_app')\n \n           const writtenEndpoint = await entrypoints.global.app.writeToDisk()\n-          documentOrAppChanged ||=\n-            hooks?.handleWrittenEndpoint(key, writtenEndpoint, false) ?? false\n+          hooks?.handleWrittenEndpoint(key, writtenEndpoint)\n           processIssues(\n             currentEntryIssues,\n             key,\n@@ -205,8 +198,7 @@ export async function handleRouteType({\n \n           const writtenEndpoint =\n             await entrypoints.global.document.writeToDisk()\n-          documentOrAppChanged ||=\n-            hooks?.handleWrittenEndpoint(key, writtenEndpoint, false) ?? false\n+          hooks?.handleWrittenEndpoint(key, writtenEndpoint)\n           processIssues(\n             currentEntryIssues,\n             key,\n@@ -218,11 +210,7 @@ export async function handleRouteType({\n         await manifestLoader.loadPagesManifest('_document')\n \n         const writtenEndpoint = await route.htmlEndpoint.writeToDisk()\n-        hooks?.handleWrittenEndpoint(\n-          serverKey,\n-          writtenEndpoint,\n-          documentOrAppChanged\n-        )\n+        hooks?.handleWrittenEndpoint(serverKey, writtenEndpoint)\n \n         const type = writtenEndpoint?.type\n \n@@ -320,7 +308,7 @@ export async function handleRouteType({\n       const key = getEntryKey('pages', 'server', page)\n \n       const writtenEndpoint = await route.endpoint.writeToDisk()\n-      hooks?.handleWrittenEndpoint(key, writtenEndpoint, false)\n+      hooks?.handleWrittenEndpoint(key, writtenEndpoint)\n \n       const type = writtenEndpoint.type\n \n@@ -345,7 +333,7 @@ export async function handleRouteType({\n       const key = getEntryKey('app', 'server', page)\n \n       const writtenEndpoint = await route.htmlEndpoint.writeToDisk()\n-      hooks?.handleWrittenEndpoint(key, writtenEndpoint, false)\n+      hooks?.handleWrittenEndpoint(key, writtenEndpoint)\n \n       if (dev) {\n         // TODO subscriptions should only be caused by the WebSocket connections\n@@ -408,7 +396,7 @@ export async function handleRouteType({\n       const key = getEntryKey('app', 'server', page)\n \n       const writtenEndpoint = await route.endpoint.writeToDisk()\n-      hooks?.handleWrittenEndpoint(key, writtenEndpoint, false)\n+      hooks?.handleWrittenEndpoint(key, writtenEndpoint)\n \n       const type = writtenEndpoint.type\n \n@@ -666,7 +654,7 @@ export async function handleEntrypoints({\n       const key = getEntryKey('root', 'server', name)\n \n       const writtenEndpoint = await instrumentation[prop].writeToDisk()\n-      dev.hooks.handleWrittenEndpoint(key, writtenEndpoint, false)\n+      dev.hooks.handleWrittenEndpoint(key, writtenEndpoint)\n       processIssues(currentEntryIssues, key, writtenEndpoint, false, logErrors)\n     }\n     await processInstrumentation('instrumentation.nodeJs', 'nodeJs')\n@@ -701,7 +689,7 @@ export async function handleEntrypoints({\n \n     async function processMiddleware() {\n       const writtenEndpoint = await endpoint.writeToDisk()\n-      dev.hooks.handleWrittenEndpoint(key, writtenEndpoint, false)\n+      dev.hooks.handleWrittenEndpoint(key, writtenEndpoint)\n       processIssues(currentEntryIssues, key, writtenEndpoint, false, logErrors)\n       await manifestLoader.loadMiddlewareManifest('middleware', 'middleware')\n       const middlewareConfig =\n@@ -852,7 +840,7 @@ export async function handlePagesErrorRoute({\n     const key = getEntryKey('pages', 'server', '_app')\n \n     const writtenEndpoint = await entrypoints.global.app.writeToDisk()\n-    hooks.handleWrittenEndpoint(key, writtenEndpoint, false)\n+    hooks.handleWrittenEndpoint(key, writtenEndpoint)\n     hooks.subscribeToChanges(\n       key,\n       false,\n@@ -879,7 +867,7 @@ export async function handlePagesErrorRoute({\n     const key = getEntryKey('pages', 'server', '_document')\n \n     const writtenEndpoint = await entrypoints.global.document.writeToDisk()\n-    hooks.handleWrittenEndpoint(key, writtenEndpoint, false)\n+    hooks.handleWrittenEndpoint(key, writtenEndpoint)\n     hooks.subscribeToChanges(\n       key,\n       false,\n@@ -905,7 +893,7 @@ export async function handlePagesErrorRoute({\n     const key = getEntryKey('pages', 'server', '_error')\n \n     const writtenEndpoint = await entrypoints.global.error.writeToDisk()\n-    hooks.handleWrittenEndpoint(key, writtenEndpoint, false)\n+    hooks.handleWrittenEndpoint(key, writtenEndpoint)\n     hooks.subscribeToChanges(\n       key,\n       false,"
        }
    ],
    "stats": {
        "total": 303,
        "additions": 82,
        "deletions": 221
    }
}