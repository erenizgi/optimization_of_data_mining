{
    "author": "ijjk",
    "message": "Add nonce handling from CSP in pages router (#78936)\n\nOur docs never called out that the nonce from a\n`content-security-policy` header would only automatically be set in app\nrouter. This adds handling to ensure it is also set for pages router.\n\nFixes #67042\nCloses NEXT-4104",
    "sha": "617867f3f13d247d8be00f75933cf22478fc9fb1",
    "files": [
        {
            "sha": "483876d544748cd64378a69b513c7de4bd01d63f",
            "filename": "packages/next/src/pages/_document.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/617867f3f13d247d8be00f75933cf22478fc9fb1/packages%2Fnext%2Fsrc%2Fpages%2F_document.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/617867f3f13d247d8be00f75933cf22478fc9fb1/packages%2Fnext%2Fsrc%2Fpages%2F_document.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fpages%2F_document.tsx?ref=617867f3f13d247d8be00f75933cf22478fc9fb1",
            "patch": "@@ -1200,10 +1200,10 @@ export default class Document<P = {}> extends React.Component<\n   render() {\n     return (\n       <Html>\n-        <Head />\n+        <Head nonce={this.props.nonce} />\n         <body>\n           <Main />\n-          <NextScript />\n+          <NextScript nonce={this.props.nonce} />\n         </body>\n       </Html>\n     )"
        },
        {
            "sha": "89be6bfe3c165c5c762df4a37c431b0e98a3ac09",
            "filename": "packages/next/src/server/render.tsx",
            "status": "modified",
            "additions": 11,
            "deletions": 1,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/617867f3f13d247d8be00f75933cf22478fc9fb1/packages%2Fnext%2Fsrc%2Fserver%2Frender.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/617867f3f13d247d8be00f75933cf22478fc9fb1/packages%2Fnext%2Fsrc%2Fserver%2Frender.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frender.tsx?ref=617867f3f13d247d8be00f75933cf22478fc9fb1",
            "patch": "@@ -104,6 +104,7 @@ import { getCacheControlHeader } from './lib/cache-control'\n import { getErrorSource } from '../shared/lib/error-source'\n import type { DeepReadonly } from '../shared/lib/deep-readonly'\n import type { PagesDevOverlayType } from '../client/components/react-dev-overlay/pages/pages-dev-overlay'\n+import { getScriptNonceFromHeader } from './app-render/get-script-nonce-from-header'\n \n let tryGetPreviewData: typeof import('./api-utils/node/try-get-preview-data').tryGetPreviewData\n let warn: typeof import('../build/output/log').warn\n@@ -740,6 +741,13 @@ export async function renderToHTMLImpl(\n       .map((script: any) => script.props)\n   }\n \n+  const csp =\n+    req.headers['content-security-policy'] ||\n+    req.headers['content-security-policy-report-only']\n+\n+  const nonce =\n+    typeof csp === 'string' ? getScriptNonceFromHeader(csp) : undefined\n+\n   const AppContainer = ({ children }: { children: JSX.Element }) => (\n     <AppRouterContext.Provider value={appRouter}>\n       <SearchParamsContext.Provider value={adaptForSearchParams(router)}>\n@@ -760,6 +768,7 @@ export async function renderToHTMLImpl(\n                     },\n                     scripts: initialScripts,\n                     mountedInstances: new Set(),\n+                    nonce,\n                   }}\n                 >\n                   <LoadableContext.Provider\n@@ -843,7 +852,7 @@ export async function renderToHTMLImpl(\n       const { html, head: renderPageHead } = await docCtx.renderPage({\n         enhanceApp,\n       })\n-      const styles = jsxStyleRegistry.styles({ nonce: options.nonce })\n+      const styles = jsxStyleRegistry.styles({ nonce: options.nonce || nonce })\n       jsxStyleRegistry.flush()\n       return { html, head: renderPageHead, styles }\n     },\n@@ -1504,6 +1513,7 @@ export async function renderToHTMLImpl(\n       isPreview: isPreview === true ? true : undefined,\n       notFoundSrcPage: notFoundSrcPage && dev ? notFoundSrcPage : undefined,\n     },\n+    nonce,\n     strictNextHead: renderOpts.strictNextHead,\n     buildManifest: filteredBuildManifest,\n     docComponentsRendered,"
        },
        {
            "sha": "f80b466b8bae21a3897bdbd5c8c12cadff62f29f",
            "filename": "packages/next/src/shared/lib/html-context.shared-runtime.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/617867f3f13d247d8be00f75933cf22478fc9fb1/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fhtml-context.shared-runtime.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/617867f3f13d247d8be00f75933cf22478fc9fb1/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fhtml-context.shared-runtime.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Fhtml-context.shared-runtime.ts?ref=617867f3f13d247d8be00f75933cf22478fc9fb1",
            "patch": "@@ -8,6 +8,7 @@ import { createContext, useContext, type JSX } from 'react'\n \n export type HtmlProps = {\n   __NEXT_DATA__: NEXT_DATA\n+  nonce?: string\n   strictNextHead: boolean\n   dangerousAsPath: string\n   docComponentsRendered: {"
        },
        {
            "sha": "8fc69c64cdbc14046246ca7c8c82295f1be9e5af",
            "filename": "test/production/app-dir/subresource-integrity/fixture/pages/pages.tsx",
            "status": "added",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/617867f3f13d247d8be00f75933cf22478fc9fb1/test%2Fproduction%2Fapp-dir%2Fsubresource-integrity%2Ffixture%2Fpages%2Fpages.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/617867f3f13d247d8be00f75933cf22478fc9fb1/test%2Fproduction%2Fapp-dir%2Fsubresource-integrity%2Ffixture%2Fpages%2Fpages.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fsubresource-integrity%2Ffixture%2Fpages%2Fpages.tsx?ref=617867f3f13d247d8be00f75933cf22478fc9fb1",
            "patch": "@@ -0,0 +1,22 @@\n+import React from 'react'\n+import Script from 'next/script'\n+\n+export function getServerSideProps() {\n+  return {\n+    props: {\n+      now: Date.now(),\n+    },\n+  }\n+}\n+\n+export default function Page() {\n+  return (\n+    <>\n+      <p>pages-nonce</p>\n+      <Script\n+        dangerouslySetInnerHTML={{ __html: 'console.log(\"hi\")' }}\n+        strategy=\"afterInteractive\"\n+      />\n+    </>\n+  )\n+}"
        },
        {
            "sha": "9d8e69723625bf80cfac1d4a06b1d7eb73f047fb",
            "filename": "test/production/app-dir/subresource-integrity/subresource-integrity.test.ts",
            "status": "modified",
            "additions": 211,
            "deletions": 205,
            "changes": 416,
            "blob_url": "https://github.com/vercel/next.js/blob/617867f3f13d247d8be00f75933cf22478fc9fb1/test%2Fproduction%2Fapp-dir%2Fsubresource-integrity%2Fsubresource-integrity.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/617867f3f13d247d8be00f75933cf22478fc9fb1/test%2Fproduction%2Fapp-dir%2Fsubresource-integrity%2Fsubresource-integrity.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fsubresource-integrity%2Fsubresource-integrity.test.ts?ref=617867f3f13d247d8be00f75933cf22478fc9fb1",
            "patch": "@@ -7,226 +7,232 @@ import cheerio from 'cheerio'\n ;(process.env.IS_TURBOPACK_TEST ? describe.skip : describe)(\n   'Subresource Integrity',\n   () => {\n-    describe.each(['node', 'edge'] as const)('with %s runtime', (runtime) => {\n-      const { next } = nextTestSetup({\n-        files: path.join(__dirname, 'fixture'),\n-      })\n-\n-      function fetchWithPolicy(policy: string | null, reportOnly?: boolean) {\n-        const cspKey = reportOnly\n-          ? 'Content-Security-Policy-Report-Only'\n-          : 'Content-Security-Policy'\n-        return next.fetch(`/${runtime}`, {\n-          headers: policy\n-            ? {\n-                [cspKey]: policy,\n-              }\n-            : {},\n+    describe.each(['node', 'edge', 'pages'] as const)(\n+      'with %s runtime',\n+      (runtime) => {\n+        const { next } = nextTestSetup({\n+          files: path.join(__dirname, 'fixture'),\n         })\n-      }\n \n-      async function renderWithPolicy(\n-        policy: string | null,\n-        reportOnly?: boolean\n-      ) {\n-        const res = await fetchWithPolicy(policy, reportOnly)\n+        function fetchWithPolicy(policy: string | null, reportOnly?: boolean) {\n+          const cspKey = reportOnly\n+            ? 'Content-Security-Policy-Report-Only'\n+            : 'Content-Security-Policy'\n+          return next.fetch(`/${runtime}`, {\n+            headers: policy\n+              ? {\n+                  [cspKey]: policy,\n+                }\n+              : {},\n+          })\n+        }\n \n-        expect(res.ok).toBe(true)\n+        async function renderWithPolicy(\n+          policy: string | null,\n+          reportOnly?: boolean\n+        ) {\n+          const res = await fetchWithPolicy(policy, reportOnly)\n \n-        const html = await res.text()\n+          expect(res.ok).toBe(true)\n \n-        return cheerio.load(html)\n-      }\n+          const html = await res.text()\n \n-      it('does not include nonce when not enabled', async () => {\n-        const policies = [\n-          `script-src 'nonce-'`, // invalid nonce\n-          'style-src \"nonce-cmFuZG9tCg==\"', // no script or default src\n-          '', // empty string\n-        ]\n+          return cheerio.load(html)\n+        }\n \n-        for (const policy of policies) {\n-          const $ = await renderWithPolicy(policy)\n+        it('does not include nonce when not enabled', async () => {\n+          const policies = [\n+            `script-src 'nonce-'`, // invalid nonce\n+            'style-src \"nonce-cmFuZG9tCg==\"', // no script or default src\n+            '', // empty string\n+          ]\n \n-          // Find all the script tags without src attributes and with nonce\n-          // attributes.\n-          const elements = $('script[nonce]:not([src])')\n+          for (const policy of policies) {\n+            const $ = await renderWithPolicy(policy)\n \n-          // Expect there to be none.\n-          expect(elements.length).toBe(0)\n-        }\n-      })\n-\n-      it('includes a nonce value with inline scripts when Content-Security-Policy header is defined', async () => {\n-        // A random nonce value, base64 encoded.\n-        const nonce = 'cmFuZG9tCg=='\n-\n-        // Validate all the cases where we could parse the nonce.\n-        const policies = [\n-          `script-src 'nonce-${nonce}'`, // base case\n-          `   script-src   'nonce-${nonce}' `, // extra space added around sources and directive\n-          `style-src 'self'; script-src 'nonce-${nonce}'`, // extra directives\n-          `script-src 'self' 'nonce-${nonce}' 'nonce-othernonce'`, // extra nonces\n-          `default-src 'nonce-othernonce'; script-src 'nonce-${nonce}';`, // script and then fallback case\n-          `default-src 'nonce-${nonce}'`, // fallback case\n-        ]\n-\n-        for (const policy of policies) {\n-          const $ = await renderWithPolicy(policy)\n-\n-          // Find all the script tags without src attributes.\n-          const elements = $('script:not([src])')\n-\n-          // Expect there to be at least 1 script tag without a src attribute.\n-          expect(elements.length).toBeGreaterThan(0)\n-\n-          // Expect all inline scripts to have the nonce value.\n-          elements.each((i, el) => {\n-            expect(el.attribs['nonce']).toBe(nonce)\n-          })\n-        }\n-      })\n-\n-      it('includes a nonce value with inline scripts when Content-Security-Policy-Report-Only header is defined', async () => {\n-        // A random nonce value, base64 encoded.\n-        const nonce = 'cmFuZG9tCg=='\n-\n-        // Validate all the cases where we could parse the nonce.\n-        const policies = [\n-          `script-src 'nonce-${nonce}'`, // base case\n-          `   script-src   'nonce-${nonce}' `, // extra space added around sources and directive\n-          `style-src 'self'; script-src 'nonce-${nonce}'`, // extra directives\n-          `script-src 'self' 'nonce-${nonce}' 'nonce-othernonce'`, // extra nonces\n-          `default-src 'nonce-othernonce'; script-src 'nonce-${nonce}';`, // script and then fallback case\n-          `default-src 'nonce-${nonce}'`, // fallback case\n-        ]\n-\n-        for (const policy of policies) {\n-          const $ = await renderWithPolicy(policy, true)\n-\n-          // Find all the script tags without src attributes.\n-          const elements = $('script:not([src])')\n-\n-          // Expect there to be at least 1 script tag without a src attribute.\n-          expect(elements.length).toBeGreaterThan(0)\n-\n-          // Expect all inline scripts to have the nonce value.\n-          elements.each((i, el) => {\n-            expect(el.attribs['nonce']).toBe(nonce)\n-          })\n-        }\n-      })\n-\n-      it('includes a nonce value with bootstrap scripts when Content-Security-Policy header is defined', async () => {\n-        // A random nonce value, base64 encoded.\n-        const nonce = 'cmFuZG9tCg=='\n-\n-        // Validate all the cases where we could parse the nonce.\n-        const policies = [\n-          `script-src 'nonce-${nonce}'`, // base case\n-          `   script-src   'nonce-${nonce}' `, // extra space added around sources and directive\n-          `style-src 'self'; script-src 'nonce-${nonce}'`, // extra directives\n-          `script-src 'self' 'nonce-${nonce}' 'nonce-othernonce'`, // extra nonces\n-          `default-src 'nonce-othernonce'; script-src 'nonce-${nonce}';`, // script and then fallback case\n-          `default-src 'nonce-${nonce}'`, // fallback case\n-        ]\n-\n-        for (const policy of policies) {\n-          const $ = await renderWithPolicy(policy)\n-\n-          // Find all the script tags without src attributes.\n-          const elements = $('script[src]')\n-\n-          // Expect there to be at least 2 script tag with a src attribute.\n-          // The main chunk and the webpack runtime.\n-          expect(elements.length).toBeGreaterThan(1)\n-\n-          // Expect all inline scripts to have the nonce value.\n-          elements.each((i, el) => {\n-            expect(el.attribs['nonce']).toBe(nonce)\n-          })\n-        }\n-      })\n-\n-      it('includes an integrity attribute on scripts', async () => {\n-        const $ = await next.render$(`/${runtime}`)\n-        // Currently webpack chunks loaded via flight runtime do not get integrity\n-        // hashes. This was previously unobservable in this test because these scripts\n-        // are inserted by the webpack runtime and immediately removed from the document.\n-        // However with the advent of preinitialization of chunks used during SSR there are\n-        // some script tags for flight loaded chunks that will be part of the initial HTML\n-        // but do not have integrity hashes. Flight does not currently support a way to\n-        // provide integrity hashes for these chunks. When this is addressed in React upstream\n-        // we can revisit this tests assertions and start to ensure it actually applies to\n-        // all SSR'd scripts. For now we will look for known entrypoint scripts and assume\n-        // everything else in the <head> is part of flight loaded chunks\n-\n-        // Collect all the scripts with integrity hashes so we can verify them.\n-        const files: Map<string, string> = new Map()\n-\n-        function assertHasIntegrity(el: CheerioElement) {\n-          const integrity = el.attribs['integrity']\n-          expect(integrity).toBeDefined()\n-          expect(integrity).toStartWith('sha256-')\n-\n-          const src = el.attribs['src']\n-          expect(src).toBeDefined()\n-\n-          files.set(src, integrity)\n-        }\n+            // Find all the script tags without src attributes and with nonce\n+            // attributes.\n+            const elements = $('script[nonce]:not([src])')\n+\n+            // Expect there to be none.\n+            expect(elements.length).toBe(0)\n+          }\n+        })\n \n-        // <head> scripts are most entrypoint scripts, polyfills, and flight loaded scripts.\n-        // Since we currently cannot assert integrity on flight loaded scripts (they do not have it)\n-        // We have to target specific expected entrypoint/polyfill scripts and assert them directly\n-        const mainScript = $(\n-          'head script[src^=\"/_next/static/chunks/main-app\"]'\n-        )\n-        expect(mainScript.length).toBe(1)\n-        assertHasIntegrity(mainScript.get(0))\n-\n-        const polyfillsScript = $(\n-          'head script[src^=\"/_next/static/chunks/polyfills\"]'\n-        )\n-        expect(polyfillsScript.length).toBe(1)\n-        assertHasIntegrity(polyfillsScript.get(0))\n-\n-        // body scripts should include just the bootstrap script. We assert that all body\n-        // scripts have integrity because we don't expect any flight loaded scripts to appear\n-        // here\n-        const bodyScripts = $('body script[src]')\n-        expect(bodyScripts.length).toBeGreaterThan(0)\n-        bodyScripts.each((i, el) => {\n-          assertHasIntegrity(el)\n+        it('includes a nonce value with inline scripts when Content-Security-Policy header is defined', async () => {\n+          // A random nonce value, base64 encoded.\n+          const nonce = 'cmFuZG9tCg=='\n+\n+          // Validate all the cases where we could parse the nonce.\n+          const policies = [\n+            `script-src 'nonce-${nonce}'`, // base case\n+            `   script-src   'nonce-${nonce}' `, // extra space added around sources and directive\n+            `style-src 'self'; script-src 'nonce-${nonce}'`, // extra directives\n+            `script-src 'self' 'nonce-${nonce}' 'nonce-othernonce'`, // extra nonces\n+            `default-src 'nonce-othernonce'; script-src 'nonce-${nonce}';`, // script and then fallback case\n+            `default-src 'nonce-${nonce}'`, // fallback case\n+          ]\n+\n+          for (const policy of policies) {\n+            const $ = await renderWithPolicy(policy)\n+\n+            // Find all the script tags without src attributes.\n+            const elements = $('script:not([src])')\n+\n+            // Expect there to be at least 1 script tag without a src attribute.\n+            expect(elements.length).toBeGreaterThan(0)\n+\n+            // Expect all inline scripts to have the nonce value.\n+            elements.each((i, el) => {\n+              expect(el.attribs['nonce']).toBe(nonce)\n+            })\n+          }\n         })\n \n-        // For each script tag, ensure that the integrity attribute is the\n-        // correct hash of the script tag.\n-        for (const [src, integrity] of files) {\n-          const res = await next.fetch(src)\n-          expect(res.status).toBe(200)\n-          const content = await res.text()\n+        it('includes a nonce value with inline scripts when Content-Security-Policy-Report-Only header is defined', async () => {\n+          // A random nonce value, base64 encoded.\n+          const nonce = 'cmFuZG9tCg=='\n+\n+          // Validate all the cases where we could parse the nonce.\n+          const policies = [\n+            `script-src 'nonce-${nonce}'`, // base case\n+            `   script-src   'nonce-${nonce}' `, // extra space added around sources and directive\n+            `style-src 'self'; script-src 'nonce-${nonce}'`, // extra directives\n+            `script-src 'self' 'nonce-${nonce}' 'nonce-othernonce'`, // extra nonces\n+            `default-src 'nonce-othernonce'; script-src 'nonce-${nonce}';`, // script and then fallback case\n+            `default-src 'nonce-${nonce}'`, // fallback case\n+          ]\n+\n+          for (const policy of policies) {\n+            const $ = await renderWithPolicy(policy, true)\n+\n+            // Find all the script tags without src attributes.\n+            const elements = $('script:not([src])')\n+\n+            // Expect there to be at least 1 script tag without a src attribute.\n+            expect(elements.length).toBeGreaterThan(0)\n+\n+            // Expect all inline scripts to have the nonce value.\n+            elements.each((i, el) => {\n+              expect(el.attribs['nonce']).toBe(nonce)\n+            })\n+          }\n+        })\n \n-          const hash = crypto\n-            .createHash('sha256')\n-            .update(content)\n-            .digest()\n-            .toString('base64')\n+        it('includes a nonce value with bootstrap scripts when Content-Security-Policy header is defined', async () => {\n+          // A random nonce value, base64 encoded.\n+          const nonce = 'cmFuZG9tCg=='\n+\n+          // Validate all the cases where we could parse the nonce.\n+          const policies = [\n+            `script-src 'nonce-${nonce}'`, // base case\n+            `   script-src   'nonce-${nonce}' `, // extra space added around sources and directive\n+            `style-src 'self'; script-src 'nonce-${nonce}'`, // extra directives\n+            `script-src 'self' 'nonce-${nonce}' 'nonce-othernonce'`, // extra nonces\n+            `default-src 'nonce-othernonce'; script-src 'nonce-${nonce}';`, // script and then fallback case\n+            `default-src 'nonce-${nonce}'`, // fallback case\n+          ]\n+\n+          for (const policy of policies) {\n+            const $ = await renderWithPolicy(policy)\n+\n+            // Find all the script tags without src attributes.\n+            const elements = $('script[src]')\n+\n+            // Expect there to be at least 2 script tag with a src attribute.\n+            // The main chunk and the webpack runtime.\n+            expect(elements.length).toBeGreaterThan(1)\n+\n+            // Expect all inline scripts to have the nonce value.\n+            elements.each((i, el) => {\n+              expect(el.attribs['nonce']).toBe(nonce)\n+            })\n+          }\n+        })\n \n-          expect(integrity).toEndWith(hash)\n-        }\n-      })\n+        it('includes an integrity attribute on scripts', async () => {\n+          // pages router doesn't do integrity attribute yet\n+          if (runtime === 'pages') return\n+\n+          const $ = await next.render$(`/${runtime}`)\n+          // Currently webpack chunks loaded via flight runtime do not get integrity\n+          // hashes. This was previously unobservable in this test because these scripts\n+          // are inserted by the webpack runtime and immediately removed from the document.\n+          // However with the advent of preinitialization of chunks used during SSR there are\n+          // some script tags for flight loaded chunks that will be part of the initial HTML\n+          // but do not have integrity hashes. Flight does not currently support a way to\n+          // provide integrity hashes for these chunks. When this is addressed in React upstream\n+          // we can revisit this tests assertions and start to ensure it actually applies to\n+          // all SSR'd scripts. For now we will look for known entrypoint scripts and assume\n+          // everything else in the <head> is part of flight loaded chunks\n+\n+          // Collect all the scripts with integrity hashes so we can verify them.\n+          const files: Map<string, string> = new Map()\n+\n+          function assertHasIntegrity(el: CheerioElement) {\n+            const integrity = el.attribs['integrity']\n+            expect(integrity).toBeDefined()\n+            expect(integrity).toStartWith('sha256-')\n+\n+            const src = el.attribs['src']\n+            expect(src).toBeDefined()\n+\n+            files.set(src, integrity)\n+          }\n+\n+          // <head> scripts are most entrypoint scripts, polyfills, and flight loaded scripts.\n+          // Since we currently cannot assert integrity on flight loaded scripts (they do not have it)\n+          // We have to target specific expected entrypoint/polyfill scripts and assert them directly\n+          const mainScript = $(\n+            `head script[src^=\"/_next/static/chunks/main-app\"]`\n+          )\n+          expect(mainScript.length).toBe(1)\n+          assertHasIntegrity(mainScript.get(0))\n+\n+          const polyfillsScript = $(\n+            'head script[src^=\"/_next/static/chunks/polyfills\"]'\n+          )\n+          expect(polyfillsScript.length).toBe(1)\n+          assertHasIntegrity(polyfillsScript.get(0))\n+\n+          // body scripts should include just the bootstrap script. We assert that all body\n+          // scripts have integrity because we don't expect any flight loaded scripts to appear\n+          // here\n+          const bodyScripts = $('body script[src]')\n+          expect(bodyScripts.length).toBeGreaterThan(0)\n+          bodyScripts.each((i, el) => {\n+            assertHasIntegrity(el)\n+          })\n \n-      it('throws when escape characters are included in nonce', async () => {\n-        const res = await fetchWithPolicy(\n-          `script-src 'nonce-\"><script></script>\"'`\n-        )\n+          // For each script tag, ensure that the integrity attribute is the\n+          // correct hash of the script tag.\n+          for (const [src, integrity] of files) {\n+            const res = await next.fetch(src)\n+            expect(res.status).toBe(200)\n+            const content = await res.text()\n+\n+            const hash = crypto\n+              .createHash('sha256')\n+              .update(content)\n+              .digest()\n+              .toString('base64')\n+\n+            expect(integrity).toEndWith(hash)\n+          }\n+        })\n \n-        if (runtime === 'node' && process.env.__NEXT_EXPERIMENTAL_PPR) {\n-          expect(res.status).toBe(200)\n-        } else {\n-          expect(res.status).toBe(500)\n-        }\n-      })\n-    })\n+        it('throws when escape characters are included in nonce', async () => {\n+          const res = await fetchWithPolicy(\n+            `script-src 'nonce-\"><script></script>\"'`\n+          )\n+\n+          if (runtime === 'node' && process.env.__NEXT_EXPERIMENTAL_PPR) {\n+            expect(res.status).toBe(200)\n+          } else {\n+            expect(res.status).toBe(500)\n+          }\n+        })\n+      }\n+    )\n   }\n )"
        }
    ],
    "stats": {
        "total": 455,
        "additions": 247,
        "deletions": 208
    }
}