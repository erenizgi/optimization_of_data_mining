{
    "author": "icyJoseph",
    "message": "docs: Clarify revalidatePath  (#82142)\n\nFixes: https://github.com/vercel/next.js/issues/81776",
    "sha": "1f8ea2a1b09bf6017bee7d72e99727c1f351bc69",
    "files": [
        {
            "sha": "aeffedab638d7ad8ff0899da1c9b54ffa031e963",
            "filename": "docs/01-app/03-api-reference/04-functions/revalidatePath.mdx",
            "status": "modified",
            "additions": 63,
            "deletions": 5,
            "changes": 68,
            "blob_url": "https://github.com/vercel/next.js/blob/1f8ea2a1b09bf6017bee7d72e99727c1f351bc69/docs%2F01-app%2F03-api-reference%2F04-functions%2FrevalidatePath.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/1f8ea2a1b09bf6017bee7d72e99727c1f351bc69/docs%2F01-app%2F03-api-reference%2F04-functions%2FrevalidatePath.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2FrevalidatePath.mdx?ref=1f8ea2a1b09bf6017bee7d72e99727c1f351bc69",
            "patch": "@@ -5,25 +5,83 @@ description: API Reference for the revalidatePath function.\n \n `revalidatePath` allows you to purge [cached data](/docs/app/guides/caching) on-demand for a specific path.\n \n+## Usage\n+\n+`revalidatePath` can be called in Server Functions and Route Handlers.\n+\n+`revalidatePath` cannot be called in Client Components or Middleware, as it only works in server environments.\n+\n > **Good to know**:\n >\n-> - `revalidatePath` only invalidates the cache when the included path is next visited. This means calling `revalidatePath` with a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is next visited.\n-> - Currently, `revalidatePath` invalidates all the routes in the [client-side Router Cache](/docs/app/guides/caching#client-side-router-cache) when used in a server action. This behavior is temporary and will be updated in the future to apply only to the specific path.\n-> - Using `revalidatePath` invalidates **only the specific path** in the [server-side Route Cache](/docs/app/guides/caching#full-route-cache).\n+> - **Server Functions**: Updates the UI immediately (if viewing the revalidated path). Currently, it also causes all previously visited pages to refresh when navigated to again. This behavior is temporary and will be updated in the future to apply only to the specific path.\n+> - **Route Handlers**: Marks the path for revalidation. The revalidation is done on the next visit to the specified path. This means calling `revalidatePath` with a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is next visited.\n \n ## Parameters\n \n ```tsx\n revalidatePath(path: string, type?: 'page' | 'layout'): void;\n ```\n \n-- `path`: Either a string representing the filesystem path associated with the data you want to revalidate (for example, `/product/[slug]/page`), or the literal route segment (for example, `/product/123`). Must be less than 1024 characters. This value is case-sensitive.\n+- `path`: Either a string representing the filesystem path associated with the data you want to revalidate (for example, `/product/[slug]/page`), or the literal route segment (for example, `/product/123`). Must not exceed 1024 characters. This value is case-sensitive.\n - `type`: (optional) `'page'` or `'layout'` string to change the type of path to revalidate. If `path` contains a dynamic segment (for example, `/product/[slug]/page`), this parameter is required. If path refers to the literal route segment, e.g., `/product/1` for a dynamic page (e.g., `/product/[slug]/page`), you should not provide `type`.\n \n ## Returns\n \n `revalidatePath` does not return a value.\n \n+## What can be revalidated\n+\n+The path parameter can point to pages, layouts, or route handlers:\n+\n+- **Pages**: Revalidates the specific page\n+- **Layouts**: Revalidates the layout and all pages beneath it\n+- **GET Route Handlers**: Only if they're statically generated\n+\n+## Relationship with `revalidateTag`\n+\n+`revalidatePath` and [`revalidateTag`](/docs/app/api-reference/functions/revalidateTag) serve different purposes:\n+\n+- **`revalidatePath`**: Revalidates a specific page or layout path\n+- **`revalidateTag`**: Revalidates data with specific tags across all pages that use those tags\n+\n+When you call `revalidatePath`, only the specified path gets fresh data on the next visit. Other pages that use the same data tags will continue to serve cached data until those specific tags are also revalidated:\n+\n+```tsx\n+// Page A: /blog\n+const posts = await fetch('https://api.vercel.app/blog', {\n+  next: { tags: ['posts'] },\n+})\n+\n+// Page B: /dashboard\n+const recentPosts = await fetch('https://api.vercel.app/blog?limit=5', {\n+  next: { tags: ['posts'] },\n+})\n+```\n+\n+After calling `revalidatePath('/blog')`:\n+\n+- **Page A (/blog)**: Shows fresh data (page re-rendered)\n+- **Page B (/dashboard)**: Still shows stale data (cache tag 'posts' not invalidated)\n+\n+### Building revalidation utilities\n+\n+`revalidatePath` and `revalidateTag` are complementary primitives that are often used together in utility functions to ensure comprehensive data consistency across your application:\n+\n+```ts\n+'use server'\n+\n+import { revalidatePath, revalidateTag } from 'next/cache'\n+\n+export async function updatePost() {\n+  await updatePostInDatabase()\n+\n+  revalidatePath('/blog') // Refresh the blog page\n+  revalidateTag('posts') // Refresh all pages using 'posts' tag\n+}\n+```\n+\n+This pattern ensures that both the specific page and any other pages using the same data remain consistent.\n+\n ## Examples\n \n ### Revalidating A Specific URL\n@@ -67,7 +125,7 @@ revalidatePath('/', 'layout')\n \n This will purge the Client-side Router Cache, and revalidate the Data Cache on the next page visit.\n \n-### Server Action\n+### Server Function\n \n ```ts filename=\"app/actions.ts\" switcher\n 'use server'"
        },
        {
            "sha": "1d31e033248c022d8722fb89d5d47db0c8edbdd3",
            "filename": "docs/01-app/03-api-reference/04-functions/revalidateTag.mdx",
            "status": "modified",
            "additions": 36,
            "deletions": 8,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/1f8ea2a1b09bf6017bee7d72e99727c1f351bc69/docs%2F01-app%2F03-api-reference%2F04-functions%2FrevalidateTag.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/1f8ea2a1b09bf6017bee7d72e99727c1f351bc69/docs%2F01-app%2F03-api-reference%2F04-functions%2FrevalidateTag.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F04-functions%2FrevalidateTag.mdx?ref=1f8ea2a1b09bf6017bee7d72e99727c1f351bc69",
            "patch": "@@ -5,17 +5,21 @@ description: API Reference for the revalidateTag function.\n \n `revalidateTag` allows you to purge [cached data](/docs/app/guides/caching) on-demand for a specific cache tag.\n \n-> **Good to know**:\n->\n-> - `revalidateTag` only invalidates the cache when the path is next visited. This means calling `revalidateTag` with a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is next visited.\n+## Usage\n+\n+`revalidateTag` can be called in Server Functions and Route Handlers.\n+\n+`revalidateTag` cannot be called in Client Components or Middleware, as it only works in server environments.\n+\n+> **Good to know**: `revalidateTag` marks tagged data as stale, but fresh data is only fetched when pages using that tag are next visited. This means calling `revalidateTag` will not immediately trigger many revalidations at once. The invalidation only happens when any page using that tag is next visited.\n \n ## Parameters\n \n ```tsx\n revalidateTag(tag: string): void;\n ```\n \n-- `tag`: A string representing the cache tag associated with the data you want to revalidate. Must be less than or equal to 256 characters. This value is case-sensitive.\n+- `tag`: A string representing the cache tag associated with the data you want to revalidate. Must not exceed 256 characters. This value is case-sensitive.\n \n You can add tags to `fetch` as follows:\n \n@@ -27,6 +31,12 @@ fetch(url, { next: { tags: [...] } });\n \n `revalidateTag` does not return a value.\n \n+## Relationship with `revalidatePath`\n+\n+`revalidateTag` revalidates data with specific tags across all pages that use those tags, while [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath) revalidates specific page or layout paths.\n+\n+> **Good to know**: These functions serve different purposes and may need to be used together for comprehensive data consistency. For detailed examples and considerations, see [Relationship with revalidateTag](/docs/app/api-reference/functions/revalidatePath#relationship-with-revalidatetag).\n+\n ## Examples\n \n ### Server Action\n@@ -61,8 +71,17 @@ import { revalidateTag } from 'next/cache'\n \n export async function GET(request: NextRequest) {\n   const tag = request.nextUrl.searchParams.get('tag')\n-  revalidateTag(tag)\n-  return Response.json({ revalidated: true, now: Date.now() })\n+\n+  if (tag) {\n+    revalidateTag(tag)\n+    return Response.json({ revalidated: true, now: Date.now() })\n+  }\n+\n+  return Response.json({\n+    revalidated: false,\n+    now: Date.now(),\n+    message: 'Missing tag to revalidate',\n+  })\n }\n ```\n \n@@ -71,7 +90,16 @@ import { revalidateTag } from 'next/cache'\n \n export async function GET(request) {\n   const tag = request.nextUrl.searchParams.get('tag')\n-  revalidateTag(tag)\n-  return Response.json({ revalidated: true, now: Date.now() })\n+\n+  if (tag) {\n+    revalidateTag(tag)\n+    return Response.json({ revalidated: true, now: Date.now() })\n+  }\n+\n+  return Response.json({\n+    revalidated: false,\n+    now: Date.now(),\n+    message: 'Missing tag to revalidate',\n+  })\n }\n ```"
        }
    ],
    "stats": {
        "total": 112,
        "additions": 99,
        "deletions": 13
    }
}