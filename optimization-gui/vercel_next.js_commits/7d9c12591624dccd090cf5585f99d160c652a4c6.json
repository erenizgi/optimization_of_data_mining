{
    "author": "sokra",
    "message": "Turbopack: fix Scope holding Arc too long (#85611)\n\n### What?\n\nTurbo tasks Arc should be dropped before returning to the caller",
    "sha": "7d9c12591624dccd090cf5585f99d160c652a4c6",
    "files": [
        {
            "sha": "ff4fc5b69d7e9f1f168f4f25eb2da47b54c6c56d",
            "filename": "turbopack/crates/turbo-tasks/src/scope.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 11,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/7d9c12591624dccd090cf5585f99d160c652a4c6/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fscope.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7d9c12591624dccd090cf5585f99d160c652a4c6/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fscope.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fscope.rs?ref=7d9c12591624dccd090cf5585f99d160c652a4c6",
            "patch": "@@ -195,8 +195,17 @@ impl<'scope, 'env: 'scope, R: Send + 'env> Scope<'scope, 'env, R> {\n         assert!(index < self.results.len(), \"Too many tasks spawned\");\n         let result_cell: &Mutex<Option<R>> = &self.results[index];\n \n+        let turbo_tasks = self.turbo_tasks.clone();\n         let f: Box<dyn FnOnce() + Send + 'scope> = Box::new(|| {\n-            let result = f();\n+            let result = {\n+                if let Some(turbo_tasks) = turbo_tasks {\n+                    // Ensure that the turbo tasks context is maintained across the job.\n+                    turbo_tasks_scope(turbo_tasks, f)\n+                } else {\n+                    // If no turbo tasks context is available, just run the job.\n+                    f()\n+                }\n+            };\n             *result_cell.lock() = Some(result);\n         });\n         let f: *mut (dyn FnOnce() + Send + 'scope) = Box::into_raw(f);\n@@ -210,7 +219,6 @@ impl<'scope, 'env: 'scope, R: Send + 'env> Scope<'scope, 'env, R> {\n         // SAFETY: We just called `Box::into_raw`.\n         let f = unsafe { Box::from_raw(f) };\n \n-        let turbo_tasks = self.turbo_tasks.clone();\n         let span = self.span.clone();\n \n         self.inner.remaining_tasks.fetch_add(1, Ordering::Relaxed);\n@@ -223,15 +231,7 @@ impl<'scope, 'env: 'scope, R: Send + 'env> Scope<'scope, 'env, R> {\n             // Spawn a worker task that will process that tasks and potentially more.\n             self.handle.spawn(async move {\n                 let _span = span.entered();\n-                if let Some(turbo_tasks) = turbo_tasks {\n-                    // Ensure that the turbo tasks context is maintained across the worker.\n-                    turbo_tasks_scope(turbo_tasks, || {\n-                        inner.worker(index, f);\n-                    });\n-                } else {\n-                    // If no turbo tasks context is available, just run the worker.\n-                    inner.worker(index, f);\n-                }\n+                inner.worker(index, f);\n             });\n         } else {\n             // Queue the task to be processed by a worker task."
        }
    ],
    "stats": {
        "total": 22,
        "additions": 11,
        "deletions": 11
    }
}