{
    "author": "bgw",
    "message": "Turbopack: Document the reasons for the current design of `parse_segment_config_from_source` (#83919)\n\nDocument all my learnings from my saga of trying to get Flow syntax to work in entrypoints with the babel loader and ultimately giving up, so that hopefully others don't waste their time like I did.\n\nhttps://vercel.slack.com/archives/C03EWR7LGEN/p1757982766169869",
    "sha": "eb602d4bd1f1112cd562845a63384c69eefe52c9",
    "files": [
        {
            "sha": "acb5b96cfc6937b7787d50e38de13756d4178623",
            "filename": "crates/next-core/src/segment_config.rs",
            "status": "modified",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/vercel/next.js/blob/eb602d4bd1f1112cd562845a63384c69eefe52c9/crates%2Fnext-core%2Fsrc%2Fsegment_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/eb602d4bd1f1112cd562845a63384c69eefe52c9/crates%2Fnext-core%2Fsrc%2Fsegment_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fsegment_config.rs?ref=eb602d4bd1f1112cd562845a63384c69eefe52c9",
            "patch": "@@ -300,6 +300,67 @@ pub enum ParseSegmentMode {\n     App,\n }\n \n+/// Parse the raw source code of a file to get the segment config local to that file.\n+///\n+/// See [the Next.js documentation for Route Segment\n+/// Configs](https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config).\n+///\n+/// Pages router and middleware use this directly. App router uses\n+/// `parse_segment_config_from_loader_tree` instead, which aggregates configuration information\n+/// across multiple files.\n+///\n+/// ## A Note on Parsing the Raw Source Code\n+///\n+/// A better API would use `ModuleAssetContext::process` to convert the `Source` to a `Module`,\n+/// instead of parsing the raw source code. That would ensure that things like webpack loaders can\n+/// run before SWC tries to parse the file, e.g. to strip unsupported syntax using Babel. However,\n+/// because the config includes `runtime`, we can't know which context to use until after parsing\n+/// the file.\n+///\n+/// This could be solved with speculative parsing:\n+/// 1. Speculatively process files and extract route segment configs using the Node.js\n+///    `ModuleAssetContext` first. This is the common/happy codepath.\n+/// 2. If we get a config specifying `runtime = \"edge\"`, we should use the Edge runtime's\n+///    `ModuleAssetContext` and re-process the file(s), extracting the segment config again.\n+/// 3. If we failed to get a configuration (e.g. a parse error), we need speculatively process with\n+///    the Edge runtime and look for a `runtime = \"edge\"` configuration key. If that also fails,\n+///    then we should report any issues/errors from the first attempt using the Node.js context.\n+///\n+/// While a speculative parsing algorithm is straightforward, there are a few factors that make it\n+/// impractical to implement:\n+///\n+/// - The app router config is loaded across many different files (page, layout, or route handler,\n+///   including an arbitrary number of those files in parallel routes), and once we discover that\n+///   something specified edge runtime, we must restart that entire loop, so try/reparse logic can't\n+///   be cleanly encapsulated to an operation over a single file.\n+///\n+/// - There's a lot of tracking that needs to happen to later suppress `Issue` collectibles on\n+///   speculatively-executed `OperationVc`s.\n+///\n+/// - Most things default to the node.js runtime and can be overridden to edge runtime, but\n+///   middleware is an exception, so different codepaths have different defaults.\n+///\n+/// The `runtime` option is going to be deprecated, and we may eventually remove edge runtime\n+/// completely (in Next 18?), so it doesn't make sense to spend a ton of time improving logic around\n+/// that. In the future, doing this the right way with the `ModuleAssetContext` will be easy (there\n+/// will only be one, no speculative parsing is needed), and I think it's okay to use a hacky\n+/// solution for a couple years until that day comes.\n+///\n+/// ## What does webpack do?\n+///\n+/// The logic is in `packages/next/src/build/analysis/get-page-static-info.ts`, but it's very\n+/// similar to what we do here.\n+///\n+/// There are a couple of notable differences:\n+///\n+/// - The webpack implementation uses a regexp (`PARSE_PATTERN`) to skip parsing some files, but\n+///   this regexp is imperfect and may also suppress some lints that we have. The performance\n+///   benefit is small, so we're not currently doing this (but we could revisit that decision in the\n+///   future).\n+///\n+/// - The `parseModule` helper function swallows errors (!) returning a `null` ast value when\n+///   parsing fails. This seems bad, as it may lead to silently-ignored segment configs, so we don't\n+///   want to do this.\n #[turbo_tasks::function]\n pub async fn parse_segment_config_from_source(\n     source: ResolvedVc<Box<dyn Source>>,\n@@ -1229,6 +1290,8 @@ async fn parse_route_matcher_from_js_value(\n     })\n }\n \n+/// A wrapper around [`parse_segment_config_from_source`] that merges route segment configuration\n+/// information from all relevant files (page, layout, parallel routes, etc).\n #[turbo_tasks::function]\n pub async fn parse_segment_config_from_loader_tree(\n     loader_tree: Vc<AppPageLoaderTree>,"
        }
    ],
    "stats": {
        "total": 63,
        "additions": 63,
        "deletions": 0
    }
}