{
    "author": "lukesandberg",
    "message": "[turbopack] RFC: Serialize turbopack objects as u16s instead of fully qualified symbol names (#83193)\n\nChange the serialization strategy for `ValueTypeId`, `TraitTypeId` and `NativeFunction` to use `u16` values instead of the `global_name` (a fully qualified name of the object).\n\nFor all these objects the value is the index+1 of the corresponding object in the set of all objects sorted by name.   This is a deterministic ordering which should ensure we can deserialize them with the same version of turbopack.\n\nPotential concerns with this approach:\n\n* debuggability in the Persistent Cache (is this even a thing?)\n* stability of ids across architectures\n    * if different architectures enable/disable turbotasks then ids will change and make the PC database non-portable. \n\nStill this should speed up serialization/deserialization by making everything smaller and faster to encode/decode\n\nOn an optimized build with a fresh `.next` directory, i measured the size of the `.cache/turbopack/vxxxx` directory\n\n`benches/module-cost`:  \n    change: 2.38Gb (-22%), wrote in 9.5s, compacted in 5.4s\n    head:  3.06Gb bytes, wrote in 10.3s, compacted in 7.6s\n\n`vercel-site`\n    change: 4.8Gb(-12%), wrote in 46ss, compacted in 6.2s\n    head:  5.5Gb, wrote in 48s, compacted in 7.6s\n\nSo a non-trivial size reduction as expected.  This should also speed up encoding/decoding but i didnt attempt to directly measure that.",
    "sha": "2a9e842602c5b8095434a4a3cbbb769612ab8497",
    "files": [
        {
            "sha": "6a6711de1ce8fd38922c323b73f44a141c441164",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/2a9e842602c5b8095434a4a3cbbb769612ab8497/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a9e842602c5b8095434a4a3cbbb769612ab8497/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=2a9e842602c5b8095434a4a3cbbb769612ab8497",
            "patch": "@@ -36,7 +36,7 @@ use turbo_tasks::{\n     },\n     event::{Event, EventListener},\n     message_queue::TimingEvent,\n-    registry::{self, get_value_type_global_name},\n+    registry::get_value_type,\n     task_statistics::TaskStatisticsApi,\n     trace::TraceRawVcs,\n     turbo_tasks,\n@@ -867,7 +867,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n \n         let _span = tracing::trace_span!(\n             \"recomputation\",\n-            cell_type = registry::get_value_type_global_name(cell.type_id),\n+            cell_type = get_value_type(cell.type_id).global_name,\n             cell_index = cell.index\n         )\n         .entered();\n@@ -3133,7 +3133,7 @@ impl DebugTraceTransientTask {\n             cell_type_id: Option<ValueTypeId>,\n         ) -> fmt::Result {\n             if let Some(ty) = cell_type_id {\n-                write!(f, \" (read cell of type {})\", get_value_type_global_name(ty))\n+                write!(f, \" (read cell of type {})\", get_value_type(ty).global_name)\n             } else {\n                 Ok(())\n             }"
        },
        {
            "sha": "f70fbca451e2233de2762ab5ea9db5f94e0d8a51",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 7,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/2a9e842602c5b8095434a4a3cbbb769612ab8497/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a9e842602c5b8095434a4a3cbbb769612ab8497/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=2a9e842602c5b8095434a4a3cbbb769612ab8497",
            "patch": "@@ -127,7 +127,7 @@ mod ser {\n                 None\n             };\n             let mut state = serializer.serialize_tuple(3)?;\n-            state.serialize_element(registry::get_value_type_global_name(self.0))?;\n+            state.serialize_element(&self.0)?;\n             if let Some(serializable) = serializable {\n                 state.serialize_element(&true)?;\n                 state.serialize_element(serializable)?;\n@@ -157,11 +157,9 @@ mod ser {\n                 where\n                     A: de::SeqAccess<'de>,\n                 {\n-                    let value_type = seq\n+                    let value_type: ValueTypeId = seq\n                         .next_element()?\n                         .ok_or_else(|| de::Error::invalid_length(0, &self))?;\n-                    let value_type = registry::get_value_type_id_by_global_name(value_type)\n-                        .ok_or_else(|| de::Error::custom(\"Unknown value type\"))?;\n                     let has_value: bool = seq\n                         .next_element()?\n                         .ok_or_else(|| de::Error::invalid_length(1, &self))?;\n@@ -212,7 +210,7 @@ mod ser {\n                 unreachable!();\n             };\n             let mut state = serializer.serialize_seq(Some(2))?;\n-            state.serialize_element(native_fn.global_name)?;\n+            state.serialize_element(&registry::get_function_id(native_fn))?;\n             let arg = *arg;\n             let arg = native_fn.arg_meta.as_serialize(arg);\n             state.serialize_element(arg)?;\n@@ -234,10 +232,10 @@ mod ser {\n                 where\n                     A: serde::de::SeqAccess<'de>,\n                 {\n-                    let fn_name = seq\n+                    let fn_id = seq\n                         .next_element()?\n                         .ok_or_else(|| serde::de::Error::invalid_length(0, &self))?;\n-                    let native_fn = registry::get_function_by_global_name(fn_name);\n+                    let native_fn = registry::get_native_function(fn_id);\n                     let seed = native_fn.arg_meta.deserialization_seed();\n                     let arg = seq\n                         .next_element_seed(seed)?"
        },
        {
            "sha": "5d50eb7574c9dd787b13245554db0463da410718",
            "filename": "turbopack/crates/turbo-tasks/src/id.rs",
            "status": "modified",
            "additions": 36,
            "deletions": 14,
            "changes": 50,
            "blob_url": "https://github.com/vercel/next.js/blob/2a9e842602c5b8095434a4a3cbbb769612ab8497/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a9e842602c5b8095434a4a3cbbb769612ab8497/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid.rs?ref=2a9e842602c5b8095434a4a3cbbb769612ab8497",
            "patch": "@@ -39,7 +39,13 @@ macro_rules! define_id {\n             pub const unsafe fn new_unchecked(id: $primitive) -> Self {\n                 Self { id: unsafe { NonZero::<$primitive>::new_unchecked(id) } }\n             }\n-\n+            /// Constructs a wrapper type from the numeric identifier.\n+            ///\n+            /// Returns `None` if the provided `id` is zero, otherwise returns\n+            /// `Some(Self)` containing the wrapped non-zero identifier.\n+            pub fn new(id: $primitive) -> Option<Self> {\n+                NonZero::<$primitive>::new(id).map(|id| Self{id})\n+            }\n             /// Allows `const` conversion to a [`NonZeroU64`], useful with\n             /// [`crate::id_factory::IdFactory::new_const`].\n             pub const fn to_non_zero_u64(self) -> NonZeroU64 {\n@@ -113,8 +119,9 @@ macro_rules! define_id {\n }\n \n define_id!(TaskId: u32, derive(Serialize, Deserialize), serde(transparent));\n-define_id!(ValueTypeId: u32);\n-define_id!(TraitTypeId: u32);\n+define_id!(FunctionId: u16);\n+define_id!(ValueTypeId: u16);\n+define_id!(TraitTypeId: u16);\n define_id!(SessionId: u32, derive(Debug, Serialize, Deserialize), serde(transparent));\n define_id!(\n     LocalTaskId: u32,\n@@ -153,13 +160,13 @@ impl TaskId {\n }\n \n macro_rules! make_serializable {\n-    ($ty:ty, $get_global_name:path, $get_id:path, $visitor_name:ident) => {\n+    ($ty:ty, $get_object:path, $validate_type_id:path, $visitor_name:ident) => {\n         impl Serialize for $ty {\n             fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n             where\n                 S: serde::Serializer,\n             {\n-                serializer.serialize_str($get_global_name(*self))\n+                serializer.serialize_u16(self.id.into())\n             }\n         }\n \n@@ -168,7 +175,7 @@ macro_rules! make_serializable {\n             where\n                 D: serde::Deserializer<'de>,\n             {\n-                deserializer.deserialize_str($visitor_name)\n+                deserializer.deserialize_u16($visitor_name)\n             }\n         }\n \n@@ -178,22 +185,31 @@ macro_rules! make_serializable {\n             type Value = $ty;\n \n             fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {\n-                formatter.write_str(concat!(\"a name of a registered \", stringify!($ty)))\n+                formatter.write_str(concat!(\"an id of a registered \", stringify!($ty)))\n             }\n \n-            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n+            fn visit_u16<E>(self, v: u16) -> Result<Self::Value, E>\n             where\n                 E: serde::de::Error,\n             {\n-                $get_id(v).ok_or_else(|| E::unknown_variant(v, &[]))\n+                match Self::Value::new(v) {\n+                    Some(value) => {\n+                        if let Some(error) = $validate_type_id(value) {\n+                            Err(E::custom(error))\n+                        } else {\n+                            Ok(value)\n+                        }\n+                    }\n+                    None => Err(E::unknown_variant(&format!(\"{v}\"), &[\"a non zero u16\"])),\n+                }\n             }\n         }\n \n         impl Debug for $ty {\n             fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n                 f.debug_struct(stringify!($ty))\n                     .field(\"id\", &self.id)\n-                    .field(\"name\", &$get_global_name(*self))\n+                    .field(\"name\", &$get_object(*self))\n                     .finish()\n             }\n         }\n@@ -202,13 +218,19 @@ macro_rules! make_serializable {\n \n make_serializable!(\n     ValueTypeId,\n-    registry::get_value_type_global_name,\n-    registry::get_value_type_id_by_global_name,\n+    registry::get_value_type,\n+    registry::validate_value_type_id,\n     ValueTypeVisitor\n );\n make_serializable!(\n     TraitTypeId,\n-    registry::get_trait_type_global_name,\n-    registry::get_trait_type_id_by_global_name,\n+    registry::get_trait,\n+    registry::validate_trait_type_id,\n     TraitTypeVisitor\n );\n+make_serializable!(\n+    FunctionId,\n+    registry::get_native_function,\n+    registry::validate_function_id,\n+    FunctionTypeVisitor\n+);"
        },
        {
            "sha": "fb33edf534493434b925083b03e672ae38b4d96a",
            "filename": "turbopack/crates/turbo-tasks/src/native_function.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 7,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/2a9e842602c5b8095434a4a3cbbb769612ab8497/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a9e842602c5b8095434a4a3cbbb769612ab8497/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs?ref=2a9e842602c5b8095434a4a3cbbb769612ab8497",
            "patch": "@@ -273,18 +273,16 @@ impl NativeFunction {\n         tracing::trace_span!(\"turbo_tasks::resolve_call\", name = self.name, flags = flags)\n     }\n }\n-\n-impl PartialEq for &'static NativeFunction {\n+impl PartialEq for NativeFunction {\n     fn eq(&self, other: &Self) -> bool {\n-        std::ptr::eq(*self, *other)\n+        std::ptr::eq(self, other)\n     }\n }\n \n-impl Eq for &'static NativeFunction {}\n-\n-impl Hash for &'static NativeFunction {\n+impl Eq for NativeFunction {}\n+impl Hash for NativeFunction {\n     fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n-        Hash::hash(&(*self as *const NativeFunction), state);\n+        (self as *const NativeFunction).hash(state);\n     }\n }\n "
        },
        {
            "sha": "7f96208ad37a98ce48c66872e3e81c49f12ca5cb",
            "filename": "turbopack/crates/turbo-tasks/src/registry.rs",
            "status": "modified",
            "additions": 140,
            "deletions": 117,
            "changes": 257,
            "blob_url": "https://github.com/vercel/next.js/blob/2a9e842602c5b8095434a4a3cbbb769612ab8497/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fregistry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a9e842602c5b8095434a4a3cbbb769612ab8497/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fregistry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fregistry.rs?ref=2a9e842602c5b8095434a4a3cbbb769612ab8497",
            "patch": "@@ -1,161 +1,184 @@\n-use std::num::NonZeroU32;\n+use std::num::NonZeroU16;\n \n+use anyhow::Error;\n use once_cell::sync::Lazy;\n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     TraitType, ValueType,\n-    id::{TraitTypeId, ValueTypeId},\n+    id::{FunctionId, TraitTypeId, ValueTypeId},\n     macro_helpers::CollectableFunction,\n     native_function::NativeFunction,\n     value_type::{CollectableTrait, CollectableValueType},\n };\n \n-pub fn get_function_by_global_name(global_name: &str) -> &'static NativeFunction {\n-    static NAME_TO_FUNCTION: Lazy<FxHashMap<&'static str, &'static NativeFunction>> =\n-        Lazy::new(|| {\n-            let mut map = FxHashMap::default();\n-            for collected in inventory::iter::<CollectableFunction> {\n-                let native_function = &**collected.0;\n-                let global_name = native_function.global_name;\n-                let prev = map.insert(global_name, native_function);\n-                assert!(\n-                    prev.is_none(),\n-                    \"multiple functions registered with the name {global_name}!\"\n-                );\n-            }\n-            map.shrink_to_fit();\n-            map\n-        });\n-\n-    match NAME_TO_FUNCTION.get(global_name) {\n-        Some(f) => f,\n-        None => panic!(\"unable to find function: {global_name}\"),\n+/// A trait for types that can be registered in a registry.\n+///\n+/// This allows the generic registry to work with different types\n+/// while maintaining their specific requirements.\n+trait RegistryItem: 'static + Eq + std::hash::Hash {\n+    /// The ID type used for this registry item\n+    type Id: Copy + From<NonZeroU16> + std::ops::Deref<Target = u16> + std::fmt::Display;\n+    const TYPE_NAME: &'static str;\n+\n+    /// Get the global name used for sorting and uniqueness validation\n+    fn global_name(&self) -> &'static str;\n+}\n+\n+impl RegistryItem for NativeFunction {\n+    type Id = FunctionId;\n+    const TYPE_NAME: &'static str = \"Function\";\n+\n+    fn global_name(&self) -> &'static str {\n+        self.global_name\n     }\n }\n \n-struct Values {\n-    id_to_value: Box<[&'static ValueType]>,\n-    value_to_id: FxHashMap<&'static ValueType, ValueTypeId>,\n-    global_name_to_value: FxHashMap<&'static str, (ValueTypeId, &'static ValueType)>,\n+impl RegistryItem for ValueType {\n+    type Id = ValueTypeId;\n+    const TYPE_NAME: &'static str = \"Value\";\n+\n+    fn global_name(&self) -> &'static str {\n+        self.global_name\n+    }\n }\n \n-static VALUES: Lazy<Values> = Lazy::new(|| {\n-    // Inventory does not guarantee an order. So we sort by the global name to get a stable order\n-    // This ensures that assigned ids are also stable.\n-    // We don't currently take advantage of this but we could in the future.  The remaining issue is\n-    // ensuring the set of values is the same across runs.\n-    let mut all_values = inventory::iter::<CollectableValueType>\n-        .into_iter()\n-        .map(|t| &**t.0)\n-        .collect::<Vec<_>>();\n-    all_values.sort_unstable_by_key(|t| t.global_name);\n-\n-    let mut value_to_id = FxHashMap::with_capacity_and_hasher(all_values.len(), Default::default());\n-    let mut global_name_to_value =\n-        FxHashMap::with_capacity_and_hasher(all_values.len(), Default::default());\n-\n-    let mut id = NonZeroU32::MIN;\n-    for &value_type in all_values.iter() {\n-        value_to_id.insert(value_type, id.into());\n-        let prev = global_name_to_value.insert(value_type.global_name, (id.into(), value_type));\n-        assert!(\n-            prev.is_none(),\n-            \"two value types registered with the same name: {}\",\n-            value_type.global_name\n-        );\n-        id = id.checked_add(1).expect(\"overflowing value type ids\");\n+impl RegistryItem for TraitType {\n+    type Id = TraitTypeId;\n+    const TYPE_NAME: &'static str = \"Trait\";\n+    fn global_name(&self) -> &'static str {\n+        self.global_name\n     }\n+}\n \n-    value_to_id.shrink_to_fit();\n-    global_name_to_value.shrink_to_fit();\n-    Values {\n-        value_to_id,\n-        id_to_value: all_values.into_boxed_slice(),\n-        global_name_to_value,\n+/// A generic registry that maps between IDs and static references to items.\n+///\n+/// This eliminates the code duplication between Functions, Values, and Traits registries.\n+struct Registry<T: RegistryItem> {\n+    id_to_item: Box<[&'static T]>,\n+    item_to_id: FxHashMap<&'static T, T::Id>,\n+}\n+\n+impl<T: RegistryItem> Registry<T> {\n+    /// Create a new registry from a collection of items.\n+    ///\n+    /// Items are sorted by global_name to ensure stable ID assignment.\n+    fn new_from_items(mut items: Vec<&'static T>) -> Self {\n+        // Sort by global name to get stable order\n+        items.sort_unstable_by_key(|item| item.global_name());\n+\n+        let mut item_to_id = FxHashMap::with_capacity_and_hasher(items.len(), Default::default());\n+        let mut names = FxHashSet::with_capacity_and_hasher(items.len(), Default::default());\n+\n+        let mut id = NonZeroU16::MIN;\n+        for &item in items.iter() {\n+            item_to_id.insert(item, id.into());\n+            let global_name = item.global_name();\n+            assert!(\n+                names.insert(global_name),\n+                \"multiple {ty} items registered with name: {global_name}!\",\n+                ty = T::TYPE_NAME\n+            );\n+            id = id.checked_add(1).expect(\"overflowing item ids\");\n+        }\n+\n+        Self {\n+            id_to_item: items.into_boxed_slice(),\n+            item_to_id,\n+        }\n     }\n-});\n \n-pub fn get_value_type_id(value: &'static ValueType) -> ValueTypeId {\n-    match VALUES.value_to_id.get(value) {\n-        Some(id) => *id,\n-        None => panic!(\"Use of unregistered trait {value:?}\"),\n+    /// Get an item by its ID\n+    fn get_item(&self, id: T::Id) -> &'static T {\n+        self.id_to_item[*id as usize - 1]\n+    }\n+\n+    /// Get the ID for an item\n+    fn get_id(&self, item: &'static T) -> T::Id {\n+        match self.item_to_id.get(&item) {\n+            Some(id) => *id,\n+            None => panic!(\n+                \"{ty} isn't registered: {item}\",\n+                ty = T::TYPE_NAME,\n+                item = item.global_name()\n+            ),\n+        }\n+    }\n+\n+    /// Validate that an ID is within the valid range\n+    fn validate_id(&self, id: T::Id) -> Option<Error> {\n+        let len = self.id_to_item.len();\n+        if *id as usize <= len {\n+            None\n+        } else {\n+            Some(anyhow::anyhow!(\n+                \"Invalid {ty} id, {id} expected a value <= {len}\",\n+                ty = T::TYPE_NAME\n+            ))\n+        }\n     }\n }\n \n-pub fn get_value_type_id_by_global_name(global_name: &str) -> Option<ValueTypeId> {\n-    VALUES\n-        .global_name_to_value\n-        .get(global_name)\n-        .map(|(id, _)| *id)\n+static FUNCTIONS: Lazy<Registry<NativeFunction>> = Lazy::new(|| {\n+    let functions = inventory::iter::<CollectableFunction>\n+        .into_iter()\n+        .map(|c| &**c.0)\n+        .collect::<Vec<_>>();\n+    Registry::new_from_items(functions)\n+});\n+\n+pub fn get_native_function(id: FunctionId) -> &'static NativeFunction {\n+    FUNCTIONS.get_item(id)\n }\n \n-pub fn get_value_type(id: ValueTypeId) -> &'static ValueType {\n-    VALUES.id_to_value[*id as usize - 1]\n+pub fn get_function_id(func: &'static NativeFunction) -> FunctionId {\n+    FUNCTIONS.get_id(func)\n+}\n+\n+pub fn validate_function_id(id: FunctionId) -> Option<Error> {\n+    FUNCTIONS.validate_id(id)\n+}\n+\n+static VALUES: Lazy<Registry<ValueType>> = Lazy::new(|| {\n+    // Inventory does not guarantee an order. So we sort by the global name to get a stable order\n+    // This ensures that assigned ids are also stable which is important since they are serialized.\n+    let all_values = inventory::iter::<CollectableValueType>\n+        .into_iter()\n+        .map(|t| &**t.0)\n+        .collect::<Vec<_>>();\n+    Registry::new_from_items(all_values)\n+});\n+\n+pub fn get_value_type_id(value: &'static ValueType) -> ValueTypeId {\n+    VALUES.get_id(value)\n }\n \n-pub fn get_value_type_global_name(id: ValueTypeId) -> &'static str {\n-    get_value_type(id).global_name\n+pub fn get_value_type(id: ValueTypeId) -> &'static ValueType {\n+    VALUES.get_item(id)\n }\n \n-struct Traits {\n-    id_to_trait: Box<[&'static TraitType]>,\n-    trait_to_id: FxHashMap<&'static TraitType, TraitTypeId>,\n-    global_name_to_trait: FxHashMap<&'static str, (TraitTypeId, &'static TraitType)>,\n+pub fn validate_value_type_id(id: ValueTypeId) -> Option<Error> {\n+    VALUES.validate_id(id)\n }\n \n-static TRAITS: Lazy<Traits> = Lazy::new(|| {\n+static TRAITS: Lazy<Registry<TraitType>> = Lazy::new(|| {\n     // Inventory does not guarantee an order. So we sort by the global name to get a stable order\n     // This ensures that assigned ids are also stable.\n-    let mut all_traits = inventory::iter::<CollectableTrait>\n+    let all_traits = inventory::iter::<CollectableTrait>\n         .into_iter()\n         .map(|t| &**t.0)\n         .collect::<Vec<_>>();\n-    all_traits.sort_unstable_by_key(|t| t.global_name);\n-\n-    let mut trait_to_id = FxHashMap::with_capacity_and_hasher(all_traits.len(), Default::default());\n-    let mut global_name_to_trait =\n-        FxHashMap::with_capacity_and_hasher(all_traits.len(), Default::default());\n-\n-    let mut id = NonZeroU32::MIN;\n-    for &trait_type in all_traits.iter() {\n-        trait_to_id.insert(trait_type, id.into());\n-\n-        let prev = global_name_to_trait.insert(trait_type.global_name, (id.into(), trait_type));\n-        assert!(\n-            prev.is_none(),\n-            \"two traits registered with the same name: {}\",\n-            trait_type.global_name\n-        );\n-        id = id.checked_add(1).expect(\"overflowing trait type ids\");\n-    }\n-    trait_to_id.shrink_to_fit();\n-    global_name_to_trait.shrink_to_fit();\n-    Traits {\n-        trait_to_id,\n-        id_to_trait: all_traits.into_boxed_slice(),\n-        global_name_to_trait,\n-    }\n+    Registry::new_from_items(all_traits)\n });\n \n pub fn get_trait_type_id(trait_type: &'static TraitType) -> TraitTypeId {\n-    match TRAITS.trait_to_id.get(trait_type) {\n-        Some(id) => *id,\n-        None => panic!(\"Use of unregistered trait {trait_type:?}\"),\n-    }\n-}\n-\n-pub fn get_trait_type_id_by_global_name(global_name: &str) -> Option<TraitTypeId> {\n-    TRAITS\n-        .global_name_to_trait\n-        .get(global_name)\n-        .map(|(id, _)| *id)\n+    TRAITS.get_id(trait_type)\n }\n \n pub fn get_trait(id: TraitTypeId) -> &'static TraitType {\n-    TRAITS.id_to_trait[*id as usize - 1]\n+    TRAITS.get_item(id)\n }\n \n-pub fn get_trait_type_global_name(id: TraitTypeId) -> &'static str {\n-    get_trait(id).global_name\n+pub fn validate_trait_type_id(id: TraitTypeId) -> Option<Error> {\n+    TRAITS.validate_id(id)\n }"
        },
        {
            "sha": "6f86a718f8d142a5f2c1a1d701b26c6c8c63a76e",
            "filename": "turbopack/crates/turbo-tasks/src/task/shared_reference.rs",
            "status": "modified",
            "additions": 18,
            "deletions": 22,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/2a9e842602c5b8095434a4a3cbbb769612ab8497/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Fshared_reference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/2a9e842602c5b8095434a4a3cbbb769612ab8497/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Fshared_reference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask%2Fshared_reference.rs?ref=2a9e842602c5b8095434a4a3cbbb769612ab8497",
            "patch": "@@ -110,13 +110,13 @@ impl Serialize for TypedSharedReference {\n         let value_type = registry::get_value_type(*ty);\n         if let Some(serializable) = value_type.any_as_serializable(arc) {\n             let mut t = serializer.serialize_tuple(2)?;\n-            t.serialize_element(registry::get_value_type_global_name(*ty))?;\n+            t.serialize_element(ty)?;\n             t.serialize_element(serializable)?;\n             t.end()\n         } else {\n             Err(serde::ser::Error::custom(format!(\n                 \"{:?} is not serializable\",\n-                registry::get_value_type_global_name(*ty)\n+                registry::get_value_type(*ty).global_name\n             )))\n         }\n     }\n@@ -156,29 +156,25 @@ impl<'de> Deserialize<'de> for TypedSharedReference {\n             where\n                 A: serde::de::SeqAccess<'de>,\n             {\n-                if let Some(global_name) = seq.next_element()? {\n-                    if let Some(ty) = registry::get_value_type_id_by_global_name(global_name) {\n-                        if let Some(seed) = registry::get_value_type(ty).get_any_deserialize_seed()\n-                        {\n-                            if let Some(value) = seq.next_element_seed(seed)? {\n-                                let arc = triomphe::Arc::<dyn Any + Send + Sync>::from(value);\n-                                Ok(TypedSharedReference {\n-                                    type_id: ty,\n-                                    reference: SharedReference(arc),\n-                                })\n-                            } else {\n-                                Err(serde::de::Error::invalid_length(\n-                                    1,\n-                                    &\"tuple with type and value\",\n-                                ))\n-                            }\n+                if let Some(type_id) = seq.next_element()? {\n+                    let value_type = registry::get_value_type(type_id);\n+                    if let Some(seed) = value_type.get_any_deserialize_seed() {\n+                        if let Some(value) = seq.next_element_seed(seed)? {\n+                            let arc = triomphe::Arc::<dyn Any + Send + Sync>::from(value);\n+                            Ok(TypedSharedReference {\n+                                type_id,\n+                                reference: SharedReference(arc),\n+                            })\n                         } else {\n-                            Err(serde::de::Error::custom(format!(\n-                                \"{ty} is not deserializable\"\n-                            )))\n+                            Err(serde::de::Error::invalid_length(\n+                                1,\n+                                &\"tuple with type and value\",\n+                            ))\n                         }\n                     } else {\n-                        Err(serde::de::Error::unknown_variant(global_name, &[]))\n+                        Err(serde::de::Error::custom(format!(\n+                            \"{value_type} is not deserializable\"\n+                        )))\n                     }\n                 } else {\n                     Err(serde::de::Error::invalid_length("
        }
    ],
    "stats": {
        "total": 377,
        "additions": 207,
        "deletions": 170
    }
}