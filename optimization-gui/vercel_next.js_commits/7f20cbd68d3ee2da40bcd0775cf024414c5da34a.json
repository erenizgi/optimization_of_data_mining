{
    "author": "mischnic",
    "message": "Turbopack: symlinks and parent globs in `outputFileTracingIncludes` (#82528)\n\n1. Don't resolve symlinks in `outputFileTracingIncludes`. Otherwise if you specify `node_modules/foo/*` in there, it will resolve to `node_modules/.pnpm/foo/*` and `require(\"foo\")` won't work anymore because there no symlink in `node_modules/foo` anymore. This is also what happens with Webpack\r\n2. Align `read_glob` with `read_dir` in that the hashmap keys only contain the path segment, and not the full path.\r\n3. Support globing parents of the start folder: if the glob can match `..`, then also try to match `directory.parent_folder().read_glob(glob)`\r\n\r\nCloses PACK-5219",
    "sha": "7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
    "files": [
        {
            "sha": "bf6d519f248c1765f8060076ec7976babdedbb68",
            "filename": "crates/next-api/src/nft_json.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/crates%2Fnext-api%2Fsrc%2Fnft_json.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fnft_json.rs?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
            "patch": "@@ -104,6 +104,7 @@ async fn apply_includes(\n ) -> Result<BTreeSet<RcStr>> {\n     debug_assert_eq!(project_root_path.fs, ident_folder.fs);\n     // Read files matching the glob pattern from the project root\n+    // This result itself has random order, but the BTreeSet will ensure a deterministic ordering.\n     let glob_result = project_root_path.read_glob(glob).await?;\n \n     // Walk the full glob_result using an explicit stack to avoid async recursion overheads.\n@@ -113,15 +114,15 @@ async fn apply_includes(\n     while let Some(glob_result) = stack.pop_back() {\n         // Process direct results (files and directories at this level)\n         for entry in glob_result.results.values() {\n-            let DirectoryEntry::File(file_path) = entry else {\n+            let (DirectoryEntry::File(file_path) | DirectoryEntry::Symlink(file_path)) = entry\n+            else {\n                 continue;\n             };\n \n-            let file_path_ref = file_path;\n             // Convert to relative path from ident_folder to the file\n             // unwrap is safe because project_root_path and ident_folder have the same filesystem\n             // and paths produced by read_glob stay in the filesystem\n-            let relative_path = ident_folder.get_relative_path_to(file_path_ref).unwrap();\n+            let relative_path = ident_folder.get_relative_path_to(file_path).unwrap();\n             result.insert(relative_path);\n         }\n "
        },
        {
            "sha": "c676f27c676ff215c71832832d5dded6745f2e25",
            "filename": "test/integration/build-trace-extra-entries-monorepo/app/app/route1/route.js",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries-monorepo%2Fapp%2Fapp%2Froute1%2Froute.js",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries-monorepo%2Fapp%2Fapp%2Froute1%2Froute.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fbuild-trace-extra-entries-monorepo%2Fapp%2Fapp%2Froute1%2Froute.js?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
            "patch": "@@ -0,0 +1,5 @@\n+export const dynamic = 'force-dynamic'\n+\n+export async function GET() {\n+  return new Response('foo')\n+}"
        },
        {
            "sha": "2163edca16e8d1fe51cfa066c5bffd2ae7b1e3c8",
            "filename": "test/integration/build-trace-extra-entries-monorepo/app/next.config.js",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries-monorepo%2Fapp%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries-monorepo%2Fapp%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fbuild-trace-extra-entries-monorepo%2Fapp%2Fnext.config.js?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
            "patch": "@@ -0,0 +1,5 @@\n+module.exports = {\n+  outputFileTracingIncludes: {\n+    '/route1': ['../other/included.txt'],\n+  },\n+}"
        },
        {
            "sha": "1269488f7fb1f4b56a8c0e5eb48cecbfadfa9219",
            "filename": "test/integration/build-trace-extra-entries-monorepo/other/included.txt",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries-monorepo%2Fother%2Fincluded.txt",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries-monorepo%2Fother%2Fincluded.txt",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fbuild-trace-extra-entries-monorepo%2Fother%2Fincluded.txt?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
            "patch": "@@ -0,0 +1 @@\n+data"
        },
        {
            "sha": "53ede30984bc6621e2882bde6e02bb6eae9da043",
            "filename": "test/integration/build-trace-extra-entries-monorepo/test/index.test.ts",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries-monorepo%2Ftest%2Findex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries-monorepo%2Ftest%2Findex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fbuild-trace-extra-entries-monorepo%2Ftest%2Findex.test.ts?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
            "patch": "@@ -0,0 +1,33 @@\n+/* eslint-env jest */\n+\n+import fs from 'fs-extra'\n+import { join } from 'path'\n+import { nextBuild } from 'next-test-utils'\n+\n+const appDir = join(__dirname, '../app')\n+\n+describe('build trace with extra entries in monorepo', () => {\n+  ;(process.env.TURBOPACK_DEV ? describe.skip : describe)(\n+    'production mode',\n+    () => {\n+      it('should build and trace correctly', async () => {\n+        const result = await nextBuild(appDir, undefined, {\n+          cwd: appDir,\n+          stderr: true,\n+          stdout: true,\n+        })\n+        expect(result.code).toBe(0)\n+        console.log(result.stderr)\n+        console.log(result.stdout)\n+\n+        const appDirRoute1Trace = await fs.readJSON(\n+          join(appDir, '.next/server/app/route1/route.js.nft.json')\n+        )\n+\n+        expect(appDirRoute1Trace.files).toContain(\n+          '../../../../../other/included.txt'\n+        )\n+      })\n+    }\n+  )\n+})"
        },
        {
            "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
            "filename": "test/integration/build-trace-extra-entries/app/include-me-global.txt",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Finclude-me-global.txt",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Finclude-me-global.txt",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Finclude-me-global.txt?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a"
        },
        {
            "sha": "ec92418ecfa39e1d744120773cc5adf4a86c60d0",
            "filename": "test/integration/build-trace-extra-entries/app/next.config.js",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnext.config.js?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
            "patch": "@@ -2,7 +2,6 @@ const path = require('path')\n \n module.exports = {\n   webpack(cfg, { isServer, nextRuntime }) {\n-    console.log(cfg.entry)\n     const origEntry = cfg.entry\n     cfg.entry = async () => {\n       const origEntries = await origEntry()\n@@ -13,15 +12,15 @@ module.exports = {\n           path.join(__dirname, 'lib/get-data.js'),\n           ...curEntry,\n         ]\n-        console.log(origEntries)\n       }\n       return origEntries\n     }\n     return cfg\n   },\n   outputFileTracingIncludes: {\n     '/index': ['include-me/**/*'],\n-    '/route1': ['./include-me/**/*'],\n+    '/route1': ['./include-me/**/*', 'node_modules/pkg-behind-symlink/*'],\n+    '/*': ['include-me-global.txt'],\n   },\n   outputFileTracingExcludes: {\n     '/index': ['public/exclude-me/**/*'],"
        },
        {
            "sha": "0c6117d9fb83be5d944c757c10508e44b4cf2b30",
            "filename": "test/integration/build-trace-extra-entries/app/node_modules/pkg-behind-symlink",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnode_modules%2Fpkg-behind-symlink",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnode_modules%2Fpkg-behind-symlink",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnode_modules%2Fpkg-behind-symlink?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
            "patch": "@@ -0,0 +1 @@\n+pkg\n\\ No newline at end of file"
        },
        {
            "sha": "2a215466ca9a29b7897c9dba3e60f6dbcbc5ee35",
            "filename": "test/integration/build-trace-extra-entries/app/node_modules/pkg/index.js",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnode_modules%2Fpkg%2Findex.js",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnode_modules%2Fpkg%2Findex.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnode_modules%2Fpkg%2Findex.js?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
            "patch": "@@ -0,0 +1 @@\n+module.exports = 'pkg'"
        },
        {
            "sha": "486738460268fbda2b5a4b26b8e0526b6119e4a6",
            "filename": "test/integration/build-trace-extra-entries/app/node_modules/pkg/package.json",
            "status": "added",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnode_modules%2Fpkg%2Fpackage.json",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnode_modules%2Fpkg%2Fpackage.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fbuild-trace-extra-entries%2Fapp%2Fnode_modules%2Fpkg%2Fpackage.json?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
            "patch": "@@ -0,0 +1,4 @@\n+{\n+  \"name\": \"pkg\",\n+  \"main\": \"./index.js\"\n+}"
        },
        {
            "sha": "53beaec5c5c336caf97bea5fdca154ff650fec7c",
            "filename": "test/integration/build-trace-extra-entries/test/index.test.js",
            "status": "modified",
            "additions": 45,
            "deletions": 8,
            "changes": 53,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/test%2Fintegration%2Fbuild-trace-extra-entries%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fbuild-trace-extra-entries%2Ftest%2Findex.test.js?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
            "patch": "@@ -16,7 +16,6 @@ describe('build trace with extra entries', () => {\n           stderr: true,\n           stdout: true,\n         })\n-        console.log(result)\n         expect(result.code).toBe(0)\n \n         const appTrace = await fs.readJSON(\n@@ -41,16 +40,26 @@ describe('build trace with extra entries', () => {\n         expect(appDirRoute1Trace.files).toContain(\n           '../../../../include-me/second.txt'\n         )\n+        expect(\n+          appDirRoute1Trace.files.some(\n+            (file) => file === '../../../../include-me-global.txt'\n+          )\n+        ).toBe(true)\n         expect(\n           appDirRoute1Trace.files.some((file) => file.includes('exclude-me'))\n         ).toBe(false)\n-\n-        // Skip hello.json check for Turbopack as it doesn't support webpack entry modifications\n-        if (!process.env.TURBOPACK_BUILD) {\n-          expect(\n-            appTrace.files.some((file) => file.endsWith('hello.json'))\n-          ).toBe(true)\n-        }\n+        expect(appDirRoute1Trace.files).toEqual(\n+          expect.arrayContaining([\n+            '../../../../node_modules/pkg-behind-symlink/index.js',\n+            '../../../../node_modules/pkg-behind-symlink/package.json',\n+          ])\n+        )\n+        // This assertion not really needed, but ensures consistency between Turbopack and Webpack\n+        expect(\n+          appDirRoute1Trace.files.some((file) =>\n+            file.startsWith('../../../../node_modules/pkg/')\n+          )\n+        ).toBe(false)\n \n         expect(\n           indexTrace.files.filter(\n@@ -62,12 +71,24 @@ describe('build trace with extra entries', () => {\n           ).length\n         )\n \n+        // Skip hello.json check for Turbopack as it doesn't support webpack entry modifications\n+        if (!process.env.TURBOPACK_BUILD) {\n+          expect(\n+            appTrace.files.some((file) => file.endsWith('hello.json'))\n+          ).toBe(true)\n+        }\n         // Skip lib/get-data.js check for Turbopack as it doesn't support webpack entry modifications\n         if (!process.env.TURBOPACK_BUILD) {\n           expect(\n             appTrace.files.some((file) => file.endsWith('lib/get-data.js'))\n           ).toBe(true)\n         }\n+        expect(\n+          appTrace.files.some(\n+            (file) => file === '../../../include-me-global.txt'\n+          )\n+        ).toBe(true)\n+\n         expect(\n           indexTrace.files.some((file) => file.endsWith('hello.json'))\n         ).toBeFalsy()\n@@ -90,6 +111,11 @@ describe('build trace with extra entries', () => {\n         expect(\n           indexTrace.files.some((file) => file.includes('exclude-me'))\n         ).toBe(false)\n+        expect(\n+          indexTrace.files.some(\n+            (file) => file === '../../../include-me-global.txt'\n+          )\n+        ).toBe(true)\n \n         expect(\n           anotherTrace.files.some((file) =>\n@@ -106,12 +132,23 @@ describe('build trace with extra entries', () => {\n             file.includes('nested-structure/dist/constants.js')\n           )\n         ).toBe(true)\n+        expect(\n+          anotherTrace.files.some(\n+            (file) => file === '../../../include-me-global.txt'\n+          )\n+        ).toBe(true)\n+\n         expect(\n           imageTrace.files.some((file) => file.includes('public/another.jpg'))\n         ).toBe(true)\n         expect(\n           imageTrace.files.some((file) => file.includes('public/test.jpg'))\n         ).toBe(false)\n+        expect(\n+          imageTrace.files.some(\n+            (file) => file === '../../../include-me-global.txt'\n+          )\n+        ).toBe(true)\n       })\n     }\n   )"
        },
        {
            "sha": "9a17774a49c37a15549a0470f0eba081790dc228",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
            "patch": "@@ -1249,6 +1249,8 @@ impl FileSystemPath {\n         Ok(None)\n     }\n \n+    /// DETERMINISM: Result is in random order. Either sort result or do not depend\n+    /// on the order.\n     pub fn read_glob(&self, glob: Vc<Glob>) -> Vc<ReadGlobResult> {\n         read_glob(self.clone(), glob)\n     }"
        },
        {
            "sha": "a65cd72fc50eaed737b01cb7b92105ac3c964a48",
            "filename": "turbopack/crates/turbo-tasks-fs/src/read_glob.rs",
            "status": "modified",
            "additions": 121,
            "deletions": 49,
            "changes": 170,
            "blob_url": "https://github.com/vercel/next.js/blob/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/7f20cbd68d3ee2da40bcd0775cf024414c5da34a/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fread_glob.rs?ref=7f20cbd68d3ee2da40bcd0775cf024414c5da34a",
            "patch": "@@ -4,16 +4,18 @@ use rustc_hash::FxHashMap;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{Completion, ResolvedVc, TryJoinIterExt, Vc};\n \n-use crate::{DirectoryContent, DirectoryEntry, FileSystem, FileSystemPath, glob::Glob};\n+use crate::{\n+    DirectoryContent, DirectoryEntry, FileSystem, FileSystemPath, LinkContent, LinkType, glob::Glob,\n+};\n \n #[turbo_tasks::value]\n #[derive(Default, Debug)]\n pub struct ReadGlobResult {\n-    pub results: FxHashMap<String, DirectoryEntry>,\n-    pub inner: FxHashMap<String, ResolvedVc<ReadGlobResult>>,\n+    pub results: FxHashMap<RcStr, DirectoryEntry>,\n+    pub inner: FxHashMap<RcStr, ResolvedVc<ReadGlobResult>>,\n }\n \n-/// Reads matches of a glob pattern.\n+/// Reads matches of a glob pattern. Symlinks are not resolved (and returned as-is)\n ///\n /// DETERMINISM: Result is in random order. Either sort result or do not depend\n /// on the order.\n@@ -40,29 +42,64 @@ async fn read_glob_internal(\n     let dir = directory.read_dir().await?;\n     let mut result = ReadGlobResult::default();\n     let glob_value = glob.await?;\n+    let handle_file = |result: &mut ReadGlobResult,\n+                       entry_path: &RcStr,\n+                       segment: &RcStr,\n+                       entry: &DirectoryEntry| {\n+        if glob_value.matches(entry_path) {\n+            result.results.insert(segment.clone(), entry.clone());\n+        }\n+    };\n+    let handle_dir = async |result: &mut ReadGlobResult,\n+                            entry_path: RcStr,\n+                            segment: &RcStr,\n+                            path: &FileSystemPath| {\n+        if glob_value.can_match_in_directory(&entry_path) {\n+            result.inner.insert(\n+                segment.clone(),\n+                read_glob_inner(entry_path, path.clone(), glob)\n+                    .to_resolved()\n+                    .await?,\n+            );\n+        }\n+        anyhow::Ok(())\n+    };\n+\n     match &*dir {\n         DirectoryContent::Entries(entries) => {\n             for (segment, entry) in entries.iter() {\n-                // This is redundant with logic inside of `read_dir` but here we track it separately\n-                // so we don't follow symlinks.\n                 let entry_path: RcStr = if prefix.is_empty() {\n                     segment.clone()\n                 } else {\n                     format!(\"{prefix}/{segment}\").into()\n                 };\n-                let entry = resolve_symlink_safely(entry.clone()).await?;\n-                if glob_value.matches(&entry_path) {\n-                    result.results.insert(entry_path.to_string(), entry.clone());\n-                }\n-                if let DirectoryEntry::Directory(path) = entry\n-                    && glob_value.can_match_in_directory(&entry_path)\n-                {\n-                    result.inner.insert(\n-                        entry_path.to_string(),\n-                        read_glob_inner(entry_path, path.clone(), glob)\n-                            .to_resolved()\n-                            .await?,\n-                    );\n+\n+                match entry {\n+                    DirectoryEntry::File(_) => {\n+                        handle_file(&mut result, &entry_path, segment, entry);\n+                    }\n+                    DirectoryEntry::Directory(path) => {\n+                        // Add the directory to `results` if it is a whole match of the glob\n+                        handle_file(&mut result, &entry_path, segment, entry);\n+                        // Recursively handle the directory\n+                        handle_dir(&mut result, entry_path, segment, path).await?;\n+                    }\n+                    DirectoryEntry::Symlink(path) => {\n+                        if let LinkContent::Link { link_type, .. } = &*path.read_link().await? {\n+                            if link_type.contains(LinkType::DIRECTORY) {\n+                                // Ensure that there are no infinite link loops, but don't resolve\n+                                resolve_symlink_safely(entry.clone()).await?;\n+\n+                                // Add the directory to `results` if it is a whole match of the glob\n+                                handle_file(&mut result, &entry_path, segment, entry);\n+                                // Recursively handle the directory\n+                                handle_dir(&mut result, entry_path, segment, path).await?;\n+                            } else {\n+                                handle_file(&mut result, &entry_path, segment, entry);\n+                            }\n+                        }\n+                    }\n+                    DirectoryEntry::Other(_) | DirectoryEntry::Error => continue,\n                 }\n             }\n         }\n@@ -71,7 +108,7 @@ async fn read_glob_internal(\n     Ok(ReadGlobResult::cell(result))\n }\n \n-// Resolve a symlink checking for recursion.\n+/// Resolve a symlink checking for recursion.\n async fn resolve_symlink_safely(entry: DirectoryEntry) -> Result<DirectoryEntry> {\n     let resolved_entry = entry.clone().resolve_symlink().await?;\n     if resolved_entry != entry && matches!(&resolved_entry, DirectoryEntry::Directory(_)) {\n@@ -189,8 +226,10 @@ async fn track_glob_internal(\n pub mod tests {\n \n     use std::{\n+        collections::HashMap,\n         fs::{File, create_dir},\n         io::prelude::*,\n+        os::unix::fs::symlink,\n     };\n \n     use turbo_rcstr::{RcStr, rcstr};\n@@ -224,13 +263,9 @@ pub mod tests {\n         ));\n         let path: RcStr = scratch.path().to_str().unwrap().into();\n         tt.run_once(async {\n-            let fs = Vc::upcast::<Box<dyn FileSystem>>(DiskFileSystem::new(rcstr!(\"temp\"), path));\n-            let read_dir = fs\n-                .root()\n-                .await?\n-                .read_glob(Glob::new(rcstr!(\"**\")))\n-                .await\n-                .unwrap();\n+            let fs = DiskFileSystem::new(rcstr!(\"temp\"), path);\n+            let root = fs.root().await?;\n+            let read_dir = root.read_glob(Glob::new(rcstr!(\"**\"))).await.unwrap();\n             assert_eq!(read_dir.results.len(), 2);\n             assert_eq!(\n                 read_dir.results.get(\"foo\"),\n@@ -244,26 +279,22 @@ pub mod tests {\n             let inner = &*read_dir.inner.get(\"sub\").unwrap().await?;\n             assert_eq!(inner.results.len(), 1);\n             assert_eq!(\n-                inner.results.get(\"sub/bar\"),\n+                inner.results.get(\"bar\"),\n                 Some(&DirectoryEntry::File(fs.root().await?.join(\"sub/bar\")?))\n             );\n             assert_eq!(inner.inner.len(), 0);\n \n             // Now with a more specific pattern\n-            let read_dir = fs\n-                .root()\n-                .await?\n-                .read_glob(Glob::new(rcstr!(\"**/bar\")))\n-                .await\n-                .unwrap();\n+            let read_dir = root.read_glob(Glob::new(rcstr!(\"**/bar\"))).await.unwrap();\n             assert_eq!(read_dir.results.len(), 0);\n             assert_eq!(read_dir.inner.len(), 1);\n             let inner = &*read_dir.inner.get(\"sub\").unwrap().await?;\n             assert_eq!(inner.results.len(), 1);\n             assert_eq!(\n-                inner.results.get(\"sub/bar\"),\n+                inner.results.get(\"bar\"),\n                 Some(&DirectoryEntry::File(fs.root().await?.join(\"sub/bar\")?))\n             );\n+\n             assert_eq!(inner.inner.len(), 0);\n \n             anyhow::Ok(())\n@@ -278,35 +309,76 @@ pub mod tests {\n         crate::register();\n         let scratch = tempfile::tempdir().unwrap();\n         {\n-            use std::os::unix::fs::symlink;\n-\n-            // Create a simple directory with 1 file and a symlink pointing at at a file in a\n-            // subdirectory\n+            // root.js\n+            // sub/foo.js\n+            // sub/link-foo.js -> ./foo.js\n+            // sub/link-root.js -> ../root.js\n             let path = scratch.path();\n             create_dir(path.join(\"sub\")).unwrap();\n             let foo = path.join(\"sub/foo.js\");\n             File::create_new(&foo).unwrap().write_all(b\"foo\").unwrap();\n-            symlink(&foo, path.join(\"link.js\")).unwrap();\n+            symlink(&foo, path.join(\"sub/link-foo.js\")).unwrap();\n+\n+            let root = path.join(\"root.js\");\n+            File::create_new(&root).unwrap().write_all(b\"root\").unwrap();\n+            symlink(&root, path.join(\"sub/link-root.js\")).unwrap();\n+\n+            let dir = path.join(\"dir\");\n+            create_dir(&dir).unwrap();\n+            File::create_new(dir.join(\"index.js\"))\n+                .unwrap()\n+                .write_all(b\"dir index\")\n+                .unwrap();\n+            symlink(&dir, path.join(\"sub/dir\")).unwrap();\n         }\n         let tt = turbo_tasks::TurboTasks::new(TurboTasksBackend::new(\n             BackendOptions::default(),\n             noop_backing_storage(),\n         ));\n         let path: RcStr = scratch.path().to_str().unwrap().into();\n         tt.run_once(async {\n-            let fs = Vc::upcast::<Box<dyn FileSystem>>(DiskFileSystem::new(rcstr!(\"temp\"), path));\n-            let read_dir = fs\n-                .root()\n-                .await?\n-                .read_glob(Glob::new(rcstr!(\"*.js\")))\n+            let fs = DiskFileSystem::new(rcstr!(\"temp\"), path);\n+            let root = fs.root().await?;\n+            // Symlinked files\n+            let read_dir = root.read_glob(Glob::new(rcstr!(\"sub/*.js\"))).await.unwrap();\n+            assert_eq!(read_dir.results.len(), 0);\n+            let inner = &*read_dir.inner.get(\"sub\").unwrap().await?;\n+            assert_eq!(\n+                inner.results,\n+                HashMap::from_iter([\n+                    (\n+                        \"link-foo.js\".into(),\n+                        DirectoryEntry::Symlink(root.join(\"sub/link-foo.js\")?),\n+                    ),\n+                    (\n+                        \"link-root.js\".into(),\n+                        DirectoryEntry::Symlink(root.join(\"sub/link-root.js\")?),\n+                    ),\n+                    (\n+                        \"foo.js\".into(),\n+                        DirectoryEntry::File(root.join(\"sub/foo.js\")?),\n+                    ),\n+                ])\n+            );\n+            assert_eq!(inner.inner.len(), 0);\n+\n+            // A symlinked folder\n+            let read_dir = root\n+                .read_glob(Glob::new(rcstr!(\"sub/dir/*\")))\n                 .await\n                 .unwrap();\n-            assert_eq!(read_dir.results.len(), 1);\n+            assert_eq!(read_dir.results.len(), 0);\n+            let inner_sub = &*read_dir.inner.get(\"sub\").unwrap().await?;\n+            assert_eq!(inner_sub.results.len(), 0);\n+            let inner_sub_dir = &*inner_sub.inner.get(\"dir\").unwrap().await?;\n             assert_eq!(\n-                read_dir.results.get(\"link.js\"),\n-                Some(&DirectoryEntry::File(fs.root().await?.join(\"sub/foo.js\")?))\n+                inner_sub_dir.results,\n+                HashMap::from_iter([(\n+                    \"index.js\".into(),\n+                    DirectoryEntry::File(root.join(\"sub/dir/index.js\")?),\n+                )])\n             );\n-            assert_eq!(read_dir.inner.len(), 0);\n+            assert_eq!(inner_sub_dir.inner.len(), 0);\n \n             anyhow::Ok(())\n         })"
        }
    ],
    "stats": {
        "total": 287,
        "additions": 224,
        "deletions": 63
    }
}