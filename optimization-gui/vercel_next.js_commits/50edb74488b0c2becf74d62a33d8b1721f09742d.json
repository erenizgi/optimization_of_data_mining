{
    "author": "wyattjoh",
    "message": "[ppr] RDC for RSCs (redo) (#80853)\n\n## What?\n\nThis PR introduces the Resume Data Cache (RDC) functionality to improve\nhandling of dynamic React Server Component (RSC) requests when Partial\nPre-rendering (PPR) is enabled. This enhancement enables dynamic RSC\nresponses to utilize the Resume Data Cache, significantly reducing\nwaterfalls and preventing content shearing.\n\n## Why?\n\nPreviously, dynamic RSC requests with PPR enabled experienced several\nissues:\n\n**Waterfall Reduction:** Dynamic RSC responses required multiple\nwaterfalls to hydrate a given cache, leading to slower response times\nand unnecessary network round-trips.\n\n**Content Shearing Prevention:** There were mismatches between static\ncached parts of the page and the dynamic response, causing visual\ninconsistencies and potential hydration errors. By ensuring the RDC\ngenerated for static responses is also used for dynamic RSC responses,\nwe maintain consistency even when the dynamic response interacts with\ncaches directly and potentially receives newer, non-stale values.\n\n**Additional Issues Addressed:**\n- Stale content revalidation not triggering correctly\n- Background revalidation producing dynamic responses instead of static\nones\n- Inconsistent cache tag staleness evaluation\n- Missing support for resumable rendering in dynamic contexts\n\n## How?\n\n**Core Implementation:**\n- Added Resume Data Cache layer that stores resumable render data for\ndynamic RSC requests\n- Ensures the same RDC used by static responses is reused for dynamic\nRSC responses\n- Introduced `forceStaticRender` flag to ensure background revalidation\ngenerates static responses\n- Refactored response cache internals to separate cache entry creation\nfrom response handling\n- Enhanced error handling with try-catch blocks for server actions in\napp-render\n\n**Revalidation Improvements:**\n- Fixed cache tag staleness evaluation for consistent behavior\n- Improved triggering logic for background revalidation of stale dynamic\ncontent\n- Better handling of cache misses and \"no-resume-data\" scenarios with\ndebug logging\n\n---------\n\nCo-authored-by: graphite-app[bot] <96075541+graphite-app[bot]@users.noreply.github.com>",
    "sha": "50edb74488b0c2becf74d62a33d8b1721f09742d",
    "files": [
        {
            "sha": "ffc9dc6ef41d96c4a9ad0d96b4ad6bb7c35c0b98",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -795,5 +795,8 @@\n   \"794\": \"Invalid <Link> with <a> child. Please remove <a>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\",\n   \"795\": \"\\\\`%s\\\\` was called from a Server Component. Next.js should be preventing %s from being included in server components statically, but did not in this case.\",\n   \"796\": \"Page \\\"%s\\\" cannot use \\\\`export const unstable_prefetch = ...\\\\` without enabling \\\\`experimental.cacheComponents\\\\` and \\\\`experimental.clientSegmentCache\\\\`.\",\n-  \"797\": \"Failed to transpile \\\"%s\\\".\"\n+  \"797\": \"Failed to transpile \\\"%s\\\".\",\n+  \"798\": \"expected a result to be returned\",\n+  \"799\": \"expected a page response, got %s\",\n+  \"800\": \"`experimental.rdcForNavigations` is enabled, but `experimental.ppr` is not.\"\n }"
        },
        {
            "sha": "54af4542b158974697877b534eba6e7d4da3624c",
            "filename": "packages/next/next-runtime.webpack-config.js",
            "status": "modified",
            "additions": 21,
            "deletions": 12,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fnext-runtime.webpack-config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fnext-runtime.webpack-config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fnext-runtime.webpack-config.js?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -172,7 +172,12 @@ module.exports = ({ dev, turbo, bundleType, experimental, ...rest }) => {\n   return {\n     entry: bundleTypes[bundleType],\n     target: 'node',\n-    mode: dev ? 'development' : 'production',\n+    mode:\n+      process.env.NEXT_DEBUG_INTERNALS === 'true'\n+        ? 'development'\n+        : dev\n+          ? 'development'\n+          : 'production',\n     output: {\n       path: path.join(__dirname, 'dist/compiled/next-server'),\n       filename: `[name]${turbo ? '-turbo' : ''}${\n@@ -181,18 +186,22 @@ module.exports = ({ dev, turbo, bundleType, experimental, ...rest }) => {\n       libraryTarget: 'commonjs2',\n     },\n     devtool: 'source-map',\n-    optimization: {\n-      moduleIds: 'named',\n-      minimize: true,\n-      concatenateModules: true,\n-      minimizer: [\n-        new webpack.SwcJsMinimizerRspackPlugin({\n-          minimizerOptions: {\n-            mangle: dev || process.env.NEXT_SERVER_NO_MANGLE ? false : true,\n+    optimization:\n+      process.env.NEXT_DEBUG_INTERNALS === 'true'\n+        ? undefined\n+        : {\n+            moduleIds: 'named',\n+            minimize: true,\n+            concatenateModules: true,\n+            minimizer: [\n+              new webpack.SwcJsMinimizerRspackPlugin({\n+                minimizerOptions: {\n+                  mangle:\n+                    dev || process.env.NEXT_SERVER_NO_MANGLE ? false : true,\n+                },\n+              }),\n+            ],\n           },\n-        }),\n-      ],\n-    },\n     plugins: [\n       new DevToolsIgnoreListPlugin({ shouldIgnorePath }),\n       new webpack.DefinePlugin({"
        },
        {
            "sha": "98445016602e5b4f43c326d9e3d0467fcada7579",
            "filename": "packages/next/src/build/index.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Findex.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -480,6 +480,7 @@ export type RoutesManifest = {\n      * rewrites will get the rewrite headers.\n      */\n     clientParamParsingOrigins: string[] | undefined\n+    dynamicRSCPrerender: boolean\n   }\n   rewriteHeaders: {\n     pathHeader: typeof NEXT_REWRITTEN_PATH_HEADER\n@@ -1567,6 +1568,17 @@ export default async function build(\n               clientParamParsingOrigins: config.experimental.clientParamParsing\n                 ? config.experimental.clientParamParsingOrigins\n                 : undefined,\n+              dynamicRSCPrerender:\n+                // Only enable RDC for Navigations if the feature is enabled.\n+                // Once we've made RDC for Navigations the default for PPR, we\n+                // can remove the check for `config.experimental.rdcForNavigations`.\n+                isAppPPREnabled &&\n+                config.experimental.rdcForNavigations === true &&\n+                // Temporarily we require that clientParamParsing is enabled for\n+                // RDC for Navigations. This is due to a builder configuration\n+                // bug that manifests as invalid query params being passed to\n+                // the resume lambdas.\n+                config.experimental.clientParamParsing === true,\n             },\n             rewriteHeaders: {\n               pathHeader: NEXT_REWRITTEN_PATH_HEADER,"
        },
        {
            "sha": "042454bef937789a40590b8e29da41ecf7b80915",
            "filename": "packages/next/src/build/templates/app-page.ts",
            "status": "modified",
            "additions": 187,
            "deletions": 71,
            "changes": 258,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Ftemplates%2Fapp-page.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -39,6 +39,7 @@ import {\n import { getBotType, isBot } from '../../shared/lib/router/utils/is-bot'\n import {\n   CachedRouteKind,\n+  IncrementalCacheKind,\n   type CachedAppPageValue,\n   type CachedPageValue,\n   type ResponseCacheEntry,\n@@ -87,6 +88,7 @@ export const __next_app__ = {\n import * as entryBase from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\n import { RedirectStatusCode } from '../../client/components/redirect-status-code'\n import { InvariantError } from '../../shared/lib/invariant-error'\n+import { scheduleOnNextTick } from '../../lib/scheduler'\n \n export * from '../../server/app-render/entry-base' with { 'turbopack-transition': 'next-server-utility' }\n \n@@ -129,7 +131,6 @@ export async function handler(\n   const multiZoneDraftMode = process.env\n     .__NEXT_MULTI_ZONE_DRAFT_MODE as any as boolean\n \n-  const initialPostponed = getRequestMeta(req, 'postponed')\n   // TODO: replace with more specific flags\n   const minimalMode = getRequestMeta(req, 'minimalMode')\n \n@@ -174,12 +175,6 @@ export async function handler(\n   const prerenderInfo = routeModule.match(pathname, prerenderManifest)\n   const isPrerendered = !!prerenderManifest.routes[resolvedPathname]\n \n-  let isSSG = Boolean(\n-    prerenderInfo ||\n-      isPrerendered ||\n-      prerenderManifest.routes[normalizedSrcPage]\n-  )\n-\n   const userAgent = req.headers['user-agent'] || ''\n   const botType = getBotType(userAgent)\n   const isHtmlBot = isHtmlBotRequest(req)\n@@ -248,7 +243,9 @@ export async function handler(\n   // If we're in minimal mode, then try to get the postponed information from\n   // the request metadata. If available, use it for resuming the postponed\n   // render.\n-  const minimalPostponed = isRoutePPREnabled ? initialPostponed : undefined\n+  const minimalPostponed = isRoutePPREnabled\n+    ? getRequestMeta(req, 'postponed')\n+    : undefined\n \n   // If PPR is enabled, and this is a RSC request (but not a prefetch), then\n   // we can use this fact to only generate the flight data for the request\n@@ -266,17 +263,35 @@ export async function handler(\n   // being true for a revalidate due to modifying the base-server this.renderOpts\n   // when fixing this to correct logic it causes hydration issue since we set\n   // serveStreamingMetadata to true during export\n-  let serveStreamingMetadata = !userAgent\n-    ? true\n-    : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots)\n+  const serveStreamingMetadata =\n+    isHtmlBot && isRoutePPREnabled\n+      ? false\n+      : !userAgent\n+        ? true\n+        : shouldServeStreamingMetadata(userAgent, nextConfig.htmlLimitedBots)\n+\n+  const isSSG = Boolean(\n+    (prerenderInfo ||\n+      isPrerendered ||\n+      prerenderManifest.routes[normalizedSrcPage]) &&\n+      // If this is a html bot request and PPR is enabled, then we don't want\n+      // to serve a static response.\n+      !(isHtmlBot && isRoutePPREnabled)\n+  )\n \n-  if (isHtmlBot && isRoutePPREnabled) {\n-    isSSG = false\n-    serveStreamingMetadata = false\n-  }\n+  // When a page supports PPR, we can support RSC for Navigations so long as the\n+  // feature is not disabled.\n+  const supportsRSCForNavigations =\n+    isRoutePPREnabled &&\n+    nextConfig.experimental.rdcForNavigations === true &&\n+    // Temporarily we require that clientParamParsing is enabled for\n+    // RDC for Navigations. This is due to a builder configuration\n+    // bug that manifests as invalid query params being passed to\n+    // the resume lambdas.\n+    nextConfig.experimental.clientParamParsing === true\n \n   // In development, we always want to generate dynamic HTML.\n-  let supportsDynamicResponse: boolean =\n+  const supportsDynamicResponse: boolean =\n     // If we're in development, we always support dynamic HTML, unless it's\n     // a data request, in which case we only produce static HTML.\n     routeModule.isDev === true ||\n@@ -285,10 +300,18 @@ export async function handler(\n     !isSSG ||\n     // If this request has provided postponed data, it supports dynamic\n     // HTML.\n-    typeof initialPostponed === 'string' ||\n-    // If this is a dynamic RSC request, then this render supports dynamic\n-    // HTML (it's dynamic).\n-    isDynamicRSCRequest\n+    typeof minimalPostponed === 'string' ||\n+    // If this handler supports onCacheEntryV2, then we can only support\n+    // dynamic responses if it's a dynamic RSC request and not in minimal mode. If it\n+    // doesn't support it we must fallback to the default behavior.\n+    (supportsRSCForNavigations && getRequestMeta(req, 'onCacheEntryV2')\n+      ? // In minimal mode, we'll always want to generate a static response\n+        // which will generate the RDC for the route. When resuming a Dynamic\n+        // RSC request, we'll pass the minimal postponed data to the render\n+        // which will trigger the `supportsDynamicResponse` to be true.\n+        isDynamicRSCRequest && !minimalMode\n+      : // Otherwise, we can support dynamic responses if it's a dynamic RSC request.\n+        isDynamicRSCRequest)\n \n   // When html bots request PPR page, perform the full dynamic rendering.\n   const shouldWaitOnAllReady = isHtmlBot && isRoutePPREnabled\n@@ -429,12 +452,16 @@ export async function handler(\n       })\n     }\n \n+    const incrementalCache = getRequestMeta(req, 'incrementalCache')\n+\n     const doRender = async ({\n       span,\n       postponed,\n       fallbackRouteParams,\n+      forceStaticRender,\n     }: {\n       span?: Span\n+\n       /**\n        * The postponed data for this render. This is only provided when resuming\n        * a render that has been postponed.\n@@ -445,6 +472,15 @@ export async function handler(\n        * The unknown route params for this render.\n        */\n       fallbackRouteParams: OpaqueFallbackRouteParams | null\n+\n+      /**\n+       * When true, this indicates that the response generator is being called\n+       * in a context where the response must be generated statically.\n+       *\n+       * CRITICAL: This should only currently be used when revalidating due to a\n+       * dynamic RSC request.\n+       */\n+      forceStaticRender: boolean\n     }): Promise<ResponseCacheEntry> => {\n       const context: AppPageRouteHandlerContext = {\n         query,\n@@ -507,7 +543,7 @@ export async function handler(\n           reactMaxHeadersLength: nextConfig.reactMaxHeadersLength,\n \n           multiZoneDraftMode,\n-          incrementalCache: getRequestMeta(req, 'incrementalCache'),\n+          incrementalCache,\n           cacheLifeProfiles: nextConfig.experimental.cacheLife,\n           basePath: nextConfig.basePath,\n           serverActions: nextConfig.experimental.serverActions,\n@@ -562,6 +598,19 @@ export async function handler(\n         },\n       }\n \n+      if (isDebugStaticShell || isDebugDynamicAccesses) {\n+        context.renderOpts.nextExport = true\n+        context.renderOpts.supportsDynamicResponse = false\n+        context.renderOpts.isRevalidate = true\n+        context.renderOpts.isDebugDynamicAccesses = isDebugDynamicAccesses\n+      }\n+\n+      // When we're revalidating in the background, we should not allow dynamic\n+      // responses.\n+      if (forceStaticRender) {\n+        context.renderOpts.supportsDynamicResponse = false\n+      }\n+\n       const result = await invokeRouteModule(span, context)\n \n       const { metadata } = result\n@@ -571,14 +620,15 @@ export async function handler(\n         headers = {},\n         // Add any fetch tags that were on the page to the response headers.\n         fetchTags: cacheTags,\n+        fetchMetrics,\n       } = metadata\n \n       if (cacheTags) {\n         headers[NEXT_CACHE_TAGS_HEADER] = cacheTags\n       }\n \n       // Pull any fetch metrics from the render onto the request.\n-      ;(req as any).fetchMetrics = metadata.fetchMetrics\n+      ;(req as any).fetchMetrics = fetchMetrics\n \n       // we don't throw static to dynamic errors in dev as isSSG\n       // is a best guess in dev since we don't have the prerender pass\n@@ -624,9 +674,10 @@ export async function handler(\n \n     const responseGenerator: ResponseGenerator = async ({\n       hasResolved,\n-      previousCacheEntry,\n+      previousCacheEntry: previousIncrementalCacheEntry,\n       isRevalidating,\n       span,\n+      forceStaticRender = false,\n     }) => {\n       const isProduction = routeModule.isDev === false\n       const didRespond = hasResolved || res.writableEnded\n@@ -636,7 +687,7 @@ export async function handler(\n       if (\n         isOnDemandRevalidate &&\n         revalidateOnlyGenerated &&\n-        !previousCacheEntry &&\n+        !previousIncrementalCacheEntry &&\n         !minimalMode\n       ) {\n         if (routerServerContext?.render404) {\n@@ -663,7 +714,7 @@ export async function handler(\n         }\n       }\n \n-      if (previousCacheEntry?.isStale === -1) {\n+      if (previousIncrementalCacheEntry?.isStale === -1) {\n         isOnDemandRevalidate = true\n       }\n \n@@ -672,7 +723,8 @@ export async function handler(\n       // or for prerendered fallback: false paths\n       if (\n         isOnDemandRevalidate &&\n-        (fallbackMode !== FallbackMode.NOT_FOUND || previousCacheEntry)\n+        (fallbackMode !== FallbackMode.NOT_FOUND ||\n+          previousIncrementalCacheEntry)\n       ) {\n         fallbackMode = FallbackMode.BLOCKING_STATIC_RENDER\n       }\n@@ -744,6 +796,7 @@ export async function handler(\n                 // here.\n                 postponed: undefined,\n                 fallbackRouteParams,\n+                forceStaticRender: false,\n               }),\n             waitUntil: ctx.waitUntil,\n           })\n@@ -764,11 +817,100 @@ export async function handler(\n \n       // Only requests that aren't revalidating can be resumed. If we have the\n       // minimal postponed data, then we should resume the render with it.\n-      const postponed =\n+      let postponed =\n         !isOnDemandRevalidate && !isRevalidating && minimalPostponed\n           ? minimalPostponed\n           : undefined\n \n+      // If this is a dynamic RSC request, we should use the postponed data from\n+      // the static render (if available). This ensures that we can utilize the\n+      // resume data cache (RDC) from the static render to ensure that the data\n+      // is consistent between the static and dynamic renders.\n+      if (\n+        // Only enable RDC for Navigations if the feature is enabled.\n+        supportsRSCForNavigations &&\n+        process.env.NEXT_RUNTIME !== 'edge' &&\n+        !minimalMode &&\n+        incrementalCache &&\n+        isDynamicRSCRequest &&\n+        // We don't typically trigger an on-demand revalidation for dynamic RSC\n+        // requests, as we're typically revalidating the page in the background\n+        // instead. However, if the cache entry is stale, we should trigger a\n+        // background revalidation on dynamic RSC requests. This prevents us\n+        // from entering an infinite loop of revalidations.\n+        !forceStaticRender\n+      ) {\n+        const incrementalCacheEntry = await incrementalCache.get(\n+          resolvedPathname,\n+          {\n+            kind: IncrementalCacheKind.APP_PAGE,\n+            isRoutePPREnabled: true,\n+            isFallback: false,\n+            // CRITICAL: we need to allow stale here as we'll revalidate in the\n+            // background if it's stale. We _want_ to possibly serve a stale\n+            // response here as it'll be consistent with the static render.\n+            allowStale: true,\n+          }\n+        )\n+\n+        // If the cache entry is found, we should use the postponed data from\n+        // the cache.\n+        if (\n+          incrementalCacheEntry &&\n+          incrementalCacheEntry.value &&\n+          incrementalCacheEntry.value.kind === CachedRouteKind.APP_PAGE\n+        ) {\n+          // CRITICAL: we're assigning the postponed data from the cache entry\n+          // here as we're using the RDC to resume the render.\n+          postponed = incrementalCacheEntry.value.postponed\n+\n+          // If the cache entry is stale, we should trigger a background\n+          // revalidation so that subsequent requests will get a fresh response.\n+          if (\n+            incrementalCacheEntry &&\n+            // We want to trigger this flow if the cache entry is stale and if\n+            // the requested revalidation flow is either foreground or\n+            // background.\n+            (incrementalCacheEntry.isStale === -1 ||\n+              incrementalCacheEntry.isStale === true)\n+          ) {\n+            // We want to schedule this on the next tick to ensure that the\n+            // render is not blocked on it.\n+            scheduleOnNextTick(async () => {\n+              const responseCache = routeModule.getResponseCache(req)\n+\n+              try {\n+                await responseCache.revalidate(\n+                  resolvedPathname,\n+                  incrementalCache,\n+                  isRoutePPREnabled,\n+                  false,\n+                  (c) =>\n+                    responseGenerator({\n+                      ...c,\n+                      // CRITICAL: we need to set this to true as we're\n+                      // revalidating in the background and typically this dynamic\n+                      // RSC request is not treated as static.\n+                      forceStaticRender: true,\n+                    }),\n+                  // CRITICAL: we need to pass null here because passing the\n+                  // previous cache entry here (which is stale) will switch on\n+                  // isOnDemandRevalidate and break the prerendering.\n+                  null,\n+                  hasResolved,\n+                  ctx.waitUntil\n+                )\n+              } catch (err) {\n+                console.error(\n+                  'Error revalidating the page in the background',\n+                  err\n+                )\n+              }\n+            })\n+          }\n+        }\n+      }\n+\n       // When we're in minimal mode, if we're trying to debug the static shell,\n       // we should just return nothing instead of resuming the dynamic render.\n       if (\n@@ -806,6 +948,7 @@ export async function handler(\n         span,\n         postponed,\n         fallbackRouteParams,\n+        forceStaticRender,\n       })\n     }\n \n@@ -898,12 +1041,7 @@ export async function handler(\n       // If this is in minimal mode and this is a flight request that isn't a\n       // prefetch request while PPR is enabled, it cannot be cached as it contains\n       // dynamic content.\n-      else if (\n-        minimalMode &&\n-        isRSCRequest &&\n-        !isPrefetchRSCRequest &&\n-        isRoutePPREnabled\n-      ) {\n+      else if (isDynamicRSCRequest) {\n         cacheControl = { revalidate: 0, expire: undefined }\n       } else if (!routeModule.isDev) {\n         // If this is a preview mode request, we shouldn't cache it\n@@ -1000,35 +1138,19 @@ export async function handler(\n       }\n \n       // If there's a callback for `onCacheEntry`, call it with the cache entry\n-      // and the revalidate options.\n-      const onCacheEntry = getRequestMeta(req, 'onCacheEntry')\n+      // and the revalidate options. If we support RDC for Navigations, we\n+      // prefer the `onCacheEntryV2` callback. Once RDC for Navigations is the\n+      // default, we can remove the fallback to `onCacheEntry` as\n+      // `onCacheEntryV2` is now fully supported.\n+      const onCacheEntry = supportsRSCForNavigations\n+        ? (getRequestMeta(req, 'onCacheEntryV2') ??\n+          getRequestMeta(req, 'onCacheEntry'))\n+        : getRequestMeta(req, 'onCacheEntry')\n       if (onCacheEntry) {\n-        const finished = await onCacheEntry(\n-          {\n-            ...cacheEntry,\n-            // TODO: remove this when upstream doesn't\n-            // always expect this value to be \"PAGE\"\n-            value: {\n-              ...cacheEntry.value,\n-              kind: 'PAGE',\n-            },\n-          },\n-          {\n-            url: getRequestMeta(req, 'initURL'),\n-          }\n-        )\n-        if (finished) {\n-          // TODO: maybe we have to end the request?\n-          return null\n-        }\n-      }\n-\n-      // If the request has a postponed state and it's a resume request we\n-      // should error.\n-      if (didPostpone && minimalPostponed) {\n-        throw new Error(\n-          'Invariant: postponed state should not be present on a resume request'\n-        )\n+        const finished = await onCacheEntry(cacheEntry, {\n+          url: getRequestMeta(req, 'initURL') ?? req.url,\n+        })\n+        if (finished) return null\n       }\n \n       if (cachedData.headers) {\n@@ -1079,7 +1201,7 @@ export async function handler(\n       }\n \n       // Mark that the request did postpone.\n-      if (didPostpone) {\n+      if (didPostpone && !isDynamicRSCRequest) {\n         res.setHeader(NEXT_DID_POSTPONE_HEADER, '1')\n       }\n \n@@ -1118,14 +1240,7 @@ export async function handler(\n             generateEtags: nextConfig.generateEtags,\n             poweredByHeader: nextConfig.poweredByHeader,\n             result: cachedData.html,\n-            // Dynamic RSC responses cannot be cached, even if they're\n-            // configured with `force-static` because we have no way of\n-            // distinguishing between `force-static` and pages that have no\n-            // postponed state.\n-            // TODO: distinguish `force-static` from pages with no postponed state (static)\n-            cacheControl: isDynamicRSCRequest\n-              ? { revalidate: 0, expire: undefined }\n-              : cacheEntry.cacheControl,\n+            cacheControl: cacheEntry.cacheControl,\n           })\n         }\n \n@@ -1145,7 +1260,7 @@ export async function handler(\n       }\n \n       // This is a request for HTML data.\n-      let body = cachedData.html\n+      const body = cachedData.html\n \n       // If there's no postponed state, we should just serve the HTML. This\n       // should also be the case for a resume request because it's completed\n@@ -1224,6 +1339,7 @@ export async function handler(\n         // This is a resume render, not a fallback render, so we don't need to\n         // set this.\n         fallbackRouteParams: null,\n+        forceStaticRender: false,\n       })\n         .then(async (result) => {\n           if (!result) {"
        },
        {
            "sha": "86387dfe47ccbb0c462997fe4b46b2f198a5f4bc",
            "filename": "packages/next/src/lib/batcher.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Flib%2Fbatcher.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Flib%2Fbatcher.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fbatcher.test.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -32,7 +32,7 @@ describe('Batcher', () => {\n \n     it('should not batch calls to different keys', async () => {\n       const batcher = Batcher.create<string, string>()\n-      const workFn = jest.fn((key) => key)\n+      const workFn = jest.fn(({ key }) => Promise.resolve(key))\n \n       const result1 = batcher.batch('key1', workFn)\n       const result2 = batcher.batch('key2', workFn)"
        },
        {
            "sha": "3642b3ffe2fb21de124670e2b6b3d816b1d4a447",
            "filename": "packages/next/src/lib/batcher.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Flib%2Fbatcher.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Flib%2Fbatcher.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Flib%2Fbatcher.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -11,10 +11,12 @@ type BatcherOptions<K, C extends string | number | null> = {\n   schedulerFn?: SchedulerFn<void>\n }\n \n-type WorkFn<V, C> = (\n-  key: C,\n+type WorkFnContext<V, K> = {\n   resolve: (value: V | PromiseLike<V>) => void\n-) => Promise<V>\n+  key: K\n+}\n+\n+type WorkFn<V, K> = (context: WorkFnContext<V, K>) => Promise<V>\n \n /**\n  * A wrapper for a function that will only allow one call to the function to\n@@ -61,10 +63,10 @@ export class Batcher<K, V, C extends string | number | null> {\n    * @param fn the function to wrap\n    * @returns a promise that resolves to the result of the function\n    */\n-  public async batch(key: K, fn: WorkFn<V, C>): Promise<V> {\n+  public async batch(key: K, fn: WorkFn<V, K>): Promise<V> {\n     const cacheKey = (this.cacheKeyFn ? await this.cacheKeyFn(key) : key) as C\n     if (cacheKey === null) {\n-      return fn(cacheKey, Promise.resolve)\n+      return fn({ resolve: (value) => Promise.resolve(value), key })\n     }\n \n     const pending = this.pending.get(cacheKey)\n@@ -75,7 +77,7 @@ export class Batcher<K, V, C extends string | number | null> {\n \n     this.schedulerFn(async () => {\n       try {\n-        const result = await fn(cacheKey, resolve)\n+        const result = await fn({ resolve, key })\n \n         // Resolving a promise multiple times is a no-op, so we can safely\n         // resolve all pending promises with the same result."
        },
        {
            "sha": "ae0a1336db8685b2bc48f443880955c44f963731",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 11,
            "deletions": 2,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -1782,7 +1782,9 @@ async function renderToHTMLOrFlightImpl(\n   } else {\n     // We're rendering dynamically\n     const renderResumeDataCache =\n-      renderOpts.renderResumeDataCache ?? postponedState?.renderResumeDataCache\n+      renderOpts.renderResumeDataCache ??\n+      postponedState?.renderResumeDataCache ??\n+      null\n \n     const rootParams = getRootParams(loaderTree, ctx.getDynamicParamFromSegment)\n     const devValidatingFallbackParams =\n@@ -1843,6 +1845,9 @@ async function renderToHTMLOrFlightImpl(\n \n     let formState: null | any = null\n     if (isPossibleActionRequest) {\n+      // For action requests, we don't want to use the resume data cache.\n+      requestStore.renderResumeDataCache = null\n+\n       // For action requests, we handle them differently with a special render result.\n       const actionRequestResult = await handleAction({\n         req,\n@@ -1887,6 +1892,9 @@ async function renderToHTMLOrFlightImpl(\n           }\n         }\n       }\n+\n+      // Restore the resume data cache\n+      requestStore.renderResumeDataCache = renderResumeDataCache\n     }\n \n     const options: RenderResultOptions = {\n@@ -2071,7 +2079,7 @@ function applyMetadataFromPrerenderResult(\n   }\n \n   // provide bailout info for debugging\n-  if (metadata.cacheControl?.revalidate === 0) {\n+  if (metadata.cacheControl.revalidate === 0) {\n     metadata.staticBailoutInfo = {\n       description: workStore.dynamicUsageDescription,\n       stack: workStore.dynamicUsageStack,\n@@ -3516,6 +3524,7 @@ async function prerenderToStream(\n         'abort',\n         () => {\n           initialServerRenderController.abort()\n+          initialServerPrerenderController.abort()\n         },\n         { once: true }\n       )"
        },
        {
            "sha": "5e4fa3be6e4c2565d54a01c2f6cd99114b6799c3",
            "filename": "packages/next/src/server/async-storage/request-store.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fasync-storage%2Frequest-store.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -115,7 +115,7 @@ export function createRequestStoreForRender(\n   previewProps: WrapperRenderOpts['previewProps'],\n   isHmrRefresh: RequestContext['isHmrRefresh'],\n   serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],\n-  renderResumeDataCache: RenderResumeDataCache | undefined,\n+  renderResumeDataCache: RenderResumeDataCache | null,\n   devFallbackParams: OpaqueFallbackRouteParams | null\n ): RequestStore {\n   return createRequestStoreImpl(\n@@ -151,7 +151,7 @@ export function createRequestStoreForAPI(\n     {},\n     implicitTags,\n     onUpdateCookies,\n-    undefined,\n+    null,\n     previewProps,\n     false,\n     undefined,\n@@ -167,7 +167,7 @@ function createRequestStoreImpl(\n   rootParams: Params,\n   implicitTags: RequestContext['implicitTags'],\n   onUpdateCookies: RenderOpts['onUpdateCookies'],\n-  renderResumeDataCache: RenderResumeDataCache | undefined,\n+  renderResumeDataCache: RenderResumeDataCache | null,\n   previewProps: WrapperRenderOpts['previewProps'],\n   isHmrRefresh: RequestContext['isHmrRefresh'],\n   serverComponentsHmrCache: RequestContext['serverComponentsHmrCache'],"
        },
        {
            "sha": "5e48b0d0603316566f4f902c909dcea8b96d0a11",
            "filename": "packages/next/src/server/config-schema.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-schema.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -374,6 +374,7 @@ export const configSchema: zod.ZodType<NextConfig> = z.lazy(() =>\n         clientSegmentCache: z\n           .union([z.boolean(), z.literal('client-only')])\n           .optional(),\n+        rdcForNavigations: z.boolean().optional(),\n         clientParamParsing: z.boolean().optional(),\n         clientParamParsingOrigins: z.array(z.string()).optional(),\n         dynamicOnHover: z.boolean().optional(),"
        },
        {
            "sha": "b39457f33096ae203c7f5fa60fdac39de55ee4d1",
            "filename": "packages/next/src/server/config-shared.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig-shared.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -466,6 +466,13 @@ export interface ExperimentalConfig {\n   linkNoTouchStart?: boolean\n   caseSensitiveRoutes?: boolean\n   clientSegmentCache?: boolean | 'client-only'\n+\n+  /**\n+   * Enables RDC for Dynamic Navigations. This is only supported for App Router\n+   * when Partial Prerendering is also enabled. This is enabled by default when\n+   * Partial Prerendering is enabled.\n+   */\n+  rdcForNavigations?: boolean\n   clientParamParsing?: boolean\n \n   /**\n@@ -1573,6 +1580,7 @@ export const defaultConfig = Object.freeze({\n     linkNoTouchStart: false,\n     caseSensitiveRoutes: false,\n     clientSegmentCache: false,\n+    rdcForNavigations: false,\n     clientParamParsing: false,\n     clientParamParsingOrigins: undefined,\n     dynamicOnHover: false,"
        },
        {
            "sha": "224196846b4a0d370bc44ea2039f6b7d9bece5ea",
            "filename": "packages/next/src/server/config.test.ts",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.test.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -170,6 +170,46 @@ describe('loadConfig', () => {\n       )\n     })\n \n+    it('errors when rdcForNavigations is enabled but ppr is disabled', async () => {\n+      await expect(\n+        loadConfig('', __dirname, {\n+          customConfig: {\n+            experimental: {\n+              rdcForNavigations: true,\n+              ppr: false,\n+            },\n+          },\n+        })\n+      ).rejects.toThrow(\n+        '`experimental.rdcForNavigations` is enabled, but `experimental.ppr` is not.'\n+      )\n+    })\n+\n+    it('defaults rdcForNavigations to true when ppr is enabled', async () => {\n+      const result = await loadConfig('', __dirname, {\n+        customConfig: {\n+          experimental: {\n+            ppr: true,\n+          },\n+        },\n+      })\n+\n+      expect(result.experimental.rdcForNavigations).toBe(true)\n+    })\n+\n+    it('allows explicitly disabling rdcForNavigations when ppr is enabled', async () => {\n+      const result = await loadConfig('', __dirname, {\n+        customConfig: {\n+          experimental: {\n+            ppr: true,\n+            rdcForNavigations: false,\n+          },\n+        },\n+      })\n+\n+      expect(result.experimental.rdcForNavigations).toBe(false)\n+    })\n+\n     it('errors when cacheComponents is enabled but PPR set to \"incremental\"', async () => {\n       await expect(\n         loadConfig('', __dirname, {"
        },
        {
            "sha": "60e22e12db92d6040bf93d9da16a1f4817e85f9c",
            "filename": "packages/next/src/server/config.ts",
            "status": "modified",
            "additions": 86,
            "deletions": 4,
            "changes": 90,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fconfig.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -214,7 +214,8 @@ function warnCustomizedOption(\n function assignDefaultsAndValidate(\n   dir: string,\n   userConfig: NextConfig & { configFileName: string },\n-  silent: boolean\n+  silent: boolean,\n+  configuredExperimentalFeatures: ConfiguredExperimentalFeature[]\n ): NextConfigComplete {\n   const configFileName = userConfig.configFileName\n   if (typeof userConfig.exportTrailingSlash !== 'undefined') {\n@@ -1143,6 +1144,46 @@ function assignDefaultsAndValidate(\n     }\n \n     result.experimental.ppr = true\n+\n+    if (\n+      configuredExperimentalFeatures &&\n+      // If we've already noted that the `process.env.__NEXT_EXPERIMENTAL_CACHE_COMPONENTS`\n+      // has enabled the feature, we don't need to note it again.\n+      process.env.__NEXT_EXPERIMENTAL_CACHE_COMPONENTS !== 'true' &&\n+      process.env.__NEXT_EXPERIMENTAL_PPR !== 'true'\n+    ) {\n+      addConfiguredExperimentalFeature(\n+        configuredExperimentalFeatures,\n+        'ppr',\n+        true,\n+        'enabled by `experimental.cacheComponents`'\n+      )\n+    }\n+  }\n+\n+  // If ppr is enabled and the user hasn't configured rdcForNavigations, we\n+  // enable it by default.\n+  if (\n+    result.experimental.ppr &&\n+    userConfig.experimental?.rdcForNavigations === undefined\n+  ) {\n+    result.experimental.rdcForNavigations = true\n+\n+    if (configuredExperimentalFeatures) {\n+      addConfiguredExperimentalFeature(\n+        configuredExperimentalFeatures,\n+        'rdcForNavigations',\n+        true,\n+        'enabled by `experimental.ppr`'\n+      )\n+    }\n+  }\n+\n+  // If rdcForNavigations is enabled, but ppr is not, we throw an error.\n+  if (result.experimental.rdcForNavigations && !result.experimental.ppr) {\n+    throw new Error(\n+      '`experimental.rdcForNavigations` is enabled, but `experimental.ppr` is not.'\n+    )\n   }\n \n   // We require clientSegmentCache to be enabled if clientParamParsing is\n@@ -1320,7 +1361,8 @@ export default async function loadConfig(\n           configFileName,\n           ...customConfig,\n         },\n-        silent\n+        silent,\n+        configuredExperimentalFeatures\n       ) as NextConfigComplete,\n       phase,\n       silent\n@@ -1526,7 +1568,8 @@ export default async function loadConfig(\n         configFileName,\n         ...userConfig,\n       },\n-      silent\n+      silent,\n+      configuredExperimentalFeatures\n     ) as NextConfigComplete\n \n     const finalConfig = await applyModifyConfig(completeConfig, phase, silent)\n@@ -1579,7 +1622,8 @@ export default async function loadConfig(\n   const completeConfig = assignDefaultsAndValidate(\n     dir,\n     { ...clonedDefaultConfig, configFileName },\n-    silent\n+    silent,\n+    configuredExperimentalFeatures\n   ) as NextConfigComplete\n \n   setHttpClientAndAgentOptions(completeConfig)\n@@ -1752,6 +1796,44 @@ function enforceExperimentalFeatures(\n     }\n   }\n \n+  // TODO: Remove this once we've made RDC for Navigations the default for PPR.\n+  if (\n+    process.env.__NEXT_EXPERIMENTAL_CACHE_COMPONENTS === 'true' &&\n+    // We do respect an explicit value in the user config.\n+    (config.experimental.rdcForNavigations === undefined ||\n+      (isDefaultConfig && !config.experimental.rdcForNavigations))\n+  ) {\n+    config.experimental.rdcForNavigations = true\n+\n+    if (configuredExperimentalFeatures) {\n+      addConfiguredExperimentalFeature(\n+        configuredExperimentalFeatures,\n+        'rdcForNavigations',\n+        true,\n+        'enabled by `__NEXT_EXPERIMENTAL_CACHE_COMPONENTS`'\n+      )\n+    }\n+  }\n+\n+  // TODO: Remove this once we've made RDC for Navigations the default for PPR.\n+  if (\n+    process.env.__NEXT_EXPERIMENTAL_PPR === 'true' &&\n+    // We do respect an explicit value in the user config.\n+    (config.experimental.rdcForNavigations === undefined ||\n+      (isDefaultConfig && !config.experimental.rdcForNavigations))\n+  ) {\n+    config.experimental.rdcForNavigations = true\n+\n+    if (configuredExperimentalFeatures) {\n+      addConfiguredExperimentalFeature(\n+        configuredExperimentalFeatures,\n+        'rdcForNavigations',\n+        true,\n+        'enabled by `__NEXT_EXPERIMENTAL_PPR`'\n+      )\n+    }\n+  }\n+\n   if (\n     config.experimental.enablePrerenderSourceMaps === undefined &&\n     config.experimental.cacheComponents === true"
        },
        {
            "sha": "05b5c33883dffc3c123346eb53544000579a2b84",
            "filename": "packages/next/src/server/lib/app-info-log.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 10,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fapp-info-log.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fapp-info-log.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fapp-info-log.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -12,13 +12,11 @@ export function logStartInfo({\n   appUrl,\n   envInfo,\n   experimentalFeatures,\n-  maxExperimentalFeatures = Infinity,\n }: {\n   networkUrl: string | null\n   appUrl: string | null\n   envInfo?: string[]\n   experimentalFeatures?: ConfiguredExperimentalFeature[]\n-  maxExperimentalFeatures?: number\n }) {\n   let bundlerSuffix\n   if (process.env.TURBOPACK) {\n@@ -44,8 +42,7 @@ export function logStartInfo({\n \n   if (experimentalFeatures?.length) {\n     Log.bootstrap(`- Experiments (use with caution):`)\n-    // only show a maximum number of flags\n-    for (const exp of experimentalFeatures.slice(0, maxExperimentalFeatures)) {\n+    for (const exp of experimentalFeatures) {\n       const symbol =\n         typeof exp.value === 'boolean'\n           ? exp.value === true\n@@ -62,10 +59,6 @@ export function logStartInfo({\n \n       Log.bootstrap(`  ${symbol} ${exp.key}${suffix}${reason}`)\n     }\n-    /* indicate if there are more than the maximum shown no. flags */\n-    if (experimentalFeatures.length > maxExperimentalFeatures) {\n-      Log.bootstrap(`  Â· ...`)\n-    }\n   }\n \n   // New line after the bootstrap info\n@@ -90,8 +83,8 @@ export async function getStartServerInfo({\n     dir,\n     {\n       reportExperimentalFeatures(features) {\n-        experimentalFeatures = features.sort(\n-          ({ key: a }, { key: b }) => a.length - b.length\n+        experimentalFeatures = features.sort(({ key: a }, { key: b }) =>\n+          a.localeCompare(b)\n         )\n       },\n       debugPrerender,"
        },
        {
            "sha": "4f944feb861c34af435ebdaa12046ec019e87f85",
            "filename": "packages/next/src/server/lib/incremental-cache/file-system-cache.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 23,
            "changes": 65,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Ffile-system-cache.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -50,15 +50,15 @@ export default class FileSystemCache implements CacheHandler {\n     if (ctx.maxMemoryCacheSize) {\n       if (!FileSystemCache.memoryCache) {\n         if (FileSystemCache.debug) {\n-          console.log('using memory store for fetch cache')\n+          console.log('FileSystemCache: using memory store for fetch cache')\n         }\n \n         FileSystemCache.memoryCache = getMemoryCache(ctx.maxMemoryCacheSize)\n       } else if (FileSystemCache.debug) {\n-        console.log('memory store already initialized')\n+        console.log('FileSystemCache: memory store already initialized')\n       }\n     } else if (FileSystemCache.debug) {\n-      console.log('not using memory store for fetch cache')\n+      console.log('FileSystemCache: not using memory store for fetch cache')\n     }\n   }\n \n@@ -71,7 +71,7 @@ export default class FileSystemCache implements CacheHandler {\n     tags = typeof tags === 'string' ? [tags] : tags\n \n     if (FileSystemCache.debug) {\n-      console.log('revalidateTag', tags)\n+      console.log('FileSystemCache: revalidateTag', tags)\n     }\n \n     if (tags.length === 0) {\n@@ -93,9 +93,9 @@ export default class FileSystemCache implements CacheHandler {\n \n     if (FileSystemCache.debug) {\n       if (kind === IncrementalCacheKind.FETCH) {\n-        console.log('get', key, ctx.tags, kind, !!data)\n+        console.log('FileSystemCache: get', key, ctx.tags, kind, !!data)\n       } else {\n-        console.log('get', key, kind, !!data)\n+        console.log('FileSystemCache: get', key, kind, !!data)\n       }\n     }\n \n@@ -155,7 +155,11 @@ export default class FileSystemCache implements CacheHandler {\n               // via header on GET same as SET\n               if (!tags?.every((tag) => storedTags?.includes(tag))) {\n                 if (FileSystemCache.debug) {\n-                  console.log('tags vs storedTags mismatch', tags, storedTags)\n+                  console.log(\n+                    'FileSystemCache: tags vs storedTags mismatch',\n+                    tags,\n+                    storedTags\n+                  )\n                 }\n                 await this.set(key, data.value, {\n                   fetchCache: true,\n@@ -271,23 +275,33 @@ export default class FileSystemCache implements CacheHandler {\n       }\n     }\n \n+    // If enabled, this will return the possibly stale data without validating\n+    // that the tags have expired or not yet been revalidated.\n+    if ('allowStale' in ctx && ctx.allowStale) {\n+      if (FileSystemCache.debug) {\n+        console.log('FileSystemCache: allow stale', ctx.allowStale)\n+      }\n+\n+      return data ?? null\n+    }\n+\n     if (\n       data?.value?.kind === CachedRouteKind.APP_PAGE ||\n       data?.value?.kind === CachedRouteKind.APP_ROUTE ||\n       data?.value?.kind === CachedRouteKind.PAGES\n     ) {\n-      let cacheTags: undefined | string[]\n       const tagsHeader = data.value.headers?.[NEXT_CACHE_TAGS_HEADER]\n-\n       if (typeof tagsHeader === 'string') {\n-        cacheTags = tagsHeader.split(',')\n-      }\n+        const cacheTags = tagsHeader.split(',')\n \n-      if (cacheTags?.length) {\n         // we trigger a blocking validation if an ISR page\n         // had a tag revalidated, if we want to be a background\n         // revalidation instead we return data.lastModified = -1\n-        if (isStale(cacheTags, data?.lastModified || Date.now())) {\n+        if (cacheTags.length > 0 && isStale(cacheTags, data.lastModified)) {\n+          if (FileSystemCache.debug) {\n+            console.log('FileSystemCache: stale tags', cacheTags)\n+          }\n+\n           return null\n         }\n       }\n@@ -297,17 +311,22 @@ export default class FileSystemCache implements CacheHandler {\n           ? [...(ctx.tags || []), ...(ctx.softTags || [])]\n           : []\n \n-      const wasRevalidated = combinedTags.some((tag) => {\n-        if (this.revalidatedTags.includes(tag)) {\n-          return true\n+      // When revalidate tag is called we don't return stale data so it's\n+      // updated right away.\n+      if (combinedTags.some((tag) => this.revalidatedTags.includes(tag))) {\n+        if (FileSystemCache.debug) {\n+          console.log('FileSystemCache: was revalidated', combinedTags)\n+        }\n+\n+        return null\n+      }\n+\n+      if (isStale(combinedTags, data.lastModified)) {\n+        if (FileSystemCache.debug) {\n+          console.log('FileSystemCache: stale tags', combinedTags)\n         }\n \n-        return isStale([tag], data?.lastModified || Date.now())\n-      })\n-      // When revalidate tag is called we don't return\n-      // stale data so it's updated right away\n-      if (wasRevalidated) {\n-        data = undefined\n+        return null\n       }\n     }\n \n@@ -325,7 +344,7 @@ export default class FileSystemCache implements CacheHandler {\n     })\n \n     if (FileSystemCache.debug) {\n-      console.log('set', key)\n+      console.log('FileSystemCache: set', key)\n     }\n \n     if (!this.flushToDisk || !data) return"
        },
        {
            "sha": "06172d493ff6235bb4b7df1d39755a3cd7667858",
            "filename": "packages/next/src/server/lib/incremental-cache/index.ts",
            "status": "modified",
            "additions": 74,
            "deletions": 13,
            "changes": 87,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fincremental-cache%2Findex.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -15,12 +15,12 @@ import {\n   type SetIncrementalResponseCacheContext,\n } from '../../response-cache'\n import type { DeepReadonly } from '../../../shared/lib/deep-readonly'\n-\n import FileSystemCache from './file-system-cache'\n import { normalizePagePath } from '../../../shared/lib/page-path/normalize-page-path'\n \n import {\n   CACHE_ONE_YEAR,\n+  NEXT_CACHE_TAGS_HEADER,\n   PRERENDER_REVALIDATE_HEADER,\n } from '../../../lib/constants'\n import { toRoute } from '../to-route'\n@@ -35,6 +35,7 @@ import type { Revalidate } from '../cache-control'\n import { getPreviouslyRevalidatedTags } from '../../server-utils'\n import { workAsyncStorage } from '../../app-render/work-async-storage.external'\n import { DetachedPromise } from '../../../lib/detached-promise'\n+import { isStale as isTagsStale } from './tags-manifest.external'\n \n export interface CacheHandlerContext {\n   fs?: CacheFs\n@@ -49,7 +50,7 @@ export interface CacheHandlerContext {\n }\n \n export interface CacheHandlerValue {\n-  lastModified?: number\n+  lastModified: number\n   age?: number\n   cacheState?: string\n   value: IncrementalCacheValue | null\n@@ -89,8 +90,8 @@ export class IncrementalCache implements IncrementalCacheType {\n   readonly allowedRevalidateHeaderKeys?: string[]\n   readonly minimalMode?: boolean\n   readonly fetchCacheKeyPrefix?: string\n-  readonly revalidatedTags?: string[]\n   readonly isOnDemandRevalidate?: boolean\n+  readonly revalidatedTags?: readonly string[]\n \n   private static readonly debug: boolean =\n     !!process.env.NEXT_PRIVATE_DEBUG_CACHE\n@@ -145,13 +146,16 @@ export class IncrementalCache implements IncrementalCacheType {\n       } else {\n         if (fs && serverDistDir) {\n           if (IncrementalCache.debug) {\n-            console.log('using filesystem cache handler')\n+            console.log('IncrementalCache: using filesystem cache handler')\n           }\n           CurCacheHandler = FileSystemCache\n         }\n       }\n     } else if (IncrementalCache.debug) {\n-      console.log('using custom cache handler', CurCacheHandler.name)\n+      console.log(\n+        'IncrementalCache: using custom cache handler',\n+        CurCacheHandler.name\n+      )\n     }\n \n     if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {\n@@ -179,7 +183,7 @@ export class IncrementalCache implements IncrementalCacheType {\n     }\n \n     if (minimalMode) {\n-      revalidatedTags = getPreviouslyRevalidatedTags(\n+      revalidatedTags = this.revalidatedTags = getPreviouslyRevalidatedTags(\n         requestHeaders,\n         this.prerenderManifest?.preview?.previewModeId\n       )\n@@ -243,7 +247,7 @@ export class IncrementalCache implements IncrementalCacheType {\n       const lock = this.locks.get(cacheKey)\n \n       if (IncrementalCache.debug) {\n-        console.log('lock get', cacheKey, !!lock)\n+        console.log('IncrementalCache: lock get', cacheKey, !!lock)\n       }\n \n       // If no lock exists, we can proceed to acquire it\n@@ -258,7 +262,7 @@ export class IncrementalCache implements IncrementalCacheType {\n     const { resolve, promise } = new DetachedPromise<void>()\n \n     if (IncrementalCache.debug) {\n-      console.log('successfully locked', cacheKey)\n+      console.log('IncrementalCache: successfully locked', cacheKey)\n     }\n \n     // Store the lock promise in the locks map\n@@ -430,7 +434,17 @@ export class IncrementalCache implements IncrementalCacheType {\n       if (resumeDataCache) {\n         const memoryCacheData = resumeDataCache.fetch.get(cacheKey)\n         if (memoryCacheData?.kind === CachedRouteKind.FETCH) {\n+          if (IncrementalCache.debug) {\n+            console.log('IncrementalCache: rdc:hit', cacheKey)\n+          }\n+\n           return { isStale: false, value: memoryCacheData }\n+        } else if (IncrementalCache.debug) {\n+          console.log('IncrementalCache: rdc:miss', cacheKey)\n+        }\n+      } else {\n+        if (IncrementalCache.debug) {\n+          console.log('IncrementalCache: rdc:no-resume-data')\n         }\n       }\n     }\n@@ -474,9 +488,34 @@ export class IncrementalCache implements IncrementalCacheType {\n             workStore?.pendingRevalidatedTags?.includes(tag)\n         )\n       ) {\n+        if (IncrementalCache.debug) {\n+          console.log('IncrementalCache: stale tag', cacheKey)\n+        }\n+\n         return null\n       }\n \n+      // As we're able to get the cache entry for this fetch, and the prerender\n+      // resume data cache (RDC) is available, it must have been populated by a\n+      // previous fetch, but was not yet present in the in-memory cache. This\n+      // could be the case when performing multiple renders in parallel during\n+      // build time where we de-duplicate the fetch calls.\n+      //\n+      // We add it to the RDC so that the next fetch call will be able to use it\n+      // and it won't have to reach into the fetch cache implementation.\n+      const workUnitStore = workUnitAsyncStorage.getStore()\n+      if (workUnitStore) {\n+        const prerenderResumeDataCache =\n+          getPrerenderResumeDataCache(workUnitStore)\n+        if (prerenderResumeDataCache) {\n+          if (IncrementalCache.debug) {\n+            console.log('IncrementalCache: rdc:set', cacheKey)\n+          }\n+\n+          prerenderResumeDataCache.fetch.set(cacheKey, cacheData.value)\n+        }\n+      }\n+\n       const revalidate = ctx.revalidate || cacheData.value.revalidate\n       const age =\n         (performance.timeOrigin +\n@@ -507,17 +546,35 @@ export class IncrementalCache implements IncrementalCacheType {\n       isStale = -1\n       revalidateAfter = -1 * CACHE_ONE_YEAR\n     } else {\n+      const now = performance.timeOrigin + performance.now()\n+      const lastModified = cacheData?.lastModified || now\n+\n       revalidateAfter = this.calculateRevalidate(\n         cacheKey,\n-        cacheData?.lastModified || performance.timeOrigin + performance.now(),\n+        lastModified,\n         this.dev ?? false,\n         ctx.isFallback\n       )\n+\n       isStale =\n-        revalidateAfter !== false &&\n-        revalidateAfter < performance.timeOrigin + performance.now()\n-          ? true\n-          : undefined\n+        revalidateAfter !== false && revalidateAfter < now ? true : undefined\n+\n+      // If the stale time couldn't be determined based on the revalidation\n+      // time, we check if the tags are stale.\n+      if (\n+        isStale === undefined &&\n+        (cacheData?.value?.kind === CachedRouteKind.APP_PAGE ||\n+          cacheData?.value?.kind === CachedRouteKind.APP_ROUTE)\n+      ) {\n+        const tagsHeader = cacheData.value.headers?.[NEXT_CACHE_TAGS_HEADER]\n+\n+        if (typeof tagsHeader === 'string') {\n+          const cacheTags = tagsHeader.split(',')\n+          if (cacheTags.length > 0 && isTagsStale(cacheTags, lastModified)) {\n+            isStale = -1\n+          }\n+        }\n+      }\n     }\n \n     if (cacheData) {\n@@ -575,6 +632,10 @@ export class IncrementalCache implements IncrementalCacheType {\n         ? getPrerenderResumeDataCache(workUnitStore)\n         : null\n       if (prerenderResumeDataCache) {\n+        if (IncrementalCache.debug) {\n+          console.log('IncrementalCache: rdc:set', pathname)\n+        }\n+\n         prerenderResumeDataCache.fetch.set(pathname, data)\n       }\n     }"
        },
        {
            "sha": "23c0756ad6908a74b23d66a7886cf45eb1fdecdf",
            "filename": "packages/next/src/server/lib/start-server.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fstart-server.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fstart-server.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fstart-server.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -377,7 +377,6 @@ export async function startServer(\n         appUrl,\n         envInfo,\n         experimentalFeatures,\n-        maxExperimentalFeatures: 3,\n       })\n \n       Log.event(`Starting...`)"
        },
        {
            "sha": "0ac6e47e26fa8148bbfd8908d143fc318eff788f",
            "filename": "packages/next/src/server/request-meta.ts",
            "status": "modified",
            "additions": 23,
            "deletions": 4,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest-meta.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -6,9 +6,13 @@ import type { BaseNextRequest } from './base-http'\n import type { CloneableBody } from './body-streams'\n import type { RouteMatch } from './route-matches/route-match'\n import type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\n-import type { ServerComponentsHmrCache } from './response-cache'\n+import type {\n+  ResponseCacheEntry,\n+  ServerComponentsHmrCache,\n+} from './response-cache'\n import type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'\n import type { OpaqueFallbackRouteParams } from './request/fallback-params'\n+import type { IncrementalCache } from './lib/incremental-cache'\n \n // FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules\n export const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')\n@@ -69,7 +73,7 @@ export interface RequestMeta {\n   /**\n    * The incremental cache to use for the request.\n    */\n-  incrementalCache?: any\n+  incrementalCache?: IncrementalCache\n \n   /**\n    * The server components HMR cache, only for dev.\n@@ -119,10 +123,25 @@ export interface RequestMeta {\n   /**\n    * If provided, this will be called when a response cache entry was generated\n    * or looked up in the cache.\n+   *\n+   * @deprecated Use `onCacheEntryV2` instead.\n    */\n   onCacheEntry?: (\n-    cacheEntry: any,\n-    requestMeta: any\n+    cacheEntry: ResponseCacheEntry,\n+    requestMeta: {\n+      url: string | undefined\n+    }\n+  ) => Promise<boolean | void> | boolean | void\n+\n+  /**\n+   * If provided, this will be called when a response cache entry was generated\n+   * or looked up in the cache.\n+   */\n+  onCacheEntryV2?: (\n+    cacheEntry: ResponseCacheEntry,\n+    requestMeta: {\n+      url: string | undefined\n+    }\n   ) => Promise<boolean | void> | boolean | void\n \n   /**"
        },
        {
            "sha": "ab0057e2310979433b711250b30e83e78fd042c0",
            "filename": "packages/next/src/server/response-cache/index.ts",
            "status": "modified",
            "additions": 250,
            "deletions": 130,
            "changes": 380,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Findex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Findex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Findex.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -18,7 +18,7 @@ import type { RouteKind } from '../route-kind'\n export * from './types'\n \n export default class ResponseCache implements ResponseCacheBase {\n-  private readonly batcher = Batcher.create<\n+  private readonly getBatcher = Batcher.create<\n     { key: string; isOnDemandRevalidate: boolean },\n     IncrementalResponseCacheEntry | null,\n     string\n@@ -33,6 +33,16 @@ export default class ResponseCache implements ResponseCacheBase {\n     schedulerFn: scheduleOnNextTick,\n   })\n \n+  private readonly revalidateBatcher = Batcher.create<\n+    string,\n+    IncrementalResponseCacheEntry | null\n+  >({\n+    // We wait to do any async work until after we've added our promise to\n+    // `pendingResponses` to ensure that any any other calls will reuse the\n+    // same promise until we've fully finished our work.\n+    schedulerFn: scheduleOnNextTick,\n+  })\n+\n   private previousCacheItem?: {\n     key: string\n     entry: IncrementalResponseCacheEntry | null\n@@ -48,6 +58,14 @@ export default class ResponseCache implements ResponseCacheBase {\n     this.minimal_mode = minimal_mode\n   }\n \n+  /**\n+   * Gets the response cache entry for the given key.\n+   *\n+   * @param key - The key to get the response cache entry for.\n+   * @param responseGenerator - The response generator to use to generate the response cache entry.\n+   * @param context - The context for the get request.\n+   * @returns The response cache entry.\n+   */\n   public async get(\n     key: string | null,\n     responseGenerator: ResponseGenerator,\n@@ -64,151 +82,253 @@ export default class ResponseCache implements ResponseCacheBase {\n     // If there is no key for the cache, we can't possibly look this up in the\n     // cache so just return the result of the response generator.\n     if (!key) {\n-      return responseGenerator({ hasResolved: false, previousCacheEntry: null })\n+      return responseGenerator({\n+        hasResolved: false,\n+        previousCacheEntry: null,\n+      })\n+    }\n+\n+    // Check minimal mode cache before doing any other work\n+    if (\n+      this.minimal_mode &&\n+      this.previousCacheItem?.key === key &&\n+      this.previousCacheItem.expiresAt > Date.now()\n+    ) {\n+      return toResponseCacheEntry(this.previousCacheItem.entry)\n     }\n \n     const {\n       incrementalCache,\n       isOnDemandRevalidate = false,\n       isFallback = false,\n       isRoutePPREnabled = false,\n+      isPrefetch = false,\n       waitUntil,\n+      routeKind,\n     } = context\n \n-    const response = await this.batcher.batch(\n+    const response = await this.getBatcher.batch(\n       { key, isOnDemandRevalidate },\n-      (cacheKey, resolve) => {\n-        const prom = (async () => {\n-          // We keep the previous cache entry around to leverage when the\n-          // incremental cache is disabled in minimal mode.\n-          if (\n-            this.minimal_mode &&\n-            this.previousCacheItem?.key === cacheKey &&\n-            this.previousCacheItem.expiresAt > Date.now()\n-          ) {\n-            return this.previousCacheItem.entry\n-          }\n+      ({ resolve }) => {\n+        const promise = this.handleGet(\n+          key,\n+          responseGenerator,\n+          {\n+            incrementalCache,\n+            isOnDemandRevalidate,\n+            isFallback,\n+            isRoutePPREnabled,\n+            isPrefetch,\n+            routeKind,\n+          },\n+          resolve\n+        )\n \n-          // Coerce the kindHint into a given kind for the incremental cache.\n-          const kind = routeKindToIncrementalCacheKind(context.routeKind)\n-\n-          let resolved = false\n-          let cachedResponse: IncrementalResponseCacheEntry | null = null\n-          try {\n-            cachedResponse = !this.minimal_mode\n-              ? await incrementalCache.get(key, {\n-                  kind,\n-                  isRoutePPREnabled: context.isRoutePPREnabled,\n-                  isFallback,\n-                })\n-              : null\n-\n-            if (cachedResponse && !isOnDemandRevalidate) {\n-              resolve(cachedResponse)\n-              resolved = true\n-\n-              if (!cachedResponse.isStale || context.isPrefetch) {\n-                // The cached value is still valid, so we don't need\n-                // to update it yet.\n-                return null\n-              }\n-            }\n-\n-            const cacheEntry = await responseGenerator({\n-              hasResolved: resolved,\n-              previousCacheEntry: cachedResponse,\n-              isRevalidating: true,\n-            })\n-\n-            // If the cache entry couldn't be generated, we don't want to cache\n-            // the result.\n-            if (!cacheEntry) {\n-              // Unset the previous cache item if it was set.\n-              if (this.minimal_mode) this.previousCacheItem = undefined\n-              return null\n-            }\n-\n-            const resolveValue = await fromResponseCacheEntry({\n-              ...cacheEntry,\n-              isMiss: !cachedResponse,\n-            })\n-            if (!resolveValue) {\n-              // Unset the previous cache item if it was set.\n-              if (this.minimal_mode) this.previousCacheItem = undefined\n-              return null\n-            }\n-\n-            // For on-demand revalidate wait to resolve until cache is set.\n-            // Otherwise resolve now.\n-            if (!isOnDemandRevalidate && !resolved) {\n-              resolve(resolveValue)\n-              resolved = true\n-            }\n-\n-            // We want to persist the result only if it has a cache control value\n-            // defined.\n-            if (resolveValue.cacheControl) {\n-              if (this.minimal_mode) {\n-                this.previousCacheItem = {\n-                  key: cacheKey,\n-                  entry: resolveValue,\n-                  expiresAt: Date.now() + 1000,\n-                }\n-              } else {\n-                await incrementalCache.set(key, resolveValue.value, {\n-                  cacheControl: resolveValue.cacheControl,\n-                  isRoutePPREnabled,\n-                  isFallback,\n-                })\n-              }\n-            }\n-\n-            return resolveValue\n-          } catch (err) {\n-            // When a path is erroring we automatically re-set the existing cache\n-            // with new revalidate and expire times to prevent non-stop retrying.\n-            if (cachedResponse?.cacheControl) {\n-              const newRevalidate = Math.min(\n-                Math.max(cachedResponse.cacheControl.revalidate || 3, 3),\n-                30\n-              )\n+        // We need to ensure background revalidates are passed to waitUntil.\n+        if (waitUntil) waitUntil(promise)\n \n-              const newExpire =\n-                cachedResponse.cacheControl.expire === undefined\n-                  ? undefined\n-                  : Math.max(\n-                      newRevalidate + 3,\n-                      cachedResponse.cacheControl.expire\n-                    )\n-\n-              await incrementalCache.set(key, cachedResponse.value, {\n-                cacheControl: { revalidate: newRevalidate, expire: newExpire },\n-                isRoutePPREnabled,\n-                isFallback,\n-              })\n-            }\n-\n-            // While revalidating in the background we can't reject as we already\n-            // resolved the cache entry so log the error here.\n-            if (resolved) {\n-              console.error(err)\n-              return null\n-            }\n-\n-            // We haven't resolved yet, so let's throw to indicate an error.\n-            throw err\n-          }\n-        })()\n-\n-        // we need to ensure background revalidates are\n-        // passed to waitUntil\n-        if (waitUntil) {\n-          waitUntil(prom)\n-        }\n-        return prom\n+        return promise\n       }\n     )\n \n     return toResponseCacheEntry(response)\n   }\n+\n+  /**\n+   * Handles the get request for the response cache.\n+   *\n+   * @param key - The key to get the response cache entry for.\n+   * @param responseGenerator - The response generator to use to generate the response cache entry.\n+   * @param context - The context for the get request.\n+   * @param resolve - The resolve function to use to resolve the response cache entry.\n+   * @returns The response cache entry.\n+   */\n+  private async handleGet(\n+    key: string,\n+    responseGenerator: ResponseGenerator,\n+    context: {\n+      incrementalCache: IncrementalResponseCache\n+      isOnDemandRevalidate: boolean\n+      isFallback: boolean\n+      isRoutePPREnabled: boolean\n+      isPrefetch: boolean\n+      routeKind: RouteKind\n+    },\n+    resolve: (value: IncrementalResponseCacheEntry | null) => void\n+  ): Promise<IncrementalResponseCacheEntry | null> {\n+    let previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null =\n+      null\n+    let resolved = false\n+\n+    try {\n+      // Get the previous cache entry if not in minimal mode\n+      previousIncrementalCacheEntry = !this.minimal_mode\n+        ? await context.incrementalCache.get(key, {\n+            kind: routeKindToIncrementalCacheKind(context.routeKind),\n+            isRoutePPREnabled: context.isRoutePPREnabled,\n+            isFallback: context.isFallback,\n+          })\n+        : null\n+\n+      if (previousIncrementalCacheEntry && !context.isOnDemandRevalidate) {\n+        resolve(previousIncrementalCacheEntry)\n+        resolved = true\n+\n+        if (!previousIncrementalCacheEntry.isStale || context.isPrefetch) {\n+          // The cached value is still valid, so we don't need to update it yet.\n+          return previousIncrementalCacheEntry\n+        }\n+      }\n+\n+      // Revalidate the cache entry\n+      const incrementalResponseCacheEntry = await this.revalidate(\n+        key,\n+        context.incrementalCache,\n+        context.isRoutePPREnabled,\n+        context.isFallback,\n+        responseGenerator,\n+        previousIncrementalCacheEntry,\n+        previousIncrementalCacheEntry !== null && !context.isOnDemandRevalidate\n+      )\n+\n+      // Handle null response\n+      if (!incrementalResponseCacheEntry) {\n+        // Unset the previous cache item if it was set so we don't use it again.\n+        if (this.minimal_mode) this.previousCacheItem = undefined\n+        return null\n+      }\n+\n+      // Resolve for on-demand revalidation or if not already resolved\n+      if (context.isOnDemandRevalidate && !resolved) {\n+        return incrementalResponseCacheEntry\n+      }\n+\n+      return incrementalResponseCacheEntry\n+    } catch (err) {\n+      // If we've already resolved the cache entry, we can't reject as we\n+      // already resolved the cache entry so log the error here.\n+      if (resolved) {\n+        console.error(err)\n+        return null\n+      }\n+\n+      throw err\n+    }\n+  }\n+\n+  /**\n+   * Revalidates the cache entry for the given key.\n+   *\n+   * @param key - The key to revalidate the cache entry for.\n+   * @param incrementalCache - The incremental cache to use to revalidate the cache entry.\n+   * @param isRoutePPREnabled - Whether the route is PPR enabled.\n+   * @param isFallback - Whether the route is a fallback.\n+   * @param responseGenerator - The response generator to use to generate the response cache entry.\n+   * @param previousIncrementalCacheEntry - The previous cache entry to use to revalidate the cache entry.\n+   * @param hasResolved - Whether the response has been resolved.\n+   * @returns The revalidated cache entry.\n+   */\n+  public async revalidate(\n+    key: string,\n+    incrementalCache: IncrementalResponseCache,\n+    isRoutePPREnabled: boolean,\n+    isFallback: boolean,\n+    responseGenerator: ResponseGenerator,\n+    previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null,\n+    hasResolved: boolean,\n+    waitUntil?: (prom: Promise<any>) => void\n+  ) {\n+    return this.revalidateBatcher.batch(key, () => {\n+      const promise = this.handleRevalidate(\n+        key,\n+        incrementalCache,\n+        isRoutePPREnabled,\n+        isFallback,\n+        responseGenerator,\n+        previousIncrementalCacheEntry,\n+        hasResolved\n+      )\n+\n+      // We need to ensure background revalidates are passed to waitUntil.\n+      if (waitUntil) waitUntil(promise)\n+\n+      return promise\n+    })\n+  }\n+\n+  private async handleRevalidate(\n+    key: string,\n+    incrementalCache: IncrementalResponseCache,\n+    isRoutePPREnabled: boolean,\n+    isFallback: boolean,\n+    responseGenerator: ResponseGenerator,\n+    previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null,\n+    hasResolved: boolean\n+  ) {\n+    try {\n+      // Generate the response cache entry using the response generator.\n+      const responseCacheEntry = await responseGenerator({\n+        hasResolved,\n+        previousCacheEntry: previousIncrementalCacheEntry,\n+        isRevalidating: true,\n+      })\n+      if (!responseCacheEntry) {\n+        return null\n+      }\n+\n+      // Convert the response cache entry to an incremental response cache entry.\n+      const incrementalResponseCacheEntry = await fromResponseCacheEntry({\n+        ...responseCacheEntry,\n+        isMiss: !previousIncrementalCacheEntry,\n+      })\n+\n+      // We want to persist the result only if it has a cache control value\n+      // defined.\n+      if (incrementalResponseCacheEntry.cacheControl) {\n+        if (this.minimal_mode) {\n+          this.previousCacheItem = {\n+            key,\n+            entry: incrementalResponseCacheEntry,\n+            expiresAt: Date.now() + 1000,\n+          }\n+        } else {\n+          await incrementalCache.set(key, incrementalResponseCacheEntry.value, {\n+            cacheControl: incrementalResponseCacheEntry.cacheControl,\n+            isRoutePPREnabled,\n+            isFallback,\n+          })\n+        }\n+      }\n+\n+      return incrementalResponseCacheEntry\n+    } catch (err) {\n+      // When a path is erroring we automatically re-set the existing cache\n+      // with new revalidate and expire times to prevent non-stop retrying.\n+      if (previousIncrementalCacheEntry?.cacheControl) {\n+        const revalidate = Math.min(\n+          Math.max(\n+            previousIncrementalCacheEntry.cacheControl.revalidate || 3,\n+            3\n+          ),\n+          30\n+        )\n+        const expire =\n+          previousIncrementalCacheEntry.cacheControl.expire === undefined\n+            ? undefined\n+            : Math.max(\n+                revalidate + 3,\n+                previousIncrementalCacheEntry.cacheControl.expire\n+              )\n+\n+        await incrementalCache.set(key, previousIncrementalCacheEntry.value, {\n+          cacheControl: { revalidate: revalidate, expire: expire },\n+          isRoutePPREnabled,\n+          isFallback,\n+        })\n+      }\n+\n+      // We haven't resolved yet, so let's throw to indicate an error.\n+      throw err\n+    }\n+  }\n }"
        },
        {
            "sha": "3a64e7d98e5bb7f2dc314c8ad5b73b6b1167257e",
            "filename": "packages/next/src/server/response-cache/types.ts",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fresponse-cache%2Ftypes.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -188,6 +188,15 @@ export type ResponseGenerator = (state: {\n   previousCacheEntry?: IncrementalResponseCacheEntry | null\n   isRevalidating?: boolean\n   span?: any\n+\n+  /**\n+   * When true, this indicates that the response generator is being called in a\n+   * context where the response must be generated statically.\n+   *\n+   * CRITICAL: This should only currently be used when revalidating due to a\n+   * dynamic RSC request.\n+   */\n+  forceStaticRender?: boolean\n }) => Promise<ResponseCacheEntry | null>\n \n export const enum IncrementalCacheKind {\n@@ -219,6 +228,11 @@ export interface GetIncrementalResponseCacheContext {\n    * True if this is a fallback request.\n    */\n   isFallback: boolean\n+\n+  /**\n+   * True if stale data is allowed to be returned.\n+   */\n+  allowStale?: boolean\n }\n \n export interface SetIncrementalFetchCacheContext {"
        },
        {
            "sha": "4b1bac393bf9eb2cb28e5c5e3201e9912048f457",
            "filename": "test/e2e/app-dir/ppr-full/ppr-full.test.ts",
            "status": "modified",
            "additions": 63,
            "deletions": 11,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fe2e%2Fapp-dir%2Fppr-full%2Fppr-full.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fe2e%2Fapp-dir%2Fppr-full%2Fppr-full.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fppr-full%2Fppr-full.test.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -67,6 +67,21 @@ const addCacheBustingSearchParam = (\n   return url.pathname + url.search\n }\n \n+/**\n+ * Expects that the cache-control header contains the given directives in any\n+ * order.\n+ *\n+ * @param header The cache-control header to check.\n+ * @param directives The directives to expect.\n+ */\n+const expectDirectives = (header: string, directives: string[]) => {\n+  const split = header.split(',').map((directive) => directive.trim())\n+  for (const directive of directives) {\n+    expect(split).toContain(directive)\n+  }\n+  expect(split.length).toEqual(directives.length)\n+}\n+\n describe('ppr-full', () => {\n   const { next, isNextDev, isNextDeploy } = nextTestSetup({\n     files: __dirname,\n@@ -107,6 +122,32 @@ describe('ppr-full', () => {\n           await res.text()\n         })\n \n+        it('should allow soft navigations to and from the / page', async () => {\n+          const browser = await next.browser('/')\n+\n+          await browser.waitForElementByCss(`[data-pathname=\"/\"]`)\n+\n+          // Add a window var so we can detect if there was a full navigation.\n+          const now = Date.now()\n+          await browser.eval(`window.beforeNav = ${now}`)\n+\n+          // Navigate to the page and wait for the page to load.\n+          await browser.elementByCss(`a[href=\"${pathname}\"]`).click()\n+          await browser.waitForElementByCss(`[data-pathname=\"${pathname}\"]`)\n+\n+          // Ensure we did a client navigation and not a full page navigation.\n+          let beforeNav = await browser.eval('window.beforeNav')\n+          expect(beforeNav).toBe(now)\n+\n+          // Navigate back to the home page and wait for the page to load.\n+          await browser.elementByCss(`a[href=\"/\"]`).click()\n+          await browser.waitForElementByCss(`[data-pathname=\"/\"]`)\n+\n+          // Ensure we did a client navigation and not a full page navigation.\n+          beforeNav = await browser.eval('window.beforeNav')\n+          expect(beforeNav).toBe(now)\n+        })\n+\n         it('should allow navigations to and from a pages/ page', async () => {\n           const browser = await next.browser(pathname)\n \n@@ -491,9 +532,11 @@ describe('ppr-full', () => {\n           }\n \n           if (isNextDeploy) {\n-            expect(res.headers.get('cache-control')).toEqual(\n-              'public, max-age=0, must-revalidate'\n-            )\n+            expectDirectives(res.headers.get('cache-control') || '', [\n+              'public',\n+              'max-age=0',\n+              'must-revalidate',\n+            ])\n           }\n \n           if (signal === 'redirect()') {\n@@ -551,9 +594,11 @@ describe('ppr-full', () => {\n             expect(res.headers.get('content-type')).toEqual('text/x-component')\n \n             if (isNextDeploy) {\n-              expect(res.headers.get('cache-control')).toEqual(\n-                'public, max-age=0, must-revalidate'\n-              )\n+              expectDirectives(res.headers.get('cache-control') || '', [\n+                'public',\n+                'max-age=0',\n+                'must-revalidate',\n+              ])\n             } else {\n               expect(res.headers.get('cache-control')).toEqual(\n                 revalidate === undefined\n@@ -602,16 +647,23 @@ describe('ppr-full', () => {\n             headers\n           )\n \n-          const res = await next.fetch(urlWithCacheBusting, {\n+          let res = await next.fetch(urlWithCacheBusting, {\n             headers,\n           })\n           expect(res.status).toEqual(200)\n           expect(res.headers.get('content-type')).toEqual('text/x-component')\n-          expect(res.headers.get('cache-control')).toEqual(\n-            'private, no-cache, no-store, max-age=0, must-revalidate'\n-          )\n+          expectDirectives(res.headers.get('cache-control') || '', [\n+            'private',\n+            'no-store',\n+            'no-cache',\n+            'max-age=0',\n+            'must-revalidate',\n+          ])\n+\n           if (isNextDeploy) {\n-            expect(res.headers.get('x-vercel-cache')).toBe('MISS')\n+            expect(res.headers.get('x-vercel-cache')).toMatch(\n+              /MISS|HIT|PRERENDER/\n+            )\n           } else {\n             expect(res.headers.get('x-nextjs-cache')).toEqual(null)\n           }"
        },
        {
            "sha": "75ff2169af9b6507789d3d9b7838e09c94f553b7",
            "filename": "test/experimental-tests-manifest.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fexperimental-tests-manifest.json",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fexperimental-tests-manifest.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fexperimental-tests-manifest.json?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -351,7 +351,8 @@\n       \"test/production/app-dir/subresource-integrity/subresource-integrity.test.ts\",\n       \"test/production/app-dir/typed-routes-with-webpack-worker/typed-routes-with-webpack-worker.test.ts\",\n       \"test/production/app-dir/unexpected-error/unexpected-error.test.ts\",\n-      \"test/production/app-dir/worker-restart/worker-restart.test.ts\"\n+      \"test/production/app-dir/worker-restart/worker-restart.test.ts\",\n+      \"test/production/app-dir/resume-data-cache/resume-data-cache.test.ts\"\n     ]\n   }\n }"
        },
        {
            "sha": "4a79ee4f9740136f7163b1af6f8d00c79e1024f5",
            "filename": "test/integration/custom-routes/test/index.test.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fcustom-routes%2Ftest%2Findex.test.js?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -2431,6 +2431,7 @@ const runTests = (isDev = false) => {\n            \"clientParamParsing\": false,\n            \"contentTypeHeader\": \"text/x-component\",\n            \"didPostponeHeader\": \"x-nextjs-postponed\",\n+           \"dynamicRSCPrerender\": false,\n            \"header\": \"rsc\",\n            \"prefetchHeader\": \"next-router-prefetch\",\n            \"prefetchSegmentDirSuffix\": \".segments\","
        },
        {
            "sha": "d8041f5e34f0e56782121f2ff87d6dcd03dd7b34",
            "filename": "test/integration/dynamic-routing/test/index.test.js",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fdynamic-routing%2Ftest%2Findex.test.js?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -1474,6 +1474,7 @@ function runTests({ dev }) {\n            \"clientParamParsing\": false,\n            \"contentTypeHeader\": \"text/x-component\",\n            \"didPostponeHeader\": \"x-nextjs-postponed\",\n+           \"dynamicRSCPrerender\": false,\n            \"header\": \"rsc\",\n            \"prefetchHeader\": \"next-router-prefetch\",\n            \"prefetchSegmentDirSuffix\": \".segments\","
        },
        {
            "sha": "75dcd7cb66f743598a5b78ad0fefc54fb67a916f",
            "filename": "test/ppr-tests-manifest.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fppr-tests-manifest.json",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fppr-tests-manifest.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fppr-tests-manifest.json?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -175,7 +175,8 @@\n       \"test/e2e/app-dir/use-cache-with-server-function-props/use-cache-with-server-function-props.test.ts\",\n       \"test/integration/app-dir-export/**/*\",\n       \"test/production/app-dir/build-output-tree-view/build-output-tree-view.test.ts\",\n-      \"test/production/app-dir/global-default-cache-handler/global-default-cache-handler.test.ts\"\n+      \"test/production/app-dir/global-default-cache-handler/global-default-cache-handler.test.ts\",\n+      \"test/production/app-dir/resume-data-cache/resume-data-cache.test.ts\"\n     ]\n   }\n }"
        },
        {
            "sha": "8e870b31b929fa1a4652d26ce1f74e83199ef14e",
            "filename": "test/production/app-dir/build-output-prerender/build-output-prerender.test.ts",
            "status": "modified",
            "additions": 106,
            "deletions": 82,
            "changes": 188,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fapp-dir%2Fbuild-output-prerender%2Fbuild-output-prerender.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fapp-dir%2Fbuild-output-prerender%2Fbuild-output-prerender.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fbuild-output-prerender%2Fbuild-output-prerender.test.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -23,43 +23,47 @@ describe('build-output-prerender', () => {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â² Next.js x.y.z (Turbopack)\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n                   â cacheComponents\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\"\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\"\n             `)\n           } else {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â² Next.js x.y.z\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n                   â cacheComponents\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\"\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\"\n             `)\n           }\n         } else if (pprEnabled) {\n           if (isTurbopack) {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â² Next.js x.y.z (Turbopack)\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â cacheComponents\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\"\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\"\n             `)\n           } else {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â² Next.js x.y.z\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â cacheComponents\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\"\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\"\n             `)\n           }\n         } else {\n@@ -68,14 +72,18 @@ describe('build-output-prerender', () => {\n              \"â² Next.js x.y.z (Turbopack)\n                 - Experiments (use with caution):\n                   â cacheComponents\n-                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\"\n+                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\n+                  â ppr (enabled by \\`experimental.cacheComponents\\`)\n+                  â rdcForNavigations (enabled by \\`experimental.ppr\\`)\"\n             `)\n           } else {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â² Next.js x.y.z\n                 - Experiments (use with caution):\n                   â cacheComponents\n-                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\"\n+                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\n+                  â ppr (enabled by \\`experimental.cacheComponents\\`)\n+                  â rdcForNavigations (enabled by \\`experimental.ppr\\`)\"\n             `)\n           }\n         }\n@@ -129,28 +137,30 @@ describe('build-output-prerender', () => {\n              \"â  Prerendering is running in debug mode. Note: This may affect performance and should not be used for production.\n                 â² Next.js x.y.z (Turbopack)\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n                   â cacheComponents\n-                  â¨¯ turbopackMinify (disabled by \\`--debug-prerender\\`)\n-                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n-                  â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\"\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n+                  â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n+                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â¨¯ turbopackMinify (disabled by \\`--debug-prerender\\`)\"\n             `)\n           } else {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â  Prerendering is running in debug mode. Note: This may affect performance and should not be used for production.\n                 â² Next.js x.y.z\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n                   â cacheComponents\n-                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n-                  â¨¯ serverMinification (disabled by \\`--debug-prerender\\`)\n-                  â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\"\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n+                  â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n+                  â¨¯ serverMinification (disabled by \\`--debug-prerender\\`)\n+                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\"\n             `)\n           }\n         } else if (pprEnabled) {\n@@ -159,28 +169,30 @@ describe('build-output-prerender', () => {\n              \"â  Prerendering is running in debug mode. Note: This may affect performance and should not be used for production.\n                 â² Next.js x.y.z (Turbopack)\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â cacheComponents\n-                  â¨¯ turbopackMinify (disabled by \\`--debug-prerender\\`)\n-                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n-                  â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\"\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â¨¯ turbopackMinify (disabled by \\`--debug-prerender\\`)\"\n             `)\n           } else {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â  Prerendering is running in debug mode. Note: This may affect performance and should not be used for production.\n                 â² Next.js x.y.z\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â cacheComponents\n-                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n-                  â¨¯ serverMinification (disabled by \\`--debug-prerender\\`)\n-                  â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\"\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â¨¯ serverMinification (disabled by \\`--debug-prerender\\`)\n+                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\"\n             `)\n           }\n         } else {\n@@ -190,21 +202,25 @@ describe('build-output-prerender', () => {\n                 â² Next.js x.y.z (Turbopack)\n                 - Experiments (use with caution):\n                   â cacheComponents\n-                  â¨¯ turbopackMinify (disabled by \\`--debug-prerender\\`)\n-                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â ppr (enabled by \\`experimental.cacheComponents\\`)\n                   â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\"\n+                  â rdcForNavigations (enabled by \\`experimental.ppr\\`)\n+                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â¨¯ turbopackMinify (disabled by \\`--debug-prerender\\`)\"\n             `)\n           } else {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â  Prerendering is running in debug mode. Note: This may affect performance and should not be used for production.\n                 â² Next.js x.y.z\n                 - Experiments (use with caution):\n                   â cacheComponents\n-                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n-                  â¨¯ serverMinification (disabled by \\`--debug-prerender\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â ppr (enabled by \\`experimental.cacheComponents\\`)\n                   â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\"\n+                  â rdcForNavigations (enabled by \\`experimental.ppr\\`)\n+                  â¨¯ serverMinification (disabled by \\`--debug-prerender\\`)\n+                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\"\n             `)\n           }\n         }\n@@ -256,39 +272,43 @@ describe('build-output-prerender', () => {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â² Next.js x.y.z (Turbopack)\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n                   â cacheComponents (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\"\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\"\n             `)\n           } else {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â² Next.js x.y.z\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n                   â cacheComponents (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\"\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`experimental.cacheComponents\\`)\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\"\n             `)\n           }\n         } else if (pprEnabled) {\n           if (isTurbopack) {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â² Next.js x.y.z (Turbopack)\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\"\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\"\n             `)\n           } else {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â² Next.js x.y.z\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\"\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\"\n             `)\n           }\n         } else {\n@@ -321,28 +341,30 @@ describe('build-output-prerender', () => {\n              \"â  Prerendering is running in debug mode. Note: This may affect performance and should not be used for production.\n                 â² Next.js x.y.z (Turbopack)\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n                   â cacheComponents (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n-                  â¨¯ turbopackMinify (disabled by \\`--debug-prerender\\`)\n-                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n-                  â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\"\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n+                  â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n+                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â¨¯ turbopackMinify (disabled by \\`--debug-prerender\\`)\"\n             `)\n           } else {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â  Prerendering is running in debug mode. Note: This may affect performance and should not be used for production.\n                 â² Next.js x.y.z\n                 - Experiments (use with caution):\n-                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n                   â cacheComponents (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n-                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n-                  â¨¯ serverMinification (disabled by \\`--debug-prerender\\`)\n-                  â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n                   â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\"\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â ppr (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n+                  â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_CACHE_COMPONENTS\\`)\n+                  â¨¯ serverMinification (disabled by \\`--debug-prerender\\`)\n+                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\"\n             `)\n           }\n         } else if (pprEnabled) {\n@@ -351,26 +373,28 @@ describe('build-output-prerender', () => {\n              \"â  Prerendering is running in debug mode. Note: This may affect performance and should not be used for production.\n                 â² Next.js x.y.z (Turbopack)\n                 - Experiments (use with caution):\n+                  â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\n                   â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â¨¯ turbopackMinify (disabled by \\`--debug-prerender\\`)\n-                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n                   â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\"\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â¨¯ turbopackMinify (disabled by \\`--debug-prerender\\`)\"\n             `)\n           } else {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â  Prerendering is running in debug mode. Note: This may affect performance and should not be used for production.\n                 â² Next.js x.y.z\n                 - Experiments (use with caution):\n+                  â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\n                   â ppr (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n-                  â¨¯ serverMinification (disabled by \\`--debug-prerender\\`)\n                   â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n-                  â clientSegmentCache (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â clientParamParsing (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\"\n+                  â rdcForNavigations (enabled by \\`__NEXT_EXPERIMENTAL_PPR\\`)\n+                  â¨¯ serverMinification (disabled by \\`--debug-prerender\\`)\n+                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\"\n             `)\n           }\n         } else {\n@@ -379,20 +403,20 @@ describe('build-output-prerender', () => {\n              \"â  Prerendering is running in debug mode. Note: This may affect performance and should not be used for production.\n                 â² Next.js x.y.z (Turbopack)\n                 - Experiments (use with caution):\n-                  â¨¯ turbopackMinify (disabled by \\`--debug-prerender\\`)\n-                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\n                   â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\"\n+                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n+                  â¨¯ turbopackMinify (disabled by \\`--debug-prerender\\`)\"\n             `)\n           } else {\n             expect(getPreambleOutput(next.cliOutput)).toMatchInlineSnapshot(`\n              \"â  Prerendering is running in debug mode. Note: This may affect performance and should not be used for production.\n                 â² Next.js x.y.z\n                 - Experiments (use with caution):\n-                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\n-                  â¨¯ serverMinification (disabled by \\`--debug-prerender\\`)\n+                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\n                   â¨¯ prerenderEarlyExit (disabled by \\`--debug-prerender\\`)\n-                  â enablePrerenderSourceMaps (enabled by \\`--debug-prerender\\`)\"\n+                  â¨¯ serverMinification (disabled by \\`--debug-prerender\\`)\n+                  â serverSourceMaps (enabled by \\`--debug-prerender\\`)\"\n             `)\n           }\n         }"
        },
        {
            "sha": "9dfde1627512b37a73ed3912c0b31e351276e718",
            "filename": "test/production/app-dir/resume-data-cache/app/layout.tsx",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Flayout.tsx?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -0,0 +1,9 @@\n+import React, { ReactNode } from 'react'\n+\n+export default function Root({ children }: { children: ReactNode }) {\n+  return (\n+    <html>\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "a42bd6f524a3954725b84d2eb7b3480bd49ced27",
            "filename": "test/production/app-dir/resume-data-cache/app/page.tsx",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Fpage.tsx?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -0,0 +1,32 @@\n+import React, { Suspense } from 'react'\n+import { connection } from 'next/server'\n+\n+import { unstable_cacheTag } from 'next/cache'\n+\n+async function getRandomNumber() {\n+  'use cache'\n+  unstable_cacheTag('test')\n+  return Math.random()\n+}\n+\n+async function DynamicComponent() {\n+  await connection()\n+  return null\n+}\n+\n+export default async function Page() {\n+  const randomNumber = await getRandomNumber()\n+  const anotherRandomNumber = await fetch(\n+    'https://next-data-api-endpoint.vercel.app/api/random',\n+    { cache: 'force-cache', next: { tags: ['test'] } }\n+  ).then((res) => res.text())\n+  return (\n+    <>\n+      <p id=\"random-number\">{randomNumber}</p>\n+      <p id=\"another-random-number\">{anotherRandomNumber}</p>\n+      <Suspense>\n+        <DynamicComponent />\n+      </Suspense>\n+    </>\n+  )\n+}"
        },
        {
            "sha": "4100bb53cdd06963db1274e8de7906a848adf954",
            "filename": "test/production/app-dir/resume-data-cache/app/revalidate/route.ts",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Frevalidate%2Froute.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Frevalidate%2Froute.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fapp%2Frevalidate%2Froute.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -0,0 +1,6 @@\n+import { revalidateTag } from 'next/cache'\n+\n+export function POST() {\n+  revalidateTag('test')\n+  return new Response(null, { status: 200 })\n+}"
        },
        {
            "sha": "cf8a60b4804fcda0e46330ad613b33b31b7da47d",
            "filename": "test/production/app-dir/resume-data-cache/next.config.js",
            "status": "added",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fnext.config.js?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -0,0 +1,12 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  experimental: {\n+    cacheComponents: true,\n+    clientSegmentCache: true,\n+    clientParamParsing: true,\n+  },\n+}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "120471b74fe53d94c1fe65cc7eaa3efc4e2acef1",
            "filename": "test/production/app-dir/resume-data-cache/resume-data-cache.test.ts",
            "status": "added",
            "additions": 132,
            "deletions": 0,
            "changes": 132,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fresume-data-cache.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fresume-data-cache.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fapp-dir%2Fresume-data-cache%2Fresume-data-cache.test.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -0,0 +1,132 @@\n+import { nextTestSetup } from 'e2e-utils'\n+import { retry } from 'next-test-utils'\n+import { computeCacheBustingSearchParam } from 'next/dist/shared/lib/router/utils/cache-busting-search-param'\n+\n+describe('resume-data-cache', () => {\n+  const { next, isNextDeploy } = nextTestSetup({\n+    files: __dirname,\n+  })\n+\n+  it.each([\n+    { name: 'use cache', id: 'random-number' },\n+    { name: 'fetch cache', id: 'another-random-number' },\n+  ])(\n+    'should have consistent data between static and dynamic renders with $name',\n+    async ({ id }) => {\n+      // First render the page statically, getting the random number from the\n+      // HTML.\n+      let $ = await next.render$('/')\n+      const first = $(`p#${id}`).text()\n+\n+      // Then get the Prefetch RSC and validate that it also contains the same\n+      // random number.\n+      await retry(async () => {\n+        const url = new URL('/', 'http://localhost')\n+\n+        url.searchParams.set(\n+          '_rsc',\n+          computeCacheBustingSearchParam('1', '/__PAGE__', undefined, undefined)\n+        )\n+\n+        const rsc = await next\n+          .fetch(url.toString(), {\n+            headers: {\n+              RSC: '1',\n+              'Next-Router-Prefetch': '1',\n+              'Next-Router-Segment-Prefetch': '/__PAGE__',\n+            },\n+          })\n+          .then((res) => res.text())\n+        expect(rsc).toContain(first)\n+      })\n+\n+      // Then get the dynamic RSC and validate that it also contains the same\n+      // random number.\n+      await retry(async () => {\n+        const rsc = await next\n+          .fetch('/', {\n+            headers: {\n+              RSC: '1',\n+            },\n+          })\n+          .then((res) => res.text())\n+        expect(rsc).toContain(first)\n+      })\n+\n+      // Then revalidate the page. Note: Dynamic RSC requests don't trigger\n+      // actual revalidation - they only mark tags as needing revalidation.\n+      // The actual revalidation only occurs when accessing a static resource again.\n+      await next.fetch('/revalidate', { method: 'POST' })\n+\n+      // Then get the dynamic RSC again and validate that it still contains the\n+      // same random number. The first request will get the stale data, but the\n+      // second request will get the fresh data as it'll eventually have\n+      // revalidated.\n+      // NOTE: this current doesn't work on Next.js Deploy, as the dynamic RSC\n+      // requests are not able to revalidate the page.\n+      if (!isNextDeploy) {\n+        const rsc = await next\n+          .fetch('/', {\n+            headers: {\n+              RSC: '1',\n+            },\n+          })\n+          .then((res) => res.text())\n+        expect(rsc).toContain(first)\n+      }\n+\n+      // We then expect after the background revalidation has been completed,\n+      // the dynamic RSC to get the fresh data.\n+      await retry(async () => {\n+        const rsc = await next\n+          .fetch('/', {\n+            headers: {\n+              RSC: '1',\n+            },\n+          })\n+          .then((res) => res.text())\n+        expect(rsc).not.toContain(first)\n+      })\n+\n+      // This proves that the dynamic RSC was able to use the resume data cache\n+      // (RDC) from the static render to ensure that the data is consistent\n+      // between the static and dynamic renders. Let's now try to render the\n+      // page statically and see that the random number changes.\n+\n+      $ = await next.render$('/')\n+      const random2 = $(`p#${id}`).text()\n+      expect(random2).not.toBe(first)\n+\n+      // Then get the Prefetch RSC and validate that it also contains the new\n+      // random number.\n+      await retry(async () => {\n+        const rsc = await next\n+          .fetch('/', {\n+            headers: {\n+              RSC: '1',\n+              'Next-Router-Prefetch': '1',\n+            },\n+          })\n+          .then((res) => res.text())\n+        expect(rsc).toContain(random2)\n+      })\n+\n+      // Then get the dynamic RSC again and validate that it also contains the\n+      // new random number.\n+      await retry(async () => {\n+        const rsc = await next\n+          .fetch('/', {\n+            headers: {\n+              RSC: '1',\n+            },\n+          })\n+          .then((res) => res.text())\n+        expect(rsc).toContain(random2)\n+      })\n+\n+      // This proves that the dynamic RSC was able to use the resume data cache\n+      // (RDC) from the static render to ensure that the data is consistent\n+      // between the static and dynamic renders.\n+    }\n+  )\n+})"
        },
        {
            "sha": "051ec6f7a05691b5c96f4b737d7321f3240ab26b",
            "filename": "test/production/standalone-mode/required-server-files/app/dyn/[slug]/page.js",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Fdyn%2F%5Bslug%5D%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Fdyn%2F%5Bslug%5D%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Fdyn%2F%5Bslug%5D%2Fpage.js?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -1,7 +1,7 @@\n import { headers } from 'next/headers'\n \n export default async function Page({ params }) {\n-  const data = headers()\n+  const data = await headers()\n \n   return (\n     <>"
        },
        {
            "sha": "521e11d2c36ba8e3c683d605162f38238c358ef1",
            "filename": "test/production/standalone-mode/required-server-files/app/rewrite/[slug]/page.js",
            "status": "modified",
            "additions": 10,
            "deletions": 4,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Frewrite%2F%5Bslug%5D%2Fpage.js",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Frewrite%2F%5Bslug%5D%2Fpage.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Fapp%2Frewrite%2F%5Bslug%5D%2Fpage.js?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -1,18 +1,24 @@\n import { Suspense } from 'react'\n-import { unstable_noStore } from 'next/cache'\n+import { connection } from 'next/server'\n \n export function generateStaticParams() {\n-  return [{ slug: 'first-cookie' }]\n+  return [{ slug: 'first-cookie' }, { slug: 'second-cookie' }]\n }\n \n-function Postpone({ children }) {\n-  unstable_noStore()\n+async function Postpone({ children }) {\n+  await connection()\n   return children\n }\n \n export default async function Page({ params }) {\n+  const random = await fetch(\n+    'https://next-data-api-endpoint.vercel.app/api/random',\n+    { cache: 'force-cache' }\n+  ).then((res) => res.text())\n+\n   return (\n     <>\n+      <p id=\"random\">{random}</p>\n       <Suspense>\n         <Postpone>\n           <p id=\"page\">/rewrite/[slug]</p>"
        },
        {
            "sha": "578e06a1f91e34722d15bb5e92dcbd5edbc1b032",
            "filename": "test/production/standalone-mode/required-server-files/required-server-files-ppr.test.ts",
            "status": "modified",
            "additions": 160,
            "deletions": 71,
            "changes": 231,
            "blob_url": "https://github.com/vercel/next.js/blob/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Frequired-server-files-ppr.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/50edb74488b0c2becf74d62a33d8b1721f09742d/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Frequired-server-files-ppr.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fproduction%2Fstandalone-mode%2Frequired-server-files%2Frequired-server-files-ppr.test.ts?ref=50edb74488b0c2becf74d62a33d8b1721f09742d",
            "patch": "@@ -1,6 +1,5 @@\n-import glob from 'glob'\n-import fs from 'fs-extra'\n-import { join } from 'path'\n+import fs from 'node:fs/promises'\n+import { join } from 'node:path'\n import cheerio from 'cheerio'\n import { createNext, FileRef } from 'e2e-utils'\n import { NextInstance } from 'e2e-utils'\n@@ -10,28 +9,25 @@ import {\n   findPort,\n   initNextServerScript,\n   killApp,\n+  retry,\n } from 'next-test-utils'\n-import { ChildProcess } from 'child_process'\n+import { ChildProcess } from 'node:child_process'\n \n describe('required server files app router', () => {\n   let next: NextInstance\n   let server: ChildProcess\n   let appPort: number | string\n-  let delayedPostpone\n-  let rewritePostpone\n+  let delayedPostpone: string\n+  let rewritePostpone: string\n+  let secondCookiePostpone: string\n+  let secondCookieHTML: string\n   let cliOutput = ''\n \n-  const setupNext = async ({\n-    nextEnv,\n-    minimalMode,\n-  }: {\n-    nextEnv?: boolean\n-    minimalMode?: boolean\n-  }) => {\n-    // test build against environment with next support\n-    process.env.NOW_BUILDER = nextEnv ? '1' : ''\n+  beforeAll(async () => {\n+    process.env.NOW_BUILDER = '1'\n     process.env.NEXT_PRIVATE_TEST_HEADERS = '1'\n \n+    // Setup the Next.js app and build it.\n     next = await createNext({\n       files: {\n         app: new FileRef(join(__dirname, 'app')),\n@@ -47,57 +43,60 @@ describe('required server files app router', () => {\n         cacheHandler: './cache-handler.js',\n         experimental: {\n           ppr: true,\n+          clientSegmentCache: true,\n         },\n         eslint: {\n           ignoreDuringBuilds: true,\n         },\n         output: 'standalone',\n       },\n     })\n+\n+    // Stop the server, we're going to restart it using the standalone server\n+    // below after some cleanup.\n     await next.stop()\n \n+    // Read the postponed state and the HTML that was generated at build time\n+    // from the output of the build.\n     delayedPostpone = (await next.readJSON('.next/server/app/delayed.meta'))\n       .postponed\n     rewritePostpone = (\n       await next.readJSON('.next/server/app/rewrite/first-cookie.meta')\n     ).postponed\n+    secondCookiePostpone = (\n+      await next.readJSON('.next/server/app/rewrite/second-cookie.meta')\n+    ).postponed\n+    secondCookieHTML = await next.readFile(\n+      '.next/server/app/rewrite/second-cookie.html'\n+    )\n \n-    await fs.move(\n+    await fs.rename(\n       join(next.testDir, '.next/standalone'),\n       join(next.testDir, 'standalone')\n     )\n-    for (const file of await fs.readdir(next.testDir)) {\n-      if (file !== 'standalone') {\n-        await fs.remove(join(next.testDir, file))\n-        console.log('removed', file)\n-      }\n-    }\n-    const files = glob.sync('**/*', {\n-      cwd: join(next.testDir, 'standalone/.next/server/pages'),\n-      dot: true,\n-    })\n \n-    for (const file of files) {\n-      if (file.endsWith('.json') || file.endsWith('.html')) {\n-        await fs.remove(join(next.testDir, '.next/server', file))\n-      }\n-    }\n+    const serverFilePath = join(next.testDir, 'standalone/server.js')\n \n-    const testServer = join(next.testDir, 'standalone/server.js')\n+    // We're going to use the minimal mode for the server.\n     await fs.writeFile(\n-      testServer,\n-      (await fs.readFile(testServer, 'utf8')).replace(\n+      serverFilePath,\n+      (await fs.readFile(serverFilePath, 'utf8')).replace(\n         'port:',\n-        `minimalMode: ${minimalMode},port:`\n+        `minimalMode: true, port:`\n       )\n     )\n+\n+    // Find a port to use for the server.\n     appPort = await findPort()\n+\n+    // Then we can start the server with the new environment variables.\n     server = await initNextServerScript(\n-      testServer,\n+      serverFilePath,\n       /- Local:/,\n       {\n         ...process.env,\n         PORT: `${appPort}`,\n+        NEXT_PRIVATE_DEBUG_CACHE: '1',\n       },\n       undefined,\n       {\n@@ -110,11 +109,8 @@ describe('required server files app router', () => {\n         },\n       }\n     )\n-  }\n-\n-  beforeAll(async () => {\n-    await setupNext({ nextEnv: true, minimalMode: true })\n   })\n+\n   afterAll(async () => {\n     delete process.env.NEXT_PRIVATE_TEST_HEADERS\n     await next.destroy()\n@@ -125,37 +121,35 @@ describe('required server files app router', () => {\n     expect(next.cliOutput).not.toContain('ERR_INVALID_URL')\n   })\n \n-  // this enables client segment cache in CI\n-  if (process.env.__NEXT_EXPERIMENTAL_PPR) {\n-    it('should de-dupe client segment tree revalidate requests', async () => {\n-      const { segmentPaths } = await next.readJSON(\n-        'standalone/.next/server/app/isr/first.meta'\n-      )\n-      const outputIdx = cliOutput.length\n+  it('should de-dupe client segment tree revalidate requests', async () => {\n+    const { segmentPaths } = await next.readJSON(\n+      'standalone/.next/server/app/isr/first.meta'\n+    )\n+    const outputIdx = cliOutput.length\n \n-      for (const segmentPath of segmentPaths) {\n-        const outputSegmentPath =\n-          join('/isr/[slug].segments', segmentPath) + '.segment.rsc'\n+    for (const segmentPath of segmentPaths) {\n+      const outputSegmentPath =\n+        join('/isr/[slug].segments', segmentPath) + '.segment.rsc'\n \n-        require('console').error('requesting', outputSegmentPath)\n+      require('console').error('requesting', outputSegmentPath)\n \n-        const res = await fetchViaHTTP(appPort, outputSegmentPath, undefined, {\n-          headers: {\n-            'x-matched-path': '/isr/[slug].segments/_tree.segment.rsc',\n-            'x-now-route-matches': 'slug=first&1=first',\n-          },\n-        })\n+      const res = await fetchViaHTTP(appPort, outputSegmentPath, undefined, {\n+        headers: {\n+          'x-matched-path': '/isr/[slug].segments/_tree.segment.rsc',\n+          'x-now-route-matches': createNowRouteMatches({\n+            slug: 'first',\n+          }).toString(),\n+        },\n+      })\n \n-        expect(res.status).toBe(200)\n-        expect(res.headers.get('content-type')).toBe('text/x-component')\n-      }\n+      expect(res.status).toBe(200)\n+      expect(res.headers.get('content-type')).toBe('text/x-component')\n+    }\n \n-      expect(\n-        cliOutput.substring(outputIdx).match(/rendering \\/isr\\/\\[slug\\]/g)\n-          .length\n-      ).toBe(1)\n-    })\n-  }\n+    expect(\n+      cliOutput.substring(outputIdx).match(/rendering \\/isr\\/\\[slug\\]/g).length\n+    ).toBe(1)\n+  })\n \n   it('should properly stream resume with Next-Resume', async () => {\n     const res = await fetchViaHTTP(appPort, '/delayed', undefined, {\n@@ -181,11 +175,6 @@ describe('required server files app router', () => {\n     const firstSuspense = chunks.find((item) => item.chunk.includes('time'))\n     const secondSuspense = chunks.find((item) => item.chunk.includes('random'))\n \n-    console.log({\n-      firstSuspense,\n-      secondSuspense,\n-    })\n-\n     expect(secondSuspense.time - firstSuspense.time).toBeGreaterThanOrEqual(\n       2 * 1000\n     )\n@@ -363,6 +352,9 @@ describe('required server files app router', () => {\n     const res = await fetchViaHTTP(appPort, '/dyn/first.rsc', undefined, {\n       headers: {\n         'x-matched-path': '/dyn/[slug]',\n+        'x-now-route-matches': createNowRouteMatches({\n+          slug: 'first',\n+        }).toString(),\n       },\n     })\n \n@@ -379,6 +371,9 @@ describe('required server files app router', () => {\n       {\n         headers: {\n           'x-matched-path': '/dyn/[slug]',\n+          'x-now-route-matches': createNowRouteMatches({\n+            slug: 'first',\n+          }).toString(),\n         },\n       }\n     )\n@@ -388,6 +383,100 @@ describe('required server files app router', () => {\n     expect(res.headers.has('x-nextjs-postponed')).toBeTrue()\n   })\n \n+  it('should use the postponed state for the RSC requests', async () => {\n+    // Let's parse the random number out of the HTML that was generated at build\n+    // time. We want to use that value as it's the one that's tied to the\n+    // postponed state that we also have.\n+    const $ = cheerio.load(secondCookieHTML)\n+\n+    const random = $('#random').text()\n+    expect(random).toBeDefined()\n+    expect(random.length).toBeGreaterThan(0)\n+\n+    // Record the start of the logs for this test.\n+    let start = cliOutput.length\n+\n+    // Then let's do a Dynamic RSC request and verify that the random value is\n+    // not present in the response without passing the postponed state.\n+    let res = await fetchViaHTTP(\n+      appPort,\n+      '/rewrite/second-cookie.rsc',\n+      undefined,\n+      {\n+        headers: {\n+          'x-matched-path': '/rewrite/[slug]',\n+          'x-now-route-matches': createNowRouteMatches({\n+            slug: 'second-cookie',\n+          }).toString(),\n+        },\n+      }\n+    )\n+\n+    expect(res.status).toBe(200)\n+    expect(res.headers.get('content-type')).toEqual('text/x-component')\n+    expect(res.headers.has('x-nextjs-postponed')).toBeFalse()\n+\n+    // We expect that the random value is not present in the response because\n+    // we're not providing a resume data cache via the postponed state.\n+    // Instead it'll contain another random number that's been generated at\n+    // runtime.\n+    let rsc = await res.text()\n+    expect(rsc).not.toContain(random)\n+\n+    // Ensure that we hit the cache handler and not the resume data cache.\n+    await retry(() => {\n+      expect(cliOutput.substring(start)).toContain('cache-handler get')\n+      expect(cliOutput.substring(start)).toContain('cache-handler set')\n+\n+      // We expect that there is no resume data cache hit or miss because\n+      // we're not providing a resume data cache via the postponed state.\n+      expect(cliOutput.substring(start)).not.toContain('rdc:miss')\n+      expect(cliOutput.substring(start)).not.toContain('rdc:hit')\n+      expect(cliOutput.substring(start)).toContain('rdc:no-resume-data')\n+    })\n+\n+    // Reset the start of the logs for this test.\n+    start = cliOutput.length\n+\n+    // Then let's get the Dynamic RSC request and verify that the random value\n+    // is present in the response by passing the postponed state.\n+    res = await fetchViaHTTP(appPort, '/rewrite/second-cookie.rsc', undefined, {\n+      method: 'POST',\n+      headers: {\n+        'x-matched-path': '/rewrite/[slug]',\n+        'x-now-route-matches': createNowRouteMatches({\n+          slug: 'second-cookie',\n+        }).toString(),\n+        'next-resume': '1',\n+      },\n+      body: secondCookiePostpone,\n+    })\n+\n+    expect(res.status).toBe(200)\n+    expect(res.headers.get('content-type')).toEqual('text/x-component')\n+    expect(res.headers.has('x-nextjs-postponed')).toBeFalse()\n+\n+    // We expect that the random value is present in the response because\n+    // we're providing a resume data cache via the postponed state.\n+    rsc = await res.text()\n+    expect(rsc).toContain(random)\n+\n+    // Ensure that we hit the resume data cache and not the cache handler.\n+    await retry(() => {\n+      expect(cliOutput.substring(start)).not.toContain('cache-handler get')\n+      expect(cliOutput.substring(start)).not.toContain('cache-handler set')\n+\n+      // We expect that there is a resume data cache hit because we're providing\n+      // a resume data cache via the postponed state.\n+      expect(cliOutput.substring(start)).toContain('rdc:hit')\n+\n+      // We expect that there is no resume data cache miss because we're\n+      // providing a resume data cache via the postponed state.\n+      expect(cliOutput.substring(start)).not.toContain('rdc:miss')\n+      expect(cliOutput.substring(start)).not.toContain('rdc:no-resume-data')\n+    })\n+  })\n+\n   it('should handle revalidating the fallback page', async () => {\n     const res = await fetchViaHTTP(appPort, '/postpone/isr/[slug]', undefined, {\n       headers: {"
        }
    ],
    "stats": {
        "total": 1777,
        "additions": 1325,
        "deletions": 452
    }
}