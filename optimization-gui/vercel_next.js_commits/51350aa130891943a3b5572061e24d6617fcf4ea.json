{
    "author": "huozhi",
    "message": "[metadata] refactor metadata loaders (#83304)",
    "sha": "51350aa130891943a3b5572061e24d6617fcf4ea",
    "files": [
        {
            "sha": "f7c8f3a0bd6858f34e25d30c4c4ffacbb311bb49",
            "filename": "crates/next-core/src/next_app/metadata/image.rs",
            "status": "modified",
            "additions": 117,
            "deletions": 34,
            "changes": 151,
            "blob_url": "https://github.com/vercel/next.js/blob/51350aa130891943a3b5572061e24d6617fcf4ea/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Fimage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/51350aa130891943a3b5572061e24d6617fcf4ea/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Fimage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Fimage.rs?ref=51350aa130891943a3b5572061e24d6617fcf4ea",
            "patch": "@@ -41,12 +41,11 @@ async fn hash_file_content(path: FileSystemPath) -> Result<u64> {\n     })\n }\n \n-#[turbo_tasks::function]\n-pub async fn dynamic_image_metadata_source(\n-    asset_context: Vc<Box<dyn AssetContext>>,\n+async fn dynamic_image_metadata_with_generator_source(\n     path: FileSystemPath,\n     ty: RcStr,\n     page: AppPage,\n+    exported_fields_excluding_default: String,\n ) -> Result<Vc<Box<dyn Source>>> {\n     let stem = path.file_stem();\n     let stem = stem.unwrap_or_default();\n@@ -58,37 +57,14 @@ pub async fn dynamic_image_metadata_source(\n     let sizes = if use_numeric_sizes {\n         \"data.width = size.width; data.height = size.height;\".to_string()\n     } else {\n-        // Note: This case seemingly can never happen because this code runs for dynamic metadata\n-        // which has e.g. a `.js` or `.ts` extension not `.svg`. Branching code is still here to\n-        // match the static implementation\n-        //\n-        // For SVGs, skip sizes and use \"any\" to let it scale automatically based on viewport,\n-        // For the images doesn't provide the size properly, use \"any\" as well.\n-        // If the size is presented, use the actual size for the image.\n         let sizes = if ext == \"svg\" {\n             \"any\"\n         } else {\n             \"${size.width}x${size.height}\"\n         };\n-\n         format!(\"data.sizes = `{sizes}`;\")\n     };\n \n-    let source = Vc::upcast(FileSource::new(path.clone()));\n-    let module = asset_context\n-        .process(\n-            source,\n-            ReferenceType::EcmaScriptModules(EcmaScriptModulesReferenceSubType::Undefined),\n-        )\n-        .module();\n-    let exports = &*collect_direct_exports(module).await?;\n-    let exported_fields_excluding_default = exports\n-        .iter()\n-        .filter(|e| *e != \"default\")\n-        .cloned()\n-        .collect::<Vec<_>>()\n-        .join(\", \");\n-\n     let code = formatdoc! {\n         r#\"\n             import {{ {exported_fields_excluding_default} }} from {resource_path}\n@@ -115,15 +91,79 @@ pub async fn dynamic_image_metadata_source(\n                     return data\n                 }}\n \n-                if (generateImageMetadata) {{\n-                    const imageMetadataArray = await generateImageMetadata({{ params }})\n-                    return imageMetadataArray.map((imageMetadata, index) => {{\n-                        const idParam = (imageMetadata.id || index) + ''\n-                        return getImageMetadata(imageMetadata, idParam)\n-                    }})\n-                }} else {{\n-                    return [getImageMetadata(imageModule, '')]\n+                const imageMetadataArray = await generateImageMetadata({{ params }})\n+                return imageMetadataArray.map((imageMetadata, index) => {{\n+                    const idParam = (imageMetadata.id || index) + ''\n+                    return getImageMetadata(imageMetadata, idParam)\n+                }})\n+            }}\n+        \"#,\n+        exported_fields_excluding_default = exported_fields_excluding_default,\n+        resource_path = StringifyJs(&format!(\"./{stem}.{ext}\")),\n+        pathname_prefix = StringifyJs(&page.to_string()),\n+        page_segment = StringifyJs(stem),\n+        sizes = sizes,\n+        hash_query = StringifyJs(&hash_query),\n+    };\n+\n+    let file = File::from(code);\n+    let source = VirtualSource::new(\n+        path.parent().join(&format!(\"{stem}--metadata.js\"))?,\n+        AssetContent::file(file.into()),\n+    );\n+\n+    Ok(Vc::upcast(source))\n+}\n+\n+async fn dynamic_image_metadata_without_generator_source(\n+    path: FileSystemPath,\n+    ty: RcStr,\n+    page: AppPage,\n+    exported_fields_excluding_default: String,\n+) -> Result<Vc<Box<dyn Source>>> {\n+    let stem = path.file_stem();\n+    let stem = stem.unwrap_or_default();\n+    let ext = path.extension();\n+\n+    let hash_query = format!(\"?{:x}\", hash_file_content(path.clone()).await?);\n+\n+    let use_numeric_sizes = ty == \"twitter\" || ty == \"openGraph\";\n+    let sizes = if use_numeric_sizes {\n+        \"data.width = size.width; data.height = size.height;\".to_string()\n+    } else {\n+        let sizes = if ext == \"svg\" {\n+            \"any\"\n+        } else {\n+            \"${size.width}x${size.height}\"\n+        };\n+        format!(\"data.sizes = `{sizes}`;\")\n+    };\n+\n+    let code = formatdoc! {\n+        r#\"\n+            import {{ {exported_fields_excluding_default} }} from {resource_path}\n+            import {{ fillMetadataSegment }} from 'next/dist/lib/metadata/get-metadata-route'\n+\n+            const imageModule = {{ {exported_fields_excluding_default} }}\n+\n+            export default async function (props) {{\n+                const {{ __metadata_id__: _, ...params }} = await props.params\n+                const imageUrl = fillMetadataSegment({pathname_prefix}, params, {page_segment})\n+\n+                function getImageMetadata(imageMetadata, idParam) {{\n+                    const data = {{\n+                        alt: imageMetadata.alt,\n+                        type: imageMetadata.contentType || 'image/png',\n+                        url: imageUrl + (idParam ? ('/' + idParam) : '') + {hash_query},\n+                    }}\n+                    const {{ size }} = imageMetadata\n+                    if (size) {{\n+                        {sizes}\n+                    }}\n+                    return data\n                 }}\n+\n+                return [getImageMetadata(imageModule, '')]\n             }}\n         \"#,\n         exported_fields_excluding_default = exported_fields_excluding_default,\n@@ -143,6 +183,49 @@ pub async fn dynamic_image_metadata_source(\n     Ok(Vc::upcast(source))\n }\n \n+#[turbo_tasks::function]\n+pub async fn dynamic_image_metadata_source(\n+    asset_context: Vc<Box<dyn AssetContext>>,\n+    path: FileSystemPath,\n+    ty: RcStr,\n+    page: AppPage,\n+) -> Result<Vc<Box<dyn Source>>> {\n+    let source = Vc::upcast(FileSource::new(path.clone()));\n+    let module = asset_context\n+        .process(\n+            source,\n+            ReferenceType::EcmaScriptModules(EcmaScriptModulesReferenceSubType::Undefined),\n+        )\n+        .module();\n+    let exports = &*collect_direct_exports(module).await?;\n+    let exported_fields_excluding_default = exports\n+        .iter()\n+        .filter(|e| *e != \"default\")\n+        .cloned()\n+        .collect::<Vec<_>>()\n+        .join(\", \");\n+\n+    let has_generate_image_metadata = exports.contains(&\"generateImageMetadata\".into());\n+\n+    if has_generate_image_metadata {\n+        dynamic_image_metadata_with_generator_source(\n+            path,\n+            ty,\n+            page,\n+            exported_fields_excluding_default,\n+        )\n+        .await\n+    } else {\n+        dynamic_image_metadata_without_generator_source(\n+            path,\n+            ty,\n+            page,\n+            exported_fields_excluding_default,\n+        )\n+        .await\n+    }\n+}\n+\n #[turbo_tasks::function]\n async fn collect_direct_exports(module: Vc<Box<dyn Module>>) -> Result<Vc<Vec<RcStr>>> {\n     let Some(ecmascript_asset) ="
        },
        {
            "sha": "064705623b30683ad78dbbfdd6cec96ea6da60d3",
            "filename": "crates/next-core/src/next_app/metadata/route.rs",
            "status": "modified",
            "additions": 96,
            "deletions": 42,
            "changes": 138,
            "blob_url": "https://github.com/vercel/next.js/blob/51350aa130891943a3b5572061e24d6617fcf4ea/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Froute.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/51350aa130891943a3b5572061e24d6617fcf4ea/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Froute.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_app%2Fmetadata%2Froute.rs?ref=51350aa130891943a3b5572061e24d6617fcf4ea",
            "patch": "@@ -47,7 +47,7 @@ pub async fn get_app_metadata_route_source(\n             } else if stem == \"sitemap\" {\n                 dynamic_site_map_route_source(mode, path, is_multi_dynamic)\n             } else {\n-                dynamic_image_route_source(path)\n+                dynamic_image_route_source(path, is_multi_dynamic)\n             }\n         }\n     })\n@@ -275,21 +275,37 @@ async fn dynamic_site_map_route_source(\n     let ext = path.extension();\n     let content_type = get_content_type(path.clone()).await?;\n     let mut static_generation_code = \"\";\n-\n-    if mode.is_production() && is_multi_dynamic {\n-        static_generation_code = indoc! {\n-            r#\"\n-                export async function generateStaticParams() {\n-                    const sitemaps = await generateSitemaps()\n-                    const params = []\n-\n-                    for (const item of sitemaps) {{\n-                        params.push({ __metadata_id__: item.id.toString() + '.xml' })\n-                    }}\n-                    return params\n-                }\n-            \"#,\n-        };\n+    let mut validation_code = \"\";\n+\n+    if is_multi_dynamic {\n+        if mode.is_production() {\n+            static_generation_code = indoc! {\n+                r#\"\n+                    export async function generateStaticParams() {\n+                        const sitemaps = await generateSitemaps()\n+                        const params = []\n+\n+                        for (const item of sitemaps) {{\n+                            params.push({ __metadata_id__: item.id.toString() + '.xml' })\n+                        }}\n+                        return params\n+                    }\n+                \"#,\n+            };\n+        } else {\n+            validation_code = indoc! {\n+                r#\"\n+                    if (process.env.NODE_ENV !== 'production' && sitemapModule.generateSitemaps) {\n+                        const sitemaps = await sitemapModule.generateSitemaps()\n+                        for (const item of sitemaps) {\n+                            if (item?.id == null) {\n+                                throw new Error('id property is required for every item returned from generateSitemaps')\n+                            }\n+                        }\n+                    }\n+                \"#,\n+            };\n+        }\n     }\n \n     let code = formatdoc! {\n@@ -318,14 +334,7 @@ async fn dynamic_site_map_route_source(\n                     }})\n                 }}\n \n-                if (process.env.NODE_ENV !== 'production' && sitemapModule.generateSitemaps) {{\n-                    const sitemaps = await sitemapModule.generateSitemaps()\n-                    for (const item of sitemaps) {{\n-                        if (item?.id == null) {{\n-                            throw new Error('id property is required for every item returned from generateSitemaps')\n-                        }}\n-                    }}\n-                }}\n+                {validation_code}\n                 \n                 const targetId = id && hasXmlExtension ? id.slice(0, -4) : undefined\n                 const data = await handler({{ id: targetId }})\n@@ -347,6 +356,7 @@ async fn dynamic_site_map_route_source(\n         content_type = StringifyJs(&content_type),\n         file_type = StringifyJs(&stem),\n         cache_control = StringifyJs(CACHE_HEADER_REVALIDATE),\n+        validation_code = validation_code,\n         static_generation_code = static_generation_code,\n     };\n \n@@ -359,8 +369,9 @@ async fn dynamic_site_map_route_source(\n     Ok(Vc::upcast(source))\n }\n \n-#[turbo_tasks::function]\n-async fn dynamic_image_route_source(path: FileSystemPath) -> Result<Vc<Box<dyn Source>>> {\n+async fn dynamic_image_route_with_metadata_source(\n+    path: FileSystemPath,\n+) -> Result<Vc<Box<dyn Source>>> {\n     let stem = path.file_stem();\n     let stem = stem.unwrap_or_default();\n     let ext = path.extension();\n@@ -384,24 +395,21 @@ async fn dynamic_image_route_source(path: FileSystemPath) -> Result<Vc<Box<dyn S\n                 const {{ __metadata_id__, ...rest }} = params || {{}}\n                 const restParams = params ? rest : undefined\n                 const targetId = __metadata_id__\n-                let id = undefined\n-\n-                if (generateImageMetadata) {{\n-                    const imageMetadata = await generateImageMetadata({{ params: restParams }})\n-                    id = imageMetadata.find((item) => {{\n-                        if (process.env.NODE_ENV !== 'production') {{\n-                            if (item?.id == null) {{\n-                                throw new Error('id property is required for every item returned from generateImageMetadata')\n-                            }}\n-                        }}\n-                        return item.id.toString() === targetId\n-                    }})?.id\n \n-                    if (id == null) {{\n-                        return new NextResponse('Not Found', {{\n-                            status: 404,\n-                        }})\n+                const imageMetadata = await generateImageMetadata({{ params: restParams }})\n+                const id = imageMetadata.find((item) => {{\n+                    if (process.env.NODE_ENV !== 'production') {{\n+                        if (item?.id == null) {{\n+                            throw new Error('id property is required for every item returned from generateImageMetadata')\n+                        }}\n                     }}\n+                    return item.id.toString() === targetId\n+                }})?.id\n+\n+                if (id == null) {{\n+                    return new NextResponse('Not Found', {{\n+                        status: 404,\n+                    }})\n                 }}\n \n                 return handler({{ params: restParams, id }})\n@@ -421,6 +429,52 @@ async fn dynamic_image_route_source(path: FileSystemPath) -> Result<Vc<Box<dyn S\n     Ok(Vc::upcast(source))\n }\n \n+async fn dynamic_image_route_without_metadata_source(\n+    path: FileSystemPath,\n+) -> Result<Vc<Box<dyn Source>>> {\n+    let stem = path.file_stem();\n+    let stem = stem.unwrap_or_default();\n+    let ext = path.extension();\n+\n+    let code = formatdoc! {\n+        r#\"\n+            import {{ NextResponse }} from 'next/server'\n+            import {{ default as handler }} from {resource_path}\n+\n+            if (typeof handler !== 'function') {{\n+                throw new Error('Default export is missing in {resource_path}')\n+            }}\n+\n+            export async function GET(_, ctx) {{\n+                return handler({{ params: await ctx.params }})\n+            }}\n+\n+            export * from {resource_path}\n+        \"#,\n+        resource_path = StringifyJs(&format!(\"./{stem}.{ext}\")),\n+    };\n+\n+    let file = File::from(code);\n+    let source = VirtualSource::new(\n+        path.parent().join(&format!(\"{stem}--route-entry.js\"))?,\n+        AssetContent::file(file.into()),\n+    );\n+\n+    Ok(Vc::upcast(source))\n+}\n+\n+#[turbo_tasks::function]\n+async fn dynamic_image_route_source(\n+    path: FileSystemPath,\n+    is_multi_dynamic: bool,\n+) -> Result<Vc<Box<dyn Source>>> {\n+    if is_multi_dynamic {\n+        dynamic_image_route_with_metadata_source(path).await\n+    } else {\n+        dynamic_image_route_without_metadata_source(path).await\n+    }\n+}\n+\n #[turbo_tasks::value(shared)]\n struct StaticMetadataFileSizeIssue {\n     img_name: RcStr,"
        },
        {
            "sha": "991777dd22b7152866a0e900951aa713db6e0d68",
            "filename": "packages/next/src/build/webpack/loaders/next-metadata-image-loader.ts",
            "status": "modified",
            "additions": 24,
            "deletions": 25,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/51350aa130891943a3b5572061e24d6617fcf4ea/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-metadata-image-loader.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/51350aa130891943a3b5572061e24d6617fcf4ea/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-metadata-image-loader.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-metadata-image-loader.ts?ref=51350aa130891943a3b5572061e24d6617fcf4ea",
            "patch": "@@ -83,41 +83,40 @@ async function nextMetadataImageLoader(\n         .join(',')}\n     }\n \n-    export default async function (props) {\n-      const { __metadata_id__: _, ...params } = await props.params\n+    function getImageMetadata(imageMetadata, idParam, resolvedParams) {\n       const imageUrl = fillMetadataSegment(${JSON.stringify(\n         pathnamePrefix\n-      )}, params, ${JSON.stringify(pageSegment)})\n-\n-      const { generateImageMetadata } = imageModule\n-\n-      function getImageMetadata(imageMetadata, idParam) {\n-        const data = {\n-          alt: imageMetadata.alt,\n-          type: imageMetadata.contentType || 'image/png',\n-          url: imageUrl + (idParam ? ('/' + idParam) : '') + ${JSON.stringify(\n-            hashQuery\n-          )},\n-        }\n-        const { size } = imageMetadata\n-        if (size) {\n-          ${\n-            type === 'twitter' || type === 'openGraph'\n-              ? 'data.width = size.width; data.height = size.height;'\n-              : 'data.sizes = size.width + \"x\" + size.height;'\n-          }\n+      )}, resolvedParams, ${JSON.stringify(pageSegment)})\n+      const data = {\n+        alt: imageMetadata.alt,\n+        type: imageMetadata.contentType || 'image/png',\n+        url: imageUrl + (idParam ? ('/' + idParam) : '') + ${JSON.stringify(\n+          hashQuery\n+        )},\n+      }\n+      const { size } = imageMetadata\n+      if (size) {\n+        ${\n+          type === 'twitter' || type === 'openGraph'\n+            ? 'data.width = size.width; data.height = size.height;'\n+            : 'data.sizes = size.width + \"x\" + size.height;'\n         }\n-        return data\n       }\n+      return data\n+    }\n+\n+    export default async function (props) {\n+      const { generateImageMetadata } = imageModule\n+      const resolvedParams = await props.params\n \n       if (generateImageMetadata) {\n-        const imageMetadataArray = await generateImageMetadata({ params })\n+        const imageMetadataArray = await generateImageMetadata({ params: resolvedParams })\n         return imageMetadataArray.map((imageMetadata, index) => {\n           const idParam = (imageMetadata.id || index) + ''\n-          return getImageMetadata(imageMetadata, idParam)\n+          return getImageMetadata(imageMetadata, idParam, resolvedParams)\n         })\n       } else {\n-        return [getImageMetadata(imageModule, '')]\n+        return [getImageMetadata(imageModule, '', resolvedParams)]\n       }\n     }`\n   }"
        },
        {
            "sha": "68f160f8b6f549a4f4494700e4bcbbdee0cca571",
            "filename": "packages/next/src/build/webpack/loaders/next-metadata-route-loader.ts",
            "status": "modified",
            "additions": 51,
            "deletions": 27,
            "changes": 78,
            "blob_url": "https://github.com/vercel/next.js/blob/51350aa130891943a3b5572061e24d6617fcf4ea/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-metadata-route-loader.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/51350aa130891943a3b5572061e24d6617fcf4ea/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-metadata-route-loader.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fbuild%2Fwebpack%2Floaders%2Fnext-metadata-route-loader.ts?ref=51350aa130891943a3b5572061e24d6617fcf4ea",
            "patch": "@@ -153,20 +153,14 @@ export async function GET() {\n `\n }\n \n-// <metadata-image>/[id]/route.js\n async function getDynamicImageRouteCode(\n   resourcePath: string,\n   loaderContext: webpack.LoaderContext<any>\n ) {\n   return `\\\n-/* dynamic image route */\n+/* dynamic image route with generateImageMetadata */\n import { NextResponse } from 'next/server'\n-import * as userland from ${JSON.stringify(resourcePath)}\n-\n-const imageModule = { ...userland }\n-\n-const handler = imageModule.default\n-const generateImageMetadata = imageModule.generateImageMetadata\n+import { default as handler, generateImageMetadata } from ${JSON.stringify(resourcePath)}\n \n ${errorOnBadHandler(resourcePath)}\n ${await createReExportsCode(resourcePath, loaderContext)}\n@@ -175,31 +169,63 @@ export async function GET(_, ctx) {\n   const params = await ctx.params\n   const { __metadata_id__, ...rest } = params || {}\n   const restParams = params ? rest : undefined\n-  const targetId = __metadata_id__\n-  let id = undefined\n-  \n-  if (generateImageMetadata) {\n-    const imageMetadata = await generateImageMetadata({ params: restParams })\n-    id = imageMetadata.find((item) => {\n-      if (process.env.NODE_ENV !== 'production') {\n-        if (item?.id == null) {\n-          throw new Error('id property is required for every item returned from generateImageMetadata')\n-        }\n+  const imageMetadata = await generateImageMetadata({ params: restParams })\n+  const id = imageMetadata.find((item) => {\n+    if (process.env.NODE_ENV !== 'production') {\n+      if (item?.id == null) {\n+        throw new Error('id property is required for every item returned from generateImageMetadata')\n       }\n-      return item.id.toString() === targetId\n-    })?.id\n-    if (id == null) {\n-      return new NextResponse('Not Found', {\n-        status: 404,\n-      })\n     }\n+    return item.id.toString() === __metadata_id__\n+  })?.id\n+  if (id == null) {\n+    return new NextResponse('Not Found', {\n+      status: 404,\n+    })\n   }\n \n   return handler({ params: restParams, id })\n }\n `\n }\n \n+async function getSingleImageRouteCode(\n+  resourcePath: string,\n+  loaderContext: webpack.LoaderContext<any>\n+) {\n+  return `\\\n+/* dynamic image route without generateImageMetadata */\n+import { NextResponse } from 'next/server'\n+import { default as handler } from ${JSON.stringify(resourcePath)}\n+\n+${errorOnBadHandler(resourcePath)}\n+${await createReExportsCode(resourcePath, loaderContext)}\n+\n+export async function GET(_, ctx) {\n+  return handler({ params: await ctx.params })\n+}\n+`\n+}\n+\n+// <metadata-image>/[id]/route.js\n+async function getImageRouteCode(\n+  resourcePath: string,\n+  loaderContext: webpack.LoaderContext<any>\n+) {\n+  const exportNames = await getLoaderModuleNamedExports(\n+    resourcePath,\n+    loaderContext\n+  )\n+\n+  const hasGenerateParamsExport = exportNames.includes('generateImageMetadata')\n+\n+  if (hasGenerateParamsExport) {\n+    return getDynamicImageRouteCode(resourcePath, loaderContext)\n+  } else {\n+    return getSingleImageRouteCode(resourcePath, loaderContext)\n+  }\n+}\n+\n async function getDynamicSitemapRouteCode(\n   resourcePath: string,\n   loaderContext: webpack.LoaderContext<any>\n@@ -244,7 +270,6 @@ ${await createReExportsCode(resourcePath, loaderContext)}\n export async function GET(_, ctx) {\n   const { __metadata_id__: id, ...params } = await ctx.params || {}\n   const hasXmlExtension = id ? id.endsWith('.xml') : false\n-\n   if (id && !hasXmlExtension) {\n     return new NextResponse('Not Found', {\n       status: 404,\n@@ -261,7 +286,6 @@ export async function GET(_, ctx) {\n   }\n \n   const targetId = id && hasXmlExtension ? id.slice(0, -4) : undefined\n-\n   const data = await handler({ id: targetId })\n   const content = resolveRouteData(data, fileType)\n \n@@ -293,7 +317,7 @@ const nextMetadataRouterLoader: webpack.LoaderDefinitionFunction<MetadataRouteLo\n       } else if (fileBaseName === 'sitemap') {\n         code = await getDynamicSitemapRouteCode(filePath, this)\n       } else {\n-        code = await getDynamicImageRouteCode(filePath, this)\n+        code = await getImageRouteCode(filePath, this)\n       }\n     } else {\n       code = await getStaticAssetRouteCode(filePath, fileBaseName)"
        }
    ],
    "stats": {
        "total": 416,
        "additions": 288,
        "deletions": 128
    }
}