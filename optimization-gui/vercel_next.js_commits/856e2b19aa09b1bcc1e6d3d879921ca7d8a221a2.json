{
    "author": "acdlite",
    "message": "[Segment Cache] Implement scroll-to-new-page (#76170)\n\nThis implements Next's scroll-to-new-page behavior in the Segment Cache.\n\nThe LayoutRouter expects an array of segment paths that represents every\npage in the new route tree. In the old implementation, this is generated\nby the `generateSegmentsFromPatch` function. In the new implementation,\nI've chosen to generate this array during the main tree traversal that\nhappens in `startPPRNavigation`.\n\nAs a future improvement, we should use the same segment path type that\nwe use to access Segment Cache entries; there's no reason to have two\nrepresentations of the same concept.",
    "sha": "856e2b19aa09b1bcc1e6d3d879921ca7d8a221a2",
    "files": [
        {
            "sha": "0d5791ac023f27f662d977d5fbdf67e46837a143",
            "filename": "packages/next/src/client/components/router-reducer/ppr-navigations.ts",
            "status": "modified",
            "additions": 112,
            "deletions": 45,
            "changes": 157,
            "blob_url": "https://github.com/vercel/next.js/blob/856e2b19aa09b1bcc1e6d3d879921ca7d8a221a2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/856e2b19aa09b1bcc1e6d3d879921ca7d8a221a2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts?ref=856e2b19aa09b1bcc1e6d3d879921ca7d8a221a2",
            "patch": "@@ -91,16 +91,20 @@ export function startPPRNavigation(\n   newRouterState: FlightRouterState,\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n-  isPrefetchHeadPartial: boolean\n+  isPrefetchHeadPartial: boolean,\n+  scrollableSegmentsResult: Array<FlightSegmentPath>\n ): Task | null {\n+  const segmentPath: Array<FlightSegmentPath> = []\n   return updateCacheNodeOnNavigation(\n     oldCacheNode,\n     oldRouterState,\n     newRouterState,\n     false,\n     prefetchData,\n     prefetchHead,\n-    isPrefetchHeadPartial\n+    isPrefetchHeadPartial,\n+    segmentPath,\n+    scrollableSegmentsResult\n   )\n }\n \n@@ -111,7 +115,9 @@ function updateCacheNodeOnNavigation(\n   didFindRootLayout: boolean,\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n-  isPrefetchHeadPartial: boolean\n+  isPrefetchHeadPartial: boolean,\n+  segmentPath: FlightSegmentPath,\n+  scrollableSegmentsResult: Array<FlightSegmentPath>\n ): Task | null {\n   // Diff the old and new trees to reuse the shared layouts.\n   const oldRouterStateChildren = oldRouterState[1]\n@@ -187,6 +193,10 @@ function updateCacheNodeOnNavigation(\n         : null\n \n     const newSegmentChild = newRouterStateChild[0]\n+    const newSegmentPathChild = segmentPath.concat([\n+      parallelRouteKey,\n+      newSegmentChild,\n+    ])\n     const newSegmentKeyChild = createRouterCacheKey(newSegmentChild)\n \n     const oldSegmentChild =\n@@ -219,7 +229,9 @@ function updateCacheNodeOnNavigation(\n           didFindRootLayout,\n           prefetchDataChild !== undefined ? prefetchDataChild : null,\n           prefetchHead,\n-          isPrefetchHeadPartial\n+          isPrefetchHeadPartial,\n+          newSegmentPathChild,\n+          scrollableSegmentsResult\n         )\n       }\n     } else if (\n@@ -240,7 +252,9 @@ function updateCacheNodeOnNavigation(\n           didFindRootLayout,\n           prefetchDataChild,\n           prefetchHead,\n-          isPrefetchHeadPartial\n+          isPrefetchHeadPartial,\n+          newSegmentPathChild,\n+          scrollableSegmentsResult\n         )\n       } else {\n         // There's no existing Cache Node for this segment. Switch to the\n@@ -251,7 +265,9 @@ function updateCacheNodeOnNavigation(\n           didFindRootLayout,\n           prefetchDataChild !== undefined ? prefetchDataChild : null,\n           prefetchHead,\n-          isPrefetchHeadPartial\n+          isPrefetchHeadPartial,\n+          newSegmentPathChild,\n+          scrollableSegmentsResult\n         )\n       }\n     } else {\n@@ -262,7 +278,9 @@ function updateCacheNodeOnNavigation(\n         didFindRootLayout,\n         prefetchDataChild !== undefined ? prefetchDataChild : null,\n         prefetchHead,\n-        isPrefetchHeadPartial\n+        isPrefetchHeadPartial,\n+        newSegmentPathChild,\n+        scrollableSegmentsResult\n       )\n     }\n \n@@ -353,7 +371,9 @@ function beginRenderingNewRouteTree(\n   didFindRootLayout: boolean,\n   prefetchData: CacheNodeSeedData | null,\n   possiblyPartialPrefetchHead: HeadData | null,\n-  isPrefetchHeadPartial: boolean\n+  isPrefetchHeadPartial: boolean,\n+  segmentPath: FlightSegmentPath,\n+  scrollableSegmentsResult: Array<FlightSegmentPath>\n ): Task {\n   if (!didFindRootLayout) {\n     // The route tree changed before we reached a layout. (The highest-level\n@@ -387,15 +407,19 @@ function beginRenderingNewRouteTree(\n     newRouterState,\n     prefetchData,\n     possiblyPartialPrefetchHead,\n-    isPrefetchHeadPartial\n+    isPrefetchHeadPartial,\n+    segmentPath,\n+    scrollableSegmentsResult\n   )\n }\n \n function createCacheNodeOnNavigation(\n   routerState: FlightRouterState,\n   prefetchData: CacheNodeSeedData | null,\n   possiblyPartialPrefetchHead: HeadData | null,\n-  isPrefetchHeadPartial: boolean\n+  isPrefetchHeadPartial: boolean,\n+  segmentPath: FlightSegmentPath,\n+  scrollableSegmentsResult: Array<FlightSegmentPath>\n ): SPANavigationTask {\n   // Same traversal as updateCacheNodeNavigation, but we switch to this path\n   // once we reach the part of the tree that was not in the previous route. We\n@@ -409,7 +433,9 @@ function createCacheNodeOnNavigation(\n       routerState,\n       null,\n       possiblyPartialPrefetchHead,\n-      isPrefetchHeadPartial\n+      isPrefetchHeadPartial,\n+      segmentPath,\n+      scrollableSegmentsResult\n     )\n   }\n \n@@ -435,7 +461,9 @@ function createCacheNodeOnNavigation(\n       routerState,\n       prefetchData,\n       possiblyPartialPrefetchHead,\n-      isPrefetchHeadPartial\n+      isPrefetchHeadPartial,\n+      segmentPath,\n+      scrollableSegmentsResult\n     )\n   }\n \n@@ -449,35 +477,51 @@ function createCacheNodeOnNavigation(\n     [parallelRouteKey: string]: FlightRouterState\n   } = {}\n   let needsDynamicRequest = false\n-  for (let parallelRouteKey in routerStateChildren) {\n-    const routerStateChild: FlightRouterState =\n-      routerStateChildren[parallelRouteKey]\n-    const prefetchDataChild: CacheNodeSeedData | void | null =\n-      prefetchDataChildren !== null\n-        ? prefetchDataChildren[parallelRouteKey]\n-        : null\n-    const segmentChild = routerStateChild[0]\n-    const segmentKeyChild = createRouterCacheKey(segmentChild)\n-    const taskChild = createCacheNodeOnNavigation(\n-      routerStateChild,\n-      prefetchDataChild,\n-      possiblyPartialPrefetchHead,\n-      isPrefetchHeadPartial\n-    )\n-    taskChildren.set(parallelRouteKey, taskChild)\n-    const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n-    if (dynamicRequestTreeChild !== null) {\n-      // Something in the child tree is dynamic.\n-      needsDynamicRequest = true\n-      dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n-    } else {\n-      dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild\n-    }\n-    const newCacheNodeChild = taskChild.node\n-    if (newCacheNodeChild !== null) {\n-      const newSegmentMapChild: ChildSegmentMap = new Map()\n-      newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n-      cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)\n+  if (isLeafSegment) {\n+    // The segment path of every leaf segment (i.e. page) is collected into\n+    // a result array. This is used by the LayoutRouter to scroll to ensure that\n+    // new pages are visible after a navigation.\n+    // TODO: We should use a string to represent the segment path instead of\n+    // an array. We already use a string representation for the path when\n+    // accessing the Segment Cache, so we can use the same one.\n+    scrollableSegmentsResult.push(segmentPath)\n+  } else {\n+    for (let parallelRouteKey in routerStateChildren) {\n+      const routerStateChild: FlightRouterState =\n+        routerStateChildren[parallelRouteKey]\n+      const prefetchDataChild: CacheNodeSeedData | void | null =\n+        prefetchDataChildren !== null\n+          ? prefetchDataChildren[parallelRouteKey]\n+          : null\n+      const segmentChild = routerStateChild[0]\n+      const segmentPathChild = segmentPath.concat([\n+        parallelRouteKey,\n+        segmentChild,\n+      ])\n+      const segmentKeyChild = createRouterCacheKey(segmentChild)\n+      const taskChild = createCacheNodeOnNavigation(\n+        routerStateChild,\n+        prefetchDataChild,\n+        possiblyPartialPrefetchHead,\n+        isPrefetchHeadPartial,\n+        segmentPathChild,\n+        scrollableSegmentsResult\n+      )\n+      taskChildren.set(parallelRouteKey, taskChild)\n+      const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n+      if (dynamicRequestTreeChild !== null) {\n+        // Something in the child tree is dynamic.\n+        needsDynamicRequest = true\n+        dynamicRequestTreeChildren[parallelRouteKey] = dynamicRequestTreeChild\n+      } else {\n+        dynamicRequestTreeChildren[parallelRouteKey] = routerStateChild\n+      }\n+      const newCacheNodeChild = taskChild.node\n+      if (newCacheNodeChild !== null) {\n+        const newSegmentMapChild: ChildSegmentMap = new Map()\n+        newSegmentMapChild.set(segmentKeyChild, newCacheNodeChild)\n+        cacheNodeChildren.set(parallelRouteKey, newSegmentMapChild)\n+      }\n     }\n   }\n \n@@ -531,7 +575,9 @@ function spawnPendingTask(\n   routerState: FlightRouterState,\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n-  isPrefetchHeadPartial: boolean\n+  isPrefetchHeadPartial: boolean,\n+  segmentPath: FlightSegmentPath,\n+  scrollableSegmentsResult: Array<FlightSegmentPath>\n ): SPANavigationTask {\n   // Create a task that will later be fulfilled by data from the server.\n \n@@ -551,7 +597,9 @@ function spawnPendingTask(\n       routerState,\n       prefetchData,\n       prefetchHead,\n-      isPrefetchHeadPartial\n+      isPrefetchHeadPartial,\n+      segmentPath,\n+      scrollableSegmentsResult\n     ),\n     // Because this is non-null, and it gets propagated up through the parent\n     // tasks, the root task will know that it needs to perform a server request.\n@@ -754,7 +802,9 @@ function createPendingCacheNode(\n   routerState: FlightRouterState,\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n-  isPrefetchHeadPartial: boolean\n+  isPrefetchHeadPartial: boolean,\n+  segmentPath: FlightSegmentPath,\n+  scrollableSegmentsResult: Array<FlightSegmentPath>\n ): ReadyCacheNode {\n   const routerStateChildren = routerState[1]\n   const prefetchDataChildren = prefetchData !== null ? prefetchData[2] : null\n@@ -769,13 +819,19 @@ function createPendingCacheNode(\n         : null\n \n     const segmentChild = routerStateChild[0]\n+    const segmentPathChild = segmentPath.concat([\n+      parallelRouteKey,\n+      segmentChild,\n+    ])\n     const segmentKeyChild = createRouterCacheKey(segmentChild)\n \n     const newCacheNodeChild = createPendingCacheNode(\n       routerStateChild,\n       prefetchDataChild === undefined ? null : prefetchDataChild,\n       prefetchHead,\n-      isPrefetchHeadPartial\n+      isPrefetchHeadPartial,\n+      segmentPathChild,\n+      scrollableSegmentsResult\n     )\n \n     const newSegmentMapChild: ChildSegmentMap = new Map()\n@@ -786,6 +842,17 @@ function createPendingCacheNode(\n   // The head is assigned to every leaf segment delivered by the server. Based\n   // on corresponding logic in fill-lazy-items-till-leaf-with-head.ts\n   const isLeafSegment = parallelRoutes.size === 0\n+\n+  if (isLeafSegment) {\n+    // The segment path of every leaf segment (i.e. page) is collected into\n+    // a result array. This is used by the LayoutRouter to scroll to ensure that\n+    // new pages are visible after a navigation.\n+    // TODO: We should use a string to represent the segment path instead of\n+    // an array. We already use a string representation for the path when\n+    // accessing the Segment Cache, so we can use the same one.\n+    scrollableSegmentsResult.push(segmentPath)\n+  }\n+\n   const maybePrefetchRsc = prefetchData !== null ? prefetchData[1] : null\n   const maybePrefetchLoading = prefetchData !== null ? prefetchData[3] : null\n   return {"
        },
        {
            "sha": "2bf1c029ebbd0ad8c831946c11ac464fbc4b45fa",
            "filename": "packages/next/src/client/components/router-reducer/reducers/navigate-reducer.ts",
            "status": "modified",
            "additions": 20,
            "deletions": 15,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/856e2b19aa09b1bcc1e6d3d879921ca7d8a221a2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/856e2b19aa09b1bcc1e6d3d879921ca7d8a221a2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts?ref=856e2b19aa09b1bcc1e6d3d879921ca7d8a221a2",
            "patch": "@@ -120,10 +120,10 @@ function handleNavigationResult(\n       mutable.cache = result.data.cacheNode\n       mutable.patchedTree = result.data.flightRouterState\n       mutable.canonicalUrl = result.data.canonicalUrl\n+      mutable.scrollableSegments = result.data.scrollableSegments\n+      mutable.shouldScroll = result.data.shouldScroll\n       // TODO: Not yet implemented\n-      // mutable.scrollableSegments = scrollableSegments\n       // mutable.hashFragment = hash\n-      // mutable.shouldScroll = shouldScroll\n       return handleMutable(state, mutable)\n     }\n     case NavigationResultTag.Async: {\n@@ -186,7 +186,8 @@ export function navigateReducer(\n       url,\n       state.cache,\n       state.tree,\n-      state.nextUrl\n+      state.nextUrl,\n+      shouldScroll\n     )\n     return handleNavigationResult(state, mutable, pendingPush, result)\n   }\n@@ -311,7 +312,8 @@ export function navigateReducer(\n               treePatch,\n               seedData,\n               head,\n-              isHeadPartial\n+              isHeadPartial,\n+              scrollableSegments\n             )\n \n             if (task !== null) {\n@@ -437,20 +439,23 @@ export function navigateReducer(\n               // segments in the FlightDataPath will be able to reference the updated cache.\n               currentCache = cache\n             }\n-          }\n-\n-          currentTree = newTree\n \n-          for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n-            const scrollableSegmentPath = [...flightSegmentPath, ...subSegment]\n-            // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n-            if (\n-              scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n-              DEFAULT_SEGMENT_KEY\n-            ) {\n-              scrollableSegments.push(scrollableSegmentPath)\n+            for (const subSegment of generateSegmentsFromPatch(treePatch)) {\n+              const scrollableSegmentPath = [\n+                ...flightSegmentPath,\n+                ...subSegment,\n+              ]\n+              // Filter out the __DEFAULT__ paths as they shouldn't be scrolled to in this case.\n+              if (\n+                scrollableSegmentPath[scrollableSegmentPath.length - 1] !==\n+                DEFAULT_SEGMENT_KEY\n+              ) {\n+                scrollableSegments.push(scrollableSegmentPath)\n+              }\n             }\n           }\n+\n+          currentTree = newTree\n         }\n       }\n "
        },
        {
            "sha": "5ea7721299352d8520843e92d01b3a649e599120",
            "filename": "packages/next/src/client/components/segment-cache/navigation.ts",
            "status": "modified",
            "additions": 37,
            "deletions": 10,
            "changes": 47,
            "blob_url": "https://github.com/vercel/next.js/blob/856e2b19aa09b1bcc1e6d3d879921ca7d8a221a2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/856e2b19aa09b1bcc1e6d3d879921ca7d8a221a2/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts?ref=856e2b19aa09b1bcc1e6d3d879921ca7d8a221a2",
            "patch": "@@ -48,6 +48,8 @@ type SuccessfulNavigationResult = {\n     flightRouterState: FlightRouterState\n     cacheNode: CacheNode\n     canonicalUrl: string\n+    scrollableSegments: Array<FlightSegmentPath>\n+    shouldScroll: boolean\n   }\n }\n \n@@ -81,7 +83,8 @@ export function navigate(\n   url: URL,\n   currentCacheNode: CacheNode,\n   currentFlightRouterState: FlightRouterState,\n-  nextUrl: string | null\n+  nextUrl: string | null,\n+  shouldScroll: boolean\n ): NavigationResult {\n   const now = Date.now()\n \n@@ -104,7 +107,8 @@ export function navigate(\n       prefetchSeedData,\n       prefetchHead,\n       isPrefetchHeadPartial,\n-      canonicalUrl\n+      canonicalUrl,\n+      shouldScroll\n     )\n   }\n   // There's no matching prefetch for this route in the cache.\n@@ -114,7 +118,8 @@ export function navigate(\n       url,\n       nextUrl,\n       currentCacheNode,\n-      currentFlightRouterState\n+      currentFlightRouterState,\n+      shouldScroll\n     ),\n   }\n }\n@@ -128,21 +133,24 @@ function navigateUsingPrefetchedRouteTree(\n   prefetchSeedData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n-  canonicalUrl: string\n+  canonicalUrl: string,\n+  shouldScroll: boolean\n ): SuccessfulNavigationResult | NoOpNavigationResult | MPANavigationResult {\n   // Recursively construct a prefetch tree by reading from the Segment Cache. To\n   // maintain compatibility, we output the same data structures as the old\n   // prefetching implementation: FlightRouterState and CacheNodeSeedData.\n   // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n   // read from the Segment Cache directly. It's only structured this way for now\n   // so we can share code with the old prefetching implementation.\n+  const scrollableSegments: Array<FlightSegmentPath> = []\n   const task = startPPRNavigation(\n     currentCacheNode,\n     currentFlightRouterState,\n     prefetchFlightRouterState,\n     prefetchSeedData,\n     prefetchHead,\n-    isPrefetchHeadPartial\n+    isPrefetchHeadPartial,\n+    scrollableSegments\n   )\n   if (task !== null) {\n     const dynamicRequestTree = task.dynamicRequestTree\n@@ -156,7 +164,13 @@ function navigateUsingPrefetchedRouteTree(\n       // The prefetched tree does not contain dynamic holes — it's\n       // fully static. We can skip the dynamic request.\n     }\n-    return navigationTaskToResult(task, currentCacheNode, canonicalUrl)\n+    return navigationTaskToResult(\n+      task,\n+      currentCacheNode,\n+      canonicalUrl,\n+      scrollableSegments,\n+      shouldScroll\n+    )\n   }\n   // The server sent back an empty tree patch. There's nothing to update.\n   return noOpNavigationResult\n@@ -165,7 +179,9 @@ function navigateUsingPrefetchedRouteTree(\n function navigationTaskToResult(\n   task: PPRNavigationTask,\n   currentCacheNode: CacheNode,\n-  canonicalUrl: string\n+  canonicalUrl: string,\n+  scrollableSegments: Array<FlightSegmentPath>,\n+  shouldScroll: boolean\n ): SuccessfulNavigationResult | MPANavigationResult {\n   const flightRouterState = task.route\n   if (flightRouterState === null) {\n@@ -183,6 +199,8 @@ function navigationTaskToResult(\n       flightRouterState,\n       cacheNode: newCacheNode !== null ? newCacheNode : currentCacheNode,\n       canonicalUrl,\n+      scrollableSegments,\n+      shouldScroll,\n     },\n   }\n }\n@@ -260,7 +278,8 @@ async function navigateDynamicallyWithNoPrefetch(\n   url: URL,\n   nextUrl: string | null,\n   currentCacheNode: CacheNode,\n-  currentFlightRouterState: FlightRouterState\n+  currentFlightRouterState: FlightRouterState,\n+  shouldScroll: boolean\n ): Promise<\n   MPANavigationResult | SuccessfulNavigationResult | NoOpNavigationResult\n > {\n@@ -314,13 +333,15 @@ async function navigateDynamicallyWithNoPrefetch(\n   )\n \n   // Now we proceed exactly as we would for normal navigation.\n+  const scrollableSegments: Array<FlightSegmentPath> = []\n   const task = startPPRNavigation(\n     currentCacheNode,\n     currentFlightRouterState,\n     prefetchFlightRouterState,\n     prefetchSeedData,\n     prefetchHead,\n-    isPrefetchHeadPartial\n+    isPrefetchHeadPartial,\n+    scrollableSegments\n   )\n   if (task !== null) {\n     // In this case, we've already sent the dynamic request, so we don't\n@@ -338,7 +359,13 @@ async function navigateDynamicallyWithNoPrefetch(\n       // The prefetched tree does not contain dynamic holes — it's\n       // fully static. We don't need to process the server response further.\n     }\n-    return navigationTaskToResult(task, currentCacheNode, canonicalUrl)\n+    return navigationTaskToResult(\n+      task,\n+      currentCacheNode,\n+      canonicalUrl,\n+      scrollableSegments,\n+      shouldScroll\n+    )\n   }\n   // The server sent back an empty tree patch. There's nothing to update.\n   return noOpNavigationResult"
        }
    ],
    "stats": {
        "total": 239,
        "additions": 169,
        "deletions": 70
    }
}