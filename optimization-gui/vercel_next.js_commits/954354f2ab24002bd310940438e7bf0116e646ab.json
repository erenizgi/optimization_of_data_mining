{
    "author": "acdlite",
    "message": "[Segment Cache] Re-implement refresh reducer (#84426)\n\nThis re-implements the refresh reducer to use the Segment Cache-style\nflow, similar to how the navigate reducer already works.\n\nMost of the logic can be reused from what was already implemented for\nnavigations. The bulk of the changes are related to the case where a\n\"default\" parallel route slot is not present on the current page, and so\nneeds to be refreshed from an older page's URL.\n\nTheoretically, this should be the last remaining case where we rely on\nthe lazy fetching logic in LayoutRouter. I think there may still be some\nerror cases where we still rely on that, though. Once these are all\naddressed, we can remove the lazy-fetching mechanism entirely.",
    "sha": "954354f2ab24002bd310940438e7bf0116e646ab",
    "files": [
        {
            "sha": "9d79650d9e5c0d6e30bcc5b546ca1642137c9bb2",
            "filename": "packages/next/src/client/components/router-reducer/create-initial-router-state.ts",
            "status": "modified",
            "additions": 0,
            "deletions": 3,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fcreate-initial-router-state.ts?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -8,7 +8,6 @@ import { fillLazyItemsTillLeafWithHead } from './fill-lazy-items-till-leaf-with-\n import { extractPathFromFlightRouterState } from './compute-changed-path'\n \n import type { AppRouterState } from './router-reducer-types'\n-import { addRefreshMarkerToActiveParallelSegments } from './refetch-inactive-parallel-segments'\n import { getFlightDataPartsFromPath } from '../../flight-data-helpers'\n \n export interface InitialRouterStateParameters {\n@@ -64,8 +63,6 @@ export function createInitialRouterState({\n         createHrefFromUrl(location)\n       : initialCanonicalUrl\n \n-  addRefreshMarkerToActiveParallelSegments(initialTree, canonicalUrl)\n-\n   // When the cache hasn't been seeded yet we fill the cache with the head.\n   if (initialParallelRoutes === null || initialParallelRoutes.size === 0) {\n     fillLazyItemsTillLeafWithHead("
        },
        {
            "sha": "fd8f18db21ebf9cde9faf5a1f3783c4a5fd5f781",
            "filename": "packages/next/src/client/components/router-reducer/ppr-navigations.ts",
            "status": "modified",
            "additions": 320,
            "deletions": 89,
            "changes": 409,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Fppr-navigations.ts?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -15,9 +15,13 @@ import type {\n } from '../../../shared/lib/app-router-types'\n import { DEFAULT_SEGMENT_KEY } from '../../../shared/lib/segment'\n import { matchSegment } from '../match-segments'\n+import { revalidateEntireCache } from '../segment-cache/cache'\n import { createHrefFromUrl } from './create-href-from-url'\n import { createRouterCacheKey } from './create-router-cache-key'\n-import type { FetchServerResponseResult } from './fetch-server-response'\n+import {\n+  fetchServerResponse,\n+  type FetchServerResponseResult,\n+} from './fetch-server-response'\n import { isNavigatingToNewRootLayout } from './is-navigating-to-new-root-layout'\n import { DYNAMIC_STALETIME_MS } from './reducers/navigate-reducer'\n \n@@ -40,6 +44,10 @@ type SPANavigationTask = {\n   // If all the segments are static, then this will be null, and no server\n   // request is required.\n   dynamicRequestTree: FlightRouterState | null\n+  // The URL that should be used to fetch the dynamic data. This is only set\n+  // when the segment cannot be refetched from the current route, because it's\n+  // part of a \"default\" parallel slot that was reused during a navigation.\n+  refreshUrl: string | null\n   children: Map<string, SPANavigationTask> | null\n }\n \n@@ -49,18 +57,25 @@ type MPANavigationTask = {\n   route: null\n   node: null\n   dynamicRequestTree: null\n+  refreshUrl: null\n   children: null\n }\n \n const MPA_NAVIGATION_TASK: MPANavigationTask = {\n   route: null,\n   node: null,\n   dynamicRequestTree: null,\n+  refreshUrl: null,\n   children: null,\n }\n \n export type Task = SPANavigationTask | MPANavigationTask\n \n+export type NavigationRequestAccumulation = {\n+  scrollableSegments: Array<FlightSegmentPath>\n+  separateRefreshUrls: Set<string> | null\n+}\n+\n // Creates a new Cache Node tree (i.e. copy-on-write) that represents the\n // optimistic result of a navigation, using both the current Cache Node tree and\n // data that was prefetched prior to navigation.\n@@ -100,7 +115,7 @@ export function startPPRNavigation(\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n   isSamePageNavigation: boolean,\n-  scrollableSegmentsResult: Array<FlightSegmentPath>\n+  accumulation: NavigationRequestAccumulation\n ): Task | null {\n   const segmentPath: Array<FlightSegmentPath> = []\n   return updateCacheNodeOnNavigation(\n@@ -115,7 +130,48 @@ export function startPPRNavigation(\n     isPrefetchHeadPartial,\n     isSamePageNavigation,\n     segmentPath,\n-    scrollableSegmentsResult\n+    accumulation\n+  )\n+}\n+\n+export function startPPRRefresh(\n+  navigatedAt: number,\n+  currentRouterState: FlightRouterState,\n+  currentNextUrl: string | null,\n+  accumulation: NavigationRequestAccumulation\n+): Task | null {\n+  // A refresh is a special case of a navigation where all the dynamic data in\n+  // the page is re-fetched. There is no \"shared layout\" to consider because\n+  // the route hasn't changed.\n+\n+  // TODO: Currently, all refreshes purge the prefetch cache. In the future,\n+  // only client-side refreshes will have this behavior; the server-side\n+  // `refresh` should send new data without purging the prefetch cache.\n+  revalidateEntireCache(currentNextUrl, currentRouterState)\n+\n+  // TODO: Currently refreshes do not read from the prefetch cache, as in the\n+  // pre-Segment Cache implementation. This will be added in a subsequent PR.\n+  const prefetchData = null\n+  const prefetchHead = null\n+  const isPrefetchHeadPartial = true\n+\n+  const isRefresh = true\n+  const refreshUrl = null\n+  // During a refresh, we intentionally don't pass in the previous\n+  // CacheNode tree.\n+  const existingCacheNode = undefined\n+  const segmentPath: FlightSegmentPath = []\n+  return createCacheNodeOnNavigation(\n+    isRefresh,\n+    refreshUrl,\n+    navigatedAt,\n+    currentRouterState,\n+    existingCacheNode,\n+    prefetchData,\n+    prefetchHead,\n+    isPrefetchHeadPartial,\n+    segmentPath,\n+    accumulation\n   )\n }\n \n@@ -131,7 +187,7 @@ function updateCacheNodeOnNavigation(\n   isPrefetchHeadPartial: boolean,\n   isSamePageNavigation: boolean,\n   segmentPath: FlightSegmentPath,\n-  scrollableSegmentsResult: Array<FlightSegmentPath>\n+  accumulation: NavigationRequestAccumulation\n ): Task | null {\n   // Diff the old and new trees to reuse the shared layouts.\n   const oldRouterStateChildren = oldRouterState[1]\n@@ -247,7 +303,7 @@ function updateCacheNodeOnNavigation(\n           prefetchHead,\n           isPrefetchHeadPartial,\n           newSegmentPathChild,\n-          scrollableSegmentsResult\n+          accumulation\n         )\n       }\n     } else if (\n@@ -288,7 +344,7 @@ function updateCacheNodeOnNavigation(\n         prefetchHead,\n         isPrefetchHeadPartial,\n         newSegmentPathChild,\n-        scrollableSegmentsResult\n+        accumulation\n       )\n     } else if (\n       oldRouterStateChild !== undefined &&\n@@ -313,7 +369,7 @@ function updateCacheNodeOnNavigation(\n           isPrefetchHeadPartial,\n           isSamePageNavigation,\n           newSegmentPathChild,\n-          scrollableSegmentsResult\n+          accumulation\n         )\n       } else {\n         // There's no existing Cache Node for this segment. Switch to the\n@@ -328,7 +384,7 @@ function updateCacheNodeOnNavigation(\n           prefetchHead,\n           isPrefetchHeadPartial,\n           newSegmentPathChild,\n-          scrollableSegmentsResult\n+          accumulation\n         )\n       }\n     } else {\n@@ -343,7 +399,7 @@ function updateCacheNodeOnNavigation(\n         prefetchHead,\n         isPrefetchHeadPartial,\n         newSegmentPathChild,\n-        scrollableSegmentsResult\n+        accumulation\n       )\n     }\n \n@@ -426,6 +482,9 @@ function updateCacheNodeOnNavigation(\n           dynamicRequestTreeChildren\n         )\n       : null,\n+    // This function is never called during a refresh, only a regular\n+    // navigation, so we can always set this to null.\n+    refreshUrl: null,\n     children: taskChildren,\n   }\n }\n@@ -440,7 +499,7 @@ function beginRenderingNewRouteTree(\n   possiblyPartialPrefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n   segmentPath: FlightSegmentPath,\n-  scrollableSegmentsResult: Array<FlightSegmentPath>\n+  accumulation: NavigationRequestAccumulation\n ): Task {\n   if (!didFindRootLayout) {\n     // The route tree changed before we reached a layout. (The highest-level\n@@ -470,27 +529,33 @@ function beginRenderingNewRouteTree(\n       return MPA_NAVIGATION_TASK\n     }\n   }\n+  const isRefresh = false\n+  const refreshUrl = null\n   return createCacheNodeOnNavigation(\n+    isRefresh,\n+    refreshUrl,\n     navigatedAt,\n     newRouterState,\n     existingCacheNode,\n     prefetchData,\n     possiblyPartialPrefetchHead,\n     isPrefetchHeadPartial,\n     segmentPath,\n-    scrollableSegmentsResult\n+    accumulation\n   )\n }\n \n function createCacheNodeOnNavigation(\n+  isRefresh: boolean,\n+  parentRefreshUrl: string | null,\n   navigatedAt: number,\n   routerState: FlightRouterState,\n   existingCacheNode: CacheNode | void,\n   prefetchData: CacheNodeSeedData | null,\n   possiblyPartialPrefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n   segmentPath: FlightSegmentPath,\n-  scrollableSegmentsResult: Array<FlightSegmentPath>\n+  accumulation: NavigationRequestAccumulation\n ): SPANavigationTask {\n   // Same traversal as updateCacheNodeNavigation, but we switch to this path\n   // once we reach the part of the tree that was not in the previous route. We\n@@ -501,6 +566,28 @@ function createCacheNodeOnNavigation(\n   const routerStateChildren = routerState[1]\n   const isLeafSegment = Object.keys(routerStateChildren).length === 0\n \n+  let refreshUrl: string | null\n+  if (isRefresh) {\n+    // During a refresh navigation, there's a special case that happens when\n+    // entering a \"default\" slot. The default slot may not be part of the\n+    // current route; it may have been reused from an older route. If so,\n+    // we need to fetch its data from the old route's URL rather than current\n+    // route's URL. Keep track of this as we traverse the tree. See\n+    // spawnPendingTask for more details.\n+    const href = routerState[2]\n+    refreshUrl =\n+      typeof href === 'string' && routerState[3] === 'refresh'\n+        ? // This segment is not present in the current route. Track its\n+          // refresh URL as we continue traversing the tree.\n+          href\n+        : // Inherit the refresh URL from the parent.\n+          parentRefreshUrl\n+  } else {\n+    // This is not a refresh, so there's no need to track the refresh URL as\n+    // we traverse the tree.\n+    refreshUrl = null\n+  }\n+\n   // Even we're rendering inside the \"new\" part of the target tree, we may have\n   // a locally cached segment that we can reuse. This may come from either 1)\n   // the CacheNode tree, which lives in React state and is populated by previous\n@@ -515,6 +602,10 @@ function createCacheNodeOnNavigation(\n     // DYNAMIC_STALETIME_MS defaults to 0, but it can be increased using\n     // the experimental.staleTimes.dynamic config. When set, we'll avoid\n     // refetching dynamic data if it was fetched within the given threshold.\n+    // TODO: We should use this same logic for popstate navigations, replacing\n+    // the `updateCacheNodeOnPopstateRestoration` function. That way we can\n+    // handle the case where the data is missing here, like we would for a\n+    // normal navigation, rather than rely on the lazy fetch in LazyRouter.\n     existingCacheNode.navigatedAt + DYNAMIC_STALETIME_MS > navigatedAt\n   ) {\n     // We have an existing CacheNode for this segment, and it's not stale. We\n@@ -546,13 +637,15 @@ function createCacheNodeOnNavigation(\n       // We only have partial data from this segment. Like missing segments, we\n       // must request the full data from the server.\n       return spawnPendingTask(\n+        isRefresh,\n+        refreshUrl,\n         navigatedAt,\n         routerState,\n         prefetchData,\n         possiblyPartialPrefetchHead,\n         isPrefetchHeadPartial,\n         segmentPath,\n-        scrollableSegmentsResult\n+        accumulation\n       )\n     } else {\n       // The prefetch data is fully static, so we can omit it from the\n@@ -564,13 +657,15 @@ function createCacheNodeOnNavigation(\n     // Create a terminal task node that will later be fulfilled by\n     // server response.\n     return spawnPendingTask(\n+      isRefresh,\n+      refreshUrl,\n       navigatedAt,\n       routerState,\n       null,\n       possiblyPartialPrefetchHead,\n       isPrefetchHeadPartial,\n       segmentPath,\n-      scrollableSegmentsResult\n+      accumulation\n     )\n   }\n \n@@ -593,7 +688,7 @@ function createCacheNodeOnNavigation(\n     // TODO: We should use a string to represent the segment path instead of\n     // an array. We already use a string representation for the path when\n     // accessing the Segment Cache, so we can use the same one.\n-    scrollableSegmentsResult.push(segmentPath)\n+    accumulation.scrollableSegments.push(segmentPath)\n   } else {\n     for (let parallelRouteKey in routerStateChildren) {\n       const routerStateChild: FlightRouterState =\n@@ -619,14 +714,16 @@ function createCacheNodeOnNavigation(\n           : undefined\n \n       const taskChild = createCacheNodeOnNavigation(\n+        isRefresh,\n+        refreshUrl,\n         navigatedAt,\n         routerStateChild,\n         existingCacheNodeChild,\n         prefetchDataChild,\n         possiblyPartialPrefetchHead,\n         isPrefetchHeadPartial,\n         segmentPathChild,\n-        scrollableSegmentsResult\n+        accumulation\n       )\n       taskChildren.set(parallelRouteKey, taskChild)\n       const dynamicRequestTreeChild = taskChild.dynamicRequestTree\n@@ -667,6 +764,7 @@ function createCacheNodeOnNavigation(\n     dynamicRequestTree: needsDynamicRequest\n       ? patchRouterStateWithNewChildren(routerState, dynamicRequestTreeChildren)\n       : null,\n+    refreshUrl,\n     children: taskChildren,\n   }\n }\n@@ -692,13 +790,15 @@ function patchRouterStateWithNewChildren(\n }\n \n function spawnPendingTask(\n+  isRefresh: boolean,\n+  refreshUrl: string | null,\n   navigatedAt: number,\n   routerState: FlightRouterState,\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n   segmentPath: FlightSegmentPath,\n-  scrollableSegmentsResult: Array<FlightSegmentPath>\n+  accumulation: NavigationRequestAccumulation\n ): SPANavigationTask {\n   // Create a task that will later be fulfilled by data from the server.\n \n@@ -710,27 +810,55 @@ function spawnPendingTask(\n   )\n   dynamicRequestTree[3] = 'refetch'\n \n+  if (isRefresh && refreshUrl !== null) {\n+    accumulateRefreshUrl(accumulation, refreshUrl)\n+  }\n+\n   const newTask: Task = {\n     route: routerState,\n \n     // Corresponds to the part of the route that will be rendered on the server.\n     node: createPendingCacheNode(\n+      isRefresh,\n       navigatedAt,\n       routerState,\n       prefetchData,\n       prefetchHead,\n       isPrefetchHeadPartial,\n       segmentPath,\n-      scrollableSegmentsResult\n+      accumulation\n     ),\n     // Because this is non-null, and it gets propagated up through the parent\n     // tasks, the root task will know that it needs to perform a server request.\n     dynamicRequestTree,\n+    refreshUrl,\n     children: null,\n   }\n   return newTask\n }\n \n+function accumulateRefreshUrl(\n+  accumulation: NavigationRequestAccumulation,\n+  refreshUrl: string\n+) {\n+  // This is a refresh navigation, and we're inside a \"default\" slot that's\n+  // not part of the current route; it was reused from an older route. In\n+  // order to get fresh data for this reused route, we need to issue a\n+  // separate request using the old route's URL.\n+  //\n+  // Track these extra URLs in the accumulated result. Later, we'll construct\n+  // an appropriate request for each unique URL in the final set. The reason\n+  // we don't do it immediately here is so we can deduplicate multiple\n+  // instances of the same URL into a single request. See\n+  // listenForDynamicRequest for more details.\n+  const separateRefreshUrls = accumulation.separateRefreshUrls\n+  if (separateRefreshUrls === null) {\n+    accumulation.separateRefreshUrls = new Set([refreshUrl])\n+  } else {\n+    separateRefreshUrls.add(refreshUrl)\n+  }\n+}\n+\n function reuseActiveSegmentInDefaultSlot(\n   oldUrl: URL,\n   oldRouterState: FlightRouterState\n@@ -766,6 +894,9 @@ function reuseActiveSegmentInDefaultSlot(\n     route: reusedRouterState,\n     node: null,\n     dynamicRequestTree: null,\n+    // This function is never called during a refresh, only a regular\n+    // navigation, so we can always set this to null.\n+    refreshUrl: null,\n     children: null,\n   }\n }\n@@ -786,55 +917,156 @@ function reuseActiveSegmentInDefaultSlot(\n // This does _not_ create a new tree; it modifies the existing one in place.\n // Which means it must follow the Suspense rules of cache safety.\n export function listenForDynamicRequest(\n+  url: URL,\n+  nextUrl: string | null,\n   task: SPANavigationTask,\n-  responsePromise: Promise<FetchServerResponseResult>\n-) {\n-  responsePromise.then(\n-    (result: FetchServerResponseResult) => {\n-      if (typeof result === 'string') {\n-        // Happens when navigating to page in `pages` from `app`. We shouldn't\n-        // get here because should have already handled this during\n-        // the prefetch.\n-        return\n-      }\n-      const { flightData, debugInfo } = result\n-      for (const normalizedFlightData of flightData) {\n-        const {\n-          segmentPath,\n-          tree: serverRouterState,\n-          seedData: dynamicData,\n-          head: dynamicHead,\n-        } = normalizedFlightData\n-\n-        if (!dynamicData) {\n-          // This shouldn't happen. PPR should always send back a response.\n-          // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n-          // this might return null.\n-          continue\n-        }\n-\n-        writeDynamicDataIntoPendingTask(\n+  dynamicRequestTree: FlightRouterState,\n+  existingDynamicRequestPromise: Promise<FetchServerResponseResult> | null,\n+  accumulation: NavigationRequestAccumulation\n+): void {\n+  const requestPromises = []\n+  const separateRefreshUrls = accumulation.separateRefreshUrls\n+  if (separateRefreshUrls === null) {\n+    // Normal case. All the data can be fetched from the same URL.\n+    if (existingDynamicRequestPromise !== null) {\n+      // A dynamic request was already initiated. This can happen if the route\n+      // tree was not already prefetched/cached before navigation.\n+      requestPromises.push(\n+        attachServerResponseListener(task, existingDynamicRequestPromise)\n+      )\n+    } else {\n+      // Initiate a new dynamic request.\n+      requestPromises.push(\n+        attachServerResponseListener(\n           task,\n-          segmentPath,\n-          serverRouterState,\n-          dynamicData,\n-          dynamicHead,\n-          debugInfo\n+          fetchServerResponse(url, {\n+            flightRouterState: dynamicRequestTree,\n+            nextUrl,\n+          })\n+        )\n+      )\n+    }\n+  } else {\n+    // This is a refresh navigation, and there are multiple URLs that we need to\n+    // request the data from. This happens when a \"default\" parallel route slot\n+    // is present in the tree, and its data cannot be fetched from the current\n+    // route. We need to split the combined dynamic request tree into separate\n+    // requests per URL.\n+    //\n+    // First construct a request tree for the main URL. This will prune away\n+    // the parts of the tree that are not present in the current route. (`null`\n+    // as the second argument is used to represent the main URL.)\n+    if (existingDynamicRequestPromise !== null) {\n+      // A dynamic request was already initiated. This can happen if the route\n+      // tree was not already prefetched/cached before navigation.\n+      requestPromises.push(\n+        attachServerResponseListener(task, existingDynamicRequestPromise)\n+      )\n+    } else {\n+      // Initiate a new dynamic request.\n+      // TODO: Create a scoped dynamic request tree that omits anything that\n+      // is not relevant to the given URL. Without doing this, the server may\n+      // sometimes render more data than necessary; this is not a regression\n+      // compared to the pre-Segment Cache implementation, though, just an\n+      // optimization we can make in the future.\n+      // const primaryDynamicRequestTree = splitTaskByURL(task, null)\n+      const primaryDynamicRequestTree = dynamicRequestTree\n+      if (primaryDynamicRequestTree !== null) {\n+        requestPromises.push(\n+          attachServerResponseListener(\n+            task,\n+            fetchServerResponse(url, {\n+              flightRouterState: primaryDynamicRequestTree,\n+              nextUrl,\n+            })\n+          )\n         )\n       }\n-\n-      // Now that we've exhausted all the data we received from the server, if\n-      // there are any remaining pending tasks in the tree, abort them now.\n-      // If there's any missing data, it will trigger a lazy fetch.\n-      abortTask(task, null, debugInfo)\n-    },\n-    (error: any) => {\n-      // This will trigger an error during render\n-      abortTask(task, error, null)\n     }\n+    // Then construct a request tree for each additional refresh URL. This will\n+    // prune away everything except the parts of the tree that match the\n+    // given refresh URL.\n+    const canonicalUrl = createHrefFromUrl(url)\n+    for (const refreshUrl of separateRefreshUrls) {\n+      if (refreshUrl === canonicalUrl) {\n+        // We already initiated a request for the this URL, above. Skip it.\n+        // TODO: This only happens because the main URL is not tracked as\n+        // part of the separateRefreshURLs set. There's probably a better way\n+        // to structure this so this case doesn't happen.\n+        continue\n+      }\n+      // TODO: Create a scoped dynamic request tree that omits anything that\n+      // is not relevant to the given URL. Without doing this, the server may\n+      // sometimes render more data than necessary; this is not a regression\n+      // compared to the pre-Segment Cache implementation, though, just an\n+      // optimization we can make in the future.\n+      // const scopedDynamicRequestTree = splitTaskByURL(task, refreshUrl)\n+      const scopedDynamicRequestTree = dynamicRequestTree\n+      if (scopedDynamicRequestTree !== null) {\n+        requestPromises.push(\n+          attachServerResponseListener(\n+            task,\n+            fetchServerResponse(new URL(refreshUrl, url.origin), {\n+              flightRouterState: scopedDynamicRequestTree,\n+              nextUrl,\n+            })\n+          )\n+        )\n+      }\n+    }\n+  }\n+\n+  // Once we've exhausted all the data we received from the server, if there are\n+  // any remaining pending tasks in the tree, abort them. As a last ditch\n+  // effort, this will trigger the \"old\" fetching path (server-patch-reducer)\n+  // in LayoutRouter, though in the future we'll remove server-patch-reducer\n+  // and handle server failures using some more robust mechanism. Perhaps by\n+  // throwing a special offline error, or by triggering an MPA refresh.\n+  Promise.all(requestPromises).then(\n+    () => abortTask(task, null, null),\n+    () => abortTask(task, null, null)\n   )\n }\n \n+function attachServerResponseListener(\n+  task: SPANavigationTask,\n+  requestPromise: Promise<FetchServerResponseResult>\n+): Promise<void> {\n+  return requestPromise.then((result) => {\n+    if (typeof result === 'string') {\n+      // Happens when navigating to page in `pages` from `app`. We shouldn't\n+      // get here because should have already handled this during\n+      // the prefetch.\n+      return\n+    }\n+    const { flightData, debugInfo } = result\n+    for (const normalizedFlightData of flightData) {\n+      const {\n+        segmentPath,\n+        tree: serverRouterState,\n+        seedData: dynamicData,\n+        head: dynamicHead,\n+      } = normalizedFlightData\n+\n+      if (!dynamicData) {\n+        // This shouldn't happen. PPR should always send back a response.\n+        // However, `FlightDataPath` is a shared type and the pre-PPR handling of\n+        // this might return null.\n+        continue\n+      }\n+\n+      writeDynamicDataIntoPendingTask(\n+        task,\n+        segmentPath,\n+        serverRouterState,\n+        dynamicData,\n+        dynamicHead,\n+        debugInfo\n+      )\n+    }\n+  })\n+}\n+\n function writeDynamicDataIntoPendingTask(\n   rootTask: SPANavigationTask,\n   segmentPath: FlightSegmentPath,\n@@ -914,8 +1146,6 @@ function finishTaskUsingDynamicDataPayload(\n         dynamicHead,\n         debugInfo\n       )\n-      // Set this to null to indicate that this task is now complete.\n-      task.dynamicRequestTree = null\n     }\n     return\n   }\n@@ -956,17 +1186,25 @@ function finishTaskUsingDynamicDataPayload(\n }\n \n function createPendingCacheNode(\n+  isRefresh: boolean,\n   navigatedAt: number,\n   routerState: FlightRouterState,\n   prefetchData: CacheNodeSeedData | null,\n   prefetchHead: HeadData | null,\n   isPrefetchHeadPartial: boolean,\n   segmentPath: FlightSegmentPath,\n-  scrollableSegmentsResult: Array<FlightSegmentPath>\n+  accumulation: NavigationRequestAccumulation\n ): ReadyCacheNode {\n   const routerStateChildren = routerState[1]\n   const prefetchDataChildren = prefetchData !== null ? prefetchData[1] : null\n \n+  if (isRefresh) {\n+    const refreshUrl = routerState[2]\n+    if (typeof refreshUrl === 'string' && routerState[3] === 'refresh') {\n+      accumulateRefreshUrl(accumulation, refreshUrl)\n+    }\n+  }\n+\n   const parallelRoutes = new Map()\n   for (let parallelRouteKey in routerStateChildren) {\n     const routerStateChild: FlightRouterState =\n@@ -984,13 +1222,14 @@ function createPendingCacheNode(\n     const segmentKeyChild = createRouterCacheKey(segmentChild)\n \n     const newCacheNodeChild = createPendingCacheNode(\n+      isRefresh,\n       navigatedAt,\n       routerStateChild,\n       prefetchDataChild === undefined ? null : prefetchDataChild,\n       prefetchHead,\n       isPrefetchHeadPartial,\n       segmentPathChild,\n-      scrollableSegmentsResult\n+      accumulation\n     )\n \n     const newSegmentMapChild: ChildSegmentMap = new Map()\n@@ -1009,7 +1248,7 @@ function createPendingCacheNode(\n     // TODO: We should use a string to represent the segment path instead of\n     // an array. We already use a string representation for the path when\n     // accessing the Segment Cache, so we can use the same one.\n-    scrollableSegmentsResult.push(segmentPath)\n+    accumulation.scrollableSegments.push(segmentPath)\n   }\n \n   const maybePrefetchRsc = prefetchData !== null ? prefetchData[0] : null\n@@ -1085,35 +1324,27 @@ function finishPendingCacheNode(\n     if (cacheNodeChild !== undefined) {\n       if (\n         serverStateChild !== undefined &&\n-        matchSegment(taskSegmentChild, serverStateChild[0])\n+        matchSegment(taskSegmentChild, serverStateChild[0]) &&\n+        dataChild !== undefined &&\n+        dataChild !== null\n       ) {\n-        if (dataChild !== undefined && dataChild !== null) {\n-          // This is the happy path. Recursively update all the children.\n-          finishPendingCacheNode(\n-            cacheNodeChild,\n-            taskStateChild,\n-            serverStateChild,\n-            dataChild,\n-            dynamicHead,\n-            debugInfo\n-          )\n-        } else {\n-          // The server never returned data for this segment. Trigger a lazy\n-          // fetch during render. This shouldn't happen because the Route Tree\n-          // and the Seed Data tree sent by the server should always be the same\n-          // shape when part of the same server response.\n-          abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n-        }\n+        finishPendingCacheNode(\n+          cacheNodeChild,\n+          taskStateChild,\n+          serverStateChild,\n+          dataChild,\n+          dynamicHead,\n+          debugInfo\n+        )\n       } else {\n-        // The server never returned data for this segment. Trigger a lazy\n-        // fetch during render.\n-        abortPendingCacheNode(taskStateChild, cacheNodeChild, null, debugInfo)\n+        // The response does not include data for this segment, but it may\n+        // be included in a separate response. Don't abort the task until all\n+        // responses are received.\n       }\n     } else {\n-      // The server response matches what was expected to receive, but there's\n-      // no matching Cache Node in the task tree. This is a bug in the\n-      // implementation because we should have created a node for every\n-      // segment in the tree that's associated with this task.\n+      // There's no matching Cache Node in the task tree. This is a bug in the\n+      // implementation because we should have created a node for every segment\n+      // in the tree that's associated with this task.\n     }\n   }\n "
        },
        {
            "sha": "3dd2239d6205e34b6799d150642168b4b86af1e4",
            "filename": "packages/next/src/client/components/router-reducer/reducers/navigate-reducer.ts",
            "status": "modified",
            "additions": 8,
            "deletions": 2,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Fnavigate-reducer.ts?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -67,7 +67,7 @@ export function generateSegmentsFromPatch(\n   return segments\n }\n \n-function handleNavigationResult(\n+export function handleNavigationResult(\n   url: URL,\n   state: ReadonlyReducerState,\n   mutable: Mutable,\n@@ -112,7 +112,13 @@ function handleNavigationResult(\n       mutable.patchedTree = result.data.flightRouterState\n       mutable.renderedSearch = result.data.renderedSearch\n       mutable.canonicalUrl = result.data.canonicalUrl\n-      mutable.scrollableSegments = result.data.scrollableSegments\n+      // TODO: During a refresh, we don't set the `scrollableSegments`. There's\n+      // some confusing and subtle logic in `handleMutable` that decides what\n+      // to do when `shouldScroll` is set but `scrollableSegments` is not. I'm\n+      // not convinced it's totally coherent but the tests assert on this\n+      // particular behavior so I've ported the logic as-is from the previous\n+      // router implementation, for now.\n+      mutable.scrollableSegments = result.data.scrollableSegments ?? undefined\n       mutable.shouldScroll = result.data.shouldScroll\n       mutable.hashFragment = result.data.hash\n       return handleMutable(state, mutable)"
        },
        {
            "sha": "9a96ee767c62457c8b25aa4335d0cc4dc0d1bd82",
            "filename": "packages/next/src/client/components/router-reducer/reducers/refresh-reducer.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 133,
            "changes": 145,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Frouter-reducer%2Freducers%2Frefresh-reducer.ts?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -1,148 +1,27 @@\n-import {\n-  fetchServerResponse,\n-  type FetchServerResponseResult,\n-} from '../fetch-server-response'\n-import { createHrefFromUrl } from '../create-href-from-url'\n-import { applyRouterStatePatchToTree } from '../apply-router-state-patch-to-tree'\n-import { isNavigatingToNewRootLayout } from '../is-navigating-to-new-root-layout'\n import type {\n   Mutable,\n   ReadonlyReducerState,\n   ReducerState,\n   RefreshAction,\n } from '../router-reducer-types'\n-import { handleExternalUrl } from './navigate-reducer'\n-import { handleMutable } from '../handle-mutable'\n-import type { CacheNode } from '../../../../shared/lib/app-router-types'\n-import { fillLazyItemsTillLeafWithHead } from '../fill-lazy-items-till-leaf-with-head'\n-import { createEmptyCacheNode } from '../../app-router'\n-import { handleSegmentMismatch } from '../handle-segment-mismatch'\n-import { hasInterceptionRouteInCurrentTree } from './has-interception-route-in-current-tree'\n-import { refreshInactiveParallelSegments } from '../refetch-inactive-parallel-segments'\n-import { revalidateEntireCache } from '../../segment-cache/cache'\n+import { handleNavigationResult } from './navigate-reducer'\n+import { refresh as refreshUsingSegmentCache } from '../../segment-cache/navigation'\n \n export function refreshReducer(\n   state: ReadonlyReducerState,\n   action: RefreshAction\n ): ReducerState {\n-  const { origin } = action\n-  const mutable: Mutable = {}\n-  const href = state.canonicalUrl\n-\n-  let currentTree = state.tree\n+  const currentUrl = new URL(state.canonicalUrl, action.origin)\n+  const result = refreshUsingSegmentCache(\n+    currentUrl,\n+    state.tree,\n+    state.nextUrl,\n+    state.renderedSearch,\n+    state.canonicalUrl\n+  )\n \n+  const mutable: Mutable = {}\n   mutable.preserveCustomHistoryState = false\n \n-  const cache: CacheNode = createEmptyCacheNode()\n-\n-  // If the current tree was intercepted, the nextUrl should be included in the request.\n-  // This is to ensure that the refresh request doesn't get intercepted, accidentally triggering the interception route.\n-  const includeNextUrl = hasInterceptionRouteInCurrentTree(state.tree)\n-\n-  // TODO-APP: verify that `href` is not an external url.\n-  // Fetch data from the root of the tree.\n-  cache.lazyData = fetchServerResponse(new URL(href, origin), {\n-    flightRouterState: [\n-      currentTree[0],\n-      currentTree[1],\n-      currentTree[2],\n-      'refetch',\n-    ],\n-    nextUrl: includeNextUrl ? state.nextUrl : null,\n-  })\n-\n-  const navigatedAt = Date.now()\n-  return cache.lazyData.then(\n-    async (result: FetchServerResponseResult) => {\n-      // Handle case when navigating to page in `pages` from `app`\n-      if (typeof result === 'string') {\n-        return handleExternalUrl(\n-          state,\n-          mutable,\n-          result,\n-          state.pushRef.pendingPush\n-        )\n-      }\n-\n-      const { flightData, canonicalUrl, renderedSearch } = result\n-\n-      // Remove cache.lazyData as it has been resolved at this point.\n-      cache.lazyData = null\n-\n-      for (const normalizedFlightData of flightData) {\n-        const {\n-          tree: treePatch,\n-          seedData: cacheNodeSeedData,\n-          head,\n-          isRootRender,\n-        } = normalizedFlightData\n-\n-        if (!isRootRender) {\n-          // TODO-APP: handle this case better\n-          console.log('REFRESH FAILED')\n-          return state\n-        }\n-\n-        const newTree = applyRouterStatePatchToTree(\n-          // TODO-APP: remove ''\n-          [''],\n-          currentTree,\n-          treePatch,\n-          state.canonicalUrl\n-        )\n-\n-        if (newTree === null) {\n-          return handleSegmentMismatch(state, action, treePatch)\n-        }\n-\n-        if (isNavigatingToNewRootLayout(currentTree, newTree)) {\n-          return handleExternalUrl(\n-            state,\n-            mutable,\n-            href,\n-            state.pushRef.pendingPush\n-          )\n-        }\n-\n-        mutable.canonicalUrl = createHrefFromUrl(canonicalUrl)\n-\n-        // Handles case where prefetch only returns the router tree patch without rendered components.\n-        if (cacheNodeSeedData !== null) {\n-          const rsc = cacheNodeSeedData[0]\n-          const loading = cacheNodeSeedData[2]\n-          cache.rsc = rsc\n-          cache.prefetchRsc = null\n-          cache.loading = loading\n-          fillLazyItemsTillLeafWithHead(\n-            navigatedAt,\n-            cache,\n-            // Existing cache is not passed in as `router.refresh()` has to invalidate the entire cache.\n-            undefined,\n-            treePatch,\n-            cacheNodeSeedData,\n-            head\n-          )\n-          revalidateEntireCache(state.nextUrl, newTree)\n-        }\n-\n-        await refreshInactiveParallelSegments({\n-          navigatedAt,\n-          state,\n-          updatedTree: newTree,\n-          updatedCache: cache,\n-          includeNextUrl,\n-          canonicalUrl: mutable.canonicalUrl || state.canonicalUrl,\n-        })\n-\n-        mutable.cache = cache\n-        mutable.patchedTree = newTree\n-        mutable.renderedSearch = renderedSearch\n-\n-        currentTree = newTree\n-      }\n-\n-      return handleMutable(state, mutable)\n-    },\n-    () => state\n-  )\n+  return handleNavigationResult(currentUrl, state, mutable, false, result)\n }"
        },
        {
            "sha": "fd7c2d41245ccec839e0911ac8ebb600adec5366",
            "filename": "packages/next/src/client/components/segment-cache/navigation.ts",
            "status": "modified",
            "additions": 108,
            "deletions": 22,
            "changes": 130,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache%2Fnavigation.ts?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -12,8 +12,10 @@ import type { NormalizedFlightData } from '../../flight-data-helpers'\n import { fetchServerResponse } from '../router-reducer/fetch-server-response'\n import {\n   startPPRNavigation,\n+  startPPRRefresh,\n   listenForDynamicRequest,\n   type Task as PPRNavigationTask,\n+  type NavigationRequestAccumulation,\n } from '../router-reducer/ppr-navigations'\n import { createHrefFromUrl } from '../router-reducer/create-href-from-url'\n import {\n@@ -28,6 +30,7 @@ import {\n import { createCacheKey } from './cache-key'\n import { addSearchParamsIfPageSegment } from '../../../shared/lib/segment'\n import { NavigationResultTag } from './types'\n+import { hasInterceptionRouteInCurrentTree } from '../router-reducer/reducers/has-interception-route-in-current-tree'\n \n type MPANavigationResult = {\n   tag: NavigationResultTag.MPA\n@@ -49,7 +52,7 @@ type SuccessfulNavigationResult = {\n     cacheNode: CacheNode\n     canonicalUrl: string\n     renderedSearch: string\n-    scrollableSegments: Array<FlightSegmentPath>\n+    scrollableSegments: Array<FlightSegmentPath> | null\n     shouldScroll: boolean\n     hash: string\n   }\n@@ -218,6 +221,81 @@ export function navigate(\n   }\n }\n \n+export function refresh(\n+  currentUrl: URL,\n+  currentFlightRouterState: FlightRouterState,\n+  currentNextUrl: string | null,\n+  currentRenderedSearch: string,\n+  currentCanonicalUrl: string\n+): SuccessfulNavigationResult | NoOpNavigationResult | MPANavigationResult {\n+  // A refresh is a special case of a navigation where all the dynamic data\n+  // on the current router is re-fetched. Most of the logic is handled within\n+  // the ppr-navigations module. The main difference here is that we call\n+  // startPPRRefresh instead of startPPRNavigation.\n+  const now = Date.now()\n+  const shouldScroll = true\n+  const accumulation: NavigationRequestAccumulation = {\n+    scrollableSegments: [],\n+    separateRefreshUrls: null,\n+  }\n+  const task = startPPRRefresh(\n+    now,\n+    currentFlightRouterState,\n+    currentNextUrl,\n+    accumulation\n+  )\n+  if (task !== null) {\n+    if (task.dynamicRequestTree !== null) {\n+      // If the current tree was intercepted, the nextUrl should be included in\n+      // the request. This is to ensure that the refresh request doesn't get\n+      // intercepted, accidentally triggering the interception route.\n+      // TODO: This logic was copied from the old implementation. It works, but\n+      // a simpler way to model this would be to track whether any navigation\n+      // has occurred since the initial (SSR) navigation, since that's the only\n+      // one that should not be intercepted.\n+      const includeNextUrl = hasInterceptionRouteInCurrentTree(\n+        currentFlightRouterState\n+      )\n+      listenForDynamicRequest(\n+        currentUrl,\n+        includeNextUrl ? currentNextUrl : null,\n+        task,\n+        task.dynamicRequestTree,\n+        null,\n+        accumulation\n+      )\n+    }\n+\n+    const newTree = task.route\n+    const newCacheNode = task.node\n+    if (newTree !== null && newCacheNode !== null) {\n+      // Re-render with the new data. All the other data remains the same.\n+      return {\n+        tag: NavigationResultTag.Success,\n+        data: {\n+          flightRouterState: newTree,\n+          cacheNode: newCacheNode,\n+          canonicalUrl: currentCanonicalUrl,\n+          renderedSearch: currentRenderedSearch,\n+          // During a refresh, we don't set the `scrollableSegments`. See\n+          // corresponding comment in navigate-reducer.ts for context.\n+          scrollableSegments: null,\n+          shouldScroll,\n+          hash: currentUrl.hash,\n+        },\n+      }\n+    }\n+  }\n+\n+  return {\n+    tag: NavigationResultTag.NoOp,\n+    data: {\n+      canonicalUrl: currentCanonicalUrl,\n+      shouldScroll,\n+    },\n+  }\n+}\n+\n function navigateUsingPrefetchedRouteTree(\n   now: number,\n   url: URL,\n@@ -241,7 +319,10 @@ function navigateUsingPrefetchedRouteTree(\n   // TODO: Eventually updateCacheNodeOnNavigation (or the equivalent) should\n   // read from the Segment Cache directly. It's only structured this way for now\n   // so we can share code with the old prefetching implementation.\n-  const scrollableSegments: Array<FlightSegmentPath> = []\n+  const accumulation: NavigationRequestAccumulation = {\n+    scrollableSegments: [],\n+    separateRefreshUrls: null,\n+  }\n   const task = startPPRNavigation(\n     now,\n     currentUrl,\n@@ -252,29 +333,25 @@ function navigateUsingPrefetchedRouteTree(\n     prefetchHead,\n     isPrefetchHeadPartial,\n     isSamePageNavigation,\n-    scrollableSegments\n+    accumulation\n   )\n   if (task !== null) {\n-    const dynamicRequestTree = task.dynamicRequestTree\n-    if (dynamicRequestTree !== null) {\n-      const promiseForDynamicServerResponse = fetchServerResponse(\n-        new URL(canonicalUrl, url.origin),\n-        {\n-          flightRouterState: dynamicRequestTree,\n-          nextUrl,\n-        }\n+    if (task.dynamicRequestTree !== null) {\n+      listenForDynamicRequest(\n+        url,\n+        nextUrl,\n+        task,\n+        task.dynamicRequestTree,\n+        null,\n+        accumulation\n       )\n-      listenForDynamicRequest(task, promiseForDynamicServerResponse)\n-    } else {\n-      // The prefetched tree does not contain dynamic holes — it's\n-      // fully static. We can skip the dynamic request.\n     }\n     return navigationTaskToResult(\n       task,\n       currentCacheNode,\n       canonicalUrl,\n       renderedSearch,\n-      scrollableSegments,\n+      accumulation.scrollableSegments,\n       shouldScroll,\n       hash\n     )\n@@ -509,7 +586,10 @@ async function navigateDynamicallyWithNoPrefetch(\n   const isPrefetchHeadPartial = true\n \n   // Now we proceed exactly as we would for normal navigation.\n-  const scrollableSegments: Array<FlightSegmentPath> = []\n+  const accumulation: NavigationRequestAccumulation = {\n+    scrollableSegments: [],\n+    separateRefreshUrls: null,\n+  }\n   const task = startPPRNavigation(\n     now,\n     currentUrl,\n@@ -520,7 +600,7 @@ async function navigateDynamicallyWithNoPrefetch(\n     prefetchHead,\n     isPrefetchHeadPartial,\n     isSamePageNavigation,\n-    scrollableSegments\n+    accumulation\n   )\n   if (task !== null) {\n     // In this case, we've already sent the dynamic request, so we don't\n@@ -531,9 +611,15 @@ async function navigateDynamicallyWithNoPrefetch(\n     // was present in the cache, but the route tree was not. E.g. navigating\n     // to a URL that was not prefetched but rewrites to a different URL\n     // that was.\n-    const hasDynamicHoles = task.dynamicRequestTree !== null\n-    if (hasDynamicHoles) {\n-      listenForDynamicRequest(task, promiseForDynamicServerResponse)\n+    if (task.dynamicRequestTree !== null) {\n+      listenForDynamicRequest(\n+        url,\n+        nextUrl,\n+        task,\n+        task.dynamicRequestTree,\n+        promiseForDynamicServerResponse,\n+        accumulation\n+      )\n     } else {\n       // The prefetched tree does not contain dynamic holes — it's\n       // fully static. We don't need to process the server response further.\n@@ -543,7 +629,7 @@ async function navigateDynamicallyWithNoPrefetch(\n       currentCacheNode,\n       createHrefFromUrl(canonicalUrl),\n       renderedSearch,\n-      scrollableSegments,\n+      accumulation.scrollableSegments,\n       shouldScroll,\n       hash\n     )"
        },
        {
            "sha": "3dedf4b59889fff0097ca2d0cfd56b62cf00815c",
            "filename": "test/e2e/app-dir/app-client-cache/client-cache.parallel-routes.test.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 10,
            "changes": 22,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fapp-client-cache%2Fclient-cache.parallel-routes.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fapp-client-cache%2Fclient-cache.parallel-routes.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fapp-client-cache%2Fclient-cache.parallel-routes.test.ts?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -1,8 +1,8 @@\n import { nextTestSetup } from 'e2e-utils'\n import { createRouterAct } from 'router-act'\n-import { browserConfigWithFixedTime, fastForwardTo } from './test-utils'\n import path from 'path'\n import { Playwright } from 'next-webdriver'\n+import type { Page as PlaywrightPage } from 'playwright'\n \n describe('app dir client cache with parallel routes', () => {\n   const { next, isNextDev } = nextTestSetup({\n@@ -29,13 +29,14 @@ describe('app dir client cache with parallel routes', () => {\n \n   describe('prefetch={true}', () => {\n     it('should prefetch the full page', async () => {\n-      let act: ReturnType<typeof createRouterAct>\n+      let page: PlaywrightPage\n       const browser = await next.browser('/', {\n-        beforePageLoad(page) {\n-          browserConfigWithFixedTime.beforePageLoad(page)\n-          act = createRouterAct(page)\n+        async beforePageLoad(p) {\n+          page = p\n+          await page.clock.install()\n         },\n       })\n+      const act = createRouterAct(page)\n \n       // Reveal the link to trigger prefetch and wait for it to complete\n       const link = await act(\n@@ -53,13 +54,14 @@ describe('app dir client cache with parallel routes', () => {\n     })\n \n     it('should re-use the cache for the full page, only for 5 mins', async () => {\n-      let act: ReturnType<typeof createRouterAct>\n+      let page: PlaywrightPage\n       const browser = await next.browser('/', {\n-        beforePageLoad(page) {\n-          browserConfigWithFixedTime.beforePageLoad(page)\n-          act = createRouterAct(page)\n+        async beforePageLoad(p) {\n+          page = p\n+          await page.clock.install()\n         },\n       })\n+      const act = createRouterAct(page)\n \n       // Toggle the link, assert on the prefetch content\n       const link = await act(\n@@ -109,7 +111,7 @@ describe('app dir client cache with parallel routes', () => {\n       }, 'no-requests')\n \n       // Fast forward 5 minutes\n-      await browser.eval(fastForwardTo, 5 * 60 * 1000)\n+      await page.clock.fastForward(5 * 60 * 1000)\n \n       // Toggle the link to the other page again, assert on prefetch content\n       const linkAfterExpiry = await act("
        },
        {
            "sha": "ae9c58d9c61d3505d5e222d57558283159cddede",
            "filename": "test/e2e/app-dir/segment-cache/refresh/app/dashboard/@main/analytics/page.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40main%2Fanalytics%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40main%2Fanalytics%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40main%2Fanalytics%2Fpage.tsx?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,3 @@\n+export default function AnalyticsPage() {\n+  return <div>Analytics page</div>\n+}"
        },
        {
            "sha": "60848c7825566272f9e251486c688e4de603f484",
            "filename": "test/e2e/app-dir/segment-cache/refresh/app/dashboard/@main/default.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40main%2Fdefault.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40main%2Fdefault.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40main%2Fdefault.tsx?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,3 @@\n+export default function DefaultDashboardMain() {\n+  return <div>(Default dashboard main)</div>\n+}"
        },
        {
            "sha": "abb2891fb61e312db9d64b443c2e779d5542db98",
            "filename": "test/e2e/app-dir/segment-cache/refresh/app/dashboard/@main/page.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40main%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40main%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40main%2Fpage.tsx?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,3 @@\n+export default function DashboardMainLandingPage() {\n+  return <div>Dashboard main landing page</div>\n+}"
        },
        {
            "sha": "8a08718fc28bda0b98bb926f5cc01638242a41b7",
            "filename": "test/e2e/app-dir/segment-cache/refresh/app/dashboard/@navbar/client.tsx",
            "status": "added",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40navbar%2Fclient.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40navbar%2Fclient.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40navbar%2Fclient.tsx?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,14 @@\n+'use client'\n+\n+import { useState } from 'react'\n+\n+export function RenderCounterClient({ uuid }: { uuid: string }) {\n+  const [counter, setCounter] = useState(0)\n+  const [prevUuid, setPrevUuid] = useState(uuid)\n+  if (prevUuid !== uuid) {\n+    // A new dynamic value was received from the server. Increment the counter.\n+    setPrevUuid(uuid)\n+    setCounter(counter + 1)\n+  }\n+  return counter\n+}"
        },
        {
            "sha": "4f20ee498fafe55e2c343c476e579984f7359cd5",
            "filename": "test/e2e/app-dir/segment-cache/refresh/app/dashboard/@navbar/default.tsx",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40navbar%2Fdefault.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40navbar%2Fdefault.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40navbar%2Fdefault.tsx?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,3 @@\n+export default function DefaultDashboardNavbar() {\n+  return <div>(Default dashboard navbar)</div>\n+}"
        },
        {
            "sha": "4c2907395db28dabcd121cc6c98f6a4f152d2e83",
            "filename": "test/e2e/app-dir/segment-cache/refresh/app/dashboard/@navbar/page.tsx",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40navbar%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40navbar%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2F%40navbar%2Fpage.tsx?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,28 @@\n+import { Suspense } from 'react'\n+import { connection } from 'next/server'\n+import { RenderCounterClient } from './client'\n+\n+async function DynamicRenderCounter(): Promise<React.ReactNode> {\n+  // Renders a count of the number of times the client receives new dynamic data\n+  // from the server. The count is computed on the client and stored in React\n+  // state, so it gets reset if the state of the tree is reset.\n+  await connection()\n+  const uuid = crypto.randomUUID()\n+  return <RenderCounterClient uuid={uuid} />\n+}\n+\n+export default function DashboardNavbarLandingPage() {\n+  return (\n+    <div>\n+      <p>Navbar</p>\n+      <Suspense fallback={<div>Loading...</div>}>\n+        <p>\n+          Navbar dynamic render counter:{' '}\n+          <span id=\"navbar-dynamic-render-counter\">\n+            <DynamicRenderCounter />\n+          </span>\n+        </p>\n+      </Suspense>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "a6f3d06470b96dfa797174c59d9e18b1705fdb9b",
            "filename": "test/e2e/app-dir/segment-cache/refresh/app/dashboard/client.tsx",
            "status": "added",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2Fclient.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2Fclient.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2Fclient.tsx?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,17 @@\n+'use client'\n+\n+import { useRouter } from 'next/navigation'\n+\n+export function ClientRefreshButton() {\n+  const router = useRouter()\n+  return (\n+    <button\n+      id=\"client-refresh-button\"\n+      onClick={() => {\n+        router.refresh()\n+      }}\n+    >\n+      Refresh\n+    </button>\n+  )\n+}"
        },
        {
            "sha": "8e10b0f1054d640af05cf007b9075b99bd8c6caf",
            "filename": "test/e2e/app-dir/segment-cache/refresh/app/dashboard/layout.tsx",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fdashboard%2Flayout.tsx?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,30 @@\n+import { LinkAccordion } from '../../components/link-accordion'\n+import { ClientRefreshButton } from './client'\n+\n+export default function DashboardLayout({\n+  navbar,\n+  main,\n+}: {\n+  navbar: React.ReactNode\n+  main: React.ReactNode\n+}) {\n+  return (\n+    <div>\n+      <div style={{ border: '1px solid black', padding: '1rem' }}>\n+        {navbar}\n+        <div>\n+          <ClientRefreshButton />\n+        </div>\n+        <ul>\n+          <li>\n+            <LinkAccordion href=\"/dashboard\">Dashboard Home</LinkAccordion>\n+          </li>\n+          <li>\n+            <LinkAccordion href=\"/dashboard/analytics\">Analytics</LinkAccordion>\n+          </li>\n+        </ul>\n+      </div>\n+      <div>{main}</div>\n+    </div>\n+  )\n+}"
        },
        {
            "sha": "dbce4ea8e3aeb6cb61b81712b62288d5abaf776b",
            "filename": "test/e2e/app-dir/segment-cache/refresh/app/layout.tsx",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Flayout.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Flayout.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Flayout.tsx?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,11 @@\n+export default function RootLayout({\n+  children,\n+}: {\n+  children: React.ReactNode\n+}) {\n+  return (\n+    <html lang=\"en\">\n+      <body>{children}</body>\n+    </html>\n+  )\n+}"
        },
        {
            "sha": "bfca65251b7bc440174b7eaed5cd7825300c74d3",
            "filename": "test/e2e/app-dir/segment-cache/refresh/app/page.tsx",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fapp%2Fpage.tsx?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,5 @@\n+import { LinkAccordion } from '../components/link-accordion'\n+\n+export default async function Page() {\n+  return <LinkAccordion href=\"/dashboard\">Dashboard</LinkAccordion>\n+}"
        },
        {
            "sha": "c6848d479aef8cacef3a5d226cd017eae08edf71",
            "filename": "test/e2e/app-dir/segment-cache/refresh/components/link-accordion.tsx",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fcomponents%2Flink-accordion.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fcomponents%2Flink-accordion.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fcomponents%2Flink-accordion.tsx?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,33 @@\n+'use client'\n+\n+import Link, { type LinkProps } from 'next/link'\n+import { useState } from 'react'\n+\n+export function LinkAccordion({\n+  href,\n+  children,\n+  prefetch,\n+}: {\n+  href: string\n+  children: React.ReactNode\n+  prefetch?: LinkProps['prefetch']\n+}) {\n+  const [isVisible, setIsVisible] = useState(false)\n+  return (\n+    <>\n+      <input\n+        type=\"checkbox\"\n+        checked={isVisible}\n+        onChange={() => setIsVisible(!isVisible)}\n+        data-link-accordion={href}\n+      />\n+      {isVisible ? (\n+        <Link href={href} prefetch={prefetch}>\n+          {children}\n+        </Link>\n+      ) : (\n+        <>{children} (link is hidden)</>\n+      )}\n+    </>\n+  )\n+}"
        },
        {
            "sha": "25146d51373108c431bbadeb4ce0ad0945093dd2",
            "filename": "test/e2e/app-dir/segment-cache/refresh/next.config.js",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fnext.config.js",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fnext.config.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fnext.config.js?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,9 @@\n+/**\n+ * @type {import('next').NextConfig}\n+ */\n+const nextConfig = {\n+  cacheComponents: true,\n+  productionBrowserSourceMaps: true,\n+}\n+\n+module.exports = nextConfig"
        },
        {
            "sha": "aa78fbab36705a873bb7454d0d5e2cedcc8a14a5",
            "filename": "test/e2e/app-dir/segment-cache/refresh/segment-cache-refresh.test.ts",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/vercel/next.js/blob/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fsegment-cache-refresh.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/954354f2ab24002bd310940438e7bf0116e646ab/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fsegment-cache-refresh.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Frefresh%2Fsegment-cache-refresh.test.ts?ref=954354f2ab24002bd310940438e7bf0116e646ab",
            "patch": "@@ -0,0 +1,55 @@\n+import { nextTestSetup } from 'e2e-utils'\n+import type * as Playwright from 'playwright'\n+import { createRouterAct } from 'router-act'\n+\n+describe('segment cache (refresh)', () => {\n+  const { next, isNextDev } = nextTestSetup({\n+    files: __dirname,\n+  })\n+  if (isNextDev) {\n+    test('disabled in development', () => {})\n+    return\n+  }\n+\n+  it('refreshes data inside reused default parallel route slots', async () => {\n+    // Load the main Dashboard page. This will render the nav bar into the\n+    // @navbar slot.\n+    let page: Playwright.Page\n+    const browser = await next.browser('/dashboard', {\n+      beforePageLoad(p: Playwright.Page) {\n+        page = p\n+      },\n+    })\n+    const act = createRouterAct(page)\n+\n+    // Navigate to the Analytics page. The analytics page does not match the\n+    // @navbar slot, so the client reuses the one that was rendered by the\n+    // previous page.\n+    await act(async () => {\n+      const toggleAnalyticsLink = await browser.elementByCss(\n+        'input[data-link-accordion=\"/dashboard/analytics\"]'\n+      )\n+      await toggleAnalyticsLink.click()\n+      const link = await browser.elementByCss('a[href=\"/dashboard/analytics\"]')\n+      await link.click()\n+    })\n+\n+    // Click the refresh button and confirm the navigation bar is re-rendered,\n+    // even though it's not part of the Analytics page.\n+    await act(\n+      async () => {\n+        const refreshButton = await browser.elementById('client-refresh-button')\n+        await refreshButton.click()\n+      },\n+      {\n+        includes: 'Navbar dynamic render counter',\n+      }\n+    )\n+\n+    const navbarDynamicRenderCounter = await browser.elementById(\n+      'navbar-dynamic-render-counter'\n+    )\n+    // If this is still 0, then the nav bar was not successfully refreshed\n+    expect(await navbarDynamicRenderCounter.textContent()).toBe('1')\n+  })\n+})"
        }
    ],
    "stats": {
        "total": 933,
        "additions": 674,
        "deletions": 259
    }
}