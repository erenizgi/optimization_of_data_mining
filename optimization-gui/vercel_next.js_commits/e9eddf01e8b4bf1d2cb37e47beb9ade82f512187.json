{
    "author": "bgw",
    "message": "Turbopack: Make turbo-tasks-fetch a bit more OOP-like (#81995)\n\nThis was a request from @lukesandberg to make this API a bit more object-oriented: https://github.com/vercel/next.js/pull/81818#discussion_r2223136594\n\n- `ReqwestClientConfig` is now just `FetchClient`.\n- `fetch` is a method on `FetchClient` instead of a function taking a config.\n- **Bonus change:** `lib.rs` is now a tiny stub that just re-exports things from other modules (`client.rs`, `error.rs`, `response.rs`).",
    "sha": "e9eddf01e8b4bf1d2cb37e47beb9ade82f512187",
    "files": [
        {
            "sha": "143684adf1d8b02597aec91544606be0ec7df9af",
            "filename": "crates/next-core/src/next_config.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 6,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/crates%2Fnext-core%2Fsrc%2Fnext_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_config.rs?ref=e9eddf01e8b4bf1d2cb37e47beb9ade82f512187",
            "patch": "@@ -9,7 +9,7 @@ use turbo_tasks::{\n     trace::TraceRawVcs,\n };\n use turbo_tasks_env::{EnvMap, ProcessEnv};\n-use turbo_tasks_fetch::ReqwestClientConfig;\n+use turbo_tasks_fetch::FetchClient;\n use turbo_tasks_fs::FileSystemPath;\n use turbopack::module_options::{\n     ConditionItem, ConditionPath, LoaderRuleItem, OptionWebpackRules,\n@@ -1725,10 +1725,7 @@ impl NextConfig {\n     }\n \n     #[turbo_tasks::function]\n-    pub async fn reqwest_client_config(\n-        &self,\n-        env: Vc<Box<dyn ProcessEnv>>,\n-    ) -> Result<Vc<ReqwestClientConfig>> {\n+    pub async fn fetch_client(&self, env: Vc<Box<dyn ProcessEnv>>) -> Result<Vc<FetchClient>> {\n         // Support both an env var and the experimental flag to provide more flexibility to\n         // developers on locked down systems, depending on if they want to configure this on a\n         // per-system or per-project basis.\n@@ -1742,7 +1739,7 @@ impl NextConfig {\n             })\n             .or(self.experimental.turbopack_use_system_tls_certs)\n             .unwrap_or(false);\n-        Ok(ReqwestClientConfig {\n+        Ok(FetchClient {\n             tls_built_in_webpki_certs: !use_system_tls_certs,\n             tls_built_in_native_certs: use_system_tls_certs,\n         }"
        },
        {
            "sha": "d3473453ff60a21866f8ba63106b3d1a1b7f2c52",
            "filename": "crates/next-core/src/next_font/google/mod.rs",
            "status": "modified",
            "additions": 17,
            "deletions": 27,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs?ref=e9eddf01e8b4bf1d2cb37e47beb9ade82f512187",
            "patch": "@@ -9,7 +9,7 @@ use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{Completion, FxIndexMap, ResolvedVc, Vc};\n use turbo_tasks_bytes::stream::SingleValue;\n use turbo_tasks_env::{CommandLineProcessEnv, ProcessEnv};\n-use turbo_tasks_fetch::{HttpResponseBody, ReqwestClientConfig, fetch};\n+use turbo_tasks_fetch::{FetchClient, HttpResponseBody};\n use turbo_tasks_fs::{\n     DiskFileSystem, File, FileContent, FileSystem, FileSystemPath,\n     json::parse_json_with_source_context,\n@@ -182,7 +182,7 @@ pub struct NextFontGoogleCssModuleReplacer {\n     project_path: FileSystemPath,\n     execution_context: ResolvedVc<ExecutionContext>,\n     next_mode: ResolvedVc<NextMode>,\n-    reqwest_client_config: ResolvedVc<ReqwestClientConfig>,\n+    fetch_client: ResolvedVc<FetchClient>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -192,13 +192,13 @@ impl NextFontGoogleCssModuleReplacer {\n         project_path: FileSystemPath,\n         execution_context: ResolvedVc<ExecutionContext>,\n         next_mode: ResolvedVc<NextMode>,\n-        reqwest_client_config: ResolvedVc<ReqwestClientConfig>,\n+        fetch_client: ResolvedVc<FetchClient>,\n     ) -> Vc<Self> {\n         Self::cell(NextFontGoogleCssModuleReplacer {\n             project_path,\n             execution_context,\n             next_mode,\n-            reqwest_client_config,\n+            fetch_client,\n         })\n     }\n \n@@ -233,9 +233,9 @@ impl NextFontGoogleCssModuleReplacer {\n             .map_or_else(\n                 || {\n                     fetch_real_stylesheet(\n+                        *self.fetch_client,\n                         stylesheet_url.clone(),\n                         css_virtual_path.clone(),\n-                        *self.reqwest_client_config,\n                     )\n                     .boxed()\n                 },\n@@ -375,19 +375,16 @@ struct NextFontGoogleFontFileOptions {\n #[turbo_tasks::value(shared)]\n pub struct NextFontGoogleFontFileReplacer {\n     project_path: FileSystemPath,\n-    reqwest_client_config: ResolvedVc<ReqwestClientConfig>,\n+    fetch_client: ResolvedVc<FetchClient>,\n }\n \n #[turbo_tasks::value_impl]\n impl NextFontGoogleFontFileReplacer {\n     #[turbo_tasks::function]\n-    pub fn new(\n-        project_path: FileSystemPath,\n-        reqwest_client_config: ResolvedVc<ReqwestClientConfig>,\n-    ) -> Vc<Self> {\n+    pub fn new(project_path: FileSystemPath, fetch_client: ResolvedVc<FetchClient>) -> Vc<Self> {\n         Self::cell(NextFontGoogleFontFileReplacer {\n             project_path,\n-            reqwest_client_config,\n+            fetch_client,\n         })\n     }\n }\n@@ -443,12 +440,9 @@ impl ImportMappingReplacement for NextFontGoogleFontFileReplacer {\n \n         // doesn't seem ideal to download the font into a string, but probably doesn't\n         // really matter either.\n-        let Some(font) = fetch_from_google_fonts(\n-            url.into(),\n-            font_virtual_path.clone(),\n-            *self.reqwest_client_config,\n-        )\n-        .await?\n+        let Some(font) =\n+            fetch_from_google_fonts(*self.fetch_client, url.into(), font_virtual_path.clone())\n+                .await?\n         else {\n             return Ok(ImportMapResult::Result(ResolveResult::unresolvable()).cell());\n         };\n@@ -670,27 +664,23 @@ fn font_file_options_from_query_map(query: &RcStr) -> Result<NextFontGoogleFontF\n }\n \n async fn fetch_real_stylesheet(\n+    fetch_client: Vc<FetchClient>,\n     stylesheet_url: RcStr,\n     css_virtual_path: FileSystemPath,\n-    reqwest_client_config: Vc<ReqwestClientConfig>,\n ) -> Result<Option<Vc<RcStr>>> {\n-    let body =\n-        fetch_from_google_fonts(stylesheet_url, css_virtual_path, reqwest_client_config).await?;\n+    let body = fetch_from_google_fonts(fetch_client, stylesheet_url, css_virtual_path).await?;\n \n     Ok(body.map(|body| body.to_string()))\n }\n \n async fn fetch_from_google_fonts(\n+    fetch_client: Vc<FetchClient>,\n     url: RcStr,\n     virtual_path: FileSystemPath,\n-    reqwest_client_config: Vc<ReqwestClientConfig>,\n ) -> Result<Option<Vc<HttpResponseBody>>> {\n-    let result = fetch(\n-        url,\n-        Some(rcstr!(USER_AGENT_FOR_GOOGLE_FONTS)),\n-        reqwest_client_config,\n-    )\n-    .await?;\n+    let result = fetch_client\n+        .fetch(url, Some(rcstr!(USER_AGENT_FOR_GOOGLE_FONTS)))\n+        .await?;\n \n     Ok(match *result {\n         Ok(r) => Some(*r.await?.body),"
        },
        {
            "sha": "63178258f988ddbe857df961c4bbf0994142e4d3",
            "filename": "crates/next-core/src/next_import_map.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/crates%2Fnext-core%2Fsrc%2Fnext_import_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/crates%2Fnext-core%2Fsrc%2Fnext_import_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_import_map.rs?ref=e9eddf01e8b4bf1d2cb37e47beb9ade82f512187",
            "patch": "@@ -1022,15 +1022,15 @@ async fn insert_next_shared_aliases(\n         next_font_google_replacer_mapping,\n     );\n \n-    let reqwest_client_config = next_config.reqwest_client_config(execution_context.env());\n+    let fetch_client = next_config.fetch_client(execution_context.env());\n     import_map.insert_alias(\n         AliasPattern::exact(\"@vercel/turbopack-next/internal/font/google/cssmodule.module.css\"),\n         ImportMapping::Dynamic(ResolvedVc::upcast(\n             NextFontGoogleCssModuleReplacer::new(\n                 project_path.clone(),\n                 execution_context,\n                 next_mode,\n-                reqwest_client_config,\n+                fetch_client,\n             )\n             .to_resolved()\n             .await?,\n@@ -1041,7 +1041,7 @@ async fn insert_next_shared_aliases(\n     import_map.insert_alias(\n         AliasPattern::exact(GOOGLE_FONTS_INTERNAL_PREFIX),\n         ImportMapping::Dynamic(ResolvedVc::upcast(\n-            NextFontGoogleFontFileReplacer::new(project_path.clone(), reqwest_client_config)\n+            NextFontGoogleFontFileReplacer::new(project_path.clone(), fetch_client)\n                 .to_resolved()\n                 .await?,\n         ))"
        },
        {
            "sha": "dc1f6ddcd084bcb93a915e9aa5fa151d9b3efcdc",
            "filename": "turbopack/crates/turbo-tasks-fetch/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/turbopack%2Fcrates%2Fturbo-tasks-fetch%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/turbopack%2Fcrates%2Fturbo-tasks-fetch%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2FCargo.toml?ref=e9eddf01e8b4bf1d2cb37e47beb9ade82f512187",
            "patch": "@@ -20,7 +20,7 @@ workspace = true\n [target.'cfg(all(target_os = \"windows\", target_arch = \"aarch64\"))'.dependencies]\n reqwest = { workspace = true, features = [\"native-tls\"] }\n \n-# If you modify this cfg, make sure you update `ReqwestClientConfig::try_build`.\n+# If you modify this cfg, make sure you update `FetchClient::try_build_uncached_reqwest_client`.\n [target.'cfg(not(any(all(target_os = \"windows\", target_arch = \"aarch64\"), target_arch=\"wasm32\")))'.dependencies]\n reqwest = { workspace = true, features = [\"rustls-tls-webpki-roots\", \"rustls-tls-native-roots\"] }\n "
        },
        {
            "sha": "296c58ef8cd6053f61c1975fbebb6c90c9319491",
            "filename": "turbopack/crates/turbo-tasks-fetch/src/client.rs",
            "status": "added",
            "additions": 156,
            "deletions": 0,
            "changes": 156,
            "blob_url": "https://github.com/vercel/next.js/blob/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Fclient.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Fclient.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Fclient.rs?ref=e9eddf01e8b4bf1d2cb37e47beb9ade82f512187",
            "patch": "@@ -0,0 +1,156 @@\n+use std::{hash::Hash, sync::LazyLock};\n+\n+use anyhow::Result;\n+use quick_cache::sync::Cache;\n+use serde::{Deserialize, Serialize};\n+use turbo_rcstr::RcStr;\n+use turbo_tasks::{\n+    NonLocalValue, ReadRef, Vc, duration_span, mark_session_dependent, trace::TraceRawVcs,\n+};\n+\n+use crate::{FetchError, FetchResult, HttpResponse, HttpResponseBody};\n+\n+const MAX_CLIENTS: usize = 16;\n+static CLIENT_CACHE: LazyLock<Cache<ReadRef<FetchClient>, reqwest::Client>> =\n+    LazyLock::new(|| Cache::new(MAX_CLIENTS));\n+\n+#[derive(Hash, PartialEq, Eq, Serialize, Deserialize, NonLocalValue, Debug, TraceRawVcs)]\n+pub enum ProxyConfig {\n+    Http(RcStr),\n+    Https(RcStr),\n+}\n+\n+/// Represents the configuration needed to construct a [`reqwest::Client`].\n+///\n+/// This is used to cache clients keyed by their configuration, so the configuration should contain\n+/// as few fields as possible and change infrequently.\n+///\n+/// This is needed because [`reqwest::ClientBuilder`] does not implement the required traits. This\n+/// factory cannot be a closure because closures do not implement `Eq` or `Hash`.\n+#[turbo_tasks::value(shared)]\n+#[derive(Hash)]\n+pub struct FetchClient {\n+    /// Whether to load embedded webpki root certs with rustls. Default is true.\n+    ///\n+    /// Ignored for:\n+    /// - Windows on ARM, which uses `native-tls` instead of `rustls-tls`.\n+    /// - Ignored for WASM targets, which use the runtime's TLS implementation.\n+    pub tls_built_in_webpki_certs: bool,\n+    /// Whether to load native root certs using the `rustls-native-certs` crate. This may make\n+    /// reqwest client initialization slower, so it's not used by default.\n+    ///\n+    /// Ignored for:\n+    /// - Windows on ARM, which uses `native-tls` instead of `rustls-tls`.\n+    /// - Ignored for WASM targets, which use the runtime's TLS implementation.\n+    pub tls_built_in_native_certs: bool,\n+}\n+\n+impl Default for FetchClient {\n+    fn default() -> Self {\n+        Self {\n+            tls_built_in_webpki_certs: true,\n+            tls_built_in_native_certs: false,\n+        }\n+    }\n+}\n+\n+impl FetchClient {\n+    /// Returns a cached instance of `reqwest::Client` it exists, otherwise constructs a new one.\n+    ///\n+    /// The cache is bound in size to prevent accidental blowups or leaks. However, in practice,\n+    /// very few clients should be created, likely only when the bundler configuration changes.\n+    ///\n+    /// Client construction is largely deterministic, aside from changes to system TLS\n+    /// configuration.\n+    ///\n+    /// The reqwest client fails to construct if the TLS backend cannot be initialized, or the\n+    /// resolver cannot load the system configuration. These failures should be treated as\n+    /// cached for some amount of time, but ultimately transient (e.g. using\n+    /// [`turbo_tasks::mark_session_dependent`]).\n+    pub fn try_get_cached_reqwest_client(\n+        self: ReadRef<FetchClient>,\n+    ) -> reqwest::Result<reqwest::Client> {\n+        CLIENT_CACHE.get_or_insert_with(&self, {\n+            let this = ReadRef::clone(&self);\n+            move || this.try_build_uncached_reqwest_client()\n+        })\n+    }\n+\n+    fn try_build_uncached_reqwest_client(&self) -> reqwest::Result<reqwest::Client> {\n+        let client_builder = reqwest::Client::builder();\n+\n+        // make sure this cfg matches the one in `Cargo.toml`!\n+        #[cfg(not(any(\n+            all(target_os = \"windows\", target_arch = \"aarch64\"),\n+            target_arch = \"wasm32\"\n+        )))]\n+        let client_builder = client_builder\n+            .tls_built_in_root_certs(false)\n+            .tls_built_in_webpki_certs(self.tls_built_in_webpki_certs)\n+            .tls_built_in_native_certs(self.tls_built_in_native_certs);\n+\n+        client_builder.build()\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl FetchClient {\n+    #[turbo_tasks::function(network)]\n+    pub async fn fetch(\n+        self: Vc<FetchClient>,\n+        url: RcStr,\n+        user_agent: Option<RcStr>,\n+    ) -> Result<Vc<FetchResult>> {\n+        let url_ref = &*url;\n+        let this = self.await?;\n+        let response_result: reqwest::Result<HttpResponse> = async move {\n+            let reqwest_client = this.try_get_cached_reqwest_client()?;\n+\n+            let mut builder = reqwest_client.get(url_ref);\n+            if let Some(user_agent) = user_agent {\n+                builder = builder.header(\"User-Agent\", user_agent.as_str());\n+            }\n+\n+            let response = {\n+                let _span = duration_span!(\"fetch request\", url = url_ref);\n+                builder.send().await\n+            }\n+            .and_then(|r| r.error_for_status())?;\n+\n+            let status = response.status().as_u16();\n+\n+            let body = {\n+                let _span = duration_span!(\"fetch response\", url = url_ref);\n+                response.bytes().await?\n+            }\n+            .to_vec();\n+\n+            Ok(HttpResponse {\n+                status,\n+                body: HttpResponseBody(body).resolved_cell(),\n+            })\n+        }\n+        .await;\n+\n+        match response_result {\n+            Ok(resp) => Ok(Vc::cell(Ok(resp.resolved_cell()))),\n+            Err(err) => {\n+                // the client failed to construct or the HTTP request failed\n+                mark_session_dependent();\n+                Ok(Vc::cell(Err(\n+                    FetchError::from_reqwest_error(&err, &url).resolved_cell()\n+                )))\n+            }\n+        }\n+    }\n+}\n+\n+#[doc(hidden)]\n+pub fn __test_only_reqwest_client_cache_clear() {\n+    CLIENT_CACHE.clear()\n+}\n+\n+#[doc(hidden)]\n+pub fn __test_only_reqwest_client_cache_len() -> usize {\n+    CLIENT_CACHE.len()\n+}"
        },
        {
            "sha": "03ab2b901ad69a3dcf44bc77f1f0c03485ebe4c0",
            "filename": "turbopack/crates/turbo-tasks-fetch/src/error.rs",
            "status": "added",
            "additions": 119,
            "deletions": 0,
            "changes": 119,
            "blob_url": "https://github.com/vercel/next.js/blob/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Ferror.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Ferror.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Ferror.rs?ref=e9eddf01e8b4bf1d2cb37e47beb9ade82f512187",
            "patch": "@@ -0,0 +1,119 @@\n+use anyhow::Result;\n+use turbo_rcstr::{RcStr, rcstr};\n+use turbo_tasks::{ResolvedVc, Vc};\n+use turbo_tasks_fs::FileSystemPath;\n+use turbopack_core::issue::{Issue, IssueSeverity, IssueStage, OptionStyledString, StyledString};\n+\n+#[derive(Debug)]\n+#[turbo_tasks::value(shared)]\n+pub enum FetchErrorKind {\n+    Connect,\n+    Timeout,\n+    Status(u16),\n+    Other,\n+}\n+\n+#[turbo_tasks::value(shared)]\n+pub struct FetchError {\n+    pub url: ResolvedVc<RcStr>,\n+    pub kind: ResolvedVc<FetchErrorKind>,\n+    pub detail: ResolvedVc<StyledString>,\n+}\n+\n+impl FetchError {\n+    pub(crate) fn from_reqwest_error(error: &reqwest::Error, url: &str) -> FetchError {\n+        let kind = if error.is_connect() {\n+            FetchErrorKind::Connect\n+        } else if error.is_timeout() {\n+            FetchErrorKind::Timeout\n+        } else if let Some(status) = error.status() {\n+            FetchErrorKind::Status(status.as_u16())\n+        } else {\n+            FetchErrorKind::Other\n+        };\n+\n+        FetchError {\n+            detail: StyledString::Text(error.to_string().into()).resolved_cell(),\n+            url: ResolvedVc::cell(url.into()),\n+            kind: kind.resolved_cell(),\n+        }\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl FetchError {\n+    #[turbo_tasks::function]\n+    pub fn to_issue(\n+        &self,\n+        severity: IssueSeverity,\n+        issue_context: FileSystemPath,\n+    ) -> Vc<FetchIssue> {\n+        FetchIssue {\n+            issue_context,\n+            severity,\n+            url: self.url,\n+            kind: self.kind,\n+            detail: self.detail,\n+        }\n+        .cell()\n+    }\n+}\n+\n+#[turbo_tasks::value(shared)]\n+pub struct FetchIssue {\n+    pub issue_context: FileSystemPath,\n+    pub severity: IssueSeverity,\n+    pub url: ResolvedVc<RcStr>,\n+    pub kind: ResolvedVc<FetchErrorKind>,\n+    pub detail: ResolvedVc<StyledString>,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Issue for FetchIssue {\n+    #[turbo_tasks::function]\n+    fn file_path(&self) -> Vc<FileSystemPath> {\n+        self.issue_context.clone().cell()\n+    }\n+\n+    fn severity(&self) -> IssueSeverity {\n+        self.severity\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn title(&self) -> Vc<StyledString> {\n+        StyledString::Text(rcstr!(\"Error while requesting resource\")).cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn stage(&self) -> Vc<IssueStage> {\n+        IssueStage::Load.into()\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn description(&self) -> Result<Vc<OptionStyledString>> {\n+        let url = &*self.url.await?;\n+        let kind = &*self.kind.await?;\n+\n+        Ok(Vc::cell(Some(\n+            StyledString::Text(match kind {\n+                FetchErrorKind::Connect => {\n+                    format!(\"There was an issue establishing a connection while requesting {url}.\")\n+                        .into()\n+                }\n+                FetchErrorKind::Status(status) => {\n+                    format!(\"Received response with status {status} when requesting {url}\").into()\n+                }\n+                FetchErrorKind::Timeout => {\n+                    format!(\"Connection timed out when requesting {url}\").into()\n+                }\n+                FetchErrorKind::Other => format!(\"There was an issue requesting {url}\").into(),\n+            })\n+            .resolved_cell(),\n+        )))\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn detail(&self) -> Vc<OptionStyledString> {\n+        Vc::cell(Some(self.detail))\n+    }\n+}"
        },
        {
            "sha": "3595055a4d44ffde97d6977e584931459acbdb43",
            "filename": "turbopack/crates/turbo-tasks-fetch/src/lib.rs",
            "status": "modified",
            "additions": 11,
            "deletions": 198,
            "changes": 209,
            "blob_url": "https://github.com/vercel/next.js/blob/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Flib.rs?ref=e9eddf01e8b4bf1d2cb37e47beb9ade82f512187",
            "patch": "@@ -2,18 +2,17 @@\n #![feature(arbitrary_self_types)]\n #![feature(arbitrary_self_types_pointers)]\n \n-mod reqwest_client_cache;\n-\n-use anyhow::Result;\n-use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{ResolvedVc, Vc, duration_span, mark_session_dependent};\n-use turbo_tasks_fs::FileSystemPath;\n-use turbopack_core::issue::{Issue, IssueSeverity, IssueStage, OptionStyledString, StyledString};\n-\n-use crate::reqwest_client_cache::try_get_cached_reqwest_client;\n-pub use crate::reqwest_client_cache::{\n-    __test_only_reqwest_client_cache_clear, __test_only_reqwest_client_cache_len, ProxyConfig,\n-    ReqwestClientConfig,\n+mod client;\n+mod error;\n+mod response;\n+\n+pub use crate::{\n+    client::{\n+        __test_only_reqwest_client_cache_clear, __test_only_reqwest_client_cache_len, FetchClient,\n+        ProxyConfig,\n+    },\n+    error::{FetchError, FetchErrorKind, FetchIssue},\n+    response::{FetchResult, HttpResponse, HttpResponseBody},\n };\n \n pub fn register() {\n@@ -22,189 +21,3 @@ pub fn register() {\n     turbopack_core::register();\n     include!(concat!(env!(\"OUT_DIR\"), \"/register.rs\"));\n }\n-\n-#[turbo_tasks::value(transparent)]\n-pub struct FetchResult(Result<ResolvedVc<HttpResponse>, ResolvedVc<FetchError>>);\n-\n-#[turbo_tasks::value(shared)]\n-#[derive(Debug)]\n-pub struct HttpResponse {\n-    pub status: u16,\n-    pub body: ResolvedVc<HttpResponseBody>,\n-}\n-\n-#[turbo_tasks::value(shared)]\n-#[derive(Debug)]\n-pub struct HttpResponseBody(pub Vec<u8>);\n-\n-#[turbo_tasks::value_impl]\n-impl HttpResponseBody {\n-    #[turbo_tasks::function]\n-    pub async fn to_string(self: Vc<Self>) -> Result<Vc<RcStr>> {\n-        let this = &*self.await?;\n-        Ok(Vc::cell(std::str::from_utf8(&this.0)?.into()))\n-    }\n-}\n-\n-#[turbo_tasks::function(network)]\n-pub async fn fetch(\n-    url: RcStr,\n-    user_agent: Option<RcStr>,\n-    client_config: Vc<ReqwestClientConfig>,\n-) -> Result<Vc<FetchResult>> {\n-    let url_ref = &*url;\n-    let client_config = client_config.await?;\n-    let response_result: reqwest::Result<HttpResponse> = async move {\n-        let client = try_get_cached_reqwest_client(client_config)?;\n-\n-        let mut builder = client.get(url_ref);\n-        if let Some(user_agent) = user_agent {\n-            builder = builder.header(\"User-Agent\", user_agent.as_str());\n-        }\n-\n-        let response = {\n-            let _span = duration_span!(\"fetch request\", url = url_ref);\n-            builder.send().await\n-        }\n-        .and_then(|r| r.error_for_status())?;\n-\n-        let status = response.status().as_u16();\n-\n-        let body = {\n-            let _span = duration_span!(\"fetch response\", url = url_ref);\n-            response.bytes().await?\n-        }\n-        .to_vec();\n-\n-        Ok(HttpResponse {\n-            status,\n-            body: HttpResponseBody(body).resolved_cell(),\n-        })\n-    }\n-    .await;\n-\n-    match response_result {\n-        Ok(resp) => Ok(Vc::cell(Ok(resp.resolved_cell()))),\n-        Err(err) => {\n-            // the client failed to construct or the HTTP request failed\n-            mark_session_dependent();\n-            Ok(Vc::cell(Err(\n-                FetchError::from_reqwest_error(&err, &url).resolved_cell()\n-            )))\n-        }\n-    }\n-}\n-\n-#[derive(Debug)]\n-#[turbo_tasks::value(shared)]\n-pub enum FetchErrorKind {\n-    Connect,\n-    Timeout,\n-    Status(u16),\n-    Other,\n-}\n-\n-#[turbo_tasks::value(shared)]\n-pub struct FetchError {\n-    pub url: ResolvedVc<RcStr>,\n-    pub kind: ResolvedVc<FetchErrorKind>,\n-    pub detail: ResolvedVc<StyledString>,\n-}\n-\n-impl FetchError {\n-    fn from_reqwest_error(error: &reqwest::Error, url: &str) -> FetchError {\n-        let kind = if error.is_connect() {\n-            FetchErrorKind::Connect\n-        } else if error.is_timeout() {\n-            FetchErrorKind::Timeout\n-        } else if let Some(status) = error.status() {\n-            FetchErrorKind::Status(status.as_u16())\n-        } else {\n-            FetchErrorKind::Other\n-        };\n-\n-        FetchError {\n-            detail: StyledString::Text(error.to_string().into()).resolved_cell(),\n-            url: ResolvedVc::cell(url.into()),\n-            kind: kind.resolved_cell(),\n-        }\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl FetchError {\n-    #[turbo_tasks::function]\n-    pub fn to_issue(\n-        &self,\n-        severity: IssueSeverity,\n-        issue_context: FileSystemPath,\n-    ) -> Vc<FetchIssue> {\n-        FetchIssue {\n-            issue_context,\n-            severity,\n-            url: self.url,\n-            kind: self.kind,\n-            detail: self.detail,\n-        }\n-        .cell()\n-    }\n-}\n-\n-#[turbo_tasks::value(shared)]\n-pub struct FetchIssue {\n-    pub issue_context: FileSystemPath,\n-    pub severity: IssueSeverity,\n-    pub url: ResolvedVc<RcStr>,\n-    pub kind: ResolvedVc<FetchErrorKind>,\n-    pub detail: ResolvedVc<StyledString>,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl Issue for FetchIssue {\n-    #[turbo_tasks::function]\n-    fn file_path(&self) -> Vc<FileSystemPath> {\n-        self.issue_context.clone().cell()\n-    }\n-\n-    fn severity(&self) -> IssueSeverity {\n-        self.severity\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn title(&self) -> Vc<StyledString> {\n-        StyledString::Text(rcstr!(\"Error while requesting resource\")).cell()\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn stage(&self) -> Vc<IssueStage> {\n-        IssueStage::Load.into()\n-    }\n-\n-    #[turbo_tasks::function]\n-    async fn description(&self) -> Result<Vc<OptionStyledString>> {\n-        let url = &*self.url.await?;\n-        let kind = &*self.kind.await?;\n-\n-        Ok(Vc::cell(Some(\n-            StyledString::Text(match kind {\n-                FetchErrorKind::Connect => {\n-                    format!(\"There was an issue establishing a connection while requesting {url}.\")\n-                        .into()\n-                }\n-                FetchErrorKind::Status(status) => {\n-                    format!(\"Received response with status {status} when requesting {url}\").into()\n-                }\n-                FetchErrorKind::Timeout => {\n-                    format!(\"Connection timed out when requesting {url}\").into()\n-                }\n-                FetchErrorKind::Other => format!(\"There was an issue requesting {url}\").into(),\n-            })\n-            .resolved_cell(),\n-        )))\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn detail(&self) -> Vc<OptionStyledString> {\n-        Vc::cell(Some(self.detail))\n-    }\n-}"
        },
        {
            "sha": "af39f3acdd76e6164ff00d33253d739825b9ce22",
            "filename": "turbopack/crates/turbo-tasks-fetch/src/reqwest_client_cache.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 97,
            "changes": 97,
            "blob_url": "https://github.com/vercel/next.js/blob/1964b17e20b52144d4ecd0a8d66a19924f7159e5/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Freqwest_client_cache.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1964b17e20b52144d4ecd0a8d66a19924f7159e5/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Freqwest_client_cache.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Freqwest_client_cache.rs?ref=1964b17e20b52144d4ecd0a8d66a19924f7159e5",
            "patch": "@@ -1,97 +0,0 @@\n-use std::{hash::Hash, sync::LazyLock};\n-\n-use quick_cache::sync::Cache;\n-use serde::{Deserialize, Serialize};\n-use turbo_rcstr::RcStr;\n-use turbo_tasks::{NonLocalValue, ReadRef, trace::TraceRawVcs};\n-\n-const MAX_CLIENTS: usize = 16;\n-static CLIENT_CACHE: LazyLock<Cache<ReadRef<ReqwestClientConfig>, reqwest::Client>> =\n-    LazyLock::new(|| Cache::new(MAX_CLIENTS));\n-\n-#[derive(Hash, PartialEq, Eq, Serialize, Deserialize, NonLocalValue, Debug, TraceRawVcs)]\n-pub enum ProxyConfig {\n-    Http(RcStr),\n-    Https(RcStr),\n-}\n-\n-/// Represents the configuration needed to construct a [`reqwest::Client`].\n-///\n-/// This is used to cache clients keyed by their configuration, so the configuration should contain\n-/// as few fields as possible and change infrequently.\n-///\n-/// This is needed because [`reqwest::ClientBuilder`] does not implement the required traits. This\n-/// factory cannot be a closure because closures do not implement `Eq` or `Hash`.\n-#[turbo_tasks::value(shared)]\n-#[derive(Hash)]\n-pub struct ReqwestClientConfig {\n-    /// Whether to load embedded webpki root certs with rustls. Default is true.\n-    ///\n-    /// Ignored for:\n-    /// - Windows on ARM, which uses `native-tls` instead of `rustls-tls`.\n-    /// - Ignored for WASM targets, which use the runtime's TLS implementation.\n-    pub tls_built_in_webpki_certs: bool,\n-    /// Whether to load native root certs using the `rustls-native-certs` crate. This may make\n-    /// reqwest client initialization slower, so it's not used by default.\n-    ///\n-    /// Ignored for:\n-    /// - Windows on ARM, which uses `native-tls` instead of `rustls-tls`.\n-    /// - Ignored for WASM targets, which use the runtime's TLS implementation.\n-    pub tls_built_in_native_certs: bool,\n-}\n-\n-impl Default for ReqwestClientConfig {\n-    fn default() -> Self {\n-        Self {\n-            tls_built_in_webpki_certs: true,\n-            tls_built_in_native_certs: false,\n-        }\n-    }\n-}\n-\n-impl ReqwestClientConfig {\n-    fn try_build(&self) -> reqwest::Result<reqwest::Client> {\n-        let client_builder = reqwest::Client::builder();\n-\n-        // make sure this cfg matches the one in `Cargo.toml`!\n-        #[cfg(not(any(\n-            all(target_os = \"windows\", target_arch = \"aarch64\"),\n-            target_arch = \"wasm32\"\n-        )))]\n-        let client_builder = client_builder\n-            .tls_built_in_root_certs(false)\n-            .tls_built_in_webpki_certs(self.tls_built_in_webpki_certs)\n-            .tls_built_in_native_certs(self.tls_built_in_native_certs);\n-\n-        client_builder.build()\n-    }\n-}\n-\n-/// Given a config, returns a cached instance if it exists, otherwise constructs a new one.\n-///\n-/// The cache is bound in size to prevent accidental blowups or leaks. However, in practice, very\n-/// few clients should be created, likely only when the bundler configuration changes.\n-///\n-/// Client construction is largely deterministic, aside from changes to system TLS configuration.\n-///\n-/// The reqwest client fails to construct if the TLS backend cannot be initialized, or the resolver\n-/// cannot load the system configuration. These failures should be treated as cached for some amount\n-/// of time, but ultimately transient (e.g. using [`turbo_tasks::mark_session_dependent`]).\n-pub fn try_get_cached_reqwest_client(\n-    config: ReadRef<ReqwestClientConfig>,\n-) -> reqwest::Result<reqwest::Client> {\n-    CLIENT_CACHE.get_or_insert_with(&config, {\n-        let config = ReadRef::clone(&config);\n-        move || config.try_build()\n-    })\n-}\n-\n-#[doc(hidden)]\n-pub fn __test_only_reqwest_client_cache_clear() {\n-    CLIENT_CACHE.clear()\n-}\n-\n-#[doc(hidden)]\n-pub fn __test_only_reqwest_client_cache_len() -> usize {\n-    CLIENT_CACHE.len()\n-}"
        },
        {
            "sha": "9df08b24998c5e9fb67657ea0f4d1a7e1a106aba",
            "filename": "turbopack/crates/turbo-tasks-fetch/src/response.rs",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/vercel/next.js/blob/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Fresponse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Fresponse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Fsrc%2Fresponse.rs?ref=e9eddf01e8b4bf1d2cb37e47beb9ade82f512187",
            "patch": "@@ -0,0 +1,28 @@\n+use anyhow::Result;\n+use turbo_rcstr::RcStr;\n+use turbo_tasks::{ResolvedVc, Vc};\n+\n+use crate::FetchError;\n+\n+#[turbo_tasks::value(transparent)]\n+pub struct FetchResult(Result<ResolvedVc<HttpResponse>, ResolvedVc<FetchError>>);\n+\n+#[turbo_tasks::value(shared)]\n+#[derive(Debug)]\n+pub struct HttpResponse {\n+    pub status: u16,\n+    pub body: ResolvedVc<HttpResponseBody>,\n+}\n+\n+#[turbo_tasks::value(shared)]\n+#[derive(Debug)]\n+pub struct HttpResponseBody(pub Vec<u8>);\n+\n+#[turbo_tasks::value_impl]\n+impl HttpResponseBody {\n+    #[turbo_tasks::function]\n+    pub async fn to_string(self: Vc<Self>) -> Result<Vc<RcStr>> {\n+        let this = &*self.await?;\n+        Ok(Vc::cell(std::str::from_utf8(&this.0)?.into()))\n+    }\n+}"
        },
        {
            "sha": "eec957a84c4c886271bb65ccffa8d7b7ac535210",
            "filename": "turbopack/crates/turbo-tasks-fetch/tests/fetch.rs",
            "status": "modified",
            "additions": 38,
            "deletions": 32,
            "changes": 70,
            "blob_url": "https://github.com/vercel/next.js/blob/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ffetch.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/e9eddf01e8b4bf1d2cb37e47beb9ade82f512187/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ffetch.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fetch%2Ftests%2Ffetch.rs?ref=e9eddf01e8b4bf1d2cb37e47beb9ade82f512187",
            "patch": "@@ -5,8 +5,8 @@ use tokio::sync::Mutex as TokioMutex;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::Vc;\n use turbo_tasks_fetch::{\n-    __test_only_reqwest_client_cache_clear, __test_only_reqwest_client_cache_len, FetchErrorKind,\n-    ReqwestClientConfig, fetch,\n+    __test_only_reqwest_client_cache_clear, __test_only_reqwest_client_cache_len, FetchClient,\n+    FetchErrorKind,\n };\n use turbo_tasks_fs::{DiskFileSystem, FileSystem, FileSystemPath};\n use turbo_tasks_testing::{Registration, register, run};\n@@ -29,15 +29,15 @@ async fn basic_get() {\n             .create_async()\n             .await;\n \n-        let config_vc = ReqwestClientConfig::default().cell();\n-        let response = &*fetch(\n-            RcStr::from(format!(\"{}/foo.woff\", server.url())),\n-            /* user_agent */ None,\n-            config_vc,\n-        )\n-        .await?\n-        .unwrap()\n-        .await?;\n+        let client_vc = FetchClient::default().cell();\n+        let response = &*client_vc\n+            .fetch(\n+                RcStr::from(format!(\"{}/foo.woff\", server.url())),\n+                /* user_agent */ None,\n+            )\n+            .await?\n+            .unwrap()\n+            .await?;\n \n         resource_mock.assert_async().await;\n \n@@ -63,15 +63,15 @@ async fn sends_user_agent() {\n \n         eprintln!(\"{}\", server.url());\n \n-        let config_vc = ReqwestClientConfig::default().cell();\n-        let response = &*fetch(\n-            RcStr::from(format!(\"{}/foo.woff\", server.url())),\n-            Some(rcstr!(\"mock-user-agent\")),\n-            config_vc,\n-        )\n-        .await?\n-        .unwrap()\n-        .await?;\n+        let client_vc = FetchClient::default().cell();\n+        let response = &*client_vc\n+            .fetch(\n+                RcStr::from(format!(\"{}/foo.woff\", server.url())),\n+                Some(rcstr!(\"mock-user-agent\")),\n+            )\n+            .await?\n+            .unwrap()\n+            .await?;\n \n         resource_mock.assert_async().await;\n \n@@ -98,8 +98,9 @@ async fn invalidation_does_not_invalidate() {\n             .await;\n \n         let url = RcStr::from(format!(\"{}/foo.woff\", server.url()));\n-        let config_vc = ReqwestClientConfig::default().cell();\n-        let response = &*fetch(url.clone(), /* user_agent */ None, config_vc)\n+        let client_vc = FetchClient::default().cell();\n+        let response = &*client_vc\n+            .fetch(url.clone(), /* user_agent */ None)\n             .await?\n             .unwrap()\n             .await?;\n@@ -109,7 +110,8 @@ async fn invalidation_does_not_invalidate() {\n         assert_eq!(response.status, 200);\n         assert_eq!(*response.body.to_string().await?, \"responsebody\");\n \n-        let second_response = &*fetch(url.clone(), /* user_agent */ None, config_vc)\n+        let second_response = &*client_vc\n+            .fetch(url.clone(), /* user_agent */ None)\n             .await?\n             .unwrap()\n             .await?;\n@@ -136,8 +138,8 @@ async fn errors_on_failed_connection() {\n         // `ECONNREFUSED`.\n         // Other values (e.g. domain name, reserved IP address block) may result in long timeouts.\n         let url = rcstr!(\"http://127.0.0.1:0/foo.woff\");\n-        let config_vc = ReqwestClientConfig::default().cell();\n-        let response_vc = fetch(url.clone(), None, config_vc);\n+        let client_vc = FetchClient::default().cell();\n+        let response_vc = client_vc.fetch(url.clone(), None);\n         let err_vc = &*response_vc.await?.unwrap_err();\n         let err = err_vc.await?;\n \n@@ -171,8 +173,8 @@ async fn errors_on_404() {\n             .await;\n \n         let url = RcStr::from(server.url());\n-        let config_vc = ReqwestClientConfig::default().cell();\n-        let response_vc = fetch(url.clone(), None, config_vc);\n+        let client_vc = FetchClient::default().cell();\n+        let response_vc = client_vc.fetch(url.clone(), None);\n         let err_vc = &*response_vc.await?.unwrap_err();\n         let err = err_vc.await?;\n \n@@ -197,7 +199,7 @@ async fn errors_on_404() {\n #[tokio::test]\n async fn client_cache() {\n     // a simple fetch that should always succeed\n-    async fn simple_fetch(path: &str, config: ReqwestClientConfig) -> anyhow::Result<()> {\n+    async fn simple_fetch(path: &str, client: FetchClient) -> anyhow::Result<()> {\n         let mut server = mockito::Server::new_async().await;\n         let _resource_mock = server\n             .mock(\"GET\", &*format!(\"/{path}\"))\n@@ -206,7 +208,11 @@ async fn client_cache() {\n             .await;\n \n         let url = RcStr::from(format!(\"{}/{}\", server.url(), path));\n-        let response = match &*fetch(url.clone(), /* user_agent */ None, config.cell()).await? {\n+        let response = match &*client\n+            .cell()\n+            .fetch(url.clone(), /* user_agent */ None)\n+            .await?\n+        {\n             Ok(resp) => resp.await?,\n             Err(_err) => {\n                 anyhow::bail!(\"fetch error\")\n@@ -227,7 +233,7 @@ async fn client_cache() {\n \n         simple_fetch(\n             \"/foo\",\n-            ReqwestClientConfig {\n+            FetchClient {\n                 tls_built_in_native_certs: false,\n                 ..Default::default()\n             },\n@@ -239,7 +245,7 @@ async fn client_cache() {\n         // the client is reused if the config is the same (by equality)\n         simple_fetch(\n             \"/bar\",\n-            ReqwestClientConfig {\n+            FetchClient {\n                 tls_built_in_native_certs: false,\n                 ..Default::default()\n             },\n@@ -251,7 +257,7 @@ async fn client_cache() {\n         // the client is recreated if the config is different\n         simple_fetch(\n             \"/bar\",\n-            ReqwestClientConfig {\n+            FetchClient {\n                 tls_built_in_native_certs: true,\n                 ..Default::default()\n             },"
        }
    ],
    "stats": {
        "total": 740,
        "additions": 376,
        "deletions": 364
    }
}