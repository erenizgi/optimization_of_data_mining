{
    "author": "kdy1",
    "message": "perf(turbopack/rcstr): Use precomputed hash (#80074)\n\n### What?\n\nUse precomputed data for hashing instead of rehashing everytime.\n\n### Why?\n\n`hash` of `&str` is `O(n)`. Although it's fast, we don't need to pay the cost for memory access.\n\n---------\n\nCo-authored-by: Tobias Koppers <tobias.koppers@googlemail.com>",
    "sha": "172a60ed6d79277c8a9c0375ca210940ca2a81ca",
    "files": [
        {
            "sha": "7e1c34a2e6bb21396221ee9df0c93d139948477b",
            "filename": "turbopack/crates/turbo-rcstr/src/dynamic.rs",
            "status": "modified",
            "additions": 153,
            "deletions": 11,
            "changes": 164,
            "blob_url": "https://github.com/vercel/next.js/blob/172a60ed6d79277c8a9c0375ca210940ca2a81ca/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Fdynamic.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/172a60ed6d79277c8a9c0375ca210940ca2a81ca/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Fdynamic.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Fdynamic.rs?ref=172a60ed6d79277c8a9c0375ca210940ca2a81ca",
            "patch": "@@ -1,10 +1,5 @@\n-use std::{\n-    hash::{Hash, Hasher},\n-    num::NonZeroU8,\n-    ptr::NonNull,\n-};\n+use std::{num::NonZeroU8, ptr::NonNull};\n \n-use rustc_hash::FxHasher;\n use triomphe::Arc;\n \n use crate::{\n@@ -14,6 +9,8 @@ use crate::{\n \n pub(crate) struct PrehashedString {\n     pub value: String,\n+    /// This is not the actual `fxhash`, but rather it's a value that passed to\n+    /// `write_u64` of [rustc_hash::FxHasher].\n     pub hash: u64,\n }\n \n@@ -46,7 +43,7 @@ pub(crate) fn new_atom<T: AsRef<str> + Into<String>>(text: T) -> RcStr {\n         return RcStr { unsafe_data };\n     }\n \n-    let hash = compute_fxhash(text.as_ref());\n+    let hash = hash_bytes(text.as_ref().as_bytes());\n \n     let entry: Arc<PrehashedString> = Arc::new(PrehashedString {\n         value: text.into(),\n@@ -87,8 +84,153 @@ pub(crate) const fn inline_atom(text: &str) -> Option<RcStr> {\n     None\n }\n \n-fn compute_fxhash(s: &str) -> u64 {\n-    let mut hasher = FxHasher::default();\n-    s.hash(&mut hasher);\n-    hasher.finish()\n+// Nothing special, digits of pi.\n+const SEED1: u64 = 0x243f6a8885a308d3;\n+const SEED2: u64 = 0x13198a2e03707344;\n+const PREVENT_TRIVIAL_ZERO_COLLAPSE: u64 = 0xa4093822299f31d0;\n+\n+#[inline]\n+fn multiply_mix(x: u64, y: u64) -> u64 {\n+    #[cfg(target_pointer_width = \"64\")]\n+    {\n+        // We compute the full u64 x u64 -> u128 product, this is a single mul\n+        // instruction on x86-64, one mul plus one mulhi on ARM64.\n+        let full = (x as u128) * (y as u128);\n+        let lo = full as u64;\n+        let hi = (full >> 64) as u64;\n+\n+        // The middle bits of the full product fluctuate the most with small\n+        // changes in the input. This is the top bits of lo and the bottom bits\n+        // of hi. We can thus make the entire output fluctuate with small\n+        // changes to the input by XOR'ing these two halves.\n+        lo ^ hi\n+\n+        // Unfortunately both 2^64 + 1 and 2^64 - 1 have small prime factors,\n+        // otherwise combining with + or - could result in a really strong hash, as:\n+        //     x * y = 2^64 * hi + lo = (-1) * hi + lo = lo - hi,   (mod 2^64 + 1)\n+        //     x * y = 2^64 * hi + lo =    1 * hi + lo = lo + hi,   (mod 2^64 - 1)\n+        // Multiplicative hashing is universal in a field (like mod p).\n+    }\n+\n+    #[cfg(target_pointer_width = \"32\")]\n+    {\n+        // u64 x u64 -> u128 product is prohibitively expensive on 32-bit.\n+        // Decompose into 32-bit parts.\n+        let lx = x as u32;\n+        let ly = y as u32;\n+        let hx = (x >> 32) as u32;\n+        let hy = (y >> 32) as u32;\n+\n+        // u32 x u32 -> u64 the low bits of one with the high bits of the other.\n+        let afull = (lx as u64) * (hy as u64);\n+        let bfull = (hx as u64) * (ly as u64);\n+\n+        // Combine, swapping low/high of one of them so the upper bits of the\n+        // product of one combine with the lower bits of the other.\n+        afull ^ bfull.rotate_right(32)\n+    }\n+}\n+\n+/// Copied from `hash_bytes` of `rustc-hash`.\n+///\n+/// See: https://github.com/rust-lang/rustc-hash/blob/dc5c33f1283de2da64d8d7a06401d91aded03ad4/src/lib.rs#L252-L297\n+///\n+/// ---\n+///\n+/// A wyhash-inspired non-collision-resistant hash for strings/slices designed\n+/// by Orson Peters, with a focus on small strings and small codesize.\n+///\n+/// The 64-bit version of this hash passes the SMHasher3 test suite on the full\n+/// 64-bit output, that is, f(hash_bytes(b) ^ f(seed)) for some good avalanching\n+/// permutation f() passed all tests with zero failures. When using the 32-bit\n+/// version of multiply_mix this hash has a few non-catastrophic failures where\n+/// there are a handful more collisions than an optimal hash would give.\n+///\n+/// We don't bother avalanching here as we'll feed this hash into a\n+/// multiplication after which we take the high bits, which avalanches for us.\n+#[inline]\n+fn hash_bytes(bytes: &[u8]) -> u64 {\n+    let len = bytes.len();\n+    let mut s0 = SEED1;\n+    let mut s1 = SEED2;\n+\n+    if len <= 16 {\n+        // XOR the input into s0, s1.\n+        if len >= 8 {\n+            s0 ^= u64::from_le_bytes(bytes[0..8].try_into().unwrap());\n+            s1 ^= u64::from_le_bytes(bytes[len - 8..].try_into().unwrap());\n+        } else if len >= 4 {\n+            s0 ^= u32::from_le_bytes(bytes[0..4].try_into().unwrap()) as u64;\n+            s1 ^= u32::from_le_bytes(bytes[len - 4..].try_into().unwrap()) as u64;\n+        } else if len > 0 {\n+            let lo = bytes[0];\n+            let mid = bytes[len / 2];\n+            let hi = bytes[len - 1];\n+            s0 ^= lo as u64;\n+            s1 ^= ((hi as u64) << 8) | mid as u64;\n+        }\n+    } else {\n+        // Handle bulk (can partially overlap with suffix).\n+        let mut off = 0;\n+        while off < len - 16 {\n+            let x = u64::from_le_bytes(bytes[off..off + 8].try_into().unwrap());\n+            let y = u64::from_le_bytes(bytes[off + 8..off + 16].try_into().unwrap());\n+\n+            // Replace s1 with a mix of s0, x, and y, and s0 with s1.\n+            // This ensures the compiler can unroll this loop into two\n+            // independent streams, one operating on s0, the other on s1.\n+            //\n+            // Since zeroes are a common input we prevent an immediate trivial\n+            // collapse of the hash function by XOR'ing a constant with y.\n+            let t = multiply_mix(s0 ^ x, PREVENT_TRIVIAL_ZERO_COLLAPSE ^ y);\n+            s0 = s1;\n+            s1 = t;\n+            off += 16;\n+        }\n+\n+        let suffix = &bytes[len - 16..];\n+        s0 ^= u64::from_le_bytes(suffix[0..8].try_into().unwrap());\n+        s1 ^= u64::from_le_bytes(suffix[8..16].try_into().unwrap());\n+    }\n+\n+    multiply_mix(s0, s1) ^ (len as u64)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::hash::{Hash, Hasher};\n+\n+    use rustc_hash::FxHasher;\n+\n+    use crate::RcStr;\n+\n+    // Ensure that the hash value is the same as the one generated by FxHasher.\n+    //\n+    // This is important for `Borrow<str>` implementation to be correct.\n+    // Note that if we enable `nightly` feature of `rustc-hash`, we need to remove\n+    // `state.write_u8(0xff);` from the hash implementation of `RcStr`.\n+    #[test]\n+    fn test_hash() {\n+        let long_string = \"A very long long long string that would not be inlined\";\n+\n+        {\n+            let u64_value = super::hash_bytes(long_string.as_bytes());\n+            dbg!(u64_value);\n+            let mut hasher = FxHasher::default();\n+            hasher.write_u64(u64_value);\n+            let expected = hasher.finish();\n+\n+            println!(\"Expected: {expected:?}\");\n+        }\n+\n+        let str = RcStr::from(long_string);\n+        assert_eq!(fxhash(str.clone()), fxhash(long_string));\n+        assert_eq!(fxhash((1, str, 1)), fxhash((1, long_string, 1)));\n+    }\n+\n+    fn fxhash<T: Hash>(value: T) -> u64 {\n+        let mut hasher = FxHasher::default();\n+        value.hash(&mut hasher);\n+        hasher.finish()\n+    }\n }"
        },
        {
            "sha": "77e87735534a2f983825c7e2d9e121013cde1c80",
            "filename": "turbopack/crates/turbo-rcstr/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/172a60ed6d79277c8a9c0375ca210940ca2a81ca/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/172a60ed6d79277c8a9c0375ca210940ca2a81ca/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-rcstr%2Fsrc%2Flib.rs?ref=172a60ed6d79277c8a9c0375ca210940ca2a81ca",
            "patch": "@@ -290,7 +290,8 @@ impl Hash for RcStr {\n         match self.tag() {\n             DYNAMIC_TAG => {\n                 let l = unsafe { deref_from(self.unsafe_data) };\n-                l.value.as_str().hash(state);\n+                state.write_u64(l.hash);\n+                state.write_u8(0xff);\n             }\n             INLINE_TAG => {\n                 self.as_str().hash(state);"
        }
    ],
    "stats": {
        "total": 167,
        "additions": 155,
        "deletions": 12
    }
}