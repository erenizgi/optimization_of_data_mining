{
    "author": "lukesandberg",
    "message": "[turbopack] Adopt inventory for our registry (#83074)\n\n## What?\n\nLeverage the `inventory` crate to automatically register turbo tasks objects using specialized linker sections.  See https://docs.rs/inventory/0.3.21/inventory/ for details\n\nFor NativeFunction and TraitType objects this was trivial and simplified the registry, for example.\n\n* functions only need the global registry during PC _deserialization_ so many builds can skip the cost.\n    * Even when we do allocate it, we can use a normal `HashMap` instead of a `DashMap` which should be a minor performance benefit on its own (no locks, smaller in ram)\n\n* TraitType objects achieve similar benefits. \n\nThe tricky part of course was trait impls:\n * Every `ValueType` needs to know all the trait methods it implements\n    * To support calling `turbo_tasks::functions` on `Vc<Box<dyn T>>`\n* every `TraitType` needs to know all the structs that implement it\n    * To support dereferencing a trait ref, aka `TraitRef<Box<dyn T>>` -> `&dyn T` to support calling non-turbotasks functions\n\nThis required two more registries which more or less followed the existing pattern.  One benefit of the new `inventory` approach is that the `VTableRegistry` drops its interior mutability (and associated locks).  Constructing VTableRegistry objects also becomes lazy which is useful since many are not needed.\n\nSo overall this should be equivalent but slightly better and it allows us to drop the build scripts (See #83156 )\n\nOne interesting note is determinism of `TraitTypeId` and `ValueTypeId`. Previously  the values assigned were determined by the order of registrations in the build script.  With inventory they are registered in an undefined order (im guessing it is deterministic based on linker input order, but inventory makes no guarantees).  As far as i can tell, this does not matter, but in the interest of determinism i have sorted the values based on their names.  In the future we can use this determinism to optimize persistence\n\n## Why?\n\nBy colocating registration with the proc macros we can simplify the registration logic.  Switching to 'pull' based registration also simplifies a number of datastructures and allows us to drop some RWLocks\n\n## Interesting consequences\n\nAll the global type names are changing, dropping the `@TODO::`\n\nThis `TODO` was a placeholder for a content hash of the current crate.  This is to support a hypothetical idea where at least some of the persistent cache could survive turbopack updates.  However based on team discussions we don't currently see a clear solution here.  If we want to do this in the future i think we could still leverage hashes in names but we would need to compose them in a different way (e.g. `build.rs` script sets an `env` var that the proc macro reads with the `env!` macro)",
    "sha": "099b1e35a0a71612983a4dab64fcd154dd615a29",
    "files": [
        {
            "sha": "8e34aad7956d05e06a535f3162609be15f7aba50",
            "filename": "Cargo.lock",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/Cargo.lock",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/Cargo.lock",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.lock?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -3300,6 +3300,15 @@ dependencies = [\n  \"syn 2.0.104\",\n ]\n \n+[[package]]\n+name = \"inventory\"\n+version = \"0.3.21\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bc61209c082fbeb19919bee74b176221b27223e27b65d781eb91af24eb1fb46e\"\n+dependencies = [\n+ \"rustversion\",\n+]\n+\n [[package]]\n name = \"ipnet\"\n version = \"2.10.1\"\n@@ -9209,6 +9218,7 @@ dependencies = [\n  \"event-listener\",\n  \"futures\",\n  \"indexmap 2.9.0\",\n+ \"inventory\",\n  \"mopa\",\n  \"once_cell\",\n  \"parking_lot\","
        },
        {
            "sha": "eea80fcea9a3759327cf682f0dd887fd9860205b",
            "filename": "Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/Cargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/Cargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/Cargo.toml?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -444,6 +444,7 @@ urlencoding = \"2.1.2\"\n vergen = { version = \"9.0.6\", features = [\"cargo\"] }\n vergen-gitcl = { version = \"1.0.8\", features = [\"cargo\"] }\n webbrowser = \"0.8.7\"\n+inventory = \"0.3.21\"\n \n [patch.crates-io]\n hyper = { git = \"https://github.com/bgw/hyper-rs.git\", branch = \"v1.6.0-with-macos-intel-miscompilation-workaround\" }"
        },
        {
            "sha": "6cc7db7592cda4f3c90d184f573e462b821ec12b",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/task_statistics.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 4,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftask_statistics.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftask_statistics.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftask_statistics.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -254,12 +254,11 @@ fn enable_stats() {\n \n fn stats_json() -> serde_json::Value {\n     let tt = turbo_tasks::turbo_tasks();\n-    remove_crate_and_hashes(serde_json::to_value(tt.task_statistics().get()).unwrap())\n+    remove_crate(serde_json::to_value(tt.task_statistics().get()).unwrap())\n }\n \n-// Global task identifiers can contain a hash of the crate and dependencies.\n-// Remove that so that we can compare against a stable value in tests.\n-fn remove_crate_and_hashes(mut json: serde_json::Value) -> serde_json::Value {\n+// Global task identifiers can contain the crate name, remove it to simplify test assertions\n+fn remove_crate(mut json: serde_json::Value) -> serde_json::Value {\n     static HASH_RE: Lazy<Regex> = Lazy::new(|| Regex::new(\"^[^:@]+@[^:]+:+\").unwrap());\n     match &mut json {\n         serde_json::Value::Object(map) => {"
        },
        {
            "sha": "54b4c1dd9c46be7e380cbff23e7b4ff12e6dee0f",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trace_transient.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrace_transient.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrace_transient.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrace_transient.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -9,14 +9,14 @@ use turbo_tasks_testing::{Registration, register, run_without_cache_check};\n static REGISTRATION: Registration = register!();\n \n const EXPECTED_TRACE: &str = \"\\\n-Adder::add_method (read cell of type turbo-tasks@TODO::::primitives::u64)\n+Adder::add_method (read cell of type turbo-tasks@turbo_tasks::primitives::u64)\n   self:\n-    Adder::new (read cell of type turbo-tasks-backend@TODO::::Adder)\n+    Adder::new (read cell of type turbo-tasks-backend@trace_transient::Adder)\n       args:\n-        unknown transient task (read cell of type turbo-tasks@TODO::::primitives::unit)\n+        unknown transient task (read cell of type turbo-tasks@turbo_tasks::primitives::())\n   args:\n-    unknown transient task (read cell of type turbo-tasks@TODO::::primitives::u16)\n-    unknown transient task (read cell of type turbo-tasks@TODO::::primitives::u32)\";\n+    unknown transient task (read cell of type turbo-tasks@turbo_tasks::primitives::u16)\n+    unknown transient task (read cell of type turbo-tasks@turbo_tasks::primitives::u32)\";\n \n #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n async fn test_trace_transient() {"
        },
        {
            "sha": "11985c364d97b4bf65709ca63672c93c604bdb19",
            "filename": "turbopack/crates/turbo-tasks-build/src/lib.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 220,
            "changes": 225,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-build%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-build%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-build%2Fsrc%2Flib.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -1,6 +1,5 @@\n use std::{\n     env::{self, current_dir},\n-    fmt::{Display, Write},\n     fs::read_dir,\n     path::{MAIN_SEPARATOR as PATH_SEP, PathBuf},\n     sync::Arc,\n@@ -11,15 +10,10 @@ use glob::glob;\n use quote::ToTokens;\n use rustc_hash::{FxHashMap, FxHashSet};\n use syn::{\n-    Attribute, Expr, Ident, Item, ItemEnum, ItemFn, ItemImpl, ItemMacro, ItemMod, ItemStruct,\n-    ItemTrait, Lit, Meta, TraitItem, TraitItemFn, parse_quote,\n-};\n-use turbo_tasks_macros_shared::{\n-    GenericTypeInput, PrimitiveInput, get_impl_function_ident, get_native_function_ident,\n-    get_path_ident, get_register_trait_impls_ident, get_register_trait_methods_ident,\n-    get_register_value_type_ident, get_trait_default_impl_function_ident,\n-    get_trait_impl_function_ident, get_trait_type_ident, get_type_ident,\n+    Attribute, Expr, Ident, Item, ItemEnum, ItemImpl, ItemMacro, ItemMod, ItemStruct, Lit, Meta,\n+    parse_quote,\n };\n+use turbo_tasks_macros_shared::{GenericTypeInput, PrimitiveInput, get_path_ident, get_type_ident};\n \n pub fn generate_register() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n@@ -28,7 +22,6 @@ pub fn generate_register() {\n     let workspace_dir = env::var_os(\"CARGO_WORKSPACE_DIR\")\n         .map(PathBuf::from)\n         .unwrap_or_else(|| crate_dir.clone());\n-    let crate_name = env::var(\"CARGO_PKG_NAME\").unwrap();\n     let out_dir = PathBuf::from(env::var(\"OUT_DIR\").unwrap());\n \n     let src_dir = crate_dir.join(\"src\");\n@@ -122,12 +115,6 @@ pub fn generate_register() {\n     }\n \n     for (filename, entry) in entries {\n-        // TODO hash src dir\n-        let hash = \"TODO\";\n-\n-        let prefix = format!(\"{crate_name}@{hash}::\");\n-\n-        let mut register_code = String::new();\n         let mut values = FxHashMap::default();\n \n         let out_file = out_dir.join(filename);\n@@ -149,13 +136,9 @@ pub fn generate_register() {\n \n             let mut ctx = RegisterContext {\n                 queue: &mut queue,\n-\n                 file_path: &file_path,\n-                prefix: &prefix,\n                 mod_path,\n                 attributes,\n-\n-                register: &mut register_code,\n                 values: &mut values,\n             };\n \n@@ -171,48 +154,9 @@ pub fn generate_register() {\n             }\n         }\n \n-        let mut values_code = String::new();\n-        for ((mod_path, ident), entry) in values {\n-            for attribute in &entry.attributes {\n-                values_code.push_str(attribute);\n-            }\n-            writeln!(\n-                values_code,\n-                \"crate{}::{}({}, #[allow(unused_variables)] |value| {{\",\n-                mod_path,\n-                get_register_value_type_ident(&ident),\n-                entry.global_name,\n-            )\n-            .unwrap();\n-            // Register all the trait items for each impl so we can dispatch to them as turbotasks\n-            for trait_ident in &entry.trait_idents {\n-                writeln!(\n-                    values_code,\n-                    \"    crate{}::{}(value);\",\n-                    mod_path,\n-                    get_register_trait_methods_ident(trait_ident, &ident),\n-                )\n-                .unwrap();\n-            }\n-            writeln!(values_code, \"}}, #[allow(unused_variables)] |value_id| {{\").unwrap();\n-            // Register all the vtables for the impls so we can dispatch to them as normal indirect\n-            // trait calls.\n-            for trait_ident in &entry.trait_idents {\n-                writeln!(\n-                    values_code,\n-                    \"    crate{}::{}(value_id);\",\n-                    mod_path,\n-                    get_register_trait_impls_ident(trait_ident, &ident),\n-                )\n-                .unwrap();\n-            }\n-            writeln!(values_code, \"}});\").unwrap();\n-        }\n+        let code = \"{\\nstatic ONCE: std::sync::Once = std::sync::Once::new();\\nONCE.call_once(|| \\\n+                    {\\n    // dead code to be deleted\\n});\\n}\\n\";\n \n-        let code = format!(\n-            \"{{\\nstatic ONCE: std::sync::Once = std::sync::Once::new();\\nONCE.call_once(|| \\\n-             {{\\n{register_code}{values_code}}});\\n}}\\n\"\n-        );\n         std::fs::write(out_file, code).unwrap();\n \n         // println!(\"cargo:warning={}\", out_file.display());\n@@ -244,8 +188,6 @@ pub fn rerun_if_glob(globs: &str, root: &str) {\n type ValueKey = (String, Ident);\n /// (global_name, trait_register_fns)\n struct ValueEntry {\n-    attributes: Vec<Arc<String>>,\n-    global_name: String,\n     trait_idents: Vec<Ident>,\n }\n \n@@ -265,21 +207,17 @@ struct RegisterContext<'a> {\n     file_path: &'a PathBuf,\n     mod_path: String,\n     attributes: Vec<Arc<String>>,\n-    prefix: &'a str,\n \n-    register: &'a mut String,\n     values: &'a mut FxHashMap<ValueKey, ValueEntry>,\n }\n \n impl RegisterContext<'_> {\n     fn process_item(&mut self, item: &Item) -> Result<()> {\n         match item {\n             Item::Enum(enum_item) => self.process_enum(enum_item),\n-            Item::Fn(fn_item) => self.process_fn(fn_item),\n             Item::Impl(impl_item) => self.process_impl(impl_item),\n             Item::Mod(mod_item) => self.process_mod(mod_item),\n             Item::Struct(struct_item) => self.process_struct(struct_item),\n-            Item::Trait(trait_item) => self.process_trait(trait_item),\n             Item::Macro(macro_item) => self.process_macro(macro_item),\n             _ => Ok(()),\n         }\n@@ -297,20 +235,6 @@ impl RegisterContext<'_> {\n         Ok(())\n     }\n \n-    fn process_fn(&mut self, item: &ItemFn) -> Result<()> {\n-        self.with_cfg_attrs(&item.attrs, move |this| this.process_fn_inner(item))\n-    }\n-\n-    fn process_fn_inner(&mut self, fn_item: &ItemFn) -> Result<()> {\n-        if has_turbo_attribute(&fn_item.attrs, \"function\") {\n-            let ident = &fn_item.sig.ident;\n-            let type_ident = get_native_function_ident(ident);\n-\n-            self.register(type_ident, self.get_global_name(&[ident]))?;\n-        }\n-        Ok(())\n-    }\n-\n     fn process_impl(&mut self, item: &ItemImpl) -> Result<()> {\n         self.with_cfg_attrs(&item.attrs, move |this| this.process_impl_inner(item))\n     }\n@@ -327,30 +251,6 @@ impl RegisterContext<'_> {\n             if let Some(trait_ident) = &trait_ident {\n                 self.add_value_trait(&struct_ident, trait_ident);\n             }\n-\n-            for item in &impl_item.items {\n-                if let syn::ImplItem::Fn(method_item) = item\n-                    && method_item\n-                        .attrs\n-                        .iter()\n-                        .any(|a| is_turbo_attribute(a, \"function\"))\n-                {\n-                    let method_ident = &method_item.sig.ident;\n-                    let function_type_ident = if let Some(trait_ident) = &trait_ident {\n-                        get_trait_impl_function_ident(&struct_ident, trait_ident, method_ident)\n-                    } else {\n-                        get_impl_function_ident(&struct_ident, method_ident)\n-                    };\n-\n-                    let global_name = if let Some(trait_ident) = &trait_ident {\n-                        self.get_global_name(&[&struct_ident, trait_ident, method_ident])\n-                    } else {\n-                        self.get_global_name(&[&struct_ident, method_ident])\n-                    };\n-\n-                    self.register(function_type_ident, global_name)?;\n-                }\n-            }\n         }\n         Ok(())\n     }\n@@ -428,44 +328,6 @@ impl RegisterContext<'_> {\n         Ok(())\n     }\n \n-    fn process_trait(&mut self, item: &ItemTrait) -> Result<()> {\n-        self.with_cfg_attrs(&item.attrs, move |this| this.process_trait_inner(item))\n-    }\n-\n-    fn process_trait_inner(&mut self, trait_item: &ItemTrait) -> Result<()> {\n-        if trait_item\n-            .attrs\n-            .iter()\n-            .any(|a| is_turbo_attribute(a, \"value_trait\"))\n-        {\n-            let trait_ident = &trait_item.ident;\n-\n-            for item in &trait_item.items {\n-                if let TraitItem::Fn(TraitItemFn {\n-                    default: Some(_),\n-                    sig,\n-                    attrs,\n-                    ..\n-                }) = item\n-                    && attrs.iter().any(|a| is_turbo_attribute(a, \"function\"))\n-                {\n-                    let method_ident = &sig.ident;\n-                    let function_type_ident =\n-                        get_trait_default_impl_function_ident(trait_ident, method_ident);\n-\n-                    self.register(\n-                        function_type_ident,\n-                        self.get_global_name(&[trait_ident, method_ident]),\n-                    )?;\n-                }\n-            }\n-\n-            let trait_type_ident = get_trait_type_ident(trait_ident);\n-            self.register(trait_type_ident, self.get_global_name(&[trait_ident]))?;\n-        }\n-        Ok(())\n-    }\n-\n     fn process_macro(&mut self, item: &ItemMacro) -> Result<()> {\n         self.with_cfg_attrs(&item.attrs, move |this| this.process_macro_inner(item))\n     }\n@@ -510,24 +372,9 @@ impl RegisterContext<'_> {\n }\n \n impl RegisterContext<'_> {\n-    fn get_global_name(&self, parts: &[&Ident]) -> String {\n-        format!(\n-            \"r##\\\"{}{}::{}\\\"##\",\n-            self.prefix,\n-            self.mod_path,\n-            parts\n-                .iter()\n-                .map(ToString::to_string)\n-                .collect::<Vec<_>>()\n-                .join(\"::\")\n-        )\n-    }\n-\n     fn add_value(&mut self, ident: &Ident) {\n         let key: ValueKey = (self.mod_path.clone(), ident.clone());\n         let value = ValueEntry {\n-            attributes: self.attributes.clone(),\n-            global_name: self.get_global_name(&[ident]),\n             trait_idents: Vec::new(),\n         };\n \n@@ -539,7 +386,6 @@ impl RegisterContext<'_> {\n \n     fn add_value_debug_impl(&mut self, ident: &Ident) {\n         // register default debug impl generated by proc macro\n-        self.register_debug_impl(ident).unwrap();\n         self.add_value_trait(\n             ident,\n             &get_type_ident(&parse_quote! {\n@@ -551,7 +397,6 @@ impl RegisterContext<'_> {\n \n     fn add_value_default_impl(&mut self, ident: &Ident) {\n         // register default ValueDefault impl generated by proc macro\n-        self.register_default_impl(ident).unwrap();\n         self.add_value_trait(\n             ident,\n             &get_type_ident(&parse_quote! {\n@@ -577,66 +422,6 @@ impl RegisterContext<'_> {\n         entry.unwrap().trait_idents.push(trait_ident.clone());\n     }\n \n-    fn register(\n-        &mut self,\n-        type_ident: impl Display,\n-        global_name: impl Display,\n-    ) -> std::fmt::Result {\n-        for attribute in &self.attributes {\n-            self.register.push_str(attribute);\n-        }\n-        writeln!(\n-            self.register,\n-            \"crate{}::{}.register({});\",\n-            self.mod_path, type_ident, global_name\n-        )\n-    }\n-\n-    /// Declares a derive of the given trait and its methods.\n-    fn register_impl(\n-        &mut self,\n-        ident: &Ident,\n-        trait_ident: &Ident,\n-        fn_names: &[&'static str],\n-    ) -> std::fmt::Result {\n-        for fn_name in fn_names {\n-            let fn_ident = Ident::new(fn_name, ident.span());\n-\n-            let (impl_fn_ident, global_name) = (\n-                get_trait_impl_function_ident(ident, trait_ident, &fn_ident),\n-                self.get_global_name(&[ident, trait_ident, &fn_ident]),\n-            );\n-\n-            self.register(impl_fn_ident, global_name)?;\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Declares the default derive of the `ValueDebug` trait.\n-    fn register_debug_impl(&mut self, ident: &Ident) -> std::fmt::Result {\n-        self.register_impl(\n-            ident,\n-            &get_type_ident(&parse_quote! {\n-                turbo_tasks::debug::ValueDebug\n-            })\n-            .unwrap(),\n-            &[\"dbg\", \"dbg_depth\"],\n-        )\n-    }\n-\n-    /// Declares the default derive of the `ValueDefault` trait.\n-    fn register_default_impl(&mut self, ident: &Ident) -> std::fmt::Result {\n-        self.register_impl(\n-            ident,\n-            &get_type_ident(&parse_quote! {\n-                turbo_tasks::ValueDefault\n-            })\n-            .unwrap(),\n-            &[\"value_default\"],\n-        )\n-    }\n-\n     fn with_cfg_attrs<T>(&mut self, attrs: &[Attribute], func: impl FnOnce(&mut Self) -> T) -> T {\n         let orig_len = self.attributes.len();\n         for attr in attrs.iter().filter(|a| is_cfg_attribute(a)) {"
        },
        {
            "sha": "068bb214cefc263a9a2d15243582b8b807004217",
            "filename": "turbopack/crates/turbo-tasks-macros-shared/src/ident.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 30,
            "changes": 32,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fident.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fident.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros-shared%2Fsrc%2Fident.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -1,23 +1,9 @@\n use quote::ToTokens;\n use syn::{GenericArgument, Ident, Path, PathArguments, Type, TypeParamBound, spanned::Spanned};\n \n-pub fn get_register_value_type_ident(struct_ident: &Ident) -> Ident {\n+pub fn get_cast_to_fat_pointer_ident(trait_ident: &Ident, struct_ident: &Ident) -> Ident {\n     Ident::new(\n-        &format!(\"__register_{struct_ident}_value_type\"),\n-        struct_ident.span(),\n-    )\n-}\n-\n-pub fn get_register_trait_methods_ident(trait_ident: &Ident, struct_ident: &Ident) -> Ident {\n-    Ident::new(\n-        &format!(\"__register_{struct_ident}_{trait_ident}_trait_methods\"),\n-        trait_ident.span(),\n-    )\n-}\n-\n-pub fn get_register_trait_impls_ident(trait_ident: &Ident, struct_ident: &Ident) -> Ident {\n-    Ident::new(\n-        &format!(\"__register_{struct_ident}_{trait_ident}_trait_impls\"),\n+        &format!(\"_cast_to_fat_pointer_{struct_ident}_{trait_ident}\"),\n         trait_ident.span(),\n     )\n }\n@@ -101,13 +87,6 @@ pub fn get_trait_impl_function_id_ident(\n     )\n }\n \n-pub fn get_internal_trait_impl_function_ident(trait_ident: &Ident, ident: &Ident) -> Ident {\n-    Ident::new(\n-        &format!(\"__trait_call_{trait_ident}_{ident}\"),\n-        trait_ident.span(),\n-    )\n-}\n-\n pub fn get_path_ident(path: &Path) -> Ident {\n     let mut result = String::new();\n \n@@ -203,10 +182,3 @@ pub fn get_value_type_ident(ident: &Ident) -> Ident {\n         ident.span(),\n     )\n }\n-\n-pub fn get_value_type_init_ident(ident: &Ident) -> Ident {\n-    Ident::new(\n-        &format!(\"{}_VALUE_TYPE_INIT\", ident.to_string().to_uppercase()),\n-        ident.span(),\n-    )\n-}"
        },
        {
            "sha": "735ab9144ac0e0f2fcb60037793e7ef44758eab6",
            "filename": "turbopack/crates/turbo-tasks-macros/src/func.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunc.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -1086,6 +1086,7 @@ pub struct FilterTraitCallArgsTokens {\n \n #[derive(Debug)]\n pub struct NativeFn {\n+    pub function_global_name: TokenStream,\n     pub function_path_string: String,\n     pub function_path: ExprPath,\n     pub is_method: bool,\n@@ -1102,6 +1103,7 @@ impl NativeFn {\n \n     pub fn definition(&self) -> TokenStream {\n         let Self {\n+            function_global_name,\n             function_path_string,\n             function_path,\n             is_method,\n@@ -1132,6 +1134,7 @@ impl NativeFn {\n                         #[allow(deprecated)]\n                         turbo_tasks::macro_helpers::NativeFunction::new_method(\n                             #function_path_string,\n+                            #function_global_name,\n                             turbo_tasks::macro_helpers::FunctionMeta {\n                                 local: #local,\n                             },\n@@ -1146,6 +1149,7 @@ impl NativeFn {\n                         #[allow(deprecated)]\n                         turbo_tasks::macro_helpers::NativeFunction::new_method_without_this(\n                             #function_path_string,\n+                            #function_global_name,\n                             turbo_tasks::macro_helpers::FunctionMeta {\n                                 local: #local,\n                             },\n@@ -1161,6 +1165,7 @@ impl NativeFn {\n                     #[allow(deprecated)]\n                     turbo_tasks::macro_helpers::NativeFunction::new_function(\n                         #function_path_string,\n+                        #function_global_name,\n                         turbo_tasks::macro_helpers::FunctionMeta {\n                             local: #local,\n                         },"
        },
        {
            "sha": "618933397a53d2fc24358e15bfe277584f8954ce",
            "filename": "turbopack/crates/turbo-tasks-macros/src/function_macro.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 5,
            "changes": 17,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Ffunction_macro.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -3,8 +3,9 @@ use quote::quote;\n use syn::{ItemFn, parse_macro_input, parse_quote};\n use turbo_tasks_macros_shared::{get_native_function_ident, is_self_used};\n \n-use crate::func::{\n-    DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n+use crate::{\n+    func::{DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes},\n+    global_name::global_name,\n };\n \n /// This macro generates the virtual function that powers turbo tasks.\n@@ -55,9 +56,11 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n     let (inline_signature, inline_block) =\n         turbo_fn.inline_signature_and_block(&block, is_self_used);\n     let inline_attrs = filter_inline_attributes(&attrs[..]);\n+    let function_path_string = ident.to_string();\n \n     let native_fn = NativeFn {\n-        function_path_string: ident.to_string(),\n+        function_global_name: global_name(&function_path_string),\n+        function_path_string,\n         function_path: parse_quote! { #inline_function_ident },\n         is_method: turbo_fn.is_method(),\n         is_self_used,\n@@ -79,11 +82,15 @@ pub fn function(args: TokenStream, input: TokenStream) -> TokenStream {\n         #[doc(hidden)]\n         #inline_signature #inline_block\n \n-        #[doc(hidden)]\n-        pub(crate) static #native_function_ident:\n+        static #native_function_ident:\n             turbo_tasks::macro_helpers::Lazy<#native_function_ty> =\n                 turbo_tasks::macro_helpers::Lazy::new(|| #native_function_def);\n \n+        // Register the function for deserialization\n+        turbo_tasks::macro_helpers::inventory_submit! {\n+            turbo_tasks::macro_helpers::CollectableFunction(&#native_function_ident)\n+        }\n+\n         #(#errors)*\n     }\n     .into()"
        },
        {
            "sha": "b8bedfe6821d32be795288f0a1b3c593e3a292ae",
            "filename": "turbopack/crates/turbo-tasks-macros/src/generic_type_macro.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fgeneric_type_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fgeneric_type_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fgeneric_type_macro.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -4,7 +4,7 @@ use rustc_hash::FxHashSet;\n use syn::{GenericParam, Lifetime, Type, parse_macro_input, spanned::Spanned, visit_mut::VisitMut};\n use turbo_tasks_macros_shared::{GenericTypeInput, get_type_ident};\n \n-use crate::value_macro::value_type_and_register;\n+use crate::{global_name::global_name, value_macro::value_type_and_register};\n \n pub fn generic_type(input: TokenStream) -> TokenStream {\n     let mut input = parse_macro_input!(input as GenericTypeInput);\n@@ -44,10 +44,10 @@ pub fn generic_type(input: TokenStream) -> TokenStream {\n \n     let (impl_generics, _, where_clause) = input.generics.split_for_impl();\n \n-    let repr = replace_generics_with_unit(input.generics.params.iter(), &input.ty);\n+    let ty = &input.ty;\n+    let repr = replace_generics_with_unit(input.generics.params.iter(), ty);\n \n-    let ty = input.ty;\n-    let Some(ident) = get_type_ident(&ty) else {\n+    let Some(ident) = get_type_ident(ty) else {\n         return quote! {\n             // An error occurred while parsing the ident.\n         }\n@@ -64,6 +64,7 @@ pub fn generic_type(input: TokenStream) -> TokenStream {\n         }\n     }\n \n+    let name = global_name(quote! {stringify!(#repr) });\n     let value_type_and_register = value_type_and_register(\n         &ident,\n         quote! { #ty },\n@@ -75,7 +76,7 @@ pub fn generic_type(input: TokenStream) -> TokenStream {\n             turbo_tasks::VcCellSharedMode<#ty>\n         },\n         quote! {\n-            turbo_tasks::ValueType::new_with_any_serialization::<#repr>()\n+            turbo_tasks::ValueType::new_with_any_serialization::<#repr>(#name)\n         },\n     );\n "
        },
        {
            "sha": "85bac0933711155c2292deebc4ff8c493a66c0d8",
            "filename": "turbopack/crates/turbo-tasks-macros/src/global_name.rs",
            "status": "added",
            "additions": 11,
            "deletions": 0,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fglobal_name.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fglobal_name.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fglobal_name.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -0,0 +1,11 @@\n+use proc_macro2::TokenStream;\n+use quote::quote;\n+\n+/// Composes an expression that will evaluate to a &'static str of the fully qualified name\n+///\n+/// The name is prefixed with the current crate name and module path\n+pub(crate) fn global_name(local_name: impl quote::ToTokens) -> TokenStream {\n+    let crate_name =\n+        std::env::var(\"CARGO_PKG_NAME\").unwrap_or_else(|_| \"unknown_crate\".to_string());\n+    quote! { concat!(#crate_name, \"@\", module_path!(), \"::\", #local_name)}\n+}"
        },
        {
            "sha": "754cc67638789ec80bea5e267d81ff53d9da6e07",
            "filename": "turbopack/crates/turbo-tasks-macros/src/lib.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Flib.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -8,6 +8,7 @@ mod derive;\n mod func;\n mod function_macro;\n mod generic_type_macro;\n+mod global_name;\n mod primitive_macro;\n mod value_impl_macro;\n mod value_macro;"
        },
        {
            "sha": "8a39cc4b70713da5bf0c53c97ed7803e93618d48",
            "filename": "turbopack/crates/turbo-tasks-macros/src/primitive_macro.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fprimitive_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fprimitive_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fprimitive_macro.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -3,7 +3,7 @@ use quote::quote;\n use syn::parse_macro_input;\n use turbo_tasks_macros_shared::{PrimitiveInput, get_type_ident};\n \n-use crate::value_macro::value_type_and_register;\n+use crate::{global_name::global_name, value_macro::value_type_and_register};\n \n pub fn primitive(input: TokenStream) -> TokenStream {\n     let input = parse_macro_input!(input as PrimitiveInput);\n@@ -32,7 +32,7 @@ pub fn primitive(input: TokenStream) -> TokenStream {\n             }\n         }\n     };\n-\n+    let name = global_name(quote! {stringify!(#ty) });\n     let value_type_and_register = value_type_and_register(\n         &ident,\n         quote! { #ty },\n@@ -44,7 +44,7 @@ pub fn primitive(input: TokenStream) -> TokenStream {\n             turbo_tasks::VcCellSharedMode<#ty>\n         },\n         quote! {\n-            turbo_tasks::ValueType::new_with_any_serialization::<#ty>()\n+            turbo_tasks::ValueType::new_with_any_serialization::<#ty>(#name)\n         },\n     );\n "
        },
        {
            "sha": "12b94aada5e6d251dc4c480f763b159cae77fd8d",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_impl_macro.rs",
            "status": "modified",
            "additions": 62,
            "deletions": 36,
            "changes": 98,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_impl_macro.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -9,13 +9,16 @@ use syn::{\n     spanned::Spanned,\n };\n use turbo_tasks_macros_shared::{\n-    get_inherent_impl_function_ident, get_path_ident, get_register_trait_impls_ident,\n-    get_register_trait_methods_ident, get_trait_impl_function_ident, get_type_ident, is_self_used,\n+    get_cast_to_fat_pointer_ident, get_inherent_impl_function_ident, get_path_ident,\n+    get_trait_impl_function_ident, get_type_ident, is_self_used,\n };\n \n-use crate::func::{\n-    DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n-    split_function_attributes,\n+use crate::{\n+    func::{\n+        DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n+        split_function_attributes,\n+    },\n+    global_name::global_name,\n };\n \n struct ValueImplArguments {\n@@ -108,9 +111,10 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                 let (inline_signature, inline_block) =\n                     turbo_fn.inline_signature_and_block(block, is_self_used);\n                 let inline_attrs = filter_inline_attributes(attrs.iter().copied());\n-\n+                let function_path_string = format!(\"{ty}::{ident}\", ty = ty.to_token_stream());\n                 let native_fn = NativeFn {\n-                    function_path_string: format!(\"{ty}::{ident}\", ty = ty.to_token_stream()),\n+                    function_global_name: global_name(&function_path_string),\n+                    function_path_string,\n                     function_path: parse_quote! { <#ty>::#inline_function_ident },\n                     is_method: turbo_fn.is_method(),\n                     is_self_used,\n@@ -141,10 +145,14 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                         pub(self) #inline_signature #inline_block\n                     }\n \n-                    #[doc(hidden)]\n-                    pub(crate) static #native_function_ident:\n+                    static #native_function_ident:\n                         turbo_tasks::macro_helpers::Lazy<#native_function_ty> =\n                             turbo_tasks::macro_helpers::Lazy::new(|| #native_function_def);\n+\n+                    // Register the function for deserialization\n+                    turbo_tasks::macro_helpers::inventory_submit! {\n+                        turbo_tasks::macro_helpers::CollectableFunction(&#native_function_ident)\n+                    }\n                 })\n             }\n         }\n@@ -170,11 +178,10 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n \n         let (impl_generics, _, where_clause) = generics.split_for_impl();\n \n-        let register_trait_methods: Ident =\n-            get_register_trait_methods_ident(&trait_ident, ty_ident);\n-        let register_trait_impls: Ident = get_register_trait_impls_ident(&trait_ident, ty_ident);\n+        let cast_to_fat_pointer_ident: Ident =\n+            get_cast_to_fat_pointer_ident(&trait_ident, ty_ident);\n \n-        let mut trait_registers = Vec::new();\n+        let mut trait_methods = Vec::new();\n         let mut trait_functions = Vec::with_capacity(items.len());\n         let mut trait_items = Vec::new();\n         let mut all_definitions = Vec::with_capacity(items.len());\n@@ -220,8 +227,13 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                 let (inline_signature, inline_block) =\n                     turbo_fn.inline_signature_and_block(block, is_self_used);\n                 let inline_attrs = filter_inline_attributes(attrs.iter().copied());\n-\n                 let native_fn = NativeFn {\n+                    // This global name breaks the pattern.  It isn't clear if it is intentional\n+                    function_global_name: global_name(format!(\n+                        \"{ty}::{trait_path}::{ident}\",\n+                        ty = ty.to_token_stream(),\n+                        trait_path = trait_path.to_token_stream()\n+                    )),\n                     function_path_string: format!(\n                         \"<{ty} as {trait_path}>::{ident}\",\n                         ty = ty.to_token_stream(),\n@@ -266,43 +278,57 @@ pub fn value_impl(args: TokenStream, input: TokenStream) -> TokenStream {\n                         #inline_signature #inline_block\n                     }\n \n-                    #[doc(hidden)]\n-                    pub(crate) static #native_function_ident:\n+                    static #native_function_ident:\n                         turbo_tasks::macro_helpers::Lazy<#native_function_ty> =\n                             turbo_tasks::macro_helpers::Lazy::new(|| #native_function_def);\n+\n+                    // Register the function for deserialization\n+                    turbo_tasks::macro_helpers::inventory_submit! {\n+                        turbo_tasks::macro_helpers::CollectableFunction(&#native_function_ident)\n+                    }\n                 });\n \n-                trait_registers.push(quote! {\n-                    value.register_trait_method(\n-                        <Box<dyn #trait_path> as turbo_tasks::VcValueTrait>::get_trait_type_id(),\n-                        stringify!(#ident),\n-                        &#native_function_ident);\n+                trait_methods.push(quote! {\n+                    (stringify!(#ident), &#native_function_ident),\n                 });\n             }\n         }\n-\n+        let value_name = global_name(quote! {stringify!(#ty_ident)});\n         quote! {\n-            #[doc(hidden)]\n-            #[allow(non_snake_case)]\n-            pub(crate) fn #register_trait_methods(value: &mut turbo_tasks::ValueType) {\n-                value.register_trait(<Box<dyn #trait_path> as turbo_tasks::VcValueTrait>::get_trait_type_id());\n-                #(#trait_registers)*\n+            // Register all the function impls so the ValueType can find them\n+            // This means objects resolve as\n+            // 1 NativeFunctions\n+            // 2 TraitTypes (requires functions)\n+            // 3 ValueTypes (requires functions and TraitTypeIds)\n+            // 4.VTableRegistries (requires ValueTypeIds)\n+            turbo_tasks::macro_helpers::inventory_submit!{\n+                turbo_tasks::macro_helpers::CollectableTraitMethods(\n+                    #value_name,\n+                    || (<::std::boxed::Box<dyn #trait_path> as turbo_tasks::VcValueTrait>::get_trait_type_id(),\n+                        vec![#(#trait_methods)*])\n+                )\n             }\n-            #[doc(hidden)]\n+\n+            // These can execute later so they can reference trait_types during registration\n+\n+            turbo_tasks::macro_helpers::inventory_submit!{\n+                turbo_tasks::macro_helpers::CollectableTraitCastFunctions(\n+                    <::std::boxed::Box<dyn #trait_path> as turbo_tasks::VcValueTrait>::get_trait_type_id,\n+                    <#ty as turbo_tasks::VcValueType>::get_value_type_id,\n+                    #cast_to_fat_pointer_ident as *const ()\n+                )\n+            }\n+\n             #[allow(non_snake_case)]\n-            pub(crate) fn #register_trait_impls(value_id: turbo_tasks::ValueTypeId) {\n-                // NOTE(lukesandberg): This relies on the nightly ptr_metadata feature.  Alternatively\n-                // we could generate a function that does the downcasting and pass that up to register_trait.\n-                // This would avoid the nightly feature.\n-                let fat_pointer: *const dyn #trait_path = ::std::ptr::null::<#ty>() as *const dyn #trait_path;\n-                let metadata = turbo_tasks::macro_helpers::metadata(fat_pointer);\n-                turbo_tasks::macro_helpers::register_trait_impl::<dyn #trait_path, Box<dyn #trait_path>>(value_id, metadata);\n+            fn #cast_to_fat_pointer_ident(raw: * const ()) -> *const dyn #trait_path {\n+                let typed = raw as *const #ty;\n+                typed as *const dyn #trait_path\n             }\n \n             // NOTE(alexkirsz) We can't have a general `turbo_tasks::Upcast<Box<dyn Trait>> for T where T: Trait` because\n             // rustc complains: error[E0210]: type parameter `T` must be covered by another type when it appears before\n             // the first local type (`dyn Trait`).\n-            unsafe impl #impl_generics turbo_tasks::Upcast<Box<dyn #trait_path>> for #ty #where_clause {}\n+            unsafe impl #impl_generics turbo_tasks::Upcast<::std::boxed::Box<dyn #trait_path>> for #ty #where_clause {}\n \n             impl #impl_generics #trait_path for #ty #where_clause {\n                 #(#trait_items)*"
        },
        {
            "sha": "7fb870d078f34f064c60bb313b213207d061e633",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_macro.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 38,
            "changes": 53,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_macro.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -11,9 +11,9 @@ use syn::{\n     parse_macro_input, parse_quote,\n     spanned::Spanned,\n };\n-use turbo_tasks_macros_shared::{\n-    get_register_value_type_ident, get_value_type_ident, get_value_type_init_ident,\n-};\n+use turbo_tasks_macros_shared::get_value_type_ident;\n+\n+use crate::global_name::global_name;\n \n enum IntoMode {\n     None,\n@@ -393,13 +393,14 @@ pub fn value(args: TokenStream, input: TokenStream) -> TokenStream {\n         });\n     }\n \n+    let name = global_name(quote! {stringify!(#ident) });\n     let new_value_type = match serialization_mode {\n         SerializationMode::None => quote! {\n-            turbo_tasks::ValueType::new::<#ident>()\n+            turbo_tasks::ValueType::new::<#ident>(#name)\n         },\n         SerializationMode::Auto | SerializationMode::Custom => {\n             quote! {\n-                turbo_tasks::ValueType::new_with_any_serialization::<#ident>()\n+                turbo_tasks::ValueType::new_with_any_serialization::<#ident>(#name)\n             }\n         }\n     };\n@@ -462,9 +463,7 @@ pub fn value_type_and_register(\n     cell_mode: proc_macro2::TokenStream,\n     new_value_type: proc_macro2::TokenStream,\n ) -> proc_macro2::TokenStream {\n-    let value_type_init_ident = get_value_type_init_ident(ident);\n     let value_type_ident = get_value_type_ident(ident);\n-    let register_value_type_ident = get_register_value_type_ident(ident);\n \n     let (impl_generics, where_clause) = if let Some(generics) = generics {\n         let (impl_generics, _, where_clause) = generics.split_for_impl();\n@@ -474,47 +473,25 @@ pub fn value_type_and_register(\n     };\n \n     quote! {\n-        #[doc(hidden)]\n-        static #value_type_init_ident: turbo_tasks::macro_helpers::OnceCell<\n-            turbo_tasks::ValueType,\n-        > = turbo_tasks::macro_helpers::OnceCell::new();\n-        #[doc(hidden)]\n-        pub(crate) static #value_type_ident: turbo_tasks::macro_helpers::Lazy<&turbo_tasks::ValueType> =\n-            turbo_tasks::macro_helpers::Lazy::new(|| {\n-                #value_type_init_ident.get_or_init(|| {\n-                    panic!(\n-                        concat!(\n-                            stringify!(#value_type_ident),\n-                            \" has not been initialized (this should happen via the generated register function)\"\n-                        )\n-                    )\n-                })\n-            });\n-\n \n-        #[doc(hidden)]\n-        #[allow(non_snake_case)]\n-        pub(crate) fn #register_value_type_ident(\n-            global_name: &'static str,\n-            init: impl FnOnce(&mut turbo_tasks::ValueType),\n-            register_traits: impl FnOnce(turbo_tasks::ValueTypeId),\n-        ) {\n-            #value_type_init_ident.get_or_init(|| {\n+        static #value_type_ident: turbo_tasks::macro_helpers::Lazy<turbo_tasks::ValueType> =\n+            turbo_tasks::macro_helpers::Lazy::new(|| {\n                 let mut value = #new_value_type;\n-                init(&mut value);\n+                turbo_tasks::macro_helpers::register_trait_methods(&mut value);\n                 value\n-            }).register(global_name, register_traits);\n-        }\n+             });\n+\n+        turbo_tasks::macro_helpers::inventory_submit!{turbo_tasks::macro_helpers::CollectableValueType(&#value_type_ident)}\n \n         unsafe impl #impl_generics turbo_tasks::VcValueType for #ty #where_clause {\n             type Read = #read;\n             type CellMode = #cell_mode;\n \n             fn get_value_type_id() -> turbo_tasks::ValueTypeId {\n                 static ident: turbo_tasks::macro_helpers::Lazy<turbo_tasks::ValueTypeId> =\n-                turbo_tasks::macro_helpers::Lazy::new(|| {\n-                    turbo_tasks::registry::get_value_type_id(*#value_type_ident)\n-                });\n+                    turbo_tasks::macro_helpers::Lazy::new(|| {\n+                        turbo_tasks::registry::get_value_type_id(&#value_type_ident)\n+                    });\n \n                 *ident\n             }"
        },
        {
            "sha": "778e08732fd2796f077e7496fbafee9d98bd2160",
            "filename": "turbopack/crates/turbo-tasks-macros/src/value_trait_macro.rs",
            "status": "modified",
            "additions": 32,
            "deletions": 19,
            "changes": 51,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-macros%2Fsrc%2Fvalue_trait_macro.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -8,9 +8,12 @@ use turbo_tasks_macros_shared::{\n     ValueTraitArguments, get_trait_default_impl_function_ident, get_trait_type_ident, is_self_used,\n };\n \n-use crate::func::{\n-    DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n-    split_function_attributes,\n+use crate::{\n+    func::{\n+        DefinitionContext, FunctionArguments, NativeFn, TurboFn, filter_inline_attributes,\n+        split_function_attributes,\n+    },\n+    global_name::global_name,\n };\n \n pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n@@ -175,8 +178,10 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n                 turbo_fn.inline_signature_and_block(default, is_self_used);\n             let inline_attrs = filter_inline_attributes(attrs.iter().copied());\n \n+            let function_path_string = format!(\"{trait_ident}::{ident}\");\n             let native_function = NativeFn {\n-                function_path_string: format!(\"{trait_ident}::{ident}\"),\n+                function_global_name: global_name(&function_path_string),\n+                function_path_string,\n                 function_path: parse_quote! {\n                     <Box<dyn #trait_ident> as #inline_extension_trait_ident>::#inline_function_ident\n                 },\n@@ -195,9 +200,7 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n             let native_function_def = native_function.definition();\n \n             trait_methods.push(quote! {\n-                trait_type.register_default_trait_method(\n-                    stringify!(#ident),\n-                    &#native_function_ident);\n+                (stringify!(#ident), Some(&#native_function_ident)),\n             });\n \n             native_functions.push(quote! {\n@@ -217,16 +220,20 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n                     #inline_signature #inline_block\n                 }\n \n-                #[doc(hidden)]\n-                pub(crate) static #native_function_ident:\n+                static #native_function_ident:\n                     turbo_tasks::macro_helpers::Lazy<#native_function_ty> =\n                         turbo_tasks::macro_helpers::Lazy::new(|| #native_function_def);\n+\n+                // Register the function for deserialization\n+                turbo_tasks::macro_helpers::inventory_submit! {\n+                    turbo_tasks::macro_helpers::CollectableFunction(&#native_function_ident)\n+                }\n             });\n \n             Some(turbo_fn.static_block(&native_function_ident))\n         } else {\n             trait_methods.push(quote! {\n-                trait_type.register_trait_method(stringify!(#ident));\n+                (stringify!(#ident), None),\n             });\n             None\n         };\n@@ -262,6 +269,7 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n         extended_supertraits.push(quote!(turbo_tasks::debug::ValueDebug));\n     }\n \n+    let trait_name = global_name(quote! {stringify!(#trait_ident)});\n     let expanded = quote! {\n         #[must_use]\n         #(#attrs)*\n@@ -272,29 +280,34 @@ pub fn value_trait(args: TokenStream, input: TokenStream) -> TokenStream {\n \n         #(#native_functions)*\n \n-        #[doc(hidden)]\n-        pub(crate) static #trait_type_ident: turbo_tasks::macro_helpers::Lazy<turbo_tasks::TraitType> =\n+        static #trait_type_ident: turbo_tasks::macro_helpers::Lazy<turbo_tasks::TraitType> =\n             turbo_tasks::macro_helpers::Lazy::new(|| {\n-                let mut trait_type = turbo_tasks::TraitType::new(stringify!(#trait_ident));;\n-                #(#trait_methods)*\n-                trait_type\n+                turbo_tasks::TraitType::new(\n+                    stringify!(#trait_ident),\n+                    #trait_name,\n+                    vec![#(#trait_methods)*])\n             });\n \n+        // Register the trait for deserialization\n+        turbo_tasks::macro_helpers::inventory_submit! {\n+            turbo_tasks::macro_helpers::CollectableTrait(&#trait_type_ident)\n+        }\n+\n         impl turbo_tasks::VcValueTrait for Box<dyn #trait_ident> {\n             type ValueTrait = dyn #trait_ident;\n \n             fn get_trait_type_id() -> turbo_tasks::TraitTypeId {\n                 static ident: turbo_tasks::macro_helpers::Lazy<turbo_tasks::TraitTypeId> =\n-                turbo_tasks::macro_helpers::Lazy::new(|| {\n-                    turbo_tasks::registry::get_trait_type_id(&#trait_type_ident)\n-                });\n+                    turbo_tasks::macro_helpers::Lazy::new(|| {\n+                        turbo_tasks::registry::get_trait_type_id(&#trait_type_ident)\n+                    });\n \n                 *ident\n             }\n \n             fn get_impl_vtables() -> &'static turbo_tasks::macro_helpers::VTableRegistry<Self::ValueTrait> {\n                 static registry: turbo_tasks::macro_helpers::Lazy<turbo_tasks::macro_helpers::VTableRegistry<dyn # trait_ident>> =\n-                turbo_tasks::macro_helpers::Lazy::new(turbo_tasks::macro_helpers::VTableRegistry::new);\n+                    turbo_tasks::macro_helpers::Lazy::new(|| turbo_tasks::macro_helpers::VTableRegistry::new(turbo_tasks::registry::get_trait_type_id(&#trait_type_ident)));\n \n                 &*registry\n             }"
        },
        {
            "sha": "bc690e2c6926d95ed0989816e4e5af1a63b7d625",
            "filename": "turbopack/crates/turbo-tasks/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2FCargo.toml?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -54,6 +54,7 @@ turbo-tasks-hash = { workspace = true }\n turbo-tasks-macros = { workspace = true }\n turbo-tasks-malloc = { workspace = true }\n unsize = { workspace = true }\n+inventory = { workspace = true }\n \n [build-dependencies]\n turbo-tasks-build = { workspace = true }"
        },
        {
            "sha": "b8f1f525f16b36eced833b03e0365c65954a1b19",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -212,7 +212,7 @@ mod ser {\n                 unreachable!();\n             };\n             let mut state = serializer.serialize_seq(Some(2))?;\n-            state.serialize_element(native_fn.global_name())?;\n+            state.serialize_element(native_fn.global_name)?;\n             let arg = *arg;\n             let arg = native_fn.arg_meta.as_serialize(arg);\n             state.serialize_element(arg)?;"
        },
        {
            "sha": "4a504ee7b2b547b22f331bc9c09a597eb2f07ca0",
            "filename": "turbopack/crates/turbo-tasks/src/id_factory.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid_factory.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid_factory.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fid_factory.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -7,7 +7,7 @@ use std::{\n \n use concurrent_queue::ConcurrentQueue;\n \n-/// A helper for constructing id types like [`FunctionId`][crate::FunctionId].\n+/// A helper for constructing id types like [`ValueTypeId`][crate::ValueTypeId].\n ///\n /// For ids that may be re-used, see [`IdFactoryWithReuse`].\n pub struct IdFactory<T> {"
        },
        {
            "sha": "7bd194e5d73291897d311e76fd04ad953a1e7d9f",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -63,7 +63,6 @@ mod manager;\n mod marker_trait;\n pub mod message_queue;\n mod native_function;\n-mod no_move_vec;\n mod once_map;\n mod output;\n pub mod panic_hooks;"
        },
        {
            "sha": "65fa451e52dbf3b70b33f82e01686c3b5daae8bb",
            "filename": "turbopack/crates/turbo-tasks/src/macro_helpers.rs",
            "status": "modified",
            "additions": 103,
            "deletions": 21,
            "changes": 124,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmacro_helpers.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmacro_helpers.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmacro_helpers.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -1,21 +1,23 @@\n //! Runtime helpers for [turbo-tasks-macro].\n \n-use std::ptr::DynMetadata;\n-\n pub use async_trait::async_trait;\n pub use once_cell::sync::{Lazy, OnceCell};\n+use rustc_hash::FxHashMap;\n pub use serde;\n pub use shrink_to_fit;\n pub use tracing;\n \n use crate::{\n-    FxDashMap, NonLocalValue, RawVc, TaskInput, TaskPersistence, ValueTypeId, Vc, VcValueTrait,\n-    debug::ValueDebugFormatString, task::TaskOutput,\n+    FxDashMap, NonLocalValue, RawVc, TaskInput, TaskPersistence, TraitTypeId, ValueType,\n+    ValueTypeId, Vc, debug::ValueDebugFormatString, task::TaskOutput,\n };\n pub use crate::{\n     magic_any::MagicAny,\n     manager::{find_cell_by_type, notify_scheduled_tasks, spawn_detached_for_testing},\n-    native_function::{FunctionMeta, NativeFunction, downcast_args_owned, downcast_args_ref},\n+    native_function::{\n+        CollectableFunction, FunctionMeta, NativeFunction, downcast_args_owned, downcast_args_ref,\n+    },\n+    value_type::{CollectableTrait, CollectableValueType},\n };\n \n #[inline(never)]\n@@ -67,7 +69,7 @@ macro_rules! stringify_path {\n /// Rexport std::ptr::metadata so not every crate needs to enable the feature when they use our\n /// macros.\n #[inline(always)]\n-pub fn metadata<T: ?Sized>(ptr: *const T) -> <T as std::ptr::Pointee>::Metadata {\n+pub const fn metadata<T: ?Sized>(ptr: *const T) -> <T as std::ptr::Pointee>::Metadata {\n     // Ideally we would just `pub use std::ptr::metadata;` but this doesn't seem to work.\n     std::ptr::metadata(ptr)\n }\n@@ -76,29 +78,109 @@ pub fn metadata<T: ?Sized>(ptr: *const T) -> <T as std::ptr::Pointee>::Metadata\n /// This is constructed in the macro gencode and populated by the registry.\n #[derive(Default)]\n pub struct VTableRegistry<T: ?Sized> {\n-    map: FxDashMap<ValueTypeId, std::ptr::DynMetadata<T>>,\n+    map: FxHashMap<ValueTypeId, <T as std::ptr::Pointee>::Metadata>,\n }\n \n impl<T: ?Sized> VTableRegistry<T> {\n-    pub fn new() -> Self {\n-        Self {\n-            map: FxDashMap::default(),\n+    pub fn new(id: TraitTypeId) -> Self {\n+        let mut map = FxHashMap::default();\n+        match TRAIT_CAST_FNS.remove(&id) {\n+            Some((_, impls)) => {\n+                for (value_type_id, RawPtr(raw_fn)) in impls {\n+                    // SAFETY: These are generated by the macro gencode in value_impl with this\n+                    // signature.\n+                    let cast_fn: fn(*const ()) -> *const T = unsafe { std::mem::transmute(raw_fn) };\n+                    // Cast a null pointer to a fat pointer using the cast_fn, this allows us to\n+                    // capture a vtable Alternatively we could just store the\n+                    // cast functions but it will be faster to call 'from_raw_parts' instead of an\n+                    // indirect function call.\n+                    let ptr = cast_fn(std::ptr::null::<()>());\n+                    let metadata = std::ptr::metadata(ptr);\n+                    let prev = map.insert(value_type_id, metadata);\n+                    debug_assert!(\n+                        prev.is_none(),\n+                        \"multiple cast functions registered for {value_type_id}\"\n+                    )\n+                }\n+            }\n+            None => {\n+                // A trait doesn't have to have any implementations.\n+            }\n         }\n-    }\n \n-    pub(crate) fn register(&self, id: ValueTypeId, vtable: std::ptr::DynMetadata<T>) {\n-        let prev = self.map.insert(id, vtable);\n-        debug_assert!(prev.is_none(), \"{id} was already registered\");\n+        Self { map }\n     }\n \n-    pub(crate) fn get(&self, id: ValueTypeId) -> DynMetadata<T> {\n-        *self.map.get(&id).unwrap().value()\n+    pub(crate) fn cast(&self, id: ValueTypeId, raw: *const ()) -> *const T {\n+        let metadata = self.map.get(&id).unwrap();\n+        std::ptr::from_raw_parts(raw, *metadata)\n     }\n }\n \n-pub fn register_trait_impl<V: 'static + ?Sized, T: VcValueTrait<ValueTrait = V>>(\n-    id: ValueTypeId,\n-    metadata: std::ptr::DynMetadata<V>,\n-) {\n-    <T as VcValueTrait>::get_impl_vtables().register(id, metadata);\n+struct RawPtr(*const ());\n+// SAFETY: We only store function pointers in here which are safe to send/sync\n+unsafe impl Sync for RawPtr {}\n+unsafe impl Send for RawPtr {}\n+\n+// Accumulate all trait impls by trait id\n+static TRAIT_CAST_FNS: Lazy<FxDashMap<TraitTypeId, Vec<(ValueTypeId, RawPtr)>>> = Lazy::new(|| {\n+    let map: FxDashMap<TraitTypeId, Vec<(ValueTypeId, RawPtr)>> = FxDashMap::default();\n+    for CollectableTraitCastFunctions(trait_id_fn, value_id_fn, cast_fn) in\n+        inventory::iter::<CollectableTraitCastFunctions>\n+    {\n+        map.entry(trait_id_fn())\n+            .or_default()\n+            .value_mut()\n+            .push((value_id_fn(), RawPtr(*cast_fn)));\n+    }\n+    map\n+});\n+\n+// Holds a raw pointer to a function that can perform a fat pointer cast\n+pub struct CollectableTraitCastFunctions(\n+    pub fn() -> TraitTypeId,\n+    pub fn() -> ValueTypeId,\n+    pub *const (),\n+);\n+// SAFETY: We only store function pointers in here.\n+unsafe impl Sync for CollectableTraitCastFunctions {}\n+inventory::collect! {CollectableTraitCastFunctions}\n+\n+#[allow(clippy::type_complexity)]\n+pub struct CollectableTraitMethods(\n+    // A value type name\n+    pub &'static str,\n+    pub fn() -> (TraitTypeId, Vec<(&'static str, &'static NativeFunction)>),\n+);\n+inventory::collect! {CollectableTraitMethods}\n+\n+// Called when initializing ValueTypes by value_impl\n+pub fn register_trait_methods(value: &mut ValueType) {\n+    #[allow(clippy::type_complexity)]\n+    static TRAIT_METHODS_BY_VALUE: Lazy<\n+        FxDashMap<&'static str, Vec<(TraitTypeId, Vec<(&'static str, &'static NativeFunction)>)>>,\n+    > = Lazy::new(|| {\n+        let map: FxDashMap<&'static str, Vec<_>> = FxDashMap::default();\n+        for CollectableTraitMethods(value_name, thunk) in inventory::iter::<CollectableTraitMethods>\n+        {\n+            map.entry(*value_name).or_default().push(thunk());\n+        }\n+        map\n+    });\n+    match TRAIT_METHODS_BY_VALUE.remove(value.global_name) {\n+        Some((_, traits)) => {\n+            for (trait_type_id, methods) in traits {\n+                let trait_type = crate::registry::get_trait(trait_type_id);\n+                value.register_trait(trait_type_id);\n+                for (name, method) in methods {\n+                    value.register_trait_method(trait_type.get(name), method);\n+                }\n+            }\n+        }\n+        None => {\n+            // do nothing, values don't have to implement any traits\n+        }\n+    }\n }\n+\n+pub use inventory::submit as inventory_submit;"
        },
        {
            "sha": "e97b37dd140683ba631c279ccf49093bc04d2a44",
            "filename": "turbopack/crates/turbo-tasks/src/native_function.rs",
            "status": "modified",
            "additions": 15,
            "deletions": 24,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fnative_function.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -1,15 +1,14 @@\n-use core::panic;\n-use std::{fmt::Debug, hash::Hash, pin::Pin, sync::OnceLock};\n+use std::{fmt::Debug, hash::Hash, pin::Pin};\n \n use anyhow::Result;\n use futures::Future;\n+use once_cell::sync::Lazy;\n use serde::{Deserialize, Serialize};\n use tracing::Span;\n \n use crate::{\n     RawVc, TaskExecutionReason, TaskInput, TaskPersistence,\n     magic_any::{MagicAny, MagicAnyDeserializeSeed, MagicAnySerializeSeed},\n-    registry::register_function,\n     task::{\n         IntoTaskFn, TaskFn,\n         function::{IntoTaskFnWithThis, NativeTaskFuture},\n@@ -161,13 +160,15 @@ pub struct NativeFunction {\n     /// handles the task execution.\n     pub(crate) implementation: Box<dyn TaskFn + Send + Sync + 'static>,\n \n-    global_name: OnceLock<&'static str>,\n+    // The globally unique name for this function, used when persisting\n+    pub(crate) global_name: &'static str,\n }\n \n impl Debug for NativeFunction {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         f.debug_struct(\"NativeFunction\")\n             .field(\"name\", &self.name)\n+            .field(\"global_name\", &self.global_name)\n             .field(\"function_meta\", &self.function_meta)\n             .finish_non_exhaustive()\n     }\n@@ -176,6 +177,7 @@ impl Debug for NativeFunction {\n impl NativeFunction {\n     pub fn new_function<Mode, Inputs>(\n         name: &'static str,\n+        global_name: &'static str,\n         function_meta: FunctionMeta,\n         implementation: impl IntoTaskFn<Mode, Inputs>,\n     ) -> Self\n@@ -184,15 +186,16 @@ impl NativeFunction {\n     {\n         Self {\n             name,\n+            global_name,\n             function_meta,\n             arg_meta: ArgMeta::new::<Inputs>(),\n             implementation: Box::new(implementation.into_task_fn()),\n-            global_name: Default::default(),\n         }\n     }\n \n     pub fn new_method_without_this<Mode, Inputs, I>(\n         name: &'static str,\n+        global_name: &'static str,\n         function_meta: FunctionMeta,\n         arg_filter: Option<(FilterOwnedArgsFunctor, FilterAndResolveFunctor)>,\n         implementation: I,\n@@ -203,19 +206,20 @@ impl NativeFunction {\n     {\n         Self {\n             name,\n+            global_name,\n             function_meta,\n             arg_meta: if let Some((filter_owned, filter_and_resolve)) = arg_filter {\n                 ArgMeta::with_filter_trait_call::<Inputs>(filter_owned, filter_and_resolve)\n             } else {\n                 ArgMeta::new::<Inputs>()\n             },\n             implementation: Box::new(implementation.into_task_fn()),\n-            global_name: Default::default(),\n         }\n     }\n \n     pub fn new_method<Mode, This, Inputs, I>(\n         name: &'static str,\n+        global_name: &'static str,\n         function_meta: FunctionMeta,\n         arg_filter: Option<(FilterOwnedArgsFunctor, FilterAndResolveFunctor)>,\n         implementation: I,\n@@ -227,14 +231,14 @@ impl NativeFunction {\n     {\n         Self {\n             name,\n+            global_name,\n             function_meta,\n             arg_meta: if let Some((filter_owned, filter_and_resolve)) = arg_filter {\n                 ArgMeta::with_filter_trait_call::<Inputs>(filter_owned, filter_and_resolve)\n             } else {\n                 ArgMeta::new::<Inputs>()\n             },\n             implementation: Box::new(implementation.into_task_fn_with_this()),\n-            global_name: Default::default(),\n         }\n     }\n \n@@ -268,23 +272,6 @@ impl NativeFunction {\n         };\n         tracing::trace_span!(\"turbo_tasks::resolve_call\", name = self.name, flags = flags)\n     }\n-\n-    /// Returns the global name for this object\n-    pub fn global_name(&self) -> &'static str {\n-        self.global_name\n-            .get()\n-            .expect(\"cannot call `global_name` unless `register` has already been called\")\n-    }\n-\n-    pub fn register(&'static self, global_name: &'static str) {\n-        match self.global_name.set(global_name) {\n-            Ok(_) => {}\n-            Err(prev) => {\n-                panic!(\"function {global_name} registered twice, previously with {prev}\");\n-            }\n-        }\n-        register_function(global_name, self);\n-    }\n }\n \n impl PartialEq for &'static NativeFunction {\n@@ -315,3 +302,7 @@ impl Ord for &'static NativeFunction {\n         )\n     }\n }\n+\n+pub struct CollectableFunction(pub &'static Lazy<NativeFunction>);\n+\n+inventory::collect! {CollectableFunction}"
        },
        {
            "sha": "f16b4d38a1a97251ffb53e2acbebc988d73e2cb8",
            "filename": "turbopack/crates/turbo-tasks/src/no_move_vec.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 198,
            "changes": 198,
            "blob_url": "https://github.com/vercel/next.js/blob/10e70b613b94e3251091caf700c0dc198fd0dc45/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fno_move_vec.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/10e70b613b94e3251091caf700c0dc198fd0dc45/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fno_move_vec.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fno_move_vec.rs?ref=10e70b613b94e3251091caf700c0dc198fd0dc45",
            "patch": "@@ -1,198 +0,0 @@\n-use std::{\n-    ptr::null_mut,\n-    slice::from_raw_parts_mut,\n-    sync::{\n-        Mutex,\n-        atomic::{AtomicPtr, Ordering},\n-    },\n-};\n-\n-const BUCKETS: usize = (usize::BITS + 1) as usize;\n-\n-/// An `Option`-like type that guarantees that a fully zeroed value is a valid\n-/// `None` variant.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-#[repr(u8)]\n-enum COption<T> {\n-    // TODO(alexkirsz) We need a way to guarantee that a fully zeroed value is a\n-    // valid `None` variant. This is theoretically possible when the wrapped\n-    // type has no valid value that can be represented by all zeros, but there\n-    // is no way to enforce this at the type level. For now, we just use a custom\n-    // option type with explicit discriminant for the `None` variant.\n-    // The issue with this implementation is that it disables niche optimization.\n-    None = 0,\n-    Some(T),\n-}\n-\n-impl<T> Default for COption<T> {\n-    fn default() -> Self {\n-        Self::None\n-    }\n-}\n-\n-impl<T> COption<T> {\n-    /// Returns a slice of the given size filled with the `None` variant.\n-    fn new_none_slice(size: usize) -> Box<[Self]> {\n-        let slice = Box::<[COption<T>]>::new_zeroed_slice(size);\n-        // Safety:\n-        // We know that a zeroed COption<T> is a valid COption::None value.\n-        unsafe { slice.assume_init() }\n-    }\n-\n-    /// Returns a reference to the contained value, or `None` if it is `None`.\n-    fn as_option_ref(&self) -> Option<&T> {\n-        match self {\n-            COption::None => None,\n-            COption::Some(t) => Some(t),\n-        }\n-    }\n-}\n-\n-pub struct NoMoveVec<T, const INITIAL_CAPACITY_BITS: u32 = 6> {\n-    buckets: [(AtomicPtr<COption<T>>, Mutex<()>); BUCKETS],\n-}\n-\n-fn get_bucket_index<const INITIAL_CAPACITY_BITS: u32>(idx: usize) -> u32 {\n-    (usize::BITS - idx.leading_zeros()).saturating_sub(INITIAL_CAPACITY_BITS)\n-}\n-\n-fn get_bucket_size<const INITIAL_CAPACITY_BITS: u32>(bucket_index: u32) -> usize {\n-    if bucket_index != 0 {\n-        1 << (bucket_index + INITIAL_CAPACITY_BITS - 1)\n-    } else {\n-        1 << INITIAL_CAPACITY_BITS\n-    }\n-}\n-\n-fn get_index_in_bucket<const INITIAL_CAPACITY_BITS: u32>(idx: usize, bucket_index: u32) -> usize {\n-    if bucket_index != 0 {\n-        idx ^ (1 << (bucket_index + INITIAL_CAPACITY_BITS - 1))\n-    } else {\n-        idx\n-    }\n-}\n-\n-/// Allocates a new bucket of `COption<T>`s, all initialized to `None`.\n-fn allocate_bucket<const INITIAL_CAPACITY_BITS: u32, T>(bucket_index: u32) -> *mut COption<T> {\n-    let size = get_bucket_size::<INITIAL_CAPACITY_BITS>(bucket_index);\n-    let slice = COption::<T>::new_none_slice(size);\n-    Box::into_raw(slice) as *mut COption<T>\n-}\n-\n-impl<T, const INITIAL_CAPACITY_BITS: u32> Default for NoMoveVec<T, INITIAL_CAPACITY_BITS> {\n-    fn default() -> Self {\n-        Self::new()\n-    }\n-}\n-\n-impl<T, const INITIAL_CAPACITY_BITS: u32> NoMoveVec<T, INITIAL_CAPACITY_BITS> {\n-    pub fn new() -> Self {\n-        let mut buckets = [null_mut(); BUCKETS];\n-        buckets[0] = allocate_bucket::<INITIAL_CAPACITY_BITS, T>(0);\n-        let buckets = buckets.map(|p| (AtomicPtr::new(p), Mutex::new(())));\n-        NoMoveVec { buckets }\n-    }\n-\n-    pub fn get(&self, idx: usize) -> Option<&T> {\n-        let bucket_idx = get_bucket_index::<INITIAL_CAPACITY_BITS>(idx);\n-        let bucket_ptr = unsafe { self.buckets.get_unchecked(bucket_idx as usize) }\n-            .0\n-            .load(Ordering::Acquire);\n-        if bucket_ptr.is_null() {\n-            return None;\n-        }\n-        let index = get_index_in_bucket::<INITIAL_CAPACITY_BITS>(idx, bucket_idx);\n-        unsafe { &*bucket_ptr.add(index) }.as_option_ref()\n-    }\n-\n-    /// # Safety\n-    /// There must not be a concurrent operation to this idx\n-    pub unsafe fn insert(&self, idx: usize, value: T) -> &T {\n-        let bucket_idx = get_bucket_index::<INITIAL_CAPACITY_BITS>(idx);\n-        let bucket = unsafe { self.buckets.get_unchecked(bucket_idx as usize) };\n-        // SAFETY: This is safe to be relaxed as the bucket will never become null\n-        // again. We perform a acquire load when it's null.\n-        let mut bucket_ptr = bucket.0.load(Ordering::Relaxed);\n-        if bucket_ptr.is_null() {\n-            bucket_ptr = bucket.0.load(Ordering::Acquire);\n-            if bucket_ptr.is_null() {\n-                let lock = bucket.1.lock();\n-                let guarded_bucket_ptr = bucket.0.load(Ordering::Acquire);\n-                if guarded_bucket_ptr.is_null() {\n-                    let new_bucket = allocate_bucket::<INITIAL_CAPACITY_BITS, T>(bucket_idx);\n-                    bucket_ptr = match bucket.0.compare_exchange(\n-                        null_mut(),\n-                        new_bucket,\n-                        Ordering::AcqRel,\n-                        Ordering::Relaxed,\n-                    ) {\n-                        Ok(_) => new_bucket,\n-                        Err(current_bucket) => {\n-                            drop(unsafe { Box::from_raw(new_bucket) });\n-                            current_bucket\n-                        }\n-                    };\n-                    drop(lock);\n-                } else {\n-                    bucket_ptr = guarded_bucket_ptr;\n-                }\n-            }\n-        }\n-        let index = get_index_in_bucket::<INITIAL_CAPACITY_BITS>(idx, bucket_idx);\n-        let item = unsafe { &mut *bucket_ptr.add(index) };\n-        *item = COption::Some(value);\n-        // To sync with any acquire load of the bucket ptr\n-        bucket.0.store(bucket_ptr, Ordering::Release);\n-        item.as_option_ref().unwrap()\n-    }\n-}\n-\n-impl<T, const INITIAL_CAPACITY_BITS: u32> Drop for NoMoveVec<T, INITIAL_CAPACITY_BITS> {\n-    fn drop(&mut self) {\n-        for (bucket_index, (bucket, _)) in self.buckets.iter_mut().enumerate() {\n-            if bucket_index < (usize::BITS + 1 - INITIAL_CAPACITY_BITS) as usize {\n-                let bucket_size = get_bucket_size::<INITIAL_CAPACITY_BITS>(bucket_index as u32);\n-                let bucket_ptr = *bucket.get_mut();\n-\n-                if !bucket_ptr.is_null() {\n-                    drop(unsafe { Box::from_raw(from_raw_parts_mut(bucket_ptr, bucket_size)) });\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::NoMoveVec;\n-\n-    #[test]\n-    fn basic_operations() {\n-        let v = NoMoveVec::<(usize, usize)>::new();\n-        assert_eq!(v.get(0), None);\n-        assert_eq!(v.get(1), None);\n-        assert_eq!(v.get(8), None);\n-        assert_eq!(v.get(9), None);\n-        assert_eq!(v.get(15), None);\n-        assert_eq!(v.get(16), None);\n-        assert_eq!(v.get(100), None);\n-        assert_eq!(v.get(1000), None);\n-\n-        for i in 0..1000 {\n-            unsafe {\n-                v.insert(i, (i, i));\n-            }\n-            assert_eq!(v.get(i), Some(&(i, i)));\n-        }\n-        for i in 0..1000 {\n-            assert_eq!(v.get(i), Some(&(i, i)));\n-        }\n-        assert_eq!(v.get(1001), None);\n-\n-        unsafe {\n-            v.insert(1000000, (0, 0));\n-        }\n-        assert_eq!(v.get(1000000), Some(&(0, 0)));\n-        assert_eq!(v.get(10000), None);\n-    }\n-}"
        },
        {
            "sha": "49de4eaeaa7ef44b1a156f302dd5a538bd97968b",
            "filename": "turbopack/crates/turbo-tasks/src/registry.rs",
            "status": "modified",
            "additions": 122,
            "deletions": 106,
            "changes": 228,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fregistry.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fregistry.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fregistry.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -1,145 +1,161 @@\n-use std::{fmt::Debug, hash::Hash, num::NonZeroU64, ops::Deref, sync::RwLock};\n+use std::num::NonZeroU32;\n \n-use dashmap::mapref::entry::Entry;\n use once_cell::sync::Lazy;\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    FxDashMap, TraitType, ValueType,\n+    TraitType, ValueType,\n     id::{TraitTypeId, ValueTypeId},\n-    id_factory::IdFactory,\n+    macro_helpers::CollectableFunction,\n     native_function::NativeFunction,\n-    no_move_vec::NoMoveVec,\n+    value_type::{CollectableTrait, CollectableValueType},\n };\n \n-static NAME_TO_FUNCTION: Lazy<RwLock<FxHashMap<&'static str, &'static NativeFunction>>> =\n-    Lazy::new(RwLock::default);\n-\n-static VALUE_TYPE_ID_FACTORY: IdFactory<ValueTypeId> = IdFactory::new_const(\n-    ValueTypeId::MIN.to_non_zero_u64(),\n-    ValueTypeId::MAX.to_non_zero_u64(),\n-);\n-static VALUE_TYPES_BY_NAME: Lazy<FxDashMap<&'static str, ValueTypeId>> =\n-    Lazy::new(FxDashMap::default);\n-static VALUE_TYPES_BY_VALUE: Lazy<FxDashMap<&'static ValueType, ValueTypeId>> =\n-    Lazy::new(FxDashMap::default);\n-static VALUE_TYPES: Lazy<NoMoveVec<(&'static ValueType, &'static str)>> = Lazy::new(NoMoveVec::new);\n-\n-static TRAIT_TYPE_ID_FACTORY: IdFactory<TraitTypeId> = IdFactory::new_const(\n-    TraitTypeId::MIN.to_non_zero_u64(),\n-    TraitTypeId::MAX.to_non_zero_u64(),\n-);\n-static TRAIT_TYPES_BY_NAME: Lazy<FxDashMap<&'static str, TraitTypeId>> =\n-    Lazy::new(FxDashMap::default);\n-static TRAIT_TYPES_BY_VALUE: Lazy<FxDashMap<&'static TraitType, TraitTypeId>> =\n-    Lazy::new(FxDashMap::default);\n-static TRAIT_TYPES: Lazy<NoMoveVec<(&'static TraitType, &'static str)>> = Lazy::new(NoMoveVec::new);\n-\n-/// Registers the value and returns its id if this is the initial\n-fn register_thing<\n-    K: Copy + Deref<Target = u32> + TryFrom<NonZeroU64>,\n-    V: Copy + Hash + Eq,\n-    const INITIAL_CAPACITY_BITS: u32,\n->(\n-    global_name: &'static str,\n-    value: V,\n-    id_factory: &IdFactory<K>,\n-    store: &NoMoveVec<(V, &'static str), INITIAL_CAPACITY_BITS>,\n-    map_by_name: &FxDashMap<&'static str, K>,\n-    map_by_value: &FxDashMap<V, K>,\n-) -> Option<K> {\n-    if let Entry::Vacant(e) = map_by_value.entry(value) {\n-        let new_id = id_factory.get();\n-        // SAFETY: this is a fresh id\n-        unsafe {\n-            store.insert(*new_id as usize, (value, global_name));\n-        }\n-        map_by_name.insert(global_name, new_id);\n-        e.insert(new_id);\n-        Some(new_id)\n-    } else {\n-        None\n-    }\n-}\n-\n-fn get_thing_id<K, V>(value: V, map_by_value: &FxDashMap<V, K>) -> K\n-where\n-    V: Hash + Eq + Debug,\n-    K: Clone,\n-{\n-    if let Some(id) = map_by_value.get(&value) {\n-        id.clone()\n-    } else {\n-        panic!(\"Use of unregistered {value:?}\");\n+pub fn get_function_by_global_name(global_name: &str) -> &'static NativeFunction {\n+    static NAME_TO_FUNCTION: Lazy<FxHashMap<&'static str, &'static NativeFunction>> =\n+        Lazy::new(|| {\n+            let mut map = FxHashMap::default();\n+            for collected in inventory::iter::<CollectableFunction> {\n+                let native_function = &**collected.0;\n+                let global_name = native_function.global_name;\n+                let prev = map.insert(global_name, native_function);\n+                assert!(\n+                    prev.is_none(),\n+                    \"multiple functions registered with the name {global_name}!\"\n+                );\n+            }\n+            map.shrink_to_fit();\n+            map\n+        });\n+\n+    match NAME_TO_FUNCTION.get(global_name) {\n+        Some(f) => f,\n+        None => panic!(\"unable to find function: {global_name}\"),\n     }\n }\n \n-/// Registers a function so it is available for persistence\n-pub fn register_function(global_name: &'static str, func: &'static NativeFunction) {\n-    let prev = NAME_TO_FUNCTION.write().unwrap().insert(global_name, func);\n-    debug_assert!(\n-        prev.is_none(),\n-        \"registration mappings for {global_name} are inconsistent!\"\n-    );\n+struct Values {\n+    id_to_value: Box<[&'static ValueType]>,\n+    value_to_id: FxHashMap<&'static ValueType, ValueTypeId>,\n+    global_name_to_value: FxHashMap<&'static str, (ValueTypeId, &'static ValueType)>,\n }\n \n-pub fn get_function_by_global_name(global_name: &str) -> &'static NativeFunction {\n-    NAME_TO_FUNCTION.read().unwrap().get(global_name).unwrap()\n-}\n+static VALUES: Lazy<Values> = Lazy::new(|| {\n+    // Inventory does not guarantee an order. So we sort by the global name to get a stable order\n+    // This ensures that assigned ids are also stable.\n+    // We don't currently take advantage of this but we could in the future.  The remaining issue is\n+    // ensuring the set of values is the same across runs.\n+    let mut all_values = inventory::iter::<CollectableValueType>\n+        .into_iter()\n+        .map(|t| &**t.0)\n+        .collect::<Vec<_>>();\n+    all_values.sort_unstable_by_key(|t| t.global_name);\n+\n+    let mut value_to_id = FxHashMap::with_capacity_and_hasher(all_values.len(), Default::default());\n+    let mut global_name_to_value =\n+        FxHashMap::with_capacity_and_hasher(all_values.len(), Default::default());\n+\n+    let mut id = NonZeroU32::MIN;\n+    for &value_type in all_values.iter() {\n+        value_to_id.insert(value_type, id.into());\n+        let prev = global_name_to_value.insert(value_type.global_name, (id.into(), value_type));\n+        assert!(\n+            prev.is_none(),\n+            \"two value types registered with the same name: {}\",\n+            value_type.global_name\n+        );\n+        id = id.checked_add(1).expect(\"overflowing value type ids\");\n+    }\n \n-pub fn register_value_type(\n-    global_name: &'static str,\n-    ty: &'static ValueType,\n-) -> Option<ValueTypeId> {\n-    register_thing(\n-        global_name,\n-        ty,\n-        &VALUE_TYPE_ID_FACTORY,\n-        &VALUE_TYPES,\n-        &VALUE_TYPES_BY_NAME,\n-        &VALUE_TYPES_BY_VALUE,\n-    )\n-}\n+    value_to_id.shrink_to_fit();\n+    global_name_to_value.shrink_to_fit();\n+    Values {\n+        value_to_id,\n+        id_to_value: all_values.into_boxed_slice(),\n+        global_name_to_value,\n+    }\n+});\n \n-pub fn get_value_type_id(func: &'static ValueType) -> ValueTypeId {\n-    get_thing_id(func, &VALUE_TYPES_BY_VALUE)\n+pub fn get_value_type_id(value: &'static ValueType) -> ValueTypeId {\n+    match VALUES.value_to_id.get(value) {\n+        Some(id) => *id,\n+        None => panic!(\"Use of unregistered trait {value:?}\"),\n+    }\n }\n \n pub fn get_value_type_id_by_global_name(global_name: &str) -> Option<ValueTypeId> {\n-    VALUE_TYPES_BY_NAME.get(global_name).map(|x| *x)\n+    VALUES\n+        .global_name_to_value\n+        .get(global_name)\n+        .map(|(id, _)| *id)\n }\n \n pub fn get_value_type(id: ValueTypeId) -> &'static ValueType {\n-    VALUE_TYPES.get(*id as usize).unwrap().0\n+    VALUES.id_to_value[*id as usize - 1]\n }\n \n pub fn get_value_type_global_name(id: ValueTypeId) -> &'static str {\n-    VALUE_TYPES.get(*id as usize).unwrap().1\n+    get_value_type(id).global_name\n }\n \n-pub fn register_trait_type(global_name: &'static str, ty: &'static TraitType) {\n-    register_thing(\n-        global_name,\n-        ty,\n-        &TRAIT_TYPE_ID_FACTORY,\n-        &TRAIT_TYPES,\n-        &TRAIT_TYPES_BY_NAME,\n-        &TRAIT_TYPES_BY_VALUE,\n-    );\n+struct Traits {\n+    id_to_trait: Box<[&'static TraitType]>,\n+    trait_to_id: FxHashMap<&'static TraitType, TraitTypeId>,\n+    global_name_to_trait: FxHashMap<&'static str, (TraitTypeId, &'static TraitType)>,\n }\n \n-pub fn get_trait_type_id(func: &'static TraitType) -> TraitTypeId {\n-    get_thing_id(func, &TRAIT_TYPES_BY_VALUE)\n+static TRAITS: Lazy<Traits> = Lazy::new(|| {\n+    // Inventory does not guarantee an order. So we sort by the global name to get a stable order\n+    // This ensures that assigned ids are also stable.\n+    let mut all_traits = inventory::iter::<CollectableTrait>\n+        .into_iter()\n+        .map(|t| &**t.0)\n+        .collect::<Vec<_>>();\n+    all_traits.sort_unstable_by_key(|t| t.global_name);\n+\n+    let mut trait_to_id = FxHashMap::with_capacity_and_hasher(all_traits.len(), Default::default());\n+    let mut global_name_to_trait =\n+        FxHashMap::with_capacity_and_hasher(all_traits.len(), Default::default());\n+\n+    let mut id = NonZeroU32::MIN;\n+    for &trait_type in all_traits.iter() {\n+        trait_to_id.insert(trait_type, id.into());\n+\n+        let prev = global_name_to_trait.insert(trait_type.global_name, (id.into(), trait_type));\n+        assert!(\n+            prev.is_none(),\n+            \"two traits registered with the same name: {}\",\n+            trait_type.global_name\n+        );\n+        id = id.checked_add(1).expect(\"overflowing trait type ids\");\n+    }\n+    trait_to_id.shrink_to_fit();\n+    global_name_to_trait.shrink_to_fit();\n+    Traits {\n+        trait_to_id,\n+        id_to_trait: all_traits.into_boxed_slice(),\n+        global_name_to_trait,\n+    }\n+});\n+\n+pub fn get_trait_type_id(trait_type: &'static TraitType) -> TraitTypeId {\n+    match TRAITS.trait_to_id.get(trait_type) {\n+        Some(id) => *id,\n+        None => panic!(\"Use of unregistered trait {trait_type:?}\"),\n+    }\n }\n \n pub fn get_trait_type_id_by_global_name(global_name: &str) -> Option<TraitTypeId> {\n-    TRAIT_TYPES_BY_NAME.get(global_name).map(|x| *x)\n+    TRAITS\n+        .global_name_to_trait\n+        .get(global_name)\n+        .map(|(id, _)| *id)\n }\n \n pub fn get_trait(id: TraitTypeId) -> &'static TraitType {\n-    TRAIT_TYPES.get(*id as usize).unwrap().0\n+    TRAITS.id_to_trait[*id as usize - 1]\n }\n \n pub fn get_trait_type_global_name(id: TraitTypeId) -> &'static str {\n-    TRAIT_TYPES.get(*id as usize).unwrap().1\n+    get_trait(id).global_name\n }"
        },
        {
            "sha": "9deccbfc524ea9e919817fc0c1a327e756f0d869",
            "filename": "turbopack/crates/turbo-tasks/src/task_statistics.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask_statistics.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask_statistics.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftask_statistics.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -73,7 +73,7 @@ impl Serialize for TaskStatistics {\n     {\n         let mut map = serializer.serialize_map(Some(self.inner.len()))?;\n         for entry in &self.inner {\n-            map.serialize_entry(entry.key().global_name(), entry.value())?;\n+            map.serialize_entry(entry.key().global_name, entry.value())?;\n         }\n         map.end()\n     }"
        },
        {
            "sha": "6ad8a49a142eb81f58e8e54e8a547ebc8c56e0c6",
            "filename": "turbopack/crates/turbo-tasks/src/trait_ref.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 21,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrait_ref.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrait_ref.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Ftrait_ref.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -72,23 +72,6 @@ impl<'de, T> Deserialize<'de> for TraitRef<T> {\n     }\n }\n \n-// This is a workaround for https://github.com/rust-lang/rust-analyzer/issues/19971\n-// that ensures type inference keeps working with ptr_metadata.\n-\n-#[cfg(rust_analyzer)]\n-impl<U> std::ops::Deref for TraitRef<Box<U>>\n-where\n-    U: ?Sized,\n-    Box<U>: VcValueTrait,\n-{\n-    type Target = U;\n-\n-    fn deref(&self) -> &Self::Target {\n-        unimplemented!(\"only exists for rust-analyzer type inference\")\n-    }\n-}\n-\n-#[cfg(not(rust_analyzer))]\n impl<U> std::ops::Deref for TraitRef<Box<U>>\n where\n     Box<U>: VcValueTrait<ValueTrait = U>,\n@@ -99,12 +82,11 @@ where\n     fn deref(&self) -> &Self::Target {\n         // This lookup will fail if the value type stored does not actually implement the trait,\n         // which implies a bug in either the registry code or the macro code.\n-        let metadata =\n-            <Box<U> as VcValueTrait>::get_impl_vtables().get(self.shared_reference.type_id);\n-        let downcast_ptr = std::ptr::from_raw_parts(\n+        let downcast_ptr = <Box<U> as VcValueTrait>::get_impl_vtables().cast(\n+            self.shared_reference.type_id,\n             self.shared_reference.reference.0.as_ptr() as *const (),\n-            metadata,\n         );\n+        // SAFETY: the pointer is derived from an Arc\n         unsafe { &*downcast_ptr }\n     }\n }"
        },
        {
            "sha": "5546d03438c66f64f121288a84e23b527d035e77",
            "filename": "turbopack/crates/turbo-tasks/src/value_type.rs",
            "status": "modified",
            "additions": 50,
            "deletions": 58,
            "changes": 108,
            "blob_url": "https://github.com/vercel/next.js/blob/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvalue_type.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/099b1e35a0a71612983a4dab64fcd154dd615a29/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvalue_type.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fvalue_type.rs?ref=099b1e35a0a71612983a4dab64fcd154dd615a29",
            "patch": "@@ -14,7 +14,7 @@ use crate::{\n     id::TraitTypeId,\n     macro_helpers::NativeFunction,\n     magic_any::{AnyDeserializeSeed, MagicAny, MagicAnyDeserializeSeed},\n-    registry::{self, register_trait_type, register_value_type},\n+    registry,\n     task::shared_reference::TypedSharedReference,\n     vc::VcCellMode,\n };\n@@ -34,7 +34,9 @@ type RawCellFactoryFn = fn(TypedSharedReference) -> RawVc;\n /// Contains a list of traits and trait methods that are available on that type.\n pub struct ValueType {\n     /// A readable name of the type\n-    pub name: String,\n+    pub name: &'static str,\n+    /// The fully qualitifed global name of the type.\n+    pub global_name: &'static str,\n     /// Set of traits available\n     traits: AutoSet<TraitTypeId>,\n     /// List of trait methods available\n@@ -87,7 +89,7 @@ impl Debug for ValueType {\n \n impl Display for ValueType {\n     fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n-        f.write_str(&self.name)\n+        f.write_str(self.name)\n     }\n }\n \n@@ -105,9 +107,10 @@ pub fn any_as_serialize<T: Any + Serialize + Send + Sync + 'static>(\n \n impl ValueType {\n     /// This is internally used by `#[turbo_tasks::value]`\n-    pub fn new<T: VcValueType>() -> Self {\n+    pub fn new<T: VcValueType>(global_name: &'static str) -> Self {\n         Self {\n-            name: std::any::type_name::<T>().to_string(),\n+            name: std::any::type_name::<T>(),\n+            global_name,\n             traits: AutoSet::new(),\n             trait_methods: AutoMap::new(),\n             magic_serialization: None,\n@@ -119,9 +122,12 @@ impl ValueType {\n     /// This is internally used by `#[turbo_tasks::value]`\n     pub fn new_with_any_serialization<\n         T: VcValueType + Any + Serialize + for<'de> Deserialize<'de>,\n-    >() -> Self {\n+    >(\n+        global_name: &'static str,\n+    ) -> Self {\n         Self {\n-            name: std::any::type_name::<T>().to_string(),\n+            name: std::any::type_name::<T>(),\n+            global_name,\n             traits: AutoSet::new(),\n             trait_methods: AutoMap::new(),\n             magic_serialization: None,\n@@ -165,15 +171,12 @@ impl ValueType {\n         self.any_serialization.map(|s| s.1)\n     }\n \n-    /// This is internally used by `#[turbo_tasks::value_impl]`\n-    pub fn register_trait_method(\n+    pub(crate) fn register_trait_method(\n         &mut self,\n-        trait_type: TraitTypeId,\n-        name: &str,\n+        trait_method: &'static TraitMethod,\n         native_fn: &'static NativeFunction,\n     ) {\n-        self.trait_methods\n-            .insert(registry::get_trait(trait_type).get(name), native_fn);\n+        self.trait_methods.insert(trait_method, native_fn);\n     }\n \n     pub fn get_trait_method(\n@@ -186,8 +189,7 @@ impl ValueType {\n         }\n     }\n \n-    /// This is internally used by `#[turbo_tasks::value_impl]`\n-    pub fn register_trait(&mut self, trait_type: TraitTypeId) {\n+    pub(crate) fn register_trait(&mut self, trait_type: TraitTypeId) {\n         self.traits.insert(trait_type);\n     }\n \n@@ -198,19 +200,13 @@ impl ValueType {\n     pub fn traits_iter(&self) -> impl Iterator<Item = TraitTypeId> + '_ {\n         self.traits.iter().cloned()\n     }\n-\n-    pub fn register(\n-        &'static self,\n-        global_name: &'static str,\n-        register_traits: impl FnOnce(crate::ValueTypeId),\n-    ) {\n-        let id = register_value_type(global_name, self);\n-        if let Some(id) = id {\n-            register_traits(id);\n-        }\n-    }\n }\n \n+// A collectable struct for value types\n+pub struct CollectableValueType(pub &'static once_cell::sync::Lazy<ValueType>);\n+\n+inventory::collect! {CollectableValueType}\n+\n pub struct TraitMethod {\n     pub(crate) trait_name: &'static str,\n     pub(crate) method_name: &'static str,\n@@ -246,9 +242,11 @@ impl TraitMethod {\n         )\n     }\n }\n+\n #[derive(Debug)]\n pub struct TraitType {\n     pub name: &'static str,\n+    pub global_name: &'static str,\n     pub(crate) methods: AutoMap<&'static str, TraitMethod>,\n }\n \n@@ -273,44 +271,38 @@ impl PartialEq for TraitType {\n }\n \n impl TraitType {\n-    pub fn new(name: &'static str) -> Self {\n+    pub fn new(\n+        name: &'static str,\n+        global_name: &'static str,\n+        trait_methods: Vec<(&'static str, Option<&'static NativeFunction>)>,\n+    ) -> Self {\n+        let mut methods = AutoMap::new();\n+        for (method_name, default_method) in trait_methods {\n+            let prev = methods.insert(\n+                method_name,\n+                TraitMethod {\n+                    trait_name: name,\n+                    method_name,\n+                    default_method,\n+                },\n+            );\n+            debug_assert!(\n+                prev.is_none(),\n+                \"duplicate methods {method_name} registered on {global_name}\"\n+            );\n+        }\n         Self {\n             name,\n-            methods: AutoMap::new(),\n+            global_name,\n+            methods,\n         }\n     }\n \n-    pub fn register_trait_method(&mut self, name: &'static str) {\n-        self.methods.insert(\n-            name,\n-            TraitMethod {\n-                trait_name: self.name,\n-                method_name: name,\n-                default_method: None,\n-            },\n-        );\n-    }\n-\n-    pub fn register_default_trait_method(\n-        &mut self,\n-        name: &'static str,\n-        native_fn: &'static NativeFunction,\n-    ) {\n-        self.methods.insert(\n-            name,\n-            TraitMethod {\n-                trait_name: self.name,\n-                method_name: name,\n-                default_method: Some(native_fn),\n-            },\n-        );\n-    }\n-\n     pub fn get(&self, name: &str) -> &TraitMethod {\n         self.methods.get(name).unwrap()\n     }\n-\n-    pub fn register(&'static self, global_name: &'static str) {\n-        register_trait_type(global_name, self);\n-    }\n }\n+\n+pub struct CollectableTrait(pub &'static once_cell::sync::Lazy<TraitType>);\n+\n+inventory::collect! {CollectableTrait}"
        }
    ],
    "stats": {
        "total": 1267,
        "additions": 470,
        "deletions": 797
    }
}