{
    "author": "sokra",
    "message": "[Turbopack] add concept of ChunkGroups (#76218)\n\n### What?\n\n* move TraceDiGraph into separate file\n* expose chunk groups from chunk_group_info\n* include entries for IsolatedMerged\n* add GraphTraversalAction::Exclude to skip postorder visit too",
    "sha": "78b74228eb87ee4075e1e02c75026847ed422aab",
    "files": [
        {
            "sha": "f600ebe479d5ebdb4d630826b4b84a1540f773cd",
            "filename": "turbopack/crates/turbopack-core/src/chunk/chunking/production.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/78b74228eb87ee4075e1e02c75026847ed422aab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking%2Fproduction.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/78b74228eb87ee4075e1e02c75026847ed422aab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking%2Fproduction.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fchunking%2Fproduction.rs?ref=78b74228eb87ee4075e1e02c75026847ed422aab",
            "patch": "@@ -37,7 +37,10 @@ pub async fn make_production_chunks(\n         for chunk_item in chunk_items {\n             let ChunkItemWithInfo { module, .. } = chunk_item;\n             let chunk_groups = if let Some(module) = module {\n-                match chunk_group_info.get(&ResolvedVc::upcast(module)) {\n+                match chunk_group_info\n+                    .module_chunk_groups\n+                    .get(&ResolvedVc::upcast(module))\n+                {\n                     Some(chunk_group) => Some(chunk_group),\n                     None => {\n                         bail!("
        },
        {
            "sha": "9af9306250e5a1d7c93cb8f590aa1a8a8c6d0544",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/async_module_info.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/78b74228eb87ee4075e1e02c75026847ed422aab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/78b74228eb87ee4075e1e02c75026847ed422aab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs?ref=78b74228eb87ee4075e1e02c75026847ed422aab",
            "patch": "@@ -103,7 +103,7 @@ async fn compute_async_module_info_single(\n         },\n     )?;\n \n-    petgraph::algo::TarjanScc::new().run(&graph.graph.0, |scc| {\n+    petgraph::algo::TarjanScc::new().run(&*graph.graph, |scc| {\n         // Only SCCs with more than one node are cycles\n         if scc.len() > 1\n             && scc"
        },
        {
            "sha": "be19104d0549bd42809337c838f13084aee157b0",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 133,
            "deletions": 55,
            "changes": 188,
            "blob_url": "https://github.com/vercel/next.js/blob/78b74228eb87ee4075e1e02c75026847ed422aab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/78b74228eb87ee4075e1e02c75026847ed422aab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=78b74228eb87ee4075e1e02c75026847ed422aab",
            "patch": "@@ -1,19 +1,21 @@\n use std::{\n-    collections::{hash_map::Entry, BinaryHeap},\n+    collections::BinaryHeap,\n     hash::Hash,\n     ops::{Deref, DerefMut},\n };\n \n use anyhow::Result;\n use either::Either;\n+use indexmap::map::Entry;\n use petgraph::graph::{DiGraph, EdgeIndex, NodeIndex};\n use roaring::RoaringBitmap;\n use rustc_hash::{FxHashMap, FxHashSet};\n use serde::{Deserialize, Serialize};\n use tracing::Instrument;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    debug::ValueDebugFormat, trace::TraceRawVcs, NonLocalValue, ResolvedVc, TryJoinIterExt, Vc,\n+    debug::ValueDebugFormat, trace::TraceRawVcs, FxIndexMap, FxIndexSet, NonLocalValue, ResolvedVc,\n+    TaskInput, TryJoinIterExt, Vc,\n };\n \n use crate::{\n@@ -30,6 +32,12 @@ use crate::{\n )]\n pub struct RoaringBitmapWrapper(#[turbo_tasks(trace_ignore)] RoaringBitmap);\n \n+impl TaskInput for RoaringBitmapWrapper {\n+    fn is_transient(&self) -> bool {\n+        false\n+    }\n+}\n+\n impl RoaringBitmapWrapper {\n     /// Whether `self` contains bits that are not in `other`\n     ///\n@@ -76,11 +84,44 @@ impl Hash for RoaringBitmapWrapper {\n     }\n }\n \n-#[turbo_tasks::value(transparent)]\n-pub struct ChunkGroupInfo(FxHashMap<ResolvedVc<Box<dyn Module>>, RoaringBitmapWrapper>);\n+#[turbo_tasks::value]\n+pub struct ChunkGroupInfo {\n+    pub module_chunk_groups: FxHashMap<ResolvedVc<Box<dyn Module>>, RoaringBitmapWrapper>,\n+    #[turbo_tasks(trace_ignore)]\n+    pub chunk_groups: Vec<ChunkGroup>,\n+}\n+\n+#[derive(\n+    Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize, ValueDebugFormat, NonLocalValue,\n+)]\n+pub enum ChunkGroup {\n+    /// e.g. a page\n+    Entry(ResolvedVc<Box<dyn Module>>),\n+    /// a module with an incoming async edge\n+    Async(ResolvedVc<Box<dyn Module>>),\n+    /// a module with an incoming non-merged isolated edge\n+    Isolated(ResolvedVc<Box<dyn Module>>),\n+    /// a module with an incoming merging isolated edge\n+    IsolatedMerged {\n+        parent: usize,\n+        merge_tag: RcStr,\n+        entries: Vec<ResolvedVc<Box<dyn Module>>>,\n+    },\n+}\n+\n+impl ChunkGroup {\n+    pub fn entries(&self) -> impl Iterator<Item = ResolvedVc<Box<dyn Module>>> + '_ {\n+        match self {\n+            ChunkGroup::Entry(e) | ChunkGroup::Async(e) | ChunkGroup::Isolated(e) => {\n+                Either::Left(std::iter::once(*e))\n+            }\n+            ChunkGroup::IsolatedMerged { entries, .. } => Either::Right(entries.iter().copied()),\n+        }\n+    }\n+}\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-enum ChunkGroup {\n+enum ChunkGroupKey {\n     /// e.g. a page\n     Entry(ResolvedVc<Box<dyn Module>>),\n     /// a module with an incoming async edge\n@@ -94,8 +135,15 @@ enum ChunkGroup {\n     },\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-struct ChunkGroupId(u32);\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\n+pub struct ChunkGroupId(u32);\n+\n+impl Deref for ChunkGroupId {\n+    type Target = u32;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n \n fn iter_neighbors<N, E>(\n     graph: &DiGraph<N, E>,\n@@ -142,9 +190,11 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n \n     let span = span_outer.clone();\n     async move {\n-        let mut next_chunk_group_id = 0u32;\n-        let mut chunk_groups_to_id: FxHashMap<ChunkGroup, ChunkGroupId> = FxHashMap::default();\n-        let mut chunk_groups_from_id: FxHashMap<ChunkGroupId, ChunkGroup> = FxHashMap::default();\n+        #[allow(clippy::type_complexity)]\n+        let mut chunk_groups_map: FxIndexMap<\n+            ChunkGroupKey,\n+            (ChunkGroupId, FxIndexSet<ResolvedVc<Box<dyn Module>>>),\n+        > = FxIndexMap::default();\n \n         let mut module_chunk_groups: FxHashMap<ResolvedVc<Box<dyn Module>>, RoaringBitmapWrapper> =\n             FxHashMap::default();\n@@ -186,58 +236,68 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                 RoaringBitmapWrapper,\n             >|\n              -> GraphTraversalAction {\n-                enum ChunkGroupInheritance<It: Iterator<Item = ChunkGroup>> {\n+                enum ChunkGroupInheritance<It: Iterator<Item = ChunkGroupKey>> {\n                     Inherit(ResolvedVc<Box<dyn Module>>),\n                     ChunkGroup(It),\n                 }\n-                let chunk_groups =\n-                    if let Some((parent, chunking_type)) = parent_info {\n-                        match chunking_type {\n-                            ChunkingType::Parallel | ChunkingType::ParallelInheritAsync => {\n-                                ChunkGroupInheritance::Inherit(parent.module)\n-                            }\n-                            ChunkingType::Async => ChunkGroupInheritance::ChunkGroup(Either::Left(\n-                                std::iter::once(ChunkGroup::Async(node.module)),\n-                            )),\n-                            ChunkingType::Isolated {\n-                                merge_tag: None, ..\n-                            } => ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n-                                ChunkGroup::Isolated(node.module),\n-                            ))),\n-                            ChunkingType::Isolated {\n-                                merge_tag: Some(merge_tag),\n-                                ..\n-                            } => ChunkGroupInheritance::ChunkGroup(Either::Right(\n-                                module_chunk_groups.get(&parent.module).unwrap().iter().map(\n-                                    |parent| ChunkGroup::IsolatedMerged {\n-                                        parent: ChunkGroupId(parent),\n-                                        merge_tag: merge_tag.clone(),\n-                                    },\n-                                ),\n-                            )),\n-                            ChunkingType::Traced => {\n-                                // Traced modules are not placed in chunk groups\n-                                return GraphTraversalAction::Skip;\n-                            }\n+                let chunk_groups = if let Some((parent, chunking_type)) = parent_info {\n+                    match chunking_type {\n+                        ChunkingType::Parallel | ChunkingType::ParallelInheritAsync => {\n+                            ChunkGroupInheritance::Inherit(parent.module)\n                         }\n-                    } else {\n-                        ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n-                            ChunkGroup::Entry(node.module),\n-                        )))\n-                    };\n+                        ChunkingType::Async => ChunkGroupInheritance::ChunkGroup(Either::Left(\n+                            std::iter::once(ChunkGroupKey::Async(node.module)),\n+                        )),\n+                        ChunkingType::Isolated {\n+                            merge_tag: None, ..\n+                        } => ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n+                            ChunkGroupKey::Isolated(node.module),\n+                        ))),\n+                        ChunkingType::Isolated {\n+                            merge_tag: Some(merge_tag),\n+                            ..\n+                        } => {\n+                            let parents = module_chunk_groups.get(&parent.module).unwrap();\n+                            let chunk_groups =\n+                                parents.iter().map(|parent| ChunkGroupKey::IsolatedMerged {\n+                                    parent: ChunkGroupId(parent),\n+                                    merge_tag: merge_tag.clone(),\n+                                });\n+                            ChunkGroupInheritance::ChunkGroup(Either::Right(chunk_groups))\n+                        }\n+                        ChunkingType::Traced => {\n+                            // Traced modules are not placed in chunk groups\n+                            return GraphTraversalAction::Skip;\n+                        }\n+                    }\n+                } else {\n+                    ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n+                        ChunkGroupKey::Entry(node.module),\n+                    )))\n+                };\n \n                 match chunk_groups {\n                     ChunkGroupInheritance::ChunkGroup(chunk_groups) => {\n                         // Start of a new chunk group, don't inherit anything from parent\n                         let chunk_group_ids = chunk_groups.map(|chunk_group| {\n-                            match chunk_groups_to_id.entry(chunk_group) {\n-                                Entry::Occupied(e) => e.get().0,\n+                            let len = chunk_groups_map.len();\n+                            let is_isolated_merged =\n+                                matches!(chunk_group, ChunkGroupKey::IsolatedMerged { .. });\n+                            match chunk_groups_map.entry(chunk_group) {\n+                                Entry::Occupied(mut e) => {\n+                                    let (id, isolated_merged_entries) = e.get_mut();\n+                                    if is_isolated_merged {\n+                                        isolated_merged_entries.insert(node.module);\n+                                    }\n+                                    **id\n+                                }\n                                 Entry::Vacant(e) => {\n-                                    let chunk_group_id = next_chunk_group_id;\n-                                    next_chunk_group_id += 1;\n-                                    chunk_groups_from_id\n-                                        .insert(ChunkGroupId(chunk_group_id), e.key().clone());\n-                                    e.insert(ChunkGroupId(chunk_group_id));\n+                                    let chunk_group_id = len as u32;\n+                                    let mut set = FxIndexSet::default();\n+                                    if is_isolated_merged {\n+                                        set.insert(node.module);\n+                                    }\n+                                    e.insert((ChunkGroupId(chunk_group_id), set));\n                                     chunk_group_id\n                                 }\n                             }\n@@ -345,9 +405,27 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n         }\n \n         span.record(\"visit_count\", visit_count);\n-        span.record(\"chunk_group_count\", next_chunk_group_id);\n-\n-        Ok(Vc::cell(module_chunk_groups))\n+        span.record(\"chunk_group_count\", chunk_groups_map.len());\n+\n+        Ok(ChunkGroupInfo {\n+            module_chunk_groups,\n+            chunk_groups: chunk_groups_map\n+                .into_iter()\n+                .map(|(k, (_, isolated_merged_entries))| match k {\n+                    ChunkGroupKey::Entry(module) => ChunkGroup::Entry(module),\n+                    ChunkGroupKey::Async(module) => ChunkGroup::Async(module),\n+                    ChunkGroupKey::Isolated(module) => ChunkGroup::Isolated(module),\n+                    ChunkGroupKey::IsolatedMerged { parent, merge_tag } => {\n+                        ChunkGroup::IsolatedMerged {\n+                            parent: parent.0 as usize,\n+                            merge_tag,\n+                            entries: isolated_merged_entries.into_iter().collect(),\n+                        }\n+                    }\n+                })\n+                .collect(),\n+        }\n+        .cell())\n     }\n     .instrument(span_outer)\n     .await"
        },
        {
            "sha": "f87326e5a92cc39988a163721c7836306e77b2a0",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 50,
            "changes": 69,
            "blob_url": "https://github.com/vercel/next.js/blob/78b74228eb87ee4075e1e02c75026847ed422aab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/78b74228eb87ee4075e1e02c75026847ed422aab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=78b74228eb87ee4075e1e02c75026847ed422aab",
            "patch": "@@ -1,7 +1,6 @@\n use std::{\n     collections::{HashSet, VecDeque},\n     future::Future,\n-    ops::Deref,\n };\n \n use anyhow::{bail, Context, Result};\n@@ -14,9 +13,8 @@ use serde::{Deserialize, Serialize};\n use tracing::{Instrument, Span};\n use turbo_rcstr::RcStr;\n use turbo_tasks::{\n-    debug::ValueDebugFormat,\n     graph::{AdjacencyMap, GraphTraversal, Visit, VisitControlFlow},\n-    trace::{TraceRawVcs, TraceRawVcsContext},\n+    trace::TraceRawVcs,\n     CollectiblesSource, FxIndexMap, NonLocalValue, ReadRef, ResolvedVc, TryJoinIterExt,\n     ValueToString, Vc,\n };\n@@ -28,12 +26,14 @@ use crate::{\n     module_graph::{\n         async_module_info::{compute_async_module_info, AsyncModulesInfo},\n         chunk_group_info::{compute_chunk_group_info, ChunkGroupInfo},\n+        traced_di_graph::TracedDiGraph,\n     },\n     reference::primary_chunkable_referenced_modules,\n };\n \n pub mod async_module_info;\n pub mod chunk_group_info;\n+mod traced_di_graph;\n \n #[derive(\n     Debug, Copy, Clone, Eq, PartialOrd, Ord, Hash, PartialEq, Serialize, Deserialize, TraceRawVcs,\n@@ -305,7 +305,7 @@ impl SingleModuleGraph {\n         graph.shrink_to_fit();\n \n         Ok(SingleModuleGraph {\n-            graph: TracedDiGraph(graph),\n+            graph: TracedDiGraph::new(graph),\n             number_of_modules,\n             modules,\n             entries: entries.clone(),\n@@ -542,9 +542,12 @@ impl SingleModuleGraph {\n                 ReverseTopologicalPass::ExpandAndVisit => {\n                     match graph.node_weight(current).unwrap() {\n                         current_node @ SingleModuleGraphNode::Module(_) => {\n-                            let action = visit_preorder(parent_arg, current_node, state);\n+                            let action = visit_preorder(parent_arg, current_node, state)?;\n+                            if action == GraphTraversalAction::Exclude {\n+                                continue;\n+                            }\n                             stack.push((ReverseTopologicalPass::Visit, parent, current));\n-                            if action? == GraphTraversalAction::Continue && expanded.insert(current)\n+                            if action == GraphTraversalAction::Continue && expanded.insert(current)\n                             {\n                                 stack.extend(iter_neighbors(graph, current).map(\n                                     |(edge, child)| {\n@@ -603,9 +606,7 @@ impl ModuleGraph {\n \n     #[turbo_tasks::function]\n     pub async fn chunk_group_info(&self) -> Result<Vc<ChunkGroupInfo>> {\n-        compute_chunk_group_info(self)\n-            .instrument(tracing::info_span!(\"compute_chunk_group_info\"))\n-            .await\n+        compute_chunk_group_info(self).await\n     }\n \n     #[turbo_tasks::function]\n@@ -618,7 +619,7 @@ impl ModuleGraph {\n             let _issues = result_op.take_collectibles::<Box<dyn Issue>>();\n             anyhow::Ok(*result_vc)\n         }\n-        .instrument(tracing::info_span!(\"compute_async_module_info\"))\n+        .instrument(tracing::info_span!(\"compute async module info\"))\n         .await\n     }\n \n@@ -940,9 +941,12 @@ impl ModuleGraph {\n                     visit_postorder(parent_arg, current_node, state);\n                 }\n                 ReverseTopologicalPass::ExpandAndVisit => {\n-                    let action = visit_preorder(parent_arg, current_node, state);\n+                    let action = visit_preorder(parent_arg, current_node, state)?;\n+                    if action == GraphTraversalAction::Exclude {\n+                        continue;\n+                    }\n                     stack.push((ReverseTopologicalPass::Visit, parent, current));\n-                    if action? == GraphTraversalAction::Continue && expanded.insert(current) {\n+                    if action == GraphTraversalAction::Continue && expanded.insert(current) {\n                         let graph = &graphs[current.graph_idx].graph;\n                         let (neighbors, current) =\n                             match graph.node_weight(current.node_idx).unwrap() {\n@@ -1027,49 +1031,14 @@ impl SingleModuleGraphNode {\n     // }\n }\n \n-#[derive(Clone, Debug, ValueDebugFormat, Serialize, Deserialize)]\n-struct TracedDiGraph<N, E>(DiGraph<N, E>);\n-impl<N, E> Default for TracedDiGraph<N, E> {\n-    fn default() -> Self {\n-        Self(Default::default())\n-    }\n-}\n-\n-impl<N, E> TraceRawVcs for TracedDiGraph<N, E>\n-where\n-    N: TraceRawVcs,\n-    E: TraceRawVcs,\n-{\n-    fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n-        for node in self.0.node_weights() {\n-            node.trace_raw_vcs(trace_context);\n-        }\n-        for edge in self.0.edge_weights() {\n-            edge.trace_raw_vcs(trace_context);\n-        }\n-    }\n-}\n-\n-impl<N, E> Deref for TracedDiGraph<N, E> {\n-    type Target = DiGraph<N, E>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.0\n-    }\n-}\n-\n-unsafe impl<N, E> NonLocalValue for TracedDiGraph<N, E>\n-where\n-    N: NonLocalValue,\n-    E: NonLocalValue,\n-{\n-}\n-\n #[derive(PartialEq, Eq, Debug)]\n pub enum GraphTraversalAction {\n     /// Continue visiting children\n     Continue,\n-    /// Skip the immediate children\n+    /// Skip the immediate children, but visit the node in postorder\n     Skip,\n+    /// Skip the immediate children and the node in postorder\n+    Exclude,\n }\n \n // These nodes are created while walking the Turbopack modules references, and are used to then"
        },
        {
            "sha": "aa7bf5eb2de8f64b20180c101def23c2657f9552",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/traced_di_graph.rs",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/vercel/next.js/blob/78b74228eb87ee4075e1e02c75026847ed422aab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Ftraced_di_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/78b74228eb87ee4075e1e02c75026847ed422aab/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Ftraced_di_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Ftraced_di_graph.rs?ref=78b74228eb87ee4075e1e02c75026847ed422aab",
            "patch": "@@ -0,0 +1,52 @@\n+use std::ops::Deref;\n+\n+use petgraph::graph::DiGraph;\n+use serde::{Deserialize, Serialize};\n+use turbo_tasks::{\n+    debug::ValueDebugFormat,\n+    trace::{TraceRawVcs, TraceRawVcsContext},\n+    NonLocalValue,\n+};\n+\n+#[derive(Clone, Debug, ValueDebugFormat, Serialize, Deserialize)]\n+pub struct TracedDiGraph<N, E>(DiGraph<N, E>);\n+impl<N, E> Default for TracedDiGraph<N, E> {\n+    fn default() -> Self {\n+        Self(Default::default())\n+    }\n+}\n+\n+impl<N, E> TracedDiGraph<N, E> {\n+    pub fn new(graph: DiGraph<N, E>) -> Self {\n+        Self(graph)\n+    }\n+}\n+\n+impl<N, E> TraceRawVcs for TracedDiGraph<N, E>\n+where\n+    N: TraceRawVcs,\n+    E: TraceRawVcs,\n+{\n+    fn trace_raw_vcs(&self, trace_context: &mut TraceRawVcsContext) {\n+        for node in self.0.node_weights() {\n+            node.trace_raw_vcs(trace_context);\n+        }\n+        for edge in self.0.edge_weights() {\n+            edge.trace_raw_vcs(trace_context);\n+        }\n+    }\n+}\n+\n+impl<N, E> Deref for TracedDiGraph<N, E> {\n+    type Target = DiGraph<N, E>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+unsafe impl<N, E> NonLocalValue for TracedDiGraph<N, E>\n+where\n+    N: NonLocalValue,\n+    E: NonLocalValue,\n+{\n+}"
        }
    ],
    "stats": {
        "total": 316,
        "additions": 209,
        "deletions": 107
    }
}