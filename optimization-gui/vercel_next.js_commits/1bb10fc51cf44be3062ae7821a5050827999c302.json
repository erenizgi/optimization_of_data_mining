{
    "author": "sokra",
    "message": "Turbopack: Track errored tasks as dependency when using untracked() (#84914)\n\n### What?\n\nThe pattern `some_operation().untracked().await?` is dangerous as it propages the error to the parent task.\n\nAn untracked read accepts an incorrectness due to eventual consistency during an update. This might also cause eventual consistent errors.\n\nIf these errors are propagates to the parent task, these error will not easily go away, as the read was untrack and therefore the error doesn't resolve automatically when the `some_operation` task computes again.\n\nThis change changes to the default of untracked read to be only untracked for the value, but track the dependency in case of an error.",
    "sha": "1bb10fc51cf44be3062ae7821a5050827999c302",
    "files": [
        {
            "sha": "f26b6f6e4129a5ac9fb717d507544d66300e8709",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 30,
            "deletions": 19,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=1bb10fc51cf44be3062ae7821a5050827999c302",
            "patch": "@@ -28,8 +28,8 @@ use tokio::time::{Duration, Instant};\n use tracing::{Span, field::Empty, info_span, trace_span};\n use turbo_tasks::{\n     CellId, FxDashMap, FxIndexMap, KeyValuePair, RawVc, ReadCellOptions, ReadConsistency,\n-    SessionId, TRANSIENT_TASK_BIT, TaskExecutionReason, TaskId, TraitTypeId, TurboTasksBackendApi,\n-    ValueTypeId,\n+    ReadOutputOptions, ReadTracking, SessionId, TRANSIENT_TASK_BIT, TaskExecutionReason, TaskId,\n+    TraitTypeId, TurboTasksBackendApi, ValueTypeId,\n     backend::{\n         Backend, CachedTaskType, CellContent, TaskExecutionSpec, TransientTaskRoot,\n         TransientTaskType, TurboTasksExecutionError, TypedCellContent,\n@@ -458,7 +458,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         self: &Arc<Self>,\n         task_id: TaskId,\n         reader: Option<TaskId>,\n-        consistency: ReadConsistency,\n+        options: ReadOutputOptions,\n         turbo_tasks: &dyn TurboTasksBackendApi<TurboTasksBackend<B>>,\n     ) -> Result<Result<RawVc, EventListener>> {\n         self.assert_not_persistent_calling_transient(reader, task_id, /* cell_id */ None);\n@@ -469,15 +469,16 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         fn listen_to_done_event<B: BackingStorage>(\n             this: &TurboTasksBackendInner<B>,\n             reader: Option<TaskId>,\n+            tracking: ReadTracking,\n             done_event: &Event,\n         ) -> EventListener {\n             done_event.listen_with_note(move || {\n                 let reader_desc = reader.map(|r| this.get_task_desc_fn(r));\n                 move || {\n                     if let Some(reader_desc) = reader_desc.as_ref() {\n-                        format!(\"try_read_task_output from {}\", reader_desc())\n+                        format!(\"try_read_task_output from {} ({})\", reader_desc(), tracking)\n                     } else {\n-                        \"try_read_task_output (untracked)\".to_string()\n+                        format!(\"try_read_task_output ({})\", tracking)\n                     }\n                 }\n             })\n@@ -487,16 +488,19 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             this: &TurboTasksBackendInner<B>,\n             task: &impl TaskGuard,\n             reader: Option<TaskId>,\n+            tracking: ReadTracking,\n             ctx: &impl ExecuteContext<'_>,\n         ) -> Option<std::result::Result<std::result::Result<RawVc, EventListener>, anyhow::Error>>\n         {\n             match get!(task, InProgress) {\n-                Some(InProgressState::Scheduled { done_event, .. }) => {\n-                    Some(Ok(Err(listen_to_done_event(this, reader, done_event))))\n-                }\n+                Some(InProgressState::Scheduled { done_event, .. }) => Some(Ok(Err(\n+                    listen_to_done_event(this, reader, tracking, done_event),\n+                ))),\n                 Some(InProgressState::InProgress(box InProgressStateInner {\n                     done_event, ..\n-                })) => Some(Ok(Err(listen_to_done_event(this, reader, done_event)))),\n+                })) => Some(Ok(Err(listen_to_done_event(\n+                    this, reader, tracking, done_event,\n+                )))),\n                 Some(InProgressState::Canceled) => Some(Err(anyhow::anyhow!(\n                     \"{} was canceled\",\n                     ctx.get_task_description(task.id())\n@@ -505,7 +509,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             }\n         }\n \n-        if matches!(consistency, ReadConsistency::Strong) {\n+        if matches!(options.consistency, ReadConsistency::Strong) {\n             // Ensure it's an root node\n             loop {\n                 let aggregation_number = get_aggregation_number(&task);\n@@ -687,7 +691,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             }\n         }\n \n-        if let Some(value) = check_in_progress(self, &task, reader, &ctx) {\n+        if let Some(value) = check_in_progress(self, &task, reader, options.tracking, &ctx) {\n             return value;\n         }\n \n@@ -705,6 +709,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             };\n             if self.should_track_dependencies()\n                 && let Some(reader) = reader\n+                && options.tracking.should_track(result.is_err())\n                 && (!task.is_immutable() || cfg!(feature = \"verify_immutable\"))\n             {\n                 let _ = task.add(CachedDataItem::OutputDependent {\n@@ -810,7 +815,9 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             None\n         };\n         if let Some(content) = content {\n-            add_cell_dependency(self, task, reader, cell, task_id, &mut ctx);\n+            if options.tracking.should_track(false) {\n+                add_cell_dependency(self, task, reader, cell, task_id, &mut ctx);\n+            }\n             return Ok(Ok(TypedCellContent(\n                 cell.type_id,\n                 CellContent(Some(content.reference)),\n@@ -835,14 +842,18 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         )\n         .copied();\n         let Some(max_id) = max_id else {\n-            add_cell_dependency(self, task, reader, cell, task_id, &mut ctx);\n+            if options.tracking.should_track(true) {\n+                add_cell_dependency(self, task, reader, cell, task_id, &mut ctx);\n+            }\n             bail!(\n                 \"Cell {cell:?} no longer exists in task {} (no cell of this type exists)\",\n                 ctx.get_task_description(task_id)\n             );\n         };\n         if cell.index >= max_id {\n-            add_cell_dependency(self, task, reader, cell, task_id, &mut ctx);\n+            if options.tracking.should_track(true) {\n+                add_cell_dependency(self, task, reader, cell, task_id, &mut ctx);\n+            }\n             bail!(\n                 \"Cell {cell:?} no longer exists in task {} (index out of bounds)\",\n                 ctx.get_task_description(task_id)\n@@ -2457,7 +2468,7 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         })\n     }\n \n-    fn try_read_own_task_cell_untracked(\n+    fn try_read_own_task_cell(\n         &self,\n         task_id: TaskId,\n         cell: CellId,\n@@ -3139,11 +3150,11 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n         &self,\n         task_id: TaskId,\n         reader: Option<TaskId>,\n-        consistency: ReadConsistency,\n+        options: ReadOutputOptions,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> Result<Result<RawVc, EventListener>> {\n         self.0\n-            .try_read_task_output(task_id, reader, consistency, turbo_tasks)\n+            .try_read_task_output(task_id, reader, options, turbo_tasks)\n     }\n \n     fn try_read_task_cell(\n@@ -3158,15 +3169,15 @@ impl<B: BackingStorage> Backend for TurboTasksBackend<B> {\n             .try_read_task_cell(task_id, reader, cell, options, turbo_tasks)\n     }\n \n-    fn try_read_own_task_cell_untracked(\n+    fn try_read_own_task_cell(\n         &self,\n         task_id: TaskId,\n         cell: CellId,\n         options: ReadCellOptions,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> Result<TypedCellContent> {\n         self.0\n-            .try_read_own_task_cell_untracked(task_id, cell, options, turbo_tasks)\n+            .try_read_own_task_cell(task_id, cell, options, turbo_tasks)\n     }\n \n     fn read_task_collectibles("
        },
        {
            "sha": "34564c3e75c3d4c9695e43c78d3823ebc1418fc4",
            "filename": "turbopack/crates/turbo-tasks-testing/src/lib.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 27,
            "changes": 30,
            "blob_url": "https://github.com/vercel/next.js/blob/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Fsrc%2Flib.rs?ref=1bb10fc51cf44be3062ae7821a5050827999c302",
            "patch": "@@ -17,7 +17,7 @@ use rustc_hash::FxHashMap;\n use tokio::sync::mpsc::Receiver;\n use turbo_tasks::{\n     CellId, ExecutionId, InvalidationReason, LocalTaskId, MagicAny, RawVc, ReadCellOptions,\n-    ReadConsistency, TaskId, TaskPersistence, TraitTypeId, TurboTasksApi, TurboTasksCallApi,\n+    ReadOutputOptions, TaskId, TaskPersistence, TraitTypeId, TurboTasksApi, TurboTasksCallApi,\n     backend::{CellContent, TaskCollectiblesMap, TypedCellContent},\n     event::{Event, EventListener},\n     message_queue::CompilationEvent,\n@@ -176,7 +176,7 @@ impl TurboTasksApi for VcStorage {\n     fn try_read_task_output(\n         &self,\n         id: TaskId,\n-        _consistency: ReadConsistency,\n+        _options: ReadOutputOptions,\n     ) -> Result<Result<RawVc, EventListener>> {\n         let tasks = self.tasks.lock().unwrap();\n         let i = *id - 1;\n@@ -190,14 +190,6 @@ impl TurboTasksApi for VcStorage {\n         }\n     }\n \n-    fn try_read_task_output_untracked(\n-        &self,\n-        task: TaskId,\n-        consistency: ReadConsistency,\n-    ) -> Result<Result<RawVc, EventListener>> {\n-        self.try_read_task_output(task, consistency)\n-    }\n-\n     fn try_read_task_cell(\n         &self,\n         task: TaskId,\n@@ -212,23 +204,7 @@ impl TurboTasksApi for VcStorage {\n         }\n         .into_typed(index.type_id)))\n     }\n-\n-    fn try_read_task_cell_untracked(\n-        &self,\n-        task: TaskId,\n-        index: CellId,\n-        _options: ReadCellOptions,\n-    ) -> Result<Result<TypedCellContent, EventListener>> {\n-        let map = self.cells.lock().unwrap();\n-        Ok(Ok(if let Some(cell) = map.get(&(task, index)) {\n-            cell.to_owned()\n-        } else {\n-            Default::default()\n-        }\n-        .into_typed(index.type_id)))\n-    }\n-\n-    fn try_read_own_task_cell_untracked(\n+    fn try_read_own_task_cell(\n         &self,\n         current_task: TaskId,\n         index: CellId,"
        },
        {
            "sha": "70f4147aa166a24633d535c5c8dfd349b186ef7a",
            "filename": "turbopack/crates/turbo-tasks/src/backend.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 12,
            "changes": 19,
            "blob_url": "https://github.com/vercel/next.js/blob/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fbackend.rs?ref=1bb10fc51cf44be3062ae7821a5050827999c302",
            "patch": "@@ -17,16 +17,11 @@ use tracing::Span;\n use turbo_rcstr::RcStr;\n \n use crate::{\n-    RawVc, ReadCellOptions, ReadRef, SharedReference, TaskId, TaskIdSet, TraitRef, TraitTypeId,\n-    TurboTasksPanic, ValueTypeId, VcRead, VcValueTrait, VcValueType,\n-    event::EventListener,\n-    macro_helpers::NativeFunction,\n-    magic_any::MagicAny,\n-    manager::{ReadConsistency, TurboTasksBackendApi},\n-    raw_vc::CellId,\n-    registry,\n-    task::shared_reference::TypedSharedReference,\n-    task_statistics::TaskStatisticsApi,\n+    RawVc, ReadCellOptions, ReadOutputOptions, ReadRef, SharedReference, TaskId, TaskIdSet,\n+    TraitRef, TraitTypeId, TurboTasksPanic, ValueTypeId, VcRead, VcValueTrait, VcValueType,\n+    event::EventListener, macro_helpers::NativeFunction, magic_any::MagicAny,\n+    manager::TurboTasksBackendApi, raw_vc::CellId, registry,\n+    task::shared_reference::TypedSharedReference, task_statistics::TaskStatisticsApi,\n     triomphe_utils::unchecked_sidecast_triomphe_arc,\n };\n \n@@ -564,7 +559,7 @@ pub trait Backend: Sync + Send {\n         &self,\n         task: TaskId,\n         reader: Option<TaskId>,\n-        consistency: ReadConsistency,\n+        options: ReadOutputOptions,\n         turbo_tasks: &dyn TurboTasksBackendApi<Self>,\n     ) -> Result<Result<RawVc, EventListener>>;\n \n@@ -581,7 +576,7 @@ pub trait Backend: Sync + Send {\n \n     /// INVALIDATION: Be careful with this, it will not track dependencies, so\n     /// using it could break cache invalidation.\n-    fn try_read_own_task_cell_untracked(\n+    fn try_read_own_task_cell(\n         &self,\n         current_task: TaskId,\n         index: CellId,"
        },
        {
            "sha": "7cbb05bfd780fa9146c9a64b5324b29ffc9ab322",
            "filename": "turbopack/crates/turbo-tasks/src/lib.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Flib.rs?ref=1bb10fc51cf44be3062ae7821a5050827999c302",
            "patch": "@@ -108,14 +108,14 @@ pub use join_iter_ext::{JoinIterExt, TryFlatJoinIterExt, TryJoinIterExt};\n pub use key_value_pair::KeyValuePair;\n pub use magic_any::MagicAny;\n pub use manager::{\n-    CurrentCellRef, ReadConsistency, TaskPersistence, TurboTasks, TurboTasksApi,\n+    CurrentCellRef, ReadConsistency, ReadTracking, TaskPersistence, TurboTasks, TurboTasksApi,\n     TurboTasksBackendApi, TurboTasksCallApi, Unused, UpdateInfo, dynamic_call, emit, mark_finished,\n     mark_root, mark_session_dependent, mark_stateful, prevent_gc, run, run_once,\n     run_once_with_reason, trait_call, turbo_tasks, turbo_tasks_scope,\n };\n pub use output::OutputContent;\n pub use raw_vc::{CellId, RawVc, ReadRawVcFuture, ResolveTypeError};\n-pub use read_options::ReadCellOptions;\n+pub use read_options::{ReadCellOptions, ReadOutputOptions};\n pub use read_ref::ReadRef;\n use rustc_hash::FxHasher;\n pub use serialization_invalidation::SerializationInvalidator;"
        },
        {
            "sha": "d32500ba675c426a49fd9689cc16f0fa77aa9d6c",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 77,
            "deletions": 68,
            "changes": 145,
            "blob_url": "https://github.com/vercel/next.js/blob/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=1bb10fc51cf44be3062ae7821a5050827999c302",
            "patch": "@@ -1,4 +1,5 @@\n use std::{\n+    fmt::Display,\n     future::Future,\n     hash::BuildHasherDefault,\n     mem::take,\n@@ -20,8 +21,8 @@ use tracing::{Instrument, instrument};\n \n use crate::{\n     Completion, InvalidationReason, InvalidationReasonSet, OutputContent, ReadCellOptions,\n-    ResolvedVc, SharedReference, TaskId, TraitMethod, ValueTypeId, Vc, VcRead, VcValueTrait,\n-    VcValueType,\n+    ReadOutputOptions, ResolvedVc, SharedReference, TaskId, TraitMethod, ValueTypeId, Vc, VcRead,\n+    VcValueTrait, VcValueType,\n     backend::{\n         Backend, CachedTaskType, CellContent, TaskCollectiblesMap, TaskExecutionSpec,\n         TransientTaskType, TurboTasksExecutionError, TypedCellContent,\n@@ -103,15 +104,7 @@ pub trait TurboTasksApi: TurboTasksCallApi + Sync + Send {\n     fn try_read_task_output(\n         &self,\n         task: TaskId,\n-        consistency: ReadConsistency,\n-    ) -> Result<Result<RawVc, EventListener>>;\n-\n-    /// INVALIDATION: Be careful with this, it will not track dependencies, so\n-    /// using it could break cache invalidation.\n-    fn try_read_task_output_untracked(\n-        &self,\n-        task: TaskId,\n-        consistency: ReadConsistency,\n+        options: ReadOutputOptions,\n     ) -> Result<Result<RawVc, EventListener>>;\n \n     fn try_read_task_cell(\n@@ -121,15 +114,6 @@ pub trait TurboTasksApi: TurboTasksCallApi + Sync + Send {\n         options: ReadCellOptions,\n     ) -> Result<Result<TypedCellContent, EventListener>>;\n \n-    /// INVALIDATION: Be careful with this, it will not track dependencies, so\n-    /// using it could break cache invalidation.\n-    fn try_read_task_cell_untracked(\n-        &self,\n-        task: TaskId,\n-        index: CellId,\n-        options: ReadCellOptions,\n-    ) -> Result<Result<TypedCellContent, EventListener>>;\n-\n     /// Reads a [`RawVc::LocalOutput`]. If the task has completed, returns the [`RawVc`] the local\n     /// task points to.\n     ///\n@@ -158,7 +142,7 @@ pub trait TurboTasksApi: TurboTasksCallApi + Sync + Send {\n \n     /// INVALIDATION: Be careful with this, it will not track dependencies, so\n     /// using it could break cache invalidation.\n-    fn try_read_own_task_cell_untracked(\n+    fn try_read_own_task_cell(\n         &self,\n         current_task: TaskId,\n         index: CellId,\n@@ -301,10 +285,11 @@ pub enum TaskPersistence {\n     Local,\n }\n \n-#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Default)]\n pub enum ReadConsistency {\n     /// The default behavior for most APIs. Reads are faster, but may return stale values, which\n     /// may later trigger re-computation.\n+    #[default]\n     Eventual,\n     /// Ensures all dependencies are fully resolved before returning the cell or output data, at\n     /// the cost of slower reads.\n@@ -313,6 +298,43 @@ pub enum ReadConsistency {\n     Strong,\n }\n \n+#[derive(Clone, Copy, Debug, Eq, PartialEq, Default)]\n+pub enum ReadTracking {\n+    /// Reads are tracked as dependencies of the current task.\n+    #[default]\n+    Tracked,\n+    /// The read is only tracked when there is an error, otherwise it is untracked.\n+    ///\n+    /// INVALIDATION: Be careful with this, it will not track dependencies, so\n+    /// using it could break cache invalidation.\n+    TrackOnlyError,\n+    /// The read is not tracked as a dependency of the current task.\n+    ///\n+    /// INVALIDATION: Be careful with this, it will not track dependencies, so\n+    /// using it could break cache invalidation.\n+    Untracked,\n+}\n+\n+impl ReadTracking {\n+    pub fn should_track(&self, is_err: bool) -> bool {\n+        match self {\n+            ReadTracking::Tracked => true,\n+            ReadTracking::TrackOnlyError => is_err,\n+            ReadTracking::Untracked => false,\n+        }\n+    }\n+}\n+\n+impl Display for ReadTracking {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            ReadTracking::Tracked => write!(f, \"tracked\"),\n+            ReadTracking::TrackOnlyError => write!(f, \"track only error\"),\n+            ReadTracking::Untracked => write!(f, \"untracked\"),\n+        }\n+    }\n+}\n+\n pub struct TurboTasks<B: Backend + 'static> {\n     this: Weak<Self>,\n     backend: B,\n@@ -927,8 +949,16 @@ impl<B: Backend + 'static> TurboTasks<B> {\n         id: TaskId,\n         consistency: ReadConsistency,\n     ) -> Result<()> {\n-        // INVALIDATION: This doesn't return a value, only waits for it to be ready.\n-        read_task_output_untracked(self, id, consistency).await?;\n+        read_task_output(\n+            self,\n+            id,\n+            ReadOutputOptions {\n+                // INVALIDATION: This doesn't return a value, only waits for it to be ready.\n+                tracking: ReadTracking::Untracked,\n+                consistency,\n+            },\n+        )\n+        .await?;\n         Ok(())\n     }\n \n@@ -1217,25 +1247,16 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n     fn try_read_task_output(\n         &self,\n         task: TaskId,\n-        consistency: ReadConsistency,\n+        options: ReadOutputOptions,\n     ) -> Result<Result<RawVc, EventListener>> {\n         self.backend.try_read_task_output(\n             task,\n             current_task_if_available(\"reading Vcs\"),\n-            consistency,\n+            options,\n             self,\n         )\n     }\n \n-    fn try_read_task_output_untracked(\n-        &self,\n-        task: TaskId,\n-        consistency: ReadConsistency,\n-    ) -> Result<Result<RawVc, EventListener>> {\n-        self.backend\n-            .try_read_task_output(task, None, consistency, self)\n-    }\n-\n     fn try_read_task_cell(\n         &self,\n         task: TaskId,\n@@ -1251,24 +1272,14 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n         )\n     }\n \n-    fn try_read_task_cell_untracked(\n-        &self,\n-        task: TaskId,\n-        index: CellId,\n-        options: ReadCellOptions,\n-    ) -> Result<Result<TypedCellContent, EventListener>> {\n-        self.backend\n-            .try_read_task_cell(task, index, None, options, self)\n-    }\n-\n-    fn try_read_own_task_cell_untracked(\n+    fn try_read_own_task_cell(\n         &self,\n         current_task: TaskId,\n         index: CellId,\n         options: ReadCellOptions,\n     ) -> Result<TypedCellContent> {\n         self.backend\n-            .try_read_own_task_cell_untracked(current_task, index, options, self)\n+            .try_read_own_task_cell(current_task, index, options, self)\n     }\n \n     fn try_read_local_output(\n@@ -1340,8 +1351,7 @@ impl<B: Backend + 'static> TurboTasksApi for TurboTasks<B> {\n         index: CellId,\n         options: ReadCellOptions,\n     ) -> Result<TypedCellContent> {\n-        // INVALIDATION: don't need to track a dependency to itself\n-        self.try_read_own_task_cell_untracked(task, index, options)\n+        self.try_read_own_task_cell(task, index, options)\n     }\n \n     fn update_own_task_cell(&self, task: TaskId, index: CellId, content: CellContent) {\n@@ -1686,25 +1696,10 @@ pub fn emit<T: VcValueTrait + ?Sized>(collectible: ResolvedVc<T>) {\n pub(crate) async fn read_task_output(\n     this: &dyn TurboTasksApi,\n     id: TaskId,\n-    consistency: ReadConsistency,\n+    options: ReadOutputOptions,\n ) -> Result<RawVc> {\n     loop {\n-        match this.try_read_task_output(id, consistency)? {\n-            Ok(result) => return Ok(result),\n-            Err(listener) => listener.await,\n-        }\n-    }\n-}\n-\n-/// INVALIDATION: Be careful with this, it will not track dependencies, so\n-/// using it could break cache invalidation.\n-pub(crate) async fn read_task_output_untracked(\n-    this: &dyn TurboTasksApi,\n-    id: TaskId,\n-    consistency: ReadConsistency,\n-) -> Result<RawVc> {\n-    loop {\n-        match this.try_read_task_output_untracked(id, consistency)? {\n+        match this.try_read_task_output(id, options)? {\n             Ok(result) => return Ok(result),\n             Err(listener) => listener.await,\n         }\n@@ -1762,7 +1757,14 @@ impl CurrentCellRef {\n     ) {\n         let tt = turbo_tasks();\n         let cell_content = tt\n-            .read_own_task_cell(self.current_task, self.index, ReadCellOptions::default())\n+            .read_own_task_cell(\n+                self.current_task,\n+                self.index,\n+                ReadCellOptions {\n+                    tracking: ReadTracking::Untracked,\n+                    ..Default::default()\n+                },\n+            )\n             .ok();\n         let update = functor(cell_content.as_ref().and_then(|cc| cc.1.0.as_ref()));\n         if let Some(update) = update {\n@@ -1873,7 +1875,14 @@ impl CurrentCellRef {\n     pub fn update_with_shared_reference(&self, shared_ref: SharedReference) {\n         let tt = turbo_tasks();\n         let content = tt\n-            .read_own_task_cell(self.current_task, self.index, ReadCellOptions::default())\n+            .read_own_task_cell(\n+                self.current_task,\n+                self.index,\n+                ReadCellOptions {\n+                    tracking: ReadTracking::Untracked,\n+                    ..Default::default()\n+                },\n+            )\n             .ok();\n         let update = if let Some(TypedCellContent(_, CellContent(Some(shared_ref_exp)))) = content {\n             // pointer equality (not value equality)"
        },
        {
            "sha": "2fe020c30c2ab1bcdf5ba8e7edda3b34bf80c4bc",
            "filename": "turbopack/crates/turbo-tasks/src/raw_vc.rs",
            "status": "modified",
            "additions": 47,
            "deletions": 28,
            "changes": 75,
            "blob_url": "https://github.com/vercel/next.js/blob/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fraw_vc.rs?ref=1bb10fc51cf44be3062ae7821a5050827999c302",
            "patch": "@@ -11,12 +11,14 @@ use serde::{Deserialize, Serialize};\n use thiserror::Error;\n \n use crate::{\n-    CollectiblesSource, ReadCellOptions, ReadConsistency, ResolvedVc, TaskId, TaskPersistence,\n-    TraitTypeId, ValueType, ValueTypeId, VcValueTrait,\n+    CollectiblesSource, ReadCellOptions, ReadConsistency, ReadOutputOptions, ResolvedVc, TaskId,\n+    TaskPersistence, TraitTypeId, ValueType, ValueTypeId, VcValueTrait,\n     backend::{CellContent, TypedCellContent},\n     event::EventListener,\n     id::{ExecutionId, LocalTaskId},\n-    manager::{read_local_output, read_task_cell, read_task_output, with_turbo_tasks},\n+    manager::{\n+        ReadTracking, read_local_output, read_task_cell, read_task_output, with_turbo_tasks,\n+    },\n     registry::{self, get_value_type},\n     turbo_tasks,\n };\n@@ -170,7 +172,7 @@ impl RawVc {\n         loop {\n             match current {\n                 RawVc::TaskOutput(task) => {\n-                    current = read_task_output(&*tt, task, ReadConsistency::Eventual)\n+                    current = read_task_output(&*tt, task, ReadOutputOptions::default())\n                         .await\n                         .map_err(|source| ResolveTypeError::TaskError { source })?;\n                 }\n@@ -199,29 +201,37 @@ impl RawVc {\n \n     /// See [`crate::Vc::resolve`].\n     pub(crate) async fn resolve(self) -> Result<RawVc> {\n-        self.resolve_inner(ReadConsistency::Eventual).await\n+        self.resolve_inner(ReadOutputOptions {\n+            tracking: ReadTracking::default(),\n+            consistency: ReadConsistency::Eventual,\n+        })\n+        .await\n     }\n \n     /// See [`crate::Vc::resolve_strongly_consistent`].\n     pub(crate) async fn resolve_strongly_consistent(self) -> Result<RawVc> {\n-        self.resolve_inner(ReadConsistency::Strong).await\n+        self.resolve_inner(ReadOutputOptions {\n+            tracking: ReadTracking::default(),\n+            consistency: ReadConsistency::Strong,\n+        })\n+        .await\n     }\n \n-    async fn resolve_inner(self, mut consistency: ReadConsistency) -> Result<RawVc> {\n+    async fn resolve_inner(self, mut options: ReadOutputOptions) -> Result<RawVc> {\n         let tt = turbo_tasks();\n         let mut current = self;\n         loop {\n             match current {\n                 RawVc::TaskOutput(task) => {\n-                    current = read_task_output(&*tt, task, consistency).await?;\n+                    current = read_task_output(&*tt, task, options).await?;\n                     // We no longer need to read strongly consistent, as any Vc returned\n                     // from the first task will be inside of the scope of the first\n                     // task. So it's already strongly consistent.\n-                    consistency = ReadConsistency::Eventual;\n+                    options.consistency = ReadConsistency::Eventual;\n                 }\n                 RawVc::TaskCell(_, _) => return Ok(current),\n                 RawVc::LocalOutput(execution_id, local_task_id, ..) => {\n-                    debug_assert_eq!(consistency, ReadConsistency::Eventual);\n+                    debug_assert_eq!(options.consistency, ReadConsistency::Eventual);\n                     current = read_local_output(&*tt, execution_id, local_task_id).await?;\n                 }\n             }\n@@ -331,33 +341,46 @@ impl CollectiblesSource for RawVc {\n }\n \n pub struct ReadRawVcFuture {\n-    consistency: ReadConsistency,\n     current: RawVc,\n-    untracked: bool,\n+    read_output_options: ReadOutputOptions,\n     read_cell_options: ReadCellOptions,\n     listener: Option<EventListener>,\n }\n \n impl ReadRawVcFuture {\n     pub(crate) fn new(vc: RawVc) -> Self {\n         ReadRawVcFuture {\n-            consistency: ReadConsistency::Eventual,\n             current: vc,\n-            untracked: false,\n+            read_output_options: ReadOutputOptions::default(),\n             read_cell_options: ReadCellOptions::default(),\n             listener: None,\n         }\n     }\n \n     pub fn strongly_consistent(mut self) -> Self {\n-        self.consistency = ReadConsistency::Strong;\n+        self.read_output_options.consistency = ReadConsistency::Strong;\n         self\n     }\n \n+    /// This will not track the value as dependency, but will still track the error as dependency,\n+    /// if there is an error.\n+    ///\n     /// INVALIDATION: Be careful with this, it will not track dependencies, so\n     /// using it could break cache invalidation.\n     pub fn untracked(mut self) -> Self {\n-        self.untracked = true;\n+        self.read_output_options.tracking = ReadTracking::TrackOnlyError;\n+        self.read_cell_options.tracking = ReadTracking::TrackOnlyError;\n+        self\n+    }\n+\n+    /// This will not track the value or the error as dependency.\n+    /// Make sure to handle eventual consistency errors.\n+    ///\n+    /// INVALIDATION: Be careful with this, it will not track dependencies, so\n+    /// using it could break cache invalidation.\n+    pub fn untracked_including_errors(mut self) -> Self {\n+        self.read_output_options.tracking = ReadTracking::Untracked;\n+        self.read_cell_options.tracking = ReadTracking::Untracked;\n         self\n     }\n \n@@ -385,17 +408,13 @@ impl Future for ReadRawVcFuture {\n                 }\n                 let mut listener = match this.current {\n                     RawVc::TaskOutput(task) => {\n-                        let read_result = if this.untracked {\n-                            tt.try_read_task_output_untracked(task, this.consistency)\n-                        } else {\n-                            tt.try_read_task_output(task, this.consistency)\n-                        };\n+                        let read_result = tt.try_read_task_output(task, this.read_output_options);\n                         match read_result {\n                             Ok(Ok(vc)) => {\n                                 // We no longer need to read strongly consistent, as any Vc returned\n                                 // from the first task will be inside of the scope of the first\n                                 // task. So it's already strongly consistent.\n-                                this.consistency = ReadConsistency::Eventual;\n+                                this.read_output_options.consistency = ReadConsistency::Eventual;\n                                 this.current = vc;\n                                 continue 'outer;\n                             }\n@@ -404,11 +423,8 @@ impl Future for ReadRawVcFuture {\n                         }\n                     }\n                     RawVc::TaskCell(task, index) => {\n-                        let read_result = if this.untracked {\n-                            tt.try_read_task_cell_untracked(task, index, this.read_cell_options)\n-                        } else {\n-                            tt.try_read_task_cell(task, index, this.read_cell_options)\n-                        };\n+                        let read_result =\n+                            tt.try_read_task_cell(task, index, this.read_cell_options);\n                         match read_result {\n                             Ok(Ok(content)) => {\n                                 // SAFETY: Constructor ensures that T and U are binary identical\n@@ -419,7 +435,10 @@ impl Future for ReadRawVcFuture {\n                         }\n                     }\n                     RawVc::LocalOutput(execution_id, local_output_id, ..) => {\n-                        debug_assert_eq!(this.consistency, ReadConsistency::Eventual);\n+                        debug_assert_eq!(\n+                            this.read_output_options.consistency,\n+                            ReadConsistency::Eventual\n+                        );\n                         let read_result = tt.try_read_local_output(execution_id, local_output_id);\n                         match read_result {\n                             Ok(Ok(vc)) => {"
        },
        {
            "sha": "3c08fe3a3b72bb8cfccd5b97ce412cf105076fdf",
            "filename": "turbopack/crates/turbo-tasks/src/read_options.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_options.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/1bb10fc51cf44be3062ae7821a5050827999c302/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_options.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_options.rs?ref=1bb10fc51cf44be3062ae7821a5050827999c302",
            "patch": "@@ -1,4 +1,13 @@\n+use crate::{ReadConsistency, ReadTracking};\n+\n #[derive(Clone, Copy, Debug, Default)]\n pub struct ReadCellOptions {\n+    pub tracking: ReadTracking,\n     pub final_read_hint: bool,\n }\n+\n+#[derive(Clone, Copy, Debug, Default)]\n+pub struct ReadOutputOptions {\n+    pub tracking: ReadTracking,\n+    pub consistency: ReadConsistency,\n+}"
        }
    ],
    "stats": {
        "total": 331,
        "additions": 175,
        "deletions": 156
    }
}