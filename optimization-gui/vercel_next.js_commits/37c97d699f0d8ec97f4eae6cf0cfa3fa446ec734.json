{
    "author": "mischnic",
    "message": "Turbopack: refactor codegen (#78685)\n\nRefactor codegen in preparation for scope hoisting\n\nNow, you can easily get the AST of the code-gen-ed module (which I need to merge them together)\n\nPart of PACK-2960",
    "sha": "37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734",
    "files": [
        {
            "sha": "054fce2042ec4f24abe920a78784b3fb7d973bb0",
            "filename": "turbopack/crates/turbo-tasks/src/read_ref.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_ref.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_ref.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fread_ref.rs?ref=37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734",
            "patch": "@@ -266,6 +266,9 @@ impl<T> ReadRef<T>\n where\n     T: VcValueType,\n {\n+    /// Returns the inner value, if this [`ReadRef`] has exactly one strong reference.\n+    ///\n+    /// Otherwise, an [`Err`] is returned with the same [`ReadRef`] that was passed in.\n     pub fn try_unwrap(this: Self) -> Result<VcReadTarget<T>, Self> {\n         match triomphe::Arc::try_unwrap(this.0) {\n             Ok(value) => Ok(T::Read::value_to_target(value)),"
        },
        {
            "sha": "9c1359002d3891db502c17b309e4719b35452d14",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 228,
            "deletions": 144,
            "changes": 372,
            "blob_url": "https://github.com/vercel/next.js/blob/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734",
            "patch": "@@ -50,12 +50,13 @@ pub use references::{AnalyzeEcmascriptModuleResult, TURBOPACK_HELPER};\n use serde::{Deserialize, Serialize};\n pub use static_code::StaticEcmascriptCode;\n use swc_core::{\n-    common::{comments::Comments, util::take::Take, Globals, Mark, GLOBALS},\n+    common::{comments::Comments, util::take::Take, Globals, Mark, SourceMap, DUMMY_SP, GLOBALS},\n     ecma::{\n-        ast::{self, ModuleItem, Program, Script},\n+        ast::{self, Expr, ModuleItem, Program, Script},\n         codegen::{text_writer::JsWriter, Emitter},\n         visit::{VisitMutWith, VisitMutWithAstPath},\n     },\n+    quote,\n };\n use tracing::Instrument;\n pub use transform::{\n@@ -99,6 +100,7 @@ use crate::{\n         analyse_ecmascript_module, async_module::OptionAsyncModule, esm::base::EsmAssetReferences,\n     },\n     side_effect_optimization::reference::EcmascriptModulePartReference,\n+    swc_comments::ImmutableComments,\n     transform::remove_shebang,\n };\n \n@@ -287,7 +289,7 @@ pub trait EcmascriptParsable {\n }\n \n #[turbo_tasks::value_trait]\n-pub trait EcmascriptAnalyzable {\n+pub trait EcmascriptAnalyzable: Module + Asset {\n     fn analyze(self: Vc<Self>) -> Vc<AnalyzeEcmascriptModuleResult>;\n \n     /// Generates module contents without an analysis pass. This is useful for\n@@ -297,12 +299,25 @@ pub trait EcmascriptAnalyzable {\n         generate_source_map: bool,\n     ) -> Result<Vc<EcmascriptModuleContent>>;\n \n+    async fn module_content_options(\n+        self: Vc<Self>,\n+        module_graph: Vc<ModuleGraph>,\n+        chunking_context: Vc<Box<dyn ChunkingContext>>,\n+        async_module_info: Option<Vc<AsyncModuleInfo>>,\n+    ) -> Result<Vc<EcmascriptModuleContentOptions>>;\n+\n     async fn module_content(\n         self: Vc<Self>,\n         module_graph: Vc<ModuleGraph>,\n         chunking_context: Vc<Box<dyn ChunkingContext>>,\n         async_module_info: Option<Vc<AsyncModuleInfo>>,\n-    ) -> Result<Vc<EcmascriptModuleContent>>;\n+    ) -> Vc<EcmascriptModuleContent> {\n+        EcmascriptModuleContent::new(self.module_content_options(\n+            module_graph,\n+            chunking_context,\n+            async_module_info,\n+        ))\n+    }\n }\n \n impl EcmascriptModuleAsset {\n@@ -413,12 +428,12 @@ impl EcmascriptAnalyzable for EcmascriptModuleAsset {\n     }\n \n     #[turbo_tasks::function]\n-    async fn module_content(\n+    async fn module_content_options(\n         self: Vc<Self>,\n         module_graph: ResolvedVc<ModuleGraph>,\n         chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n         async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n-    ) -> Result<Vc<EcmascriptModuleContent>> {\n+    ) -> Result<Vc<EcmascriptModuleContentOptions>> {\n         let parsed = self.parse().to_resolved().await?;\n \n         let analyze = self.analyze();\n@@ -429,24 +444,23 @@ impl EcmascriptAnalyzable for EcmascriptModuleAsset {\n             .reference_module_source_maps(Vc::upcast(self))\n             .await?;\n \n-        Ok(EcmascriptModuleContent::new(\n-            EcmascriptModuleContentOptions {\n-                parsed,\n-                ident: self.ident().to_resolved().await?,\n-                specified_module_type: module_type_result.module_type,\n-                module_graph,\n-                chunking_context,\n-                references: analyze.references().to_resolved().await?,\n-                esm_references: analyze_ref.esm_references,\n-                part_references: vec![],\n-                code_generation: analyze_ref.code_generation,\n-                async_module: analyze_ref.async_module,\n-                generate_source_map,\n-                original_source_map: analyze_ref.source_map,\n-                exports: analyze_ref.exports,\n-                async_module_info,\n-            },\n-        ))\n+        Ok(EcmascriptModuleContentOptions {\n+            parsed,\n+            ident: self.ident().to_resolved().await?,\n+            specified_module_type: module_type_result.module_type,\n+            module_graph,\n+            chunking_context,\n+            references: analyze.references().to_resolved().await?,\n+            esm_references: analyze_ref.esm_references,\n+            part_references: vec![],\n+            code_generation: analyze_ref.code_generation,\n+            async_module: analyze_ref.async_module,\n+            generate_source_map,\n+            original_source_map: analyze_ref.source_map,\n+            exports: analyze_ref.exports,\n+            async_module_info,\n+        }\n+        .cell())\n     }\n }\n \n@@ -783,15 +797,16 @@ impl EcmascriptChunkItem for ModuleChunkItem {\n }\n \n /// The transformed contents of an Ecmascript module.\n-#[turbo_tasks::value]\n+#[turbo_tasks::value(shared)]\n pub struct EcmascriptModuleContent {\n     pub inner_code: Rope,\n     pub source_map: Option<Rope>,\n     pub is_esm: bool,\n     // pub refresh: bool,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, TaskInput, TraceRawVcs)]\n+#[turbo_tasks::value(shared)]\n+#[derive(Clone, Debug, Hash, TaskInput)]\n pub struct EcmascriptModuleContentOptions {\n     parsed: ResolvedVc<ParseResult>,\n     ident: ResolvedVc<AssetIdent>,\n@@ -809,37 +824,31 @@ pub struct EcmascriptModuleContentOptions {\n     async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n }\n \n-#[turbo_tasks::value_impl]\n-impl EcmascriptModuleContent {\n-    /// Creates a new [`Vc<EcmascriptModuleContent>`].\n-    #[turbo_tasks::function]\n-    pub async fn new(input: EcmascriptModuleContentOptions) -> Result<Vc<Self>> {\n+impl EcmascriptModuleContentOptions {\n+    async fn merged_code_gens(&self) -> Result<Vec<CodeGeneration>> {\n         let EcmascriptModuleContentOptions {\n             parsed,\n-            ident,\n-            specified_module_type,\n             module_graph,\n             chunking_context,\n             references,\n             esm_references,\n             part_references,\n             code_generation,\n             async_module,\n-            generate_source_map,\n-            original_source_map,\n             exports,\n             async_module_info,\n-        } = input;\n+            ..\n+        } = self;\n \n-        let (esm_code_gens, part_code_gens, additional_code_gens, code_gens) = async {\n+        async {\n             let additional_code_gens = [\n                 if let Some(async_module) = &*async_module.await? {\n                     Some(\n                         async_module\n                             .code_generation(\n                                 async_module_info.map(|info| *info),\n-                                *references,\n-                                *chunking_context,\n+                                **references,\n+                                **chunking_context,\n                             )\n                             .await?,\n                     )\n@@ -849,7 +858,7 @@ impl EcmascriptModuleContent {\n                 if let EcmascriptExports::EsmExports(exports) = *exports.await? {\n                     Some(\n                         exports\n-                            .code_generation(*module_graph, *chunking_context, Some(*parsed))\n+                            .code_generation(**module_graph, **chunking_context, Some(**parsed))\n                             .await?,\n                     )\n                 } else {\n@@ -860,47 +869,64 @@ impl EcmascriptModuleContent {\n             let esm_code_gens = esm_references\n                 .await?\n                 .iter()\n-                .map(|r| r.code_generation(*chunking_context))\n+                .map(|r| r.code_generation(**chunking_context))\n                 .try_join()\n                 .await?;\n \n             let part_code_gens = part_references\n                 .iter()\n-                .map(|r| r.code_generation(*chunking_context))\n+                .map(|r| r.code_generation(**chunking_context))\n                 .try_join()\n                 .await?;\n \n             let code_gens = code_generation\n                 .await?\n                 .iter()\n-                .map(|c| c.code_generation(*module_graph, *chunking_context))\n+                .map(|c| c.code_generation(**module_graph, **chunking_context))\n                 .try_join()\n                 .await?;\n \n-            anyhow::Ok((\n-                esm_code_gens,\n-                part_code_gens,\n-                additional_code_gens,\n-                code_gens,\n-            ))\n+            anyhow::Ok(\n+                esm_code_gens\n+                    .into_iter()\n+                    .chain(part_code_gens.into_iter())\n+                    .chain(additional_code_gens.into_iter().flatten())\n+                    .chain(code_gens.into_iter())\n+                    .collect(),\n+            )\n         }\n         .instrument(tracing::info_span!(\"precompute code generation\"))\n-        .await?;\n-\n-        let code_gens = esm_code_gens\n-            .iter()\n-            .chain(part_code_gens.iter())\n-            .chain(additional_code_gens.iter().flatten())\n-            .chain(code_gens.iter());\n+        .await\n+    }\n+}\n \n-        gen_content_with_code_gens(\n+#[turbo_tasks::value_impl]\n+impl EcmascriptModuleContent {\n+    /// Creates a new [`Vc<EcmascriptModuleContent>`].\n+    #[turbo_tasks::function]\n+    pub async fn new(input: Vc<EcmascriptModuleContentOptions>) -> Result<Vc<Self>> {\n+        let input = input.await?;\n+        let EcmascriptModuleContentOptions {\n             parsed,\n-            *ident,\n+            ident,\n             specified_module_type,\n-            code_gens,\n             generate_source_map,\n             original_source_map,\n-        )\n+            ..\n+        } = &*input;\n+        let code_gens = input.merged_code_gens().await?;\n+        async {\n+            let content = process_parse_result(\n+                *parsed,\n+                **ident,\n+                *specified_module_type,\n+                code_gens,\n+                *generate_source_map,\n+                *original_source_map,\n+            )\n+            .await?;\n+            emit_content(content).await\n+        }\n         .instrument(tracing::info_span!(\"gen content with code gens\"))\n         .await\n     }\n@@ -913,29 +939,39 @@ impl EcmascriptModuleContent {\n         specified_module_type: SpecifiedModuleType,\n         generate_source_map: bool,\n     ) -> Result<Vc<Self>> {\n-        gen_content_with_code_gens(\n+        let content = process_parse_result(\n             parsed.to_resolved().await?,\n             ident,\n             specified_module_type,\n-            &[],\n+            vec![],\n             generate_source_map,\n             OptionStringifiedSourceMap::none().to_resolved().await?,\n         )\n-        .await\n+        .await?;\n+        emit_content(content).await\n     }\n }\n \n-async fn gen_content_with_code_gens(\n+struct CodeGenResult {\n+    program: Program,\n+    source_map: Arc<SourceMap>,\n+    comments: Either<ImmutableComments, Arc<ImmutableComments>>,\n+    is_esm: bool,\n+    generate_source_map: bool,\n+    original_source_map: Option<ResolvedVc<OptionStringifiedSourceMap>>,\n+}\n+\n+async fn process_parse_result(\n     parsed: ResolvedVc<ParseResult>,\n     ident: Vc<AssetIdent>,\n     specified_module_type: SpecifiedModuleType,\n-    code_gens: impl IntoIterator<Item = &CodeGeneration>,\n+    code_gens: Vec<CodeGeneration>,\n     generate_source_map: bool,\n     original_source_map: ResolvedVc<OptionStringifiedSourceMap>,\n-) -> Result<Vc<EcmascriptModuleContent>> {\n+) -> Result<CodeGenResult> {\n     let parsed = parsed.final_read_hint().await?;\n \n-    match &*parsed {\n+    Ok(match &*parsed {\n         ParseResult::Ok { .. } => {\n             // We need a mutable version of the AST. We try to avoid cloning it by unwrapping the\n             // ReadRef.\n@@ -978,102 +1014,150 @@ async fn gen_content_with_code_gens(\n                 }\n                 _ => unreachable!(),\n             };\n+            let top_level_mark = eval_context.top_level_mark;\n+            let is_esm = eval_context.is_esm(specified_module_type);\n \n-            process_content_with_code_gens(\n-                &mut program,\n-                globals,\n-                Some(eval_context.top_level_mark),\n-                code_gens,\n-            );\n+            process_content_with_code_gens(&mut program, globals, Some(top_level_mark), code_gens);\n \n-            let mut bytes: Vec<u8> = vec![];\n-            // TODO: Insert this as a sourceless segment so that sourcemaps aren't affected.\n-            // = format!(\"/* {} */\\n\", self.module.path().to_string().await?).into_bytes();\n-\n-            let mut mappings = vec![];\n-\n-            {\n-                let comments = match comments {\n-                    Either::Left(comments) => Either::Left(comments.into_consumable()),\n-                    Either::Right(ref comments) => Either::Right(comments.consumable()),\n-                };\n-                let comments: &dyn Comments = match &comments {\n-                    Either::Left(comments) => comments,\n-                    Either::Right(comments) => comments,\n-                };\n-\n-                let mut emitter = Emitter {\n-                    cfg: swc_core::ecma::codegen::Config::default(),\n-                    cm: source_map.clone(),\n-                    comments: Some(&comments),\n-                    wr: JsWriter::new(\n-                        source_map.clone(),\n-                        \"\\n\",\n-                        &mut bytes,\n-                        generate_source_map.then_some(&mut mappings),\n-                    ),\n-                };\n-\n-                emitter.emit_program(&program)?;\n+            CodeGenResult {\n+                program,\n+                source_map: source_map.clone(),\n+                comments,\n+                is_esm,\n+                generate_source_map,\n+                original_source_map: Some(original_source_map),\n             }\n+        }\n+        ParseResult::Unparseable { messages } => {\n+            let path = ident.path().to_string().await?;\n+            let error_messages = messages\n+                .as_ref()\n+                .and_then(|m| m.first().map(|f| format!(\"\\n{}\", f)))\n+                .unwrap_or(\"\".into());\n+            let msg = format!(\"Could not parse module '{path}'\\n{error_messages}\");\n+            let body = vec![\n+                quote!(\n+                    \"const e = new Error($msg);\" as Stmt,\n+                    msg: Expr = Expr::Lit(msg.into()),\n+                ),\n+                quote!(\"e.code = 'MODULE_UNPARSEABLE';\" as Stmt),\n+                quote!(\"throw e;\" as Stmt),\n+            ];\n \n-            let source_map = if generate_source_map {\n-                Some(generate_js_source_map(\n-                    source_map.clone(),\n-                    mappings,\n-                    original_source_map.await?.as_ref(),\n-                )?)\n-            } else {\n-                None\n-            };\n-\n-            Ok(EcmascriptModuleContent {\n-                inner_code: bytes.into(),\n-                source_map,\n-                is_esm: eval_context.is_esm(specified_module_type),\n+            CodeGenResult {\n+                program: Program::Script(Script {\n+                    span: DUMMY_SP,\n+                    body,\n+                    shebang: None,\n+                }),\n+                source_map: Arc::new(SourceMap::default()),\n+                comments: Either::Left(Default::default()),\n+                is_esm: false,\n+                generate_source_map: false,\n+                original_source_map: None,\n             }\n-            .cell())\n         }\n-        ParseResult::Unparseable { messages } => Ok(EcmascriptModuleContent {\n-            inner_code: format!(\n-                \"const e = new Error(`Could not parse module \\\n-                 '{path}'\\n{error_messages}`);\\ne.code = 'MODULE_UNPARSEABLE';\\nthrow e;\",\n-                path = ident.path().to_string().await?,\n-                error_messages = messages\n-                    .as_ref()\n-                    .and_then(|m| { m.first().map(|f| format!(\"\\n{}\", f)) })\n-                    .unwrap_or(\"\".into())\n-            )\n-            .into(),\n-            source_map: None,\n-            is_esm: false,\n+        ParseResult::NotFound => {\n+            let path = ident.path().to_string().await?;\n+            let msg = format!(\"Could not parse module '{path}'\");\n+            let body = vec![\n+                quote!(\n+                    \"const e = new Error($msg);\" as Stmt,\n+                    msg: Expr = Expr::Lit(msg.into()),\n+                ),\n+                quote!(\"e.code = 'MODULE_UNPARSEABLE';\" as Stmt),\n+                quote!(\"throw e;\" as Stmt),\n+            ];\n+            CodeGenResult {\n+                program: Program::Script(Script {\n+                    span: DUMMY_SP,\n+                    body,\n+                    shebang: None,\n+                }),\n+                source_map: Arc::new(SourceMap::default()),\n+                comments: Either::Left(Default::default()),\n+                is_esm: false,\n+                generate_source_map: false,\n+                original_source_map: None,\n+            }\n         }\n-        .cell()),\n-        ParseResult::NotFound => Ok(EcmascriptModuleContent {\n-            inner_code: format!(\n-                \"const e = new Error(\\\"Could not parse module '{path}'\\\");\\ne.code = \\\n-                 'MODULE_UNPARSEABLE';\\nthrow e;\",\n-                path = ident.path().to_string().await?\n-            )\n-            .into(),\n-            source_map: None,\n-            is_esm: false,\n+    })\n+}\n+\n+async fn emit_content(content: CodeGenResult) -> Result<Vc<EcmascriptModuleContent>> {\n+    let CodeGenResult {\n+        program,\n+        source_map,\n+        comments,\n+        is_esm,\n+        generate_source_map,\n+        original_source_map,\n+    } = content;\n+\n+    let mut bytes: Vec<u8> = vec![];\n+    // TODO: Insert this as a sourceless segment so that sourcemaps aren't affected.\n+    // = format!(\"/* {} */\\n\", self.module.path().to_string().await?).into_bytes();\n+\n+    let mut mappings = vec![];\n+\n+    {\n+        let comments = match comments {\n+            Either::Left(comments) => Either::Left(comments.into_consumable()),\n+            Either::Right(ref comments) => Either::Right(comments.consumable()),\n+        };\n+        let comments: &dyn Comments = match &comments {\n+            Either::Left(comments) => comments,\n+            Either::Right(comments) => comments,\n+        };\n+\n+        let mut emitter = Emitter {\n+            cfg: swc_core::ecma::codegen::Config::default(),\n+            cm: source_map.clone(),\n+            comments: Some(&comments),\n+            wr: JsWriter::new(\n+                source_map.clone(),\n+                \"\\n\",\n+                &mut bytes,\n+                generate_source_map.then_some(&mut mappings),\n+            ),\n+        };\n+\n+        emitter.emit_program(&program)?;\n+    }\n+\n+    let source_map = if generate_source_map {\n+        if let Some(original_source_map) = original_source_map {\n+            Some(generate_js_source_map(\n+                source_map.clone(),\n+                mappings,\n+                original_source_map.await?.as_ref(),\n+            )?)\n+        } else {\n+            Some(generate_js_source_map(source_map.clone(), mappings, None)?)\n         }\n-        .cell()),\n+    } else {\n+        None\n+    };\n+\n+    Ok(EcmascriptModuleContent {\n+        inner_code: bytes.into(),\n+        source_map,\n+        is_esm,\n     }\n+    .cell())\n }\n \n-fn process_content_with_code_gens<'a>(\n+fn process_content_with_code_gens(\n     program: &mut Program,\n     globals: &Globals,\n     top_level_mark: Option<Mark>,\n-    code_gens: impl IntoIterator<Item = &'a CodeGeneration>,\n+    code_gens: Vec<CodeGeneration>,\n ) {\n     let mut visitors = Vec::new();\n     let mut root_visitors = Vec::new();\n     let mut early_hoisted_stmts = FxIndexMap::default();\n     let mut hoisted_stmts = FxIndexMap::default();\n-    for code_gen in code_gens {\n+    for code_gen in &code_gens {\n         for CodeGenerationHoistedStmt { key, stmt } in &code_gen.hoisted_stmts {\n             hoisted_stmts.entry(key.clone()).or_insert(stmt.clone());\n         }"
        },
        {
            "sha": "cfba0f016c8845ad78e537957486c67b0c650d3f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/facade/module.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 20,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fmodule.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fmodule.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Ffacade%2Fmodule.rs?ref=37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734",
            "patch": "@@ -204,32 +204,31 @@ impl EcmascriptAnalyzable for EcmascriptModuleFacadeModule {\n     }\n \n     #[turbo_tasks::function]\n-    async fn module_content(\n+    async fn module_content_options(\n         self: Vc<Self>,\n         module_graph: ResolvedVc<ModuleGraph>,\n         chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n         async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n-    ) -> Result<Vc<EcmascriptModuleContent>> {\n+    ) -> Result<Vc<EcmascriptModuleContentOptions>> {\n         let (esm_references, part_references) = self.await?.specific_references().await?;\n \n-        Ok(EcmascriptModuleContent::new(\n-            EcmascriptModuleContentOptions {\n-                parsed: ParseResult::empty().to_resolved().await?,\n-                ident: self.ident().to_resolved().await?,\n-                specified_module_type: SpecifiedModuleType::EcmaScript,\n-                module_graph,\n-                chunking_context,\n-                references: self.references().to_resolved().await?,\n-                esm_references,\n-                part_references,\n-                code_generation: CodeGens::empty().to_resolved().await?,\n-                async_module: ResolvedVc::cell(Some(self.async_module().to_resolved().await?)),\n-                generate_source_map: false,\n-                original_source_map: OptionStringifiedSourceMap::none().to_resolved().await?,\n-                exports: self.get_exports().to_resolved().await?,\n-                async_module_info,\n-            },\n-        ))\n+        Ok(EcmascriptModuleContentOptions {\n+            parsed: ParseResult::empty().to_resolved().await?,\n+            ident: self.ident().to_resolved().await?,\n+            specified_module_type: SpecifiedModuleType::EcmaScript,\n+            module_graph,\n+            chunking_context,\n+            references: self.references().to_resolved().await?,\n+            esm_references,\n+            part_references,\n+            code_generation: CodeGens::empty().to_resolved().await?,\n+            async_module: ResolvedVc::cell(Some(self.async_module().to_resolved().await?)),\n+            generate_source_map: false,\n+            original_source_map: OptionStringifiedSourceMap::none().to_resolved().await?,\n+            exports: self.get_exports().to_resolved().await?,\n+            async_module_info,\n+        }\n+        .cell())\n     }\n }\n "
        },
        {
            "sha": "2ec94499f194136109862ebed1d4d8f62bef32a0",
            "filename": "turbopack/crates/turbopack-ecmascript/src/side_effect_optimization/locals/module.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 20,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fmodule.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fmodule.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fside_effect_optimization%2Flocals%2Fmodule.rs?ref=37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734",
            "patch": "@@ -92,12 +92,12 @@ impl EcmascriptAnalyzable for EcmascriptModuleLocalsModule {\n     }\n \n     #[turbo_tasks::function]\n-    async fn module_content(\n+    async fn module_content_options(\n         self: Vc<Self>,\n         module_graph: ResolvedVc<ModuleGraph>,\n         chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n         async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n-    ) -> Result<Vc<EcmascriptModuleContent>> {\n+    ) -> Result<Vc<EcmascriptModuleContentOptions>> {\n         let exports = self.get_exports().to_resolved().await?;\n         let original_module = self.await?.module;\n         let parsed = original_module.parse().to_resolved().await?;\n@@ -110,24 +110,23 @@ impl EcmascriptAnalyzable for EcmascriptModuleLocalsModule {\n             .reference_module_source_maps(Vc::upcast(self))\n             .await?;\n \n-        Ok(EcmascriptModuleContent::new(\n-            EcmascriptModuleContentOptions {\n-                parsed,\n-                ident: self.ident().to_resolved().await?,\n-                specified_module_type: module_type_result.module_type,\n-                module_graph,\n-                chunking_context,\n-                references: analyze.local_references().to_resolved().await?,\n-                esm_references: analyze_result.esm_local_references,\n-                part_references: vec![],\n-                code_generation: analyze_result.code_generation,\n-                async_module: analyze_result.async_module,\n-                generate_source_map,\n-                original_source_map: analyze_result.source_map,\n-                exports,\n-                async_module_info,\n-            },\n-        ))\n+        Ok(EcmascriptModuleContentOptions {\n+            parsed,\n+            ident: self.ident().to_resolved().await?,\n+            specified_module_type: module_type_result.module_type,\n+            module_graph,\n+            chunking_context,\n+            references: analyze.local_references().to_resolved().await?,\n+            esm_references: analyze_result.esm_local_references,\n+            part_references: vec![],\n+            code_generation: analyze_result.code_generation,\n+            async_module: analyze_result.async_module,\n+            generate_source_map,\n+            original_source_map: analyze_result.source_map,\n+            exports,\n+            async_module_info,\n+        }\n+        .cell())\n     }\n }\n "
        },
        {
            "sha": "49926328c9b59b132fc0d8c2463cf2496c72bbbf",
            "filename": "turbopack/crates/turbopack-ecmascript/src/tree_shake/asset.rs",
            "status": "modified",
            "additions": 19,
            "deletions": 20,
            "changes": 39,
            "blob_url": "https://github.com/vercel/next.js/blob/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Ftree_shake%2Fasset.rs?ref=37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734",
            "patch": "@@ -75,12 +75,12 @@ impl EcmascriptAnalyzable for EcmascriptModulePartAsset {\n     }\n \n     #[turbo_tasks::function]\n-    async fn module_content(\n+    async fn module_content_options(\n         self: Vc<Self>,\n         module_graph: ResolvedVc<ModuleGraph>,\n         chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n         async_module_info: Option<ResolvedVc<AsyncModuleInfo>>,\n-    ) -> Result<Vc<EcmascriptModuleContent>> {\n+    ) -> Result<Vc<EcmascriptModuleContentOptions>> {\n         let module = self.await?;\n \n         let split_data = split_module(*module.full_module);\n@@ -96,24 +96,23 @@ impl EcmascriptAnalyzable for EcmascriptModulePartAsset {\n             .reference_module_source_maps(Vc::upcast(self))\n             .await?;\n \n-        Ok(EcmascriptModuleContent::new(\n-            EcmascriptModuleContentOptions {\n-                parsed,\n-                ident: self.ident().to_resolved().await?,\n-                specified_module_type: module_type_result.module_type,\n-                module_graph,\n-                chunking_context,\n-                references: analyze.references().to_resolved().await?,\n-                esm_references: analyze_ref.esm_references,\n-                part_references: vec![],\n-                code_generation: analyze_ref.code_generation,\n-                async_module: analyze_ref.async_module,\n-                generate_source_map,\n-                original_source_map: analyze_ref.source_map,\n-                exports: analyze_ref.exports,\n-                async_module_info,\n-            },\n-        ))\n+        Ok(EcmascriptModuleContentOptions {\n+            parsed,\n+            ident: self.ident().to_resolved().await?,\n+            specified_module_type: module_type_result.module_type,\n+            module_graph,\n+            chunking_context,\n+            references: analyze.references().to_resolved().await?,\n+            esm_references: analyze_ref.esm_references,\n+            part_references: vec![],\n+            code_generation: analyze_ref.code_generation,\n+            async_module: analyze_ref.async_module,\n+            generate_source_map,\n+            original_source_map: analyze_ref.source_map,\n+            exports: analyze_ref.exports,\n+            async_module_info,\n+        }\n+        .cell())\n     }\n }\n "
        },
        {
            "sha": "d05b155eade169fe676fe3bbb80732365ce47322",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/comptime/unreachable/output/4e721_crates_turbopack-tests_tests_snapshot_comptime_unreachable_input_index_9022a405.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcomptime%2Funreachable%2Foutput%2F4e721_crates_turbopack-tests_tests_snapshot_comptime_unreachable_input_index_9022a405.js",
            "raw_url": "https://github.com/vercel/next.js/raw/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcomptime%2Funreachable%2Foutput%2F4e721_crates_turbopack-tests_tests_snapshot_comptime_unreachable_input_index_9022a405.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fcomptime%2Funreachable%2Foutput%2F4e721_crates_turbopack-tests_tests_snapshot_comptime_unreachable_input_index_9022a405.js?ref=37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734",
            "patch": "@@ -6,5 +6,6 @@ var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n {\n const e = new Error(\"Could not parse module '[project]/turbopack/crates/turbopack-tests/tests/snapshot/comptime/unreachable/input/index.js'\");\n e.code = 'MODULE_UNPARSEABLE';\n-throw e;}}),\n+throw e;\n+}}),\n }]);\n\\ No newline at end of file"
        },
        {
            "sha": "eb931df0dc0a65704344900d374e6183ce012f0a",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/mdx/error/output/turbopack_crates_turbopack-tests_tests_snapshot_mdx_error_input_index_e6acdd0c.js",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fmdx%2Ferror%2Foutput%2Fturbopack_crates_turbopack-tests_tests_snapshot_mdx_error_input_index_e6acdd0c.js",
            "raw_url": "https://github.com/vercel/next.js/raw/37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fmdx%2Ferror%2Foutput%2Fturbopack_crates_turbopack-tests_tests_snapshot_mdx_error_input_index_e6acdd0c.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fmdx%2Ferror%2Foutput%2Fturbopack_crates_turbopack-tests_tests_snapshot_mdx_error_input_index_e6acdd0c.js?ref=37c97d699f0d8ec97f4eae6cf0cfa3fa446ec734",
            "patch": "@@ -6,5 +6,6 @@ var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;\n {\n const e = new Error(\"Could not parse module '[project]/turbopack/crates/turbopack-tests/tests/snapshot/mdx/error/input/index.js'\");\n e.code = 'MODULE_UNPARSEABLE';\n-throw e;}}),\n+throw e;\n+}}),\n }]);\n\\ No newline at end of file"
        }
    ],
    "stats": {
        "total": 498,
        "additions": 292,
        "deletions": 206
    }
}