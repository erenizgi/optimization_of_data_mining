{
    "author": "bgw",
    "message": "[devtools] Add an endpoint to poll for server status (#80005)\n\nAfter the server restarts, the frontend needs some way to determine when the server is back up. This provides an endpoint that can be polled.\n\n## Test Plan\n\nTested by running\n\n```\ncurl -v http://localhost:3000/__nextjs_server_status\n```\n\na few times and noticing the `executionId` is stable.\n\nRestart the server with\n\n```\ncurl -v --request POST --header \"Content-Type: application/json\" --data '{}' http://localhost:3000/__nextjs_restart_dev\n```\n\nand notice that the `executionId` change next time I poll `/__nextjs_server_status`.\n\n## Explanation for the `executionId`\n\n**Note:** The feedback was that we don't really need to handle this yet, but most of the complexity is in handling this on the frontend. It's only 3 lines of code and some comments on the backend to return a random value. So this implements it, but it's up to frontend if it wants to use the `executionId` or not.\n\n> I'm trying to work out the polling endpoint to see when the server is back up. Maybe I'm overthinking this, but I'm a bit concerned about a race condition:\n>\n> * You send the request to shut down the server. You can't reliably wait for it to complete because the exiting server might cause the request to hang (though typically on a sane machine it should close the TCP connection).\n> * The shut down request is actually still processing but it's super slow for some reason (e.g. it's sending telemetry).\n> * Assuming it's hanging, after a second you start sending requests to the polling endpoint to see when the server is back up.\n> * The server hasn't actually shut down yet, but you think it's back up, so you refresh the page too early.\n>\n> So my thought is we need some identifier of the current executing dev server returned by the poll endpoint that changes upon restart, like a nonce. This could be a timestamp of the server startup or just a large random number that's cached in-memory by the server.\n>\n> So then how do we pass that to the client? We probably don't want to do that using the bundler define plugin, as it would change on every startup and might unnecessarily invalidate caches (assuming you're not deleting the persistent cache anyways). So I'm thinking the restart flow could be:\n>\n> 1. We call the poll endpoint to get the nonce / execution id. We await this fetch.\n> 2. Once we have the nonce, we call the restart endpoint without awaiting it (under the assumption it could hang).\n> 3. We poll the endpoint and only restart once we get a response with a different nonce / execution id value.\n>\n> That's a little ugly because now it's two requests to initiate the restart, but the poll endpoint should be really quick and it's to localhost, so there's not much added latency.",
    "sha": "8d7eaae6a5af58cbb8b82310ff0d56ac2329f71b",
    "files": [
        {
            "sha": "4421eebbafe7650172e7b5f4f15e858cd8f4b6bc",
            "filename": "packages/next/src/client/components/react-dev-overlay/server/restart-dev-server-middleware.ts",
            "status": "modified",
            "additions": 42,
            "deletions": 6,
            "changes": 48,
            "blob_url": "https://github.com/vercel/next.js/blob/8d7eaae6a5af58cbb8b82310ff0d56ac2329f71b/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Freact-dev-overlay%2Fserver%2Frestart-dev-server-middleware.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/8d7eaae6a5af58cbb8b82310ff0d56ac2329f71b/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Freact-dev-overlay%2Fserver%2Frestart-dev-server-middleware.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Freact-dev-overlay%2Fserver%2Frestart-dev-server-middleware.ts?ref=8d7eaae6a5af58cbb8b82310ff0d56ac2329f71b",
            "patch": "@@ -15,14 +15,23 @@ export function getRestartDevServerMiddleware({\n   telemetry,\n   turbopackProject,\n }: RestartDevServerMiddlewareConfig) {\n-  return async function (\n+  /**\n+   * Some random value between 1 and Number.MAX_SAFE_INTEGER (inclusive). The same value is returned\n+   * on every call to `__nextjs_server_status` until the server is restarted.\n+   *\n+   * Can be used to determine if two server status responses are from the same process or a\n+   * different (restarted) process.\n+   */\n+  const executionId: number =\n+    Math.floor(Math.random() * Number.MAX_SAFE_INTEGER) + 1\n+\n+  async function handleRestartRequest(\n     req: IncomingMessage,\n     res: ServerResponse,\n-    next: () => void\n-  ): Promise<void> {\n-    const { pathname, searchParams } = new URL(`http://n${req.url}`)\n-    if (pathname !== '/__nextjs_restart_dev' || req.method !== 'POST') {\n-      return next()\n+    searchParams: URLSearchParams\n+  ) {\n+    if (req.method !== 'POST') {\n+      return middlewareResponse.methodNotAllowed(res)\n     }\n \n     const invalidatePersistentCache = searchParams.has(\n@@ -48,4 +57,31 @@ export function getRestartDevServerMiddleware({\n \n     return middlewareResponse.noContent(res)\n   }\n+\n+  async function handleServerStatus(req: IncomingMessage, res: ServerResponse) {\n+    if (req.method !== 'GET') {\n+      return middlewareResponse.methodNotAllowed(res)\n+    }\n+\n+    return middlewareResponse.json(res, {\n+      executionId,\n+    })\n+  }\n+\n+  return async function (\n+    req: IncomingMessage,\n+    res: ServerResponse,\n+    next: () => void\n+  ): Promise<void> {\n+    const { pathname, searchParams } = new URL(`http://n${req.url}`)\n+\n+    switch (pathname) {\n+      case '/__nextjs_restart_dev':\n+        return await handleRestartRequest(req, res, searchParams)\n+      case '/__nextjs_server_status':\n+        return await handleServerStatus(req, res)\n+      default:\n+        return next()\n+    }\n+  }\n }"
        }
    ],
    "stats": {
        "total": 48,
        "additions": 42,
        "deletions": 6
    }
}