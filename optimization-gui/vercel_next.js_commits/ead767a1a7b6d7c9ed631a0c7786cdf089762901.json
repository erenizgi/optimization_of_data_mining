{
    "author": "sokra",
    "message": "Turbopack: avoid panics due to eventual consistency (#79242)\n\n### What?\n\nAvoid panics in favor of bails as this might happen due to eventual consistency.",
    "sha": "ead767a1a7b6d7c9ed631a0c7786cdf089762901",
    "files": [
        {
            "sha": "396a7c91f4817b2963ab419dfeff0fb65efed9f1",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 49,
            "deletions": 25,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/ead767a1a7b6d7c9ed631a0c7786cdf089762901/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ead767a1a7b6d7c9ed631a0c7786cdf089762901/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=ead767a1a7b6d7c9ed631a0c7786cdf089762901",
            "patch": "@@ -3,7 +3,7 @@ use std::{\n     ops::{Deref, DerefMut},\n };\n \n-use anyhow::{Result, bail};\n+use anyhow::{Context, Result, bail};\n use either::Either;\n use indexmap::map::Entry;\n use roaring::RoaringBitmap;\n@@ -365,15 +365,17 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                     entries.iter().flat_map(|e| e.entries()),\n                     |parent, node| {\n                         if let Some((parent, _)) = parent {\n-                            let parent_depth = *module_depth.get(&parent.module).unwrap();\n+                            let parent_depth = *module_depth\n+                                .get(&parent.module)\n+                                .context(\"Module depth not found\")?;\n                             module_depth.entry(node.module).or_insert(parent_depth + 1);\n                         } else {\n                             module_depth.insert(node.module, 0);\n                         };\n \n                         module_chunk_groups.insert(node.module, RoaringBitmapWrapper::default());\n \n-                        GraphTraversalAction::Continue\n+                        Ok(GraphTraversalAction::Continue)\n                     },\n                 )\n                 .await?;\n@@ -446,23 +448,27 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n \n         let visit_count = graph\n             .traverse_edges_fixed_point_with_priority(\n-                entries.iter().flat_map(|e| e.entries()).map(|e| {\n-                    (\n-                        e,\n-                        TraversalPriority {\n-                            depth: *module_depth.get(&e).unwrap(),\n-                            chunk_group_len: 0,\n-                        },\n-                    )\n-                }),\n+                entries\n+                    .iter()\n+                    .flat_map(|e| e.entries())\n+                    .map(|e| {\n+                        Ok((\n+                            e,\n+                            TraversalPriority {\n+                                depth: *module_depth.get(&e).context(\"Module depth not found\")?,\n+                                chunk_group_len: 0,\n+                            },\n+                        ))\n+                    })\n+                    .collect::<Result<Vec<_>>>()?,\n                 &mut module_chunk_groups,\n                 |parent_info: Option<(&'_ SingleModuleGraphModuleNode, &'_ ChunkingType)>,\n                  node: &'_ SingleModuleGraphModuleNode,\n                  module_chunk_groups: &mut FxHashMap<\n                     ResolvedVc<Box<dyn Module>>,\n                     RoaringBitmapWrapper,\n                 >|\n-                 -> GraphTraversalAction {\n+                 -> Result<GraphTraversalAction> {\n                     enum ChunkGroupInheritance<It: Iterator<Item = ChunkGroupKey>> {\n                         Inherit(ResolvedVc<Box<dyn Module>>),\n                         ChunkGroup(It),\n@@ -489,7 +495,9 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                                 merge_tag: Some(merge_tag),\n                                 ..\n                             } => {\n-                                let parents = module_chunk_groups.get(&parent.module).unwrap();\n+                                let parents = module_chunk_groups\n+                                    .get(&parent.module)\n+                                    .context(\"Module chunk group not found\")?;\n                                 let chunk_groups =\n                                     parents.iter().map(|parent| ChunkGroupKey::IsolatedMerged {\n                                         parent: ChunkGroupId(parent),\n@@ -503,7 +511,9 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                                 merge_tag: Some(merge_tag),\n                                 ..\n                             } => {\n-                                let parents = module_chunk_groups.get(&parent.module).unwrap();\n+                                let parents = module_chunk_groups\n+                                    .get(&parent.module)\n+                                    .context(\"Module chunk group not found\")?;\n                                 let chunk_groups =\n                                     parents.iter().map(|parent| ChunkGroupKey::SharedMerged {\n                                         parent: ChunkGroupId(parent),\n@@ -515,16 +525,20 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                             }\n                             ChunkingType::Traced => {\n                                 // Traced modules are not placed in chunk groups\n-                                return GraphTraversalAction::Skip;\n+                                return Ok(GraphTraversalAction::Skip);\n                             }\n                         }\n                     } else {\n                         ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n-                            entry_chunk_group_keys.get(&node.module).unwrap().clone(),\n+                            // TODO remove clone\n+                            entry_chunk_group_keys\n+                                .get(&node.module)\n+                                .context(\"Module chunk group not found\")?\n+                                .clone(),\n                         )))\n                     };\n \n-                    match chunk_groups {\n+                    Ok(match chunk_groups {\n                         ChunkGroupInheritance::ChunkGroup(chunk_groups) => {\n                             // Start of a new chunk group, don't inherit anything from parent\n                             let chunk_group_ids = chunk_groups.map(|chunk_group| {\n@@ -558,7 +572,9 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                                 RoaringBitmapWrapper(RoaringBitmap::from_iter(chunk_group_ids));\n \n                             // Assign chunk group to the target node (the entry of the chunk group)\n-                            let bitset = module_chunk_groups.get_mut(&node.module).unwrap();\n+                            let bitset = module_chunk_groups\n+                                .get_mut(&node.module)\n+                                .context(\"Module chunk group not found\")?;\n                             if chunk_groups.is_proper_superset(bitset) {\n                                 // Add bits from parent, and continue traversal because changed\n                                 **bitset |= chunk_groups.into_inner();\n@@ -577,12 +593,13 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                                 // A self-reference\n                                 GraphTraversalAction::Skip\n                             } else {\n-                                // Fast path\n                                 let [Some(parent_chunk_groups), Some(current_chunk_groups)] =\n                                     module_chunk_groups.get_disjoint_mut([&parent, &node.module])\n                                 else {\n                                     // All modules are inserted in the previous iteration\n-                                    unreachable!()\n+                                    // Technically unreachable, but could be reached due to eventual\n+                                    // consistency\n+                                    bail!(\"Module chunk groups not found\");\n                                 };\n \n                                 if current_chunk_groups.is_empty() {\n@@ -601,7 +618,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                                 }\n                             }\n                         }\n-                    }\n+                    })\n                 },\n                 // This priority is used as a heuristic to keep the number of retraversals down, by\n                 // - keeping it similar to a BFS via the depth priority\n@@ -610,9 +627,16 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n                 //\n                 // Both try to first visit modules with a large dependency subgraph first (which\n                 // would be higher in the graph and are included by few chunks themselves).\n-                |successor, module_chunk_groups| TraversalPriority {\n-                    depth: *module_depth.get(&successor.module).unwrap(),\n-                    chunk_group_len: module_chunk_groups.get(&successor.module).unwrap().len(),\n+                |successor, module_chunk_groups| {\n+                    Ok(TraversalPriority {\n+                        depth: *module_depth\n+                            .get(&successor.module)\n+                            .context(\"Module depth not found\")?,\n+                        chunk_group_len: module_chunk_groups\n+                            .get(&successor.module)\n+                            .context(\"Module chunk group not found\")?\n+                            .len(),\n+                    })\n                 },\n             )\n             .await?;"
        },
        {
            "sha": "b7aee6ce40b9e088c18494394f2a3449ceee9b18",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/ead767a1a7b6d7c9ed631a0c7786cdf089762901/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ead767a1a7b6d7c9ed631a0c7786cdf089762901/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=ead767a1a7b6d7c9ed631a0c7786cdf089762901",
            "patch": "@@ -920,7 +920,7 @@ impl ModuleGraph {\n         mut visitor: impl FnMut(\n             Option<(&'_ SingleModuleGraphModuleNode, &'_ ChunkingType)>,\n             &'_ SingleModuleGraphModuleNode,\n-        ) -> GraphTraversalAction,\n+        ) -> Result<GraphTraversalAction>,\n     ) -> Result<()> {\n         let graphs = self.get_graphs().await?;\n \n@@ -933,7 +933,7 @@ impl ModuleGraph {\n         );\n         let mut visited = HashSet::new();\n         for entry_node in &queue {\n-            visitor(None, get_node!(graphs, entry_node)?);\n+            visitor(None, get_node!(graphs, entry_node)?)?;\n         }\n         while let Some(node) = queue.pop_front() {\n             let graph = &graphs[node.graph_idx].graph;\n@@ -948,7 +948,7 @@ impl ModuleGraph {\n                     };\n                     let succ_weight = get_node!(graphs, succ)?;\n                     let edge_weight = graph.edge_weight(edge).unwrap();\n-                    let action = visitor(Some((node_weight, edge_weight)), succ_weight);\n+                    let action = visitor(Some((node_weight, edge_weight)), succ_weight)?;\n                     if !visited.contains(&succ) && action == GraphTraversalAction::Continue {\n                         queue.push_back(succ);\n                     }\n@@ -1197,8 +1197,8 @@ impl ModuleGraph {\n             Option<(&'_ SingleModuleGraphModuleNode, &'_ ChunkingType)>,\n             &'_ SingleModuleGraphModuleNode,\n             &mut S,\n-        ) -> GraphTraversalAction,\n-        priority: impl Fn(&'_ SingleModuleGraphModuleNode, &mut S) -> P,\n+        ) -> Result<GraphTraversalAction>,\n+        priority: impl Fn(&'_ SingleModuleGraphModuleNode, &mut S) -> Result<P>,\n     ) -> Result<usize> {\n         let graphs = self.get_graphs().await?;\n \n@@ -1237,7 +1237,7 @@ impl ModuleGraph {\n                 .await?,\n         );\n         for entry_node in &queue {\n-            visit(None, get_node!(graphs, entry_node.node)?, state);\n+            visit(None, get_node!(graphs, entry_node.node)?, state)?;\n         }\n \n         let mut visit_count = 0usize;\n@@ -1256,12 +1256,12 @@ impl ModuleGraph {\n                 };\n                 let (succ_weight, succ) = get_node_idx!(graphs, succ)?;\n                 let edge_weight = graph.edge_weight(edge).unwrap();\n-                let action = visit(Some((node_weight, edge_weight)), succ_weight, state);\n+                let action = visit(Some((node_weight, edge_weight)), succ_weight, state)?;\n \n                 if action == GraphTraversalAction::Continue && queue_set.insert(succ) {\n                     queue.push(NodeWithPriority {\n                         node: succ,\n-                        priority: priority(succ_weight, state),\n+                        priority: priority(succ_weight, state)?,\n                     });\n                 }\n             }"
        }
    ],
    "stats": {
        "total": 90,
        "additions": 57,
        "deletions": 33
    }
}