{
    "author": "sokra",
    "message": "Turbopack: compute ordered entries in module batches (#77294)\n\n### What?\n\nWhen computing the module batches, also compute the correct postorder of isolated and shared chunk groups",
    "sha": "ace4574ca9582aab12a47cb40587a24846c72e1c",
    "files": [
        {
            "sha": "80ab89b0cb45f2474ff019789d95f42ead0a59a6",
            "filename": "turbopack/crates/turbopack-core/src/chunk/mod.rs",
            "status": "modified",
            "additions": 25,
            "deletions": 16,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/ace4574ca9582aab12a47cb40587a24846c72e1c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ace4574ca9582aab12a47cb40587a24846c72e1c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fchunk%2Fmod.rs?ref=ace4574ca9582aab12a47cb40587a24846c72e1c",
            "patch": "@@ -205,25 +205,34 @@ pub enum ChunkingType {\n \n impl ChunkingType {\n     pub fn is_inherit_async(&self) -> bool {\n-        match self {\n-            ChunkingType::Parallel => false,\n-            ChunkingType::ParallelInheritAsync => true,\n-            ChunkingType::Async => false,\n-            ChunkingType::Isolated { .. } => false,\n-            ChunkingType::Shared { inherit_async, .. } => *inherit_async,\n-            ChunkingType::Traced => false,\n-        }\n+        matches!(\n+            self,\n+            ChunkingType::ParallelInheritAsync\n+                | ChunkingType::Shared {\n+                    inherit_async: true,\n+                    ..\n+                }\n+        )\n     }\n \n     pub fn is_parallel(&self) -> bool {\n-        match self {\n-            ChunkingType::Parallel => true,\n-            ChunkingType::ParallelInheritAsync => true,\n-            ChunkingType::Async => false,\n-            ChunkingType::Isolated { .. } => false,\n-            ChunkingType::Shared { .. } => false,\n-            ChunkingType::Traced => false,\n-        }\n+        matches!(\n+            self,\n+            ChunkingType::Parallel | ChunkingType::ParallelInheritAsync\n+        )\n+    }\n+\n+    pub fn is_merged(&self) -> bool {\n+        matches!(\n+            self,\n+            ChunkingType::Isolated {\n+                merge_tag: Some(_),\n+                ..\n+            } | ChunkingType::Shared {\n+                merge_tag: Some(_),\n+                ..\n+            }\n+        )\n     }\n \n     pub fn without_inherit_async(&self) -> Self {"
        },
        {
            "sha": "b76b0e3ae984e3777714c77ff55475030833a4e5",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 33,
            "deletions": 2,
            "changes": 35,
            "blob_url": "https://github.com/vercel/next.js/blob/ace4574ca9582aab12a47cb40587a24846c72e1c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ace4574ca9582aab12a47cb40587a24846c72e1c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=ace4574ca9582aab12a47cb40587a24846c72e1c",
            "patch": "@@ -88,6 +88,8 @@ pub struct ChunkGroupInfo {\n     pub module_chunk_groups: FxHashMap<ResolvedVc<Box<dyn Module>>, RoaringBitmapWrapper>,\n     #[turbo_tasks(trace_ignore)]\n     pub chunk_groups: FxIndexSet<ChunkGroup>,\n+    #[turbo_tasks(trace_ignore)]\n+    pub chunk_group_keys: FxIndexSet<ChunkGroupKey>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -174,6 +176,19 @@ pub enum ChunkGroup {\n }\n \n impl ChunkGroup {\n+    /// Returns the parent group when this chunk group is a merged group. In that case `entries()`\n+    /// are in unspecified order.\n+    pub fn get_merged_parent(&self) -> Option<usize> {\n+        match self {\n+            ChunkGroup::IsolatedMerged { parent, .. } | ChunkGroup::SharedMerged { parent, .. } => {\n+                Some(*parent)\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// Iterates over the entries of the chunk group. When `get_merged_parent` is Some, the order is\n+    /// unspecified.\n     pub fn entries(&self) -> impl Iterator<Item = ResolvedVc<Box<dyn Module>>> + Clone + '_ {\n         match self {\n             ChunkGroup::Async(e) | ChunkGroup::Isolated(e) | ChunkGroup::Shared(e) => {\n@@ -185,6 +200,15 @@ impl ChunkGroup {\n         }\n     }\n \n+    pub fn entries_count(&self) -> usize {\n+        match self {\n+            ChunkGroup::Async(_) | ChunkGroup::Isolated(_) | ChunkGroup::Shared(_) => 1,\n+            ChunkGroup::Entry(entries)\n+            | ChunkGroup::IsolatedMerged { entries, .. }\n+            | ChunkGroup::SharedMerged { entries, .. } => entries.len(),\n+        }\n+    }\n+\n     pub async fn debug_str(&self, chunk_group_info: &ChunkGroupInfo) -> Result<String> {\n         Ok(match self {\n             ChunkGroup::Entry(entries) => format!(\n@@ -245,8 +269,8 @@ impl ChunkGroup {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-enum ChunkGroupKey {\n+#[derive(Debug, Clone, Hash, PartialEq, Eq, Serialize, Deserialize)]\n+pub enum ChunkGroupKey {\n     /// e.g. a page\n     Entry(Vec<ResolvedVc<Box<dyn Module>>>),\n     /// a module with an incoming async edge\n@@ -270,6 +294,12 @@ enum ChunkGroupKey {\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\n pub struct ChunkGroupId(u32);\n \n+impl From<usize> for ChunkGroupId {\n+    fn from(id: usize) -> Self {\n+        Self(id as u32)\n+    }\n+}\n+\n impl Deref for ChunkGroupId {\n     type Target = u32;\n     fn deref(&self) -> &Self::Target {\n@@ -621,6 +651,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraph) -> Result<Vc<ChunkGro\n \n         Ok(ChunkGroupInfo {\n             module_chunk_groups,\n+            chunk_group_keys: chunk_groups_map.keys().cloned().collect(),\n             chunk_groups: chunk_groups_map\n                 .into_iter()\n                 .map(|(k, (_, merged_entries))| match k {"
        },
        {
            "sha": "2596f364bf63819c890808a7ec7767ab14e08ba4",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/module_batches.rs",
            "status": "modified",
            "additions": 114,
            "deletions": 1,
            "changes": 115,
            "blob_url": "https://github.com/vercel/next.js/blob/ace4574ca9582aab12a47cb40587a24846c72e1c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/ace4574ca9582aab12a47cb40587a24846c72e1c/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs?ref=ace4574ca9582aab12a47cb40587a24846c72e1c",
            "patch": "@@ -20,7 +20,7 @@ use crate::{\n     chunk::{ChunkableModule, ChunkingType},\n     module::Module,\n     module_graph::{\n-        chunk_group_info::{ChunkGroupInfo, RoaringBitmapWrapper},\n+        chunk_group_info::{ChunkGroupInfo, ChunkGroupKey, RoaringBitmapWrapper},\n         module_batch::{ModuleBatch, ModuleBatchGroup, ModuleOrBatch},\n         traced_di_graph::{iter_neighbors_rev, TracedDiGraph},\n         GraphTraversalAction, ModuleGraph,\n@@ -48,6 +48,8 @@ pub struct ModuleBatchesGraphEdge {\n     pub module: Option<ResolvedVc<Box<dyn Module>>>,\n }\n \n+type EntriesList = FxIndexSet<ResolvedVc<Box<dyn Module>>>;\n+\n #[turbo_tasks::value(cell = \"new\", eq = \"manual\", into = \"new\")]\n pub struct ModuleBatchesGraph {\n     graph: TracedDiGraph<ModuleOrBatch, ModuleBatchesGraphEdge>,\n@@ -61,6 +63,12 @@ pub struct ModuleBatchesGraph {\n     #[turbo_tasks(trace_ignore)]\n     entries: FxHashMap<ResolvedVc<Box<dyn Module>>, NodeIndex>,\n     batch_groups: FxHashMap<ModuleOrBatch, ResolvedVc<ModuleBatchGroup>>,\n+\n+    /// For chunk groups where the postorder of entries is different than the order of the\n+    /// `ChunkGroup::entries()` this contains Some with the postorder list of entries of that chunk\n+    /// group. The index in this list corresponds to the index in the\n+    /// chunk_group_info.chunk_groups.\n+    ordered_entries: Vec<Option<EntriesList>>,\n }\n \n impl ModuleBatchesGraph {\n@@ -79,6 +87,28 @@ impl ModuleBatchesGraph {\n         Ok(*entry)\n     }\n \n+    pub fn get_ordered_entries<'l>(\n+        &'l self,\n+        chunk_group_info: &'l ChunkGroupInfo,\n+        idx: usize,\n+    ) -> impl Iterator<Item = ResolvedVc<Box<dyn Module>>> + 'l {\n+        if let Some(ordered_entries) = self\n+            .ordered_entries\n+            .get(idx)\n+            .as_ref()\n+            .and_then(|o| o.as_ref())\n+        {\n+            if let Some(chunk_group) = chunk_group_info.chunk_groups.get_index(idx) {\n+                debug_assert_eq!(ordered_entries.len(), chunk_group.entries_count());\n+            }\n+            Either::Left(Either::Left(ordered_entries.iter().copied()))\n+        } else if let Some(chunk_group) = chunk_group_info.chunk_groups.get_index(idx) {\n+            Either::Right(chunk_group.entries())\n+        } else {\n+            Either::Left(Either::Right(std::iter::empty()))\n+        }\n+    }\n+\n     pub fn get_batch_group(\n         &self,\n         module_or_batch: &ModuleOrBatch,\n@@ -323,6 +353,8 @@ pub async fn compute_module_batches(\n         let mut pre_batches = PreBatches::new();\n         let mut queue: VecDeque<(ResolvedVc<Box<dyn Module>>, PreBatchIndex)> = VecDeque::new();\n \n+        let mut chunk_group_indicies_with_merged_children = FxHashSet::default();\n+\n         // Start with the entries\n         for chunk_group in &chunk_group_info.chunk_groups {\n             for entry in chunk_group.entries() {\n@@ -340,6 +372,9 @@ pub async fn compute_module_batches(\n                     pre_batches.single_module_entries.insert(entry);\n                 }\n             }\n+            if let Some(parent) = chunk_group.get_merged_parent() {\n+                chunk_group_indicies_with_merged_children.insert(parent);\n+            }\n         }\n \n         let mut initial_pre_batch_items = 0;\n@@ -360,6 +395,83 @@ pub async fn compute_module_batches(\n         span.record(\"initial_pre_batch_items\", initial_pre_batch_items);\n         span.record(\"initial_pre_batches\", pre_batches.batches.len());\n \n+        // Figure out the order of all merged groups\n+        let mut ordered_entries: Vec<Option<EntriesList>> =\n+            vec![None; chunk_group_info.chunk_groups.len()];\n+        for (i, chunk_group) in chunk_group_info.chunk_groups.iter().enumerate() {\n+            if !chunk_group_indicies_with_merged_children.contains(&i) {\n+                continue;\n+            }\n+            let mut merged_modules: FxHashMap<ChunkingType, FxIndexSet<_>> = FxHashMap::default();\n+            let mut stack = ordered_entries[i]\n+                .as_ref()\n+                .map_or_else(\n+                    || Either::Left(chunk_group.entries()),\n+                    |v| Either::Right(v.iter().copied()),\n+                )\n+                .filter_map(|module| {\n+                    if let Some(chunkable_module) = ResolvedVc::try_downcast(module) {\n+                        let idx = *pre_batches.entries.get(&chunkable_module).unwrap();\n+                        Some((idx, 0))\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .collect::<Vec<_>>();\n+            stack.reverse();\n+            let mut visited = FxHashSet::default();\n+            while let Some((idx, mut pos)) = stack.pop() {\n+                let batch = &pre_batches.batches[idx];\n+                while let Some(item) = batch.items.get_index(pos) {\n+                    match item {\n+                        PreBatchItem::ParallelModule(_) => {}\n+                        PreBatchItem::ParallelReference(other_idx) => {\n+                            if visited.insert(*other_idx) {\n+                                stack.push((idx, pos + 1));\n+                                stack.push((*other_idx, 0));\n+                                break;\n+                            }\n+                        }\n+                        PreBatchItem::NonParallelEdge(chunking_type, module) => {\n+                            if chunking_type.is_merged() {\n+                                merged_modules\n+                                    .entry(chunking_type.clone())\n+                                    .or_default()\n+                                    .insert(*module);\n+                            }\n+                        }\n+                    }\n+                    pos += 1;\n+                }\n+            }\n+            if !merged_modules.is_empty() {\n+                for (ty, merged_modules) in merged_modules {\n+                    let chunk_group_key = match ty {\n+                        ChunkingType::Isolated {\n+                            merge_tag: Some(merge_tag),\n+                            ..\n+                        } => ChunkGroupKey::IsolatedMerged {\n+                            parent: i.into(),\n+                            merge_tag: merge_tag.clone(),\n+                        },\n+                        ChunkingType::Shared {\n+                            merge_tag: Some(merge_tag),\n+                            ..\n+                        } => ChunkGroupKey::SharedMerged {\n+                            parent: i.into(),\n+                            merge_tag: merge_tag.clone(),\n+                        },\n+                        _ => unreachable!(),\n+                    };\n+                    let idx = chunk_group_info\n+                        .chunk_group_keys\n+                        .get_index_of(&chunk_group_key)\n+                        .unwrap();\n+                    ordered_entries[idx] = Some(merged_modules);\n+                }\n+            }\n+        }\n+\n         // Create a map of parallel module to the batches they are contained in.\n         let mut parallel_module_to_pre_batch: FxIndexMap<_, Vec<PreBatchIndex>> =\n             FxIndexMap::default();\n@@ -748,6 +860,7 @@ pub async fn compute_module_batches(\n             graph: TracedDiGraph(graph),\n             entries,\n             batch_groups,\n+            ordered_entries,\n         }\n         .cell())\n     }"
        }
    ],
    "stats": {
        "total": 191,
        "additions": 172,
        "deletions": 19
    }
}