{
    "author": "wbinnssmith",
    "message": "Turbopack next/font: Use a custom enum instead of `Result` for failed local font files (#78941)\n\nPreviously, we used `anyhow::Result` for this, but this conflicts with\nhow we use `Error` in Turbo Tasks as system-level exceptions.\n\nTest Plan: `pnpm test-dev-turbo\ntest/e2e/app-dir/next-font/next-font.test.ts`",
    "sha": "66acc8393090225a4e86d82962bb4ee991741883",
    "files": [
        {
            "sha": "1e2ea92696f37ca7b5307cfab4cd10f6441b9fa3",
            "filename": "crates/next-core/src/next_font/font_fallback.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/66acc8393090225a4e86d82962bb4ee991741883/crates%2Fnext-core%2Fsrc%2Fnext_font%2Ffont_fallback.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/66acc8393090225a4e86d82962bb4ee991741883/crates%2Fnext-core%2Fsrc%2Fnext_font%2Ffont_fallback.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Ffont_fallback.rs?ref=66acc8393090225a4e86d82962bb4ee991741883",
            "patch": "@@ -60,7 +60,7 @@ impl FontFallback {\n }\n \n #[turbo_tasks::value(transparent)]\n-pub(crate) struct FontFallbacks(Vec<ResolvedVc<FontFallback>>);\n+pub(crate) struct FontFallbacks(pub Vec<ResolvedVc<FontFallback>>);\n \n #[turbo_tasks::value_impl]\n impl FontFallbacks {"
        },
        {
            "sha": "6412bb6e7f4129a09d8c2b3e48cd9268018a58de",
            "filename": "crates/next-core/src/next_font/local/errors.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 5,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/66acc8393090225a4e86d82962bb4ee991741883/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Ferrors.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/66acc8393090225a4e86d82962bb4ee991741883/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Ferrors.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Ferrors.rs?ref=66acc8393090225a4e86d82962bb4ee991741883",
            "patch": "@@ -1,8 +1,19 @@\n-use thiserror::Error;\n+use std::fmt::Display;\n+\n+use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n+use turbo_tasks::{trace::TraceRawVcs, NonLocalValue};\n+\n+pub(crate) enum FontResult<T> {\n+    Ok(T),\n+    FontFileNotFound(FontFileNotFound),\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Serialize, Deserialize, NonLocalValue, TraceRawVcs)]\n+pub(crate) struct FontFileNotFound(pub RcStr);\n \n-#[derive(Debug, Error)]\n-pub enum FontError {\n-    #[error(\"could not find font file\")]\n-    FontFileNotFound(RcStr),\n+impl Display for FontFileNotFound {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        write!(f, \"Font file not found: Can't resolve {}'\", self.0)\n+    }\n }"
        },
        {
            "sha": "18a9a90f6ba90d706ae6776a75b367899925964b",
            "filename": "crates/next-core/src/next_font/local/font_fallback.rs",
            "status": "modified",
            "additions": 52,
            "deletions": 26,
            "changes": 78,
            "blob_url": "https://github.com/vercel/next.js/blob/66acc8393090225a4e86d82962bb4ee991741883/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Ffont_fallback.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/66acc8393090225a4e86d82962bb4ee991741883/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Ffont_fallback.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Ffont_fallback.rs?ref=66acc8393090225a4e86d82962bb4ee991741883",
            "patch": "@@ -7,6 +7,7 @@ use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::{FileContent, FileSystemPath};\n \n use super::{\n+    errors::{FontFileNotFound, FontResult},\n     options::{FontDescriptor, FontDescriptors, FontWeight, NextFontLocalOptions},\n     request::AdjustFontFallback,\n };\n@@ -15,10 +16,15 @@ use crate::next_font::{\n         AutomaticFontFallback, DefaultFallbackFont, FontAdjustment, FontFallback, FontFallbacks,\n         DEFAULT_SANS_SERIF_FONT, DEFAULT_SERIF_FONT,\n     },\n-    local::errors::FontError,\n     util::{get_scoped_font_family, FontFamilyType},\n };\n \n+#[turbo_tasks::value(shared)]\n+pub(crate) enum FontFallbackResult {\n+    Ok(ResolvedVc<FontFallbacks>),\n+    FontFileNotFound(FontFileNotFound),\n+}\n+\n // From\n // https://github.com/vercel/next.js/blob/7457be0c74e64b4d0617943ed27f4d557cc916be/packages/font/src/local/get-fallback-metrics-from-font-file.ts#L34\n static AVG_CHARACTERS: &str = \"aaabcdeeeefghiijklmnnoopqrrssttuvwxyz      \";\n@@ -29,56 +35,76 @@ static BOLD_WEIGHT: f64 = 700.0;\n pub(super) async fn get_font_fallbacks(\n     lookup_path: Vc<FileSystemPath>,\n     options_vc: Vc<NextFontLocalOptions>,\n-) -> Result<Vc<FontFallbacks>> {\n+) -> Result<Vc<FontFallbackResult>> {\n     let options = &*options_vc.await?;\n-    let mut font_fallbacks = vec![];\n     let scoped_font_family =\n         get_scoped_font_family(FontFamilyType::Fallback.cell(), options_vc.font_family());\n \n+    let mut font_fallbacks = vec![];\n     match options.adjust_font_fallback {\n-        AdjustFontFallback::Arial => font_fallbacks.push(\n-            FontFallback::Automatic(AutomaticFontFallback {\n-                scoped_font_family: scoped_font_family.to_resolved().await?,\n-                local_font_family: ResolvedVc::cell(\"Arial\".into()),\n-                adjustment: Some(\n-                    get_font_adjustment(lookup_path, options_vc, &DEFAULT_SANS_SERIF_FONT).await?,\n+        AdjustFontFallback::Arial => {\n+            let adjustment =\n+                get_font_adjustment(lookup_path, options_vc, &DEFAULT_SANS_SERIF_FONT).await?;\n+\n+            match adjustment {\n+                FontResult::Ok(adjustment) => font_fallbacks.push(\n+                    FontFallback::Automatic(AutomaticFontFallback {\n+                        scoped_font_family: scoped_font_family.to_resolved().await?,\n+                        local_font_family: ResolvedVc::cell(\"Arial\".into()),\n+                        adjustment: Some(adjustment),\n+                    })\n+                    .resolved_cell(),\n                 ),\n-            })\n-            .resolved_cell(),\n-        ),\n-        AdjustFontFallback::TimesNewRoman => font_fallbacks.push(\n-            FontFallback::Automatic(AutomaticFontFallback {\n-                scoped_font_family: scoped_font_family.to_resolved().await?,\n-                local_font_family: ResolvedVc::cell(\"Times New Roman\".into()),\n-                adjustment: Some(\n-                    get_font_adjustment(lookup_path, options_vc, &DEFAULT_SERIF_FONT).await?,\n+                FontResult::FontFileNotFound(err) => {\n+                    return Ok(FontFallbackResult::FontFileNotFound(err).cell())\n+                }\n+            };\n+        }\n+        AdjustFontFallback::TimesNewRoman => {\n+            let adjustment =\n+                get_font_adjustment(lookup_path, options_vc, &DEFAULT_SERIF_FONT).await?;\n+\n+            match adjustment {\n+                FontResult::Ok(adjustment) => font_fallbacks.push(\n+                    FontFallback::Automatic(AutomaticFontFallback {\n+                        scoped_font_family: scoped_font_family.to_resolved().await?,\n+                        local_font_family: ResolvedVc::cell(\"Times New Roman\".into()),\n+                        adjustment: Some(adjustment),\n+                    })\n+                    .resolved_cell(),\n                 ),\n-            })\n-            .resolved_cell(),\n-        ),\n+                FontResult::FontFileNotFound(err) => {\n+                    return Ok(FontFallbackResult::FontFileNotFound(err).cell())\n+                }\n+            };\n+        }\n         AdjustFontFallback::None => (),\n     };\n \n     if let Some(fallback) = &options.fallback {\n         font_fallbacks.push(FontFallback::Manual(fallback.clone()).resolved_cell());\n     }\n \n-    Ok(Vc::cell(font_fallbacks))\n+    Ok(FontFallbackResult::Ok(FontFallbacks(font_fallbacks).resolved_cell()).cell())\n }\n \n async fn get_font_adjustment(\n     lookup_path: Vc<FileSystemPath>,\n     options: Vc<NextFontLocalOptions>,\n     fallback_font: &DefaultFallbackFont,\n-) -> Result<FontAdjustment> {\n+) -> Result<FontResult<FontAdjustment>> {\n     let options = &*options.await?;\n     let main_descriptor = pick_font_for_fallback_generation(&options.fonts)?;\n     let font_file = &*lookup_path\n         .join(main_descriptor.path.clone())\n         .read()\n         .await?;\n     let font_file_rope = match font_file {\n-        FileContent::NotFound => bail!(FontError::FontFileNotFound(main_descriptor.path.clone())),\n+        FileContent::NotFound => {\n+            return Ok(FontResult::FontFileNotFound(FontFileNotFound(\n+                main_descriptor.path.clone(),\n+            )));\n+        }\n         FileContent::Content(file) => file.content(),\n     };\n \n@@ -106,12 +132,12 @@ async fn get_font_adjustment(\n         None => 1.0,\n     };\n \n-    Ok(FontAdjustment {\n+    Ok(FontResult::Ok(FontAdjustment {\n         ascent: font.hhea_table.ascender as f64 / (units_per_em * size_adjust),\n         descent: font.hhea_table.descender as f64 / (units_per_em * size_adjust),\n         line_gap: font.hhea_table.line_gap as f64 / (units_per_em * size_adjust),\n         size_adjust,\n-    })\n+    }))\n }\n \n fn calc_average_width(font: &mut Font<DynamicFontTableProvider>) -> Option<f32> {"
        },
        {
            "sha": "c00b6ab4069a3895e375bc50786b8da5b63e1b9c",
            "filename": "crates/next-core/src/next_font/local/mod.rs",
            "status": "modified",
            "additions": 34,
            "deletions": 25,
            "changes": 59,
            "blob_url": "https://github.com/vercel/next.js/blob/66acc8393090225a4e86d82962bb4ee991741883/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/66acc8393090225a4e86d82962bb4ee991741883/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Flocal%2Fmod.rs?ref=66acc8393090225a4e86d82962bb4ee991741883",
            "patch": "@@ -1,4 +1,5 @@\n use anyhow::{bail, Context, Result};\n+use font_fallback::FontFallbackResult;\n use indoc::formatdoc;\n use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n@@ -31,12 +32,12 @@ use super::{\n use crate::{\n     next_app::metadata::split_extension,\n     next_font::{\n-        local::{errors::FontError, options::FontWeight},\n+        local::options::FontWeight,\n         util::{get_request_hash, get_request_id},\n     },\n };\n \n-mod errors;\n+pub mod errors;\n pub mod font_fallback;\n pub mod options;\n pub mod request;\n@@ -106,33 +107,26 @@ impl BeforeResolvePlugin for NextFontLocalResolvePlugin {\n                 let request_hash = get_request_hash(&query).await?;\n                 let qstr = qstring::QString::from(query.as_str());\n                 let options_vc = font_options_from_query_map(**query_vc);\n-                let font_fallbacks = get_font_fallbacks(lookup_path, options_vc);\n-                let properties = get_font_css_properties(options_vc, font_fallbacks).await;\n \n+                let font_fallbacks = &*get_font_fallbacks(lookup_path, options_vc).await?;\n                 let lookup_path = lookup_path.to_resolved().await?;\n-                if let Err(e) = &properties {\n-                    for source_error in e.chain() {\n-                        if let Some(FontError::FontFileNotFound(font_path)) =\n-                            source_error.downcast_ref::<FontError>()\n-                        {\n-                            FontResolvingIssue {\n-                                origin_path: lookup_path,\n-                                font_path: ResolvedVc::cell(font_path.clone()),\n-                            }\n-                            .resolved_cell()\n-                            .emit();\n-\n-                            return Ok(ResolveResultOption::some(*ResolveResult::primary(\n-                                ResolveResultItem::Error(ResolvedVc::cell(\n-                                    format!(\"Font file not found: Can't resolve {}'\", font_path)\n-                                        .into(),\n-                                )),\n-                            )));\n+                let font_fallbacks = match font_fallbacks {\n+                    FontFallbackResult::FontFileNotFound(err) => {\n+                        FontResolvingIssue {\n+                            origin_path: lookup_path,\n+                            font_path: ResolvedVc::cell(err.0.clone()),\n                         }\n+                        .resolved_cell()\n+                        .emit();\n+\n+                        return Ok(ResolveResultOption::some(*ResolveResult::primary(\n+                            ResolveResultItem::Error(ResolvedVc::cell(err.to_string().into())),\n+                        )));\n                     }\n-                }\n+                    FontFallbackResult::Ok(font_fallbacks) => *font_fallbacks,\n+                };\n \n-                let properties = properties?;\n+                let properties = get_font_css_properties(options_vc, *font_fallbacks).await?;\n                 let file_content = formatdoc!(\n                     r#\"\n                     import cssModule from \"@vercel/turbopack-next/internal/font/local/cssmodule.module.css?{}\";\n@@ -194,7 +188,22 @@ impl BeforeResolvePlugin for NextFontLocalResolvePlugin {\n                     )\n                     .into(),\n                 );\n-                let fallback = get_font_fallbacks(lookup_path, options);\n+                let fallback = &*get_font_fallbacks(lookup_path, options).await?;\n+                let fallback = match fallback {\n+                    FontFallbackResult::FontFileNotFound(err) => {\n+                        FontResolvingIssue {\n+                            origin_path: lookup_path.to_resolved().await?,\n+                            font_path: ResolvedVc::cell(err.0.clone()),\n+                        }\n+                        .resolved_cell()\n+                        .emit();\n+\n+                        return Ok(ResolveResultOption::some(*ResolveResult::primary(\n+                            ResolveResultItem::Error(ResolvedVc::cell(err.to_string().into())),\n+                        )));\n+                    }\n+                    FontFallbackResult::Ok(font_fallbacks) => **font_fallbacks,\n+                };\n \n                 let stylesheet = build_stylesheet(\n                     font_options_from_query_map(**query_vc),"
        }
    ],
    "stats": {
        "total": 160,
        "additions": 103,
        "deletions": 57
    }
}