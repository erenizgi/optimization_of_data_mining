{
    "author": "acdlite",
    "message": "Extract getDynamicParam to a shared module (#82137)\n\nI'm in the midst of a refactor to move dynamic route param parsing to\nthe client. This way client components can extract route params from the\nbrowser URL without needing to make a server request. For example, if a\npage is completely rendered on the client, we should be able to change\nthe URL without a request, even if the page accesses params.\n\nIn this PR, I've extracted the logic for parsing dynamic params into a\nshared module. It's not actually loaded on the client yet, but I wanted\nto move this into a separate file as its own step to make sure it works\non its own.\n\nWe need to be careful not to make this logic any more complex than it\nneeds to be. Ideally it would be little more than a regex. For most\nparams, that's the case, but alas there's already some unfortunate\nspecial case handling for catchall routes.",
    "sha": "8d937e712bccf79fe25a7c7aad05d39bf81b3c45",
    "files": [
        {
            "sha": "3d9c81bd6045b6de06b8e180934bce838eb02d04",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 15,
            "deletions": 71,
            "changes": 86,
            "blob_url": "https://github.com/vercel/next.js/blob/8d937e712bccf79fe25a7c7aad05d39bf81b3c45/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/8d937e712bccf79fe25a7c7aad05d39bf81b3c45/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=8d937e712bccf79fe25a7c7aad05d39bf81b3c45",
            "patch": "@@ -80,10 +80,7 @@ import {\n   isUserLandError,\n   getDigestForWellKnownError,\n } from './create-error-handler'\n-import {\n-  getShortDynamicParamType,\n-  dynamicParamTypes,\n-} from './get-short-dynamic-param-type'\n+import { dynamicParamTypes } from './get-short-dynamic-param-type'\n import { getSegmentParam } from './get-segment-param'\n import { getScriptNonceFromHeader } from './get-script-nonce-from-header'\n import { parseAndValidateFlightRouterState } from './parse-and-validate-flight-router-state'\n@@ -143,7 +140,6 @@ import {\n } from '../client-component-renderer-logger'\n import { createServerModuleMap } from './action-utils'\n import { isNodeNextRequest } from '../base-http/helpers'\n-import { parseParameter } from '../../shared/lib/router/utils/route-regex'\n import { parseRelativeUrl } from '../../shared/lib/router/utils/parse-relative-url'\n import AppRouter from '../../client/components/app-router'\n import type { ServerComponentsHmrCache } from '../response-cache'\n@@ -196,16 +192,19 @@ import { isReactLargeShellError } from './react-large-shell-error'\n import type { GlobalErrorComponent } from '../../client/components/builtin/global-error'\n import { normalizeConventionFilePath } from './segment-explorer-path'\n import { getRequestMeta } from '../request-meta'\n+import { getDynamicParam } from '../../shared/lib/router/utils/get-dynamic-param'\n \n export type GetDynamicParamFromSegment = (\n   // [slug] / [[slug]] / [...slug]\n   segment: string\n-) => {\n+) => DynamicParam | null\n+\n+export type DynamicParam = {\n   param: string\n   value: string | string[] | null\n   treeSegment: Segment\n   type: DynamicParamTypesShort\n-} | null\n+}\n \n export type GenerateFlight = typeof generateDynamicFlightRenderResult\n \n@@ -365,70 +364,15 @@ function makeGetDynamicParamFromSegment(\n     if (!segmentParam) {\n       return null\n     }\n-\n-    const key = segmentParam.param\n-\n-    let value = params[key]\n-\n-    if (fallbackRouteParams && fallbackRouteParams.has(segmentParam.param)) {\n-      value = fallbackRouteParams.get(segmentParam.param)\n-    } else if (Array.isArray(value)) {\n-      value = value.map((i) => encodeURIComponent(i))\n-    } else if (typeof value === 'string') {\n-      value = encodeURIComponent(value)\n-    }\n-\n-    if (!value) {\n-      const isCatchall = segmentParam.type === 'catchall'\n-      const isOptionalCatchall = segmentParam.type === 'optional-catchall'\n-\n-      if (isCatchall || isOptionalCatchall) {\n-        const dynamicParamType = dynamicParamTypes[segmentParam.type]\n-        // handle the case where an optional catchall does not have a value,\n-        // e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`\n-        if (isOptionalCatchall) {\n-          return {\n-            param: key,\n-            value: null,\n-            type: dynamicParamType,\n-            treeSegment: [key, '', dynamicParamType],\n-          }\n-        }\n-\n-        // handle the case where a catchall or optional catchall does not have a value,\n-        // e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched\n-        value = pagePath\n-          .split('/')\n-          // remove the first empty string\n-          .slice(1)\n-          // replace any dynamic params with the actual values\n-          .flatMap((pathSegment) => {\n-            const param = parseParameter(pathSegment)\n-            // if the segment matches a param, return the param value\n-            // otherwise, it's a static segment, so just return that\n-            return params[param.key] ?? param.key\n-          })\n-\n-        return {\n-          param: key,\n-          value,\n-          type: dynamicParamType,\n-          // This value always has to be a string.\n-          treeSegment: [key, value.join('/'), dynamicParamType],\n-        }\n-      }\n-    }\n-\n-    const type = getShortDynamicParamType(segmentParam.type)\n-\n-    return {\n-      param: key,\n-      // The value that is passed to user code.\n-      value: value,\n-      // The value that is rendered in the router tree.\n-      treeSegment: [key, Array.isArray(value) ? value.join('/') : value, type],\n-      type: type,\n-    }\n+    const segmentKey = segmentParam.param\n+    const dynamicParamType = dynamicParamTypes[segmentParam.type]\n+    return getDynamicParam(\n+      params,\n+      segmentKey,\n+      dynamicParamType,\n+      pagePath,\n+      fallbackRouteParams\n+    )\n   }\n }\n "
        },
        {
            "sha": "1c73bc7e2a1ce8a17ddfb79604585d36c3fd1da9",
            "filename": "packages/next/src/shared/lib/router/utils/get-dynamic-param.ts",
            "status": "added",
            "additions": 141,
            "deletions": 0,
            "changes": 141,
            "blob_url": "https://github.com/vercel/next.js/blob/8d937e712bccf79fe25a7c7aad05d39bf81b3c45/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/8d937e712bccf79fe25a7c7aad05d39bf81b3c45/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Fget-dynamic-param.ts?ref=8d937e712bccf79fe25a7c7aad05d39bf81b3c45",
            "patch": "@@ -0,0 +1,141 @@\n+import type { DynamicParam } from '../../../../server/app-render/app-render'\n+import type { DynamicParamTypesShort } from '../../../../server/app-render/types'\n+import type { FallbackRouteParams } from '../../../../server/request/fallback-params'\n+\n+/**\n+ *\n+ * Shared logic on client and server for creating a dynamic param value.\n+ *\n+ * This code needs to be shared with the client so it can extract dynamic route\n+ * params from the URL without a server request.\n+ *\n+ * Because everything in this module is sent to the client, we should aim to\n+ * keep this code as simple as possible. The special case handling for catchall\n+ * and optional is, alas, unfortunate.\n+ */\n+export function getDynamicParam(\n+  params: { [key: string]: any },\n+  segmentKey: string,\n+  dynamicParamType: DynamicParamTypesShort,\n+  pagePath: string,\n+  fallbackRouteParams: FallbackRouteParams | null\n+): DynamicParam {\n+  let value = params[segmentKey]\n+\n+  if (fallbackRouteParams && fallbackRouteParams.has(segmentKey)) {\n+    value = fallbackRouteParams.get(segmentKey)\n+  } else if (Array.isArray(value)) {\n+    value = value.map((i) => encodeURIComponent(i))\n+  } else if (typeof value === 'string') {\n+    value = encodeURIComponent(value)\n+  }\n+\n+  if (!value) {\n+    const isCatchall = dynamicParamType === 'c'\n+    const isOptionalCatchall = dynamicParamType === 'oc'\n+\n+    if (isCatchall || isOptionalCatchall) {\n+      // handle the case where an optional catchall does not have a value,\n+      // e.g. `/dashboard/[[...slug]]` when requesting `/dashboard`\n+      if (isOptionalCatchall) {\n+        return {\n+          param: segmentKey,\n+          value: null,\n+          type: dynamicParamType,\n+          treeSegment: [segmentKey, '', dynamicParamType],\n+        }\n+      }\n+\n+      // handle the case where a catchall or optional catchall does not have a value,\n+      // e.g. `/foo/bar/hello` and `@slot/[...catchall]` or `@slot/[[...catchall]]` is matched\n+      value = pagePath\n+        .split('/')\n+        // remove the first empty string\n+        .slice(1)\n+        // replace any dynamic params with the actual values\n+        .flatMap((pathSegment) => {\n+          const param = parseParameter(pathSegment)\n+          // if the segment matches a param, return the param value\n+          // otherwise, it's a static segment, so just return that\n+          return params[param.key] ?? param.key\n+        })\n+\n+      return {\n+        param: segmentKey,\n+        value,\n+        type: dynamicParamType,\n+        // This value always has to be a string.\n+        treeSegment: [segmentKey, value.join('/'), dynamicParamType],\n+      }\n+    }\n+  }\n+\n+  return {\n+    param: segmentKey,\n+    // The value that is passed to user code.\n+    value: value,\n+    // The value that is rendered in the router tree.\n+    treeSegment: [\n+      segmentKey,\n+      Array.isArray(value) ? value.join('/') : value,\n+      dynamicParamType,\n+    ],\n+    type: dynamicParamType,\n+  }\n+}\n+\n+/**\n+ * Regular expression pattern used to match route parameters.\n+ * Matches both single parameters and parameter groups.\n+ * Examples:\n+ *   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true\n+ *   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false\n+ *   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true\n+ *   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false\n+ */\n+export const PARAMETER_PATTERN = /^([^[]*)\\[((?:\\[[^\\]]*\\])|[^\\]]+)\\](.*)$/\n+\n+/**\n+ * Parses a given parameter from a route to a data structure that can be used\n+ * to generate the parametrized route.\n+ * Examples:\n+ *   - `[[...slug]]` -> `{ key: 'slug', repeat: true, optional: true }`\n+ *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: false }`\n+ *   - `[[foo]]` -> `{ key: 'foo', repeat: false, optional: true }`\n+ *   - `[bar]` -> `{ key: 'bar', repeat: false, optional: false }`\n+ *   - `fizz` -> `{ key: 'fizz', repeat: false, optional: false }`\n+ * @param param - The parameter to parse.\n+ * @returns The parsed parameter as a data structure.\n+ */\n+export function parseParameter(param: string) {\n+  const match = param.match(PARAMETER_PATTERN)\n+\n+  if (!match) {\n+    return parseMatchedParameter(param)\n+  }\n+\n+  return parseMatchedParameter(match[2])\n+}\n+\n+/**\n+ * Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used\n+ * to generate the parametrized route.\n+ * Examples:\n+ *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n+ *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n+ *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n+ *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n+ * @param param - The matched parameter to parse.\n+ * @returns The parsed parameter as a data structure.\n+ */\n+export function parseMatchedParameter(param: string) {\n+  const optional = param.startsWith('[') && param.endsWith(']')\n+  if (optional) {\n+    param = param.slice(1, -1)\n+  }\n+  const repeat = param.startsWith('...')\n+  if (repeat) {\n+    param = param.slice(3)\n+  }\n+  return { key: param, repeat, optional }\n+}"
        },
        {
            "sha": "c6c826eb62f4d4b9c67a373e7acb27eb7f242f01",
            "filename": "packages/next/src/shared/lib/router/utils/route-regex.test.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/8d937e712bccf79fe25a7c7aad05d39bf81b3c45/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-regex.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/8d937e712bccf79fe25a7c7aad05d39bf81b3c45/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-regex.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-regex.test.ts?ref=8d937e712bccf79fe25a7c7aad05d39bf81b3c45",
            "patch": "@@ -1,5 +1,5 @@\n import { getNamedRouteRegex } from './route-regex'\n-import { parseParameter } from './route-regex'\n+import { parseParameter } from './get-dynamic-param'\n \n describe('getNamedRouteRegex', () => {\n   it('should handle interception markers adjacent to dynamic path segments', () => {"
        },
        {
            "sha": "5dfb7fb10b977650d23fa7e75381e213c108ea4b",
            "filename": "packages/next/src/shared/lib/router/utils/route-regex.ts",
            "status": "modified",
            "additions": 1,
            "deletions": 56,
            "changes": 57,
            "blob_url": "https://github.com/vercel/next.js/blob/8d937e712bccf79fe25a7c7aad05d39bf81b3c45/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-regex.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/8d937e712bccf79fe25a7c7aad05d39bf81b3c45/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-regex.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Frouter%2Futils%2Froute-regex.ts?ref=8d937e712bccf79fe25a7c7aad05d39bf81b3c45",
            "patch": "@@ -5,6 +5,7 @@ import {\n import { INTERCEPTION_ROUTE_MARKERS } from './interception-routes'\n import { escapeStringRegexp } from '../../escape-regexp'\n import { removeTrailingSlash } from './remove-trailing-slash'\n+import { PARAMETER_PATTERN, parseMatchedParameter } from './get-dynamic-param'\n \n export interface Group {\n   pos: number\n@@ -77,62 +78,6 @@ type GetRouteRegexOptions = {\n   excludeOptionalTrailingSlash?: boolean\n }\n \n-/**\n- * Regular expression pattern used to match route parameters.\n- * Matches both single parameters and parameter groups.\n- * Examples:\n- *   - `[[...slug]]` matches parameter group with key 'slug', repeat: true, optional: true\n- *   - `[...slug]` matches parameter group with key 'slug', repeat: true, optional: false\n- *   - `[[foo]]` matches parameter with key 'foo', repeat: false, optional: true\n- *   - `[bar]` matches parameter with key 'bar', repeat: false, optional: false\n- */\n-const PARAMETER_PATTERN = /^([^[]*)\\[((?:\\[[^\\]]*\\])|[^\\]]+)\\](.*)$/\n-\n-/**\n- * Parses a given parameter from a route to a data structure that can be used\n- * to generate the parametrized route.\n- * Examples:\n- *   - `[[...slug]]` -> `{ key: 'slug', repeat: true, optional: true }`\n- *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: false }`\n- *   - `[[foo]]` -> `{ key: 'foo', repeat: false, optional: true }`\n- *   - `[bar]` -> `{ key: 'bar', repeat: false, optional: false }`\n- *   - `fizz` -> `{ key: 'fizz', repeat: false, optional: false }`\n- * @param param - The parameter to parse.\n- * @returns The parsed parameter as a data structure.\n- */\n-export function parseParameter(param: string) {\n-  const match = param.match(PARAMETER_PATTERN)\n-\n-  if (!match) {\n-    return parseMatchedParameter(param)\n-  }\n-\n-  return parseMatchedParameter(match[2])\n-}\n-\n-/**\n- * Parses a matched parameter from the PARAMETER_PATTERN regex to a data structure that can be used\n- * to generate the parametrized route.\n- * Examples:\n- *   - `[...slug]` -> `{ key: 'slug', repeat: true, optional: true }`\n- *   - `...slug` -> `{ key: 'slug', repeat: true, optional: false }`\n- *   - `[foo]` -> `{ key: 'foo', repeat: false, optional: true }`\n- *   - `bar` -> `{ key: 'bar', repeat: false, optional: false }`\n- * @param param - The matched parameter to parse.\n- * @returns The parsed parameter as a data structure.\n- */\n-function parseMatchedParameter(param: string) {\n-  const optional = param.startsWith('[') && param.endsWith(']')\n-  if (optional) {\n-    param = param.slice(1, -1)\n-  }\n-  const repeat = param.startsWith('...')\n-  if (repeat) {\n-    param = param.slice(3)\n-  }\n-  return { key: param, repeat, optional }\n-}\n-\n function getParametrizedRoute(\n   route: string,\n   includeSuffix: boolean,"
        }
    ],
    "stats": {
        "total": 286,
        "additions": 158,
        "deletions": 128
    }
}