{
    "author": "acdlite",
    "message": "Skip empty prefetch request for dynamic routes (#78436)\n\nIn the Segment Cache implementation of prefetching, a prefetch happens\nin two phases: first we fetch the route tree, then we fetch the data\nitself.\n\nThe route tree prefetch tells us important metadata about the structure\nof the target route, like whether it shares any layouts with the current\npage. We can use this information to omit parts of the tree from\nsubsequent data request.\n\nIn this PR, I've added a new piece of metadata to the route tree\nprefetch response: `hasLoadingBoundary`. For each segment in the tree,\nthis represents whether there is a `loading.tsx` boundary somewhere\nwithin it. This is useful because we know that during a prefetch, the\nserver will only render up to the nearest loading boundary (unless\nprefetch={true} is set); if there are no loading boundaries, then the\nserver will return an empty response.\n\nIn the latter case, we can use this information to skip the data\nprefetch entirely, freeing up bandwidth for other requests in the queue.",
    "sha": "c30747fe437fe367dd8a6b74e2907f4b6ca435c4",
    "files": [
        {
            "sha": "37f392c6cc19e4835cc3c3a2b1cc68499c8fdafb",
            "filename": "packages/next/src/client/components/segment-cache-impl/cache.ts",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fcache.ts?ref=c30747fe437fe367dd8a6b74e2907f4b6ca435c4",
            "patch": "@@ -11,6 +11,7 @@ import type {\n   CacheNodeSeedData,\n   Segment as FlightRouterStateSegment,\n } from '../../../server/app-render/types'\n+import { HasLoadingBoundary } from '../../../server/app-render/types'\n import {\n   NEXT_DID_POSTPONE_HEADER,\n   NEXT_ROUTER_PREFETCH_HEADER,\n@@ -85,6 +86,13 @@ export type RouteTree = {\n     [parallelRouteKey: string]: RouteTree\n   }\n   isRootLayout: boolean\n+\n+  // If this is a dynamic route, indicates whether there is a loading boundary\n+  // somewhere in the tree. If not, we can skip the prefetch for the data,\n+  // because we know it would be an empty response. (For a static/PPR route,\n+  // this value is disregarded, because in that model `loading.tsx` is treated\n+  // like any other Suspense boundary.)\n+  hasLoadingBoundary: HasLoadingBoundary\n }\n \n type RouteCacheEntryShared = {\n@@ -871,6 +879,9 @@ function convertTreePrefetchToRouteTree(\n     segment: prefetch.segment,\n     slots,\n     isRootLayout: prefetch.isRootLayout,\n+    // This field is only relevant to dynamic routes. For a PPR/static route,\n+    // there's always some partial loading state we can fetch.\n+    hasLoadingBoundary: HasLoadingBoundary.SegmentHasLoadingBoundary,\n   }\n }\n \n@@ -935,6 +946,10 @@ function convertFlightRouterStateToRouteTree(\n     segment: segmentWithoutSearchParams,\n     slots,\n     isRootLayout: flightRouterState[4] === true,\n+    hasLoadingBoundary:\n+      flightRouterState[5] !== undefined\n+        ? flightRouterState[5]\n+        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary,\n   }\n }\n "
        },
        {
            "sha": "8ddf58fc049b0ae1bfd44ae73740f894cb663d73",
            "filename": "packages/next/src/client/components/segment-cache-impl/scheduler.ts",
            "status": "modified",
            "additions": 21,
            "deletions": 17,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fclient%2Fcomponents%2Fsegment-cache-impl%2Fscheduler.ts?ref=c30747fe437fe367dd8a6b74e2907f4b6ca435c4",
            "patch": "@@ -2,6 +2,7 @@ import type {\n   FlightRouterState,\n   Segment as FlightRouterStateSegment,\n } from '../../../server/app-render/types'\n+import { HasLoadingBoundary } from '../../../server/app-render/types'\n import { matchSegment } from '../match-segments'\n import {\n   readOrCreateRouteCacheEntry,\n@@ -684,20 +685,23 @@ function diffRouteTreeAgainstCurrent(\n             // conservative about which segments to include in the request.\n             //\n             // The server will only render up to the first loading boundary\n-            // inside new part of the tree. If there's no loading boundary, the\n-            // server will never return any data. TODO: When we prefetch the\n-            // route tree, the server should indicate whether there's a loading\n-            // boundary so the client doesn't send a second request for no\n-            // reason.\n-            const requestTreeChild =\n-              pingPPRDisabledRouteTreeUpToLoadingBoundary(\n-                now,\n-                task,\n-                route,\n-                newTreeChild,\n-                null,\n-                spawnedEntries\n-              )\n+            // inside new part of the tree. If there's no loading boundary\n+            // anywhere in the tree, the server will never return any data, so\n+            // we can skip the request.\n+            const subtreeHasLoadingBoundary =\n+              newTreeChild.hasLoadingBoundary !==\n+              HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n+            const requestTreeChild = subtreeHasLoadingBoundary\n+              ? pingPPRDisabledRouteTreeUpToLoadingBoundary(\n+                  now,\n+                  task,\n+                  route,\n+                  newTreeChild,\n+                  null,\n+                  spawnedEntries\n+                )\n+              : // There's no loading boundary within this tree. Bail out.\n+                convertRouteTreeToFlightRouterState(newTreeChild)\n             requestTreeChildren[parallelRouteKey] = requestTreeChild\n             break\n           }\n@@ -800,9 +804,9 @@ function pingPPRDisabledRouteTreeUpToLoadingBoundary(\n     }\n     case EntryStatus.Fulfilled: {\n       // The segment is already cached.\n-      // TODO: The server should include a `hasLoading` field as part of the\n-      // route tree prefetch.\n-      if (segment.loading !== null) {\n+      const segmentHasLoadingBoundary =\n+        tree.hasLoadingBoundary === HasLoadingBoundary.SegmentHasLoadingBoundary\n+      if (segmentHasLoadingBoundary) {\n         // This segment has a loading boundary, which means the server won't\n         // render its children. So there's nothing left to prefetch along this\n         // path. We can bail out."
        },
        {
            "sha": "41b1ddc1faebc3f8e678f6338050252d7e8d887b",
            "filename": "packages/next/src/server/app-render/create-flight-router-state-from-loader-tree.ts",
            "status": "modified",
            "additions": 79,
            "deletions": 18,
            "changes": 97,
            "blob_url": "https://github.com/vercel/next.js/blob/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-flight-router-state-from-loader-tree.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-flight-router-state-from-loader-tree.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fcreate-flight-router-state-from-loader-tree.ts?ref=c30747fe437fe367dd8a6b74e2907f4b6ca435c4",
            "patch": "@@ -1,13 +1,14 @@\n import type { LoaderTree } from '../lib/app-dir-module'\n-import type { FlightRouterState } from './types'\n+import { HasLoadingBoundary, type FlightRouterState } from './types'\n import type { GetDynamicParamFromSegment } from './app-render'\n import { addSearchParamsIfPageSegment } from '../../shared/lib/segment'\n \n-export function createFlightRouterStateFromLoaderTree(\n-  [segment, parallelRoutes, { layout }]: LoaderTree,\n+function createFlightRouterStateFromLoaderTreeImpl(\n+  [segment, parallelRoutes, { layout, loading }]: LoaderTree,\n   getDynamicParamFromSegment: GetDynamicParamFromSegment,\n   searchParams: any,\n-  rootLayoutIncluded = false\n+  includeHasLoadingBoundary: boolean,\n+  didFindRootLayout: boolean\n ): FlightRouterState {\n   const dynamicParam = getDynamicParamFromSegment(segment)\n   const treeSegment = dynamicParam ? dynamicParam.treeSegment : segment\n@@ -17,23 +18,83 @@ export function createFlightRouterStateFromLoaderTree(\n     {},\n   ]\n \n-  if (!rootLayoutIncluded && typeof layout !== 'undefined') {\n-    rootLayoutIncluded = true\n+  // Mark the first segment that has a layout as the \"root\" layout\n+  if (!didFindRootLayout && typeof layout !== 'undefined') {\n+    didFindRootLayout = true\n     segmentTree[4] = true\n   }\n \n-  segmentTree[1] = Object.keys(parallelRoutes).reduce(\n-    (existingValue, currentValue) => {\n-      existingValue[currentValue] = createFlightRouterStateFromLoaderTree(\n-        parallelRoutes[currentValue],\n-        getDynamicParamFromSegment,\n-        searchParams,\n-        rootLayoutIncluded\n-      )\n-      return existingValue\n-    },\n-    {} as FlightRouterState[1]\n-  )\n+  let childHasLoadingBoundary = false\n+  const children: FlightRouterState[1] = {}\n+  Object.keys(parallelRoutes).forEach((parallelRouteKey) => {\n+    const child = createFlightRouterStateFromLoaderTreeImpl(\n+      parallelRoutes[parallelRouteKey],\n+      getDynamicParamFromSegment,\n+      searchParams,\n+      includeHasLoadingBoundary,\n+      didFindRootLayout\n+    )\n+    if (\n+      includeHasLoadingBoundary &&\n+      child[5] !== HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n+    ) {\n+      childHasLoadingBoundary = true\n+    }\n+    children[parallelRouteKey] = child\n+  })\n+  segmentTree[1] = children\n+\n+  if (includeHasLoadingBoundary) {\n+    // During a route tree prefetch, the FlightRouterState includes whether a\n+    // tree has a loading boundary. The client uses this to determine if it can\n+    // skip the data prefetch request — if `hasLoadingBoundary` is `false`, the\n+    // data prefetch response will be empty, so there's no reason to request it.\n+    // NOTE: It would be better to accumulate this while building the loader\n+    // tree so we don't have to keep re-deriving it, but since this won't be\n+    // once PPR is enabled everywhere, it's not that important.\n+    segmentTree[5] = loading\n+      ? HasLoadingBoundary.SegmentHasLoadingBoundary\n+      : childHasLoadingBoundary\n+        ? HasLoadingBoundary.SubtreeHasLoadingBoundary\n+        : HasLoadingBoundary.SubtreeHasNoLoadingBoundary\n+  }\n \n   return segmentTree\n }\n+\n+export function createFlightRouterStateFromLoaderTree(\n+  loaderTree: LoaderTree,\n+  getDynamicParamFromSegment: GetDynamicParamFromSegment,\n+  searchParams: any\n+) {\n+  const includeHasLoadingBoundary = false\n+  const didFindRootLayout = false\n+  return createFlightRouterStateFromLoaderTreeImpl(\n+    loaderTree,\n+    getDynamicParamFromSegment,\n+    searchParams,\n+    includeHasLoadingBoundary,\n+    didFindRootLayout\n+  )\n+}\n+\n+export function createRouteTreePrefetch(\n+  loaderTree: LoaderTree,\n+  getDynamicParamFromSegment: GetDynamicParamFromSegment\n+): FlightRouterState {\n+  // Search params should not be added to page segment's cache key during a\n+  // route tree prefetch request, because they do not affect the structure of\n+  // the route. The client cache has its own logic to handle search params.\n+  const searchParams = {}\n+  // During a route tree prefetch, we include `hasLoadingBoundary` in\n+  // the response.\n+  const includeHasLoadingBoundary = true\n+  const didFindRootLayout = false\n+  return createFlightRouterStateFromLoaderTreeImpl(\n+    loaderTree,\n+    getDynamicParamFromSegment,\n+    searchParams,\n+    includeHasLoadingBoundary,\n+    didFindRootLayout\n+  )\n+}"
        },
        {
            "sha": "e4b36dca4bcdbf9a2db59e29f07c5e65b2910ae4",
            "filename": "packages/next/src/server/app-render/types.ts",
            "status": "modified",
            "additions": 16,
            "deletions": 0,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Ftypes.ts?ref=c30747fe437fe367dd8a6b74e2907f4b6ca435c4",
            "patch": "@@ -94,8 +94,24 @@ export type FlightRouterState = [\n    */\n   refresh?: 'refetch' | 'refresh' | 'inside-shared-layout' | null,\n   isRootLayout?: boolean,\n+  /**\n+   * Only present when responding to a tree prefetch request. Indicates whether\n+   * there is a loading boundary somewhere in the tree. The client cache uses\n+   * this to determine if it can skip the data prefetch request.\n+   */\n+  hasLoadingBoundary?: HasLoadingBoundary,\n ]\n \n+export const enum HasLoadingBoundary {\n+  // There is a loading boundary in this particular segment\n+  SegmentHasLoadingBoundary = 1,\n+  // There is a loading boundary somewhere in the subtree (but not in\n+  // this segment)\n+  SubtreeHasLoadingBoundary = 2,\n+  // There is no loading boundary in this segment or any of its descendants\n+  SubtreeHasNoLoadingBoundary = 3,\n+}\n+\n /**\n  * Individual Flight response path\n  */"
        },
        {
            "sha": "da2166abf12af7558689e6929e48b17d4ec3f2ec",
            "filename": "packages/next/src/server/app-render/walk-tree-with-flight-router-state.tsx",
            "status": "modified",
            "additions": 13,
            "deletions": 7,
            "changes": 20,
            "blob_url": "https://github.com/vercel/next.js/blob/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwalk-tree-with-flight-router-state.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwalk-tree-with-flight-router-state.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwalk-tree-with-flight-router-state.tsx?ref=c30747fe437fe367dd8a6b74e2907f4b6ca435c4",
            "patch": "@@ -9,7 +9,10 @@ import { matchSegment } from '../../client/components/match-segments'\n import type { LoaderTree } from '../lib/app-dir-module'\n import { getLinkAndScriptTags } from './get-css-inlined-link-tags'\n import { getPreloadableFonts } from './get-preloadable-fonts'\n-import { createFlightRouterStateFromLoaderTree } from './create-flight-router-state-from-loader-tree'\n+import {\n+  createFlightRouterStateFromLoaderTree,\n+  createRouteTreePrefetch,\n+} from './create-flight-router-state-from-loader-tree'\n import type { AppRenderContext } from './app-render'\n import { hasLoadingComponentInTree } from './has-loading-component-in-tree'\n import {\n@@ -153,12 +156,15 @@ export async function walkTreeWithFlightRouterState({\n         ? flightRouterState[0]\n         : actualSegment\n \n-    const routerState = createFlightRouterStateFromLoaderTree(\n-      // Create router state using the slice of the loaderTree\n-      loaderTreeToFilter,\n-      getDynamicParamFromSegment,\n-      query\n-    )\n+    const routerState = parsedRequestHeaders.isRouteTreePrefetchRequest\n+      ? // Route tree prefetch requests contain some extra information\n+        createRouteTreePrefetch(loaderTreeToFilter, getDynamicParamFromSegment)\n+      : createFlightRouterStateFromLoaderTree(\n+          loaderTreeToFilter,\n+          getDynamicParamFromSegment,\n+          query\n+        )\n+\n     return [\n       [\n         overriddenSegment,"
        },
        {
            "sha": "90db1c0f9c92ff262c03d4ea784f6261c2770cc5",
            "filename": "test/e2e/app-dir/segment-cache/incremental-opt-in/app/page.tsx",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Fpage.tsx?ref=c30747fe437fe367dd8a6b74e2907f4b6ca435c4",
            "patch": "@@ -35,6 +35,13 @@ export default function Page() {\n           <LinkAccordion href=\"/ppr-disabled-with-loading-boundary\">\n             Page with PPR disabled, but has a loading boundary\n           </LinkAccordion>\n+          <ul>\n+            <li>\n+              <LinkAccordion href=\"/ppr-disabled-with-loading-boundary/child\">\n+                Another dynamic page that shares the same loading boundary\n+              </LinkAccordion>\n+            </li>\n+          </ul>\n         </li>\n       </ul>\n     </>"
        },
        {
            "sha": "07dd4704a4a360a0150fab8abf0b11fc5bc69ae4",
            "filename": "test/e2e/app-dir/segment-cache/incremental-opt-in/app/ppr-disabled-with-loading-boundary/child/page.tsx",
            "status": "added",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Fppr-disabled-with-loading-boundary%2Fchild%2Fpage.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Fppr-disabled-with-loading-boundary%2Fchild%2Fpage.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Fppr-disabled-with-loading-boundary%2Fchild%2Fpage.tsx?ref=c30747fe437fe367dd8a6b74e2907f4b6ca435c4",
            "patch": "@@ -0,0 +1,6 @@\n+import { connection } from 'next/server'\n+\n+export default async function PPRDisabledWithLoadingBoundaryChildPage() {\n+  await connection()\n+  return <div id=\"child-page-content\">Child page content</div>\n+}"
        },
        {
            "sha": "d28ada742ee643dd43164ed28fe85983a6a1a255",
            "filename": "test/e2e/app-dir/segment-cache/incremental-opt-in/app/ppr-disabled-with-loading-boundary/loading.tsx",
            "status": "modified",
            "additions": 2,
            "deletions": 14,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Fppr-disabled-with-loading-boundary%2Floading.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Fppr-disabled-with-loading-boundary%2Floading.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fapp%2Fppr-disabled-with-loading-boundary%2Floading.tsx?ref=c30747fe437fe367dd8a6b74e2907f4b6ca435c4",
            "patch": "@@ -1,15 +1,3 @@\n-import { Suspense } from 'react'\n-import { connection } from 'next/server'\n-\n-async function Content() {\n-  await connection()\n-  return 'Dynamic Content'\n-}\n-\n-export default function PPRDisabled() {\n-  return (\n-    <Suspense fallback=\"Loading...\">\n-      <Content />\n-    </Suspense>\n-  )\n+export default function Loading() {\n+  return <div id=\"loading-boundary\">Loading...</div>\n }"
        },
        {
            "sha": "398c70e4f185ce13852c2810405503deab716fdd",
            "filename": "test/e2e/app-dir/segment-cache/incremental-opt-in/segment-cache-incremental-opt-in.test.ts",
            "status": "modified",
            "additions": 134,
            "deletions": 0,
            "changes": 134,
            "blob_url": "https://github.com/vercel/next.js/blob/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fsegment-cache-incremental-opt-in.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/c30747fe437fe367dd8a6b74e2907f4b6ca435c4/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fsegment-cache-incremental-opt-in.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fe2e%2Fapp-dir%2Fsegment-cache%2Fincremental-opt-in%2Fsegment-cache-incremental-opt-in.test.ts?ref=c30747fe437fe367dd8a6b74e2907f4b6ca435c4",
            "patch": "@@ -92,6 +92,140 @@ describe('segment cache (incremental opt in)', () => {\n       testPrefetchDeduping('/ppr-disabled-with-loading-boundary'))\n   })\n \n+  it('prefetches a dynamic route when PPR is disabled if it has a loading.tsx boundary', async () => {\n+    let act\n+    const browser = await next.browser('/', {\n+      beforePageLoad(p) {\n+        act = createRouterAct(p)\n+      },\n+    })\n+\n+    // Initiate a prefetch for a dynamic page with no PPR, but with a\n+    // loading.tsx boundary. We should be able to prefetch up to the\n+    // loading boundary.\n+    await act(async () => {\n+      const checkbox = await browser.elementByCss(\n+        `input[data-link-accordion=\"/ppr-disabled-with-loading-boundary\"]`\n+      )\n+      await checkbox.click()\n+    }, [\n+      // Response includes the loading boundary\n+      { includes: 'Loading...' },\n+      // but it does not include the dynamic page content\n+      { includes: 'Page content', block: 'reject' },\n+    ])\n+\n+    // Navigate to the page\n+    await act(\n+      async () => {\n+        await browser\n+          .elementByCss(`a[href=\"/ppr-disabled-with-loading-boundary\"]`)\n+          .click()\n+        // We can immediately render the loading boundary before the network\n+        // responds, because it was prefetched\n+        const loadingBoundary = await browser.elementById('loading-boundary')\n+        expect(await loadingBoundary.text()).toBe('Loading...')\n+      },\n+      // The page content is fetched on navigation\n+      { includes: 'Page content' }\n+    )\n+    const pageContent = await browser.elementById('page-content')\n+    expect(await pageContent.text()).toBe('Page content')\n+  })\n+\n+  it(\n+    'skips prefetching a dynamic route when PPR is disabled if everything up ' +\n+      'to its loading.tsx boundary is already cached',\n+    async () => {\n+      let act\n+      const browser = await next.browser('/', {\n+        beforePageLoad(p) {\n+          act = createRouterAct(p)\n+        },\n+      })\n+\n+      // Initiate a prefetch for a dynamic page with no PPR, but with a\n+      // loading.tsx boundary. We should be able to prefetch up to the\n+      // loading boundary.\n+      await act(async () => {\n+        const checkbox = await browser.elementByCss(\n+          `input[data-link-accordion=\"/ppr-disabled-with-loading-boundary\"]`\n+        )\n+        await checkbox.click()\n+      }, [\n+        // Response includes the loading boundary\n+        { includes: 'Loading...' },\n+        // but it does not include the dynamic page content\n+        { includes: 'Page content', block: 'reject' },\n+      ])\n+\n+      await act(async () => {\n+        const checkbox = await browser.elementByCss(\n+          `input[data-link-accordion=\"/ppr-disabled-with-loading-boundary/child\"]`\n+        )\n+        await checkbox.click()\n+      }, 'no-requests')\n+\n+      // Navigate to the page\n+      await act(async () => {\n+        await browser\n+          .elementByCss(`a[href=\"/ppr-disabled-with-loading-boundary/child\"]`)\n+          .click()\n+        // We can immediately render the loading boundary before the network\n+        // responds, because it was prefetched\n+        const loadingBoundary = await browser.elementById('loading-boundary')\n+        expect(await loadingBoundary.text()).toBe('Loading...')\n+      }, [\n+        // The page content is fetched on navigation\n+        { includes: 'Child page content' },\n+        // The loading boundary is not fetched on navigation, because it\n+        // was already loaded into the cache during the prefetch for the\n+        // other page.\n+        { includes: 'Loading...', block: 'reject' },\n+      ])\n+      const pageContent = await browser.elementById('child-page-content')\n+      expect(await pageContent.text()).toBe('Child page content')\n+    }\n+  )\n+\n+  it('skips prefetching a dynamic route when PPR is disabled if it has no loading.tsx boundary', async () => {\n+    let act\n+    const browser = await next.browser('/', {\n+      beforePageLoad(p) {\n+        act = createRouterAct(p)\n+      },\n+    })\n+\n+    // Initiate a prefetch for a dynamic page with no loading.tsx and no PPR.\n+    // The route tree prefetch will tell the client that there is no loading\n+    // boundary, and therefore the client can skip prefetching the data, since\n+    // it would be an empty response, anyway.\n+    await act(\n+      async () => {\n+        const checkbox = await browser.elementByCss(\n+          `input[data-link-accordion=\"/ppr-disabled\"]`\n+        )\n+        await checkbox.click()\n+      },\n+      // This assertion will fail if more than one request includes the given\n+      // string. Because the string appears in the FlightRouterState for the\n+      // page, it effectively asserts that only one prefetch request is issued\n+      // — the one for the route tree.\n+      { includes: 'ppr-disabled' }\n+    )\n+\n+    // Navigate to the page\n+    await act(\n+      async () => {\n+        await browser.elementByCss(`a[href=\"/ppr-disabled\"]`).click()\n+      },\n+      // The page content is fetched on navigation\n+      { includes: 'Page content' }\n+    )\n+    const pageContent = await browser.elementById('page-content')\n+    expect(await pageContent.text()).toBe('Page content')\n+  })\n+\n   it(\n     'prefetches a shared layout on a PPR-enabled route that was previously ' +\n       'omitted from a non-PPR-enabled route',"
        }
    ],
    "stats": {
        "total": 349,
        "additions": 293,
        "deletions": 56
    }
}