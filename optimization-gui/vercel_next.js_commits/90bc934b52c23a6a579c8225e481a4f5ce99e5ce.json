{
    "author": "lukesandberg",
    "message": "[turbopack] Issue 'too many matches' warning for DirAssets also (#84768)\n\nSame as https://github.com/vercel/next.js/pull/84701 except for DirAssets which are what we create for things like `path.resolve` or `path.join`",
    "sha": "90bc934b52c23a6a579c8225e481a4f5ce99e5ce",
    "files": [
        {
            "sha": "064887b42c128bc204bb6d4357b4ff9596c21f3f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/mod.rs",
            "status": "modified",
            "additions": 21,
            "deletions": 15,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/90bc934b52c23a6a579c8225e481a4f5ce99e5ce/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/90bc934b52c23a6a579c8225e481a4f5ce99e5ce/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fmod.rs?ref=90bc934b52c23a6a579c8225e481a4f5ce99e5ce",
            "patch": "@@ -104,8 +104,7 @@ use self::{\n         EsmAssetReference, EsmAsyncAssetReference, EsmExports, EsmModuleItem, ImportMetaBinding,\n         ImportMetaRef, UrlAssetReference, export::EsmExport,\n     },\n-    node::DirAssetReference,\n-    raw::FileSourceReference,\n+    raw::{DirAssetReference, FileSourceReference},\n     typescript::{TsConfigReference, TsReferencePathAssetReference, TsReferenceTypeAssetReference},\n };\n use super::{\n@@ -1652,6 +1651,8 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n             .await\n     };\n \n+    let make_issue_source =\n+        || IssueSource::from_swc_offsets(source, span.lo.to_u32(), span.hi.to_u32());\n     if new {\n         match func {\n             JsValue::WellKnownFunction(WellKnownFunctionKind::URLConstructor) => {\n@@ -1987,11 +1988,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                             context_dir,\n                             Pattern::new(pat),\n                             collect_affecting_sources,\n-                            IssueSource::from_swc_offsets(\n-                                source,\n-                                span.lo.to_u32(),\n-                                span.hi.to_u32(),\n-                            ),\n+                            make_issue_source(),\n                         )\n                         .to_resolved()\n                         .await?,\n@@ -2043,7 +2040,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n             }\n             if let Some(context_dir) = get_traced_project_dir().await? {\n                 analysis.add_reference(\n-                    DirAssetReference::new(context_dir, Pattern::new(pat))\n+                    DirAssetReference::new(context_dir, Pattern::new(pat), make_issue_source())\n                         .to_resolved()\n                         .await?,\n                 );\n@@ -2085,7 +2082,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n             }\n             if let Some(context_dir) = get_traced_project_dir().await? {\n                 analysis.add_reference(\n-                    DirAssetReference::new(context_dir, Pattern::new(pat))\n+                    DirAssetReference::new(context_dir, Pattern::new(pat), make_issue_source())\n                         .to_resolved()\n                         .await?,\n                 );\n@@ -2376,9 +2373,13 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                             };\n                             if let Some(context_dir) = get_traced_project_dir().await? {\n                                 analysis.add_reference(\n-                                    DirAssetReference::new(context_dir, Pattern::new(abs_pattern))\n-                                        .to_resolved()\n-                                        .await?,\n+                                    DirAssetReference::new(\n+                                        context_dir,\n+                                        Pattern::new(abs_pattern),\n+                                        make_issue_source(),\n+                                    )\n+                                    .to_resolved()\n+                                    .await?,\n                                 );\n                             }\n                             return Ok(());\n@@ -2441,9 +2442,13 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                 };\n                 if let Some(context_dir) = get_traced_project_dir().await? {\n                     analysis.add_reference(\n-                        DirAssetReference::new(context_dir, Pattern::new(abs_pattern))\n-                            .to_resolved()\n-                            .await?,\n+                        DirAssetReference::new(\n+                            context_dir,\n+                            Pattern::new(abs_pattern),\n+                            make_issue_source(),\n+                        )\n+                        .to_resolved()\n+                        .await?,\n                     );\n                 }\n                 return Ok(());\n@@ -2510,6 +2515,7 @@ async fn handle_call<G: Fn(Vec<Effect>) + Send + Sync>(\n                             DirAssetReference::new(\n                                 context_dir.clone(),\n                                 Pattern::new(Pattern::Constant(dir.into())),\n+                                make_issue_source(),\n                             )\n                             .to_resolved()\n                         })"
        },
        {
            "sha": "efc5aaf6c7954b29d8600052fd85184c9d394e7f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/node.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 133,
            "changes": 137,
            "blob_url": "https://github.com/vercel/next.js/blob/90bc934b52c23a6a579c8225e481a4f5ce99e5ce/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/90bc934b52c23a6a579c8225e481a4f5ce99e5ce/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fnode.rs?ref=90bc934b52c23a6a579c8225e481a4f5ce99e5ce",
            "patch": "@@ -1,17 +1,10 @@\n-use anyhow::{Result, bail};\n-use tracing::Instrument;\n-use turbo_rcstr::{RcStr, rcstr};\n+use anyhow::Result;\n+use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{\n-    chunk::{ChunkableModuleReference, ChunkingType, ChunkingTypeOption},\n-    file_source::FileSource,\n-    raw_module::RawModule,\n-    reference::ModuleReference,\n-    resolve::{\n-        ModuleResolveResult, RequestKey,\n-        pattern::{Pattern, PatternMatch, read_matches},\n-    },\n+    file_source::FileSource, raw_module::RawModule, reference::ModuleReference,\n+    resolve::ModuleResolveResult,\n };\n \n #[turbo_tasks::value]\n@@ -53,125 +46,3 @@ impl ValueToString for PackageJsonReference {\n         ))\n     }\n }\n-\n-#[turbo_tasks::value]\n-#[derive(Hash, Debug)]\n-pub struct DirAssetReference {\n-    pub context_dir: FileSystemPath,\n-    pub path: ResolvedVc<Pattern>,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl DirAssetReference {\n-    #[turbo_tasks::function]\n-    pub fn new(context_dir: FileSystemPath, path: ResolvedVc<Pattern>) -> Vc<Self> {\n-        Self::cell(DirAssetReference { context_dir, path })\n-    }\n-}\n-\n-async fn resolve_reference_from_dir(\n-    context_dir: FileSystemPath,\n-    path: Vc<Pattern>,\n-) -> Result<Vc<ModuleResolveResult>> {\n-    let path_ref = path.await?;\n-    let (abs_path, rel_path) = path_ref.split_could_match(\"/ROOT/\");\n-    if abs_path.is_none() && rel_path.is_none() {\n-        return Ok(*ModuleResolveResult::unresolvable());\n-    }\n-\n-    let abs_matches = if let Some(abs_path) = &abs_path {\n-        Some(\n-            read_matches(\n-                context_dir.root().owned().await?,\n-                rcstr!(\"/ROOT/\"),\n-                true,\n-                Pattern::new(abs_path.or_any_nested_file()),\n-            )\n-            .await?,\n-        )\n-    } else {\n-        None\n-    };\n-    let rel_matches = if let Some(rel_path) = &rel_path {\n-        Some(\n-            read_matches(\n-                context_dir,\n-                rcstr!(\"\"),\n-                true,\n-                Pattern::new(rel_path.or_any_nested_file()),\n-            )\n-            .await?,\n-        )\n-    } else {\n-        None\n-    };\n-\n-    let matches = abs_matches\n-        .into_iter()\n-        .flatten()\n-        .chain(rel_matches.into_iter().flatten());\n-\n-    let mut affecting_sources = Vec::new();\n-    let mut results = Vec::new();\n-    for pat_match in matches {\n-        match pat_match {\n-            PatternMatch::File(matched_path, file) => {\n-                let realpath = file.realpath_with_links().await?;\n-                for symlink in &realpath.symlinks {\n-                    affecting_sources.push(ResolvedVc::upcast(\n-                        FileSource::new(symlink.clone()).to_resolved().await?,\n-                    ));\n-                }\n-                let path: FileSystemPath = match &realpath.path_result {\n-                    Ok(path) => path.clone(),\n-                    Err(e) => bail!(e.as_error_message(file, &realpath)),\n-                };\n-                results.push((\n-                    RequestKey::new(matched_path.clone()),\n-                    ResolvedVc::upcast(\n-                        RawModule::new(Vc::upcast(FileSource::new(path)))\n-                            .to_resolved()\n-                            .await?,\n-                    ),\n-                ));\n-            }\n-            PatternMatch::Directory(..) => {}\n-        }\n-    }\n-    Ok(*ModuleResolveResult::modules_with_affecting_sources(\n-        results,\n-        affecting_sources,\n-    ))\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ModuleReference for DirAssetReference {\n-    #[turbo_tasks::function]\n-    async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n-        let span = tracing::info_span!(\n-            \"trace directory\",\n-            pattern = display(self.path.to_string().await?)\n-        );\n-        resolve_reference_from_dir(self.context_dir.clone(), *self.path)\n-            .instrument(span)\n-            .await\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ChunkableModuleReference for DirAssetReference {\n-    #[turbo_tasks::function]\n-    fn chunking_type(&self) -> Vc<ChunkingTypeOption> {\n-        Vc::cell(Some(ChunkingType::Traced))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ValueToString for DirAssetReference {\n-    #[turbo_tasks::function]\n-    async fn to_string(&self) -> Result<Vc<RcStr>> {\n-        Ok(Vc::cell(\n-            format!(\"directory assets {}\", self.path.to_string().await?,).into(),\n-        ))\n-    }\n-}"
        },
        {
            "sha": "e5124cfa1a4fffaee361f3f9b40858011bf40211",
            "filename": "turbopack/crates/turbopack-ecmascript/src/references/raw.rs",
            "status": "modified",
            "additions": 193,
            "deletions": 30,
            "changes": 223,
            "blob_url": "https://github.com/vercel/next.js/blob/90bc934b52c23a6a579c8225e481a4f5ce99e5ce/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fraw.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/90bc934b52c23a6a579c8225e481a4f5ce99e5ce/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fraw.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Freferences%2Fraw.rs?ref=90bc934b52c23a6a579c8225e481a4f5ce99e5ce",
            "patch": "@@ -1,18 +1,23 @@\n-use anyhow::Result;\n+use anyhow::{Result, bail};\n use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{\n     chunk::{ChunkableModuleReference, ChunkingType, ChunkingTypeOption},\n+    file_source::FileSource,\n     issue::{\n         Issue, IssueExt, IssueSeverity, IssueSource, IssueStage, OptionIssueSource,\n         OptionStyledString, StyledString,\n     },\n+    raw_module::RawModule,\n     reference::ModuleReference,\n-    resolve::{ModuleResolveResult, pattern::Pattern, resolve_raw},\n+    resolve::{\n+        ModuleResolveResult, RequestKey,\n+        pattern::{Pattern, PatternMatch, read_matches},\n+        resolve_raw,\n+    },\n };\n-\n #[turbo_tasks::value]\n #[derive(Hash, Debug)]\n pub struct FileSourceReference {\n@@ -58,26 +63,202 @@ impl ModuleReference for FileSourceReference {\n             .as_raw_module_result()\n             .resolve()\n             .await?;\n-            let num_matches = result.await?.primary.len();\n-            if num_matches > TOO_MANY_MATCHES_LIMIT {\n-                TooManyMatchesWarning {\n-                    source: self.issue_source,\n-                    context_dir: self.context_dir.clone(),\n-                    num_matches,\n-                    pattern: self.path,\n+            check_and_emit_too_many_matches_warning(\n+                result,\n+                self.issue_source,\n+                self.context_dir.clone(),\n+                self.path,\n+            )\n+            .await?;\n+\n+            Ok(result)\n+        }\n+        .instrument(span)\n+        .await\n+    }\n+}\n+#[turbo_tasks::value_impl]\n+impl ChunkableModuleReference for FileSourceReference {\n+    #[turbo_tasks::function]\n+    fn chunking_type(&self) -> Vc<ChunkingTypeOption> {\n+        Vc::cell(Some(ChunkingType::Traced))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ValueToString for FileSourceReference {\n+    #[turbo_tasks::function]\n+    async fn to_string(&self) -> Result<Vc<RcStr>> {\n+        Ok(Vc::cell(\n+            format!(\"raw asset {}\", self.path.to_string().await?,).into(),\n+        ))\n+    }\n+}\n+\n+#[turbo_tasks::value]\n+#[derive(Hash, Debug)]\n+pub struct DirAssetReference {\n+    context_dir: FileSystemPath,\n+    path: ResolvedVc<Pattern>,\n+    issue_source: IssueSource,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl DirAssetReference {\n+    #[turbo_tasks::function]\n+    pub fn new(\n+        context_dir: FileSystemPath,\n+        path: ResolvedVc<Pattern>,\n+        issue_source: IssueSource,\n+    ) -> Vc<Self> {\n+        Self::cell(DirAssetReference {\n+            context_dir,\n+            path,\n+            issue_source,\n+        })\n+    }\n+}\n+\n+async fn resolve_reference_from_dir(\n+    context_dir: FileSystemPath,\n+    path: Vc<Pattern>,\n+) -> Result<Vc<ModuleResolveResult>> {\n+    let path_ref = path.await?;\n+    let (abs_path, rel_path) = path_ref.split_could_match(\"/ROOT/\");\n+    if abs_path.is_none() && rel_path.is_none() {\n+        return Ok(*ModuleResolveResult::unresolvable());\n+    }\n+\n+    let abs_matches = if let Some(abs_path) = &abs_path {\n+        Some(\n+            read_matches(\n+                context_dir.root().owned().await?,\n+                rcstr!(\"/ROOT/\"),\n+                true,\n+                Pattern::new(abs_path.or_any_nested_file()),\n+            )\n+            .await?,\n+        )\n+    } else {\n+        None\n+    };\n+    let rel_matches = if let Some(rel_path) = &rel_path {\n+        Some(\n+            read_matches(\n+                context_dir,\n+                rcstr!(\"\"),\n+                true,\n+                Pattern::new(rel_path.or_any_nested_file()),\n+            )\n+            .await?,\n+        )\n+    } else {\n+        None\n+    };\n+\n+    let matches = abs_matches\n+        .into_iter()\n+        .flatten()\n+        .chain(rel_matches.into_iter().flatten());\n+\n+    let mut affecting_sources = Vec::new();\n+    let mut results = Vec::new();\n+    for pat_match in matches {\n+        match pat_match {\n+            PatternMatch::File(matched_path, file) => {\n+                let realpath = file.realpath_with_links().await?;\n+                for symlink in &realpath.symlinks {\n+                    affecting_sources.push(ResolvedVc::upcast(\n+                        FileSource::new(symlink.clone()).to_resolved().await?,\n+                    ));\n                 }\n-                .resolved_cell()\n-                .emit();\n+                let path: FileSystemPath = match &realpath.path_result {\n+                    Ok(path) => path.clone(),\n+                    Err(e) => bail!(e.as_error_message(file, &realpath)),\n+                };\n+                results.push((\n+                    RequestKey::new(matched_path.clone()),\n+                    ResolvedVc::upcast(\n+                        RawModule::new(Vc::upcast(FileSource::new(path)))\n+                            .to_resolved()\n+                            .await?,\n+                    ),\n+                ));\n             }\n+            PatternMatch::Directory(..) => {}\n+        }\n+    }\n+    Ok(*ModuleResolveResult::modules_with_affecting_sources(\n+        results,\n+        affecting_sources,\n+    ))\n+}\n \n+#[turbo_tasks::value_impl]\n+impl ModuleReference for DirAssetReference {\n+    #[turbo_tasks::function]\n+    async fn resolve_reference(&self) -> Result<Vc<ModuleResolveResult>> {\n+        let span = tracing::info_span!(\n+            \"trace directory\",\n+            pattern = display(self.path.to_string().await?)\n+        );\n+        async {\n+            let result = resolve_reference_from_dir(self.context_dir.clone(), *self.path).await?;\n+            check_and_emit_too_many_matches_warning(\n+                result,\n+                self.issue_source,\n+                self.context_dir.clone(),\n+                self.path,\n+            )\n+            .await?;\n             Ok(result)\n         }\n         .instrument(span)\n         .await\n     }\n }\n+\n+#[turbo_tasks::value_impl]\n+impl ChunkableModuleReference for DirAssetReference {\n+    #[turbo_tasks::function]\n+    fn chunking_type(&self) -> Vc<ChunkingTypeOption> {\n+        Vc::cell(Some(ChunkingType::Traced))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ValueToString for DirAssetReference {\n+    #[turbo_tasks::function]\n+    async fn to_string(&self) -> Result<Vc<RcStr>> {\n+        Ok(Vc::cell(\n+            format!(\"directory assets {}\", self.path.to_string().await?,).into(),\n+        ))\n+    }\n+}\n+\n /// If a pattern resolves to more than 10000 results, it's likely a mistake so issue a warning.\n const TOO_MANY_MATCHES_LIMIT: usize = 10000;\n+\n+async fn check_and_emit_too_many_matches_warning(\n+    result: Vc<ModuleResolveResult>,\n+    issue_source: IssueSource,\n+    context_dir: FileSystemPath,\n+    pattern: ResolvedVc<Pattern>,\n+) -> Result<()> {\n+    let num_matches = result.await?.primary.len();\n+    if num_matches > TOO_MANY_MATCHES_LIMIT {\n+        TooManyMatchesWarning {\n+            source: issue_source,\n+            context_dir,\n+            num_matches,\n+            pattern,\n+        }\n+        .resolved_cell()\n+        .emit();\n+    }\n+    Ok(())\n+}\n+\n #[turbo_tasks::value(shared)]\n struct TooManyMatchesWarning {\n     source: IssueSource,\n@@ -131,21 +312,3 @@ impl Issue for TooManyMatchesWarning {\n         Vc::cell(Some(self.source))\n     }\n }\n-\n-#[turbo_tasks::value_impl]\n-impl ChunkableModuleReference for FileSourceReference {\n-    #[turbo_tasks::function]\n-    fn chunking_type(&self) -> Vc<ChunkingTypeOption> {\n-        Vc::cell(Some(ChunkingType::Traced))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ValueToString for FileSourceReference {\n-    #[turbo_tasks::function]\n-    async fn to_string(&self) -> Result<Vc<RcStr>> {\n-        Ok(Vc::cell(\n-            format!(\"raw asset {}\", self.path.to_string().await?,).into(),\n-        ))\n-    }\n-}"
        }
    ],
    "stats": {
        "total": 396,
        "additions": 218,
        "deletions": 178
    }
}