{
    "author": "feedthejim",
    "message": "chore: add dev boot profiling and benchmark scripts (#87940)\n\n## Summary\n\nDevelopment scripts for profiling and benchmarking Next.js dev server boot time.\n\n### Benchmarking Scripts\n- `benchmark-boot-time.sh` - Wall-clock benchmarking with two metrics:\n  - **Listen time**: When TCP port accepts connections\n  - **Ready time**: When first HTTP request succeeds\n- `benchmark-next-dev-boot.js` - Multi-iteration benchmarking with statistics (median, p95, stddev)\n\n### Profiling Scripts\n- `profile-next-dev-boot.js` - CPU profiling infrastructure using V8 inspector\n- `analyze-profile.js` - Analyze CPU profiles to identify hot modules by CPU time\n\n### Analysis Scripts\n- `analyze-dev-server-bundle.js` - Bundle analyzer for dev server (generates treemap report)\n- `trace-cli-startup.js` - Module loading trace to identify slow imports\n\n## Usage\n\n```bash\n# Benchmark dev server boot time (5 runs by default)\n./scripts/benchmark-boot-time.sh\n\n# Multi-iteration benchmark with stats\nnode scripts/benchmark-next-dev-boot.js --iterations 10\n\n# Generate CPU profile\nnode scripts/profile-next-dev-boot.js\n\n# Analyze profile output\nnode scripts/analyze-profile.js .next/cpu-profiles/*.cpuprofile\n\n# Analyze dev server bundle\nnode scripts/analyze-dev-server-bundle.js --open\n```\n\n## Test Plan\n- [x] Run `./scripts/benchmark-boot-time.sh` locally\n- [x] Verify scripts execute without errors",
    "sha": "a39366938a9bb669ef775404b3547a876ec2f0d4",
    "files": [
        {
            "sha": "58067083c8aa86da122205f12cfbb20b223ad196",
            "filename": "scripts/analyze-dev-server-bundle.js",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/vercel/next.js/blob/a39366938a9bb669ef775404b3547a876ec2f0d4/scripts%2Fanalyze-dev-server-bundle.js",
            "raw_url": "https://github.com/vercel/next.js/raw/a39366938a9bb669ef775404b3547a876ec2f0d4/scripts%2Fanalyze-dev-server-bundle.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/scripts%2Fanalyze-dev-server-bundle.js?ref=a39366938a9bb669ef775404b3547a876ec2f0d4",
            "patch": "@@ -0,0 +1,142 @@\n+#!/usr/bin/env node\n+/**\n+ * Dev Server Bundle Analyzer\n+ *\n+ * Generates a bundle analyzer report for the dev server bundle.\n+ *\n+ * Usage:\n+ *   node scripts/analyze-bundle.js [options]\n+ *\n+ * Options:\n+ *   --open          Open the report in browser (default: false)\n+ *   --verbose       Show detailed module reasons\n+ *   --json          Also output stats.json file\n+ *   --list-modules  List all bundled modules to console\n+ *   --list-externals List all externalized modules\n+ */\n+\n+const { execSync } = require('child_process')\n+const path = require('path')\n+const fs = require('fs')\n+\n+// Parse arguments\n+const args = process.argv.slice(2)\n+const hasFlag = (name) => args.includes(`--${name}`)\n+\n+const openBrowser = hasFlag('open')\n+const verbose = hasFlag('verbose')\n+const outputJson = hasFlag('json')\n+const listModules = hasFlag('list-modules')\n+const listExternals = hasFlag('list-externals')\n+\n+const nextDir = path.join(__dirname, '..', 'packages', 'next')\n+const bundlePath = path.join(\n+  nextDir,\n+  'dist/compiled/dev-server/start-server.js'\n+)\n+const reportPath = path.join(\n+  nextDir,\n+  'dist/compiled/dev-server/bundle-report.html'\n+)\n+\n+console.log('\\x1b[34m=== Dev Server Bundle Analyzer ===\\x1b[0m')\n+console.log('')\n+\n+// Build with analyzer\n+console.log('Building bundle with analyzer...')\n+const env = {\n+  ...process.env,\n+  ANALYZE: '1',\n+  ...(verbose ? { ANALYZE_REASONS: '1' } : {}),\n+}\n+\n+try {\n+  execSync('npx taskr next_bundle_dev_server', {\n+    cwd: nextDir,\n+    stdio: verbose ? 'inherit' : 'pipe',\n+    env,\n+  })\n+} catch (err) {\n+  console.error('\\x1b[31mBuild failed\\x1b[0m')\n+  process.exit(1)\n+}\n+\n+// Get bundle stats\n+const stats = fs.statSync(bundlePath)\n+const sizeKB = Math.round(stats.size / 1024)\n+const sizeMB = (stats.size / (1024 * 1024)).toFixed(2)\n+\n+console.log('')\n+console.log('\\x1b[32mBundle Stats:\\x1b[0m')\n+console.log(`  Size: ${sizeKB} KB (${sizeMB} MB)`)\n+console.log(`  Path: ${bundlePath}`)\n+console.log(`  Report: ${reportPath}`)\n+console.log('')\n+\n+// List bundled modules\n+if (listModules) {\n+  console.log('\\x1b[33mBundled Modules:\\x1b[0m')\n+  const content = fs.readFileSync(bundlePath, 'utf-8')\n+  const moduleMatches = content.match(/\"\\.\\/dist\\/[^\"]+/g) || []\n+  const modules = [...new Set(moduleMatches)]\n+    .map((m) => m.replace(/^\"/, ''))\n+    .filter((m) => !m.includes(' recursive'))\n+    .sort()\n+\n+  modules.forEach((m) => console.log(`  ${m}`))\n+  console.log(`\\n  Total: ${modules.length} modules`)\n+  console.log('')\n+}\n+\n+// List externalized modules\n+if (listExternals) {\n+  console.log('\\x1b[33mExternalized Modules:\\x1b[0m')\n+  const content = fs.readFileSync(bundlePath, 'utf-8')\n+\n+  // Find external requires\n+  const externalMatches =\n+    content.match(\n+      /require\\(\"(next\\/dist\\/[^\"]+|@next\\/[^\"]+|styled-jsx[^\"]*)\"\\)/g\n+    ) || []\n+  const externals = [...new Set(externalMatches)]\n+    .map((m) => m.match(/require\\(\"([^\"]+)\"\\)/)[1])\n+    .sort()\n+\n+  externals.forEach((m) => console.log(`  ${m}`))\n+  console.log(`\\n  Total: ${externals.length} external requires`)\n+  console.log('')\n+}\n+\n+// Output JSON stats\n+if (outputJson) {\n+  const statsJsonPath = path.join(\n+    nextDir,\n+    'dist/compiled/dev-server/stats.json'\n+  )\n+  console.log(`Stats JSON: ${statsJsonPath}`)\n+  console.log('(Run with ANALYZE_REASONS=1 for detailed stats)')\n+}\n+\n+// Open in browser\n+if (openBrowser) {\n+  console.log('Opening report in browser...')\n+  const opener =\n+    process.platform === 'darwin'\n+      ? 'open'\n+      : process.platform === 'win32'\n+        ? 'start'\n+        : 'xdg-open'\n+  try {\n+    execSync(`${opener} \"${reportPath}\"`, { stdio: 'ignore' })\n+  } catch {\n+    console.log(`Could not open browser. Open manually: ${reportPath}`)\n+  }\n+}\n+\n+console.log('\\x1b[32mDone!\\x1b[0m')\n+console.log('')\n+console.log('Tips:')\n+console.log('  - Open the HTML report to see interactive treemap')\n+console.log('  - Use --list-modules to see all bundled modules')\n+console.log('  - Use --list-externals to see external requires')\n+console.log('  - Use --verbose for detailed build output')"
        },
        {
            "sha": "637201ce18585742a6808d1138ffc92fc7bac0a4",
            "filename": "scripts/analyze-profile.js",
            "status": "added",
            "additions": 49,
            "deletions": 0,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/a39366938a9bb669ef775404b3547a876ec2f0d4/scripts%2Fanalyze-profile.js",
            "raw_url": "https://github.com/vercel/next.js/raw/a39366938a9bb669ef775404b3547a876ec2f0d4/scripts%2Fanalyze-profile.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/scripts%2Fanalyze-profile.js?ref=a39366938a9bb669ef775404b3547a876ec2f0d4",
            "patch": "@@ -0,0 +1,49 @@\n+#!/usr/bin/env node\n+/**\n+ * Analyze a CPU profile to identify hot modules\n+ */\n+\n+const fs = require('fs')\n+\n+const profilePath = process.argv[2]\n+if (!profilePath) {\n+  console.error('Usage: node analyze-profile.js <profile.cpuprofile>')\n+  process.exit(1)\n+}\n+\n+const profile = JSON.parse(fs.readFileSync(profilePath, 'utf-8'))\n+\n+// Extract nodes with their hit counts\n+const nodes = profile.nodes || []\n+\n+// Group by file/module\n+const moduleHits = {}\n+nodes.forEach((node) => {\n+  const fn = node.callFrame\n+  if (fn && fn.url) {\n+    const url = fn.url\n+    // Extract module name from path\n+    let moduleName = url\n+    if (url.includes('next/dist/')) {\n+      moduleName = url.split('next/dist/')[1]\n+    } else if (url.includes('node_modules/')) {\n+      moduleName = 'node_modules/' + url.split('node_modules/').pop()\n+    }\n+    if (!moduleHits[moduleName]) {\n+      moduleHits[moduleName] = { hits: 0 }\n+    }\n+    moduleHits[moduleName].hits += node.hitCount || 0\n+  }\n+})\n+\n+// Sort by hits\n+const sorted = Object.entries(moduleHits)\n+  .filter(([_, v]) => v.hits > 0)\n+  .sort((a, b) => b[1].hits - a[1].hits)\n+  .slice(0, 40)\n+\n+console.log('Top 40 modules by CPU time:')\n+console.log('='.repeat(70))\n+sorted.forEach(([name, data], i) => {\n+  console.log(`${String(i + 1).padStart(2)}. ${name} (${data.hits} hits)`)\n+})"
        },
        {
            "sha": "8c40af9cc60b62b2a606480c31752a4726831751",
            "filename": "scripts/benchmark-boot-time.sh",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/vercel/next.js/blob/a39366938a9bb669ef775404b3547a876ec2f0d4/scripts%2Fbenchmark-boot-time.sh",
            "raw_url": "https://github.com/vercel/next.js/raw/a39366938a9bb669ef775404b3547a876ec2f0d4/scripts%2Fbenchmark-boot-time.sh",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/scripts%2Fbenchmark-boot-time.sh?ref=a39366938a9bb669ef775404b3547a876ec2f0d4",
            "patch": "@@ -0,0 +1,203 @@\n+#!/bin/bash\n+#\n+# Benchmark dev server boot time (wall-clock)\n+#\n+# Measures TWO metrics:\n+#   1. listen_time: When server starts accepting TCP connections\n+#   2. ready_time: When server responds to first HTTP request\n+#\n+# The delta between these shows how much initialization is deferred after \"Ready\".\n+#\n+# Usage:\n+#   ./scripts/benchmark-boot-time.sh [runs] [test-dir]\n+#\n+# Examples:\n+#   ./scripts/benchmark-boot-time.sh           # 5 runs, uses /tmp/next-boot-test\n+#   ./scripts/benchmark-boot-time.sh 3         # 3 runs\n+#   ./scripts/benchmark-boot-time.sh 5 ./my-app  # 5 runs on existing app\n+\n+set -e\n+\n+RUNS=${1:-5}\n+TEST_DIR=${2:-/tmp/next-boot-test}\n+NEXT_BIN=\"$(dirname \"$0\")/../packages/next/dist/bin/next\"\n+PORT=3456\n+\n+echo \"=== Dev Server Boot Time Benchmark ===\"\n+echo \"Runs: $RUNS\"\n+echo \"Test dir: $TEST_DIR\"\n+echo \"Next.js: $NEXT_BIN\"\n+echo \"\"\n+echo \"Metrics:\"\n+echo \"  listen_time: TCP port accepting connections\"\n+echo \"  ready_time:  First HTTP request succeeds\"\n+echo \"  delta:       ready_time - listen_time (deferred init)\"\n+echo \"\"\n+\n+# Create test app if it doesn't exist\n+if [ ! -f \"$TEST_DIR/package.json\" ]; then\n+  echo \"Creating test app...\"\n+  mkdir -p \"$TEST_DIR/app\"\n+  cat > \"$TEST_DIR/package.json\" << 'EOF'\n+{\n+  \"name\": \"boot-test\",\n+  \"private\": true,\n+  \"dependencies\": {\n+    \"react\": \"19.0.0\",\n+    \"react-dom\": \"19.0.0\"\n+  }\n+}\n+EOF\n+  cat > \"$TEST_DIR/app/layout.tsx\" << 'EOF'\n+export default function RootLayout({ children }: { children: React.ReactNode }) {\n+  return <html><body>{children}</body></html>\n+}\n+EOF\n+  cat > \"$TEST_DIR/app/page.tsx\" << 'EOF'\n+export default function Home() { return <h1>Hello</h1> }\n+EOF\n+  (cd \"$TEST_DIR\" && npm install --silent)\n+  # Link local next\n+  (cd \"$TEST_DIR\" && npm link \"$(dirname \"$NEXT_BIN\")/..\" 2>/dev/null || true)\n+fi\n+\n+# Kill any existing next dev on our port\n+pkill -f \"next dev.*$PORT\" 2>/dev/null || true\n+sleep 0.5\n+\n+# Returns: listen_time,ready_time (comma-separated)\n+benchmark_run() {\n+  local label=$1\n+  local clean_next=$2\n+\n+  if [ \"$clean_next\" = \"true\" ]; then\n+    rm -rf \"$TEST_DIR/.next\"\n+  fi\n+\n+  # Measure wall-clock time from command start\n+  local start_time=$(python3 -c 'import time; print(int(time.time() * 1000))')\n+\n+  \"$NEXT_BIN\" dev --turbopack --port $PORT \"$TEST_DIR\" > /dev/null 2>&1 &\n+  local pid=$!\n+\n+  local timeout=600  # 30s at 50ms intervals\n+  local listen_time=\"\"\n+  local ready_time=\"\"\n+\n+  # Phase 1: Wait for port to be listening (nc -z)\n+  for i in $(seq 1 $timeout); do\n+    if nc -z localhost $PORT 2>/dev/null; then\n+      listen_time=$(python3 -c 'import time; print(int(time.time() * 1000))')\n+      break\n+    fi\n+    sleep 0.05\n+  done\n+\n+  # Phase 2: Wait for HTTP response (curl)\n+  if [ -n \"$listen_time\" ]; then\n+    for i in $(seq 1 $timeout); do\n+      if curl -s \"http://localhost:$PORT\" > /dev/null 2>&1; then\n+        ready_time=$(python3 -c 'import time; print(int(time.time() * 1000))')\n+        break\n+      fi\n+      sleep 0.05\n+    done\n+  fi\n+\n+  # Kill the server\n+  kill $pid 2>/dev/null || true\n+  wait $pid 2>/dev/null || true\n+\n+  if [ -n \"$listen_time\" ] && [ -n \"$ready_time\" ]; then\n+    local listen_delta=$((listen_time - start_time))\n+    local ready_delta=$((ready_time - start_time))\n+    echo \"$listen_delta,$ready_delta\"\n+  else\n+    echo \"TIMEOUT,TIMEOUT\"\n+  fi\n+}\n+\n+run_benchmark_series() {\n+  local series_name=$1\n+  local clean_next=$2\n+\n+  echo \"--- $series_name ---\"\n+  echo \"Run | Listen | Ready | Delta\"\n+  echo \"----|--------|-------|------\"\n+\n+  local listen_times=\"\"\n+  local ready_times=\"\"\n+  local deltas=\"\"\n+\n+  for i in $(seq 1 $RUNS); do\n+    RESULT=$(benchmark_run \"$series_name-$i\" \"$clean_next\")\n+    LISTEN=$(echo \"$RESULT\" | cut -d',' -f1)\n+    READY=$(echo \"$RESULT\" | cut -d',' -f2)\n+\n+    if [ \"$LISTEN\" != \"TIMEOUT\" ] && [ \"$READY\" != \"TIMEOUT\" ]; then\n+      DELTA=$((READY - LISTEN))\n+      printf \"%3d | %5dms | %5dms | %5dms\\n\" \"$i\" \"$LISTEN\" \"$READY\" \"$DELTA\"\n+      listen_times=\"$listen_times $LISTEN\"\n+      ready_times=\"$ready_times $READY\"\n+      deltas=\"$deltas $DELTA\"\n+    else\n+      printf \"%3d | TIMEOUT | TIMEOUT | -\\n\" \"$i\"\n+    fi\n+  done\n+\n+  # Calculate averages\n+  local listen_avg=$(echo $listen_times | tr ' ' '\\n' | grep -v '^$' | awk '{sum+=$1; count++} END {if(count>0) printf \"%.0f\", sum/count; else print \"N/A\"}')\n+  local ready_avg=$(echo $ready_times | tr ' ' '\\n' | grep -v '^$' | awk '{sum+=$1; count++} END {if(count>0) printf \"%.0f\", sum/count; else print \"N/A\"}')\n+  local delta_avg=$(echo $deltas | tr ' ' '\\n' | grep -v '^$' | awk '{sum+=$1; count++} END {if(count>0) printf \"%.0f\", sum/count; else print \"N/A\"}')\n+\n+  echo \"\"\n+  echo \"Average: listen=${listen_avg}ms, ready=${ready_avg}ms, delta=${delta_avg}ms\"\n+  echo \"\"\n+\n+  # Export for summary\n+  export \"${series_name}_LISTEN_AVG=$listen_avg\"\n+  export \"${series_name}_READY_AVG=$ready_avg\"\n+  export \"${series_name}_DELTA_AVG=$delta_avg\"\n+}\n+\n+# Run cold start benchmarks\n+run_benchmark_series \"COLD\" true\n+\n+# Warmup for bytecode cache\n+echo \"--- Warming up bytecode cache (12s) ---\"\n+\"$NEXT_BIN\" dev --turbopack --port $PORT \"$TEST_DIR\" > /dev/null 2>&1 &\n+WARMUP_PID=$!\n+for i in $(seq 1 200); do\n+  if curl -s \"http://localhost:$PORT\" > /dev/null 2>&1; then\n+    break\n+  fi\n+  sleep 0.05\n+done\n+sleep 12\n+kill $WARMUP_PID 2>/dev/null || true\n+wait $WARMUP_PID 2>/dev/null || true\n+echo \"\"\n+\n+# Run warm start benchmarks\n+run_benchmark_series \"WARM\" false\n+\n+# Summary\n+echo \"==============================================\"\n+echo \"                  SUMMARY\"\n+echo \"==============================================\"\n+echo \"\"\n+echo \"Cold Start ($RUNS runs):\"\n+echo \"  Port listening: ${COLD_LISTEN_AVG}ms\"\n+echo \"  First request:  ${COLD_READY_AVG}ms\"\n+echo \"  Deferred init:  ${COLD_DELTA_AVG}ms\"\n+echo \"\"\n+echo \"Warm Start ($RUNS runs):\"\n+echo \"  Port listening: ${WARM_LISTEN_AVG}ms\"\n+echo \"  First request:  ${WARM_READY_AVG}ms\"\n+echo \"  Deferred init:  ${WARM_DELTA_AVG}ms\"\n+echo \"\"\n+\n+if [ \"$COLD_READY_AVG\" != \"N/A\" ] && [ \"$WARM_READY_AVG\" != \"N/A\" ]; then\n+  CACHE_BENEFIT=$((COLD_READY_AVG - WARM_READY_AVG))\n+  echo \"Cache benefit: ${CACHE_BENEFIT}ms (cold - warm ready)\"\n+fi"
        },
        {
            "sha": "bea27f4c40a319061bf3365fa79461ac41e1ee90",
            "filename": "scripts/benchmark-next-dev-boot.js",
            "status": "added",
            "additions": 245,
            "deletions": 0,
            "changes": 245,
            "blob_url": "https://github.com/vercel/next.js/blob/a39366938a9bb669ef775404b3547a876ec2f0d4/scripts%2Fbenchmark-next-dev-boot.js",
            "raw_url": "https://github.com/vercel/next.js/raw/a39366938a9bb669ef775404b3547a876ec2f0d4/scripts%2Fbenchmark-next-dev-boot.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/scripts%2Fbenchmark-next-dev-boot.js?ref=a39366938a9bb669ef775404b3547a876ec2f0d4",
            "patch": "@@ -0,0 +1,245 @@\n+#!/usr/bin/env node\n+/**\n+ * Dev Server Boot Time Benchmark\n+ *\n+ * Usage:\n+ *   node scripts/benchmark-boot.js [options]\n+ *\n+ * Options:\n+ *   --iterations=N    Number of iterations (default: 5)\n+ *   --test-dir=PATH   Test project directory (default: /private/tmp/next-boot-test)\n+ *   --bundled         Use bundled dev server (default)\n+ *   --unbundled       Use unbundled dev server\n+ *   --compare         Run both bundled and unbundled for comparison\n+ *   --turbopack       Use Turbopack (default)\n+ *   --webpack         Use Webpack\n+ */\n+\n+const { spawn, execSync } = require('child_process')\n+const path = require('path')\n+const fs = require('fs')\n+\n+// Parse arguments\n+const args = process.argv.slice(2)\n+const getArg = (name, defaultValue) => {\n+  const arg = args.find((a) => a.startsWith(`--${name}=`))\n+  return arg ? arg.split('=')[1] : defaultValue\n+}\n+const hasFlag = (name) => args.includes(`--${name}`)\n+\n+const iterations = parseInt(getArg('iterations', '5'), 10)\n+const testDir = getArg('test-dir', '/private/tmp/next-boot-test')\n+const compare = hasFlag('compare')\n+const useWebpack = hasFlag('webpack')\n+const bundlerFlag = useWebpack ? '--webpack' : '--turbopack'\n+\n+const nextDir = path.join(__dirname, '..', 'packages', 'next')\n+const nextBin = path.join(nextDir, 'dist/bin/next')\n+const cliSource = path.join(nextDir, 'src/cli/next-dev.ts')\n+\n+console.log('\\x1b[34m=== Next.js Dev Server Boot Benchmark ===\\x1b[0m')\n+console.log(`Iterations: ${iterations}`)\n+console.log(`Test directory: ${testDir}`)\n+console.log(`Bundler: ${useWebpack ? 'Webpack' : 'Turbopack'}`)\n+console.log('')\n+\n+// Verify test directory exists\n+if (!fs.existsSync(testDir)) {\n+  console.error(\n+    `\\x1b[31mError: Test directory does not exist: ${testDir}\\x1b[0m`\n+  )\n+  console.log('Create a test project first:')\n+  console.log(`  mkdir -p ${testDir} && cd ${testDir}`)\n+  console.log('  pnpm init && pnpm add next@canary react react-dom')\n+  console.log(\n+    '  mkdir -p app && echo \"export default function Page() { return <h1>Hello</h1> }\" > app/page.tsx'\n+  )\n+  process.exit(1)\n+}\n+\n+// Kill existing next dev processes\n+function killNextDev() {\n+  try {\n+    execSync('pkill -f \"next dev\"', { stdio: 'ignore' })\n+  } catch {}\n+}\n+\n+// Run a single benchmark iteration\n+function runIteration() {\n+  return new Promise((resolve, reject) => {\n+    // Clean .next directory\n+    const nextCache = path.join(testDir, '.next')\n+    if (fs.existsSync(nextCache)) {\n+      fs.rmSync(nextCache, { recursive: true, force: true })\n+    }\n+\n+    const startTime = Date.now()\n+    let resolved = false\n+\n+    const child = spawn(nextBin, ['dev', bundlerFlag], {\n+      cwd: testDir,\n+      stdio: ['ignore', 'pipe', 'pipe'],\n+      env: { ...process.env, FORCE_COLOR: '0' },\n+    })\n+\n+    let output = ''\n+\n+    const onData = (data) => {\n+      output += data.toString()\n+      // Look for \"Ready in Xms\" pattern\n+      const match = output.match(/Ready in (\\d+)ms/)\n+      if (match && !resolved) {\n+        resolved = true\n+        const reportedTime = parseInt(match[1], 10)\n+        const actualTime = Date.now() - startTime\n+        child.kill('SIGTERM')\n+        resolve({ reportedTime, actualTime })\n+      }\n+    }\n+\n+    child.stdout.on('data', onData)\n+    child.stderr.on('data', onData)\n+\n+    child.on('error', (err) => {\n+      if (!resolved) {\n+        resolved = true\n+        reject(err)\n+      }\n+    })\n+\n+    // Timeout after 60 seconds\n+    setTimeout(() => {\n+      if (!resolved) {\n+        resolved = true\n+        child.kill('SIGKILL')\n+        reject(new Error('Timeout waiting for server to start'))\n+      }\n+    }, 60000)\n+  })\n+}\n+\n+// Run benchmark with multiple iterations\n+async function runBenchmark(name) {\n+  console.log(`\\x1b[33mRunning ${name}...\\x1b[0m`)\n+\n+  const reportedTimes = []\n+  const actualTimes = []\n+\n+  for (let i = 1; i <= iterations; i++) {\n+    try {\n+      killNextDev()\n+      await new Promise((r) => setTimeout(r, 500))\n+\n+      const { reportedTime, actualTime } = await runIteration()\n+      reportedTimes.push(reportedTime)\n+      actualTimes.push(actualTime)\n+      console.log(\n+        `  Run ${i}: ${reportedTime}ms (reported) / ${actualTime}ms (actual)`\n+      )\n+    } catch (err) {\n+      console.log(`  Run ${i}: Failed - ${err.message}`)\n+    }\n+  }\n+\n+  killNextDev()\n+\n+  if (reportedTimes.length === 0) {\n+    console.log('\\x1b[31mNo successful runs\\x1b[0m')\n+    return null\n+  }\n+\n+  // Calculate statistics\n+  const calcStats = (times) => {\n+    const sum = times.reduce((a, b) => a + b, 0)\n+    const avg = Math.round(sum / times.length)\n+    const min = Math.min(...times)\n+    const max = Math.max(...times)\n+    const sorted = [...times].sort((a, b) => a - b)\n+    const median = sorted[Math.floor(sorted.length / 2)]\n+    return { avg, min, max, median, count: times.length }\n+  }\n+\n+  const reported = calcStats(reportedTimes)\n+  const actual = calcStats(actualTimes)\n+\n+  console.log(`\\x1b[32mResults for ${name}:\\x1b[0m`)\n+  console.log(`  Reported time (Next.js internal):`)\n+  console.log(\n+    `    Avg: ${reported.avg}ms | Min: ${reported.min}ms | Max: ${reported.max}ms | Median: ${reported.median}ms`\n+  )\n+  console.log(`  Actual time (CLI to ready):`)\n+  console.log(\n+    `    Avg: ${actual.avg}ms | Min: ${actual.min}ms | Max: ${actual.max}ms | Median: ${actual.median}ms`\n+  )\n+  console.log('')\n+\n+  return { reported, actual }\n+}\n+\n+// Switch between bundled/unbundled\n+function setBundled(useBundled) {\n+  const content = fs.readFileSync(cliSource, 'utf-8')\n+\n+  const bundledPath = `require.resolve(\n+    '../compiled/dev-server/start-server'\n+  )`\n+  const unbundledPath = `require.resolve('../server/lib/start-server')`\n+\n+  let newContent\n+  if (useBundled) {\n+    newContent = content.replace(\n+      /const startServerPath = require\\.resolve\\(['\"]\\.\\.\\/server\\/lib\\/start-server['\"]\\)/,\n+      `const startServerPath = ${bundledPath}`\n+    )\n+  } else {\n+    newContent = content.replace(\n+      /const startServerPath = require\\.resolve\\(\\s*['\"]\\.\\.\\/compiled\\/dev-server\\/start-server['\"]\\s*\\)/,\n+      `const startServerPath = ${unbundledPath}`\n+    )\n+  }\n+\n+  if (newContent !== content) {\n+    fs.writeFileSync(cliSource, newContent)\n+    // Rebuild CLI\n+    console.log(`Rebuilding CLI (${useBundled ? 'bundled' : 'unbundled'})...`)\n+    execSync('npx taskr cli', { cwd: nextDir, stdio: 'ignore' })\n+  }\n+}\n+\n+// Main\n+async function main() {\n+  killNextDev()\n+\n+  if (compare) {\n+    // Run both bundled and unbundled\n+    setBundled(true)\n+    const bundledResults = await runBenchmark('Bundled dev server')\n+\n+    setBundled(false)\n+    const unbundledResults = await runBenchmark('Unbundled dev server')\n+\n+    // Restore to bundled\n+    setBundled(true)\n+\n+    // Print comparison\n+    console.log('\\x1b[34m=== Comparison ===\\x1b[0m')\n+    if (bundledResults && unbundledResults) {\n+      const reportedDiff =\n+        bundledResults.reported.avg - unbundledResults.reported.avg\n+      const actualDiff = bundledResults.actual.avg - unbundledResults.actual.avg\n+\n+      console.log(\n+        `Reported time difference: ${reportedDiff > 0 ? '+' : ''}${reportedDiff}ms (${reportedDiff > 0 ? 'bundled slower' : 'bundled faster'})`\n+      )\n+      console.log(\n+        `Actual time difference: ${actualDiff > 0 ? '+' : ''}${actualDiff}ms (${actualDiff > 0 ? 'bundled slower' : 'bundled faster'})`\n+      )\n+    }\n+  } else {\n+    await runBenchmark('Dev server')\n+  }\n+\n+  console.log('\\x1b[32mDone!\\x1b[0m')\n+}\n+\n+main().catch(console.error)"
        },
        {
            "sha": "eadbe6eb4f1eb1e3b2502c33918095184afe8805",
            "filename": "scripts/profile-next-dev-boot.js",
            "status": "added",
            "additions": 299,
            "deletions": 0,
            "changes": 299,
            "blob_url": "https://github.com/vercel/next.js/blob/a39366938a9bb669ef775404b3547a876ec2f0d4/scripts%2Fprofile-next-dev-boot.js",
            "raw_url": "https://github.com/vercel/next.js/raw/a39366938a9bb669ef775404b3547a876ec2f0d4/scripts%2Fprofile-next-dev-boot.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/scripts%2Fprofile-next-dev-boot.js?ref=a39366938a9bb669ef775404b3547a876ec2f0d4",
            "patch": "@@ -0,0 +1,299 @@\n+#!/usr/bin/env node\n+/**\n+ * Next.js CPU Profile Script\n+ *\n+ * Generates CPU profiles for Next.js startup and dev server boot.\n+ *\n+ * Usage:\n+ *   node scripts/profile-next-dev-boot.js [options]\n+ *\n+ * Options:\n+ *   --test-dir=PATH     Test project directory (default: /private/tmp/next-boot-test)\n+ *   --output-dir=PATH   Output directory for profiles (default: ./profiles)\n+ *   --turbopack         Use Turbopack (default)\n+ *   --webpack           Use Webpack\n+ *   --duration=MS       How long to profile after ready (default: 1000)\n+ *   --cli               Profile just the CLI entry point (runs next --help)\n+ *\n+ * Output files:\n+ *   - dev-turbopack-YYYY-MM-DDTHH-MM-SS.cpuprofile\n+ *   - cli-turbopack-YYYY-MM-DDTHH-MM-SS.cpuprofile\n+ *\n+ * The profile can be loaded in:\n+ *   - Chrome DevTools (Performance tab -> Load profile)\n+ *   - VS Code (JavaScript Profile Visualizer extension)\n+ *   - https://www.speedscope.app/\n+ *\n+ * Note: Currently profiles the parent process only. For child process profiling,\n+ * additional Next.js changes are needed (see future PRs).\n+ */\n+\n+const { spawn, execSync } = require('child_process')\n+const path = require('path')\n+const fs = require('fs')\n+\n+// Parse arguments\n+const args = process.argv.slice(2)\n+const getArg = (name, defaultValue) => {\n+  const arg = args.find((a) => a.startsWith(`--${name}=`))\n+  return arg ? arg.split('=')[1] : defaultValue\n+}\n+const hasFlag = (name) => args.includes(`--${name}`)\n+\n+const testDir = getArg('test-dir', '/private/tmp/next-boot-test')\n+const baseOutputDir =\n+  getArg('output-dir', null) || path.join(process.cwd(), 'profiles')\n+const useWebpack = hasFlag('webpack')\n+const duration = parseInt(getArg('duration', '1000'), 10)\n+const profileCli = hasFlag('cli')\n+const bundlerFlag = useWebpack ? '--webpack' : '--turbopack'\n+\n+// Generate meaningful profile names\n+const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19)\n+const bundlerName = useWebpack ? 'webpack' : 'turbopack'\n+const profileType = profileCli ? 'cli' : 'dev'\n+const outputDir = baseOutputDir\n+const profileName = `${profileType}-${bundlerName}-${timestamp}`\n+\n+const nextDir = path.join(__dirname, '..', 'packages', 'next')\n+const nextBin = path.join(nextDir, 'dist/bin/next')\n+\n+if (profileCli) {\n+  console.log('\\x1b[34m=== Next.js CLI Entry Point Profile ===\\x1b[0m')\n+} else {\n+  console.log('\\x1b[34m=== Next.js Dev Server CPU Profile ===\\x1b[0m')\n+  console.log(`Test directory: ${testDir}`)\n+  console.log(`Bundler: ${useWebpack ? 'Webpack' : 'Turbopack'}`)\n+}\n+console.log(`Output directory: ${outputDir}`)\n+console.log('')\n+\n+// Verify test directory (only for dev server profiling)\n+if (!profileCli && !fs.existsSync(testDir)) {\n+  console.error(\n+    `\\x1b[31mError: Test directory does not exist: ${testDir}\\x1b[0m`\n+  )\n+  process.exit(1)\n+}\n+\n+// Create output directory\n+if (!fs.existsSync(outputDir)) {\n+  fs.mkdirSync(outputDir, { recursive: true })\n+}\n+\n+// Kill existing processes\n+function killNextDev() {\n+  try {\n+    execSync('pkill -f \"next dev\"', { stdio: 'ignore' })\n+  } catch {}\n+}\n+\n+async function runProfile() {\n+  killNextDev()\n+  await new Promise((r) => setTimeout(r, 500))\n+\n+  // Clean .next directory\n+  const nextCache = path.join(testDir, '.next')\n+  if (fs.existsSync(nextCache)) {\n+    fs.rmSync(nextCache, { recursive: true, force: true })\n+  }\n+\n+  console.log('Starting dev server with CPU profiling...')\n+  console.log('(Profile will be saved after server is ready)')\n+  console.log('')\n+\n+  return new Promise((resolve, reject) => {\n+    let resolved = false\n+\n+    // Profile the parent process with --cpu-prof\n+    const spawnArgs = [\n+      process.execPath,\n+      [\n+        '--cpu-prof',\n+        `--cpu-prof-dir=${outputDir}`,\n+        `--cpu-prof-name=${profileName}`,\n+        nextBin,\n+        'dev',\n+        bundlerFlag,\n+      ],\n+    ]\n+\n+    const child = spawn(spawnArgs[0], spawnArgs[1], {\n+      cwd: testDir,\n+      stdio: ['ignore', 'pipe', 'pipe'],\n+      env: { ...process.env, FORCE_COLOR: '0' },\n+    })\n+\n+    let output = ''\n+\n+    const onData = (data) => {\n+      const text = data.toString()\n+      output += text\n+      process.stdout.write(text)\n+\n+      // Wait for \"Ready in Xms\"\n+      if (output.includes('Ready in') && !resolved) {\n+        resolved = true\n+        console.log('')\n+        console.log(\n+          `\\x1b[33mServer ready, profiling for ${duration}ms more...\\x1b[0m`\n+        )\n+\n+        // Wait a bit then stop\n+        setTimeout(() => {\n+          console.log('Stopping server and saving profile...')\n+          child.kill('SIGINT')\n+        }, duration)\n+      }\n+    }\n+\n+    child.stdout.on('data', onData)\n+    child.stderr.on('data', onData)\n+\n+    child.on('close', (code) => {\n+      killNextDev()\n+\n+      // Wait a moment for profile files to be written\n+      setTimeout(() => {\n+        // Find and rename profiles matching our name pattern\n+        // --cpu-prof-name creates files without extension\n+        const files = fs.readdirSync(outputDir)\n+        const rawFiles = files.filter(\n+          (f) => f.startsWith(profileName) && !f.endsWith('.cpuprofile')\n+        )\n+\n+        // Rename raw files to have .cpuprofile extension\n+        rawFiles.forEach((f) => {\n+          const oldPath = path.join(outputDir, f)\n+          const newPath = path.join(outputDir, `${f}.cpuprofile`)\n+          fs.renameSync(oldPath, newPath)\n+        })\n+\n+        // Now find all .cpuprofile files\n+        const profileFiles = fs\n+          .readdirSync(outputDir)\n+          .filter((f) => f.startsWith(profileName) && f.endsWith('.cpuprofile'))\n+        const profiles = profileFiles\n+          .map((f) => ({\n+            name: f,\n+            path: path.join(outputDir, f),\n+            size: fs.statSync(path.join(outputDir, f)).size,\n+          }))\n+          .filter((p) => p.size > 0)\n+          .sort((a, b) => b.size - a.size)\n+\n+        if (profiles.length > 0) {\n+          console.log('')\n+          console.log(`\\x1b[32mProfile(s) saved:\\x1b[0m`)\n+          profiles.forEach((p, i) => {\n+            const sizeKB = Math.round(p.size / 1024)\n+            console.log(`  ${i + 1}. ${p.path} (${sizeKB} KB)`)\n+          })\n+          console.log('')\n+          console.log('To view the profile:')\n+          console.log('  1. Open Chrome DevTools -> Performance tab')\n+          console.log('  2. Click \"Load profile\" and select the file')\n+          console.log('  3. Or use https://www.speedscope.app/')\n+          console.log('')\n+          console.log(\n+            '\\x1b[33mTip:\\x1b[0m The largest profile is usually the child process (server worker)'\n+          )\n+          resolve(profiles[0].path)\n+        } else {\n+          console.log('')\n+          console.log(\n+            '\\x1b[33mNo profiles found. Trying alternative method...\\x1b[0m'\n+          )\n+          console.log('')\n+          console.log(\n+            'To profile the child process, modify next-dev.ts to add profiling flags.'\n+          )\n+          console.log(\n+            'Or use: node --cpu-prof --cpu-prof-dir=./profiles ./dist/bin/next dev'\n+          )\n+          reject(new Error('Profile file not found'))\n+        }\n+      }, 500)\n+    })\n+\n+    child.on('error', reject)\n+\n+    // Timeout\n+    setTimeout(() => {\n+      if (!resolved) {\n+        child.kill('SIGKILL')\n+        reject(new Error('Timeout waiting for server'))\n+      }\n+    }, 120000)\n+  })\n+}\n+\n+async function runCliProfile() {\n+  console.log('Profiling CLI entry point (next --help)...')\n+  console.log('')\n+\n+  return new Promise((resolve, reject) => {\n+    const child = spawn(\n+      process.execPath,\n+      [\n+        '--cpu-prof',\n+        `--cpu-prof-dir=${outputDir}`,\n+        `--cpu-prof-name=${profileName}`,\n+        nextBin,\n+        '--help',\n+      ],\n+      {\n+        cwd: process.cwd(),\n+        stdio: ['ignore', 'pipe', 'pipe'],\n+        env: { ...process.env, FORCE_COLOR: '0' },\n+      }\n+    )\n+\n+    child.stdout.on('data', () => {})\n+    child.stderr.on('data', () => {})\n+\n+    child.on('close', (code) => {\n+      // Wait for profile to be written\n+      setTimeout(() => {\n+        // --cpu-prof-name creates files without extension, rename to .cpuprofile\n+        const rawFile = path.join(outputDir, profileName)\n+        const finalFile = path.join(outputDir, `${profileName}.cpuprofile`)\n+\n+        if (fs.existsSync(rawFile)) {\n+          fs.renameSync(rawFile, finalFile)\n+          const size = fs.statSync(finalFile).size\n+          console.log(`\\x1b[32mProfile saved:\\x1b[0m`)\n+          console.log(`  ${finalFile} (${Math.round(size / 1024)} KB)`)\n+          console.log('')\n+          console.log('To view the profile:')\n+          console.log('  1. Open Chrome DevTools -> Performance tab')\n+          console.log('  2. Click \"Load profile\" and select the file')\n+          console.log('  3. Or use https://www.speedscope.app/')\n+          console.log('')\n+          console.log(\n+            '\\x1b[33mTip:\\x1b[0m Look for heavy modules loaded at startup'\n+          )\n+          resolve(finalFile)\n+        } else if (fs.existsSync(finalFile)) {\n+          const size = fs.statSync(finalFile).size\n+          console.log(`\\x1b[32mProfile saved:\\x1b[0m`)\n+          console.log(`  ${finalFile} (${Math.round(size / 1024)} KB)`)\n+          resolve(finalFile)\n+        } else {\n+          reject(new Error('Profile file not found'))\n+        }\n+      }, 500)\n+    })\n+\n+    child.on('error', reject)\n+  })\n+}\n+\n+// Main execution\n+const main = profileCli ? runCliProfile : runProfile\n+\n+main().catch((err) => {\n+  console.error('\\x1b[31mError:\\x1b[0m', err.message)\n+  if (!profileCli) killNextDev()\n+  process.exit(1)\n+})"
        },
        {
            "sha": "96e9a23a92595c32d27c4d98860945182a07e53f",
            "filename": "scripts/trace-cli-startup.js",
            "status": "added",
            "additions": 139,
            "deletions": 0,
            "changes": 139,
            "blob_url": "https://github.com/vercel/next.js/blob/a39366938a9bb669ef775404b3547a876ec2f0d4/scripts%2Ftrace-cli-startup.js",
            "raw_url": "https://github.com/vercel/next.js/raw/a39366938a9bb669ef775404b3547a876ec2f0d4/scripts%2Ftrace-cli-startup.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/scripts%2Ftrace-cli-startup.js?ref=a39366938a9bb669ef775404b3547a876ec2f0d4",
            "patch": "@@ -0,0 +1,139 @@\n+#!/usr/bin/env node\n+/**\n+ * CLI Startup Tracer\n+ *\n+ * Uses the V8 Inspector API to trace module loading at CLI startup.\n+ * This helps identify which modules are being loaded eagerly.\n+ *\n+ * Usage:\n+ *   node scripts/trace-cli-startup.js [--command=dev|build|--help]\n+ */\n+\n+const inspector = require('inspector')\n+const fs = require('fs')\n+const path = require('path')\n+\n+const args = process.argv.slice(2)\n+const getArg = (name, defaultValue) => {\n+  const arg = args.find((a) => a.startsWith(`--${name}=`))\n+  return arg ? arg.split('=')[1] : defaultValue\n+}\n+\n+const command = getArg('command', '--help')\n+const outputDir = path.join(process.cwd(), 'profiles')\n+\n+if (!fs.existsSync(outputDir)) {\n+  fs.mkdirSync(outputDir, { recursive: true })\n+}\n+\n+console.log('\\x1b[34m=== Next.js CLI Startup Trace ===\\x1b[0m')\n+console.log(`Command: next ${command}`)\n+console.log(`Output directory: ${outputDir}`)\n+console.log('')\n+\n+// Start CPU profiling\n+const session = new inspector.Session()\n+session.connect()\n+\n+// Track module loading via require hook\n+const Module = require('module')\n+const originalRequire = Module.prototype.require\n+const loadedModules = []\n+const moduleLoadTimes = []\n+\n+Module.prototype.require = function (id) {\n+  const start = process.hrtime.bigint()\n+  const result = originalRequire.apply(this, arguments)\n+  const end = process.hrtime.bigint()\n+  const durationMs = Number(end - start) / 1e6\n+\n+  // Get the resolved path\n+  let resolvedPath = id\n+  try {\n+    resolvedPath = require.resolve(id, { paths: [this.path || process.cwd()] })\n+  } catch {}\n+\n+  // Filter to show only Next.js-related modules\n+  if (resolvedPath.includes('next/dist/') || resolvedPath.includes('@next/')) {\n+    const shortPath = resolvedPath.includes('next/dist/')\n+      ? resolvedPath.split('next/dist/')[1]\n+      : resolvedPath\n+\n+    if (!loadedModules.includes(shortPath)) {\n+      loadedModules.push(shortPath)\n+      moduleLoadTimes.push({ module: shortPath, time: durationMs })\n+    }\n+  }\n+\n+  return result\n+}\n+\n+// Save original process.exit and intercept to prevent CLI from exiting mid-profile\n+const originalExit = process.exit\n+process.exit = () => {\n+  // Don't actually exit during profiling - we want to capture the full profile\n+}\n+\n+// Start profiling\n+session.post('Profiler.enable', () => {\n+  session.post('Profiler.start', () => {\n+    console.log('Starting CLI with profiling...')\n+    console.log('')\n+\n+    const startTime = process.hrtime.bigint()\n+\n+    // Load the CLI\n+    try {\n+      process.argv = [process.argv[0], 'next', command]\n+      require('../packages/next/dist/bin/next')\n+    } catch (e) {\n+      // Expected - CLI might throw\n+    }\n+\n+    const endTime = process.hrtime.bigint()\n+    const totalMs = Number(endTime - startTime) / 1e6\n+\n+    // Stop profiling and save\n+    session.post('Profiler.stop', (err, { profile }) => {\n+      if (err) {\n+        console.error('Error stopping profiler:', err)\n+      } else {\n+        const profilePath = path.join(\n+          outputDir,\n+          `cli-startup-${Date.now()}.cpuprofile`\n+        )\n+        fs.writeFileSync(profilePath, JSON.stringify(profile))\n+        console.log(`\\x1b[32mProfile saved:\\x1b[0m ${profilePath}`)\n+      }\n+\n+      // Print results\n+      console.log('')\n+      console.log(`\\x1b[32mTotal startup time:\\x1b[0m ${totalMs.toFixed(2)}ms`)\n+      console.log('')\n+      console.log(`\\x1b[33mModules loaded (${loadedModules.length}):\\x1b[0m`)\n+      console.log('='.repeat(70))\n+\n+      // Sort by load time\n+      moduleLoadTimes.sort((a, b) => b.time - a.time)\n+      moduleLoadTimes.slice(0, 30).forEach((m, i) => {\n+        const timeStr =\n+          m.time > 1\n+            ? `${m.time.toFixed(1)}ms`\n+            : `${(m.time * 1000).toFixed(0)}Î¼s`\n+        console.log(`${String(i + 1).padStart(2)}. ${m.module} (${timeStr})`)\n+      })\n+\n+      console.log('')\n+      console.log(`\\x1b[33mAll loaded modules:\\x1b[0m`)\n+      console.log(loadedModules.join('\\n'))\n+\n+      // Restore original require\n+      Module.prototype.require = originalRequire\n+\n+      session.disconnect()\n+\n+      // Exit cleanly now that profiling is complete\n+      originalExit(0)\n+    })\n+  })\n+})"
        }
    ],
    "stats": {
        "total": 1077,
        "additions": 1077,
        "deletions": 0
    }
}