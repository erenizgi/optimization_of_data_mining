{
    "author": "H01001000",
    "message": "docs: cacheHandlers use object instead of class (#86022)\n\n<!-- Thanks for opening a PR! Your contribution is much appreciated.\nTo make sure your PR is handled as smoothly as possible we request that\nyou follow the checklist sections below.\nChoose the right checklist for the change(s) that you're making:\n\n## For Contributors\n\n### Improving Documentation\n\n- Run `pnpm prettier-fix` to fix formatting issues before opening the\nPR.\n- Read the Docs Contribution Guide to ensure your contribution follows\nthe docs guidelines:\nhttps://nextjs.org/docs/community/contribution-guide\n\n### Fixing a bug\n\n- Related issues linked using `fixes #number`\n- Tests added. See:\nhttps://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs\n- Errors have a helpful link attached, see\nhttps://github.com/vercel/next.js/blob/canary/contributing.md\n\n### Adding a feature\n\n- Implements an existing feature request or RFC. Make sure the feature\nrequest has been accepted for implementation before opening a PR. (A\ndiscussion must be opened, see\nhttps://github.com/vercel/next.js/discussions/new?category=ideas)\n- Related issues/discussions are linked using `fixes #number`\n- e2e tests added\n(https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs)\n- Documentation added\n- Telemetry added. In case of a feature if it's used or not.\n- Errors have a helpful link attached, see\nhttps://github.com/vercel/next.js/blob/canary/contributing.md\n\n\n## For Maintainers\n\n- Minimal description (aim for explaining to someone not on the team to\nunderstand the PR)\n- When linking to a Slack thread, you might want to share details of the\nconclusion\n- Link both the Linear (Fixes NEXT-xxx) and the GitHub issues\n- Add review comments if necessary to explain to the reviewer the logic\nbehind a change\n\n### What?\n\n### Why?\n\n### How?\n\nCloses NEXT-\nFixes #\n\n-->\n\nThis PR fixes the docs' example where it used class (like cacheHandler\n(no s)), but cacheHandlers expect an object.\n\n---------\n\nCo-authored-by: Joseph <joseph.chamochumbi@vercel.com>",
    "sha": "d174698cded19687b7b97b281c49b4dd2086a367",
    "files": [
        {
            "sha": "ba1c572e2112d96d5ab65fee7b522f5cbb7f4800",
            "filename": "docs/01-app/03-api-reference/05-config/01-next-config-js/cacheHandlers.mdx",
            "status": "modified",
            "additions": 30,
            "deletions": 32,
            "changes": 62,
            "blob_url": "https://github.com/vercel/next.js/blob/d174698cded19687b7b97b281c49b4dd2086a367/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FcacheHandlers.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/d174698cded19687b7b97b281c49b4dd2086a367/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FcacheHandlers.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F03-api-reference%2F05-config%2F01-next-config-js%2FcacheHandlers.mdx?ref=d174698cded19687b7b97b281c49b4dd2086a367",
            "patch": "@@ -41,8 +41,8 @@ import type { NextConfig } from 'next'\n \n const nextConfig: NextConfig = {\n   cacheHandlers: {\n-    default: './cache-handlers/default-handler.js',\n-    remote: './cache-handlers/remote-handler.js',\n+    default: require.resolve('./cache-handlers/default-handler.js'),\n+    remote: require.resolve('./cache-handlers/remote-handler.js'),\n   },\n }\n \n@@ -52,8 +52,8 @@ export default nextConfig\n ```js filename=\"next.config.js\" switcher\n module.exports = {\n   cacheHandlers: {\n-    default: './cache-handlers/default-handler.js',\n-    remote: './cache-handlers/remote-handler.js',\n+    default: require.resolve('./cache-handlers/default-handler.js'),\n+    remote: require.resolve('./cache-handlers/remote-handler.js'),\n   },\n }\n ```\n@@ -91,7 +91,7 @@ Returns a `CacheEntry` object if found, or `undefined` if not found or expired.\n Your `get` method should retrieve the cache entry from storage, check if it has expired based on the `revalidate` time, and return `undefined` for missing or expired entries.\n \n ```js\n-class CacheHandler {\n+const cacheHandler = {\n   async get(cacheKey, softTags) {\n     const entry = cache.get(cacheKey)\n     if (!entry) return undefined\n@@ -103,7 +103,7 @@ class CacheHandler {\n     }\n \n     return entry\n-  }\n+  },\n }\n ```\n \n@@ -127,14 +127,14 @@ Returns `Promise<void>`.\n Your `set` method must await the `pendingEntry` promise before storing it, since the cache entry may still be generating when this method is called. Once resolved, store the entry in your cache system.\n \n ```js\n-class CacheHandler {\n+const cacheHandler = {\n   async set(cacheKey, pendingEntry) {\n     // Wait for the entry to be ready\n     const entry = await pendingEntry\n \n     // Store in your cache system\n     cache.set(cacheKey, entry)\n-  }\n+  },\n }\n ```\n \n@@ -153,11 +153,11 @@ Returns `Promise<void>`.\n For in-memory caches, this can be a no-op. For distributed caches, use this to sync tag state from an external service or database before processing requests.\n \n ```js\n-class CacheHandler {\n+const cacheHandler = {\n   async refreshTags() {\n     // For in-memory cache, no action needed\n     // For distributed cache, sync tag state from external service\n-  }\n+  },\n }\n ```\n \n@@ -182,14 +182,14 @@ Returns:\n If you're not tracking tag revalidation timestamps, return `0`. Otherwise, find the most recent revalidation timestamp across all the provided tags. Return `Infinity` if you prefer to handle soft tag checking in the `get` method.\n \n ```js\n-class CacheHandler {\n+const cacheHandler = {\n   async getExpiration(tags) {\n     // Return 0 if not tracking tag revalidation\n     return 0\n \n     // Or return the most recent revalidation timestamp\n     // return Math.max(...tags.map(tag => tagTimestamps.get(tag) || 0));\n-  }\n+  },\n }\n ```\n \n@@ -213,15 +213,15 @@ Returns `Promise<void>`.\n When tags are revalidated, your handler should invalidate all cache entries that have any of those tags. Iterate through your cache and remove entries whose tags match the provided list.\n \n ```js\n-class CacheHandler {\n+const cacheHandler = {\n   async updateTags(tags, durations) {\n     // Invalidate all cache entries with matching tags\n     for (const [key, entry] of cache.entries()) {\n       if (entry.tags.some((tag) => tags.includes(tag))) {\n         cache.delete(key)\n       }\n     }\n-  }\n+  },\n }\n ```\n \n@@ -264,7 +264,7 @@ Here's a minimal implementation using a `Map` for storage. This example demonstr\n const cache = new Map()\n const pendingSets = new Map()\n \n-module.exports = class MemoryCacheHandler {\n+module.exports = {\n   async get(cacheKey, softTags) {\n     // Wait for any pending set operation to complete\n     const pendingPromise = pendingSets.get(cacheKey)\n@@ -284,7 +284,7 @@ module.exports = class MemoryCacheHandler {\n     }\n \n     return entry\n-  }\n+  },\n \n   async set(cacheKey, pendingEntry) {\n     // Create a promise to track this set operation\n@@ -304,16 +304,16 @@ module.exports = class MemoryCacheHandler {\n       resolvePending()\n       pendingSets.delete(cacheKey)\n     }\n-  }\n+  },\n \n   async refreshTags() {\n     // No-op for in-memory cache\n-  }\n+  },\n \n   async getExpiration(tags) {\n     // Return 0 to indicate no tags have been revalidated\n     return 0\n-  }\n+  },\n \n   async updateTags(tags, durations) {\n     // Implement tag-based invalidation\n@@ -322,7 +322,7 @@ module.exports = class MemoryCacheHandler {\n         cache.delete(key)\n       }\n     }\n-  }\n+  },\n }\n ```\n \n@@ -333,15 +333,13 @@ For durable storage like Redis or a database, you'll need to serialize the cache\n ```js filename=\"cache-handlers/redis-handler.js\"\n const { createClient } = require('redis')\n \n-module.exports = class RedisCacheHandler {\n-  constructor() {\n-    this.client = createClient({ url: process.env.REDIS_URL })\n-    this.client.connect()\n-  }\n+const client = createClient({ url: process.env.REDIS_URL })\n+client.connect()\n \n+module.exports = {\n   async get(cacheKey, softTags) {\n     // Retrieve from Redis\n-    const stored = await this.client.get(cacheKey)\n+    const stored = await client.get(cacheKey)\n     if (!stored) return undefined\n \n     // Deserialize the entry\n@@ -361,7 +359,7 @@ module.exports = class RedisCacheHandler {\n       expire: data.expire,\n       revalidate: data.revalidate,\n     }\n-  }\n+  },\n \n   async set(cacheKey, pendingEntry) {\n     const entry = await pendingEntry\n@@ -383,7 +381,7 @@ module.exports = class RedisCacheHandler {\n     // Combine chunks and serialize for Redis storage\n     const data = Buffer.concat(chunks.map((chunk) => Buffer.from(chunk)))\n \n-    await this.client.set(\n+    await client.set(\n       cacheKey,\n       JSON.stringify({\n         value: data.toString('base64'),\n@@ -395,23 +393,23 @@ module.exports = class RedisCacheHandler {\n       }),\n       { EX: entry.expire } // Use Redis TTL for automatic expiration\n     )\n-  }\n+  },\n \n   async refreshTags() {\n     // No-op for basic Redis implementation\n     // Could sync with external tag service if needed\n-  }\n+  },\n \n   async getExpiration(tags) {\n     // Return 0 to indicate no tags have been revalidated\n     // Could query Redis for tag expiration timestamps if tracking them\n     return 0\n-  }\n+  },\n \n   async updateTags(tags, durations) {\n     // Implement tag-based invalidation if needed\n     // Could iterate over keys with matching tags and delete them\n-  }\n+  },\n }\n ```\n "
        }
    ],
    "stats": {
        "total": 62,
        "additions": 30,
        "deletions": 32
    }
}