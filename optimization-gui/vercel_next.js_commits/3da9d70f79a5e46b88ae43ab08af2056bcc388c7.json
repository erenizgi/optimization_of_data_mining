{
    "author": "sokra",
    "message": "Turbopack: avoid deriving css source map path from generated code path (#77735)\n\n### What?\n\navoid using the original asset path for the source map path\n\ninstead compute our own path based on similar input. This will become more important when we are using content hashes for files.",
    "sha": "3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
    "files": [
        {
            "sha": "d6ce10838ebec78ba274f7aa0e5b04100ddaa68b",
            "filename": "test/integration/css-minify/test/index.test.js",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/test%2Fintegration%2Fcss-minify%2Ftest%2Findex.test.js",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/test%2Fintegration%2Fcss-minify%2Ftest%2Findex.test.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fintegration%2Fcss-minify%2Ftest%2Findex.test.js?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -25,8 +25,7 @@ function runTests() {\n        \"/* [project]/test/integration/css-minify/styles/global.css [client] (css) */\n        .a{--var-1:-50%;--var-2:-50%}.b{--var-1:0;--var-2:-50%}\n \n-       /*# sourceMappingURL=test_integration_css-minify_styles_global_411632c3.css.map*/\n-       \"\n+       /*# sourceMappingURL=test_integration_css-minify_styles_global_411632c3.css.map*/\"\n       `)\n     } else {\n       expect(css).toMatchInlineSnapshot("
        },
        {
            "sha": "6b368aec716c4974f560dbf8d75594dfc3268d95",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/chunk.rs",
            "status": "modified",
            "additions": 20,
            "deletions": 4,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fchunk.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -5,6 +5,7 @@ use turbo_tasks_fs::FileSystemPath;\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::{Chunk, ChunkingContext, OutputChunk, OutputChunkRuntimeInfo},\n+    ident::AssetIdent,\n     introspect::{Introspectable, IntrospectableChildren},\n     output::{OutputAsset, OutputAssets},\n     source_map::{GenerateSourceMap, OptionStringifiedSourceMap, SourceMapAsset},\n@@ -35,6 +36,22 @@ impl EcmascriptBrowserChunk {\n         }\n         .cell()\n     }\n+\n+    #[turbo_tasks::function]\n+    async fn source_map(self: Vc<Self>) -> Result<Vc<SourceMapAsset>> {\n+        let this = self.await?;\n+        Ok(SourceMapAsset::new(\n+            Vc::upcast(*this.chunking_context),\n+            this.ident_for_path(),\n+            Vc::upcast(self),\n+        ))\n+    }\n+}\n+\n+impl EcmascriptBrowserChunk {\n+    fn ident_for_path(&self) -> Vc<AssetIdent> {\n+        self.chunk.ident().with_modifier(modifier())\n+    }\n }\n \n #[turbo_tasks::value_impl]\n@@ -71,6 +88,7 @@ impl EcmascriptBrowserChunk {\n             *this.chunking_context,\n             self,\n             this.chunk.chunk_content(),\n+            self.source_map(),\n         ))\n     }\n \n@@ -84,7 +102,7 @@ impl EcmascriptBrowserChunk {\n impl OutputAsset for EcmascriptBrowserChunk {\n     #[turbo_tasks::function]\n     fn path(&self) -> Vc<FileSystemPath> {\n-        let ident = self.chunk.ident().with_modifier(modifier());\n+        let ident = self.ident_for_path();\n         self.chunking_context.chunk_path(ident, \".js\".into())\n     }\n \n@@ -107,9 +125,7 @@ impl OutputAsset for EcmascriptBrowserChunk {\n         references.extend(chunk_references.iter().copied());\n \n         if include_source_map {\n-            references.push(ResolvedVc::upcast(\n-                SourceMapAsset::new(Vc::upcast(self)).to_resolved().await?,\n-            ));\n+            references.push(ResolvedVc::upcast(self.source_map().to_resolved().await?));\n         }\n \n         Ok(Vc::cell(references))"
        },
        {
            "sha": "ee198b5b595b23e4948e216b6f33b03c7e42e546",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/content.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 17,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fcontent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fcontent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fcontent.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -4,13 +4,13 @@ use anyhow::{bail, Result};\n use indoc::writedoc;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, Vc};\n-use turbo_tasks_fs::File;\n+use turbo_tasks_fs::{rope::RopeBuilder, File};\n use turbopack_core::{\n     asset::AssetContent,\n     chunk::{ChunkingContext, MinifyType, ModuleId},\n     code_builder::{Code, CodeBuilder},\n     output::OutputAsset,\n-    source_map::{GenerateSourceMap, OptionStringifiedSourceMap},\n+    source_map::{GenerateSourceMap, OptionStringifiedSourceMap, SourceMapAsset},\n     version::{MergeableVersionedContent, Version, VersionedContent, VersionedContentMerger},\n };\n use turbopack_ecmascript::{chunk::EcmascriptChunkContent, minify::minify, utils::StringifyJs};\n@@ -26,6 +26,7 @@ pub struct EcmascriptBrowserChunkContent {\n     pub(super) chunking_context: ResolvedVc<BrowserChunkingContext>,\n     pub(super) chunk: ResolvedVc<EcmascriptBrowserChunk>,\n     pub(super) content: ResolvedVc<EcmascriptChunkContent>,\n+    pub(super) source_map: ResolvedVc<SourceMapAsset>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -35,11 +36,13 @@ impl EcmascriptBrowserChunkContent {\n         chunking_context: ResolvedVc<BrowserChunkingContext>,\n         chunk: ResolvedVc<EcmascriptBrowserChunk>,\n         content: ResolvedVc<EcmascriptChunkContent>,\n+        source_map: ResolvedVc<SourceMapAsset>,\n     ) -> Result<Vc<Self>> {\n         Ok(EcmascriptBrowserChunkContent {\n             chunking_context,\n             chunk,\n             content,\n+            source_map,\n         }\n         .cell())\n     }\n@@ -80,7 +83,7 @@ impl EcmascriptBrowserChunkContent {\n                 output_root.to_string()\n             );\n         };\n-        let mut code = CodeBuilder::default();\n+        let mut code = CodeBuilder::new(source_maps);\n \n         // When a chunk is executed, it will either register itself with the current\n         // instance of the runtime, or it will push itself onto the list of pending\n@@ -109,17 +112,6 @@ impl EcmascriptBrowserChunkContent {\n \n         write!(code, \"\\n}}]);\")?;\n \n-        if source_maps && code.has_source_map() {\n-            let filename = chunk_path.file_name();\n-            write!(\n-                code,\n-                // findSourceMapURL assumes this co-located sourceMappingURL,\n-                // and needs to be adjusted in case this is ever changed.\n-                \"\\n\\n//# sourceMappingURL={}.map\",\n-                urlencoding::encode(filename)\n-            )?;\n-        }\n-\n         let mut code = code.build();\n \n         if let MinifyType::Minify { mangle } = this.chunking_context.await?.minify_type() {\n@@ -134,10 +126,24 @@ impl EcmascriptBrowserChunkContent {\n impl VersionedContent for EcmascriptBrowserChunkContent {\n     #[turbo_tasks::function]\n     async fn content(self: Vc<Self>) -> Result<Vc<AssetContent>> {\n+        let this = self.await?;\n         let code = self.code().await?;\n-        Ok(AssetContent::file(\n-            File::from(code.source_code().clone()).into(),\n-        ))\n+\n+        let rope = if code.has_source_map() {\n+            let mut rope_builder = RopeBuilder::default();\n+            rope_builder.concat(code.source_code());\n+            let source_map_path = this.source_map.path().await?;\n+            write!(\n+                rope_builder,\n+                \"\\n\\n//# sourceMappingURL={}\",\n+                urlencoding::encode(source_map_path.file_name())\n+            )?;\n+            rope_builder.build()\n+        } else {\n+            code.source_code().clone()\n+        };\n+\n+        Ok(AssetContent::file(File::from(rope).into()))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "65491db75c4cd8fba02248f2942297f62caac327",
            "filename": "turbopack/crates/turbopack-browser/src/ecmascript/evaluate/chunk.rs",
            "status": "modified",
            "additions": 54,
            "deletions": 38,
            "changes": 92,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-browser%2Fsrc%2Fecmascript%2Fevaluate%2Fchunk.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -5,7 +5,7 @@ use indoc::writedoc;\n use serde::Serialize;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{ReadRef, ResolvedVc, TryJoinIterExt, Value, ValueToString, Vc};\n-use turbo_tasks_fs::{File, FileSystemPath};\n+use turbo_tasks_fs::{rope::RopeBuilder, File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::{\n@@ -130,7 +130,7 @@ impl EcmascriptBrowserEvaluateChunk {\n             runtime_module_ids,\n         };\n \n-        let mut code = CodeBuilder::default();\n+        let mut code = CodeBuilder::new(source_maps);\n \n         // We still use the `TURBOPACK` global variable to store the chunk here,\n         // as there may be another runtime already loaded in the page.\n@@ -178,17 +178,6 @@ impl EcmascriptBrowserEvaluateChunk {\n             }\n         }\n \n-        if source_maps && code.has_source_map() {\n-            let filename = chunk_path.file_name();\n-            write!(\n-                code,\n-                // findSourceMapURL assumes this co-located sourceMappingURL,\n-                // and needs to be adjusted in case this is ever changed.\n-                \"\\n\\n//# sourceMappingURL={}.map\",\n-                urlencoding::encode(filename)\n-            )?;\n-        }\n-\n         let mut code = code.build();\n \n         if let MinifyType::Minify { mangle } = this.chunking_context.await?.minify_type() {\n@@ -197,25 +186,9 @@ impl EcmascriptBrowserEvaluateChunk {\n \n         Ok(code.cell())\n     }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ValueToString for EcmascriptBrowserEvaluateChunk {\n-    #[turbo_tasks::function]\n-    fn to_string(&self) -> Vc<RcStr> {\n-        Vc::cell(\"Ecmascript Browser Evaluate Chunk\".into())\n-    }\n-}\n \n-#[turbo_tasks::function]\n-fn modifier() -> Vc<RcStr> {\n-    Vc::cell(\"ecmascript browser evaluate chunk\".into())\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl OutputAsset for EcmascriptBrowserEvaluateChunk {\n     #[turbo_tasks::function]\n-    async fn path(&self) -> Result<Vc<FileSystemPath>> {\n+    async fn ident_for_path(&self) -> Result<Vc<AssetIdent>> {\n         let mut ident = self.ident.owned().await?;\n \n         ident.add_modifier(modifier().to_resolved().await?);\n@@ -238,8 +211,40 @@ impl OutputAsset for EcmascriptBrowserEvaluateChunk {\n                 .await?,\n         );\n \n-        let ident = AssetIdent::new(Value::new(ident));\n-        Ok(self.chunking_context.chunk_path(ident, \".js\".into()))\n+        Ok(AssetIdent::new(Value::new(ident)))\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn source_map(self: Vc<Self>) -> Result<Vc<SourceMapAsset>> {\n+        let this = self.await?;\n+        Ok(SourceMapAsset::new(\n+            Vc::upcast(*this.chunking_context),\n+            self.ident_for_path(),\n+            Vc::upcast(self),\n+        ))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ValueToString for EcmascriptBrowserEvaluateChunk {\n+    #[turbo_tasks::function]\n+    fn to_string(&self) -> Vc<RcStr> {\n+        Vc::cell(\"Ecmascript Browser Evaluate Chunk\".into())\n+    }\n+}\n+\n+#[turbo_tasks::function]\n+fn modifier() -> Vc<RcStr> {\n+    Vc::cell(\"ecmascript browser evaluate chunk\".into())\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl OutputAsset for EcmascriptBrowserEvaluateChunk {\n+    #[turbo_tasks::function]\n+    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n+        let this = self.await?;\n+        let ident = self.ident_for_path();\n+        Ok(this.chunking_context.chunk_path(ident, \".js\".into()))\n     }\n \n     #[turbo_tasks::function]\n@@ -253,9 +258,7 @@ impl OutputAsset for EcmascriptBrowserEvaluateChunk {\n             .await?;\n \n         if include_source_map {\n-            references.push(ResolvedVc::upcast(\n-                SourceMapAsset::new(Vc::upcast(self)).to_resolved().await?,\n-            ));\n+            references.push(ResolvedVc::upcast(self.source_map().to_resolved().await?));\n         }\n \n         for chunk_data in &*self.chunks_data().await? {\n@@ -271,9 +274,22 @@ impl Asset for EcmascriptBrowserEvaluateChunk {\n     #[turbo_tasks::function]\n     async fn content(self: Vc<Self>) -> Result<Vc<AssetContent>> {\n         let code = self.code().await?;\n-        Ok(AssetContent::file(\n-            File::from(code.source_code().clone()).into(),\n-        ))\n+\n+        let rope = if code.has_source_map() {\n+            let mut rope_builder = RopeBuilder::default();\n+            rope_builder.concat(code.source_code());\n+            let source_map_path = self.source_map().path().await?;\n+            write!(\n+                rope_builder,\n+                \"\\n\\n//# sourceMappingURL={}\",\n+                urlencoding::encode(source_map_path.file_name())\n+            )?;\n+            rope_builder.build()\n+        } else {\n+            code.source_code().clone()\n+        };\n+\n+        Ok(AssetContent::file(File::from(rope).into()))\n     }\n }\n "
        },
        {
            "sha": "92504dd214dedaa41aaaa6774ca2597fbc8f3268",
            "filename": "turbopack/crates/turbopack-core/src/code_builder.rs",
            "status": "modified",
            "additions": 43,
            "deletions": 13,
            "changes": 56,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcode_builder.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcode_builder.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fcode_builder.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -37,13 +37,28 @@ impl Code {\n }\n \n /// CodeBuilder provides a mutable container to append source code.\n-#[derive(Default)]\n pub struct CodeBuilder {\n     code: RopeBuilder,\n-    mappings: Vec<Mapping>,\n+    mappings: Option<Vec<Mapping>>,\n+}\n+\n+impl Default for CodeBuilder {\n+    fn default() -> Self {\n+        Self {\n+            code: RopeBuilder::default(),\n+            mappings: Some(Vec::new()),\n+        }\n+    }\n }\n \n impl CodeBuilder {\n+    pub fn new(collect_mappings: bool) -> Self {\n+        Self {\n+            code: RopeBuilder::default(),\n+            mappings: collect_mappings.then(Vec::new),\n+        }\n+    }\n+\n     /// Pushes synthetic runtime code without an associated source map. This is\n     /// the default concatenation operation, but it's designed to be used\n     /// with the `+=` operator.\n@@ -72,12 +87,14 @@ impl CodeBuilder {\n             }\n \n             let len = self.code.len();\n-            self.mappings.extend(\n-                prebuilt\n-                    .mappings\n-                    .iter()\n-                    .map(|(index, map)| (index + len, map.clone())),\n-            );\n+            if let Some(mappings) = self.mappings.as_mut() {\n+                mappings.extend(\n+                    prebuilt\n+                        .mappings\n+                        .iter()\n+                        .map(|(index, map)| (index + len, map.clone())),\n+                );\n+            }\n         } else {\n             self.push_map(None);\n         }\n@@ -91,27 +108,32 @@ impl CodeBuilder {\n     /// synthetic section directly after an original section, we tell Chrome\n     /// that the previous map ended at this point.\n     fn push_map(&mut self, map: Option<Rope>) {\n-        if map.is_none() && matches!(self.mappings.last(), None | Some((_, None))) {\n+        let Some(mappings) = self.mappings.as_mut() else {\n+            return;\n+        };\n+        if map.is_none() && matches!(mappings.last(), None | Some((_, None))) {\n             // No reason to push an empty map directly after an empty map\n             return;\n         }\n \n         debug_assert!(\n-            map.is_some() || !self.mappings.is_empty(),\n+            map.is_some() || !mappings.is_empty(),\n             \"the first mapping is never a None\"\n         );\n-        self.mappings.push((self.code.len(), map));\n+        mappings.push((self.code.len(), map));\n     }\n \n     /// Tests if any code in this CodeBuilder contains an associated source map.\n     pub fn has_source_map(&self) -> bool {\n-        !self.mappings.is_empty()\n+        self.mappings\n+            .as_ref()\n+            .is_some_and(|mappings| !mappings.is_empty())\n     }\n \n     pub fn build(self) -> Code {\n         Code {\n             code: self.code.build(),\n-            mappings: self.mappings,\n+            mappings: self.mappings.unwrap_or_default(),\n         }\n     }\n }\n@@ -139,6 +161,14 @@ impl Write for CodeBuilder {\n     }\n }\n \n+impl From<Code> for CodeBuilder {\n+    fn from(code: Code) -> Self {\n+        let mut builder = CodeBuilder::default();\n+        builder.push_code(&code);\n+        builder\n+    }\n+}\n+\n #[turbo_tasks::value_impl]\n impl GenerateSourceMap for Code {\n     /// Generates the source map out of all the pushed Original code."
        },
        {
            "sha": "7edc7a5195af34a8840725f1a457ada26b756f61",
            "filename": "turbopack/crates/turbopack-core/src/source_map/source_map_asset.rs",
            "status": "modified",
            "additions": 61,
            "deletions": 14,
            "changes": 75,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fsource_map_asset.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fsource_map_asset.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fsource_map%2Fsource_map_asset.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -1,49 +1,94 @@\n-use anyhow::{bail, Result};\n+use anyhow::Result;\n+use serde::{Deserialize, Serialize};\n use turbo_rcstr::RcStr;\n-use turbo_tasks::{FxIndexSet, ResolvedVc, ValueToString, Vc};\n+use turbo_tasks::{\n+    debug::ValueDebugFormat, trace::TraceRawVcs, FxIndexSet, NonLocalValue, ResolvedVc,\n+    ValueToString, Vc,\n+};\n use turbo_tasks_fs::{File, FileSystemPath};\n \n use crate::{\n     asset::{Asset, AssetContent},\n+    chunk::ChunkingContext,\n+    ident::AssetIdent,\n     introspect::{Introspectable, IntrospectableChildren},\n     output::OutputAsset,\n     source_map::{GenerateSourceMap, SourceMap},\n };\n \n+#[derive(PartialEq, Eq, Serialize, Deserialize, NonLocalValue, TraceRawVcs, ValueDebugFormat)]\n+enum PathType {\n+    Fixed {\n+        path: ResolvedVc<FileSystemPath>,\n+    },\n+    FromIdent {\n+        chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+        ident_for_path: ResolvedVc<AssetIdent>,\n+    },\n+}\n+\n /// Represents the source map of an ecmascript asset.\n #[turbo_tasks::value]\n pub struct SourceMapAsset {\n-    asset: ResolvedVc<Box<dyn OutputAsset>>,\n+    path_ty: PathType,\n+    generate_source_map: ResolvedVc<Box<dyn GenerateSourceMap>>,\n }\n \n #[turbo_tasks::value_impl]\n impl SourceMapAsset {\n     #[turbo_tasks::function]\n-    pub fn new(asset: ResolvedVc<Box<dyn OutputAsset>>) -> Vc<Self> {\n-        SourceMapAsset { asset }.cell()\n+    pub fn new(\n+        chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+        ident_for_path: ResolvedVc<AssetIdent>,\n+        generate_source_map: ResolvedVc<Box<dyn GenerateSourceMap>>,\n+    ) -> Vc<Self> {\n+        SourceMapAsset {\n+            path_ty: PathType::FromIdent {\n+                chunking_context,\n+                ident_for_path,\n+            },\n+            generate_source_map,\n+        }\n+        .cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    pub fn new_fixed(\n+        path: ResolvedVc<FileSystemPath>,\n+        generate_source_map: ResolvedVc<Box<dyn GenerateSourceMap>>,\n+    ) -> Vc<Self> {\n+        SourceMapAsset {\n+            path_ty: PathType::Fixed { path },\n+            generate_source_map,\n+        }\n+        .cell()\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl OutputAsset for SourceMapAsset {\n     #[turbo_tasks::function]\n-    fn path(&self) -> Vc<FileSystemPath> {\n+    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n         // NOTE(alexkirsz) We used to include the asset's version id in the path,\n         // but this caused `all_assets_map` to be recomputed on every change.\n-        self.asset.path().append(\".map\".into())\n+        let this = self.await?;\n+        Ok(match this.path_ty {\n+            PathType::FromIdent {\n+                chunking_context,\n+                ident_for_path,\n+            } => chunking_context\n+                .chunk_path(*ident_for_path, \".js\".into())\n+                .append(\".map\".into()),\n+            PathType::Fixed { path } => path.append(\".map\".into()),\n+        })\n     }\n }\n \n #[turbo_tasks::value_impl]\n impl Asset for SourceMapAsset {\n     #[turbo_tasks::function]\n     async fn content(&self) -> Result<Vc<AssetContent>> {\n-        let Some(generate_source_map) =\n-            ResolvedVc::try_sidecast::<Box<dyn GenerateSourceMap>>(self.asset)\n-        else {\n-            bail!(\"asset does not support generating source maps\")\n-        };\n-        if let Some(sm) = &*generate_source_map.generate_source_map().await? {\n+        if let Some(sm) = &*self.generate_source_map.generate_source_map().await? {\n             Ok(AssetContent::file(File::from(sm.clone()).into()))\n         } else {\n             Ok(AssetContent::file(\n@@ -83,7 +128,9 @@ impl Introspectable for SourceMapAsset {\n     #[turbo_tasks::function]\n     async fn children(&self) -> Result<Vc<IntrospectableChildren>> {\n         let mut children = FxIndexSet::default();\n-        if let Some(asset) = ResolvedVc::try_sidecast::<Box<dyn Introspectable>>(self.asset) {\n+        if let Some(asset) =\n+            ResolvedVc::try_sidecast::<Box<dyn Introspectable>>(self.generate_source_map)\n+        {\n             children.insert((ResolvedVc::cell(\"asset\".into()), asset));\n         }\n         Ok(Vc::cell(children))"
        },
        {
            "sha": "93e2ba24cd5afca0602b5e75493e9a9503ab6542",
            "filename": "turbopack/crates/turbopack-css/src/chunk/mod.rs",
            "status": "modified",
            "additions": 88,
            "deletions": 72,
            "changes": 160,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fmod.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -10,7 +10,10 @@ use turbo_tasks::{\n     FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt, Value, ValueDefault, ValueToString,\n     Vc,\n };\n-use turbo_tasks_fs::{rope::Rope, File, FileSystem, FileSystemPath};\n+use turbo_tasks_fs::{\n+    rope::{Rope, RopeBuilder},\n+    File, FileSystem, FileSystemPath,\n+};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::{\n@@ -66,8 +69,13 @@ impl CssChunk {\n \n         let this = self.await?;\n \n-        let mut code = CodeBuilder::default();\n-        let mut body = CodeBuilder::default();\n+        let source_maps = *this\n+            .chunking_context\n+            .reference_chunk_source_maps(Vc::upcast(self))\n+            .await?;\n+\n+        let mut code = CodeBuilder::new(source_maps);\n+        let mut body = CodeBuilder::new(source_maps);\n         let mut external_imports = FxIndexSet::default();\n         for css_item in &this.content.await?.chunk_items {\n             let id = &*css_item.id().await?;\n@@ -109,30 +117,86 @@ impl CssChunk {\n         let built = &body.build();\n         code.push_code(built);\n \n-        if *this\n-            .chunking_context\n-            .reference_chunk_source_maps(Vc::upcast(self))\n-            .await?\n-            && code.has_source_map()\n-        {\n-            let chunk_path = self.path().await?;\n-            writeln!(\n-                code,\n-                \"/*# sourceMappingURL={}.map*/\",\n-                urlencoding::encode(chunk_path.file_name())\n-            )?;\n-        }\n-\n         let c = code.build().cell();\n         Ok(c)\n     }\n \n     #[turbo_tasks::function]\n     async fn content(self: Vc<Self>) -> Result<Vc<AssetContent>> {\n         let code = self.code().await?;\n-        Ok(AssetContent::file(\n-            File::from(code.source_code().clone()).into(),\n-        ))\n+\n+        let rope = if code.has_source_map() {\n+            use std::io::Write;\n+            let mut rope_builder = RopeBuilder::default();\n+            rope_builder.concat(code.source_code());\n+            let source_map_path = CssChunkSourceMapAsset::new(self).path().await?;\n+            write!(\n+                rope_builder,\n+                \"/*# sourceMappingURL={}*/\",\n+                urlencoding::encode(source_map_path.file_name())\n+            )?;\n+            rope_builder.build()\n+        } else {\n+            code.source_code().clone()\n+        };\n+\n+        Ok(AssetContent::file(File::from(rope).into()))\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn ident_for_path(&self) -> Result<Vc<AssetIdent>> {\n+        let CssChunkContent { chunk_items, .. } = &*self.content.await?;\n+        let mut common_path = if let Some(chunk_item) = chunk_items.first() {\n+            let path = chunk_item.asset_ident().path().to_resolved().await?;\n+            Some((path, path.await?))\n+        } else {\n+            None\n+        };\n+\n+        // The included chunk items and the availability info describe the chunk\n+        // uniquely\n+        let chunk_item_key = chunk_item_key().to_resolved().await?;\n+        for &chunk_item in chunk_items.iter() {\n+            if let Some((common_path_vc, common_path_ref)) = common_path.as_mut() {\n+                let path = chunk_item.asset_ident().path().await?;\n+                while !path.is_inside_or_equal_ref(common_path_ref) {\n+                    let parent = common_path_vc.parent().to_resolved().await?;\n+                    if parent == *common_path_vc {\n+                        common_path = None;\n+                        break;\n+                    }\n+                    *common_path_vc = parent;\n+                    *common_path_ref = (*common_path_vc).await?;\n+                }\n+            }\n+        }\n+        let assets = chunk_items\n+            .iter()\n+            .map(|chunk_item| async move {\n+                Ok((\n+                    chunk_item_key,\n+                    chunk_item.content_ident().to_resolved().await?,\n+                ))\n+            })\n+            .try_join()\n+            .await?;\n+\n+        let ident = AssetIdent {\n+            path: if let Some((common_path, _)) = common_path {\n+                common_path\n+            } else {\n+                ServerFileSystem::new().root().to_resolved().await?\n+            },\n+            query: ResolvedVc::cell(RcStr::default()),\n+            fragment: None,\n+            assets,\n+            modifiers: Vec::new(),\n+            parts: Vec::new(),\n+            layer: None,\n+            content_type: None,\n+        };\n+\n+        Ok(AssetIdent::new(Value::new(ident)))\n     }\n }\n \n@@ -253,61 +317,13 @@ fn chunk_item_key() -> Vc<RcStr> {\n #[turbo_tasks::value_impl]\n impl OutputAsset for CssChunk {\n     #[turbo_tasks::function]\n-    async fn path(&self) -> Result<Vc<FileSystemPath>> {\n-        let CssChunkContent { chunk_items, .. } = &*self.content.await?;\n-        let mut common_path = if let Some(chunk_item) = chunk_items.first() {\n-            let path = chunk_item.asset_ident().path().to_resolved().await?;\n-            Some((path, path.await?))\n-        } else {\n-            None\n-        };\n-\n-        // The included chunk items and the availability info describe the chunk\n-        // uniquely\n-        let chunk_item_key = chunk_item_key().to_resolved().await?;\n-        for &chunk_item in chunk_items.iter() {\n-            if let Some((common_path_vc, common_path_ref)) = common_path.as_mut() {\n-                let path = chunk_item.asset_ident().path().await?;\n-                while !path.is_inside_or_equal_ref(common_path_ref) {\n-                    let parent = common_path_vc.parent().to_resolved().await?;\n-                    if parent == *common_path_vc {\n-                        common_path = None;\n-                        break;\n-                    }\n-                    *common_path_vc = parent;\n-                    *common_path_ref = (*common_path_vc).await?;\n-                }\n-            }\n-        }\n-        let assets = chunk_items\n-            .iter()\n-            .map(|chunk_item| async move {\n-                Ok((\n-                    chunk_item_key,\n-                    chunk_item.content_ident().to_resolved().await?,\n-                ))\n-            })\n-            .try_join()\n-            .await?;\n-\n-        let ident = AssetIdent {\n-            path: if let Some((common_path, _)) = common_path {\n-                common_path\n-            } else {\n-                ServerFileSystem::new().root().to_resolved().await?\n-            },\n-            query: ResolvedVc::cell(RcStr::default()),\n-            fragment: None,\n-            assets,\n-            modifiers: Vec::new(),\n-            parts: Vec::new(),\n-            layer: None,\n-            content_type: None,\n-        };\n+    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n+        let ident = self.ident_for_path();\n \n         Ok(self\n+            .await?\n             .chunking_context\n-            .chunk_path(AssetIdent::new(Value::new(ident)), \".css\".into()))\n+            .chunk_path(ident, \".css\".into()))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "58ba49a9ddb9484828645781a89d358cc4ef0ffc",
            "filename": "turbopack/crates/turbopack-css/src/chunk/single_item_chunk/chunk.rs",
            "status": "modified",
            "additions": 35,
            "deletions": 27,
            "changes": 62,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fchunk.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -3,7 +3,7 @@ use std::fmt::Write;\n use anyhow::Result;\n use turbo_rcstr::RcStr;\n use turbo_tasks::{ResolvedVc, ValueToString, Vc};\n-use turbo_tasks_fs::{File, FileSystemPath};\n+use turbo_tasks_fs::{rope::RopeBuilder, File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n     chunk::{Chunk, ChunkItem, ChunkingContext},\n@@ -22,7 +22,7 @@ use crate::chunk::{write_import_context, CssChunkItem};\n /// avoiding rule duplication.\n #[turbo_tasks::value]\n pub struct SingleItemCssChunk {\n-    chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n+    pub(super) chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n     item: ResolvedVc<Box<dyn CssChunkItem>>,\n }\n \n@@ -49,7 +49,11 @@ impl SingleItemCssChunk {\n         use std::io::Write;\n \n         let this = self.await?;\n-        let mut code = CodeBuilder::default();\n+        let source_maps = *this\n+            .chunking_context\n+            .reference_chunk_source_maps(Vc::upcast(self))\n+            .await?;\n+        let mut code = CodeBuilder::new(source_maps);\n \n         let id = &*this.item.id().await?;\n \n@@ -60,23 +64,15 @@ impl SingleItemCssChunk {\n         code.push_source(&content.inner_code, content.source_map.clone());\n         write!(code, \"{close}\")?;\n \n-        if *this\n-            .chunking_context\n-            .reference_chunk_source_maps(Vc::upcast(self))\n-            .await?\n-            && code.has_source_map()\n-        {\n-            let chunk_path = self.path().await?;\n-            write!(\n-                code,\n-                \"\\n/*# sourceMappingURL={}.map*/\",\n-                urlencoding::encode(chunk_path.file_name())\n-            )?;\n-        }\n-\n         let c = code.build().cell();\n         Ok(c)\n     }\n+\n+    #[turbo_tasks::function]\n+    pub(super) async fn ident_for_path(&self) -> Result<Vc<AssetIdent>> {\n+        let item = self.item.asset_ident();\n+        Ok(item.with_modifier(single_item_modifier()))\n+    }\n }\n \n #[turbo_tasks::value_impl]\n@@ -101,13 +97,11 @@ fn single_item_modifier() -> Vc<RcStr> {\n #[turbo_tasks::value_impl]\n impl OutputAsset for SingleItemCssChunk {\n     #[turbo_tasks::function]\n-    fn path(&self) -> Vc<FileSystemPath> {\n-        self.chunking_context.chunk_path(\n-            self.item\n-                .asset_ident()\n-                .with_modifier(single_item_modifier()),\n-            \".single.css\".into(),\n-        )\n+    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n+        Ok(self\n+            .await?\n+            .chunking_context\n+            .chunk_path(self.ident_for_path(), \".single.css\".into()))\n     }\n \n     #[turbo_tasks::function]\n@@ -134,9 +128,23 @@ impl Asset for SingleItemCssChunk {\n     #[turbo_tasks::function]\n     async fn content(self: Vc<Self>) -> Result<Vc<AssetContent>> {\n         let code = self.code().await?;\n-        Ok(AssetContent::file(\n-            File::from(code.source_code().clone()).into(),\n-        ))\n+\n+        let rope = if code.has_source_map() {\n+            use std::io::Write;\n+            let mut rope_builder = RopeBuilder::default();\n+            rope_builder.concat(code.source_code());\n+            let source_map_path = SingleItemCssChunkSourceMapAsset::new(self).path().await?;\n+            write!(\n+                rope_builder,\n+                \"\\n/*# sourceMappingURL={}*/\",\n+                urlencoding::encode(source_map_path.file_name())\n+            )?;\n+            rope_builder.build()\n+        } else {\n+            code.source_code().clone()\n+        };\n+\n+        Ok(AssetContent::file(File::from(rope).into()))\n     }\n }\n "
        },
        {
            "sha": "9581ac62aeb28a261f6cef8c701f2140d8d0b64e",
            "filename": "turbopack/crates/turbopack-css/src/chunk/single_item_chunk/source_map.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 2,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fsource_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fsource_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsingle_item_chunk%2Fsource_map.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -3,6 +3,7 @@ use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n+    chunk::ChunkingContext,\n     output::OutputAsset,\n     source_map::{GenerateSourceMap, SourceMap},\n };\n@@ -26,8 +27,14 @@ impl SingleItemCssChunkSourceMapAsset {\n #[turbo_tasks::value_impl]\n impl OutputAsset for SingleItemCssChunkSourceMapAsset {\n     #[turbo_tasks::function]\n-    fn path(&self) -> Vc<FileSystemPath> {\n-        self.chunk.path().append(\".map\".into())\n+    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n+        let this = self.await?;\n+        Ok(this\n+            .chunk\n+            .await?\n+            .chunking_context\n+            .chunk_path(this.chunk.ident_for_path(), \".single.css\".into())\n+            .append(\".map\".into()))\n     }\n }\n "
        },
        {
            "sha": "3a5ee8af5337f1fc71f60574d3444e382b3032f2",
            "filename": "turbopack/crates/turbopack-css/src/chunk/source_map.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsource_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsource_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-css%2Fsrc%2Fchunk%2Fsource_map.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -3,6 +3,7 @@ use turbo_tasks::{ResolvedVc, Vc};\n use turbo_tasks_fs::{File, FileSystemPath};\n use turbopack_core::{\n     asset::{Asset, AssetContent},\n+    chunk::ChunkingContext,\n     output::OutputAsset,\n     source_map::{GenerateSourceMap, SourceMap},\n };\n@@ -26,8 +27,15 @@ impl CssChunkSourceMapAsset {\n #[turbo_tasks::value_impl]\n impl OutputAsset for CssChunkSourceMapAsset {\n     #[turbo_tasks::function]\n-    fn path(&self) -> Vc<FileSystemPath> {\n-        self.chunk.path().append(\".map\".into())\n+    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n+        let this = self.await?;\n+        let ident = this.chunk.ident_for_path();\n+        Ok(this\n+            .chunk\n+            .await?\n+            .chunking_context\n+            .chunk_path(ident, \".css\".into())\n+            .append(\".map\".into()))\n     }\n }\n "
        },
        {
            "sha": "66d1bd28eeb47a37cffcfa36f40c4cdd299b070f",
            "filename": "turbopack/crates/turbopack-ecmascript/src/minify.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 14,
            "changes": 16,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fminify.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fminify.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fminify.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -1,4 +1,4 @@\n-use std::{io::Write, sync::Arc};\n+use std::sync::Arc;\n \n use anyhow::{bail, Context, Result};\n use swc_core::{\n@@ -118,21 +118,13 @@ pub fn minify(path: &FileSystemPath, code: &Code, source_maps: bool, mangle: boo\n         print_program(cm.clone(), program, source_maps.is_some())?\n     };\n \n-    let mut builder = CodeBuilder::default();\n+    let mut builder = CodeBuilder::new(source_maps.is_some());\n     if let Some(original_map) = source_maps.as_ref() {\n         src_map_buf.shrink_to_fit();\n         builder.push_source(\n             &src.into(),\n             Some(generate_js_source_map(cm, src_map_buf, Some(original_map))?),\n         );\n-\n-        write!(\n-            builder,\n-            // findSourceMapURL assumes this co-located sourceMappingURL,\n-            // and needs to be adjusted in case this is ever changed.\n-            \"\\n//# sourceMappingURL={}.map\",\n-            urlencoding::encode(path.file_name())\n-        )?;\n     } else {\n         builder.push_source(&src.into(), None);\n     }\n@@ -168,10 +160,6 @@ fn print_program(\n                 .emit_program(&program)\n                 .context(\"failed to emit module\")?;\n         }\n-        if source_maps {\n-            // end with a new line when we have a source map comment\n-            buf.push(b'\\n');\n-        }\n         // Invalid utf8 is valid in javascript world.\n         // SAFETY: SWC generates valid utf8.\n         unsafe { String::from_utf8_unchecked(buf) }"
        },
        {
            "sha": "47254afc194c55cdddfd570dd535e6e522d04771",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/chunk.rs",
            "status": "modified",
            "additions": 12,
            "deletions": 3,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fchunk.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -36,6 +36,16 @@ impl EcmascriptBuildNodeChunk {\n         }\n         .cell()\n     }\n+\n+    #[turbo_tasks::function]\n+    async fn source_map(self: Vc<Self>) -> Result<Vc<SourceMapAsset>> {\n+        let this = self.await?;\n+        Ok(SourceMapAsset::new(\n+            Vc::upcast(*this.chunking_context),\n+            this.chunk.ident().with_modifier(modifier()),\n+            Vc::upcast(self),\n+        ))\n+    }\n }\n \n #[turbo_tasks::value_impl]\n@@ -60,6 +70,7 @@ impl EcmascriptBuildNodeChunk {\n             *this.chunking_context,\n             self,\n             this.chunk.chunk_content(),\n+            self.source_map(),\n         ))\n     }\n }\n@@ -88,9 +99,7 @@ impl OutputAsset for EcmascriptBuildNodeChunk {\n         }\n \n         if include_source_map {\n-            references.push(ResolvedVc::upcast(\n-                SourceMapAsset::new(Vc::upcast(self)).to_resolved().await?,\n-            ));\n+            references.push(ResolvedVc::upcast(self.source_map().to_resolved().await?));\n         }\n \n         Ok(Vc::cell(references))"
        },
        {
            "sha": "47164914800f68d11e78805e7c19e628ba5c9dac",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/content.rs",
            "status": "modified",
            "additions": 23,
            "deletions": 15,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fcontent.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fcontent.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fcontent.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -1,13 +1,13 @@\n use anyhow::Result;\n use indoc::writedoc;\n use turbo_tasks::{ResolvedVc, Vc};\n-use turbo_tasks_fs::File;\n+use turbo_tasks_fs::{rope::RopeBuilder, File};\n use turbopack_core::{\n     asset::AssetContent,\n     chunk::{ChunkingContext, MinifyType},\n     code_builder::{Code, CodeBuilder},\n     output::OutputAsset,\n-    source_map::{GenerateSourceMap, OptionStringifiedSourceMap},\n+    source_map::{GenerateSourceMap, OptionStringifiedSourceMap, SourceMapAsset},\n     version::{Version, VersionedContent},\n };\n use turbopack_ecmascript::{chunk::EcmascriptChunkContent, minify::minify, utils::StringifyJs};\n@@ -20,6 +20,7 @@ pub(super) struct EcmascriptBuildNodeChunkContent {\n     pub(super) content: ResolvedVc<EcmascriptChunkContent>,\n     pub(super) chunking_context: ResolvedVc<NodeJsChunkingContext>,\n     pub(super) chunk: ResolvedVc<EcmascriptBuildNodeChunk>,\n+    pub(super) source_map: ResolvedVc<SourceMapAsset>,\n }\n \n #[turbo_tasks::value_impl]\n@@ -29,11 +30,13 @@ impl EcmascriptBuildNodeChunkContent {\n         chunking_context: ResolvedVc<NodeJsChunkingContext>,\n         chunk: ResolvedVc<EcmascriptBuildNodeChunk>,\n         content: ResolvedVc<EcmascriptChunkContent>,\n+        source_map: ResolvedVc<SourceMapAsset>,\n     ) -> Vc<Self> {\n         EcmascriptBuildNodeChunkContent {\n             content,\n             chunking_context,\n             chunk,\n+            source_map,\n         }\n         .cell()\n     }\n@@ -50,7 +53,6 @@ impl EcmascriptBuildNodeChunkContent {\n             .reference_chunk_source_maps(*ResolvedVc::upcast(this.chunk))\n             .await?;\n         let chunk_path_vc = this.chunk.path();\n-        let chunk_path = chunk_path_vc.await?;\n \n         let mut code = CodeBuilder::default();\n \n@@ -74,15 +76,6 @@ impl EcmascriptBuildNodeChunkContent {\n \n         write!(code, \"\\n}};\")?;\n \n-        if source_maps && code.has_source_map() {\n-            let filename = chunk_path.file_name();\n-            write!(\n-                code,\n-                \"\\n\\n//# sourceMappingURL={}.map\",\n-                urlencoding::encode(filename)\n-            )?;\n-        }\n-\n         let mut code = code.build();\n \n         if let MinifyType::Minify { mangle } = this.chunking_context.await?.minify_type() {\n@@ -115,10 +108,25 @@ impl GenerateSourceMap for EcmascriptBuildNodeChunkContent {\n impl VersionedContent for EcmascriptBuildNodeChunkContent {\n     #[turbo_tasks::function]\n     async fn content(self: Vc<Self>) -> Result<Vc<AssetContent>> {\n+        let this = self.await?;\n         let code = self.code().await?;\n-        Ok(AssetContent::file(\n-            File::from(code.source_code().clone()).into(),\n-        ))\n+\n+        let rope = if code.has_source_map() {\n+            use std::io::Write;\n+            let mut rope_builder = RopeBuilder::default();\n+            rope_builder.concat(code.source_code());\n+            let source_map_path = this.source_map.path().await?;\n+            write!(\n+                rope_builder,\n+                \"\\n\\n//# sourceMappingURL={}\",\n+                urlencoding::encode(source_map_path.file_name())\n+            )?;\n+            rope_builder.build()\n+        } else {\n+            code.source_code().clone()\n+        };\n+\n+        Ok(AssetContent::file(File::from(rope).into()))\n     }\n \n     #[turbo_tasks::function]"
        },
        {
            "sha": "e91560657152c6b6ed0cf9ce85be6a44f683f0e7",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/entry/chunk.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 3,
            "changes": 10,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fchunk.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -148,6 +148,12 @@ impl EcmascriptBuildNodeEntryChunk {\n     fn runtime_chunk(&self) -> Vc<EcmascriptBuildNodeRuntimeChunk> {\n         EcmascriptBuildNodeRuntimeChunk::new(*self.chunking_context)\n     }\n+\n+    #[turbo_tasks::function]\n+    async fn source_map(self: Vc<Self>) -> Result<Vc<SourceMapAsset>> {\n+        let this = self.await?;\n+        Ok(SourceMapAsset::new_fixed(*this.path, Vc::upcast(self)))\n+    }\n }\n \n #[turbo_tasks::value_impl]\n@@ -187,9 +193,7 @@ impl OutputAsset for EcmascriptBuildNodeEntryChunk {\n             .reference_chunk_source_maps(Vc::upcast(self))\n             .await?\n         {\n-            references.push(ResolvedVc::upcast(\n-                SourceMapAsset::new(Vc::upcast(self)).to_resolved().await?,\n-            ))\n+            references.push(ResolvedVc::upcast(self.source_map().to_resolved().await?))\n         }\n \n         let other_chunks = this.other_chunks.await?;"
        },
        {
            "sha": "b474078920f830e28864194b240084eed3a6df30",
            "filename": "turbopack/crates/turbopack-nodejs/src/ecmascript/node/entry/runtime.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 10,
            "changes": 34,
            "blob_url": "https://github.com/vercel/next.js/blob/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fruntime.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/3da9d70f79a5e46b88ae43ab08af2056bcc388c7/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fruntime.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-nodejs%2Fsrc%2Fecmascript%2Fnode%2Fentry%2Fruntime.rs?ref=3da9d70f79a5e46b88ae43ab08af2056bcc388c7",
            "patch": "@@ -93,6 +93,25 @@ impl EcmascriptBuildNodeRuntimeChunk {\n \n         Ok(Code::cell(code.build()))\n     }\n+\n+    #[turbo_tasks::function]\n+    fn ident_for_path(self: Vc<Self>) -> Vc<AssetIdent> {\n+        AssetIdent::from_path(\n+            turbopack_ecmascript_runtime::embed_fs()\n+                .root()\n+                .join(\"runtime.js\".into()),\n+        )\n+    }\n+\n+    #[turbo_tasks::function]\n+    async fn source_map(self: Vc<Self>) -> Result<Vc<SourceMapAsset>> {\n+        let this = self.await?;\n+        Ok(SourceMapAsset::new(\n+            Vc::upcast(*this.chunking_context),\n+            self.ident_for_path(),\n+            Vc::upcast(self),\n+        ))\n+    }\n }\n \n #[turbo_tasks::value_impl]\n@@ -106,14 +125,11 @@ impl ValueToString for EcmascriptBuildNodeRuntimeChunk {\n #[turbo_tasks::value_impl]\n impl OutputAsset for EcmascriptBuildNodeRuntimeChunk {\n     #[turbo_tasks::function]\n-    fn path(&self) -> Vc<FileSystemPath> {\n-        let ident = AssetIdent::from_path(\n-            turbopack_ecmascript_runtime::embed_fs()\n-                .root()\n-                .join(\"runtime.js\".into()),\n-        );\n+    async fn path(self: Vc<Self>) -> Result<Vc<FileSystemPath>> {\n+        let this = self.await?;\n+        let ident = self.ident_for_path();\n \n-        self.chunking_context.chunk_path(ident, \".js\".into())\n+        Ok(this.chunking_context.chunk_path(ident, \".js\".into()))\n     }\n \n     #[turbo_tasks::function]\n@@ -126,9 +142,7 @@ impl OutputAsset for EcmascriptBuildNodeRuntimeChunk {\n             .reference_chunk_source_maps(Vc::upcast(self))\n             .await?\n         {\n-            references.push(ResolvedVc::upcast(\n-                SourceMapAsset::new(Vc::upcast(self)).to_resolved().await?,\n-            ))\n+            references.push(ResolvedVc::upcast(self.source_map().to_resolved().await?))\n         }\n \n         Ok(Vc::cell(references))"
        }
    ],
    "stats": {
        "total": 648,
        "additions": 412,
        "deletions": 236
    }
}