{
    "author": "mischnic",
    "message": "Turbopack: transpile runtime with swc (#84931)\n\nTranspile the Turbopack runtime according to browserslist\r\nWe need to inline swc helpers, as the runtime is what provides the module system at runtime (so we cannot require anything here)\r\n\r\nPart of #83799  \r\nRelated to [PACK-5450](https://linear.app/vercel/issue/PACK-5450/turbopack-builds-do-not-correctly-process-all-files-ex-turbopack)",
    "sha": "6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
    "files": [
        {
            "sha": "ddb4cb684c01c0b5bd78e469da79624dbbdb3305",
            "filename": "crates/next-core/src/segment_config.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/crates%2Fnext-core%2Fsrc%2Fsegment_config.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/crates%2Fnext-core%2Fsrc%2Fsegment_config.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fsegment_config.rs?ref=6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
            "patch": "@@ -387,6 +387,7 @@ pub async fn parse_segment_config_from_source(\n         },\n         EcmascriptInputTransforms::empty(),\n         false,\n+        false,\n     )\n     .await?;\n "
        },
        {
            "sha": "9f49a3252446c1c2a5a2b82b5f79f164cb4b2580",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/src/asset_context.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 4,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fsrc%2Fasset_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fsrc%2Fasset_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fsrc%2Fasset_context.rs?ref=6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
            "patch": "@@ -20,12 +20,10 @@ pub async fn get_runtime_asset_context(\n             enable_typescript_transform: Some(\n                 TypescriptTransformOptions::default().resolved_cell(),\n             ),\n+            inline_helpers: true,\n             ..Default::default()\n         },\n-        // TODO: This fails when enabled, we cannot insert helpers for the runtime code as this\n-        // happens after bundling.\n-        // environment: Some(environment),\n-        environment: None,\n+        environment: Some(environment),\n         tree_shaking_mode: Some(TreeShakingMode::ReexportsOnly),\n         ..Default::default()\n     }"
        },
        {
            "sha": "4340c1159bff09f17302b9730ccca73891b56f38",
            "filename": "turbopack/crates/turbopack-ecmascript/Cargo.toml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-ecmascript%2FCargo.toml",
            "raw_url": "https://github.com/vercel/next.js/raw/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-ecmascript%2FCargo.toml",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2FCargo.toml?ref=6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
            "patch": "@@ -63,6 +63,7 @@ swc_core = { workspace = true, features = [\n   \"common_sourcemap\",\n   \"ecma_ast_shrink\",\n   \"ecma_codegen\",\n+  \"ecma_helpers_inline\",\n   \"ecma_lints\",\n   \"ecma_minifier\",\n   \"ecma_parser\","
        },
        {
            "sha": "49f70f47d8f5855f50967123dd11c7467c3636c6",
            "filename": "turbopack/crates/turbopack-ecmascript/src/lib.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Flib.rs?ref=6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
            "patch": "@@ -270,6 +270,8 @@ pub struct EcmascriptOptions {\n     // node_modules.\n     /// Whether to replace `typeof window` with some constant value.\n     pub enable_typeof_window_inlining: Option<TypeofWindow>,\n+\n+    pub inline_helpers: bool,\n }\n \n #[turbo_tasks::value]\n@@ -687,11 +689,13 @@ impl EcmascriptModuleAsset {\n \n impl EcmascriptModuleAsset {\n     pub async fn parse(&self) -> Result<Vc<ParseResult>> {\n+        let options = self.options.await?;\n         Ok(parse(\n             *self.source,\n             self.ty,\n             *self.transforms,\n-            self.options.await?.analyze_mode == AnalyzeMode::Tracing,\n+            options.analyze_mode == AnalyzeMode::Tracing,\n+            options.inline_helpers,\n         ))\n     }\n "
        },
        {
            "sha": "21f193bbd82c0249b652defd511bbc6ee482e698",
            "filename": "turbopack/crates/turbopack-ecmascript/src/parse.rs",
            "status": "modified",
            "additions": 39,
            "deletions": 37,
            "changes": 76,
            "blob_url": "https://github.com/vercel/next.js/blob/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fparse.rs?ref=6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
            "patch": "@@ -13,11 +13,14 @@ use swc_core::{\n     },\n     ecma::{\n         ast::{EsVersion, Id, ObjectPatProp, Pat, Program, VarDecl},\n-        lints::{config::LintConfig, rules::LintParams},\n+        lints::{self, config::LintConfig, rules::LintParams},\n         parser::{EsSyntax, Parser, Syntax, TsSyntax, lexer::Lexer},\n-        transforms::base::{\n-            helpers::{HELPERS, Helpers},\n-            resolver,\n+        transforms::{\n+            base::{\n+                helpers::{HELPERS, Helpers},\n+                resolver,\n+            },\n+            proposal::explicit_resource_management::explicit_resource_management,\n         },\n         visit::{Visit, VisitMutWith, VisitWith, noop_visit_type},\n     },\n@@ -174,6 +177,7 @@ pub async fn parse(\n     ty: EcmascriptModuleAssetType,\n     transforms: ResolvedVc<EcmascriptInputTransforms>,\n     is_external_tracing: bool,\n+    inline_helpers: bool,\n ) -> Result<Vc<ParseResult>> {\n     let span = tracing::info_span!(\n         \"parse ecmascript\",\n@@ -186,6 +190,7 @@ pub async fn parse(\n         ty,\n         transforms,\n         is_external_tracing && matches!(ty, EcmascriptModuleAssetType::EcmascriptExtensionless),\n+        inline_helpers,\n     )\n     .instrument(span)\n     .await\n@@ -203,6 +208,7 @@ async fn parse_internal(\n     ty: EcmascriptModuleAssetType,\n     transforms: ResolvedVc<EcmascriptInputTransforms>,\n     loose_errors: bool,\n+    inline_helpers: bool,\n ) -> Result<Vc<ParseResult>> {\n     let content = source.content();\n     let fs_path = source.ident().path().owned().await?;\n@@ -247,6 +253,7 @@ async fn parse_internal(\n                             ty,\n                             transforms,\n                             loose_errors,\n+                            inline_helpers,\n                         )\n                         .await\n                         {\n@@ -302,6 +309,7 @@ async fn parse_file_content(\n     ty: EcmascriptModuleAssetType,\n     transforms: &[EcmascriptInputTransform],\n     loose_errors: bool,\n+    inline_helpers: bool,\n ) -> Result<Vc<ParseResult>> {\n     let source_map: Arc<swc_core::common::SourceMap> = Default::default();\n     let (emitter, collector) = IssueEmitter::new(\n@@ -331,19 +339,20 @@ async fn parse_file_content(\n                 let lexer = Lexer::new(\n                     match ty {\n                         EcmascriptModuleAssetType::Ecmascript\n-                        | EcmascriptModuleAssetType::EcmascriptExtensionless\n-                        => Syntax::Es(EsSyntax {\n-                            jsx: true,\n-                            fn_bind: true,\n-                            decorators: true,\n-                            decorators_before_export: true,\n-                            export_default_from: true,\n-                            import_attributes: true,\n-                            allow_super_outside_method: true,\n-                            allow_return_outside_function: true,\n-                            auto_accessors: true,\n-                            explicit_resource_management: true,\n-                        }),\n+                        | EcmascriptModuleAssetType::EcmascriptExtensionless => {\n+                            Syntax::Es(EsSyntax {\n+                                jsx: true,\n+                                fn_bind: true,\n+                                decorators: true,\n+                                decorators_before_export: true,\n+                                export_default_from: true,\n+                                import_attributes: true,\n+                                allow_super_outside_method: true,\n+                                allow_return_outside_function: true,\n+                                auto_accessors: true,\n+                                explicit_resource_management: true,\n+                            })\n+                        }\n                         EcmascriptModuleAssetType::Typescript { tsx, .. } => {\n                             Syntax::Typescript(TsSyntax {\n                                 decorators: true,\n@@ -408,7 +417,7 @@ async fn parse_file_content(\n                     | EcmascriptModuleAssetType::TypescriptDeclaration\n             );\n \n-            let helpers=Helpers::new(true);\n+            let helpers = Helpers::new(!inline_helpers);\n             let span = tracing::trace_span!(\"swc_resolver\").entered();\n \n             parsed_program.visit_mut_with(&mut resolver(\n@@ -421,7 +430,7 @@ async fn parse_file_content(\n             let span = tracing::trace_span!(\"swc_lint\").entered();\n \n             let lint_config = LintConfig::default();\n-            let rules = swc_core::ecma::lints::rules::all(LintParams {\n+            let rules = lints::rules::all(LintParams {\n                 program: &parsed_program,\n                 lint_config: &lint_config,\n                 unresolved_ctxt: SyntaxContext::empty().apply_mark(unresolved_mark),\n@@ -430,13 +439,11 @@ async fn parse_file_content(\n                 source_map: source_map.clone(),\n             });\n \n-            parsed_program.mutate(swc_core::ecma::lints::rules::lint_pass(rules));\n+            parsed_program.mutate(lints::rules::lint_pass(rules));\n             drop(span);\n \n             HELPERS.set(&helpers, || {\n-                parsed_program.mutate(\n-                    swc_core::ecma::transforms::proposal::explicit_resource_management::explicit_resource_management(),\n-                );\n+                parsed_program.mutate(explicit_resource_management());\n             });\n \n             let var_with_ts_declare = if is_typescript {\n@@ -456,7 +463,7 @@ async fn parse_file_content(\n                 file_name_hash: file_path_hash,\n                 query_str: query,\n                 file_path: fs_path.clone(),\n-                source\n+                source,\n             };\n             let span = tracing::trace_span!(\"transforms\");\n             async {\n@@ -467,8 +474,8 @@ async fn parse_file_content(\n                 }\n                 anyhow::Ok(())\n             }\n-                .instrument(span)\n-                .await?;\n+            .instrument(span)\n+            .await?;\n \n             if parser_handler.has_errors() {\n                 let messages = if let Some(error) = collector_parse.last_emitted_issue() {\n@@ -481,16 +488,15 @@ async fn parse_file_content(\n                 } else {\n                     None\n                 };\n-                let messages =\n-                    Some(messages.unwrap_or_else(|| vec![fm.src.clone().into()]));\n+                let messages = Some(messages.unwrap_or_else(|| vec![fm.src.clone().into()]));\n                 return Ok(ParseResult::Unparsable { messages });\n             }\n \n             let helpers = Helpers::from_data(helpers);\n             HELPERS.set(&helpers, || {\n-                parsed_program.mutate(\n-                    swc_core::ecma::transforms::base::helpers::inject_helpers(unresolved_mark),\n-                );\n+                parsed_program.mutate(swc_core::ecma::transforms::base::helpers::inject_helpers(\n+                    unresolved_mark,\n+                ));\n             });\n \n             let eval_context = EvalContext::new(\n@@ -512,13 +518,9 @@ async fn parse_file_content(\n                 source_map,\n             })\n         },\n-        |f, cx| {\n-            GLOBALS.set(globals_ref, || {\n-                HANDLER.set(&handler, || f.poll(cx))\n-            })\n-        },\n+        |f, cx| GLOBALS.set(globals_ref, || HANDLER.set(&handler, || f.poll(cx))),\n     )\n-        .await?;\n+    .await?;\n     if let ParseResult::Ok {\n         globals: ref mut g, ..\n     } = result"
        },
        {
            "sha": "69c46554b11de44e617297c70159b3374e413228",
            "filename": "turbopack/crates/turbopack-ecmascript/src/webpack/parse.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fparse.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fparse.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Fparse.rs?ref=6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
            "patch": "@@ -195,6 +195,7 @@ pub async fn webpack_runtime(\n         EcmascriptModuleAssetType::Ecmascript,\n         transforms,\n         false,\n+        false,\n     )\n     .await?;\n     match &*parsed {"
        },
        {
            "sha": "362fa939b329f94cd825a024cf92f76d431ce4be",
            "filename": "turbopack/crates/turbopack-ecmascript/src/webpack/references.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Freferences.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Freferences.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript%2Fsrc%2Fwebpack%2Freferences.rs?ref=6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
            "patch": "@@ -31,6 +31,7 @@ pub async fn module_references(\n         EcmascriptModuleAssetType::Ecmascript,\n         *transforms,\n         false,\n+        false,\n     )\n     .await?;\n     match &*parsed {"
        },
        {
            "sha": "e9f036feed00af4cdc7bf77b80a94b22acb46aeb",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/swc_transforms/preset_env/options.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fswc_transforms%2Fpreset_env%2Foptions.json",
            "raw_url": "https://github.com/vercel/next.js/raw/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fswc_transforms%2Fpreset_env%2Foptions.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fswc_transforms%2Fpreset_env%2Foptions.json?ref=6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
            "patch": "@@ -1,3 +1,4 @@\n {\n-  \"browserslist\": \"chrome 41\"\n+  \"browserslist\": \"chrome 41\",\n+  \"runtimeType\": \"Production\"\n }"
        },
        {
            "sha": "17597c6938e39c77926778eaae658dc35c5d67ae",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/swc_transforms/preset_env/output/5c1d0_turbopack-tests_tests_snapshot_swc_transforms_preset_env_input_index_5aaf1327.js",
            "status": "modified",
            "additions": 1660,
            "deletions": 1,
            "changes": 1661,
            "blob_url": "https://github.com/vercel/next.js/blob/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fswc_transforms%2Fpreset_env%2Foutput%2F5c1d0_turbopack-tests_tests_snapshot_swc_transforms_preset_env_input_index_5aaf1327.js",
            "raw_url": "https://github.com/vercel/next.js/raw/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fswc_transforms%2Fpreset_env%2Foutput%2F5c1d0_turbopack-tests_tests_snapshot_swc_transforms_preset_env_input_index_5aaf1327.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fswc_transforms%2Fpreset_env%2Foutput%2F5c1d0_turbopack-tests_tests_snapshot_swc_transforms_preset_env_input_index_5aaf1327.js?ref=6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
            "patch": "@@ -2,4 +2,1663 @@\n     \"output/5c1d0_turbopack-tests_tests_snapshot_swc_transforms_preset_env_input_index_5aaf1327.js\",\n     {\"otherChunks\":[\"output/turbopack_crates_turbopack-tests_tests_snapshot_e54bacca._.js\"],\"runtimeModuleIds\":[\"[project]/turbopack/crates/turbopack-tests/tests/snapshot/swc_transforms/preset_env/input/index.js [test] (ecmascript)\"]}\n ]);\n-// Dummy runtime\n\\ No newline at end of file\n+(() => {\n+if (!Array.isArray(globalThis.TURBOPACK)) {\n+    return;\n+}\n+\n+const CHUNK_BASE_PATH = \"\";\n+const CHUNK_SUFFIX_PATH = \"\";\n+const RELATIVE_ROOT_PATH = \"../../../../../../..\";\n+const RUNTIME_PUBLIC_PATH = \"\";\n+/**\n+ * This file contains runtime types and functions that are shared between all\n+ * TurboPack ECMAScript runtimes.\n+ *\n+ * It will be prepended to the runtime code of each runtime.\n+ */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"./runtime-types.d.ts\" />\n+function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n+    try {\n+        var info = gen[key](arg);\n+        var value = info.value;\n+    } catch (error) {\n+        reject(error);\n+        return;\n+    }\n+    if (info.done) {\n+        resolve(value);\n+    } else {\n+        Promise.resolve(value).then(_next, _throw);\n+    }\n+}\n+function _async_to_generator(fn) {\n+    return function() {\n+        var self = this, args = arguments;\n+        return new Promise(function(resolve, reject) {\n+            var gen = fn.apply(self, args);\n+            function _next(value) {\n+                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n+            }\n+            function _throw(err) {\n+                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n+            }\n+            _next(undefined);\n+        });\n+    };\n+}\n+function _define_property(obj, key, value) {\n+    if (key in obj) {\n+        Object.defineProperty(obj, key, {\n+            value: value,\n+            enumerable: true,\n+            configurable: true,\n+            writable: true\n+        });\n+    } else {\n+        obj[key] = value;\n+    }\n+    return obj;\n+}\n+function _type_of(obj) {\n+    \"@swc/helpers - typeof\";\n+    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n+}\n+function _ts_generator(thisArg, body) {\n+    var f, y, t, _ = {\n+        label: 0,\n+        sent: function() {\n+            if (t[0] & 1) throw t[1];\n+            return t[1];\n+        },\n+        trys: [],\n+        ops: []\n+    }, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n+    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n+        return this;\n+    }), g;\n+    function verb(n) {\n+        return function(v) {\n+            return step([\n+                n,\n+                v\n+            ]);\n+        };\n+    }\n+    function step(op) {\n+        if (f) throw new TypeError(\"Generator is already executing.\");\n+        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n+            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n+            if (y = 0, t) op = [\n+                op[0] & 2,\n+                t.value\n+            ];\n+            switch(op[0]){\n+                case 0:\n+                case 1:\n+                    t = op;\n+                    break;\n+                case 4:\n+                    _.label++;\n+                    return {\n+                        value: op[1],\n+                        done: false\n+                    };\n+                case 5:\n+                    _.label++;\n+                    y = op[1];\n+                    op = [\n+                        0\n+                    ];\n+                    continue;\n+                case 7:\n+                    op = _.ops.pop();\n+                    _.trys.pop();\n+                    continue;\n+                default:\n+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n+                        _ = 0;\n+                        continue;\n+                    }\n+                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n+                        _.label = op[1];\n+                        break;\n+                    }\n+                    if (op[0] === 6 && _.label < t[1]) {\n+                        _.label = t[1];\n+                        t = op;\n+                        break;\n+                    }\n+                    if (t && _.label < t[2]) {\n+                        _.label = t[2];\n+                        _.ops.push(op);\n+                        break;\n+                    }\n+                    if (t[2]) _.ops.pop();\n+                    _.trys.pop();\n+                    continue;\n+            }\n+            op = body.call(thisArg, _);\n+        } catch (e) {\n+            op = [\n+                6,\n+                e\n+            ];\n+            y = 0;\n+        } finally{\n+            f = t = 0;\n+        }\n+        if (op[0] & 5) throw op[1];\n+        return {\n+            value: op[0] ? op[1] : void 0,\n+            done: true\n+        };\n+    }\n+}\n+var REEXPORTED_OBJECTS = new WeakMap();\n+/**\n+ * Constructs the `__turbopack_context__` object for a module.\n+ */ function Context(module, exports) {\n+    this.m = module;\n+    // We need to store this here instead of accessing it from the module object to:\n+    // 1. Make it available to factories directly, since we rewrite `this` to\n+    //    `__turbopack_context__.e` in CJS modules.\n+    // 2. Support async modules which rewrite `module.exports` to a promise, so we\n+    //    can still access the original exports object from functions like\n+    //    `esmExport`\n+    // Ideally we could find a new approach for async modules and drop this property altogether.\n+    this.e = exports;\n+}\n+var contextPrototype = Context.prototype;\n+var hasOwnProperty = Object.prototype.hasOwnProperty;\n+var toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag;\n+function defineProp(obj, name, options) {\n+    if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options);\n+}\n+function getOverwrittenModule(moduleCache, id) {\n+    var module = moduleCache[id];\n+    if (!module) {\n+        // This is invoked when a module is merged into another module, thus it wasn't invoked via\n+        // instantiateModule and the cache entry wasn't created yet.\n+        module = createModuleObject(id);\n+        moduleCache[id] = module;\n+    }\n+    return module;\n+}\n+/**\n+ * Creates the module object. Only done here to ensure all module objects have the same shape.\n+ */ function createModuleObject(id) {\n+    return {\n+        exports: {},\n+        error: undefined,\n+        id: id,\n+        namespaceObject: undefined\n+    };\n+}\n+var BindingTag_Value = 0;\n+/**\n+ * Adds the getters to the exports object.\n+ */ function esm(exports, bindings) {\n+    defineProp(exports, '__esModule', {\n+        value: true\n+    });\n+    if (toStringTag) defineProp(exports, toStringTag, {\n+        value: 'Module'\n+    });\n+    var i = 0;\n+    while(i < bindings.length){\n+        var propName = bindings[i++];\n+        var tagOrFunction = bindings[i++];\n+        if (typeof tagOrFunction === 'number') {\n+            if (tagOrFunction === BindingTag_Value) {\n+                defineProp(exports, propName, {\n+                    value: bindings[i++],\n+                    enumerable: true,\n+                    writable: false\n+                });\n+            } else {\n+                throw new Error(`unexpected tag: ${tagOrFunction}`);\n+            }\n+        } else {\n+            var getterFn = tagOrFunction;\n+            if (typeof bindings[i] === 'function') {\n+                var setterFn = bindings[i++];\n+                defineProp(exports, propName, {\n+                    get: getterFn,\n+                    set: setterFn,\n+                    enumerable: true\n+                });\n+            } else {\n+                defineProp(exports, propName, {\n+                    get: getterFn,\n+                    enumerable: true\n+                });\n+            }\n+        }\n+    }\n+    Object.seal(exports);\n+}\n+/**\n+ * Makes the module an ESM with exports\n+ */ function esmExport(bindings, id) {\n+    var module;\n+    var exports;\n+    if (id != null) {\n+        module = getOverwrittenModule(this.c, id);\n+        exports = module.exports;\n+    } else {\n+        module = this.m;\n+        exports = this.e;\n+    }\n+    module.namespaceObject = exports;\n+    esm(exports, bindings);\n+}\n+contextPrototype.s = esmExport;\n+function ensureDynamicExports(module, exports) {\n+    var reexportedObjects = REEXPORTED_OBJECTS.get(module);\n+    if (!reexportedObjects) {\n+        REEXPORTED_OBJECTS.set(module, reexportedObjects = []);\n+        module.exports = module.namespaceObject = new Proxy(exports, {\n+            get: function get(target, prop) {\n+                if (hasOwnProperty.call(target, prop) || prop === 'default' || prop === '__esModule') {\n+                    return Reflect.get(target, prop);\n+                }\n+                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n+                try {\n+                    for(var _iterator = reexportedObjects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n+                        var obj = _step.value;\n+                        var value = Reflect.get(obj, prop);\n+                        if (value !== undefined) return value;\n+                    }\n+                } catch (err) {\n+                    _didIteratorError = true;\n+                    _iteratorError = err;\n+                } finally{\n+                    try {\n+                        if (!_iteratorNormalCompletion && _iterator.return != null) {\n+                            _iterator.return();\n+                        }\n+                    } finally{\n+                        if (_didIteratorError) {\n+                            throw _iteratorError;\n+                        }\n+                    }\n+                }\n+                return undefined;\n+            },\n+            ownKeys: function ownKeys(target) {\n+                var keys = Reflect.ownKeys(target);\n+                var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n+                try {\n+                    for(var _iterator = reexportedObjects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n+                        var obj = _step.value;\n+                        var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;\n+                        try {\n+                            for(var _iterator1 = Reflect.ownKeys(obj)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){\n+                                var key = _step1.value;\n+                                if (key !== 'default' && !keys.includes(key)) keys.push(key);\n+                            }\n+                        } catch (err) {\n+                            _didIteratorError1 = true;\n+                            _iteratorError1 = err;\n+                        } finally{\n+                            try {\n+                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {\n+                                    _iterator1.return();\n+                                }\n+                            } finally{\n+                                if (_didIteratorError1) {\n+                                    throw _iteratorError1;\n+                                }\n+                            }\n+                        }\n+                    }\n+                } catch (err) {\n+                    _didIteratorError = true;\n+                    _iteratorError = err;\n+                } finally{\n+                    try {\n+                        if (!_iteratorNormalCompletion && _iterator.return != null) {\n+                            _iterator.return();\n+                        }\n+                    } finally{\n+                        if (_didIteratorError) {\n+                            throw _iteratorError;\n+                        }\n+                    }\n+                }\n+                return keys;\n+            }\n+        });\n+    }\n+    return reexportedObjects;\n+}\n+/**\n+ * Dynamically exports properties from an object\n+ */ function dynamicExport(object, id) {\n+    var module;\n+    var exports;\n+    if (id != null) {\n+        module = getOverwrittenModule(this.c, id);\n+        exports = module.exports;\n+    } else {\n+        module = this.m;\n+        exports = this.e;\n+    }\n+    var reexportedObjects = ensureDynamicExports(module, exports);\n+    if ((typeof object === \"undefined\" ? \"undefined\" : _type_of(object)) === 'object' && object !== null) {\n+        reexportedObjects.push(object);\n+    }\n+}\n+contextPrototype.j = dynamicExport;\n+function exportValue(value, id) {\n+    var module;\n+    if (id != null) {\n+        module = getOverwrittenModule(this.c, id);\n+    } else {\n+        module = this.m;\n+    }\n+    module.exports = value;\n+}\n+contextPrototype.v = exportValue;\n+function exportNamespace(namespace, id) {\n+    var module;\n+    if (id != null) {\n+        module = getOverwrittenModule(this.c, id);\n+    } else {\n+        module = this.m;\n+    }\n+    module.exports = module.namespaceObject = namespace;\n+}\n+contextPrototype.n = exportNamespace;\n+function createGetter(obj, key) {\n+    return function() {\n+        return obj[key];\n+    };\n+}\n+/**\n+ * @returns prototype of the object\n+ */ var getProto = Object.getPrototypeOf ? function(obj) {\n+    return Object.getPrototypeOf(obj);\n+} : function(obj) {\n+    return obj.__proto__;\n+};\n+/** Prototypes that are not expanded for exports */ var LEAF_PROTOTYPES = [\n+    null,\n+    getProto({}),\n+    getProto([]),\n+    getProto(getProto)\n+];\n+/**\n+ * @param raw\n+ * @param ns\n+ * @param allowExportDefault\n+ *   * `false`: will have the raw module as default export\n+ *   * `true`: will have the default property as default export\n+ */ function interopEsm(raw, ns, allowExportDefault) {\n+    var bindings = [];\n+    var defaultLocation = -1;\n+    for(var current = raw; ((typeof current === \"undefined\" ? \"undefined\" : _type_of(current)) === 'object' || typeof current === 'function') && !LEAF_PROTOTYPES.includes(current); current = getProto(current)){\n+        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n+        try {\n+            for(var _iterator = Object.getOwnPropertyNames(current)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n+                var key = _step.value;\n+                bindings.push(key, createGetter(raw, key));\n+                if (defaultLocation === -1 && key === 'default') {\n+                    defaultLocation = bindings.length - 1;\n+                }\n+            }\n+        } catch (err) {\n+            _didIteratorError = true;\n+            _iteratorError = err;\n+        } finally{\n+            try {\n+                if (!_iteratorNormalCompletion && _iterator.return != null) {\n+                    _iterator.return();\n+                }\n+            } finally{\n+                if (_didIteratorError) {\n+                    throw _iteratorError;\n+                }\n+            }\n+        }\n+    }\n+    // this is not really correct\n+    // we should set the `default` getter if the imported module is a `.cjs file`\n+    if (!(allowExportDefault && defaultLocation >= 0)) {\n+        // Replace the binding with one for the namespace itself in order to preserve iteration order.\n+        if (defaultLocation >= 0) {\n+            // Replace the getter with the value\n+            bindings.splice(defaultLocation, 1, BindingTag_Value, raw);\n+        } else {\n+            bindings.push('default', BindingTag_Value, raw);\n+        }\n+    }\n+    esm(ns, bindings);\n+    return ns;\n+}\n+function createNS(raw) {\n+    if (typeof raw === 'function') {\n+        return function() {\n+            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n+                args[_key] = arguments[_key];\n+            }\n+            return raw.apply(this, args);\n+        };\n+    } else {\n+        return Object.create(null);\n+    }\n+}\n+function esmImport(id) {\n+    var module = getOrInstantiateModuleFromParent(id, this.m);\n+    // any ES module has to have `module.namespaceObject` defined.\n+    if (module.namespaceObject) return module.namespaceObject;\n+    // only ESM can be an async module, so we don't need to worry about exports being a promise here.\n+    var raw = module.exports;\n+    return module.namespaceObject = interopEsm(raw, createNS(raw), raw && raw.__esModule);\n+}\n+contextPrototype.i = esmImport;\n+function asyncLoader(moduleId) {\n+    var loader = this.r(moduleId);\n+    return loader(esmImport.bind(this));\n+}\n+contextPrototype.A = asyncLoader;\n+// Add a simple runtime require so that environments without one can still pass\n+// `typeof require` CommonJS checks so that exports are correctly registered.\n+var runtimeRequire = // @ts-ignore\n+typeof require === 'function' ? require : function require1() {\n+    throw new Error('Unexpected use of runtime require');\n+};\n+contextPrototype.t = runtimeRequire;\n+function commonJsRequire(id) {\n+    return getOrInstantiateModuleFromParent(id, this.m).exports;\n+}\n+contextPrototype.r = commonJsRequire;\n+/**\n+ * `require.context` and require/import expression runtime.\n+ */ function moduleContext(map) {\n+    function moduleContext(id) {\n+        if (hasOwnProperty.call(map, id)) {\n+            return map[id].module();\n+        }\n+        var e = new Error(`Cannot find module '${id}'`);\n+        e.code = 'MODULE_NOT_FOUND';\n+        throw e;\n+    }\n+    moduleContext.keys = function() {\n+        return Object.keys(map);\n+    };\n+    moduleContext.resolve = function(id) {\n+        if (hasOwnProperty.call(map, id)) {\n+            return map[id].id();\n+        }\n+        var e = new Error(`Cannot find module '${id}'`);\n+        e.code = 'MODULE_NOT_FOUND';\n+        throw e;\n+    };\n+    moduleContext.import = function(id) {\n+        return _async_to_generator(function() {\n+            return _ts_generator(this, function(_state) {\n+                switch(_state.label){\n+                    case 0:\n+                        return [\n+                            4,\n+                            moduleContext(id)\n+                        ];\n+                    case 1:\n+                        return [\n+                            2,\n+                            _state.sent()\n+                        ];\n+                }\n+            });\n+        })();\n+    };\n+    return moduleContext;\n+}\n+contextPrototype.f = moduleContext;\n+/**\n+ * Returns the path of a chunk defined by its data.\n+ */ function getChunkPath(chunkData) {\n+    return typeof chunkData === 'string' ? chunkData : chunkData.path;\n+}\n+function isPromise(maybePromise) {\n+    return maybePromise != null && (typeof maybePromise === \"undefined\" ? \"undefined\" : _type_of(maybePromise)) === 'object' && 'then' in maybePromise && typeof maybePromise.then === 'function';\n+}\n+function isAsyncModuleExt(obj) {\n+    return turbopackQueues in obj;\n+}\n+function createPromise() {\n+    var resolve;\n+    var reject;\n+    var promise = new Promise(function(res, rej) {\n+        reject = rej;\n+        resolve = res;\n+    });\n+    return {\n+        promise: promise,\n+        resolve: resolve,\n+        reject: reject\n+    };\n+}\n+// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\n+// The CompressedModuleFactories format is\n+// - 1 or more module ids\n+// - a module factory function\n+// So walking this is a little complex but the flat structure is also fast to\n+// traverse, we can use `typeof` operators to distinguish the two cases.\n+function installCompressedModuleFactories(chunkModules, offset, moduleFactories, newModuleId) {\n+    var i = offset;\n+    while(i < chunkModules.length){\n+        var moduleId = chunkModules[i];\n+        var end = i + 1;\n+        // Find our factory function\n+        while(end < chunkModules.length && typeof chunkModules[end] !== 'function'){\n+            end++;\n+        }\n+        if (end === chunkModules.length) {\n+            throw new Error('malformed chunk format, expected a factory function');\n+        }\n+        // Each chunk item has a 'primary id' and optional additional ids. If the primary id is already\n+        // present we know all the additional ids are also present, so we don't need to check.\n+        if (!moduleFactories.has(moduleId)) {\n+            var moduleFactoryFn = chunkModules[end];\n+            applyModuleFactoryName(moduleFactoryFn);\n+            newModuleId === null || newModuleId === void 0 ? void 0 : newModuleId(moduleId);\n+            for(; i < end; i++){\n+                moduleId = chunkModules[i];\n+                moduleFactories.set(moduleId, moduleFactoryFn);\n+            }\n+        }\n+        i = end + 1; // end is pointing at the last factory advance to the next id or the end of the array.\n+    }\n+}\n+// everything below is adapted from webpack\n+// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\n+var turbopackQueues = Symbol('turbopack queues');\n+var turbopackExports = Symbol('turbopack exports');\n+var turbopackError = Symbol('turbopack error');\n+function resolveQueue(queue) {\n+    if (queue && queue.status !== 1) {\n+        queue.status = 1;\n+        queue.forEach(function(fn) {\n+            return fn.queueCount--;\n+        });\n+        queue.forEach(function(fn) {\n+            return fn.queueCount-- ? fn.queueCount++ : fn();\n+        });\n+    }\n+}\n+function wrapDeps(deps) {\n+    return deps.map(function(dep) {\n+        if (dep !== null && (typeof dep === \"undefined\" ? \"undefined\" : _type_of(dep)) === 'object') {\n+            if (isAsyncModuleExt(dep)) return dep;\n+            if (isPromise(dep)) {\n+                var queue = Object.assign([], {\n+                    status: 0\n+                });\n+                var _obj;\n+                var obj = (_obj = {}, _define_property(_obj, turbopackExports, {}), _define_property(_obj, turbopackQueues, function(fn) {\n+                    return fn(queue);\n+                }), _obj);\n+                dep.then(function(res) {\n+                    obj[turbopackExports] = res;\n+                    resolveQueue(queue);\n+                }, function(err) {\n+                    obj[turbopackError] = err;\n+                    resolveQueue(queue);\n+                });\n+                return obj;\n+            }\n+        }\n+        var _obj1;\n+        return _obj1 = {}, _define_property(_obj1, turbopackExports, dep), _define_property(_obj1, turbopackQueues, function() {}), _obj1;\n+    });\n+}\n+function asyncModule(body, hasAwait) {\n+    var module = this.m;\n+    var queue = hasAwait ? Object.assign([], {\n+        status: -1\n+    }) : undefined;\n+    var depQueues = new Set();\n+    var _createPromise = createPromise(), resolve = _createPromise.resolve, reject = _createPromise.reject, rawPromise = _createPromise.promise;\n+    var _obj;\n+    var promise = Object.assign(rawPromise, (_obj = {}, _define_property(_obj, turbopackExports, module.exports), _define_property(_obj, turbopackQueues, function(fn) {\n+        queue && fn(queue);\n+        depQueues.forEach(fn);\n+        promise['catch'](function() {});\n+    }), _obj));\n+    var attributes = {\n+        get: function get() {\n+            return promise;\n+        },\n+        set: function set(v) {\n+            // Calling `esmExport` leads to this.\n+            if (v !== promise) {\n+                promise[turbopackExports] = v;\n+            }\n+        }\n+    };\n+    Object.defineProperty(module, 'exports', attributes);\n+    Object.defineProperty(module, 'namespaceObject', attributes);\n+    function handleAsyncDependencies(deps) {\n+        var currentDeps = wrapDeps(deps);\n+        var getResult = function() {\n+            return currentDeps.map(function(d) {\n+                if (d[turbopackError]) throw d[turbopackError];\n+                return d[turbopackExports];\n+            });\n+        };\n+        var _createPromise = createPromise(), promise = _createPromise.promise, resolve = _createPromise.resolve;\n+        var fn = Object.assign(function() {\n+            return resolve(getResult);\n+        }, {\n+            queueCount: 0\n+        });\n+        function fnQueue(q) {\n+            if (q !== queue && !depQueues.has(q)) {\n+                depQueues.add(q);\n+                if (q && q.status === 0) {\n+                    fn.queueCount++;\n+                    q.push(fn);\n+                }\n+            }\n+        }\n+        currentDeps.map(function(dep) {\n+            return dep[turbopackQueues](fnQueue);\n+        });\n+        return fn.queueCount ? promise : getResult();\n+    }\n+    function asyncResult(err) {\n+        if (err) {\n+            reject(promise[turbopackError] = err);\n+        } else {\n+            resolve(promise[turbopackExports]);\n+        }\n+        resolveQueue(queue);\n+    }\n+    body(handleAsyncDependencies, asyncResult);\n+    if (queue && queue.status === -1) {\n+        queue.status = 0;\n+    }\n+}\n+contextPrototype.a = asyncModule;\n+/**\n+ * A pseudo \"fake\" URL object to resolve to its relative path.\n+ *\n+ * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\n+ * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\n+ * hydration mismatch.\n+ *\n+ * This is based on webpack's existing implementation:\n+ * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\n+ */ var relativeURL = function relativeURL(inputUrl) {\n+    var realUrl = new URL(inputUrl, 'x:/');\n+    var values = {};\n+    for(var key in realUrl)values[key] = realUrl[key];\n+    values.href = inputUrl;\n+    values.pathname = inputUrl.replace(/[?#].*/, '');\n+    values.origin = values.protocol = '';\n+    values.toString = values.toJSON = function() {\n+        for(var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++){\n+            _args[_key] = arguments[_key];\n+        }\n+        return inputUrl;\n+    };\n+    for(var key1 in values)Object.defineProperty(this, key1, {\n+        enumerable: true,\n+        configurable: true,\n+        value: values[key1]\n+    });\n+};\n+relativeURL.prototype = URL.prototype;\n+contextPrototype.U = relativeURL;\n+/**\n+ * Utility function to ensure all variants of an enum are handled.\n+ */ function invariant(never, computeMessage) {\n+    throw new Error(`Invariant: ${computeMessage(never)}`);\n+}\n+/**\n+ * A stub function to make `require` available but non-functional in ESM.\n+ */ function requireStub(_moduleId) {\n+    throw new Error('dynamic usage of require is not supported');\n+}\n+contextPrototype.z = requireStub;\n+// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\n+contextPrototype.g = globalThis;\n+function applyModuleFactoryName(factory) {\n+    // Give the module factory a nice name to improve stack traces.\n+    Object.defineProperty(factory, 'name', {\n+        value: '__TURBOPACK__module__evaluation__'\n+    });\n+}\n+/**\n+ * This file contains runtime types and functions that are shared between all\n+ * Turbopack *development* ECMAScript runtimes.\n+ *\n+ * It will be appended to the runtime code of each runtime right after the\n+ * shared runtime utils.\n+ */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../base/globals.d.ts\" />\n+/// <reference path=\"../../../shared/runtime-utils.ts\" />\n+// Used in WebWorkers to tell the runtime about the chunk base path\n+function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n+    try {\n+        var info = gen[key](arg);\n+        var value = info.value;\n+    } catch (error) {\n+        reject(error);\n+        return;\n+    }\n+    if (info.done) {\n+        resolve(value);\n+    } else {\n+        Promise.resolve(value).then(_next, _throw);\n+    }\n+}\n+function _async_to_generator(fn) {\n+    return function() {\n+        var self = this, args = arguments;\n+        return new Promise(function(resolve, reject) {\n+            var gen = fn.apply(self, args);\n+            function _next(value) {\n+                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n+            }\n+            function _throw(err) {\n+                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n+            }\n+            _next(undefined);\n+        });\n+    };\n+}\n+function _ts_generator(thisArg, body) {\n+    var f, y, t, _ = {\n+        label: 0,\n+        sent: function() {\n+            if (t[0] & 1) throw t[1];\n+            return t[1];\n+        },\n+        trys: [],\n+        ops: []\n+    }, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n+    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n+        return this;\n+    }), g;\n+    function verb(n) {\n+        return function(v) {\n+            return step([\n+                n,\n+                v\n+            ]);\n+        };\n+    }\n+    function step(op) {\n+        if (f) throw new TypeError(\"Generator is already executing.\");\n+        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n+            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n+            if (y = 0, t) op = [\n+                op[0] & 2,\n+                t.value\n+            ];\n+            switch(op[0]){\n+                case 0:\n+                case 1:\n+                    t = op;\n+                    break;\n+                case 4:\n+                    _.label++;\n+                    return {\n+                        value: op[1],\n+                        done: false\n+                    };\n+                case 5:\n+                    _.label++;\n+                    y = op[1];\n+                    op = [\n+                        0\n+                    ];\n+                    continue;\n+                case 7:\n+                    op = _.ops.pop();\n+                    _.trys.pop();\n+                    continue;\n+                default:\n+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n+                        _ = 0;\n+                        continue;\n+                    }\n+                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n+                        _.label = op[1];\n+                        break;\n+                    }\n+                    if (op[0] === 6 && _.label < t[1]) {\n+                        _.label = t[1];\n+                        t = op;\n+                        break;\n+                    }\n+                    if (t && _.label < t[2]) {\n+                        _.label = t[2];\n+                        _.ops.push(op);\n+                        break;\n+                    }\n+                    if (t[2]) _.ops.pop();\n+                    _.trys.pop();\n+                    continue;\n+            }\n+            op = body.call(thisArg, _);\n+        } catch (e) {\n+            op = [\n+                6,\n+                e\n+            ];\n+            y = 0;\n+        } finally{\n+            f = t = 0;\n+        }\n+        if (op[0] & 5) throw op[1];\n+        return {\n+            value: op[0] ? op[1] : void 0,\n+            done: true\n+        };\n+    }\n+}\n+var browserContextPrototype = Context.prototype;\n+var SourceType = /*#__PURE__*/ function(SourceType) {\n+    /**\n+   * The module was instantiated because it was included in an evaluated chunk's\n+   * runtime.\n+   * SourceData is a ChunkPath.\n+   */ SourceType[SourceType[\"Runtime\"] = 0] = \"Runtime\";\n+    /**\n+   * The module was instantiated because a parent module imported it.\n+   * SourceData is a ModuleId.\n+   */ SourceType[SourceType[\"Parent\"] = 1] = \"Parent\";\n+    /**\n+   * The module was instantiated because it was included in a chunk's hot module\n+   * update.\n+   * SourceData is an array of ModuleIds or undefined.\n+   */ SourceType[SourceType[\"Update\"] = 2] = \"Update\";\n+    return SourceType;\n+}(SourceType || {});\n+var moduleFactories = new Map();\n+contextPrototype.M = moduleFactories;\n+var availableModules = new Map();\n+var availableModuleChunks = new Map();\n+function factoryNotAvailableMessage(moduleId, sourceType, sourceData) {\n+    var instantiationReason;\n+    switch(sourceType){\n+        case 0:\n+            instantiationReason = `as a runtime entry of chunk ${sourceData}`;\n+            break;\n+        case 1:\n+            instantiationReason = `because it was required from module ${sourceData}`;\n+            break;\n+        case 2:\n+            instantiationReason = 'because of an HMR update';\n+            break;\n+        default:\n+            invariant(sourceType, function(sourceType) {\n+                return `Unknown source type: ${sourceType}`;\n+            });\n+    }\n+    return `Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available.`;\n+}\n+function loadChunk(chunkData) {\n+    return loadChunkInternal(1, this.m.id, chunkData);\n+}\n+browserContextPrototype.l = loadChunk;\n+function loadInitialChunk(chunkPath, chunkData) {\n+    return loadChunkInternal(0, chunkPath, chunkData);\n+}\n+function loadChunkInternal(sourceType, sourceData, chunkData) {\n+    return _async_to_generator(function() {\n+        var includedList, modulesPromises, includedModuleChunksList, moduleChunksPromises, promise, moduleChunksToLoad, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, moduleChunk, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1, _iterator1, _step1, moduleChunkToLoad, promise1, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, includedModuleChunk, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, included;\n+        return _ts_generator(this, function(_state) {\n+            switch(_state.label){\n+                case 0:\n+                    if (typeof chunkData === 'string') {\n+                        return [\n+                            2,\n+                            loadChunkPath(sourceType, sourceData, chunkData)\n+                        ];\n+                    }\n+                    includedList = chunkData.included || [];\n+                    modulesPromises = includedList.map(function(included) {\n+                        if (moduleFactories.has(included)) return true;\n+                        return availableModules.get(included);\n+                    });\n+                    if (!(modulesPromises.length > 0 && modulesPromises.every(function(p) {\n+                        return p;\n+                    }))) return [\n+                        3,\n+                        2\n+                    ];\n+                    // When all included items are already loaded or loading, we can skip loading ourselves\n+                    return [\n+                        4,\n+                        Promise.all(modulesPromises)\n+                    ];\n+                case 1:\n+                    _state.sent();\n+                    return [\n+                        2\n+                    ];\n+                case 2:\n+                    includedModuleChunksList = chunkData.moduleChunks || [];\n+                    moduleChunksPromises = includedModuleChunksList.map(function(included) {\n+                        // TODO(alexkirsz) Do we need this check?\n+                        // if (moduleFactories[included]) return true;\n+                        return availableModuleChunks.get(included);\n+                    }).filter(function(p) {\n+                        return p;\n+                    });\n+                    if (!(moduleChunksPromises.length > 0)) return [\n+                        3,\n+                        5\n+                    ];\n+                    if (!(moduleChunksPromises.length === includedModuleChunksList.length)) return [\n+                        3,\n+                        4\n+                    ];\n+                    // When all included module chunks are already loaded or loading, we can skip loading ourselves\n+                    return [\n+                        4,\n+                        Promise.all(moduleChunksPromises)\n+                    ];\n+                case 3:\n+                    _state.sent();\n+                    return [\n+                        2\n+                    ];\n+                case 4:\n+                    moduleChunksToLoad = new Set();\n+                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n+                    try {\n+                        for(_iterator = includedModuleChunksList[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n+                            moduleChunk = _step.value;\n+                            if (!availableModuleChunks.has(moduleChunk)) {\n+                                moduleChunksToLoad.add(moduleChunk);\n+                            }\n+                        }\n+                    } catch (err) {\n+                        _didIteratorError = true;\n+                        _iteratorError = err;\n+                    } finally{\n+                        try {\n+                            if (!_iteratorNormalCompletion && _iterator.return != null) {\n+                                _iterator.return();\n+                            }\n+                        } finally{\n+                            if (_didIteratorError) {\n+                                throw _iteratorError;\n+                            }\n+                        }\n+                    }\n+                    _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;\n+                    try {\n+                        for(_iterator1 = moduleChunksToLoad[Symbol.iterator](); !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){\n+                            moduleChunkToLoad = _step1.value;\n+                            promise1 = loadChunkPath(sourceType, sourceData, moduleChunkToLoad);\n+                            availableModuleChunks.set(moduleChunkToLoad, promise1);\n+                            moduleChunksPromises.push(promise1);\n+                        }\n+                    } catch (err) {\n+                        _didIteratorError1 = true;\n+                        _iteratorError1 = err;\n+                    } finally{\n+                        try {\n+                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {\n+                                _iterator1.return();\n+                            }\n+                        } finally{\n+                            if (_didIteratorError1) {\n+                                throw _iteratorError1;\n+                            }\n+                        }\n+                    }\n+                    promise = Promise.all(moduleChunksPromises);\n+                    return [\n+                        3,\n+                        6\n+                    ];\n+                case 5:\n+                    promise = loadChunkPath(sourceType, sourceData, chunkData.path);\n+                    _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;\n+                    try {\n+                        // Mark all included module chunks as loading if they are not already loaded or loading.\n+                        for(_iterator2 = includedModuleChunksList[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){\n+                            includedModuleChunk = _step2.value;\n+                            if (!availableModuleChunks.has(includedModuleChunk)) {\n+                                availableModuleChunks.set(includedModuleChunk, promise);\n+                            }\n+                        }\n+                    } catch (err) {\n+                        _didIteratorError2 = true;\n+                        _iteratorError2 = err;\n+                    } finally{\n+                        try {\n+                            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n+                                _iterator2.return();\n+                            }\n+                        } finally{\n+                            if (_didIteratorError2) {\n+                                throw _iteratorError2;\n+                            }\n+                        }\n+                    }\n+                    _state.label = 6;\n+                case 6:\n+                    _iteratorNormalCompletion3 = true, _didIteratorError3 = false, _iteratorError3 = undefined;\n+                    try {\n+                        for(_iterator3 = includedList[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true){\n+                            included = _step3.value;\n+                            if (!availableModules.has(included)) {\n+                                // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\n+                                // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\n+                                availableModules.set(included, promise);\n+                            }\n+                        }\n+                    } catch (err) {\n+                        _didIteratorError3 = true;\n+                        _iteratorError3 = err;\n+                    } finally{\n+                        try {\n+                            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n+                                _iterator3.return();\n+                            }\n+                        } finally{\n+                            if (_didIteratorError3) {\n+                                throw _iteratorError3;\n+                            }\n+                        }\n+                    }\n+                    return [\n+                        4,\n+                        promise\n+                    ];\n+                case 7:\n+                    _state.sent();\n+                    return [\n+                        2\n+                    ];\n+            }\n+        });\n+    })();\n+}\n+var loadedChunk = Promise.resolve(undefined);\n+var instrumentedBackendLoadChunks = new WeakMap();\n+// Do not make this async. React relies on referential equality of the returned Promise.\n+function loadChunkByUrl(chunkUrl) {\n+    return loadChunkByUrlInternal(1, this.m.id, chunkUrl);\n+}\n+browserContextPrototype.L = loadChunkByUrl;\n+// Do not make this async. React relies on referential equality of the returned Promise.\n+function loadChunkByUrlInternal(sourceType, sourceData, chunkUrl) {\n+    var thenable = BACKEND.loadChunkCached(sourceType, chunkUrl);\n+    var entry = instrumentedBackendLoadChunks.get(thenable);\n+    if (entry === undefined) {\n+        var resolve = instrumentedBackendLoadChunks.set.bind(instrumentedBackendLoadChunks, thenable, loadedChunk);\n+        entry = thenable.then(resolve).catch(function(error) {\n+            var loadReason;\n+            switch(sourceType){\n+                case 0:\n+                    loadReason = `as a runtime dependency of chunk ${sourceData}`;\n+                    break;\n+                case 1:\n+                    loadReason = `from module ${sourceData}`;\n+                    break;\n+                case 2:\n+                    loadReason = 'from an HMR update';\n+                    break;\n+                default:\n+                    invariant(sourceType, function(sourceType) {\n+                        return `Unknown source type: ${sourceType}`;\n+                    });\n+            }\n+            throw new Error(`Failed to load chunk ${chunkUrl} ${loadReason}${error ? `: ${error}` : ''}`, error ? {\n+                cause: error\n+            } : undefined);\n+        });\n+        instrumentedBackendLoadChunks.set(thenable, entry);\n+    }\n+    return entry;\n+}\n+// Do not make this async. React relies on referential equality of the returned Promise.\n+function loadChunkPath(sourceType, sourceData, chunkPath) {\n+    var url = getChunkRelativeUrl(chunkPath);\n+    return loadChunkByUrlInternal(sourceType, sourceData, url);\n+}\n+/**\n+ * Returns an absolute url to an asset.\n+ */ function resolvePathFromModule(moduleId) {\n+    var exported = this.r(moduleId);\n+    var _exported_default;\n+    return (_exported_default = exported === null || exported === void 0 ? void 0 : exported.default) !== null && _exported_default !== void 0 ? _exported_default : exported;\n+}\n+browserContextPrototype.R = resolvePathFromModule;\n+/**\n+ * no-op for browser\n+ * @param modulePath\n+ */ function resolveAbsolutePath(modulePath) {\n+    return `/ROOT/${modulePath !== null && modulePath !== void 0 ? modulePath : ''}`;\n+}\n+browserContextPrototype.P = resolveAbsolutePath;\n+/**\n+ * Returns a blob URL for the worker.\n+ * @param chunks list of chunks to load\n+ */ function getWorkerBlobURL(chunks) {\n+    // It is important to reverse the array so when bootstrapping we can infer what chunk is being\n+    // evaluated by poping urls off of this array.  See `getPathFromScript`\n+    var bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};\n+self.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};\n+importScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_LOCATION + c).reverse());`;\n+    var blob = new Blob([\n+        bootstrap\n+    ], {\n+        type: 'text/javascript'\n+    });\n+    return URL.createObjectURL(blob);\n+}\n+browserContextPrototype.b = getWorkerBlobURL;\n+/**\n+ * Instantiates a runtime module.\n+ */ function instantiateRuntimeModule(moduleId, chunkPath) {\n+    return instantiateModule(moduleId, 0, chunkPath);\n+}\n+/**\n+ * Returns the URL relative to the origin where a chunk can be fetched from.\n+ */ function getChunkRelativeUrl(chunkPath) {\n+    return `${CHUNK_BASE_PATH}${chunkPath.split('/').map(function(p) {\n+        return encodeURIComponent(p);\n+    }).join('/')}${CHUNK_SUFFIX_PATH}`;\n+}\n+function getPathFromScript(chunkScript) {\n+    if (typeof chunkScript === 'string') {\n+        return chunkScript;\n+    }\n+    var chunkUrl = typeof TURBOPACK_NEXT_CHUNK_URLS !== 'undefined' ? TURBOPACK_NEXT_CHUNK_URLS.pop() : chunkScript.getAttribute('src');\n+    var src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, ''));\n+    var path = src.startsWith(CHUNK_BASE_PATH) ? src.slice(CHUNK_BASE_PATH.length) : src;\n+    return path;\n+}\n+var regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n+/**\n+ * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\n+ */ function isJs(chunkUrlOrPath) {\n+    return regexJsUrl.test(chunkUrlOrPath);\n+}\n+var regexCssUrl = /\\.css(?:\\?[^#]*)?(?:#.*)?$/;\n+/**\n+ * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\n+ */ function isCss(chunkUrl) {\n+    return regexCssUrl.test(chunkUrl);\n+}\n+function loadWebAssembly(chunkPath, edgeModule, importsObj) {\n+    return BACKEND.loadWebAssembly(1, this.m.id, chunkPath, edgeModule, importsObj);\n+}\n+contextPrototype.w = loadWebAssembly;\n+function loadWebAssemblyModule(chunkPath, edgeModule) {\n+    return BACKEND.loadWebAssemblyModule(1, this.m.id, chunkPath, edgeModule);\n+}\n+contextPrototype.u = loadWebAssemblyModule;\n+/// <reference path=\"./runtime-base.ts\" />\n+/// <reference path=\"./dummy.ts\" />\n+var moduleCache = {};\n+contextPrototype.c = moduleCache;\n+/**\n+ * Gets or instantiates a runtime module.\n+ */ // @ts-ignore\n+// eslint-disable-next-line @typescript-eslint/no-unused-vars\n+function getOrInstantiateRuntimeModule(chunkPath, moduleId) {\n+    var module = moduleCache[moduleId];\n+    if (module) {\n+        if (module.error) {\n+            throw module.error;\n+        }\n+        return module;\n+    }\n+    return instantiateModule(moduleId, SourceType.Runtime, chunkPath);\n+}\n+/**\n+ * Retrieves a module from the cache, or instantiate it if it is not cached.\n+ */ // Used by the backend\n+// @ts-ignore\n+// eslint-disable-next-line @typescript-eslint/no-unused-vars\n+var getOrInstantiateModuleFromParent = function(id, sourceModule) {\n+    var module = moduleCache[id];\n+    if (module) {\n+        if (module.error) {\n+            throw module.error;\n+        }\n+        return module;\n+    }\n+    return instantiateModule(id, SourceType.Parent, sourceModule.id);\n+};\n+function instantiateModule(id, sourceType, sourceData) {\n+    var moduleFactory = moduleFactories.get(id);\n+    if (typeof moduleFactory !== 'function') {\n+        // This can happen if modules incorrectly handle HMR disposes/updates,\n+        // e.g. when they keep a `setTimeout` around which still executes old code\n+        // and contains e.g. a `require(\"something\")` call.\n+        throw new Error(factoryNotAvailableMessage(id, sourceType, sourceData));\n+    }\n+    var module = createModuleObject(id);\n+    var exports = module.exports;\n+    moduleCache[id] = module;\n+    // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\n+    var context = new Context(module, exports);\n+    try {\n+        moduleFactory(context, module, exports);\n+    } catch (error) {\n+        module.error = error;\n+        throw error;\n+    }\n+    if (module.namespaceObject && module.exports !== module.namespaceObject) {\n+        // in case of a circular dependency: cjs1 -> esm2 -> cjs1\n+        interopEsm(module.exports, module.namespaceObject);\n+    }\n+    return module;\n+}\n+// eslint-disable-next-line @typescript-eslint/no-unused-vars\n+function registerChunk(registration) {\n+    var chunkPath = getPathFromScript(registration[0]);\n+    var runtimeParams;\n+    // When bootstrapping we are passed a single runtimeParams object so we can distinguish purely based on length\n+    if (registration.length === 2) {\n+        runtimeParams = registration[1];\n+    } else {\n+        runtimeParams = undefined;\n+        installCompressedModuleFactories(registration, /* offset= */ 1, moduleFactories);\n+    }\n+    return BACKEND.registerChunk(chunkPath, runtimeParams);\n+}\n+/**\n+ * This file contains the runtime code specific to the Turbopack development\n+ * ECMAScript DOM runtime.\n+ *\n+ * It will be appended to the base development runtime code.\n+ */ /* eslint-disable @typescript-eslint/no-unused-vars */ /// <reference path=\"../../../browser/runtime/base/runtime-base.ts\" />\n+/// <reference path=\"../../../shared/runtime-types.d.ts\" />\n+function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n+    try {\n+        var info = gen[key](arg);\n+        var value = info.value;\n+    } catch (error) {\n+        reject(error);\n+        return;\n+    }\n+    if (info.done) {\n+        resolve(value);\n+    } else {\n+        Promise.resolve(value).then(_next, _throw);\n+    }\n+}\n+function _async_to_generator(fn) {\n+    return function() {\n+        var self1 = this, args = arguments;\n+        return new Promise(function(resolve, reject) {\n+            var gen = fn.apply(self1, args);\n+            function _next(value) {\n+                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n+            }\n+            function _throw(err) {\n+                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n+            }\n+            _next(undefined);\n+        });\n+    };\n+}\n+function _ts_generator(thisArg, body) {\n+    var f, y, t, _ = {\n+        label: 0,\n+        sent: function() {\n+            if (t[0] & 1) throw t[1];\n+            return t[1];\n+        },\n+        trys: [],\n+        ops: []\n+    }, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n+    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n+        return this;\n+    }), g;\n+    function verb(n) {\n+        return function(v) {\n+            return step([\n+                n,\n+                v\n+            ]);\n+        };\n+    }\n+    function step(op) {\n+        if (f) throw new TypeError(\"Generator is already executing.\");\n+        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n+            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n+            if (y = 0, t) op = [\n+                op[0] & 2,\n+                t.value\n+            ];\n+            switch(op[0]){\n+                case 0:\n+                case 1:\n+                    t = op;\n+                    break;\n+                case 4:\n+                    _.label++;\n+                    return {\n+                        value: op[1],\n+                        done: false\n+                    };\n+                case 5:\n+                    _.label++;\n+                    y = op[1];\n+                    op = [\n+                        0\n+                    ];\n+                    continue;\n+                case 7:\n+                    op = _.ops.pop();\n+                    _.trys.pop();\n+                    continue;\n+                default:\n+                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n+                        _ = 0;\n+                        continue;\n+                    }\n+                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n+                        _.label = op[1];\n+                        break;\n+                    }\n+                    if (op[0] === 6 && _.label < t[1]) {\n+                        _.label = t[1];\n+                        t = op;\n+                        break;\n+                    }\n+                    if (t && _.label < t[2]) {\n+                        _.label = t[2];\n+                        _.ops.push(op);\n+                        break;\n+                    }\n+                    if (t[2]) _.ops.pop();\n+                    _.trys.pop();\n+                    continue;\n+            }\n+            op = body.call(thisArg, _);\n+        } catch (e) {\n+            op = [\n+                6,\n+                e\n+            ];\n+            y = 0;\n+        } finally{\n+            f = t = 0;\n+        }\n+        if (op[0] & 5) throw op[1];\n+        return {\n+            value: op[0] ? op[1] : void 0,\n+            done: true\n+        };\n+    }\n+}\n+var BACKEND;\n+/**\n+ * Maps chunk paths to the corresponding resolver.\n+ */ var chunkResolvers = new Map();\n+(function() {\n+    BACKEND = {\n+        registerChunk: function registerChunk(chunkPath, params) {\n+            return _async_to_generator(function() {\n+                var chunkUrl, resolver, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, otherChunkData, otherChunkPath, otherChunkUrl, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1, _iterator1, _step1, moduleId;\n+                return _ts_generator(this, function(_state) {\n+                    switch(_state.label){\n+                        case 0:\n+                            chunkUrl = getChunkRelativeUrl(chunkPath);\n+                            resolver = getOrCreateResolver(chunkUrl);\n+                            resolver.resolve();\n+                            if (params == null) {\n+                                return [\n+                                    2\n+                                ];\n+                            }\n+                            _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n+                            try {\n+                                for(_iterator = params.otherChunks[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n+                                    otherChunkData = _step.value;\n+                                    otherChunkPath = getChunkPath(otherChunkData);\n+                                    otherChunkUrl = getChunkRelativeUrl(otherChunkPath);\n+                                    // Chunk might have started loading, so we want to avoid triggering another load.\n+                                    getOrCreateResolver(otherChunkUrl);\n+                                }\n+                            } catch (err) {\n+                                _didIteratorError = true;\n+                                _iteratorError = err;\n+                            } finally{\n+                                try {\n+                                    if (!_iteratorNormalCompletion && _iterator.return != null) {\n+                                        _iterator.return();\n+                                    }\n+                                } finally{\n+                                    if (_didIteratorError) {\n+                                        throw _iteratorError;\n+                                    }\n+                                }\n+                            }\n+                            // This waits for chunks to be loaded, but also marks included items as available.\n+                            return [\n+                                4,\n+                                Promise.all(params.otherChunks.map(function(otherChunkData) {\n+                                    return loadInitialChunk(chunkPath, otherChunkData);\n+                                }))\n+                            ];\n+                        case 1:\n+                            _state.sent();\n+                            if (params.runtimeModuleIds.length > 0) {\n+                                _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;\n+                                try {\n+                                    for(_iterator1 = params.runtimeModuleIds[Symbol.iterator](); !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){\n+                                        moduleId = _step1.value;\n+                                        getOrInstantiateRuntimeModule(chunkPath, moduleId);\n+                                    }\n+                                } catch (err) {\n+                                    _didIteratorError1 = true;\n+                                    _iteratorError1 = err;\n+                                } finally{\n+                                    try {\n+                                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {\n+                                            _iterator1.return();\n+                                        }\n+                                    } finally{\n+                                        if (_didIteratorError1) {\n+                                            throw _iteratorError1;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                            return [\n+                                2\n+                            ];\n+                    }\n+                });\n+            })();\n+        },\n+        /**\n+     * Loads the given chunk, and returns a promise that resolves once the chunk\n+     * has been loaded.\n+     */ loadChunkCached: function loadChunkCached(sourceType, chunkUrl) {\n+            return doLoadChunk(sourceType, chunkUrl);\n+        },\n+        loadWebAssembly: function loadWebAssembly(_sourceType, _sourceData, wasmChunkPath, _edgeModule, importsObj) {\n+            return _async_to_generator(function() {\n+                var req, instance;\n+                return _ts_generator(this, function(_state) {\n+                    switch(_state.label){\n+                        case 0:\n+                            req = fetchWebAssembly(wasmChunkPath);\n+                            return [\n+                                4,\n+                                WebAssembly.instantiateStreaming(req, importsObj)\n+                            ];\n+                        case 1:\n+                            instance = _state.sent().instance;\n+                            return [\n+                                2,\n+                                instance.exports\n+                            ];\n+                    }\n+                });\n+            })();\n+        },\n+        loadWebAssemblyModule: function loadWebAssemblyModule(_sourceType, _sourceData, wasmChunkPath, _edgeModule) {\n+            return _async_to_generator(function() {\n+                var req;\n+                return _ts_generator(this, function(_state) {\n+                    switch(_state.label){\n+                        case 0:\n+                            req = fetchWebAssembly(wasmChunkPath);\n+                            return [\n+                                4,\n+                                WebAssembly.compileStreaming(req)\n+                            ];\n+                        case 1:\n+                            return [\n+                                2,\n+                                _state.sent()\n+                            ];\n+                    }\n+                });\n+            })();\n+        }\n+    };\n+    function getOrCreateResolver(chunkUrl) {\n+        var resolver = chunkResolvers.get(chunkUrl);\n+        if (!resolver) {\n+            var resolve;\n+            var reject;\n+            var promise = new Promise(function(innerResolve, innerReject) {\n+                resolve = innerResolve;\n+                reject = innerReject;\n+            });\n+            resolver = {\n+                resolved: false,\n+                loadingStarted: false,\n+                promise: promise,\n+                resolve: function() {\n+                    resolver.resolved = true;\n+                    resolve();\n+                },\n+                reject: reject\n+            };\n+            chunkResolvers.set(chunkUrl, resolver);\n+        }\n+        return resolver;\n+    }\n+    /**\n+   * Loads the given chunk, and returns a promise that resolves once the chunk\n+   * has been loaded.\n+   */ function doLoadChunk(sourceType, chunkUrl) {\n+        var resolver = getOrCreateResolver(chunkUrl);\n+        if (resolver.loadingStarted) {\n+            return resolver.promise;\n+        }\n+        if (sourceType === SourceType.Runtime) {\n+            // We don't need to load chunks references from runtime code, as they're already\n+            // present in the DOM.\n+            resolver.loadingStarted = true;\n+            if (isCss(chunkUrl)) {\n+                // CSS chunks do not register themselves, and as such must be marked as\n+                // loaded instantly.\n+                resolver.resolve();\n+            }\n+            // We need to wait for JS chunks to register themselves within `registerChunk`\n+            // before we can start instantiating runtime modules, hence the absence of\n+            // `resolver.resolve()` in this branch.\n+            return resolver.promise;\n+        }\n+        if (typeof importScripts === 'function') {\n+            // We're in a web worker\n+            if (isCss(chunkUrl)) {\n+            // ignore\n+            } else if (isJs(chunkUrl)) {\n+                self.TURBOPACK_NEXT_CHUNK_URLS.push(chunkUrl);\n+                importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl);\n+            } else {\n+                throw new Error(`can't infer type of chunk from URL ${chunkUrl} in worker`);\n+            }\n+        } else {\n+            // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\n+            var decodedChunkUrl = decodeURI(chunkUrl);\n+            if (isCss(chunkUrl)) {\n+                var previousLinks = document.querySelectorAll(`link[rel=stylesheet][href=\"${chunkUrl}\"],link[rel=stylesheet][href^=\"${chunkUrl}?\"],link[rel=stylesheet][href=\"${decodedChunkUrl}\"],link[rel=stylesheet][href^=\"${decodedChunkUrl}?\"]`);\n+                if (previousLinks.length > 0) {\n+                    // CSS chunks do not register themselves, and as such must be marked as\n+                    // loaded instantly.\n+                    resolver.resolve();\n+                } else {\n+                    var link = document.createElement('link');\n+                    link.rel = 'stylesheet';\n+                    link.href = chunkUrl;\n+                    link.onerror = function() {\n+                        resolver.reject();\n+                    };\n+                    link.onload = function() {\n+                        // CSS chunks do not register themselves, and as such must be marked as\n+                        // loaded instantly.\n+                        resolver.resolve();\n+                    };\n+                    // Append to the `head` for webpack compatibility.\n+                    document.head.appendChild(link);\n+                }\n+            } else if (isJs(chunkUrl)) {\n+                var previousScripts = document.querySelectorAll(`script[src=\"${chunkUrl}\"],script[src^=\"${chunkUrl}?\"],script[src=\"${decodedChunkUrl}\"],script[src^=\"${decodedChunkUrl}?\"]`);\n+                if (previousScripts.length > 0) {\n+                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n+                    try {\n+                        // There is this edge where the script already failed loading, but we\n+                        // can't detect that. The Promise will never resolve in this case.\n+                        for(var _iterator = Array.from(previousScripts)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n+                            var script = _step.value;\n+                            script.addEventListener('error', function() {\n+                                resolver.reject();\n+                            });\n+                        }\n+                    } catch (err) {\n+                        _didIteratorError = true;\n+                        _iteratorError = err;\n+                    } finally{\n+                        try {\n+                            if (!_iteratorNormalCompletion && _iterator.return != null) {\n+                                _iterator.return();\n+                            }\n+                        } finally{\n+                            if (_didIteratorError) {\n+                                throw _iteratorError;\n+                            }\n+                        }\n+                    }\n+                } else {\n+                    var script1 = document.createElement('script');\n+                    script1.src = chunkUrl;\n+                    // We'll only mark the chunk as loaded once the script has been executed,\n+                    // which happens in `registerChunk`. Hence the absence of `resolve()` in\n+                    // this branch.\n+                    script1.onerror = function() {\n+                        resolver.reject();\n+                    };\n+                    // Append to the `head` for webpack compatibility.\n+                    document.head.appendChild(script1);\n+                }\n+            } else {\n+                throw new Error(`can't infer type of chunk from URL ${chunkUrl}`);\n+            }\n+        }\n+        resolver.loadingStarted = true;\n+        return resolver.promise;\n+    }\n+    function fetchWebAssembly(wasmChunkPath) {\n+        return fetch(getChunkRelativeUrl(wasmChunkPath));\n+    }\n+})();\n+const chunksToRegister = globalThis.TURBOPACK;\n+globalThis.TURBOPACK = { push: registerChunk };\n+chunksToRegister.forEach(registerChunk);\n+})();\n+\n+\n+//# sourceMappingURL=780ce_turbopack-tests_tests_snapshot_swc_transforms_preset_env_input_index_5aaf1327.js.map\n\\ No newline at end of file"
        },
        {
            "sha": "644f003a81f2aa53b34548c145d364db19aab35c",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/swc_transforms/preset_env/output/780ce_turbopack-tests_tests_snapshot_swc_transforms_preset_env_input_index_5aaf1327.js.map",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fswc_transforms%2Fpreset_env%2Foutput%2F780ce_turbopack-tests_tests_snapshot_swc_transforms_preset_env_input_index_5aaf1327.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fswc_transforms%2Fpreset_env%2Foutput%2F780ce_turbopack-tests_tests_snapshot_swc_transforms_preset_env_input_index_5aaf1327.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fswc_transforms%2Fpreset_env%2Foutput%2F780ce_turbopack-tests_tests_snapshot_swc_transforms_preset_env_input_index_5aaf1327.js.map?ref=6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
            "patch": "@@ -1,5 +1,9 @@\n {\n   \"version\": 3,\n   \"sources\": [],\n-  \"sections\": []\n+  \"sections\": [\n+    {\"offset\": {\"line\": 13, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared/runtime-utils.ts\"],\"sourcesContent\":[\"/**\\n * This file contains runtime types and functions that are shared between all\\n * TurboPack ECMAScript runtimes.\\n *\\n * It will be prepended to the runtime code of each runtime.\\n */\\n\\n/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"./runtime-types.d.ts\\\" />\\n\\ntype EsmNamespaceObject = Record<string, any>\\n\\n// @ts-ignore Defined in `dev-base.ts`\\ndeclare function getOrInstantiateModuleFromParent<M>(\\n  id: ModuleId,\\n  sourceModule: M\\n): M\\n\\nconst REEXPORTED_OBJECTS = new WeakMap<Module, ReexportedObjects>()\\n\\n/**\\n * Constructs the `__turbopack_context__` object for a module.\\n */\\nfunction Context(\\n  this: TurbopackBaseContext<Module>,\\n  module: Module,\\n  exports: Exports\\n) {\\n  this.m = module\\n  // We need to store this here instead of accessing it from the module object to:\\n  // 1. Make it available to factories directly, since we rewrite `this` to\\n  //    `__turbopack_context__.e` in CJS modules.\\n  // 2. Support async modules which rewrite `module.exports` to a promise, so we\\n  //    can still access the original exports object from functions like\\n  //    `esmExport`\\n  // Ideally we could find a new approach for async modules and drop this property altogether.\\n  this.e = exports\\n}\\nconst contextPrototype = Context.prototype as TurbopackBaseContext<Module>\\n\\ntype ModuleContextMap = Record<ModuleId, ModuleContextEntry>\\n\\ninterface ModuleContextEntry {\\n  id: () => ModuleId\\n  module: () => any\\n}\\n\\ninterface ModuleContext {\\n  // require call\\n  (moduleId: ModuleId): Exports | EsmNamespaceObject\\n\\n  // async import call\\n  import(moduleId: ModuleId): Promise<Exports | EsmNamespaceObject>\\n\\n  keys(): ModuleId[]\\n\\n  resolve(moduleId: ModuleId): ModuleId\\n}\\n\\ntype GetOrInstantiateModuleFromParent<M extends Module> = (\\n  moduleId: M['id'],\\n  parentModule: M\\n) => M\\n\\ndeclare function getOrInstantiateRuntimeModule(\\n  chunkPath: ChunkPath,\\n  moduleId: ModuleId\\n): Module\\n\\nconst hasOwnProperty = Object.prototype.hasOwnProperty\\nconst toStringTag = typeof Symbol !== 'undefined' && Symbol.toStringTag\\n\\nfunction defineProp(\\n  obj: any,\\n  name: PropertyKey,\\n  options: PropertyDescriptor & ThisType<any>\\n) {\\n  if (!hasOwnProperty.call(obj, name)) Object.defineProperty(obj, name, options)\\n}\\n\\nfunction getOverwrittenModule(\\n  moduleCache: ModuleCache<Module>,\\n  id: ModuleId\\n): Module {\\n  let module = moduleCache[id]\\n  if (!module) {\\n    // This is invoked when a module is merged into another module, thus it wasn't invoked via\\n    // instantiateModule and the cache entry wasn't created yet.\\n    module = createModuleObject(id)\\n    moduleCache[id] = module\\n  }\\n  return module\\n}\\n\\n/**\\n * Creates the module object. Only done here to ensure all module objects have the same shape.\\n */\\nfunction createModuleObject(id: ModuleId): Module {\\n  return {\\n    exports: {},\\n    error: undefined,\\n    id,\\n    namespaceObject: undefined,\\n  }\\n}\\n\\ntype BindingTag = 0\\nconst BindingTag_Value = 0 as BindingTag\\n\\n// an arbitrary sequence of bindings as\\n// - a prop name\\n// - BindingTag_Value, a value to be bound directly, or\\n// - 1 or 2 functions to bind as getters and sdetters\\ntype EsmBindings = Array<\\n  string | BindingTag | (() => unknown) | ((v: unknown) => void) | unknown\\n>\\n\\n/**\\n * Adds the getters to the exports object.\\n */\\nfunction esm(exports: Exports, bindings: EsmBindings) {\\n  defineProp(exports, '__esModule', { value: true })\\n  if (toStringTag) defineProp(exports, toStringTag, { value: 'Module' })\\n  let i = 0\\n  while (i < bindings.length) {\\n    const propName = bindings[i++] as string\\n    const tagOrFunction = bindings[i++]\\n    if (typeof tagOrFunction === 'number') {\\n      if (tagOrFunction === BindingTag_Value) {\\n        defineProp(exports, propName, {\\n          value: bindings[i++],\\n          enumerable: true,\\n          writable: false,\\n        })\\n      } else {\\n        throw new Error(`unexpected tag: ${tagOrFunction}`)\\n      }\\n    } else {\\n      const getterFn = tagOrFunction as () => unknown\\n      if (typeof bindings[i] === 'function') {\\n        const setterFn = bindings[i++] as (v: unknown) => void\\n        defineProp(exports, propName, {\\n          get: getterFn,\\n          set: setterFn,\\n          enumerable: true,\\n        })\\n      } else {\\n        defineProp(exports, propName, {\\n          get: getterFn,\\n          enumerable: true,\\n        })\\n      }\\n    }\\n  }\\n  Object.seal(exports)\\n}\\n\\n/**\\n * Makes the module an ESM with exports\\n */\\nfunction esmExport(\\n  this: TurbopackBaseContext<Module>,\\n  bindings: EsmBindings,\\n  id: ModuleId | undefined\\n) {\\n  let module: Module\\n  let exports: Module['exports']\\n  if (id != null) {\\n    module = getOverwrittenModule(this.c, id)\\n    exports = module.exports\\n  } else {\\n    module = this.m\\n    exports = this.e\\n  }\\n  module.namespaceObject = exports\\n  esm(exports, bindings)\\n}\\ncontextPrototype.s = esmExport\\n\\ntype ReexportedObjects = Record<PropertyKey, unknown>[]\\nfunction ensureDynamicExports(\\n  module: Module,\\n  exports: Exports\\n): ReexportedObjects {\\n  let reexportedObjects: ReexportedObjects | undefined =\\n    REEXPORTED_OBJECTS.get(module)\\n\\n  if (!reexportedObjects) {\\n    REEXPORTED_OBJECTS.set(module, (reexportedObjects = []))\\n    module.exports = module.namespaceObject = new Proxy(exports, {\\n      get(target, prop) {\\n        if (\\n          hasOwnProperty.call(target, prop) ||\\n          prop === 'default' ||\\n          prop === '__esModule'\\n        ) {\\n          return Reflect.get(target, prop)\\n        }\\n        for (const obj of reexportedObjects!) {\\n          const value = Reflect.get(obj, prop)\\n          if (value !== undefined) return value\\n        }\\n        return undefined\\n      },\\n      ownKeys(target) {\\n        const keys = Reflect.ownKeys(target)\\n        for (const obj of reexportedObjects!) {\\n          for (const key of Reflect.ownKeys(obj)) {\\n            if (key !== 'default' && !keys.includes(key)) keys.push(key)\\n          }\\n        }\\n        return keys\\n      },\\n    })\\n  }\\n  return reexportedObjects\\n}\\n\\n/**\\n * Dynamically exports properties from an object\\n */\\nfunction dynamicExport(\\n  this: TurbopackBaseContext<Module>,\\n  object: Record<string, any>,\\n  id: ModuleId | undefined\\n) {\\n  let module: Module\\n  let exports: Exports\\n  if (id != null) {\\n    module = getOverwrittenModule(this.c, id)\\n    exports = module.exports\\n  } else {\\n    module = this.m\\n    exports = this.e\\n  }\\n  const reexportedObjects = ensureDynamicExports(module, exports)\\n\\n  if (typeof object === 'object' && object !== null) {\\n    reexportedObjects.push(object)\\n  }\\n}\\ncontextPrototype.j = dynamicExport\\n\\nfunction exportValue(\\n  this: TurbopackBaseContext<Module>,\\n  value: any,\\n  id: ModuleId | undefined\\n) {\\n  let module: Module\\n  if (id != null) {\\n    module = getOverwrittenModule(this.c, id)\\n  } else {\\n    module = this.m\\n  }\\n  module.exports = value\\n}\\ncontextPrototype.v = exportValue\\n\\nfunction exportNamespace(\\n  this: TurbopackBaseContext<Module>,\\n  namespace: any,\\n  id: ModuleId | undefined\\n) {\\n  let module: Module\\n  if (id != null) {\\n    module = getOverwrittenModule(this.c, id)\\n  } else {\\n    module = this.m\\n  }\\n  module.exports = module.namespaceObject = namespace\\n}\\ncontextPrototype.n = exportNamespace\\n\\nfunction createGetter(obj: Record<string | symbol, any>, key: string | symbol) {\\n  return () => obj[key]\\n}\\n\\n/**\\n * @returns prototype of the object\\n */\\nconst getProto: (obj: any) => any = Object.getPrototypeOf\\n  ? (obj) => Object.getPrototypeOf(obj)\\n  : (obj) => obj.__proto__\\n\\n/** Prototypes that are not expanded for exports */\\nconst LEAF_PROTOTYPES = [null, getProto({}), getProto([]), getProto(getProto)]\\n\\n/**\\n * @param raw\\n * @param ns\\n * @param allowExportDefault\\n *   * `false`: will have the raw module as default export\\n *   * `true`: will have the default property as default export\\n */\\nfunction interopEsm(\\n  raw: Exports,\\n  ns: EsmNamespaceObject,\\n  allowExportDefault?: boolean\\n) {\\n  const bindings: EsmBindings = []\\n  let defaultLocation = -1\\n  for (\\n    let current = raw;\\n    (typeof current === 'object' || typeof current === 'function') &&\\n    !LEAF_PROTOTYPES.includes(current);\\n    current = getProto(current)\\n  ) {\\n    for (const key of Object.getOwnPropertyNames(current)) {\\n      bindings.push(key, createGetter(raw, key))\\n      if (defaultLocation === -1 && key === 'default') {\\n        defaultLocation = bindings.length - 1\\n      }\\n    }\\n  }\\n\\n  // this is not really correct\\n  // we should set the `default` getter if the imported module is a `.cjs file`\\n  if (!(allowExportDefault && defaultLocation >= 0)) {\\n    // Replace the binding with one for the namespace itself in order to preserve iteration order.\\n    if (defaultLocation >= 0) {\\n      // Replace the getter with the value\\n      bindings.splice(defaultLocation, 1, BindingTag_Value, raw)\\n    } else {\\n      bindings.push('default', BindingTag_Value, raw)\\n    }\\n  }\\n\\n  esm(ns, bindings)\\n  return ns\\n}\\n\\nfunction createNS(raw: Module['exports']): EsmNamespaceObject {\\n  if (typeof raw === 'function') {\\n    return function (this: any, ...args: any[]) {\\n      return raw.apply(this, args)\\n    }\\n  } else {\\n    return Object.create(null)\\n  }\\n}\\n\\nfunction esmImport(\\n  this: TurbopackBaseContext<Module>,\\n  id: ModuleId\\n): Exclude<Module['namespaceObject'], undefined> {\\n  const module = getOrInstantiateModuleFromParent(id, this.m)\\n\\n  // any ES module has to have `module.namespaceObject` defined.\\n  if (module.namespaceObject) return module.namespaceObject\\n\\n  // only ESM can be an async module, so we don't need to worry about exports being a promise here.\\n  const raw = module.exports\\n  return (module.namespaceObject = interopEsm(\\n    raw,\\n    createNS(raw),\\n    raw && (raw as any).__esModule\\n  ))\\n}\\ncontextPrototype.i = esmImport\\n\\nfunction asyncLoader(\\n  this: TurbopackBaseContext<Module>,\\n  moduleId: ModuleId\\n): Promise<Exports> {\\n  const loader = this.r(moduleId) as (\\n    importFunction: EsmImport\\n  ) => Promise<Exports>\\n  return loader(esmImport.bind(this))\\n}\\ncontextPrototype.A = asyncLoader\\n\\n// Add a simple runtime require so that environments without one can still pass\\n// `typeof require` CommonJS checks so that exports are correctly registered.\\nconst runtimeRequire =\\n  // @ts-ignore\\n  typeof require === 'function'\\n    ? // @ts-ignore\\n      require\\n    : function require() {\\n        throw new Error('Unexpected use of runtime require')\\n      }\\ncontextPrototype.t = runtimeRequire\\n\\nfunction commonJsRequire(\\n  this: TurbopackBaseContext<Module>,\\n  id: ModuleId\\n): Exports {\\n  return getOrInstantiateModuleFromParent(id, this.m).exports\\n}\\ncontextPrototype.r = commonJsRequire\\n\\n/**\\n * `require.context` and require/import expression runtime.\\n */\\nfunction moduleContext(map: ModuleContextMap): ModuleContext {\\n  function moduleContext(id: ModuleId): Exports {\\n    if (hasOwnProperty.call(map, id)) {\\n      return map[id].module()\\n    }\\n\\n    const e = new Error(`Cannot find module '${id}'`)\\n    ;(e as any).code = 'MODULE_NOT_FOUND'\\n    throw e\\n  }\\n\\n  moduleContext.keys = (): ModuleId[] => {\\n    return Object.keys(map)\\n  }\\n\\n  moduleContext.resolve = (id: ModuleId): ModuleId => {\\n    if (hasOwnProperty.call(map, id)) {\\n      return map[id].id()\\n    }\\n\\n    const e = new Error(`Cannot find module '${id}'`)\\n    ;(e as any).code = 'MODULE_NOT_FOUND'\\n    throw e\\n  }\\n\\n  moduleContext.import = async (id: ModuleId) => {\\n    return await (moduleContext(id) as Promise<Exports>)\\n  }\\n\\n  return moduleContext\\n}\\ncontextPrototype.f = moduleContext\\n\\n/**\\n * Returns the path of a chunk defined by its data.\\n */\\nfunction getChunkPath(chunkData: ChunkData): ChunkPath {\\n  return typeof chunkData === 'string' ? chunkData : chunkData.path\\n}\\n\\nfunction isPromise<T = any>(maybePromise: any): maybePromise is Promise<T> {\\n  return (\\n    maybePromise != null &&\\n    typeof maybePromise === 'object' &&\\n    'then' in maybePromise &&\\n    typeof maybePromise.then === 'function'\\n  )\\n}\\n\\nfunction isAsyncModuleExt<T extends {}>(obj: T): obj is AsyncModuleExt & T {\\n  return turbopackQueues in obj\\n}\\n\\nfunction createPromise<T>() {\\n  let resolve: (value: T | PromiseLike<T>) => void\\n  let reject: (reason?: any) => void\\n\\n  const promise = new Promise<T>((res, rej) => {\\n    reject = rej\\n    resolve = res\\n  })\\n\\n  return {\\n    promise,\\n    resolve: resolve!,\\n    reject: reject!,\\n  }\\n}\\n\\n// Load the CompressedmoduleFactories of a chunk into the `moduleFactories` Map.\\n// The CompressedModuleFactories format is\\n// - 1 or more module ids\\n// - a module factory function\\n// So walking this is a little complex but the flat structure is also fast to\\n// traverse, we can use `typeof` operators to distinguish the two cases.\\nfunction installCompressedModuleFactories(\\n  chunkModules: CompressedModuleFactories,\\n  offset: number,\\n  moduleFactories: ModuleFactories,\\n  newModuleId?: (id: ModuleId) => void\\n) {\\n  let i = offset\\n  while (i < chunkModules.length) {\\n    let moduleId = chunkModules[i] as ModuleId\\n    let end = i + 1\\n    // Find our factory function\\n    while (\\n      end < chunkModules.length &&\\n      typeof chunkModules[end] !== 'function'\\n    ) {\\n      end++\\n    }\\n    if (end === chunkModules.length) {\\n      throw new Error('malformed chunk format, expected a factory function')\\n    }\\n    // Each chunk item has a 'primary id' and optional additional ids. If the primary id is already\\n    // present we know all the additional ids are also present, so we don't need to check.\\n    if (!moduleFactories.has(moduleId)) {\\n      const moduleFactoryFn = chunkModules[end] as Function\\n      applyModuleFactoryName(moduleFactoryFn)\\n      newModuleId?.(moduleId)\\n      for (; i < end; i++) {\\n        moduleId = chunkModules[i] as ModuleId\\n        moduleFactories.set(moduleId, moduleFactoryFn)\\n      }\\n    }\\n    i = end + 1 // end is pointing at the last factory advance to the next id or the end of the array.\\n  }\\n}\\n\\n// everything below is adapted from webpack\\n// https://github.com/webpack/webpack/blob/6be4065ade1e252c1d8dcba4af0f43e32af1bdc1/lib/runtime/AsyncModuleRuntimeModule.js#L13\\n\\nconst turbopackQueues = Symbol('turbopack queues')\\nconst turbopackExports = Symbol('turbopack exports')\\nconst turbopackError = Symbol('turbopack error')\\n\\nconst enum QueueStatus {\\n  Unknown = -1,\\n  Unresolved = 0,\\n  Resolved = 1,\\n}\\n\\ntype AsyncQueueFn = (() => void) & { queueCount: number }\\ntype AsyncQueue = AsyncQueueFn[] & {\\n  status: QueueStatus\\n}\\n\\nfunction resolveQueue(queue?: AsyncQueue) {\\n  if (queue && queue.status !== QueueStatus.Resolved) {\\n    queue.status = QueueStatus.Resolved\\n    queue.forEach((fn) => fn.queueCount--)\\n    queue.forEach((fn) => (fn.queueCount-- ? fn.queueCount++ : fn()))\\n  }\\n}\\n\\ntype Dep = Exports | AsyncModulePromise | Promise<Exports>\\n\\ntype AsyncModuleExt = {\\n  [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => void\\n  [turbopackExports]: Exports\\n  [turbopackError]?: any\\n}\\n\\ntype AsyncModulePromise<T = Exports> = Promise<T> & AsyncModuleExt\\n\\nfunction wrapDeps(deps: Dep[]): AsyncModuleExt[] {\\n  return deps.map((dep): AsyncModuleExt => {\\n    if (dep !== null && typeof dep === 'object') {\\n      if (isAsyncModuleExt(dep)) return dep\\n      if (isPromise(dep)) {\\n        const queue: AsyncQueue = Object.assign([], {\\n          status: QueueStatus.Unresolved,\\n        })\\n\\n        const obj: AsyncModuleExt = {\\n          [turbopackExports]: {},\\n          [turbopackQueues]: (fn: (queue: AsyncQueue) => void) => fn(queue),\\n        }\\n\\n        dep.then(\\n          (res) => {\\n            obj[turbopackExports] = res\\n            resolveQueue(queue)\\n          },\\n          (err) => {\\n            obj[turbopackError] = err\\n            resolveQueue(queue)\\n          }\\n        )\\n\\n        return obj\\n      }\\n    }\\n\\n    return {\\n      [turbopackExports]: dep,\\n      [turbopackQueues]: () => {},\\n    }\\n  })\\n}\\n\\nfunction asyncModule(\\n  this: TurbopackBaseContext<Module>,\\n  body: (\\n    handleAsyncDependencies: (\\n      deps: Dep[]\\n    ) => Exports[] | Promise<() => Exports[]>,\\n    asyncResult: (err?: any) => void\\n  ) => void,\\n  hasAwait: boolean\\n) {\\n  const module = this.m\\n  const queue: AsyncQueue | undefined = hasAwait\\n    ? Object.assign([], { status: QueueStatus.Unknown })\\n    : undefined\\n\\n  const depQueues: Set<AsyncQueue> = new Set()\\n\\n  const { resolve, reject, promise: rawPromise } = createPromise<Exports>()\\n\\n  const promise: AsyncModulePromise = Object.assign(rawPromise, {\\n    [turbopackExports]: module.exports,\\n    [turbopackQueues]: (fn) => {\\n      queue && fn(queue)\\n      depQueues.forEach(fn)\\n      promise['catch'](() => {})\\n    },\\n  } satisfies AsyncModuleExt)\\n\\n  const attributes: PropertyDescriptor = {\\n    get(): any {\\n      return promise\\n    },\\n    set(v: any) {\\n      // Calling `esmExport` leads to this.\\n      if (v !== promise) {\\n        promise[turbopackExports] = v\\n      }\\n    },\\n  }\\n\\n  Object.defineProperty(module, 'exports', attributes)\\n  Object.defineProperty(module, 'namespaceObject', attributes)\\n\\n  function handleAsyncDependencies(deps: Dep[]) {\\n    const currentDeps = wrapDeps(deps)\\n\\n    const getResult = () =>\\n      currentDeps.map((d) => {\\n        if (d[turbopackError]) throw d[turbopackError]\\n        return d[turbopackExports]\\n      })\\n\\n    const { promise, resolve } = createPromise<() => Exports[]>()\\n\\n    const fn: AsyncQueueFn = Object.assign(() => resolve(getResult), {\\n      queueCount: 0,\\n    })\\n\\n    function fnQueue(q: AsyncQueue) {\\n      if (q !== queue && !depQueues.has(q)) {\\n        depQueues.add(q)\\n        if (q && q.status === QueueStatus.Unresolved) {\\n          fn.queueCount++\\n          q.push(fn)\\n        }\\n      }\\n    }\\n\\n    currentDeps.map((dep) => dep[turbopackQueues](fnQueue))\\n\\n    return fn.queueCount ? promise : getResult()\\n  }\\n\\n  function asyncResult(err?: any) {\\n    if (err) {\\n      reject((promise[turbopackError] = err))\\n    } else {\\n      resolve(promise[turbopackExports])\\n    }\\n\\n    resolveQueue(queue)\\n  }\\n\\n  body(handleAsyncDependencies, asyncResult)\\n\\n  if (queue && queue.status === QueueStatus.Unknown) {\\n    queue.status = QueueStatus.Unresolved\\n  }\\n}\\ncontextPrototype.a = asyncModule\\n\\n/**\\n * A pseudo \\\"fake\\\" URL object to resolve to its relative path.\\n *\\n * When UrlRewriteBehavior is set to relative, calls to the `new URL()` will construct url without base using this\\n * runtime function to generate context-agnostic urls between different rendering context, i.e ssr / client to avoid\\n * hydration mismatch.\\n *\\n * This is based on webpack's existing implementation:\\n * https://github.com/webpack/webpack/blob/87660921808566ef3b8796f8df61bd79fc026108/lib/runtime/RelativeUrlRuntimeModule.js\\n */\\nconst relativeURL = function relativeURL(this: any, inputUrl: string) {\\n  const realUrl = new URL(inputUrl, 'x:/')\\n  const values: Record<string, any> = {}\\n  for (const key in realUrl) values[key] = (realUrl as any)[key]\\n  values.href = inputUrl\\n  values.pathname = inputUrl.replace(/[?#].*/, '')\\n  values.origin = values.protocol = ''\\n  values.toString = values.toJSON = (..._args: Array<any>) => inputUrl\\n  for (const key in values)\\n    Object.defineProperty(this, key, {\\n      enumerable: true,\\n      configurable: true,\\n      value: values[key],\\n    })\\n}\\nrelativeURL.prototype = URL.prototype\\ncontextPrototype.U = relativeURL\\n\\n/**\\n * Utility function to ensure all variants of an enum are handled.\\n */\\nfunction invariant(never: never, computeMessage: (arg: any) => string): never {\\n  throw new Error(`Invariant: ${computeMessage(never)}`)\\n}\\n\\n/**\\n * A stub function to make `require` available but non-functional in ESM.\\n */\\nfunction requireStub(_moduleId: ModuleId): never {\\n  throw new Error('dynamic usage of require is not supported')\\n}\\ncontextPrototype.z = requireStub\\n\\n// Make `globalThis` available to the module in a way that cannot be shadowed by a local variable.\\ncontextPrototype.g = globalThis\\n\\ntype ContextConstructor<M> = {\\n  new (module: Module, exports: Exports): TurbopackBaseContext<M>\\n}\\n\\nfunction applyModuleFactoryName(factory: Function) {\\n  // Give the module factory a nice name to improve stack traces.\\n  Object.defineProperty(factory, 'name', {\\n    value: '__TURBOPACK__module__evaluation__',\\n  })\\n}\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}},\n+    {\"offset\": {\"line\": 733, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/browser/runtime/base/runtime-base.ts\"],\"sourcesContent\":[\"/**\\n * This file contains runtime types and functions that are shared between all\\n * Turbopack *development* ECMAScript runtimes.\\n *\\n * It will be appended to the runtime code of each runtime right after the\\n * shared runtime utils.\\n */\\n\\n/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../base/globals.d.ts\\\" />\\n/// <reference path=\\\"../../../shared/runtime-utils.ts\\\" />\\n\\n// Used in WebWorkers to tell the runtime about the chunk base path\\ndeclare var TURBOPACK_WORKER_LOCATION: string\\n// Used in WebWorkers to tell the runtime about the current chunk url since it can't be detected via document.currentScript\\n// Note it's stored in reversed order to use push and pop\\ndeclare var TURBOPACK_NEXT_CHUNK_URLS: ChunkUrl[] | undefined\\n\\n// Injected by rust code\\ndeclare var CHUNK_BASE_PATH: string\\ndeclare var CHUNK_SUFFIX_PATH: string\\n\\ninterface TurbopackBrowserBaseContext<M> extends TurbopackBaseContext<M> {\\n  R: ResolvePathFromModule\\n}\\n\\nconst browserContextPrototype =\\n  Context.prototype as TurbopackBrowserBaseContext<unknown>\\n\\n// Provided by build or dev base\\ndeclare function instantiateModule(\\n  id: ModuleId,\\n  sourceType: SourceType,\\n  sourceData: SourceData\\n): Module\\n\\ntype RuntimeParams = {\\n  otherChunks: ChunkData[]\\n  runtimeModuleIds: ModuleId[]\\n}\\n\\ntype ChunkRegistration = [\\n  chunkPath: ChunkScript,\\n  ...([RuntimeParams] | CompressedModuleFactories),\\n]\\n\\ntype ChunkList = {\\n  script: ChunkListScript\\n  chunks: ChunkData[]\\n  source: 'entry' | 'dynamic'\\n}\\n\\nenum SourceType {\\n  /**\\n   * The module was instantiated because it was included in an evaluated chunk's\\n   * runtime.\\n   * SourceData is a ChunkPath.\\n   */\\n  Runtime = 0,\\n  /**\\n   * The module was instantiated because a parent module imported it.\\n   * SourceData is a ModuleId.\\n   */\\n  Parent = 1,\\n  /**\\n   * The module was instantiated because it was included in a chunk's hot module\\n   * update.\\n   * SourceData is an array of ModuleIds or undefined.\\n   */\\n  Update = 2,\\n}\\n\\ntype SourceData = ChunkPath | ModuleId | ModuleId[] | undefined\\ninterface RuntimeBackend {\\n  registerChunk: (chunkPath: ChunkPath, params?: RuntimeParams) => void\\n  /**\\n   * Returns the same Promise for the same chunk URL.\\n   */\\n  loadChunkCached: (sourceType: SourceType, chunkUrl: ChunkUrl) => Promise<void>\\n  loadWebAssembly: (\\n    sourceType: SourceType,\\n    sourceData: SourceData,\\n    wasmChunkPath: ChunkPath,\\n    edgeModule: () => WebAssembly.Module,\\n    importsObj: WebAssembly.Imports\\n  ) => Promise<Exports>\\n  loadWebAssemblyModule: (\\n    sourceType: SourceType,\\n    sourceData: SourceData,\\n    wasmChunkPath: ChunkPath,\\n    edgeModule: () => WebAssembly.Module\\n  ) => Promise<WebAssembly.Module>\\n}\\n\\ninterface DevRuntimeBackend {\\n  reloadChunk?: (chunkUrl: ChunkUrl) => Promise<void>\\n  unloadChunk?: (chunkUrl: ChunkUrl) => void\\n  restart: () => void\\n}\\n\\nconst moduleFactories: ModuleFactories = new Map()\\ncontextPrototype.M = moduleFactories\\n\\nconst availableModules: Map<ModuleId, Promise<any> | true> = new Map()\\n\\nconst availableModuleChunks: Map<ChunkPath, Promise<any> | true> = new Map()\\n\\nfunction factoryNotAvailableMessage(\\n  moduleId: ModuleId,\\n  sourceType: SourceType,\\n  sourceData: SourceData\\n): string {\\n  let instantiationReason\\n  switch (sourceType) {\\n    case SourceType.Runtime:\\n      instantiationReason = `as a runtime entry of chunk ${sourceData}`\\n      break\\n    case SourceType.Parent:\\n      instantiationReason = `because it was required from module ${sourceData}`\\n      break\\n    case SourceType.Update:\\n      instantiationReason = 'because of an HMR update'\\n      break\\n    default:\\n      invariant(\\n        sourceType,\\n        (sourceType) => `Unknown source type: ${sourceType}`\\n      )\\n  }\\n  return `Module ${moduleId} was instantiated ${instantiationReason}, but the module factory is not available.`\\n}\\n\\nfunction loadChunk(\\n  this: TurbopackBrowserBaseContext<Module>,\\n  chunkData: ChunkData\\n): Promise<void> {\\n  return loadChunkInternal(SourceType.Parent, this.m.id, chunkData)\\n}\\nbrowserContextPrototype.l = loadChunk\\n\\nfunction loadInitialChunk(chunkPath: ChunkPath, chunkData: ChunkData) {\\n  return loadChunkInternal(SourceType.Runtime, chunkPath, chunkData)\\n}\\n\\nasync function loadChunkInternal(\\n  sourceType: SourceType,\\n  sourceData: SourceData,\\n  chunkData: ChunkData\\n): Promise<void> {\\n  if (typeof chunkData === 'string') {\\n    return loadChunkPath(sourceType, sourceData, chunkData)\\n  }\\n\\n  const includedList = chunkData.included || []\\n  const modulesPromises = includedList.map((included) => {\\n    if (moduleFactories.has(included)) return true\\n    return availableModules.get(included)\\n  })\\n  if (modulesPromises.length > 0 && modulesPromises.every((p) => p)) {\\n    // When all included items are already loaded or loading, we can skip loading ourselves\\n    await Promise.all(modulesPromises)\\n    return\\n  }\\n\\n  const includedModuleChunksList = chunkData.moduleChunks || []\\n  const moduleChunksPromises = includedModuleChunksList\\n    .map((included) => {\\n      // TODO(alexkirsz) Do we need this check?\\n      // if (moduleFactories[included]) return true;\\n      return availableModuleChunks.get(included)\\n    })\\n    .filter((p) => p)\\n\\n  let promise: Promise<unknown>\\n  if (moduleChunksPromises.length > 0) {\\n    // Some module chunks are already loaded or loading.\\n\\n    if (moduleChunksPromises.length === includedModuleChunksList.length) {\\n      // When all included module chunks are already loaded or loading, we can skip loading ourselves\\n      await Promise.all(moduleChunksPromises)\\n      return\\n    }\\n\\n    const moduleChunksToLoad: Set<ChunkPath> = new Set()\\n    for (const moduleChunk of includedModuleChunksList) {\\n      if (!availableModuleChunks.has(moduleChunk)) {\\n        moduleChunksToLoad.add(moduleChunk)\\n      }\\n    }\\n\\n    for (const moduleChunkToLoad of moduleChunksToLoad) {\\n      const promise = loadChunkPath(sourceType, sourceData, moduleChunkToLoad)\\n\\n      availableModuleChunks.set(moduleChunkToLoad, promise)\\n\\n      moduleChunksPromises.push(promise)\\n    }\\n\\n    promise = Promise.all(moduleChunksPromises)\\n  } else {\\n    promise = loadChunkPath(sourceType, sourceData, chunkData.path)\\n\\n    // Mark all included module chunks as loading if they are not already loaded or loading.\\n    for (const includedModuleChunk of includedModuleChunksList) {\\n      if (!availableModuleChunks.has(includedModuleChunk)) {\\n        availableModuleChunks.set(includedModuleChunk, promise)\\n      }\\n    }\\n  }\\n\\n  for (const included of includedList) {\\n    if (!availableModules.has(included)) {\\n      // It might be better to race old and new promises, but it's rare that the new promise will be faster than a request started earlier.\\n      // In production it's even more rare, because the chunk optimization tries to deduplicate modules anyway.\\n      availableModules.set(included, promise)\\n    }\\n  }\\n\\n  await promise\\n}\\n\\nconst loadedChunk = Promise.resolve(undefined)\\nconst instrumentedBackendLoadChunks = new WeakMap<\\n  Promise<any>,\\n  Promise<any> | typeof loadedChunk\\n>()\\n// Do not make this async. React relies on referential equality of the returned Promise.\\nfunction loadChunkByUrl(\\n  this: TurbopackBrowserBaseContext<Module>,\\n  chunkUrl: ChunkUrl\\n) {\\n  return loadChunkByUrlInternal(SourceType.Parent, this.m.id, chunkUrl)\\n}\\nbrowserContextPrototype.L = loadChunkByUrl\\n\\n// Do not make this async. React relies on referential equality of the returned Promise.\\nfunction loadChunkByUrlInternal(\\n  sourceType: SourceType,\\n  sourceData: SourceData,\\n  chunkUrl: ChunkUrl\\n): Promise<any> {\\n  const thenable = BACKEND.loadChunkCached(sourceType, chunkUrl)\\n  let entry = instrumentedBackendLoadChunks.get(thenable)\\n  if (entry === undefined) {\\n    const resolve = instrumentedBackendLoadChunks.set.bind(\\n      instrumentedBackendLoadChunks,\\n      thenable,\\n      loadedChunk\\n    )\\n    entry = thenable.then(resolve).catch((error) => {\\n      let loadReason: string\\n      switch (sourceType) {\\n        case SourceType.Runtime:\\n          loadReason = `as a runtime dependency of chunk ${sourceData}`\\n          break\\n        case SourceType.Parent:\\n          loadReason = `from module ${sourceData}`\\n          break\\n        case SourceType.Update:\\n          loadReason = 'from an HMR update'\\n          break\\n        default:\\n          invariant(\\n            sourceType,\\n            (sourceType) => `Unknown source type: ${sourceType}`\\n          )\\n      }\\n      throw new Error(\\n        `Failed to load chunk ${chunkUrl} ${loadReason}${\\n          error ? `: ${error}` : ''\\n        }`,\\n        error\\n          ? {\\n              cause: error,\\n            }\\n          : undefined\\n      )\\n    })\\n    instrumentedBackendLoadChunks.set(thenable, entry)\\n  }\\n\\n  return entry\\n}\\n\\n// Do not make this async. React relies on referential equality of the returned Promise.\\nfunction loadChunkPath(\\n  sourceType: SourceType,\\n  sourceData: SourceData,\\n  chunkPath: ChunkPath\\n): Promise<void> {\\n  const url = getChunkRelativeUrl(chunkPath)\\n  return loadChunkByUrlInternal(sourceType, sourceData, url)\\n}\\n\\n/**\\n * Returns an absolute url to an asset.\\n */\\nfunction resolvePathFromModule(\\n  this: TurbopackBaseContext<Module>,\\n  moduleId: string\\n): string {\\n  const exported = this.r(moduleId)\\n  return exported?.default ?? exported\\n}\\nbrowserContextPrototype.R = resolvePathFromModule\\n\\n/**\\n * no-op for browser\\n * @param modulePath\\n */\\nfunction resolveAbsolutePath(modulePath?: string): string {\\n  return `/ROOT/${modulePath ?? ''}`\\n}\\nbrowserContextPrototype.P = resolveAbsolutePath\\n\\n/**\\n * Returns a blob URL for the worker.\\n * @param chunks list of chunks to load\\n */\\nfunction getWorkerBlobURL(chunks: ChunkPath[]): string {\\n  // It is important to reverse the array so when bootstrapping we can infer what chunk is being\\n  // evaluated by poping urls off of this array.  See `getPathFromScript`\\n  let bootstrap = `self.TURBOPACK_WORKER_LOCATION = ${JSON.stringify(location.origin)};\\nself.TURBOPACK_NEXT_CHUNK_URLS = ${JSON.stringify(chunks.reverse().map(getChunkRelativeUrl), null, 2)};\\nimportScripts(...self.TURBOPACK_NEXT_CHUNK_URLS.map(c => self.TURBOPACK_WORKER_LOCATION + c).reverse());`\\n  let blob = new Blob([bootstrap], { type: 'text/javascript' })\\n  return URL.createObjectURL(blob)\\n}\\nbrowserContextPrototype.b = getWorkerBlobURL\\n\\n/**\\n * Instantiates a runtime module.\\n */\\nfunction instantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\\n}\\n/**\\n * Returns the URL relative to the origin where a chunk can be fetched from.\\n */\\nfunction getChunkRelativeUrl(chunkPath: ChunkPath | ChunkListPath): ChunkUrl {\\n  return `${CHUNK_BASE_PATH}${chunkPath\\n    .split('/')\\n    .map((p) => encodeURIComponent(p))\\n    .join('/')}${CHUNK_SUFFIX_PATH}` as ChunkUrl\\n}\\n\\n/**\\n * Return the ChunkPath from a ChunkScript.\\n */\\nfunction getPathFromScript(chunkScript: ChunkPath | ChunkScript): ChunkPath\\nfunction getPathFromScript(\\n  chunkScript: ChunkListPath | ChunkListScript\\n): ChunkListPath\\nfunction getPathFromScript(\\n  chunkScript: ChunkPath | ChunkListPath | ChunkScript | ChunkListScript\\n): ChunkPath | ChunkListPath {\\n  if (typeof chunkScript === 'string') {\\n    return chunkScript as ChunkPath | ChunkListPath\\n  }\\n  const chunkUrl =\\n    typeof TURBOPACK_NEXT_CHUNK_URLS !== 'undefined'\\n      ? TURBOPACK_NEXT_CHUNK_URLS.pop()!\\n      : chunkScript.getAttribute('src')!\\n  const src = decodeURIComponent(chunkUrl.replace(/[?#].*$/, ''))\\n  const path = src.startsWith(CHUNK_BASE_PATH)\\n    ? src.slice(CHUNK_BASE_PATH.length)\\n    : src\\n  return path as ChunkPath | ChunkListPath\\n}\\n\\nconst regexJsUrl = /\\\\.js(?:\\\\?[^#]*)?(?:#.*)?$/\\n/**\\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\\n */\\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\\n  return regexJsUrl.test(chunkUrlOrPath)\\n}\\n\\nconst regexCssUrl = /\\\\.css(?:\\\\?[^#]*)?(?:#.*)?$/\\n/**\\n * Checks if a given path/URL ends with .css, optionally followed by ?query or #fragment.\\n */\\nfunction isCss(chunkUrl: ChunkUrl): boolean {\\n  return regexCssUrl.test(chunkUrl)\\n}\\n\\nfunction loadWebAssembly(\\n  this: TurbopackBaseContext<Module>,\\n  chunkPath: ChunkPath,\\n  edgeModule: () => WebAssembly.Module,\\n  importsObj: WebAssembly.Imports\\n): Promise<Exports> {\\n  return BACKEND.loadWebAssembly(\\n    SourceType.Parent,\\n    this.m.id,\\n    chunkPath,\\n    edgeModule,\\n    importsObj\\n  )\\n}\\ncontextPrototype.w = loadWebAssembly\\n\\nfunction loadWebAssemblyModule(\\n  this: TurbopackBaseContext<Module>,\\n  chunkPath: ChunkPath,\\n  edgeModule: () => WebAssembly.Module\\n): Promise<WebAssembly.Module> {\\n  return BACKEND.loadWebAssemblyModule(\\n    SourceType.Parent,\\n    this.m.id,\\n    chunkPath,\\n    edgeModule\\n  )\\n}\\ncontextPrototype.u = loadWebAssemblyModule\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}},\n+    {\"offset\": {\"line\": 1201, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/browser/runtime/base/build-base.ts\"],\"sourcesContent\":[\"/// <reference path=\\\"./runtime-base.ts\\\" />\\n/// <reference path=\\\"./dummy.ts\\\" />\\n\\nconst moduleCache: ModuleCache<Module> = {}\\ncontextPrototype.c = moduleCache\\n\\n/**\\n * Gets or instantiates a runtime module.\\n */\\n// @ts-ignore\\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\\nfunction getOrInstantiateRuntimeModule(\\n  chunkPath: ChunkPath,\\n  moduleId: ModuleId\\n): Module {\\n  const module = moduleCache[moduleId]\\n  if (module) {\\n    if (module.error) {\\n      throw module.error\\n    }\\n    return module\\n  }\\n\\n  return instantiateModule(moduleId, SourceType.Runtime, chunkPath)\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it if it is not cached.\\n */\\n// Used by the backend\\n// @ts-ignore\\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\\nconst getOrInstantiateModuleFromParent: GetOrInstantiateModuleFromParent<\\n  Module\\n> = (id, sourceModule) => {\\n  const module = moduleCache[id]\\n\\n  if (module) {\\n    if (module.error) {\\n      throw module.error\\n    }\\n    return module\\n  }\\n\\n  return instantiateModule(id, SourceType.Parent, sourceModule.id)\\n}\\n\\nfunction instantiateModule(\\n  id: ModuleId,\\n  sourceType: SourceType,\\n  sourceData: SourceData\\n): Module {\\n  const moduleFactory = moduleFactories.get(id)\\n  if (typeof moduleFactory !== 'function') {\\n    // This can happen if modules incorrectly handle HMR disposes/updates,\\n    // e.g. when they keep a `setTimeout` around which still executes old code\\n    // and contains e.g. a `require(\\\"something\\\")` call.\\n    throw new Error(factoryNotAvailableMessage(id, sourceType, sourceData))\\n  }\\n\\n  const module: Module = createModuleObject(id)\\n  const exports = module.exports\\n\\n  moduleCache[id] = module\\n\\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\\n  const context = new (Context as any as ContextConstructor<Module>)(\\n    module,\\n    exports\\n  )\\n  try {\\n    moduleFactory(context, module, exports)\\n  } catch (error) {\\n    module.error = error as any\\n    throw error\\n  }\\n\\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\\n    interopEsm(module.exports, module.namespaceObject)\\n  }\\n\\n  return module\\n}\\n\\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\\nfunction registerChunk(registration: ChunkRegistration) {\\n  const chunkPath = getPathFromScript(registration[0])\\n  let runtimeParams: RuntimeParams | undefined\\n  // When bootstrapping we are passed a single runtimeParams object so we can distinguish purely based on length\\n  if (registration.length === 2) {\\n    runtimeParams = registration[1] as RuntimeParams\\n  } else {\\n    runtimeParams = undefined\\n    installCompressedModuleFactories(\\n      registration as CompressedModuleFactories,\\n      /* offset= */ 1,\\n      moduleFactories\\n    )\\n  }\\n\\n  return BACKEND.registerChunk(chunkPath, runtimeParams)\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,0CAA0C;AAC1C,mCAAmC;AAEnC,IAAM,cAAmC,CAAC;AAC1C,iBAAiB,CAAC,GAAG;AAErB;;CAEC,GACD,aAAa;AACb,6DAA6D;AAC7D,SAAS,8BACP,SAAoB,EACpB,QAAkB;IAElB,IAAM,SAAS,WAAW,CAAC,SAAS;IACpC,IAAI,QAAQ;QACV,IAAI,OAAO,KAAK,EAAE;YAChB,MAAM,OAAO,KAAK;QACpB;QACA,OAAO;IACT;IAEA,OAAO,kBAAkB,UAAU,WAAW,OAAO,EAAE;AACzD;AAEA;;CAEC,GACD,sBAAsB;AACtB,aAAa;AACb,6DAA6D;AAC7D,IAAM,mCAEF,SAAC,IAAI;IACP,IAAM,SAAS,WAAW,CAAC,GAAG;IAE9B,IAAI,QAAQ;QACV,IAAI,OAAO,KAAK,EAAE;YAChB,MAAM,OAAO,KAAK;QACpB;QACA,OAAO;IACT;IAEA,OAAO,kBAAkB,IAAI,WAAW,MAAM,EAAE,aAAa,EAAE;AACjE;AAEA,SAAS,kBACP,EAAY,EACZ,UAAsB,EACtB,UAAsB;IAEtB,IAAM,gBAAgB,gBAAgB,GAAG,CAAC;IAC1C,IAAI,OAAO,kBAAkB,YAAY;QACvC,sEAAsE;QACtE,0EAA0E;QAC1E,mDAAmD;QACnD,MAAM,IAAI,MAAM,2BAA2B,IAAI,YAAY;IAC7D;IAEA,IAAM,SAAiB,mBAAmB;IAC1C,IAAM,UAAU,OAAO,OAAO;IAE9B,WAAW,CAAC,GAAG,GAAG;IAElB,4EAA4E;IAC5E,IAAM,UAAU,IAAK,QACnB,QACA;IAEF,IAAI;QACF,cAAc,SAAS,QAAQ;IACjC,EAAE,OAAO,OAAO;QACd,OAAO,KAAK,GAAG;QACf,MAAM;IACR;IAEA,IAAI,OAAO,eAAe,IAAI,OAAO,OAAO,KAAK,OAAO,eAAe,EAAE;QACvE,yDAAyD;QACzD,WAAW,OAAO,OAAO,EAAE,OAAO,eAAe;IACnD;IAEA,OAAO;AACT;AAEA,6DAA6D;AAC7D,SAAS,cAAc,YAA+B;IACpD,IAAM,YAAY,kBAAkB,YAAY,CAAC,EAAE;IACnD,IAAI;IACJ,8GAA8G;IAC9G,IAAI,aAAa,MAAM,KAAK,GAAG;QAC7B,gBAAgB,YAAY,CAAC,EAAE;IACjC,OAAO;QACL,gBAAgB;QAChB,iCACE,cACA,WAAW,GAAG,GACd;IAEJ;IAEA,OAAO,QAAQ,aAAa,CAAC,WAAW;AAC1C\",\"ignoreList\":[0]}},\n+    {\"offset\": {\"line\": 1272, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/browser/runtime/dom/runtime-backend-dom.ts\"],\"sourcesContent\":[\"/**\\n * This file contains the runtime code specific to the Turbopack development\\n * ECMAScript DOM runtime.\\n *\\n * It will be appended to the base development runtime code.\\n */\\n\\n/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../../../browser/runtime/base/runtime-base.ts\\\" />\\n/// <reference path=\\\"../../../shared/runtime-types.d.ts\\\" />\\n\\ntype ChunkResolver = {\\n  resolved: boolean\\n  loadingStarted: boolean\\n  resolve: () => void\\n  reject: (error?: Error) => void\\n  promise: Promise<any>\\n}\\n\\nlet BACKEND: RuntimeBackend\\n\\n/**\\n * Maps chunk paths to the corresponding resolver.\\n */\\nconst chunkResolvers: Map<ChunkUrl, ChunkResolver> = new Map()\\n\\n;(() => {\\n  BACKEND = {\\n    async registerChunk(chunkPath, params) {\\n      const chunkUrl = getChunkRelativeUrl(chunkPath)\\n\\n      const resolver = getOrCreateResolver(chunkUrl)\\n      resolver.resolve()\\n\\n      if (params == null) {\\n        return\\n      }\\n\\n      for (const otherChunkData of params.otherChunks) {\\n        const otherChunkPath = getChunkPath(otherChunkData)\\n        const otherChunkUrl = getChunkRelativeUrl(otherChunkPath)\\n\\n        // Chunk might have started loading, so we want to avoid triggering another load.\\n        getOrCreateResolver(otherChunkUrl)\\n      }\\n\\n      // This waits for chunks to be loaded, but also marks included items as available.\\n      await Promise.all(\\n        params.otherChunks.map((otherChunkData) =>\\n          loadInitialChunk(chunkPath, otherChunkData)\\n        )\\n      )\\n\\n      if (params.runtimeModuleIds.length > 0) {\\n        for (const moduleId of params.runtimeModuleIds) {\\n          getOrInstantiateRuntimeModule(chunkPath, moduleId)\\n        }\\n      }\\n    },\\n\\n    /**\\n     * Loads the given chunk, and returns a promise that resolves once the chunk\\n     * has been loaded.\\n     */\\n    loadChunkCached(sourceType: SourceType, chunkUrl: ChunkUrl) {\\n      return doLoadChunk(sourceType, chunkUrl)\\n    },\\n\\n    async loadWebAssembly(\\n      _sourceType: SourceType,\\n      _sourceData: SourceData,\\n      wasmChunkPath: ChunkPath,\\n      _edgeModule: () => WebAssembly.Module,\\n      importsObj: WebAssembly.Imports\\n    ): Promise<Exports> {\\n      const req = fetchWebAssembly(wasmChunkPath)\\n\\n      const { instance } = await WebAssembly.instantiateStreaming(\\n        req,\\n        importsObj\\n      )\\n\\n      return instance.exports\\n    },\\n\\n    async loadWebAssemblyModule(\\n      _sourceType: SourceType,\\n      _sourceData: SourceData,\\n      wasmChunkPath: ChunkPath,\\n      _edgeModule: () => WebAssembly.Module\\n    ): Promise<WebAssembly.Module> {\\n      const req = fetchWebAssembly(wasmChunkPath)\\n\\n      return await WebAssembly.compileStreaming(req)\\n    },\\n  }\\n\\n  function getOrCreateResolver(chunkUrl: ChunkUrl): ChunkResolver {\\n    let resolver = chunkResolvers.get(chunkUrl)\\n    if (!resolver) {\\n      let resolve: () => void\\n      let reject: (error?: Error) => void\\n      const promise = new Promise<void>((innerResolve, innerReject) => {\\n        resolve = innerResolve\\n        reject = innerReject\\n      })\\n      resolver = {\\n        resolved: false,\\n        loadingStarted: false,\\n        promise,\\n        resolve: () => {\\n          resolver!.resolved = true\\n          resolve()\\n        },\\n        reject: reject!,\\n      }\\n      chunkResolvers.set(chunkUrl, resolver)\\n    }\\n    return resolver\\n  }\\n\\n  /**\\n   * Loads the given chunk, and returns a promise that resolves once the chunk\\n   * has been loaded.\\n   */\\n  function doLoadChunk(sourceType: SourceType, chunkUrl: ChunkUrl) {\\n    const resolver = getOrCreateResolver(chunkUrl)\\n    if (resolver.loadingStarted) {\\n      return resolver.promise\\n    }\\n\\n    if (sourceType === SourceType.Runtime) {\\n      // We don't need to load chunks references from runtime code, as they're already\\n      // present in the DOM.\\n      resolver.loadingStarted = true\\n\\n      if (isCss(chunkUrl)) {\\n        // CSS chunks do not register themselves, and as such must be marked as\\n        // loaded instantly.\\n        resolver.resolve()\\n      }\\n\\n      // We need to wait for JS chunks to register themselves within `registerChunk`\\n      // before we can start instantiating runtime modules, hence the absence of\\n      // `resolver.resolve()` in this branch.\\n\\n      return resolver.promise\\n    }\\n\\n    if (typeof importScripts === 'function') {\\n      // We're in a web worker\\n      if (isCss(chunkUrl)) {\\n        // ignore\\n      } else if (isJs(chunkUrl)) {\\n        self.TURBOPACK_NEXT_CHUNK_URLS!.push(chunkUrl)\\n        importScripts(TURBOPACK_WORKER_LOCATION + chunkUrl)\\n      } else {\\n        throw new Error(\\n          `can't infer type of chunk from URL ${chunkUrl} in worker`\\n        )\\n      }\\n    } else {\\n      // TODO(PACK-2140): remove this once all filenames are guaranteed to be escaped.\\n      const decodedChunkUrl = decodeURI(chunkUrl)\\n\\n      if (isCss(chunkUrl)) {\\n        const previousLinks = document.querySelectorAll(\\n          `link[rel=stylesheet][href=\\\"${chunkUrl}\\\"],link[rel=stylesheet][href^=\\\"${chunkUrl}?\\\"],link[rel=stylesheet][href=\\\"${decodedChunkUrl}\\\"],link[rel=stylesheet][href^=\\\"${decodedChunkUrl}?\\\"]`\\n        )\\n        if (previousLinks.length > 0) {\\n          // CSS chunks do not register themselves, and as such must be marked as\\n          // loaded instantly.\\n          resolver.resolve()\\n        } else {\\n          const link = document.createElement('link')\\n          link.rel = 'stylesheet'\\n          link.href = chunkUrl\\n          link.onerror = () => {\\n            resolver.reject()\\n          }\\n          link.onload = () => {\\n            // CSS chunks do not register themselves, and as such must be marked as\\n            // loaded instantly.\\n            resolver.resolve()\\n          }\\n          // Append to the `head` for webpack compatibility.\\n          document.head.appendChild(link)\\n        }\\n      } else if (isJs(chunkUrl)) {\\n        const previousScripts = document.querySelectorAll(\\n          `script[src=\\\"${chunkUrl}\\\"],script[src^=\\\"${chunkUrl}?\\\"],script[src=\\\"${decodedChunkUrl}\\\"],script[src^=\\\"${decodedChunkUrl}?\\\"]`\\n        )\\n        if (previousScripts.length > 0) {\\n          // There is this edge where the script already failed loading, but we\\n          // can't detect that. The Promise will never resolve in this case.\\n          for (const script of Array.from(previousScripts)) {\\n            script.addEventListener('error', () => {\\n              resolver.reject()\\n            })\\n          }\\n        } else {\\n          const script = document.createElement('script')\\n          script.src = chunkUrl\\n          // We'll only mark the chunk as loaded once the script has been executed,\\n          // which happens in `registerChunk`. Hence the absence of `resolve()` in\\n          // this branch.\\n          script.onerror = () => {\\n            resolver.reject()\\n          }\\n          // Append to the `head` for webpack compatibility.\\n          document.head.appendChild(script)\\n        }\\n      } else {\\n        throw new Error(`can't infer type of chunk from URL ${chunkUrl}`)\\n      }\\n    }\\n\\n    resolver.loadingStarted = true\\n    return resolver.promise\\n  }\\n\\n  function fetchWebAssembly(wasmChunkPath: ChunkPath) {\\n    return fetch(getChunkRelativeUrl(wasmChunkPath))\\n  }\\n})()\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}}]\n }\n\\ No newline at end of file"
        },
        {
            "sha": "0f0bc88e74a1d0d0b6e5624fa0ef6d4a2d5e7bb6",
            "filename": "turbopack/crates/turbopack/src/module_options/mod.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmod.rs?ref=6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
            "patch": "@@ -209,6 +209,7 @@ impl ModuleOptions {\n                     esm_url_rewrite_behavior,\n                     enable_typeof_window_inlining,\n                     source_maps: ecmascript_source_maps,\n+                    inline_helpers,\n                     ..\n                 },\n             enable_mdx,\n@@ -282,6 +283,7 @@ impl ModuleOptions {\n             keep_last_successful_parse,\n             analyze_mode,\n             enable_typeof_window_inlining,\n+            inline_helpers,\n             ..Default::default()\n         };\n         let ecmascript_options_vc = ecmascript_options.resolved_cell();"
        },
        {
            "sha": "386e0017dd12747328c49ec4033b5e3a7cf42fdf",
            "filename": "turbopack/crates/turbopack/src/module_options/module_options_context.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fmodule_options%2Fmodule_options_context.rs?ref=6254a987a6921b36f3f5d5ba7b20a8fd0fc12f97",
            "patch": "@@ -239,6 +239,9 @@ pub struct EcmascriptOptionsContext {\n     /// Specifies how Source Maps are handled.\n     pub source_maps: SourceMapsType,\n \n+    // TODO should this be a part of Environment instead?\n+    pub inline_helpers: bool,\n+\n     pub placeholder_for_future_extensions: (),\n }\n "
        }
    ],
    "stats": {
        "total": 1767,
        "additions": 1722,
        "deletions": 45
    }
}