{
    "author": "mischnic",
    "message": "Turbopack: refactor `evaluate` to take module_graph (#85971)\n\nFor some operations, we need the module graph (e.g. determining unused exports, and for the future inner graph tree shaking).\n\nPreviously, it was constructed inside of the evaluation machinery.",
    "sha": "87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22",
    "files": [
        {
            "sha": "14b262c28d2976fff68b3b0d60e8c3641167d129",
            "filename": "crates/next-core/src/next_font/google/mod.rs",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_font%2Fgoogle%2Fmod.rs?ref=87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22",
            "patch": "@@ -21,6 +21,7 @@ use turbopack_core::{\n     context::AssetContext,\n     ident::Layer,\n     issue::{IssueExt, IssueSeverity, StyledString},\n+    module_graph::ModuleGraph,\n     reference_type::{InnerAssets, ReferenceType},\n     resolve::{\n         ResolveResult,\n@@ -31,7 +32,9 @@ use turbopack_core::{\n     virtual_source::VirtualSource,\n };\n use turbopack_node::{\n-    debug::should_debug, evaluate::evaluate, execution_context::ExecutionContext,\n+    debug::should_debug,\n+    evaluate::{evaluate, get_evaluate_entries},\n+    execution_context::ExecutionContext,\n };\n \n use self::{\n@@ -752,15 +755,17 @@ async fn get_mock_stylesheet(\n         )\n         .module();\n \n+    let entries = get_evaluate_entries(mocked_response_asset, asset_context, None);\n+    let module_graph = ModuleGraph::from_modules(entries.graph_entries(), false);\n+\n     let root = mock_fs.root().owned().await?;\n     let val = evaluate(\n-        mocked_response_asset,\n+        entries,\n         root,\n         *env,\n         loader_source,\n-        asset_context,\n         *chunking_context,\n-        None,\n+        module_graph,\n         vec![],\n         Completion::immutable(),\n         should_debug(\"next_font::google\"),"
        },
        {
            "sha": "7d8aed4651ec1914b7dc4c89b8e15292f3225392",
            "filename": "turbopack/crates/turbopack-node/src/evaluate.rs",
            "status": "modified",
            "additions": 117,
            "deletions": 98,
            "changes": 215,
            "blob_url": "https://github.com/vercel/next.js/blob/87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Fevaluate.rs?ref=87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22",
            "patch": "@@ -18,12 +18,13 @@ use turbopack_core::{\n     context::AssetContext,\n     error::PrettyPrintError,\n     file_source::FileSource,\n+    ident::AssetIdent,\n     issue::{\n         Issue, IssueExt, IssueSource, IssueStage, OptionIssueSource, OptionStyledString,\n         StyledString,\n     },\n     module::Module,\n-    module_graph::{ModuleGraph, chunk_group_info::ChunkGroupEntry},\n+    module_graph::{GraphEntries, ModuleGraph, chunk_group_info::ChunkGroupEntry},\n     output::{OutputAsset, OutputAssets},\n     reference_type::{InnerAssets, ReferenceType},\n     source::Source,\n@@ -68,23 +69,16 @@ struct EmittedEvaluatePoolAssets {\n \n #[turbo_tasks::function(operation)]\n async fn emit_evaluate_pool_assets_operation(\n-    module_asset: ResolvedVc<Box<dyn Module>>,\n-    asset_context: ResolvedVc<Box<dyn AssetContext>>,\n+    entries: ResolvedVc<EvaluateEntries>,\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    runtime_entries: Option<ResolvedVc<EvaluatableAssets>>,\n+    module_graph: ResolvedVc<ModuleGraph>,\n ) -> Result<Vc<EmittedEvaluatePoolAssets>> {\n-    let runtime_asset = asset_context\n-        .process(\n-            Vc::upcast(FileSource::new(\n-                embed_file_path(rcstr!(\"ipc/evaluate.ts\")).owned().await?,\n-            )),\n-            ReferenceType::Internal(InnerAssets::empty().to_resolved().await?),\n-        )\n-        .module()\n-        .to_resolved()\n-        .await?;\n+    let EvaluateEntries {\n+        entries,\n+        main_entry_ident,\n+    } = &*entries.await?;\n \n-    let module_path = module_asset.ident().path().await?;\n+    let module_path = main_entry_ident.path().await?;\n     let file_name = module_path.file_name();\n     let file_name = if file_name.ends_with(\".js\") {\n         Cow::Borrowed(file_name)\n@@ -94,62 +88,11 @@ async fn emit_evaluate_pool_assets_operation(\n         Cow::Owned(format!(\"{file_name}.js\"))\n     };\n     let entrypoint = chunking_context.output_root().await?.join(&file_name)?;\n-    let entry_module = asset_context\n-        .process(\n-            Vc::upcast(VirtualSource::new(\n-                runtime_asset.ident().path().await?.join(\"evaluate.js\")?,\n-                AssetContent::file(\n-                    File::from(\"import { run } from 'RUNTIME'; run(() => import('INNER'))\").into(),\n-                ),\n-            )),\n-            ReferenceType::Internal(ResolvedVc::cell(fxindexmap! {\n-                rcstr!(\"INNER\") => module_asset,\n-                rcstr!(\"RUNTIME\") => runtime_asset\n-            })),\n-        )\n-        .module()\n-        .to_resolved()\n-        .await?;\n-\n-    let runtime_entries = {\n-        let globals_module = asset_context\n-            .process(\n-                Vc::upcast(FileSource::new(\n-                    embed_file_path(rcstr!(\"globals.ts\")).owned().await?,\n-                )),\n-                ReferenceType::Internal(InnerAssets::empty().to_resolved().await?),\n-            )\n-            .module();\n-\n-        let Some(globals_module) =\n-            Vc::try_resolve_sidecast::<Box<dyn EvaluatableAsset>>(globals_module).await?\n-        else {\n-            bail!(\"Internal module is not evaluatable\");\n-        };\n-\n-        let mut entries = vec![globals_module.to_resolved().await?];\n-        if let Some(runtime_entries) = runtime_entries {\n-            for &entry in &*runtime_entries.await? {\n-                entries.push(entry)\n-            }\n-        }\n-        entries\n-    };\n-\n-    let module_graph = ModuleGraph::from_modules(\n-        Vc::cell(vec![ChunkGroupEntry::Entry(\n-            iter::once(entry_module)\n-                .chain(runtime_entries.iter().copied().map(ResolvedVc::upcast))\n-                .collect(),\n-        )]),\n-        false,\n-    );\n \n     let bootstrap = chunking_context.root_entry_chunk_group_asset(\n         entrypoint.clone(),\n-        Vc::<EvaluatableAssets>::cell(runtime_entries)\n-            .with_entry(*ResolvedVc::try_downcast(entry_module).unwrap()),\n-        module_graph,\n+        Vc::cell(entries.clone()),\n+        *module_graph,\n         OutputAssets::empty(),\n         OutputAssets::empty(),\n     );\n@@ -178,17 +121,11 @@ struct EmittedEvaluatePoolAssetsWithEffects {\n \n #[turbo_tasks::function(operation)]\n async fn emit_evaluate_pool_assets_with_effects_operation(\n-    module_asset: ResolvedVc<Box<dyn Module>>,\n-    asset_context: ResolvedVc<Box<dyn AssetContext>>,\n+    entries: ResolvedVc<EvaluateEntries>,\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    runtime_entries: Option<ResolvedVc<EvaluatableAssets>>,\n+    module_graph: ResolvedVc<ModuleGraph>,\n ) -> Result<Vc<EmittedEvaluatePoolAssetsWithEffects>> {\n-    let operation = emit_evaluate_pool_assets_operation(\n-        module_asset,\n-        asset_context,\n-        chunking_context,\n-        runtime_entries,\n-    );\n+    let operation = emit_evaluate_pool_assets_operation(entries, chunking_context, module_graph);\n     let assets = operation.read_strongly_consistent().await?;\n     let effects = Arc::new(get_effects(operation).await?);\n     Ok(EmittedEvaluatePoolAssetsWithEffects { assets, effects }.cell())\n@@ -216,22 +153,17 @@ pub enum EnvVarTracking {\n /// Pass the file you cared as `runtime_entries` to invalidate and reload the\n /// evaluated result automatically.\n pub async fn get_evaluate_pool(\n-    module_asset: ResolvedVc<Box<dyn Module>>,\n+    entries: ResolvedVc<EvaluateEntries>,\n     cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n-    asset_context: ResolvedVc<Box<dyn AssetContext>>,\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    runtime_entries: Option<ResolvedVc<EvaluatableAssets>>,\n+    module_graph: ResolvedVc<ModuleGraph>,\n     additional_invalidation: ResolvedVc<Completion>,\n     debug: bool,\n     env_var_tracking: EnvVarTracking,\n ) -> Result<Vc<NodeJsPool>> {\n-    let operation = emit_evaluate_pool_assets_with_effects_operation(\n-        module_asset,\n-        asset_context,\n-        chunking_context,\n-        runtime_entries,\n-    );\n+    let operation =\n+        emit_evaluate_pool_assets_with_effects_operation(entries, chunking_context, module_graph);\n     let EmittedEvaluatePoolAssetsWithEffects { assets, effects } =\n         &*operation.read_strongly_consistent().await?;\n     effects.apply().await?;\n@@ -401,29 +333,118 @@ pub async fn custom_evaluate(evaluate_context: impl EvaluateContext) -> Result<V\n     Ok(Vc::cell(result.map(RcStr::from)))\n }\n \n+#[turbo_tasks::value]\n+pub struct EvaluateEntries {\n+    entries: Vec<ResolvedVc<Box<dyn EvaluatableAsset + 'static>>>,\n+    main_entry_ident: ResolvedVc<AssetIdent>,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl EvaluateEntries {\n+    #[turbo_tasks::function]\n+    pub async fn graph_entries(self: Vc<Self>) -> Result<Vc<GraphEntries>> {\n+        Ok(Vc::cell(vec![ChunkGroupEntry::Entry(\n+            self.await?\n+                .entries\n+                .iter()\n+                .cloned()\n+                .map(ResolvedVc::upcast)\n+                .collect(),\n+        )]))\n+    }\n+}\n+\n+#[turbo_tasks::function]\n+pub async fn get_evaluate_entries(\n+    module_asset: ResolvedVc<Box<dyn Module>>,\n+    asset_context: ResolvedVc<Box<dyn AssetContext>>,\n+    runtime_entries: Option<ResolvedVc<EvaluatableAssets>>,\n+) -> Result<Vc<EvaluateEntries>> {\n+    let runtime_asset = asset_context\n+        .process(\n+            Vc::upcast(FileSource::new(\n+                embed_file_path(rcstr!(\"ipc/evaluate.ts\")).owned().await?,\n+            )),\n+            ReferenceType::Internal(InnerAssets::empty().to_resolved().await?),\n+        )\n+        .module()\n+        .to_resolved()\n+        .await?;\n+\n+    let entry_module = asset_context\n+        .process(\n+            Vc::upcast(VirtualSource::new(\n+                runtime_asset.ident().path().await?.join(\"evaluate.js\")?,\n+                AssetContent::file(\n+                    File::from(\"import { run } from 'RUNTIME'; run(() => import('INNER'))\").into(),\n+                ),\n+            )),\n+            ReferenceType::Internal(ResolvedVc::cell(fxindexmap! {\n+                rcstr!(\"INNER\") => module_asset,\n+                rcstr!(\"RUNTIME\") => runtime_asset\n+            })),\n+        )\n+        .module()\n+        .to_resolved()\n+        .await?;\n+\n+    let runtime_entries = {\n+        let globals_module = asset_context\n+            .process(\n+                Vc::upcast(FileSource::new(\n+                    embed_file_path(rcstr!(\"globals.ts\")).owned().await?,\n+                )),\n+                ReferenceType::Internal(InnerAssets::empty().to_resolved().await?),\n+            )\n+            .module();\n+\n+        let Some(globals_module) =\n+            Vc::try_resolve_sidecast::<Box<dyn EvaluatableAsset>>(globals_module).await?\n+        else {\n+            bail!(\"Internal module is not evaluatable\");\n+        };\n+\n+        let mut entries = vec![globals_module.to_resolved().await?];\n+        if let Some(runtime_entries) = runtime_entries {\n+            for &entry in &*runtime_entries.await? {\n+                entries.push(entry)\n+            }\n+        }\n+        entries\n+    };\n+\n+    Ok(EvaluateEntries {\n+        entries: runtime_entries\n+            .iter()\n+            .copied()\n+            .chain(iter::once(ResolvedVc::try_downcast(entry_module).unwrap()))\n+            .collect(),\n+        main_entry_ident: module_asset.ident().to_resolved().await?,\n+    }\n+    .cell())\n+}\n+\n /// Pass the file you cared as `runtime_entries` to invalidate and reload the\n /// evaluated result automatically.\n #[turbo_tasks::function]\n pub async fn evaluate(\n-    module_asset: ResolvedVc<Box<dyn Module>>,\n+    entries: ResolvedVc<EvaluateEntries>,\n     cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n     context_source_for_issue: ResolvedVc<Box<dyn Source>>,\n-    asset_context: ResolvedVc<Box<dyn AssetContext>>,\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    runtime_entries: Option<ResolvedVc<EvaluatableAssets>>,\n+    module_graph: ResolvedVc<ModuleGraph>,\n     args: Vec<ResolvedVc<JsonValue>>,\n     additional_invalidation: ResolvedVc<Completion>,\n     debug: bool,\n ) -> Result<Vc<Option<RcStr>>> {\n     custom_evaluate(BasicEvaluateContext {\n-        module_asset,\n+        entries,\n         cwd,\n         env,\n         context_source_for_issue,\n-        asset_context,\n         chunking_context,\n-        runtime_entries,\n+        module_graph,\n         args,\n         additional_invalidation,\n         debug,\n@@ -487,13 +508,12 @@ async fn pull_operation<T: EvaluateContext>(\n \n #[derive(Clone, PartialEq, Eq, Hash, TaskInput, Debug, Serialize, Deserialize, TraceRawVcs)]\n struct BasicEvaluateContext {\n-    module_asset: ResolvedVc<Box<dyn Module>>,\n+    entries: ResolvedVc<EvaluateEntries>,\n     cwd: FileSystemPath,\n     env: ResolvedVc<Box<dyn ProcessEnv>>,\n     context_source_for_issue: ResolvedVc<Box<dyn Source>>,\n-    asset_context: ResolvedVc<Box<dyn AssetContext>>,\n     chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n-    runtime_entries: Option<ResolvedVc<EvaluatableAssets>>,\n+    module_graph: ResolvedVc<ModuleGraph>,\n     args: Vec<ResolvedVc<JsonValue>>,\n     additional_invalidation: ResolvedVc<Completion>,\n     debug: bool,\n@@ -507,12 +527,11 @@ impl EvaluateContext for BasicEvaluateContext {\n \n     fn pool(&self) -> OperationVc<crate::pool::NodeJsPool> {\n         get_evaluate_pool(\n-            self.module_asset,\n+            self.entries,\n             self.cwd.clone(),\n             self.env,\n-            self.asset_context,\n             self.chunking_context,\n-            self.runtime_entries,\n+            self.module_graph,\n             self.additional_invalidation,\n             self.debug,\n             EnvVarTracking::WholeEnvTracked,"
        },
        {
            "sha": "2092d7bb5e55d017ee547f187741d7241fce2283",
            "filename": "turbopack/crates/turbopack-node/src/transforms/postcss.rs",
            "status": "modified",
            "additions": 14,
            "deletions": 7,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fpostcss.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fpostcss.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fpostcss.rs?ref=87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22",
            "patch": "@@ -15,6 +15,7 @@ use turbopack_core::{\n     context::{AssetContext, ProcessResult},\n     file_source::FileSource,\n     ident::AssetIdent,\n+    module_graph::ModuleGraph,\n     reference_type::{EntryReferenceSubType, InnerAssets, ReferenceType},\n     resolve::{FindContextFileResult, find_context_file_or_package_key, options::ImportMapping},\n     source::Source,\n@@ -29,7 +30,7 @@ use super::{\n     webpack::WebpackLoaderContext,\n };\n use crate::{\n-    embed_js::embed_file_path, execution_context::ExecutionContext,\n+    embed_js::embed_file_path, evaluate::get_evaluate_entries, execution_context::ExecutionContext,\n     transforms::webpack::evaluate_webpack_loader,\n };\n \n@@ -485,10 +486,16 @@ impl PostCssTransformedAsset {\n             .await?;\n \n         let postcss_executor =\n-            postcss_executor(*evaluate_context, project_path.clone(), config_path)\n-                .module()\n-                .to_resolved()\n-                .await?;\n+            postcss_executor(*evaluate_context, project_path.clone(), config_path).module();\n+\n+        let entries = get_evaluate_entries(postcss_executor, *evaluate_context, None)\n+            .to_resolved()\n+            .await?;\n+\n+        let module_graph = ModuleGraph::from_modules(entries.graph_entries(), false)\n+            .to_resolved()\n+            .await?;\n+\n         let css_fs_path = self.source.ident().path();\n \n         // We need to get a path relative to the project because the postcss loader\n@@ -502,12 +509,12 @@ impl PostCssTransformedAsset {\n             };\n \n         let config_value = evaluate_webpack_loader(WebpackLoaderContext {\n-            module_asset: postcss_executor,\n+            entries,\n             cwd: project_path.clone(),\n             env: *env,\n             context_source_for_issue: self.source,\n-            asset_context: evaluate_context,\n             chunking_context: *chunking_context,\n+            module_graph,\n             resolve_options_context: None,\n             args: vec![\n                 ResolvedVc::cell(content.into()),"
        },
        {
            "sha": "899849fb155200cd11de26c81b0d116b37321188",
            "filename": "turbopack/crates/turbopack-node/src/transforms/webpack.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 11,
            "changes": 27,
            "blob_url": "https://github.com/vercel/next.js/blob/87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-node%2Fsrc%2Ftransforms%2Fwebpack.rs?ref=87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22",
            "patch": "@@ -29,7 +29,7 @@ use turbopack_core::{\n         Issue, IssueExt, IssueSeverity, IssueSource, IssueStage, OptionIssueSource,\n         OptionStyledString, StyledString,\n     },\n-    module::Module,\n+    module_graph::ModuleGraph,\n     reference_type::{InnerAssets, ReferenceType},\n     resolve::{\n         options::{ConditionValue, ResolveInPackage, ResolveIntoPackage, ResolveOptions},\n@@ -55,7 +55,8 @@ use crate::{\n     debug::should_debug,\n     embed_js::embed_file_path,\n     evaluate::{\n-        EnvVarTracking, EvaluateContext, EvaluationIssue, custom_evaluate, get_evaluate_pool,\n+        EnvVarTracking, EvaluateContext, EvaluateEntries, EvaluationIssue, custom_evaluate,\n+        get_evaluate_entries, get_evaluate_pool,\n     },\n     execution_context::ExecutionContext,\n     pool::{FormattingMode, NodeJsPool},\n@@ -240,8 +241,13 @@ impl WebpackLoadersProcessedAsset {\n         };\n         let evaluate_context = transform.evaluate_context;\n \n-        let webpack_loaders_executor = webpack_loaders_executor(*evaluate_context)\n-            .module()\n+        let webpack_loaders_executor = webpack_loaders_executor(*evaluate_context).module();\n+\n+        let entries = get_evaluate_entries(webpack_loaders_executor, *evaluate_context, None)\n+            .to_resolved()\n+            .await?;\n+\n+        let module_graph = ModuleGraph::from_modules(entries.graph_entries(), false)\n             .to_resolved()\n             .await?;\n \n@@ -254,12 +260,12 @@ impl WebpackLoadersProcessedAsset {\n         };\n         let loaders = transform.loaders.await?;\n         let config_value = evaluate_webpack_loader(WebpackLoaderContext {\n-            module_asset: webpack_loaders_executor,\n+            entries,\n             cwd: project_path.clone(),\n             env: *env,\n             context_source_for_issue: this.source,\n-            asset_context: evaluate_context,\n             chunking_context: *chunking_context,\n+            module_graph,\n             resolve_options_context: Some(transform.resolve_options_context),\n             args: vec![\n                 ResolvedVc::cell(content),\n@@ -410,11 +416,11 @@ pub enum ResponseMessage {\n \n #[derive(Clone, PartialEq, Eq, Hash, TaskInput, Serialize, Deserialize, Debug, TraceRawVcs)]\n pub struct WebpackLoaderContext {\n-    pub module_asset: ResolvedVc<Box<dyn Module>>,\n+    pub entries: ResolvedVc<EvaluateEntries>,\n     pub cwd: FileSystemPath,\n     pub env: ResolvedVc<Box<dyn ProcessEnv>>,\n     pub context_source_for_issue: ResolvedVc<Box<dyn Source>>,\n-    pub asset_context: ResolvedVc<Box<dyn AssetContext>>,\n+    pub module_graph: ResolvedVc<ModuleGraph>,\n     pub chunking_context: ResolvedVc<Box<dyn ChunkingContext>>,\n     pub resolve_options_context: Option<ResolvedVc<ResolveOptionsContext>>,\n     pub args: Vec<ResolvedVc<JsonValue>>,\n@@ -429,12 +435,11 @@ impl EvaluateContext for WebpackLoaderContext {\n \n     fn pool(&self) -> OperationVc<crate::pool::NodeJsPool> {\n         get_evaluate_pool(\n-            self.module_asset,\n+            self.entries,\n             self.cwd.clone(),\n             self.env,\n-            self.asset_context,\n             self.chunking_context,\n-            None,\n+            self.module_graph,\n             self.additional_invalidation,\n             should_debug(\"webpack_loader\"),\n             // Env vars are read untracked, since we want a more granular dependency on certain env"
        },
        {
            "sha": "713bde46fe8f823779babbd24e07d0a37b5ae028",
            "filename": "turbopack/crates/turbopack-tests/tests/execution.rs",
            "status": "modified",
            "additions": 10,
            "deletions": 14,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fexecution.rs?ref=87d865f6ff7c7397a3df4acb0fdf8a01ceda8a22",
            "patch": "@@ -39,17 +39,18 @@ use turbopack_core::{\n     file_source::FileSource,\n     ident::Layer,\n     issue::CollectibleIssuesExt,\n-    module_graph::{\n-        ModuleGraph, chunk_group_info::ChunkGroupEntry, export_usage::compute_export_usage_info,\n-    },\n+    module_graph::{ModuleGraph, export_usage::compute_export_usage_info},\n     reference_type::{InnerAssets, ReferenceType},\n     resolve::{\n         ExternalTraced, ExternalType,\n         options::{ImportMap, ImportMapping},\n     },\n };\n use turbopack_ecmascript_runtime::RuntimeType;\n-use turbopack_node::{debug::should_debug, evaluate::evaluate};\n+use turbopack_node::{\n+    debug::should_debug,\n+    evaluate::{evaluate, get_evaluate_entries},\n+};\n use turbopack_nodejs::NodeJsChunkingContext;\n use turbopack_resolve::resolve_options_context::ResolveOptionsContext;\n use turbopack_test_utils::{jest::JestRunResult, snapshot::UPDATE};\n@@ -462,13 +463,9 @@ async fn run_test_operation(prepared_test: ResolvedVc<PreparedTest>) -> Result<V\n         )\n         .module();\n \n-    // Keep this in sync with what `evaluate` does internally\n-    let module_graph = ModuleGraph::from_modules(\n-        Vc::cell(vec![ChunkGroupEntry::Entry(vec![\n-            jest_entry_asset.to_resolved().await?,\n-        ])]),\n-        false,\n-    );\n+    let entries = get_evaluate_entries(jest_entry_asset, asset_context, None);\n+\n+    let module_graph = ModuleGraph::from_modules(entries.graph_entries(), false);\n \n     let chunking_context = NodeJsChunkingContext::builder(\n         project_root.clone(),\n@@ -514,13 +511,12 @@ async fn run_test_operation(prepared_test: ResolvedVc<PreparedTest>) -> Result<V\n     .build();\n \n     let res = evaluate(\n-        jest_entry_asset,\n+        entries,\n         path.clone(),\n         Vc::upcast(CommandLineProcessEnv::new()),\n         Vc::upcast(test_source),\n-        asset_context,\n         Vc::upcast(chunking_context),\n-        None,\n+        module_graph,\n         vec![],\n         Completion::immutable(),\n         should_debug(\"execution_test\"),"
        }
    ],
    "stats": {
        "total": 300,
        "additions": 166,
        "deletions": 134
    }
}