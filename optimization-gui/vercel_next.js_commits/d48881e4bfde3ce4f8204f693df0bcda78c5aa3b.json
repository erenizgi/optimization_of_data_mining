{
    "author": "devjiwonchoi",
    "message": "test: split hot module reload HMR test into multiple files (#79067)\n\nSplit long-running hot module reload hmr test to parallelize and reduce\nCI time.\n\nPort of https://github.com/vercel/next.js/pull/73620, confirmed no new\nchanges.\nx-ref:\nhttps://github.com/vercel/next.js/commits/canary/test/development/basic/hmr/hot-module-reload.test.ts",
    "sha": "d48881e4bfde3ce4f8204f693df0bcda78c5aa3b",
    "files": [
        {
            "sha": "c95910722adaae57273b6418a589e93752e78408",
            "filename": "test/development/basic/hmr/hot-module-reload-no-base-path-no-asset-prefix.test.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/d48881e4bfde3ce4f8204f693df0bcda78c5aa3b/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload-no-base-path-no-asset-prefix.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d48881e4bfde3ce4f8204f693df0bcda78c5aa3b/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload-no-base-path-no-asset-prefix.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload-no-base-path-no-asset-prefix.test.ts?ref=d48881e4bfde3ce4f8204f693df0bcda78c5aa3b",
            "patch": "@@ -0,0 +1,7 @@\n+import { runHotModuleReloadHmrTest } from './run-hot-module-reload-hmr-test.util'\n+\n+const nextConfig = { basePath: '', assetPrefix: '' }\n+\n+describe(`HMR - Hot Module Reload, nextConfig: ${JSON.stringify(nextConfig)}`, () => {\n+  runHotModuleReloadHmrTest(nextConfig)\n+})"
        },
        {
            "sha": "ba8b39261e6b2ee3a1364d61922b67247eb08e39",
            "filename": "test/development/basic/hmr/hot-module-reload-no-base-path-yes-asset-prefix.test.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/d48881e4bfde3ce4f8204f693df0bcda78c5aa3b/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload-no-base-path-yes-asset-prefix.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d48881e4bfde3ce4f8204f693df0bcda78c5aa3b/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload-no-base-path-yes-asset-prefix.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload-no-base-path-yes-asset-prefix.test.ts?ref=d48881e4bfde3ce4f8204f693df0bcda78c5aa3b",
            "patch": "@@ -0,0 +1,7 @@\n+import { runHotModuleReloadHmrTest } from './run-hot-module-reload-hmr-test.util'\n+\n+const nextConfig = { basePath: '', assetPrefix: '/asset-prefix' }\n+\n+describe(`HMR - Hot Module Reload, nextConfig: ${JSON.stringify(nextConfig)}`, () => {\n+  runHotModuleReloadHmrTest(nextConfig)\n+})"
        },
        {
            "sha": "a178cf2d1b4aa3978309d8e12d7c841115294bc2",
            "filename": "test/development/basic/hmr/hot-module-reload-yes-base-path-no-asset-prefix.test.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/d48881e4bfde3ce4f8204f693df0bcda78c5aa3b/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload-yes-base-path-no-asset-prefix.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d48881e4bfde3ce4f8204f693df0bcda78c5aa3b/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload-yes-base-path-no-asset-prefix.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload-yes-base-path-no-asset-prefix.test.ts?ref=d48881e4bfde3ce4f8204f693df0bcda78c5aa3b",
            "patch": "@@ -0,0 +1,7 @@\n+import { runHotModuleReloadHmrTest } from './run-hot-module-reload-hmr-test.util'\n+\n+const nextConfig = { basePath: '/docs', assetPrefix: '' }\n+\n+describe(`HMR - Hot Module Reload, nextConfig: ${JSON.stringify(nextConfig)}`, () => {\n+  runHotModuleReloadHmrTest(nextConfig)\n+})"
        },
        {
            "sha": "d7a41f073b7d0926e354f21003aaa419015aa831",
            "filename": "test/development/basic/hmr/hot-module-reload-yes-base-path-yes-asset-prefix.test.ts",
            "status": "added",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/d48881e4bfde3ce4f8204f693df0bcda78c5aa3b/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload-yes-base-path-yes-asset-prefix.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d48881e4bfde3ce4f8204f693df0bcda78c5aa3b/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload-yes-base-path-yes-asset-prefix.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload-yes-base-path-yes-asset-prefix.test.ts?ref=d48881e4bfde3ce4f8204f693df0bcda78c5aa3b",
            "patch": "@@ -0,0 +1,7 @@\n+import { runHotModuleReloadHmrTest } from './run-hot-module-reload-hmr-test.util'\n+\n+const nextConfig = { basePath: '/docs', assetPrefix: '/asset-prefix' }\n+\n+describe(`HMR - Hot Module Reload, nextConfig: ${JSON.stringify(nextConfig)}`, () => {\n+  runHotModuleReloadHmrTest(nextConfig)\n+})"
        },
        {
            "sha": "1b284ea0d5c1e6295e26ec70a48eee57e45cb895",
            "filename": "test/development/basic/hmr/hot-module-reload.test.ts",
            "status": "removed",
            "additions": 0,
            "deletions": 282,
            "changes": 282,
            "blob_url": "https://github.com/vercel/next.js/blob/7ac4eae058ba76adbca53a92424c6796a322676d/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload.test.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/7ac4eae058ba76adbca53a92424c6796a322676d/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload.test.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fhmr%2Fhot-module-reload.test.ts?ref=7ac4eae058ba76adbca53a92424c6796a322676d",
            "patch": "@@ -1,282 +0,0 @@\n-import { join } from 'path'\n-import cheerio from 'cheerio'\n-import {\n-  getBrowserBodyText,\n-  renderViaHTTP,\n-  retry,\n-  waitFor,\n-} from 'next-test-utils'\n-import { nextTestSetup } from 'e2e-utils'\n-import type { NextConfig } from 'next'\n-\n-describe.each([\n-  { basePath: '', assetPrefix: '' },\n-  { basePath: '', assetPrefix: '/asset-prefix' },\n-  { basePath: '/docs', assetPrefix: '' },\n-  { basePath: '/docs', assetPrefix: '/asset-prefix' },\n-])(\n-  'HMR - Hot Module Reload, nextConfig: %o',\n-  (nextConfig: Partial<NextConfig>) => {\n-    const { next } = nextTestSetup({\n-      files: __dirname,\n-      nextConfig,\n-      patchFileDelay: 500,\n-    })\n-    const { basePath } = nextConfig\n-\n-    describe('delete a page and add it back', () => {\n-      it('should load the page properly', async () => {\n-        const contactPagePath = join('pages', 'hmr', 'contact.js')\n-        const newContactPagePath = join('pages', 'hmr', '_contact.js')\n-        const browser = await next.browser(basePath + '/hmr/contact')\n-        try {\n-          const text = await browser.elementByCss('p').text()\n-          expect(text).toBe('This is the contact page.')\n-\n-          // Rename the file to mimic a deleted page\n-          await next.renameFile(contactPagePath, newContactPagePath)\n-\n-          await retry(async () => {\n-            expect(await getBrowserBodyText(browser)).toMatch(\n-              /This page could not be found/\n-            )\n-          })\n-\n-          // Rename the file back to the original filename\n-          await next.renameFile(newContactPagePath, contactPagePath)\n-\n-          // wait until the page comes back\n-          await retry(async () => {\n-            expect(await getBrowserBodyText(browser)).toMatch(\n-              /This is the contact page/\n-            )\n-          })\n-\n-          expect(next.cliOutput).toContain('Compiled /_error')\n-        } finally {\n-          await next\n-            .renameFile(newContactPagePath, contactPagePath)\n-            .catch(() => {})\n-        }\n-      })\n-    })\n-\n-    describe('editing a page', () => {\n-      it('should detect the changes and display it', async () => {\n-        const browser = await next.browser(basePath + '/hmr/about')\n-        const text = await browser.elementByCss('p').text()\n-        expect(text).toBe('This is the about page.')\n-\n-        const aboutPagePath = join('pages', 'hmr', 'about.js')\n-\n-        const originalContent = await next.readFile(aboutPagePath)\n-        const editedContent = originalContent.replace(\n-          'This is the about page',\n-          'COOL page'\n-        )\n-\n-        // change the content\n-        try {\n-          await next.patchFile(aboutPagePath, editedContent)\n-          await retry(async () => {\n-            expect(await getBrowserBodyText(browser)).toMatch(/COOL page/)\n-          })\n-        } finally {\n-          // add the original content\n-          await next.patchFile(aboutPagePath, originalContent)\n-        }\n-\n-        await retry(async () => {\n-          expect(await getBrowserBodyText(browser)).toMatch(\n-            /This is the about page/\n-          )\n-        })\n-      })\n-\n-      it('should not reload unrelated pages', async () => {\n-        const browser = await next.browser(basePath + '/hmr/counter')\n-        const text = await browser\n-          .elementByCss('button')\n-          .click()\n-          .elementByCss('button')\n-          .click()\n-          .elementByCss('p')\n-          .text()\n-        expect(text).toBe('COUNT: 2')\n-\n-        const aboutPagePath = join('pages', 'hmr', 'about.js')\n-\n-        const originalContent = await next.readFile(aboutPagePath)\n-        const editedContent = originalContent.replace(\n-          'This is the about page',\n-          'COOL page'\n-        )\n-\n-        try {\n-          // Change the about.js page\n-          await next.patchFile(aboutPagePath, editedContent)\n-\n-          // Check whether the this page has reloaded or not.\n-          await retry(async () => {\n-            expect(await browser.elementByCss('p').text()).toMatch(/COUNT: 2/)\n-          })\n-        } finally {\n-          // restore the about page content.\n-          await next.patchFile(aboutPagePath, originalContent)\n-        }\n-      })\n-\n-      // Added because of a regression in react-hot-loader, see issues: #4246 #4273\n-      // Also: https://github.com/vercel/styled-jsx/issues/425\n-      it('should update styles correctly', async () => {\n-        const browser = await next.browser(basePath + '/hmr/style')\n-        const pTag = await browser.elementByCss('.hmr-style-page p')\n-        const initialFontSize = await pTag.getComputedCss('font-size')\n-\n-        expect(initialFontSize).toBe('100px')\n-\n-        const pagePath = join('pages', 'hmr', 'style.js')\n-\n-        const originalContent = await next.readFile(pagePath)\n-        const editedContent = originalContent.replace('100px', '200px')\n-\n-        // Change the page\n-        await next.patchFile(pagePath, editedContent)\n-\n-        try {\n-          // Check whether the this page has reloaded or not.\n-          await retry(async () => {\n-            const editedPTag = await browser.elementByCss('.hmr-style-page p')\n-            expect(await editedPTag.getComputedCss('font-size')).toBe('200px')\n-          })\n-        } finally {\n-          // Finally is used so that we revert the content back to the original regardless of the test outcome\n-          // restore the about page content.\n-          await next.patchFile(pagePath, originalContent)\n-        }\n-      })\n-\n-      // Added because of a regression in react-hot-loader, see issues: #4246 #4273\n-      // Also: https://github.com/vercel/styled-jsx/issues/425\n-      it('should update styles in a stateful component correctly', async () => {\n-        const browser = await next.browser(\n-          basePath + '/hmr/style-stateful-component'\n-        )\n-        const pagePath = join('pages', 'hmr', 'style-stateful-component.js')\n-        const originalContent = await next.readFile(pagePath)\n-        try {\n-          const pTag = await browser.elementByCss('.hmr-style-page p')\n-          const initialFontSize = await pTag.getComputedCss('font-size')\n-\n-          expect(initialFontSize).toBe('100px')\n-          const editedContent = originalContent.replace('100px', '200px')\n-\n-          // Change the page\n-          await next.patchFile(pagePath, editedContent)\n-\n-          // Check whether the this page has reloaded or not.\n-          await retry(async () => {\n-            const editedPTag = await browser.elementByCss('.hmr-style-page p')\n-            expect(await editedPTag.getComputedCss('font-size')).toBe('200px')\n-          })\n-        } finally {\n-          await next.patchFile(pagePath, originalContent)\n-        }\n-      })\n-\n-      // Added because of a regression in react-hot-loader, see issues: #4246 #4273\n-      // Also: https://github.com/vercel/styled-jsx/issues/425\n-      it('should update styles in a dynamic component correctly', async () => {\n-        const browser = await next.browser(\n-          basePath + '/hmr/style-dynamic-component'\n-        )\n-        const secondBrowser = await next.browser(\n-          basePath + '/hmr/style-dynamic-component'\n-        )\n-        const pagePath = join('components', 'hmr', 'dynamic.js')\n-        const originalContent = await next.readFile(pagePath)\n-        try {\n-          const div = await browser.elementByCss('#dynamic-component')\n-          const initialClientClassName = await div.getAttribute('class')\n-          const initialFontSize = await div.getComputedCss('font-size')\n-\n-          expect(initialFontSize).toBe('100px')\n-\n-          const initialHtml = await renderViaHTTP(\n-            next.url,\n-            basePath + '/hmr/style-dynamic-component'\n-          )\n-          expect(initialHtml.includes('100px')).toBeTruthy()\n-\n-          const $initialHtml = cheerio.load(initialHtml)\n-          const initialServerClassName =\n-            $initialHtml('#dynamic-component').attr('class')\n-\n-          expect(initialClientClassName === initialServerClassName).toBeTruthy()\n-\n-          const editedContent = originalContent.replace('100px', '200px')\n-\n-          // Change the page\n-          await next.patchFile(pagePath, editedContent)\n-\n-          // wait for 5 seconds\n-          await waitFor(5000)\n-\n-          // Check whether the this page has reloaded or not.\n-          const editedDiv =\n-            await secondBrowser.elementByCss('#dynamic-component')\n-          const editedClientClassName = await editedDiv.getAttribute('class')\n-          const editedFontSize = await editedDiv.getComputedCss('font-size')\n-          const browserHtml = await secondBrowser.eval(\n-            'document.documentElement.innerHTML'\n-          )\n-\n-          expect(editedFontSize).toBe('200px')\n-          expect(browserHtml.includes('font-size:200px')).toBe(true)\n-          expect(browserHtml.includes('font-size:100px')).toBe(false)\n-\n-          const editedHtml = await renderViaHTTP(\n-            next.url,\n-            basePath + '/hmr/style-dynamic-component'\n-          )\n-          expect(editedHtml.includes('200px')).toBeTruthy()\n-          const $editedHtml = cheerio.load(editedHtml)\n-          const editedServerClassName =\n-            $editedHtml('#dynamic-component').attr('class')\n-\n-          expect(editedClientClassName === editedServerClassName).toBe(true)\n-        } finally {\n-          // Finally is used so that we revert the content back to the original regardless of the test outcome\n-          // restore the about page content.\n-          await next.patchFile(pagePath, originalContent)\n-        }\n-      })\n-\n-      it('should not full reload when nonlatin characters are used', async () => {\n-        const browser = await next.browser(basePath + '/hmr/nonlatin')\n-        const pagePath = join('pages', 'hmr', 'nonlatin.js')\n-        const originalContent = await next.readFile(pagePath)\n-        try {\n-          const timeOrigin = await browser.eval('performance.timeOrigin')\n-          const editedContent = originalContent.replace(\n-            '<div>テスト</div>',\n-            '<div class=\"updated\">テスト</div>'\n-          )\n-\n-          // Change the page\n-          await next.patchFile(pagePath, editedContent)\n-\n-          await browser.waitForElementByCss('.updated')\n-\n-          expect(await browser.eval('performance.timeOrigin')).toEqual(\n-            timeOrigin\n-          )\n-        } finally {\n-          // Finally is used so that we revert the content back to the original regardless of the test outcome\n-          // restore the about page content.\n-          await next.patchFile(pagePath, originalContent)\n-        }\n-      })\n-    })\n-  }\n-)"
        },
        {
            "sha": "aa95c3fd0990a2c54188ad900c42ec3f2e67f262",
            "filename": "test/development/basic/hmr/run-hot-module-reload-hmr-test.util.ts",
            "status": "added",
            "additions": 273,
            "deletions": 0,
            "changes": 273,
            "blob_url": "https://github.com/vercel/next.js/blob/d48881e4bfde3ce4f8204f693df0bcda78c5aa3b/test%2Fdevelopment%2Fbasic%2Fhmr%2Frun-hot-module-reload-hmr-test.util.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/d48881e4bfde3ce4f8204f693df0bcda78c5aa3b/test%2Fdevelopment%2Fbasic%2Fhmr%2Frun-hot-module-reload-hmr-test.util.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/test%2Fdevelopment%2Fbasic%2Fhmr%2Frun-hot-module-reload-hmr-test.util.ts?ref=d48881e4bfde3ce4f8204f693df0bcda78c5aa3b",
            "patch": "@@ -0,0 +1,273 @@\n+import { join } from 'path'\n+import cheerio from 'cheerio'\n+import {\n+  getBrowserBodyText,\n+  renderViaHTTP,\n+  retry,\n+  waitFor,\n+} from 'next-test-utils'\n+import { nextTestSetup } from 'e2e-utils'\n+\n+export function runHotModuleReloadHmrTest(nextConfig: {\n+  basePath: string\n+  assetPrefix: string\n+}) {\n+  const { next } = nextTestSetup({\n+    files: __dirname,\n+    nextConfig,\n+    patchFileDelay: 500,\n+  })\n+  const { basePath } = nextConfig\n+\n+  describe('delete a page and add it back', () => {\n+    it('should load the page properly', async () => {\n+      const contactPagePath = join('pages', 'hmr', 'contact.js')\n+      const newContactPagePath = join('pages', 'hmr', '_contact.js')\n+      const browser = await next.browser(basePath + '/hmr/contact')\n+      try {\n+        const text = await browser.elementByCss('p').text()\n+        expect(text).toBe('This is the contact page.')\n+\n+        // Rename the file to mimic a deleted page\n+        await next.renameFile(contactPagePath, newContactPagePath)\n+\n+        await retry(async () => {\n+          expect(await getBrowserBodyText(browser)).toMatch(\n+            /This page could not be found/\n+          )\n+        })\n+\n+        // Rename the file back to the original filename\n+        await next.renameFile(newContactPagePath, contactPagePath)\n+\n+        // wait until the page comes back\n+        await retry(async () => {\n+          expect(await getBrowserBodyText(browser)).toMatch(\n+            /This is the contact page/\n+          )\n+        })\n+\n+        expect(next.cliOutput).toContain('Compiled /_error')\n+      } finally {\n+        await next\n+          .renameFile(newContactPagePath, contactPagePath)\n+          .catch(() => {})\n+      }\n+    })\n+  })\n+\n+  describe('editing a page', () => {\n+    it('should detect the changes and display it', async () => {\n+      const browser = await next.browser(basePath + '/hmr/about')\n+      const text = await browser.elementByCss('p').text()\n+      expect(text).toBe('This is the about page.')\n+\n+      const aboutPagePath = join('pages', 'hmr', 'about.js')\n+\n+      const originalContent = await next.readFile(aboutPagePath)\n+      const editedContent = originalContent.replace(\n+        'This is the about page',\n+        'COOL page'\n+      )\n+\n+      // change the content\n+      try {\n+        await next.patchFile(aboutPagePath, editedContent)\n+        await retry(async () => {\n+          expect(await getBrowserBodyText(browser)).toMatch(/COOL page/)\n+        })\n+      } finally {\n+        // add the original content\n+        await next.patchFile(aboutPagePath, originalContent)\n+      }\n+\n+      await retry(async () => {\n+        expect(await getBrowserBodyText(browser)).toMatch(\n+          /This is the about page/\n+        )\n+      })\n+    })\n+\n+    it('should not reload unrelated pages', async () => {\n+      const browser = await next.browser(basePath + '/hmr/counter')\n+      const text = await browser\n+        .elementByCss('button')\n+        .click()\n+        .elementByCss('button')\n+        .click()\n+        .elementByCss('p')\n+        .text()\n+      expect(text).toBe('COUNT: 2')\n+\n+      const aboutPagePath = join('pages', 'hmr', 'about.js')\n+\n+      const originalContent = await next.readFile(aboutPagePath)\n+      const editedContent = originalContent.replace(\n+        'This is the about page',\n+        'COOL page'\n+      )\n+\n+      try {\n+        // Change the about.js page\n+        await next.patchFile(aboutPagePath, editedContent)\n+\n+        // Check whether the this page has reloaded or not.\n+        await retry(async () => {\n+          expect(await browser.elementByCss('p').text()).toMatch(/COUNT: 2/)\n+        })\n+      } finally {\n+        // restore the about page content.\n+        await next.patchFile(aboutPagePath, originalContent)\n+      }\n+    })\n+\n+    // Added because of a regression in react-hot-loader, see issues: #4246 #4273\n+    // Also: https://github.com/vercel/styled-jsx/issues/425\n+    it('should update styles correctly', async () => {\n+      const browser = await next.browser(basePath + '/hmr/style')\n+      const pTag = await browser.elementByCss('.hmr-style-page p')\n+      const initialFontSize = await pTag.getComputedCss('font-size')\n+\n+      expect(initialFontSize).toBe('100px')\n+\n+      const pagePath = join('pages', 'hmr', 'style.js')\n+\n+      const originalContent = await next.readFile(pagePath)\n+      const editedContent = originalContent.replace('100px', '200px')\n+\n+      // Change the page\n+      await next.patchFile(pagePath, editedContent)\n+\n+      try {\n+        // Check whether the this page has reloaded or not.\n+        await retry(async () => {\n+          const editedPTag = await browser.elementByCss('.hmr-style-page p')\n+          expect(await editedPTag.getComputedCss('font-size')).toBe('200px')\n+        })\n+      } finally {\n+        // Finally is used so that we revert the content back to the original regardless of the test outcome\n+        // restore the about page content.\n+        await next.patchFile(pagePath, originalContent)\n+      }\n+    })\n+\n+    // Added because of a regression in react-hot-loader, see issues: #4246 #4273\n+    // Also: https://github.com/vercel/styled-jsx/issues/425\n+    it('should update styles in a stateful component correctly', async () => {\n+      const browser = await next.browser(\n+        basePath + '/hmr/style-stateful-component'\n+      )\n+      const pagePath = join('pages', 'hmr', 'style-stateful-component.js')\n+      const originalContent = await next.readFile(pagePath)\n+      try {\n+        const pTag = await browser.elementByCss('.hmr-style-page p')\n+        const initialFontSize = await pTag.getComputedCss('font-size')\n+\n+        expect(initialFontSize).toBe('100px')\n+        const editedContent = originalContent.replace('100px', '200px')\n+\n+        // Change the page\n+        await next.patchFile(pagePath, editedContent)\n+\n+        // Check whether the this page has reloaded or not.\n+        await retry(async () => {\n+          const editedPTag = await browser.elementByCss('.hmr-style-page p')\n+          expect(await editedPTag.getComputedCss('font-size')).toBe('200px')\n+        })\n+      } finally {\n+        await next.patchFile(pagePath, originalContent)\n+      }\n+    })\n+\n+    // Added because of a regression in react-hot-loader, see issues: #4246 #4273\n+    // Also: https://github.com/vercel/styled-jsx/issues/425\n+    it('should update styles in a dynamic component correctly', async () => {\n+      const browser = await next.browser(\n+        basePath + '/hmr/style-dynamic-component'\n+      )\n+      const secondBrowser = await next.browser(\n+        basePath + '/hmr/style-dynamic-component'\n+      )\n+      const pagePath = join('components', 'hmr', 'dynamic.js')\n+      const originalContent = await next.readFile(pagePath)\n+      try {\n+        const div = await browser.elementByCss('#dynamic-component')\n+        const initialClientClassName = await div.getAttribute('class')\n+        const initialFontSize = await div.getComputedCss('font-size')\n+\n+        expect(initialFontSize).toBe('100px')\n+\n+        const initialHtml = await renderViaHTTP(\n+          next.url,\n+          basePath + '/hmr/style-dynamic-component'\n+        )\n+        expect(initialHtml.includes('100px')).toBeTruthy()\n+\n+        const $initialHtml = cheerio.load(initialHtml)\n+        const initialServerClassName =\n+          $initialHtml('#dynamic-component').attr('class')\n+\n+        expect(initialClientClassName === initialServerClassName).toBeTruthy()\n+\n+        const editedContent = originalContent.replace('100px', '200px')\n+\n+        // Change the page\n+        await next.patchFile(pagePath, editedContent)\n+\n+        // wait for 5 seconds\n+        await waitFor(5000)\n+\n+        // Check whether the this page has reloaded or not.\n+        const editedDiv = await secondBrowser.elementByCss('#dynamic-component')\n+        const editedClientClassName = await editedDiv.getAttribute('class')\n+        const editedFontSize = await editedDiv.getComputedCss('font-size')\n+        const browserHtml = await secondBrowser.eval(\n+          'document.documentElement.innerHTML'\n+        )\n+\n+        expect(editedFontSize).toBe('200px')\n+        expect(browserHtml.includes('font-size:200px')).toBe(true)\n+        expect(browserHtml.includes('font-size:100px')).toBe(false)\n+\n+        const editedHtml = await renderViaHTTP(\n+          next.url,\n+          basePath + '/hmr/style-dynamic-component'\n+        )\n+        expect(editedHtml.includes('200px')).toBeTruthy()\n+        const $editedHtml = cheerio.load(editedHtml)\n+        const editedServerClassName =\n+          $editedHtml('#dynamic-component').attr('class')\n+\n+        expect(editedClientClassName === editedServerClassName).toBe(true)\n+      } finally {\n+        // Finally is used so that we revert the content back to the original regardless of the test outcome\n+        // restore the about page content.\n+        await next.patchFile(pagePath, originalContent)\n+      }\n+    })\n+\n+    it('should not full reload when nonlatin characters are used', async () => {\n+      const browser = await next.browser(basePath + '/hmr/nonlatin')\n+      const pagePath = join('pages', 'hmr', 'nonlatin.js')\n+      const originalContent = await next.readFile(pagePath)\n+      try {\n+        const timeOrigin = await browser.eval('performance.timeOrigin')\n+        const editedContent = originalContent.replace(\n+          '<div>テスト</div>',\n+          '<div class=\"updated\">テスト</div>'\n+        )\n+\n+        // Change the page\n+        await next.patchFile(pagePath, editedContent)\n+\n+        await browser.waitForElementByCss('.updated')\n+\n+        expect(await browser.eval('performance.timeOrigin')).toEqual(timeOrigin)\n+      } finally {\n+        // Finally is used so that we revert the content back to the original regardless of the test outcome\n+        // restore the about page content.\n+        await next.patchFile(pagePath, originalContent)\n+      }\n+    })\n+  })\n+}"
        }
    ],
    "stats": {
        "total": 583,
        "additions": 301,
        "deletions": 282
    }
}