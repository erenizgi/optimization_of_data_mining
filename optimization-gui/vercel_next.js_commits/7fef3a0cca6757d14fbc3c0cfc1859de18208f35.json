{
    "author": "icyJoseph",
    "message": "docs: fresh up getting started 00 (#85736)",
    "sha": "7fef3a0cca6757d14fbc3c0cfc1859de18208f35",
    "files": [
        {
            "sha": "69eb8a8f369c7b32e43eb7f24f99968c660e8c68",
            "filename": "docs/01-app/01-getting-started/09-caching-and-revalidating.mdx",
            "status": "modified",
            "additions": 163,
            "deletions": 149,
            "changes": 312,
            "blob_url": "https://github.com/vercel/next.js/blob/7fef3a0cca6757d14fbc3c0cfc1859de18208f35/docs%2F01-app%2F01-getting-started%2F09-caching-and-revalidating.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/7fef3a0cca6757d14fbc3c0cfc1859de18208f35/docs%2F01-app%2F01-getting-started%2F09-caching-and-revalidating.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F09-caching-and-revalidating.mdx?ref=7fef3a0cca6757d14fbc3c0cfc1859de18208f35",
            "patch": "@@ -6,21 +6,23 @@ related:\n   description: Learn more about the features mentioned in this page by reading the API Reference.\n   links:\n     - app/api-reference/functions/fetch\n-    - app/api-reference/functions/unstable_cache\n-    - app/api-reference/functions/revalidatePath\n+    - app/api-reference/functions/cacheTag\n     - app/api-reference/functions/revalidateTag\n     - app/api-reference/functions/updateTag\n+    - app/api-reference/functions/revalidatePath\n+    - app/api-reference/functions/unstable_cache\n ---\n \n Caching is a technique for storing the result of data fetching and other computations so that future requests for the same data can be served faster, without doing the work again. While revalidation allows you to update cache entries without having to rebuild your entire application.\n \n Next.js provides a few APIs to handle caching and revalidation. This guide will walk you through when and how to use them.\n \n - [`fetch`](#fetch)\n-- [`unstable_cache`](#unstable_cache)\n-- [`revalidatePath`](#revalidatepath)\n+- [`cacheTag`](#cachetag)\n - [`revalidateTag`](#revalidatetag)\n - [`updateTag`](#updatetag)\n+- [`revalidatePath`](#revalidatepath)\n+- [`unstable_cache`](#unstable_cache) (Legacy)\n \n ## `fetch`\n \n@@ -56,103 +58,65 @@ export default async function Page() {\n \n This will revalidate the data after a specified amount of seconds.\n \n-See the [`fetch` API reference](/docs/app/api-reference/functions/fetch) to learn more.\n-\n-## `unstable_cache`\n+You can also tag `fetch` requests to enable on-demand cache invalidation:\n \n-`unstable_cache` allows you to cache the result of database queries and other async functions. To use it, wrap `unstable_cache` around the function. For example:\n-\n-```ts filename=\"app/lib/data.ts\" switcher\n-import { db } from '@/lib/db'\n+```tsx filename=\"app/lib/data.ts\" switcher\n export async function getUserById(id: string) {\n-  return db\n-    .select()\n-    .from(users)\n-    .where(eq(users.id, id))\n-    .then((res) => res[0])\n+  const data = await fetch(`https://...`, {\n+    next: {\n+      tags: ['user'],\n+    },\n+  })\n }\n ```\n \n ```jsx filename=\"app/lib/data.js\" switcher\n-import { db } from '@/lib/db'\n-\n export async function getUserById(id) {\n-  return db\n-    .select()\n-    .from(users)\n-    .where(eq(users.id, id))\n-    .then((res) => res[0])\n+  const data = await fetch(`https://...`, {\n+    next: {\n+      tags: ['user'],\n+    },\n+  })\n }\n ```\n \n-```tsx filename=\"app/page.tsx\" highlight={2,11,13} switcher\n-import { unstable_cache } from 'next/cache'\n-import { getUserById } from '@/app/lib/data'\n+See the [`fetch` API reference](/docs/app/api-reference/functions/fetch) to learn more.\n \n-export default async function Page({\n-  params,\n-}: {\n-  params: Promise<{ userId: string }>\n-}) {\n-  const { userId } = await params\n+## `cacheTag`\n \n-  const getCachedUser = unstable_cache(\n-    async () => {\n-      return getUserById(userId)\n-    },\n-    [userId] // add the user ID to the cache key\n-  )\n-}\n-```\n+[`cacheTag`](/docs/app/api-reference/functions/cacheTag) allows you to tag cached data in [Cache Components](/docs/app/getting-started/cache-components) so it can be revalidated on-demand. Previously, cache tagging was limited to `fetch` requests, and caching other work required the experimental `unstable_cache` API.\n \n-```jsx filename=\"app/page.js\" highlight={2,7,9} switcher\n-import { unstable_cache } from 'next/cache'\n-import { getUserById } from '@/app/lib/data'\n+With Cache Components, you can use the [`use cache`](/docs/app/api-reference/directives/use-cache) directive to cache any computation, and `cacheTag` to tag it. This works with database queries, file system operations, and other server-side work.\n \n-export default async function Page({ params }) {\n-  const { userId } = await params\n+```tsx filename=\"app/lib/data.ts\" switcher\n+import { cacheTag } from 'next/cache'\n \n-  const getCachedUser = unstable_cache(\n-    async () => {\n-      return getUserById(userId)\n-    },\n-    [userId] // add the user ID to the cache key\n-  )\n+export async function getProducts() {\n+  'use cache'\n+  cacheTag('products')\n+\n+  const products = await db.query('SELECT * FROM products')\n+  return products\n }\n ```\n \n-The function accepts a third optional object to define how the cache should be revalidated. It accepts:\n+```jsx filename=\"app/lib/data.js\" switcher\n+import { cacheTag } from 'next/cache'\n \n-- `tags`: an array of tags used by Next.js to revalidate the cache.\n-- `revalidate`: the number of seconds after cache should be revalidated.\n+export async function getProducts() {\n+  'use cache'\n+  cacheTag('products')\n \n-```tsx filename=\"app/page.tsx\" highlight={6-9} switcher\n-const getCachedUser = unstable_cache(\n-  async () => {\n-    return getUserById(userId)\n-  },\n-  [userId],\n-  {\n-    tags: ['user'],\n-    revalidate: 3600,\n-  }\n-)\n+  const products = await db.query('SELECT * FROM products')\n+  return products\n+}\n ```\n \n-```jsx filename=\"app/page.js\" highlight={6-9} switcher\n-const getCachedUser = unstable_cache(\n-  async () => {\n-    return getUserById(userId)\n-  },\n-  [userId],\n-  {\n-    tags: ['user'],\n-    revalidate: 3600,\n-  }\n-)\n-```\n+Once tagged, you can use [`revalidateTag`](#revalidatetag) or [`updateTag`](#updatetag) to invalidate the cache entry for products.\n \n-See the [`unstable_cache` API reference](/docs/app/api-reference/functions/unstable_cache) to learn more.\n+> **Good to know**: `cacheTag` is used with [Cache Components](/docs/app/getting-started/cache-components) and the [`use cache`](/docs/app/api-reference/directives/use-cache) directive. It expands the caching and revalidation story beyond `fetch`.\n+\n+See the [`cacheTag` API reference](/docs/app/api-reference/functions/cacheTag) to learn more.\n \n ## `revalidateTag`\n \n@@ -161,55 +125,7 @@ See the [`unstable_cache` API reference](/docs/app/api-reference/functions/unsta\n - **With `profile=\"max\"`**: Uses stale-while-revalidate semantics, serving stale content while fetching fresh content in the background\n - **Without the second argument**: Legacy behavior that immediately expires the cache (deprecated)\n \n-To use it with `fetch`, start by tagging the function with the `next.tags` option:\n-\n-```tsx filename=\"app/lib/data.ts\" highlight={3-5} switcher\n-export async function getUserById(id: string) {\n-  const data = await fetch(`https://...`, {\n-    next: {\n-      tags: ['user'],\n-    },\n-  })\n-}\n-```\n-\n-```jsx filename=\"app/lib/data.js\" highlight={3-5} switcher\n-export async function getUserById(id) {\n-  const data = await fetch(`https://...`, {\n-    next: {\n-      tags: ['user'],\n-    },\n-  })\n-}\n-```\n-\n-Alternatively, you can mark an `unstable_cache` function with the `tags` option:\n-\n-```tsx filename=\"app/lib/data.ts\" highlight={6-8} switcher\n-export const getUserById = unstable_cache(\n-  async (id: string) => {\n-    return db.query.users.findFirst({ where: eq(users.id, id) })\n-  },\n-  ['user'], // Needed if variables are not passed as parameters\n-  {\n-    tags: ['user'],\n-  }\n-)\n-```\n-\n-```jsx filename=\"app/lib/data.js\" highlight={6-8} switcher\n-export const getUserById = unstable_cache(\n-  async (id) => {\n-    return db.query.users.findFirst({ where: eq(users.id, id) })\n-  },\n-  ['user'], // Needed if variables are not passed as parameters\n-  {\n-    tags: ['user'],\n-  }\n-)\n-```\n-\n-Then, call `revalidateTag` in a [Route Handler](/docs/app/api-reference/file-conventions/route) or Server Action:\n+After tagging your cached data, using [`fetch`](#fetch) with `next.tags`, or the [`cacheTag`](#cachetag) function, you may call `revalidateTag` in a [Route Handler](/docs/app/api-reference/file-conventions/route) or Server Action:\n \n ```tsx filename=\"app/lib/actions.ts\" highlight={1,5} switcher\n import { revalidateTag } from 'next/cache'\n@@ -233,28 +149,6 @@ You can reuse the same tag in multiple functions to revalidate them all at once.\n \n See the [`revalidateTag` API reference](/docs/app/api-reference/functions/revalidateTag) to learn more.\n \n-## `revalidatePath`\n-\n-`revalidatePath` is used to revalidate a route and following an event. To use it, call it in a [Route Handler](/docs/app/api-reference/file-conventions/route) or Server Action:\n-\n-```tsx filename=\"app/lib/actions.ts\" highlight={1} switcher\n-import { revalidatePath } from 'next/cache'\n-\n-export async function updateUser(id: string) {\n-  // Mutate data\n-  revalidatePath('/profile')\n-```\n-\n-```jsx filename=\"app/lib/actions.js\" highlight={1} switcher\n-import { revalidatePath } from 'next/cache'\n-\n-export async function updateUser(id) {\n-  // Mutate data\n-  revalidatePath('/profile')\n-```\n-\n-See the [`revalidatePath` API reference](/docs/app/api-reference/functions/revalidatePath) to learn more.\n-\n ## `updateTag`\n \n `updateTag` is specifically designed for Server Actions to immediately expire cached data for read-your-own-writes scenarios. Unlike `revalidateTag`, it can only be used within Server Actions and immediately expires the cache entry.\n@@ -307,3 +201,123 @@ The key differences between `revalidateTag` and `updateTag`:\n - **`revalidateTag`**: In Server Actions and Route Handlers, supports stale-while-revalidate with `profile=\"max\"`\n \n See the [`updateTag` API reference](/docs/app/api-reference/functions/updateTag) to learn more.\n+\n+## `revalidatePath`\n+\n+`revalidatePath` is used to revalidate a route and following an event. To use it, call it in a [Route Handler](/docs/app/api-reference/file-conventions/route) or Server Action:\n+\n+```tsx filename=\"app/lib/actions.ts\" highlight={1} switcher\n+import { revalidatePath } from 'next/cache'\n+\n+export async function updateUser(id: string) {\n+  // Mutate data\n+  revalidatePath('/profile')\n+```\n+\n+```jsx filename=\"app/lib/actions.js\" highlight={1} switcher\n+import { revalidatePath } from 'next/cache'\n+\n+export async function updateUser(id) {\n+  // Mutate data\n+  revalidatePath('/profile')\n+```\n+\n+See the [`revalidatePath` API reference](/docs/app/api-reference/functions/revalidatePath) to learn more.\n+\n+## `unstable_cache`\n+\n+> **Good to know**: `unstable_cache` is an experimental API. We recommend opting into [Cache Components](/docs/app/getting-started/cache-components) and replacing `unstable_cache` with the [`use cache`](/docs/app/api-reference/directives/use-cache) directive. See the [Cache Components documentation](/docs/app/getting-started/cache-components) for more details.\n+\n+`unstable_cache` allows you to cache the result of database queries and other async functions. To use it, wrap `unstable_cache` around the function. For example:\n+\n+```ts filename=\"app/lib/data.ts\" switcher\n+import { db } from '@/lib/db'\n+export async function getUserById(id: string) {\n+  return db\n+    .select()\n+    .from(users)\n+    .where(eq(users.id, id))\n+    .then((res) => res[0])\n+}\n+```\n+\n+```jsx filename=\"app/lib/data.js\" switcher\n+import { db } from '@/lib/db'\n+\n+export async function getUserById(id) {\n+  return db\n+    .select()\n+    .from(users)\n+    .where(eq(users.id, id))\n+    .then((res) => res[0])\n+}\n+```\n+\n+```tsx filename=\"app/page.tsx\" highlight={2,11,13} switcher\n+import { unstable_cache } from 'next/cache'\n+import { getUserById } from '@/app/lib/data'\n+\n+export default async function Page({\n+  params,\n+}: {\n+  params: Promise<{ userId: string }>\n+}) {\n+  const { userId } = await params\n+\n+  const getCachedUser = unstable_cache(\n+    async () => {\n+      return getUserById(userId)\n+    },\n+    [userId] // add the user ID to the cache key\n+  )\n+}\n+```\n+\n+```jsx filename=\"app/page.js\" highlight={2,7,9} switcher\n+import { unstable_cache } from 'next/cache'\n+import { getUserById } from '@/app/lib/data'\n+\n+export default async function Page({ params }) {\n+  const { userId } = await params\n+\n+  const getCachedUser = unstable_cache(\n+    async () => {\n+      return getUserById(userId)\n+    },\n+    [userId] // add the user ID to the cache key\n+  )\n+}\n+```\n+\n+The function accepts a third optional object to define how the cache should be revalidated. It accepts:\n+\n+- `tags`: an array of tags used by Next.js to revalidate the cache.\n+- `revalidate`: the number of seconds after cache should be revalidated.\n+\n+```tsx filename=\"app/page.tsx\" highlight={6-9} switcher\n+const getCachedUser = unstable_cache(\n+  async () => {\n+    return getUserById(userId)\n+  },\n+  [userId],\n+  {\n+    tags: ['user'],\n+    revalidate: 3600,\n+  }\n+)\n+```\n+\n+```jsx filename=\"app/page.js\" highlight={6-9} switcher\n+const getCachedUser = unstable_cache(\n+  async () => {\n+    return getUserById(userId)\n+  },\n+  [userId],\n+  {\n+    tags: ['user'],\n+    revalidate: 3600,\n+  }\n+)\n+```\n+\n+See the [`unstable_cache` API reference](/docs/app/api-reference/functions/unstable_cache) to learn more."
        },
        {
            "sha": "f0298aca3eae6c09ce0c442b3f4816c55da5e315",
            "filename": "docs/01-app/01-getting-started/15-route-handlers.mdx",
            "status": "modified",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/vercel/next.js/blob/7fef3a0cca6757d14fbc3c0cfc1859de18208f35/docs%2F01-app%2F01-getting-started%2F15-route-handlers.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/7fef3a0cca6757d14fbc3c0cfc1859de18208f35/docs%2F01-app%2F01-getting-started%2F15-route-handlers.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F15-route-handlers.mdx?ref=7fef3a0cca6757d14fbc3c0cfc1859de18208f35",
            "patch": "@@ -84,6 +84,46 @@ export async function GET() {\n \n > **Good to know**: Other supported HTTP methods are **not** cached, even if they are placed alongside a `GET` method that is cached, in the same file.\n \n+#### With Cache Components\n+\n+When using [Cache Components](/docs/app/getting-started/cache-components), you can use the [`use cache`](/docs/app/api-reference/directives/use-cache) directive to cache data fetching within your Route Handlers. Route Handlers are dynamic by default, but can be pre-rendered at build time if they don't use runtime or dynamic data.\n+\n+```ts filename=\"app/api/posts/route.ts\" switcher\n+import { cacheTag } from 'next/cache'\n+\n+async function getPosts() {\n+  'use cache'\n+  cacheTag('posts')\n+\n+  const posts = await fetchPosts()\n+  return posts\n+}\n+\n+export async function GET() {\n+  const posts = await getPosts()\n+  return Response.json(posts)\n+}\n+```\n+\n+```js filename=\"app/api/posts/route.js\" switcher\n+import { cacheTag } from 'next/cache'\n+\n+async function getPosts() {\n+  'use cache'\n+  cacheTag('posts')\n+\n+  const posts = await fetchPosts()\n+  return posts\n+}\n+\n+export async function GET() {\n+  const posts = await getPosts()\n+  return Response.json(posts)\n+}\n+```\n+\n+See the [Cache Components documentation](/docs/app/getting-started/cache-components#route-handlers-with-cache-components) for more details on caching strategies and revalidation.\n+\n ### Special Route Handlers\n \n Special Route Handlers like [`sitemap.ts`](/docs/app/api-reference/file-conventions/metadata/sitemap), [`opengraph-image.tsx`](/docs/app/api-reference/file-conventions/metadata/opengraph-image), and [`icon.tsx`](/docs/app/api-reference/file-conventions/metadata/app-icons), and other [metadata files](/docs/app/api-reference/file-conventions/metadata) remain static by default unless they use Dynamic APIs or dynamic config options."
        },
        {
            "sha": "236d066388da28175333e25dfb68e8613c39a02a",
            "filename": "docs/01-app/01-getting-started/16-proxy.mdx",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/7fef3a0cca6757d14fbc3c0cfc1859de18208f35/docs%2F01-app%2F01-getting-started%2F16-proxy.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/7fef3a0cca6757d14fbc3c0cfc1859de18208f35/docs%2F01-app%2F01-getting-started%2F16-proxy.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F16-proxy.mdx?ref=7fef3a0cca6757d14fbc3c0cfc1859de18208f35",
            "patch": "@@ -12,15 +12,19 @@ related:\n \n ## Proxy\n \n+> **Good to know**: Starting with Next.js 16, Middleware is now called Proxy to better reflect its purpose. The functionality remains the same.\n+\n Proxy allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.\n \n ### Use cases\n \n Some common scenarios where Proxy is effective include:\n \n-- Quick redirects after reading parts of the incoming request\n-- Rewriting to different pages based on A/B tests or experiments\n - Modifying headers for all pages or a subset of pages\n+- Rewriting to different pages based on A/B tests or experiments\n+- Programmatic redirects based on incoming request properties\n+\n+For simple redirects, consider using the [`redirects`](/docs/app/api-reference/config/next-config-js/redirects) configuration in `next.config.ts` first. Proxy should be used when you need access to request data or more complex logic.\n \n Proxy is _not_ intended for slow data fetching. While Proxy can be helpful for [optimistic checks](/docs/app/guides/authentication#optimistic-checks-with-proxy-optional) such as permission-based redirects, it should not be used as a full session management or authorization solution.\n "
        },
        {
            "sha": "3649f79718c1d5404ee019570e4faeecdf00f10d",
            "filename": "docs/01-app/01-getting-started/18-upgrading.mdx",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/7fef3a0cca6757d14fbc3c0cfc1859de18208f35/docs%2F01-app%2F01-getting-started%2F18-upgrading.mdx",
            "raw_url": "https://github.com/vercel/next.js/raw/7fef3a0cca6757d14fbc3c0cfc1859de18208f35/docs%2F01-app%2F01-getting-started%2F18-upgrading.mdx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/docs%2F01-app%2F01-getting-started%2F18-upgrading.mdx?ref=7fef3a0cca6757d14fbc3c0cfc1859de18208f35",
            "patch": "@@ -48,13 +48,6 @@ npm i next@canary\n \n The following features are currently available in canary:\n \n-**Caching**:\n-\n-- [`\"use cache\"`](/docs/app/api-reference/directives/use-cache)\n-- [`cacheLife`](/docs/app/api-reference/functions/cacheLife)\n-- [`cacheTag`](/docs/app/api-reference/functions/cacheTag)\n-- [`cacheComponents`](/docs/app/api-reference/config/next-config-js/cacheComponents)\n-\n **Authentication**:\n \n - [`forbidden`](/docs/app/api-reference/functions/forbidden)"
        }
    ],
    "stats": {
        "total": 367,
        "additions": 209,
        "deletions": 158
    }
}