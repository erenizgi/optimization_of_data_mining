{
    "author": "unstubbable",
    "message": "Remove DIO w/o PPR branch from `app-render.tsx` (#79303)\n\nNow that `ppr` is automatically enabled when `dynamicIO` is enabled, we can remove the code branch that handled prerendering with Dynamic IO enabled, and PPR disabled.\r\n\r\n> [!NOTE]  \r\n> This PR is best reviewed with hidden whitespace changes.",
    "sha": "c23f08e3d9bc1c1497ce9e01268f615698a83355",
    "files": [
        {
            "sha": "dd4803930bdbfa65dc92fb5cc3b6394cceda384d",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 385,
            "deletions": 830,
            "changes": 1215,
            "blob_url": "https://github.com/vercel/next.js/blob/c23f08e3d9bc1c1497ce9e01268f615698a83355/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/c23f08e3d9bc1c1497ce9e01268f615698a83355/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=c23f08e3d9bc1c1497ce9e01268f615698a83355",
            "patch": "@@ -127,7 +127,6 @@ import {\n   isPrerenderInterruptedError,\n   createDynamicTrackingState,\n   createDynamicValidationState,\n-  getFirstDynamicReason,\n   trackAllowedDynamicAccess,\n   throwIfDisallowedDynamic,\n   consumeDynamicAccess,\n@@ -150,7 +149,6 @@ import { createMutableActionQueue } from '../../client/components/app-router-ins\n import { getRevalidateReason } from '../instrumentation/utils'\n import { PAGE_SEGMENT_KEY } from '../../shared/lib/segment'\n import type { FallbackRouteParams } from '../request/fallback-params'\n-import { DynamicServerError } from '../../client/components/hooks-server-context'\n import {\n   ServerPrerenderStreamResult,\n   processPrelude,\n@@ -2729,49 +2727,145 @@ async function prerenderToStream(\n \n   try {\n     if (renderOpts.experimental.dynamicIO) {\n-      if (renderOpts.experimental.isRoutePPREnabled) {\n-        /**\n-         * dynamicIO with PPR\n-         *\n-         * The general approach is to render the RSC stream first allowing any cache reads to resolve.\n-         * Once we have settled all cache reads we restart the render and abort after a single Task.\n-         *\n-         * Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used\n-         * during the initial render because we need to ensure all caches can be filled as part of the initial Task\n-         * and a synchronous abort might prevent us from filling all caches.\n-         *\n-         * Once the render is complete we allow the SSR render to finish and use a combination of the postponed state\n-         * and the reactServerIsDynamic value to determine how to treat the resulting render\n-         */\n-\n-        // Prerender controller represents the lifetime of the prerender.\n-        // It will be aborted when a Task is complete or a synchronously aborting\n-        // API is called. Notably during cache-filling renders this does not actually\n-        // terminate the render itself which will continue until all caches are filled\n-        const initialServerPrerenderController = new AbortController()\n-\n-        // This controller represents the lifetime of the React render call. Notably\n-        // during the cache-filling render it is different from the prerender controller\n-        // because we don't want to end the react render until all caches are filled.\n-        const initialServerRenderController = new AbortController()\n-\n-        // The cacheSignal helps us track whether caches are still filling or we are ready\n-        // to cut the render off.\n-        const cacheSignal = new CacheSignal()\n-\n-        // The resume data cache here should use a fresh instance as it's\n-        // performing a fresh prerender. If we get to implementing the\n-        // prerendering of an already prerendered page, we should use the passed\n-        // resume data cache instead.\n-        const prerenderResumeDataCache = createPrerenderResumeDataCache()\n-\n-        const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n+      /**\n+       * dynamicIO with PPR\n+       *\n+       * The general approach is to render the RSC stream first allowing any cache reads to resolve.\n+       * Once we have settled all cache reads we restart the render and abort after a single Task.\n+       *\n+       * Unlike with the non PPR case we can't synchronously abort the render when a dynamic API is used\n+       * during the initial render because we need to ensure all caches can be filled as part of the initial Task\n+       * and a synchronous abort might prevent us from filling all caches.\n+       *\n+       * Once the render is complete we allow the SSR render to finish and use a combination of the postponed state\n+       * and the reactServerIsDynamic value to determine how to treat the resulting render\n+       */\n+\n+      // Prerender controller represents the lifetime of the prerender.\n+      // It will be aborted when a Task is complete or a synchronously aborting\n+      // API is called. Notably during cache-filling renders this does not actually\n+      // terminate the render itself which will continue until all caches are filled\n+      const initialServerPrerenderController = new AbortController()\n+\n+      // This controller represents the lifetime of the React render call. Notably\n+      // during the cache-filling render it is different from the prerender controller\n+      // because we don't want to end the react render until all caches are filled.\n+      const initialServerRenderController = new AbortController()\n+\n+      // The cacheSignal helps us track whether caches are still filling or we are ready\n+      // to cut the render off.\n+      const cacheSignal = new CacheSignal()\n+\n+      // The resume data cache here should use a fresh instance as it's\n+      // performing a fresh prerender. If we get to implementing the\n+      // prerendering of an already prerendered page, we should use the passed\n+      // resume data cache instead.\n+      const prerenderResumeDataCache = createPrerenderResumeDataCache()\n+\n+      const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n+        type: 'prerender',\n+        phase: 'render',\n+        rootParams,\n+        implicitTags,\n+        renderSignal: initialServerRenderController.signal,\n+        controller: initialServerPrerenderController,\n+        cacheSignal,\n+        dynamicTracking: null,\n+        revalidate: INFINITE_CACHE,\n+        expire: INFINITE_CACHE,\n+        stale: INFINITE_CACHE,\n+        tags: [...implicitTags.tags],\n+        prerenderResumeDataCache,\n+        hmrRefreshHash: undefined,\n+      })\n+\n+      // We're not going to use the result of this render because the only time it could be used\n+      // is if it completes in a microtask and that's likely very rare for any non-trivial app\n+      const initialServerPayload = await workUnitAsyncStorage.run(\n+        initialServerPrerenderStore,\n+        getRSCPayload,\n+        tree,\n+        ctx,\n+        res.statusCode === 404\n+      )\n+\n+      const pendingInitialServerResult = workUnitAsyncStorage.run(\n+        initialServerPrerenderStore,\n+        ComponentMod.prerender,\n+        initialServerPayload,\n+        clientReferenceManifest.clientModules,\n+        {\n+          onError: (err) => {\n+            const digest = getDigestForWellKnownError(err)\n+\n+            if (digest) {\n+              return digest\n+            }\n+\n+            if (initialServerPrerenderController.signal.aborted) {\n+              // The render aborted before this error was handled which indicates\n+              // the error is caused by unfinished components within the render\n+              return\n+            } else if (\n+              process.env.NEXT_DEBUG_BUILD ||\n+              process.env.__NEXT_VERBOSE_LOGGING\n+            ) {\n+              printDebugThrownValueForProspectiveRender(err, workStore.route)\n+            }\n+          },\n+          // we don't care to track postpones during the prospective render because we need\n+          // to always do a final render anyway\n+          onPostpone: undefined,\n+          // We don't want to stop rendering until the cacheSignal is complete so we pass\n+          // a different signal to this render call than is used by dynamic APIs to signify\n+          // transitioning out of the prerender environment\n+          signal: initialServerRenderController.signal,\n+        }\n+      )\n+\n+      // Wait for all caches to be finished filling and for async imports to resolve\n+      trackPendingModules(cacheSignal)\n+      await cacheSignal.cacheReady()\n+\n+      initialServerRenderController.abort()\n+      initialServerPrerenderController.abort()\n+\n+      // We don't need to continue the prerender process if we already\n+      // detected invalid dynamic usage in the initial prerender phase.\n+      if (workStore.invalidDynamicUsageError) {\n+        throw workStore.invalidDynamicUsageError\n+      }\n+\n+      let initialServerResult\n+      try {\n+        initialServerResult = await createReactServerPrerenderResult(\n+          pendingInitialServerResult\n+        )\n+      } catch (err) {\n+        if (\n+          initialServerRenderController.signal.aborted ||\n+          initialServerPrerenderController.signal.aborted\n+        ) {\n+          // These are expected errors that might error the prerender. we ignore them.\n+        } else if (\n+          process.env.NEXT_DEBUG_BUILD ||\n+          process.env.__NEXT_VERBOSE_LOGGING\n+        ) {\n+          // We don't normally log these errors because we are going to retry anyway but\n+          // it can be useful for debugging Next.js itself to get visibility here when needed\n+          printDebugThrownValueForProspectiveRender(err, workStore.route)\n+        }\n+      }\n+\n+      if (initialServerResult) {\n+        const initialClientController = new AbortController()\n+        const initialClientPrerenderStore: PrerenderStore = {\n           type: 'prerender',\n           phase: 'render',\n           rootParams,\n           implicitTags,\n-          renderSignal: initialServerRenderController.signal,\n-          controller: initialServerPrerenderController,\n+          renderSignal: initialClientController.signal,\n+          controller: initialClientController,\n           cacheSignal,\n           dynamicTracking: null,\n           revalidate: INFINITE_CACHE,\n@@ -2780,74 +2874,50 @@ async function prerenderToStream(\n           tags: [...implicitTags.tags],\n           prerenderResumeDataCache,\n           hmrRefreshHash: undefined,\n-        })\n-\n-        // We're not going to use the result of this render because the only time it could be used\n-        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n-        const initialServerPayload = await workUnitAsyncStorage.run(\n-          initialServerPrerenderStore,\n-          getRSCPayload,\n-          tree,\n-          ctx,\n-          res.statusCode === 404\n-        )\n+        }\n \n-        const pendingInitialServerResult = workUnitAsyncStorage.run(\n-          initialServerPrerenderStore,\n-          ComponentMod.prerender,\n-          initialServerPayload,\n-          clientReferenceManifest.clientModules,\n+        const prerender = require('react-dom/static.edge')\n+          .prerender as (typeof import('react-dom/static.edge'))['prerender']\n+        const pendingInitialClientResult = workUnitAsyncStorage.run(\n+          initialClientPrerenderStore,\n+          prerender,\n+          <App\n+            reactServerStream={initialServerResult.asUnclosingStream()}\n+            preinitScripts={preinitScripts}\n+            clientReferenceManifest={clientReferenceManifest}\n+            ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n+            ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n+            gracefullyDegrade={!!ctx.renderOpts.botType}\n+            nonce={nonce}\n+          />,\n           {\n+            signal: initialClientController.signal,\n             onError: (err) => {\n               const digest = getDigestForWellKnownError(err)\n \n               if (digest) {\n                 return digest\n               }\n \n-              if (initialServerPrerenderController.signal.aborted) {\n-                // The render aborted before this error was handled which indicates\n-                // the error is caused by unfinished components within the render\n-                return\n+              if (initialClientController.signal.aborted) {\n+                // These are expected errors that might error the prerender. we ignore them.\n               } else if (\n                 process.env.NEXT_DEBUG_BUILD ||\n                 process.env.__NEXT_VERBOSE_LOGGING\n               ) {\n+                // We don't normally log these errors because we are going to retry anyway but\n+                // it can be useful for debugging Next.js itself to get visibility here when needed\n                 printDebugThrownValueForProspectiveRender(err, workStore.route)\n               }\n             },\n-            // we don't care to track postpones during the prospective render because we need\n-            // to always do a final render anyway\n-            onPostpone: undefined,\n-            // We don't want to stop rendering until the cacheSignal is complete so we pass\n-            // a different signal to this render call than is used by dynamic APIs to signify\n-            // transitioning out of the prerender environment\n-            signal: initialServerRenderController.signal,\n+            bootstrapScripts: [bootstrapScript],\n           }\n         )\n \n-        // Wait for all caches to be finished filling and for async imports to resolve\n-        trackPendingModules(cacheSignal)\n-        await cacheSignal.cacheReady()\n-\n-        initialServerRenderController.abort()\n-        initialServerPrerenderController.abort()\n-\n-        // We don't need to continue the prerender process if we already\n-        // detected invalid dynamic usage in the initial prerender phase.\n-        if (workStore.invalidDynamicUsageError) {\n-          throw workStore.invalidDynamicUsageError\n-        }\n-\n-        let initialServerResult\n-        try {\n-          initialServerResult = await createReactServerPrerenderResult(\n-            pendingInitialServerResult\n-          )\n-        } catch (err) {\n+        pendingInitialClientResult.catch((err) => {\n           if (\n             initialServerRenderController.signal.aborted ||\n-            initialServerPrerenderController.signal.aborted\n+            isPrerenderInterruptedError(err)\n           ) {\n             // These are expected errors that might error the prerender. we ignore them.\n           } else if (\n@@ -2858,810 +2928,295 @@ async function prerenderToStream(\n             // it can be useful for debugging Next.js itself to get visibility here when needed\n             printDebugThrownValueForProspectiveRender(err, workStore.route)\n           }\n-        }\n-\n-        if (initialServerResult) {\n-          const initialClientController = new AbortController()\n-          const initialClientPrerenderStore: PrerenderStore = {\n-            type: 'prerender',\n-            phase: 'render',\n-            rootParams,\n-            implicitTags,\n-            renderSignal: initialClientController.signal,\n-            controller: initialClientController,\n-            cacheSignal,\n-            dynamicTracking: null,\n-            revalidate: INFINITE_CACHE,\n-            expire: INFINITE_CACHE,\n-            stale: INFINITE_CACHE,\n-            tags: [...implicitTags.tags],\n-            prerenderResumeDataCache,\n-            hmrRefreshHash: undefined,\n-          }\n-\n-          const prerender = require('react-dom/static.edge')\n-            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n-          const pendingInitialClientResult = workUnitAsyncStorage.run(\n-            initialClientPrerenderStore,\n-            prerender,\n-            <App\n-              reactServerStream={initialServerResult.asUnclosingStream()}\n-              preinitScripts={preinitScripts}\n-              clientReferenceManifest={clientReferenceManifest}\n-              ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n-              ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n-              gracefullyDegrade={!!ctx.renderOpts.botType}\n-              nonce={nonce}\n-            />,\n-            {\n-              signal: initialClientController.signal,\n-              onError: (err) => {\n-                const digest = getDigestForWellKnownError(err)\n-\n-                if (digest) {\n-                  return digest\n-                }\n-\n-                if (initialClientController.signal.aborted) {\n-                  // These are expected errors that might error the prerender. we ignore them.\n-                } else if (\n-                  process.env.NEXT_DEBUG_BUILD ||\n-                  process.env.__NEXT_VERBOSE_LOGGING\n-                ) {\n-                  // We don't normally log these errors because we are going to retry anyway but\n-                  // it can be useful for debugging Next.js itself to get visibility here when needed\n-                  printDebugThrownValueForProspectiveRender(\n-                    err,\n-                    workStore.route\n-                  )\n-                }\n-              },\n-              bootstrapScripts: [bootstrapScript],\n-            }\n-          )\n-\n-          pendingInitialClientResult.catch((err) => {\n-            if (\n-              initialServerRenderController.signal.aborted ||\n-              isPrerenderInterruptedError(err)\n-            ) {\n-              // These are expected errors that might error the prerender. we ignore them.\n-            } else if (\n-              process.env.NEXT_DEBUG_BUILD ||\n-              process.env.__NEXT_VERBOSE_LOGGING\n-            ) {\n-              // We don't normally log these errors because we are going to retry anyway but\n-              // it can be useful for debugging Next.js itself to get visibility here when needed\n-              printDebugThrownValueForProspectiveRender(err, workStore.route)\n-            }\n-          })\n-\n-          // This is mostly needed for dynamic `import()`s in client components.\n-          // Promises passed to client were already awaited above (assuming that they came from cached functions)\n-          trackPendingModules(cacheSignal)\n-          await cacheSignal.cacheReady()\n-          initialClientController.abort()\n-        }\n-\n-        let serverIsDynamic = false\n-        const finalServerController = new AbortController()\n-        const serverDynamicTracking = createDynamicTrackingState(\n-          renderOpts.isDebugDynamicAccesses\n-        )\n-\n-        const finalRenderPrerenderStore: PrerenderStore = (prerenderStore = {\n-          type: 'prerender',\n-          phase: 'render',\n-          rootParams,\n-          implicitTags,\n-          renderSignal: finalServerController.signal,\n-          controller: finalServerController,\n-          // During the final prerender we don't need to track cache access so we omit the signal\n-          cacheSignal: null,\n-          dynamicTracking: serverDynamicTracking,\n-          revalidate: INFINITE_CACHE,\n-          expire: INFINITE_CACHE,\n-          stale: INFINITE_CACHE,\n-          tags: [...implicitTags.tags],\n-          prerenderResumeDataCache,\n-          hmrRefreshHash: undefined,\n         })\n \n-        const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n-          finalRenderPrerenderStore,\n-          getRSCPayload,\n-          tree,\n-          ctx,\n-          res.statusCode === 404\n-        )\n-        let prerenderIsPending = true\n-        const reactServerResult = (reactServerPrerenderResult =\n-          await createReactServerPrerenderResult(\n-            prerenderAndAbortInSequentialTasks(\n-              async () => {\n-                const prerenderResult = await workUnitAsyncStorage.run(\n-                  // The store to scope\n-                  finalRenderPrerenderStore,\n-                  // The function to run\n-                  ComponentMod.prerender,\n-                  // ... the arguments for the function to run\n-                  finalAttemptRSCPayload,\n-                  clientReferenceManifest.clientModules,\n-                  {\n-                    onError: (err: unknown) => {\n-                      return serverComponentsErrorHandler(err)\n-                    },\n-                    signal: finalServerController.signal,\n-                  }\n-                )\n-                prerenderIsPending = false\n-                return prerenderResult\n-              },\n-              () => {\n-                if (finalServerController.signal.aborted) {\n-                  // If the server controller is already aborted we must have called something\n-                  // that required aborting the prerender synchronously such as with new Date()\n-                  serverIsDynamic = true\n-                  return\n-                }\n-\n-                if (prerenderIsPending) {\n-                  // If prerenderIsPending then we have blocked for longer than a Task and we assume\n-                  // there is something unfinished.\n-                  serverIsDynamic = true\n-                }\n-                finalServerController.abort()\n-              }\n-            )\n-          ))\n+        // This is mostly needed for dynamic `import()`s in client components.\n+        // Promises passed to client were already awaited above (assuming that they came from cached functions)\n+        trackPendingModules(cacheSignal)\n+        await cacheSignal.cacheReady()\n+        initialClientController.abort()\n+      }\n \n-        const clientDynamicTracking = createDynamicTrackingState(\n-          renderOpts.isDebugDynamicAccesses\n-        )\n-        const finalClientController = new AbortController()\n-        const finalClientPrerenderStore: PrerenderStore = {\n-          type: 'prerender',\n-          phase: 'render',\n-          rootParams,\n-          implicitTags,\n-          renderSignal: finalClientController.signal,\n-          controller: finalClientController,\n-          // For HTML Generation we don't need to track cache reads (RSC only)\n-          cacheSignal: null,\n-          dynamicTracking: clientDynamicTracking,\n-          revalidate: INFINITE_CACHE,\n-          expire: INFINITE_CACHE,\n-          stale: INFINITE_CACHE,\n-          tags: [...implicitTags.tags],\n-          prerenderResumeDataCache,\n-          hmrRefreshHash: undefined,\n-        }\n+      let serverIsDynamic = false\n+      const finalServerController = new AbortController()\n+      const serverDynamicTracking = createDynamicTrackingState(\n+        renderOpts.isDebugDynamicAccesses\n+      )\n \n-        let clientIsDynamic = false\n-        let dynamicValidation = createDynamicValidationState()\n+      const finalRenderPrerenderStore: PrerenderStore = (prerenderStore = {\n+        type: 'prerender',\n+        phase: 'render',\n+        rootParams,\n+        implicitTags,\n+        renderSignal: finalServerController.signal,\n+        controller: finalServerController,\n+        // During the final prerender we don't need to track cache access so we omit the signal\n+        cacheSignal: null,\n+        dynamicTracking: serverDynamicTracking,\n+        revalidate: INFINITE_CACHE,\n+        expire: INFINITE_CACHE,\n+        stale: INFINITE_CACHE,\n+        tags: [...implicitTags.tags],\n+        prerenderResumeDataCache,\n+        hmrRefreshHash: undefined,\n+      })\n \n-        const prerender = require('react-dom/static.edge')\n-          .prerender as (typeof import('react-dom/static.edge'))['prerender']\n-        let { prelude: unprocessedPrelude, postponed } =\n-          await prerenderAndAbortInSequentialTasks(\n-            () =>\n-              workUnitAsyncStorage.run(\n-                finalClientPrerenderStore,\n-                prerender,\n-                <App\n-                  reactServerStream={reactServerResult.asUnclosingStream()}\n-                  preinitScripts={preinitScripts}\n-                  clientReferenceManifest={clientReferenceManifest}\n-                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n-                  ServerInsertedMetadataProvider={\n-                    ServerInsertedMetadataProvider\n-                  }\n-                  gracefullyDegrade={!!ctx.renderOpts.botType}\n-                  nonce={nonce}\n-                />,\n+      const finalAttemptRSCPayload = await workUnitAsyncStorage.run(\n+        finalRenderPrerenderStore,\n+        getRSCPayload,\n+        tree,\n+        ctx,\n+        res.statusCode === 404\n+      )\n+      let prerenderIsPending = true\n+      const reactServerResult = (reactServerPrerenderResult =\n+        await createReactServerPrerenderResult(\n+          prerenderAndAbortInSequentialTasks(\n+            async () => {\n+              const prerenderResult = await workUnitAsyncStorage.run(\n+                // The store to scope\n+                finalRenderPrerenderStore,\n+                // The function to run\n+                ComponentMod.prerender,\n+                // ... the arguments for the function to run\n+                finalAttemptRSCPayload,\n+                clientReferenceManifest.clientModules,\n                 {\n-                  signal: finalClientController.signal,\n-                  onError: (err: unknown, errorInfo: ErrorInfo) => {\n-                    if (\n-                      isPrerenderInterruptedError(err) ||\n-                      finalClientController.signal.aborted\n-                    ) {\n-                      clientIsDynamic = true\n-\n-                      const componentStack: string | undefined = (\n-                        errorInfo as any\n-                      ).componentStack\n-                      if (typeof componentStack === 'string') {\n-                        trackAllowedDynamicAccess(\n-                          workStore.route,\n-                          componentStack,\n-                          dynamicValidation\n-                        )\n-                      }\n-                      return\n-                    }\n-\n-                    return htmlRendererErrorHandler(err, errorInfo)\n-                  },\n-                  onHeaders: (headers: Headers) => {\n-                    headers.forEach((value, key) => {\n-                      appendHeader(key, value)\n-                    })\n+                  onError: (err: unknown) => {\n+                    return serverComponentsErrorHandler(err)\n                   },\n-                  maxHeadersLength: renderOpts.reactMaxHeadersLength,\n-                  bootstrapScripts: [bootstrapScript],\n+                  signal: finalServerController.signal,\n                 }\n-              ),\n+              )\n+              prerenderIsPending = false\n+              return prerenderResult\n+            },\n             () => {\n-              finalClientController.abort()\n-            }\n-          )\n+              if (finalServerController.signal.aborted) {\n+                // If the server controller is already aborted we must have called something\n+                // that required aborting the prerender synchronously such as with new Date()\n+                serverIsDynamic = true\n+                return\n+              }\n \n-        const { prelude, preludeIsEmpty } =\n-          await processPrelude(unprocessedPrelude)\n-\n-        // If we've disabled throwing on empty static shell, then we don't need to\n-        // track any dynamic access that occurs above the suspense boundary because\n-        // we'll do so in the route shell.\n-        if (!ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n-          throwIfDisallowedDynamic(\n-            workStore,\n-            preludeIsEmpty,\n-            dynamicValidation,\n-            serverDynamicTracking,\n-            clientDynamicTracking\n+              if (prerenderIsPending) {\n+                // If prerenderIsPending then we have blocked for longer than a Task and we assume\n+                // there is something unfinished.\n+                serverIsDynamic = true\n+              }\n+              finalServerController.abort()\n+            }\n           )\n-        }\n-\n-        const getServerInsertedHTML = makeGetServerInsertedHTML({\n-          polyfills,\n-          renderServerInsertedHTML,\n-          serverCapturedErrors: allCapturedErrors,\n-          basePath: renderOpts.basePath,\n-          tracingMetadata: tracingMetadata,\n-        })\n-\n-        const flightData = await streamToBuffer(reactServerResult.asStream())\n-        metadata.flightData = flightData\n-        metadata.segmentData = await collectSegmentData(\n-          flightData,\n-          finalRenderPrerenderStore,\n-          ComponentMod,\n-          renderOpts,\n-          fallbackRouteParams\n-        )\n-\n-        if (serverIsDynamic || clientIsDynamic) {\n-          if (postponed != null) {\n-            // Dynamic HTML case\n-            metadata.postponed = await getDynamicHTMLPostponedState(\n-              postponed,\n-              fallbackRouteParams,\n-              prerenderResumeDataCache\n-            )\n-          } else {\n-            // Dynamic Data case\n-            metadata.postponed = await getDynamicDataPostponedState(\n-              prerenderResumeDataCache\n-            )\n-          }\n-          reactServerResult.consume()\n-          return {\n-            digestErrorsMap: reactServerErrorsByDigest,\n-            ssrErrors: allCapturedErrors,\n-            stream: await continueDynamicPrerender(prelude, {\n-              getServerInsertedHTML,\n-              getServerInsertedMetadata,\n-            }),\n-            dynamicAccess: consumeDynamicAccess(\n-              serverDynamicTracking,\n-              clientDynamicTracking\n-            ),\n-            // TODO: Should this include the SSR pass?\n-            collectedRevalidate: finalRenderPrerenderStore.revalidate,\n-            collectedExpire: finalRenderPrerenderStore.expire,\n-            collectedStale: selectStaleTime(finalRenderPrerenderStore.stale),\n-            collectedTags: finalRenderPrerenderStore.tags,\n-          }\n-        } else {\n-          // Static case\n-          if (workStore.forceDynamic) {\n-            throw new StaticGenBailoutError(\n-              'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n-            )\n-          }\n+        ))\n \n-          let htmlStream = prelude\n-          if (postponed != null) {\n-            // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n-            // so we can set all the postponed boundaries to client render mode before we store the HTML response\n-            const resume = require('react-dom/server.edge')\n-              .resume as (typeof import('react-dom/server.edge'))['resume']\n+      const clientDynamicTracking = createDynamicTrackingState(\n+        renderOpts.isDebugDynamicAccesses\n+      )\n+      const finalClientController = new AbortController()\n+      const finalClientPrerenderStore: PrerenderStore = {\n+        type: 'prerender',\n+        phase: 'render',\n+        rootParams,\n+        implicitTags,\n+        renderSignal: finalClientController.signal,\n+        controller: finalClientController,\n+        // For HTML Generation we don't need to track cache reads (RSC only)\n+        cacheSignal: null,\n+        dynamicTracking: clientDynamicTracking,\n+        revalidate: INFINITE_CACHE,\n+        expire: INFINITE_CACHE,\n+        stale: INFINITE_CACHE,\n+        tags: [...implicitTags.tags],\n+        prerenderResumeDataCache,\n+        hmrRefreshHash: undefined,\n+      }\n \n-            // We don't actually want to render anything so we just pass a stream\n-            // that never resolves. The resume call is going to abort immediately anyway\n-            const foreverStream = new ReadableStream<Uint8Array>()\n+      let clientIsDynamic = false\n+      let dynamicValidation = createDynamicValidationState()\n \n-            const resumeStream = await resume(\n+      const prerender = require('react-dom/static.edge')\n+        .prerender as (typeof import('react-dom/static.edge'))['prerender']\n+      let { prelude: unprocessedPrelude, postponed } =\n+        await prerenderAndAbortInSequentialTasks(\n+          () =>\n+            workUnitAsyncStorage.run(\n+              finalClientPrerenderStore,\n+              prerender,\n               <App\n-                reactServerStream={foreverStream}\n-                preinitScripts={() => {}}\n+                reactServerStream={reactServerResult.asUnclosingStream()}\n+                preinitScripts={preinitScripts}\n                 clientReferenceManifest={clientReferenceManifest}\n                 ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n                 ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n                 gracefullyDegrade={!!ctx.renderOpts.botType}\n                 nonce={nonce}\n               />,\n-              JSON.parse(JSON.stringify(postponed)),\n               {\n-                signal: createPostponedAbortSignal('static prerender resume'),\n-                onError: htmlRendererErrorHandler,\n-                nonce,\n-              }\n-            )\n-\n-            // First we write everything from the prerender, then we write everything from the aborted resume render\n-            htmlStream = chainStreams(prelude, resumeStream)\n-          }\n+                signal: finalClientController.signal,\n+                onError: (err: unknown, errorInfo: ErrorInfo) => {\n+                  if (\n+                    isPrerenderInterruptedError(err) ||\n+                    finalClientController.signal.aborted\n+                  ) {\n+                    clientIsDynamic = true\n+\n+                    const componentStack: string | undefined = (\n+                      errorInfo as any\n+                    ).componentStack\n+                    if (typeof componentStack === 'string') {\n+                      trackAllowedDynamicAccess(\n+                        workStore.route,\n+                        componentStack,\n+                        dynamicValidation\n+                      )\n+                    }\n+                    return\n+                  }\n \n-          return {\n-            digestErrorsMap: reactServerErrorsByDigest,\n-            ssrErrors: allCapturedErrors,\n-            stream: await continueStaticPrerender(htmlStream, {\n-              inlinedDataStream: createInlinedDataReadableStream(\n-                reactServerResult.consumeAsStream(),\n-                nonce,\n-                formState\n-              ),\n-              getServerInsertedHTML,\n-              getServerInsertedMetadata,\n-            }),\n-            dynamicAccess: consumeDynamicAccess(\n-              serverDynamicTracking,\n-              clientDynamicTracking\n+                  return htmlRendererErrorHandler(err, errorInfo)\n+                },\n+                onHeaders: (headers: Headers) => {\n+                  headers.forEach((value, key) => {\n+                    appendHeader(key, value)\n+                  })\n+                },\n+                maxHeadersLength: renderOpts.reactMaxHeadersLength,\n+                bootstrapScripts: [bootstrapScript],\n+              }\n             ),\n-            // TODO: Should this include the SSR pass?\n-            collectedRevalidate: finalRenderPrerenderStore.revalidate,\n-            collectedExpire: finalRenderPrerenderStore.expire,\n-            collectedStale: selectStaleTime(finalRenderPrerenderStore.stale),\n-            collectedTags: finalRenderPrerenderStore.tags,\n+          () => {\n+            finalClientController.abort()\n           }\n-        }\n-      } else {\n-        /**\n-         * dynamicIO without PPR\n-         *\n-         * The general approach is to render the RSC tree first allowing for any inflight\n-         * caches to resolve. Once we have settled inflight caches we can check and see if any\n-         * synchronous dynamic APIs were used. If so we don't need to bother doing anything more\n-         * because the page will be dynamic on re-render anyway\n-         *\n-         * If no sync dynamic APIs were used we then re-render and abort after a single Task.\n-         * If the render errors we know that the page has some dynamic IO. This assumes and relies\n-         * upon caches reading from a in process memory cache and resolving in a microtask. While this\n-         * is true from our own default cache implementation and if you don't exceed our LRU size it\n-         * might not be true for custom cache implementations.\n-         *\n-         * Future implementations can do some different strategies during build like using IPC to\n-         * synchronously fill caches during this special rendering mode. For now this heuristic should work\n-         */\n-\n-        const cache = workStore.incrementalCache\n-        if (!cache) {\n-          throw new Error(\n-            'Expected incremental cache to exist. This is a bug in Next.js'\n-          )\n-        }\n-\n-        // Prerender controller represents the lifetime of the prerender.\n-        // It will be aborted when a Task is complete or a synchronously aborting\n-        // API is called. Notably during cache-filling renders this does not actually\n-        // terminate the render itself which will continue until all caches are filled\n-        const initialServerPrerenderController = new AbortController()\n-\n-        // This controller represents the lifetime of the React render call. Notably\n-        // during the cache-filling render it is different from the prerender controller\n-        // because we don't want to end the react render until all caches are filled.\n-        const initialServerRenderController = new AbortController()\n-\n-        const cacheSignal = new CacheSignal()\n-        const prerenderResumeDataCache = createPrerenderResumeDataCache()\n-\n-        const initialServerPrerenderStore: PrerenderStore = (prerenderStore = {\n-          type: 'prerender',\n-          phase: 'render',\n-          rootParams,\n-          implicitTags,\n-          renderSignal: initialServerRenderController.signal,\n-          controller: initialServerPrerenderController,\n-          cacheSignal,\n-          dynamicTracking: null,\n-          revalidate: INFINITE_CACHE,\n-          expire: INFINITE_CACHE,\n-          stale: INFINITE_CACHE,\n-          tags: [...implicitTags.tags],\n-          prerenderResumeDataCache,\n-          hmrRefreshHash: undefined,\n-        })\n+        )\n \n-        const initialClientController = new AbortController()\n-        const initialClientPrerenderStore: PrerenderStore = (prerenderStore = {\n-          type: 'prerender',\n-          phase: 'render',\n-          rootParams,\n-          implicitTags,\n-          renderSignal: initialClientController.signal,\n-          controller: initialClientController,\n-          cacheSignal,\n-          dynamicTracking: null,\n-          revalidate: INFINITE_CACHE,\n-          expire: INFINITE_CACHE,\n-          stale: INFINITE_CACHE,\n-          tags: [...implicitTags.tags],\n-          prerenderResumeDataCache,\n-          hmrRefreshHash: undefined,\n-        })\n+      const { prelude, preludeIsEmpty } =\n+        await processPrelude(unprocessedPrelude)\n \n-        // We're not going to use the result of this render because the only time it could be used\n-        // is if it completes in a microtask and that's likely very rare for any non-trivial app\n-        const firstAttemptRSCPayload = await workUnitAsyncStorage.run(\n-          initialServerPrerenderStore,\n-          getRSCPayload,\n-          tree,\n-          ctx,\n-          res.statusCode === 404\n+      // If we've disabled throwing on empty static shell, then we don't need to\n+      // track any dynamic access that occurs above the suspense boundary because\n+      // we'll do so in the route shell.\n+      if (!ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n+        throwIfDisallowedDynamic(\n+          workStore,\n+          preludeIsEmpty,\n+          dynamicValidation,\n+          serverDynamicTracking,\n+          clientDynamicTracking\n         )\n+      }\n \n-        let initialServerStream\n-        try {\n-          initialServerStream = workUnitAsyncStorage.run(\n-            initialServerPrerenderStore,\n-            ComponentMod.renderToReadableStream,\n-            firstAttemptRSCPayload,\n-            clientReferenceManifest.clientModules,\n-            {\n-              onError: (err) => {\n-                const digest = getDigestForWellKnownError(err)\n+      const getServerInsertedHTML = makeGetServerInsertedHTML({\n+        polyfills,\n+        renderServerInsertedHTML,\n+        serverCapturedErrors: allCapturedErrors,\n+        basePath: renderOpts.basePath,\n+        tracingMetadata: tracingMetadata,\n+      })\n \n-                if (digest) {\n-                  return digest\n-                }\n+      const flightData = await streamToBuffer(reactServerResult.asStream())\n+      metadata.flightData = flightData\n+      metadata.segmentData = await collectSegmentData(\n+        flightData,\n+        finalRenderPrerenderStore,\n+        ComponentMod,\n+        renderOpts,\n+        fallbackRouteParams\n+      )\n \n-                if (\n-                  initialServerPrerenderController.signal.aborted ||\n-                  initialServerRenderController.signal.aborted\n-                ) {\n-                  // The render aborted before this error was handled which indicates\n-                  // the error is caused by unfinished components within the render\n-                  return\n-                } else if (\n-                  process.env.NEXT_DEBUG_BUILD ||\n-                  process.env.__NEXT_VERBOSE_LOGGING\n-                ) {\n-                  printDebugThrownValueForProspectiveRender(\n-                    err,\n-                    workStore.route\n-                  )\n-                }\n-              },\n-              signal: initialServerRenderController.signal,\n-            }\n+      if (serverIsDynamic || clientIsDynamic) {\n+        if (postponed != null) {\n+          // Dynamic HTML case\n+          metadata.postponed = await getDynamicHTMLPostponedState(\n+            postponed,\n+            fallbackRouteParams,\n+            prerenderResumeDataCache\n           )\n-        } catch (err: unknown) {\n-          if (\n-            initialServerPrerenderController.signal.aborted ||\n-            initialServerRenderController.signal.aborted\n-          ) {\n-            // These are expected errors that might error the prerender. we ignore them.\n-          } else if (\n-            process.env.NEXT_DEBUG_BUILD ||\n-            process.env.__NEXT_VERBOSE_LOGGING\n-          ) {\n-            // We don't normally log these errors because we are going to retry anyway but\n-            // it can be useful for debugging Next.js itself to get visibility here when needed\n-            printDebugThrownValueForProspectiveRender(err, workStore.route)\n-          }\n+        } else {\n+          // Dynamic Data case\n+          metadata.postponed = await getDynamicDataPostponedState(\n+            prerenderResumeDataCache\n+          )\n+        }\n+        reactServerResult.consume()\n+        return {\n+          digestErrorsMap: reactServerErrorsByDigest,\n+          ssrErrors: allCapturedErrors,\n+          stream: await continueDynamicPrerender(prelude, {\n+            getServerInsertedHTML,\n+            getServerInsertedMetadata,\n+          }),\n+          dynamicAccess: consumeDynamicAccess(\n+            serverDynamicTracking,\n+            clientDynamicTracking\n+          ),\n+          // TODO: Should this include the SSR pass?\n+          collectedRevalidate: finalRenderPrerenderStore.revalidate,\n+          collectedExpire: finalRenderPrerenderStore.expire,\n+          collectedStale: selectStaleTime(finalRenderPrerenderStore.stale),\n+          collectedTags: finalRenderPrerenderStore.tags,\n         }\n+      } else {\n+        // Static case\n+        if (workStore.forceDynamic) {\n+          throw new StaticGenBailoutError(\n+            'Invariant: a Page with `dynamic = \"force-dynamic\"` did not trigger the dynamic pathway. This is a bug in Next.js'\n+          )\n+        }\n+\n+        let htmlStream = prelude\n+        if (postponed != null) {\n+          // We postponed but nothing dynamic was used. We resume the render now and immediately abort it\n+          // so we can set all the postponed boundaries to client render mode before we store the HTML response\n+          const resume = require('react-dom/server.edge')\n+            .resume as (typeof import('react-dom/server.edge'))['resume']\n \n-        if (initialServerStream) {\n-          const prerender = require('react-dom/static.edge')\n-            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n-          const pendingInitialClientResult = workUnitAsyncStorage.run(\n-            initialClientPrerenderStore,\n-            prerender,\n+          // We don't actually want to render anything so we just pass a stream\n+          // that never resolves. The resume call is going to abort immediately anyway\n+          const foreverStream = new ReadableStream<Uint8Array>()\n+\n+          const resumeStream = await resume(\n             <App\n-              reactServerStream={initialServerStream}\n-              preinitScripts={preinitScripts}\n+              reactServerStream={foreverStream}\n+              preinitScripts={() => {}}\n               clientReferenceManifest={clientReferenceManifest}\n               ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n               ServerInsertedMetadataProvider={ServerInsertedMetadataProvider}\n               gracefullyDegrade={!!ctx.renderOpts.botType}\n               nonce={nonce}\n             />,\n+            JSON.parse(JSON.stringify(postponed)),\n             {\n-              signal: initialClientController.signal,\n-              onError: (err) => {\n-                const digest = getDigestForWellKnownError(err)\n-\n-                if (digest) {\n-                  return digest\n-                }\n-\n-                if (initialClientController.signal.aborted) {\n-                  // These are expected errors that might error the prerender. we ignore them.\n-                } else if (\n-                  process.env.NEXT_DEBUG_BUILD ||\n-                  process.env.__NEXT_VERBOSE_LOGGING\n-                ) {\n-                  // We don't normally log these errors because we are going to retry anyway but\n-                  // it can be useful for debugging Next.js itself to get visibility here when needed\n-                  printDebugThrownValueForProspectiveRender(\n-                    err,\n-                    workStore.route\n-                  )\n-                }\n-              },\n-              bootstrapScripts: [bootstrapScript],\n-            }\n-          )\n-          pendingInitialClientResult.catch((err: unknown) => {\n-            if (initialClientController.signal.aborted) {\n-              // We aborted the render normally and can ignore this error\n-            } else {\n-              // We're going to retry to so we normally would suppress this error but\n-              // when verbose logging is on we print it\n-              if (process.env.__NEXT_VERBOSE_LOGGING) {\n-                printDebugThrownValueForProspectiveRender(err, workStore.route)\n-              }\n-            }\n-          })\n-        }\n-\n-        // Wait for all caches to be finished filling and for async imports to resolve\n-        trackPendingModules(cacheSignal)\n-        await cacheSignal.cacheReady()\n-\n-        // It is important that we abort the SSR render first to avoid\n-        // connection closed errors from having an incomplete RSC stream\n-        initialClientController.abort()\n-        initialServerRenderController.abort()\n-        initialServerPrerenderController.abort()\n-\n-        // We don't need to continue the prerender process if we already\n-        // detected invalid dynamic usage in the initial prerender phase.\n-        if (workStore.invalidDynamicUsageError) {\n-          throw workStore.invalidDynamicUsageError\n-        }\n-\n-        // We've now filled caches and triggered any inadvertant sync bailouts\n-        // due to lazy module initialization. We can restart our render to capture results\n-\n-        let serverIsDynamic = false\n-        const finalServerController = new AbortController()\n-        const serverDynamicTracking = createDynamicTrackingState(\n-          renderOpts.isDebugDynamicAccesses\n-        )\n-\n-        const finalServerPrerenderStore: PrerenderStore = (prerenderStore = {\n-          type: 'prerender',\n-          phase: 'render',\n-          rootParams,\n-          implicitTags,\n-          renderSignal: finalServerController.signal,\n-          controller: finalServerController,\n-          // During the final prerender we don't need to track cache access so we omit the signal\n-          cacheSignal: null,\n-          dynamicTracking: serverDynamicTracking,\n-          revalidate: INFINITE_CACHE,\n-          expire: INFINITE_CACHE,\n-          stale: INFINITE_CACHE,\n-          tags: [...implicitTags.tags],\n-          prerenderResumeDataCache,\n-          hmrRefreshHash: undefined,\n-        })\n-\n-        let clientIsDynamic = false\n-        const finalClientController = new AbortController()\n-        const clientDynamicTracking = createDynamicTrackingState(\n-          renderOpts.isDebugDynamicAccesses\n-        )\n-        const dynamicValidation = createDynamicValidationState()\n-\n-        const finalClientPrerenderStore: PrerenderStore = (prerenderStore = {\n-          type: 'prerender',\n-          phase: 'render',\n-          rootParams,\n-          implicitTags,\n-          renderSignal: finalClientController.signal,\n-          controller: finalClientController,\n-          // During the final prerender we don't need to track cache access so we omit the signal\n-          cacheSignal: null,\n-          dynamicTracking: clientDynamicTracking,\n-          revalidate: INFINITE_CACHE,\n-          expire: INFINITE_CACHE,\n-          stale: INFINITE_CACHE,\n-          tags: [...implicitTags.tags],\n-          prerenderResumeDataCache,\n-          hmrRefreshHash: undefined,\n-        })\n-\n-        const finalServerPayload = await workUnitAsyncStorage.run(\n-          finalServerPrerenderStore,\n-          getRSCPayload,\n-          tree,\n-          ctx,\n-          res.statusCode === 404\n-        )\n-\n-        const serverPrerenderStreamResult = (reactServerPrerenderResult =\n-          await prerenderServerWithPhases(\n-            finalServerController.signal,\n-            () =>\n-              workUnitAsyncStorage.run(\n-                finalServerPrerenderStore,\n-                ComponentMod.renderToReadableStream,\n-                finalServerPayload,\n-                clientReferenceManifest.clientModules,\n-                {\n-                  onError: (err: unknown) => {\n-                    if (finalServerController.signal.aborted) {\n-                      serverIsDynamic = true\n-                      if (isPrerenderInterruptedError(err)) {\n-                        return err.digest\n-                      }\n-                      return getDigestForWellKnownError(err)\n-                    }\n-\n-                    return serverComponentsErrorHandler(err)\n-                  },\n-                  signal: finalServerController.signal,\n-                }\n-              ),\n-            () => {\n-              finalServerController.abort()\n-            }\n-          ))\n-\n-        let htmlStream, preludeIsEmpty\n-        const serverPhasedStream = serverPrerenderStreamResult.asPhasedStream()\n-        try {\n-          const prerender = require('react-dom/static.edge')\n-            .prerender as (typeof import('react-dom/static.edge'))['prerender']\n-          const result = await prerenderClientWithPhases(\n-            () =>\n-              workUnitAsyncStorage.run(\n-                finalClientPrerenderStore,\n-                prerender,\n-                <App\n-                  reactServerStream={serverPhasedStream}\n-                  preinitScripts={preinitScripts}\n-                  clientReferenceManifest={clientReferenceManifest}\n-                  ServerInsertedHTMLProvider={ServerInsertedHTMLProvider}\n-                  ServerInsertedMetadataProvider={\n-                    ServerInsertedMetadataProvider\n-                  }\n-                  gracefullyDegrade={!!ctx.renderOpts.botType}\n-                  nonce={nonce}\n-                />,\n-                {\n-                  signal: finalClientController.signal,\n-                  onError: (err: unknown, errorInfo: ErrorInfo) => {\n-                    if (\n-                      isPrerenderInterruptedError(err) ||\n-                      finalClientController.signal.aborted\n-                    ) {\n-                      clientIsDynamic = true\n-\n-                      const componentStack: string | undefined = (\n-                        errorInfo as any\n-                      ).componentStack\n-                      if (typeof componentStack === 'string') {\n-                        trackAllowedDynamicAccess(\n-                          workStore.route,\n-                          componentStack,\n-                          dynamicValidation\n-                        )\n-                      }\n-                      return\n-                    }\n-\n-                    return htmlRendererErrorHandler(err, errorInfo)\n-                  },\n-                  bootstrapScripts: [bootstrapScript],\n-                }\n-              ),\n-            () => {\n-              finalClientController.abort()\n-              serverPhasedStream.assertExhausted()\n+              signal: createPostponedAbortSignal('static prerender resume'),\n+              onError: htmlRendererErrorHandler,\n+              nonce,\n             }\n           )\n-          const processed = await processPrelude(result.prelude)\n-          htmlStream = processed.prelude\n-          preludeIsEmpty = processed.preludeIsEmpty\n-        } catch (err) {\n-          if (\n-            isPrerenderInterruptedError(err) ||\n-            finalClientController.signal.aborted\n-          ) {\n-            preludeIsEmpty = true\n-          } else {\n-            // This error is something else and should bubble up\n-            throw err\n-          }\n-        }\n \n-        // If we've disabled throwing on empty static shell, then we don't need to\n-        // track any dynamic access that occurs above the suspense boundary because\n-        // we'll do so in the route shell.\n-        if (!ctx.renderOpts.doNotThrowOnEmptyStaticShell) {\n-          // We don't have a shell because the root errored when we aborted.\n-          throwIfDisallowedDynamic(\n-            workStore,\n-            preludeIsEmpty,\n-            dynamicValidation,\n-            serverDynamicTracking,\n-            clientDynamicTracking\n-          )\n-        }\n-\n-        if (serverIsDynamic || clientIsDynamic) {\n-          const dynamicReason = serverIsDynamic\n-            ? getFirstDynamicReason(serverDynamicTracking)\n-            : getFirstDynamicReason(clientDynamicTracking)\n-          if (dynamicReason) {\n-            throw new DynamicServerError(\n-              `Route \"${workStore.route}\" couldn't be rendered statically because it used \\`${dynamicReason}\\`. See more info here: https://nextjs.org/docs/messages/next-prerender-data`\n-            )\n-          } else {\n-            throw new DynamicServerError(\n-              `Route \"${workStore.route}\" couldn't be rendered statically it accessed data without explicitly caching it. See more info here: https://nextjs.org/docs/messages/next-prerender-data`\n-            )\n-          }\n+          // First we write everything from the prerender, then we write everything from the aborted resume render\n+          htmlStream = chainStreams(prelude, resumeStream)\n         }\n \n-        const flightData = await streamToBuffer(\n-          serverPrerenderStreamResult.asStream()\n-        )\n-        metadata.flightData = flightData\n-        metadata.segmentData = await collectSegmentData(\n-          flightData,\n-          finalClientPrerenderStore,\n-          ComponentMod,\n-          renderOpts,\n-          fallbackRouteParams\n-        )\n-\n-        const getServerInsertedHTML = makeGetServerInsertedHTML({\n-          polyfills,\n-          renderServerInsertedHTML,\n-          serverCapturedErrors: allCapturedErrors,\n-          basePath: renderOpts.basePath,\n-          tracingMetadata: tracingMetadata,\n-        })\n-        const validateRootLayout = renderOpts.dev\n         return {\n           digestErrorsMap: reactServerErrorsByDigest,\n           ssrErrors: allCapturedErrors,\n-          stream: await continueFizzStream(htmlStream!, {\n+          stream: await continueStaticPrerender(htmlStream, {\n             inlinedDataStream: createInlinedDataReadableStream(\n-              serverPrerenderStreamResult.asStream(),\n+              reactServerResult.consumeAsStream(),\n               nonce,\n               formState\n             ),\n-            isStaticGeneration: true,\n             getServerInsertedHTML,\n             getServerInsertedMetadata,\n-            validateRootLayout,\n           }),\n           dynamicAccess: consumeDynamicAccess(\n             serverDynamicTracking,\n             clientDynamicTracking\n           ),\n           // TODO: Should this include the SSR pass?\n-          collectedRevalidate: finalServerPrerenderStore.revalidate,\n-          collectedExpire: finalServerPrerenderStore.expire,\n-          collectedStale: selectStaleTime(finalServerPrerenderStore.stale),\n-          collectedTags: finalServerPrerenderStore.tags,\n+          collectedRevalidate: finalRenderPrerenderStore.revalidate,\n+          collectedExpire: finalRenderPrerenderStore.expire,\n+          collectedStale: selectStaleTime(finalRenderPrerenderStore.stale),\n+          collectedTags: finalRenderPrerenderStore.tags,\n         }\n       }\n     } else if (renderOpts.experimental.isRoutePPREnabled) {"
        }
    ],
    "stats": {
        "total": 1215,
        "additions": 385,
        "deletions": 830
    }
}