{
    "author": "kdy1",
    "message": "perf(turbopack): Apply small-vector optimization for `TaskId`s (#80830)\n\n### What?\n\nReduce memory allocations by applying small vector optimization.\n\n### Why?\n\n`sizeof(SmallVec<[TaskId; 4]>)` == `sizeof(Vec<TaskId>)` so it's an simple optimization.\n\nReducing memory allocation may yield performance improvements.",
    "sha": "4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a",
    "files": [
        {
            "sha": "736783d316e2abf5c2cf4df2d2fd4f5bfef4e2f2",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/operation/update_output.rs",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Foperation%2Fupdate_output.rs?ref=4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a",
            "patch": "@@ -2,6 +2,7 @@ use std::mem::take;\n \n use anyhow::Result;\n use serde::{Deserialize, Serialize};\n+use smallvec::SmallVec;\n use turbo_tasks::{RawVc, TaskId, backend::TurboTasksExecutionError};\n \n #[cfg(feature = \"trace_task_dirty\")]\n@@ -26,12 +27,12 @@ pub enum UpdateOutputOperation {\n     MakeDependentTasksDirty {\n         #[cfg(feature = \"trace_task_dirty\")]\n         task_id: TaskId,\n-        dependent_tasks: Vec<TaskId>,\n-        children: Vec<TaskId>,\n+        dependent_tasks: SmallVec<[TaskId; 4]>,\n+        children: SmallVec<[TaskId; 4]>,\n         queue: AggregationUpdateQueue,\n     },\n     EnsureUnfinishedChildrenDirty {\n-        children: Vec<TaskId>,\n+        children: SmallVec<[TaskId; 4]>,\n         queue: AggregationUpdateQueue,\n     },\n     AggregationUpdate {"
        },
        {
            "sha": "0b784948943270a019d97875319b76af979df614",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/storage.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fstorage.rs?ref=4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a",
            "patch": "@@ -7,6 +7,7 @@ use std::{\n \n use bitfield::bitfield;\n use rayon::iter::{IndexedParallelIterator, IntoParallelRefIterator, ParallelIterator};\n+use smallvec::SmallVec;\n use turbo_tasks::{FxDashMap, TaskId};\n \n use crate::{\n@@ -670,7 +671,7 @@ impl Storage {\n             .with_max_len(1)\n             .map(|shard| {\n                 let mut direct_snapshots: Vec<(TaskId, Box<InnerStorageSnapshot>)> = Vec::new();\n-                let mut modified: Vec<TaskId> = Vec::new();\n+                let mut modified: SmallVec<[TaskId; 4]> = SmallVec::new();\n                 {\n                     // Take the snapshots from the modified map\n                     let guard = shard.write();\n@@ -1100,7 +1101,7 @@ impl Drop for SnapshotGuard<'_> {\n \n pub struct SnapshotShard<'l, PP, P, PS> {\n     direct_snapshots: Vec<(TaskId, Box<InnerStorageSnapshot>)>,\n-    modified: Vec<TaskId>,\n+    modified: SmallVec<[TaskId; 4]>,\n     storage: &'l Storage,\n     guard: Option<Arc<SnapshotGuard<'l>>>,\n     process: &'l P,"
        },
        {
            "sha": "6f564b4893022542d84624b0733c5911afe56672",
            "filename": "turbopack/crates/turbo-tasks/src/manager.rs",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/vercel/next.js/blob/4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fmanager.rs?ref=4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a",
            "patch": "@@ -16,6 +16,7 @@ use anyhow::{Result, anyhow};\n use auto_hash_map::AutoMap;\n use rustc_hash::FxHasher;\n use serde::{Deserialize, Serialize};\n+use smallvec::SmallVec;\n use tokio::{runtime::Handle, select, sync::mpsc::Receiver, task_local};\n use tokio_util::task::TaskTracker;\n use tracing::{Instrument, Level, Span, info_span, instrument, trace_span};\n@@ -399,7 +400,7 @@ struct CurrentTaskState {\n     /// Affected tasks, that are tracked during task execution. These tasks will\n     /// be invalidated when the execution finishes or before reading a cell\n     /// value.\n-    tasks_to_notify: Vec<TaskId>,\n+    tasks_to_notify: SmallVec<[TaskId; 4]>,\n \n     /// True if the current task has state in cells\n     stateful: bool,\n@@ -429,7 +430,7 @@ impl CurrentTaskState {\n         Self {\n             task_id,\n             execution_id,\n-            tasks_to_notify: Vec::new(),\n+            tasks_to_notify: SmallVec::new(),\n             stateful: false,\n             cell_counters: Some(AutoMap::default()),\n             local_tasks: Vec::new(),\n@@ -1514,7 +1515,7 @@ impl<B: Backend + 'static> TurboTasksBackendApi<B> for TurboTasks<B> {\n             let CurrentTaskState {\n                 tasks_to_notify, ..\n             } = &mut *cell.write().unwrap();\n-            tasks_to_notify.extend(tasks.iter());\n+            tasks_to_notify.extend(tasks.iter().copied());\n         });\n         if result.is_err() {\n             let _guard = trace_span!(\"schedule_notify_tasks\", count = tasks.len()).entered();\n@@ -1529,7 +1530,7 @@ impl<B: Backend + 'static> TurboTasksBackendApi<B> for TurboTasks<B> {\n             let CurrentTaskState {\n                 tasks_to_notify, ..\n             } = &mut *cell.write().unwrap();\n-            tasks_to_notify.extend(tasks.iter());\n+            tasks_to_notify.extend(tasks.iter().copied());\n         });\n         if result.is_err() {\n             let _guard = trace_span!(\"schedule_notify_tasks_set\", count = tasks.len()).entered();"
        },
        {
            "sha": "fae4418a51ed63519a42992730a51eb21dbcd5d2",
            "filename": "turbopack/crates/turbo-tasks/src/persisted_graph.rs",
            "status": "modified",
            "additions": 40,
            "deletions": 25,
            "changes": 65,
            "blob_url": "https://github.com/vercel/next.js/blob/4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fpersisted_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fpersisted_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks%2Fsrc%2Fpersisted_graph.rs?ref=4eea8e75a79512d8e5cd5d93de9a958de4fd4f3a",
            "patch": "@@ -1,5 +1,6 @@\n use anyhow::Result;\n use serde::{Deserialize, Serialize, ser::SerializeSeq};\n+use smallvec::SmallVec;\n \n use crate::{\n     CellId, RawVc, TaskId,\n@@ -21,8 +22,8 @@ impl Default for TaskCell {\n \n #[derive(Serialize, Deserialize, Debug)]\n pub struct TaskData {\n-    pub children: Vec<TaskId>,\n-    pub dependencies: Vec<RawVc>,\n+    pub children: SmallVec<[TaskId; 4]>,\n+    pub dependencies: SmallVec<[RawVc; 1]>,\n     pub cells: TaskCells,\n     pub output: RawVc,\n }\n@@ -130,25 +131,27 @@ pub struct ActivateResult {\n \n     /// Further tasks that need to be activated that\n     /// didn't fit into that batch\n-    pub more_tasks_to_activate: Vec<TaskId>,\n+    pub more_tasks_to_activate: SmallVec<[TaskId; 4]>,\n }\n \n #[derive(Debug)]\n pub struct PersistResult {\n     /// Tasks that need to be activated\n-    pub tasks_to_activate: Vec<TaskId>,\n+    pub tasks_to_activate: SmallVec<[TaskId; 4]>,\n \n     /// Tasks that need to be deactivated\n-    pub tasks_to_deactivate: Vec<TaskId>,\n+    pub tasks_to_deactivate: SmallVec<[TaskId; 4]>,\n }\n \n #[derive(Debug)]\n pub struct DeactivateResult {\n     /// Further tasks that need to be deactivated that\n     /// didn't fit into that batch\n-    pub more_tasks_to_deactivate: Vec<TaskId>,\n+    pub more_tasks_to_deactivate: SmallVec<[TaskId; 4]>,\n }\n \n+pub type TypeIds = SmallVec<[TaskId; 4]>;\n+\n pub trait PersistedGraph: Sync + Send {\n     /// read task data and state for a specific task.\n     fn read(\n@@ -216,8 +219,10 @@ pub trait PersistedGraph: Sync + Send {\n     /// Removes all external keep alives that were not renewed this round.\n     /// This is usually called after the initial build has finished and all\n     /// external keep alives has been renewed.\n-    fn remove_outdated_externally_active(&self, api: &dyn PersistedGraphApi)\n-    -> Result<Vec<TaskId>>;\n+    fn remove_outdated_externally_active(\n+        &self,\n+        api: &dyn PersistedGraphApi,\n+    ) -> Result<SmallVec<[TaskId; 4]>>;\n \n     /// update the dirty flag for a stored task\n     /// Returns true, when the task is active and should be scheduled\n@@ -228,23 +233,27 @@ pub trait PersistedGraph: Sync + Send {\n \n     /// make all tasks that depend on that vc dirty and\n     /// return a list of active tasks that should be scheduled\n-    fn make_dependent_dirty(&self, vc: RawVc, api: &dyn PersistedGraphApi) -> Result<Vec<TaskId>>;\n+    fn make_dependent_dirty(\n+        &self,\n+        vc: RawVc,\n+        api: &dyn PersistedGraphApi,\n+    ) -> Result<SmallVec<[TaskId; 4]>>;\n \n     /// Get all tasks that are active, but not persisted.\n     /// This is usually called at beginning to create and schedule\n     /// tasks that are missing in the persisted graph\n-    fn get_active_external_tasks(&self, api: &dyn PersistedGraphApi) -> Result<Vec<TaskId>>;\n+    fn get_active_external_tasks(\n+        &self,\n+        api: &dyn PersistedGraphApi,\n+    ) -> Result<SmallVec<[TaskId; 4]>>;\n \n     /// Get all tasks that are dirty and active.\n     /// This is usually called at the beginning to schedule these tasks.\n-    fn get_dirty_active_tasks(&self, api: &dyn PersistedGraphApi) -> Result<Vec<TaskId>>;\n+    fn get_dirty_active_tasks(&self, api: &dyn PersistedGraphApi) -> Result<SmallVec<[TaskId; 4]>>;\n \n     /// Get tasks that have active update pending that need to be continued\n     /// returns (tasks_to_activate, tasks_to_deactivate)\n-    fn get_pending_active_update(\n-        &self,\n-        api: &dyn PersistedGraphApi,\n-    ) -> Result<(Vec<TaskId>, Vec<TaskId>)>;\n+    fn get_pending_active_update(&self, api: &dyn PersistedGraphApi) -> Result<(TypeIds, TypeIds)>;\n \n     /// Stop operations\n     #[allow(unused_variables)]\n@@ -350,8 +359,8 @@ impl PersistedGraph for () {\n     fn remove_outdated_externally_active(\n         &self,\n         _api: &dyn PersistedGraphApi,\n-    ) -> Result<Vec<TaskId>> {\n-        Ok(Vec::new())\n+    ) -> Result<SmallVec<[TaskId; 4]>> {\n+        Ok(Default::default())\n     }\n \n     fn make_dirty(&self, _task: TaskId, _api: &dyn PersistedGraphApi) -> Result<bool> {\n@@ -366,22 +375,28 @@ impl PersistedGraph for () {\n         &self,\n         _vc: RawVc,\n         _api: &dyn PersistedGraphApi,\n-    ) -> Result<Vec<TaskId>> {\n-        Ok(Vec::new())\n+    ) -> Result<SmallVec<[TaskId; 4]>> {\n+        Ok(Default::default())\n     }\n \n-    fn get_active_external_tasks(&self, _api: &dyn PersistedGraphApi) -> Result<Vec<TaskId>> {\n-        Ok(Vec::new())\n+    fn get_active_external_tasks(\n+        &self,\n+        _api: &dyn PersistedGraphApi,\n+    ) -> Result<SmallVec<[TaskId; 4]>> {\n+        Ok(Default::default())\n     }\n \n-    fn get_dirty_active_tasks(&self, _api: &dyn PersistedGraphApi) -> Result<Vec<TaskId>> {\n-        Ok(Vec::new())\n+    fn get_dirty_active_tasks(\n+        &self,\n+        _api: &dyn PersistedGraphApi,\n+    ) -> Result<SmallVec<[TaskId; 4]>> {\n+        Ok(Default::default())\n     }\n \n     fn get_pending_active_update(\n         &self,\n         _api: &dyn PersistedGraphApi,\n-    ) -> Result<(Vec<TaskId>, Vec<TaskId>)> {\n-        Ok((Vec::new(), Vec::new()))\n+    ) -> Result<(SmallVec<[TaskId; 4]>, SmallVec<[TaskId; 4]>)> {\n+        Ok((Default::default(), Default::default()))\n     }\n }"
        }
    ],
    "stats": {
        "total": 86,
        "additions": 52,
        "deletions": 34
    }
}