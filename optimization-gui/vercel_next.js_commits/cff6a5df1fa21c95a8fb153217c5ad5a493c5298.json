{
    "author": "mischnic",
    "message": "Turbopack: remove duplicate traversal implementations (#85853)\n\nWe had two implementations of various traversals: first for the SingleModuleGraph, and then also the more general version that can cross module graphs. Let's just use the second for everything (with just a single graph in the case of `SingleModuleGraph`)\r\n\r\nThis turned out to be a much bigger change than I had anticipated, but this was long overdue anyway.",
    "sha": "cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
    "files": [
        {
            "sha": "648776140be4dbb8a9e2e46ffdb3266e7abcd6ae",
            "filename": "crates/next-api/src/analyze.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/crates%2Fnext-api%2Fsrc%2Fanalyze.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/crates%2Fnext-api%2Fsrc%2Fanalyze.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fanalyze.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -419,10 +419,10 @@ pub async fn analyze_module_graphs(module_graphs: Vc<ModuleGraphs>) -> Result<Vc\n         module_graph.traverse_all_edges_unordered(|(parent_node, reference), node| {\n             match reference.chunking_type {\n                 ChunkingType::Async => {\n-                    all_async_edges.insert((parent_node.module, node.module));\n+                    all_async_edges.insert((parent_node, node));\n                 }\n                 _ => {\n-                    all_edges.insert((parent_node.module, node.module));\n+                    all_edges.insert((parent_node, node));\n                 }\n             }\n             Ok(())"
        },
        {
            "sha": "5428b1729956cc140be789076115216b1d9fc479",
            "filename": "crates/next-api/src/client_references.rs",
            "status": "modified",
            "additions": 1,
            "deletions": 3,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/crates%2Fnext-api%2Fsrc%2Fclient_references.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/crates%2Fnext-api%2Fsrc%2Fclient_references.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fclient_references.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -34,9 +34,7 @@ pub async fn map_client_references(\n     let graph = graph.await?;\n     let manifest = graph\n         .iter_nodes()\n-        .map(|node| async move {\n-            let module = node.module;\n-\n+        .map(|module| async move {\n             if let Some(client_reference_module) =\n                 ResolvedVc::try_downcast_type::<EcmascriptClientReferenceModule>(module)\n             {"
        },
        {
            "sha": "75e476b8aa32131c9fe2205a9c45725aec1de090",
            "filename": "crates/next-api/src/dynamic_imports.rs",
            "status": "modified",
            "additions": 6,
            "deletions": 8,
            "changes": 14,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fdynamic_imports.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -35,7 +35,7 @@ use turbopack_core::{\n         availability_info::AvailabilityInfo,\n     },\n     module::Module,\n-    module_graph::{ModuleGraph, SingleModuleGraph, SingleModuleGraphModuleNode},\n+    module_graph::{ModuleGraph, SingleModuleGraph},\n     output::OutputAssets,\n };\n \n@@ -125,30 +125,28 @@ pub async fn map_next_dynamic(graph: Vc<SingleModuleGraph>) -> Result<Vc<Dynamic\n     let actions = graph\n         .await?\n         .iter_nodes()\n-        .map(|node| async move {\n-            let SingleModuleGraphModuleNode { module } = node;\n-\n+        .map(|module| async move {\n             if module\n                 .ident()\n                 .await?\n                 .layer\n                 .as_ref()\n                 .is_some_and(|layer| layer.name() == \"app-client\" || layer.name() == \"client\")\n                 && let Some(dynamic_entry_module) =\n-                    ResolvedVc::try_downcast_type::<NextDynamicEntryModule>(*module)\n+                    ResolvedVc::try_downcast_type::<NextDynamicEntryModule>(module)\n             {\n                 return Ok(Some((\n-                    *module,\n+                    module,\n                     DynamicImportEntriesMapType::DynamicEntry(dynamic_entry_module),\n                 )));\n             }\n             // TODO add this check once these modules have the correct layer\n             // if layer.is_some_and(|layer| &**layer == \"app-rsc\") {\n             if let Some(client_reference_module) =\n-                ResolvedVc::try_downcast_type::<EcmascriptClientReferenceModule>(*module)\n+                ResolvedVc::try_downcast_type::<EcmascriptClientReferenceModule>(module)\n             {\n                 return Ok(Some((\n-                    *module,\n+                    module,\n                     DynamicImportEntriesMapType::ClientReference(client_reference_module),\n                 )));\n             }"
        },
        {
            "sha": "37e8b4e4a168ad685d0b9e949a871cb4c68103aa",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 108,
            "deletions": 88,
            "changes": 196,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -74,7 +74,7 @@ impl NextDynamicGraph {\n         let span = tracing::info_span!(\"collect next/dynamic imports for endpoint\");\n         async move {\n             let data = &*self.data.await?;\n-            let graph = &*self.graph.await?;\n+            let graph = self.graph.await?;\n \n             #[derive(Clone, PartialEq, Eq)]\n             enum VisitState {\n@@ -96,48 +96,56 @@ impl NextDynamicGraph {\n \n             // module -> the client reference entry (if any)\n             let mut state_map = FxHashMap::default();\n-            graph.traverse_edges_from_entries(entries, |parent_info, node| {\n-                let module = node.module;\n-                let Some((parent_node, _)) = parent_info else {\n-                    state_map.insert(module, VisitState::Entry);\n-                    return GraphTraversalAction::Continue;\n-                };\n-                let parent_module = parent_node.module;\n-\n-                let module_type = data.get(&module);\n-                let parent_state = state_map.get(&parent_module).unwrap().clone();\n-                let parent_client_reference =\n-                    if let Some(DynamicImportEntriesMapType::ClientReference(module)) = module_type\n-                    {\n-                        Some(ClientReferenceType::EcmascriptClientReference(*module))\n-                    } else if let VisitState::InClientReference(ty) = parent_state {\n-                        Some(ty)\n-                    } else {\n-                        None\n+            graph.read().traverse_edges_from_entries_dfs(\n+                entries,\n+                &mut (),\n+                |parent_info, node, _| {\n+                    let module = node;\n+                    let Some((parent_node, _)) = parent_info else {\n+                        state_map.insert(module, VisitState::Entry);\n+                        return Ok(GraphTraversalAction::Continue);\n                     };\n+                    let parent_module = parent_node;\n \n-                match module_type {\n-                    Some(DynamicImportEntriesMapType::DynamicEntry(dynamic_entry)) => {\n-                        result.push((*dynamic_entry, parent_client_reference));\n+                    let module_type = data.get(&module);\n+                    let parent_state = state_map.get(&parent_module).unwrap().clone();\n+                    let parent_client_reference =\n+                        if let Some(DynamicImportEntriesMapType::ClientReference(module)) =\n+                            module_type\n+                        {\n+                            Some(ClientReferenceType::EcmascriptClientReference(*module))\n+                        } else if let VisitState::InClientReference(ty) = parent_state {\n+                            Some(ty)\n+                        } else {\n+                            None\n+                        };\n \n-                        state_map.insert(module, parent_state);\n-                        GraphTraversalAction::Skip\n-                    }\n-                    Some(DynamicImportEntriesMapType::ClientReference(client_reference)) => {\n-                        state_map.insert(\n-                            module,\n-                            VisitState::InClientReference(\n-                                ClientReferenceType::EcmascriptClientReference(*client_reference),\n-                            ),\n-                        );\n-                        GraphTraversalAction::Continue\n-                    }\n-                    None => {\n-                        state_map.insert(module, parent_state);\n-                        GraphTraversalAction::Continue\n-                    }\n-                }\n-            })?;\n+                    Ok(match module_type {\n+                        Some(DynamicImportEntriesMapType::DynamicEntry(dynamic_entry)) => {\n+                            result.push((*dynamic_entry, parent_client_reference));\n+\n+                            state_map.insert(module, parent_state);\n+                            GraphTraversalAction::Skip\n+                        }\n+                        Some(DynamicImportEntriesMapType::ClientReference(client_reference)) => {\n+                            state_map.insert(\n+                                module,\n+                                VisitState::InClientReference(\n+                                    ClientReferenceType::EcmascriptClientReference(\n+                                        *client_reference,\n+                                    ),\n+                                ),\n+                            );\n+                            GraphTraversalAction::Continue\n+                        }\n+                        None => {\n+                            state_map.insert(module, parent_state);\n+                            GraphTraversalAction::Continue\n+                        }\n+                    })\n+                },\n+                |_, _, _| Ok(()),\n+            )?;\n             Ok(Vc::cell(result))\n         }\n         .instrument(span)\n@@ -184,19 +192,25 @@ impl ServerActionsGraph {\n                 Cow::Borrowed(data)\n             } else {\n                 // The graph contains the whole app, traverse and collect all reachable imports.\n-                let graph = &*self.graph.await?;\n+                let graph = self.graph.await?;\n \n                 if !graph.has_entry_module(entry) {\n                     // the graph doesn't contain the entry, e.g. for the additional module graph\n                     return Ok(Vc::cell(Default::default()));\n                 }\n \n                 let mut result = FxIndexMap::default();\n-                graph.traverse_from_entry(entry, |node| {\n-                    if let Some(node_data) = data.get(&node.module) {\n-                        result.insert(node.module, *node_data);\n-                    }\n-                })?;\n+                graph.read().traverse_nodes_from_entries_dfs(\n+                    vec![entry],\n+                    &mut result,\n+                    |node, result| {\n+                        if let Some(node_data) = data.get(&node) {\n+                            result.insert(node, *node_data);\n+                        }\n+                        Ok(GraphTraversalAction::Continue)\n+                    },\n+                    |_, _| Ok(()),\n+                )?;\n                 Cow::Owned(result)\n             };\n \n@@ -274,7 +288,7 @@ impl ClientReferencesGraph {\n         let span = tracing::info_span!(\"collect client references for endpoint\");\n         async move {\n             let data = &*self.data.await?;\n-            let graph = &*self.graph.await?;\n+            let graph = self.graph.await?;\n \n             let entries = if !self.is_single_page {\n                 if !graph.has_entry_module(entry) {\n@@ -293,12 +307,13 @@ impl ClientReferencesGraph {\n \n             let mut server_components = FxIndexSet::default();\n \n+            let graph = graph.read();\n             // Perform a DFS traversal to find all server components included by this page.\n-            graph.traverse_nodes_from_entries(\n+            graph.traverse_nodes_from_entries_dfs(\n                 entries,\n                 &mut (),\n                 |node, _| {\n-                    let module_type = data.get(&node.module);\n+                    let module_type = data.get(&node);\n                     Ok(match module_type {\n                         Some(\n                             ClientManifestEntryType::EcmascriptClientReference { .. }\n@@ -310,14 +325,14 @@ impl ClientReferencesGraph {\n                 },\n                 |node, _| {\n                     if let Some(server_util_module) =\n-                        ResolvedVc::try_downcast_type::<NextServerUtilityModule>(node.module)\n+                        ResolvedVc::try_downcast_type::<NextServerUtilityModule>(node)\n                     {\n                         // Server utility used by the template, not a server component\n                         server_utils.insert(server_util_module);\n                         return Ok(());\n                     }\n \n-                    let module_type = data.get(&node.module);\n+                    let module_type = data.get(&node);\n \n                     let ty = match module_type {\n                         Some(ClientManifestEntryType::EcmascriptClientReference {\n@@ -350,11 +365,11 @@ impl ClientReferencesGraph {\n             // necessarily rendered at the same time (not-found, or parallel routes), we need to\n             // determine the order of client references individually for each server component.\n             for sc in server_components.iter().copied() {\n-                graph.traverse_nodes_from_entries(\n+                graph.traverse_nodes_from_entries_dfs(\n                     std::iter::once(ResolvedVc::upcast(sc)),\n                     &mut (),\n                     |node, _| {\n-                        let module = node.module;\n+                        let module = node;\n                         let module_type = data.get(&module);\n \n                         Ok(match module_type {\n@@ -366,7 +381,7 @@ impl ClientReferencesGraph {\n                         })\n                     },\n                     |node, _| {\n-                        let module = node.module;\n+                        let module = node;\n                         if let Some(server_util_module) =\n                             ResolvedVc::try_downcast_type::<NextServerUtilityModule>(module)\n                         {\n@@ -506,7 +521,7 @@ async fn validate_pages_css_imports(\n     entry: Vc<Box<dyn Module>>,\n     app_module: ResolvedVc<Box<dyn Module>>,\n ) -> Result<()> {\n-    let graph = &*graph.await?;\n+    let graph = graph.await?;\n     let entry = entry.to_resolved().await?;\n \n     let entries = if !is_single_page {\n@@ -521,47 +536,52 @@ async fn validate_pages_css_imports(\n \n     let mut candidates = vec![];\n \n-    graph.traverse_edges_from_entries(entries, |parent_info, node| {\n-        let module = node.module;\n+    graph.read().traverse_edges_from_entries_dfs(\n+        entries,\n+        &mut (),\n+        |parent_info, node, _| {\n+            let module = node;\n \n-        // If we're at a root node, there is nothing importing this module and we can skip\n-        // any further validations.\n-        let Some((parent_node, _)) = parent_info else {\n-            return GraphTraversalAction::Continue;\n-        };\n-        let parent_module = parent_node.module;\n+            // If we're at a root node, there is nothing importing this module and we can skip\n+            // any further validations.\n+            let Some((parent_node, _)) = parent_info else {\n+                return Ok(GraphTraversalAction::Continue);\n+            };\n+            let parent_module = parent_node;\n \n-        // Importing CSS from _app.js is always allowed.\n-        if parent_module == app_module {\n-            return GraphTraversalAction::Continue;\n-        }\n+            // Importing CSS from _app.js is always allowed.\n+            if parent_module == app_module {\n+                return Ok(GraphTraversalAction::Continue);\n+            }\n \n-        // If the module being imported isn't a global css module, there is nothing to validate.\n-        let module_is_global_css =\n-            ResolvedVc::try_downcast_type::<CssModuleAsset>(module).is_some();\n+            // If the module being imported isn't a global css module, there is nothing to validate.\n+            let module_is_global_css =\n+                ResolvedVc::try_downcast_type::<CssModuleAsset>(module).is_some();\n \n-        if !module_is_global_css {\n-            return GraphTraversalAction::Continue;\n-        }\n+            if !module_is_global_css {\n+                return Ok(GraphTraversalAction::Continue);\n+            }\n \n-        let parent_is_css_module = ResolvedVc::try_downcast_type::<ModuleCssAsset>(parent_module)\n-            .is_some()\n-            || ResolvedVc::try_downcast_type::<CssModuleAsset>(parent_module).is_some();\n+            let parent_is_css_module =\n+                ResolvedVc::try_downcast_type::<ModuleCssAsset>(parent_module).is_some()\n+                    || ResolvedVc::try_downcast_type::<CssModuleAsset>(parent_module).is_some();\n \n-        // We also always allow .module css/scss/sass files to import global css files as well.\n-        if parent_is_css_module {\n-            return GraphTraversalAction::Continue;\n-        }\n+            // We also always allow .module css/scss/sass files to import global css files as well.\n+            if parent_is_css_module {\n+                return Ok(GraphTraversalAction::Continue);\n+            }\n \n-        // If all of the above invariants have been checked, we look to see if the parent module is\n-        // the same as the app module. If it isn't we know it isn't a valid place to import global\n-        // css.\n-        if parent_module != app_module {\n-            candidates.push(CssGlobalImportIssue::new(parent_module, module))\n-        }\n+            // If all of the above invariants have been checked, we look to see if the parent module\n+            // is the same as the app module. If it isn't we know it isn't a valid place\n+            // to import global css.\n+            if parent_module != app_module {\n+                candidates.push(CssGlobalImportIssue::new(parent_module, module))\n+            }\n \n-        GraphTraversalAction::Continue\n-    })?;\n+            Ok(GraphTraversalAction::Continue)\n+        },\n+        |_, _, _| Ok(()),\n+    )?;\n \n     candidates\n         .into_iter()"
        },
        {
            "sha": "480033600954dec02b9b106244c09f3bc03f59fe",
            "filename": "crates/next-api/src/server_actions.rs",
            "status": "modified",
            "additions": 16,
            "deletions": 22,
            "changes": 38,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fserver_actions.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -30,10 +30,7 @@ use turbopack_core::{\n     file_source::FileSource,\n     ident::AssetIdent,\n     module::Module,\n-    module_graph::{\n-        ModuleGraph, SingleModuleGraph, SingleModuleGraphModuleNode,\n-        async_module_info::AsyncModulesInfo,\n-    },\n+    module_graph::{ModuleGraph, SingleModuleGraph, async_module_info::AsyncModulesInfo},\n     output::OutputAsset,\n     reference_type::{EcmaScriptModulesReferenceSubType, ReferenceType},\n     resolve::ModulePart,\n@@ -454,24 +451,21 @@ pub async fn map_server_actions(graph: Vc<SingleModuleGraph>) -> Result<Vc<AllMo\n     let actions = graph\n         .await?\n         .iter_nodes()\n-        .map(|node| {\n-            async move {\n-                let SingleModuleGraphModuleNode { module } = node;\n-                // TODO: compare module contexts instead?\n-                let layer = match module.ident().await?.layer.as_ref() {\n-                    Some(layer) if layer.name() == \"app-rsc\" || layer.name() == \"app-edge-rsc\" => {\n-                        ActionLayer::Rsc\n-                    }\n-                    Some(layer) if layer.name() == \"app-client\" => ActionLayer::ActionBrowser,\n-                    // TODO really ignore SSR?\n-                    _ => return Ok(None),\n-                };\n-                // TODO the old implementation did parse_actions(to_rsc_context(module))\n-                // is that really necessary?\n-                Ok(parse_actions(**module)\n-                    .await?\n-                    .map(|action_map| (*module, (layer, action_map))))\n-            }\n+        .map(async |module| {\n+            // TODO: compare module contexts instead?\n+            let layer = match module.ident().await?.layer.as_ref() {\n+                Some(layer) if layer.name() == \"app-rsc\" || layer.name() == \"app-edge-rsc\" => {\n+                    ActionLayer::Rsc\n+                }\n+                Some(layer) if layer.name() == \"app-client\" => ActionLayer::ActionBrowser,\n+                // TODO really ignore SSR?\n+                _ => return Ok(None),\n+            };\n+            // TODO the old implementation did parse_actions(to_rsc_context(module))\n+            // is that really necessary?\n+            Ok(parse_actions(*module)\n+                .await?\n+                .map(|action_map| (module, (layer, action_map))))\n         })\n         .try_flat_join()\n         .await?;"
        },
        {
            "sha": "bc8613102d34b1d1cdefe9ec80c4b32b4961e7ed",
            "filename": "crates/next-api/src/webpack_stats.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fwebpack_stats.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -60,9 +60,9 @@ where\n         let mut edges = vec![];\n         module_graph.traverse_all_edges_unordered(|(parent_node, r), current| {\n             edges.push((\n-                parent_node.module,\n+                parent_node,\n                 RcStr::from(format!(\"{}: {}\", r.chunking_type, r.export)),\n-                current.module,\n+                current,\n             ));\n             Ok(())\n         })?;"
        },
        {
            "sha": "96a465a5dc57114ed4a555eeba524b2b05282d4f",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/async_module_info.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 13,
            "changes": 21,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fasync_module_info.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -57,7 +57,7 @@ async fn compute_async_module_info_single(\n \n     let self_async_modules = graph\n         .iter_nodes()\n-        .map(async |node| Ok((node.module, *node.module.is_self_async().await?)))\n+        .map(async |node| Ok((node, *node.is_self_async().await?)))\n         .try_join()\n         .await?\n         .into_iter()\n@@ -73,7 +73,8 @@ async fn compute_async_module_info_single(\n     // modules in the SCC is async.\n \n     let mut async_modules = self_async_modules;\n-    graph.traverse_edges_from_entries_dfs(\n+    let graph_ref = graph.read();\n+    graph_ref.traverse_edges_from_entries_dfs(\n         graph.entry_modules(),\n         &mut (),\n         |_, _, _| Ok(GraphTraversalAction::Continue),\n@@ -82,8 +83,6 @@ async fn compute_async_module_info_single(\n                 // An entry module\n                 return Ok(());\n             };\n-            let module = module.module();\n-            let parent_module = parent_module.module;\n \n             if ref_data.chunking_type.is_inherit_async() && async_modules.contains(&module) {\n                 async_modules.insert(parent_module);\n@@ -92,19 +91,15 @@ async fn compute_async_module_info_single(\n         },\n     )?;\n \n-    graph.traverse_cycles(\n+    graph_ref.traverse_cycles(\n         |ref_data| ref_data.chunking_type.is_inherit_async(),\n         |cycle| {\n-            if cycle\n-                .iter()\n-                .any(|node| async_modules.contains(&node.module))\n-            {\n-                for &node in cycle {\n-                    async_modules.insert(node.module);\n-                }\n+            if cycle.iter().any(|node| async_modules.contains(node)) {\n+                async_modules.extend(cycle.iter().map(|n| **n));\n             }\n+            Ok(())\n         },\n-    );\n+    )?;\n \n     Ok(Vc::cell(async_modules))\n }"
        },
        {
            "sha": "0b3f99b9ffb1d423487db06e07777f410ad1cf8d",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/chunk_group_info.rs",
            "status": "modified",
            "additions": 21,
            "deletions": 23,
            "changes": 44,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fchunk_group_info.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -19,7 +19,7 @@ use turbo_tasks::{\n use crate::{\n     chunk::ChunkingType,\n     module::Module,\n-    module_graph::{GraphTraversalAction, ModuleGraphRef, RefData, SingleModuleGraphModuleNode},\n+    module_graph::{GraphTraversalAction, ModuleGraphRef, RefData},\n };\n \n #[derive(\n@@ -412,14 +412,14 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n                 |parent, node| {\n                     if let Some((parent, _)) = parent {\n                         let parent_depth = *module_depth\n-                            .get(&parent.module)\n+                            .get(&parent)\n                             .context(\"Module depth not found\")?;\n-                        module_depth.entry(node.module).or_insert(parent_depth + 1);\n+                        module_depth.entry(node).or_insert(parent_depth + 1);\n                     } else {\n-                        module_depth.insert(node.module, 0);\n+                        module_depth.insert(node, 0);\n                     };\n \n-                    module_chunk_groups.insert(node.module, RoaringBitmapWrapper::default());\n+                    module_chunk_groups.insert(node, RoaringBitmapWrapper::default());\n \n                     Ok(GraphTraversalAction::Continue)\n                 },\n@@ -507,8 +507,8 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n                 })\n                 .collect::<Result<Vec<_>>>()?,\n             &mut module_chunk_groups,\n-            |parent_info: Option<(&'_ SingleModuleGraphModuleNode, &'_ RefData)>,\n-             node: &'_ SingleModuleGraphModuleNode,\n+            |parent_info: Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n+             node: ResolvedVc<Box<dyn Module>>,\n              module_chunk_groups: &mut FxHashMap<\n                 ResolvedVc<Box<dyn Module>>,\n                 RoaringBitmapWrapper,\n@@ -520,28 +520,26 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n                 }\n                 let chunk_groups = if let Some((parent, ref_data)) = parent_info {\n                     match &ref_data.chunking_type {\n-                        ChunkingType::Parallel { .. } => {\n-                            ChunkGroupInheritance::Inherit(parent.module)\n-                        }\n+                        ChunkingType::Parallel { .. } => ChunkGroupInheritance::Inherit(parent),\n                         ChunkingType::Async => ChunkGroupInheritance::ChunkGroup(Either::Left(\n-                            std::iter::once(ChunkGroupKey::Async(node.module)),\n+                            std::iter::once(ChunkGroupKey::Async(node)),\n                         )),\n                         ChunkingType::Isolated {\n                             merge_tag: None, ..\n                         } => ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n-                            ChunkGroupKey::Isolated(node.module),\n+                            ChunkGroupKey::Isolated(node),\n                         ))),\n                         ChunkingType::Shared {\n                             merge_tag: None, ..\n                         } => ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n-                            ChunkGroupKey::Shared(node.module),\n+                            ChunkGroupKey::Shared(node),\n                         ))),\n                         ChunkingType::Isolated {\n                             merge_tag: Some(merge_tag),\n                             ..\n                         } => {\n                             let parents = module_chunk_groups\n-                                .get(&parent.module)\n+                                .get(&parent)\n                                 .context(\"Module chunk group not found\")?;\n                             let chunk_groups =\n                                 parents.iter().map(|parent| ChunkGroupKey::IsolatedMerged {\n@@ -557,7 +555,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n                             ..\n                         } => {\n                             let parents = module_chunk_groups\n-                                .get(&parent.module)\n+                                .get(&parent)\n                                 .context(\"Module chunk group not found\")?;\n                             let chunk_groups =\n                                 parents.iter().map(|parent| ChunkGroupKey::SharedMerged {\n@@ -577,7 +575,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n                     ChunkGroupInheritance::ChunkGroup(Either::Left(std::iter::once(\n                         // TODO remove clone\n                         entry_chunk_group_keys\n-                            .get(&node.module)\n+                            .get(&node)\n                             .context(\"Module chunk group not found\")?\n                             .clone(),\n                     )))\n@@ -597,15 +595,15 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n                                 Entry::Occupied(mut e) => {\n                                     let (id, merged_entries) = e.get_mut();\n                                     if is_merged {\n-                                        merged_entries.insert(node.module);\n+                                        merged_entries.insert(node);\n                                     }\n                                     **id\n                                 }\n                                 Entry::Vacant(e) => {\n                                     let chunk_group_id = len as u32;\n                                     let mut set = FxIndexSet::default();\n                                     if is_merged {\n-                                        set.insert(node.module);\n+                                        set.insert(node);\n                                     }\n                                     e.insert((ChunkGroupId(chunk_group_id), set));\n                                     chunk_group_id\n@@ -618,7 +616,7 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n \n                         // Assign chunk group to the target node (the entry of the chunk group)\n                         let bitset = module_chunk_groups\n-                            .get_mut(&node.module)\n+                            .get_mut(&node)\n                             .context(\"Module chunk group not found\")?;\n                         if chunk_groups.is_proper_superset(bitset) {\n                             // Add bits from parent, and continue traversal because changed\n@@ -634,12 +632,12 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n                         // Inherit chunk groups from parent, merge parent chunk groups into\n                         // current\n \n-                        if parent == node.module {\n+                        if parent == node {\n                             // A self-reference\n                             GraphTraversalAction::Skip\n                         } else {\n                             let [Some(parent_chunk_groups), Some(current_chunk_groups)] =\n-                                module_chunk_groups.get_disjoint_mut([&parent, &node.module])\n+                                module_chunk_groups.get_disjoint_mut([&parent, &node])\n                             else {\n                                 // All modules are inserted in the previous iteration\n                                 // Technically unreachable, but could be reached due to eventual\n@@ -673,10 +671,10 @@ pub async fn compute_chunk_group_info(graph: &ModuleGraphRef) -> Result<Vc<Chunk\n             |successor, module_chunk_groups| {\n                 Ok(TraversalPriority {\n                     depth: *module_depth\n-                        .get(&successor.module)\n+                        .get(&successor)\n                         .context(\"Module depth not found\")?,\n                     chunk_group_len: module_chunk_groups\n-                        .get(&successor.module)\n+                        .get(&successor)\n                         .context(\"Module chunk group not found\")?\n                         .len(),\n                 })"
        },
        {
            "sha": "1e33facf35e458a7079f5728a13de677776a7228",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/export_usage.rs",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fexport_usage.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fexport_usage.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fexport_usage.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -15,7 +15,7 @@ pub async fn compute_export_usage_info(\n     let mut used_exports = FxHashMap::<_, ModuleExportUsageInfo>::default();\n     let graph = graph.read_graphs().await?;\n     graph.traverse_all_edges_unordered(|(_, ref_data), target| {\n-        let e = used_exports.entry(target.module).or_default();\n+        let e = used_exports.entry(target).or_default();\n \n         e.add(&ref_data.export);\n \n@@ -40,7 +40,8 @@ pub async fn compute_export_usage_info(\n             // rare.  For vercel-site on 8/22/2025 there were 106 cycles covering 800 modules\n             // (or 1.2% of all modules).  So with this analysis we could potentially drop 80% of\n             // the cycle breaker modules.\n-            circuit_breakers.extend(cycle.iter().map(|n| n.module));\n+            circuit_breakers.extend(cycle.iter().map(|n| **n));\n+            Ok(())\n         },\n     )?;\n "
        },
        {
            "sha": "58e13706a4c11314b10525c20536b43e15ab33f2",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/merged_modules.rs",
            "status": "modified",
            "additions": 21,
            "deletions": 24,
            "changes": 45,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmerged_modules.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -12,8 +12,7 @@ use crate::{\n     },\n     module::Module,\n     module_graph::{\n-        GraphTraversalAction, ModuleGraph, RefData, SingleModuleGraphModuleNode,\n-        chunk_group_info::RoaringBitmapWrapper,\n+        GraphTraversalAction, ModuleGraph, RefData, chunk_group_info::RoaringBitmapWrapper,\n     },\n     resolve::ExportUsage,\n };\n@@ -99,11 +98,11 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                 |parent, node| {\n                     if let Some((parent, _)) = parent {\n                         let parent_depth = *module_depth\n-                            .get(&parent.module)\n+                            .get(&parent)\n                             .context(\"Module depth not found\")?;\n-                        module_depth.entry(node.module).or_insert(parent_depth + 1);\n+                        module_depth.entry(node).or_insert(parent_depth + 1);\n                     } else {\n-                        module_depth.insert(node.module, 0);\n+                        module_depth.insert(node, 0);\n                     };\n \n                     Ok(GraphTraversalAction::Continue)\n@@ -125,8 +124,7 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n         let mergeable = graphs\n             .iter()\n             .flat_map(|g| g.iter_nodes())\n-            .map(async |n| {\n-                let module = n.module;\n+            .map(async |module| {\n                 if let Some(mergeable) =\n                     ResolvedVc::try_downcast::<Box<dyn MergeableModule>>(module)\n                     && *mergeable.is_mergeable().await?\n@@ -150,22 +148,22 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                 .map(|e| Ok((*e, -*module_depth.get(e).context(\"Module depth not found\")?)))\n                 .collect::<Result<Vec<_>>>()?,\n             &mut (),\n-            |parent_info: Option<(&'_ SingleModuleGraphModuleNode, &'_ RefData)>,\n-             node: &'_ SingleModuleGraphModuleNode,\n+            |parent_info: Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n+             node: ResolvedVc<Box<dyn Module>>,\n              _|\n              -> Result<GraphTraversalAction> {\n                 // On the down traversal, establish which edges are mergeable and set the list\n                 // indices.\n                 let (parent_module, hoisted) = parent_info.map_or((None, false), |(node, ty)| {\n                     (\n-                        Some(node.module),\n+                        Some(node),\n                         match &ty.chunking_type {\n                             ChunkingType::Parallel { hoisted, .. } => *hoisted,\n                             _ => false,\n                         },\n                     )\n                 });\n-                let module = node.module;\n+                let module = node;\n \n                 Ok(if parent_module.is_some_and(|p| p == module) {\n                     // A self-reference\n@@ -181,9 +179,9 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n \n                     // A hoisted reference from a mergeable module to a non-async mergeable\n                     // module, inherit bitmaps from parent.\n-                    module_merged_groups.entry(node.module).or_default();\n+                    module_merged_groups.entry(node).or_default();\n                     let [Some(parent_merged_groups), Some(current_merged_groups)] =\n-                        module_merged_groups.get_disjoint_mut([&parent_module, &node.module])\n+                        module_merged_groups.get_disjoint_mut([&parent_module, &node])\n                     else {\n                         // All modules are inserted in the previous iteration\n                         bail!(\"unreachable except for eventual consistency\");\n@@ -227,7 +225,7 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                 // Invert the ordering here. High priority values get visited first, and we want to\n                 // visit the low-depth nodes first, as we are propagating bitmaps downwards.\n                 Ok(-*module_depth\n-                    .get(&successor.module)\n+                    .get(&successor)\n                     .context(\"Module depth not found\")?)\n             },\n         )?;\n@@ -332,15 +330,15 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                             &mut (),\n                             |parent_info, node, _| {\n                                 if parent_info.is_none_or(|(_, r)| r.chunking_type.is_parallel())\n-                                    && visited.insert(node.module)\n+                                    && visited.insert(node)\n                                 {\n                                     Ok(GraphTraversalAction::Continue)\n                                 } else {\n                                     Ok(GraphTraversalAction::Exclude)\n                                 }\n                             },\n                             |parent_info, node, _| {\n-                                let module = node.module;\n+                                let module = node;\n                                 let bitmap = module_merged_groups\n                                     .get(&module)\n                                     .context(\"every module should have a bitmap at this point\")?;\n@@ -383,15 +381,14 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n                                 }\n \n                                 if let Some((parent, _)) = parent_info {\n-                                    let same_bitmap =\n-                                        module_merged_groups.get(&parent.module).unwrap()\n-                                            == module_merged_groups.get(&module).unwrap();\n+                                    let same_bitmap = module_merged_groups.get(&parent).unwrap()\n+                                        == module_merged_groups.get(&module).unwrap();\n \n                                     if same_bitmap {\n                                         intra_group_references_rev\n                                             .entry(module)\n                                             .or_default()\n-                                            .insert(parent.module);\n+                                            .insert(parent);\n                                     }\n                                 }\n                                 Ok(())\n@@ -469,22 +466,22 @@ pub async fn compute_merged_modules(module_graph: Vc<ModuleGraph>) -> Result<Vc<\n             &mut (),\n             |_, _, _| Ok(GraphTraversalAction::Continue),\n             |parent_info, node, _| {\n-                let module = node.module;\n+                let module = node;\n \n                 if let Some((parent, _)) = parent_info {\n-                    let same_bitmap = module_merged_groups.get(&parent.module).unwrap()\n+                    let same_bitmap = module_merged_groups.get(&parent).unwrap()\n                         == module_merged_groups.get(&module).unwrap();\n \n                     if same_bitmap {\n                         intra_group_references\n-                            .entry(parent.module)\n+                            .entry(parent)\n                             .or_default()\n                             .insert(module);\n                     }\n                 }\n \n                 if parent_info.is_none_or(|(parent, _)| {\n-                    module_merged_groups.get(&parent.module).unwrap()\n+                    module_merged_groups.get(&parent).unwrap()\n                         != module_merged_groups.get(&module).unwrap()\n                 }) {\n                     // This module needs to be exposed:"
        },
        {
            "sha": "22c0ec1dddc07b957fd559be3d06893f4ece4287",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/mod.rs",
            "status": "modified",
            "additions": 262,
            "deletions": 587,
            "changes": 849,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmod.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -1,16 +1,14 @@\n+use core::panic;\n use std::{\n-    collections::{BinaryHeap, HashSet, VecDeque, hash_map::Entry},\n+    collections::{BinaryHeap, VecDeque, hash_map::Entry},\n     future::Future,\n };\n \n use anyhow::{Context, Result, bail};\n use auto_hash_map::AutoSet;\n use petgraph::{\n     graph::{DiGraph, EdgeIndex, NodeIndex},\n-    visit::{\n-        Dfs, EdgeRef, IntoNeighbors, IntoNodeReferences, NodeIndexable, Reversed, VisitMap,\n-        Visitable,\n-    },\n+    visit::{EdgeRef, IntoNeighbors, IntoNodeReferences, NodeIndexable, Reversed},\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n use serde::{Deserialize, Serialize};\n@@ -35,7 +33,7 @@ use crate::{\n         merged_modules::{MergedModuleInfo, compute_merged_modules},\n         module_batches::{ModuleBatchesGraph, compute_module_batches},\n         style_groups::{StyleGroups, StyleGroupsConfig, compute_style_groups},\n-        traced_di_graph::{TracedDiGraph, iter_neighbors_rev},\n+        traced_di_graph::TracedDiGraph,\n     },\n     reference::primary_chunkable_referenced_modules,\n     resolve::ExportUsage,\n@@ -95,9 +93,7 @@ impl VisitedModules {\n                 .await?\n                 .enumerate_nodes()\n                 .flat_map(|(node_idx, module)| match module {\n-                    SingleModuleGraphNode::Module(SingleModuleGraphModuleNode {\n-                        module, ..\n-                    }) => Some((\n+                    SingleModuleGraphNode::Module(module) => Some((\n                         *module,\n                         GraphNodeIndex {\n                             graph_idx: 0,\n@@ -132,10 +128,7 @@ impl VisitedModules {\n                 graph\n                     .enumerate_nodes()\n                     .flat_map(|(node_idx, module)| match module {\n-                        SingleModuleGraphNode::Module(SingleModuleGraphModuleNode {\n-                            module,\n-                            ..\n-                        }) => Some((\n+                        SingleModuleGraphNode::Module(module) => Some((\n                             *module,\n                             GraphNodeIndex {\n                                 graph_idx: self.next_graph_idx,\n@@ -287,9 +280,7 @@ impl SingleModuleGraph {\n                         let current_idx = if let Some(current_idx) = modules.get(&module) {\n                             *current_idx\n                         } else {\n-                            let idx = graph.add_node(SingleModuleGraphNode::Module(\n-                                SingleModuleGraphModuleNode { module },\n-                            ));\n+                            let idx = graph.add_node(SingleModuleGraphNode::Module(module));\n                             number_of_modules += 1;\n                             modules.insert(module, idx);\n                             idx\n@@ -330,11 +321,7 @@ impl SingleModuleGraph {\n                                     idx: *idx,\n                                     module: target,\n                                 },\n-                                None => {\n-                                    SingleModuleGraphNode::Module(SingleModuleGraphModuleNode {\n-                                        module: target,\n-                                    })\n-                                }\n+                                None => SingleModuleGraphNode::Module(target),\n                             });\n                             modules.insert(target, idx);\n                             idx\n@@ -385,17 +372,10 @@ impl SingleModuleGraph {\n         Ok(graph)\n     }\n \n-    fn get_module(&self, module: ResolvedVc<Box<dyn Module>>) -> Result<NodeIndex> {\n-        self.modules\n-            .get(&module)\n-            .copied()\n-            .context(\"Couldn't find module in graph\")\n-    }\n-\n     /// Iterate over all nodes in the graph\n-    pub fn iter_nodes(&self) -> impl Iterator<Item = &'_ SingleModuleGraphModuleNode> + '_ {\n+    pub fn iter_nodes(&self) -> impl Iterator<Item = ResolvedVc<Box<dyn Module>>> + '_ {\n         self.graph.node_weights().filter_map(|n| match n {\n-            SingleModuleGraphNode::Module(node) => Some(node),\n+            SingleModuleGraphNode::Module(node) => Some(*node),\n             SingleModuleGraphNode::VisitedModule { .. } => None,\n         })\n     }\n@@ -424,353 +404,18 @@ impl SingleModuleGraph {\n         self.graph.node_references()\n     }\n \n-    /// Traverses all reachable nodes (once)\n-    pub fn traverse_from_entry<'a>(\n-        &'a self,\n-        entry: ResolvedVc<Box<dyn Module>>,\n-        mut visitor: impl FnMut(&'a SingleModuleGraphModuleNode),\n-    ) -> Result<()> {\n-        let entry_node = self.get_module(entry)?;\n-\n-        let mut dfs = Dfs::new(&*self.graph, entry_node);\n-        while let Some(nx) = dfs.next(&*self.graph) {\n-            let SingleModuleGraphNode::Module(weight) = self.graph.node_weight(nx).unwrap() else {\n-                return Ok(());\n-            };\n-            // weight.emit_issues();\n-            visitor(weight);\n+    pub fn read(self: &ReadRef<SingleModuleGraph>) -> ModuleGraphRef {\n+        ModuleGraphRef {\n+            graphs: vec![self.clone()],\n+            skip_visited_module_children: true,\n         }\n-        Ok(())\n     }\n \n-    /// Traverses all reachable nodes once\n-    pub fn traverse_nodes_from_entries<'a, S>(\n-        &'a self,\n-        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n-        state: &mut S,\n-        visit_preorder: impl Fn(&'a SingleModuleGraphModuleNode, &mut S) -> Result<GraphTraversalAction>,\n-        mut visit_postorder: impl FnMut(&'a SingleModuleGraphModuleNode, &mut S) -> Result<()>,\n-    ) -> Result<()> {\n-        let graph = &self.graph;\n-        let entries = entries.into_iter().map(|e| self.get_module(e).unwrap());\n-\n-        enum Pass {\n-            Visit,\n-            ExpandAndVisit,\n-        }\n-\n-        let mut stack: Vec<(Pass, NodeIndex)> =\n-            entries.map(|e| (Pass::ExpandAndVisit, e)).collect();\n-        let mut expanded = FxHashSet::default();\n-        while let Some((pass, current)) = stack.pop() {\n-            match pass {\n-                Pass::Visit => {\n-                    if let SingleModuleGraphNode::Module(current_node) =\n-                        graph.node_weight(current).unwrap()\n-                    {\n-                        visit_postorder(current_node, state)?;\n-                    }\n-                }\n-                Pass::ExpandAndVisit => {\n-                    if expanded.insert(current)\n-                        && let SingleModuleGraphNode::Module(current_node) =\n-                            graph.node_weight(current).unwrap()\n-                    {\n-                        let action = visit_preorder(current_node, state)?;\n-                        if action == GraphTraversalAction::Exclude {\n-                            continue;\n-                        }\n-                        stack.push((Pass::Visit, current));\n-                        if action == GraphTraversalAction::Continue {\n-                            stack.extend(\n-                                iter_neighbors_rev(graph, current)\n-                                    .map(|(_, child)| (Pass::ExpandAndVisit, child)),\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Traverses all reachable edges exactly once and calls the visitor with the edge source and\n-    /// target.\n-    ///\n-    /// This means that target nodes can be revisited (once per incoming edge).\n-    ///\n-    /// * `entry` - The entry module to start the traversal from\n-    /// * `visitor` - Called before visiting the children of a node.\n-    ///    - Receives (originating &SingleModuleGraphNode, edge &ChunkingType), target\n-    ///      &SingleModuleGraphNode, state &S\n-    ///    - Can return [GraphTraversalAction]s to control the traversal\n-    pub fn traverse_edges_from_entries<'a>(\n-        &'a self,\n-        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n-        mut visitor: impl FnMut(\n-            Option<(&'a SingleModuleGraphModuleNode, &'a RefData)>,\n-            &'a SingleModuleGraphModuleNode,\n-        ) -> GraphTraversalAction,\n-    ) -> Result<()> {\n-        let graph = &self.graph;\n-        let entries = entries.into_iter().map(|e| self.get_module(e).unwrap());\n-\n-        let mut stack = entries.collect::<Vec<_>>();\n-        let mut discovered = graph.visit_map();\n-        // entry_weight.emit_issues();\n-        for entry_node in &stack {\n-            let SingleModuleGraphNode::Module(entry_weight) =\n-                graph.node_weight(*entry_node).unwrap()\n-            else {\n-                continue;\n-            };\n-            visitor(None, entry_weight);\n-        }\n-\n-        while let Some(node) = stack.pop() {\n-            let SingleModuleGraphNode::Module(node_weight) = graph.node_weight(node).unwrap()\n-            else {\n-                continue;\n-            };\n-            if discovered.visit(node) {\n-                let neighbors = {\n-                    let mut neighbors = vec![];\n-                    let mut walker = graph.neighbors(node).detach();\n-                    while let Some((edge, succ)) = walker.next(graph) {\n-                        neighbors.push((edge, succ));\n-                    }\n-                    neighbors\n-                };\n-\n-                for (edge, succ) in neighbors {\n-                    let SingleModuleGraphNode::Module(succ_weight) =\n-                        graph.node_weight(succ).unwrap()\n-                    else {\n-                        continue;\n-                    };\n-                    let edge_weight = graph.edge_weight(edge).unwrap();\n-                    let action = visitor(Some((node_weight, edge_weight)), succ_weight);\n-                    if !discovered.is_visited(&succ) && action == GraphTraversalAction::Continue {\n-                        stack.push(succ);\n-                    }\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Traverses all edges exactly once and calls the visitor with the edge source and\n-    /// target.\n-    ///\n-    /// This means that target nodes can be revisited (once per incoming edge).\n-    pub fn traverse_edges<'a>(\n-        &'a self,\n-        mut visitor: impl FnMut(\n-            (\n-                Option<(&'a SingleModuleGraphModuleNode, &'a RefData)>,\n-                &'a SingleModuleGraphModuleNode,\n-            ),\n-        ) -> GraphTraversalAction,\n-    ) -> Result<()> {\n-        let graph = &self.graph;\n-        let mut stack: Vec<NodeIndex> = self\n-            .entries\n-            .iter()\n-            .flat_map(|e| e.entries())\n-            .map(|e| *self.modules.get(&e).unwrap())\n-            .collect();\n-        let mut discovered = graph.visit_map();\n-        for entry_node in &stack {\n-            let SingleModuleGraphNode::Module(entry_node) = graph.node_weight(*entry_node).unwrap()\n-            else {\n-                continue;\n-            };\n-            visitor((None, entry_node));\n-        }\n-\n-        while let Some(node) = stack.pop() {\n-            if discovered.visit(node) {\n-                let SingleModuleGraphNode::Module(node_weight) = graph.node_weight(node).unwrap()\n-                else {\n-                    continue;\n-                };\n-                for edge in graph.edges(node).collect::<Vec<_>>() {\n-                    let edge_weight = edge.weight();\n-                    let succ = edge.target();\n-                    let SingleModuleGraphNode::Module(succ_weight) =\n-                        graph.node_weight(succ).unwrap()\n-                    else {\n-                        continue;\n-                    };\n-                    let action = visitor((Some((node_weight, edge_weight)), succ_weight));\n-                    if !discovered.is_visited(&succ) && action == GraphTraversalAction::Continue {\n-                        stack.push(succ);\n-                    }\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    /// Traverses all reachable nodes and also continue revisiting them as long the visitor returns\n-    /// GraphTraversalAction::Continue. The visitor is responsible for the runtime complexity and\n-    /// eventual termination of the traversal. This corresponds to computing a fixed point state for\n-    /// the graph.\n-    ///\n-    /// It is guaranteed that the parent node passed to the `visit` function, if any, has\n-    /// already been passed to `visit`.\n-    ///\n-    /// * `entries` - The entry modules to start the traversal from\n-    /// * `visit` - Called for a specific edge\n-    ///    - Receives: Option(originating &SingleModuleGraphNode, edge &ChunkingType), target\n-    ///      &SingleModuleGraphNode\n-    ///    - Return [GraphTraversalAction]s to control the traversal\n-    ///\n-    /// Returns the number of node visits (i.e. higher than the node\n-    /// count if there are retraversals).\n-    pub fn traverse_edges_from_entries_fixed_point<'a>(\n-        &'a self,\n-        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n-        mut visit: impl FnMut(\n-            Option<(&'a SingleModuleGraphModuleNode, &'a RefData)>,\n-            &'a SingleModuleGraphNode,\n-        ) -> Result<GraphTraversalAction>,\n-    ) -> Result<usize> {\n-        let mut queue = VecDeque::default();\n-        let mut queue_set = FxHashSet::default();\n-\n-        for module in entries {\n-            let index = self.get_module(module).unwrap();\n-            let action = visit(None, self.graph.node_weight(index).unwrap())?;\n-            if action == GraphTraversalAction::Continue && queue_set.insert(index) {\n-                queue.push_back(index);\n-            }\n-        }\n-\n-        let mut visit_count = 0;\n-        while let Some(index) = queue.pop_front() {\n-            queue_set.remove(&index);\n-            let node = match self.graph.node_weight(index).unwrap() {\n-                SingleModuleGraphNode::Module(single_module_graph_module_node) => {\n-                    single_module_graph_module_node\n-                }\n-                _ => {\n-                    continue; // we don't traverse into parent graphs\n-                }\n-            };\n-            visit_count += 1;\n-            for edge in self\n-                .graph\n-                .edges_directed(index, petgraph::Direction::Outgoing)\n-            {\n-                let refdata = edge.weight();\n-                let target_index = edge.target();\n-                let target = self.graph.node_weight(edge.target()).unwrap();\n-                let action = visit(Some((node, refdata)), target)?;\n-                if action == GraphTraversalAction::Continue && queue_set.insert(target_index) {\n-                    queue.push_back(target_index);\n-                }\n-            }\n-        }\n-\n-        Ok(visit_count)\n-    }\n-\n-    /// Traverses all reachable edges in dfs order. The preorder visitor can be used to\n-    /// forward state down the graph, and to skip subgraphs.\n-    ///\n-    /// Use this to collect modules in evaluation order.\n-    ///\n-    /// Target nodes can be revisited (once per incoming edge) in the preorder_visitor, in the post\n-    /// order visitor they are visited exactly once with the first edge they were discovered with.\n-    /// Edges are traversed in normal order, so should correspond to reference order.\n-    ///\n-    /// * `entries` - The entry modules to start the traversal from\n-    /// * `state` - The state to be passed to the visitors\n-    /// * `visit_preorder` - Called before visiting the children of a node.\n-    ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n-    ///      &SingleModuleGraphNode, state &S\n-    ///    - Can return [GraphTraversalAction]s to control the traversal\n-    /// * `visit_postorder` - Called after visiting the children of a node. Return\n-    ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n-    ///      &SingleModuleGraphNode, state &S\n-    pub fn traverse_edges_from_entries_dfs<'a, S>(\n-        &'a self,\n-        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n-        state: &mut S,\n-        mut visit_preorder: impl FnMut(\n-            Option<(&'a SingleModuleGraphModuleNode, &'a RefData)>,\n-            &'a SingleModuleGraphNode,\n-            &mut S,\n-        ) -> Result<GraphTraversalAction>,\n-        mut visit_postorder: impl FnMut(\n-            Option<(&'a SingleModuleGraphModuleNode, &'a RefData)>,\n-            &'a SingleModuleGraphNode,\n-            &mut S,\n-        ) -> Result<()>,\n-    ) -> Result<()> {\n-        let graph = &self.graph;\n-        let entries = entries.into_iter().map(|e| self.get_module(e).unwrap());\n-\n-        enum Pass {\n-            Visit,\n-            ExpandAndVisit,\n-        }\n-\n-        #[allow(clippy::type_complexity)] // This is a temporary internal structure\n-        let mut stack: Vec<(Pass, Option<(NodeIndex, EdgeIndex)>, NodeIndex)> =\n-            entries.map(|e| (Pass::ExpandAndVisit, None, e)).collect();\n-        let mut expanded = FxHashSet::default();\n-        while let Some((pass, parent, current)) = stack.pop() {\n-            let parent_arg = parent.map(|parent| {\n-                (\n-                    match graph.node_weight(parent.0).unwrap() {\n-                        SingleModuleGraphNode::Module(node) => node,\n-                        SingleModuleGraphNode::VisitedModule { .. } => {\n-                            unreachable!()\n-                        }\n-                    },\n-                    graph.edge_weight(parent.1).unwrap(),\n-                )\n-            });\n-            match pass {\n-                Pass::Visit => {\n-                    visit_postorder(parent_arg, graph.node_weight(current).unwrap(), state)?;\n-                }\n-                Pass::ExpandAndVisit => match graph.node_weight(current).unwrap() {\n-                    current_node @ SingleModuleGraphNode::Module(_) => {\n-                        let action = visit_preorder(parent_arg, current_node, state)?;\n-                        if action == GraphTraversalAction::Exclude {\n-                            continue;\n-                        }\n-                        stack.push((Pass::Visit, parent, current));\n-                        if action == GraphTraversalAction::Continue && expanded.insert(current) {\n-                            stack.extend(iter_neighbors_rev(graph, current).map(\n-                                |(edge, child)| {\n-                                    (Pass::ExpandAndVisit, Some((current, edge)), child)\n-                                },\n-                            ));\n-                        }\n-                    }\n-                    current_node @ SingleModuleGraphNode::VisitedModule { .. } => {\n-                        visit_preorder(parent_arg, current_node, state)?;\n-                        visit_postorder(parent_arg, current_node, state)?;\n-                    }\n-                },\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    pub fn traverse_cycles<'l>(\n+    fn traverse_cycles<'l>(\n         &'l self,\n         edge_filter: impl Fn(&'l RefData) -> bool,\n-        mut visit_cycle: impl FnMut(&[&'l SingleModuleGraphModuleNode]),\n-    ) {\n+        mut visit_cycle: impl FnMut(&[&'l ResolvedVc<Box<dyn Module>>]) -> Result<()>,\n+    ) -> Result<()> {\n         // see https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n         // but iteratively instead of recursively\n \n@@ -853,14 +498,15 @@ impl SingleModuleGraph {\n                                 }\n                             }\n                             if scc.len() > 1 {\n-                                visit_cycle(&scc);\n+                                visit_cycle(&scc)?;\n                             }\n                             scc.clear();\n                         }\n                     }\n                 }\n             }\n         }\n+        Ok(())\n     }\n \n     /// For each issue computes a (possibly empty) list of traces from the file that produced the\n@@ -1162,90 +808,31 @@ impl ModuleGraph {\n         let async_modules_info = self.async_module_info().await?;\n \n         let entry = graph_ref.get_entry(module)?;\n-        let referenced_modules =\n-            iter_neighbors_rev(&graphs[entry.graph_idx()].graph, entry.node_idx)\n-                .filter(|(edge_idx, _)| {\n-                    let ty = graphs[entry.graph_idx()]\n-                        .graph\n-                        .edge_weight(*edge_idx)\n-                        .unwrap();\n-                    ty.chunking_type.is_inherit_async()\n-                })\n-                .map(|(_, child_idx)| {\n-                    anyhow::Ok(\n-                        get_node!(\n-                            graphs,\n-                            GraphNodeIndex {\n-                                graph_idx: entry.graph_idx,\n-                                node_idx: child_idx\n-                            }\n-                        )?\n-                        .module,\n-                    )\n-                })\n-                .collect::<Result<Vec<_>>>()?\n-                .into_iter()\n-                .rev()\n-                .filter(|m| async_modules_info.contains(m))\n-                .map(|m| *m)\n-                .collect();\n+        let referenced_modules = iter_graphs_neighbors_rev(graphs, entry)\n+            .filter(|(edge_idx, _)| {\n+                let ty = graphs[entry.graph_idx()]\n+                    .graph\n+                    .edge_weight(*edge_idx)\n+                    .unwrap();\n+                ty.chunking_type.is_inherit_async()\n+            })\n+            .map(|(_, child_idx)| anyhow::Ok(graph_ref.get_node(child_idx)?.module()))\n+            .collect::<Result<Vec<_>>>()?\n+            .into_iter()\n+            .rev()\n+            .filter(|m| async_modules_info.contains(m))\n+            .map(|m| *m)\n+            .collect();\n \n         Ok(AsyncModuleInfo::new(referenced_modules))\n     }\n }\n \n-// fn get_node<T>(\n-//     graphs: Vec<ReadRef<SingleModuleGraph>>,\n-//     node: GraphNodeIndex,\n-// ) -> Result<&'static SingleModuleGraphModuleNode> {\n-macro_rules! get_node {\n-    ($graphs:expr, $node:expr) => {{\n-        let node_idx = $node;\n-        match $graphs[node_idx.graph_idx()]\n-            .graph\n-            .node_weight(node_idx.node_idx)\n-        {\n-            Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok(node),\n-            Some(SingleModuleGraphNode::VisitedModule { idx, .. }) => {\n-                match $graphs[idx.graph_idx()].graph.node_weight(idx.node_idx) {\n-                    Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok(node),\n-                    Some(SingleModuleGraphNode::VisitedModule { .. }) => Err(::anyhow::anyhow!(\n-                        \"Expected visited target node to be module\"\n-                    )),\n-                    None => Err(::anyhow::anyhow!(\"Expected visited target node\")),\n-                }\n-            }\n-            None => Err(::anyhow::anyhow!(\"Expected graph node\")),\n-        }\n-    }};\n-}\n-pub(crate) use get_node;\n-macro_rules! get_node_idx {\n-    ($graphs:expr, $node:expr) => {{\n-        let node_idx = $node;\n-        match $graphs[node_idx.graph_idx()]\n-            .graph\n-            .node_weight(node_idx.node_idx)\n-        {\n-            Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok((node, node_idx)),\n-            Some(SingleModuleGraphNode::VisitedModule { idx, .. }) => {\n-                match $graphs[idx.graph_idx()].graph.node_weight(idx.node_idx) {\n-                    Some(SingleModuleGraphNode::Module(node)) => ::anyhow::Ok((node, *idx)),\n-                    Some(SingleModuleGraphNode::VisitedModule { .. }) => Err(::anyhow::anyhow!(\n-                        \"Expected visited target node to be module\"\n-                    )),\n-                    None => Err(::anyhow::anyhow!(\"Expected visited target node\")),\n-                }\n-            }\n-            None => Err(::anyhow::anyhow!(\"Expected graph node\")),\n-        }\n-    }};\n-}\n-\n impl ModuleGraph {\n     pub async fn read_graphs(self: Vc<ModuleGraph>) -> Result<ModuleGraphRef> {\n         Ok(ModuleGraphRef {\n             graphs: self.await?.graphs.iter().try_join().await?,\n+            skip_visited_module_children: false,\n         })\n     }\n }\n@@ -1254,6 +841,9 @@ impl ModuleGraph {\n /// aren't awaited multiple times within the same task.\n pub struct ModuleGraphRef {\n     pub graphs: Vec<ReadRef<SingleModuleGraph>>,\n+    // Whether to simply ignore SingleModuleGraphNode::VisitedModule during traversals. For single\n+    // module graph usecases, this is what you want. For the whole graph, there should be an error.\n+    skip_visited_module_children: bool,\n }\n \n impl ModuleGraphRef {\n@@ -1274,20 +864,95 @@ impl ModuleGraphRef {\n         Ok(idx)\n     }\n \n+    fn get_node(&self, entry: GraphNodeIndex) -> Result<&SingleModuleGraphNode> {\n+        let graph = &self.graphs[entry.graph_idx()];\n+        graph\n+            .graph\n+            .node_weight(entry.node_idx)\n+            .context(\"Expected graph node\")\n+    }\n+\n+    fn should_visit_node(&self, node: &SingleModuleGraphNode) -> bool {\n+        if self.skip_visited_module_children {\n+            !matches!(node, SingleModuleGraphNode::VisitedModule { .. })\n+        } else {\n+            true\n+        }\n+    }\n+\n     /// Returns a map of all modules in the graphs to their identifiers.\n     /// This is primarily useful for debugging.\n     pub async fn get_ids(&self) -> Result<FxHashMap<ResolvedVc<Box<dyn Module>>, ReadRef<RcStr>>> {\n         Ok(self\n             .graphs\n             .iter()\n             .flat_map(|g| g.iter_nodes())\n-            .map(async |n| Ok((n.module, n.module.ident().to_string().await?)))\n+            .map(async |n| Ok((n, n.ident().to_string().await?)))\n             .try_join()\n             .await?\n             .into_iter()\n             .collect::<FxHashMap<_, _>>())\n     }\n \n+    /// Traverses all reachable nodes exactly once and calls the visitor.\n+    ///\n+    /// * `entries` - The entry modules to start the traversal from\n+    /// * `state` mutable state to be shared across the visitors\n+    /// * `visit_preorder` - Called before visiting the children of a node.\n+    ///    - Receives the module and the `state`\n+    ///    - Can return [GraphTraversalAction]s to control the traversal\n+    /// * `visit_postorder` - Called after visiting children of a node.\n+    pub fn traverse_nodes_from_entries_dfs<S>(\n+        &self,\n+        entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n+        state: &mut S,\n+        visit_preorder: impl Fn(ResolvedVc<Box<dyn Module>>, &mut S) -> Result<GraphTraversalAction>,\n+        mut visit_postorder: impl FnMut(ResolvedVc<Box<dyn Module>>, &mut S) -> Result<()>,\n+    ) -> Result<()> {\n+        let graphs = &self.graphs;\n+\n+        let entries = entries.into_iter().collect::<Vec<_>>();\n+\n+        enum Pass {\n+            Visit,\n+            ExpandAndVisit,\n+        }\n+        let mut stack: Vec<(Pass, GraphNodeIndex)> = Vec::with_capacity(entries.len());\n+        for entry in entries.into_iter().rev() {\n+            stack.push((Pass::ExpandAndVisit, self.get_entry(entry)?));\n+        }\n+        let mut expanded = FxHashSet::default();\n+        while let Some((pass, current)) = stack.pop() {\n+            let current_node = self.get_node(current)?;\n+            match pass {\n+                Pass::Visit => {\n+                    visit_postorder(current_node.module(), state)?;\n+                }\n+                Pass::ExpandAndVisit => {\n+                    if !expanded.insert(current) {\n+                        continue;\n+                    }\n+                    let action = visit_preorder(current_node.module(), state)?;\n+                    if action == GraphTraversalAction::Exclude {\n+                        continue;\n+                    }\n+                    stack.push((Pass::Visit, current));\n+                    if action == GraphTraversalAction::Continue\n+                        && self.should_visit_node(current_node)\n+                    {\n+                        let current = current_node.target_idx().unwrap_or(current);\n+                        stack.extend(\n+                            iter_graphs_neighbors_rev(graphs, current)\n+                                .map(|(_, child)| (Pass::ExpandAndVisit, child)),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n     /// Traverses all reachable edges exactly once and calls the visitor with the edge source and\n     /// target.\n     ///\n@@ -1302,8 +967,8 @@ impl ModuleGraphRef {\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         mut visitor: impl FnMut(\n-            Option<(&'_ SingleModuleGraphModuleNode, &'_ RefData)>,\n-            &'_ SingleModuleGraphModuleNode,\n+            Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n+            ResolvedVc<Box<dyn Module>>,\n         ) -> Result<GraphTraversalAction>,\n     ) -> Result<()> {\n         let graphs = &self.graphs;\n@@ -1314,24 +979,25 @@ impl ModuleGraphRef {\n                 .map(|e| self.get_entry(e))\n                 .collect::<Result<Vec<_>>>()?,\n         );\n-        let mut visited = HashSet::new();\n+        let mut visited = FxHashSet::default();\n         for entry_node in &queue {\n-            visitor(None, get_node!(graphs, entry_node)?)?;\n+            visitor(None, self.get_node(*entry_node)?.module())?;\n         }\n         while let Some(node) = queue.pop_front() {\n-            let graph = &graphs[node.graph_idx()].graph;\n-            let node_weight = get_node!(graphs, node)?;\n             if visited.insert(node) {\n-                let neighbors = iter_neighbors_rev(graph, node.node_idx);\n-\n-                for (edge, succ) in neighbors {\n-                    let succ = GraphNodeIndex {\n-                        graph_idx: node.graph_idx,\n-                        node_idx: succ,\n-                    };\n-                    let succ_weight = get_node!(graphs, succ)?;\n+                let node_weight = self.get_node(node)?;\n+                let graph = &graphs[node.graph_idx()].graph;\n+                for (edge, succ) in iter_graphs_neighbors_rev(graphs, node) {\n+                    let succ_weight = self.get_node(succ)?;\n                     let edge_weight = graph.edge_weight(edge).unwrap();\n-                    let action = visitor(Some((node_weight, edge_weight)), succ_weight)?;\n+                    let action = visitor(\n+                        Some((node_weight.module(), edge_weight)),\n+                        succ_weight.module(),\n+                    )?;\n+                    if !self.should_visit_node(succ_weight) {\n+                        continue;\n+                    }\n+                    let succ = succ_weight.target_idx().unwrap_or(succ);\n                     if !visited.contains(&succ) && action == GraphTraversalAction::Continue {\n                         queue.push_back(succ);\n                     }\n@@ -1352,39 +1018,39 @@ impl ModuleGraphRef {\n     ///    - Receives (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode, state &S\n     ///    - Can return [GraphTraversalAction]s to control the traversal\n-    pub fn traverse_edges_from_entry(\n+    pub fn traverse_edges_from_entry_dfs(\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         mut visitor: impl FnMut(\n-            Option<(&'_ SingleModuleGraphModuleNode, &'_ RefData)>,\n-            &'_ SingleModuleGraphModuleNode,\n+            Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n+            ResolvedVc<Box<dyn Module>>,\n         ) -> GraphTraversalAction,\n     ) -> Result<()> {\n         let graphs = &self.graphs;\n \n-        let entries = entries.into_iter();\n-        let mut stack = Vec::with_capacity(entries.size_hint().0);\n-        for entry in entries {\n-            stack.push(self.get_entry(entry)?);\n-        }\n-        let mut visited = HashSet::new();\n+        let mut stack = entries\n+            .into_iter()\n+            .map(|e| self.get_entry(e))\n+            .collect::<Result<Vec<_>>>()?;\n+        let mut visited = FxHashSet::default();\n         for entry_node in &stack {\n-            visitor(None, get_node!(graphs, entry_node)?);\n+            visitor(None, self.get_node(*entry_node)?.module());\n         }\n         while let Some(node) = stack.pop() {\n-            let graph = &graphs[node.graph_idx()].graph;\n-            let node_weight = get_node!(graphs, node)?;\n             if visited.insert(node) {\n-                let neighbors = iter_neighbors_rev(graph, node.node_idx);\n-\n-                for (edge, succ) in neighbors {\n-                    let succ = GraphNodeIndex {\n-                        graph_idx: node.graph_idx,\n-                        node_idx: succ,\n-                    };\n-                    let succ_weight = get_node!(graphs, succ)?;\n+                let node_weight = self.get_node(node)?;\n+                let graph = &graphs[node.graph_idx()].graph;\n+                for (edge, succ) in iter_graphs_neighbors_rev(graphs, node) {\n+                    let succ_weight = self.get_node(succ)?;\n                     let edge_weight = graph.edge_weight(edge).unwrap();\n-                    let action = visitor(Some((node_weight, edge_weight)), succ_weight);\n+                    let action = visitor(\n+                        Some((node_weight.module(), edge_weight)),\n+                        succ_weight.module(),\n+                    );\n+                    if !self.should_visit_node(succ_weight) {\n+                        continue;\n+                    }\n+                    let succ = succ_weight.target_idx().unwrap_or(succ);\n                     if !visited.contains(&succ) && action == GraphTraversalAction::Continue {\n                         stack.push(succ);\n                     }\n@@ -1406,27 +1072,18 @@ impl ModuleGraphRef {\n     pub fn traverse_all_edges_unordered(\n         &self,\n         mut visitor: impl FnMut(\n-            (&'_ SingleModuleGraphModuleNode, &'_ RefData),\n-            &'_ SingleModuleGraphModuleNode,\n+            (ResolvedVc<Box<dyn Module>>, &'_ RefData),\n+            ResolvedVc<Box<dyn Module>>,\n         ) -> Result<()>,\n     ) -> Result<()> {\n-        let graphs = &self.graphs;\n-\n-        for graph in graphs {\n+        for graph in &self.graphs {\n             let graph = &graph.graph;\n             for edge in graph.edge_references() {\n-                let source = match graph.node_weight(edge.source()).unwrap() {\n-                    SingleModuleGraphNode::Module(node) => node,\n-                    SingleModuleGraphNode::VisitedModule { .. } => unreachable!(),\n-                };\n-                let target = match graph.node_weight(edge.target()).unwrap() {\n-                    SingleModuleGraphNode::Module(node) => node,\n-                    SingleModuleGraphNode::VisitedModule { idx, .. } => get_node!(graphs, idx)?,\n-                };\n+                let source = graph.node_weight(edge.source()).unwrap().module();\n+                let target = graph.node_weight(edge.target()).unwrap().module();\n                 visitor((source, edge.weight()), target)?;\n             }\n         }\n-\n         Ok(())\n     }\n \n@@ -1448,19 +1105,18 @@ impl ModuleGraphRef {\n     /// * `visit_postorder` - Called after visiting the children of a node. Return\n     ///    - Receives: (originating &SingleModuleGraphNode, edge &ChunkingType), target\n     ///      &SingleModuleGraphNode, state &S\n-    ///    - Can return [GraphTraversalAction]s to control the traversal\n     pub fn traverse_edges_from_entries_dfs<S>(\n         &self,\n         entries: impl IntoIterator<Item = ResolvedVc<Box<dyn Module>>>,\n         state: &mut S,\n         mut visit_preorder: impl FnMut(\n-            Option<(&'_ SingleModuleGraphModuleNode, &'_ RefData)>,\n-            &'_ SingleModuleGraphModuleNode,\n+            Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n+            ResolvedVc<Box<dyn Module>>,\n             &mut S,\n         ) -> Result<GraphTraversalAction>,\n         mut visit_postorder: impl FnMut(\n-            Option<(&'_ SingleModuleGraphModuleNode, &'_ RefData)>,\n-            &'_ SingleModuleGraphModuleNode,\n+            Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n+            ResolvedVc<Box<dyn Module>>,\n             &mut S,\n         ) -> Result<()>,\n     ) -> Result<()> {\n@@ -1478,54 +1134,37 @@ impl ModuleGraphRef {\n         for entry in entries.into_iter().rev() {\n             stack.push((Pass::ExpandAndVisit, None, self.get_entry(entry)?));\n         }\n-        let mut expanded = HashSet::new();\n+        let mut expanded = FxHashSet::default();\n         while let Some((pass, parent, current)) = stack.pop() {\n             let parent_arg = match parent {\n                 Some((parent_node, parent_edge)) => Some((\n-                    get_node!(graphs, parent_node)?,\n+                    self.get_node(parent_node)?.module(),\n                     graphs[parent_node.graph_idx()]\n                         .graph\n                         .edge_weight(parent_edge)\n                         .unwrap(),\n                 )),\n                 None => None,\n             };\n-            let current_node = get_node!(graphs, current)?;\n+            let current_node = self.get_node(current)?;\n             match pass {\n                 Pass::Visit => {\n-                    visit_postorder(parent_arg, current_node, state)?;\n+                    visit_postorder(parent_arg, current_node.module(), state)?;\n                 }\n                 Pass::ExpandAndVisit => {\n-                    let action = visit_preorder(parent_arg, current_node, state)?;\n+                    let action = visit_preorder(parent_arg, current_node.module(), state)?;\n                     if action == GraphTraversalAction::Exclude {\n                         continue;\n                     }\n                     stack.push((Pass::Visit, parent, current));\n-                    if action == GraphTraversalAction::Continue && expanded.insert(current) {\n-                        let graph = &graphs[current.graph_idx()].graph;\n-                        let (neighbors_rev, current) = match graph\n-                            .node_weight(current.node_idx)\n-                            .unwrap()\n-                        {\n-                            SingleModuleGraphNode::Module(_) => {\n-                                (iter_neighbors_rev(graph, current.node_idx), current)\n-                            }\n-                            SingleModuleGraphNode::VisitedModule { idx, .. } => (\n-                                // We switch graphs\n-                                iter_neighbors_rev(&graphs[idx.graph_idx()].graph, idx.node_idx),\n-                                *idx,\n-                            ),\n-                        };\n-                        stack.extend(neighbors_rev.map(|(edge, child)| {\n-                            (\n-                                Pass::ExpandAndVisit,\n-                                Some((current, edge)),\n-                                GraphNodeIndex {\n-                                    graph_idx: current.graph_idx,\n-                                    node_idx: child,\n-                                },\n-                            )\n-                        }));\n+                    if action == GraphTraversalAction::Continue\n+                        && expanded.insert(current)\n+                        && self.should_visit_node(current_node)\n+                    {\n+                        let current = current_node.target_idx().unwrap_or(current);\n+                        stack.extend(iter_graphs_neighbors_rev(graphs, current).map(\n+                            |(edge, child)| (Pass::ExpandAndVisit, Some((current, edge)), child),\n+                        ));\n                     }\n                 }\n             }\n@@ -1539,10 +1178,10 @@ impl ModuleGraphRef {\n     pub fn traverse_cycles(\n         &self,\n         edge_filter: impl Fn(&RefData) -> bool,\n-        mut visit_cycle: impl FnMut(&[&SingleModuleGraphModuleNode]),\n+        mut visit_cycle: impl FnMut(&[&ResolvedVc<Box<dyn Module>>]) -> Result<()>,\n     ) -> Result<()> {\n         for graph in &self.graphs {\n-            graph.traverse_cycles(&edge_filter, &mut visit_cycle);\n+            graph.traverse_cycles(&edge_filter, &mut visit_cycle)?;\n         }\n         Ok(())\n     }\n@@ -1573,13 +1212,18 @@ impl ModuleGraphRef {\n         entries: impl IntoIterator<Item = (ResolvedVc<Box<dyn Module>>, P)>,\n         state: &mut S,\n         mut visit: impl FnMut(\n-            Option<(&'_ SingleModuleGraphModuleNode, &'_ RefData)>,\n-            &'_ SingleModuleGraphModuleNode,\n+            Option<(ResolvedVc<Box<dyn Module>>, &'_ RefData)>,\n+            ResolvedVc<Box<dyn Module>>,\n             &mut S,\n         ) -> Result<GraphTraversalAction>,\n-        priority: impl Fn(&'_ SingleModuleGraphModuleNode, &mut S) -> Result<P>,\n+        priority: impl Fn(ResolvedVc<Box<dyn Module>>, &mut S) -> Result<P>,\n     ) -> Result<usize> {\n         let graphs = &self.graphs;\n+        if self.skip_visited_module_children {\n+            panic!(\n+                \"traverse_edges_fixed_point_with_priority musn't be called on individual graphs\"\n+            );\n+        }\n \n         #[derive(PartialEq, Eq)]\n         struct NodeWithPriority<T: Ord> {\n@@ -1616,31 +1260,33 @@ impl ModuleGraphRef {\n         );\n \n         for entry_node in &queue {\n-            visit(None, get_node!(graphs, entry_node.node)?, state)?;\n+            visit(None, self.get_node(entry_node.node)?.module(), state)?;\n         }\n \n         let mut visit_count = 0usize;\n         while let Some(NodeWithPriority { node, .. }) = queue.pop() {\n             queue_set.remove(&node);\n-            let (node_weight, node) = get_node_idx!(graphs, node)?;\n-            let graph = &graphs[node.graph_idx()].graph;\n-            let neighbors = iter_neighbors_rev(graph, node.node_idx);\n+            let node_weight = self.get_node(node)?;\n+            let node = node_weight.target_idx().unwrap_or(node);\n \n             visit_count += 1;\n \n-            for (edge, succ) in neighbors {\n-                let succ = GraphNodeIndex {\n-                    graph_idx: node.graph_idx,\n-                    node_idx: succ,\n-                };\n-                let (succ_weight, succ) = get_node_idx!(graphs, succ)?;\n+            let graph = &graphs[node.graph_idx()].graph;\n+            for (edge, succ) in iter_graphs_neighbors_rev(graphs, node) {\n+                let succ_weight = self.get_node(succ)?;\n+\n                 let edge_weight = graph.edge_weight(edge).unwrap();\n-                let action = visit(Some((node_weight, edge_weight)), succ_weight, state)?;\n+                let action = visit(\n+                    Some((node_weight.module(), edge_weight)),\n+                    succ_weight.module(),\n+                    state,\n+                )?;\n \n+                let succ = succ_weight.target_idx().unwrap_or(succ);\n                 if action == GraphTraversalAction::Continue && queue_set.insert(succ) {\n                     queue.push(NodeWithPriority {\n                         node: succ,\n-                        priority: priority(succ_weight, state)?,\n+                        priority: priority(succ_weight.module(), state)?,\n                     });\n                 }\n             }\n@@ -1650,6 +1296,34 @@ impl ModuleGraphRef {\n     }\n }\n \n+/// Iterate the edges of a node REVERSED!\n+fn iter_graphs_neighbors_rev(\n+    graphs: &[ReadRef<SingleModuleGraph>],\n+    node: GraphNodeIndex,\n+) -> impl Iterator<Item = (EdgeIndex, GraphNodeIndex)> + '_ {\n+    let graph = &*graphs[node.graph_idx()].graph;\n+\n+    if cfg!(debug_assertions) {\n+        let node_weight = graph.node_weight(node.node_idx).unwrap();\n+        if let SingleModuleGraphNode::VisitedModule { .. } = node_weight {\n+            panic!(\"iter_graphs_neighbors_rev called on VisitedModule node\");\n+        }\n+    }\n+\n+    let mut walker = graph.neighbors(node.node_idx).detach();\n+    std::iter::from_fn(move || {\n+        walker.next(graph).map(|(edge_idx, succ_idx)| {\n+            (\n+                edge_idx,\n+                GraphNodeIndex {\n+                    graph_idx: node.graph_idx,\n+                    node_idx: succ_idx,\n+                },\n+            )\n+        })\n+    })\n+}\n+\n #[turbo_tasks::value_impl]\n impl SingleModuleGraph {\n     #[turbo_tasks::function]\n@@ -1686,14 +1360,9 @@ impl SingleModuleGraph {\n     }\n }\n \n-#[derive(Clone, Debug, Serialize, Deserialize, TraceRawVcs, NonLocalValue)]\n-pub struct SingleModuleGraphModuleNode {\n-    pub module: ResolvedVc<Box<dyn Module>>,\n-}\n-\n #[derive(Clone, Debug, Serialize, Deserialize, TraceRawVcs, NonLocalValue)]\n pub enum SingleModuleGraphNode {\n-    Module(SingleModuleGraphModuleNode),\n+    Module(ResolvedVc<Box<dyn Module>>),\n     // Models a module that is referenced but has already been visited by an earlier graph.\n     VisitedModule {\n         idx: GraphNodeIndex,\n@@ -1704,10 +1373,16 @@ pub enum SingleModuleGraphNode {\n impl SingleModuleGraphNode {\n     pub fn module(&self) -> ResolvedVc<Box<dyn Module>> {\n         match self {\n-            SingleModuleGraphNode::Module(SingleModuleGraphModuleNode { module }) => *module,\n+            SingleModuleGraphNode::Module(module) => *module,\n             SingleModuleGraphNode::VisitedModule { module, .. } => *module,\n         }\n     }\n+    pub fn target_idx(&self) -> Option<GraphNodeIndex> {\n+        match self {\n+            SingleModuleGraphNode::VisitedModule { idx, .. } => Some(*idx),\n+            SingleModuleGraphNode::Module(_) => None,\n+        }\n+    }\n }\n \n #[derive(PartialEq, Eq, Debug)]\n@@ -1956,7 +1631,7 @@ pub mod tests {\n     use anyhow::Result;\n     use rustc_hash::FxHashMap;\n     use turbo_rcstr::{RcStr, rcstr};\n-    use turbo_tasks::{ReadRef, ResolvedVc, TryJoinIterExt, Vc};\n+    use turbo_tasks::{ResolvedVc, TryJoinIterExt, Vc};\n     use turbo_tasks_backend::{BackendOptions, TurboTasksBackend, noop_backing_storage};\n     use turbo_tasks_fs::{FileSystem, FileSystemPath, VirtualFileSystem};\n \n@@ -1965,15 +1640,15 @@ pub mod tests {\n         ident::AssetIdent,\n         module::Module,\n         module_graph::{\n-            GraphEntries, GraphTraversalAction, SingleModuleGraph,\n+            GraphEntries, GraphTraversalAction, ModuleGraph, ModuleGraphRef, SingleModuleGraph,\n             chunk_group_info::ChunkGroupEntry,\n         },\n         reference::{ModuleReference, ModuleReferences, SingleChunkableModuleReference},\n         resolve::ExportUsage,\n     };\n \n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n-    async fn traverse_dfs_from_entries_diamond() {\n+    async fn test_traverse_dfs_from_entries_diamond() {\n         run_graph_test(\n             vec![rcstr!(\"a.js\")],\n             {\n@@ -1993,17 +1668,15 @@ pub mod tests {\n                     &mut (),\n                     |parent, target, _| {\n                         preorder_visits.push((\n-                            parent\n-                                .map(|(node, _)| module_to_name.get(&node.module).unwrap().clone()),\n-                            module_to_name.get(&target.module()).unwrap().clone(),\n+                            parent.map(|(node, _)| module_to_name.get(&node).unwrap().clone()),\n+                            module_to_name.get(&target).unwrap().clone(),\n                         ));\n                         Ok(GraphTraversalAction::Continue)\n                     },\n                     |parent, target, _| {\n                         postorder_visits.push((\n-                            parent\n-                                .map(|(node, _)| module_to_name.get(&node.module).unwrap().clone()),\n-                            module_to_name.get(&target.module()).unwrap().clone(),\n+                            parent.map(|(node, _)| module_to_name.get(&node).unwrap().clone()),\n+                            module_to_name.get(&target).unwrap().clone(),\n                         ));\n                         Ok(())\n                     },\n@@ -2035,7 +1708,7 @@ pub mod tests {\n     }\n \n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n-    async fn traverse_dfs_from_entries_cycle() {\n+    async fn test_traverse_dfs_from_entries_cycle() {\n         run_graph_test(\n             vec![rcstr!(\"a.js\")],\n             {\n@@ -2055,17 +1728,15 @@ pub mod tests {\n                     &mut (),\n                     |parent, target, _| {\n                         preorder_visits.push((\n-                            parent\n-                                .map(|(node, _)| module_to_name.get(&node.module).unwrap().clone()),\n-                            module_to_name.get(&target.module()).unwrap().clone(),\n+                            parent.map(|(node, _)| module_to_name.get(&node).unwrap().clone()),\n+                            module_to_name.get(&target).unwrap().clone(),\n                         ));\n                         Ok(GraphTraversalAction::Continue)\n                     },\n                     |parent, target, _| {\n                         postorder_visits.push((\n-                            parent\n-                                .map(|(node, _)| module_to_name.get(&node.module).unwrap().clone()),\n-                            module_to_name.get(&target.module()).unwrap().clone(),\n+                            parent.map(|(node, _)| module_to_name.get(&node).unwrap().clone()),\n+                            module_to_name.get(&target).unwrap().clone(),\n                         ));\n                         Ok(())\n                     },\n@@ -2095,7 +1766,7 @@ pub mod tests {\n     }\n \n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n-    async fn traverse_edges_from_entries_fixed_point_cycle() {\n+    async fn test_traverse_edges_fixed_point_with_priority_cycle() {\n         run_graph_test(\n             vec![rcstr!(\"a.js\")],\n             {\n@@ -2110,13 +1781,13 @@ pub mod tests {\n                 let mut visits = Vec::new();\n                 let mut count = 0;\n \n-                graph.traverse_edges_from_entries_fixed_point(\n-                    entry_modules,\n-                    |parent, target| {\n+                graph.traverse_edges_fixed_point_with_priority(\n+                    entry_modules.into_iter().map(|m| (m, 0)),\n+                    &mut (),\n+                    |parent, target, _| {\n                         visits.push((\n-                            parent\n-                                .map(|(node, _)| module_to_name.get(&node.module).unwrap().clone()),\n-                            module_to_name.get(&target.module()).unwrap().clone(),\n+                            parent.map(|(node, _)| module_to_name.get(&node).unwrap().clone()),\n+                            module_to_name.get(&target).unwrap().clone(),\n                         ));\n                         count += 1;\n \n@@ -2127,6 +1798,7 @@ pub mod tests {\n                             GraphTraversalAction::Skip\n                         })\n                     },\n+                    |_, _| Ok(0),\n                 )?;\n                 assert_eq!(\n                     vec![\n@@ -2221,7 +1893,7 @@ pub mod tests {\n         entries: Vec<RcStr>,\n         graph: FxHashMap<RcStr, Vec<RcStr>>,\n         test_fn: impl FnOnce(\n-            ReadRef<SingleModuleGraph>,\n+            ModuleGraphRef,\n             Vec<ResolvedVc<Box<dyn Module>>>,\n             FxHashMap<ResolvedVc<Box<dyn Module>>, RcStr>,\n         ) -> Result<()>\n@@ -2261,22 +1933,25 @@ pub mod tests {\n                     entry_modules.clone(),\n                 )])),\n                 false,\n-            )\n-            .await?;\n+            );\n \n             // Create a simple name mapping to make analyzing the visitors easier.\n             // Technically they could always pull this name off of the\n-            // `module.ident().await?.path.path` themselves but that `await` is trick in the\n-            // visitors so precomputing this helps.\n+            // `module.ident().await?.path.path` themselves but you cannot `await` in visitors.\n             let module_to_name = graph\n+                .await?\n                 .modules\n                 .keys()\n                 .map(|m| async move { Ok((*m, m.ident().await?.path.path.clone())) })\n                 .try_join()\n                 .await?\n                 .into_iter()\n                 .collect();\n-            test_fn(graph, entry_modules, module_to_name)\n+            test_fn(\n+                ModuleGraph::from_single_graph(graph).read_graphs().await?,\n+                entry_modules,\n+                module_to_name,\n+            )\n         })\n         .await\n         .unwrap();"
        },
        {
            "sha": "ec33427329202c37814201a9039c1469a8ca55c2",
            "filename": "turbopack/crates/turbopack-core/src/module_graph/module_batches.rs",
            "status": "modified",
            "additions": 8,
            "deletions": 7,
            "changes": 15,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-core%2Fsrc%2Fmodule_graph%2Fmodule_batches.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -295,7 +295,7 @@ impl PreBatches {\n                     },\n                     |(_, ty)| &ty.chunking_type,\n                 );\n-                let module = node.module;\n+                let module = node;\n                 if !ty.is_parallel() {\n                     state.items.push(PreBatchItem::NonParallelEdge(\n                         ty.without_inherit_async(),\n@@ -319,7 +319,7 @@ impl PreBatches {\n                 }\n             },\n             |_, node, state| {\n-                let item = PreBatchItem::ParallelModule(node.module);\n+                let item = PreBatchItem::ParallelModule(node);\n                 state.items.push(item);\n                 Ok(())\n             },\n@@ -352,19 +352,19 @@ pub async fn compute_module_batches(\n         // different chunk group bitmap)\n         module_graph.traverse_all_edges_unordered(|(parent, ty), node| {\n             let std::collections::hash_set::Entry::Vacant(entry) =\n-                pre_batches.boundary_modules.entry(node.module)\n+                pre_batches.boundary_modules.entry(node)\n             else {\n                 // Already a boundary module, can skip check\n                 return Ok(());\n             };\n             if ty.chunking_type.is_parallel() {\n                 let parent_chunk_groups = chunk_group_info\n                     .module_chunk_groups\n-                    .get(&parent.module)\n+                    .get(&parent)\n                     .context(\"all modules need to have chunk group info\")?;\n                 let chunk_groups = chunk_group_info\n                     .module_chunk_groups\n-                    .get(&node.module)\n+                    .get(&node)\n                     .context(\"all modules need to have chunk group info\")?;\n                 if parent_chunk_groups != chunk_groups {\n                     // This is a boundary module\n@@ -390,12 +390,13 @@ pub async fn compute_module_batches(\n             |cycle| {\n                 if cycle\n                     .iter()\n-                    .any(|node| pre_batches.boundary_modules.contains(&node.module))\n+                    .any(|node| pre_batches.boundary_modules.contains(node))\n                 {\n                     pre_batches\n                         .boundary_modules\n-                        .extend(cycle.iter().map(|node| node.module));\n+                        .extend(cycle.iter().map(|node| **node));\n                 }\n+                Ok(())\n             },\n         )?;\n "
        },
        {
            "sha": "466830c6173a1208c3ad66cb187ca4f823ffc50d",
            "filename": "turbopack/crates/turbopack/src/global_module_ids.rs",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/vercel/next.js/blob/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fglobal_module_ids.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/cff6a5df1fa21c95a8fb153217c5ad5a493c5298/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fglobal_module_ids.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack%2Fsrc%2Fglobal_module_ids.rs?ref=cff6a5df1fa21c95a8fb153217c5ad5a493c5298",
            "patch": "@@ -26,7 +26,7 @@ pub async fn get_global_module_id_strategy(\n         let module_idents = graphs\n             .iter()\n             .flat_map(|graph| graph.iter_nodes())\n-            .map(|m| m.module.ident());\n+            .map(|m| m.ident());\n \n         // And additionally, all the modules that are inserted by chunking (i.e. async loaders)\n         let mut async_idents = vec![];\n@@ -39,7 +39,7 @@ pub async fn get_global_module_id_strategy(\n                 },\n             ) = parent\n             {\n-                let module = ResolvedVc::try_sidecast::<Box<dyn ChunkableModule>>(current.module)\n+                let module = ResolvedVc::try_sidecast::<Box<dyn ChunkableModule>>(current)\n                     .context(\"expected chunkable module for async reference\")?;\n                 async_idents.push(AsyncLoaderModule::asset_ident_for(*module));\n             }"
        }
    ],
    "stats": {
        "total": 1243,
        "additions": 460,
        "deletions": 783
    }
}