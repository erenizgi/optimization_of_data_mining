{
    "author": "sokra",
    "message": "[Turbopack] only invalidate fs writes with a different content (#75936)\n\n### What?\n\nThere are cases where two write tasks write to the same file. This can happen e. g. when two different image source files with the same content are used and end up with the same content hashed filename.\n\nBut since dependency tracking is disabled for one off builds, this results in an invalidation of the first write task when the second write task effect is executed. And an invalidation will panic in dependency-tracking-disabled mode.\n\nThis change only invalidates other write tasks when they write a different content and keeps writes with the same content intact.\n\nThis should avoid the panic as no task is invalidated.",
    "sha": "fa2ccaf5f8e7678cd51628ee9c3b04ed3a5c0688",
    "files": [
        {
            "sha": "af0b46a971e70f202ae3678e747d9bcd87298334",
            "filename": "turbopack/crates/turbo-tasks-fs/src/invalidator_map.rs",
            "status": "modified",
            "additions": 24,
            "deletions": 9,
            "changes": 33,
            "blob_url": "https://github.com/vercel/next.js/blob/fa2ccaf5f8e7678cd51628ee9c3b04ed3a5c0688/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidator_map.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa2ccaf5f8e7678cd51628ee9c3b04ed3a5c0688/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidator_map.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Finvalidator_map.rs?ref=fa2ccaf5f8e7678cd51628ee9c3b04ed3a5c0688",
            "patch": "@@ -1,13 +1,23 @@\n use std::sync::{LockResult, Mutex, MutexGuard};\n \n use concurrent_queue::ConcurrentQueue;\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n use serde::{de::Visitor, Deserialize, Serialize};\n-use turbo_tasks::Invalidator;\n+use turbo_tasks::{Invalidator, ReadRef};\n+\n+use crate::{FileContent, LinkContent};\n+\n+#[derive(Serialize, Deserialize, PartialEq, Eq)]\n+pub enum WriteContent {\n+    File(ReadRef<FileContent>),\n+    Link(ReadRef<LinkContent>),\n+}\n+\n+type InnerMap = FxHashMap<String, FxHashMap<Invalidator, Option<WriteContent>>>;\n \n pub struct InvalidatorMap {\n-    queue: ConcurrentQueue<(String, Invalidator)>,\n-    map: Mutex<FxHashMap<String, FxHashSet<Invalidator>>>,\n+    queue: ConcurrentQueue<(String, Invalidator, Option<WriteContent>)>,\n+    map: Mutex<InnerMap>,\n }\n \n impl Default for InvalidatorMap {\n@@ -24,17 +34,22 @@ impl InvalidatorMap {\n         Self::default()\n     }\n \n-    pub fn lock(&self) -> LockResult<MutexGuard<'_, FxHashMap<String, FxHashSet<Invalidator>>>> {\n+    pub fn lock(&self) -> LockResult<MutexGuard<'_, InnerMap>> {\n         let mut guard = self.map.lock()?;\n-        while let Ok((key, value)) = self.queue.pop() {\n-            guard.entry(key).or_default().insert(value);\n+        while let Ok((key, value, write_content)) = self.queue.pop() {\n+            guard.entry(key).or_default().insert(value, write_content);\n         }\n         Ok(guard)\n     }\n \n     #[allow(unused_must_use)]\n-    pub fn insert(&self, key: String, invalidator: Invalidator) {\n-        self.queue.push((key, invalidator));\n+    pub fn insert(\n+        &self,\n+        key: String,\n+        invalidator: Invalidator,\n+        write_content: Option<WriteContent>,\n+    ) {\n+        self.queue.push((key, invalidator, write_content));\n     }\n }\n "
        },
        {
            "sha": "464f8d3867e951b7e37f9571115ebb7c0b4f8a17",
            "filename": "turbopack/crates/turbo-tasks-fs/src/lib.rs",
            "status": "modified",
            "additions": 52,
            "deletions": 25,
            "changes": 77,
            "blob_url": "https://github.com/vercel/next.js/blob/fa2ccaf5f8e7678cd51628ee9c3b04ed3a5c0688/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa2ccaf5f8e7678cd51628ee9c3b04ed3a5c0688/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Flib.rs?ref=fa2ccaf5f8e7678cd51628ee9c3b04ed3a5c0688",
            "patch": "@@ -49,7 +49,6 @@ use mime::Mime;\n use rayon::iter::{IntoParallelIterator, ParallelIterator};\n use read_glob::read_glob;\n pub use read_glob::ReadGlobResult;\n-use rustc_hash::FxHashSet;\n use serde::{Deserialize, Serialize};\n use serde_json::Value;\n use tokio::{\n@@ -73,6 +72,7 @@ use watcher::DiskWatcher;\n use self::{invalidation::Write, json::UnparseableJson, mutex_map::MutexMap};\n use crate::{\n     attach::AttachedFileSystem,\n+    invalidator_map::WriteContent,\n     retry::{retry_blocking, retry_future},\n     rope::{Rope, RopeReader},\n };\n@@ -244,9 +244,10 @@ impl DiskFileSystemInner {\n \n     /// registers the path as an invalidator for the current task,\n     /// has to be called within a turbo-tasks function\n-    fn register_invalidator(&self, path: &Path) -> Result<()> {\n+    fn register_read_invalidator(&self, path: &Path) -> Result<()> {\n         let invalidator = turbo_tasks::get_invalidator();\n-        self.invalidator_map.insert(path_to_key(path), invalidator);\n+        self.invalidator_map\n+            .insert(path_to_key(path), invalidator, None);\n         #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n         if let Some(dir) = path.parent() {\n             self.watcher.ensure_watching(dir, self.root_path())?;\n@@ -257,28 +258,38 @@ impl DiskFileSystemInner {\n     /// registers the path as an invalidator for the current task,\n     /// has to be called within a turbo-tasks function. It removes and returns\n     /// the current list of invalidators.\n-    fn register_sole_invalidator(\n+    fn register_write_invalidator(\n         &self,\n         path: &Path,\n         invalidator: Invalidator,\n-    ) -> Result<FxHashSet<Invalidator>> {\n+        write_content: WriteContent,\n+    ) -> Result<Vec<(Invalidator, Option<WriteContent>)>> {\n         let mut invalidator_map = self.invalidator_map.lock().unwrap();\n-        let old_invalidators =\n-            invalidator_map.insert(path_to_key(path), FxHashSet::from_iter([invalidator]));\n+        let invalidators = invalidator_map.entry(path_to_key(path)).or_default();\n+        let old_invalidators = invalidators\n+            .extract_if(|i, old_write_content| {\n+                i == &invalidator\n+                    || old_write_content\n+                        .as_ref()\n+                        .is_none_or(|old| old != &write_content)\n+            })\n+            .filter(|(i, _)| i != &invalidator)\n+            .collect::<Vec<_>>();\n+        invalidators.insert(invalidator, Some(write_content));\n         drop(invalidator_map);\n         #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n         if let Some(dir) = path.parent() {\n             self.watcher.ensure_watching(dir, self.root_path())?;\n         }\n-        Ok(old_invalidators.unwrap_or_default())\n+        Ok(old_invalidators)\n     }\n \n     /// registers the path as an invalidator for the current task,\n     /// has to be called within a turbo-tasks function\n     fn register_dir_invalidator(&self, path: &Path) -> Result<()> {\n         let invalidator = turbo_tasks::get_invalidator();\n         self.dir_invalidator_map\n-            .insert(path_to_key(path), invalidator);\n+            .insert(path_to_key(path), invalidator, None);\n         #[cfg(not(any(target_os = \"macos\", target_os = \"windows\")))]\n         self.watcher.ensure_watching(path, self.root_path())?;\n         Ok(())\n@@ -300,7 +311,7 @@ impl DiskFileSystemInner {\n             .into_par_iter()\n             .chain(dir_invalidator_map.into_par_iter())\n             .flat_map(|(_, invalidators)| invalidators.into_par_iter());\n-        iter.for_each(|i| {\n+        iter.for_each(|(i, _)| {\n             let _span = span.clone().entered();\n             let _guard = handle.enter();\n             i.invalidate()\n@@ -323,26 +334,30 @@ impl DiskFileSystemInner {\n                     .into_par_iter()\n                     .map(move |i| (reason.clone(), i))\n             });\n-        iter.for_each(|(reason, invalidator)| {\n+        iter.for_each(|(reason, (invalidator, _))| {\n             let _span = span.clone().entered();\n             let _guard = handle.enter();\n             invalidator.invalidate_with_reason(reason)\n         });\n     }\n \n-    fn invalidate_from_write(&self, full_path: &Path, invalidators: FxHashSet<Invalidator>) {\n+    fn invalidate_from_write(\n+        &self,\n+        full_path: &Path,\n+        invalidators: Vec<(Invalidator, Option<WriteContent>)>,\n+    ) {\n         if !invalidators.is_empty() {\n             if let Some(path) = format_absolute_fs_path(full_path, &self.name, self.root_path()) {\n                 if invalidators.len() == 1 {\n-                    let invalidator = invalidators.into_iter().next().unwrap();\n+                    let (invalidator, _) = invalidators.into_iter().next().unwrap();\n                     invalidator.invalidate_with_reason(Write { path });\n                 } else {\n-                    invalidators.into_iter().for_each(|invalidator| {\n+                    invalidators.into_iter().for_each(|(invalidator, _)| {\n                         invalidator.invalidate_with_reason(Write { path: path.clone() });\n                     });\n                 }\n             } else {\n-                invalidators.into_iter().for_each(|invalidator| {\n+                invalidators.into_iter().for_each(|(invalidator, _)| {\n                     invalidator.invalidate();\n                 });\n             }\n@@ -498,7 +513,7 @@ impl FileSystem for DiskFileSystem {\n     async fn read(&self, fs_path: Vc<FileSystemPath>) -> Result<Vc<FileContent>> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n-        self.inner.register_invalidator(&full_path)?;\n+        self.inner.register_read_invalidator(&full_path)?;\n \n         let _lock = self.inner.lock_path(&full_path).await;\n         let content = match retry_future(|| File::from_path(full_path.clone()))\n@@ -579,7 +594,7 @@ impl FileSystem for DiskFileSystem {\n     async fn read_link(&self, fs_path: Vc<FileSystemPath>) -> Result<Vc<LinkContent>> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n-        self.inner.register_invalidator(&full_path)?;\n+        self.inner.register_read_invalidator(&full_path)?;\n \n         let _lock = self.inner.lock_path(&full_path).await;\n         let link_path = match retry_future(|| fs::read_link(&full_path))\n@@ -665,7 +680,7 @@ impl FileSystem for DiskFileSystem {\n     async fn track(&self, fs_path: Vc<FileSystemPath>) -> Result<Vc<Completion>> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n-        self.inner.register_invalidator(&full_path)?;\n+        self.inner.register_read_invalidator(&full_path)?;\n         Ok(Completion::new())\n     }\n \n@@ -683,7 +698,11 @@ impl FileSystem for DiskFileSystem {\n             let _lock = inner.lock_path(&full_path).await;\n \n             // Track the file, so that we will rewrite it if it ever changes.\n-            let old_invalidators = inner.register_sole_invalidator(&full_path, invalidator)?;\n+            let old_invalidators = inner.register_write_invalidator(\n+                &full_path,\n+                invalidator,\n+                WriteContent::File(content.clone()),\n+            )?;\n \n             // We perform an untracked comparison here, so that this write is not dependent\n             // on a read's Vc<FileContent> (and the memory it holds). Our untracked read can\n@@ -701,8 +720,10 @@ impl FileSystem for DiskFileSystem {\n             if compare == FileComparison::Equal {\n                 if !old_invalidators.is_empty() {\n                     let key = path_to_key(&full_path);\n-                    for i in old_invalidators {\n-                        inner.invalidator_map.insert(key.clone(), i);\n+                    for (invalidator, write_content) in old_invalidators {\n+                        inner\n+                            .invalidator_map\n+                            .insert(key.clone(), invalidator, write_content);\n                     }\n                 }\n                 return Ok(());\n@@ -806,7 +827,11 @@ impl FileSystem for DiskFileSystem {\n \n             let _lock = inner.lock_path(&full_path).await;\n \n-            let old_invalidators = inner.register_sole_invalidator(&full_path, invalidator)?;\n+            let old_invalidators = inner.register_write_invalidator(\n+                &full_path,\n+                invalidator,\n+                WriteContent::Link(content.clone()),\n+            )?;\n \n             // TODO(sokra) preform a untracked read here, register an invalidator and get\n             // all existing invalidators\n@@ -832,8 +857,10 @@ impl FileSystem for DiskFileSystem {\n             if is_equal {\n                 if !old_invalidators.is_empty() {\n                     let key = path_to_key(&full_path);\n-                    for i in old_invalidators {\n-                        inner.invalidator_map.insert(key.clone(), i);\n+                    for (invalidator, write_content) in old_invalidators {\n+                        inner\n+                            .invalidator_map\n+                            .insert(key.clone(), invalidator, write_content);\n                     }\n                 }\n                 return Ok(());\n@@ -919,7 +946,7 @@ impl FileSystem for DiskFileSystem {\n     async fn metadata(&self, fs_path: Vc<FileSystemPath>) -> Result<Vc<FileMeta>> {\n         mark_session_dependent();\n         let full_path = self.to_sys_path(fs_path).await?;\n-        self.inner.register_invalidator(&full_path)?;\n+        self.inner.register_read_invalidator(&full_path)?;\n \n         let _lock = self.inner.lock_path(&full_path).await;\n         let meta = retry_blocking(&full_path, |path| std::fs::metadata(path))"
        },
        {
            "sha": "fdbb104499668bf4f3ad624674bd23f3091a5a1e",
            "filename": "turbopack/crates/turbo-tasks-fs/src/watcher.rs",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/vercel/next.js/blob/fa2ccaf5f8e7678cd51628ee9c3b04ed3a5c0688/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/fa2ccaf5f8e7678cd51628ee9c3b04ed3a5c0688/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-fs%2Fsrc%2Fwatcher.rs?ref=fa2ccaf5f8e7678cd51628ee9c3b04ed3a5c0688",
            "patch": "@@ -22,6 +22,7 @@ use turbo_tasks::{spawn_thread, Invalidator};\n use crate::{\n     format_absolute_fs_path,\n     invalidation::{WatchChange, WatchStart},\n+    invalidator_map::WriteContent,\n     path_to_key, DiskFileSystemInner,\n };\n \n@@ -192,7 +193,7 @@ impl DiskWatcher {\n                         .into_par_iter()\n                         .map(move |i| (reason.clone(), i))\n                 })\n-                .for_each(|(reason, invalidator)| {\n+                .for_each(|(reason, (invalidator, _))| {\n                     let _span = span.clone().entered();\n                     let _guard = handle.enter();\n                     invalidator.invalidate_with_reason(reason)\n@@ -202,7 +203,7 @@ impl DiskWatcher {\n                     let _span = span.clone().entered();\n                     invalidators.into_par_iter().map(move |i| i)\n                 })\n-                .for_each(|invalidator| {\n+                .for_each(|(invalidator, _)| {\n                     let _span = span.clone().entered();\n                     let _guard = handle.enter();\n                     invalidator.invalidate()\n@@ -459,31 +460,31 @@ fn invalidate(\n fn invalidate_path(\n     inner: &DiskFileSystemInner,\n     report_invalidation_reason: bool,\n-    invalidator_map: &mut FxHashMap<String, FxHashSet<Invalidator>>,\n+    invalidator_map: &mut FxHashMap<String, FxHashMap<Invalidator, Option<WriteContent>>>,\n     paths: impl Iterator<Item = PathBuf>,\n ) {\n     for path in paths {\n         let key = path_to_key(&path);\n         if let Some(invalidators) = invalidator_map.remove(&key) {\n             invalidators\n                 .into_iter()\n-                .for_each(|i| invalidate(inner, report_invalidation_reason, &path, i));\n+                .for_each(|(i, _)| invalidate(inner, report_invalidation_reason, &path, i));\n         }\n     }\n }\n \n fn invalidate_path_and_children_execute(\n     inner: &DiskFileSystemInner,\n     report_invalidation_reason: bool,\n-    invalidator_map: &mut FxHashMap<String, FxHashSet<Invalidator>>,\n+    invalidator_map: &mut FxHashMap<String, FxHashMap<Invalidator, Option<WriteContent>>>,\n     paths: impl Iterator<Item = PathBuf>,\n ) {\n     for path in paths {\n         let path_key = path_to_key(&path);\n         for (_, invalidators) in invalidator_map.extract_if(|key, _| key.starts_with(&path_key)) {\n             invalidators\n                 .into_iter()\n-                .for_each(|i| invalidate(inner, report_invalidation_reason, &path, i));\n+                .for_each(|(i, _)| invalidate(inner, report_invalidation_reason, &path, i));\n         }\n     }\n }"
        }
    ],
    "stats": {
        "total": 123,
        "additions": 83,
        "deletions": 40
    }
}