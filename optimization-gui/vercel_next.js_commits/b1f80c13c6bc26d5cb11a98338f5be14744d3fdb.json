{
    "author": "lukesandberg",
    "message": "[turbopack] Avoid calling `find_server_entries` in the whole_app_module_graph case (#81943)\n\n## Improve performance of find_client_references in production builds\n\n### What?\nAvoid calling `find_server_entries` in the production case where there is a single module graph.  While all the turbotasks launched by `find_server_entries` are by definition already done it is still a lot of tiny tasks to get cache hits and re do work that was already done when building the graph.\n\nSo instead we can just report server components and server utilities when performing the graph traversal.  Unfortunately this does not work in development builds since the stacked layout graphs interfere with ordering, so in that case we will still call `find_server_entries`, however we can do this concurrently with the graph traversal to save a bit of latency.\n\n###  Why?\n\nTo improve performance of course!\n\n![image.png](https://graphite-user-uploaded-assets-prod.s3.amazonaws.com/AwJ29EfoPcPdLSwCZxAz/89a13c00-f4a6-4fc1-8626-619ce645600d.png)\n\nThis represents a small latency progression. Collecting client references is on the critical path for chunking so this makes sense. We have to collect all client references for all pages",
    "sha": "b1f80c13c6bc26d5cb11a98338f5be14744d3fdb",
    "files": [
        {
            "sha": "10325cba99785f6dba662ba956eeb8dffbfa2ef5",
            "filename": "crates/next-api/src/module_graph.rs",
            "status": "modified",
            "additions": 69,
            "deletions": 37,
            "changes": 106,
            "blob_url": "https://github.com/vercel/next.js/blob/b1f80c13c6bc26d5cb11a98338f5be14744d3fdb/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1f80c13c6bc26d5cb11a98338f5be14744d3fdb/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-api%2Fsrc%2Fmodule_graph.rs?ref=b1f80c13c6bc26d5cb11a98338f5be14744d3fdb",
            "patch": "@@ -2,19 +2,21 @@ use std::{borrow::Cow, collections::hash_map::Entry};\n \n use anyhow::{Ok, Result};\n use either::Either;\n+use futures::join;\n use next_core::{\n     next_client_reference::{\n         ClientReference, ClientReferenceGraphResult, ClientReferenceType, ServerEntries,\n         find_server_entries,\n     },\n     next_dynamic::NextDynamicEntryModule,\n     next_manifests::ActionLayer,\n+    next_server_utility::server_utility_module::NextServerUtilityModule,\n };\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n use tracing::Instrument;\n use turbo_rcstr::{RcStr, rcstr};\n use turbo_tasks::{\n-    CollectiblesSource, FxIndexMap, ReadRef, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt,\n+    CollectiblesSource, FxIndexMap, FxIndexSet, ResolvedVc, TryFlatJoinIterExt, TryJoinIterExt,\n     ValueToString, Vc,\n };\n use turbo_tasks_fs::FileSystemPath;\n@@ -289,7 +291,8 @@ impl ClientReferencesGraph {\n             // post_order callbacks which is the same as evaluation order\n             let mut client_references = Vec::new();\n             let mut client_reference_modules = Vec::new();\n-            let mut server_components = FxHashSet::default();\n+            let mut server_components = FxIndexSet::default();\n+            let mut server_utils = FxIndexSet::default();\n \n             // Track how we reached each client reference.  This way if a client reference is\n             // referenced by the root and by a server component we don't only associate it with the\n@@ -355,6 +358,12 @@ impl ClientReferencesGraph {\n                 },\n                 |_, node, state_map| {\n                     let module = node.module();\n+                    if let Some(server_util_module) =\n+                        ResolvedVc::try_downcast_type::<NextServerUtilityModule>(module)\n+                    {\n+                        server_utils.insert(server_util_module);\n+                    }\n+\n                     let Some(module_type) = data.manifest.get(&module) else {\n                         return Ok(());\n                     };\n@@ -407,8 +416,9 @@ impl ClientReferencesGraph {\n \n             Ok(ClientReferenceGraphResult {\n                 client_references: client_references.into_iter().collect(),\n-                server_utils: vec![],\n-                server_component_entries: vec![],\n+                // The order of server_utils does not matter\n+                server_utils: server_utils.into_iter().collect(),\n+                server_component_entries: server_components.into_iter().collect(),\n             }\n             .cell())\n         }\n@@ -717,46 +727,68 @@ impl GlobalBuildInformation {\n     ) -> Result<Vc<ClientReferenceGraphResult>> {\n         let span = tracing::info_span!(\"collect all client references for endpoint\");\n         async move {\n-            let mut result = if let [graph] = &self.client_references[..] {\n-                // Just a single graph, no need to merge results\n-                graph\n-                    .get_client_references_for_endpoint(entry)\n-                    .owned()\n-                    .await?\n+            let result = if let [graph] = &self.client_references[..] {\n+                // Just a single graph, no need to merge results  This also naturally aggregates\n+                // server components and server utilities in the correct order\n+                let result = graph.get_client_references_for_endpoint(entry);\n+                #[cfg(debug_assertions)]\n+                {\n+                    let result = result.await?;\n+                    if has_layout_segments {\n+                        use rustc_hash::FxHashSet;\n+\n+                        let ServerEntries {\n+                            server_utils,\n+                            server_component_entries,\n+                        } = &*find_server_entries(entry, include_traced).await?;\n+                        // order of server utils doesn't matter, so just ensure that they match\n+                        assert_eq!(\n+                            FxHashSet::from_iter(result.server_utils.iter()),\n+                            FxHashSet::from_iter(server_utils.iter())\n+                        );\n+                        // The order of server_components does matter, enforce it is identical\n+                        assert_eq!(&result.server_component_entries, server_component_entries);\n+                    }\n+                }\n+                result\n             } else {\n                 let results = self\n                     .client_references\n                     .iter()\n                     .map(|graph| graph.get_client_references_for_endpoint(entry))\n-                    .try_join()\n-                    .await?;\n-\n-                let mut iter = results.into_iter();\n-                let mut result = ReadRef::into_owned(iter.next().unwrap());\n-                for r in iter {\n-                    result.extend(&r);\n-                }\n-                result\n-            };\n+                    .try_join();\n+                // Do this separately for now, because the aggregation of multiple graph traversals\n+                // messes up the order of the server_component_entries.\n+                let server_entries = async {\n+                    if has_layout_segments {\n+                        let server_entries = find_server_entries(entry, include_traced).await?;\n+                        Ok(Some(server_entries))\n+                    } else {\n+                        Ok(None)\n+                    }\n+                };\n+                // Wait for both in parallel since `find_server_entries` tends to be slower than the\n+                // graph traversals\n+                let (results, server_entries) = join!(results, server_entries);\n \n-            // TODO(luke.sandberg): at least in the whole_app_module_graph case we should be able to\n-            // collect server components and server utilities during the above traversals in the\n-            // correct order.  `find_server_entries returns them in reverse topological order (root\n-            // layout first, page last) but the above traversals find them in DFS post\n-            // order which means we would need to reverse it.\n-            // For server_utils the order is irrelevant.\n-            if has_layout_segments {\n-                // Do this separately for now, because the graph traversal order messes up the order\n-                // of the server_component_entries.\n-                let ServerEntries {\n+                let mut result = ClientReferenceGraphResult {\n+                    client_references: results?\n+                        .iter()\n+                        .flat_map(|r| r.client_references.iter().copied())\n+                        .collect(),\n+                    ..Default::default()\n+                };\n+                if let Some(ServerEntries {\n                     server_utils,\n                     server_component_entries,\n-                } = &*find_server_entries(entry, include_traced).await?;\n-                result.server_utils = server_utils.clone();\n-                result.server_component_entries = server_component_entries.clone();\n-            }\n-\n-            Ok(result.cell())\n+                }) = server_entries?.as_deref()\n+                {\n+                    result.server_utils = server_utils.clone();\n+                    result.server_component_entries = server_component_entries.clone();\n+                }\n+                result.cell()\n+            };\n+            Ok(result)\n         }\n         .instrument(span)\n         .await"
        },
        {
            "sha": "614f3d6efeb2345ea642bcee6f853d905c4b2f17",
            "filename": "crates/next-core/src/next_client_reference/visit_client_reference.rs",
            "status": "modified",
            "additions": 0,
            "deletions": 11,
            "changes": 11,
            "blob_url": "https://github.com/vercel/next.js/blob/b1f80c13c6bc26d5cb11a98338f5be14744d3fdb/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/b1f80c13c6bc26d5cb11a98338f5be14744d3fdb/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/crates%2Fnext-core%2Fsrc%2Fnext_client_reference%2Fvisit_client_reference.rs?ref=b1f80c13c6bc26d5cb11a98338f5be14744d3fdb",
            "patch": "@@ -106,17 +106,6 @@ impl ClientReferenceGraphResult {\n     }\n }\n \n-impl ClientReferenceGraphResult {\n-    /// Merges multiple return values of client_reference_graph together.\n-    pub fn extend(&mut self, other: &Self) {\n-        self.client_references\n-            .extend(other.client_references.iter().copied());\n-        self.server_component_entries\n-            .extend(other.server_component_entries.iter().copied());\n-        self.server_utils.extend(other.server_utils.iter().copied());\n-    }\n-}\n-\n #[turbo_tasks::value(shared)]\n #[derive(Clone, Debug)]\n pub struct ServerEntries {"
        }
    ],
    "stats": {
        "total": 117,
        "additions": 69,
        "deletions": 48
    }
}