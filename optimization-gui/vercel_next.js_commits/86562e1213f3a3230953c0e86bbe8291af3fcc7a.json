{
    "author": "eps1lon",
    "message": "[turbopack] Return cached Promise from `__turbopack_load_by_url__ ` (#81663)",
    "sha": "86562e1213f3a3230953c0e86bbe8291af3fcc7a",
    "files": [
        {
            "sha": "9d910199e43abc98ceeb0c76e023f0d672c57d03",
            "filename": "packages/next/src/server/dev/hot-reloader-turbopack.ts",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/vercel/next.js/blob/86562e1213f3a3230953c0e86bbe8291af3fcc7a/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/86562e1213f3a3230953c0e86bbe8291af3fcc7a/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdev%2Fhot-reloader-turbopack.ts?ref=86562e1213f3a3230953c0e86bbe8291af3fcc7a",
            "patch": "@@ -346,6 +346,13 @@ export async function createHotReloaderTurbopack(\n       p.startsWith('server/app')\n     )\n \n+    // Edge uses the browser runtime which already disposes chunks individually.\n+    // TODO: process.env.NEXT_RUNTIME is 'nodejs' even though Node.js runtime is not used.\n+    if ('__turbopack_clear_chunk_cache__' in globalThis) {\n+      ;(globalThis as any).__turbopack_clear_chunk_cache__()\n+    }\n+\n+    // TODO: Stop re-evaluating React Client once it relies on Turbopack's chunk cache.\n     if (hasAppPaths) {\n       deleteFromRequireCache(\n         require.resolve("
        },
        {
            "sha": "b6fb52f71677b2e7edc86d74515049f2f6d106de",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/browser/runtime/base/runtime-base.ts",
            "status": "modified",
            "additions": 36,
            "deletions": 28,
            "changes": 64,
            "blob_url": "https://github.com/vercel/next.js/blob/86562e1213f3a3230953c0e86bbe8291af3fcc7a/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fruntime-base.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/86562e1213f3a3230953c0e86bbe8291af3fcc7a/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fruntime-base.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fbrowser%2Fruntime%2Fbase%2Fruntime-base.ts?ref=86562e1213f3a3230953c0e86bbe8291af3fcc7a",
            "patch": "@@ -193,35 +193,43 @@ async function loadChunk(\n   return promise\n }\n \n-async function loadChunkByUrl(source: SourceInfo, chunkUrl: ChunkUrl) {\n-  try {\n-    await BACKEND.loadChunk(chunkUrl, source)\n-  } catch (error) {\n-    let loadReason\n-    switch (source.type) {\n-      case SourceType.Runtime:\n-        loadReason = `as a runtime dependency of chunk ${source.chunkPath}`\n-        break\n-      case SourceType.Parent:\n-        loadReason = `from module ${source.parentId}`\n-        break\n-      case SourceType.Update:\n-        loadReason = 'from an HMR update'\n-        break\n-      default:\n-        invariant(source, (source) => `Unknown source type: ${source?.type}`)\n-    }\n-    throw new Error(\n-      `Failed to load chunk ${chunkUrl} ${loadReason}${\n-        error ? `: ${error}` : ''\n-      }`,\n-      error\n-        ? {\n-            cause: error,\n-          }\n-        : undefined\n-    )\n+const instrumentedBackendLoadChunks = new WeakMap<Promise<any>, Promise<any>>()\n+// Do not make this async. React relies on referential equality of the returned Promise.\n+function loadChunkByUrl(source: SourceInfo, chunkUrl: ChunkUrl): Promise<any> {\n+  const thenable = BACKEND.loadChunk(chunkUrl, source)\n+  let entry = instrumentedBackendLoadChunks.get(thenable)\n+  if (entry === undefined) {\n+    entry = thenable.catch((error) => {\n+      let loadReason\n+      switch (source.type) {\n+        case SourceType.Runtime:\n+          loadReason = `as a runtime dependency of chunk ${source.chunkPath}`\n+          break\n+        case SourceType.Parent:\n+          loadReason = `from module ${source.parentId}`\n+          break\n+        case SourceType.Update:\n+          loadReason = 'from an HMR update'\n+          break\n+        default:\n+          invariant(source, (source) => `Unknown source type: ${source?.type}`)\n+      }\n+      throw new Error(\n+        `Failed to load chunk ${chunkUrl} ${loadReason}${\n+          error ? `: ${error}` : ''\n+        }`,\n+        error\n+          ? {\n+              cause: error,\n+            }\n+          : undefined\n+      )\n+    })\n+    // TODO: Free the Promise once it resolves.\n+    instrumentedBackendLoadChunks.set(thenable, entry)\n   }\n+\n+  return entry\n }\n \n async function loadChunkPath("
        },
        {
            "sha": "6aff7843d756311bc42ed1742d350fcdcc525e35",
            "filename": "turbopack/crates/turbopack-ecmascript-runtime/js/src/nodejs/runtime.ts",
            "status": "modified",
            "additions": 37,
            "deletions": 16,
            "changes": 53,
            "blob_url": "https://github.com/vercel/next.js/blob/86562e1213f3a3230953c0e86bbe8291af3fcc7a/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fnodejs%2Fruntime.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/86562e1213f3a3230953c0e86bbe8291af3fcc7a/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fnodejs%2Fruntime.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-ecmascript-runtime%2Fjs%2Fsrc%2Fnodejs%2Fruntime.ts?ref=86562e1213f3a3230953c0e86bbe8291af3fcc7a",
            "patch": "@@ -93,6 +93,13 @@ function loadChunk(chunkData: ChunkData, source?: SourceInfo): void {\n }\n \n const loadedChunks = new Set<ChunkPath>()\n+const unsupportedLoadChunk = Promise.resolve(undefined)\n+const loadedChunk = Promise.resolve(undefined)\n+const chunkCache = new Map<ChunkPath, Promise<any> | null>()\n+\n+function clearChunkCache() {\n+  chunkCache.clear()\n+}\n \n function loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\n   if (!isJs(chunkPath)) {\n@@ -136,21 +143,10 @@ function loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\n   }\n }\n \n-async function loadChunkAsync(\n+async function loadChunkAsyncUncached(\n   source: SourceInfo,\n-  chunkData: ChunkData\n-): Promise<any> {\n-  const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\n-  if (!isJs(chunkPath)) {\n-    // We only support loading JS chunks in Node.js.\n-    // This branch can be hit when trying to load a CSS chunk.\n-    return\n-  }\n-\n-  if (loadedChunks.has(chunkPath)) {\n-    return\n-  }\n-\n+  chunkPath: ChunkPath\n+): Promise<void> {\n   const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\n \n   try {\n@@ -187,7 +183,6 @@ async function loadChunkAsync(\n         }\n       }\n     }\n-    loadedChunks.add(chunkPath)\n   } catch (e) {\n     let errorMessage = `Failed to load chunk ${chunkPath}`\n \n@@ -201,7 +196,30 @@ async function loadChunkAsync(\n   }\n }\n \n-async function loadChunkAsyncByUrl(source: SourceInfo, chunkUrl: string) {\n+function loadChunkAsync(\n+  source: SourceInfo,\n+  chunkData: ChunkData\n+): Promise<any> {\n+  const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\n+  if (!isJs(chunkPath)) {\n+    // We only support loading JS chunks in Node.js.\n+    // This branch can be hit when trying to load a CSS chunk.\n+    return unsupportedLoadChunk\n+  }\n+\n+  let entry = chunkCache.get(chunkPath)\n+  if (entry === undefined) {\n+    const resolve = chunkCache.set.bind(chunkCache, chunkPath, null)\n+    // A new Promise ensures callers that don't handle rejection will still trigger one unhandled rejection.\n+    // Handling the rejection will not trigger unhandled rejections.\n+    entry = loadChunkAsyncUncached(source, chunkPath).then(resolve)\n+    chunkCache.set(chunkPath, entry)\n+  }\n+  // TODO: Return an instrumented Promise that React can use instead of relying on referential equality.\n+  return entry === null ? loadedChunk : entry\n+}\n+\n+function loadChunkAsyncByUrl(source: SourceInfo, chunkUrl: string) {\n   const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath\n   return loadChunkAsync(source, path)\n }\n@@ -363,6 +381,9 @@ function isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\n   return regexJsUrl.test(chunkUrlOrPath)\n }\n \n+// For hot-reloader\n+;(globalThis as any).__turbopack_clear_chunk_cache__ = clearChunkCache\n+\n module.exports = {\n   getOrInstantiateRuntimeModule,\n   loadChunk,"
        },
        {
            "sha": "ea06511d15af1ccd59dac81ddaf434cf3a561cfd",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/output/[turbopack]_runtime.js",
            "status": "modified",
            "additions": 29,
            "deletions": 12,
            "changes": 41,
            "blob_url": "https://github.com/vercel/next.js/blob/86562e1213f3a3230953c0e86bbe8291af3fcc7a/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js",
            "raw_url": "https://github.com/vercel/next.js/raw/86562e1213f3a3230953c0e86bbe8291af3fcc7a/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js?ref=86562e1213f3a3230953c0e86bbe8291af3fcc7a",
            "patch": "@@ -496,6 +496,12 @@ function loadChunk(chunkData, source) {\n     }\n }\n const loadedChunks = new Set();\n+const unsupportedLoadChunk = Promise.resolve(undefined);\n+const loadedChunk = Promise.resolve(undefined);\n+const chunkCache = new Map();\n+function clearChunkCache() {\n+    chunkCache.clear();\n+}\n function loadChunkPath(chunkPath, source) {\n     if (!isJs(chunkPath)) {\n         // We only support loading JS chunks in Node.js.\n@@ -532,16 +538,7 @@ function loadChunkPath(chunkPath, source) {\n         });\n     }\n }\n-async function loadChunkAsync(source, chunkData) {\n-    const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path;\n-    if (!isJs(chunkPath)) {\n-        // We only support loading JS chunks in Node.js.\n-        // This branch can be hit when trying to load a CSS chunk.\n-        return;\n-    }\n-    if (loadedChunks.has(chunkPath)) {\n-        return;\n-    }\n+async function loadChunkAsyncUncached(source, chunkPath) {\n     const resolved = path.resolve(RUNTIME_ROOT, chunkPath);\n     try {\n         const contents = await fs.readFile(resolved, 'utf-8');\n@@ -571,7 +568,6 @@ async function loadChunkAsync(source, chunkData) {\n                 }\n             }\n         }\n-        loadedChunks.add(chunkPath);\n     } catch (e) {\n         let errorMessage = `Failed to load chunk ${chunkPath}`;\n         if (source) {\n@@ -582,7 +578,25 @@ async function loadChunkAsync(source, chunkData) {\n         });\n     }\n }\n-async function loadChunkAsyncByUrl(source, chunkUrl) {\n+function loadChunkAsync(source, chunkData) {\n+    const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path;\n+    if (!isJs(chunkPath)) {\n+        // We only support loading JS chunks in Node.js.\n+        // This branch can be hit when trying to load a CSS chunk.\n+        return unsupportedLoadChunk;\n+    }\n+    let entry = chunkCache.get(chunkPath);\n+    if (entry === undefined) {\n+        const resolve = chunkCache.set.bind(chunkCache, chunkPath, null);\n+        // A new Promise ensures callers that don't handle rejection will still trigger one unhandled rejection.\n+        // Handling the rejection will not trigger unhandled rejections.\n+        entry = loadChunkAsyncUncached(source, chunkPath).then(resolve);\n+        chunkCache.set(chunkPath, entry);\n+    }\n+    // TODO: Return an instrumented Promise that React can use instead of relying on referential equality.\n+    return entry === null ? loadedChunk : entry;\n+}\n+function loadChunkAsyncByUrl(source, chunkUrl) {\n     const path1 = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT));\n     return loadChunkAsync(source, path1);\n }\n@@ -710,6 +724,9 @@ const regexJsUrl = /\\.js(?:\\?[^#]*)?(?:#.*)?$/;\n  */ function isJs(chunkUrlOrPath) {\n     return regexJsUrl.test(chunkUrlOrPath);\n }\n+// For hot-reloader\n+;\n+globalThis.__turbopack_clear_chunk_cache__ = clearChunkCache;\n module.exports = {\n     getOrInstantiateRuntimeModule,\n     loadChunk"
        },
        {
            "sha": "98bdff4aaa8771ad4a9006e7895fcf9da137f94f",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_build_runtime/output/[turbopack]_runtime.js.map",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/vercel/next.js/blob/86562e1213f3a3230953c0e86bbe8291af3fcc7a/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/86562e1213f3a3230953c0e86bbe8291af3fcc7a/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_build_runtime%2Foutput%2F%5Bturbopack%5D_runtime.js.map?ref=86562e1213f3a3230953c0e86bbe8291af3fcc7a",
            "patch": "@@ -6,5 +6,5 @@\n     {\"offset\": {\"line\": 367, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/base-externals-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n\\n/// A 'base' utilities to support runtime can have externals.\\n/// Currently this is for node.js / edge runtime both.\\n/// If a fn requires node.js specific behavior, it should be placed in `node-external-utils` instead.\\n\\nasync function externalImport(id: DependencySpecifier) {\\n  let raw\\n  try {\\n    raw = await import(id)\\n  } catch (err) {\\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\\n    // an external module we don't provide a shim for (e.g. querystring, url).\\n    // For now, we fail semi-silently, but in the future this should be a\\n    // compilation error.\\n    throw new Error(`Failed to load external module ${id}: ${err}`)\\n  }\\n\\n  if (raw && raw.__esModule && raw.default && 'default' in raw.default) {\\n    return interopEsm(raw.default, createNS(raw), true)\\n  }\\n\\n  return raw\\n}\\n\\nfunction externalRequire(\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm: boolean = false\\n): Exports | EsmNamespaceObject {\\n  let raw\\n  try {\\n    raw = thunk()\\n  } catch (err) {\\n    // TODO(alexkirsz) This can happen when a client-side module tries to load\\n    // an external module we don't provide a shim for (e.g. querystring, url).\\n    // For now, we fail semi-silently, but in the future this should be a\\n    // compilation error.\\n    throw new Error(`Failed to load external module ${id}: ${err}`)\\n  }\\n\\n  if (!esm || raw.__esModule) {\\n    return raw\\n  }\\n\\n  return interopEsm(raw, createNS(raw), true)\\n}\\n\\nexternalRequire.resolve = (\\n  id: string,\\n  options?: {\\n    paths?: string[]\\n  }\\n) => {\\n  return require.resolve(id, options)\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,6DAA6D;AAC7D,sDAAsD;AACtD,qGAAqG;AAErG,eAAe,eAAe,EAAuB;IACnD,IAAI;IACJ,IAAI;QACF,MAAM,MAAM,MAAM,CAAC;IACrB,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,OAAO,IAAI,UAAU,IAAI,IAAI,OAAO,IAAI,aAAa,IAAI,OAAO,EAAE;QACpE,OAAO,WAAW,IAAI,OAAO,EAAE,SAAS,MAAM;IAChD;IAEA,OAAO;AACT;AAEA,SAAS,gBACP,EAAY,EACZ,KAAgB,EAChB,MAAe,KAAK;IAEpB,IAAI;IACJ,IAAI;QACF,MAAM;IACR,EAAE,OAAO,KAAK;QACZ,0EAA0E;QAC1E,0EAA0E;QAC1E,qEAAqE;QACrE,qBAAqB;QACrB,MAAM,IAAI,MAAM,CAAC,+BAA+B,EAAE,GAAG,EAAE,EAAE,KAAK;IAChE;IAEA,IAAI,CAAC,OAAO,IAAI,UAAU,EAAE;QAC1B,OAAO;IACT;IAEA,OAAO,WAAW,KAAK,SAAS,MAAM;AACxC;AAEA,gBAAgB,OAAO,GAAG,CACxB,IACA;IAIA,OAAO,QAAQ,OAAO,CAAC,IAAI;AAC7B\",\"ignoreList\":[0]}},\n     {\"offset\": {\"line\": 406, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/node-externals-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\ndeclare var RUNTIME_PUBLIC_PATH: string\\ndeclare var RELATIVE_ROOT_PATH: string\\ndeclare var ASSET_PREFIX: string\\n\\nconst path = require('path')\\n\\nconst relativePathToRuntimeRoot = path.relative(RUNTIME_PUBLIC_PATH, '.')\\n// Compute the relative path to the `distDir`.\\nconst relativePathToDistRoot = path.join(\\n  relativePathToRuntimeRoot,\\n  RELATIVE_ROOT_PATH\\n)\\nconst RUNTIME_ROOT = path.resolve(__filename, relativePathToRuntimeRoot)\\n// Compute the absolute path to the root, by stripping distDir from the absolute path to this file.\\nconst ABSOLUTE_ROOT = path.resolve(__filename, relativePathToDistRoot)\\n\\n/**\\n * Returns an absolute path to the given module path.\\n * Module path should be relative, either path to a file or a directory.\\n *\\n * This fn allows to calculate an absolute path for some global static values, such as\\n * `__dirname` or `import.meta.url` that Turbopack will not embeds in compile time.\\n * See ImportMetaBinding::code_generation for the usage.\\n */\\nfunction resolveAbsolutePath(modulePath?: string): string {\\n  if (modulePath) {\\n    return path.join(ABSOLUTE_ROOT, modulePath)\\n  }\\n  return ABSOLUTE_ROOT\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAMpD,MAAM,OAAO,QAAQ;AAErB,MAAM,4BAA4B,KAAK,QAAQ,CAAC,qBAAqB;AACrE,8CAA8C;AAC9C,MAAM,yBAAyB,KAAK,IAAI,CACtC,2BACA;AAEF,MAAM,eAAe,KAAK,OAAO,CAAC,YAAY;AAC9C,mGAAmG;AACnG,MAAM,gBAAgB,KAAK,OAAO,CAAC,YAAY;AAE/C;;;;;;;CAOC,GACD,SAAS,oBAAoB,UAAmB;IAC9C,IAAI,YAAY;QACd,OAAO,KAAK,IAAI,CAAC,eAAe;IAClC;IACA,OAAO;AACT\",\"ignoreList\":[0]}},\n     {\"offset\": {\"line\": 426, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/shared-node/node-wasm-utils.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n\\nfunction readWebAssemblyAsResponse(path: string) {\\n  const { createReadStream } = require('fs') as typeof import('fs')\\n  const { Readable } = require('stream') as typeof import('stream')\\n\\n  const stream = createReadStream(path)\\n\\n  // @ts-ignore unfortunately there's a slight type mismatch with the stream.\\n  return new Response(Readable.toWeb(stream), {\\n    headers: {\\n      'content-type': 'application/wasm',\\n    },\\n  })\\n}\\n\\nasync function compileWebAssemblyFromPath(\\n  path: string\\n): Promise<WebAssembly.Module> {\\n  const response = readWebAssemblyAsResponse(path)\\n\\n  return await WebAssembly.compileStreaming(response)\\n}\\n\\nasync function instantiateWebAssemblyFromPath(\\n  path: string,\\n  importsObj: WebAssembly.Imports\\n): Promise<Exports> {\\n  const response = readWebAssemblyAsResponse(path)\\n\\n  const { instance } = await WebAssembly.instantiateStreaming(\\n    response,\\n    importsObj\\n  )\\n\\n  return instance.exports\\n}\\n\"],\"names\":[],\"mappings\":\"AAAA,oDAAoD,GAEpD,mDAAmD;AAEnD,SAAS,0BAA0B,IAAY;IAC7C,MAAM,EAAE,gBAAgB,EAAE,GAAG,QAAQ;IACrC,MAAM,EAAE,QAAQ,EAAE,GAAG,QAAQ;IAE7B,MAAM,SAAS,iBAAiB;IAEhC,2EAA2E;IAC3E,OAAO,IAAI,SAAS,SAAS,KAAK,CAAC,SAAS;QAC1C,SAAS;YACP,gBAAgB;QAClB;IACF;AACF;AAEA,eAAe,2BACb,IAAY;IAEZ,MAAM,WAAW,0BAA0B;IAE3C,OAAO,MAAM,YAAY,gBAAgB,CAAC;AAC5C;AAEA,eAAe,+BACb,IAAY,EACZ,UAA+B;IAE/B,MAAM,WAAW,0BAA0B;IAE3C,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,YAAY,oBAAoB,CACzD,UACA;IAGF,OAAO,SAAS,OAAO;AACzB\",\"ignoreList\":[0]}},\n-    {\"offset\": {\"line\": 447, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/nodejs/runtime.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/base-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-wasm-utils.ts\\\" />\\n\\nenum SourceType {\\n  /**\\n   * The module was instantiated because it was included in an evaluated chunk's\\n   * runtime.\\n   */\\n  Runtime = 0,\\n  /**\\n   * The module was instantiated because a parent module imported it.\\n   */\\n  Parent = 1,\\n}\\n\\ntype SourceInfo =\\n  | {\\n      type: SourceType.Runtime\\n      chunkPath: ChunkPath\\n    }\\n  | {\\n      type: SourceType.Parent\\n      parentId: ModuleId\\n    }\\n\\nprocess.env.TURBOPACK = '1'\\n\\nfunction stringifySourceInfo(source: SourceInfo): string {\\n  switch (source.type) {\\n    case SourceType.Runtime:\\n      return `runtime for chunk ${source.chunkPath}`\\n    case SourceType.Parent:\\n      return `parent module ${source.parentId}`\\n    default:\\n      invariant(source, (source) => `Unknown source type: ${source?.type}`)\\n  }\\n}\\n\\ntype ExternalRequire = (\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm?: boolean\\n) => Exports | EsmNamespaceObject\\ntype ExternalImport = (id: ModuleId) => Promise<Exports | EsmNamespaceObject>\\n\\ninterface TurbopackNodeBuildContext extends TurbopackBaseContext<Module> {\\n  R: ResolvePathFromModule\\n  x: ExternalRequire\\n  y: ExternalImport\\n}\\n\\ntype ModuleFactory = (\\n  this: Module['exports'],\\n  context: TurbopackNodeBuildContext\\n) => unknown\\n\\nconst url = require('url') as typeof import('url')\\nconst fs = require('fs/promises') as typeof import('fs/promises')\\n\\nconst moduleFactories: ModuleFactories = Object.create(null)\\nconst moduleCache: ModuleCache<Module> = Object.create(null)\\n\\n/**\\n * Returns an absolute path to the given module's id.\\n */\\nfunction createResolvePathFromModule(\\n  resolver: (moduleId: string) => Exports\\n): (moduleId: string) => string {\\n  return function resolvePathFromModule(moduleId: string): string {\\n    const exported = resolver(moduleId)\\n    const exportedPath = exported?.default ?? exported\\n    if (typeof exportedPath !== 'string') {\\n      return exported as any\\n    }\\n\\n    const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length)\\n    const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix)\\n\\n    return url.pathToFileURL(resolved).href\\n  }\\n}\\n\\nfunction loadChunk(chunkData: ChunkData, source?: SourceInfo): void {\\n  if (typeof chunkData === 'string') {\\n    return loadChunkPath(chunkData, source)\\n  } else {\\n    return loadChunkPath(chunkData.path, source)\\n  }\\n}\\n\\nconst loadedChunks = new Set<ChunkPath>()\\n\\nfunction loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return\\n  }\\n\\n  if (loadedChunks.has(chunkPath)) {\\n    return\\n  }\\n\\n  try {\\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n    const chunkModules: CompressedModuleFactories = require(resolved)\\n\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        if (Array.isArray(moduleFactory)) {\\n          let [moduleFactoryFn, otherIds] = moduleFactory\\n          moduleFactories[moduleId] = moduleFactoryFn\\n          for (const otherModuleId of otherIds) {\\n            moduleFactories[otherModuleId] = moduleFactoryFn\\n          }\\n        } else {\\n          moduleFactories[moduleId] = moduleFactory\\n        }\\n      }\\n    }\\n    loadedChunks.add(chunkPath)\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`\\n\\n    if (source) {\\n      errorMessage += ` from ${stringifySourceInfo(source)}`\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    })\\n  }\\n}\\n\\nasync function loadChunkAsync(\\n  source: SourceInfo,\\n  chunkData: ChunkData\\n): Promise<any> {\\n  const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return\\n  }\\n\\n  if (loadedChunks.has(chunkPath)) {\\n    return\\n  }\\n\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  try {\\n    const contents = await fs.readFile(resolved, 'utf-8')\\n\\n    const localRequire = (id: string) => {\\n      let resolvedId = require.resolve(id, { paths: [path.dirname(resolved)] })\\n      return require(resolvedId)\\n    }\\n    const module = {\\n      exports: {},\\n    }\\n    // TODO: Use vm.runInThisContext once our minimal supported Node.js version includes https://github.com/nodejs/node/pull/52153\\n    // eslint-disable-next-line no-eval -- Can't use vm.runInThisContext due to https://github.com/nodejs/node/issues/52102\\n    ;(0, eval)(\\n      '(function(module, exports, require, __dirname, __filename) {' +\\n        contents +\\n        '\\\\n})' +\\n        '\\\\n//# sourceURL=' +\\n        url.pathToFileURL(resolved)\\n    )(module, module.exports, localRequire, path.dirname(resolved), resolved)\\n\\n    const chunkModules: CompressedModuleFactories = module.exports\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        if (Array.isArray(moduleFactory)) {\\n          let [moduleFactoryFn, otherIds] = moduleFactory\\n          moduleFactories[moduleId] = moduleFactoryFn\\n          for (const otherModuleId of otherIds) {\\n            moduleFactories[otherModuleId] = moduleFactoryFn\\n          }\\n        } else {\\n          moduleFactories[moduleId] = moduleFactory\\n        }\\n      }\\n    }\\n    loadedChunks.add(chunkPath)\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`\\n\\n    if (source) {\\n      errorMessage += ` from ${stringifySourceInfo(source)}`\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    })\\n  }\\n}\\n\\nasync function loadChunkAsyncByUrl(source: SourceInfo, chunkUrl: string) {\\n  const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath\\n  return loadChunkAsync(source, path)\\n}\\n\\nfunction loadWebAssembly(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module,\\n  imports: WebAssembly.Imports\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return instantiateWebAssemblyFromPath(resolved, imports)\\n}\\n\\nfunction loadWebAssemblyModule(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return compileWebAssemblyFromPath(resolved)\\n}\\n\\nfunction getWorkerBlobURL(_chunks: ChunkPath[]): string {\\n  throw new Error('Worker blobs are not implemented yet for Node.js')\\n}\\n\\nfunction instantiateModule(id: ModuleId, source: SourceInfo): Module {\\n  const moduleFactory = moduleFactories[id]\\n  if (typeof moduleFactory !== 'function') {\\n    // This can happen if modules incorrectly handle HMR disposes/updates,\\n    // e.g. when they keep a `setTimeout` around which still executes old code\\n    // and contains e.g. a `require(\\\"something\\\")` call.\\n    let instantiationReason\\n    switch (source.type) {\\n      case SourceType.Runtime:\\n        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`\\n        break\\n      case SourceType.Parent:\\n        instantiationReason = `because it was required from module ${source.parentId}`\\n        break\\n      default:\\n        invariant(source, (source) => `Unknown source type: ${source?.type}`)\\n    }\\n    throw new Error(\\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\\n    )\\n  }\\n\\n  const module: Module = {\\n    exports: {},\\n    error: undefined,\\n    loaded: false,\\n    id,\\n    namespaceObject: undefined,\\n  }\\n  moduleCache[id] = module\\n\\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\\n  try {\\n    const r = commonJsRequire.bind(null, module)\\n    moduleFactory.call(module.exports, {\\n      a: asyncModule.bind(null, module),\\n      e: module.exports,\\n      r,\\n      t: runtimeRequire,\\n      x: externalRequire,\\n      y: externalImport,\\n      f: moduleContext,\\n      i: esmImport.bind(null, module),\\n      s: esmExport.bind(null, module, module.exports, moduleCache),\\n      j: dynamicExport.bind(null, module, module.exports, moduleCache),\\n      v: exportValue.bind(null, module, moduleCache),\\n      n: exportNamespace.bind(null, module, moduleCache),\\n      m: module,\\n      c: moduleCache,\\n      M: moduleFactories,\\n      l: loadChunkAsync.bind(null, { type: SourceType.Parent, parentId: id }),\\n      L: loadChunkAsyncByUrl.bind(null, {\\n        type: SourceType.Parent,\\n        parentId: id,\\n      }),\\n      w: loadWebAssembly,\\n      u: loadWebAssemblyModule,\\n      P: resolveAbsolutePath,\\n      U: relativeURL,\\n      R: createResolvePathFromModule(r),\\n      b: getWorkerBlobURL,\\n      z: requireStub,\\n    })\\n  } catch (error) {\\n    module.error = error as any\\n    throw error\\n  }\\n\\n  module.loaded = true\\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\\n    interopEsm(module.exports, module.namespaceObject)\\n  }\\n\\n  return module\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it if it is not cached.\\n */\\n// @ts-ignore\\nfunction getOrInstantiateModuleFromParent(\\n  id: ModuleId,\\n  sourceModule: Module\\n): Module {\\n  const module = moduleCache[id]\\n\\n  if (module) {\\n    return module\\n  }\\n\\n  return instantiateModule(id, {\\n    type: SourceType.Parent,\\n    parentId: sourceModule.id,\\n  })\\n}\\n\\n/**\\n * Instantiates a runtime module.\\n */\\nfunction instantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath })\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\\n */\\n// @ts-ignore TypeScript doesn't separate this module space from the browser runtime\\nfunction getOrInstantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  const module = moduleCache[moduleId]\\n  if (module) {\\n    if (module.error) {\\n      throw module.error\\n    }\\n    return module\\n  }\\n\\n  return instantiateRuntimeModule(moduleId, chunkPath)\\n}\\n\\nconst regexJsUrl = /\\\\.js(?:\\\\?[^#]*)?(?:#.*)?$/\\n/**\\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\\n */\\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\\n  return regexJsUrl.test(chunkUrlOrPath)\\n}\\n\\nmodule.exports = {\\n  getOrInstantiateRuntimeModule,\\n  loadChunk,\\n}\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}}]\n+    {\"offset\": {\"line\": 447, \"column\": 0}, \"map\": {\"version\":3,\"sources\":[\"turbopack:///[turbopack]/nodejs/runtime.ts\"],\"sourcesContent\":[\"/* eslint-disable @typescript-eslint/no-unused-vars */\\n\\n/// <reference path=\\\"../shared/runtime-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/base-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-externals-utils.ts\\\" />\\n/// <reference path=\\\"../shared-node/node-wasm-utils.ts\\\" />\\n\\nenum SourceType {\\n  /**\\n   * The module was instantiated because it was included in an evaluated chunk's\\n   * runtime.\\n   */\\n  Runtime = 0,\\n  /**\\n   * The module was instantiated because a parent module imported it.\\n   */\\n  Parent = 1,\\n}\\n\\ntype SourceInfo =\\n  | {\\n      type: SourceType.Runtime\\n      chunkPath: ChunkPath\\n    }\\n  | {\\n      type: SourceType.Parent\\n      parentId: ModuleId\\n    }\\n\\nprocess.env.TURBOPACK = '1'\\n\\nfunction stringifySourceInfo(source: SourceInfo): string {\\n  switch (source.type) {\\n    case SourceType.Runtime:\\n      return `runtime for chunk ${source.chunkPath}`\\n    case SourceType.Parent:\\n      return `parent module ${source.parentId}`\\n    default:\\n      invariant(source, (source) => `Unknown source type: ${source?.type}`)\\n  }\\n}\\n\\ntype ExternalRequire = (\\n  id: ModuleId,\\n  thunk: () => any,\\n  esm?: boolean\\n) => Exports | EsmNamespaceObject\\ntype ExternalImport = (id: ModuleId) => Promise<Exports | EsmNamespaceObject>\\n\\ninterface TurbopackNodeBuildContext extends TurbopackBaseContext<Module> {\\n  R: ResolvePathFromModule\\n  x: ExternalRequire\\n  y: ExternalImport\\n}\\n\\ntype ModuleFactory = (\\n  this: Module['exports'],\\n  context: TurbopackNodeBuildContext\\n) => unknown\\n\\nconst url = require('url') as typeof import('url')\\nconst fs = require('fs/promises') as typeof import('fs/promises')\\n\\nconst moduleFactories: ModuleFactories = Object.create(null)\\nconst moduleCache: ModuleCache<Module> = Object.create(null)\\n\\n/**\\n * Returns an absolute path to the given module's id.\\n */\\nfunction createResolvePathFromModule(\\n  resolver: (moduleId: string) => Exports\\n): (moduleId: string) => string {\\n  return function resolvePathFromModule(moduleId: string): string {\\n    const exported = resolver(moduleId)\\n    const exportedPath = exported?.default ?? exported\\n    if (typeof exportedPath !== 'string') {\\n      return exported as any\\n    }\\n\\n    const strippedAssetPrefix = exportedPath.slice(ASSET_PREFIX.length)\\n    const resolved = path.resolve(RUNTIME_ROOT, strippedAssetPrefix)\\n\\n    return url.pathToFileURL(resolved).href\\n  }\\n}\\n\\nfunction loadChunk(chunkData: ChunkData, source?: SourceInfo): void {\\n  if (typeof chunkData === 'string') {\\n    return loadChunkPath(chunkData, source)\\n  } else {\\n    return loadChunkPath(chunkData.path, source)\\n  }\\n}\\n\\nconst loadedChunks = new Set<ChunkPath>()\\nconst unsupportedLoadChunk = Promise.resolve(undefined)\\nconst loadedChunk = Promise.resolve(undefined)\\nconst chunkCache = new Map<ChunkPath, Promise<any> | null>()\\n\\nfunction clearChunkCache() {\\n  chunkCache.clear()\\n}\\n\\nfunction loadChunkPath(chunkPath: ChunkPath, source?: SourceInfo): void {\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return\\n  }\\n\\n  if (loadedChunks.has(chunkPath)) {\\n    return\\n  }\\n\\n  try {\\n    const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n    const chunkModules: CompressedModuleFactories = require(resolved)\\n\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        if (Array.isArray(moduleFactory)) {\\n          let [moduleFactoryFn, otherIds] = moduleFactory\\n          moduleFactories[moduleId] = moduleFactoryFn\\n          for (const otherModuleId of otherIds) {\\n            moduleFactories[otherModuleId] = moduleFactoryFn\\n          }\\n        } else {\\n          moduleFactories[moduleId] = moduleFactory\\n        }\\n      }\\n    }\\n    loadedChunks.add(chunkPath)\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`\\n\\n    if (source) {\\n      errorMessage += ` from ${stringifySourceInfo(source)}`\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    })\\n  }\\n}\\n\\nasync function loadChunkAsyncUncached(\\n  source: SourceInfo,\\n  chunkPath: ChunkPath\\n): Promise<void> {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  try {\\n    const contents = await fs.readFile(resolved, 'utf-8')\\n\\n    const localRequire = (id: string) => {\\n      let resolvedId = require.resolve(id, { paths: [path.dirname(resolved)] })\\n      return require(resolvedId)\\n    }\\n    const module = {\\n      exports: {},\\n    }\\n    // TODO: Use vm.runInThisContext once our minimal supported Node.js version includes https://github.com/nodejs/node/pull/52153\\n    // eslint-disable-next-line no-eval -- Can't use vm.runInThisContext due to https://github.com/nodejs/node/issues/52102\\n    ;(0, eval)(\\n      '(function(module, exports, require, __dirname, __filename) {' +\\n        contents +\\n        '\\\\n})' +\\n        '\\\\n//# sourceURL=' +\\n        url.pathToFileURL(resolved)\\n    )(module, module.exports, localRequire, path.dirname(resolved), resolved)\\n\\n    const chunkModules: CompressedModuleFactories = module.exports\\n    for (const [moduleId, moduleFactory] of Object.entries(chunkModules)) {\\n      if (!moduleFactories[moduleId]) {\\n        if (Array.isArray(moduleFactory)) {\\n          let [moduleFactoryFn, otherIds] = moduleFactory\\n          moduleFactories[moduleId] = moduleFactoryFn\\n          for (const otherModuleId of otherIds) {\\n            moduleFactories[otherModuleId] = moduleFactoryFn\\n          }\\n        } else {\\n          moduleFactories[moduleId] = moduleFactory\\n        }\\n      }\\n    }\\n  } catch (e) {\\n    let errorMessage = `Failed to load chunk ${chunkPath}`\\n\\n    if (source) {\\n      errorMessage += ` from ${stringifySourceInfo(source)}`\\n    }\\n\\n    throw new Error(errorMessage, {\\n      cause: e,\\n    })\\n  }\\n}\\n\\nfunction loadChunkAsync(\\n  source: SourceInfo,\\n  chunkData: ChunkData\\n): Promise<any> {\\n  const chunkPath = typeof chunkData === 'string' ? chunkData : chunkData.path\\n  if (!isJs(chunkPath)) {\\n    // We only support loading JS chunks in Node.js.\\n    // This branch can be hit when trying to load a CSS chunk.\\n    return unsupportedLoadChunk\\n  }\\n\\n  let entry = chunkCache.get(chunkPath)\\n  if (entry === undefined) {\\n    const resolve = chunkCache.set.bind(chunkCache, chunkPath, null)\\n    // A new Promise ensures callers that don't handle rejection will still trigger one unhandled rejection.\\n    // Handling the rejection will not trigger unhandled rejections.\\n    entry = loadChunkAsyncUncached(source, chunkPath).then(resolve)\\n    chunkCache.set(chunkPath, entry)\\n  }\\n  // TODO: Return an instrumented Promise that React can use instead of relying on referential equality.\\n  return entry === null ? loadedChunk : entry\\n}\\n\\nfunction loadChunkAsyncByUrl(source: SourceInfo, chunkUrl: string) {\\n  const path = url.fileURLToPath(new URL(chunkUrl, RUNTIME_ROOT)) as ChunkPath\\n  return loadChunkAsync(source, path)\\n}\\n\\nfunction loadWebAssembly(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module,\\n  imports: WebAssembly.Imports\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return instantiateWebAssemblyFromPath(resolved, imports)\\n}\\n\\nfunction loadWebAssemblyModule(\\n  chunkPath: ChunkPath,\\n  _edgeModule: () => WebAssembly.Module\\n) {\\n  const resolved = path.resolve(RUNTIME_ROOT, chunkPath)\\n\\n  return compileWebAssemblyFromPath(resolved)\\n}\\n\\nfunction getWorkerBlobURL(_chunks: ChunkPath[]): string {\\n  throw new Error('Worker blobs are not implemented yet for Node.js')\\n}\\n\\nfunction instantiateModule(id: ModuleId, source: SourceInfo): Module {\\n  const moduleFactory = moduleFactories[id]\\n  if (typeof moduleFactory !== 'function') {\\n    // This can happen if modules incorrectly handle HMR disposes/updates,\\n    // e.g. when they keep a `setTimeout` around which still executes old code\\n    // and contains e.g. a `require(\\\"something\\\")` call.\\n    let instantiationReason\\n    switch (source.type) {\\n      case SourceType.Runtime:\\n        instantiationReason = `as a runtime entry of chunk ${source.chunkPath}`\\n        break\\n      case SourceType.Parent:\\n        instantiationReason = `because it was required from module ${source.parentId}`\\n        break\\n      default:\\n        invariant(source, (source) => `Unknown source type: ${source?.type}`)\\n    }\\n    throw new Error(\\n      `Module ${id} was instantiated ${instantiationReason}, but the module factory is not available. It might have been deleted in an HMR update.`\\n    )\\n  }\\n\\n  const module: Module = {\\n    exports: {},\\n    error: undefined,\\n    loaded: false,\\n    id,\\n    namespaceObject: undefined,\\n  }\\n  moduleCache[id] = module\\n\\n  // NOTE(alexkirsz) This can fail when the module encounters a runtime error.\\n  try {\\n    const r = commonJsRequire.bind(null, module)\\n    moduleFactory.call(module.exports, {\\n      a: asyncModule.bind(null, module),\\n      e: module.exports,\\n      r,\\n      t: runtimeRequire,\\n      x: externalRequire,\\n      y: externalImport,\\n      f: moduleContext,\\n      i: esmImport.bind(null, module),\\n      s: esmExport.bind(null, module, module.exports, moduleCache),\\n      j: dynamicExport.bind(null, module, module.exports, moduleCache),\\n      v: exportValue.bind(null, module, moduleCache),\\n      n: exportNamespace.bind(null, module, moduleCache),\\n      m: module,\\n      c: moduleCache,\\n      M: moduleFactories,\\n      l: loadChunkAsync.bind(null, { type: SourceType.Parent, parentId: id }),\\n      L: loadChunkAsyncByUrl.bind(null, {\\n        type: SourceType.Parent,\\n        parentId: id,\\n      }),\\n      w: loadWebAssembly,\\n      u: loadWebAssemblyModule,\\n      P: resolveAbsolutePath,\\n      U: relativeURL,\\n      R: createResolvePathFromModule(r),\\n      b: getWorkerBlobURL,\\n      z: requireStub,\\n    })\\n  } catch (error) {\\n    module.error = error as any\\n    throw error\\n  }\\n\\n  module.loaded = true\\n  if (module.namespaceObject && module.exports !== module.namespaceObject) {\\n    // in case of a circular dependency: cjs1 -> esm2 -> cjs1\\n    interopEsm(module.exports, module.namespaceObject)\\n  }\\n\\n  return module\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it if it is not cached.\\n */\\n// @ts-ignore\\nfunction getOrInstantiateModuleFromParent(\\n  id: ModuleId,\\n  sourceModule: Module\\n): Module {\\n  const module = moduleCache[id]\\n\\n  if (module) {\\n    return module\\n  }\\n\\n  return instantiateModule(id, {\\n    type: SourceType.Parent,\\n    parentId: sourceModule.id,\\n  })\\n}\\n\\n/**\\n * Instantiates a runtime module.\\n */\\nfunction instantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  return instantiateModule(moduleId, { type: SourceType.Runtime, chunkPath })\\n}\\n\\n/**\\n * Retrieves a module from the cache, or instantiate it as a runtime module if it is not cached.\\n */\\n// @ts-ignore TypeScript doesn't separate this module space from the browser runtime\\nfunction getOrInstantiateRuntimeModule(\\n  moduleId: ModuleId,\\n  chunkPath: ChunkPath\\n): Module {\\n  const module = moduleCache[moduleId]\\n  if (module) {\\n    if (module.error) {\\n      throw module.error\\n    }\\n    return module\\n  }\\n\\n  return instantiateRuntimeModule(moduleId, chunkPath)\\n}\\n\\nconst regexJsUrl = /\\\\.js(?:\\\\?[^#]*)?(?:#.*)?$/\\n/**\\n * Checks if a given path/URL ends with .js, optionally followed by ?query or #fragment.\\n */\\nfunction isJs(chunkUrlOrPath: ChunkUrl | ChunkPath): boolean {\\n  return regexJsUrl.test(chunkUrlOrPath)\\n}\\n\\n// For hot-reloader\\n;(globalThis as any).__turbopack_clear_chunk_cache__ = clearChunkCache\\n\\nmodule.exports = {\\n  getOrInstantiateRuntimeModule,\\n  loadChunk,\\n}\\n\"],\"names\":[],\"mappings\":\"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\",\"ignoreList\":[0]}}]\n }\n\\ No newline at end of file"
        },
        {
            "sha": "b23abfd09138bbaa6a624925ae2108028763a4e1",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_dev_runtime/output/b1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js",
            "status": "modified",
            "additions": 28,
            "deletions": 21,
            "changes": 49,
            "blob_url": "https://github.com/vercel/next.js/blob/86562e1213f3a3230953c0e86bbe8291af3fcc7a/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js",
            "raw_url": "https://github.com/vercel/next.js/raw/86562e1213f3a3230953c0e86bbe8291af3fcc7a/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js?ref=86562e1213f3a3230953c0e86bbe8291af3fcc7a",
            "patch": "@@ -482,28 +482,35 @@ async function loadChunk(source, chunkData) {\n     }\n     return promise;\n }\n-async function loadChunkByUrl(source, chunkUrl) {\n-    try {\n-        await BACKEND.loadChunk(chunkUrl, source);\n-    } catch (error) {\n-        let loadReason;\n-        switch(source.type){\n-            case 0:\n-                loadReason = `as a runtime dependency of chunk ${source.chunkPath}`;\n-                break;\n-            case 1:\n-                loadReason = `from module ${source.parentId}`;\n-                break;\n-            case 2:\n-                loadReason = 'from an HMR update';\n-                break;\n-            default:\n-                invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n-        }\n-        throw new Error(`Failed to load chunk ${chunkUrl} ${loadReason}${error ? `: ${error}` : ''}`, error ? {\n-            cause: error\n-        } : undefined);\n+const instrumentedBackendLoadChunks = new WeakMap();\n+// Do not make this async. React relies on referential equality of the returned Promise.\n+function loadChunkByUrl(source, chunkUrl) {\n+    const thenable = BACKEND.loadChunk(chunkUrl, source);\n+    let entry = instrumentedBackendLoadChunks.get(thenable);\n+    if (entry === undefined) {\n+        entry = thenable.catch((error)=>{\n+            let loadReason;\n+            switch(source.type){\n+                case 0:\n+                    loadReason = `as a runtime dependency of chunk ${source.chunkPath}`;\n+                    break;\n+                case 1:\n+                    loadReason = `from module ${source.parentId}`;\n+                    break;\n+                case 2:\n+                    loadReason = 'from an HMR update';\n+                    break;\n+                default:\n+                    invariant(source, (source)=>`Unknown source type: ${source?.type}`);\n+            }\n+            throw new Error(`Failed to load chunk ${chunkUrl} ${loadReason}${error ? `: ${error}` : ''}`, error ? {\n+                cause: error\n+            } : undefined);\n+        });\n+        // TODO: Free the Promise once it resolves.\n+        instrumentedBackendLoadChunks.set(thenable, entry);\n     }\n+    return entry;\n }\n async function loadChunkPath(source, chunkPath) {\n     const url = getChunkRelativeUrl(chunkPath);"
        },
        {
            "sha": "84e00133cc1fe4e5a5cd99dd00d17373bb071411",
            "filename": "turbopack/crates/turbopack-tests/tests/snapshot/runtime/default_dev_runtime/output/b1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js.map",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/vercel/next.js/blob/86562e1213f3a3230953c0e86bbe8291af3fcc7a/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js.map",
            "raw_url": "https://github.com/vercel/next.js/raw/86562e1213f3a3230953c0e86bbe8291af3fcc7a/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js.map",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbopack-tests%2Ftests%2Fsnapshot%2Fruntime%2Fdefault_dev_runtime%2Foutput%2Fb1abf_turbopack-tests_tests_snapshot_runtime_default_dev_runtime_input_index_73aab4ae.js.map?ref=86562e1213f3a3230953c0e86bbe8291af3fcc7a"
        }
    ],
    "stats": {
        "total": 224,
        "additions": 142,
        "deletions": 82
    }
}