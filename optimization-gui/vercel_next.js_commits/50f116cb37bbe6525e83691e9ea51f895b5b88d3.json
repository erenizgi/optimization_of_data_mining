{
    "author": "sokra",
    "message": "Turbopack: when reading a non yet existing cell from a in progress tasks, wait for the computation to finish (#77029)\n\n<!-- Thanks for opening a PR! Your contribution is much appreciated.\nTo make sure your PR is handled as smoothly as possible we request that you follow the checklist sections below.\nChoose the right checklist for the change(s) that you're making:\n\n## For Contributors\n\n### Improving Documentation\n\n- Run `pnpm prettier-fix` to fix formatting issues before opening the PR.\n- Read the Docs Contribution Guide to ensure your contribution follows the docs guidelines: https://nextjs.org/docs/community/contribution-guide\n\n### Adding or Updating Examples\n\n- The \"examples guidelines\" are followed from our contributing doc https://github.com/vercel/next.js/blob/canary/contributing/examples/adding-examples.md\n- Make sure the linting passes by running `pnpm build && pnpm lint`. See https://github.com/vercel/next.js/blob/canary/contributing/repository/linting.md\n\n### Fixing a bug\n\n- Related issues linked using `fixes #number`\n- Tests added. See: https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs\n- Errors have a helpful link attached, see https://github.com/vercel/next.js/blob/canary/contributing.md\n\n### Adding a feature\n\n- Implements an existing feature request or RFC. Make sure the feature request has been accepted for implementation before opening a PR. (A discussion must be opened, see https://github.com/vercel/next.js/discussions/new?category=ideas)\n- Related issues/discussions are linked using `fixes #number`\n- e2e tests added (https://github.com/vercel/next.js/blob/canary/contributing/core/testing.md#writing-tests-for-nextjs)\n- Documentation added\n- Telemetry added. In case of a feature if it's used or not.\n- Errors have a helpful link attached, see https://github.com/vercel/next.js/blob/canary/contributing.md\n\n\n## For Maintainers\n\n- Minimal description (aim for explaining to someone not on the team to understand the PR)\n- When linking to a Slack thread, you might want to share details of the conclusion\n- Link both the Linear (Fixes NEXT-xxx) and the GitHub issues\n- Add review comments if necessary to explain to the reviewer the logic behind a change\n\n### What?\n\n### Why?\n\n### How?\n\nCloses NEXT-\nFixes #\n\n-->",
    "sha": "50f116cb37bbe6525e83691e9ea51f895b5b88d3",
    "files": [
        {
            "sha": "c53a986bfddd984a56f107d9bdc0a57834d8f818",
            "filename": "turbopack/crates/turbo-tasks-backend/src/backend/mod.rs",
            "status": "modified",
            "additions": 66,
            "deletions": 80,
            "changes": 146,
            "blob_url": "https://github.com/vercel/next.js/blob/50f116cb37bbe6525e83691e9ea51f895b5b88d3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/50f116cb37bbe6525e83691e9ea51f895b5b88d3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Fsrc%2Fbackend%2Fmod.rs?ref=50f116cb37bbe6525e83691e9ea51f895b5b88d3",
            "patch": "@@ -676,20 +676,29 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             )));\n         }\n \n+        let in_progress = get!(task, InProgress);\n+        if matches!(in_progress, Some(InProgressState::InProgress(..))) {\n+            return Ok(Err(self.listen_to_cell(&mut task, task_id, reader, cell).0));\n+        }\n+        let is_cancelled = matches!(in_progress, Some(InProgressState::Canceled));\n+        let is_scheduled = matches!(in_progress, Some(InProgressState::Scheduled { .. }));\n+\n         // Check cell index range (cell might not exist at all)\n-        let Some(max_id) = get!(\n+        let max_id = get!(\n             task,\n             CellTypeMaxIndex {\n                 cell_type: cell.type_id\n             }\n-        ) else {\n+        )\n+        .copied();\n+        let Some(max_id) = max_id else {\n             add_cell_dependency(self, task, reader, cell, task_id, &mut ctx);\n             bail!(\n                 \"Cell {cell:?} no longer exists in task {} (no cell of this type exists)\",\n                 ctx.get_task_description(task_id)\n             );\n         };\n-        if cell.index >= *max_id {\n+        if cell.index >= max_id {\n             add_cell_dependency(self, task, reader, cell, task_id, &mut ctx);\n             bail!(\n                 \"Cell {cell:?} no longer exists in task {} (index out of bounds)\",\n@@ -700,19 +709,9 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         // Cell should exist, but data was dropped or is not serializable. We need to recompute the\n         // task the get the cell content.\n \n-        let reader_desc = reader.map(|r| self.get_task_desc_fn(r));\n-        let note = move || {\n-            if let Some(reader_desc) = reader_desc.as_ref() {\n-                format!(\"try_read_task_cell from {}\", reader_desc())\n-            } else {\n-                \"try_read_task_cell (untracked)\".to_string()\n-            }\n-        };\n-\n-        // Register event listener for cell computation\n-        if let Some(in_progress) = get!(task, InProgressCell { cell }) {\n-            // Someone else is already computing the cell\n-            let listener = in_progress.event.listen_with_note(note);\n+        // Listen to the cell and potentially schedule the task\n+        let (listener, new_listener) = self.listen_to_cell(&mut task, task_id, reader, cell);\n+        if !new_listener {\n             return Ok(Err(listener));\n         }\n \n@@ -723,58 +722,47 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n         )\n         .entered();\n \n-        // We create the event and potentially schedule the task\n-        let in_progress = InProgressCellState::new(task_id, cell);\n+        // Schedule the task, if not already scheduled\n+        if is_cancelled {\n+            bail!(\"{} was canceled\", ctx.get_task_description(task_id));\n+        } else if !is_scheduled\n+            && task.add(CachedDataItem::new_scheduled(\n+                self.get_task_desc_fn(task_id),\n+            ))\n+        {\n+            turbo_tasks.schedule(task_id);\n+        }\n+\n+        Ok(Err(listener))\n+    }\n \n+    fn listen_to_cell(\n+        &self,\n+        task: &mut impl TaskGuard,\n+        task_id: TaskId,\n+        reader: Option<TaskId>,\n+        cell: CellId,\n+    ) -> (EventListener, bool) {\n+        let reader_desc = reader.map(|r| self.get_task_desc_fn(r));\n+        let note = move || {\n+            if let Some(reader_desc) = reader_desc.as_ref() {\n+                format!(\"try_read_task_cell (in progress) from {}\", reader_desc())\n+            } else {\n+                \"try_read_task_cell (in progress, untracked)\".to_string()\n+            }\n+        };\n+        if let Some(in_progress) = get!(task, InProgressCell { cell }) {\n+            // Someone else is already computing the cell\n+            let listener = in_progress.event.listen_with_note(note);\n+            return (listener, false);\n+        }\n+        let in_progress = InProgressCellState::new(task_id, cell);\n         let listener = in_progress.event.listen_with_note(note);\n         task.add_new(CachedDataItem::InProgressCell {\n             cell,\n             value: in_progress,\n         });\n-\n-        // Schedule the task, if not already scheduled\n-        if let Some(existing) = get!(task, InProgress) {\n-            match existing {\n-                InProgressState::InProgress(box InProgressStateInner { stale, .. }) => {\n-                    if !*stale {\n-                        let idx = get!(\n-                            task,\n-                            CellTypeMaxIndex {\n-                                cell_type: cell.type_id\n-                            }\n-                        )\n-                        .copied()\n-                        .unwrap_or_default();\n-                        if cell.index <= idx {\n-                            // The current execution is past the cell, so we need to reexecute.\n-                            let Some(InProgressState::InProgress(box InProgressStateInner {\n-                                stale,\n-                                ..\n-                            })) = get_mut!(task, InProgress)\n-                            else {\n-                                unreachable!();\n-                            };\n-                            *stale = true;\n-                        } else {\n-                            // The cell will still be written in the current execution, so we can\n-                            // just continue here.\n-                        }\n-                    }\n-                }\n-                InProgressState::Scheduled { .. } => {\n-                    // Already scheduled\n-                }\n-                InProgressState::Canceled => {\n-                    bail!(\"{} was canceled\", ctx.get_task_description(task_id));\n-                }\n-            }\n-        } else if task.add(CachedDataItem::new_scheduled(\n-            self.get_task_desc_fn(task_id),\n-        )) {\n-            turbo_tasks.schedule(task_id);\n-        }\n-\n-        Ok(Err(listener))\n+        (listener, true)\n     }\n \n     fn lookup_task_type(&self, task_id: TaskId) -> Option<Arc<CachedTaskType>> {\n@@ -1385,25 +1373,8 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             old_edges.extend(iter_many!(task, Child { task } => task).map(OutdatedEdge::Child));\n         }\n \n-        // Remove no longer existing cells and notify in progress cells\n+        // Remove no longer existing cells and\n         // find all outdated data items (removed cells, outdated edges)\n-        removed_data.extend(\n-            task.extract_if(CachedDataItemType::InProgressCell, |key, value| {\n-                match (key, value) {\n-                    (\n-                        CachedDataItemKey::InProgressCell { cell },\n-                        CachedDataItemValueRef::InProgressCell { value },\n-                    ) if cell_counters\n-                        .get(&cell.type_id)\n-                        .is_none_or(|start_index| cell.index >= *start_index) =>\n-                    {\n-                        value.event.notify(usize::MAX);\n-                        true\n-                    }\n-                    _ => false,\n-                }\n-            }),\n-        );\n         removed_data.extend(task.extract_if(CachedDataItemType::CellData, |key, _| {\n             matches!(key, CachedDataItemKey::CellData { cell } if cell_counters\n                         .get(&cell.type_id).is_none_or(|start_index| cell.index >= *start_index))\n@@ -1540,6 +1511,21 @@ impl<B: BackingStorage> TurboTasksBackendInner<B> {\n             return true;\n         }\n \n+        // Notify in progress cells\n+        removed_data.extend(task.extract_if(\n+            CachedDataItemType::InProgressCell,\n+            |key, value| match (key, value) {\n+                (\n+                    CachedDataItemKey::InProgressCell { .. },\n+                    CachedDataItemValueRef::InProgressCell { value },\n+                ) => {\n+                    value.event.notify(usize::MAX);\n+                    true\n+                }\n+                _ => false,\n+            },\n+        ));\n+\n         // Update the dirty state\n         let new_dirty_state = if session_dependent {\n             Some(DirtyState {"
        }
    ],
    "stats": {
        "total": 146,
        "additions": 66,
        "deletions": 80
    }
}