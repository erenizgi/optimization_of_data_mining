{
    "author": "sokra",
    "message": "Turbopack: move tests to backend (#80995)\n\n### What?\n\nWe no longer have multiple backends, so no need to have these symlink hack to clone tests",
    "sha": "5c1769ea89483c3fe5396817149a4849e5cd62a3",
    "files": [
        {
            "sha": "391ab595a93e26ff2684f12233a790887f30d690",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/all_in_one.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fall_in_one.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fall_in_one.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fall_in_one.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/all_in_one.rs\n\\ No newline at end of file"
        },
        {
            "sha": "f9321cfd797fb32d485ccbf58e57cd1f54d55cd6",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/all_in_one.rs",
            "status": "added",
            "additions": 205,
            "deletions": 0,
            "changes": 205,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fall_in_one.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fall_in_one.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fall_in_one.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,205 @@\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+\n+use anyhow::{Result, bail};\n+use turbo_rcstr::{RcStr, rcstr};\n+use turbo_tasks::{ResolvedVc, TaskInput, ValueToString, Vc};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn all_in_one() {\n+    run(&REGISTRATION, || async {\n+        let a: Vc<u32> = Vc::cell(4242);\n+        assert_eq!(*a.await?, 4242);\n+\n+        let a: Vc<MyTransparentValue> = Vc::cell(4242);\n+        assert_eq!(*a.await?, 4242);\n+\n+        let b = MyEnumValue::cell(MyEnumValue::More(MyEnumValue::Yeah(42).resolved_cell()));\n+        assert_eq!(*b.to_string().await?, \"42\");\n+\n+        let c = MyStructValue {\n+            value: 42,\n+            next: Some(MyStructValue::new(a).to_resolved().await?),\n+        }\n+        .into();\n+\n+        let result = my_function(a, b.get_last(), c, MyEnumValue::Yeah(42));\n+        assert_eq!(*result.my_trait_function().await?, \"42\");\n+        assert_eq!(*result.my_trait_function2().await?, \"42\");\n+        assert_eq!(*result.my_trait_function3().await?, \"4242\");\n+        assert_eq!(*result.to_string().await?, \"42\");\n+\n+        // Testing Vc<Self> in traits\n+\n+        let a: Vc<Number> = Vc::cell(32);\n+        let b: Vc<Number> = Vc::cell(10);\n+        let c: Vc<Number> = a.add(Vc::upcast(b));\n+\n+        assert_eq!(*c.await?, 42);\n+\n+        let a_erased: Vc<Box<dyn Add>> = Vc::upcast(a);\n+        let b_erased: Vc<Box<dyn Add>> = Vc::upcast(b);\n+        let c_erased: Vc<Box<dyn Add>> = a_erased.add(b_erased);\n+\n+        assert_eq!(\n+            *Vc::try_resolve_downcast_type::<Number>(c_erased)\n+                .await?\n+                .unwrap()\n+                .await?,\n+            42\n+        );\n+\n+        let b_erased_other: Vc<Box<dyn Add>> = Vc::upcast(Vc::<NumberB>::cell(10));\n+        let c_erased_invalid: Vc<Box<dyn Add>> = a_erased.add(b_erased_other);\n+        assert!(c_erased_invalid.resolve().await.is_err());\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::value(transparent)]\n+#[derive(Debug, Clone, Hash)]\n+struct MyTransparentValue(u32);\n+\n+#[turbo_tasks::value(shared)]\n+#[derive(Debug, Clone, Hash, TaskInput)]\n+enum MyEnumValue {\n+    Yeah(u32),\n+    Nah,\n+    More(ResolvedVc<MyEnumValue>),\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl MyEnumValue {\n+    #[turbo_tasks::function]\n+    pub async fn get_last(self: Vc<Self>) -> Result<Vc<Self>> {\n+        let mut current = self;\n+        while let MyEnumValue::More(more) = &*current.await? {\n+            current = **more;\n+        }\n+        Ok(current)\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ValueToString for MyEnumValue {\n+    #[turbo_tasks::function]\n+    fn to_string(&self) -> Vc<RcStr> {\n+        match self {\n+            MyEnumValue::Yeah(value) => Vc::cell(value.to_string().into()),\n+            MyEnumValue::Nah => Vc::cell(rcstr!(\"nah\")),\n+            MyEnumValue::More(more) => more.to_string(),\n+        }\n+    }\n+}\n+\n+#[turbo_tasks::value(shared)]\n+struct MyStructValue {\n+    value: u32,\n+    next: Option<ResolvedVc<MyStructValue>>,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl MyStructValue {\n+    #[turbo_tasks::function]\n+    pub async fn new(value: Vc<MyTransparentValue>) -> Result<Vc<Self>> {\n+        Ok(Self::cell(MyStructValue {\n+            value: *value.await?,\n+            next: None,\n+        }))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ValueToString for MyStructValue {\n+    #[turbo_tasks::function]\n+    fn to_string(&self) -> Vc<RcStr> {\n+        Vc::cell(self.value.to_string().into())\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl MyTrait for MyStructValue {\n+    #[turbo_tasks::function]\n+    fn my_trait_function2(self: Vc<Self>) -> Vc<RcStr> {\n+        self.to_string()\n+    }\n+    #[turbo_tasks::function]\n+    fn my_trait_function3(&self) -> Result<Vc<RcStr>> {\n+        if let Some(next) = self.next {\n+            return Ok(next.my_trait_function3());\n+        }\n+        Ok(Vc::cell(self.value.to_string().into()))\n+    }\n+}\n+\n+#[turbo_tasks::value_trait]\n+trait MyTrait: ValueToString {\n+    #[turbo_tasks::function]\n+    async fn my_trait_function(self: Vc<Self>) -> Result<Vc<RcStr>> {\n+        if *self.to_string().await? != \"42\" {\n+            bail!(\"my_trait_function must only be called with 42 as value\")\n+        }\n+        // Calling a function twice\n+        Ok(self.to_string())\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn my_trait_function2(self: Vc<Self>) -> Vc<RcStr>;\n+    #[turbo_tasks::function]\n+    fn my_trait_function3(self: Vc<Self>) -> Vc<RcStr>;\n+}\n+\n+#[turbo_tasks::function]\n+async fn my_function(\n+    a: Vc<MyTransparentValue>,\n+    b: Vc<MyEnumValue>,\n+    c: Vc<MyStructValue>,\n+    d: MyEnumValue,\n+) -> Result<Vc<MyStructValue>> {\n+    assert_eq!(*a.await?, 4242);\n+    assert_eq!(*b.await?, MyEnumValue::Yeah(42));\n+    assert_eq!(c.await?.value, 42);\n+    assert_eq!(d, MyEnumValue::Yeah(42));\n+    Ok(c)\n+}\n+\n+#[turbo_tasks::value_trait]\n+trait Add {\n+    #[turbo_tasks::function]\n+    fn add(self: Vc<Self>, other: Vc<Box<dyn Add>>) -> Vc<Self>;\n+}\n+\n+#[turbo_tasks::value(transparent)]\n+struct Number(u32);\n+\n+#[turbo_tasks::value_impl]\n+impl Add for Number {\n+    #[turbo_tasks::function]\n+    async fn add(self: Vc<Self>, other: Vc<Box<dyn Add>>) -> Result<Vc<Self>> {\n+        let Some(other) = Vc::try_resolve_downcast_type::<Number>(other).await? else {\n+            bail!(\"Expected Number\");\n+        };\n+        Ok(Vc::cell(*self.await? + *other.await?))\n+    }\n+}\n+\n+#[turbo_tasks::value(transparent)]\n+struct NumberB(u32);\n+\n+#[turbo_tasks::value_impl]\n+impl Add for NumberB {\n+    #[turbo_tasks::function]\n+    async fn add(self: Vc<Self>, other: Vc<Box<dyn Add>>) -> Result<Vc<Self>> {\n+        let Some(other) = Vc::try_resolve_downcast_type::<NumberB>(other).await? else {\n+            bail!(\"Expected NumberB\");\n+        };\n+        Ok(Vc::cell(*self.await? + *other.await?))\n+    }\n+}"
        },
        {
            "sha": "d2c98272f0102e92f62e2c3a406297cae5d0e0a8",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/basic.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbasic.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbasic.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbasic.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/basic.rs\n\\ No newline at end of file"
        },
        {
            "sha": "a12da0b8578d8eacd60210900d44257ef67e7877",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/basic.rs",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbasic.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbasic.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fbasic.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,74 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use anyhow::Result;\n+use turbo_tasks::Vc;\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn basic() {\n+    run(&REGISTRATION, || async {\n+        let output1 = func_without_args();\n+        assert_eq!(output1.await?.value, 123);\n+\n+        let input = Value { value: 42 }.cell();\n+        let output2 = func_transient(input);\n+        assert_eq!(output2.await?.value, 42);\n+\n+        let output3 = func_persistent(output1);\n+        assert_eq!(output3.await?.value, 123);\n+\n+        let output4 = nested_func_without_args_waiting();\n+        assert_eq!(output4.await?.value, 123);\n+\n+        let output5 = nested_func_without_args_non_waiting();\n+        assert_eq!(output5.await?.value, 123);\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::value]\n+#[derive(Clone, Debug)]\n+struct Value {\n+    value: u32,\n+}\n+\n+#[turbo_tasks::function]\n+async fn func_transient(input: Vc<Value>) -> Result<Vc<Value>> {\n+    println!(\"func_transient\");\n+    let value = input.await?.value;\n+    Ok(Value { value }.cell())\n+}\n+\n+#[turbo_tasks::function]\n+async fn func_persistent(input: Vc<Value>) -> Result<Vc<Value>> {\n+    println!(\"func_persistent\");\n+    let value = input.await?.value;\n+    Ok(Value { value }.cell())\n+}\n+\n+#[turbo_tasks::function]\n+fn func_without_args() -> Result<Vc<Value>> {\n+    println!(\"func_without_args\");\n+    let value = 123;\n+    Ok(Value { value }.cell())\n+}\n+\n+#[turbo_tasks::function]\n+async fn nested_func_without_args_waiting() -> Result<Vc<Value>> {\n+    println!(\"nested_func_without_args_waiting\");\n+    let value = func_without_args().owned().await?;\n+    Ok(value.cell())\n+}\n+\n+#[turbo_tasks::function]\n+fn nested_func_without_args_non_waiting() -> Result<Vc<Value>> {\n+    println!(\"nested_func_without_args_non_waiting\");\n+    Ok(func_without_args())\n+}"
        },
        {
            "sha": "b20501cd53c797d0ed3f67cf3ced0f4ff95f31f3",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/call_types.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcall_types.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcall_types.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcall_types.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/call_types.rs\n\\ No newline at end of file"
        },
        {
            "sha": "17875d2630d78588665002a3de7c30140c63de14",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/call_types.rs",
            "status": "added",
            "additions": 203,
            "deletions": 0,
            "changes": 203,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcall_types.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcall_types.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcall_types.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,203 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use anyhow::Result;\n+use turbo_tasks::Vc;\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn functions() {\n+    run(&REGISTRATION, || async {\n+        assert_eq!(*fn_plain().await?, 42);\n+        assert_eq!(*fn_arg(43).await?, 43);\n+        assert_eq!(*fn_vc_arg(Vc::cell(44)).await?, 44);\n+        assert_eq!(*async_fn_plain().await?, 42);\n+        assert_eq!(*async_fn_arg(43).await?, 43);\n+        assert_eq!(*async_fn_vc_arg(Vc::cell(44)).await?, 44);\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::function]\n+fn fn_plain() -> Vc<u32> {\n+    Vc::cell(42)\n+}\n+\n+#[turbo_tasks::function]\n+fn fn_arg(n: u32) -> Vc<u32> {\n+    Vc::cell(n)\n+}\n+\n+#[turbo_tasks::function]\n+fn fn_vc_arg(n: Vc<u32>) -> Vc<u32> {\n+    n\n+}\n+\n+#[turbo_tasks::function]\n+fn async_fn_plain() -> Result<Vc<u32>> {\n+    Ok(Vc::cell(42))\n+}\n+\n+#[turbo_tasks::function]\n+fn async_fn_arg(n: u32) -> Result<Vc<u32>> {\n+    Ok(Vc::cell(n))\n+}\n+\n+#[turbo_tasks::function]\n+async fn async_fn_vc_arg(n: Vc<u32>) -> Result<Vc<u32>> {\n+    Ok(Vc::cell(*n.await?))\n+}\n+\n+#[tokio::test]\n+async fn methods() {\n+    run(&REGISTRATION, || async {\n+        assert_eq!(*Value::static_method().await?, 42);\n+        assert_eq!(*Value::async_static_method().await?, 42);\n+\n+        let value = Value(43).cell();\n+        assert_eq!(*value.method().await?, 43);\n+        assert_eq!(*value.async_method().await?, 43);\n+        assert_eq!(*value.vc_method().await?, 42);\n+        assert_eq!(*value.async_vc_method().await?, 43);\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::value]\n+struct Value(u32);\n+\n+#[turbo_tasks::value_impl]\n+impl Value {\n+    #[turbo_tasks::function]\n+    fn static_method() -> Vc<u32> {\n+        Vc::cell(42)\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn async_static_method() -> Result<Vc<u32>> {\n+        Ok(Vc::cell(42))\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn method(&self) -> Vc<u32> {\n+        Vc::cell(self.0)\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn async_method(&self) -> Result<Vc<u32>> {\n+        Ok(Vc::cell(self.0))\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn vc_method(self: Vc<Self>) -> Vc<u32> {\n+        Vc::cell(42)\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn async_vc_method(&self) -> Result<Vc<u32>> {\n+        Ok(Vc::cell(self.0))\n+    }\n+}\n+\n+#[tokio::test]\n+async fn trait_methods() {\n+    run(&REGISTRATION, || async {\n+        assert_eq!(*Value::static_trait_method().await?, 42);\n+        assert_eq!(*Value::async_static_trait_method().await?, 42);\n+\n+        let value = Value(43).cell();\n+        assert_eq!(*value.trait_method().await?, 43);\n+        assert_eq!(*value.async_trait_method().await?, 43);\n+        assert_eq!(*value.default_trait_method().await?, 42);\n+        assert_eq!(*value.default_async_trait_method().await?, 42);\n+\n+        let trait_value: Vc<Box<dyn ValueTrait>> = Vc::upcast(value);\n+        assert_eq!(*trait_value.trait_method().await?, 43);\n+        assert_eq!(*trait_value.async_trait_method().await?, 43);\n+        assert_eq!(*trait_value.default_trait_method().await?, 42);\n+        assert_eq!(*trait_value.default_async_trait_method().await?, 42);\n+\n+        let value = wrap_value(value);\n+        assert_eq!(*value.trait_method().await?, 43);\n+        assert_eq!(*value.async_trait_method().await?, 43);\n+        assert_eq!(*value.default_trait_method().await?, 42);\n+        assert_eq!(*value.default_async_trait_method().await?, 42);\n+\n+        let trait_value = wrap_trait_value(trait_value);\n+        assert_eq!(*trait_value.trait_method().await?, 43);\n+        assert_eq!(*trait_value.async_trait_method().await?, 43);\n+        assert_eq!(*trait_value.default_trait_method().await?, 42);\n+        assert_eq!(*trait_value.default_async_trait_method().await?, 42);\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::function]\n+fn wrap_value(v: Vc<Value>) -> Vc<Value> {\n+    v\n+}\n+\n+#[turbo_tasks::function]\n+fn wrap_trait_value(v: Vc<Box<dyn ValueTrait>>) -> Vc<Box<dyn ValueTrait>> {\n+    v\n+}\n+\n+#[turbo_tasks::value_trait]\n+trait ValueTrait {\n+    #[turbo_tasks::function]\n+    fn static_trait_method() -> Vc<u32>;\n+    #[turbo_tasks::function]\n+    async fn async_static_trait_method() -> Result<Vc<u32>>;\n+    #[turbo_tasks::function]\n+    fn default_static_trait_method() -> Vc<u32> {\n+        Vc::cell(42)\n+    }\n+    #[turbo_tasks::function]\n+    fn default_async_static_trait_method() -> Result<Vc<u32>> {\n+        Ok(Vc::cell(42))\n+    }\n+    #[turbo_tasks::function]\n+    fn trait_method(&self) -> Vc<u32>;\n+    #[turbo_tasks::function]\n+    fn async_trait_method(&self) -> Result<Vc<u32>>;\n+    #[turbo_tasks::function]\n+    fn default_trait_method(self: Vc<Self>) -> Vc<u32> {\n+        Vc::cell(42)\n+    }\n+    #[turbo_tasks::function]\n+    fn default_async_trait_method(self: Vc<Self>) -> Result<Vc<u32>> {\n+        Ok(Vc::cell(42))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ValueTrait for Value {\n+    #[turbo_tasks::function]\n+    fn static_trait_method() -> Vc<u32> {\n+        Vc::cell(42)\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn async_static_trait_method() -> Result<Vc<u32>> {\n+        Ok(Vc::cell(42))\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn trait_method(&self) -> Vc<u32> {\n+        Vc::cell(self.0)\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn async_trait_method(&self) -> Result<Vc<u32>> {\n+        Ok(Vc::cell(self.0))\n+    }\n+}"
        },
        {
            "sha": "7de5bc7d80499a5edb81bcdef0c45032fe35ae5f",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/collectibles.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcollectibles.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcollectibles.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcollectibles.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/collectibles.rs\n\\ No newline at end of file"
        },
        {
            "sha": "a86c0e09343d078a8eaa006050435fef2360757a",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/collectibles.rs",
            "status": "added",
            "additions": 271,
            "deletions": 0,
            "changes": 271,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcollectibles.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcollectibles.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fcollectibles.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,271 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use std::time::Duration;\n+\n+use anyhow::Result;\n+use auto_hash_map::AutoSet;\n+use rustc_hash::FxHashSet;\n+use tokio::time::sleep;\n+use turbo_rcstr::{RcStr, rcstr};\n+use turbo_tasks::{CollectiblesSource, ResolvedVc, ValueToString, Vc, emit};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn transitive_emitting() {\n+    run(&REGISTRATION, || async {\n+        let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"\"));\n+        let result_val = result_op.connect().strongly_consistent().await?;\n+        let list = result_op.peek_collectibles::<Box<dyn ValueToString>>();\n+        assert_eq!(list.len(), 2);\n+        let mut expected = [\"123\", \"42\"].into_iter().collect::<FxHashSet<_>>();\n+        for collectible in list {\n+            assert!(expected.remove(collectible.to_string().await?.as_str()))\n+        }\n+        assert_eq!(result_val.0, 0);\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn transitive_emitting_indirect() {\n+    run(&REGISTRATION, || async {\n+        let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"\"));\n+        let collectibles_op = my_transitive_emitting_function_collectibles(rcstr!(\"\"), rcstr!(\"\"));\n+        let list = collectibles_op.connect().strongly_consistent().await?;\n+        assert_eq!(list.len(), 2);\n+        let mut expected = [\"123\", \"42\"].into_iter().collect::<FxHashSet<_>>();\n+        for collectible in list.iter() {\n+            assert!(expected.remove(collectible.to_string().await?.as_str()))\n+        }\n+        assert_eq!(result_op.connect().await?.0, 0);\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn multi_emitting() {\n+    run(&REGISTRATION, || async {\n+        let result_op = my_multi_emitting_function();\n+        let result_val = result_op.connect().strongly_consistent().await?;\n+        let list = result_op.peek_collectibles::<Box<dyn ValueToString>>();\n+        assert_eq!(list.len(), 2);\n+        let mut expected = [\"123\", \"42\"].into_iter().collect::<FxHashSet<_>>();\n+        for collectible in list {\n+            assert!(expected.remove(collectible.to_string().await?.as_str()))\n+        }\n+        assert_eq!(result_val.0, 0);\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn taking_collectibles() {\n+    run(&REGISTRATION, || async {\n+        let result_op = my_collecting_function();\n+        let result_val = result_op.connect().strongly_consistent().await?;\n+        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n+        // my_collecting_function already processed the collectibles so the list should\n+        // be empty\n+        assert!(list.is_empty());\n+        assert_eq!(result_val.0, 0);\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn taking_collectibles_extra_layer() {\n+    run(&REGISTRATION, || async {\n+        let result_op = my_collecting_function_indirect();\n+        let result_val = result_op.connect().strongly_consistent().await?;\n+        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n+        // my_collecting_function already processed the collectibles so the list should\n+        // be empty\n+        assert!(list.is_empty());\n+        assert_eq!(result_val.0, 0);\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn taking_collectibles_parallel() {\n+    run(&REGISTRATION, || async {\n+        let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"a\"));\n+        let result_val = result_op.connect().strongly_consistent().await?;\n+        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n+        assert_eq!(list.len(), 2);\n+        assert_eq!(result_val.0, 0);\n+\n+        let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"b\"));\n+        let result_val = result_op.connect().strongly_consistent().await?;\n+        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n+        assert_eq!(list.len(), 2);\n+        assert_eq!(result_val.0, 0);\n+\n+        let result_op =\n+            my_transitive_emitting_function_with_child_scope(rcstr!(\"\"), rcstr!(\"b\"), rcstr!(\"1\"));\n+        let result_val = result_op.connect().strongly_consistent().await?;\n+        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n+        assert_eq!(list.len(), 2);\n+        assert_eq!(result_val.0, 0);\n+\n+        let result_op =\n+            my_transitive_emitting_function_with_child_scope(rcstr!(\"\"), rcstr!(\"b\"), rcstr!(\"2\"));\n+        let result_val = result_op.connect().strongly_consistent().await?;\n+        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n+        assert_eq!(list.len(), 2);\n+        assert_eq!(result_val.0, 0);\n+\n+        let result_op =\n+            my_transitive_emitting_function_with_child_scope(rcstr!(\"\"), rcstr!(\"c\"), rcstr!(\"3\"));\n+        let result_val = result_op.connect().strongly_consistent().await?;\n+        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n+        assert_eq!(list.len(), 2);\n+        assert_eq!(result_val.0, 0);\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn taking_collectibles_with_resolve() {\n+    run(&REGISTRATION, || async {\n+        let result_op = my_transitive_emitting_function_with_resolve(rcstr!(\"resolve\"));\n+        result_op.connect().strongly_consistent().await?;\n+        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n+        assert_eq!(list.len(), 2);\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::value(transparent)]\n+struct Collectibles(AutoSet<ResolvedVc<Box<dyn ValueToString>>>);\n+\n+#[turbo_tasks::function(operation)]\n+async fn my_collecting_function() -> Result<Vc<Thing>> {\n+    let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"\"));\n+    let result_vc = result_op.connect();\n+    result_vc.await?;\n+    result_op.take_collectibles::<Box<dyn ValueToString>>();\n+    Ok(result_vc)\n+}\n+\n+#[turbo_tasks::function(operation)]\n+async fn my_collecting_function_indirect() -> Result<Vc<Thing>> {\n+    let result_op = my_collecting_function();\n+    let result_vc = result_op.connect();\n+    result_vc.strongly_consistent().await?;\n+    let list = result_op.peek_collectibles::<Box<dyn ValueToString>>();\n+    // my_collecting_function already processed the collectibles so the list should\n+    // be empty\n+    assert!(list.is_empty());\n+    Ok(result_vc)\n+}\n+\n+#[turbo_tasks::function(operation)]\n+async fn my_multi_emitting_function() -> Result<Vc<Thing>> {\n+    my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"a\"))\n+        .connect()\n+        .await?;\n+    my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"b\"))\n+        .connect()\n+        .await?;\n+    my_emitting_function(rcstr!(\"\")).await?;\n+    Ok(Thing::cell(Thing(0)))\n+}\n+\n+#[turbo_tasks::function(operation)]\n+async fn my_transitive_emitting_function(key: RcStr, key2: RcStr) -> Result<Vc<Thing>> {\n+    let _ = key2;\n+    my_emitting_function(key).await?;\n+    Ok(Thing::cell(Thing(0)))\n+}\n+\n+#[turbo_tasks::function(operation)]\n+fn my_transitive_emitting_function_collectibles(\n+    key: RcStr,\n+    key2: RcStr,\n+) -> Result<Vc<Collectibles>> {\n+    let result_op = my_transitive_emitting_function(key, key2);\n+    Ok(Vc::cell(\n+        result_op.peek_collectibles::<Box<dyn ValueToString>>(),\n+    ))\n+}\n+\n+#[turbo_tasks::function(operation)]\n+async fn my_transitive_emitting_function_with_child_scope(\n+    key: RcStr,\n+    key2: RcStr,\n+    key3: RcStr,\n+) -> Result<Vc<Thing>> {\n+    let _ = key3;\n+    let thing_op = my_transitive_emitting_function(key, key2);\n+    let thing_vc = thing_op.connect();\n+    thing_vc.await?;\n+    let list = thing_op.peek_collectibles::<Box<dyn ValueToString>>();\n+    assert_eq!(list.len(), 2);\n+    Ok(thing_vc)\n+}\n+\n+#[turbo_tasks::function]\n+async fn my_emitting_function(key: RcStr) -> Result<()> {\n+    let _ = key;\n+    sleep(Duration::from_millis(100)).await;\n+    emit(ResolvedVc::upcast::<Box<dyn ValueToString>>(Thing::new(\n+        123,\n+    )));\n+    emit(ResolvedVc::upcast::<Box<dyn ValueToString>>(Thing::new(42)));\n+    Ok(())\n+}\n+\n+#[turbo_tasks::function]\n+fn my_transitive_emitting_function_with_thing(key: RcStr, _thing: Vc<Thing>) -> Result<()> {\n+    let _ = my_emitting_function(key);\n+    Ok(())\n+}\n+\n+#[turbo_tasks::function(operation)]\n+fn my_transitive_emitting_function_with_resolve(key: RcStr) -> Result<()> {\n+    let _ = my_transitive_emitting_function_with_thing(key, get_thing(0));\n+    Ok(())\n+}\n+\n+#[turbo_tasks::value(shared)]\n+struct Thing(u32);\n+\n+impl Thing {\n+    fn new(v: u32) -> ResolvedVc<Self> {\n+        Self::resolved_cell(Thing(v))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ValueToString for Thing {\n+    #[turbo_tasks::function]\n+    fn to_string(&self) -> Vc<RcStr> {\n+        Vc::cell(self.0.to_string().into())\n+    }\n+}\n+\n+#[turbo_tasks::function]\n+fn get_thing(v: u32) -> Vc<Thing> {\n+    Thing::cell(Thing(v))\n+}"
        },
        {
            "sha": "ee7aea7eab52f2b2bf60a72a03eac9034d5194fb",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/debug.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdebug.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdebug.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdebug.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/debug.rs\n\\ No newline at end of file"
        },
        {
            "sha": "854d57b2343956559a89a080657bbe30f44fe704",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/debug.rs",
            "status": "added",
            "additions": 202,
            "deletions": 0,
            "changes": 202,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdebug.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdebug.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdebug.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,202 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use std::sync::Mutex;\n+\n+use turbo_tasks::{ResolvedVc, Vc, debug::ValueDebug};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn primitive_debug() {\n+    run(&REGISTRATION, || async {\n+        let a: Vc<u32> = Vc::cell(42);\n+        assert_eq!(format!(\"{:?}\", a.dbg().await?), \"42\");\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn transparent_debug() {\n+    run(&REGISTRATION, || async {\n+        let a: Vc<Transparent> = Transparent(42).cell();\n+        assert_eq!(format!(\"{:?}\", a.dbg().await?), \"42\");\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn enum_none_debug() {\n+    run(&REGISTRATION, || async {\n+        let a: Vc<Enum> = Enum::None.cell();\n+        assert_eq!(format!(\"{:?}\", a.dbg().await?), \"Enum :: None\");\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn enum_transparent_debug() {\n+    run(&REGISTRATION, || async {\n+        let a: Vc<Enum> = Enum::Transparent(Transparent(42).resolved_cell()).cell();\n+        assert_eq!(\n+            format!(\"{:?}\", a.dbg().await?),\n+            r#\"Enum :: Transparent(\n+    42,\n+)\"#\n+        );\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn enum_inner_vc_debug() {\n+    run(&REGISTRATION, || async {\n+        let a: Vc<Enum> = Enum::Enum(Enum::None.resolved_cell()).cell();\n+        assert_eq!(\n+            format!(\"{:?}\", a.dbg().await?),\n+            r#\"Enum :: Enum(\n+    Enum :: None,\n+)\"#\n+        );\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn struct_unit_debug() {\n+    run(&REGISTRATION, || async {\n+        let a: Vc<StructUnit> = StructUnit.cell();\n+        assert_eq!(format!(\"{:?}\", a.dbg().await?), \"StructUnit\");\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn struct_transparent_debug() {\n+    run(&REGISTRATION, || async {\n+        let a: Vc<StructWithTransparent> = StructWithTransparent {\n+            transparent: Transparent(42).resolved_cell(),\n+        }\n+        .cell();\n+        assert_eq!(\n+            format!(\"{:?}\", a.dbg().await?),\n+            r#\"StructWithTransparent {\n+    transparent: 42,\n+}\"#\n+        );\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn struct_vec_debug() {\n+    run(&REGISTRATION, || async {\n+        let a: Vc<StructWithVec> = StructWithVec { vec: vec![] }.cell();\n+        assert_eq!(\n+            format!(\"{:?}\", a.dbg().await?),\n+            r#\"StructWithVec {\n+    vec: [],\n+}\"#\n+        );\n+\n+        let b: Vc<StructWithVec> = StructWithVec {\n+            vec: vec![Transparent(42).resolved_cell()],\n+        }\n+        .cell();\n+        assert_eq!(\n+            format!(\"{:?}\", b.dbg().await?),\n+            r#\"StructWithVec {\n+    vec: [\n+        42,\n+    ],\n+}\"#\n+        );\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn struct_ignore_debug() {\n+    run(&REGISTRATION, || async {\n+        let a: Vc<StructWithIgnore> = StructWithIgnore {\n+            dont_ignore: 42,\n+            ignore: Mutex::new(()),\n+        }\n+        .cell();\n+        assert_eq!(\n+            format!(\"{:?}\", a.dbg().await?),\n+            r#\"StructWithIgnore {\n+    dont_ignore: 42,\n+}\"#\n+        );\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::value(transparent, shared)]\n+struct Transparent(u32);\n+\n+// Allow Enum::Enum\n+#[allow(clippy::enum_variant_names)]\n+#[turbo_tasks::value(shared)]\n+enum Enum {\n+    None,\n+    Transparent(ResolvedVc<Transparent>),\n+    Enum(ResolvedVc<Enum>),\n+}\n+\n+#[turbo_tasks::value(shared)]\n+struct StructUnit;\n+\n+#[turbo_tasks::value(shared)]\n+struct StructWithTransparent {\n+    transparent: ResolvedVc<Transparent>,\n+}\n+\n+#[turbo_tasks::value(shared)]\n+struct StructWithOption {\n+    option: Option<ResolvedVc<Transparent>>,\n+}\n+\n+#[turbo_tasks::value(shared)]\n+struct StructWithVec {\n+    vec: Vec<ResolvedVc<Transparent>>,\n+}\n+\n+#[turbo_tasks::value(shared, eq = \"manual\")]\n+struct StructWithIgnore {\n+    dont_ignore: u32,\n+    // We're using a `Mutex` instead of a `T: Debug` type to ensure we support `T: !Debug`.\n+    #[turbo_tasks(debug_ignore, trace_ignore)]\n+    ignore: Mutex<()>,\n+}\n+\n+impl PartialEq for StructWithIgnore {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.dont_ignore == other.dont_ignore\n+    }\n+}\n+\n+impl Eq for StructWithIgnore {}"
        },
        {
            "sha": "e726e54a7881e648ea8fc968a051d22b9f9e6256",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/detached.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/detached.rs\n\\ No newline at end of file"
        },
        {
            "sha": "73a083ac600156a63b6b1d664c5cdf777440c499",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/detached.rs",
            "status": "added",
            "additions": 170,
            "deletions": 0,
            "changes": 170,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdetached.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,170 @@\n+#![allow(clippy::needless_return)] // clippy bug causes false positive\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+\n+use tokio::{\n+    sync::{Notify, watch},\n+    time::{Duration, sleep, timeout},\n+};\n+use turbo_tasks::{\n+    State, TransientInstance, Vc, prevent_gc,\n+    trace::{TraceRawVcs, TraceRawVcsContext},\n+    turbo_tasks,\n+};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn test_spawns_detached() -> anyhow::Result<()> {\n+    run(&REGISTRATION, || async {\n+        // HACK: The watch channel we use has an incorrect implementation of `TraceRawVcs`, just\n+        // disable GC for the test so this can't cause any problems.\n+        prevent_gc();\n+        // timeout: prevent the test from hanging, and fail instead if this is broken\n+        timeout(Duration::from_secs(5), async {\n+            let notify = TransientInstance::new(NotifyTaskInput(Notify::new()));\n+            let (tx, mut rx) = watch::channel(None);\n+            let tx = TransientInstance::new(WatchSenderTaskInput(tx));\n+\n+            // create the task\n+            let out_vc = spawns_detached(notify.clone(), tx.clone());\n+\n+            // see that the task does not exit yet\n+            timeout(Duration::from_millis(100), out_vc.strongly_consistent())\n+                .await\n+                .expect_err(\"should wait on the detached task\");\n+\n+            // let the detached future exit\n+            notify.0.notify_waiters();\n+\n+            // it should send us back a cell\n+            let detached_vc: Vc<u32> = rx.wait_for(|opt| opt.is_some()).await?.unwrap();\n+            assert_eq!(*detached_vc.strongly_consistent().await?, 42);\n+\n+            // the parent task should now be able to exit\n+            out_vc.strongly_consistent().await?;\n+\n+            Ok(())\n+        })\n+        .await?\n+    })\n+    .await\n+}\n+\n+#[derive(TraceRawVcs)]\n+struct NotifyTaskInput(\n+    // trace_ignore: `notify` doesn't store any data\n+    #[turbo_tasks(trace_ignore)] Notify,\n+);\n+\n+struct WatchSenderTaskInput<T>(watch::Sender<T>);\n+\n+impl<T: TraceRawVcs> TraceRawVcs for WatchSenderTaskInput<T> {\n+    fn trace_raw_vcs(&self, _trace_context: &mut TraceRawVcsContext) {\n+        // HACK: This implementation is wrong (the channel contains a `Vc`), but we can't access it.\n+        // Instead we just `prevent_gc` in the tests.\n+    }\n+}\n+\n+#[turbo_tasks::function]\n+async fn spawns_detached(\n+    notify: TransientInstance<NotifyTaskInput>,\n+    sender: TransientInstance<WatchSenderTaskInput<Option<Vc<u32>>>>,\n+) -> Vc<()> {\n+    tokio::spawn(turbo_tasks().detached_for_testing(Box::pin(async move {\n+        notify.0.notified().await;\n+        // creating cells after the normal lifetime of the task should be okay, as the parent task\n+        // is waiting on us before exiting!\n+        sender.0.send(Some(Vc::cell(42))).unwrap();\n+        Ok(())\n+    })));\n+    Vc::cell(())\n+}\n+\n+#[tokio::test]\n+async fn test_spawns_detached_changing() -> anyhow::Result<()> {\n+    run(&REGISTRATION, || async {\n+        // HACK: The watch channel we use has an incorrect implementation of `TraceRawVcs`\n+        prevent_gc();\n+        // timeout: prevent the test from hanging, and fail instead if this is broken\n+        timeout(Duration::from_secs(5), async {\n+            let (tx, mut rx) = watch::channel(None);\n+            let tx = TransientInstance::new(WatchSenderTaskInput(tx));\n+\n+            // state that's read by the detached future\n+            let changing_input_detached = ChangingInput {\n+                state: State::new(42),\n+            }\n+            .cell();\n+\n+            // state that's read by the outer task\n+            let changing_input_outer = ChangingInput {\n+                state: State::new(0),\n+            }\n+            .cell();\n+\n+            // create the task\n+            let out_vc =\n+                spawns_detached_changing(tx.clone(), changing_input_detached, changing_input_outer);\n+\n+            // it should send us back a cell\n+            let detached_vc: Vc<u32> = rx.wait_for(|opt| opt.is_some()).await.unwrap().unwrap();\n+            assert_eq!(*detached_vc.strongly_consistent().await.unwrap(), 42);\n+\n+            // the parent task should now be able to exit\n+            out_vc.strongly_consistent().await.unwrap();\n+\n+            // changing either input should invalidate the vc and cause it to run again\n+            changing_input_detached.await.unwrap().state.set(43);\n+            out_vc.strongly_consistent().await.unwrap();\n+            assert_eq!(*detached_vc.strongly_consistent().await.unwrap(), 43);\n+\n+            changing_input_outer.await.unwrap().state.set(44);\n+            assert_eq!(*out_vc.strongly_consistent().await.unwrap(), 44);\n+\n+            Ok(())\n+        })\n+        .await?\n+    })\n+    .await\n+}\n+\n+#[turbo_tasks::value]\n+struct ChangingInput {\n+    state: State<u32>,\n+}\n+\n+#[turbo_tasks::function]\n+async fn spawns_detached_changing(\n+    sender: TransientInstance<WatchSenderTaskInput<Option<Vc<u32>>>>,\n+    changing_input_detached: Vc<ChangingInput>,\n+    changing_input_outer: Vc<ChangingInput>,\n+) -> Vc<u32> {\n+    let tt = turbo_tasks();\n+    tokio::spawn(tt.clone().detached_for_testing(Box::pin(async move {\n+        sleep(Duration::from_millis(100)).await;\n+        // nested detached_for_testing calls should work\n+        tokio::spawn(tt.clone().detached_for_testing(Box::pin(async move {\n+            sleep(Duration::from_millis(100)).await;\n+            // creating cells after the normal lifetime of the task should be okay, as the parent\n+            // task is waiting on us before exiting!\n+            sender\n+                .0\n+                .send(Some(Vc::cell(\n+                    *read_changing_input(changing_input_detached).await.unwrap(),\n+                )))\n+                .unwrap();\n+            Ok(())\n+        })));\n+        Ok(())\n+    })));\n+    Vc::cell(*read_changing_input(changing_input_outer).await.unwrap())\n+}\n+\n+// spawns_detached should take a dependency on this function for each input\n+#[turbo_tasks::function(invalidator)]\n+async fn read_changing_input(changing_input: Vc<ChangingInput>) -> Vc<u32> {\n+    // when changing_input.set is called, it will trigger an invalidator for this task\n+    Vc::cell(*changing_input.await.unwrap().state.get())\n+}"
        },
        {
            "sha": "0a45daf6b8443d06fff4376a92a9b9973cd87a7e",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/dirty_in_progress.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdirty_in_progress.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdirty_in_progress.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdirty_in_progress.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/dirty_in_progress.rs\n\\ No newline at end of file"
        },
        {
            "sha": "49027755fcfa9691a1803fc6e3a157fb197ab57a",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/dirty_in_progress.rs",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdirty_in_progress.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdirty_in_progress.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fdirty_in_progress.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,109 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use std::time::Duration;\n+\n+use anyhow::{Result, bail};\n+use turbo_rcstr::RcStr;\n+use turbo_tasks::{CollectiblesSource, ResolvedVc, State, ValueToString, Vc, emit};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn dirty_in_progress() {\n+    run(&REGISTRATION, || async {\n+        let cases = [\n+            (1, 3, 2, 2, \"\"),\n+            (11, 13, 12, 42, \"12\"),\n+            (1, 13, 11, 42, \"11\"),\n+            (1, 3, 11, 42, \"11\"),\n+            (11, 3, 2, 2, \"\"),\n+            (11, 13, 2, 2, \"\"),\n+        ];\n+        for (a, b, c, value, collectible) in cases {\n+            println!(\"{a} -> {b} -> {c} = {value} {collectible}\");\n+            let input = ChangingInput {\n+                state: State::new(a),\n+            }\n+            .cell();\n+            let input_val = input.await?;\n+            let output = compute(input);\n+            output.await?;\n+            println!(\"update to {b}\");\n+            input_val.state.set(b);\n+            tokio::time::sleep(Duration::from_millis(50)).await;\n+            println!(\"update to {c}\");\n+            input_val.state.set(c);\n+            let read = output.strongly_consistent().await?;\n+            assert_eq!(read.value, value);\n+            assert_eq!(read.collectible, collectible);\n+            println!(\"\\n\");\n+        }\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::value]\n+struct ChangingInput {\n+    state: State<u32>,\n+}\n+\n+#[turbo_tasks::value]\n+struct Output {\n+    value: u32,\n+    collectible: String,\n+}\n+\n+#[turbo_tasks::value]\n+struct Collectible {\n+    value: u32,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ValueToString for Collectible {\n+    #[turbo_tasks::function]\n+    fn to_string(&self) -> Vc<RcStr> {\n+        Vc::cell(self.value.to_string().into())\n+    }\n+}\n+\n+#[turbo_tasks::function(operation, invalidator)]\n+async fn inner_compute(input: ResolvedVc<ChangingInput>) -> Result<Vc<u32>> {\n+    println!(\"start inner_compute\");\n+    let value = *input.await?.state.get();\n+    tokio::time::sleep(Duration::from_millis(200)).await;\n+    if value > 10 {\n+        let collectible: ResolvedVc<Box<dyn ValueToString>> =\n+            ResolvedVc::upcast(Collectible { value }.resolved_cell());\n+        emit(collectible);\n+\n+        println!(\"end inner_compute with collectible\");\n+        Ok(Vc::cell(42))\n+    } else {\n+        println!(\"end inner_compute without collectible\");\n+        Ok(Vc::cell(value))\n+    }\n+}\n+\n+#[turbo_tasks::function]\n+async fn compute(input: ResolvedVc<ChangingInput>) -> Result<Vc<Output>> {\n+    println!(\"start compute\");\n+    let operation = inner_compute(input);\n+    let value = *operation.connect().await?;\n+    let collectibles = operation.peek_collectibles::<Box<dyn ValueToString>>();\n+    if collectibles.len() > 1 {\n+        bail!(\"expected 0..1 collectible, found {}\", collectibles.len());\n+    }\n+    let first = collectibles.iter().next();\n+    let collectible = if let Some(first) = first {\n+        first.to_string().await?.to_string()\n+    } else {\n+        \"\".to_string()\n+    };\n+    println!(\"end compute\");\n+    Ok(Output { value, collectible }.cell())\n+}"
        },
        {
            "sha": "9070c4d0b4dcc91aecd199ce9f146a714a7fc3a2",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/emptied_cells.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/emptied_cells.rs\n\\ No newline at end of file"
        },
        {
            "sha": "8ebc61a705fa352f830563ea7fbcfdbc3d2aa54d",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/emptied_cells.rs",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Femptied_cells.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,75 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use anyhow::Result;\n+use turbo_tasks::{State, Vc};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn recompute() {\n+    run(&REGISTRATION, || async {\n+        let input = ChangingInput {\n+            state: State::new(1),\n+        }\n+        .cell();\n+        let output = compute(input);\n+        assert_eq!(*output.await?, 1);\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(10);\n+        assert_eq!(*output.strongly_consistent().await?, 10);\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(5);\n+        assert_eq!(*output.strongly_consistent().await?, 5);\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(20);\n+        assert_eq!(*output.strongly_consistent().await?, 20);\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(15);\n+        assert_eq!(*output.strongly_consistent().await?, 15);\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(1);\n+        assert_eq!(*output.strongly_consistent().await?, 1);\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap();\n+}\n+\n+#[turbo_tasks::value]\n+struct ChangingInput {\n+    state: State<u32>,\n+}\n+\n+#[turbo_tasks::function]\n+async fn compute(input: Vc<ChangingInput>) -> Result<Vc<u32>> {\n+    println!(\"compute()\");\n+    let value = *inner_compute(input).await?;\n+    Ok(Vc::cell(value))\n+}\n+\n+#[turbo_tasks::function(invalidator)]\n+async fn inner_compute(input: Vc<ChangingInput>) -> Result<Vc<u32>> {\n+    println!(\"inner_compute()\");\n+    let state_value = *input.await?.state.get();\n+    let mut last = None;\n+    for i in 0..=state_value {\n+        last = Some(compute2(Vc::cell(i)));\n+    }\n+    Ok(last.unwrap())\n+}\n+\n+#[turbo_tasks::function]\n+async fn compute2(input: Vc<u32>) -> Result<Vc<u32>> {\n+    println!(\"compute2()\");\n+    let value = *input.await?;\n+    Ok(Vc::cell(value))\n+}"
        },
        {
            "sha": "1230ad8c6d7c250547da65a365dee36778705507",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/filter_unused_args.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ffilter_unused_args.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ffilter_unused_args.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ffilter_unused_args.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/filter_unused_args.rs\n\\ No newline at end of file"
        },
        {
            "sha": "b7081174940c6c94de9bd441dcc55c477b04ca63",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/filter_unused_args.rs",
            "status": "added",
            "additions": 65,
            "deletions": 0,
            "changes": 65,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ffilter_unused_args.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ffilter_unused_args.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ffilter_unused_args.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,65 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use anyhow::Result;\n+use turbo_tasks::Vc;\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn filtered_trait_method_args() -> Result<()> {\n+    run(&REGISTRATION, || async {\n+        let uses_arg = UsesArg.cell();\n+        assert_eq!(\n+            uses_arg.method_with_arg(0).to_resolved().await?,\n+            uses_arg.method_with_arg(0).to_resolved().await?,\n+        );\n+        assert_ne!(\n+            uses_arg.method_with_arg(0).to_resolved().await?,\n+            uses_arg.method_with_arg(1).to_resolved().await?,\n+        );\n+\n+        let ignores_arg = IgnoresArg.cell();\n+        assert_eq!(\n+            ignores_arg.method_with_arg(0).to_resolved().await?,\n+            ignores_arg.method_with_arg(0).to_resolved().await?,\n+        );\n+        assert_eq!(\n+            ignores_arg.method_with_arg(0).to_resolved().await?,\n+            ignores_arg.method_with_arg(1).to_resolved().await?,\n+        );\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[turbo_tasks::value_trait]\n+trait ExampleTrait {\n+    #[turbo_tasks::function]\n+    fn method_with_arg(&self, number: i32) -> Vc<()>;\n+}\n+\n+#[turbo_tasks::value]\n+struct UsesArg;\n+\n+#[turbo_tasks::value_impl]\n+impl ExampleTrait for UsesArg {\n+    #[turbo_tasks::function]\n+    fn method_with_arg(&self, number: i32) -> Vc<()> {\n+        let _ = number;\n+        Vc::cell(())\n+    }\n+}\n+\n+#[turbo_tasks::value]\n+struct IgnoresArg;\n+\n+#[turbo_tasks::value_impl]\n+impl ExampleTrait for IgnoresArg {\n+    #[turbo_tasks::function]\n+    fn method_with_arg(&self, _number: i32) -> Vc<()> {\n+        Vc::cell(())\n+    }\n+}"
        },
        {
            "sha": "29d9f86f4556624de6731c988410fbcfdea877fb",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/local_tasks.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Flocal_tasks.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Flocal_tasks.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Flocal_tasks.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/local_tasks.rs\n\\ No newline at end of file"
        },
        {
            "sha": "e2a6a7abdfa740fc73a61ffe790d6ef1f986650e",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/local_tasks.rs",
            "status": "added",
            "additions": 69,
            "deletions": 0,
            "changes": 69,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Flocal_tasks.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Flocal_tasks.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Flocal_tasks.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,69 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use anyhow::Result;\n+use turbo_tasks::{Vc, test_helpers::current_task_for_testing};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn test_local_task_id() -> Result<()> {\n+    run(&REGISTRATION, || async {\n+        let local_vc = get_local_task_id();\n+        assert!(local_vc.is_local());\n+        assert_eq!(*local_vc.await.unwrap(), *current_task_for_testing());\n+\n+        let local_trait_vc = Foo {}.cell().get_local_task_id();\n+        assert!(local_trait_vc.is_local());\n+        assert_eq!(*local_trait_vc.await.unwrap(), *current_task_for_testing());\n+\n+        let non_local_vc = get_non_local_task_id();\n+        assert!(!non_local_vc.is_local());\n+        assert_ne!(*non_local_vc.await.unwrap(), *current_task_for_testing());\n+\n+        let non_local_trait_vc = Foo {}.cell().get_non_local_task_id();\n+        assert!(!non_local_trait_vc.is_local());\n+        assert_ne!(\n+            *non_local_trait_vc.await.unwrap(),\n+            *current_task_for_testing()\n+        );\n+\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[turbo_tasks::function(local)]\n+fn get_local_task_id() -> Vc<u32> {\n+    Vc::cell(*current_task_for_testing())\n+}\n+\n+#[turbo_tasks::function]\n+fn get_non_local_task_id() -> Vc<u32> {\n+    Vc::cell(*current_task_for_testing())\n+}\n+\n+#[turbo_tasks::value_trait]\n+trait SomeTrait {\n+    #[turbo_tasks::function]\n+    fn get_local_task_id(self: Vc<Self>) -> Vc<u32>;\n+    #[turbo_tasks::function]\n+    fn get_non_local_task_id(self: Vc<Self>) -> Vc<u32>;\n+}\n+#[turbo_tasks::value(shared)]\n+struct Foo {}\n+\n+#[turbo_tasks::value_impl]\n+impl SomeTrait for Foo {\n+    #[turbo_tasks::function(local)]\n+    fn get_local_task_id(self: Vc<Self>) -> Vc<u32> {\n+        Vc::cell(*current_task_for_testing())\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn get_non_local_task_id(self: Vc<Self>) -> Vc<u32> {\n+        Vc::cell(*current_task_for_testing())\n+    }\n+}"
        },
        {
            "sha": "0fe3b98a6abc652de414c6eb8c97ae5f8e5a5cf7",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/operation_vc.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Foperation_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Foperation_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Foperation_vc.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/operation_vc.rs\n\\ No newline at end of file"
        },
        {
            "sha": "125ec9b8943649a5c31bd94b8c44391eb9dcc7a1",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/operation_vc.rs",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Foperation_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Foperation_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Foperation_vc.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,36 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use anyhow::Result;\n+use turbo_tasks::{OperationVc, ResolvedVc, Vc};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[turbo_tasks::function(operation)]\n+fn bare_op_fn() -> Vc<i32> {\n+    Vc::cell(21)\n+}\n+\n+// operations can take `ResolvedVc`s too (anything that's a `NonLocalValue`).\n+#[turbo_tasks::function(operation)]\n+async fn multiply(value: OperationVc<i32>, coefficient: ResolvedVc<i32>) -> Result<Vc<i32>> {\n+    Ok(Vc::cell((*value.connect().await?) * (*coefficient.await?)))\n+}\n+\n+#[turbo_tasks::function]\n+fn use_operations() -> Vc<i32> {\n+    let twenty_one: OperationVc<i32> = bare_op_fn();\n+    let fourty_two: OperationVc<i32> = multiply(twenty_one, ResolvedVc::cell(2));\n+    fourty_two.connect()\n+}\n+\n+#[tokio::test]\n+async fn test_use_operations() -> Result<()> {\n+    run(&REGISTRATION, || async {\n+        assert_eq!(*use_operations().await?, 42);\n+        Ok(())\n+    })\n+    .await\n+}"
        },
        {
            "sha": "23ff275bf1de5385ac2933d6c1ac3ec0094fc613",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/performance.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fperformance.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fperformance.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fperformance.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/performance.rs\n\\ No newline at end of file"
        },
        {
            "sha": "904843fad2a63282cbbc376753f32a8e2448f422",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/performance.rs",
            "status": "added",
            "additions": 340,
            "deletions": 0,
            "changes": 340,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fperformance.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fperformance.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fperformance.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,340 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use std::{future::Future, time::Duration};\n+\n+use anyhow::Result;\n+use turbo_tasks::{TransientInstance, Vc};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+const COUNT1: u32 = 100;\n+const COUNT2: u32 = 2000;\n+\n+async fn run_test<F, T>(\n+    f: impl Fn() -> F + Sync + Send + Clone + 'static,\n+    limit: Duration,\n+) -> anyhow::Result<()>\n+where\n+    F: Future<Output = anyhow::Result<T>> + Sync + Send + 'static,\n+{\n+    // The first call will actually execute everything.\n+    let start = std::time::Instant::now();\n+    f().await?;\n+    println!(\"Initial call took {:?}\", start.elapsed());\n+\n+    let mut warmup_calls = Vec::new();\n+\n+    for _ in 0..10 {\n+        let start = std::time::Instant::now();\n+        f().await?;\n+        let warmup_call = start.elapsed();\n+        println!(\"Subsequent call took {warmup_call:?}\");\n+        warmup_calls.push(warmup_call);\n+    }\n+\n+    // Susbsequent calls should be very fast.\n+    let start = std::time::Instant::now();\n+    for _ in 0..COUNT1 {\n+        f().await?;\n+    }\n+    let subsequent = start.elapsed();\n+    println!(\n+        \"First {} subsequent calls took {:?} ({:?} per call)\",\n+        COUNT1,\n+        subsequent,\n+        subsequent / COUNT1\n+    );\n+\n+    let start = std::time::Instant::now();\n+    for _ in 0..COUNT1 {\n+        f().await?;\n+    }\n+    let subsequent2 = start.elapsed();\n+    println!(\n+        \"Another {} subsequent calls took {:?} ({:?} per call)\",\n+        COUNT1,\n+        subsequent2,\n+        subsequent2 / COUNT1\n+    );\n+\n+    let start = std::time::Instant::now();\n+    for _ in 0..COUNT1 {\n+        f().await?;\n+    }\n+    let subsequent3 = start.elapsed();\n+    println!(\n+        \"Another {} subsequent calls took {:?} ({:?} per call)\",\n+        COUNT1,\n+        subsequent3,\n+        subsequent3 / COUNT1\n+    );\n+\n+    if subsequent2 * 2 > subsequent * 3 || subsequent3 * 2 > subsequent * 3 {\n+        // Performance regresses with more calls\n+        // Check if this fixes itself eventually\n+        for i in 0.. {\n+            let start = std::time::Instant::now();\n+            for _ in 0..COUNT1 {\n+                f().await?;\n+            }\n+            let subsequent4 = start.elapsed();\n+            println!(\n+                \"Another {} subsequent calls took {:?} ({:?} per call)\",\n+                COUNT1,\n+                subsequent4,\n+                subsequent4 / COUNT1\n+            );\n+            if subsequent4 * 2 < subsequent * 3 {\n+                break;\n+            }\n+            if i >= 20 {\n+                panic!(\"Performance regressed with more calls\");\n+            }\n+        }\n+    }\n+\n+    let start = std::time::Instant::now();\n+    f().await?;\n+    let final_call = start.elapsed();\n+    println!(\"Final call took {final_call:?}\");\n+\n+    let target = subsequent / COUNT1;\n+\n+    for (i, warmup_call) in warmup_calls.into_iter().enumerate() {\n+        assert!(\n+            warmup_call < target * 10,\n+            \"Warmup call {} should be less than {:?}\",\n+            i,\n+            target * 10\n+        );\n+    }\n+\n+    assert!(\n+        subsequent < limit * COUNT1,\n+        \"Each call should be less than {limit:?}\"\n+    );\n+\n+    assert!(\n+        subsequent2 < limit * COUNT1,\n+        \"Each call should be less than {limit:?}\"\n+    );\n+\n+    assert!(\n+        subsequent3 < limit * COUNT1,\n+        \"Each call should be less than {limit:?}\"\n+    );\n+\n+    anyhow::Ok(())\n+}\n+\n+fn check_skip() -> bool {\n+    if matches!(\n+        std::env::var(\"TURBOPACK_TEST_PERFORMANCE\").ok().as_deref(),\n+        None | Some(\"\") | Some(\"no\") | Some(\"false\")\n+    ) {\n+        println!(\"Skipping test, pass `TURBOPACK_TEST_PERFORMANCE=yes` to run it\");\n+        return true;\n+    }\n+\n+    false\n+}\n+\n+#[tokio::test]\n+async fn many_calls_to_many_children() {\n+    if check_skip() {\n+        return;\n+    }\n+    run(&REGISTRATION, || {\n+        run_test(\n+            || calls_many_children(TransientInstance::new(()), None).strongly_consistent(),\n+            Duration::from_micros(100),\n+        )\n+    })\n+    .await\n+    .unwrap();\n+}\n+\n+#[tokio::test]\n+async fn many_calls_to_uncached_many_children() {\n+    if check_skip() {\n+        return;\n+    }\n+    run(&REGISTRATION, || {\n+        run_test(\n+            || {\n+                calls_many_children(TransientInstance::new(()), Some(TransientInstance::new(())))\n+                    .strongly_consistent()\n+            },\n+            Duration::from_micros(100) * COUNT2,\n+        )\n+    })\n+    .await\n+    .unwrap();\n+}\n+\n+fn run_big_graph_test(counts: Vec<u32>) -> impl Future<Output = Result<()>> + Send + 'static {\n+    println!(\n+        \"Graph {:?} = {} tasks\",\n+        counts,\n+        (1..=counts.len())\n+            .map(|i| counts.iter().take(i).product::<u32>())\n+            .sum::<u32>()\n+    );\n+    run_test(\n+        move || calls_big_graph(counts.clone(), TransientInstance::new(())).strongly_consistent(),\n+        Duration::from_micros(100),\n+    )\n+}\n+\n+#[tokio::test]\n+async fn many_calls_to_big_graph_1() {\n+    if check_skip() {\n+        return;\n+    }\n+    run(&REGISTRATION, || run_big_graph_test(vec![5, 8, 10, 15, 20]))\n+        .await\n+        .unwrap();\n+}\n+\n+#[tokio::test]\n+async fn many_calls_to_big_graph_2() {\n+    if check_skip() {\n+        return;\n+    }\n+    run(&REGISTRATION, || {\n+        run_big_graph_test(vec![2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n+    })\n+    .await\n+    .unwrap();\n+}\n+\n+#[tokio::test]\n+async fn many_calls_to_big_graph_3() {\n+    if check_skip() {\n+        return;\n+    }\n+    run(&REGISTRATION, || run_big_graph_test(vec![1000, 3, 3, 3, 3]))\n+        .await\n+        .unwrap();\n+}\n+\n+#[tokio::test]\n+async fn many_calls_to_big_graph_4() {\n+    if check_skip() {\n+        return;\n+    }\n+    run(&REGISTRATION, || run_big_graph_test(vec![3, 3, 3, 3, 1000]))\n+        .await\n+        .unwrap();\n+}\n+\n+#[tokio::test]\n+async fn many_calls_to_big_graph_5() {\n+    if check_skip() {\n+        return;\n+    }\n+    run(&REGISTRATION, || {\n+        run_big_graph_test(vec![10, 10, 10, 10, 10])\n+    })\n+    .await\n+    .unwrap();\n+}\n+\n+#[tokio::test]\n+async fn many_calls_to_big_graph_6() {\n+    if check_skip() {\n+        return;\n+    }\n+    run(&REGISTRATION, || {\n+        run_big_graph_test(vec![2, 2, 2, 1000, 2, 2, 2])\n+    })\n+    .await\n+    .unwrap();\n+}\n+\n+#[tokio::test]\n+async fn many_calls_to_big_graph_7() {\n+    if check_skip() {\n+        return;\n+    }\n+    run(&REGISTRATION, || {\n+        run_big_graph_test(vec![\n+            1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 3, 2, 1, 1, 1, 1, 5, 1, 1, 1, 200, 2, 1,\n+            1, 1, 1, 1, 1, 1, 1, 1,\n+        ])\n+    })\n+    .await\n+    .unwrap();\n+}\n+\n+#[tokio::test]\n+async fn many_calls_to_big_graph_8() {\n+    if check_skip() {\n+        return;\n+    }\n+    run(&REGISTRATION, || {\n+        run_big_graph_test(vec![200, 2, 2, 2, 2, 200])\n+    })\n+    .await\n+    .unwrap();\n+}\n+\n+#[tokio::test]\n+async fn many_calls_to_big_graph_9() {\n+    if check_skip() {\n+        return;\n+    }\n+    run(&REGISTRATION, || {\n+        run_big_graph_test(vec![10000, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1])\n+    })\n+    .await\n+    .unwrap();\n+}\n+\n+#[turbo_tasks::value]\n+struct Value {\n+    value: u32,\n+}\n+\n+#[turbo_tasks::function]\n+fn calls_many_children(i: TransientInstance<()>, j: Option<TransientInstance<()>>) -> Vc<()> {\n+    let _ = i;\n+    let _ = many_children(j);\n+    Vc::cell(())\n+}\n+\n+#[turbo_tasks::function]\n+fn many_children(_j: Option<TransientInstance<()>>) -> Vc<()> {\n+    for i in 0..COUNT2 {\n+        let _ = many_children_inner(i);\n+    }\n+    Vc::cell(())\n+}\n+\n+#[turbo_tasks::function]\n+fn many_children_inner(_i: u32) -> Vc<()> {\n+    Vc::cell(())\n+}\n+\n+#[turbo_tasks::function]\n+fn calls_big_graph(mut counts: Vec<u32>, i: TransientInstance<()>) -> Vc<()> {\n+    let _ = i;\n+    counts.reverse();\n+    let _ = big_graph(counts, vec![]);\n+    Vc::cell(())\n+}\n+\n+#[turbo_tasks::function]\n+fn big_graph(mut counts: Vec<u32>, keys: Vec<u32>) -> Vc<()> {\n+    let Some(count) = counts.pop() else {\n+        return Vc::cell(());\n+    };\n+    for i in 0..count {\n+        let new_keys = keys.iter().copied().chain(std::iter::once(i)).collect();\n+        let _ = big_graph(counts.clone(), new_keys);\n+    }\n+    Vc::cell(())\n+}"
        },
        {
            "sha": "0791eca92a2b37221b5c058b8beb53f21e40e4b6",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/random_change.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/random_change.rs\n\\ No newline at end of file"
        },
        {
            "sha": "eb1c537c9714eb70ad03929473f862ec51275344",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/random_change.rs",
            "status": "added",
            "additions": 71,
            "deletions": 0,
            "changes": 71,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frandom_change.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,71 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use anyhow::{Result, bail};\n+use rand::Rng;\n+use turbo_tasks::{State, Vc};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn random_change() {\n+    run(&REGISTRATION, || async {\n+        let state = make_state();\n+        let value = rand::rng().random_range(0..100);\n+        state.await?.state.set(value);\n+\n+        let result = func(state, 0).await?;\n+        assert_eq!(result.value, value);\n+\n+        let result = func2(state).await?;\n+        assert_eq!(result.value, value);\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::value]\n+#[derive(Clone, Debug)]\n+struct Value {\n+    value: i32,\n+}\n+\n+#[turbo_tasks::value]\n+#[derive(Debug)]\n+struct ValueContainer {\n+    state: State<i32>,\n+}\n+\n+#[turbo_tasks::function]\n+fn make_state() -> Vc<ValueContainer> {\n+    ValueContainer {\n+        state: State::new(0),\n+    }\n+    .cell()\n+}\n+\n+#[turbo_tasks::function(invalidator)]\n+async fn func2(input: Vc<ValueContainer>) -> Result<Vc<Value>> {\n+    let state = input.await?;\n+    let value = state.state.get();\n+    println!(\"func2 {}\", *value);\n+    Ok(func(input, -*value))\n+}\n+\n+#[turbo_tasks::function(invalidator)]\n+async fn func(input: Vc<ValueContainer>, nesting: i32) -> Result<Vc<Value>> {\n+    let state = input.await?;\n+    let value = state.state.get();\n+    if nesting < *value {\n+        return Ok(func(input, nesting + 1));\n+    }\n+    if nesting == *value {\n+        println!(\"func {nesting}\");\n+        return Ok(Value { value: *value }.cell());\n+    }\n+    bail!(\"func no longer valid {}\", nesting)\n+}"
        },
        {
            "sha": "4e1719dfefec28fc10983f51be6c4f1f2158786a",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/read_ref_cell.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/read_ref_cell.rs\n\\ No newline at end of file"
        },
        {
            "sha": "fae432e519612ad5cdf4757601afaf9f2b062c15",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/read_ref_cell.rs",
            "status": "added",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fread_ref_cell.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,87 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // clippy bug causes false positive\n+\n+use std::sync::Mutex;\n+\n+use anyhow::Result;\n+use turbo_tasks::{Invalidator, ReadRef, Vc, get_invalidator};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn read_ref() {\n+    run(&REGISTRATION, || async {\n+        let counter = Counter::cell(Counter {\n+            value: Mutex::new((0, None)),\n+        });\n+\n+        let counter_value = counter.get_value();\n+\n+        assert_eq!(*counter.get_value().strongly_consistent().await?, 0);\n+        assert_eq!(*counter_value.strongly_consistent().await?, 0);\n+\n+        counter.await?.incr();\n+\n+        assert_eq!(*counter.get_value().strongly_consistent().await?, 1);\n+        assert_eq!(*counter_value.strongly_consistent().await?, 1);\n+\n+        // `ref_counter` will still point to the same `counter` instance as `counter`.\n+        let ref_counter = ReadRef::cell(counter.await?);\n+        let ref_counter_value = ref_counter.get_value();\n+\n+        // However, `local_counter_value` will point to the value of `counter_value`\n+        // at the time it was turned into a trait reference (just like a `ReadRef`\n+        // would).\n+        let local_counter_value = ReadRef::cell(counter_value.await?).get_value();\n+\n+        counter.await?.incr();\n+\n+        assert_eq!(*counter.get_value().strongly_consistent().await?, 2);\n+        assert_eq!(*counter_value.strongly_consistent().await?, 2);\n+        assert_eq!(*ref_counter_value.strongly_consistent().await?, 2);\n+        assert_eq!(*local_counter_value.strongly_consistent().await?, 1);\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::value(transparent)]\n+struct CounterValue(usize);\n+\n+#[turbo_tasks::value(serialization = \"none\", cell = \"new\", eq = \"manual\")]\n+struct Counter {\n+    #[turbo_tasks(debug_ignore, trace_ignore)]\n+    value: Mutex<(usize, Option<Invalidator>)>,\n+}\n+\n+impl Counter {\n+    fn incr(&self) {\n+        let mut lock = self.value.lock().unwrap();\n+        lock.0 += 1;\n+        if let Some(i) = lock.1.take() {\n+            i.invalidate();\n+        }\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Counter {\n+    #[turbo_tasks::function(invalidator)]\n+    fn get_value(&self) -> Result<Vc<CounterValue>> {\n+        let mut lock = self.value.lock().unwrap();\n+        lock.1 = Some(get_invalidator());\n+        Ok(Vc::cell(lock.0))\n+    }\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl CounterValue {\n+    #[turbo_tasks::function]\n+    fn get_value(self: Vc<Self>) -> Vc<Self> {\n+        self\n+    }\n+}"
        },
        {
            "sha": "5c35fb81af4e34e7de242b4b1599768d36affa03",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/recompute.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/recompute.rs\n\\ No newline at end of file"
        },
        {
            "sha": "d708707ff78462a55c2772c7266126a5ac8e5bb1",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/recompute.rs",
            "status": "added",
            "additions": 137,
            "deletions": 0,
            "changes": 137,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,137 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use anyhow::Result;\n+use turbo_tasks::{ResolvedVc, State, Vc};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn recompute() {\n+    run(&REGISTRATION, || async {\n+        let input = ChangingInput {\n+            state: State::new(1),\n+        }\n+        .cell();\n+        let input2 = ChangingInput {\n+            state: State::new(10),\n+        }\n+        .cell();\n+        let output = compute(input, input2);\n+        let read = output.await?;\n+        assert_eq!(read.state_value, 1);\n+        assert_eq!(read.state_value2, 10);\n+        let random_value = read.random_value;\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(2);\n+        let read = output.strongly_consistent().await?;\n+        assert_eq!(read.state_value, 2);\n+        assert_ne!(read.random_value, random_value);\n+        let random_value = read.random_value;\n+\n+        println!(\"changing input2\");\n+        input2.await?.state.set(20);\n+        let read = output.strongly_consistent().await?;\n+        assert_eq!(read.state_value2, 20);\n+        assert_ne!(read.random_value, random_value);\n+        let random_value = read.random_value;\n+\n+        println!(\"changing input\");\n+        input.await?.state.set(5);\n+        let read = output.strongly_consistent().await?;\n+        assert_eq!(read.state_value, 5);\n+        assert_eq!(read.state_value2, 42);\n+        assert_ne!(read.random_value, random_value);\n+        let random_value = read.random_value;\n+\n+        println!(\"changing input2\");\n+        input2.await?.state.set(30);\n+        let read = output.strongly_consistent().await?;\n+        assert_eq!(read.random_value, random_value);\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[tokio::test]\n+async fn immutable_analysis() {\n+    run(&REGISTRATION, || async {\n+        let input = ChangingInput {\n+            state: State::new(1),\n+        }\n+        .resolved_cell();\n+\n+        // Verify\n+\n+        let vc_holder = VcHolder { vc: input }.resolved_cell();\n+        let read = vc_holder.compute().strongly_consistent().await?;\n+        assert_eq!(read.state_value, 1);\n+        assert_eq!(read.state_value2, 1);\n+        let random_value = read.random_value;\n+\n+        println!(\"changing input1\");\n+        input.await?.state.set(30);\n+        let read = vc_holder.compute().strongly_consistent().await?;\n+        assert_eq!(read.state_value, 30);\n+        assert_eq!(read.state_value2, 42);\n+        assert_ne!(read.random_value, random_value);\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::value]\n+struct ChangingInput {\n+    state: State<u32>,\n+}\n+\n+#[turbo_tasks::value]\n+struct VcHolder {\n+    vc: ResolvedVc<ChangingInput>,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl VcHolder {\n+    #[turbo_tasks::function]\n+    fn compute(&self) -> Vc<Output> {\n+        compute(*self.vc, *self.vc)\n+    }\n+}\n+\n+#[turbo_tasks::value]\n+struct Output {\n+    state_value: u32,\n+    state_value2: u32,\n+    random_value: u32,\n+}\n+\n+#[turbo_tasks::function(invalidator)]\n+async fn compute(input: Vc<ChangingInput>, input2: Vc<ChangingInput>) -> Result<Vc<Output>> {\n+    let state_value = *input.await?.state.get();\n+    let state_value2 = if state_value < 5 {\n+        *compute2(input2).await?\n+    } else {\n+        42\n+    };\n+    let random_value = rand::random();\n+\n+    Ok(Output {\n+        state_value,\n+        state_value2,\n+        random_value,\n+    }\n+    .cell())\n+}\n+\n+#[turbo_tasks::function(invalidator)]\n+async fn compute2(input: Vc<ChangingInput>) -> Result<Vc<u32>> {\n+    let state_value = *input.await?.state.get();\n+    Ok(Vc::cell(state_value))\n+}"
        },
        {
            "sha": "664d8d48d14087af32a89785b4a0ee3221ef9ad0",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/recompute_collectibles.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute_collectibles.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute_collectibles.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute_collectibles.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/recompute_collectibles.rs\n\\ No newline at end of file"
        },
        {
            "sha": "89e2bca2d9c0ad997a6ae4c631ed93d10a52b910",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/recompute_collectibles.rs",
            "status": "added",
            "additions": 125,
            "deletions": 0,
            "changes": 125,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute_collectibles.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute_collectibles.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Frecompute_collectibles.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,125 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // clippy bug causes false positive\n+\n+use anyhow::{Result, bail};\n+use turbo_rcstr::RcStr;\n+use turbo_tasks::{CollectiblesSource, ResolvedVc, State, ValueToString, Vc, emit};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn recompute() {\n+    run(&REGISTRATION, || async {\n+        let input = ChangingInput::new(1).resolve().await?;\n+        let input2 = ChangingInput::new(2).resolve().await?;\n+        input.await?.state.set(1);\n+        input2.await?.state.set(1000);\n+        let output = compute(input, input2, 1);\n+        let read = output.strongly_consistent().await?;\n+        assert_eq!(read.value, 42);\n+        assert_eq!(read.collectible, \"1\");\n+\n+        for i in 2..100 {\n+            input.await?.state.set(i);\n+            let read = output.strongly_consistent().await?;\n+            assert_eq!(read.value, 42);\n+            assert_eq!(read.collectible, i.to_string());\n+        }\n+\n+        for i in 0..100 {\n+            input2.await?.state.set(i);\n+            let read = output.strongly_consistent().await?;\n+            assert_eq!(read.value, 42);\n+            assert_eq!(read.collectible, \"99\");\n+        }\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::value]\n+struct ChangingInput {\n+    state: State<u32>,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ChangingInput {\n+    #[turbo_tasks::function]\n+    fn new(key: u32) -> Vc<Self> {\n+        let _ = key;\n+        Self {\n+            state: State::new(1),\n+        }\n+        .cell()\n+    }\n+}\n+\n+#[turbo_tasks::value]\n+struct Output {\n+    value: u32,\n+    collectible: String,\n+}\n+\n+#[turbo_tasks::value]\n+struct Collectible {\n+    value: u32,\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl ValueToString for Collectible {\n+    #[turbo_tasks::function]\n+    fn to_string(&self) -> Vc<RcStr> {\n+        Vc::cell(self.value.to_string().into())\n+    }\n+}\n+\n+#[turbo_tasks::function(operation, invalidator)]\n+async fn inner_compute(\n+    input: ResolvedVc<ChangingInput>,\n+    input2: ResolvedVc<ChangingInput>,\n+) -> Result<Vc<u32>> {\n+    println!(\"inner_compute()\");\n+    Ok(inner_compute2(*input, *input2.await?.state.get()))\n+}\n+\n+#[turbo_tasks::function(invalidator)]\n+async fn inner_compute2(input: Vc<ChangingInput>, innerness: u32) -> Result<Vc<u32>> {\n+    println!(\"inner_compute2({innerness})\");\n+    if innerness > 0 {\n+        return Ok(inner_compute2(input, innerness - 1));\n+    }\n+    let value = *input.await?.state.get();\n+    let collectible: ResolvedVc<Box<dyn ValueToString>> =\n+        ResolvedVc::upcast(Collectible { value }.resolved_cell());\n+    emit(collectible);\n+\n+    Ok(Vc::cell(42))\n+}\n+\n+#[turbo_tasks::function]\n+async fn compute(\n+    input: ResolvedVc<ChangingInput>,\n+    input2: ResolvedVc<ChangingInput>,\n+    innerness: u32,\n+) -> Result<Vc<Output>> {\n+    println!(\"compute({innerness})\");\n+    if innerness > 0 {\n+        return Ok(compute(*input, *input2, innerness - 1));\n+    }\n+    let operation = inner_compute(input, input2);\n+    let value = *operation.connect().await?;\n+    let collectibles = operation.peek_collectibles::<Box<dyn ValueToString>>();\n+    if collectibles.len() != 1 {\n+        bail!(\"expected 1 collectible, found {}\", collectibles.len());\n+    }\n+    let first = *collectibles.iter().next().unwrap();\n+    let collectible = first.to_string().await?;\n+    Ok(Output {\n+        value,\n+        collectible: collectible.to_string(),\n+    }\n+    .cell())\n+}"
        },
        {
            "sha": "601c7f0fc000894a40a5eb2890280905fe53d6ee",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/resolved_vc.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fresolved_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fresolved_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fresolved_vc.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/resolved_vc.rs\n\\ No newline at end of file"
        },
        {
            "sha": "ad4692bf6f6ea0361711f3c40e611f281318a3b7",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/resolved_vc.rs",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fresolved_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fresolved_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fresolved_vc.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,111 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use anyhow::Result;\n+use turbo_tasks::{ReadRef, ResolvedVc, Vc};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[turbo_tasks::value]\n+struct Wrapper(u32);\n+\n+#[turbo_tasks::function]\n+fn returns_int(value: u32) -> Vc<u32> {\n+    Vc::cell(value)\n+}\n+\n+#[turbo_tasks::function]\n+fn assert_resolved(input: ResolvedVc<u32>) {\n+    // double-check that this `ResolvedVc` is *actually* resolved\n+    let input_vc: Vc<u32> = *input;\n+    assert!(input_vc.is_resolved());\n+}\n+\n+#[tokio::test]\n+async fn test_conversion() -> Result<()> {\n+    run(&REGISTRATION, || async {\n+        let unresolved: Vc<u32> = Vc::cell(42);\n+        let resolved: ResolvedVc<u32> = unresolved.to_resolved().await?;\n+        let _: Vc<u32> = *resolved;\n+        let _: ReadRef<u32> = resolved.await?;\n+        let _: ReadRef<u32> = (&resolved).await?;\n+        let _: u32 = *resolved.await?;\n+        let _: u32 = *(&resolved).await?;\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[tokio::test]\n+async fn test_cell_construction() -> Result<()> {\n+    run(&REGISTRATION, || async {\n+        let a: ResolvedVc<u32> = ResolvedVc::cell(42);\n+        assert_eq!(*a.await?, 42);\n+        let b: ResolvedVc<Wrapper> = Wrapper(42).resolved_cell();\n+        assert_eq!(b.await?.0, 42);\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[tokio::test]\n+async fn test_resolved_vc_as_arg() -> Result<()> {\n+    run(&REGISTRATION, || async {\n+        let unresolved: Vc<u32> = returns_int(42);\n+        assert!(!unresolved.is_resolved());\n+        // calling a function should cause it's arguments to get resolved automatically\n+        assert_resolved(unresolved).await?;\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[tokio::test]\n+async fn test_into_future() -> Result<()> {\n+    run(&REGISTRATION, || async {\n+        let mut resolved = ResolvedVc::cell(42);\n+        let _: ReadRef<u32> = resolved.await?;\n+        let _: ReadRef<u32> = (&resolved).await?;\n+        let _: ReadRef<u32> = (&mut resolved).await?;\n+        let mut unresolved = Vc::cell(42);\n+        let _: ReadRef<u32> = unresolved.await?;\n+        let _: ReadRef<u32> = (&unresolved).await?;\n+        let _: ReadRef<u32> = (&mut unresolved).await?;\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[tokio::test]\n+async fn test_sidecast() -> Result<()> {\n+    run(&REGISTRATION, || async {\n+        let concrete_value = ImplementsAandB.resolved_cell();\n+        let as_a = ResolvedVc::upcast::<Box<dyn TraitA>>(concrete_value);\n+        let as_b = ResolvedVc::try_sidecast::<Box<dyn TraitB>>(as_a);\n+        assert!(as_b.is_some());\n+        let as_c = ResolvedVc::try_sidecast::<Box<dyn TraitC>>(as_a);\n+        assert!(as_c.is_none());\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[turbo_tasks::value_trait]\n+trait TraitA {}\n+\n+#[turbo_tasks::value_trait]\n+trait TraitB {}\n+\n+#[turbo_tasks::value_trait]\n+trait TraitC {}\n+\n+#[turbo_tasks::value]\n+struct ImplementsAandB;\n+\n+#[turbo_tasks::value_impl]\n+impl TraitA for ImplementsAandB {}\n+\n+#[turbo_tasks::value_impl]\n+impl TraitB for ImplementsAandB {}"
        },
        {
            "sha": "b9c42dc7c5214dad706fdc423ca4b4c816cc0f2e",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/scope_stress.rs",
            "status": "renamed",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fscope_stress.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fscope_stress.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fscope_stress.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "previous_filename": "turbopack/crates/turbo-tasks-testing/tests/scope_stress.rs"
        },
        {
            "sha": "bd2c655c31c6b588567d8c5795a3193e663cad70",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/shrink_to_fit.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fshrink_to_fit.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fshrink_to_fit.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fshrink_to_fit.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/shrink_to_fit.rs\n\\ No newline at end of file"
        },
        {
            "sha": "524a78950acf227d74e2d0dea6a53d9335b95c77",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/shrink_to_fit.rs",
            "status": "added",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fshrink_to_fit.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fshrink_to_fit.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Fshrink_to_fit.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,24 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use anyhow::Result;\n+use turbo_tasks::Vc;\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[turbo_tasks::value(transparent)]\n+struct Wrapper(Vec<u32>);\n+\n+#[tokio::test]\n+async fn test_shrink_to_fit() -> Result<()> {\n+    run(&REGISTRATION, || async {\n+        // `Vec::shrink_to_fit` is implicitly called when a cell is constructed.\n+        let a: Vc<Wrapper> = Vc::cell(Vec::with_capacity(100));\n+        assert_eq!(a.await?.capacity(), 0);\n+\n+        Ok(())\n+    })\n+    .await\n+}"
        },
        {
            "sha": "bc0c0bbb90f5ada666b578042350e6caed89633c",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/task_statistics.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftask_statistics.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftask_statistics.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftask_statistics.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/task_statistics.rs\n\\ No newline at end of file"
        },
        {
            "sha": "8a391ace095aafe1eda2b1397e811106b53dfca2",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/task_statistics.rs",
            "status": "added",
            "additions": 274,
            "deletions": 0,
            "changes": 274,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftask_statistics.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftask_statistics.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftask_statistics.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,274 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use std::future::IntoFuture;\n+\n+use anyhow::Result;\n+use once_cell::sync::Lazy;\n+use regex::Regex;\n+use serde_json::json;\n+use turbo_tasks::Vc;\n+use turbo_tasks_testing::{Registration, register, run_without_cache_check};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn test_simple_task() -> Result<()> {\n+    run_without_cache_check(&REGISTRATION, async move {\n+        enable_stats();\n+        for i in 0..10 {\n+            double(i).await.unwrap();\n+            // use cached results\n+            double(i).await.unwrap();\n+        }\n+        for i in 0..5 {\n+            double(i).await.unwrap();\n+        }\n+        assert_eq!(\n+            stats_json(),\n+            json!({\n+                \"double\": {\n+                    \"cache_miss\": 10,\n+                    \"cache_hit\": 15,\n+                },\n+            })\n+        );\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[tokio::test]\n+async fn test_await_same_vc_multiple_times() -> Result<()> {\n+    run_without_cache_check(&REGISTRATION, async move {\n+        enable_stats();\n+        let dvc = double(0);\n+        // this is awaited multiple times, but only resolved once\n+        tokio::try_join!(dvc.into_future(), dvc.into_future()).unwrap();\n+        dvc.await.unwrap();\n+        assert_eq!(\n+            stats_json(),\n+            json!({\n+                \"double\": {\n+                    \"cache_miss\": 1,\n+                    \"cache_hit\": 0,\n+                },\n+            })\n+        );\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[tokio::test]\n+async fn test_vc_receiving_task() -> Result<()> {\n+    run_without_cache_check(&REGISTRATION, async move {\n+        enable_stats();\n+        for i in 0..10 {\n+            let dvc = double(i);\n+            double_vc(dvc).await.unwrap();\n+            // use cached results\n+            double_vc(dvc).await.unwrap();\n+        }\n+        for i in 0..5 {\n+            let dvc = double(i);\n+            double_vc(dvc).await.unwrap();\n+        }\n+        assert_eq!(\n+            stats_json(),\n+            json!({\n+                \"double\": {\n+                    \"cache_miss\": 10,\n+                    \"cache_hit\": 5,\n+                },\n+                \"double_vc\": {\n+                    \"cache_miss\": 10,\n+                    \"cache_hit\": 15,\n+                },\n+            })\n+        );\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[tokio::test]\n+async fn test_trait_methods() -> Result<()> {\n+    run_without_cache_check(&REGISTRATION, async move {\n+        enable_stats();\n+        for i in 0..10 {\n+            let wvc = wrap(i);\n+            tokio::try_join!(wvc.double().into_future(), wvc.double().into_future()).unwrap();\n+            tokio::try_join!(wvc.double_vc().into_future(), wvc.double_vc().into_future()).unwrap();\n+        }\n+        // use cached results\n+        for i in 0..5 {\n+            let wvc = wrap(i);\n+            wvc.double().await.unwrap();\n+            wvc.double_vc().await.unwrap();\n+        }\n+        assert_eq!(\n+            stats_json(),\n+            json!({\n+                \"wrap\": {\n+                    \"cache_miss\": 10,\n+                    \"cache_hit\": 5,\n+                },\n+                \"WrappedU64::Doublable::double\": {\n+                    \"cache_miss\": 10,\n+                    \"cache_hit\": 15,\n+                },\n+                \"WrappedU64::Doublable::double_vc\": {\n+                    \"cache_miss\": 10,\n+                    \"cache_hit\": 15,\n+                },\n+            })\n+        );\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[tokio::test]\n+async fn test_dyn_trait_methods() -> Result<()> {\n+    run_without_cache_check(&REGISTRATION, async move {\n+        enable_stats();\n+        for i in 0..10 {\n+            let wvc: Vc<Box<dyn Doublable>> = Vc::upcast(wrap(i));\n+            let _ = tokio::try_join!(wvc.double().resolve(), wvc.double().resolve()).unwrap();\n+            let _ = tokio::try_join!(wvc.double_vc().resolve(), wvc.double_vc().resolve()).unwrap();\n+        }\n+        // use cached results\n+        for i in 0..5 {\n+            let wvc: Vc<Box<dyn Doublable>> = Vc::upcast(wrap(i));\n+            let _ = wvc.double().resolve().await.unwrap();\n+            let _ = wvc.double_vc().resolve().await.unwrap();\n+        }\n+        // use cached results without dynamic dispatch\n+        for i in 0..2 {\n+            let wvc = wrap(i);\n+            let _ = wvc.double().await.unwrap();\n+            let _ = wvc.double_vc().await.unwrap();\n+        }\n+        assert_eq!(\n+            stats_json(),\n+            json!({\n+                \"wrap\": {\n+                    \"cache_miss\": 10,\n+                    \"cache_hit\": 7,\n+                },\n+                \"WrappedU64::Doublable::double\": {\n+                    \"cache_miss\": 10,\n+                    \"cache_hit\": 17,\n+                },\n+                \"WrappedU64::Doublable::double_vc\": {\n+                    \"cache_miss\": 10,\n+                    \"cache_hit\": 17,\n+                },\n+            })\n+        );\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+// creates Vcs, but doesn't ever execute them\n+#[tokio::test]\n+async fn test_no_execution() -> Result<()> {\n+    run_without_cache_check(&REGISTRATION, async move {\n+        enable_stats();\n+        // don't await this!\n+        let _ = wrap_vc(double_vc(double(123))).double().double_vc();\n+        assert_eq!(\n+            stats_json(),\n+            json!({\n+                \"double\": {\n+                    \"cache_miss\": 1,\n+                    \"cache_hit\": 0,\n+                },\n+            })\n+        );\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+// Internally, this function uses `PersistentTaskType`.\n+#[turbo_tasks::function]\n+fn double(val: u64) -> Vc<u64> {\n+    Vc::cell(val * 2)\n+}\n+\n+// Internally, this function uses `LocalTaskType::ResolveNative`.\n+#[turbo_tasks::function]\n+async fn double_vc(val: Vc<u64>) -> Result<Vc<u64>> {\n+    let val = *val.await?;\n+    Ok(Vc::cell(val * 2))\n+}\n+\n+#[turbo_tasks::value]\n+struct WrappedU64(u64);\n+\n+#[turbo_tasks::function]\n+fn wrap(val: u64) -> Vc<WrappedU64> {\n+    WrappedU64(val).cell()\n+}\n+\n+#[turbo_tasks::function]\n+async fn wrap_vc(val: Vc<u64>) -> Result<Vc<WrappedU64>> {\n+    Ok(WrappedU64(*val.await?).cell())\n+}\n+\n+#[turbo_tasks::value_trait]\n+pub trait Doublable {\n+    #[turbo_tasks::function]\n+    fn double(&self) -> Vc<Self>;\n+    #[turbo_tasks::function]\n+    fn double_vc(self: Vc<Self>) -> Vc<Self>;\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl Doublable for WrappedU64 {\n+    #[turbo_tasks::function]\n+    fn double(&self) -> Vc<Self> {\n+        WrappedU64(self.0 * 2).cell()\n+    }\n+\n+    #[turbo_tasks::function]\n+    fn double_vc(&self) -> Result<Vc<Self>> {\n+        let val = self.0;\n+        Ok(WrappedU64(val * 2).cell())\n+    }\n+}\n+\n+#[turbo_tasks::function]\n+fn fail(val: u64) -> Result<Vc<()>> {\n+    anyhow::bail!(\"failed using {val}\");\n+}\n+\n+fn enable_stats() {\n+    let tt = turbo_tasks::turbo_tasks();\n+    tt.task_statistics().enable();\n+}\n+\n+fn stats_json() -> serde_json::Value {\n+    let tt = turbo_tasks::turbo_tasks();\n+    remove_crate_and_hashes(serde_json::to_value(tt.task_statistics().get()).unwrap())\n+}\n+\n+// Global task identifiers can contain a hash of the crate and dependencies.\n+// Remove that so that we can compare against a stable value in tests.\n+fn remove_crate_and_hashes(mut json: serde_json::Value) -> serde_json::Value {\n+    static HASH_RE: Lazy<Regex> = Lazy::new(|| Regex::new(\"^[^:@]+@[^:]+:+\").unwrap());\n+    match &mut json {\n+        serde_json::Value::Object(map) => {\n+            let old_map = std::mem::take(map);\n+            for (k, v) in old_map {\n+                map.insert(HASH_RE.replace(&k, \"\").into_owned(), v);\n+            }\n+        }\n+        _ => unreachable!(\"expected object\"),\n+    };\n+    json\n+}"
        },
        {
            "sha": "026eed7f3b50f2f95f9c8e4c28057db36f568b70",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trait_ref_cell.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/trait_ref_cell.rs\n\\ No newline at end of file"
        },
        {
            "sha": "03b18261f4b20f698dbfd58fb7ebf5de8bd3f4c6",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trait_ref_cell.rs",
            "status": "added",
            "additions": 114,
            "deletions": 0,
            "changes": 114,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,114 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n+\n+use std::sync::Mutex;\n+\n+use anyhow::Result;\n+use turbo_tasks::{IntoTraitRef, Invalidator, TraitRef, Vc, get_invalidator};\n+use turbo_tasks_testing::{Registration, register, run};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn trait_ref() {\n+    run(&REGISTRATION, || async {\n+        let counter = Counter::cell(Counter {\n+            value: Mutex::new((0, None)),\n+        });\n+\n+        let counter_value = counter.get_value();\n+\n+        assert_eq!(*counter.get_value().strongly_consistent().await?, 0);\n+        assert_eq!(*counter_value.strongly_consistent().await?, 0);\n+\n+        counter.await?.incr();\n+\n+        assert_eq!(*counter.get_value().strongly_consistent().await?, 1);\n+        assert_eq!(*counter_value.strongly_consistent().await?, 1);\n+\n+        // `ref_counter` will still point to the same `counter` instance as `counter`.\n+        let trait_ref_counter = Vc::upcast::<Box<dyn CounterTrait>>(counter)\n+            .into_trait_ref()\n+            .await?;\n+        let ref_counter = TraitRef::cell(trait_ref_counter.clone());\n+        let ref_counter_value = ref_counter.get_value();\n+\n+        // However, `local_counter_value` will point to the value of `counter_value`\n+        // at the time it was turned into a trait reference (just like a `ReadRef`\n+        // would).\n+        let local_counter_value = TraitRef::cell(\n+            Vc::upcast::<Box<dyn CounterValueTrait>>(counter_value)\n+                .into_trait_ref()\n+                .await?,\n+        )\n+        .get_value();\n+\n+        counter.await?.incr();\n+        assert_eq!(trait_ref_counter.get_value_sync().0, 2);\n+        assert_eq!(*counter.get_value().strongly_consistent().await?, 2);\n+        assert_eq!(*counter_value.strongly_consistent().await?, 2);\n+        assert_eq!(*ref_counter_value.strongly_consistent().await?, 2);\n+        assert_eq!(*local_counter_value.strongly_consistent().await?, 1);\n+\n+        anyhow::Ok(())\n+    })\n+    .await\n+    .unwrap()\n+}\n+\n+#[turbo_tasks::value(transparent)]\n+#[derive(Copy, Clone)]\n+struct CounterValue(usize);\n+\n+#[turbo_tasks::value(serialization = \"none\", cell = \"new\", eq = \"manual\")]\n+struct Counter {\n+    #[turbo_tasks(debug_ignore, trace_ignore)]\n+    value: Mutex<(usize, Option<Invalidator>)>,\n+}\n+\n+impl Counter {\n+    fn incr(&self) {\n+        let mut lock = self.value.lock().unwrap();\n+        lock.0 += 1;\n+        if let Some(i) = lock.1.take() {\n+            i.invalidate();\n+        }\n+    }\n+}\n+\n+#[turbo_tasks::value_trait]\n+trait CounterTrait {\n+    #[turbo_tasks::function]\n+    fn get_value(&self) -> Vc<CounterValue>;\n+\n+    fn get_value_sync(&self) -> CounterValue;\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl CounterTrait for Counter {\n+    #[turbo_tasks::function(invalidator)]\n+    fn get_value(&self) -> Result<Vc<CounterValue>> {\n+        let mut lock = self.value.lock().unwrap();\n+        lock.1 = Some(get_invalidator());\n+        Ok(Vc::cell(lock.0))\n+    }\n+\n+    fn get_value_sync(&self) -> CounterValue {\n+        CounterValue(self.value.lock().unwrap().0)\n+    }\n+}\n+\n+#[turbo_tasks::value_trait]\n+trait CounterValueTrait {\n+    #[turbo_tasks::function]\n+    fn get_value(&self) -> Vc<CounterValue>;\n+}\n+\n+#[turbo_tasks::value_impl]\n+impl CounterValueTrait for CounterValue {\n+    #[turbo_tasks::function]\n+    fn get_value(self: Vc<Self>) -> Vc<Self> {\n+        self\n+    }\n+}"
        },
        {
            "sha": "a502db6bef9d5d055c43fbbf519088558f3ccf3c",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/trait_ref_cell_mode.rs",
            "status": "renamed",
            "additions": 18,
            "deletions": 18,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell_mode.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell_mode.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftrait_ref_cell_mode.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -11,7 +11,7 @@ static REGISTRATION: Registration = register!();\n // value is equal.\n #[tokio::test]\n async fn test_trait_ref_shared_cell_mode() {\n-    run(&REGISTRATION, async {\n+    run(&REGISTRATION, || async {\n         let input = CellIdSelector {\n             value: 42,\n             cell_idx: State::new(0),\n@@ -20,33 +20,33 @@ async fn test_trait_ref_shared_cell_mode() {\n \n         // create the task and compute it\n         let counter_value_vc = shared_value_from_input(input);\n-        let trait_ref_a = counter_value_vc.into_trait_ref().await.unwrap();\n+        let trait_ref_a = counter_value_vc.into_trait_ref().await?;\n \n         // invalidate the task, and pick a different cell id for the next execution\n-        input.await.unwrap().cell_idx.set_unconditionally(1);\n+        input.await?.cell_idx.set_unconditionally(1);\n \n         // recompute the task\n-        let trait_ref_b = counter_value_vc.into_trait_ref().await.unwrap();\n+        let trait_ref_b = counter_value_vc.into_trait_ref().await?;\n \n         for trait_ref in [&trait_ref_a, &trait_ref_b] {\n-            assert_eq!(\n-                *TraitRef::cell(trait_ref.clone()).get_value().await.unwrap(),\n-                42\n-            );\n+            assert_eq!(*TraitRef::cell(trait_ref.clone()).get_value().await?, 42);\n         }\n \n         // because we're using `cell = \"shared\"`, these trait refs must use the same\n         // underlying Arc/SharedRef (by identity)\n         assert!(TraitRef::ptr_eq(&trait_ref_a, &trait_ref_b));\n+\n+        anyhow::Ok(())\n     })\n     .await\n+    .unwrap();\n }\n \n // Test that with `cell = \"new\"`, the cell will is never re-used, even if the\n // value is equal.\n #[tokio::test]\n async fn test_trait_ref_new_cell_mode() {\n-    run(&REGISTRATION, async {\n+    run(&REGISTRATION, || async {\n         let input = CellIdSelector {\n             value: 42,\n             cell_idx: State::new(0),\n@@ -55,26 +55,26 @@ async fn test_trait_ref_new_cell_mode() {\n \n         // create the task and compute it\n         let counter_value_vc = new_value_from_input(input);\n-        let trait_ref_a = counter_value_vc.into_trait_ref().await.unwrap();\n+        let trait_ref_a = counter_value_vc.into_trait_ref().await?;\n \n         // invalidate the task, and pick a different cell id for the next execution\n-        input.await.unwrap().cell_idx.set_unconditionally(1);\n+        input.await?.cell_idx.set_unconditionally(1);\n \n         // recompute the task\n-        let trait_ref_b = counter_value_vc.into_trait_ref().await.unwrap();\n+        let trait_ref_b = counter_value_vc.into_trait_ref().await?;\n \n         for trait_ref in [&trait_ref_a, &trait_ref_b] {\n-            assert_eq!(\n-                *TraitRef::cell(trait_ref.clone()).get_value().await.unwrap(),\n-                42\n-            );\n+            assert_eq!(*TraitRef::cell(trait_ref.clone()).get_value().await?, 42);\n         }\n \n         // because we're using `cell = \"new\"`, these trait refs must use different\n         // underlying Arc/SharedRefs (by identity)\n         assert!(!TraitRef::ptr_eq(&trait_ref_a, &trait_ref_b));\n+\n+        anyhow::Ok(())\n     })\n     .await\n+    .unwrap();\n }\n \n #[turbo_tasks::value_trait]\n@@ -135,12 +135,12 @@ where\n     Ok(TraitRef::cell(picked_vc.into_trait_ref().await?))\n }\n \n-#[turbo_tasks::function]\n+#[turbo_tasks::function(invalidator)]\n async fn shared_value_from_input(input: Vc<CellIdSelector>) -> Result<Vc<Box<dyn ValueTrait>>> {\n     value_from_input::<SharedValue>(input, Vc::<SharedValue>::cell).await\n }\n \n-#[turbo_tasks::function]\n+#[turbo_tasks::function(invalidator)]\n async fn new_value_from_input(input: Vc<CellIdSelector>) -> Result<Vc<Box<dyn ValueTrait>>> {\n     value_from_input::<NewValue>(input, Vc::<NewValue>::cell).await\n }",
            "previous_filename": "turbopack/crates/turbo-tasks-testing/tests/trait_ref_cell_mode.rs"
        },
        {
            "sha": "a12b998ce9f5b2d88691103ff08931147e21e787",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/transient_vc.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 1,
            "changes": 1,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftransient_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftransient_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftransient_vc.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1 +0,0 @@\n-../../turbo-tasks-testing/tests/transient_vc.rs\n\\ No newline at end of file"
        },
        {
            "sha": "7db072310c915df44ec3a30cdf789eb9cc89eb3b",
            "filename": "turbopack/crates/turbo-tasks-backend/tests/transient_vc.rs",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/vercel/next.js/blob/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftransient_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/5c1769ea89483c3fe5396817149a4849e5cd62a3/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftransient_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-backend%2Ftests%2Ftransient_vc.rs?ref=5c1769ea89483c3fe5396817149a4849e5cd62a3",
            "patch": "@@ -0,0 +1,55 @@\n+#![feature(arbitrary_self_types)]\n+#![feature(arbitrary_self_types_pointers)]\n+\n+use anyhow::Result;\n+use turbo_tasks::{TaskInput, TransientValue, Vc};\n+use turbo_tasks_testing::{Registration, register, run_without_cache_check};\n+\n+static REGISTRATION: Registration = register!();\n+\n+#[tokio::test]\n+async fn test_transient_vc() -> Result<()> {\n+    run_without_cache_check(&REGISTRATION, async {\n+        test_transient_operation(TransientValue::new(123))\n+            .read_strongly_consistent()\n+            .await?;\n+        Ok(())\n+    })\n+    .await\n+}\n+\n+#[turbo_tasks::function(operation)]\n+async fn test_transient_operation(transient_arg: TransientValue<i32>) -> Result<()> {\n+    let called_with_transient = has_transient_arg(transient_arg);\n+    let called_with_persistent = has_persistent_arg(123);\n+\n+    assert!(called_with_transient.is_transient());\n+    assert!(!called_with_persistent.is_transient());\n+    assert!(has_vc_arg(called_with_transient).is_transient());\n+    assert!(!has_vc_arg(called_with_persistent).is_transient());\n+\n+    let called_with_transient_resolved = called_with_transient.to_resolved().await?;\n+    let called_with_persistent_resolved = called_with_persistent.to_resolved().await?;\n+\n+    assert!(called_with_transient_resolved.is_transient());\n+    assert!(!called_with_persistent_resolved.is_transient());\n+    assert!(has_vc_arg(*called_with_transient_resolved).is_transient());\n+    assert!(!has_vc_arg(*called_with_persistent_resolved).is_transient());\n+\n+    Ok(())\n+}\n+\n+#[turbo_tasks::function]\n+fn has_transient_arg(arg: TransientValue<i32>) -> Vc<i32> {\n+    Vc::cell(*arg)\n+}\n+\n+#[turbo_tasks::function]\n+fn has_persistent_arg(arg: i32) -> Vc<i32> {\n+    Vc::cell(arg)\n+}\n+\n+#[turbo_tasks::function]\n+async fn has_vc_arg(arg: Vc<i32>) -> Result<Vc<i32>> {\n+    Ok(Vc::cell(*arg.await?))\n+}"
        },
        {
            "sha": "f9321cfd797fb32d485ccbf58e57cd1f54d55cd6",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/all_in_one.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 205,
            "changes": 205,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fall_in_one.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fall_in_one.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fall_in_one.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,205 +0,0 @@\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-\n-use anyhow::{Result, bail};\n-use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{ResolvedVc, TaskInput, ValueToString, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn all_in_one() {\n-    run(&REGISTRATION, || async {\n-        let a: Vc<u32> = Vc::cell(4242);\n-        assert_eq!(*a.await?, 4242);\n-\n-        let a: Vc<MyTransparentValue> = Vc::cell(4242);\n-        assert_eq!(*a.await?, 4242);\n-\n-        let b = MyEnumValue::cell(MyEnumValue::More(MyEnumValue::Yeah(42).resolved_cell()));\n-        assert_eq!(*b.to_string().await?, \"42\");\n-\n-        let c = MyStructValue {\n-            value: 42,\n-            next: Some(MyStructValue::new(a).to_resolved().await?),\n-        }\n-        .into();\n-\n-        let result = my_function(a, b.get_last(), c, MyEnumValue::Yeah(42));\n-        assert_eq!(*result.my_trait_function().await?, \"42\");\n-        assert_eq!(*result.my_trait_function2().await?, \"42\");\n-        assert_eq!(*result.my_trait_function3().await?, \"4242\");\n-        assert_eq!(*result.to_string().await?, \"42\");\n-\n-        // Testing Vc<Self> in traits\n-\n-        let a: Vc<Number> = Vc::cell(32);\n-        let b: Vc<Number> = Vc::cell(10);\n-        let c: Vc<Number> = a.add(Vc::upcast(b));\n-\n-        assert_eq!(*c.await?, 42);\n-\n-        let a_erased: Vc<Box<dyn Add>> = Vc::upcast(a);\n-        let b_erased: Vc<Box<dyn Add>> = Vc::upcast(b);\n-        let c_erased: Vc<Box<dyn Add>> = a_erased.add(b_erased);\n-\n-        assert_eq!(\n-            *Vc::try_resolve_downcast_type::<Number>(c_erased)\n-                .await?\n-                .unwrap()\n-                .await?,\n-            42\n-        );\n-\n-        let b_erased_other: Vc<Box<dyn Add>> = Vc::upcast(Vc::<NumberB>::cell(10));\n-        let c_erased_invalid: Vc<Box<dyn Add>> = a_erased.add(b_erased_other);\n-        assert!(c_erased_invalid.resolve().await.is_err());\n-\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-#[derive(Debug, Clone, Hash)]\n-struct MyTransparentValue(u32);\n-\n-#[turbo_tasks::value(shared)]\n-#[derive(Debug, Clone, Hash, TaskInput)]\n-enum MyEnumValue {\n-    Yeah(u32),\n-    Nah,\n-    More(ResolvedVc<MyEnumValue>),\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl MyEnumValue {\n-    #[turbo_tasks::function]\n-    pub async fn get_last(self: Vc<Self>) -> Result<Vc<Self>> {\n-        let mut current = self;\n-        while let MyEnumValue::More(more) = &*current.await? {\n-            current = **more;\n-        }\n-        Ok(current)\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ValueToString for MyEnumValue {\n-    #[turbo_tasks::function]\n-    fn to_string(&self) -> Vc<RcStr> {\n-        match self {\n-            MyEnumValue::Yeah(value) => Vc::cell(value.to_string().into()),\n-            MyEnumValue::Nah => Vc::cell(rcstr!(\"nah\")),\n-            MyEnumValue::More(more) => more.to_string(),\n-        }\n-    }\n-}\n-\n-#[turbo_tasks::value(shared)]\n-struct MyStructValue {\n-    value: u32,\n-    next: Option<ResolvedVc<MyStructValue>>,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl MyStructValue {\n-    #[turbo_tasks::function]\n-    pub async fn new(value: Vc<MyTransparentValue>) -> Result<Vc<Self>> {\n-        Ok(Self::cell(MyStructValue {\n-            value: *value.await?,\n-            next: None,\n-        }))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ValueToString for MyStructValue {\n-    #[turbo_tasks::function]\n-    fn to_string(&self) -> Vc<RcStr> {\n-        Vc::cell(self.value.to_string().into())\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl MyTrait for MyStructValue {\n-    #[turbo_tasks::function]\n-    fn my_trait_function2(self: Vc<Self>) -> Vc<RcStr> {\n-        self.to_string()\n-    }\n-    #[turbo_tasks::function]\n-    fn my_trait_function3(&self) -> Result<Vc<RcStr>> {\n-        if let Some(next) = self.next {\n-            return Ok(next.my_trait_function3());\n-        }\n-        Ok(Vc::cell(self.value.to_string().into()))\n-    }\n-}\n-\n-#[turbo_tasks::value_trait]\n-trait MyTrait: ValueToString {\n-    #[turbo_tasks::function]\n-    async fn my_trait_function(self: Vc<Self>) -> Result<Vc<RcStr>> {\n-        if *self.to_string().await? != \"42\" {\n-            bail!(\"my_trait_function must only be called with 42 as value\")\n-        }\n-        // Calling a function twice\n-        Ok(self.to_string())\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn my_trait_function2(self: Vc<Self>) -> Vc<RcStr>;\n-    #[turbo_tasks::function]\n-    fn my_trait_function3(self: Vc<Self>) -> Vc<RcStr>;\n-}\n-\n-#[turbo_tasks::function]\n-async fn my_function(\n-    a: Vc<MyTransparentValue>,\n-    b: Vc<MyEnumValue>,\n-    c: Vc<MyStructValue>,\n-    d: MyEnumValue,\n-) -> Result<Vc<MyStructValue>> {\n-    assert_eq!(*a.await?, 4242);\n-    assert_eq!(*b.await?, MyEnumValue::Yeah(42));\n-    assert_eq!(c.await?.value, 42);\n-    assert_eq!(d, MyEnumValue::Yeah(42));\n-    Ok(c)\n-}\n-\n-#[turbo_tasks::value_trait]\n-trait Add {\n-    #[turbo_tasks::function]\n-    fn add(self: Vc<Self>, other: Vc<Box<dyn Add>>) -> Vc<Self>;\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-struct Number(u32);\n-\n-#[turbo_tasks::value_impl]\n-impl Add for Number {\n-    #[turbo_tasks::function]\n-    async fn add(self: Vc<Self>, other: Vc<Box<dyn Add>>) -> Result<Vc<Self>> {\n-        let Some(other) = Vc::try_resolve_downcast_type::<Number>(other).await? else {\n-            bail!(\"Expected Number\");\n-        };\n-        Ok(Vc::cell(*self.await? + *other.await?))\n-    }\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-struct NumberB(u32);\n-\n-#[turbo_tasks::value_impl]\n-impl Add for NumberB {\n-    #[turbo_tasks::function]\n-    async fn add(self: Vc<Self>, other: Vc<Box<dyn Add>>) -> Result<Vc<Self>> {\n-        let Some(other) = Vc::try_resolve_downcast_type::<NumberB>(other).await? else {\n-            bail!(\"Expected NumberB\");\n-        };\n-        Ok(Vc::cell(*self.await? + *other.await?))\n-    }\n-}"
        },
        {
            "sha": "a12da0b8578d8eacd60210900d44257ef67e7877",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/basic.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 74,
            "changes": 74,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fbasic.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fbasic.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fbasic.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,74 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use anyhow::Result;\n-use turbo_tasks::Vc;\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn basic() {\n-    run(&REGISTRATION, || async {\n-        let output1 = func_without_args();\n-        assert_eq!(output1.await?.value, 123);\n-\n-        let input = Value { value: 42 }.cell();\n-        let output2 = func_transient(input);\n-        assert_eq!(output2.await?.value, 42);\n-\n-        let output3 = func_persistent(output1);\n-        assert_eq!(output3.await?.value, 123);\n-\n-        let output4 = nested_func_without_args_waiting();\n-        assert_eq!(output4.await?.value, 123);\n-\n-        let output5 = nested_func_without_args_non_waiting();\n-        assert_eq!(output5.await?.value, 123);\n-\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::value]\n-#[derive(Clone, Debug)]\n-struct Value {\n-    value: u32,\n-}\n-\n-#[turbo_tasks::function]\n-async fn func_transient(input: Vc<Value>) -> Result<Vc<Value>> {\n-    println!(\"func_transient\");\n-    let value = input.await?.value;\n-    Ok(Value { value }.cell())\n-}\n-\n-#[turbo_tasks::function]\n-async fn func_persistent(input: Vc<Value>) -> Result<Vc<Value>> {\n-    println!(\"func_persistent\");\n-    let value = input.await?.value;\n-    Ok(Value { value }.cell())\n-}\n-\n-#[turbo_tasks::function]\n-fn func_without_args() -> Result<Vc<Value>> {\n-    println!(\"func_without_args\");\n-    let value = 123;\n-    Ok(Value { value }.cell())\n-}\n-\n-#[turbo_tasks::function]\n-async fn nested_func_without_args_waiting() -> Result<Vc<Value>> {\n-    println!(\"nested_func_without_args_waiting\");\n-    let value = func_without_args().owned().await?;\n-    Ok(value.cell())\n-}\n-\n-#[turbo_tasks::function]\n-fn nested_func_without_args_non_waiting() -> Result<Vc<Value>> {\n-    println!(\"nested_func_without_args_non_waiting\");\n-    Ok(func_without_args())\n-}"
        },
        {
            "sha": "17875d2630d78588665002a3de7c30140c63de14",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/call_types.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 203,
            "changes": 203,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fcall_types.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fcall_types.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fcall_types.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,203 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use anyhow::Result;\n-use turbo_tasks::Vc;\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn functions() {\n-    run(&REGISTRATION, || async {\n-        assert_eq!(*fn_plain().await?, 42);\n-        assert_eq!(*fn_arg(43).await?, 43);\n-        assert_eq!(*fn_vc_arg(Vc::cell(44)).await?, 44);\n-        assert_eq!(*async_fn_plain().await?, 42);\n-        assert_eq!(*async_fn_arg(43).await?, 43);\n-        assert_eq!(*async_fn_vc_arg(Vc::cell(44)).await?, 44);\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::function]\n-fn fn_plain() -> Vc<u32> {\n-    Vc::cell(42)\n-}\n-\n-#[turbo_tasks::function]\n-fn fn_arg(n: u32) -> Vc<u32> {\n-    Vc::cell(n)\n-}\n-\n-#[turbo_tasks::function]\n-fn fn_vc_arg(n: Vc<u32>) -> Vc<u32> {\n-    n\n-}\n-\n-#[turbo_tasks::function]\n-fn async_fn_plain() -> Result<Vc<u32>> {\n-    Ok(Vc::cell(42))\n-}\n-\n-#[turbo_tasks::function]\n-fn async_fn_arg(n: u32) -> Result<Vc<u32>> {\n-    Ok(Vc::cell(n))\n-}\n-\n-#[turbo_tasks::function]\n-async fn async_fn_vc_arg(n: Vc<u32>) -> Result<Vc<u32>> {\n-    Ok(Vc::cell(*n.await?))\n-}\n-\n-#[tokio::test]\n-async fn methods() {\n-    run(&REGISTRATION, || async {\n-        assert_eq!(*Value::static_method().await?, 42);\n-        assert_eq!(*Value::async_static_method().await?, 42);\n-\n-        let value = Value(43).cell();\n-        assert_eq!(*value.method().await?, 43);\n-        assert_eq!(*value.async_method().await?, 43);\n-        assert_eq!(*value.vc_method().await?, 42);\n-        assert_eq!(*value.async_vc_method().await?, 43);\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::value]\n-struct Value(u32);\n-\n-#[turbo_tasks::value_impl]\n-impl Value {\n-    #[turbo_tasks::function]\n-    fn static_method() -> Vc<u32> {\n-        Vc::cell(42)\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn async_static_method() -> Result<Vc<u32>> {\n-        Ok(Vc::cell(42))\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn method(&self) -> Vc<u32> {\n-        Vc::cell(self.0)\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn async_method(&self) -> Result<Vc<u32>> {\n-        Ok(Vc::cell(self.0))\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn vc_method(self: Vc<Self>) -> Vc<u32> {\n-        Vc::cell(42)\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn async_vc_method(&self) -> Result<Vc<u32>> {\n-        Ok(Vc::cell(self.0))\n-    }\n-}\n-\n-#[tokio::test]\n-async fn trait_methods() {\n-    run(&REGISTRATION, || async {\n-        assert_eq!(*Value::static_trait_method().await?, 42);\n-        assert_eq!(*Value::async_static_trait_method().await?, 42);\n-\n-        let value = Value(43).cell();\n-        assert_eq!(*value.trait_method().await?, 43);\n-        assert_eq!(*value.async_trait_method().await?, 43);\n-        assert_eq!(*value.default_trait_method().await?, 42);\n-        assert_eq!(*value.default_async_trait_method().await?, 42);\n-\n-        let trait_value: Vc<Box<dyn ValueTrait>> = Vc::upcast(value);\n-        assert_eq!(*trait_value.trait_method().await?, 43);\n-        assert_eq!(*trait_value.async_trait_method().await?, 43);\n-        assert_eq!(*trait_value.default_trait_method().await?, 42);\n-        assert_eq!(*trait_value.default_async_trait_method().await?, 42);\n-\n-        let value = wrap_value(value);\n-        assert_eq!(*value.trait_method().await?, 43);\n-        assert_eq!(*value.async_trait_method().await?, 43);\n-        assert_eq!(*value.default_trait_method().await?, 42);\n-        assert_eq!(*value.default_async_trait_method().await?, 42);\n-\n-        let trait_value = wrap_trait_value(trait_value);\n-        assert_eq!(*trait_value.trait_method().await?, 43);\n-        assert_eq!(*trait_value.async_trait_method().await?, 43);\n-        assert_eq!(*trait_value.default_trait_method().await?, 42);\n-        assert_eq!(*trait_value.default_async_trait_method().await?, 42);\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::function]\n-fn wrap_value(v: Vc<Value>) -> Vc<Value> {\n-    v\n-}\n-\n-#[turbo_tasks::function]\n-fn wrap_trait_value(v: Vc<Box<dyn ValueTrait>>) -> Vc<Box<dyn ValueTrait>> {\n-    v\n-}\n-\n-#[turbo_tasks::value_trait]\n-trait ValueTrait {\n-    #[turbo_tasks::function]\n-    fn static_trait_method() -> Vc<u32>;\n-    #[turbo_tasks::function]\n-    async fn async_static_trait_method() -> Result<Vc<u32>>;\n-    #[turbo_tasks::function]\n-    fn default_static_trait_method() -> Vc<u32> {\n-        Vc::cell(42)\n-    }\n-    #[turbo_tasks::function]\n-    fn default_async_static_trait_method() -> Result<Vc<u32>> {\n-        Ok(Vc::cell(42))\n-    }\n-    #[turbo_tasks::function]\n-    fn trait_method(&self) -> Vc<u32>;\n-    #[turbo_tasks::function]\n-    fn async_trait_method(&self) -> Result<Vc<u32>>;\n-    #[turbo_tasks::function]\n-    fn default_trait_method(self: Vc<Self>) -> Vc<u32> {\n-        Vc::cell(42)\n-    }\n-    #[turbo_tasks::function]\n-    fn default_async_trait_method(self: Vc<Self>) -> Result<Vc<u32>> {\n-        Ok(Vc::cell(42))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ValueTrait for Value {\n-    #[turbo_tasks::function]\n-    fn static_trait_method() -> Vc<u32> {\n-        Vc::cell(42)\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn async_static_trait_method() -> Result<Vc<u32>> {\n-        Ok(Vc::cell(42))\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn trait_method(&self) -> Vc<u32> {\n-        Vc::cell(self.0)\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn async_trait_method(&self) -> Result<Vc<u32>> {\n-        Ok(Vc::cell(self.0))\n-    }\n-}"
        },
        {
            "sha": "a86c0e09343d078a8eaa006050435fef2360757a",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/collectibles.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 271,
            "changes": 271,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fcollectibles.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fcollectibles.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fcollectibles.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,271 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use std::time::Duration;\n-\n-use anyhow::Result;\n-use auto_hash_map::AutoSet;\n-use rustc_hash::FxHashSet;\n-use tokio::time::sleep;\n-use turbo_rcstr::{RcStr, rcstr};\n-use turbo_tasks::{CollectiblesSource, ResolvedVc, ValueToString, Vc, emit};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn transitive_emitting() {\n-    run(&REGISTRATION, || async {\n-        let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"\"));\n-        let result_val = result_op.connect().strongly_consistent().await?;\n-        let list = result_op.peek_collectibles::<Box<dyn ValueToString>>();\n-        assert_eq!(list.len(), 2);\n-        let mut expected = [\"123\", \"42\"].into_iter().collect::<FxHashSet<_>>();\n-        for collectible in list {\n-            assert!(expected.remove(collectible.to_string().await?.as_str()))\n-        }\n-        assert_eq!(result_val.0, 0);\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn transitive_emitting_indirect() {\n-    run(&REGISTRATION, || async {\n-        let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"\"));\n-        let collectibles_op = my_transitive_emitting_function_collectibles(rcstr!(\"\"), rcstr!(\"\"));\n-        let list = collectibles_op.connect().strongly_consistent().await?;\n-        assert_eq!(list.len(), 2);\n-        let mut expected = [\"123\", \"42\"].into_iter().collect::<FxHashSet<_>>();\n-        for collectible in list.iter() {\n-            assert!(expected.remove(collectible.to_string().await?.as_str()))\n-        }\n-        assert_eq!(result_op.connect().await?.0, 0);\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn multi_emitting() {\n-    run(&REGISTRATION, || async {\n-        let result_op = my_multi_emitting_function();\n-        let result_val = result_op.connect().strongly_consistent().await?;\n-        let list = result_op.peek_collectibles::<Box<dyn ValueToString>>();\n-        assert_eq!(list.len(), 2);\n-        let mut expected = [\"123\", \"42\"].into_iter().collect::<FxHashSet<_>>();\n-        for collectible in list {\n-            assert!(expected.remove(collectible.to_string().await?.as_str()))\n-        }\n-        assert_eq!(result_val.0, 0);\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn taking_collectibles() {\n-    run(&REGISTRATION, || async {\n-        let result_op = my_collecting_function();\n-        let result_val = result_op.connect().strongly_consistent().await?;\n-        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n-        // my_collecting_function already processed the collectibles so the list should\n-        // be empty\n-        assert!(list.is_empty());\n-        assert_eq!(result_val.0, 0);\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn taking_collectibles_extra_layer() {\n-    run(&REGISTRATION, || async {\n-        let result_op = my_collecting_function_indirect();\n-        let result_val = result_op.connect().strongly_consistent().await?;\n-        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n-        // my_collecting_function already processed the collectibles so the list should\n-        // be empty\n-        assert!(list.is_empty());\n-        assert_eq!(result_val.0, 0);\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn taking_collectibles_parallel() {\n-    run(&REGISTRATION, || async {\n-        let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"a\"));\n-        let result_val = result_op.connect().strongly_consistent().await?;\n-        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n-        assert_eq!(list.len(), 2);\n-        assert_eq!(result_val.0, 0);\n-\n-        let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"b\"));\n-        let result_val = result_op.connect().strongly_consistent().await?;\n-        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n-        assert_eq!(list.len(), 2);\n-        assert_eq!(result_val.0, 0);\n-\n-        let result_op =\n-            my_transitive_emitting_function_with_child_scope(rcstr!(\"\"), rcstr!(\"b\"), rcstr!(\"1\"));\n-        let result_val = result_op.connect().strongly_consistent().await?;\n-        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n-        assert_eq!(list.len(), 2);\n-        assert_eq!(result_val.0, 0);\n-\n-        let result_op =\n-            my_transitive_emitting_function_with_child_scope(rcstr!(\"\"), rcstr!(\"b\"), rcstr!(\"2\"));\n-        let result_val = result_op.connect().strongly_consistent().await?;\n-        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n-        assert_eq!(list.len(), 2);\n-        assert_eq!(result_val.0, 0);\n-\n-        let result_op =\n-            my_transitive_emitting_function_with_child_scope(rcstr!(\"\"), rcstr!(\"c\"), rcstr!(\"3\"));\n-        let result_val = result_op.connect().strongly_consistent().await?;\n-        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n-        assert_eq!(list.len(), 2);\n-        assert_eq!(result_val.0, 0);\n-\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn taking_collectibles_with_resolve() {\n-    run(&REGISTRATION, || async {\n-        let result_op = my_transitive_emitting_function_with_resolve(rcstr!(\"resolve\"));\n-        result_op.connect().strongly_consistent().await?;\n-        let list = result_op.take_collectibles::<Box<dyn ValueToString>>();\n-        assert_eq!(list.len(), 2);\n-\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-struct Collectibles(AutoSet<ResolvedVc<Box<dyn ValueToString>>>);\n-\n-#[turbo_tasks::function(operation)]\n-async fn my_collecting_function() -> Result<Vc<Thing>> {\n-    let result_op = my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"\"));\n-    let result_vc = result_op.connect();\n-    result_vc.await?;\n-    result_op.take_collectibles::<Box<dyn ValueToString>>();\n-    Ok(result_vc)\n-}\n-\n-#[turbo_tasks::function(operation)]\n-async fn my_collecting_function_indirect() -> Result<Vc<Thing>> {\n-    let result_op = my_collecting_function();\n-    let result_vc = result_op.connect();\n-    result_vc.strongly_consistent().await?;\n-    let list = result_op.peek_collectibles::<Box<dyn ValueToString>>();\n-    // my_collecting_function already processed the collectibles so the list should\n-    // be empty\n-    assert!(list.is_empty());\n-    Ok(result_vc)\n-}\n-\n-#[turbo_tasks::function(operation)]\n-async fn my_multi_emitting_function() -> Result<Vc<Thing>> {\n-    my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"a\"))\n-        .connect()\n-        .await?;\n-    my_transitive_emitting_function(rcstr!(\"\"), rcstr!(\"b\"))\n-        .connect()\n-        .await?;\n-    my_emitting_function(rcstr!(\"\")).await?;\n-    Ok(Thing::cell(Thing(0)))\n-}\n-\n-#[turbo_tasks::function(operation)]\n-async fn my_transitive_emitting_function(key: RcStr, key2: RcStr) -> Result<Vc<Thing>> {\n-    let _ = key2;\n-    my_emitting_function(key).await?;\n-    Ok(Thing::cell(Thing(0)))\n-}\n-\n-#[turbo_tasks::function(operation)]\n-fn my_transitive_emitting_function_collectibles(\n-    key: RcStr,\n-    key2: RcStr,\n-) -> Result<Vc<Collectibles>> {\n-    let result_op = my_transitive_emitting_function(key, key2);\n-    Ok(Vc::cell(\n-        result_op.peek_collectibles::<Box<dyn ValueToString>>(),\n-    ))\n-}\n-\n-#[turbo_tasks::function(operation)]\n-async fn my_transitive_emitting_function_with_child_scope(\n-    key: RcStr,\n-    key2: RcStr,\n-    key3: RcStr,\n-) -> Result<Vc<Thing>> {\n-    let _ = key3;\n-    let thing_op = my_transitive_emitting_function(key, key2);\n-    let thing_vc = thing_op.connect();\n-    thing_vc.await?;\n-    let list = thing_op.peek_collectibles::<Box<dyn ValueToString>>();\n-    assert_eq!(list.len(), 2);\n-    Ok(thing_vc)\n-}\n-\n-#[turbo_tasks::function]\n-async fn my_emitting_function(key: RcStr) -> Result<()> {\n-    let _ = key;\n-    sleep(Duration::from_millis(100)).await;\n-    emit(ResolvedVc::upcast::<Box<dyn ValueToString>>(Thing::new(\n-        123,\n-    )));\n-    emit(ResolvedVc::upcast::<Box<dyn ValueToString>>(Thing::new(42)));\n-    Ok(())\n-}\n-\n-#[turbo_tasks::function]\n-fn my_transitive_emitting_function_with_thing(key: RcStr, _thing: Vc<Thing>) -> Result<()> {\n-    let _ = my_emitting_function(key);\n-    Ok(())\n-}\n-\n-#[turbo_tasks::function(operation)]\n-fn my_transitive_emitting_function_with_resolve(key: RcStr) -> Result<()> {\n-    let _ = my_transitive_emitting_function_with_thing(key, get_thing(0));\n-    Ok(())\n-}\n-\n-#[turbo_tasks::value(shared)]\n-struct Thing(u32);\n-\n-impl Thing {\n-    fn new(v: u32) -> ResolvedVc<Self> {\n-        Self::resolved_cell(Thing(v))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ValueToString for Thing {\n-    #[turbo_tasks::function]\n-    fn to_string(&self) -> Vc<RcStr> {\n-        Vc::cell(self.0.to_string().into())\n-    }\n-}\n-\n-#[turbo_tasks::function]\n-fn get_thing(v: u32) -> Vc<Thing> {\n-    Thing::cell(Thing(v))\n-}"
        },
        {
            "sha": "854d57b2343956559a89a080657bbe30f44fe704",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/debug.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 202,
            "changes": 202,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdebug.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdebug.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdebug.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,202 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use std::sync::Mutex;\n-\n-use turbo_tasks::{ResolvedVc, Vc, debug::ValueDebug};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn primitive_debug() {\n-    run(&REGISTRATION, || async {\n-        let a: Vc<u32> = Vc::cell(42);\n-        assert_eq!(format!(\"{:?}\", a.dbg().await?), \"42\");\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn transparent_debug() {\n-    run(&REGISTRATION, || async {\n-        let a: Vc<Transparent> = Transparent(42).cell();\n-        assert_eq!(format!(\"{:?}\", a.dbg().await?), \"42\");\n-\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn enum_none_debug() {\n-    run(&REGISTRATION, || async {\n-        let a: Vc<Enum> = Enum::None.cell();\n-        assert_eq!(format!(\"{:?}\", a.dbg().await?), \"Enum :: None\");\n-\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn enum_transparent_debug() {\n-    run(&REGISTRATION, || async {\n-        let a: Vc<Enum> = Enum::Transparent(Transparent(42).resolved_cell()).cell();\n-        assert_eq!(\n-            format!(\"{:?}\", a.dbg().await?),\n-            r#\"Enum :: Transparent(\n-    42,\n-)\"#\n-        );\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn enum_inner_vc_debug() {\n-    run(&REGISTRATION, || async {\n-        let a: Vc<Enum> = Enum::Enum(Enum::None.resolved_cell()).cell();\n-        assert_eq!(\n-            format!(\"{:?}\", a.dbg().await?),\n-            r#\"Enum :: Enum(\n-    Enum :: None,\n-)\"#\n-        );\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn struct_unit_debug() {\n-    run(&REGISTRATION, || async {\n-        let a: Vc<StructUnit> = StructUnit.cell();\n-        assert_eq!(format!(\"{:?}\", a.dbg().await?), \"StructUnit\");\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn struct_transparent_debug() {\n-    run(&REGISTRATION, || async {\n-        let a: Vc<StructWithTransparent> = StructWithTransparent {\n-            transparent: Transparent(42).resolved_cell(),\n-        }\n-        .cell();\n-        assert_eq!(\n-            format!(\"{:?}\", a.dbg().await?),\n-            r#\"StructWithTransparent {\n-    transparent: 42,\n-}\"#\n-        );\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn struct_vec_debug() {\n-    run(&REGISTRATION, || async {\n-        let a: Vc<StructWithVec> = StructWithVec { vec: vec![] }.cell();\n-        assert_eq!(\n-            format!(\"{:?}\", a.dbg().await?),\n-            r#\"StructWithVec {\n-    vec: [],\n-}\"#\n-        );\n-\n-        let b: Vc<StructWithVec> = StructWithVec {\n-            vec: vec![Transparent(42).resolved_cell()],\n-        }\n-        .cell();\n-        assert_eq!(\n-            format!(\"{:?}\", b.dbg().await?),\n-            r#\"StructWithVec {\n-    vec: [\n-        42,\n-    ],\n-}\"#\n-        );\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn struct_ignore_debug() {\n-    run(&REGISTRATION, || async {\n-        let a: Vc<StructWithIgnore> = StructWithIgnore {\n-            dont_ignore: 42,\n-            ignore: Mutex::new(()),\n-        }\n-        .cell();\n-        assert_eq!(\n-            format!(\"{:?}\", a.dbg().await?),\n-            r#\"StructWithIgnore {\n-    dont_ignore: 42,\n-}\"#\n-        );\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::value(transparent, shared)]\n-struct Transparent(u32);\n-\n-// Allow Enum::Enum\n-#[allow(clippy::enum_variant_names)]\n-#[turbo_tasks::value(shared)]\n-enum Enum {\n-    None,\n-    Transparent(ResolvedVc<Transparent>),\n-    Enum(ResolvedVc<Enum>),\n-}\n-\n-#[turbo_tasks::value(shared)]\n-struct StructUnit;\n-\n-#[turbo_tasks::value(shared)]\n-struct StructWithTransparent {\n-    transparent: ResolvedVc<Transparent>,\n-}\n-\n-#[turbo_tasks::value(shared)]\n-struct StructWithOption {\n-    option: Option<ResolvedVc<Transparent>>,\n-}\n-\n-#[turbo_tasks::value(shared)]\n-struct StructWithVec {\n-    vec: Vec<ResolvedVc<Transparent>>,\n-}\n-\n-#[turbo_tasks::value(shared, eq = \"manual\")]\n-struct StructWithIgnore {\n-    dont_ignore: u32,\n-    // We're using a `Mutex` instead of a `T: Debug` type to ensure we support `T: !Debug`.\n-    #[turbo_tasks(debug_ignore, trace_ignore)]\n-    ignore: Mutex<()>,\n-}\n-\n-impl PartialEq for StructWithIgnore {\n-    fn eq(&self, other: &Self) -> bool {\n-        self.dont_ignore == other.dont_ignore\n-    }\n-}\n-\n-impl Eq for StructWithIgnore {}"
        },
        {
            "sha": "73a083ac600156a63b6b1d664c5cdf777440c499",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/detached.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 170,
            "changes": 170,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdetached.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdetached.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdetached.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,170 +0,0 @@\n-#![allow(clippy::needless_return)] // clippy bug causes false positive\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-\n-use tokio::{\n-    sync::{Notify, watch},\n-    time::{Duration, sleep, timeout},\n-};\n-use turbo_tasks::{\n-    State, TransientInstance, Vc, prevent_gc,\n-    trace::{TraceRawVcs, TraceRawVcsContext},\n-    turbo_tasks,\n-};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn test_spawns_detached() -> anyhow::Result<()> {\n-    run(&REGISTRATION, || async {\n-        // HACK: The watch channel we use has an incorrect implementation of `TraceRawVcs`, just\n-        // disable GC for the test so this can't cause any problems.\n-        prevent_gc();\n-        // timeout: prevent the test from hanging, and fail instead if this is broken\n-        timeout(Duration::from_secs(5), async {\n-            let notify = TransientInstance::new(NotifyTaskInput(Notify::new()));\n-            let (tx, mut rx) = watch::channel(None);\n-            let tx = TransientInstance::new(WatchSenderTaskInput(tx));\n-\n-            // create the task\n-            let out_vc = spawns_detached(notify.clone(), tx.clone());\n-\n-            // see that the task does not exit yet\n-            timeout(Duration::from_millis(100), out_vc.strongly_consistent())\n-                .await\n-                .expect_err(\"should wait on the detached task\");\n-\n-            // let the detached future exit\n-            notify.0.notify_waiters();\n-\n-            // it should send us back a cell\n-            let detached_vc: Vc<u32> = rx.wait_for(|opt| opt.is_some()).await?.unwrap();\n-            assert_eq!(*detached_vc.strongly_consistent().await?, 42);\n-\n-            // the parent task should now be able to exit\n-            out_vc.strongly_consistent().await?;\n-\n-            Ok(())\n-        })\n-        .await?\n-    })\n-    .await\n-}\n-\n-#[derive(TraceRawVcs)]\n-struct NotifyTaskInput(\n-    // trace_ignore: `notify` doesn't store any data\n-    #[turbo_tasks(trace_ignore)] Notify,\n-);\n-\n-struct WatchSenderTaskInput<T>(watch::Sender<T>);\n-\n-impl<T: TraceRawVcs> TraceRawVcs for WatchSenderTaskInput<T> {\n-    fn trace_raw_vcs(&self, _trace_context: &mut TraceRawVcsContext) {\n-        // HACK: This implementation is wrong (the channel contains a `Vc`), but we can't access it.\n-        // Instead we just `prevent_gc` in the tests.\n-    }\n-}\n-\n-#[turbo_tasks::function]\n-async fn spawns_detached(\n-    notify: TransientInstance<NotifyTaskInput>,\n-    sender: TransientInstance<WatchSenderTaskInput<Option<Vc<u32>>>>,\n-) -> Vc<()> {\n-    tokio::spawn(turbo_tasks().detached_for_testing(Box::pin(async move {\n-        notify.0.notified().await;\n-        // creating cells after the normal lifetime of the task should be okay, as the parent task\n-        // is waiting on us before exiting!\n-        sender.0.send(Some(Vc::cell(42))).unwrap();\n-        Ok(())\n-    })));\n-    Vc::cell(())\n-}\n-\n-#[tokio::test]\n-async fn test_spawns_detached_changing() -> anyhow::Result<()> {\n-    run(&REGISTRATION, || async {\n-        // HACK: The watch channel we use has an incorrect implementation of `TraceRawVcs`\n-        prevent_gc();\n-        // timeout: prevent the test from hanging, and fail instead if this is broken\n-        timeout(Duration::from_secs(5), async {\n-            let (tx, mut rx) = watch::channel(None);\n-            let tx = TransientInstance::new(WatchSenderTaskInput(tx));\n-\n-            // state that's read by the detached future\n-            let changing_input_detached = ChangingInput {\n-                state: State::new(42),\n-            }\n-            .cell();\n-\n-            // state that's read by the outer task\n-            let changing_input_outer = ChangingInput {\n-                state: State::new(0),\n-            }\n-            .cell();\n-\n-            // create the task\n-            let out_vc =\n-                spawns_detached_changing(tx.clone(), changing_input_detached, changing_input_outer);\n-\n-            // it should send us back a cell\n-            let detached_vc: Vc<u32> = rx.wait_for(|opt| opt.is_some()).await.unwrap().unwrap();\n-            assert_eq!(*detached_vc.strongly_consistent().await.unwrap(), 42);\n-\n-            // the parent task should now be able to exit\n-            out_vc.strongly_consistent().await.unwrap();\n-\n-            // changing either input should invalidate the vc and cause it to run again\n-            changing_input_detached.await.unwrap().state.set(43);\n-            out_vc.strongly_consistent().await.unwrap();\n-            assert_eq!(*detached_vc.strongly_consistent().await.unwrap(), 43);\n-\n-            changing_input_outer.await.unwrap().state.set(44);\n-            assert_eq!(*out_vc.strongly_consistent().await.unwrap(), 44);\n-\n-            Ok(())\n-        })\n-        .await?\n-    })\n-    .await\n-}\n-\n-#[turbo_tasks::value]\n-struct ChangingInput {\n-    state: State<u32>,\n-}\n-\n-#[turbo_tasks::function]\n-async fn spawns_detached_changing(\n-    sender: TransientInstance<WatchSenderTaskInput<Option<Vc<u32>>>>,\n-    changing_input_detached: Vc<ChangingInput>,\n-    changing_input_outer: Vc<ChangingInput>,\n-) -> Vc<u32> {\n-    let tt = turbo_tasks();\n-    tokio::spawn(tt.clone().detached_for_testing(Box::pin(async move {\n-        sleep(Duration::from_millis(100)).await;\n-        // nested detached_for_testing calls should work\n-        tokio::spawn(tt.clone().detached_for_testing(Box::pin(async move {\n-            sleep(Duration::from_millis(100)).await;\n-            // creating cells after the normal lifetime of the task should be okay, as the parent\n-            // task is waiting on us before exiting!\n-            sender\n-                .0\n-                .send(Some(Vc::cell(\n-                    *read_changing_input(changing_input_detached).await.unwrap(),\n-                )))\n-                .unwrap();\n-            Ok(())\n-        })));\n-        Ok(())\n-    })));\n-    Vc::cell(*read_changing_input(changing_input_outer).await.unwrap())\n-}\n-\n-// spawns_detached should take a dependency on this function for each input\n-#[turbo_tasks::function(invalidator)]\n-async fn read_changing_input(changing_input: Vc<ChangingInput>) -> Vc<u32> {\n-    // when changing_input.set is called, it will trigger an invalidator for this task\n-    Vc::cell(*changing_input.await.unwrap().state.get())\n-}"
        },
        {
            "sha": "49027755fcfa9691a1803fc6e3a157fb197ab57a",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/dirty_in_progress.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 109,
            "changes": 109,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdirty_in_progress.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdirty_in_progress.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fdirty_in_progress.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,109 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use std::time::Duration;\n-\n-use anyhow::{Result, bail};\n-use turbo_rcstr::RcStr;\n-use turbo_tasks::{CollectiblesSource, ResolvedVc, State, ValueToString, Vc, emit};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn dirty_in_progress() {\n-    run(&REGISTRATION, || async {\n-        let cases = [\n-            (1, 3, 2, 2, \"\"),\n-            (11, 13, 12, 42, \"12\"),\n-            (1, 13, 11, 42, \"11\"),\n-            (1, 3, 11, 42, \"11\"),\n-            (11, 3, 2, 2, \"\"),\n-            (11, 13, 2, 2, \"\"),\n-        ];\n-        for (a, b, c, value, collectible) in cases {\n-            println!(\"{a} -> {b} -> {c} = {value} {collectible}\");\n-            let input = ChangingInput {\n-                state: State::new(a),\n-            }\n-            .cell();\n-            let input_val = input.await?;\n-            let output = compute(input);\n-            output.await?;\n-            println!(\"update to {b}\");\n-            input_val.state.set(b);\n-            tokio::time::sleep(Duration::from_millis(50)).await;\n-            println!(\"update to {c}\");\n-            input_val.state.set(c);\n-            let read = output.strongly_consistent().await?;\n-            assert_eq!(read.value, value);\n-            assert_eq!(read.collectible, collectible);\n-            println!(\"\\n\");\n-        }\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::value]\n-struct ChangingInput {\n-    state: State<u32>,\n-}\n-\n-#[turbo_tasks::value]\n-struct Output {\n-    value: u32,\n-    collectible: String,\n-}\n-\n-#[turbo_tasks::value]\n-struct Collectible {\n-    value: u32,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ValueToString for Collectible {\n-    #[turbo_tasks::function]\n-    fn to_string(&self) -> Vc<RcStr> {\n-        Vc::cell(self.value.to_string().into())\n-    }\n-}\n-\n-#[turbo_tasks::function(operation, invalidator)]\n-async fn inner_compute(input: ResolvedVc<ChangingInput>) -> Result<Vc<u32>> {\n-    println!(\"start inner_compute\");\n-    let value = *input.await?.state.get();\n-    tokio::time::sleep(Duration::from_millis(200)).await;\n-    if value > 10 {\n-        let collectible: ResolvedVc<Box<dyn ValueToString>> =\n-            ResolvedVc::upcast(Collectible { value }.resolved_cell());\n-        emit(collectible);\n-\n-        println!(\"end inner_compute with collectible\");\n-        Ok(Vc::cell(42))\n-    } else {\n-        println!(\"end inner_compute without collectible\");\n-        Ok(Vc::cell(value))\n-    }\n-}\n-\n-#[turbo_tasks::function]\n-async fn compute(input: ResolvedVc<ChangingInput>) -> Result<Vc<Output>> {\n-    println!(\"start compute\");\n-    let operation = inner_compute(input);\n-    let value = *operation.connect().await?;\n-    let collectibles = operation.peek_collectibles::<Box<dyn ValueToString>>();\n-    if collectibles.len() > 1 {\n-        bail!(\"expected 0..1 collectible, found {}\", collectibles.len());\n-    }\n-    let first = collectibles.iter().next();\n-    let collectible = if let Some(first) = first {\n-        first.to_string().await?.to_string()\n-    } else {\n-        \"\".to_string()\n-    };\n-    println!(\"end compute\");\n-    Ok(Output { value, collectible }.cell())\n-}"
        },
        {
            "sha": "8ebc61a705fa352f830563ea7fbcfdbc3d2aa54d",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/emptied_cells.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 75,
            "changes": 75,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Femptied_cells.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Femptied_cells.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Femptied_cells.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,75 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use anyhow::Result;\n-use turbo_tasks::{State, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn recompute() {\n-    run(&REGISTRATION, || async {\n-        let input = ChangingInput {\n-            state: State::new(1),\n-        }\n-        .cell();\n-        let output = compute(input);\n-        assert_eq!(*output.await?, 1);\n-\n-        println!(\"changing input\");\n-        input.await?.state.set(10);\n-        assert_eq!(*output.strongly_consistent().await?, 10);\n-\n-        println!(\"changing input\");\n-        input.await?.state.set(5);\n-        assert_eq!(*output.strongly_consistent().await?, 5);\n-\n-        println!(\"changing input\");\n-        input.await?.state.set(20);\n-        assert_eq!(*output.strongly_consistent().await?, 20);\n-\n-        println!(\"changing input\");\n-        input.await?.state.set(15);\n-        assert_eq!(*output.strongly_consistent().await?, 15);\n-\n-        println!(\"changing input\");\n-        input.await?.state.set(1);\n-        assert_eq!(*output.strongly_consistent().await?, 1);\n-\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap();\n-}\n-\n-#[turbo_tasks::value]\n-struct ChangingInput {\n-    state: State<u32>,\n-}\n-\n-#[turbo_tasks::function]\n-async fn compute(input: Vc<ChangingInput>) -> Result<Vc<u32>> {\n-    println!(\"compute()\");\n-    let value = *inner_compute(input).await?;\n-    Ok(Vc::cell(value))\n-}\n-\n-#[turbo_tasks::function(invalidator)]\n-async fn inner_compute(input: Vc<ChangingInput>) -> Result<Vc<u32>> {\n-    println!(\"inner_compute()\");\n-    let state_value = *input.await?.state.get();\n-    let mut last = None;\n-    for i in 0..=state_value {\n-        last = Some(compute2(Vc::cell(i)));\n-    }\n-    Ok(last.unwrap())\n-}\n-\n-#[turbo_tasks::function]\n-async fn compute2(input: Vc<u32>) -> Result<Vc<u32>> {\n-    println!(\"compute2()\");\n-    let value = *input.await?;\n-    Ok(Vc::cell(value))\n-}"
        },
        {
            "sha": "b7081174940c6c94de9bd441dcc55c477b04ca63",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/filter_unused_args.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 65,
            "changes": 65,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Ffilter_unused_args.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Ffilter_unused_args.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Ffilter_unused_args.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,65 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use anyhow::Result;\n-use turbo_tasks::Vc;\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn filtered_trait_method_args() -> Result<()> {\n-    run(&REGISTRATION, || async {\n-        let uses_arg = UsesArg.cell();\n-        assert_eq!(\n-            uses_arg.method_with_arg(0).to_resolved().await?,\n-            uses_arg.method_with_arg(0).to_resolved().await?,\n-        );\n-        assert_ne!(\n-            uses_arg.method_with_arg(0).to_resolved().await?,\n-            uses_arg.method_with_arg(1).to_resolved().await?,\n-        );\n-\n-        let ignores_arg = IgnoresArg.cell();\n-        assert_eq!(\n-            ignores_arg.method_with_arg(0).to_resolved().await?,\n-            ignores_arg.method_with_arg(0).to_resolved().await?,\n-        );\n-        assert_eq!(\n-            ignores_arg.method_with_arg(0).to_resolved().await?,\n-            ignores_arg.method_with_arg(1).to_resolved().await?,\n-        );\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[turbo_tasks::value_trait]\n-trait ExampleTrait {\n-    #[turbo_tasks::function]\n-    fn method_with_arg(&self, number: i32) -> Vc<()>;\n-}\n-\n-#[turbo_tasks::value]\n-struct UsesArg;\n-\n-#[turbo_tasks::value_impl]\n-impl ExampleTrait for UsesArg {\n-    #[turbo_tasks::function]\n-    fn method_with_arg(&self, number: i32) -> Vc<()> {\n-        let _ = number;\n-        Vc::cell(())\n-    }\n-}\n-\n-#[turbo_tasks::value]\n-struct IgnoresArg;\n-\n-#[turbo_tasks::value_impl]\n-impl ExampleTrait for IgnoresArg {\n-    #[turbo_tasks::function]\n-    fn method_with_arg(&self, _number: i32) -> Vc<()> {\n-        Vc::cell(())\n-    }\n-}"
        },
        {
            "sha": "e2a6a7abdfa740fc73a61ffe790d6ef1f986650e",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/local_tasks.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 69,
            "changes": 69,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Flocal_tasks.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Flocal_tasks.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Flocal_tasks.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,69 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use anyhow::Result;\n-use turbo_tasks::{Vc, test_helpers::current_task_for_testing};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn test_local_task_id() -> Result<()> {\n-    run(&REGISTRATION, || async {\n-        let local_vc = get_local_task_id();\n-        assert!(local_vc.is_local());\n-        assert_eq!(*local_vc.await.unwrap(), *current_task_for_testing());\n-\n-        let local_trait_vc = Foo {}.cell().get_local_task_id();\n-        assert!(local_trait_vc.is_local());\n-        assert_eq!(*local_trait_vc.await.unwrap(), *current_task_for_testing());\n-\n-        let non_local_vc = get_non_local_task_id();\n-        assert!(!non_local_vc.is_local());\n-        assert_ne!(*non_local_vc.await.unwrap(), *current_task_for_testing());\n-\n-        let non_local_trait_vc = Foo {}.cell().get_non_local_task_id();\n-        assert!(!non_local_trait_vc.is_local());\n-        assert_ne!(\n-            *non_local_trait_vc.await.unwrap(),\n-            *current_task_for_testing()\n-        );\n-\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[turbo_tasks::function(local)]\n-fn get_local_task_id() -> Vc<u32> {\n-    Vc::cell(*current_task_for_testing())\n-}\n-\n-#[turbo_tasks::function]\n-fn get_non_local_task_id() -> Vc<u32> {\n-    Vc::cell(*current_task_for_testing())\n-}\n-\n-#[turbo_tasks::value_trait]\n-trait SomeTrait {\n-    #[turbo_tasks::function]\n-    fn get_local_task_id(self: Vc<Self>) -> Vc<u32>;\n-    #[turbo_tasks::function]\n-    fn get_non_local_task_id(self: Vc<Self>) -> Vc<u32>;\n-}\n-#[turbo_tasks::value(shared)]\n-struct Foo {}\n-\n-#[turbo_tasks::value_impl]\n-impl SomeTrait for Foo {\n-    #[turbo_tasks::function(local)]\n-    fn get_local_task_id(self: Vc<Self>) -> Vc<u32> {\n-        Vc::cell(*current_task_for_testing())\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn get_non_local_task_id(self: Vc<Self>) -> Vc<u32> {\n-        Vc::cell(*current_task_for_testing())\n-    }\n-}"
        },
        {
            "sha": "125ec9b8943649a5c31bd94b8c44391eb9dcc7a1",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/operation_vc.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 36,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Foperation_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Foperation_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Foperation_vc.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,36 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use anyhow::Result;\n-use turbo_tasks::{OperationVc, ResolvedVc, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[turbo_tasks::function(operation)]\n-fn bare_op_fn() -> Vc<i32> {\n-    Vc::cell(21)\n-}\n-\n-// operations can take `ResolvedVc`s too (anything that's a `NonLocalValue`).\n-#[turbo_tasks::function(operation)]\n-async fn multiply(value: OperationVc<i32>, coefficient: ResolvedVc<i32>) -> Result<Vc<i32>> {\n-    Ok(Vc::cell((*value.connect().await?) * (*coefficient.await?)))\n-}\n-\n-#[turbo_tasks::function]\n-fn use_operations() -> Vc<i32> {\n-    let twenty_one: OperationVc<i32> = bare_op_fn();\n-    let fourty_two: OperationVc<i32> = multiply(twenty_one, ResolvedVc::cell(2));\n-    fourty_two.connect()\n-}\n-\n-#[tokio::test]\n-async fn test_use_operations() -> Result<()> {\n-    run(&REGISTRATION, || async {\n-        assert_eq!(*use_operations().await?, 42);\n-        Ok(())\n-    })\n-    .await\n-}"
        },
        {
            "sha": "904843fad2a63282cbbc376753f32a8e2448f422",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/performance.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 340,
            "changes": 340,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fperformance.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fperformance.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fperformance.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,340 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use std::{future::Future, time::Duration};\n-\n-use anyhow::Result;\n-use turbo_tasks::{TransientInstance, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-const COUNT1: u32 = 100;\n-const COUNT2: u32 = 2000;\n-\n-async fn run_test<F, T>(\n-    f: impl Fn() -> F + Sync + Send + Clone + 'static,\n-    limit: Duration,\n-) -> anyhow::Result<()>\n-where\n-    F: Future<Output = anyhow::Result<T>> + Sync + Send + 'static,\n-{\n-    // The first call will actually execute everything.\n-    let start = std::time::Instant::now();\n-    f().await?;\n-    println!(\"Initial call took {:?}\", start.elapsed());\n-\n-    let mut warmup_calls = Vec::new();\n-\n-    for _ in 0..10 {\n-        let start = std::time::Instant::now();\n-        f().await?;\n-        let warmup_call = start.elapsed();\n-        println!(\"Subsequent call took {warmup_call:?}\");\n-        warmup_calls.push(warmup_call);\n-    }\n-\n-    // Susbsequent calls should be very fast.\n-    let start = std::time::Instant::now();\n-    for _ in 0..COUNT1 {\n-        f().await?;\n-    }\n-    let subsequent = start.elapsed();\n-    println!(\n-        \"First {} subsequent calls took {:?} ({:?} per call)\",\n-        COUNT1,\n-        subsequent,\n-        subsequent / COUNT1\n-    );\n-\n-    let start = std::time::Instant::now();\n-    for _ in 0..COUNT1 {\n-        f().await?;\n-    }\n-    let subsequent2 = start.elapsed();\n-    println!(\n-        \"Another {} subsequent calls took {:?} ({:?} per call)\",\n-        COUNT1,\n-        subsequent2,\n-        subsequent2 / COUNT1\n-    );\n-\n-    let start = std::time::Instant::now();\n-    for _ in 0..COUNT1 {\n-        f().await?;\n-    }\n-    let subsequent3 = start.elapsed();\n-    println!(\n-        \"Another {} subsequent calls took {:?} ({:?} per call)\",\n-        COUNT1,\n-        subsequent3,\n-        subsequent3 / COUNT1\n-    );\n-\n-    if subsequent2 * 2 > subsequent * 3 || subsequent3 * 2 > subsequent * 3 {\n-        // Performance regresses with more calls\n-        // Check if this fixes itself eventually\n-        for i in 0.. {\n-            let start = std::time::Instant::now();\n-            for _ in 0..COUNT1 {\n-                f().await?;\n-            }\n-            let subsequent4 = start.elapsed();\n-            println!(\n-                \"Another {} subsequent calls took {:?} ({:?} per call)\",\n-                COUNT1,\n-                subsequent4,\n-                subsequent4 / COUNT1\n-            );\n-            if subsequent4 * 2 < subsequent * 3 {\n-                break;\n-            }\n-            if i >= 20 {\n-                panic!(\"Performance regressed with more calls\");\n-            }\n-        }\n-    }\n-\n-    let start = std::time::Instant::now();\n-    f().await?;\n-    let final_call = start.elapsed();\n-    println!(\"Final call took {final_call:?}\");\n-\n-    let target = subsequent / COUNT1;\n-\n-    for (i, warmup_call) in warmup_calls.into_iter().enumerate() {\n-        assert!(\n-            warmup_call < target * 10,\n-            \"Warmup call {} should be less than {:?}\",\n-            i,\n-            target * 10\n-        );\n-    }\n-\n-    assert!(\n-        subsequent < limit * COUNT1,\n-        \"Each call should be less than {limit:?}\"\n-    );\n-\n-    assert!(\n-        subsequent2 < limit * COUNT1,\n-        \"Each call should be less than {limit:?}\"\n-    );\n-\n-    assert!(\n-        subsequent3 < limit * COUNT1,\n-        \"Each call should be less than {limit:?}\"\n-    );\n-\n-    anyhow::Ok(())\n-}\n-\n-fn check_skip() -> bool {\n-    if matches!(\n-        std::env::var(\"TURBOPACK_TEST_PERFORMANCE\").ok().as_deref(),\n-        None | Some(\"\") | Some(\"no\") | Some(\"false\")\n-    ) {\n-        println!(\"Skipping test, pass `TURBOPACK_TEST_PERFORMANCE=yes` to run it\");\n-        return true;\n-    }\n-\n-    false\n-}\n-\n-#[tokio::test]\n-async fn many_calls_to_many_children() {\n-    if check_skip() {\n-        return;\n-    }\n-    run(&REGISTRATION, || {\n-        run_test(\n-            || calls_many_children(TransientInstance::new(()), None).strongly_consistent(),\n-            Duration::from_micros(100),\n-        )\n-    })\n-    .await\n-    .unwrap();\n-}\n-\n-#[tokio::test]\n-async fn many_calls_to_uncached_many_children() {\n-    if check_skip() {\n-        return;\n-    }\n-    run(&REGISTRATION, || {\n-        run_test(\n-            || {\n-                calls_many_children(TransientInstance::new(()), Some(TransientInstance::new(())))\n-                    .strongly_consistent()\n-            },\n-            Duration::from_micros(100) * COUNT2,\n-        )\n-    })\n-    .await\n-    .unwrap();\n-}\n-\n-fn run_big_graph_test(counts: Vec<u32>) -> impl Future<Output = Result<()>> + Send + 'static {\n-    println!(\n-        \"Graph {:?} = {} tasks\",\n-        counts,\n-        (1..=counts.len())\n-            .map(|i| counts.iter().take(i).product::<u32>())\n-            .sum::<u32>()\n-    );\n-    run_test(\n-        move || calls_big_graph(counts.clone(), TransientInstance::new(())).strongly_consistent(),\n-        Duration::from_micros(100),\n-    )\n-}\n-\n-#[tokio::test]\n-async fn many_calls_to_big_graph_1() {\n-    if check_skip() {\n-        return;\n-    }\n-    run(&REGISTRATION, || run_big_graph_test(vec![5, 8, 10, 15, 20]))\n-        .await\n-        .unwrap();\n-}\n-\n-#[tokio::test]\n-async fn many_calls_to_big_graph_2() {\n-    if check_skip() {\n-        return;\n-    }\n-    run(&REGISTRATION, || {\n-        run_big_graph_test(vec![2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n-    })\n-    .await\n-    .unwrap();\n-}\n-\n-#[tokio::test]\n-async fn many_calls_to_big_graph_3() {\n-    if check_skip() {\n-        return;\n-    }\n-    run(&REGISTRATION, || run_big_graph_test(vec![1000, 3, 3, 3, 3]))\n-        .await\n-        .unwrap();\n-}\n-\n-#[tokio::test]\n-async fn many_calls_to_big_graph_4() {\n-    if check_skip() {\n-        return;\n-    }\n-    run(&REGISTRATION, || run_big_graph_test(vec![3, 3, 3, 3, 1000]))\n-        .await\n-        .unwrap();\n-}\n-\n-#[tokio::test]\n-async fn many_calls_to_big_graph_5() {\n-    if check_skip() {\n-        return;\n-    }\n-    run(&REGISTRATION, || {\n-        run_big_graph_test(vec![10, 10, 10, 10, 10])\n-    })\n-    .await\n-    .unwrap();\n-}\n-\n-#[tokio::test]\n-async fn many_calls_to_big_graph_6() {\n-    if check_skip() {\n-        return;\n-    }\n-    run(&REGISTRATION, || {\n-        run_big_graph_test(vec![2, 2, 2, 1000, 2, 2, 2])\n-    })\n-    .await\n-    .unwrap();\n-}\n-\n-#[tokio::test]\n-async fn many_calls_to_big_graph_7() {\n-    if check_skip() {\n-        return;\n-    }\n-    run(&REGISTRATION, || {\n-        run_big_graph_test(vec![\n-            1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 3, 2, 1, 1, 1, 1, 5, 1, 1, 1, 200, 2, 1,\n-            1, 1, 1, 1, 1, 1, 1, 1,\n-        ])\n-    })\n-    .await\n-    .unwrap();\n-}\n-\n-#[tokio::test]\n-async fn many_calls_to_big_graph_8() {\n-    if check_skip() {\n-        return;\n-    }\n-    run(&REGISTRATION, || {\n-        run_big_graph_test(vec![200, 2, 2, 2, 2, 200])\n-    })\n-    .await\n-    .unwrap();\n-}\n-\n-#[tokio::test]\n-async fn many_calls_to_big_graph_9() {\n-    if check_skip() {\n-        return;\n-    }\n-    run(&REGISTRATION, || {\n-        run_big_graph_test(vec![10000, 1, 1, 2, 1, 1, 2, 2, 1, 1, 1, 1])\n-    })\n-    .await\n-    .unwrap();\n-}\n-\n-#[turbo_tasks::value]\n-struct Value {\n-    value: u32,\n-}\n-\n-#[turbo_tasks::function]\n-fn calls_many_children(i: TransientInstance<()>, j: Option<TransientInstance<()>>) -> Vc<()> {\n-    let _ = i;\n-    let _ = many_children(j);\n-    Vc::cell(())\n-}\n-\n-#[turbo_tasks::function]\n-fn many_children(_j: Option<TransientInstance<()>>) -> Vc<()> {\n-    for i in 0..COUNT2 {\n-        let _ = many_children_inner(i);\n-    }\n-    Vc::cell(())\n-}\n-\n-#[turbo_tasks::function]\n-fn many_children_inner(_i: u32) -> Vc<()> {\n-    Vc::cell(())\n-}\n-\n-#[turbo_tasks::function]\n-fn calls_big_graph(mut counts: Vec<u32>, i: TransientInstance<()>) -> Vc<()> {\n-    let _ = i;\n-    counts.reverse();\n-    let _ = big_graph(counts, vec![]);\n-    Vc::cell(())\n-}\n-\n-#[turbo_tasks::function]\n-fn big_graph(mut counts: Vec<u32>, keys: Vec<u32>) -> Vc<()> {\n-    let Some(count) = counts.pop() else {\n-        return Vc::cell(());\n-    };\n-    for i in 0..count {\n-        let new_keys = keys.iter().copied().chain(std::iter::once(i)).collect();\n-        let _ = big_graph(counts.clone(), new_keys);\n-    }\n-    Vc::cell(())\n-}"
        },
        {
            "sha": "eb1c537c9714eb70ad03929473f862ec51275344",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/random_change.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 71,
            "changes": 71,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frandom_change.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frandom_change.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frandom_change.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,71 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use anyhow::{Result, bail};\n-use rand::Rng;\n-use turbo_tasks::{State, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn random_change() {\n-    run(&REGISTRATION, || async {\n-        let state = make_state();\n-        let value = rand::rng().random_range(0..100);\n-        state.await?.state.set(value);\n-\n-        let result = func(state, 0).await?;\n-        assert_eq!(result.value, value);\n-\n-        let result = func2(state).await?;\n-        assert_eq!(result.value, value);\n-\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::value]\n-#[derive(Clone, Debug)]\n-struct Value {\n-    value: i32,\n-}\n-\n-#[turbo_tasks::value]\n-#[derive(Debug)]\n-struct ValueContainer {\n-    state: State<i32>,\n-}\n-\n-#[turbo_tasks::function]\n-fn make_state() -> Vc<ValueContainer> {\n-    ValueContainer {\n-        state: State::new(0),\n-    }\n-    .cell()\n-}\n-\n-#[turbo_tasks::function(invalidator)]\n-async fn func2(input: Vc<ValueContainer>) -> Result<Vc<Value>> {\n-    let state = input.await?;\n-    let value = state.state.get();\n-    println!(\"func2 {}\", *value);\n-    Ok(func(input, -*value))\n-}\n-\n-#[turbo_tasks::function(invalidator)]\n-async fn func(input: Vc<ValueContainer>, nesting: i32) -> Result<Vc<Value>> {\n-    let state = input.await?;\n-    let value = state.state.get();\n-    if nesting < *value {\n-        return Ok(func(input, nesting + 1));\n-    }\n-    if nesting == *value {\n-        println!(\"func {nesting}\");\n-        return Ok(Value { value: *value }.cell());\n-    }\n-    bail!(\"func no longer valid {}\", nesting)\n-}"
        },
        {
            "sha": "fae432e519612ad5cdf4757601afaf9f2b062c15",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/read_ref_cell.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 87,
            "changes": 87,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fread_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fread_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fread_ref_cell.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,87 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // clippy bug causes false positive\n-\n-use std::sync::Mutex;\n-\n-use anyhow::Result;\n-use turbo_tasks::{Invalidator, ReadRef, Vc, get_invalidator};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn read_ref() {\n-    run(&REGISTRATION, || async {\n-        let counter = Counter::cell(Counter {\n-            value: Mutex::new((0, None)),\n-        });\n-\n-        let counter_value = counter.get_value();\n-\n-        assert_eq!(*counter.get_value().strongly_consistent().await?, 0);\n-        assert_eq!(*counter_value.strongly_consistent().await?, 0);\n-\n-        counter.await?.incr();\n-\n-        assert_eq!(*counter.get_value().strongly_consistent().await?, 1);\n-        assert_eq!(*counter_value.strongly_consistent().await?, 1);\n-\n-        // `ref_counter` will still point to the same `counter` instance as `counter`.\n-        let ref_counter = ReadRef::cell(counter.await?);\n-        let ref_counter_value = ref_counter.get_value();\n-\n-        // However, `local_counter_value` will point to the value of `counter_value`\n-        // at the time it was turned into a trait reference (just like a `ReadRef`\n-        // would).\n-        let local_counter_value = ReadRef::cell(counter_value.await?).get_value();\n-\n-        counter.await?.incr();\n-\n-        assert_eq!(*counter.get_value().strongly_consistent().await?, 2);\n-        assert_eq!(*counter_value.strongly_consistent().await?, 2);\n-        assert_eq!(*ref_counter_value.strongly_consistent().await?, 2);\n-        assert_eq!(*local_counter_value.strongly_consistent().await?, 1);\n-\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-struct CounterValue(usize);\n-\n-#[turbo_tasks::value(serialization = \"none\", cell = \"new\", eq = \"manual\")]\n-struct Counter {\n-    #[turbo_tasks(debug_ignore, trace_ignore)]\n-    value: Mutex<(usize, Option<Invalidator>)>,\n-}\n-\n-impl Counter {\n-    fn incr(&self) {\n-        let mut lock = self.value.lock().unwrap();\n-        lock.0 += 1;\n-        if let Some(i) = lock.1.take() {\n-            i.invalidate();\n-        }\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl Counter {\n-    #[turbo_tasks::function(invalidator)]\n-    fn get_value(&self) -> Result<Vc<CounterValue>> {\n-        let mut lock = self.value.lock().unwrap();\n-        lock.1 = Some(get_invalidator());\n-        Ok(Vc::cell(lock.0))\n-    }\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl CounterValue {\n-    #[turbo_tasks::function]\n-    fn get_value(self: Vc<Self>) -> Vc<Self> {\n-        self\n-    }\n-}"
        },
        {
            "sha": "d708707ff78462a55c2772c7266126a5ac8e5bb1",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/recompute.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 137,
            "changes": 137,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frecompute.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frecompute.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frecompute.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,137 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use anyhow::Result;\n-use turbo_tasks::{ResolvedVc, State, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn recompute() {\n-    run(&REGISTRATION, || async {\n-        let input = ChangingInput {\n-            state: State::new(1),\n-        }\n-        .cell();\n-        let input2 = ChangingInput {\n-            state: State::new(10),\n-        }\n-        .cell();\n-        let output = compute(input, input2);\n-        let read = output.await?;\n-        assert_eq!(read.state_value, 1);\n-        assert_eq!(read.state_value2, 10);\n-        let random_value = read.random_value;\n-\n-        println!(\"changing input\");\n-        input.await?.state.set(2);\n-        let read = output.strongly_consistent().await?;\n-        assert_eq!(read.state_value, 2);\n-        assert_ne!(read.random_value, random_value);\n-        let random_value = read.random_value;\n-\n-        println!(\"changing input2\");\n-        input2.await?.state.set(20);\n-        let read = output.strongly_consistent().await?;\n-        assert_eq!(read.state_value2, 20);\n-        assert_ne!(read.random_value, random_value);\n-        let random_value = read.random_value;\n-\n-        println!(\"changing input\");\n-        input.await?.state.set(5);\n-        let read = output.strongly_consistent().await?;\n-        assert_eq!(read.state_value, 5);\n-        assert_eq!(read.state_value2, 42);\n-        assert_ne!(read.random_value, random_value);\n-        let random_value = read.random_value;\n-\n-        println!(\"changing input2\");\n-        input2.await?.state.set(30);\n-        let read = output.strongly_consistent().await?;\n-        assert_eq!(read.random_value, random_value);\n-\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[tokio::test]\n-async fn immutable_analysis() {\n-    run(&REGISTRATION, || async {\n-        let input = ChangingInput {\n-            state: State::new(1),\n-        }\n-        .resolved_cell();\n-\n-        // Verify\n-\n-        let vc_holder = VcHolder { vc: input }.resolved_cell();\n-        let read = vc_holder.compute().strongly_consistent().await?;\n-        assert_eq!(read.state_value, 1);\n-        assert_eq!(read.state_value2, 1);\n-        let random_value = read.random_value;\n-\n-        println!(\"changing input1\");\n-        input.await?.state.set(30);\n-        let read = vc_holder.compute().strongly_consistent().await?;\n-        assert_eq!(read.state_value, 30);\n-        assert_eq!(read.state_value2, 42);\n-        assert_ne!(read.random_value, random_value);\n-\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::value]\n-struct ChangingInput {\n-    state: State<u32>,\n-}\n-\n-#[turbo_tasks::value]\n-struct VcHolder {\n-    vc: ResolvedVc<ChangingInput>,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl VcHolder {\n-    #[turbo_tasks::function]\n-    fn compute(&self) -> Vc<Output> {\n-        compute(*self.vc, *self.vc)\n-    }\n-}\n-\n-#[turbo_tasks::value]\n-struct Output {\n-    state_value: u32,\n-    state_value2: u32,\n-    random_value: u32,\n-}\n-\n-#[turbo_tasks::function(invalidator)]\n-async fn compute(input: Vc<ChangingInput>, input2: Vc<ChangingInput>) -> Result<Vc<Output>> {\n-    let state_value = *input.await?.state.get();\n-    let state_value2 = if state_value < 5 {\n-        *compute2(input2).await?\n-    } else {\n-        42\n-    };\n-    let random_value = rand::random();\n-\n-    Ok(Output {\n-        state_value,\n-        state_value2,\n-        random_value,\n-    }\n-    .cell())\n-}\n-\n-#[turbo_tasks::function(invalidator)]\n-async fn compute2(input: Vc<ChangingInput>) -> Result<Vc<u32>> {\n-    let state_value = *input.await?.state.get();\n-    Ok(Vc::cell(state_value))\n-}"
        },
        {
            "sha": "89e2bca2d9c0ad997a6ae4c631ed93d10a52b910",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/recompute_collectibles.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 125,
            "changes": 125,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frecompute_collectibles.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frecompute_collectibles.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Frecompute_collectibles.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,125 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // clippy bug causes false positive\n-\n-use anyhow::{Result, bail};\n-use turbo_rcstr::RcStr;\n-use turbo_tasks::{CollectiblesSource, ResolvedVc, State, ValueToString, Vc, emit};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn recompute() {\n-    run(&REGISTRATION, || async {\n-        let input = ChangingInput::new(1).resolve().await?;\n-        let input2 = ChangingInput::new(2).resolve().await?;\n-        input.await?.state.set(1);\n-        input2.await?.state.set(1000);\n-        let output = compute(input, input2, 1);\n-        let read = output.strongly_consistent().await?;\n-        assert_eq!(read.value, 42);\n-        assert_eq!(read.collectible, \"1\");\n-\n-        for i in 2..100 {\n-            input.await?.state.set(i);\n-            let read = output.strongly_consistent().await?;\n-            assert_eq!(read.value, 42);\n-            assert_eq!(read.collectible, i.to_string());\n-        }\n-\n-        for i in 0..100 {\n-            input2.await?.state.set(i);\n-            let read = output.strongly_consistent().await?;\n-            assert_eq!(read.value, 42);\n-            assert_eq!(read.collectible, \"99\");\n-        }\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::value]\n-struct ChangingInput {\n-    state: State<u32>,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ChangingInput {\n-    #[turbo_tasks::function]\n-    fn new(key: u32) -> Vc<Self> {\n-        let _ = key;\n-        Self {\n-            state: State::new(1),\n-        }\n-        .cell()\n-    }\n-}\n-\n-#[turbo_tasks::value]\n-struct Output {\n-    value: u32,\n-    collectible: String,\n-}\n-\n-#[turbo_tasks::value]\n-struct Collectible {\n-    value: u32,\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl ValueToString for Collectible {\n-    #[turbo_tasks::function]\n-    fn to_string(&self) -> Vc<RcStr> {\n-        Vc::cell(self.value.to_string().into())\n-    }\n-}\n-\n-#[turbo_tasks::function(operation, invalidator)]\n-async fn inner_compute(\n-    input: ResolvedVc<ChangingInput>,\n-    input2: ResolvedVc<ChangingInput>,\n-) -> Result<Vc<u32>> {\n-    println!(\"inner_compute()\");\n-    Ok(inner_compute2(*input, *input2.await?.state.get()))\n-}\n-\n-#[turbo_tasks::function(invalidator)]\n-async fn inner_compute2(input: Vc<ChangingInput>, innerness: u32) -> Result<Vc<u32>> {\n-    println!(\"inner_compute2({innerness})\");\n-    if innerness > 0 {\n-        return Ok(inner_compute2(input, innerness - 1));\n-    }\n-    let value = *input.await?.state.get();\n-    let collectible: ResolvedVc<Box<dyn ValueToString>> =\n-        ResolvedVc::upcast(Collectible { value }.resolved_cell());\n-    emit(collectible);\n-\n-    Ok(Vc::cell(42))\n-}\n-\n-#[turbo_tasks::function]\n-async fn compute(\n-    input: ResolvedVc<ChangingInput>,\n-    input2: ResolvedVc<ChangingInput>,\n-    innerness: u32,\n-) -> Result<Vc<Output>> {\n-    println!(\"compute({innerness})\");\n-    if innerness > 0 {\n-        return Ok(compute(*input, *input2, innerness - 1));\n-    }\n-    let operation = inner_compute(input, input2);\n-    let value = *operation.connect().await?;\n-    let collectibles = operation.peek_collectibles::<Box<dyn ValueToString>>();\n-    if collectibles.len() != 1 {\n-        bail!(\"expected 1 collectible, found {}\", collectibles.len());\n-    }\n-    let first = *collectibles.iter().next().unwrap();\n-    let collectible = first.to_string().await?;\n-    Ok(Output {\n-        value,\n-        collectible: collectible.to_string(),\n-    }\n-    .cell())\n-}"
        },
        {
            "sha": "ad4692bf6f6ea0361711f3c40e611f281318a3b7",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/resolved_vc.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 111,
            "changes": 111,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fresolved_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fresolved_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fresolved_vc.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,111 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use anyhow::Result;\n-use turbo_tasks::{ReadRef, ResolvedVc, Vc};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[turbo_tasks::value]\n-struct Wrapper(u32);\n-\n-#[turbo_tasks::function]\n-fn returns_int(value: u32) -> Vc<u32> {\n-    Vc::cell(value)\n-}\n-\n-#[turbo_tasks::function]\n-fn assert_resolved(input: ResolvedVc<u32>) {\n-    // double-check that this `ResolvedVc` is *actually* resolved\n-    let input_vc: Vc<u32> = *input;\n-    assert!(input_vc.is_resolved());\n-}\n-\n-#[tokio::test]\n-async fn test_conversion() -> Result<()> {\n-    run(&REGISTRATION, || async {\n-        let unresolved: Vc<u32> = Vc::cell(42);\n-        let resolved: ResolvedVc<u32> = unresolved.to_resolved().await?;\n-        let _: Vc<u32> = *resolved;\n-        let _: ReadRef<u32> = resolved.await?;\n-        let _: ReadRef<u32> = (&resolved).await?;\n-        let _: u32 = *resolved.await?;\n-        let _: u32 = *(&resolved).await?;\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[tokio::test]\n-async fn test_cell_construction() -> Result<()> {\n-    run(&REGISTRATION, || async {\n-        let a: ResolvedVc<u32> = ResolvedVc::cell(42);\n-        assert_eq!(*a.await?, 42);\n-        let b: ResolvedVc<Wrapper> = Wrapper(42).resolved_cell();\n-        assert_eq!(b.await?.0, 42);\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[tokio::test]\n-async fn test_resolved_vc_as_arg() -> Result<()> {\n-    run(&REGISTRATION, || async {\n-        let unresolved: Vc<u32> = returns_int(42);\n-        assert!(!unresolved.is_resolved());\n-        // calling a function should cause it's arguments to get resolved automatically\n-        assert_resolved(unresolved).await?;\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[tokio::test]\n-async fn test_into_future() -> Result<()> {\n-    run(&REGISTRATION, || async {\n-        let mut resolved = ResolvedVc::cell(42);\n-        let _: ReadRef<u32> = resolved.await?;\n-        let _: ReadRef<u32> = (&resolved).await?;\n-        let _: ReadRef<u32> = (&mut resolved).await?;\n-        let mut unresolved = Vc::cell(42);\n-        let _: ReadRef<u32> = unresolved.await?;\n-        let _: ReadRef<u32> = (&unresolved).await?;\n-        let _: ReadRef<u32> = (&mut unresolved).await?;\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[tokio::test]\n-async fn test_sidecast() -> Result<()> {\n-    run(&REGISTRATION, || async {\n-        let concrete_value = ImplementsAandB.resolved_cell();\n-        let as_a = ResolvedVc::upcast::<Box<dyn TraitA>>(concrete_value);\n-        let as_b = ResolvedVc::try_sidecast::<Box<dyn TraitB>>(as_a);\n-        assert!(as_b.is_some());\n-        let as_c = ResolvedVc::try_sidecast::<Box<dyn TraitC>>(as_a);\n-        assert!(as_c.is_none());\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[turbo_tasks::value_trait]\n-trait TraitA {}\n-\n-#[turbo_tasks::value_trait]\n-trait TraitB {}\n-\n-#[turbo_tasks::value_trait]\n-trait TraitC {}\n-\n-#[turbo_tasks::value]\n-struct ImplementsAandB;\n-\n-#[turbo_tasks::value_impl]\n-impl TraitA for ImplementsAandB {}\n-\n-#[turbo_tasks::value_impl]\n-impl TraitB for ImplementsAandB {}"
        },
        {
            "sha": "524a78950acf227d74e2d0dea6a53d9335b95c77",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/shrink_to_fit.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 24,
            "changes": 24,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fshrink_to_fit.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fshrink_to_fit.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Fshrink_to_fit.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,24 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use anyhow::Result;\n-use turbo_tasks::Vc;\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[turbo_tasks::value(transparent)]\n-struct Wrapper(Vec<u32>);\n-\n-#[tokio::test]\n-async fn test_shrink_to_fit() -> Result<()> {\n-    run(&REGISTRATION, || async {\n-        // `Vec::shrink_to_fit` is implicitly called when a cell is constructed.\n-        let a: Vc<Wrapper> = Vc::cell(Vec::with_capacity(100));\n-        assert_eq!(a.await?.capacity(), 0);\n-\n-        Ok(())\n-    })\n-    .await\n-}"
        },
        {
            "sha": "8a391ace095aafe1eda2b1397e811106b53dfca2",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/task_statistics.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 274,
            "changes": 274,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Ftask_statistics.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Ftask_statistics.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Ftask_statistics.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,274 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use std::future::IntoFuture;\n-\n-use anyhow::Result;\n-use once_cell::sync::Lazy;\n-use regex::Regex;\n-use serde_json::json;\n-use turbo_tasks::Vc;\n-use turbo_tasks_testing::{Registration, register, run_without_cache_check};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn test_simple_task() -> Result<()> {\n-    run_without_cache_check(&REGISTRATION, async move {\n-        enable_stats();\n-        for i in 0..10 {\n-            double(i).await.unwrap();\n-            // use cached results\n-            double(i).await.unwrap();\n-        }\n-        for i in 0..5 {\n-            double(i).await.unwrap();\n-        }\n-        assert_eq!(\n-            stats_json(),\n-            json!({\n-                \"double\": {\n-                    \"cache_miss\": 10,\n-                    \"cache_hit\": 15,\n-                },\n-            })\n-        );\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[tokio::test]\n-async fn test_await_same_vc_multiple_times() -> Result<()> {\n-    run_without_cache_check(&REGISTRATION, async move {\n-        enable_stats();\n-        let dvc = double(0);\n-        // this is awaited multiple times, but only resolved once\n-        tokio::try_join!(dvc.into_future(), dvc.into_future()).unwrap();\n-        dvc.await.unwrap();\n-        assert_eq!(\n-            stats_json(),\n-            json!({\n-                \"double\": {\n-                    \"cache_miss\": 1,\n-                    \"cache_hit\": 0,\n-                },\n-            })\n-        );\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[tokio::test]\n-async fn test_vc_receiving_task() -> Result<()> {\n-    run_without_cache_check(&REGISTRATION, async move {\n-        enable_stats();\n-        for i in 0..10 {\n-            let dvc = double(i);\n-            double_vc(dvc).await.unwrap();\n-            // use cached results\n-            double_vc(dvc).await.unwrap();\n-        }\n-        for i in 0..5 {\n-            let dvc = double(i);\n-            double_vc(dvc).await.unwrap();\n-        }\n-        assert_eq!(\n-            stats_json(),\n-            json!({\n-                \"double\": {\n-                    \"cache_miss\": 10,\n-                    \"cache_hit\": 5,\n-                },\n-                \"double_vc\": {\n-                    \"cache_miss\": 10,\n-                    \"cache_hit\": 15,\n-                },\n-            })\n-        );\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[tokio::test]\n-async fn test_trait_methods() -> Result<()> {\n-    run_without_cache_check(&REGISTRATION, async move {\n-        enable_stats();\n-        for i in 0..10 {\n-            let wvc = wrap(i);\n-            tokio::try_join!(wvc.double().into_future(), wvc.double().into_future()).unwrap();\n-            tokio::try_join!(wvc.double_vc().into_future(), wvc.double_vc().into_future()).unwrap();\n-        }\n-        // use cached results\n-        for i in 0..5 {\n-            let wvc = wrap(i);\n-            wvc.double().await.unwrap();\n-            wvc.double_vc().await.unwrap();\n-        }\n-        assert_eq!(\n-            stats_json(),\n-            json!({\n-                \"wrap\": {\n-                    \"cache_miss\": 10,\n-                    \"cache_hit\": 5,\n-                },\n-                \"WrappedU64::Doublable::double\": {\n-                    \"cache_miss\": 10,\n-                    \"cache_hit\": 15,\n-                },\n-                \"WrappedU64::Doublable::double_vc\": {\n-                    \"cache_miss\": 10,\n-                    \"cache_hit\": 15,\n-                },\n-            })\n-        );\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[tokio::test]\n-async fn test_dyn_trait_methods() -> Result<()> {\n-    run_without_cache_check(&REGISTRATION, async move {\n-        enable_stats();\n-        for i in 0..10 {\n-            let wvc: Vc<Box<dyn Doublable>> = Vc::upcast(wrap(i));\n-            let _ = tokio::try_join!(wvc.double().resolve(), wvc.double().resolve()).unwrap();\n-            let _ = tokio::try_join!(wvc.double_vc().resolve(), wvc.double_vc().resolve()).unwrap();\n-        }\n-        // use cached results\n-        for i in 0..5 {\n-            let wvc: Vc<Box<dyn Doublable>> = Vc::upcast(wrap(i));\n-            let _ = wvc.double().resolve().await.unwrap();\n-            let _ = wvc.double_vc().resolve().await.unwrap();\n-        }\n-        // use cached results without dynamic dispatch\n-        for i in 0..2 {\n-            let wvc = wrap(i);\n-            let _ = wvc.double().await.unwrap();\n-            let _ = wvc.double_vc().await.unwrap();\n-        }\n-        assert_eq!(\n-            stats_json(),\n-            json!({\n-                \"wrap\": {\n-                    \"cache_miss\": 10,\n-                    \"cache_hit\": 7,\n-                },\n-                \"WrappedU64::Doublable::double\": {\n-                    \"cache_miss\": 10,\n-                    \"cache_hit\": 17,\n-                },\n-                \"WrappedU64::Doublable::double_vc\": {\n-                    \"cache_miss\": 10,\n-                    \"cache_hit\": 17,\n-                },\n-            })\n-        );\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-// creates Vcs, but doesn't ever execute them\n-#[tokio::test]\n-async fn test_no_execution() -> Result<()> {\n-    run_without_cache_check(&REGISTRATION, async move {\n-        enable_stats();\n-        // don't await this!\n-        let _ = wrap_vc(double_vc(double(123))).double().double_vc();\n-        assert_eq!(\n-            stats_json(),\n-            json!({\n-                \"double\": {\n-                    \"cache_miss\": 1,\n-                    \"cache_hit\": 0,\n-                },\n-            })\n-        );\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-// Internally, this function uses `PersistentTaskType`.\n-#[turbo_tasks::function]\n-fn double(val: u64) -> Vc<u64> {\n-    Vc::cell(val * 2)\n-}\n-\n-// Internally, this function uses `LocalTaskType::ResolveNative`.\n-#[turbo_tasks::function]\n-async fn double_vc(val: Vc<u64>) -> Result<Vc<u64>> {\n-    let val = *val.await?;\n-    Ok(Vc::cell(val * 2))\n-}\n-\n-#[turbo_tasks::value]\n-struct WrappedU64(u64);\n-\n-#[turbo_tasks::function]\n-fn wrap(val: u64) -> Vc<WrappedU64> {\n-    WrappedU64(val).cell()\n-}\n-\n-#[turbo_tasks::function]\n-async fn wrap_vc(val: Vc<u64>) -> Result<Vc<WrappedU64>> {\n-    Ok(WrappedU64(*val.await?).cell())\n-}\n-\n-#[turbo_tasks::value_trait]\n-pub trait Doublable {\n-    #[turbo_tasks::function]\n-    fn double(&self) -> Vc<Self>;\n-    #[turbo_tasks::function]\n-    fn double_vc(self: Vc<Self>) -> Vc<Self>;\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl Doublable for WrappedU64 {\n-    #[turbo_tasks::function]\n-    fn double(&self) -> Vc<Self> {\n-        WrappedU64(self.0 * 2).cell()\n-    }\n-\n-    #[turbo_tasks::function]\n-    fn double_vc(&self) -> Result<Vc<Self>> {\n-        let val = self.0;\n-        Ok(WrappedU64(val * 2).cell())\n-    }\n-}\n-\n-#[turbo_tasks::function]\n-fn fail(val: u64) -> Result<Vc<()>> {\n-    anyhow::bail!(\"failed using {val}\");\n-}\n-\n-fn enable_stats() {\n-    let tt = turbo_tasks::turbo_tasks();\n-    tt.task_statistics().enable();\n-}\n-\n-fn stats_json() -> serde_json::Value {\n-    let tt = turbo_tasks::turbo_tasks();\n-    remove_crate_and_hashes(serde_json::to_value(tt.task_statistics().get()).unwrap())\n-}\n-\n-// Global task identifiers can contain a hash of the crate and dependencies.\n-// Remove that so that we can compare against a stable value in tests.\n-fn remove_crate_and_hashes(mut json: serde_json::Value) -> serde_json::Value {\n-    static HASH_RE: Lazy<Regex> = Lazy::new(|| Regex::new(\"^[^:@]+@[^:]+:+\").unwrap());\n-    match &mut json {\n-        serde_json::Value::Object(map) => {\n-            let old_map = std::mem::take(map);\n-            for (k, v) in old_map {\n-                map.insert(HASH_RE.replace(&k, \"\").into_owned(), v);\n-            }\n-        }\n-        _ => unreachable!(\"expected object\"),\n-    };\n-    json\n-}"
        },
        {
            "sha": "03b18261f4b20f698dbfd58fb7ebf5de8bd3f4c6",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/trait_ref_cell.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 114,
            "changes": 114,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Ftrait_ref_cell.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Ftrait_ref_cell.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Ftrait_ref_cell.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,114 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-#![allow(clippy::needless_return)] // tokio macro-generated code doesn't respect this\n-\n-use std::sync::Mutex;\n-\n-use anyhow::Result;\n-use turbo_tasks::{IntoTraitRef, Invalidator, TraitRef, Vc, get_invalidator};\n-use turbo_tasks_testing::{Registration, register, run};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn trait_ref() {\n-    run(&REGISTRATION, || async {\n-        let counter = Counter::cell(Counter {\n-            value: Mutex::new((0, None)),\n-        });\n-\n-        let counter_value = counter.get_value();\n-\n-        assert_eq!(*counter.get_value().strongly_consistent().await?, 0);\n-        assert_eq!(*counter_value.strongly_consistent().await?, 0);\n-\n-        counter.await?.incr();\n-\n-        assert_eq!(*counter.get_value().strongly_consistent().await?, 1);\n-        assert_eq!(*counter_value.strongly_consistent().await?, 1);\n-\n-        // `ref_counter` will still point to the same `counter` instance as `counter`.\n-        let trait_ref_counter = Vc::upcast::<Box<dyn CounterTrait>>(counter)\n-            .into_trait_ref()\n-            .await?;\n-        let ref_counter = TraitRef::cell(trait_ref_counter.clone());\n-        let ref_counter_value = ref_counter.get_value();\n-\n-        // However, `local_counter_value` will point to the value of `counter_value`\n-        // at the time it was turned into a trait reference (just like a `ReadRef`\n-        // would).\n-        let local_counter_value = TraitRef::cell(\n-            Vc::upcast::<Box<dyn CounterValueTrait>>(counter_value)\n-                .into_trait_ref()\n-                .await?,\n-        )\n-        .get_value();\n-\n-        counter.await?.incr();\n-        assert_eq!(trait_ref_counter.get_value_sync().0, 2);\n-        assert_eq!(*counter.get_value().strongly_consistent().await?, 2);\n-        assert_eq!(*counter_value.strongly_consistent().await?, 2);\n-        assert_eq!(*ref_counter_value.strongly_consistent().await?, 2);\n-        assert_eq!(*local_counter_value.strongly_consistent().await?, 1);\n-\n-        anyhow::Ok(())\n-    })\n-    .await\n-    .unwrap()\n-}\n-\n-#[turbo_tasks::value(transparent)]\n-#[derive(Copy, Clone)]\n-struct CounterValue(usize);\n-\n-#[turbo_tasks::value(serialization = \"none\", cell = \"new\", eq = \"manual\")]\n-struct Counter {\n-    #[turbo_tasks(debug_ignore, trace_ignore)]\n-    value: Mutex<(usize, Option<Invalidator>)>,\n-}\n-\n-impl Counter {\n-    fn incr(&self) {\n-        let mut lock = self.value.lock().unwrap();\n-        lock.0 += 1;\n-        if let Some(i) = lock.1.take() {\n-            i.invalidate();\n-        }\n-    }\n-}\n-\n-#[turbo_tasks::value_trait]\n-trait CounterTrait {\n-    #[turbo_tasks::function]\n-    fn get_value(&self) -> Vc<CounterValue>;\n-\n-    fn get_value_sync(&self) -> CounterValue;\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl CounterTrait for Counter {\n-    #[turbo_tasks::function(invalidator)]\n-    fn get_value(&self) -> Result<Vc<CounterValue>> {\n-        let mut lock = self.value.lock().unwrap();\n-        lock.1 = Some(get_invalidator());\n-        Ok(Vc::cell(lock.0))\n-    }\n-\n-    fn get_value_sync(&self) -> CounterValue {\n-        CounterValue(self.value.lock().unwrap().0)\n-    }\n-}\n-\n-#[turbo_tasks::value_trait]\n-trait CounterValueTrait {\n-    #[turbo_tasks::function]\n-    fn get_value(&self) -> Vc<CounterValue>;\n-}\n-\n-#[turbo_tasks::value_impl]\n-impl CounterValueTrait for CounterValue {\n-    #[turbo_tasks::function]\n-    fn get_value(self: Vc<Self>) -> Vc<Self> {\n-        self\n-    }\n-}"
        },
        {
            "sha": "7db072310c915df44ec3a30cdf789eb9cc89eb3b",
            "filename": "turbopack/crates/turbo-tasks-testing/tests/transient_vc.rs",
            "status": "removed",
            "additions": 0,
            "deletions": 55,
            "changes": 55,
            "blob_url": "https://github.com/vercel/next.js/blob/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Ftransient_vc.rs",
            "raw_url": "https://github.com/vercel/next.js/raw/0cfdf50b5ed3964f34b82328baf4bc8270332354/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Ftransient_vc.rs",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/turbopack%2Fcrates%2Fturbo-tasks-testing%2Ftests%2Ftransient_vc.rs?ref=0cfdf50b5ed3964f34b82328baf4bc8270332354",
            "patch": "@@ -1,55 +0,0 @@\n-#![feature(arbitrary_self_types)]\n-#![feature(arbitrary_self_types_pointers)]\n-\n-use anyhow::Result;\n-use turbo_tasks::{TaskInput, TransientValue, Vc};\n-use turbo_tasks_testing::{Registration, register, run_without_cache_check};\n-\n-static REGISTRATION: Registration = register!();\n-\n-#[tokio::test]\n-async fn test_transient_vc() -> Result<()> {\n-    run_without_cache_check(&REGISTRATION, async {\n-        test_transient_operation(TransientValue::new(123))\n-            .read_strongly_consistent()\n-            .await?;\n-        Ok(())\n-    })\n-    .await\n-}\n-\n-#[turbo_tasks::function(operation)]\n-async fn test_transient_operation(transient_arg: TransientValue<i32>) -> Result<()> {\n-    let called_with_transient = has_transient_arg(transient_arg);\n-    let called_with_persistent = has_persistent_arg(123);\n-\n-    assert!(called_with_transient.is_transient());\n-    assert!(!called_with_persistent.is_transient());\n-    assert!(has_vc_arg(called_with_transient).is_transient());\n-    assert!(!has_vc_arg(called_with_persistent).is_transient());\n-\n-    let called_with_transient_resolved = called_with_transient.to_resolved().await?;\n-    let called_with_persistent_resolved = called_with_persistent.to_resolved().await?;\n-\n-    assert!(called_with_transient_resolved.is_transient());\n-    assert!(!called_with_persistent_resolved.is_transient());\n-    assert!(has_vc_arg(*called_with_transient_resolved).is_transient());\n-    assert!(!has_vc_arg(*called_with_persistent_resolved).is_transient());\n-\n-    Ok(())\n-}\n-\n-#[turbo_tasks::function]\n-fn has_transient_arg(arg: TransientValue<i32>) -> Vc<i32> {\n-    Vc::cell(*arg)\n-}\n-\n-#[turbo_tasks::function]\n-fn has_persistent_arg(arg: i32) -> Vc<i32> {\n-    Vc::cell(arg)\n-}\n-\n-#[turbo_tasks::function]\n-async fn has_vc_arg(arg: Vc<i32>) -> Result<Vc<i32>> {\n-    Ok(Vc::cell(*arg.await?))\n-}"
        }
    ],
    "stats": {
        "total": 5691,
        "additions": 2835,
        "deletions": 2856
    }
}