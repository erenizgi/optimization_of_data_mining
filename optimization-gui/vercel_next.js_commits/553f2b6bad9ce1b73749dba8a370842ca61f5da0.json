{
    "author": "lubieowoce",
    "message": "[Cache Components] correctly label IO promises in devtools (#84928)\n\nUpdates to staged rendering (cacheComponents dev) to support \"suspended\nby\" in Suspense Devtools\n\n- promises for `cookies()` and other user-callable APIs are now created\nbefore we start the render. Each call to `cookies()` will return the\nsame promise (although currently it's wrapped in a fresh proxy). The\npromise is created via `new Promise`, triggered by a timeout (for the\nrelevant stage) and has `displayName`. This marks it as an IO operation.\nBy re-using the same promise, we make sure that all callsites that await\nit are considered to be suspended by the same IO operation.\n- promises for `params` and `searchParams` use a similar trick. All\ninstances of `params` and will be derived from one shared IO promise\n`sharedParamsParent`. When determining \"suspended by\", React will walk\nup the promise chain, find this parent, and use its `displayName`, which\nwe set to `\"params\"`. `searchParams` work analogously\n\n---------\n\nCo-authored-by: Josh Story <story@hey.com>",
    "sha": "553f2b6bad9ce1b73749dba8a370842ca61f5da0",
    "files": [
        {
            "sha": "80ce4617c418816a89ac3204736d20eb5aeb524e",
            "filename": "packages/next/errors.json",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Ferrors.json",
            "raw_url": "https://github.com/vercel/next.js/raw/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Ferrors.json",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Ferrors.json?ref=553f2b6bad9ce1b73749dba8a370842ca61f5da0",
            "patch": "@@ -887,5 +887,6 @@\n   \"886\": \"`cacheTag()` is only available with the `cacheComponents` config.\",\n   \"887\": \"`cacheLife()` is only available with the `cacheComponents` config.\",\n   \"888\": \"Unknown \\\\`cacheLife()\\\\` profile \\\"%s\\\" is not configured in next.config.js\\\\nmodule.exports = {\\n  cacheLife: {\\n    \\\"%s\\\": ...\\\\n  }\\n}\",\n-  \"889\": \"Unknown \\\\`cacheLife()\\\\` profile \\\"%s\\\" is not configured in next.config.js\\\\nmodule.exports = {\\n  cacheLife: {\\n      \\\"%s\\\": ...\\\\n    }\\n}\"\n+  \"889\": \"Unknown \\\\`cacheLife()\\\\` profile \\\"%s\\\" is not configured in next.config.js\\\\nmodule.exports = {\\n  cacheLife: {\\n      \\\"%s\\\": ...\\\\n    }\\n}\",\n+  \"890\": \"Received an underlying cookies object that does not match either `cookies` or `mutableCookies`\"\n }"
        },
        {
            "sha": "41a472e7796a5c29fd72bb48555629d2503aa3c9",
            "filename": "packages/next/src/server/app-render/app-render.tsx",
            "status": "modified",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/vercel/next.js/blob/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "raw_url": "https://github.com/vercel/next.js/raw/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fapp-render.tsx?ref=553f2b6bad9ce1b73749dba8a370842ca61f5da0",
            "patch": "@@ -2821,6 +2821,12 @@ async function renderWithRestartOnCacheMissInDev(\n   // so not having a resume data cache won't break any expectations in case we don't need to restart.\n   requestStore.renderResumeDataCache = null\n   requestStore.stagedRendering = initialStageController\n+  requestStore.asyncApiPromises = createAsyncApiPromisesInDev(\n+    initialStageController,\n+    requestStore.cookies,\n+    requestStore.mutableCookies,\n+    requestStore.headers\n+  )\n   requestStore.cacheSignal = cacheSignal\n \n   let debugChannel = setReactDebugChannel && createDebugChannel()\n@@ -2921,6 +2927,12 @@ async function renderWithRestartOnCacheMissInDev(\n   )\n   requestStore.stagedRendering = finalStageController\n   requestStore.cacheSignal = null\n+  requestStore.asyncApiPromises = createAsyncApiPromisesInDev(\n+    finalStageController,\n+    requestStore.cookies,\n+    requestStore.mutableCookies,\n+    requestStore.headers\n+  )\n \n   // The initial render already wrote to its debug channel.\n   // We're not using it, so we need to create a new one.\n@@ -2962,6 +2974,48 @@ async function renderWithRestartOnCacheMissInDev(\n   }\n }\n \n+function createAsyncApiPromisesInDev(\n+  stagedRendering: StagedRenderingController,\n+  cookies: RequestStore['cookies'],\n+  mutableCookies: RequestStore['mutableCookies'],\n+  headers: RequestStore['headers']\n+): NonNullable<RequestStore['asyncApiPromises']> {\n+  return {\n+    // Runtime APIs\n+    cookies: stagedRendering.delayUntilStage(\n+      RenderStage.Runtime,\n+      'cookies',\n+      cookies\n+    ),\n+    mutableCookies: stagedRendering.delayUntilStage(\n+      RenderStage.Runtime,\n+      'cookies',\n+      mutableCookies as RequestStore['cookies']\n+    ),\n+    headers: stagedRendering.delayUntilStage(\n+      RenderStage.Runtime,\n+      'headers',\n+      headers\n+    ),\n+    // These are not used directly, but we chain other `params`/`searchParams` promises off of them.\n+    sharedParamsParent: stagedRendering.delayUntilStage(\n+      RenderStage.Runtime,\n+      'params',\n+      '<internal params>'\n+    ),\n+    sharedSearchParamsParent: stagedRendering.delayUntilStage(\n+      RenderStage.Runtime,\n+      'searchParams',\n+      '<internal searchParams>'\n+    ),\n+    connection: stagedRendering.delayUntilStage(\n+      RenderStage.Dynamic,\n+      'connection',\n+      undefined\n+    ),\n+  }\n+}\n+\n type DebugChannelPair = {\n   serverSide: DebugChannelServer\n   clientSide: DebugChannelClient"
        },
        {
            "sha": "e31d13fa95bea022351eb3feb2dcb9657dc2de63",
            "filename": "packages/next/src/server/app-render/staged-rendering.ts",
            "status": "modified",
            "additions": 43,
            "deletions": 13,
            "changes": 56,
            "blob_url": "https://github.com/vercel/next.js/blob/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fstaged-rendering.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fstaged-rendering.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fstaged-rendering.ts?ref=553f2b6bad9ce1b73749dba8a370842ca61f5da0",
            "patch": "@@ -52,30 +52,37 @@ export class StagedRenderingController {\n     }\n   }\n \n-  delayUntilStage<T>(stage: NonStaticRenderStage, resolvedValue: T) {\n-    let stagePromise: Promise<void>\n+  private getStagePromise(stage: NonStaticRenderStage): Promise<void> {\n     switch (stage) {\n       case RenderStage.Runtime: {\n-        stagePromise = this.runtimeStagePromise.promise\n-        break\n+        return this.runtimeStagePromise.promise\n       }\n       case RenderStage.Dynamic: {\n-        stagePromise = this.dynamicStagePromise.promise\n-        break\n+        return this.dynamicStagePromise.promise\n       }\n       default: {\n         stage satisfies never\n         throw new InvariantError(`Invalid render stage: ${stage}`)\n       }\n     }\n+  }\n+\n+  waitForStage(stage: NonStaticRenderStage) {\n+    return this.getStagePromise(stage)\n+  }\n+\n+  delayUntilStage<T>(\n+    stage: NonStaticRenderStage,\n+    displayName: string | undefined,\n+    resolvedValue: T\n+  ) {\n+    const ioTriggerPromise = this.getStagePromise(stage)\n \n-    // FIXME: this seems to be the only form that leads to correct API names\n-    // being displayed in React Devtools (in the \"suspended by\" section).\n-    // If we use `promise.then(() => resolvedValue)`, the names are lost.\n-    // It's a bit strange that only one of those works right.\n-    const promise = new Promise<T>((resolve, reject) => {\n-      stagePromise.then(resolve.bind(null, resolvedValue), reject)\n-    })\n+    const promise = makeDevtoolsIOPromiseFromIOTrigger(\n+      ioTriggerPromise,\n+      displayName,\n+      resolvedValue\n+    )\n \n     // Analogously to `makeHangingPromise`, we might reject this promise if the signal is invoked.\n     // (e.g. in the case where we don't want want the render to proceed to the dynamic stage and abort it).\n@@ -88,3 +95,26 @@ export class StagedRenderingController {\n }\n \n function ignoreReject() {}\n+\n+// TODO(restart-on-cache-miss): the layering of `delayUntilStage`,\n+// `makeDevtoolsIOPromiseFromIOTrigger` and and `makeDevtoolsIOAwarePromise`\n+// is confusing, we should clean it up.\n+function makeDevtoolsIOPromiseFromIOTrigger<T>(\n+  ioTrigger: Promise<any>,\n+  displayName: string | undefined,\n+  resolvedValue: T\n+): Promise<T> {\n+  // If we create a `new Promise` and give it a displayName\n+  // (with no userspace code above us in the stack)\n+  // React Devtools will use it as the IO cause when determining \"suspended by\".\n+  // In particular, it should shadow any inner IO that resolved/rejected the promise\n+  // (in case of staged rendering, this will be the `setTimeout` that triggers the relevant stage)\n+  const promise = new Promise<T>((resolve, reject) => {\n+    ioTrigger.then(resolve.bind(null, resolvedValue), reject)\n+  })\n+  if (displayName !== undefined) {\n+    // @ts-expect-error\n+    promise.displayName = displayName\n+  }\n+  return promise\n+}"
        },
        {
            "sha": "679dc6766fbe48a5bf4eb36039b4fd83b088d4b9",
            "filename": "packages/next/src/server/app-render/work-unit-async-storage.external.ts",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/vercel/next.js/blob/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fapp-render%2Fwork-unit-async-storage.external.ts?ref=553f2b6bad9ce1b73749dba8a370842ca61f5da0",
            "patch": "@@ -70,10 +70,22 @@ export interface RequestStore extends CommonWorkUnitStore {\n   usedDynamic?: boolean\n   devFallbackParams?: OpaqueFallbackRouteParams | null\n   stagedRendering?: StagedRenderingController | null\n+  asyncApiPromises?: DevAsyncApiPromises\n   cacheSignal?: CacheSignal | null\n   prerenderResumeDataCache?: PrerenderResumeDataCache | null\n }\n \n+type DevAsyncApiPromises = {\n+  cookies: Promise<ReadonlyRequestCookies>\n+  mutableCookies: Promise<ReadonlyRequestCookies>\n+  headers: Promise<ReadonlyHeaders>\n+\n+  sharedParamsParent: Promise<string>\n+  sharedSearchParamsParent: Promise<string>\n+\n+  connection: Promise<undefined>\n+}\n+\n /**\n  * The Prerender store is for tracking information related to prerenders.\n  *"
        },
        {
            "sha": "f6295a61547d6c20c28a57ccff33829c63271be5",
            "filename": "packages/next/src/server/dynamic-rendering-utils.ts",
            "status": "modified",
            "additions": 5,
            "deletions": 1,
            "changes": 6,
            "blob_url": "https://github.com/vercel/next.js/blob/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Fdynamic-rendering-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Fdynamic-rendering-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Fdynamic-rendering-utils.ts?ref=553f2b6bad9ce1b73749dba8a370842ca61f5da0",
            "patch": "@@ -83,7 +83,11 @@ export function makeDevtoolsIOAwarePromise<T>(\n ): Promise<T> {\n   if (requestStore.stagedRendering) {\n     // We resolve each stage in a timeout, so React DevTools will pick this up as IO.\n-    return requestStore.stagedRendering.delayUntilStage(stage, underlying)\n+    return requestStore.stagedRendering.delayUntilStage(\n+      stage,\n+      undefined,\n+      underlying\n+    )\n   }\n   // in React DevTools if we resolve in a setTimeout we will observe\n   // the promise resolution as something that can suspend a boundary or root."
        },
        {
            "sha": "d596d7c7e17162947c94688a90c72dff1efdda8a",
            "filename": "packages/next/src/server/lib/patch-fetch.ts",
            "status": "modified",
            "additions": 10,
            "deletions": 15,
            "changes": 25,
            "blob_url": "https://github.com/vercel/next.js/blob/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Flib%2Fpatch-fetch.ts?ref=553f2b6bad9ce1b73749dba8a370842ca61f5da0",
            "patch": "@@ -562,9 +562,8 @@ export function createPatchedFetcher(\n                   cacheSignal.endRead()\n                   cacheSignal = null\n                 }\n-                await workUnitStore.stagedRendering.delayUntilStage(\n-                  RenderStage.Dynamic,\n-                  undefined\n+                await workUnitStore.stagedRendering.waitForStage(\n+                  RenderStage.Dynamic\n                 )\n               }\n               break\n@@ -689,9 +688,8 @@ export function createPatchedFetcher(\n                       cacheSignal.endRead()\n                       cacheSignal = null\n                     }\n-                    await workUnitStore.stagedRendering.delayUntilStage(\n-                      RenderStage.Dynamic,\n-                      undefined\n+                    await workUnitStore.stagedRendering.waitForStage(\n+                      RenderStage.Dynamic\n                     )\n                   }\n                   break\n@@ -962,9 +960,8 @@ export function createPatchedFetcher(\n                     process.env.NODE_ENV === 'development' &&\n                     workUnitStore.stagedRendering\n                   ) {\n-                    await workUnitStore.stagedRendering.delayUntilStage(\n-                      RenderStage.Dynamic,\n-                      undefined\n+                    await workUnitStore.stagedRendering.waitForStage(\n+                      RenderStage.Dynamic\n                     )\n                   }\n                   break\n@@ -1091,9 +1088,8 @@ export function createPatchedFetcher(\n                       cacheSignal.endRead()\n                       cacheSignal = null\n                     }\n-                    await workUnitStore.stagedRendering.delayUntilStage(\n-                      RenderStage.Dynamic,\n-                      undefined\n+                    await workUnitStore.stagedRendering.waitForStage(\n+                      RenderStage.Dynamic\n                     )\n                   }\n                   break\n@@ -1138,9 +1134,8 @@ export function createPatchedFetcher(\n                       process.env.NODE_ENV === 'development' &&\n                       workUnitStore.stagedRendering\n                     ) {\n-                      await workUnitStore.stagedRendering.delayUntilStage(\n-                        RenderStage.Dynamic,\n-                        undefined\n+                      await workUnitStore.stagedRendering.waitForStage(\n+                        RenderStage.Dynamic\n                       )\n                     }\n                     break"
        },
        {
            "sha": "4da34e8e2b5b6b3b6a42a7f225749dd2949565a9",
            "filename": "packages/next/src/server/request/connection.ts",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/vercel/next.js/blob/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fconnection.ts?ref=553f2b6bad9ce1b73749dba8a370842ca61f5da0",
            "patch": "@@ -106,6 +106,9 @@ export function connection(): Promise<void> {\n             // Semantically we only need the dev tracking when running in `next dev`\n             // but since you would never use next dev with production NODE_ENV we use this\n             // as a proxy so we can statically exclude this code from production builds.\n+            if (workUnitStore.asyncApiPromises) {\n+              return workUnitStore.asyncApiPromises.connection\n+            }\n             return makeDevtoolsIOAwarePromise(\n               undefined,\n               workUnitStore,"
        },
        {
            "sha": "9dc8227a5a162f170702d360e927aa6065874931",
            "filename": "packages/next/src/server/request/cookies.ts",
            "status": "modified",
            "additions": 80,
            "deletions": 27,
            "changes": 107,
            "blob_url": "https://github.com/vercel/next.js/blob/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fcookies.ts?ref=553f2b6bad9ce1b73749dba8a370842ca61f5da0",
            "patch": "@@ -28,7 +28,6 @@ import {\n import { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\n import { isRequestAPICallableInsideAfter } from './utils'\n import { InvariantError } from '../../shared/lib/invariant-error'\n-import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n import { RenderStage } from '../app-render/staged-rendering'\n \n export function cookies(): Promise<ReadonlyRequestCookies> {\n@@ -190,6 +189,20 @@ function makeUntrackedCookiesWithDevWarnings(\n   underlyingCookies: ReadonlyRequestCookies,\n   route?: string\n ): Promise<ReadonlyRequestCookies> {\n+  if (requestStore.asyncApiPromises) {\n+    let promise: Promise<ReadonlyRequestCookies>\n+    if (underlyingCookies === requestStore.mutableCookies) {\n+      promise = requestStore.asyncApiPromises.mutableCookies\n+    } else if (underlyingCookies === requestStore.cookies) {\n+      promise = requestStore.asyncApiPromises.cookies\n+    } else {\n+      throw new InvariantError(\n+        'Received an underlying cookies object that does not match either `cookies` or `mutableCookies`'\n+      )\n+    }\n+    return instrumentCookiesPromiseWithDevWarnings(promise, route)\n+  }\n+\n   const cachedCookies = CachedCookies.get(underlyingCookies)\n   if (cachedCookies) {\n     return cachedCookies\n@@ -201,32 +214,7 @@ function makeUntrackedCookiesWithDevWarnings(\n     RenderStage.Runtime\n   )\n \n-  const proxiedPromise = new Proxy(promise, {\n-    get(target, prop, receiver) {\n-      switch (prop) {\n-        case Symbol.iterator: {\n-          warnForSyncAccess(route, '`...cookies()` or similar iteration')\n-          break\n-        }\n-        case 'size':\n-        case 'get':\n-        case 'getAll':\n-        case 'has':\n-        case 'set':\n-        case 'delete':\n-        case 'clear':\n-        case 'toString': {\n-          warnForSyncAccess(route, `\\`cookies().${prop}\\``)\n-          break\n-        }\n-        default: {\n-          // We only warn for well-defined properties of the cookies object.\n-        }\n-      }\n-\n-      return ReflectAdapter.get(target, prop, receiver)\n-    },\n-  })\n+  const proxiedPromise = instrumentCookiesPromiseWithDevWarnings(promise, route)\n \n   CachedCookies.set(underlyingCookies, proxiedPromise)\n \n@@ -237,6 +225,71 @@ const warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n   createCookiesAccessError\n )\n \n+function instrumentCookiesPromiseWithDevWarnings(\n+  promise: Promise<ReadonlyRequestCookies>,\n+  route: string | undefined\n+) {\n+  Object.defineProperties(promise, {\n+    [Symbol.iterator]: replaceableWarningDescriptorForSymbolIterator(\n+      promise,\n+      route\n+    ),\n+    size: replaceableWarningDescriptor(promise, 'size', route),\n+    get: replaceableWarningDescriptor(promise, 'get', route),\n+    getAll: replaceableWarningDescriptor(promise, 'getAll', route),\n+    has: replaceableWarningDescriptor(promise, 'has', route),\n+    set: replaceableWarningDescriptor(promise, 'set', route),\n+    delete: replaceableWarningDescriptor(promise, 'delete', route),\n+    clear: replaceableWarningDescriptor(promise, 'clear', route),\n+    toString: replaceableWarningDescriptor(promise, 'toString', route),\n+  })\n+  return promise\n+}\n+\n+function replaceableWarningDescriptor(\n+  target: unknown,\n+  prop: string,\n+  route: string | undefined\n+) {\n+  return {\n+    enumerable: false,\n+    get() {\n+      warnForSyncAccess(route, `\\`cookies().${prop}\\``)\n+      return undefined\n+    },\n+    set(value: unknown) {\n+      Object.defineProperty(target, prop, {\n+        value,\n+        writable: true,\n+        configurable: true,\n+      })\n+    },\n+    configurable: true,\n+  }\n+}\n+\n+function replaceableWarningDescriptorForSymbolIterator(\n+  target: unknown,\n+  route: string | undefined\n+) {\n+  return {\n+    enumerable: false,\n+    get() {\n+      warnForSyncAccess(route, '`...cookies()` or similar iteration')\n+      return undefined\n+    },\n+    set(value: unknown) {\n+      Object.defineProperty(target, Symbol.iterator, {\n+        value,\n+        writable: true,\n+        enumerable: true,\n+        configurable: true,\n+      })\n+    },\n+    configurable: true,\n+  }\n+}\n+\n function createCookiesAccessError(\n   route: string | undefined,\n   expression: string"
        },
        {
            "sha": "fcc21925df1bd0f047cc7731242a87c036c54e6d",
            "filename": "packages/next/src/server/request/headers.ts",
            "status": "modified",
            "additions": 73,
            "deletions": 29,
            "changes": 102,
            "blob_url": "https://github.com/vercel/next.js/blob/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fheaders.ts?ref=553f2b6bad9ce1b73749dba8a370842ca61f5da0",
            "patch": "@@ -26,7 +26,6 @@ import {\n import { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\n import { isRequestAPICallableInsideAfter } from './utils'\n import { InvariantError } from '../../shared/lib/invariant-error'\n-import { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\n import { RenderStage } from '../app-render/staged-rendering'\n \n /**\n@@ -199,6 +198,11 @@ function makeUntrackedHeadersWithDevWarnings(\n   route: string | undefined,\n   requestStore: RequestStore\n ): Promise<ReadonlyHeaders> {\n+  if (requestStore.asyncApiPromises) {\n+    const promise = requestStore.asyncApiPromises.headers\n+    return instrumentHeadersPromiseWithDevWarnings(promise, route)\n+  }\n+\n   const cachedHeaders = CachedHeaders.get(underlyingHeaders)\n   if (cachedHeaders) {\n     return cachedHeaders\n@@ -210,34 +214,7 @@ function makeUntrackedHeadersWithDevWarnings(\n     RenderStage.Runtime\n   )\n \n-  const proxiedPromise = new Proxy(promise, {\n-    get(target, prop, receiver) {\n-      switch (prop) {\n-        case Symbol.iterator: {\n-          warnForSyncAccess(route, '`...headers()` or similar iteration')\n-          break\n-        }\n-        case 'append':\n-        case 'delete':\n-        case 'get':\n-        case 'has':\n-        case 'set':\n-        case 'getSetCookie':\n-        case 'forEach':\n-        case 'keys':\n-        case 'values':\n-        case 'entries': {\n-          warnForSyncAccess(route, `\\`headers().${prop}\\``)\n-          break\n-        }\n-        default: {\n-          // We only warn for well-defined properties of the headers object.\n-        }\n-      }\n-\n-      return ReflectAdapter.get(target, prop, receiver)\n-    },\n-  })\n+  const proxiedPromise = instrumentHeadersPromiseWithDevWarnings(promise, route)\n \n   CachedHeaders.set(underlyingHeaders, proxiedPromise)\n \n@@ -248,6 +225,73 @@ const warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n   createHeadersAccessError\n )\n \n+function instrumentHeadersPromiseWithDevWarnings(\n+  promise: Promise<ReadonlyHeaders>,\n+  route: string | undefined\n+) {\n+  Object.defineProperties(promise, {\n+    [Symbol.iterator]: replaceableWarningDescriptorForSymbolIterator(\n+      promise,\n+      route\n+    ),\n+    append: replaceableWarningDescriptor(promise, 'append', route),\n+    delete: replaceableWarningDescriptor(promise, 'delete', route),\n+    get: replaceableWarningDescriptor(promise, 'get', route),\n+    has: replaceableWarningDescriptor(promise, 'has', route),\n+    set: replaceableWarningDescriptor(promise, 'set', route),\n+    getSetCookie: replaceableWarningDescriptor(promise, 'getSetCookie', route),\n+    forEach: replaceableWarningDescriptor(promise, 'forEach', route),\n+    keys: replaceableWarningDescriptor(promise, 'keys', route),\n+    values: replaceableWarningDescriptor(promise, 'values', route),\n+    entries: replaceableWarningDescriptor(promise, 'entries', route),\n+  })\n+  return promise\n+}\n+\n+function replaceableWarningDescriptor(\n+  target: unknown,\n+  prop: string,\n+  route: string | undefined\n+) {\n+  return {\n+    enumerable: false,\n+    get() {\n+      warnForSyncAccess(route, `\\`headers().${prop}\\``)\n+      return undefined\n+    },\n+    set(value: unknown) {\n+      Object.defineProperty(target, prop, {\n+        value,\n+        writable: true,\n+        configurable: true,\n+      })\n+    },\n+    configurable: true,\n+  }\n+}\n+\n+function replaceableWarningDescriptorForSymbolIterator(\n+  target: unknown,\n+  route: string | undefined\n+) {\n+  return {\n+    enumerable: false,\n+    get() {\n+      warnForSyncAccess(route, '`...headers()` or similar iteration')\n+      return undefined\n+    },\n+    set(value: unknown) {\n+      Object.defineProperty(target, Symbol.iterator, {\n+        value,\n+        writable: true,\n+        enumerable: true,\n+        configurable: true,\n+      })\n+    },\n+    configurable: true,\n+  }\n+}\n+\n function createHeadersAccessError(\n   route: string | undefined,\n   expression: string"
        },
        {
            "sha": "aa1baf60457362854c1689846406c766b201446d",
            "filename": "packages/next/src/server/request/params.ts",
            "status": "modified",
            "additions": 32,
            "deletions": 4,
            "changes": 36,
            "blob_url": "https://github.com/vercel/next.js/blob/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fparams.ts?ref=553f2b6bad9ce1b73749dba8a370842ca61f5da0",
            "patch": "@@ -455,6 +455,23 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n   workStore: WorkStore,\n   requestStore: RequestStore\n ): Promise<Params> {\n+  if (requestStore.asyncApiPromises && hasFallbackParams) {\n+    // Deliberately don't wrap each instance of params in a `new Promise()`.\n+    // We want React Devtools to consider all the separate `params` promises\n+    // that we create for each segment to be triggered by one IO operation --\n+    // the resolving of the underlying `sharedParamsParent` promise.\n+    // It's created above any userspace code and has a `displayName`,\n+    // so it should show up in \"suspended by\".\n+    const promise = requestStore.asyncApiPromises.sharedParamsParent.then(\n+      () => underlyingParams\n+    )\n+    return instrumentParamsPromiseWithDevWarnings(\n+      underlyingParams,\n+      promise,\n+      workStore\n+    )\n+  }\n+\n   const cachedParams = CachedParams.get(underlyingParams)\n   if (cachedParams) {\n     return cachedParams\n@@ -472,6 +489,20 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n     : // We don't want to force an environment transition when this params is not part of the fallback params set\n       Promise.resolve(underlyingParams)\n \n+  const proxiedPromise = instrumentParamsPromiseWithDevWarnings(\n+    underlyingParams,\n+    promise,\n+    workStore\n+  )\n+  CachedParams.set(underlyingParams, proxiedPromise)\n+  return proxiedPromise\n+}\n+\n+function instrumentParamsPromiseWithDevWarnings(\n+  underlyingParams: Params,\n+  promise: Promise<Params>,\n+  workStore: WorkStore\n+): Promise<Params> {\n   // Track which properties we should warn for.\n   const proxiedProperties = new Set<string>()\n \n@@ -484,7 +515,7 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n     }\n   })\n \n-  const proxiedPromise = new Proxy(promise, {\n+  return new Proxy(promise, {\n     get(target, prop, receiver) {\n       if (typeof prop === 'string') {\n         if (\n@@ -509,9 +540,6 @@ function makeDynamicallyTrackedParamsWithDevWarnings(\n       return Reflect.ownKeys(target)\n     },\n   })\n-\n-  CachedParams.set(underlyingParams, proxiedPromise)\n-  return proxiedPromise\n }\n \n const warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev("
        },
        {
            "sha": "eed2cc9e76d43bf651a24dabf97b69c48ef56347",
            "filename": "packages/next/src/server/request/search-params.ts",
            "status": "modified",
            "additions": 90,
            "deletions": 27,
            "changes": 117,
            "blob_url": "https://github.com/vercel/next.js/blob/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fserver%2Frequest%2Fsearch-params.ts?ref=553f2b6bad9ce1b73749dba8a370842ca61f5da0",
            "patch": "@@ -386,28 +386,97 @@ function makeUntrackedSearchParamsWithDevWarnings(\n   workStore: WorkStore,\n   requestStore: RequestStore\n ): Promise<SearchParams> {\n-  // Note: unlike some of the other functions here, we tie the lifetime of the cached search params\n-  // to the request store, not `underlyingSearchParams`.\n-  // If we didn't do that we'd end up re-using the same object across both renders in the restart-on-cache-miss flow,\n-  // meaning that the `searchParams` promise would (incorrectly) be already resolved in the restarted render.\n-  const cachedSearchParams = CachedSearchParams.get(requestStore)\n-  if (cachedSearchParams) {\n-    return cachedSearchParams\n+  if (requestStore.asyncApiPromises) {\n+    // Do not cache the resulting promise. If we do, we'll only show the first \"awaited at\"\n+    // across all segments that receive searchParams.\n+    return makeUntrackedSearchParamsWithDevWarningsImpl(\n+      underlyingSearchParams,\n+      workStore,\n+      requestStore\n+    )\n+  } else {\n+    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n+    if (cachedSearchParams) {\n+      return cachedSearchParams\n+    }\n+    const promise = makeUntrackedSearchParamsWithDevWarningsImpl(\n+      underlyingSearchParams,\n+      workStore,\n+      requestStore\n+    )\n+    CachedSearchParams.set(requestStore, promise)\n+    return promise\n   }\n+}\n \n-  // Track which properties we should warn for.\n-  const proxiedProperties = new Set<string>()\n+function makeUntrackedSearchParamsWithDevWarningsImpl(\n+  underlyingSearchParams: SearchParams,\n+  workStore: WorkStore,\n+  requestStore: RequestStore\n+): Promise<SearchParams> {\n+  const promiseInitialized = { current: false }\n+  const proxiedUnderlying = instrumentSearchParamsObjectWithDevWarnings(\n+    underlyingSearchParams,\n+    workStore,\n+    promiseInitialized\n+  )\n \n+  let promise: Promise<SearchParams>\n+  if (requestStore.asyncApiPromises) {\n+    // Deliberately don't wrap each instance of params in a `new Promise()`.\n+    // We want React Devtools to consider all the separate `searchParams` promises\n+    // that we create for each segment to be triggered by one IO operation --\n+    // the resolving of the underlying `sharedParamsParent` promise.\n+    // It's created above any userspace code and has a `displayName`,\n+    // so it should show up in \"suspended by\".\n+    promise = requestStore.asyncApiPromises.sharedSearchParamsParent.then(\n+      () => proxiedUnderlying\n+    )\n+  } else {\n+    promise = makeDevtoolsIOAwarePromise(\n+      proxiedUnderlying,\n+      requestStore,\n+      RenderStage.Runtime\n+    )\n+  }\n+  promise.then(\n+    () => {\n+      promiseInitialized.current = true\n+    },\n+    // If we're in staged rendering, this promise will reject if the render\n+    // is aborted before it can reach the runtime stage.\n+    // In that case, we have to prevent an unhandled rejection from the promise\n+    // created by this `.then()` call.\n+    // This does not affect the `promiseInitialized` logic above,\n+    // because `proxiedUnderlying` will not be used to resolve the promise,\n+    // so there's no risk of any of its properties being accessed and triggering\n+    // an undesireable warning.\n+    ignoreReject\n+  )\n+\n+  return instrumentSearchParamsPromiseWithDevWarnings(\n+    underlyingSearchParams,\n+    promise,\n+    workStore\n+  )\n+}\n+\n+function ignoreReject() {}\n+\n+function instrumentSearchParamsObjectWithDevWarnings(\n+  underlyingSearchParams: SearchParams,\n+  workStore: WorkStore,\n+  promiseInitialized: { current: boolean }\n+) {\n   // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n   // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n   // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n   // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n   // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n   // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n-  let promiseInitialized = false\n-  const proxiedUnderlying = new Proxy(underlyingSearchParams, {\n+  return new Proxy(underlyingSearchParams, {\n     get(target, prop, receiver) {\n-      if (typeof prop === 'string' && promiseInitialized) {\n+      if (typeof prop === 'string' && promiseInitialized.current) {\n         if (workStore.dynamicShouldError) {\n           const expression = describeStringPropertyAccess('searchParams', prop)\n           throwWithStaticGenerationBailoutErrorWithDynamicError(\n@@ -445,18 +514,15 @@ function makeUntrackedSearchParamsWithDevWarnings(\n       return Reflect.ownKeys(target)\n     },\n   })\n+}\n \n-  // We don't use makeResolvedReactPromise here because searchParams\n-  // supports copying with spread and we don't want to unnecessarily\n-  // instrument the promise with spreadable properties of ReactPromise.\n-  const promise = makeDevtoolsIOAwarePromise(\n-    proxiedUnderlying,\n-    requestStore,\n-    RenderStage.Runtime\n-  )\n-  promise.then(() => {\n-    promiseInitialized = true\n-  })\n+function instrumentSearchParamsPromiseWithDevWarnings(\n+  underlyingSearchParams: SearchParams,\n+  promise: Promise<SearchParams>,\n+  workStore: WorkStore\n+) {\n+  // Track which properties we should warn for.\n+  const proxiedProperties = new Set<string>()\n \n   Object.keys(underlyingSearchParams).forEach((prop) => {\n     if (wellKnownProperties.has(prop)) {\n@@ -467,7 +533,7 @@ function makeUntrackedSearchParamsWithDevWarnings(\n     }\n   })\n \n-  const proxiedPromise = new Proxy(promise, {\n+  return new Proxy(promise, {\n     get(target, prop, receiver) {\n       if (prop === 'then' && workStore.dynamicShouldError) {\n         const expression = '`searchParams.then`'\n@@ -520,9 +586,6 @@ function makeUntrackedSearchParamsWithDevWarnings(\n       return Reflect.ownKeys(target)\n     },\n   })\n-\n-  CachedSearchParams.set(requestStore, proxiedPromise)\n-  return proxiedPromise\n }\n \n const warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev("
        },
        {
            "sha": "ea6e5cccc95becbb114f5ff9bcca6c760be0f0bc",
            "filename": "packages/next/src/shared/lib/utils/reflect-utils.ts",
            "status": "modified",
            "additions": 2,
            "deletions": 3,
            "changes": 5,
            "blob_url": "https://github.com/vercel/next.js/blob/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Futils%2Freflect-utils.ts",
            "raw_url": "https://github.com/vercel/next.js/raw/553f2b6bad9ce1b73749dba8a370842ca61f5da0/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Futils%2Freflect-utils.ts",
            "contents_url": "https://api.github.com/repos/vercel/next.js/contents/packages%2Fnext%2Fsrc%2Fshared%2Flib%2Futils%2Freflect-utils.ts?ref=553f2b6bad9ce1b73749dba8a370842ca61f5da0",
            "patch": "@@ -29,21 +29,20 @@ export const wellKnownProperties = new Set([\n   'toLocaleString',\n \n   // Promise prototype\n-  // fallthrough\n   'then',\n   'catch',\n   'finally',\n \n   // React Promise extension\n-  // fallthrough\n   'status',\n+  // 'value',\n+  // 'error',\n \n   // React introspection\n   'displayName',\n   '_debugInfo',\n \n   // Common tested properties\n-  // fallthrough\n   'toJSON',\n   '$$typeof',\n   '__esModule',"
        }
    ],
    "stats": {
        "total": 526,
        "additions": 406,
        "deletions": 120
    }
}